# Copyright (c) 2014, the Dart project authors.  Please see the AUTHORS file
# for details. All rights reserved. Use of this source code is governed by a
# BSD-style license that can be found in the LICENSE file.

import("../sdk_args.gni")
import("configs.gni")
import("runtime_args.gni")

if (is_fuchsia) {
  import("//build/fuchsia/sdk.gni")
}

config("dart_public_config") {
  include_dirs = [
    ".",
    "include",
  ]
}

# Adds PRODUCT define if Flutter has specified "release" for dart_runtime_mode
config("dart_maybe_product_config") {
  defines = []

  if (dart_runtime_mode != "develop" && dart_runtime_mode != "profile" &&
      dart_runtime_mode != "release") {
    print("Invalid |dart_runtime_mode|")
    assert(false)
  }

  if (dart_runtime_mode == "release") {
    if (dart_debug) {
      print("Debug and release mode are mutually exclusive.")
    }
    assert(!dart_debug)
    defines += [ "PRODUCT" ]
  }
}

# This is a config to use to build PRODUCT mode artifacts in a RELEASE build.
# If a DEBUG build has been specified it will be ignored.
config("dart_product_config") {
  defines = []
  cflags = []
  if (!dart_debug) {
    defines += [ "PRODUCT" ]
    if (is_posix) {
      cflags = [
        # This is the equivalent from `build/config/BUILDCONFIG.gn` which includes
        # `build/config/gcc:symbol_visibility_hidden` in product mode.
        "-fvisibility=hidden",
      ]
    }
  }
}

config("dart_precompiled_runtime_config") {
  defines = []
  defines += [
    "DART_PRECOMPILED_RUNTIME",
    "EXCLUDE_CFE_AND_KERNEL_PLATFORM",
  ]
}

# Controls DART_PRECOMPILER #define.
config("dart_precompiler_config") {
  defines = []
  defines += [ "DART_PRECOMPILER" ]
}

config("dart_os_config") {
  defines = []

  if (target_os == "android") {
    defines += [ "TARGET_OS_ANDROID" ]
  } else if (target_os == "fuchsia") {
    defines += [ "TARGET_OS_FUCHSIA" ]
  } else if (target_os == "ios") {
    defines += [ "TARGET_OS_MACOS" ]
    defines += [ "TARGET_OS_MACOS_IOS" ]
  } else if (target_os == "linux") {
    defines += [ "TARGET_OS_LINUX" ]
  } else if (target_os == "mac") {
    defines += [ "TARGET_OS_MACOS" ]
  } else if (target_os == "win") {
    defines += [ "TARGET_OS_WINDOWS" ]
  } else if (target_os == "winuwp") {
    defines += [
      "TARGET_OS_WINDOWS",
      "TARGET_OS_WINDOWS_UWP",
    ]
  } else {
    print("Unknown target_os: $target_os")
    assert(false)
  }
}

# We need to build gen_snapshot targeting Fuchsia during a build of the SDK
# targeting Mac and Linux. This configuration is used to unconditionally target
# Fuchsia. It should not be combined with dart_os_config.
config("dart_os_fuchsia_config") {
  defines = [ "TARGET_OS_FUCHSIA" ]
}

config("dart_arch_config") {
  defines = []

  if (dart_target_arch == "arm") {
    defines += [ "TARGET_ARCH_ARM" ]
  } else if (dart_target_arch == "arm64") {
    defines += [ "TARGET_ARCH_ARM64" ]
  } else if (dart_target_arch == "x64") {
    defines += [ "TARGET_ARCH_X64" ]
  } else if (dart_target_arch == "ia32" || dart_target_arch == "x86") {
    defines += [ "TARGET_ARCH_IA32" ]
  } else {
    print("Invalid dart_target_arch: $dart_target_arch")
    assert(false)
  }
}

config("dart_config") {
  defines = []

  if (dart_debug) {
    defines += [ "DEBUG" ]
  } else {
    defines += [ "NDEBUG" ]
  }

  include_dirs = [ "include" ]
  if (dart_use_tcmalloc) {
    defines += [ "DART_USE_TCMALLOC" ]
    include_dirs += [ "../third_party/tcmalloc/gperftools/src" ]
  }

  if (is_fuchsia) {
    if (using_fuchsia_gn_sdk) {
      lib_dirs = [ root_out_dir + "/lib" ]
    }
    if (using_fuchsia_gn_sdk || using_fuchsia_sdk) {
      # TODO(chinmaygarde): Currenty these targets need to be build in the
      # Fuchsia tree as well as outside it using the SDK. However, not all
      # Fuchsia features are available in the SDK. As these features are added,
      # the guards can be removed. Eventually, only SDK builds will be present.
      # Then, this flag can be removed completely.
      defines += [ "FUCHSIA_SDK" ]
    } else {
      include_dirs += [ "//zircon/system/ulib/zx/include" ]
    }
  }

  if (!is_win) {
    cflags = [
      "-Werror",
      "-Wall",
      "-Wextra",  # Also known as -W.
      "-Wno-unused-parameter",
      "-Wno-unused-private-field",
      "-Wnon-virtual-dtor",
      "-Wvla",
      "-Woverloaded-virtual",
      "-Wno-comments",  # Conflicts with clang-format.
      "-g3",
      "-ggdb3",
      "-fno-rtti",
      "-fno-exceptions",
    ]
    if (is_clang) {
      cflags += [ "-Wimplicit-fallthrough" ]
    } else {
      cflags += [ "-Wno-cast-function-type" ]
    }

    ldflags = []
    if (is_clang && dart_vm_code_coverage) {
      cflags += [
        "-O0",
        "-fprofile-arcs",
        "-ftest-coverage",
      ]
      ldflags += [ "--coverage" ]
    } else if (dart_debug) {
      cflags += [ "-O${dart_debug_optimization_level}" ]
    } else {
      cflags += [ "-O3" ]
    }

    if (is_fuchsia) {
      # safe-stack does not work with the interpreter.
      cflags += [ "-fno-sanitize=safe-stack" ]
    }
  }
}

config("dart_shared_lib") {
  if (dart_lib_export_symbols) {
    defines = [ "DART_SHARED_LIB" ]
  }
}

config("dart_libfuzzer_config") {
  defines = [ "FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION" ]
  cflags = [ "-fsanitize=address,fuzzer-no-link" ]
  ldflags = [ "-fsanitize=address,fuzzer" ]
}

source_set("dart_api") {
  public_configs = [ ":dart_public_config" ]
  sources = [
    "include/dart_api.h",
    "include/dart_api_dl.c",
    "include/dart_api_dl.h",
    "include/dart_native_api.h",
    "include/dart_tools_api.h",
    "include/dart_version.h",
    "include/internal/dart_api_dl_impl.h",
  ]
}

library_for_all_configs("libdart") {
  target_type = dart_component_kind
  extra_deps = [
    ":generate_version_cc_file",
    "third_party/double-conversion/src:libdouble_conversion",
  ]
  if (is_fuchsia) {
    if (using_fuchsia_gn_sdk) {
      extra_deps += [
        "$fuchsia_sdk_root/build/config:runtime_library_group",
        "$fuchsia_sdk_root/pkg/fdio",
        "$fuchsia_sdk_root/pkg/trace-engine",
        "//build/fuchsia/config/clang:c++-runtime-deps",
      ]
    } else if (using_fuchsia_sdk) {
      extra_deps += [
        "$fuchsia_sdk_root/pkg:fdio",
        "$fuchsia_sdk_root/pkg:trace-engine",
      ]
    } else {
      extra_deps += [
        "//zircon/public/lib/fbl",
        "//zircon/system/ulib/trace-engine",
      ]
    }
  }
  configurable_deps = [
    "platform:libdart_platform",
    "vm:libdart_lib",
    "vm:libdart_vm",
  ]
  compiler_lib = "vm:libdart_compiler"
  extra_configs = [ ":dart_shared_lib" ]
  include_dirs = [ "." ]
  public_configs = [ ":dart_public_config" ]
  sources = [
    "$target_gen_dir/version.cc",
    "include/dart_api.h",
    "include/dart_native_api.h",
    "include/dart_tools_api.h",
    "vm/dart_api_impl.cc",
    "vm/native_api_impl.cc",
    "vm/version.h",
  ]
}

action("generate_version_cc_file") {
  inputs = [
    "../tools/utils.py",
    "../tools/VERSION",
    "vm/version_in.cc",
  ]
  if (dart_version_git_info) {
    inputs += [ "$default_git_folder/logs/HEAD" ]
  }
  output = "$target_gen_dir/version.cc"
  outputs = [ output ]

  script = "../tools/make_version.py"
  args = [
    "--quiet",
    "--output",
    rebase_path(output, root_build_dir),
    "--input",
    rebase_path("vm/version_in.cc", root_build_dir),
  ]
  if (!dart_version_git_info) {
    args += [ "--no_git_hash" ]
  }
  if (!verify_sdk_hash) {
    args += [ "--no_sdk_hash" ]
  }
}
