# Copyright (c) 2014, the Dart project authors.  Please see the AUTHORS file
# for details. All rights reserved. Use of this source code is governed by a
# BSD-style license that can be found in the LICENSE file.

import("../../build/config/gclient_args.gni")
import("../../build/dart/dart_action.gni")
import("../../sdk_args.gni")
import("../runtime_args.gni")
import("../vm/compiler/compiler_sources.gni")
import("../vm/heap/heap_sources.gni")
import("../vm/vm_sources.gni")
import("builtin_impl_sources.gni")
import("builtin_sources.gni")
import("cli_impl_sources.gni")
import("cli_sources.gni")
import("io_impl_sources.gni")
import("io_sources.gni")

if (is_fuchsia) {
  import("//build/fuchsia/sdk.gni")
}

config("libdart_builtin_config") {
  if (!is_win) {
    libs = [ "dl" ]
  }
  if (is_android) {
    libs += [
      "android",
      "log",
    ]
  }
}

template("build_libdart_builtin") {
  extra_configs = []
  if (defined(invoker.extra_configs)) {
    extra_configs += invoker.extra_configs
  }
  source_set(target_name) {
    configs += [ "..:dart_config" ] + extra_configs
    public_configs = [ ":libdart_builtin_config" ]
    deps = []
    if (is_fuchsia) {
      if (using_fuchsia_gn_sdk) {
        public_deps = [ "$fuchsia_sdk_root/pkg/fdio" ]
      } else if (using_fuchsia_sdk) {
        public_deps = [ "$fuchsia_sdk_root/pkg:fdio" ]
      } else {
        public_deps = [ "//sdk/lib/fdio" ]
      }
    }
    include_dirs = [ ".." ]
    set_sources_assignment_filter([
                                    "*_test.cc",
                                    "*_test.h",
                                  ])
    sources = builtin_impl_sources
  }
}

build_libdart_builtin("libdart_builtin") {
  extra_configs = [
    "..:dart_maybe_product_config",
    "..:dart_os_config",
    "..:dart_arch_config",
  ]
}

build_libdart_builtin("libdart_builtin_product") {
  extra_configs = [
    "..:dart_product_config",
    "..:dart_os_config",
    "..:dart_arch_config",
  ]
}

build_libdart_builtin("libdart_builtin_fuchsia") {
  extra_configs = [
    "..:dart_maybe_product_config",
    "..:dart_os_fuchsia_config",
  ]
}

build_libdart_builtin("libdart_builtin_product_fuchsia") {
  extra_configs = [
    "..:dart_product_config",
    "..:dart_os_fuchsia_config",
  ]
}

build_libdart_builtin("libdart_builtin_host_targeting_host") {
  extra_configs = [ "..:dart_maybe_product_config" ]
}

build_libdart_builtin("libdart_builtin_product_host_targeting_host") {
  extra_configs = [ "..:dart_product_config" ]
}

static_library("crashpad") {
  configs += [
    "..:dart_arch_config",
    "..:dart_config",
    "..:dart_product_config",
    "..:dart_os_fuchsia_config",
  ]
  include_dirs = [ ".." ]
  sources = [ "crashpad.cc" ]

  if (dart_use_crashpad) {
    assert(is_win, "dart_use_crashpad is only supported on Windows")
    deps = [
      "//third_party/crashpad/crashpad/client",
      "//third_party/mini_chromium/mini_chromium/base",

      # This binary is used to handle crashes of the dart binary.
      "//third_party/crashpad/crashpad/handler:crashpad_handler",
    ]
    include_dirs += [ "//third_party/crashpad" ]
    defines = [ "DART_USE_CRASHPAD" ]
  }
}

template("build_elf_loader") {
  source_set(target_name) {
    configs += [
      "..:dart_arch_config",
      "..:dart_config",
      "..:dart_product_config",
      "..:dart_os_fuchsia_config",
    ]
    include_dirs = [ ".." ]
    sources = [
      "elf_loader.cc",
      "elf_loader.h",
    ]
    deps = invoker.deps
  }
}

build_elf_loader("elf_loader") {
  deps = [ ":libdart_builtin" ]
}

build_elf_loader("elf_loader_product") {
  deps = [ ":libdart_builtin_product" ]
}

template("build_gen_snapshot") {
  extra_configs = []
  if (defined(invoker.extra_configs)) {
    extra_configs += invoker.extra_configs
  }
  extra_deps = []
  if (defined(invoker.extra_deps)) {
    extra_deps += invoker.extra_deps
  }
  executable(target_name) {
    configs += [
                 "..:dart_config",
                 "..:dart_precompiler_config",
               ] + extra_configs
    deps = extra_deps

    defines = [ "EXCLUDE_CFE_AND_KERNEL_PLATFORM" ]

    sources = [
      "address_sanitizer.cc",
      "builtin.cc",
      "builtin.h",
      "error_exit.cc",
      "error_exit.h",
      "gzip.cc",
      "gzip.h",
      "loader.cc",
      "loader.h",
      "snapshot_utils.cc",
      "snapshot_utils.h",

      # Very limited native resolver provided.
      "builtin_gen_snapshot.cc",
      "dfe.cc",
      "dfe.h",
      "gen_snapshot.cc",
      "options.cc",
      "options.h",
      "vmservice_impl.cc",
      "vmservice_impl.h",
    ]

    include_dirs = [
      "..",
      "//third_party",
    ]

    if (dart_use_tcmalloc) {
      deps += [ "//third_party/tcmalloc" ]
    }

    if (is_mac) {
      frameworks = [
        "CoreFoundation.framework",
        "CoreServices.framework",
      ]
    }

    if (!is_win) {
      # Adds all symbols to the dynamic symbol table, not just used ones.
      # This is needed to make native extensions work. It is also needed to get
      # symbols in VM-generated backtraces and profiles.
      ldflags = [ "-rdynamic" ]
    }

    if (is_win) {
      libs = [
        "iphlpapi.lib",
        "psapi.lib",
        "ws2_32.lib",
        "Rpcrt4.lib",
        "shlwapi.lib",
        "winmm.lib",
      ]
    }
  }
}

build_gen_snapshot("gen_snapshot") {
  extra_configs = [
    "..:dart_maybe_product_config",
    "..:dart_arch_config",
    "..:dart_os_config",
  ]
  extra_deps = [
    ":gen_snapshot_dart_io",
    ":libdart_builtin",
    "..:libdart_precompiler",
    "../platform:libdart_platform_precompiler",
  ]
}

build_gen_snapshot("gen_snapshot_product") {
  extra_configs = [
    "..:dart_product_config",
    "..:dart_arch_config",
    "..:dart_os_config",
  ]
  extra_deps = [
    ":gen_snapshot_dart_io_product",
    ":libdart_builtin_product",
    "..:libdart_precompiler_product",
    "../platform:libdart_platform_precompiler_product",
  ]
}

build_gen_snapshot("gen_snapshot_fuchsia") {
  extra_configs = [
    "..:dart_maybe_product_config",
    "..:dart_arch_config",
    "..:dart_os_fuchsia_config",
  ]
  extra_deps = [
    ":gen_snapshot_dart_io_fuchsia",
    ":libdart_builtin_fuchsia",
    "..:libdart_precompiler_fuchsia",
    "../platform:libdart_platform_precompiler_fuchsia",
  ]
}

build_gen_snapshot("gen_snapshot_product_fuchsia") {
  extra_configs = [
    "..:dart_product_config",
    "..:dart_arch_config",
    "..:dart_os_fuchsia_config",
  ]
  extra_deps = [
    ":gen_snapshot_dart_io_product_fuchsia",
    ":libdart_builtin_product_fuchsia",
    "..:libdart_precompiler_product_fuchsia",
    "../platform:libdart_platform_precompiler_product_fuchsia",
  ]
}

build_gen_snapshot("gen_snapshot_host_targeting_host") {
  extra_configs = [ "..:dart_maybe_product_config" ]
  extra_deps = [
    ":gen_snapshot_dart_io_host_targeting_host",
    ":libdart_builtin_host_targeting_host",
    "..:libdart_precompiler_host_targeting_host",
    "../platform:libdart_platform_precompiler_host_targeting_host",
  ]
}

build_gen_snapshot("gen_snapshot_product_host_targeting_host") {
  extra_configs = [ "..:dart_product_config" ]
  extra_deps = [
    ":gen_snapshot_dart_io_host_targeting_host",
    ":libdart_builtin_host_targeting_host",
    "..:libdart_precompiler_host_targeting_host",
    "../platform:libdart_platform_precompiler_host_targeting_host",
  ]
}

# A source set for the implementation of 'dart:io' library
# (without secure sockets) suitable for linking with gen_snapshot.
template("build_gen_snapshot_dart_io") {
  extra_configs = []
  if (defined(invoker.extra_configs)) {
    extra_configs += invoker.extra_configs
  }
  source_set(target_name) {
    configs += [
                 "..:dart_config",
                 "..:dart_precompiler_config",
               ] + extra_configs

    if (is_fuchsia) {
      if (using_fuchsia_gn_sdk) {
        public_deps = [ "$fuchsia_sdk_root/pkg/fdio" ]
      } else if (using_fuchsia_sdk) {
        public_deps = [ "$fuchsia_sdk_root/pkg:fdio" ]
      } else {
        public_deps = [ "//sdk/lib/fdio" ]
      }
    }

    deps = [ "//third_party/zlib" ]

    custom_sources_filter = [
      "*_test.cc",
      "*_test.h",
    ]
    if (!is_mac && !is_ios) {
      # Dart tree uses *_macos.* instead of *_mac.*
      custom_sources_filter += [
        "*_macos.h",
        "*_macos.cc",
      ]
    }
    set_sources_assignment_filter(custom_sources_filter)

    defines = [ "DART_IO_SECURE_SOCKET_DISABLED" ]

    sources = io_impl_sources + cli_impl_sources
    sources += [
      "io_natives.cc",
      "io_natives.h",
    ]

    include_dirs = [
      "..",
      "//third_party",
    ]
  }
}

build_gen_snapshot_dart_io("gen_snapshot_dart_io") {
  extra_configs = [
    "..:dart_maybe_product_config",
    "..:dart_arch_config",
    "..:dart_os_config",
  ]
}

build_gen_snapshot_dart_io("gen_snapshot_dart_io_product") {
  extra_configs = [
    "..:dart_product_config",
    "..:dart_arch_config",
    "..:dart_os_config",
  ]
}

build_gen_snapshot_dart_io("gen_snapshot_dart_io_host_targeting_host") {
  extra_configs = [ "..:dart_maybe_product_config" ]
}

build_gen_snapshot_dart_io("gen_snapshot_dart_io_product_host_targeting_host") {
  extra_configs = [ "..:dart_product_config" ]
}

build_gen_snapshot_dart_io("gen_snapshot_dart_io_fuchsia") {
  extra_configs = [
    "..:dart_maybe_product_config",
    "..:dart_arch_config",
    "..:dart_os_fuchsia_config",
  ]
}

build_gen_snapshot_dart_io("gen_snapshot_dart_io_product_fuchsia") {
  extra_configs = [
    "..:dart_product_config",
    "..:dart_arch_config",
    "..:dart_os_fuchsia_config",
  ]
}

# A source set for the implementation of 'dart:io' library.
template("dart_io") {
  extra_configs = []
  if (defined(invoker.extra_configs)) {
    extra_configs += invoker.extra_configs
  }
  extra_sources = []
  if (defined(invoker.extra_sources)) {
    extra_sources += invoker.extra_sources
  }
  extra_deps = []
  if (defined(invoker.extra_deps)) {
    extra_deps += invoker.extra_deps
  }
  source_set(target_name) {
    configs += [
                 "..:dart_arch_config",
                 "..:dart_config",
                 "..:dart_os_config",
               ] + extra_configs
    public_configs = [ "..:dart_public_config" ]
    custom_sources_filter = [
      "*_test.cc",
      "*_test.h",
      "builtin_gen_snapshot.cc",
    ]
    if (!is_mac && !is_ios) {
      # Dart tree uses *_macos.* instead of *_mac.*
      custom_sources_filter += [
        "*_macos.h",
        "*_macos.cc",
      ]
    }
    set_sources_assignment_filter(custom_sources_filter)

    defines = []
    deps = [ "//third_party/zlib" ] + extra_deps
    if (is_mac || is_ios) {
      frameworks = [
        "CoreFoundation.framework",
        "Security.framework",
      ]

      if (is_mac) {
        frameworks += [ "CoreServices.framework" ]
      }
    }

    deps += [ "//third_party/boringssl" ]

    if (is_fuchsia) {
      if (using_fuchsia_gn_sdk) {
        public_deps = [ "$fuchsia_sdk_root/pkg/fdio" ]
      } else if (using_fuchsia_sdk) {
        public_deps = [ "$fuchsia_sdk_root/pkg:fdio" ]
      } else {
        public_deps = [ "//sdk/lib/fdio" ]
      }
    }

    sources = io_impl_sources + cli_impl_sources
    sources += [
                 "builtin_natives.cc",
                 "io_natives.cc",
                 "io_natives.h",
               ] + extra_sources

    if (is_linux || is_win || is_fuchsia) {
      if (dart_use_fallback_root_certificates) {
        sources += [ "//third_party/root_certificates/root_certificates.cc" ]
      } else {
        defines += [ "DART_IO_ROOT_CERTS_DISABLED" ]
      }
    }

    include_dirs = [
      "..",
      "//third_party",
    ]
  }
}

dart_io("dart_io_api") {
  extra_configs = [ "..:dart_maybe_product_config" ]
  extra_sources = [
    "../include/bin/dart_io_api.h",
    "builtin.cc",
    "dart_io_api_impl.cc",
  ]
  extra_deps = [ ":libdart_builtin" ]
}

dart_io("dart_io_api_product") {
  extra_configs = [ "..:dart_product_config" ]
  extra_sources = [
    "../include/bin/dart_io_api.h",
    "builtin.cc",
    "dart_io_api_impl.cc",
  ]
  extra_deps = [ ":libdart_builtin_product" ]
}

dart_io("standalone_dart_io") {
  extra_configs = [ "..:dart_maybe_product_config" ]
  extra_sources = []
  extra_deps = [ ":libdart_builtin" ]
}

dart_io("standalone_dart_io_product") {
  extra_configs = [ "..:dart_product_config" ]
  extra_sources = []
  extra_deps = [ ":libdart_builtin_product" ]
}

gen_snapshot_action("generate_snapshot_bin") {
  deps = [ "../vm:vm_platform_stripped" ]
  vm_snapshot_data = "$target_gen_dir/vm_snapshot_data.bin"
  vm_snapshot_instructions = "$target_gen_dir/vm_snapshot_instructions.bin"
  isolate_snapshot_data = "$target_gen_dir/isolate_snapshot_data.bin"
  isolate_snapshot_instructions =
      "$target_gen_dir/isolate_snapshot_instructions.bin"

  platform_dill = "$root_out_dir/vm_platform_strong_stripped.dill"
  inputs = [ platform_dill ]
  outputs = [
    vm_snapshot_data,
    vm_snapshot_instructions,
    isolate_snapshot_data,
    isolate_snapshot_instructions,
  ]
  args = [
    "--enable-experiment=non-nullable",
    "--sound-null-safety",
    "--deterministic",
    "--snapshot_kind=" + dart_core_snapshot_kind,
    "--vm_snapshot_data=" + rebase_path(vm_snapshot_data, root_build_dir),
    "--vm_snapshot_instructions=" +
        rebase_path(vm_snapshot_instructions, root_build_dir),
    "--isolate_snapshot_data=" +
        rebase_path(isolate_snapshot_data, root_build_dir),
    "--isolate_snapshot_instructions=" +
        rebase_path(isolate_snapshot_instructions, root_build_dir),
    rebase_path(platform_dill),
  ]
}

# Generates an assembly file defining a given symbol with the bytes from a
# binary file. Places the symbol in a text section if 'executable' is true,
# otherwise places the symbol in a read-only data section.
template("bin_to_assembly") {
  assert(defined(invoker.deps), "Must define deps")
  assert(defined(invoker.input), "Must define input binary file")
  assert(defined(invoker.symbol), "Must define symbol name")
  assert(defined(invoker.executable), "Must define boolean executable")

  action(target_name) {
    deps = invoker.deps
    script = "../tools/bin_to_assembly.py"
    output = invoker.input + ".S"
    args = [
      "--input",
      rebase_path(invoker.input),
      "--output",
      rebase_path(output),
      "--symbol_name",
      invoker.symbol,
      "--target_os",
      current_os,
    ]
    if (defined(invoker.size_symbol)) {
      args += [
        "--size_symbol_name",
        invoker.size_symbol,
        "--target_arch",
        current_cpu,
      ]
    }
    if (invoker.executable) {
      args += [ "--executable" ]
    }
    inputs = [ invoker.input ]
    outputs = [ output ]
  }
}

# Generates an object file defining a given symbol with the bytes from a
# binary file. Places the symbol in the read-only data section.
template("bin_to_coff") {
  assert(defined(invoker.deps), "Must define deps")
  assert(defined(invoker.input), "Must define input binary file")
  assert(defined(invoker.symbol), "Must define symbol name")
  assert(defined(invoker.executable), "Must define executable")

  action(target_name) {
    deps = invoker.deps
    script = "../tools/bin_to_coff.py"
    output = invoker.input + ".o"
    args = [
      "--input",
      rebase_path(invoker.input),
      "--output",
      rebase_path(output),
      "--symbol_name",
      invoker.symbol,
    ]

    if (defined(invoker.size_symbol)) {
      args += [
        "--size_symbol_name",
        invoker.size_symbol,
      ]
    }

    if (invoker.executable) {
      args += [ "--executable" ]
    }

    if (current_cpu == "x64") {
      args += [ "--64-bit" ]
    }
    inputs = [ invoker.input ]
    outputs = [ output ]
  }
}

template("bin_to_linkable") {
  assert(defined(invoker.deps), "Must define deps")
  assert(defined(invoker.input), "Must define input binary file")
  assert(defined(invoker.symbol), "Must define symbol name")
  target_type = "bin_to_assembly"
  if (is_win) {
    target_type = "bin_to_coff"
  }

  target(target_type, target_name) {
    forward_variables_from(invoker, "*")
  }
}

bin_to_linkable("vm_snapshot_data_linkable") {
  deps = [ ":generate_snapshot_bin" ]
  input = "$target_gen_dir/vm_snapshot_data.bin"
  symbol = "kDartVmSnapshotData"
  executable = false
}

bin_to_linkable("vm_snapshot_instructions_linkable") {
  deps = [ ":generate_snapshot_bin" ]
  input = "$target_gen_dir/vm_snapshot_instructions.bin"
  symbol = "kDartVmSnapshotInstructions"
  executable = true
}

bin_to_linkable("isolate_snapshot_data_linkable") {
  deps = [ ":generate_snapshot_bin" ]
  input = "$target_gen_dir/isolate_snapshot_data.bin"
  symbol = "kDartCoreIsolateSnapshotData"
  executable = false
}

bin_to_linkable("isolate_snapshot_instructions_linkable") {
  deps = [ ":generate_snapshot_bin" ]
  input = "$target_gen_dir/isolate_snapshot_instructions.bin"
  symbol = "kDartCoreIsolateSnapshotInstructions"
  executable = true
}

bin_to_linkable("kernel_service_dill_linkable") {
  deps = [ "../../utils/kernel-service:kernel_service_dill" ]
  input = "$root_gen_dir/kernel_service.dill"
  symbol = "kKernelServiceDill"
  size_symbol = "kKernelServiceDillSize"
  executable = false
}

bin_to_linkable("platform_strong_dill_linkable") {
  deps = [ "../vm:vm_platform" ]
  input = "$root_out_dir/vm_platform_strong.dill"
  symbol = "kPlatformStrongDill"
  size_symbol = "kPlatformStrongDillSize"
  executable = false
}

source_set("dart_snapshot_cc") {
  visibility = [ ":*" ]
  deps = [
    ":isolate_snapshot_data_linkable",
    ":isolate_snapshot_instructions_linkable",
    ":vm_snapshot_data_linkable",
    ":vm_snapshot_instructions_linkable",
  ]
  sources = get_target_outputs(":isolate_snapshot_data_linkable") +
            get_target_outputs(":isolate_snapshot_instructions_linkable") +
            get_target_outputs(":vm_snapshot_data_linkable") +
            get_target_outputs(":vm_snapshot_instructions_linkable")
}

source_set("dart_kernel_platform_cc") {
  visibility = [ ":*" ]
  deps = [
    ":gen_kernel_bytecode_dill",
    ":kernel_service_dill_linkable",
    ":platform_strong_dill_linkable",
    "../../utils/kernel-service:kernel_service_bytecode_dill",
  ]
  sources = get_target_outputs(":kernel_service_dill_linkable") +
            get_target_outputs(":platform_strong_dill_linkable")
}

template("dart_executable") {
  use_product_mode = dart_runtime_mode == "release"
  if (defined(invoker.use_product_mode)) {
    use_product_mode = invoker.use_product_mode
  }

  extra_configs = []
  if (defined(invoker.extra_configs)) {
    extra_configs += invoker.extra_configs
  }
  extra_deps = []
  if (defined(invoker.extra_deps)) {
    extra_deps += invoker.extra_deps
  }
  extra_defines = []
  if (defined(invoker.extra_defines)) {
    extra_defines = invoker.extra_defines
  }
  extra_sources = []
  if (defined(invoker.extra_sources)) {
    extra_sources += invoker.extra_sources
  }
  extra_ldflags = []
  if (defined(invoker.extra_ldflags)) {
    extra_ldflags = invoker.extra_ldflags
  }
  target_type = "executable"
  if (defined(invoker.target_type)) {
    target_type = invoker.target_type
  }
  target(target_type, target_name) {
    configs += [
                 "..:dart_arch_config",
                 "..:dart_config",
                 "..:dart_os_config",
               ] + extra_configs
    if (use_product_mode) {
      configs += [ "..:dart_product_config" ]
    } else {
      configs += [ "..:dart_maybe_product_config" ]
    }
    if (target_os != current_os && target_os == "fuchsia") {
      # We already have these in the standalone build, but Fuchsia doesn't
      # have them. They are needed for running Fuchsia binaries built for the
      # host.
      if (is_linux) {
        # TODO(liama): Commenting this line out because it causes problems for
        # --os=fuchsia. If no one complains, remove it.
        # configs += [ "../../build/config/gcc:executable_ldconfig" ]
      } else if (is_mac) {
        configs += [ "../../build/config/mac:mac_dynamic_flags" ]
      }
    }

    deps = [
      ":crashpad",
      "//third_party/boringssl",
      "//third_party/zlib",
    ]
    if (use_product_mode) {
      deps += [ ":standalone_dart_io_product" ]
    } else {
      deps += [ ":standalone_dart_io" ]
    }
    deps += extra_deps

    defines = extra_defines
    if (exclude_kernel_service) {
      defines += [ "EXCLUDE_CFE_AND_KERNEL_PLATFORM" ]
    }

    if (dart_use_tcmalloc) {
      deps += [ "//third_party/tcmalloc" ]
    }

    include_dirs = [
      "..",
      "//third_party",
    ]

    sources = [
                "dart_embedder_api_impl.cc",
                "error_exit.cc",
                "error_exit.h",
                "main_options.cc",
                "main_options.h",
                "options.cc",
                "options.h",
                "snapshot_utils.cc",
                "snapshot_utils.h",
                "vmservice_impl.cc",
                "vmservice_impl.h",
              ] + extra_sources

    if (is_win) {
      ldflags = [ "/EXPORT:Dart_True" ]
    } else {
      # Adds all symbols to the dynamic symbol table, not just used ones.
      # This is needed to make native extensions work. It is also needed to get
      # symbols in VM-generated backtraces and profiles.
      ldflags = [ "-rdynamic" ]
    }

    ldflags += extra_ldflags

    if (is_win) {
      libs = [
        "iphlpapi.lib",
        "psapi.lib",
        "ws2_32.lib",
        "Rpcrt4.lib",
        "shlwapi.lib",
        "winmm.lib",
      ]
    }
  }
}

dart_executable("dart") {
  extra_deps = [
    ":dart_snapshot_cc",
    "..:libdart_jit",
    "../platform:libdart_platform_jit",
  ]
  if (dart_runtime_mode != "release") {
    extra_deps += [ "../observatory:standalone_observatory_archive" ]
  }
  extra_sources = [
    "builtin.cc",
    "dartdev_isolate.cc",
    "dartdev_isolate.h",
    "dfe.cc",
    "dfe.h",
    "gzip.cc",
    "gzip.h",
    "loader.cc",
    "loader.h",
    "main.cc",
  ]
  if (dart_runtime_mode == "release") {
    extra_sources += [ "observatory_assets_empty.cc" ]
  }
  if (!exclude_kernel_service) {
    extra_deps += [ ":dart_kernel_platform_cc" ]
  }
}

dart_executable("dart_precompiled_runtime") {
  extra_configs = [ "..:dart_precompiled_runtime_config" ]
  extra_deps = [
    "..:libdart_precompiled_runtime",
    "../platform:libdart_platform_precompiled_runtime",
  ]
  if (dart_runtime_mode != "release") {
    extra_deps += [ "../observatory:standalone_observatory_archive" ]
  }
  extra_sources = [
    "builtin.cc",
    "gzip.cc",
    "gzip.h",
    "loader.cc",
    "loader.h",
    "main.cc",
    "snapshot_empty.cc",
  ]

  if (dart_runtime_mode == "release") {
    extra_deps += [ ":elf_loader_product" ]
  } else {
    extra_deps += [ ":elf_loader" ]
  }

  if (dart_runtime_mode == "release") {
    extra_sources += [ "observatory_assets_empty.cc" ]
  }
}

dart_executable("dart_precompiled_runtime_product") {
  use_product_mode = true
  extra_configs = [ "..:dart_precompiled_runtime_config" ]
  extra_deps = [
    "..:libdart_precompiled_runtime_product",
    "../platform:libdart_platform_precompiled_runtime_product",
  ]
  extra_sources = [
    "builtin.cc",
    "gzip.cc",
    "gzip.h",
    "loader.cc",
    "loader.h",
    "main.cc",
    "observatory_assets_empty.cc",
    "snapshot_empty.cc",
  ]

  extra_deps += [ ":elf_loader_product" ]
}

executable("process_test") {
  sources = [ "process_test.cc" ]
}

prebuilt_dart_action("gen_kernel_bytecode_dill") {
  deps = [ "../vm:vm_platform" ]
  platform_dill = "$root_out_dir/vm_platform_strong.dill"

  output = "$root_out_dir/gen_kernel_bytecode.dill"
  depfile = "$target_gen_dir/gen_kernel_bytecode.dill.d"
  outputs = [
    output,
    depfile,
  ]

  script = "../../pkg/vm/bin/gen_kernel.dart"

  abs_depfile = rebase_path(depfile)
  rebased_output = rebase_path(output, root_build_dir)

  vm_args = [
    "--depfile=$abs_depfile",
    "--depfile_output_filename=$rebased_output",
    "-Dsdk_hash=$sdk_hash",
  ]

  args = [
    "--gen-bytecode",
    "--drop-ast",
    "--no-embed-sources",
    "--platform",
    rebase_path(platform_dill),
    "--output",
    rebase_path(output),
    rebase_path(script),
  ]
}

executable("run_vm_tests") {
  if (target_os == "fuchsia") {
    testonly = true
  }

  configs += [
    "..:dart_arch_config",
    "..:dart_config",
    "..:dart_os_config",
    "..:dart_maybe_product_config",
  ]

  if (dart_target_arch != "ia32") {
    configs += [ "..:dart_precompiler_config" ]
  }

  deps = [
    ":crashpad",
    ":dart_kernel_platform_cc",
    ":dart_snapshot_cc",
    ":gen_kernel_bytecode_dill",
    ":standalone_dart_io",
    "..:libdart_precompiler",
    "//third_party/zlib",
  ]
  if (defined(checkout_llvm) && checkout_llvm) {
    deps += [ "//runtime/llvm_codegen/bit:test" ]
  }
  include_dirs = [
    "..",
    "$target_gen_dir",
    "//third_party",
  ]
  defines = [ "TESTING" ]

  if (dart_use_tcmalloc) {
    deps += [ "//third_party/tcmalloc" ]
    defines += [ "DART_USE_TCMALLOC" ]
  }

  if (is_fuchsia) {
    if (using_fuchsia_gn_sdk) {
      include_dirs += [ "$fuchsia_sdk_path/pkg/trace-engine/include" ]
      libs = [ "zircon" ]
    }
    if (!using_fuchsia_gn_sdk && !using_fuchsia_sdk) {
      deps += [ "//zircon/system/ulib/trace" ]
    }
  }

  # The VM sources are already included in libdart, so we just want to add in
  # the tests here.
  vm_tests = rebase_path(vm_sources_tests, ".", "../vm")
  compiler_tests = rebase_path(compiler_sources_tests, ".", "../vm/compiler")
  heap_tests = rebase_path(heap_sources_tests, ".", "../vm/heap")

  sources = [
              "builtin.cc",
              "dfe.cc",
              "dfe.h",
              "error_exit.cc",
              "error_exit.h",
              "gzip.cc",
              "gzip.h",
              "loader.cc",
              "loader.h",
              "run_vm_tests.cc",
              "snapshot_utils.cc",
              "snapshot_utils.h",
              "vmservice_impl.cc",
              "vmservice_impl.h",
            ] + builtin_impl_tests + vm_tests + compiler_tests + heap_tests +
            io_impl_tests

  if (!is_win) {
    # Adds all symbols to the dynamic symbol table, not just used ones.
    # This is needed to make native extensions work. It is also needed to get
    # symbols in VM-generated backtraces and profiles.
    ldflags = [ "-rdynamic" ]
  }

  if (is_win) {
    libs = [
      "iphlpapi.lib",
      "psapi.lib",
      "ws2_32.lib",
      "Rpcrt4.lib",
      "shlwapi.lib",
      "winmm.lib",
    ]
  }
}

shared_library("test_extension") {
  deps = [ ":dart" ]
  sources = [
    "test_extension.c",
    "test_extension_dllmain_win.cc",
  ]
  include_dirs = [ ".." ]
  defines = [
    # The only effect of DART_SHARED_LIB is to export the Dart API.
    "DART_SHARED_LIB",
  ]
  if (is_linux || is_android) {
    cflags = [ "-fPIC" ]
  }
  if (is_win) {
    libs = [ "dart.lib" ]
    abs_root_out_dir = rebase_path(root_out_dir)
    ldflags = [ "/LIBPATH:$abs_root_out_dir" ]
  }
}

shared_library("entrypoints_verification_test_extension") {
  deps = [ ":dart" ]
  sources = [
    "entrypoints_verification_test_extension.cc",
    "entrypoints_verification_test_extension_dllmain_win.cc",
  ]
  include_dirs = [ ".." ]
  defines = [
    # The only effect of DART_SHARED_LIB is to export the Dart API.
    "DART_SHARED_LIB",
  ]
  if (is_linux || is_android) {
    cflags = [ "-fPIC" ]
  }
  if (is_win) {
    libs = [ "dart.lib" ]
    abs_root_out_dir = rebase_path(root_out_dir)
    ldflags = [ "/LIBPATH:$abs_root_out_dir" ]
  }
}

shared_library("ffi_test_dynamic_library") {
  deps = [ ":dart" ]
  sources = [ "ffi_test/ffi_test_dynamic_library.cc" ]
  include_dirs = [ ".." ]
  defines = [
    # The only effect of DART_SHARED_LIB is to export the Dart API.
    "DART_SHARED_LIB",
  ]
  if (is_linux || is_android) {
    cflags = [ "-fPIC" ]
  }
  if (is_win) {
    # TODO(dartbug.com/40579): This wrongly links in dart.exe on precompiled.
    libs = [ "dart.lib" ]
    abs_root_out_dir = rebase_path(root_out_dir)
    ldflags = [ "/LIBPATH:$abs_root_out_dir" ]
  }
}

shared_library("ffi_test_functions") {
  deps = [ ":dart" ]

  sources = [
    # This file must be compiled in for dynamic linking.
    "../include/dart_api_dl.c",

    # The two files here do not depend on each other.
    # flutter/flutter integration tests will only use `ffi_test_functions.cc` -
    # any test functionality using `dart_api.h` has to go into
    # `ffi_test_functions_vmspecific.cc`.
    "ffi_test/ffi_test_functions.cc",
    "ffi_test/ffi_test_functions_vmspecific.cc",
  ]
  if (is_win && current_cpu == "x64") {
    sources += [ "ffi_test/clobber_x64_win.S" ]
  } else if (!is_win) {
    sources += [ "ffi_test/clobber_$current_cpu.S" ]
  }
  include_dirs = [ ".." ]
  defines = [
    # The only effect of DART_SHARED_LIB is to export the Dart API.
    "DART_SHARED_LIB",
  ]
  if (is_linux || is_android) {
    cflags = [ "-fPIC" ]
  }
  if (is_win) {
    # TODO(dartbug.com/40579): This wrongly links in dart.exe on precompiled.
    libs = [ "dart.lib" ]
    abs_root_out_dir = rebase_path(root_out_dir)
    ldflags = [ "/LIBPATH:$abs_root_out_dir" ]
  }
}

shared_library("sample_extension") {
  deps = [ ":dart" ]
  sources = [
    "../../samples/sample_extension/sample_extension.cc",
    "../../samples/sample_extension/sample_extension_dllmain_win.cc",
  ]
  include_dirs = [ ".." ]
  defines = [
    # The only effect of DART_SHARED_LIB is to export the Dart API.
    "DART_SHARED_LIB",
  ]
  if (is_linux || is_android) {
    cflags = [ "-fPIC" ]
  }
  if (is_win) {
    libs = [ "dart.lib" ]
    abs_root_out_dir = rebase_path(root_out_dir)
    ldflags = [ "/LIBPATH:$abs_root_out_dir" ]
  }
}

# DartLibFuzzer only "exists" for restricted configurations.
if (defined(is_linux) && is_linux && defined(is_asan) && is_asan &&
    (dart_target_arch == "x64" || dart_target_arch == "arm64")) {
  dart_executable("dart_libfuzzer") {
    extra_ldflags = [ "-fsanitize=address,fuzzer" ]
    extra_deps = [ "..:libdart_libfuzzer" ]
    extra_sources = [
      "../vm/libfuzzer/dart_libfuzzer.cc",
      "builtin.cc",
      "dfe.cc",
      "dfe.h",
    ]
    if (!exclude_kernel_service) {
      extra_deps += [ ":dart_kernel_platform_cc" ]
    }
  }
}
