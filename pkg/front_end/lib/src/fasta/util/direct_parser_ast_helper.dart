// Copyright (c) 2020, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

import 'package:_fe_analyzer_shared/src/parser/assert.dart';
import 'package:_fe_analyzer_shared/src/parser/block_kind.dart';
import 'package:_fe_analyzer_shared/src/parser/declaration_kind.dart';
import 'package:_fe_analyzer_shared/src/parser/formal_parameter_kind.dart';
import 'package:_fe_analyzer_shared/src/parser/identifier_context.dart';
import 'package:_fe_analyzer_shared/src/parser/listener.dart';
import 'package:_fe_analyzer_shared/src/parser/member_kind.dart';
import 'package:_fe_analyzer_shared/src/scanner/error_token.dart';
import 'package:_fe_analyzer_shared/src/scanner/token.dart';
import 'package:front_end/src/fasta/messages.dart';

// THIS FILE IS AUTO GENERATED BY
// 'tool/_fasta/direct_parser_ast_helper_creator.dart'
// Run e.g.
/*
   out/ReleaseX64/dart \
     pkg/front_end/tool/_fasta/direct_parser_ast_helper_creator.dart \
      > pkg/front_end/lib/src/fasta/util/direct_parser_ast_helper.dart
*/

class DirectParserASTContent {
  final String what;
  final DirectParserASTType type;
  final Map<String, Object> arguments;
  List<DirectParserASTContent> content;

  DirectParserASTContent(this.what, this.type, this.arguments);

  // TODO(jensj): Compare two ASTs.
}

enum DirectParserASTType { BEGIN, END, HANDLE, DONE }

abstract class AbstractDirectParserASTListener implements Listener {
  List<DirectParserASTContent> data = [];

  void seen(
      String what, DirectParserASTType type, Map<String, Object> arguments);

  void beginArguments(Token token) {
    seen("Arguments", DirectParserASTType.BEGIN, {"token": token});
  }

  void endArguments(int count, Token beginToken, Token endToken) {
    seen("Arguments", DirectParserASTType.END,
        {"count": count, "beginToken": beginToken, "endToken": endToken});
  }

  void handleAsyncModifier(Token asyncToken, Token starToken) {
    seen("AsyncModifier", DirectParserASTType.HANDLE,
        {"asyncToken": asyncToken, "starToken": starToken});
  }

  void beginAwaitExpression(Token token) {
    seen("AwaitExpression", DirectParserASTType.BEGIN, {"token": token});
  }

  void endAwaitExpression(Token beginToken, Token endToken) {
    seen("AwaitExpression", DirectParserASTType.END,
        {"beginToken": beginToken, "endToken": endToken});
  }

  void endInvalidAwaitExpression(
      Token beginToken, Token endToken, MessageCode errorCode) {
    seen("InvalidAwaitExpression", DirectParserASTType.END, {
      "beginToken": beginToken,
      "endToken": endToken,
      "errorCode": errorCode
    });
  }

  void beginBlock(Token token, BlockKind blockKind) {
    seen("Block", DirectParserASTType.BEGIN,
        {"token": token, "blockKind": blockKind});
  }

  void endBlock(
      int count, Token beginToken, Token endToken, BlockKind blockKind) {
    seen("Block", DirectParserASTType.END, {
      "count": count,
      "beginToken": beginToken,
      "endToken": endToken,
      "blockKind": blockKind
    });
  }

  void handleInvalidTopLevelBlock(Token token) {
    seen("InvalidTopLevelBlock", DirectParserASTType.HANDLE, {"token": token});
  }

  void beginCascade(Token token) {
    seen("Cascade", DirectParserASTType.BEGIN, {"token": token});
  }

  void endCascade() {
    seen("Cascade", DirectParserASTType.END, {});
  }

  void beginCaseExpression(Token caseKeyword) {
    seen("CaseExpression", DirectParserASTType.BEGIN,
        {"caseKeyword": caseKeyword});
  }

  void endCaseExpression(Token colon) {
    seen("CaseExpression", DirectParserASTType.END, {"colon": colon});
  }

  void beginClassOrMixinBody(DeclarationKind kind, Token token) {
    seen("ClassOrMixinBody", DirectParserASTType.BEGIN,
        {"kind": kind, "token": token});
  }

  void endClassOrMixinBody(
      DeclarationKind kind, int memberCount, Token beginToken, Token endToken) {
    seen("ClassOrMixinBody", DirectParserASTType.END, {
      "kind": kind,
      "memberCount": memberCount,
      "beginToken": beginToken,
      "endToken": endToken
    });
  }

  void beginClassOrNamedMixinApplicationPrelude(Token token) {
    seen("ClassOrNamedMixinApplicationPrelude", DirectParserASTType.BEGIN,
        {"token": token});
  }

  void beginClassDeclaration(Token begin, Token abstractToken, Token name) {
    seen("ClassDeclaration", DirectParserASTType.BEGIN,
        {"begin": begin, "abstractToken": abstractToken, "name": name});
  }

  void handleClassExtends(Token extendsKeyword, int typeCount) {
    seen("ClassExtends", DirectParserASTType.HANDLE,
        {"extendsKeyword": extendsKeyword, "typeCount": typeCount});
  }

  void handleClassOrMixinImplements(
      Token implementsKeyword, int interfacesCount) {
    seen("ClassOrMixinImplements", DirectParserASTType.HANDLE, {
      "implementsKeyword": implementsKeyword,
      "interfacesCount": interfacesCount
    });
  }

  void handleClassHeader(Token begin, Token classKeyword, Token nativeToken) {
    seen("ClassHeader", DirectParserASTType.HANDLE, {
      "begin": begin,
      "classKeyword": classKeyword,
      "nativeToken": nativeToken
    });
  }

  void handleRecoverClassHeader() {
    seen("RecoverClassHeader", DirectParserASTType.HANDLE, {});
  }

  void endClassDeclaration(Token beginToken, Token endToken) {
    seen("ClassDeclaration", DirectParserASTType.END,
        {"beginToken": beginToken, "endToken": endToken});
  }

  void beginMixinDeclaration(Token mixinKeyword, Token name) {
    seen("MixinDeclaration", DirectParserASTType.BEGIN,
        {"mixinKeyword": mixinKeyword, "name": name});
  }

  void handleMixinOn(Token onKeyword, int typeCount) {
    seen("MixinOn", DirectParserASTType.HANDLE,
        {"onKeyword": onKeyword, "typeCount": typeCount});
  }

  void handleMixinHeader(Token mixinKeyword) {
    seen("MixinHeader", DirectParserASTType.HANDLE,
        {"mixinKeyword": mixinKeyword});
  }

  void handleRecoverMixinHeader() {
    seen("RecoverMixinHeader", DirectParserASTType.HANDLE, {});
  }

  void endMixinDeclaration(Token mixinKeyword, Token endToken) {
    seen("MixinDeclaration", DirectParserASTType.END,
        {"mixinKeyword": mixinKeyword, "endToken": endToken});
  }

  void beginUncategorizedTopLevelDeclaration(Token token) {
    seen("UncategorizedTopLevelDeclaration", DirectParserASTType.BEGIN,
        {"token": token});
  }

  void beginExtensionDeclarationPrelude(Token extensionKeyword) {
    seen("ExtensionDeclarationPrelude", DirectParserASTType.BEGIN,
        {"extensionKeyword": extensionKeyword});
  }

  void beginExtensionDeclaration(Token extensionKeyword, Token name) {
    seen("ExtensionDeclaration", DirectParserASTType.BEGIN,
        {"extensionKeyword": extensionKeyword, "name": name});
  }

  void endExtensionDeclaration(
      Token extensionKeyword, Token onKeyword, Token endToken) {
    seen("ExtensionDeclaration", DirectParserASTType.END, {
      "extensionKeyword": extensionKeyword,
      "onKeyword": onKeyword,
      "endToken": endToken
    });
  }

  void beginCombinators(Token token) {
    seen("Combinators", DirectParserASTType.BEGIN, {"token": token});
  }

  void endCombinators(int count) {
    seen("Combinators", DirectParserASTType.END, {"count": count});
  }

  void beginCompilationUnit(Token token) {
    seen("CompilationUnit", DirectParserASTType.BEGIN, {"token": token});
  }

  void handleDirectivesOnly() {
    seen("DirectivesOnly", DirectParserASTType.HANDLE, {});
  }

  void endCompilationUnit(int count, Token token) {
    seen("CompilationUnit", DirectParserASTType.END,
        {"count": count, "token": token});
  }

  void beginConstLiteral(Token token) {
    seen("ConstLiteral", DirectParserASTType.BEGIN, {"token": token});
  }

  void endConstLiteral(Token token) {
    seen("ConstLiteral", DirectParserASTType.END, {"token": token});
  }

  void beginConstructorReference(Token start) {
    seen("ConstructorReference", DirectParserASTType.BEGIN, {"start": start});
  }

  void endConstructorReference(
      Token start, Token periodBeforeName, Token endToken) {
    seen("ConstructorReference", DirectParserASTType.END, {
      "start": start,
      "periodBeforeName": periodBeforeName,
      "endToken": endToken
    });
  }

  void beginDoWhileStatement(Token token) {
    seen("DoWhileStatement", DirectParserASTType.BEGIN, {"token": token});
  }

  void endDoWhileStatement(
      Token doKeyword, Token whileKeyword, Token endToken) {
    seen("DoWhileStatement", DirectParserASTType.END, {
      "doKeyword": doKeyword,
      "whileKeyword": whileKeyword,
      "endToken": endToken
    });
  }

  void beginDoWhileStatementBody(Token token) {
    seen("DoWhileStatementBody", DirectParserASTType.BEGIN, {"token": token});
  }

  void endDoWhileStatementBody(Token token) {
    seen("DoWhileStatementBody", DirectParserASTType.END, {"token": token});
  }

  void beginWhileStatementBody(Token token) {
    seen("WhileStatementBody", DirectParserASTType.BEGIN, {"token": token});
  }

  void endWhileStatementBody(Token token) {
    seen("WhileStatementBody", DirectParserASTType.END, {"token": token});
  }

  void beginEnum(Token enumKeyword) {
    seen("Enum", DirectParserASTType.BEGIN, {"enumKeyword": enumKeyword});
  }

  void endEnum(Token enumKeyword, Token leftBrace, int count) {
    seen("Enum", DirectParserASTType.END,
        {"enumKeyword": enumKeyword, "leftBrace": leftBrace, "count": count});
  }

  void beginExport(Token token) {
    seen("Export", DirectParserASTType.BEGIN, {"token": token});
  }

  void endExport(Token exportKeyword, Token semicolon) {
    seen("Export", DirectParserASTType.END,
        {"exportKeyword": exportKeyword, "semicolon": semicolon});
  }

  void handleExtraneousExpression(Token token, Message message) {
    seen("ExtraneousExpression", DirectParserASTType.HANDLE,
        {"token": token, "message": message});
  }

  void handleExpressionStatement(Token token) {
    seen("ExpressionStatement", DirectParserASTType.HANDLE, {"token": token});
  }

  void beginFactoryMethod(
      Token lastConsumed, Token externalToken, Token constToken) {
    seen("FactoryMethod", DirectParserASTType.BEGIN, {
      "lastConsumed": lastConsumed,
      "externalToken": externalToken,
      "constToken": constToken
    });
  }

  void endClassFactoryMethod(
      Token beginToken, Token factoryKeyword, Token endToken) {
    seen("ClassFactoryMethod", DirectParserASTType.END, {
      "beginToken": beginToken,
      "factoryKeyword": factoryKeyword,
      "endToken": endToken
    });
  }

  void endMixinFactoryMethod(
      Token beginToken, Token factoryKeyword, Token endToken) {
    seen("MixinFactoryMethod", DirectParserASTType.END, {
      "beginToken": beginToken,
      "factoryKeyword": factoryKeyword,
      "endToken": endToken
    });
  }

  void endExtensionFactoryMethod(
      Token beginToken, Token factoryKeyword, Token endToken) {
    seen("ExtensionFactoryMethod", DirectParserASTType.END, {
      "beginToken": beginToken,
      "factoryKeyword": factoryKeyword,
      "endToken": endToken
    });
  }

  void beginFormalParameter(Token token, MemberKind kind, Token requiredToken,
      Token covariantToken, Token varFinalOrConst) {
    seen("FormalParameter", DirectParserASTType.BEGIN, {
      "token": token,
      "kind": kind,
      "requiredToken": requiredToken,
      "covariantToken": covariantToken,
      "varFinalOrConst": varFinalOrConst
    });
  }

  void endFormalParameter(
      Token thisKeyword,
      Token periodAfterThis,
      Token nameToken,
      Token initializerStart,
      Token initializerEnd,
      FormalParameterKind kind,
      MemberKind memberKind) {
    seen("FormalParameter", DirectParserASTType.END, {
      "thisKeyword": thisKeyword,
      "periodAfterThis": periodAfterThis,
      "nameToken": nameToken,
      "initializerStart": initializerStart,
      "initializerEnd": initializerEnd,
      "kind": kind,
      "memberKind": memberKind
    });
  }

  void handleNoFormalParameters(Token token, MemberKind kind) {
    seen("NoFormalParameters", DirectParserASTType.HANDLE,
        {"token": token, "kind": kind});
  }

  void beginFormalParameters(Token token, MemberKind kind) {
    seen("FormalParameters", DirectParserASTType.BEGIN,
        {"token": token, "kind": kind});
  }

  void endFormalParameters(
      int count, Token beginToken, Token endToken, MemberKind kind) {
    seen("FormalParameters", DirectParserASTType.END, {
      "count": count,
      "beginToken": beginToken,
      "endToken": endToken,
      "kind": kind
    });
  }

  void endClassFields(
      Token abstractToken,
      Token externalToken,
      Token staticToken,
      Token covariantToken,
      Token lateToken,
      Token varFinalOrConst,
      int count,
      Token beginToken,
      Token endToken) {
    seen("ClassFields", DirectParserASTType.END, {
      "abstractToken": abstractToken,
      "externalToken": externalToken,
      "staticToken": staticToken,
      "covariantToken": covariantToken,
      "lateToken": lateToken,
      "varFinalOrConst": varFinalOrConst,
      "count": count,
      "beginToken": beginToken,
      "endToken": endToken
    });
  }

  void endMixinFields(
      Token abstractToken,
      Token externalToken,
      Token staticToken,
      Token covariantToken,
      Token lateToken,
      Token varFinalOrConst,
      int count,
      Token beginToken,
      Token endToken) {
    seen("MixinFields", DirectParserASTType.END, {
      "abstractToken": abstractToken,
      "externalToken": externalToken,
      "staticToken": staticToken,
      "covariantToken": covariantToken,
      "lateToken": lateToken,
      "varFinalOrConst": varFinalOrConst,
      "count": count,
      "beginToken": beginToken,
      "endToken": endToken
    });
  }

  void endExtensionFields(
      Token abstractToken,
      Token externalToken,
      Token staticToken,
      Token covariantToken,
      Token lateToken,
      Token varFinalOrConst,
      int count,
      Token beginToken,
      Token endToken) {
    seen("ExtensionFields", DirectParserASTType.END, {
      "abstractToken": abstractToken,
      "externalToken": externalToken,
      "staticToken": staticToken,
      "covariantToken": covariantToken,
      "lateToken": lateToken,
      "varFinalOrConst": varFinalOrConst,
      "count": count,
      "beginToken": beginToken,
      "endToken": endToken
    });
  }

  void handleForInitializerEmptyStatement(Token token) {
    seen("ForInitializerEmptyStatement", DirectParserASTType.HANDLE,
        {"token": token});
  }

  void handleForInitializerExpressionStatement(Token token, bool forIn) {
    seen("ForInitializerExpressionStatement", DirectParserASTType.HANDLE,
        {"token": token, "forIn": forIn});
  }

  void handleForInitializerLocalVariableDeclaration(Token token, bool forIn) {
    seen("ForInitializerLocalVariableDeclaration", DirectParserASTType.HANDLE,
        {"token": token, "forIn": forIn});
  }

  void beginForStatement(Token token) {
    seen("ForStatement", DirectParserASTType.BEGIN, {"token": token});
  }

  void handleForLoopParts(Token forKeyword, Token leftParen,
      Token leftSeparator, int updateExpressionCount) {
    seen("ForLoopParts", DirectParserASTType.HANDLE, {
      "forKeyword": forKeyword,
      "leftParen": leftParen,
      "leftSeparator": leftSeparator,
      "updateExpressionCount": updateExpressionCount
    });
  }

  void endForStatement(Token endToken) {
    seen("ForStatement", DirectParserASTType.END, {"endToken": endToken});
  }

  void beginForStatementBody(Token token) {
    seen("ForStatementBody", DirectParserASTType.BEGIN, {"token": token});
  }

  void endForStatementBody(Token token) {
    seen("ForStatementBody", DirectParserASTType.END, {"token": token});
  }

  void handleForInLoopParts(Token awaitToken, Token forToken,
      Token leftParenthesis, Token inKeyword) {
    seen("ForInLoopParts", DirectParserASTType.HANDLE, {
      "awaitToken": awaitToken,
      "forToken": forToken,
      "leftParenthesis": leftParenthesis,
      "inKeyword": inKeyword
    });
  }

  void endForIn(Token endToken) {
    seen("ForIn", DirectParserASTType.END, {"endToken": endToken});
  }

  void beginForInExpression(Token token) {
    seen("ForInExpression", DirectParserASTType.BEGIN, {"token": token});
  }

  void endForInExpression(Token token) {
    seen("ForInExpression", DirectParserASTType.END, {"token": token});
  }

  void beginForInBody(Token token) {
    seen("ForInBody", DirectParserASTType.BEGIN, {"token": token});
  }

  void endForInBody(Token token) {
    seen("ForInBody", DirectParserASTType.END, {"token": token});
  }

  void beginNamedFunctionExpression(Token token) {
    seen(
        "NamedFunctionExpression", DirectParserASTType.BEGIN, {"token": token});
  }

  void endNamedFunctionExpression(Token endToken) {
    seen("NamedFunctionExpression", DirectParserASTType.END,
        {"endToken": endToken});
  }

  void beginLocalFunctionDeclaration(Token token) {
    seen("LocalFunctionDeclaration", DirectParserASTType.BEGIN,
        {"token": token});
  }

  void endLocalFunctionDeclaration(Token endToken) {
    seen("LocalFunctionDeclaration", DirectParserASTType.END,
        {"endToken": endToken});
  }

  void beginBlockFunctionBody(Token token) {
    seen("BlockFunctionBody", DirectParserASTType.BEGIN, {"token": token});
  }

  void endBlockFunctionBody(int count, Token beginToken, Token endToken) {
    seen("BlockFunctionBody", DirectParserASTType.END,
        {"count": count, "beginToken": beginToken, "endToken": endToken});
  }

  void handleNoFunctionBody(Token token) {
    seen("NoFunctionBody", DirectParserASTType.HANDLE, {"token": token});
  }

  void handleFunctionBodySkipped(Token token, bool isExpressionBody) {
    seen("FunctionBodySkipped", DirectParserASTType.HANDLE,
        {"token": token, "isExpressionBody": isExpressionBody});
  }

  void beginFunctionName(Token token) {
    seen("FunctionName", DirectParserASTType.BEGIN, {"token": token});
  }

  void endFunctionName(Token beginToken, Token token) {
    seen("FunctionName", DirectParserASTType.END,
        {"beginToken": beginToken, "token": token});
  }

  void beginFunctionTypeAlias(Token token) {
    seen("FunctionTypeAlias", DirectParserASTType.BEGIN, {"token": token});
  }

  void endFunctionTypeAlias(
      Token typedefKeyword, Token equals, Token endToken) {
    seen("FunctionTypeAlias", DirectParserASTType.END, {
      "typedefKeyword": typedefKeyword,
      "equals": equals,
      "endToken": endToken
    });
  }

  void handleClassWithClause(Token withKeyword) {
    seen("ClassWithClause", DirectParserASTType.HANDLE,
        {"withKeyword": withKeyword});
  }

  void handleClassNoWithClause() {
    seen("ClassNoWithClause", DirectParserASTType.HANDLE, {});
  }

  void beginNamedMixinApplication(
      Token begin, Token abstractToken, Token name) {
    seen("NamedMixinApplication", DirectParserASTType.BEGIN,
        {"begin": begin, "abstractToken": abstractToken, "name": name});
  }

  void handleNamedMixinApplicationWithClause(Token withKeyword) {
    seen("NamedMixinApplicationWithClause", DirectParserASTType.HANDLE,
        {"withKeyword": withKeyword});
  }

  void endNamedMixinApplication(Token begin, Token classKeyword, Token equals,
      Token implementsKeyword, Token endToken) {
    seen("NamedMixinApplication", DirectParserASTType.END, {
      "begin": begin,
      "classKeyword": classKeyword,
      "equals": equals,
      "implementsKeyword": implementsKeyword,
      "endToken": endToken
    });
  }

  void beginHide(Token hideKeyword) {
    seen("Hide", DirectParserASTType.BEGIN, {"hideKeyword": hideKeyword});
  }

  void endHide(Token hideKeyword) {
    seen("Hide", DirectParserASTType.END, {"hideKeyword": hideKeyword});
  }

  void handleIdentifierList(int count) {
    seen("IdentifierList", DirectParserASTType.HANDLE, {"count": count});
  }

  void beginTypeList(Token token) {
    seen("TypeList", DirectParserASTType.BEGIN, {"token": token});
  }

  void endTypeList(int count) {
    seen("TypeList", DirectParserASTType.END, {"count": count});
  }

  void beginIfStatement(Token token) {
    seen("IfStatement", DirectParserASTType.BEGIN, {"token": token});
  }

  void endIfStatement(Token ifToken, Token elseToken) {
    seen("IfStatement", DirectParserASTType.END,
        {"ifToken": ifToken, "elseToken": elseToken});
  }

  void beginThenStatement(Token token) {
    seen("ThenStatement", DirectParserASTType.BEGIN, {"token": token});
  }

  void endThenStatement(Token token) {
    seen("ThenStatement", DirectParserASTType.END, {"token": token});
  }

  void beginElseStatement(Token token) {
    seen("ElseStatement", DirectParserASTType.BEGIN, {"token": token});
  }

  void endElseStatement(Token token) {
    seen("ElseStatement", DirectParserASTType.END, {"token": token});
  }

  void beginImport(Token importKeyword) {
    seen("Import", DirectParserASTType.BEGIN, {"importKeyword": importKeyword});
  }

  void handleImportPrefix(Token deferredKeyword, Token asKeyword) {
    seen("ImportPrefix", DirectParserASTType.HANDLE,
        {"deferredKeyword": deferredKeyword, "asKeyword": asKeyword});
  }

  void endImport(Token importKeyword, Token semicolon) {
    seen("Import", DirectParserASTType.END,
        {"importKeyword": importKeyword, "semicolon": semicolon});
  }

  void handleRecoverImport(Token semicolon) {
    seen("RecoverImport", DirectParserASTType.HANDLE, {"semicolon": semicolon});
  }

  void beginConditionalUris(Token token) {
    seen("ConditionalUris", DirectParserASTType.BEGIN, {"token": token});
  }

  void endConditionalUris(int count) {
    seen("ConditionalUris", DirectParserASTType.END, {"count": count});
  }

  void beginConditionalUri(Token ifKeyword) {
    seen("ConditionalUri", DirectParserASTType.BEGIN, {"ifKeyword": ifKeyword});
  }

  void endConditionalUri(Token ifKeyword, Token leftParen, Token equalSign) {
    seen("ConditionalUri", DirectParserASTType.END, {
      "ifKeyword": ifKeyword,
      "leftParen": leftParen,
      "equalSign": equalSign
    });
  }

  void handleDottedName(int count, Token firstIdentifier) {
    seen("DottedName", DirectParserASTType.HANDLE,
        {"count": count, "firstIdentifier": firstIdentifier});
  }

  void beginImplicitCreationExpression(Token token) {
    seen("ImplicitCreationExpression", DirectParserASTType.BEGIN,
        {"token": token});
  }

  void endImplicitCreationExpression(Token token) {
    seen("ImplicitCreationExpression", DirectParserASTType.END,
        {"token": token});
  }

  void beginInitializedIdentifier(Token token) {
    seen("InitializedIdentifier", DirectParserASTType.BEGIN, {"token": token});
  }

  void endInitializedIdentifier(Token nameToken) {
    seen("InitializedIdentifier", DirectParserASTType.END,
        {"nameToken": nameToken});
  }

  void beginFieldInitializer(Token token) {
    seen("FieldInitializer", DirectParserASTType.BEGIN, {"token": token});
  }

  void endFieldInitializer(Token assignment, Token token) {
    seen("FieldInitializer", DirectParserASTType.END,
        {"assignment": assignment, "token": token});
  }

  void handleNoFieldInitializer(Token token) {
    seen("NoFieldInitializer", DirectParserASTType.HANDLE, {"token": token});
  }

  void beginVariableInitializer(Token token) {
    seen("VariableInitializer", DirectParserASTType.BEGIN, {"token": token});
  }

  void endVariableInitializer(Token assignmentOperator) {
    seen("VariableInitializer", DirectParserASTType.END,
        {"assignmentOperator": assignmentOperator});
  }

  void handleNoVariableInitializer(Token token) {
    seen("NoVariableInitializer", DirectParserASTType.HANDLE, {"token": token});
  }

  void beginInitializer(Token token) {
    seen("Initializer", DirectParserASTType.BEGIN, {"token": token});
  }

  void endInitializer(Token token) {
    seen("Initializer", DirectParserASTType.END, {"token": token});
  }

  void beginInitializers(Token token) {
    seen("Initializers", DirectParserASTType.BEGIN, {"token": token});
  }

  void endInitializers(int count, Token beginToken, Token endToken) {
    seen("Initializers", DirectParserASTType.END,
        {"count": count, "beginToken": beginToken, "endToken": endToken});
  }

  void handleNoInitializers() {
    seen("NoInitializers", DirectParserASTType.HANDLE, {});
  }

  void handleInvalidExpression(Token token) {
    seen("InvalidExpression", DirectParserASTType.HANDLE, {"token": token});
  }

  void handleInvalidFunctionBody(Token token) {
    seen("InvalidFunctionBody", DirectParserASTType.HANDLE, {"token": token});
  }

  void handleInvalidTypeReference(Token token) {
    seen("InvalidTypeReference", DirectParserASTType.HANDLE, {"token": token});
  }

  void handleLabel(Token token) {
    seen("Label", DirectParserASTType.HANDLE, {"token": token});
  }

  void beginLabeledStatement(Token token, int labelCount) {
    seen("LabeledStatement", DirectParserASTType.BEGIN,
        {"token": token, "labelCount": labelCount});
  }

  void endLabeledStatement(int labelCount) {
    seen("LabeledStatement", DirectParserASTType.END,
        {"labelCount": labelCount});
  }

  void beginLibraryName(Token token) {
    seen("LibraryName", DirectParserASTType.BEGIN, {"token": token});
  }

  void endLibraryName(Token libraryKeyword, Token semicolon) {
    seen("LibraryName", DirectParserASTType.END,
        {"libraryKeyword": libraryKeyword, "semicolon": semicolon});
  }

  void handleLiteralMapEntry(Token colon, Token endToken) {
    seen("LiteralMapEntry", DirectParserASTType.HANDLE,
        {"colon": colon, "endToken": endToken});
  }

  void beginLiteralString(Token token) {
    seen("LiteralString", DirectParserASTType.BEGIN, {"token": token});
  }

  void handleInterpolationExpression(Token leftBracket, Token rightBracket) {
    seen("InterpolationExpression", DirectParserASTType.HANDLE,
        {"leftBracket": leftBracket, "rightBracket": rightBracket});
  }

  void endLiteralString(int interpolationCount, Token endToken) {
    seen("LiteralString", DirectParserASTType.END,
        {"interpolationCount": interpolationCount, "endToken": endToken});
  }

  void handleStringJuxtaposition(Token startToken, int literalCount) {
    seen("StringJuxtaposition", DirectParserASTType.HANDLE,
        {"startToken": startToken, "literalCount": literalCount});
  }

  void beginMember() {
    seen("Member", DirectParserASTType.BEGIN, {});
  }

  void handleInvalidMember(Token endToken) {
    seen("InvalidMember", DirectParserASTType.HANDLE, {"endToken": endToken});
  }

  void endMember() {
    seen("Member", DirectParserASTType.END, {});
  }

  void beginMethod(Token externalToken, Token staticToken, Token covariantToken,
      Token varFinalOrConst, Token getOrSet, Token name) {
    seen("Method", DirectParserASTType.BEGIN, {
      "externalToken": externalToken,
      "staticToken": staticToken,
      "covariantToken": covariantToken,
      "varFinalOrConst": varFinalOrConst,
      "getOrSet": getOrSet,
      "name": name
    });
  }

  void endClassMethod(Token getOrSet, Token beginToken, Token beginParam,
      Token beginInitializers, Token endToken) {
    seen("ClassMethod", DirectParserASTType.END, {
      "getOrSet": getOrSet,
      "beginToken": beginToken,
      "beginParam": beginParam,
      "beginInitializers": beginInitializers,
      "endToken": endToken
    });
  }

  void endMixinMethod(Token getOrSet, Token beginToken, Token beginParam,
      Token beginInitializers, Token endToken) {
    seen("MixinMethod", DirectParserASTType.END, {
      "getOrSet": getOrSet,
      "beginToken": beginToken,
      "beginParam": beginParam,
      "beginInitializers": beginInitializers,
      "endToken": endToken
    });
  }

  void endExtensionMethod(Token getOrSet, Token beginToken, Token beginParam,
      Token beginInitializers, Token endToken) {
    seen("ExtensionMethod", DirectParserASTType.END, {
      "getOrSet": getOrSet,
      "beginToken": beginToken,
      "beginParam": beginParam,
      "beginInitializers": beginInitializers,
      "endToken": endToken
    });
  }

  void endClassConstructor(Token getOrSet, Token beginToken, Token beginParam,
      Token beginInitializers, Token endToken) {
    seen("ClassConstructor", DirectParserASTType.END, {
      "getOrSet": getOrSet,
      "beginToken": beginToken,
      "beginParam": beginParam,
      "beginInitializers": beginInitializers,
      "endToken": endToken
    });
  }

  void endMixinConstructor(Token getOrSet, Token beginToken, Token beginParam,
      Token beginInitializers, Token endToken) {
    seen("MixinConstructor", DirectParserASTType.END, {
      "getOrSet": getOrSet,
      "beginToken": beginToken,
      "beginParam": beginParam,
      "beginInitializers": beginInitializers,
      "endToken": endToken
    });
  }

  void endExtensionConstructor(Token getOrSet, Token beginToken,
      Token beginParam, Token beginInitializers, Token endToken) {
    seen("ExtensionConstructor", DirectParserASTType.END, {
      "getOrSet": getOrSet,
      "beginToken": beginToken,
      "beginParam": beginParam,
      "beginInitializers": beginInitializers,
      "endToken": endToken
    });
  }

  void beginMetadataStar(Token token) {
    seen("MetadataStar", DirectParserASTType.BEGIN, {"token": token});
  }

  void endMetadataStar(int count) {
    seen("MetadataStar", DirectParserASTType.END, {"count": count});
  }

  void beginMetadata(Token token) {
    seen("Metadata", DirectParserASTType.BEGIN, {"token": token});
  }

  void endMetadata(Token beginToken, Token periodBeforeName, Token endToken) {
    seen("Metadata", DirectParserASTType.END, {
      "beginToken": beginToken,
      "periodBeforeName": periodBeforeName,
      "endToken": endToken
    });
  }

  void beginOptionalFormalParameters(Token token) {
    seen("OptionalFormalParameters", DirectParserASTType.BEGIN,
        {"token": token});
  }

  void endOptionalFormalParameters(
      int count, Token beginToken, Token endToken) {
    seen("OptionalFormalParameters", DirectParserASTType.END,
        {"count": count, "beginToken": beginToken, "endToken": endToken});
  }

  void beginPart(Token token) {
    seen("Part", DirectParserASTType.BEGIN, {"token": token});
  }

  void endPart(Token partKeyword, Token semicolon) {
    seen("Part", DirectParserASTType.END,
        {"partKeyword": partKeyword, "semicolon": semicolon});
  }

  void beginPartOf(Token token) {
    seen("PartOf", DirectParserASTType.BEGIN, {"token": token});
  }

  void endPartOf(
      Token partKeyword, Token ofKeyword, Token semicolon, bool hasName) {
    seen("PartOf", DirectParserASTType.END, {
      "partKeyword": partKeyword,
      "ofKeyword": ofKeyword,
      "semicolon": semicolon,
      "hasName": hasName
    });
  }

  void beginRedirectingFactoryBody(Token token) {
    seen("RedirectingFactoryBody", DirectParserASTType.BEGIN, {"token": token});
  }

  void endRedirectingFactoryBody(Token beginToken, Token endToken) {
    seen("RedirectingFactoryBody", DirectParserASTType.END,
        {"beginToken": beginToken, "endToken": endToken});
  }

  void beginReturnStatement(Token token) {
    seen("ReturnStatement", DirectParserASTType.BEGIN, {"token": token});
  }

  void handleNativeFunctionBody(Token nativeToken, Token semicolon) {
    seen("NativeFunctionBody", DirectParserASTType.HANDLE,
        {"nativeToken": nativeToken, "semicolon": semicolon});
  }

  void handleNativeFunctionBodyIgnored(Token nativeToken, Token semicolon) {
    seen("NativeFunctionBodyIgnored", DirectParserASTType.HANDLE,
        {"nativeToken": nativeToken, "semicolon": semicolon});
  }

  void handleNativeFunctionBodySkipped(Token nativeToken, Token semicolon) {
    seen("NativeFunctionBodySkipped", DirectParserASTType.HANDLE,
        {"nativeToken": nativeToken, "semicolon": semicolon});
  }

  void handleEmptyFunctionBody(Token semicolon) {
    seen("EmptyFunctionBody", DirectParserASTType.HANDLE,
        {"semicolon": semicolon});
  }

  void handleExpressionFunctionBody(Token arrowToken, Token endToken) {
    seen("ExpressionFunctionBody", DirectParserASTType.HANDLE,
        {"arrowToken": arrowToken, "endToken": endToken});
  }

  void endReturnStatement(
      bool hasExpression, Token beginToken, Token endToken) {
    seen("ReturnStatement", DirectParserASTType.END, {
      "hasExpression": hasExpression,
      "beginToken": beginToken,
      "endToken": endToken
    });
  }

  void handleSend(Token beginToken, Token endToken) {
    seen("Send", DirectParserASTType.HANDLE,
        {"beginToken": beginToken, "endToken": endToken});
  }

  void beginShow(Token showKeyword) {
    seen("Show", DirectParserASTType.BEGIN, {"showKeyword": showKeyword});
  }

  void endShow(Token showKeyword) {
    seen("Show", DirectParserASTType.END, {"showKeyword": showKeyword});
  }

  void beginSwitchStatement(Token token) {
    seen("SwitchStatement", DirectParserASTType.BEGIN, {"token": token});
  }

  void endSwitchStatement(Token switchKeyword, Token endToken) {
    seen("SwitchStatement", DirectParserASTType.END,
        {"switchKeyword": switchKeyword, "endToken": endToken});
  }

  void beginSwitchBlock(Token token) {
    seen("SwitchBlock", DirectParserASTType.BEGIN, {"token": token});
  }

  void endSwitchBlock(int caseCount, Token beginToken, Token endToken) {
    seen("SwitchBlock", DirectParserASTType.END, {
      "caseCount": caseCount,
      "beginToken": beginToken,
      "endToken": endToken
    });
  }

  void beginLiteralSymbol(Token token) {
    seen("LiteralSymbol", DirectParserASTType.BEGIN, {"token": token});
  }

  void endLiteralSymbol(Token hashToken, int identifierCount) {
    seen("LiteralSymbol", DirectParserASTType.END,
        {"hashToken": hashToken, "identifierCount": identifierCount});
  }

  void handleThrowExpression(Token throwToken, Token endToken) {
    seen("ThrowExpression", DirectParserASTType.HANDLE,
        {"throwToken": throwToken, "endToken": endToken});
  }

  void beginRethrowStatement(Token token) {
    seen("RethrowStatement", DirectParserASTType.BEGIN, {"token": token});
  }

  void endRethrowStatement(Token rethrowToken, Token endToken) {
    seen("RethrowStatement", DirectParserASTType.END,
        {"rethrowToken": rethrowToken, "endToken": endToken});
  }

  void endTopLevelDeclaration(Token nextToken) {
    seen("TopLevelDeclaration", DirectParserASTType.END,
        {"nextToken": nextToken});
  }

  void handleInvalidTopLevelDeclaration(Token endToken) {
    seen("InvalidTopLevelDeclaration", DirectParserASTType.HANDLE,
        {"endToken": endToken});
  }

  void beginTopLevelMember(Token token) {
    seen("TopLevelMember", DirectParserASTType.BEGIN, {"token": token});
  }

  void beginFields(Token lastConsumed) {
    seen("Fields", DirectParserASTType.BEGIN, {"lastConsumed": lastConsumed});
  }

  void endTopLevelFields(
      Token externalToken,
      Token staticToken,
      Token covariantToken,
      Token lateToken,
      Token varFinalOrConst,
      int count,
      Token beginToken,
      Token endToken) {
    seen("TopLevelFields", DirectParserASTType.END, {
      "externalToken": externalToken,
      "staticToken": staticToken,
      "covariantToken": covariantToken,
      "lateToken": lateToken,
      "varFinalOrConst": varFinalOrConst,
      "count": count,
      "beginToken": beginToken,
      "endToken": endToken
    });
  }

  void beginTopLevelMethod(Token lastConsumed, Token externalToken) {
    seen("TopLevelMethod", DirectParserASTType.BEGIN,
        {"lastConsumed": lastConsumed, "externalToken": externalToken});
  }

  void endTopLevelMethod(Token beginToken, Token getOrSet, Token endToken) {
    seen("TopLevelMethod", DirectParserASTType.END,
        {"beginToken": beginToken, "getOrSet": getOrSet, "endToken": endToken});
  }

  void beginTryStatement(Token token) {
    seen("TryStatement", DirectParserASTType.BEGIN, {"token": token});
  }

  void handleCaseMatch(Token caseKeyword, Token colon) {
    seen("CaseMatch", DirectParserASTType.HANDLE,
        {"caseKeyword": caseKeyword, "colon": colon});
  }

  void beginCatchClause(Token token) {
    seen("CatchClause", DirectParserASTType.BEGIN, {"token": token});
  }

  void endCatchClause(Token token) {
    seen("CatchClause", DirectParserASTType.END, {"token": token});
  }

  void handleCatchBlock(Token onKeyword, Token catchKeyword, Token comma) {
    seen("CatchBlock", DirectParserASTType.HANDLE,
        {"onKeyword": onKeyword, "catchKeyword": catchKeyword, "comma": comma});
  }

  void handleFinallyBlock(Token finallyKeyword) {
    seen("FinallyBlock", DirectParserASTType.HANDLE,
        {"finallyKeyword": finallyKeyword});
  }

  void endTryStatement(int catchCount, Token tryKeyword, Token finallyKeyword) {
    seen("TryStatement", DirectParserASTType.END, {
      "catchCount": catchCount,
      "tryKeyword": tryKeyword,
      "finallyKeyword": finallyKeyword
    });
  }

  void handleType(Token beginToken, Token questionMark) {
    seen("Type", DirectParserASTType.HANDLE,
        {"beginToken": beginToken, "questionMark": questionMark});
  }

  void handleNonNullAssertExpression(Token bang) {
    seen("NonNullAssertExpression", DirectParserASTType.HANDLE, {"bang": bang});
  }

  void handleNoName(Token token) {
    seen("NoName", DirectParserASTType.HANDLE, {"token": token});
  }

  void beginFunctionType(Token beginToken) {
    seen("FunctionType", DirectParserASTType.BEGIN, {"beginToken": beginToken});
  }

  void endFunctionType(Token functionToken, Token questionMark) {
    seen("FunctionType", DirectParserASTType.END,
        {"functionToken": functionToken, "questionMark": questionMark});
  }

  void beginTypeArguments(Token token) {
    seen("TypeArguments", DirectParserASTType.BEGIN, {"token": token});
  }

  void endTypeArguments(int count, Token beginToken, Token endToken) {
    seen("TypeArguments", DirectParserASTType.END,
        {"count": count, "beginToken": beginToken, "endToken": endToken});
  }

  void handleInvalidTypeArguments(Token token) {
    seen("InvalidTypeArguments", DirectParserASTType.HANDLE, {"token": token});
  }

  void handleNoTypeArguments(Token token) {
    seen("NoTypeArguments", DirectParserASTType.HANDLE, {"token": token});
  }

  void beginTypeVariable(Token token) {
    seen("TypeVariable", DirectParserASTType.BEGIN, {"token": token});
  }

  void handleTypeVariablesDefined(Token token, int count) {
    seen("TypeVariablesDefined", DirectParserASTType.HANDLE,
        {"token": token, "count": count});
  }

  void endTypeVariable(
      Token token, int index, Token extendsOrSuper, Token variance) {
    seen("TypeVariable", DirectParserASTType.END, {
      "token": token,
      "index": index,
      "extendsOrSuper": extendsOrSuper,
      "variance": variance
    });
  }

  void beginTypeVariables(Token token) {
    seen("TypeVariables", DirectParserASTType.BEGIN, {"token": token});
  }

  void endTypeVariables(Token beginToken, Token endToken) {
    seen("TypeVariables", DirectParserASTType.END,
        {"beginToken": beginToken, "endToken": endToken});
  }

  void beginFunctionExpression(Token token) {
    seen("FunctionExpression", DirectParserASTType.BEGIN, {"token": token});
  }

  void endFunctionExpression(Token beginToken, Token token) {
    seen("FunctionExpression", DirectParserASTType.END,
        {"beginToken": beginToken, "token": token});
  }

  void beginVariablesDeclaration(
      Token token, Token lateToken, Token varFinalOrConst) {
    seen("VariablesDeclaration", DirectParserASTType.BEGIN, {
      "token": token,
      "lateToken": lateToken,
      "varFinalOrConst": varFinalOrConst
    });
  }

  void endVariablesDeclaration(int count, Token endToken) {
    seen("VariablesDeclaration", DirectParserASTType.END,
        {"count": count, "endToken": endToken});
  }

  void beginWhileStatement(Token token) {
    seen("WhileStatement", DirectParserASTType.BEGIN, {"token": token});
  }

  void endWhileStatement(Token whileKeyword, Token endToken) {
    seen("WhileStatement", DirectParserASTType.END,
        {"whileKeyword": whileKeyword, "endToken": endToken});
  }

  void beginAsOperatorType(Token operator) {
    seen("AsOperatorType", DirectParserASTType.BEGIN, {"operator": operator});
  }

  void endAsOperatorType(Token operator) {
    seen("AsOperatorType", DirectParserASTType.END, {"operator": operator});
  }

  void handleAsOperator(Token operator) {
    seen("AsOperator", DirectParserASTType.HANDLE, {"operator": operator});
  }

  void handleAssignmentExpression(Token token) {
    seen("AssignmentExpression", DirectParserASTType.HANDLE, {"token": token});
  }

  void beginBinaryExpression(Token token) {
    seen("BinaryExpression", DirectParserASTType.BEGIN, {"token": token});
  }

  void endBinaryExpression(Token token) {
    seen("BinaryExpression", DirectParserASTType.END, {"token": token});
  }

  void handleEndingBinaryExpression(Token token) {
    seen(
        "EndingBinaryExpression", DirectParserASTType.HANDLE, {"token": token});
  }

  void beginConditionalExpression(Token question) {
    seen("ConditionalExpression", DirectParserASTType.BEGIN,
        {"question": question});
  }

  void handleConditionalExpressionColon() {
    seen("ConditionalExpressionColon", DirectParserASTType.HANDLE, {});
  }

  void endConditionalExpression(Token question, Token colon) {
    seen("ConditionalExpression", DirectParserASTType.END,
        {"question": question, "colon": colon});
  }

  void beginConstExpression(Token constKeyword) {
    seen("ConstExpression", DirectParserASTType.BEGIN,
        {"constKeyword": constKeyword});
  }

  void endConstExpression(Token token) {
    seen("ConstExpression", DirectParserASTType.END, {"token": token});
  }

  void beginForControlFlow(Token awaitToken, Token forToken) {
    seen("ForControlFlow", DirectParserASTType.BEGIN,
        {"awaitToken": awaitToken, "forToken": forToken});
  }

  void endForControlFlow(Token token) {
    seen("ForControlFlow", DirectParserASTType.END, {"token": token});
  }

  void endForInControlFlow(Token token) {
    seen("ForInControlFlow", DirectParserASTType.END, {"token": token});
  }

  void beginIfControlFlow(Token ifToken) {
    seen("IfControlFlow", DirectParserASTType.BEGIN, {"ifToken": ifToken});
  }

  void handleThenControlFlow(Token token) {
    seen("ThenControlFlow", DirectParserASTType.HANDLE, {"token": token});
  }

  void handleElseControlFlow(Token elseToken) {
    seen("ElseControlFlow", DirectParserASTType.HANDLE,
        {"elseToken": elseToken});
  }

  void endIfControlFlow(Token token) {
    seen("IfControlFlow", DirectParserASTType.END, {"token": token});
  }

  void endIfElseControlFlow(Token token) {
    seen("IfElseControlFlow", DirectParserASTType.END, {"token": token});
  }

  void handleSpreadExpression(Token spreadToken) {
    seen("SpreadExpression", DirectParserASTType.HANDLE,
        {"spreadToken": spreadToken});
  }

  void beginFunctionTypedFormalParameter(Token token) {
    seen("FunctionTypedFormalParameter", DirectParserASTType.BEGIN,
        {"token": token});
  }

  void endFunctionTypedFormalParameter(Token nameToken, Token question) {
    seen("FunctionTypedFormalParameter", DirectParserASTType.END,
        {"nameToken": nameToken, "question": question});
  }

  void handleIdentifier(Token token, IdentifierContext context) {
    seen("Identifier", DirectParserASTType.HANDLE,
        {"token": token, "context": context});
  }

  void handleIndexedExpression(
      Token question, Token openSquareBracket, Token closeSquareBracket) {
    seen("IndexedExpression", DirectParserASTType.HANDLE, {
      "question": question,
      "openSquareBracket": openSquareBracket,
      "closeSquareBracket": closeSquareBracket
    });
  }

  void beginIsOperatorType(Token operator) {
    seen("IsOperatorType", DirectParserASTType.BEGIN, {"operator": operator});
  }

  void endIsOperatorType(Token operator) {
    seen("IsOperatorType", DirectParserASTType.END, {"operator": operator});
  }

  void handleIsOperator(Token isOperator, Token not) {
    seen("IsOperator", DirectParserASTType.HANDLE,
        {"isOperator": isOperator, "not": not});
  }

  void handleLiteralBool(Token token) {
    seen("LiteralBool", DirectParserASTType.HANDLE, {"token": token});
  }

  void handleBreakStatement(
      bool hasTarget, Token breakKeyword, Token endToken) {
    seen("BreakStatement", DirectParserASTType.HANDLE, {
      "hasTarget": hasTarget,
      "breakKeyword": breakKeyword,
      "endToken": endToken
    });
  }

  void handleContinueStatement(
      bool hasTarget, Token continueKeyword, Token endToken) {
    seen("ContinueStatement", DirectParserASTType.HANDLE, {
      "hasTarget": hasTarget,
      "continueKeyword": continueKeyword,
      "endToken": endToken
    });
  }

  void handleEmptyStatement(Token token) {
    seen("EmptyStatement", DirectParserASTType.HANDLE, {"token": token});
  }

  void beginAssert(Token assertKeyword, Assert kind) {
    seen("Assert", DirectParserASTType.BEGIN,
        {"assertKeyword": assertKeyword, "kind": kind});
  }

  void endAssert(Token assertKeyword, Assert kind, Token leftParenthesis,
      Token commaToken, Token semicolonToken) {
    seen("Assert", DirectParserASTType.END, {
      "assertKeyword": assertKeyword,
      "kind": kind,
      "leftParenthesis": leftParenthesis,
      "commaToken": commaToken,
      "semicolonToken": semicolonToken
    });
  }

  void handleLiteralDouble(Token token) {
    seen("LiteralDouble", DirectParserASTType.HANDLE, {"token": token});
  }

  void handleLiteralInt(Token token) {
    seen("LiteralInt", DirectParserASTType.HANDLE, {"token": token});
  }

  void handleLiteralList(
      int count, Token leftBracket, Token constKeyword, Token rightBracket) {
    seen("LiteralList", DirectParserASTType.HANDLE, {
      "count": count,
      "leftBracket": leftBracket,
      "constKeyword": constKeyword,
      "rightBracket": rightBracket
    });
  }

  void handleLiteralSetOrMap(
    int count,
    Token leftBrace,
    Token constKeyword,
    Token rightBrace,
    bool hasSetEntry,
  ) {
    seen("LiteralSetOrMap", DirectParserASTType.HANDLE, {
      "count": count,
      "leftBrace": leftBrace,
      "constKeyword": constKeyword,
      "rightBrace": rightBrace,
      "hasSetEntry": hasSetEntry
    });
  }

  void handleLiteralNull(Token token) {
    seen("LiteralNull", DirectParserASTType.HANDLE, {"token": token});
  }

  void handleNativeClause(Token nativeToken, bool hasName) {
    seen("NativeClause", DirectParserASTType.HANDLE,
        {"nativeToken": nativeToken, "hasName": hasName});
  }

  void handleNamedArgument(Token colon) {
    seen("NamedArgument", DirectParserASTType.HANDLE, {"colon": colon});
  }

  void beginNewExpression(Token token) {
    seen("NewExpression", DirectParserASTType.BEGIN, {"token": token});
  }

  void endNewExpression(Token token) {
    seen("NewExpression", DirectParserASTType.END, {"token": token});
  }

  void handleNoArguments(Token token) {
    seen("NoArguments", DirectParserASTType.HANDLE, {"token": token});
  }

  void handleNoConstructorReferenceContinuationAfterTypeArguments(Token token) {
    seen("NoConstructorReferenceContinuationAfterTypeArguments",
        DirectParserASTType.HANDLE, {"token": token});
  }

  void handleNoType(Token lastConsumed) {
    seen("NoType", DirectParserASTType.HANDLE, {"lastConsumed": lastConsumed});
  }

  void handleNoTypeVariables(Token token) {
    seen("NoTypeVariables", DirectParserASTType.HANDLE, {"token": token});
  }

  void handleOperator(Token token) {
    seen("Operator", DirectParserASTType.HANDLE, {"token": token});
  }

  void handleSymbolVoid(Token token) {
    seen("SymbolVoid", DirectParserASTType.HANDLE, {"token": token});
  }

  void handleOperatorName(Token operatorKeyword, Token token) {
    seen("OperatorName", DirectParserASTType.HANDLE,
        {"operatorKeyword": operatorKeyword, "token": token});
  }

  void handleInvalidOperatorName(Token operatorKeyword, Token token) {
    seen("InvalidOperatorName", DirectParserASTType.HANDLE,
        {"operatorKeyword": operatorKeyword, "token": token});
  }

  void handleParenthesizedCondition(Token token) {
    seen(
        "ParenthesizedCondition", DirectParserASTType.HANDLE, {"token": token});
  }

  void handleParenthesizedExpression(Token token) {
    seen("ParenthesizedExpression", DirectParserASTType.HANDLE,
        {"token": token});
  }

  void handleQualified(Token period) {
    seen("Qualified", DirectParserASTType.HANDLE, {"period": period});
  }

  void handleStringPart(Token token) {
    seen("StringPart", DirectParserASTType.HANDLE, {"token": token});
  }

  void handleSuperExpression(Token token, IdentifierContext context) {
    seen("SuperExpression", DirectParserASTType.HANDLE,
        {"token": token, "context": context});
  }

  void beginSwitchCase(int labelCount, int expressionCount, Token firstToken) {
    seen("SwitchCase", DirectParserASTType.BEGIN, {
      "labelCount": labelCount,
      "expressionCount": expressionCount,
      "firstToken": firstToken
    });
  }

  void endSwitchCase(
      int labelCount,
      int expressionCount,
      Token defaultKeyword,
      Token colonAfterDefault,
      int statementCount,
      Token firstToken,
      Token endToken) {
    seen("SwitchCase", DirectParserASTType.END, {
      "labelCount": labelCount,
      "expressionCount": expressionCount,
      "defaultKeyword": defaultKeyword,
      "colonAfterDefault": colonAfterDefault,
      "statementCount": statementCount,
      "firstToken": firstToken,
      "endToken": endToken
    });
  }

  void handleThisExpression(Token token, IdentifierContext context) {
    seen("ThisExpression", DirectParserASTType.HANDLE,
        {"token": token, "context": context});
  }

  void handleUnaryPostfixAssignmentExpression(Token token) {
    seen("UnaryPostfixAssignmentExpression", DirectParserASTType.HANDLE,
        {"token": token});
  }

  void handleUnaryPrefixExpression(Token token) {
    seen("UnaryPrefixExpression", DirectParserASTType.HANDLE, {"token": token});
  }

  void handleUnaryPrefixAssignmentExpression(Token token) {
    seen("UnaryPrefixAssignmentExpression", DirectParserASTType.HANDLE,
        {"token": token});
  }

  void beginFormalParameterDefaultValueExpression() {
    seen(
        "FormalParameterDefaultValueExpression", DirectParserASTType.BEGIN, {});
  }

  void endFormalParameterDefaultValueExpression() {
    seen("FormalParameterDefaultValueExpression", DirectParserASTType.END, {});
  }

  void handleValuedFormalParameter(Token equals, Token token) {
    seen("ValuedFormalParameter", DirectParserASTType.HANDLE,
        {"equals": equals, "token": token});
  }

  void handleFormalParameterWithoutValue(Token token) {
    seen("FormalParameterWithoutValue", DirectParserASTType.HANDLE,
        {"token": token});
  }

  void handleVoidKeyword(Token token) {
    seen("VoidKeyword", DirectParserASTType.HANDLE, {"token": token});
  }

  void handleVoidKeywordWithTypeArguments(Token token) {
    seen("VoidKeywordWithTypeArguments", DirectParserASTType.HANDLE,
        {"token": token});
  }

  void beginYieldStatement(Token token) {
    seen("YieldStatement", DirectParserASTType.BEGIN, {"token": token});
  }

  void endYieldStatement(Token yieldToken, Token starToken, Token endToken) {
    seen("YieldStatement", DirectParserASTType.END, {
      "yieldToken": yieldToken,
      "starToken": starToken,
      "endToken": endToken
    });
  }

  void endInvalidYieldStatement(Token beginToken, Token starToken,
      Token endToken, MessageCode errorCode) {
    seen("InvalidYieldStatement", DirectParserASTType.END, {
      "beginToken": beginToken,
      "starToken": starToken,
      "endToken": endToken,
      "errorCode": errorCode
    });
  }

  void handleRecoverableError(
      Message message, Token startToken, Token endToken) {
    seen("RecoverableError", DirectParserASTType.HANDLE,
        {"message": message, "startToken": startToken, "endToken": endToken});
  }

  void handleErrorToken(ErrorToken token) {
    seen("ErrorToken", DirectParserASTType.HANDLE, {"token": token});
  }

  void handleUnescapeError(
      Message message, Token location, int stringOffset, int length) {
    seen("UnescapeError", DirectParserASTType.HANDLE, {
      "message": message,
      "location": location,
      "stringOffset": stringOffset,
      "length": length
    });
  }

  void handleInvalidStatement(Token token, Message message) {
    seen("InvalidStatement", DirectParserASTType.HANDLE,
        {"token": token, "message": message});
  }

  void handleScript(Token token) {
    seen("Script", DirectParserASTType.HANDLE, {"token": token});
  }

  void handleCommentReferenceText(String referenceSource, int referenceOffset) {
    seen("CommentReferenceText", DirectParserASTType.HANDLE, {
      "referenceSource": referenceSource,
      "referenceOffset": referenceOffset
    });
  }

  void handleCommentReference(
      Token newKeyword, Token prefix, Token period, Token token) {
    seen("CommentReference", DirectParserASTType.HANDLE, {
      "newKeyword": newKeyword,
      "prefix": prefix,
      "period": period,
      "token": token
    });
  }

  void handleNoCommentReference() {
    seen("NoCommentReference", DirectParserASTType.HANDLE, {});
  }
}
