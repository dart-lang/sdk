// Copyright (c) 2020, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

import 'package:_fe_analyzer_shared/src/experiments/flags.dart';
import 'package:_fe_analyzer_shared/src/parser/assert.dart';
import 'package:_fe_analyzer_shared/src/parser/block_kind.dart';
import 'package:_fe_analyzer_shared/src/parser/constructor_reference_context.dart';
import 'package:_fe_analyzer_shared/src/parser/declaration_kind.dart';
import 'package:_fe_analyzer_shared/src/parser/formal_parameter_kind.dart';
import 'package:_fe_analyzer_shared/src/parser/identifier_context.dart';
import 'package:_fe_analyzer_shared/src/parser/listener.dart';
import 'package:_fe_analyzer_shared/src/parser/member_kind.dart';
import 'package:_fe_analyzer_shared/src/scanner/error_token.dart';
import 'package:_fe_analyzer_shared/src/scanner/token.dart';
import 'package:front_end/src/fasta/messages.dart';

// ignore_for_file: lines_longer_than_80_chars

// THIS FILE IS AUTO GENERATED BY
// 'tool/_fasta/parser_ast_helper_creator.dart'
// Run this command to update it:
// 'dart pkg/front_end/tool/_fasta/parser_ast_helper_creator.dart'

abstract class ParserAstNode {
  final String what;
  final ParserAstType type;
  Map<String, Object?> get deprecatedArguments;
  List<ParserAstNode>? children;
  ParserAstNode? parent;

  ParserAstNode(this.what, this.type);

  // TODO(jensj): Compare two ASTs.
}

enum ParserAstType { BEGIN, END, HANDLE }

abstract class AbstractParserAstListener implements Listener {
  List<ParserAstNode> data = [];

  void seen(ParserAstNode entry);

  @override
  void beginArguments(Token token) {
    ArgumentsBegin data = new ArgumentsBegin(ParserAstType.BEGIN, token: token);
    seen(data);
  }

  @override
  void endArguments(int count, Token beginToken, Token endToken) {
    ArgumentsEnd data = new ArgumentsEnd(ParserAstType.END,
        count: count, beginToken: beginToken, endToken: endToken);
    seen(data);
  }

  @override
  void handleObjectPatternFields(int count, Token beginToken, Token endToken) {
    ObjectPatternFieldsHandle data = new ObjectPatternFieldsHandle(
        ParserAstType.HANDLE,
        count: count,
        beginToken: beginToken,
        endToken: endToken);
    seen(data);
  }

  @override
  void handleAsyncModifier(Token? asyncToken, Token? starToken) {
    AsyncModifierHandle data = new AsyncModifierHandle(ParserAstType.HANDLE,
        asyncToken: asyncToken, starToken: starToken);
    seen(data);
  }

  @override
  void beginAwaitExpression(Token token) {
    AwaitExpressionBegin data =
        new AwaitExpressionBegin(ParserAstType.BEGIN, token: token);
    seen(data);
  }

  @override
  void endAwaitExpression(Token beginToken, Token endToken) {
    AwaitExpressionEnd data = new AwaitExpressionEnd(ParserAstType.END,
        beginToken: beginToken, endToken: endToken);
    seen(data);
  }

  @override
  void endInvalidAwaitExpression(
      Token beginToken, Token endToken, MessageCode errorCode) {
    InvalidAwaitExpressionEnd data = new InvalidAwaitExpressionEnd(
        ParserAstType.END,
        beginToken: beginToken,
        endToken: endToken,
        errorCode: errorCode);
    seen(data);
  }

  @override
  void beginBlock(Token token, BlockKind blockKind) {
    BlockBegin data =
        new BlockBegin(ParserAstType.BEGIN, token: token, blockKind: blockKind);
    seen(data);
  }

  @override
  void endBlock(
      int count, Token beginToken, Token endToken, BlockKind blockKind) {
    BlockEnd data = new BlockEnd(ParserAstType.END,
        count: count,
        beginToken: beginToken,
        endToken: endToken,
        blockKind: blockKind);
    seen(data);
  }

  @override
  void handleInvalidTopLevelBlock(Token token) {
    InvalidTopLevelBlockHandle data =
        new InvalidTopLevelBlockHandle(ParserAstType.HANDLE, token: token);
    seen(data);
  }

  @override
  void beginCascade(Token token) {
    CascadeBegin data = new CascadeBegin(ParserAstType.BEGIN, token: token);
    seen(data);
  }

  @override
  void endCascade() {
    CascadeEnd data = new CascadeEnd(ParserAstType.END);
    seen(data);
  }

  @override
  void beginCaseExpression(Token caseKeyword) {
    CaseExpressionBegin data =
        new CaseExpressionBegin(ParserAstType.BEGIN, caseKeyword: caseKeyword);
    seen(data);
  }

  @override
  void endCaseExpression(Token caseKeyword, Token? when, Token colon) {
    CaseExpressionEnd data = new CaseExpressionEnd(ParserAstType.END,
        caseKeyword: caseKeyword, when: when, colon: colon);
    seen(data);
  }

  @override
  void beginClassOrMixinOrExtensionBody(DeclarationKind kind, Token token) {
    ClassOrMixinOrExtensionBodyBegin data =
        new ClassOrMixinOrExtensionBodyBegin(ParserAstType.BEGIN,
            kind: kind, token: token);
    seen(data);
  }

  @override
  void endClassOrMixinOrExtensionBody(
      DeclarationKind kind, int memberCount, Token beginToken, Token endToken) {
    ClassOrMixinOrExtensionBodyEnd data = new ClassOrMixinOrExtensionBodyEnd(
        ParserAstType.END,
        kind: kind,
        memberCount: memberCount,
        beginToken: beginToken,
        endToken: endToken);
    seen(data);
  }

  @override
  void beginClassOrMixinOrNamedMixinApplicationPrelude(Token token) {
    ClassOrMixinOrNamedMixinApplicationPreludeBegin data =
        new ClassOrMixinOrNamedMixinApplicationPreludeBegin(ParserAstType.BEGIN,
            token: token);
    seen(data);
  }

  @override
  void beginClassDeclaration(
      Token begin,
      Token? abstractToken,
      Token? macroToken,
      Token? inlineToken,
      Token? sealedToken,
      Token? baseToken,
      Token? interfaceToken,
      Token? finalToken,
      Token? augmentToken,
      Token? mixinToken,
      Token name) {
    ClassDeclarationBegin data = new ClassDeclarationBegin(ParserAstType.BEGIN,
        begin: begin,
        abstractToken: abstractToken,
        macroToken: macroToken,
        inlineToken: inlineToken,
        sealedToken: sealedToken,
        baseToken: baseToken,
        interfaceToken: interfaceToken,
        finalToken: finalToken,
        augmentToken: augmentToken,
        mixinToken: mixinToken,
        name: name);
    seen(data);
  }

  @override
  void handleClassExtends(Token? extendsKeyword, int typeCount) {
    ClassExtendsHandle data = new ClassExtendsHandle(ParserAstType.HANDLE,
        extendsKeyword: extendsKeyword, typeCount: typeCount);
    seen(data);
  }

  @override
  void handleImplements(Token? implementsKeyword, int interfacesCount) {
    ImplementsHandle data = new ImplementsHandle(ParserAstType.HANDLE,
        implementsKeyword: implementsKeyword, interfacesCount: interfacesCount);
    seen(data);
  }

  @override
  void handleExtensionShowHide(Token? showKeyword, int showElementCount,
      Token? hideKeyword, int hideElementCount) {
    ExtensionShowHideHandle data = new ExtensionShowHideHandle(
        ParserAstType.HANDLE,
        showKeyword: showKeyword,
        showElementCount: showElementCount,
        hideKeyword: hideKeyword,
        hideElementCount: hideElementCount);
    seen(data);
  }

  @override
  void handleClassHeader(Token begin, Token classKeyword, Token? nativeToken) {
    ClassHeaderHandle data = new ClassHeaderHandle(ParserAstType.HANDLE,
        begin: begin, classKeyword: classKeyword, nativeToken: nativeToken);
    seen(data);
  }

  @override
  void handleRecoverClassHeader() {
    RecoverClassHeaderHandle data =
        new RecoverClassHeaderHandle(ParserAstType.HANDLE);
    seen(data);
  }

  @override
  void endClassDeclaration(Token beginToken, Token endToken) {
    ClassDeclarationEnd data = new ClassDeclarationEnd(ParserAstType.END,
        beginToken: beginToken, endToken: endToken);
    seen(data);
  }

  @override
  void beginMixinDeclaration(
      Token? augmentToken,
      Token? sealedToken,
      Token? baseToken,
      Token? interfaceToken,
      Token? finalToken,
      Token mixinKeyword,
      Token name) {
    MixinDeclarationBegin data = new MixinDeclarationBegin(ParserAstType.BEGIN,
        augmentToken: augmentToken,
        sealedToken: sealedToken,
        baseToken: baseToken,
        interfaceToken: interfaceToken,
        finalToken: finalToken,
        mixinKeyword: mixinKeyword,
        name: name);
    seen(data);
  }

  @override
  void handleMixinOn(Token? onKeyword, int typeCount) {
    MixinOnHandle data = new MixinOnHandle(ParserAstType.HANDLE,
        onKeyword: onKeyword, typeCount: typeCount);
    seen(data);
  }

  @override
  void handleMixinHeader(Token mixinKeyword) {
    MixinHeaderHandle data =
        new MixinHeaderHandle(ParserAstType.HANDLE, mixinKeyword: mixinKeyword);
    seen(data);
  }

  @override
  void handleRecoverMixinHeader() {
    RecoverMixinHeaderHandle data =
        new RecoverMixinHeaderHandle(ParserAstType.HANDLE);
    seen(data);
  }

  @override
  void endMixinDeclaration(Token mixinKeyword, Token endToken) {
    MixinDeclarationEnd data = new MixinDeclarationEnd(ParserAstType.END,
        mixinKeyword: mixinKeyword, endToken: endToken);
    seen(data);
  }

  @override
  void beginUncategorizedTopLevelDeclaration(Token token) {
    UncategorizedTopLevelDeclarationBegin data =
        new UncategorizedTopLevelDeclarationBegin(ParserAstType.BEGIN,
            token: token);
    seen(data);
  }

  @override
  void beginExtensionDeclarationPrelude(Token extensionKeyword) {
    ExtensionDeclarationPreludeBegin data =
        new ExtensionDeclarationPreludeBegin(ParserAstType.BEGIN,
            extensionKeyword: extensionKeyword);
    seen(data);
  }

  @override
  void beginExtensionDeclaration(Token extensionKeyword, Token? name) {
    ExtensionDeclarationBegin data = new ExtensionDeclarationBegin(
        ParserAstType.BEGIN,
        extensionKeyword: extensionKeyword,
        name: name);
    seen(data);
  }

  @override
  void endExtensionDeclaration(Token extensionKeyword, Token? typeKeyword,
      Token onKeyword, Token? showKeyword, Token? hideKeyword, Token endToken) {
    ExtensionDeclarationEnd data = new ExtensionDeclarationEnd(
        ParserAstType.END,
        extensionKeyword: extensionKeyword,
        typeKeyword: typeKeyword,
        onKeyword: onKeyword,
        showKeyword: showKeyword,
        hideKeyword: hideKeyword,
        endToken: endToken);
    seen(data);
  }

  @override
  void beginCombinators(Token token) {
    CombinatorsBegin data =
        new CombinatorsBegin(ParserAstType.BEGIN, token: token);
    seen(data);
  }

  @override
  void endCombinators(int count) {
    CombinatorsEnd data = new CombinatorsEnd(ParserAstType.END, count: count);
    seen(data);
  }

  @override
  void beginCompilationUnit(Token token) {
    CompilationUnitBegin data =
        new CompilationUnitBegin(ParserAstType.BEGIN, token: token);
    seen(data);
  }

  @override
  void handleDirectivesOnly() {
    DirectivesOnlyHandle data = new DirectivesOnlyHandle(ParserAstType.HANDLE);
    seen(data);
  }

  @override
  void endCompilationUnit(int count, Token token) {
    CompilationUnitEnd data =
        new CompilationUnitEnd(ParserAstType.END, count: count, token: token);
    seen(data);
  }

  @override
  void beginConstLiteral(Token token) {
    ConstLiteralBegin data =
        new ConstLiteralBegin(ParserAstType.BEGIN, token: token);
    seen(data);
  }

  @override
  void endConstLiteral(Token token) {
    ConstLiteralEnd data = new ConstLiteralEnd(ParserAstType.END, token: token);
    seen(data);
  }

  @override
  void beginConstructorReference(Token start) {
    ConstructorReferenceBegin data =
        new ConstructorReferenceBegin(ParserAstType.BEGIN, start: start);
    seen(data);
  }

  @override
  void endConstructorReference(Token start, Token? periodBeforeName,
      Token endToken, ConstructorReferenceContext constructorReferenceContext) {
    ConstructorReferenceEnd data = new ConstructorReferenceEnd(
        ParserAstType.END,
        start: start,
        periodBeforeName: periodBeforeName,
        endToken: endToken,
        constructorReferenceContext: constructorReferenceContext);
    seen(data);
  }

  @override
  void beginDoWhileStatement(Token token) {
    DoWhileStatementBegin data =
        new DoWhileStatementBegin(ParserAstType.BEGIN, token: token);
    seen(data);
  }

  @override
  void endDoWhileStatement(
      Token doKeyword, Token whileKeyword, Token endToken) {
    DoWhileStatementEnd data = new DoWhileStatementEnd(ParserAstType.END,
        doKeyword: doKeyword, whileKeyword: whileKeyword, endToken: endToken);
    seen(data);
  }

  @override
  void beginDoWhileStatementBody(Token token) {
    DoWhileStatementBodyBegin data =
        new DoWhileStatementBodyBegin(ParserAstType.BEGIN, token: token);
    seen(data);
  }

  @override
  void endDoWhileStatementBody(Token token) {
    DoWhileStatementBodyEnd data =
        new DoWhileStatementBodyEnd(ParserAstType.END, token: token);
    seen(data);
  }

  @override
  void beginWhileStatementBody(Token token) {
    WhileStatementBodyBegin data =
        new WhileStatementBodyBegin(ParserAstType.BEGIN, token: token);
    seen(data);
  }

  @override
  void endWhileStatementBody(Token token) {
    WhileStatementBodyEnd data =
        new WhileStatementBodyEnd(ParserAstType.END, token: token);
    seen(data);
  }

  @override
  void beginEnum(Token enumKeyword) {
    EnumBegin data =
        new EnumBegin(ParserAstType.BEGIN, enumKeyword: enumKeyword);
    seen(data);
  }

  @override
  void endEnum(Token enumKeyword, Token leftBrace, int memberCount) {
    EnumEnd data = new EnumEnd(ParserAstType.END,
        enumKeyword: enumKeyword,
        leftBrace: leftBrace,
        memberCount: memberCount);
    seen(data);
  }

  @override
  void endEnumConstructor(Token? getOrSet, Token beginToken, Token beginParam,
      Token? beginInitializers, Token endToken) {
    EnumConstructorEnd data = new EnumConstructorEnd(ParserAstType.END,
        getOrSet: getOrSet,
        beginToken: beginToken,
        beginParam: beginParam,
        beginInitializers: beginInitializers,
        endToken: endToken);
    seen(data);
  }

  @override
  void handleEnumElements(Token elementsEndToken, int elementsCount) {
    EnumElementsHandle data = new EnumElementsHandle(ParserAstType.HANDLE,
        elementsEndToken: elementsEndToken, elementsCount: elementsCount);
    seen(data);
  }

  @override
  void handleEnumHeader(Token enumKeyword, Token leftBrace) {
    EnumHeaderHandle data = new EnumHeaderHandle(ParserAstType.HANDLE,
        enumKeyword: enumKeyword, leftBrace: leftBrace);
    seen(data);
  }

  @override
  void handleEnumElement(Token beginToken) {
    EnumElementHandle data =
        new EnumElementHandle(ParserAstType.HANDLE, beginToken: beginToken);
    seen(data);
  }

  @override
  void endEnumFactoryMethod(
      Token beginToken, Token factoryKeyword, Token endToken) {
    EnumFactoryMethodEnd data = new EnumFactoryMethodEnd(ParserAstType.END,
        beginToken: beginToken,
        factoryKeyword: factoryKeyword,
        endToken: endToken);
    seen(data);
  }

  @override
  void beginExport(Token token) {
    ExportBegin data = new ExportBegin(ParserAstType.BEGIN, token: token);
    seen(data);
  }

  @override
  void endExport(Token exportKeyword, Token semicolon) {
    ExportEnd data = new ExportEnd(ParserAstType.END,
        exportKeyword: exportKeyword, semicolon: semicolon);
    seen(data);
  }

  @override
  void handleExtraneousExpression(Token token, Message message) {
    ExtraneousExpressionHandle data = new ExtraneousExpressionHandle(
        ParserAstType.HANDLE,
        token: token,
        message: message);
    seen(data);
  }

  @override
  void handleExpressionStatement(Token token) {
    ExpressionStatementHandle data =
        new ExpressionStatementHandle(ParserAstType.HANDLE, token: token);
    seen(data);
  }

  @override
  void beginFactoryMethod(DeclarationKind declarationKind, Token lastConsumed,
      Token? externalToken, Token? constToken) {
    FactoryMethodBegin data = new FactoryMethodBegin(ParserAstType.BEGIN,
        declarationKind: declarationKind,
        lastConsumed: lastConsumed,
        externalToken: externalToken,
        constToken: constToken);
    seen(data);
  }

  @override
  void endClassFactoryMethod(
      Token beginToken, Token factoryKeyword, Token endToken) {
    ClassFactoryMethodEnd data = new ClassFactoryMethodEnd(ParserAstType.END,
        beginToken: beginToken,
        factoryKeyword: factoryKeyword,
        endToken: endToken);
    seen(data);
  }

  @override
  void endMixinFactoryMethod(
      Token beginToken, Token factoryKeyword, Token endToken) {
    MixinFactoryMethodEnd data = new MixinFactoryMethodEnd(ParserAstType.END,
        beginToken: beginToken,
        factoryKeyword: factoryKeyword,
        endToken: endToken);
    seen(data);
  }

  @override
  void endExtensionFactoryMethod(
      Token beginToken, Token factoryKeyword, Token endToken) {
    ExtensionFactoryMethodEnd data = new ExtensionFactoryMethodEnd(
        ParserAstType.END,
        beginToken: beginToken,
        factoryKeyword: factoryKeyword,
        endToken: endToken);
    seen(data);
  }

  @override
  void beginFormalParameter(Token token, MemberKind kind, Token? requiredToken,
      Token? covariantToken, Token? varFinalOrConst) {
    FormalParameterBegin data = new FormalParameterBegin(ParserAstType.BEGIN,
        token: token,
        kind: kind,
        requiredToken: requiredToken,
        covariantToken: covariantToken,
        varFinalOrConst: varFinalOrConst);
    seen(data);
  }

  @override
  void endFormalParameter(
      Token? thisKeyword,
      Token? superKeyword,
      Token? periodAfterThisOrSuper,
      Token nameToken,
      Token? initializerStart,
      Token? initializerEnd,
      FormalParameterKind kind,
      MemberKind memberKind) {
    FormalParameterEnd data = new FormalParameterEnd(ParserAstType.END,
        thisKeyword: thisKeyword,
        superKeyword: superKeyword,
        periodAfterThisOrSuper: periodAfterThisOrSuper,
        nameToken: nameToken,
        initializerStart: initializerStart,
        initializerEnd: initializerEnd,
        kind: kind,
        memberKind: memberKind);
    seen(data);
  }

  @override
  void handleNoFormalParameters(Token token, MemberKind kind) {
    NoFormalParametersHandle data = new NoFormalParametersHandle(
        ParserAstType.HANDLE,
        token: token,
        kind: kind);
    seen(data);
  }

  @override
  void beginFormalParameters(Token token, MemberKind kind) {
    FormalParametersBegin data = new FormalParametersBegin(ParserAstType.BEGIN,
        token: token, kind: kind);
    seen(data);
  }

  @override
  void endFormalParameters(
      int count, Token beginToken, Token endToken, MemberKind kind) {
    FormalParametersEnd data = new FormalParametersEnd(ParserAstType.END,
        count: count, beginToken: beginToken, endToken: endToken, kind: kind);
    seen(data);
  }

  @override
  void endClassFields(
      Token? abstractToken,
      Token? augmentToken,
      Token? externalToken,
      Token? staticToken,
      Token? covariantToken,
      Token? lateToken,
      Token? varFinalOrConst,
      int count,
      Token beginToken,
      Token endToken) {
    ClassFieldsEnd data = new ClassFieldsEnd(ParserAstType.END,
        abstractToken: abstractToken,
        augmentToken: augmentToken,
        externalToken: externalToken,
        staticToken: staticToken,
        covariantToken: covariantToken,
        lateToken: lateToken,
        varFinalOrConst: varFinalOrConst,
        count: count,
        beginToken: beginToken,
        endToken: endToken);
    seen(data);
  }

  @override
  void endMixinFields(
      Token? abstractToken,
      Token? augmentToken,
      Token? externalToken,
      Token? staticToken,
      Token? covariantToken,
      Token? lateToken,
      Token? varFinalOrConst,
      int count,
      Token beginToken,
      Token endToken) {
    MixinFieldsEnd data = new MixinFieldsEnd(ParserAstType.END,
        abstractToken: abstractToken,
        augmentToken: augmentToken,
        externalToken: externalToken,
        staticToken: staticToken,
        covariantToken: covariantToken,
        lateToken: lateToken,
        varFinalOrConst: varFinalOrConst,
        count: count,
        beginToken: beginToken,
        endToken: endToken);
    seen(data);
  }

  @override
  void endExtensionFields(
      Token? abstractToken,
      Token? augmentToken,
      Token? externalToken,
      Token? staticToken,
      Token? covariantToken,
      Token? lateToken,
      Token? varFinalOrConst,
      int count,
      Token beginToken,
      Token endToken) {
    ExtensionFieldsEnd data = new ExtensionFieldsEnd(ParserAstType.END,
        abstractToken: abstractToken,
        augmentToken: augmentToken,
        externalToken: externalToken,
        staticToken: staticToken,
        covariantToken: covariantToken,
        lateToken: lateToken,
        varFinalOrConst: varFinalOrConst,
        count: count,
        beginToken: beginToken,
        endToken: endToken);
    seen(data);
  }

  @override
  void endEnumFields(
      Token? abstractToken,
      Token? augmentToken,
      Token? externalToken,
      Token? staticToken,
      Token? covariantToken,
      Token? lateToken,
      Token? varFinalOrConst,
      int count,
      Token beginToken,
      Token endToken) {
    EnumFieldsEnd data = new EnumFieldsEnd(ParserAstType.END,
        abstractToken: abstractToken,
        augmentToken: augmentToken,
        externalToken: externalToken,
        staticToken: staticToken,
        covariantToken: covariantToken,
        lateToken: lateToken,
        varFinalOrConst: varFinalOrConst,
        count: count,
        beginToken: beginToken,
        endToken: endToken);
    seen(data);
  }

  @override
  void endEnumMethod(Token? getOrSet, Token beginToken, Token beginParam,
      Token? beginInitializers, Token endToken) {
    EnumMethodEnd data = new EnumMethodEnd(ParserAstType.END,
        getOrSet: getOrSet,
        beginToken: beginToken,
        beginParam: beginParam,
        beginInitializers: beginInitializers,
        endToken: endToken);
    seen(data);
  }

  @override
  void handleForInitializerEmptyStatement(Token token) {
    ForInitializerEmptyStatementHandle data =
        new ForInitializerEmptyStatementHandle(ParserAstType.HANDLE,
            token: token);
    seen(data);
  }

  @override
  void handleForInitializerExpressionStatement(Token token, bool forIn) {
    ForInitializerExpressionStatementHandle data =
        new ForInitializerExpressionStatementHandle(ParserAstType.HANDLE,
            token: token, forIn: forIn);
    seen(data);
  }

  @override
  void handleForInitializerLocalVariableDeclaration(Token token, bool forIn) {
    ForInitializerLocalVariableDeclarationHandle data =
        new ForInitializerLocalVariableDeclarationHandle(ParserAstType.HANDLE,
            token: token, forIn: forIn);
    seen(data);
  }

  @override
  void handleForInitializerPatternVariableAssignment(
      Token keyword, Token equals) {
    ForInitializerPatternVariableAssignmentHandle data =
        new ForInitializerPatternVariableAssignmentHandle(ParserAstType.HANDLE,
            keyword: keyword, equals: equals);
    seen(data);
  }

  @override
  void beginForStatement(Token token) {
    ForStatementBegin data =
        new ForStatementBegin(ParserAstType.BEGIN, token: token);
    seen(data);
  }

  @override
  void handleForLoopParts(Token forKeyword, Token leftParen,
      Token leftSeparator, int updateExpressionCount) {
    ForLoopPartsHandle data = new ForLoopPartsHandle(ParserAstType.HANDLE,
        forKeyword: forKeyword,
        leftParen: leftParen,
        leftSeparator: leftSeparator,
        updateExpressionCount: updateExpressionCount);
    seen(data);
  }

  @override
  void endForStatement(Token endToken) {
    ForStatementEnd data =
        new ForStatementEnd(ParserAstType.END, endToken: endToken);
    seen(data);
  }

  @override
  void beginForStatementBody(Token token) {
    ForStatementBodyBegin data =
        new ForStatementBodyBegin(ParserAstType.BEGIN, token: token);
    seen(data);
  }

  @override
  void endForStatementBody(Token token) {
    ForStatementBodyEnd data =
        new ForStatementBodyEnd(ParserAstType.END, token: token);
    seen(data);
  }

  @override
  void handleForInLoopParts(Token? awaitToken, Token forToken,
      Token leftParenthesis, Token? patternKeyword, Token inKeyword) {
    ForInLoopPartsHandle data = new ForInLoopPartsHandle(ParserAstType.HANDLE,
        awaitToken: awaitToken,
        forToken: forToken,
        leftParenthesis: leftParenthesis,
        patternKeyword: patternKeyword,
        inKeyword: inKeyword);
    seen(data);
  }

  @override
  void endForIn(Token endToken) {
    ForInEnd data = new ForInEnd(ParserAstType.END, endToken: endToken);
    seen(data);
  }

  @override
  void beginForInExpression(Token token) {
    ForInExpressionBegin data =
        new ForInExpressionBegin(ParserAstType.BEGIN, token: token);
    seen(data);
  }

  @override
  void endForInExpression(Token token) {
    ForInExpressionEnd data =
        new ForInExpressionEnd(ParserAstType.END, token: token);
    seen(data);
  }

  @override
  void beginForInBody(Token token) {
    ForInBodyBegin data = new ForInBodyBegin(ParserAstType.BEGIN, token: token);
    seen(data);
  }

  @override
  void endForInBody(Token token) {
    ForInBodyEnd data = new ForInBodyEnd(ParserAstType.END, token: token);
    seen(data);
  }

  @override
  void beginNamedFunctionExpression(Token token) {
    NamedFunctionExpressionBegin data =
        new NamedFunctionExpressionBegin(ParserAstType.BEGIN, token: token);
    seen(data);
  }

  @override
  void endNamedFunctionExpression(Token endToken) {
    NamedFunctionExpressionEnd data =
        new NamedFunctionExpressionEnd(ParserAstType.END, endToken: endToken);
    seen(data);
  }

  @override
  void beginLocalFunctionDeclaration(Token token) {
    LocalFunctionDeclarationBegin data =
        new LocalFunctionDeclarationBegin(ParserAstType.BEGIN, token: token);
    seen(data);
  }

  @override
  void endLocalFunctionDeclaration(Token endToken) {
    LocalFunctionDeclarationEnd data =
        new LocalFunctionDeclarationEnd(ParserAstType.END, endToken: endToken);
    seen(data);
  }

  @override
  void beginBlockFunctionBody(Token token) {
    BlockFunctionBodyBegin data =
        new BlockFunctionBodyBegin(ParserAstType.BEGIN, token: token);
    seen(data);
  }

  @override
  void endBlockFunctionBody(int count, Token beginToken, Token endToken) {
    BlockFunctionBodyEnd data = new BlockFunctionBodyEnd(ParserAstType.END,
        count: count, beginToken: beginToken, endToken: endToken);
    seen(data);
  }

  @override
  void handleNoFunctionBody(Token token) {
    NoFunctionBodyHandle data =
        new NoFunctionBodyHandle(ParserAstType.HANDLE, token: token);
    seen(data);
  }

  @override
  void handleFunctionBodySkipped(Token token, bool isExpressionBody) {
    FunctionBodySkippedHandle data = new FunctionBodySkippedHandle(
        ParserAstType.HANDLE,
        token: token,
        isExpressionBody: isExpressionBody);
    seen(data);
  }

  @override
  void beginFunctionName(Token token) {
    FunctionNameBegin data =
        new FunctionNameBegin(ParserAstType.BEGIN, token: token);
    seen(data);
  }

  @override
  void endFunctionName(Token beginToken, Token token) {
    FunctionNameEnd data = new FunctionNameEnd(ParserAstType.END,
        beginToken: beginToken, token: token);
    seen(data);
  }

  @override
  void beginTypedef(Token token) {
    TypedefBegin data = new TypedefBegin(ParserAstType.BEGIN, token: token);
    seen(data);
  }

  @override
  void endTypedef(Token typedefKeyword, Token? equals, Token endToken) {
    TypedefEnd data = new TypedefEnd(ParserAstType.END,
        typedefKeyword: typedefKeyword, equals: equals, endToken: endToken);
    seen(data);
  }

  @override
  void handleClassWithClause(Token withKeyword) {
    ClassWithClauseHandle data = new ClassWithClauseHandle(ParserAstType.HANDLE,
        withKeyword: withKeyword);
    seen(data);
  }

  @override
  void handleClassNoWithClause() {
    ClassNoWithClauseHandle data =
        new ClassNoWithClauseHandle(ParserAstType.HANDLE);
    seen(data);
  }

  @override
  void handleEnumWithClause(Token withKeyword) {
    EnumWithClauseHandle data = new EnumWithClauseHandle(ParserAstType.HANDLE,
        withKeyword: withKeyword);
    seen(data);
  }

  @override
  void handleEnumNoWithClause() {
    EnumNoWithClauseHandle data =
        new EnumNoWithClauseHandle(ParserAstType.HANDLE);
    seen(data);
  }

  @override
  void beginNamedMixinApplication(
      Token begin,
      Token? abstractToken,
      Token? macroToken,
      Token? inlineToken,
      Token? sealedToken,
      Token? baseToken,
      Token? interfaceToken,
      Token? finalToken,
      Token? augmentToken,
      Token? mixinToken,
      Token name) {
    NamedMixinApplicationBegin data = new NamedMixinApplicationBegin(
        ParserAstType.BEGIN,
        begin: begin,
        abstractToken: abstractToken,
        macroToken: macroToken,
        inlineToken: inlineToken,
        sealedToken: sealedToken,
        baseToken: baseToken,
        interfaceToken: interfaceToken,
        finalToken: finalToken,
        augmentToken: augmentToken,
        mixinToken: mixinToken,
        name: name);
    seen(data);
  }

  @override
  void handleNamedMixinApplicationWithClause(Token withKeyword) {
    NamedMixinApplicationWithClauseHandle data =
        new NamedMixinApplicationWithClauseHandle(ParserAstType.HANDLE,
            withKeyword: withKeyword);
    seen(data);
  }

  @override
  void endNamedMixinApplication(Token begin, Token classKeyword, Token equals,
      Token? implementsKeyword, Token endToken) {
    NamedMixinApplicationEnd data = new NamedMixinApplicationEnd(
        ParserAstType.END,
        begin: begin,
        classKeyword: classKeyword,
        equals: equals,
        implementsKeyword: implementsKeyword,
        endToken: endToken);
    seen(data);
  }

  @override
  void beginHide(Token hideKeyword) {
    HideBegin data =
        new HideBegin(ParserAstType.BEGIN, hideKeyword: hideKeyword);
    seen(data);
  }

  @override
  void endHide(Token hideKeyword) {
    HideEnd data = new HideEnd(ParserAstType.END, hideKeyword: hideKeyword);
    seen(data);
  }

  @override
  void handleIdentifierList(int count) {
    IdentifierListHandle data =
        new IdentifierListHandle(ParserAstType.HANDLE, count: count);
    seen(data);
  }

  @override
  void beginTypeList(Token token) {
    TypeListBegin data = new TypeListBegin(ParserAstType.BEGIN, token: token);
    seen(data);
  }

  @override
  void endTypeList(int count) {
    TypeListEnd data = new TypeListEnd(ParserAstType.END, count: count);
    seen(data);
  }

  @override
  void beginIfStatement(Token token) {
    IfStatementBegin data =
        new IfStatementBegin(ParserAstType.BEGIN, token: token);
    seen(data);
  }

  @override
  void endIfStatement(Token ifToken, Token? elseToken) {
    IfStatementEnd data = new IfStatementEnd(ParserAstType.END,
        ifToken: ifToken, elseToken: elseToken);
    seen(data);
  }

  @override
  void beginThenStatement(Token token) {
    ThenStatementBegin data =
        new ThenStatementBegin(ParserAstType.BEGIN, token: token);
    seen(data);
  }

  @override
  void endThenStatement(Token token) {
    ThenStatementEnd data =
        new ThenStatementEnd(ParserAstType.END, token: token);
    seen(data);
  }

  @override
  void beginElseStatement(Token token) {
    ElseStatementBegin data =
        new ElseStatementBegin(ParserAstType.BEGIN, token: token);
    seen(data);
  }

  @override
  void endElseStatement(Token token) {
    ElseStatementEnd data =
        new ElseStatementEnd(ParserAstType.END, token: token);
    seen(data);
  }

  @override
  void beginImport(Token importKeyword) {
    ImportBegin data =
        new ImportBegin(ParserAstType.BEGIN, importKeyword: importKeyword);
    seen(data);
  }

  @override
  void handleImportPrefix(Token? deferredKeyword, Token? asKeyword) {
    ImportPrefixHandle data = new ImportPrefixHandle(ParserAstType.HANDLE,
        deferredKeyword: deferredKeyword, asKeyword: asKeyword);
    seen(data);
  }

  @override
  void endImport(Token importKeyword, Token? augmentToken, Token? semicolon) {
    ImportEnd data = new ImportEnd(ParserAstType.END,
        importKeyword: importKeyword,
        augmentToken: augmentToken,
        semicolon: semicolon);
    seen(data);
  }

  @override
  void handleRecoverImport(Token? semicolon) {
    RecoverImportHandle data =
        new RecoverImportHandle(ParserAstType.HANDLE, semicolon: semicolon);
    seen(data);
  }

  @override
  void beginConditionalUris(Token token) {
    ConditionalUrisBegin data =
        new ConditionalUrisBegin(ParserAstType.BEGIN, token: token);
    seen(data);
  }

  @override
  void endConditionalUris(int count) {
    ConditionalUrisEnd data =
        new ConditionalUrisEnd(ParserAstType.END, count: count);
    seen(data);
  }

  @override
  void beginConditionalUri(Token ifKeyword) {
    ConditionalUriBegin data =
        new ConditionalUriBegin(ParserAstType.BEGIN, ifKeyword: ifKeyword);
    seen(data);
  }

  @override
  void endConditionalUri(Token ifKeyword, Token leftParen, Token? equalSign) {
    ConditionalUriEnd data = new ConditionalUriEnd(ParserAstType.END,
        ifKeyword: ifKeyword, leftParen: leftParen, equalSign: equalSign);
    seen(data);
  }

  @override
  void handleDottedName(int count, Token firstIdentifier) {
    DottedNameHandle data = new DottedNameHandle(ParserAstType.HANDLE,
        count: count, firstIdentifier: firstIdentifier);
    seen(data);
  }

  @override
  void beginImplicitCreationExpression(Token token) {
    ImplicitCreationExpressionBegin data =
        new ImplicitCreationExpressionBegin(ParserAstType.BEGIN, token: token);
    seen(data);
  }

  @override
  void endImplicitCreationExpression(Token token, Token openAngleBracket) {
    ImplicitCreationExpressionEnd data = new ImplicitCreationExpressionEnd(
        ParserAstType.END,
        token: token,
        openAngleBracket: openAngleBracket);
    seen(data);
  }

  @override
  void beginInitializedIdentifier(Token token) {
    InitializedIdentifierBegin data =
        new InitializedIdentifierBegin(ParserAstType.BEGIN, token: token);
    seen(data);
  }

  @override
  void endInitializedIdentifier(Token nameToken) {
    InitializedIdentifierEnd data =
        new InitializedIdentifierEnd(ParserAstType.END, nameToken: nameToken);
    seen(data);
  }

  @override
  void beginFieldInitializer(Token token) {
    FieldInitializerBegin data =
        new FieldInitializerBegin(ParserAstType.BEGIN, token: token);
    seen(data);
  }

  @override
  void endFieldInitializer(Token assignment, Token token) {
    FieldInitializerEnd data = new FieldInitializerEnd(ParserAstType.END,
        assignment: assignment, token: token);
    seen(data);
  }

  @override
  void handleNoFieldInitializer(Token token) {
    NoFieldInitializerHandle data =
        new NoFieldInitializerHandle(ParserAstType.HANDLE, token: token);
    seen(data);
  }

  @override
  void beginVariableInitializer(Token token) {
    VariableInitializerBegin data =
        new VariableInitializerBegin(ParserAstType.BEGIN, token: token);
    seen(data);
  }

  @override
  void endVariableInitializer(Token assignmentOperator) {
    VariableInitializerEnd data = new VariableInitializerEnd(ParserAstType.END,
        assignmentOperator: assignmentOperator);
    seen(data);
  }

  @override
  void handleNoVariableInitializer(Token token) {
    NoVariableInitializerHandle data =
        new NoVariableInitializerHandle(ParserAstType.HANDLE, token: token);
    seen(data);
  }

  @override
  void beginInitializer(Token token) {
    InitializerBegin data =
        new InitializerBegin(ParserAstType.BEGIN, token: token);
    seen(data);
  }

  @override
  void endInitializer(Token token) {
    InitializerEnd data = new InitializerEnd(ParserAstType.END, token: token);
    seen(data);
  }

  @override
  void beginInitializers(Token token) {
    InitializersBegin data =
        new InitializersBegin(ParserAstType.BEGIN, token: token);
    seen(data);
  }

  @override
  void endInitializers(int count, Token beginToken, Token endToken) {
    InitializersEnd data = new InitializersEnd(ParserAstType.END,
        count: count, beginToken: beginToken, endToken: endToken);
    seen(data);
  }

  @override
  void handleNoInitializers() {
    NoInitializersHandle data = new NoInitializersHandle(ParserAstType.HANDLE);
    seen(data);
  }

  @override
  void handleInvalidExpression(Token token) {
    InvalidExpressionHandle data =
        new InvalidExpressionHandle(ParserAstType.HANDLE, token: token);
    seen(data);
  }

  @override
  void handleInvalidFunctionBody(Token token) {
    InvalidFunctionBodyHandle data =
        new InvalidFunctionBodyHandle(ParserAstType.HANDLE, token: token);
    seen(data);
  }

  @override
  void handleInvalidTypeReference(Token token) {
    InvalidTypeReferenceHandle data =
        new InvalidTypeReferenceHandle(ParserAstType.HANDLE, token: token);
    seen(data);
  }

  @override
  void handleLabel(Token token) {
    LabelHandle data = new LabelHandle(ParserAstType.HANDLE, token: token);
    seen(data);
  }

  @override
  void beginLabeledStatement(Token token, int labelCount) {
    LabeledStatementBegin data = new LabeledStatementBegin(ParserAstType.BEGIN,
        token: token, labelCount: labelCount);
    seen(data);
  }

  @override
  void endLabeledStatement(int labelCount) {
    LabeledStatementEnd data =
        new LabeledStatementEnd(ParserAstType.END, labelCount: labelCount);
    seen(data);
  }

  @override
  void beginLibraryAugmentation(Token libraryKeyword, Token augmentKeyword) {
    LibraryAugmentationBegin data = new LibraryAugmentationBegin(
        ParserAstType.BEGIN,
        libraryKeyword: libraryKeyword,
        augmentKeyword: augmentKeyword);
    seen(data);
  }

  @override
  void endLibraryAugmentation(
      Token libraryKeyword, Token augmentKeyword, Token semicolon) {
    LibraryAugmentationEnd data = new LibraryAugmentationEnd(ParserAstType.END,
        libraryKeyword: libraryKeyword,
        augmentKeyword: augmentKeyword,
        semicolon: semicolon);
    seen(data);
  }

  @override
  void beginLibraryName(Token token) {
    LibraryNameBegin data =
        new LibraryNameBegin(ParserAstType.BEGIN, token: token);
    seen(data);
  }

  @override
  void endLibraryName(Token libraryKeyword, Token semicolon, bool hasName) {
    LibraryNameEnd data = new LibraryNameEnd(ParserAstType.END,
        libraryKeyword: libraryKeyword, semicolon: semicolon, hasName: hasName);
    seen(data);
  }

  @override
  void handleLiteralMapEntry(Token colon, Token endToken) {
    LiteralMapEntryHandle data = new LiteralMapEntryHandle(ParserAstType.HANDLE,
        colon: colon, endToken: endToken);
    seen(data);
  }

  @override
  void handleMapPatternEntry(Token colon, Token endToken) {
    MapPatternEntryHandle data = new MapPatternEntryHandle(ParserAstType.HANDLE,
        colon: colon, endToken: endToken);
    seen(data);
  }

  @override
  void beginLiteralString(Token token) {
    LiteralStringBegin data =
        new LiteralStringBegin(ParserAstType.BEGIN, token: token);
    seen(data);
  }

  @override
  void handleInterpolationExpression(Token leftBracket, Token? rightBracket) {
    InterpolationExpressionHandle data = new InterpolationExpressionHandle(
        ParserAstType.HANDLE,
        leftBracket: leftBracket,
        rightBracket: rightBracket);
    seen(data);
  }

  @override
  void endLiteralString(int interpolationCount, Token endToken) {
    LiteralStringEnd data = new LiteralStringEnd(ParserAstType.END,
        interpolationCount: interpolationCount, endToken: endToken);
    seen(data);
  }

  @override
  void handleStringJuxtaposition(Token startToken, int literalCount) {
    StringJuxtapositionHandle data = new StringJuxtapositionHandle(
        ParserAstType.HANDLE,
        startToken: startToken,
        literalCount: literalCount);
    seen(data);
  }

  @override
  void beginMember() {
    MemberBegin data = new MemberBegin(ParserAstType.BEGIN);
    seen(data);
  }

  @override
  void handleInvalidMember(Token endToken) {
    InvalidMemberHandle data =
        new InvalidMemberHandle(ParserAstType.HANDLE, endToken: endToken);
    seen(data);
  }

  @override
  void endMember() {
    MemberEnd data = new MemberEnd(ParserAstType.END);
    seen(data);
  }

  @override
  void beginMethod(
      DeclarationKind declarationKind,
      Token? augmentToken,
      Token? externalToken,
      Token? staticToken,
      Token? covariantToken,
      Token? varFinalOrConst,
      Token? getOrSet,
      Token name) {
    MethodBegin data = new MethodBegin(ParserAstType.BEGIN,
        declarationKind: declarationKind,
        augmentToken: augmentToken,
        externalToken: externalToken,
        staticToken: staticToken,
        covariantToken: covariantToken,
        varFinalOrConst: varFinalOrConst,
        getOrSet: getOrSet,
        name: name);
    seen(data);
  }

  @override
  void endClassMethod(Token? getOrSet, Token beginToken, Token beginParam,
      Token? beginInitializers, Token endToken) {
    ClassMethodEnd data = new ClassMethodEnd(ParserAstType.END,
        getOrSet: getOrSet,
        beginToken: beginToken,
        beginParam: beginParam,
        beginInitializers: beginInitializers,
        endToken: endToken);
    seen(data);
  }

  @override
  void endMixinMethod(Token? getOrSet, Token beginToken, Token beginParam,
      Token? beginInitializers, Token endToken) {
    MixinMethodEnd data = new MixinMethodEnd(ParserAstType.END,
        getOrSet: getOrSet,
        beginToken: beginToken,
        beginParam: beginParam,
        beginInitializers: beginInitializers,
        endToken: endToken);
    seen(data);
  }

  @override
  void endExtensionMethod(Token? getOrSet, Token beginToken, Token beginParam,
      Token? beginInitializers, Token endToken) {
    ExtensionMethodEnd data = new ExtensionMethodEnd(ParserAstType.END,
        getOrSet: getOrSet,
        beginToken: beginToken,
        beginParam: beginParam,
        beginInitializers: beginInitializers,
        endToken: endToken);
    seen(data);
  }

  @override
  void endClassConstructor(Token? getOrSet, Token beginToken, Token beginParam,
      Token? beginInitializers, Token endToken) {
    ClassConstructorEnd data = new ClassConstructorEnd(ParserAstType.END,
        getOrSet: getOrSet,
        beginToken: beginToken,
        beginParam: beginParam,
        beginInitializers: beginInitializers,
        endToken: endToken);
    seen(data);
  }

  @override
  void endMixinConstructor(Token? getOrSet, Token beginToken, Token beginParam,
      Token? beginInitializers, Token endToken) {
    MixinConstructorEnd data = new MixinConstructorEnd(ParserAstType.END,
        getOrSet: getOrSet,
        beginToken: beginToken,
        beginParam: beginParam,
        beginInitializers: beginInitializers,
        endToken: endToken);
    seen(data);
  }

  @override
  void endExtensionConstructor(Token? getOrSet, Token beginToken,
      Token beginParam, Token? beginInitializers, Token endToken) {
    ExtensionConstructorEnd data = new ExtensionConstructorEnd(
        ParserAstType.END,
        getOrSet: getOrSet,
        beginToken: beginToken,
        beginParam: beginParam,
        beginInitializers: beginInitializers,
        endToken: endToken);
    seen(data);
  }

  @override
  void beginMetadataStar(Token token) {
    MetadataStarBegin data =
        new MetadataStarBegin(ParserAstType.BEGIN, token: token);
    seen(data);
  }

  @override
  void endMetadataStar(int count) {
    MetadataStarEnd data = new MetadataStarEnd(ParserAstType.END, count: count);
    seen(data);
  }

  @override
  void beginMetadata(Token token) {
    MetadataBegin data = new MetadataBegin(ParserAstType.BEGIN, token: token);
    seen(data);
  }

  @override
  void endMetadata(Token beginToken, Token? periodBeforeName, Token endToken) {
    MetadataEnd data = new MetadataEnd(ParserAstType.END,
        beginToken: beginToken,
        periodBeforeName: periodBeforeName,
        endToken: endToken);
    seen(data);
  }

  @override
  void beginOptionalFormalParameters(Token token) {
    OptionalFormalParametersBegin data =
        new OptionalFormalParametersBegin(ParserAstType.BEGIN, token: token);
    seen(data);
  }

  @override
  void endOptionalFormalParameters(
      int count, Token beginToken, Token endToken) {
    OptionalFormalParametersEnd data = new OptionalFormalParametersEnd(
        ParserAstType.END,
        count: count,
        beginToken: beginToken,
        endToken: endToken);
    seen(data);
  }

  @override
  void beginPart(Token token) {
    PartBegin data = new PartBegin(ParserAstType.BEGIN, token: token);
    seen(data);
  }

  @override
  void endPart(Token partKeyword, Token semicolon) {
    PartEnd data = new PartEnd(ParserAstType.END,
        partKeyword: partKeyword, semicolon: semicolon);
    seen(data);
  }

  @override
  void beginPartOf(Token token) {
    PartOfBegin data = new PartOfBegin(ParserAstType.BEGIN, token: token);
    seen(data);
  }

  @override
  void endPartOf(
      Token partKeyword, Token ofKeyword, Token semicolon, bool hasName) {
    PartOfEnd data = new PartOfEnd(ParserAstType.END,
        partKeyword: partKeyword,
        ofKeyword: ofKeyword,
        semicolon: semicolon,
        hasName: hasName);
    seen(data);
  }

  @override
  void beginRedirectingFactoryBody(Token token) {
    RedirectingFactoryBodyBegin data =
        new RedirectingFactoryBodyBegin(ParserAstType.BEGIN, token: token);
    seen(data);
  }

  @override
  void endRedirectingFactoryBody(Token beginToken, Token endToken) {
    RedirectingFactoryBodyEnd data = new RedirectingFactoryBodyEnd(
        ParserAstType.END,
        beginToken: beginToken,
        endToken: endToken);
    seen(data);
  }

  @override
  void beginReturnStatement(Token token) {
    ReturnStatementBegin data =
        new ReturnStatementBegin(ParserAstType.BEGIN, token: token);
    seen(data);
  }

  @override
  void handleNativeFunctionBody(Token nativeToken, Token semicolon) {
    NativeFunctionBodyHandle data = new NativeFunctionBodyHandle(
        ParserAstType.HANDLE,
        nativeToken: nativeToken,
        semicolon: semicolon);
    seen(data);
  }

  @override
  void handleNativeFunctionBodyIgnored(Token nativeToken, Token semicolon) {
    NativeFunctionBodyIgnoredHandle data = new NativeFunctionBodyIgnoredHandle(
        ParserAstType.HANDLE,
        nativeToken: nativeToken,
        semicolon: semicolon);
    seen(data);
  }

  @override
  void handleNativeFunctionBodySkipped(Token nativeToken, Token semicolon) {
    NativeFunctionBodySkippedHandle data = new NativeFunctionBodySkippedHandle(
        ParserAstType.HANDLE,
        nativeToken: nativeToken,
        semicolon: semicolon);
    seen(data);
  }

  @override
  void handleEmptyFunctionBody(Token semicolon) {
    EmptyFunctionBodyHandle data =
        new EmptyFunctionBodyHandle(ParserAstType.HANDLE, semicolon: semicolon);
    seen(data);
  }

  @override
  void handleExpressionFunctionBody(Token arrowToken, Token? endToken) {
    ExpressionFunctionBodyHandle data = new ExpressionFunctionBodyHandle(
        ParserAstType.HANDLE,
        arrowToken: arrowToken,
        endToken: endToken);
    seen(data);
  }

  @override
  void endReturnStatement(
      bool hasExpression, Token beginToken, Token endToken) {
    ReturnStatementEnd data = new ReturnStatementEnd(ParserAstType.END,
        hasExpression: hasExpression,
        beginToken: beginToken,
        endToken: endToken);
    seen(data);
  }

  @override
  void handleSend(Token beginToken, Token endToken) {
    SendHandle data = new SendHandle(ParserAstType.HANDLE,
        beginToken: beginToken, endToken: endToken);
    seen(data);
  }

  @override
  void beginShow(Token showKeyword) {
    ShowBegin data =
        new ShowBegin(ParserAstType.BEGIN, showKeyword: showKeyword);
    seen(data);
  }

  @override
  void endShow(Token showKeyword) {
    ShowEnd data = new ShowEnd(ParserAstType.END, showKeyword: showKeyword);
    seen(data);
  }

  @override
  void beginSwitchStatement(Token token) {
    SwitchStatementBegin data =
        new SwitchStatementBegin(ParserAstType.BEGIN, token: token);
    seen(data);
  }

  @override
  void endSwitchStatement(Token switchKeyword, Token endToken) {
    SwitchStatementEnd data = new SwitchStatementEnd(ParserAstType.END,
        switchKeyword: switchKeyword, endToken: endToken);
    seen(data);
  }

  @override
  void beginSwitchExpression(Token token) {
    SwitchExpressionBegin data =
        new SwitchExpressionBegin(ParserAstType.BEGIN, token: token);
    seen(data);
  }

  @override
  void endSwitchExpression(Token switchKeyword, Token endToken) {
    SwitchExpressionEnd data = new SwitchExpressionEnd(ParserAstType.END,
        switchKeyword: switchKeyword, endToken: endToken);
    seen(data);
  }

  @override
  void beginSwitchBlock(Token token) {
    SwitchBlockBegin data =
        new SwitchBlockBegin(ParserAstType.BEGIN, token: token);
    seen(data);
  }

  @override
  void endSwitchBlock(int caseCount, Token beginToken, Token endToken) {
    SwitchBlockEnd data = new SwitchBlockEnd(ParserAstType.END,
        caseCount: caseCount, beginToken: beginToken, endToken: endToken);
    seen(data);
  }

  @override
  void beginSwitchExpressionBlock(Token token) {
    SwitchExpressionBlockBegin data =
        new SwitchExpressionBlockBegin(ParserAstType.BEGIN, token: token);
    seen(data);
  }

  @override
  void endSwitchExpressionBlock(
      int caseCount, Token beginToken, Token endToken) {
    SwitchExpressionBlockEnd data = new SwitchExpressionBlockEnd(
        ParserAstType.END,
        caseCount: caseCount,
        beginToken: beginToken,
        endToken: endToken);
    seen(data);
  }

  @override
  void beginLiteralSymbol(Token token) {
    LiteralSymbolBegin data =
        new LiteralSymbolBegin(ParserAstType.BEGIN, token: token);
    seen(data);
  }

  @override
  void endLiteralSymbol(Token hashToken, int identifierCount) {
    LiteralSymbolEnd data = new LiteralSymbolEnd(ParserAstType.END,
        hashToken: hashToken, identifierCount: identifierCount);
    seen(data);
  }

  @override
  void handleThrowExpression(Token throwToken, Token endToken) {
    ThrowExpressionHandle data = new ThrowExpressionHandle(ParserAstType.HANDLE,
        throwToken: throwToken, endToken: endToken);
    seen(data);
  }

  @override
  void beginRethrowStatement(Token token) {
    RethrowStatementBegin data =
        new RethrowStatementBegin(ParserAstType.BEGIN, token: token);
    seen(data);
  }

  @override
  void endRethrowStatement(Token rethrowToken, Token endToken) {
    RethrowStatementEnd data = new RethrowStatementEnd(ParserAstType.END,
        rethrowToken: rethrowToken, endToken: endToken);
    seen(data);
  }

  @override
  void endTopLevelDeclaration(Token nextToken) {
    TopLevelDeclarationEnd data =
        new TopLevelDeclarationEnd(ParserAstType.END, nextToken: nextToken);
    seen(data);
  }

  @override
  void handleInvalidTopLevelDeclaration(Token endToken) {
    InvalidTopLevelDeclarationHandle data =
        new InvalidTopLevelDeclarationHandle(ParserAstType.HANDLE,
            endToken: endToken);
    seen(data);
  }

  @override
  void beginTopLevelMember(Token token) {
    TopLevelMemberBegin data =
        new TopLevelMemberBegin(ParserAstType.BEGIN, token: token);
    seen(data);
  }

  @override
  void beginFields(
      DeclarationKind declarationKind,
      Token? abstractToken,
      Token? augmentToken,
      Token? externalToken,
      Token? staticToken,
      Token? covariantToken,
      Token? lateToken,
      Token? varFinalOrConst,
      Token lastConsumed) {
    FieldsBegin data = new FieldsBegin(ParserAstType.BEGIN,
        declarationKind: declarationKind,
        abstractToken: abstractToken,
        augmentToken: augmentToken,
        externalToken: externalToken,
        staticToken: staticToken,
        covariantToken: covariantToken,
        lateToken: lateToken,
        varFinalOrConst: varFinalOrConst,
        lastConsumed: lastConsumed);
    seen(data);
  }

  @override
  void endTopLevelFields(
      Token? externalToken,
      Token? staticToken,
      Token? covariantToken,
      Token? lateToken,
      Token? varFinalOrConst,
      int count,
      Token beginToken,
      Token endToken) {
    TopLevelFieldsEnd data = new TopLevelFieldsEnd(ParserAstType.END,
        externalToken: externalToken,
        staticToken: staticToken,
        covariantToken: covariantToken,
        lateToken: lateToken,
        varFinalOrConst: varFinalOrConst,
        count: count,
        beginToken: beginToken,
        endToken: endToken);
    seen(data);
  }

  @override
  void beginTopLevelMethod(
      Token lastConsumed, Token? augmentToken, Token? externalToken) {
    TopLevelMethodBegin data = new TopLevelMethodBegin(ParserAstType.BEGIN,
        lastConsumed: lastConsumed,
        augmentToken: augmentToken,
        externalToken: externalToken);
    seen(data);
  }

  @override
  void endTopLevelMethod(Token beginToken, Token? getOrSet, Token endToken) {
    TopLevelMethodEnd data = new TopLevelMethodEnd(ParserAstType.END,
        beginToken: beginToken, getOrSet: getOrSet, endToken: endToken);
    seen(data);
  }

  @override
  void beginTryStatement(Token token) {
    TryStatementBegin data =
        new TryStatementBegin(ParserAstType.BEGIN, token: token);
    seen(data);
  }

  @override
  void beginCatchClause(Token token) {
    CatchClauseBegin data =
        new CatchClauseBegin(ParserAstType.BEGIN, token: token);
    seen(data);
  }

  @override
  void endCatchClause(Token token) {
    CatchClauseEnd data = new CatchClauseEnd(ParserAstType.END, token: token);
    seen(data);
  }

  @override
  void handleCatchBlock(Token? onKeyword, Token? catchKeyword, Token? comma) {
    CatchBlockHandle data = new CatchBlockHandle(ParserAstType.HANDLE,
        onKeyword: onKeyword, catchKeyword: catchKeyword, comma: comma);
    seen(data);
  }

  @override
  void handleFinallyBlock(Token finallyKeyword) {
    FinallyBlockHandle data = new FinallyBlockHandle(ParserAstType.HANDLE,
        finallyKeyword: finallyKeyword);
    seen(data);
  }

  @override
  void endTryStatement(
      int catchCount, Token tryKeyword, Token? finallyKeyword) {
    TryStatementEnd data = new TryStatementEnd(ParserAstType.END,
        catchCount: catchCount,
        tryKeyword: tryKeyword,
        finallyKeyword: finallyKeyword);
    seen(data);
  }

  @override
  void handleType(Token beginToken, Token? questionMark) {
    TypeHandle data = new TypeHandle(ParserAstType.HANDLE,
        beginToken: beginToken, questionMark: questionMark);
    seen(data);
  }

  @override
  void handleNonNullAssertExpression(Token bang) {
    NonNullAssertExpressionHandle data =
        new NonNullAssertExpressionHandle(ParserAstType.HANDLE, bang: bang);
    seen(data);
  }

  @override
  void handleNullAssertPattern(Token bang) {
    NullAssertPatternHandle data =
        new NullAssertPatternHandle(ParserAstType.HANDLE, bang: bang);
    seen(data);
  }

  @override
  void handleNullCheckPattern(Token question) {
    NullCheckPatternHandle data =
        new NullCheckPatternHandle(ParserAstType.HANDLE, question: question);
    seen(data);
  }

  @override
  void handleVariablePattern(Token? keyword, Token variable,
      {required bool inAssignmentPattern}) {
    VariablePatternHandle data = new VariablePatternHandle(ParserAstType.HANDLE,
        keyword: keyword,
        variable: variable,
        inAssignmentPattern: inAssignmentPattern);
    seen(data);
  }

  @override
  void handleNoName(Token token) {
    NoNameHandle data = new NoNameHandle(ParserAstType.HANDLE, token: token);
    seen(data);
  }

  @override
  void beginRecordType(Token leftBracket) {
    RecordTypeBegin data =
        new RecordTypeBegin(ParserAstType.BEGIN, leftBracket: leftBracket);
    seen(data);
  }

  @override
  void endRecordType(
      Token leftBracket, Token? questionMark, int count, bool hasNamedFields) {
    RecordTypeEnd data = new RecordTypeEnd(ParserAstType.END,
        leftBracket: leftBracket,
        questionMark: questionMark,
        count: count,
        hasNamedFields: hasNamedFields);
    seen(data);
  }

  @override
  void beginRecordTypeEntry() {
    RecordTypeEntryBegin data = new RecordTypeEntryBegin(ParserAstType.BEGIN);
    seen(data);
  }

  @override
  void endRecordTypeEntry() {
    RecordTypeEntryEnd data = new RecordTypeEntryEnd(ParserAstType.END);
    seen(data);
  }

  @override
  void beginRecordTypeNamedFields(Token leftBracket) {
    RecordTypeNamedFieldsBegin data = new RecordTypeNamedFieldsBegin(
        ParserAstType.BEGIN,
        leftBracket: leftBracket);
    seen(data);
  }

  @override
  void endRecordTypeNamedFields(int count, Token leftBracket) {
    RecordTypeNamedFieldsEnd data = new RecordTypeNamedFieldsEnd(
        ParserAstType.END,
        count: count,
        leftBracket: leftBracket);
    seen(data);
  }

  @override
  void beginFunctionType(Token beginToken) {
    FunctionTypeBegin data =
        new FunctionTypeBegin(ParserAstType.BEGIN, beginToken: beginToken);
    seen(data);
  }

  @override
  void endFunctionType(Token functionToken, Token? questionMark) {
    FunctionTypeEnd data = new FunctionTypeEnd(ParserAstType.END,
        functionToken: functionToken, questionMark: questionMark);
    seen(data);
  }

  @override
  void beginTypeArguments(Token token) {
    TypeArgumentsBegin data =
        new TypeArgumentsBegin(ParserAstType.BEGIN, token: token);
    seen(data);
  }

  @override
  void endTypeArguments(int count, Token beginToken, Token endToken) {
    TypeArgumentsEnd data = new TypeArgumentsEnd(ParserAstType.END,
        count: count, beginToken: beginToken, endToken: endToken);
    seen(data);
  }

  @override
  void handleInvalidTypeArguments(Token token) {
    InvalidTypeArgumentsHandle data =
        new InvalidTypeArgumentsHandle(ParserAstType.HANDLE, token: token);
    seen(data);
  }

  @override
  void handleNoTypeArguments(Token token) {
    NoTypeArgumentsHandle data =
        new NoTypeArgumentsHandle(ParserAstType.HANDLE, token: token);
    seen(data);
  }

  @override
  void beginTypeVariable(Token token) {
    TypeVariableBegin data =
        new TypeVariableBegin(ParserAstType.BEGIN, token: token);
    seen(data);
  }

  @override
  void handleTypeVariablesDefined(Token token, int count) {
    TypeVariablesDefinedHandle data = new TypeVariablesDefinedHandle(
        ParserAstType.HANDLE,
        token: token,
        count: count);
    seen(data);
  }

  @override
  void endTypeVariable(
      Token token, int index, Token? extendsOrSuper, Token? variance) {
    TypeVariableEnd data = new TypeVariableEnd(ParserAstType.END,
        token: token,
        index: index,
        extendsOrSuper: extendsOrSuper,
        variance: variance);
    seen(data);
  }

  @override
  void beginTypeVariables(Token token) {
    TypeVariablesBegin data =
        new TypeVariablesBegin(ParserAstType.BEGIN, token: token);
    seen(data);
  }

  @override
  void endTypeVariables(Token beginToken, Token endToken) {
    TypeVariablesEnd data = new TypeVariablesEnd(ParserAstType.END,
        beginToken: beginToken, endToken: endToken);
    seen(data);
  }

  @override
  void beginFunctionExpression(Token token) {
    FunctionExpressionBegin data =
        new FunctionExpressionBegin(ParserAstType.BEGIN, token: token);
    seen(data);
  }

  @override
  void endFunctionExpression(Token beginToken, Token token) {
    FunctionExpressionEnd data = new FunctionExpressionEnd(ParserAstType.END,
        beginToken: beginToken, token: token);
    seen(data);
  }

  @override
  void beginVariablesDeclaration(
      Token token, Token? lateToken, Token? varFinalOrConst) {
    VariablesDeclarationBegin data = new VariablesDeclarationBegin(
        ParserAstType.BEGIN,
        token: token,
        lateToken: lateToken,
        varFinalOrConst: varFinalOrConst);
    seen(data);
  }

  @override
  void endVariablesDeclaration(int count, Token? endToken) {
    VariablesDeclarationEnd data = new VariablesDeclarationEnd(
        ParserAstType.END,
        count: count,
        endToken: endToken);
    seen(data);
  }

  @override
  void beginWhileStatement(Token token) {
    WhileStatementBegin data =
        new WhileStatementBegin(ParserAstType.BEGIN, token: token);
    seen(data);
  }

  @override
  void endWhileStatement(Token whileKeyword, Token endToken) {
    WhileStatementEnd data = new WhileStatementEnd(ParserAstType.END,
        whileKeyword: whileKeyword, endToken: endToken);
    seen(data);
  }

  @override
  void beginAsOperatorType(Token operator) {
    AsOperatorTypeBegin data =
        new AsOperatorTypeBegin(ParserAstType.BEGIN, operator: operator);
    seen(data);
  }

  @override
  void endAsOperatorType(Token operator) {
    AsOperatorTypeEnd data =
        new AsOperatorTypeEnd(ParserAstType.END, operator: operator);
    seen(data);
  }

  @override
  void handleAsOperator(Token operator) {
    AsOperatorHandle data =
        new AsOperatorHandle(ParserAstType.HANDLE, operator: operator);
    seen(data);
  }

  @override
  void handleCastPattern(Token operator) {
    CastPatternHandle data =
        new CastPatternHandle(ParserAstType.HANDLE, operator: operator);
    seen(data);
  }

  @override
  void handleAssignmentExpression(Token token) {
    AssignmentExpressionHandle data =
        new AssignmentExpressionHandle(ParserAstType.HANDLE, token: token);
    seen(data);
  }

  @override
  void beginBinaryExpression(Token token) {
    BinaryExpressionBegin data =
        new BinaryExpressionBegin(ParserAstType.BEGIN, token: token);
    seen(data);
  }

  @override
  void endBinaryExpression(Token token) {
    BinaryExpressionEnd data =
        new BinaryExpressionEnd(ParserAstType.END, token: token);
    seen(data);
  }

  @override
  void beginBinaryPattern(Token token) {
    BinaryPatternBegin data =
        new BinaryPatternBegin(ParserAstType.BEGIN, token: token);
    seen(data);
  }

  @override
  void endBinaryPattern(Token token) {
    BinaryPatternEnd data =
        new BinaryPatternEnd(ParserAstType.END, token: token);
    seen(data);
  }

  @override
  void handleEndingBinaryExpression(Token token) {
    EndingBinaryExpressionHandle data =
        new EndingBinaryExpressionHandle(ParserAstType.HANDLE, token: token);
    seen(data);
  }

  @override
  void beginConditionalExpression(Token question) {
    ConditionalExpressionBegin data =
        new ConditionalExpressionBegin(ParserAstType.BEGIN, question: question);
    seen(data);
  }

  @override
  void handleConditionalExpressionColon() {
    ConditionalExpressionColonHandle data =
        new ConditionalExpressionColonHandle(ParserAstType.HANDLE);
    seen(data);
  }

  @override
  void endConditionalExpression(Token question, Token colon) {
    ConditionalExpressionEnd data = new ConditionalExpressionEnd(
        ParserAstType.END,
        question: question,
        colon: colon);
    seen(data);
  }

  @override
  void beginConstExpression(Token constKeyword) {
    ConstExpressionBegin data = new ConstExpressionBegin(ParserAstType.BEGIN,
        constKeyword: constKeyword);
    seen(data);
  }

  @override
  void endConstExpression(Token token) {
    ConstExpressionEnd data =
        new ConstExpressionEnd(ParserAstType.END, token: token);
    seen(data);
  }

  @override
  void handleConstFactory(Token constKeyword) {
    ConstFactoryHandle data = new ConstFactoryHandle(ParserAstType.HANDLE,
        constKeyword: constKeyword);
    seen(data);
  }

  @override
  void beginForControlFlow(Token? awaitToken, Token forToken) {
    ForControlFlowBegin data = new ForControlFlowBegin(ParserAstType.BEGIN,
        awaitToken: awaitToken, forToken: forToken);
    seen(data);
  }

  @override
  void endForControlFlow(Token token) {
    ForControlFlowEnd data =
        new ForControlFlowEnd(ParserAstType.END, token: token);
    seen(data);
  }

  @override
  void endForInControlFlow(Token token) {
    ForInControlFlowEnd data =
        new ForInControlFlowEnd(ParserAstType.END, token: token);
    seen(data);
  }

  @override
  void beginIfControlFlow(Token ifToken) {
    IfControlFlowBegin data =
        new IfControlFlowBegin(ParserAstType.BEGIN, ifToken: ifToken);
    seen(data);
  }

  @override
  void handleThenControlFlow(Token token) {
    ThenControlFlowHandle data =
        new ThenControlFlowHandle(ParserAstType.HANDLE, token: token);
    seen(data);
  }

  @override
  void handleElseControlFlow(Token elseToken) {
    ElseControlFlowHandle data =
        new ElseControlFlowHandle(ParserAstType.HANDLE, elseToken: elseToken);
    seen(data);
  }

  @override
  void endIfControlFlow(Token token) {
    IfControlFlowEnd data =
        new IfControlFlowEnd(ParserAstType.END, token: token);
    seen(data);
  }

  @override
  void endIfElseControlFlow(Token token) {
    IfElseControlFlowEnd data =
        new IfElseControlFlowEnd(ParserAstType.END, token: token);
    seen(data);
  }

  @override
  void handleSpreadExpression(Token spreadToken) {
    SpreadExpressionHandle data = new SpreadExpressionHandle(
        ParserAstType.HANDLE,
        spreadToken: spreadToken);
    seen(data);
  }

  @override
  void handleRestPattern(Token dots, {required bool hasSubPattern}) {
    RestPatternHandle data = new RestPatternHandle(ParserAstType.HANDLE,
        dots: dots, hasSubPattern: hasSubPattern);
    seen(data);
  }

  @override
  void beginFunctionTypedFormalParameter(Token token) {
    FunctionTypedFormalParameterBegin data =
        new FunctionTypedFormalParameterBegin(ParserAstType.BEGIN,
            token: token);
    seen(data);
  }

  @override
  void endFunctionTypedFormalParameter(Token nameToken, Token? question) {
    FunctionTypedFormalParameterEnd data = new FunctionTypedFormalParameterEnd(
        ParserAstType.END,
        nameToken: nameToken,
        question: question);
    seen(data);
  }

  @override
  void handleIdentifier(Token token, IdentifierContext context) {
    IdentifierHandle data = new IdentifierHandle(ParserAstType.HANDLE,
        token: token, context: context);
    seen(data);
  }

  @override
  void handleShowHideIdentifier(Token? modifier, Token identifier) {
    ShowHideIdentifierHandle data = new ShowHideIdentifierHandle(
        ParserAstType.HANDLE,
        modifier: modifier,
        identifier: identifier);
    seen(data);
  }

  @override
  void handleIndexedExpression(
      Token? question, Token openSquareBracket, Token closeSquareBracket) {
    IndexedExpressionHandle data = new IndexedExpressionHandle(
        ParserAstType.HANDLE,
        question: question,
        openSquareBracket: openSquareBracket,
        closeSquareBracket: closeSquareBracket);
    seen(data);
  }

  @override
  void beginIsOperatorType(Token operator) {
    IsOperatorTypeBegin data =
        new IsOperatorTypeBegin(ParserAstType.BEGIN, operator: operator);
    seen(data);
  }

  @override
  void endIsOperatorType(Token operator) {
    IsOperatorTypeEnd data =
        new IsOperatorTypeEnd(ParserAstType.END, operator: operator);
    seen(data);
  }

  @override
  void handleIsOperator(Token isOperator, Token? not) {
    IsOperatorHandle data = new IsOperatorHandle(ParserAstType.HANDLE,
        isOperator: isOperator, not: not);
    seen(data);
  }

  @override
  void handleLiteralBool(Token token) {
    LiteralBoolHandle data =
        new LiteralBoolHandle(ParserAstType.HANDLE, token: token);
    seen(data);
  }

  @override
  void handleBreakStatement(
      bool hasTarget, Token breakKeyword, Token endToken) {
    BreakStatementHandle data = new BreakStatementHandle(ParserAstType.HANDLE,
        hasTarget: hasTarget, breakKeyword: breakKeyword, endToken: endToken);
    seen(data);
  }

  @override
  void handleContinueStatement(
      bool hasTarget, Token continueKeyword, Token endToken) {
    ContinueStatementHandle data = new ContinueStatementHandle(
        ParserAstType.HANDLE,
        hasTarget: hasTarget,
        continueKeyword: continueKeyword,
        endToken: endToken);
    seen(data);
  }

  @override
  void handleEmptyStatement(Token token) {
    EmptyStatementHandle data =
        new EmptyStatementHandle(ParserAstType.HANDLE, token: token);
    seen(data);
  }

  @override
  void beginAssert(Token assertKeyword, Assert kind) {
    AssertBegin data = new AssertBegin(ParserAstType.BEGIN,
        assertKeyword: assertKeyword, kind: kind);
    seen(data);
  }

  @override
  void endAssert(Token assertKeyword, Assert kind, Token leftParenthesis,
      Token? commaToken, Token semicolonToken) {
    AssertEnd data = new AssertEnd(ParserAstType.END,
        assertKeyword: assertKeyword,
        kind: kind,
        leftParenthesis: leftParenthesis,
        commaToken: commaToken,
        semicolonToken: semicolonToken);
    seen(data);
  }

  @override
  void handleLiteralDouble(Token token) {
    LiteralDoubleHandle data =
        new LiteralDoubleHandle(ParserAstType.HANDLE, token: token);
    seen(data);
  }

  @override
  void handleLiteralInt(Token token) {
    LiteralIntHandle data =
        new LiteralIntHandle(ParserAstType.HANDLE, token: token);
    seen(data);
  }

  @override
  void handleLiteralList(
      int count, Token leftBracket, Token? constKeyword, Token rightBracket) {
    LiteralListHandle data = new LiteralListHandle(ParserAstType.HANDLE,
        count: count,
        leftBracket: leftBracket,
        constKeyword: constKeyword,
        rightBracket: rightBracket);
    seen(data);
  }

  @override
  void handleListPattern(int count, Token leftBracket, Token rightBracket) {
    ListPatternHandle data = new ListPatternHandle(ParserAstType.HANDLE,
        count: count, leftBracket: leftBracket, rightBracket: rightBracket);
    seen(data);
  }

  @override
  void handleLiteralSetOrMap(
    int count,
    Token leftBrace,
    Token? constKeyword,
    Token rightBrace,
    bool hasSetEntry,
  ) {
    LiteralSetOrMapHandle data = new LiteralSetOrMapHandle(ParserAstType.HANDLE,
        count: count,
        leftBrace: leftBrace,
        constKeyword: constKeyword,
        rightBrace: rightBrace,
        hasSetEntry: hasSetEntry);
    seen(data);
  }

  @override
  void handleMapPattern(int count, Token leftBrace, Token rightBrace) {
    MapPatternHandle data = new MapPatternHandle(ParserAstType.HANDLE,
        count: count, leftBrace: leftBrace, rightBrace: rightBrace);
    seen(data);
  }

  @override
  void handleLiteralNull(Token token) {
    LiteralNullHandle data =
        new LiteralNullHandle(ParserAstType.HANDLE, token: token);
    seen(data);
  }

  @override
  void handleNativeClause(Token nativeToken, bool hasName) {
    NativeClauseHandle data = new NativeClauseHandle(ParserAstType.HANDLE,
        nativeToken: nativeToken, hasName: hasName);
    seen(data);
  }

  @override
  void handleNamedArgument(Token colon) {
    NamedArgumentHandle data =
        new NamedArgumentHandle(ParserAstType.HANDLE, colon: colon);
    seen(data);
  }

  @override
  void handlePatternField(Token? colon) {
    PatternFieldHandle data =
        new PatternFieldHandle(ParserAstType.HANDLE, colon: colon);
    seen(data);
  }

  @override
  void handleNamedRecordField(Token colon) {
    NamedRecordFieldHandle data =
        new NamedRecordFieldHandle(ParserAstType.HANDLE, colon: colon);
    seen(data);
  }

  @override
  void beginNewExpression(Token token) {
    NewExpressionBegin data =
        new NewExpressionBegin(ParserAstType.BEGIN, token: token);
    seen(data);
  }

  @override
  void endNewExpression(Token token) {
    NewExpressionEnd data =
        new NewExpressionEnd(ParserAstType.END, token: token);
    seen(data);
  }

  @override
  void handleNoArguments(Token token) {
    NoArgumentsHandle data =
        new NoArgumentsHandle(ParserAstType.HANDLE, token: token);
    seen(data);
  }

  @override
  void handleNoConstructorReferenceContinuationAfterTypeArguments(Token token) {
    NoConstructorReferenceContinuationAfterTypeArgumentsHandle data =
        new NoConstructorReferenceContinuationAfterTypeArgumentsHandle(
            ParserAstType.HANDLE,
            token: token);
    seen(data);
  }

  @override
  void handleNoTypeNameInConstructorReference(Token token) {
    NoTypeNameInConstructorReferenceHandle data =
        new NoTypeNameInConstructorReferenceHandle(ParserAstType.HANDLE,
            token: token);
    seen(data);
  }

  @override
  void handleNoType(Token lastConsumed) {
    NoTypeHandle data =
        new NoTypeHandle(ParserAstType.HANDLE, lastConsumed: lastConsumed);
    seen(data);
  }

  @override
  void handleNoTypeVariables(Token token) {
    NoTypeVariablesHandle data =
        new NoTypeVariablesHandle(ParserAstType.HANDLE, token: token);
    seen(data);
  }

  @override
  void handleOperator(Token token) {
    OperatorHandle data =
        new OperatorHandle(ParserAstType.HANDLE, token: token);
    seen(data);
  }

  @override
  void handleSwitchCaseNoWhenClause(Token token) {
    SwitchCaseNoWhenClauseHandle data =
        new SwitchCaseNoWhenClauseHandle(ParserAstType.HANDLE, token: token);
    seen(data);
  }

  @override
  void handleSwitchExpressionCasePattern(Token token) {
    SwitchExpressionCasePatternHandle data =
        new SwitchExpressionCasePatternHandle(ParserAstType.HANDLE,
            token: token);
    seen(data);
  }

  @override
  void handleSymbolVoid(Token token) {
    SymbolVoidHandle data =
        new SymbolVoidHandle(ParserAstType.HANDLE, token: token);
    seen(data);
  }

  @override
  void handleOperatorName(Token operatorKeyword, Token token) {
    OperatorNameHandle data = new OperatorNameHandle(ParserAstType.HANDLE,
        operatorKeyword: operatorKeyword, token: token);
    seen(data);
  }

  @override
  void handleInvalidOperatorName(Token operatorKeyword, Token token) {
    InvalidOperatorNameHandle data = new InvalidOperatorNameHandle(
        ParserAstType.HANDLE,
        operatorKeyword: operatorKeyword,
        token: token);
    seen(data);
  }

  @override
  void handleParenthesizedCondition(Token token, Token? case_, Token? when) {
    ParenthesizedConditionHandle data = new ParenthesizedConditionHandle(
        ParserAstType.HANDLE,
        token: token,
        case_: case_,
        when: when);
    seen(data);
  }

  @override
  void beginPatternGuard(Token when) {
    PatternGuardBegin data =
        new PatternGuardBegin(ParserAstType.BEGIN, when: when);
    seen(data);
  }

  @override
  void beginParenthesizedExpressionOrRecordLiteral(Token token) {
    ParenthesizedExpressionOrRecordLiteralBegin data =
        new ParenthesizedExpressionOrRecordLiteralBegin(ParserAstType.BEGIN,
            token: token);
    seen(data);
  }

  @override
  void beginSwitchCaseWhenClause(Token when) {
    SwitchCaseWhenClauseBegin data =
        new SwitchCaseWhenClauseBegin(ParserAstType.BEGIN, when: when);
    seen(data);
  }

  @override
  void endRecordLiteral(Token token, int count, Token? constKeyword) {
    RecordLiteralEnd data = new RecordLiteralEnd(ParserAstType.END,
        token: token, count: count, constKeyword: constKeyword);
    seen(data);
  }

  @override
  void handleRecordPattern(Token token, int count) {
    RecordPatternHandle data = new RecordPatternHandle(ParserAstType.HANDLE,
        token: token, count: count);
    seen(data);
  }

  @override
  void endPatternGuard(Token token) {
    PatternGuardEnd data = new PatternGuardEnd(ParserAstType.END, token: token);
    seen(data);
  }

  @override
  void endParenthesizedExpression(Token token) {
    ParenthesizedExpressionEnd data =
        new ParenthesizedExpressionEnd(ParserAstType.END, token: token);
    seen(data);
  }

  @override
  void endSwitchCaseWhenClause(Token token) {
    SwitchCaseWhenClauseEnd data =
        new SwitchCaseWhenClauseEnd(ParserAstType.END, token: token);
    seen(data);
  }

  @override
  void handleParenthesizedPattern(Token token) {
    ParenthesizedPatternHandle data =
        new ParenthesizedPatternHandle(ParserAstType.HANDLE, token: token);
    seen(data);
  }

  @override
  void beginConstantPattern(Token? constKeyword) {
    ConstantPatternBegin data = new ConstantPatternBegin(ParserAstType.BEGIN,
        constKeyword: constKeyword);
    seen(data);
  }

  @override
  void endConstantPattern(Token? constKeyword) {
    ConstantPatternEnd data =
        new ConstantPatternEnd(ParserAstType.END, constKeyword: constKeyword);
    seen(data);
  }

  @override
  void handleObjectPattern(
      Token firstIdentifier, Token? dot, Token? secondIdentifier) {
    ObjectPatternHandle data = new ObjectPatternHandle(ParserAstType.HANDLE,
        firstIdentifier: firstIdentifier,
        dot: dot,
        secondIdentifier: secondIdentifier);
    seen(data);
  }

  @override
  void handleQualified(Token period) {
    QualifiedHandle data =
        new QualifiedHandle(ParserAstType.HANDLE, period: period);
    seen(data);
  }

  @override
  void handleStringPart(Token token) {
    StringPartHandle data =
        new StringPartHandle(ParserAstType.HANDLE, token: token);
    seen(data);
  }

  @override
  void handleSuperExpression(Token token, IdentifierContext context) {
    SuperExpressionHandle data = new SuperExpressionHandle(ParserAstType.HANDLE,
        token: token, context: context);
    seen(data);
  }

  @override
  void handleAugmentSuperExpression(
      Token augmentToken, Token superToken, IdentifierContext context) {
    AugmentSuperExpressionHandle data = new AugmentSuperExpressionHandle(
        ParserAstType.HANDLE,
        augmentToken: augmentToken,
        superToken: superToken,
        context: context);
    seen(data);
  }

  @override
  void beginSwitchCase(int labelCount, int expressionCount, Token firstToken) {
    SwitchCaseBegin data = new SwitchCaseBegin(ParserAstType.BEGIN,
        labelCount: labelCount,
        expressionCount: expressionCount,
        firstToken: firstToken);
    seen(data);
  }

  @override
  void endSwitchCase(
      int labelCount,
      int expressionCount,
      Token? defaultKeyword,
      Token? colonAfterDefault,
      int statementCount,
      Token firstToken,
      Token endToken) {
    SwitchCaseEnd data = new SwitchCaseEnd(ParserAstType.END,
        labelCount: labelCount,
        expressionCount: expressionCount,
        defaultKeyword: defaultKeyword,
        colonAfterDefault: colonAfterDefault,
        statementCount: statementCount,
        firstToken: firstToken,
        endToken: endToken);
    seen(data);
  }

  @override
  void beginSwitchExpressionCase() {
    SwitchExpressionCaseBegin data =
        new SwitchExpressionCaseBegin(ParserAstType.BEGIN);
    seen(data);
  }

  @override
  void endSwitchExpressionCase(Token? when, Token arrow, Token endToken) {
    SwitchExpressionCaseEnd data = new SwitchExpressionCaseEnd(
        ParserAstType.END,
        when: when,
        arrow: arrow,
        endToken: endToken);
    seen(data);
  }

  @override
  void handleThisExpression(Token token, IdentifierContext context) {
    ThisExpressionHandle data = new ThisExpressionHandle(ParserAstType.HANDLE,
        token: token, context: context);
    seen(data);
  }

  @override
  void handleUnaryPostfixAssignmentExpression(Token token) {
    UnaryPostfixAssignmentExpressionHandle data =
        new UnaryPostfixAssignmentExpressionHandle(ParserAstType.HANDLE,
            token: token);
    seen(data);
  }

  @override
  void handleUnaryPrefixExpression(Token token) {
    UnaryPrefixExpressionHandle data =
        new UnaryPrefixExpressionHandle(ParserAstType.HANDLE, token: token);
    seen(data);
  }

  @override
  void handleRelationalPattern(Token token) {
    RelationalPatternHandle data =
        new RelationalPatternHandle(ParserAstType.HANDLE, token: token);
    seen(data);
  }

  @override
  void handleUnaryPrefixAssignmentExpression(Token token) {
    UnaryPrefixAssignmentExpressionHandle data =
        new UnaryPrefixAssignmentExpressionHandle(ParserAstType.HANDLE,
            token: token);
    seen(data);
  }

  @override
  void beginFormalParameterDefaultValueExpression() {
    FormalParameterDefaultValueExpressionBegin data =
        new FormalParameterDefaultValueExpressionBegin(ParserAstType.BEGIN);
    seen(data);
  }

  @override
  void endFormalParameterDefaultValueExpression() {
    FormalParameterDefaultValueExpressionEnd data =
        new FormalParameterDefaultValueExpressionEnd(ParserAstType.END);
    seen(data);
  }

  @override
  void handleValuedFormalParameter(
      Token equals, Token token, FormalParameterKind kind) {
    ValuedFormalParameterHandle data = new ValuedFormalParameterHandle(
        ParserAstType.HANDLE,
        equals: equals,
        token: token,
        kind: kind);
    seen(data);
  }

  @override
  void handleFormalParameterWithoutValue(Token token) {
    FormalParameterWithoutValueHandle data =
        new FormalParameterWithoutValueHandle(ParserAstType.HANDLE,
            token: token);
    seen(data);
  }

  @override
  void handleVoidKeyword(Token token) {
    VoidKeywordHandle data =
        new VoidKeywordHandle(ParserAstType.HANDLE, token: token);
    seen(data);
  }

  @override
  void handleVoidKeywordWithTypeArguments(Token token) {
    VoidKeywordWithTypeArgumentsHandle data =
        new VoidKeywordWithTypeArgumentsHandle(ParserAstType.HANDLE,
            token: token);
    seen(data);
  }

  @override
  void beginYieldStatement(Token token) {
    YieldStatementBegin data =
        new YieldStatementBegin(ParserAstType.BEGIN, token: token);
    seen(data);
  }

  @override
  void endYieldStatement(Token yieldToken, Token? starToken, Token endToken) {
    YieldStatementEnd data = new YieldStatementEnd(ParserAstType.END,
        yieldToken: yieldToken, starToken: starToken, endToken: endToken);
    seen(data);
  }

  @override
  void endInvalidYieldStatement(Token beginToken, Token? starToken,
      Token endToken, MessageCode errorCode) {
    InvalidYieldStatementEnd data = new InvalidYieldStatementEnd(
        ParserAstType.END,
        beginToken: beginToken,
        starToken: starToken,
        endToken: endToken,
        errorCode: errorCode);
    seen(data);
  }

  @override
  void handleRecoverableError(
      Message message, Token startToken, Token endToken) {
    RecoverableErrorHandle data = new RecoverableErrorHandle(
        ParserAstType.HANDLE,
        message: message,
        startToken: startToken,
        endToken: endToken);
    seen(data);
  }

  @override
  void handleExperimentNotEnabled(
      ExperimentalFlag experimentalFlag, Token startToken, Token endToken) {
    ExperimentNotEnabledHandle data = new ExperimentNotEnabledHandle(
        ParserAstType.HANDLE,
        experimentalFlag: experimentalFlag,
        startToken: startToken,
        endToken: endToken);
    seen(data);
  }

  @override
  void handleErrorToken(ErrorToken token) {
    ErrorTokenHandle data =
        new ErrorTokenHandle(ParserAstType.HANDLE, token: token);
    seen(data);
  }

  @override
  void handleUnescapeError(
      Message message, Token location, int stringOffset, int length) {
    UnescapeErrorHandle data = new UnescapeErrorHandle(ParserAstType.HANDLE,
        message: message,
        location: location,
        stringOffset: stringOffset,
        length: length);
    seen(data);
  }

  @override
  void handleInvalidStatement(Token token, Message message) {
    InvalidStatementHandle data = new InvalidStatementHandle(
        ParserAstType.HANDLE,
        token: token,
        message: message);
    seen(data);
  }

  @override
  void handleScript(Token token) {
    ScriptHandle data = new ScriptHandle(ParserAstType.HANDLE, token: token);
    seen(data);
  }

  @override
  void handleCommentReferenceText(String referenceSource, int referenceOffset) {
    CommentReferenceTextHandle data = new CommentReferenceTextHandle(
        ParserAstType.HANDLE,
        referenceSource: referenceSource,
        referenceOffset: referenceOffset);
    seen(data);
  }

  @override
  void handleCommentReference(
      Token? newKeyword,
      Token? firstToken,
      Token? firstPeriod,
      Token? secondToken,
      Token? secondPeriod,
      Token thirdToken) {
    CommentReferenceHandle data = new CommentReferenceHandle(
        ParserAstType.HANDLE,
        newKeyword: newKeyword,
        firstToken: firstToken,
        firstPeriod: firstPeriod,
        secondToken: secondToken,
        secondPeriod: secondPeriod,
        thirdToken: thirdToken);
    seen(data);
  }

  @override
  void handleNoCommentReference() {
    NoCommentReferenceHandle data =
        new NoCommentReferenceHandle(ParserAstType.HANDLE);
    seen(data);
  }

  @override
  void handleTypeArgumentApplication(Token openAngleBracket) {
    TypeArgumentApplicationHandle data = new TypeArgumentApplicationHandle(
        ParserAstType.HANDLE,
        openAngleBracket: openAngleBracket);
    seen(data);
  }

  @override
  void handleNewAsIdentifier(Token token) {
    NewAsIdentifierHandle data =
        new NewAsIdentifierHandle(ParserAstType.HANDLE, token: token);
    seen(data);
  }

  @override
  void handlePatternVariableDeclarationStatement(
      Token keyword, Token equals, Token semicolon) {
    PatternVariableDeclarationStatementHandle data =
        new PatternVariableDeclarationStatementHandle(ParserAstType.HANDLE,
            keyword: keyword, equals: equals, semicolon: semicolon);
    seen(data);
  }

  @override
  void handlePatternAssignment(Token equals) {
    PatternAssignmentHandle data =
        new PatternAssignmentHandle(ParserAstType.HANDLE, equals: equals);
    seen(data);
  }
}

class ArgumentsBegin extends ParserAstNode {
  final Token token;

  ArgumentsBegin(ParserAstType type, {required this.token})
      : super("Arguments", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
      };
}

class ArgumentsEnd extends ParserAstNode {
  final int count;
  final Token beginToken;
  final Token endToken;

  ArgumentsEnd(ParserAstType type,
      {required this.count, required this.beginToken, required this.endToken})
      : super("Arguments", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "count": count,
        "beginToken": beginToken,
        "endToken": endToken,
      };
}

class ObjectPatternFieldsHandle extends ParserAstNode {
  final int count;
  final Token beginToken;
  final Token endToken;

  ObjectPatternFieldsHandle(ParserAstType type,
      {required this.count, required this.beginToken, required this.endToken})
      : super("ObjectPatternFields", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "count": count,
        "beginToken": beginToken,
        "endToken": endToken,
      };
}

class AsyncModifierHandle extends ParserAstNode {
  final Token? asyncToken;
  final Token? starToken;

  AsyncModifierHandle(ParserAstType type, {this.asyncToken, this.starToken})
      : super("AsyncModifier", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "asyncToken": asyncToken,
        "starToken": starToken,
      };
}

class AwaitExpressionBegin extends ParserAstNode {
  final Token token;

  AwaitExpressionBegin(ParserAstType type, {required this.token})
      : super("AwaitExpression", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
      };
}

class AwaitExpressionEnd extends ParserAstNode {
  final Token beginToken;
  final Token endToken;

  AwaitExpressionEnd(ParserAstType type,
      {required this.beginToken, required this.endToken})
      : super("AwaitExpression", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "beginToken": beginToken,
        "endToken": endToken,
      };
}

class InvalidAwaitExpressionEnd extends ParserAstNode {
  final Token beginToken;
  final Token endToken;
  final MessageCode errorCode;

  InvalidAwaitExpressionEnd(ParserAstType type,
      {required this.beginToken,
      required this.endToken,
      required this.errorCode})
      : super("InvalidAwaitExpression", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "beginToken": beginToken,
        "endToken": endToken,
        "errorCode": errorCode,
      };
}

class BlockBegin extends ParserAstNode {
  final Token token;
  final BlockKind blockKind;

  BlockBegin(ParserAstType type, {required this.token, required this.blockKind})
      : super("Block", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
        "blockKind": blockKind,
      };
}

class BlockEnd extends ParserAstNode {
  final int count;
  final Token beginToken;
  final Token endToken;
  final BlockKind blockKind;

  BlockEnd(ParserAstType type,
      {required this.count,
      required this.beginToken,
      required this.endToken,
      required this.blockKind})
      : super("Block", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "count": count,
        "beginToken": beginToken,
        "endToken": endToken,
        "blockKind": blockKind,
      };
}

class InvalidTopLevelBlockHandle extends ParserAstNode {
  final Token token;

  InvalidTopLevelBlockHandle(ParserAstType type, {required this.token})
      : super("InvalidTopLevelBlock", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
      };
}

class CascadeBegin extends ParserAstNode {
  final Token token;

  CascadeBegin(ParserAstType type, {required this.token})
      : super("Cascade", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
      };
}

class CascadeEnd extends ParserAstNode {
  CascadeEnd(ParserAstType type) : super("Cascade", type);

  @override
  Map<String, Object?> get deprecatedArguments => {};
}

class CaseExpressionBegin extends ParserAstNode {
  final Token caseKeyword;

  CaseExpressionBegin(ParserAstType type, {required this.caseKeyword})
      : super("CaseExpression", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "caseKeyword": caseKeyword,
      };
}

class CaseExpressionEnd extends ParserAstNode {
  final Token caseKeyword;
  final Token? when;
  final Token colon;

  CaseExpressionEnd(ParserAstType type,
      {required this.caseKeyword, this.when, required this.colon})
      : super("CaseExpression", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "caseKeyword": caseKeyword,
        "when": when,
        "colon": colon,
      };
}

class ClassOrMixinOrExtensionBodyBegin extends ParserAstNode {
  final DeclarationKind kind;
  final Token token;

  ClassOrMixinOrExtensionBodyBegin(ParserAstType type,
      {required this.kind, required this.token})
      : super("ClassOrMixinOrExtensionBody", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "kind": kind,
        "token": token,
      };
}

class ClassOrMixinOrExtensionBodyEnd extends ParserAstNode {
  final DeclarationKind kind;
  final int memberCount;
  final Token beginToken;
  final Token endToken;

  ClassOrMixinOrExtensionBodyEnd(ParserAstType type,
      {required this.kind,
      required this.memberCount,
      required this.beginToken,
      required this.endToken})
      : super("ClassOrMixinOrExtensionBody", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "kind": kind,
        "memberCount": memberCount,
        "beginToken": beginToken,
        "endToken": endToken,
      };
}

class ClassOrMixinOrNamedMixinApplicationPreludeBegin extends ParserAstNode {
  final Token token;

  ClassOrMixinOrNamedMixinApplicationPreludeBegin(ParserAstType type,
      {required this.token})
      : super("ClassOrMixinOrNamedMixinApplicationPrelude", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
      };
}

class ClassDeclarationBegin extends ParserAstNode {
  final Token begin;
  final Token? abstractToken;
  final Token? macroToken;
  final Token? inlineToken;
  final Token? sealedToken;
  final Token? baseToken;
  final Token? interfaceToken;
  final Token? finalToken;
  final Token? augmentToken;
  final Token? mixinToken;
  final Token name;

  ClassDeclarationBegin(ParserAstType type,
      {required this.begin,
      this.abstractToken,
      this.macroToken,
      this.inlineToken,
      this.sealedToken,
      this.baseToken,
      this.interfaceToken,
      this.finalToken,
      this.augmentToken,
      this.mixinToken,
      required this.name})
      : super("ClassDeclaration", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "begin": begin,
        "abstractToken": abstractToken,
        "macroToken": macroToken,
        "inlineToken": inlineToken,
        "sealedToken": sealedToken,
        "baseToken": baseToken,
        "interfaceToken": interfaceToken,
        "finalToken": finalToken,
        "augmentToken": augmentToken,
        "mixinToken": mixinToken,
        "name": name,
      };
}

class ClassExtendsHandle extends ParserAstNode {
  final Token? extendsKeyword;
  final int typeCount;

  ClassExtendsHandle(ParserAstType type,
      {this.extendsKeyword, required this.typeCount})
      : super("ClassExtends", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "extendsKeyword": extendsKeyword,
        "typeCount": typeCount,
      };
}

class ImplementsHandle extends ParserAstNode {
  final Token? implementsKeyword;
  final int interfacesCount;

  ImplementsHandle(ParserAstType type,
      {this.implementsKeyword, required this.interfacesCount})
      : super("Implements", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "implementsKeyword": implementsKeyword,
        "interfacesCount": interfacesCount,
      };
}

class ExtensionShowHideHandle extends ParserAstNode {
  final Token? showKeyword;
  final int showElementCount;
  final Token? hideKeyword;
  final int hideElementCount;

  ExtensionShowHideHandle(ParserAstType type,
      {this.showKeyword,
      required this.showElementCount,
      this.hideKeyword,
      required this.hideElementCount})
      : super("ExtensionShowHide", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "showKeyword": showKeyword,
        "showElementCount": showElementCount,
        "hideKeyword": hideKeyword,
        "hideElementCount": hideElementCount,
      };
}

class ClassHeaderHandle extends ParserAstNode {
  final Token begin;
  final Token classKeyword;
  final Token? nativeToken;

  ClassHeaderHandle(ParserAstType type,
      {required this.begin, required this.classKeyword, this.nativeToken})
      : super("ClassHeader", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "begin": begin,
        "classKeyword": classKeyword,
        "nativeToken": nativeToken,
      };
}

class RecoverClassHeaderHandle extends ParserAstNode {
  RecoverClassHeaderHandle(ParserAstType type)
      : super("RecoverClassHeader", type);

  @override
  Map<String, Object?> get deprecatedArguments => {};
}

class ClassDeclarationEnd extends ParserAstNode {
  final Token beginToken;
  final Token endToken;

  ClassDeclarationEnd(ParserAstType type,
      {required this.beginToken, required this.endToken})
      : super("ClassDeclaration", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "beginToken": beginToken,
        "endToken": endToken,
      };
}

class MixinDeclarationBegin extends ParserAstNode {
  final Token? augmentToken;
  final Token? sealedToken;
  final Token? baseToken;
  final Token? interfaceToken;
  final Token? finalToken;
  final Token mixinKeyword;
  final Token name;

  MixinDeclarationBegin(ParserAstType type,
      {this.augmentToken,
      this.sealedToken,
      this.baseToken,
      this.interfaceToken,
      this.finalToken,
      required this.mixinKeyword,
      required this.name})
      : super("MixinDeclaration", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "augmentToken": augmentToken,
        "sealedToken": sealedToken,
        "baseToken": baseToken,
        "interfaceToken": interfaceToken,
        "finalToken": finalToken,
        "mixinKeyword": mixinKeyword,
        "name": name,
      };
}

class MixinOnHandle extends ParserAstNode {
  final Token? onKeyword;
  final int typeCount;

  MixinOnHandle(ParserAstType type, {this.onKeyword, required this.typeCount})
      : super("MixinOn", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "onKeyword": onKeyword,
        "typeCount": typeCount,
      };
}

class MixinHeaderHandle extends ParserAstNode {
  final Token mixinKeyword;

  MixinHeaderHandle(ParserAstType type, {required this.mixinKeyword})
      : super("MixinHeader", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "mixinKeyword": mixinKeyword,
      };
}

class RecoverMixinHeaderHandle extends ParserAstNode {
  RecoverMixinHeaderHandle(ParserAstType type)
      : super("RecoverMixinHeader", type);

  @override
  Map<String, Object?> get deprecatedArguments => {};
}

class MixinDeclarationEnd extends ParserAstNode {
  final Token mixinKeyword;
  final Token endToken;

  MixinDeclarationEnd(ParserAstType type,
      {required this.mixinKeyword, required this.endToken})
      : super("MixinDeclaration", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "mixinKeyword": mixinKeyword,
        "endToken": endToken,
      };
}

class UncategorizedTopLevelDeclarationBegin extends ParserAstNode {
  final Token token;

  UncategorizedTopLevelDeclarationBegin(ParserAstType type,
      {required this.token})
      : super("UncategorizedTopLevelDeclaration", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
      };
}

class ExtensionDeclarationPreludeBegin extends ParserAstNode {
  final Token extensionKeyword;

  ExtensionDeclarationPreludeBegin(ParserAstType type,
      {required this.extensionKeyword})
      : super("ExtensionDeclarationPrelude", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "extensionKeyword": extensionKeyword,
      };
}

class ExtensionDeclarationBegin extends ParserAstNode {
  final Token extensionKeyword;
  final Token? name;

  ExtensionDeclarationBegin(ParserAstType type,
      {required this.extensionKeyword, this.name})
      : super("ExtensionDeclaration", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "extensionKeyword": extensionKeyword,
        "name": name,
      };
}

class ExtensionDeclarationEnd extends ParserAstNode {
  final Token extensionKeyword;
  final Token? typeKeyword;
  final Token onKeyword;
  final Token? showKeyword;
  final Token? hideKeyword;
  final Token endToken;

  ExtensionDeclarationEnd(ParserAstType type,
      {required this.extensionKeyword,
      this.typeKeyword,
      required this.onKeyword,
      this.showKeyword,
      this.hideKeyword,
      required this.endToken})
      : super("ExtensionDeclaration", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "extensionKeyword": extensionKeyword,
        "typeKeyword": typeKeyword,
        "onKeyword": onKeyword,
        "showKeyword": showKeyword,
        "hideKeyword": hideKeyword,
        "endToken": endToken,
      };
}

class CombinatorsBegin extends ParserAstNode {
  final Token token;

  CombinatorsBegin(ParserAstType type, {required this.token})
      : super("Combinators", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
      };
}

class CombinatorsEnd extends ParserAstNode {
  final int count;

  CombinatorsEnd(ParserAstType type, {required this.count})
      : super("Combinators", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "count": count,
      };
}

class CompilationUnitBegin extends ParserAstNode {
  final Token token;

  CompilationUnitBegin(ParserAstType type, {required this.token})
      : super("CompilationUnit", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
      };
}

class DirectivesOnlyHandle extends ParserAstNode {
  DirectivesOnlyHandle(ParserAstType type) : super("DirectivesOnly", type);

  @override
  Map<String, Object?> get deprecatedArguments => {};
}

class CompilationUnitEnd extends ParserAstNode {
  final int count;
  final Token token;

  CompilationUnitEnd(ParserAstType type,
      {required this.count, required this.token})
      : super("CompilationUnit", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "count": count,
        "token": token,
      };
}

class ConstLiteralBegin extends ParserAstNode {
  final Token token;

  ConstLiteralBegin(ParserAstType type, {required this.token})
      : super("ConstLiteral", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
      };
}

class ConstLiteralEnd extends ParserAstNode {
  final Token token;

  ConstLiteralEnd(ParserAstType type, {required this.token})
      : super("ConstLiteral", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
      };
}

class ConstructorReferenceBegin extends ParserAstNode {
  final Token start;

  ConstructorReferenceBegin(ParserAstType type, {required this.start})
      : super("ConstructorReference", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "start": start,
      };
}

class ConstructorReferenceEnd extends ParserAstNode {
  final Token start;
  final Token? periodBeforeName;
  final Token endToken;
  final ConstructorReferenceContext constructorReferenceContext;

  ConstructorReferenceEnd(ParserAstType type,
      {required this.start,
      this.periodBeforeName,
      required this.endToken,
      required this.constructorReferenceContext})
      : super("ConstructorReference", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "start": start,
        "periodBeforeName": periodBeforeName,
        "endToken": endToken,
        "constructorReferenceContext": constructorReferenceContext,
      };
}

class DoWhileStatementBegin extends ParserAstNode {
  final Token token;

  DoWhileStatementBegin(ParserAstType type, {required this.token})
      : super("DoWhileStatement", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
      };
}

class DoWhileStatementEnd extends ParserAstNode {
  final Token doKeyword;
  final Token whileKeyword;
  final Token endToken;

  DoWhileStatementEnd(ParserAstType type,
      {required this.doKeyword,
      required this.whileKeyword,
      required this.endToken})
      : super("DoWhileStatement", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "doKeyword": doKeyword,
        "whileKeyword": whileKeyword,
        "endToken": endToken,
      };
}

class DoWhileStatementBodyBegin extends ParserAstNode {
  final Token token;

  DoWhileStatementBodyBegin(ParserAstType type, {required this.token})
      : super("DoWhileStatementBody", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
      };
}

class DoWhileStatementBodyEnd extends ParserAstNode {
  final Token token;

  DoWhileStatementBodyEnd(ParserAstType type, {required this.token})
      : super("DoWhileStatementBody", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
      };
}

class WhileStatementBodyBegin extends ParserAstNode {
  final Token token;

  WhileStatementBodyBegin(ParserAstType type, {required this.token})
      : super("WhileStatementBody", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
      };
}

class WhileStatementBodyEnd extends ParserAstNode {
  final Token token;

  WhileStatementBodyEnd(ParserAstType type, {required this.token})
      : super("WhileStatementBody", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
      };
}

class EnumBegin extends ParserAstNode {
  final Token enumKeyword;

  EnumBegin(ParserAstType type, {required this.enumKeyword})
      : super("Enum", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "enumKeyword": enumKeyword,
      };
}

class EnumEnd extends ParserAstNode {
  final Token enumKeyword;
  final Token leftBrace;
  final int memberCount;

  EnumEnd(ParserAstType type,
      {required this.enumKeyword,
      required this.leftBrace,
      required this.memberCount})
      : super("Enum", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "enumKeyword": enumKeyword,
        "leftBrace": leftBrace,
        "memberCount": memberCount,
      };
}

class EnumConstructorEnd extends ParserAstNode {
  final Token? getOrSet;
  final Token beginToken;
  final Token beginParam;
  final Token? beginInitializers;
  final Token endToken;

  EnumConstructorEnd(ParserAstType type,
      {this.getOrSet,
      required this.beginToken,
      required this.beginParam,
      this.beginInitializers,
      required this.endToken})
      : super("EnumConstructor", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "getOrSet": getOrSet,
        "beginToken": beginToken,
        "beginParam": beginParam,
        "beginInitializers": beginInitializers,
        "endToken": endToken,
      };
}

class EnumElementsHandle extends ParserAstNode {
  final Token elementsEndToken;
  final int elementsCount;

  EnumElementsHandle(ParserAstType type,
      {required this.elementsEndToken, required this.elementsCount})
      : super("EnumElements", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "elementsEndToken": elementsEndToken,
        "elementsCount": elementsCount,
      };
}

class EnumHeaderHandle extends ParserAstNode {
  final Token enumKeyword;
  final Token leftBrace;

  EnumHeaderHandle(ParserAstType type,
      {required this.enumKeyword, required this.leftBrace})
      : super("EnumHeader", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "enumKeyword": enumKeyword,
        "leftBrace": leftBrace,
      };
}

class EnumElementHandle extends ParserAstNode {
  final Token beginToken;

  EnumElementHandle(ParserAstType type, {required this.beginToken})
      : super("EnumElement", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "beginToken": beginToken,
      };
}

class EnumFactoryMethodEnd extends ParserAstNode {
  final Token beginToken;
  final Token factoryKeyword;
  final Token endToken;

  EnumFactoryMethodEnd(ParserAstType type,
      {required this.beginToken,
      required this.factoryKeyword,
      required this.endToken})
      : super("EnumFactoryMethod", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "beginToken": beginToken,
        "factoryKeyword": factoryKeyword,
        "endToken": endToken,
      };
}

class ExportBegin extends ParserAstNode {
  final Token token;

  ExportBegin(ParserAstType type, {required this.token})
      : super("Export", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
      };
}

class ExportEnd extends ParserAstNode {
  final Token exportKeyword;
  final Token semicolon;

  ExportEnd(ParserAstType type,
      {required this.exportKeyword, required this.semicolon})
      : super("Export", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "exportKeyword": exportKeyword,
        "semicolon": semicolon,
      };
}

class ExtraneousExpressionHandle extends ParserAstNode {
  final Token token;
  final Message message;

  ExtraneousExpressionHandle(ParserAstType type,
      {required this.token, required this.message})
      : super("ExtraneousExpression", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
        "message": message,
      };
}

class ExpressionStatementHandle extends ParserAstNode {
  final Token token;

  ExpressionStatementHandle(ParserAstType type, {required this.token})
      : super("ExpressionStatement", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
      };
}

class FactoryMethodBegin extends ParserAstNode {
  final DeclarationKind declarationKind;
  final Token lastConsumed;
  final Token? externalToken;
  final Token? constToken;

  FactoryMethodBegin(ParserAstType type,
      {required this.declarationKind,
      required this.lastConsumed,
      this.externalToken,
      this.constToken})
      : super("FactoryMethod", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "declarationKind": declarationKind,
        "lastConsumed": lastConsumed,
        "externalToken": externalToken,
        "constToken": constToken,
      };
}

class ClassFactoryMethodEnd extends ParserAstNode {
  final Token beginToken;
  final Token factoryKeyword;
  final Token endToken;

  ClassFactoryMethodEnd(ParserAstType type,
      {required this.beginToken,
      required this.factoryKeyword,
      required this.endToken})
      : super("ClassFactoryMethod", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "beginToken": beginToken,
        "factoryKeyword": factoryKeyword,
        "endToken": endToken,
      };
}

class MixinFactoryMethodEnd extends ParserAstNode {
  final Token beginToken;
  final Token factoryKeyword;
  final Token endToken;

  MixinFactoryMethodEnd(ParserAstType type,
      {required this.beginToken,
      required this.factoryKeyword,
      required this.endToken})
      : super("MixinFactoryMethod", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "beginToken": beginToken,
        "factoryKeyword": factoryKeyword,
        "endToken": endToken,
      };
}

class ExtensionFactoryMethodEnd extends ParserAstNode {
  final Token beginToken;
  final Token factoryKeyword;
  final Token endToken;

  ExtensionFactoryMethodEnd(ParserAstType type,
      {required this.beginToken,
      required this.factoryKeyword,
      required this.endToken})
      : super("ExtensionFactoryMethod", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "beginToken": beginToken,
        "factoryKeyword": factoryKeyword,
        "endToken": endToken,
      };
}

class FormalParameterBegin extends ParserAstNode {
  final Token token;
  final MemberKind kind;
  final Token? requiredToken;
  final Token? covariantToken;
  final Token? varFinalOrConst;

  FormalParameterBegin(ParserAstType type,
      {required this.token,
      required this.kind,
      this.requiredToken,
      this.covariantToken,
      this.varFinalOrConst})
      : super("FormalParameter", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
        "kind": kind,
        "requiredToken": requiredToken,
        "covariantToken": covariantToken,
        "varFinalOrConst": varFinalOrConst,
      };
}

class FormalParameterEnd extends ParserAstNode {
  final Token? thisKeyword;
  final Token? superKeyword;
  final Token? periodAfterThisOrSuper;
  final Token nameToken;
  final Token? initializerStart;
  final Token? initializerEnd;
  final FormalParameterKind kind;
  final MemberKind memberKind;

  FormalParameterEnd(ParserAstType type,
      {this.thisKeyword,
      this.superKeyword,
      this.periodAfterThisOrSuper,
      required this.nameToken,
      this.initializerStart,
      this.initializerEnd,
      required this.kind,
      required this.memberKind})
      : super("FormalParameter", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "thisKeyword": thisKeyword,
        "superKeyword": superKeyword,
        "periodAfterThisOrSuper": periodAfterThisOrSuper,
        "nameToken": nameToken,
        "initializerStart": initializerStart,
        "initializerEnd": initializerEnd,
        "kind": kind,
        "memberKind": memberKind,
      };
}

class NoFormalParametersHandle extends ParserAstNode {
  final Token token;
  final MemberKind kind;

  NoFormalParametersHandle(ParserAstType type,
      {required this.token, required this.kind})
      : super("NoFormalParameters", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
        "kind": kind,
      };
}

class FormalParametersBegin extends ParserAstNode {
  final Token token;
  final MemberKind kind;

  FormalParametersBegin(ParserAstType type,
      {required this.token, required this.kind})
      : super("FormalParameters", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
        "kind": kind,
      };
}

class FormalParametersEnd extends ParserAstNode {
  final int count;
  final Token beginToken;
  final Token endToken;
  final MemberKind kind;

  FormalParametersEnd(ParserAstType type,
      {required this.count,
      required this.beginToken,
      required this.endToken,
      required this.kind})
      : super("FormalParameters", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "count": count,
        "beginToken": beginToken,
        "endToken": endToken,
        "kind": kind,
      };
}

class ClassFieldsEnd extends ParserAstNode {
  final Token? abstractToken;
  final Token? augmentToken;
  final Token? externalToken;
  final Token? staticToken;
  final Token? covariantToken;
  final Token? lateToken;
  final Token? varFinalOrConst;
  final int count;
  final Token beginToken;
  final Token endToken;

  ClassFieldsEnd(ParserAstType type,
      {this.abstractToken,
      this.augmentToken,
      this.externalToken,
      this.staticToken,
      this.covariantToken,
      this.lateToken,
      this.varFinalOrConst,
      required this.count,
      required this.beginToken,
      required this.endToken})
      : super("ClassFields", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "abstractToken": abstractToken,
        "augmentToken": augmentToken,
        "externalToken": externalToken,
        "staticToken": staticToken,
        "covariantToken": covariantToken,
        "lateToken": lateToken,
        "varFinalOrConst": varFinalOrConst,
        "count": count,
        "beginToken": beginToken,
        "endToken": endToken,
      };
}

class MixinFieldsEnd extends ParserAstNode {
  final Token? abstractToken;
  final Token? augmentToken;
  final Token? externalToken;
  final Token? staticToken;
  final Token? covariantToken;
  final Token? lateToken;
  final Token? varFinalOrConst;
  final int count;
  final Token beginToken;
  final Token endToken;

  MixinFieldsEnd(ParserAstType type,
      {this.abstractToken,
      this.augmentToken,
      this.externalToken,
      this.staticToken,
      this.covariantToken,
      this.lateToken,
      this.varFinalOrConst,
      required this.count,
      required this.beginToken,
      required this.endToken})
      : super("MixinFields", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "abstractToken": abstractToken,
        "augmentToken": augmentToken,
        "externalToken": externalToken,
        "staticToken": staticToken,
        "covariantToken": covariantToken,
        "lateToken": lateToken,
        "varFinalOrConst": varFinalOrConst,
        "count": count,
        "beginToken": beginToken,
        "endToken": endToken,
      };
}

class ExtensionFieldsEnd extends ParserAstNode {
  final Token? abstractToken;
  final Token? augmentToken;
  final Token? externalToken;
  final Token? staticToken;
  final Token? covariantToken;
  final Token? lateToken;
  final Token? varFinalOrConst;
  final int count;
  final Token beginToken;
  final Token endToken;

  ExtensionFieldsEnd(ParserAstType type,
      {this.abstractToken,
      this.augmentToken,
      this.externalToken,
      this.staticToken,
      this.covariantToken,
      this.lateToken,
      this.varFinalOrConst,
      required this.count,
      required this.beginToken,
      required this.endToken})
      : super("ExtensionFields", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "abstractToken": abstractToken,
        "augmentToken": augmentToken,
        "externalToken": externalToken,
        "staticToken": staticToken,
        "covariantToken": covariantToken,
        "lateToken": lateToken,
        "varFinalOrConst": varFinalOrConst,
        "count": count,
        "beginToken": beginToken,
        "endToken": endToken,
      };
}

class EnumFieldsEnd extends ParserAstNode {
  final Token? abstractToken;
  final Token? augmentToken;
  final Token? externalToken;
  final Token? staticToken;
  final Token? covariantToken;
  final Token? lateToken;
  final Token? varFinalOrConst;
  final int count;
  final Token beginToken;
  final Token endToken;

  EnumFieldsEnd(ParserAstType type,
      {this.abstractToken,
      this.augmentToken,
      this.externalToken,
      this.staticToken,
      this.covariantToken,
      this.lateToken,
      this.varFinalOrConst,
      required this.count,
      required this.beginToken,
      required this.endToken})
      : super("EnumFields", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "abstractToken": abstractToken,
        "augmentToken": augmentToken,
        "externalToken": externalToken,
        "staticToken": staticToken,
        "covariantToken": covariantToken,
        "lateToken": lateToken,
        "varFinalOrConst": varFinalOrConst,
        "count": count,
        "beginToken": beginToken,
        "endToken": endToken,
      };
}

class EnumMethodEnd extends ParserAstNode {
  final Token? getOrSet;
  final Token beginToken;
  final Token beginParam;
  final Token? beginInitializers;
  final Token endToken;

  EnumMethodEnd(ParserAstType type,
      {this.getOrSet,
      required this.beginToken,
      required this.beginParam,
      this.beginInitializers,
      required this.endToken})
      : super("EnumMethod", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "getOrSet": getOrSet,
        "beginToken": beginToken,
        "beginParam": beginParam,
        "beginInitializers": beginInitializers,
        "endToken": endToken,
      };
}

class ForInitializerEmptyStatementHandle extends ParserAstNode {
  final Token token;

  ForInitializerEmptyStatementHandle(ParserAstType type, {required this.token})
      : super("ForInitializerEmptyStatement", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
      };
}

class ForInitializerExpressionStatementHandle extends ParserAstNode {
  final Token token;
  final bool forIn;

  ForInitializerExpressionStatementHandle(ParserAstType type,
      {required this.token, required this.forIn})
      : super("ForInitializerExpressionStatement", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
        "forIn": forIn,
      };
}

class ForInitializerLocalVariableDeclarationHandle extends ParserAstNode {
  final Token token;
  final bool forIn;

  ForInitializerLocalVariableDeclarationHandle(ParserAstType type,
      {required this.token, required this.forIn})
      : super("ForInitializerLocalVariableDeclaration", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
        "forIn": forIn,
      };
}

class ForInitializerPatternVariableAssignmentHandle extends ParserAstNode {
  final Token keyword;
  final Token equals;

  ForInitializerPatternVariableAssignmentHandle(ParserAstType type,
      {required this.keyword, required this.equals})
      : super("ForInitializerPatternVariableAssignment", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "keyword": keyword,
        "equals": equals,
      };
}

class ForStatementBegin extends ParserAstNode {
  final Token token;

  ForStatementBegin(ParserAstType type, {required this.token})
      : super("ForStatement", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
      };
}

class ForLoopPartsHandle extends ParserAstNode {
  final Token forKeyword;
  final Token leftParen;
  final Token leftSeparator;
  final int updateExpressionCount;

  ForLoopPartsHandle(ParserAstType type,
      {required this.forKeyword,
      required this.leftParen,
      required this.leftSeparator,
      required this.updateExpressionCount})
      : super("ForLoopParts", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "forKeyword": forKeyword,
        "leftParen": leftParen,
        "leftSeparator": leftSeparator,
        "updateExpressionCount": updateExpressionCount,
      };
}

class ForStatementEnd extends ParserAstNode {
  final Token endToken;

  ForStatementEnd(ParserAstType type, {required this.endToken})
      : super("ForStatement", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "endToken": endToken,
      };
}

class ForStatementBodyBegin extends ParserAstNode {
  final Token token;

  ForStatementBodyBegin(ParserAstType type, {required this.token})
      : super("ForStatementBody", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
      };
}

class ForStatementBodyEnd extends ParserAstNode {
  final Token token;

  ForStatementBodyEnd(ParserAstType type, {required this.token})
      : super("ForStatementBody", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
      };
}

class ForInLoopPartsHandle extends ParserAstNode {
  final Token? awaitToken;
  final Token forToken;
  final Token leftParenthesis;
  final Token? patternKeyword;
  final Token inKeyword;

  ForInLoopPartsHandle(ParserAstType type,
      {this.awaitToken,
      required this.forToken,
      required this.leftParenthesis,
      this.patternKeyword,
      required this.inKeyword})
      : super("ForInLoopParts", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "awaitToken": awaitToken,
        "forToken": forToken,
        "leftParenthesis": leftParenthesis,
        "patternKeyword": patternKeyword,
        "inKeyword": inKeyword,
      };
}

class ForInEnd extends ParserAstNode {
  final Token endToken;

  ForInEnd(ParserAstType type, {required this.endToken}) : super("ForIn", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "endToken": endToken,
      };
}

class ForInExpressionBegin extends ParserAstNode {
  final Token token;

  ForInExpressionBegin(ParserAstType type, {required this.token})
      : super("ForInExpression", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
      };
}

class ForInExpressionEnd extends ParserAstNode {
  final Token token;

  ForInExpressionEnd(ParserAstType type, {required this.token})
      : super("ForInExpression", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
      };
}

class ForInBodyBegin extends ParserAstNode {
  final Token token;

  ForInBodyBegin(ParserAstType type, {required this.token})
      : super("ForInBody", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
      };
}

class ForInBodyEnd extends ParserAstNode {
  final Token token;

  ForInBodyEnd(ParserAstType type, {required this.token})
      : super("ForInBody", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
      };
}

class NamedFunctionExpressionBegin extends ParserAstNode {
  final Token token;

  NamedFunctionExpressionBegin(ParserAstType type, {required this.token})
      : super("NamedFunctionExpression", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
      };
}

class NamedFunctionExpressionEnd extends ParserAstNode {
  final Token endToken;

  NamedFunctionExpressionEnd(ParserAstType type, {required this.endToken})
      : super("NamedFunctionExpression", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "endToken": endToken,
      };
}

class LocalFunctionDeclarationBegin extends ParserAstNode {
  final Token token;

  LocalFunctionDeclarationBegin(ParserAstType type, {required this.token})
      : super("LocalFunctionDeclaration", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
      };
}

class LocalFunctionDeclarationEnd extends ParserAstNode {
  final Token endToken;

  LocalFunctionDeclarationEnd(ParserAstType type, {required this.endToken})
      : super("LocalFunctionDeclaration", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "endToken": endToken,
      };
}

class BlockFunctionBodyBegin extends ParserAstNode {
  final Token token;

  BlockFunctionBodyBegin(ParserAstType type, {required this.token})
      : super("BlockFunctionBody", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
      };
}

class BlockFunctionBodyEnd extends ParserAstNode {
  final int count;
  final Token beginToken;
  final Token endToken;

  BlockFunctionBodyEnd(ParserAstType type,
      {required this.count, required this.beginToken, required this.endToken})
      : super("BlockFunctionBody", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "count": count,
        "beginToken": beginToken,
        "endToken": endToken,
      };
}

class NoFunctionBodyHandle extends ParserAstNode {
  final Token token;

  NoFunctionBodyHandle(ParserAstType type, {required this.token})
      : super("NoFunctionBody", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
      };
}

class FunctionBodySkippedHandle extends ParserAstNode {
  final Token token;
  final bool isExpressionBody;

  FunctionBodySkippedHandle(ParserAstType type,
      {required this.token, required this.isExpressionBody})
      : super("FunctionBodySkipped", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
        "isExpressionBody": isExpressionBody,
      };
}

class FunctionNameBegin extends ParserAstNode {
  final Token token;

  FunctionNameBegin(ParserAstType type, {required this.token})
      : super("FunctionName", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
      };
}

class FunctionNameEnd extends ParserAstNode {
  final Token beginToken;
  final Token token;

  FunctionNameEnd(ParserAstType type,
      {required this.beginToken, required this.token})
      : super("FunctionName", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "beginToken": beginToken,
        "token": token,
      };
}

class TypedefBegin extends ParserAstNode {
  final Token token;

  TypedefBegin(ParserAstType type, {required this.token})
      : super("Typedef", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
      };
}

class TypedefEnd extends ParserAstNode {
  final Token typedefKeyword;
  final Token? equals;
  final Token endToken;

  TypedefEnd(ParserAstType type,
      {required this.typedefKeyword, this.equals, required this.endToken})
      : super("Typedef", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "typedefKeyword": typedefKeyword,
        "equals": equals,
        "endToken": endToken,
      };
}

class ClassWithClauseHandle extends ParserAstNode {
  final Token withKeyword;

  ClassWithClauseHandle(ParserAstType type, {required this.withKeyword})
      : super("ClassWithClause", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "withKeyword": withKeyword,
      };
}

class ClassNoWithClauseHandle extends ParserAstNode {
  ClassNoWithClauseHandle(ParserAstType type)
      : super("ClassNoWithClause", type);

  @override
  Map<String, Object?> get deprecatedArguments => {};
}

class EnumWithClauseHandle extends ParserAstNode {
  final Token withKeyword;

  EnumWithClauseHandle(ParserAstType type, {required this.withKeyword})
      : super("EnumWithClause", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "withKeyword": withKeyword,
      };
}

class EnumNoWithClauseHandle extends ParserAstNode {
  EnumNoWithClauseHandle(ParserAstType type) : super("EnumNoWithClause", type);

  @override
  Map<String, Object?> get deprecatedArguments => {};
}

class NamedMixinApplicationBegin extends ParserAstNode {
  final Token begin;
  final Token? abstractToken;
  final Token? macroToken;
  final Token? inlineToken;
  final Token? sealedToken;
  final Token? baseToken;
  final Token? interfaceToken;
  final Token? finalToken;
  final Token? augmentToken;
  final Token? mixinToken;
  final Token name;

  NamedMixinApplicationBegin(ParserAstType type,
      {required this.begin,
      this.abstractToken,
      this.macroToken,
      this.inlineToken,
      this.sealedToken,
      this.baseToken,
      this.interfaceToken,
      this.finalToken,
      this.augmentToken,
      this.mixinToken,
      required this.name})
      : super("NamedMixinApplication", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "begin": begin,
        "abstractToken": abstractToken,
        "macroToken": macroToken,
        "inlineToken": inlineToken,
        "sealedToken": sealedToken,
        "baseToken": baseToken,
        "interfaceToken": interfaceToken,
        "finalToken": finalToken,
        "augmentToken": augmentToken,
        "mixinToken": mixinToken,
        "name": name,
      };
}

class NamedMixinApplicationWithClauseHandle extends ParserAstNode {
  final Token withKeyword;

  NamedMixinApplicationWithClauseHandle(ParserAstType type,
      {required this.withKeyword})
      : super("NamedMixinApplicationWithClause", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "withKeyword": withKeyword,
      };
}

class NamedMixinApplicationEnd extends ParserAstNode {
  final Token begin;
  final Token classKeyword;
  final Token equals;
  final Token? implementsKeyword;
  final Token endToken;

  NamedMixinApplicationEnd(ParserAstType type,
      {required this.begin,
      required this.classKeyword,
      required this.equals,
      this.implementsKeyword,
      required this.endToken})
      : super("NamedMixinApplication", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "begin": begin,
        "classKeyword": classKeyword,
        "equals": equals,
        "implementsKeyword": implementsKeyword,
        "endToken": endToken,
      };
}

class HideBegin extends ParserAstNode {
  final Token hideKeyword;

  HideBegin(ParserAstType type, {required this.hideKeyword})
      : super("Hide", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "hideKeyword": hideKeyword,
      };
}

class HideEnd extends ParserAstNode {
  final Token hideKeyword;

  HideEnd(ParserAstType type, {required this.hideKeyword})
      : super("Hide", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "hideKeyword": hideKeyword,
      };
}

class IdentifierListHandle extends ParserAstNode {
  final int count;

  IdentifierListHandle(ParserAstType type, {required this.count})
      : super("IdentifierList", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "count": count,
      };
}

class TypeListBegin extends ParserAstNode {
  final Token token;

  TypeListBegin(ParserAstType type, {required this.token})
      : super("TypeList", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
      };
}

class TypeListEnd extends ParserAstNode {
  final int count;

  TypeListEnd(ParserAstType type, {required this.count})
      : super("TypeList", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "count": count,
      };
}

class IfStatementBegin extends ParserAstNode {
  final Token token;

  IfStatementBegin(ParserAstType type, {required this.token})
      : super("IfStatement", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
      };
}

class IfStatementEnd extends ParserAstNode {
  final Token ifToken;
  final Token? elseToken;

  IfStatementEnd(ParserAstType type, {required this.ifToken, this.elseToken})
      : super("IfStatement", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "ifToken": ifToken,
        "elseToken": elseToken,
      };
}

class ThenStatementBegin extends ParserAstNode {
  final Token token;

  ThenStatementBegin(ParserAstType type, {required this.token})
      : super("ThenStatement", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
      };
}

class ThenStatementEnd extends ParserAstNode {
  final Token token;

  ThenStatementEnd(ParserAstType type, {required this.token})
      : super("ThenStatement", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
      };
}

class ElseStatementBegin extends ParserAstNode {
  final Token token;

  ElseStatementBegin(ParserAstType type, {required this.token})
      : super("ElseStatement", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
      };
}

class ElseStatementEnd extends ParserAstNode {
  final Token token;

  ElseStatementEnd(ParserAstType type, {required this.token})
      : super("ElseStatement", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
      };
}

class ImportBegin extends ParserAstNode {
  final Token importKeyword;

  ImportBegin(ParserAstType type, {required this.importKeyword})
      : super("Import", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "importKeyword": importKeyword,
      };
}

class ImportPrefixHandle extends ParserAstNode {
  final Token? deferredKeyword;
  final Token? asKeyword;

  ImportPrefixHandle(ParserAstType type, {this.deferredKeyword, this.asKeyword})
      : super("ImportPrefix", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "deferredKeyword": deferredKeyword,
        "asKeyword": asKeyword,
      };
}

class ImportEnd extends ParserAstNode {
  final Token importKeyword;
  final Token? augmentToken;
  final Token? semicolon;

  ImportEnd(ParserAstType type,
      {required this.importKeyword, this.augmentToken, this.semicolon})
      : super("Import", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "importKeyword": importKeyword,
        "augmentToken": augmentToken,
        "semicolon": semicolon,
      };
}

class RecoverImportHandle extends ParserAstNode {
  final Token? semicolon;

  RecoverImportHandle(ParserAstType type, {this.semicolon})
      : super("RecoverImport", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "semicolon": semicolon,
      };
}

class ConditionalUrisBegin extends ParserAstNode {
  final Token token;

  ConditionalUrisBegin(ParserAstType type, {required this.token})
      : super("ConditionalUris", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
      };
}

class ConditionalUrisEnd extends ParserAstNode {
  final int count;

  ConditionalUrisEnd(ParserAstType type, {required this.count})
      : super("ConditionalUris", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "count": count,
      };
}

class ConditionalUriBegin extends ParserAstNode {
  final Token ifKeyword;

  ConditionalUriBegin(ParserAstType type, {required this.ifKeyword})
      : super("ConditionalUri", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "ifKeyword": ifKeyword,
      };
}

class ConditionalUriEnd extends ParserAstNode {
  final Token ifKeyword;
  final Token leftParen;
  final Token? equalSign;

  ConditionalUriEnd(ParserAstType type,
      {required this.ifKeyword, required this.leftParen, this.equalSign})
      : super("ConditionalUri", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "ifKeyword": ifKeyword,
        "leftParen": leftParen,
        "equalSign": equalSign,
      };
}

class DottedNameHandle extends ParserAstNode {
  final int count;
  final Token firstIdentifier;

  DottedNameHandle(ParserAstType type,
      {required this.count, required this.firstIdentifier})
      : super("DottedName", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "count": count,
        "firstIdentifier": firstIdentifier,
      };
}

class ImplicitCreationExpressionBegin extends ParserAstNode {
  final Token token;

  ImplicitCreationExpressionBegin(ParserAstType type, {required this.token})
      : super("ImplicitCreationExpression", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
      };
}

class ImplicitCreationExpressionEnd extends ParserAstNode {
  final Token token;
  final Token openAngleBracket;

  ImplicitCreationExpressionEnd(ParserAstType type,
      {required this.token, required this.openAngleBracket})
      : super("ImplicitCreationExpression", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
        "openAngleBracket": openAngleBracket,
      };
}

class InitializedIdentifierBegin extends ParserAstNode {
  final Token token;

  InitializedIdentifierBegin(ParserAstType type, {required this.token})
      : super("InitializedIdentifier", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
      };
}

class InitializedIdentifierEnd extends ParserAstNode {
  final Token nameToken;

  InitializedIdentifierEnd(ParserAstType type, {required this.nameToken})
      : super("InitializedIdentifier", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "nameToken": nameToken,
      };
}

class FieldInitializerBegin extends ParserAstNode {
  final Token token;

  FieldInitializerBegin(ParserAstType type, {required this.token})
      : super("FieldInitializer", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
      };
}

class FieldInitializerEnd extends ParserAstNode {
  final Token assignment;
  final Token token;

  FieldInitializerEnd(ParserAstType type,
      {required this.assignment, required this.token})
      : super("FieldInitializer", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "assignment": assignment,
        "token": token,
      };
}

class NoFieldInitializerHandle extends ParserAstNode {
  final Token token;

  NoFieldInitializerHandle(ParserAstType type, {required this.token})
      : super("NoFieldInitializer", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
      };
}

class VariableInitializerBegin extends ParserAstNode {
  final Token token;

  VariableInitializerBegin(ParserAstType type, {required this.token})
      : super("VariableInitializer", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
      };
}

class VariableInitializerEnd extends ParserAstNode {
  final Token assignmentOperator;

  VariableInitializerEnd(ParserAstType type, {required this.assignmentOperator})
      : super("VariableInitializer", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "assignmentOperator": assignmentOperator,
      };
}

class NoVariableInitializerHandle extends ParserAstNode {
  final Token token;

  NoVariableInitializerHandle(ParserAstType type, {required this.token})
      : super("NoVariableInitializer", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
      };
}

class InitializerBegin extends ParserAstNode {
  final Token token;

  InitializerBegin(ParserAstType type, {required this.token})
      : super("Initializer", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
      };
}

class InitializerEnd extends ParserAstNode {
  final Token token;

  InitializerEnd(ParserAstType type, {required this.token})
      : super("Initializer", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
      };
}

class InitializersBegin extends ParserAstNode {
  final Token token;

  InitializersBegin(ParserAstType type, {required this.token})
      : super("Initializers", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
      };
}

class InitializersEnd extends ParserAstNode {
  final int count;
  final Token beginToken;
  final Token endToken;

  InitializersEnd(ParserAstType type,
      {required this.count, required this.beginToken, required this.endToken})
      : super("Initializers", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "count": count,
        "beginToken": beginToken,
        "endToken": endToken,
      };
}

class NoInitializersHandle extends ParserAstNode {
  NoInitializersHandle(ParserAstType type) : super("NoInitializers", type);

  @override
  Map<String, Object?> get deprecatedArguments => {};
}

class InvalidExpressionHandle extends ParserAstNode {
  final Token token;

  InvalidExpressionHandle(ParserAstType type, {required this.token})
      : super("InvalidExpression", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
      };
}

class InvalidFunctionBodyHandle extends ParserAstNode {
  final Token token;

  InvalidFunctionBodyHandle(ParserAstType type, {required this.token})
      : super("InvalidFunctionBody", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
      };
}

class InvalidTypeReferenceHandle extends ParserAstNode {
  final Token token;

  InvalidTypeReferenceHandle(ParserAstType type, {required this.token})
      : super("InvalidTypeReference", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
      };
}

class LabelHandle extends ParserAstNode {
  final Token token;

  LabelHandle(ParserAstType type, {required this.token}) : super("Label", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
      };
}

class LabeledStatementBegin extends ParserAstNode {
  final Token token;
  final int labelCount;

  LabeledStatementBegin(ParserAstType type,
      {required this.token, required this.labelCount})
      : super("LabeledStatement", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
        "labelCount": labelCount,
      };
}

class LabeledStatementEnd extends ParserAstNode {
  final int labelCount;

  LabeledStatementEnd(ParserAstType type, {required this.labelCount})
      : super("LabeledStatement", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "labelCount": labelCount,
      };
}

class LibraryAugmentationBegin extends ParserAstNode {
  final Token libraryKeyword;
  final Token augmentKeyword;

  LibraryAugmentationBegin(ParserAstType type,
      {required this.libraryKeyword, required this.augmentKeyword})
      : super("LibraryAugmentation", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "libraryKeyword": libraryKeyword,
        "augmentKeyword": augmentKeyword,
      };
}

class LibraryAugmentationEnd extends ParserAstNode {
  final Token libraryKeyword;
  final Token augmentKeyword;
  final Token semicolon;

  LibraryAugmentationEnd(ParserAstType type,
      {required this.libraryKeyword,
      required this.augmentKeyword,
      required this.semicolon})
      : super("LibraryAugmentation", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "libraryKeyword": libraryKeyword,
        "augmentKeyword": augmentKeyword,
        "semicolon": semicolon,
      };
}

class LibraryNameBegin extends ParserAstNode {
  final Token token;

  LibraryNameBegin(ParserAstType type, {required this.token})
      : super("LibraryName", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
      };
}

class LibraryNameEnd extends ParserAstNode {
  final Token libraryKeyword;
  final Token semicolon;
  final bool hasName;

  LibraryNameEnd(ParserAstType type,
      {required this.libraryKeyword,
      required this.semicolon,
      required this.hasName})
      : super("LibraryName", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "libraryKeyword": libraryKeyword,
        "semicolon": semicolon,
        "hasName": hasName,
      };
}

class LiteralMapEntryHandle extends ParserAstNode {
  final Token colon;
  final Token endToken;

  LiteralMapEntryHandle(ParserAstType type,
      {required this.colon, required this.endToken})
      : super("LiteralMapEntry", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "colon": colon,
        "endToken": endToken,
      };
}

class MapPatternEntryHandle extends ParserAstNode {
  final Token colon;
  final Token endToken;

  MapPatternEntryHandle(ParserAstType type,
      {required this.colon, required this.endToken})
      : super("MapPatternEntry", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "colon": colon,
        "endToken": endToken,
      };
}

class LiteralStringBegin extends ParserAstNode {
  final Token token;

  LiteralStringBegin(ParserAstType type, {required this.token})
      : super("LiteralString", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
      };
}

class InterpolationExpressionHandle extends ParserAstNode {
  final Token leftBracket;
  final Token? rightBracket;

  InterpolationExpressionHandle(ParserAstType type,
      {required this.leftBracket, this.rightBracket})
      : super("InterpolationExpression", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "leftBracket": leftBracket,
        "rightBracket": rightBracket,
      };
}

class LiteralStringEnd extends ParserAstNode {
  final int interpolationCount;
  final Token endToken;

  LiteralStringEnd(ParserAstType type,
      {required this.interpolationCount, required this.endToken})
      : super("LiteralString", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "interpolationCount": interpolationCount,
        "endToken": endToken,
      };
}

class StringJuxtapositionHandle extends ParserAstNode {
  final Token startToken;
  final int literalCount;

  StringJuxtapositionHandle(ParserAstType type,
      {required this.startToken, required this.literalCount})
      : super("StringJuxtaposition", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "startToken": startToken,
        "literalCount": literalCount,
      };
}

class MemberBegin extends ParserAstNode {
  MemberBegin(ParserAstType type) : super("Member", type);

  @override
  Map<String, Object?> get deprecatedArguments => {};
}

class InvalidMemberHandle extends ParserAstNode {
  final Token endToken;

  InvalidMemberHandle(ParserAstType type, {required this.endToken})
      : super("InvalidMember", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "endToken": endToken,
      };
}

class MemberEnd extends ParserAstNode {
  MemberEnd(ParserAstType type) : super("Member", type);

  @override
  Map<String, Object?> get deprecatedArguments => {};
}

class MethodBegin extends ParserAstNode {
  final DeclarationKind declarationKind;
  final Token? augmentToken;
  final Token? externalToken;
  final Token? staticToken;
  final Token? covariantToken;
  final Token? varFinalOrConst;
  final Token? getOrSet;
  final Token name;

  MethodBegin(ParserAstType type,
      {required this.declarationKind,
      this.augmentToken,
      this.externalToken,
      this.staticToken,
      this.covariantToken,
      this.varFinalOrConst,
      this.getOrSet,
      required this.name})
      : super("Method", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "declarationKind": declarationKind,
        "augmentToken": augmentToken,
        "externalToken": externalToken,
        "staticToken": staticToken,
        "covariantToken": covariantToken,
        "varFinalOrConst": varFinalOrConst,
        "getOrSet": getOrSet,
        "name": name,
      };
}

class ClassMethodEnd extends ParserAstNode {
  final Token? getOrSet;
  final Token beginToken;
  final Token beginParam;
  final Token? beginInitializers;
  final Token endToken;

  ClassMethodEnd(ParserAstType type,
      {this.getOrSet,
      required this.beginToken,
      required this.beginParam,
      this.beginInitializers,
      required this.endToken})
      : super("ClassMethod", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "getOrSet": getOrSet,
        "beginToken": beginToken,
        "beginParam": beginParam,
        "beginInitializers": beginInitializers,
        "endToken": endToken,
      };
}

class MixinMethodEnd extends ParserAstNode {
  final Token? getOrSet;
  final Token beginToken;
  final Token beginParam;
  final Token? beginInitializers;
  final Token endToken;

  MixinMethodEnd(ParserAstType type,
      {this.getOrSet,
      required this.beginToken,
      required this.beginParam,
      this.beginInitializers,
      required this.endToken})
      : super("MixinMethod", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "getOrSet": getOrSet,
        "beginToken": beginToken,
        "beginParam": beginParam,
        "beginInitializers": beginInitializers,
        "endToken": endToken,
      };
}

class ExtensionMethodEnd extends ParserAstNode {
  final Token? getOrSet;
  final Token beginToken;
  final Token beginParam;
  final Token? beginInitializers;
  final Token endToken;

  ExtensionMethodEnd(ParserAstType type,
      {this.getOrSet,
      required this.beginToken,
      required this.beginParam,
      this.beginInitializers,
      required this.endToken})
      : super("ExtensionMethod", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "getOrSet": getOrSet,
        "beginToken": beginToken,
        "beginParam": beginParam,
        "beginInitializers": beginInitializers,
        "endToken": endToken,
      };
}

class ClassConstructorEnd extends ParserAstNode {
  final Token? getOrSet;
  final Token beginToken;
  final Token beginParam;
  final Token? beginInitializers;
  final Token endToken;

  ClassConstructorEnd(ParserAstType type,
      {this.getOrSet,
      required this.beginToken,
      required this.beginParam,
      this.beginInitializers,
      required this.endToken})
      : super("ClassConstructor", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "getOrSet": getOrSet,
        "beginToken": beginToken,
        "beginParam": beginParam,
        "beginInitializers": beginInitializers,
        "endToken": endToken,
      };
}

class MixinConstructorEnd extends ParserAstNode {
  final Token? getOrSet;
  final Token beginToken;
  final Token beginParam;
  final Token? beginInitializers;
  final Token endToken;

  MixinConstructorEnd(ParserAstType type,
      {this.getOrSet,
      required this.beginToken,
      required this.beginParam,
      this.beginInitializers,
      required this.endToken})
      : super("MixinConstructor", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "getOrSet": getOrSet,
        "beginToken": beginToken,
        "beginParam": beginParam,
        "beginInitializers": beginInitializers,
        "endToken": endToken,
      };
}

class ExtensionConstructorEnd extends ParserAstNode {
  final Token? getOrSet;
  final Token beginToken;
  final Token beginParam;
  final Token? beginInitializers;
  final Token endToken;

  ExtensionConstructorEnd(ParserAstType type,
      {this.getOrSet,
      required this.beginToken,
      required this.beginParam,
      this.beginInitializers,
      required this.endToken})
      : super("ExtensionConstructor", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "getOrSet": getOrSet,
        "beginToken": beginToken,
        "beginParam": beginParam,
        "beginInitializers": beginInitializers,
        "endToken": endToken,
      };
}

class MetadataStarBegin extends ParserAstNode {
  final Token token;

  MetadataStarBegin(ParserAstType type, {required this.token})
      : super("MetadataStar", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
      };
}

class MetadataStarEnd extends ParserAstNode {
  final int count;

  MetadataStarEnd(ParserAstType type, {required this.count})
      : super("MetadataStar", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "count": count,
      };
}

class MetadataBegin extends ParserAstNode {
  final Token token;

  MetadataBegin(ParserAstType type, {required this.token})
      : super("Metadata", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
      };
}

class MetadataEnd extends ParserAstNode {
  final Token beginToken;
  final Token? periodBeforeName;
  final Token endToken;

  MetadataEnd(ParserAstType type,
      {required this.beginToken, this.periodBeforeName, required this.endToken})
      : super("Metadata", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "beginToken": beginToken,
        "periodBeforeName": periodBeforeName,
        "endToken": endToken,
      };
}

class OptionalFormalParametersBegin extends ParserAstNode {
  final Token token;

  OptionalFormalParametersBegin(ParserAstType type, {required this.token})
      : super("OptionalFormalParameters", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
      };
}

class OptionalFormalParametersEnd extends ParserAstNode {
  final int count;
  final Token beginToken;
  final Token endToken;

  OptionalFormalParametersEnd(ParserAstType type,
      {required this.count, required this.beginToken, required this.endToken})
      : super("OptionalFormalParameters", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "count": count,
        "beginToken": beginToken,
        "endToken": endToken,
      };
}

class PartBegin extends ParserAstNode {
  final Token token;

  PartBegin(ParserAstType type, {required this.token}) : super("Part", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
      };
}

class PartEnd extends ParserAstNode {
  final Token partKeyword;
  final Token semicolon;

  PartEnd(ParserAstType type,
      {required this.partKeyword, required this.semicolon})
      : super("Part", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "partKeyword": partKeyword,
        "semicolon": semicolon,
      };
}

class PartOfBegin extends ParserAstNode {
  final Token token;

  PartOfBegin(ParserAstType type, {required this.token})
      : super("PartOf", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
      };
}

class PartOfEnd extends ParserAstNode {
  final Token partKeyword;
  final Token ofKeyword;
  final Token semicolon;
  final bool hasName;

  PartOfEnd(ParserAstType type,
      {required this.partKeyword,
      required this.ofKeyword,
      required this.semicolon,
      required this.hasName})
      : super("PartOf", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "partKeyword": partKeyword,
        "ofKeyword": ofKeyword,
        "semicolon": semicolon,
        "hasName": hasName,
      };
}

class RedirectingFactoryBodyBegin extends ParserAstNode {
  final Token token;

  RedirectingFactoryBodyBegin(ParserAstType type, {required this.token})
      : super("RedirectingFactoryBody", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
      };
}

class RedirectingFactoryBodyEnd extends ParserAstNode {
  final Token beginToken;
  final Token endToken;

  RedirectingFactoryBodyEnd(ParserAstType type,
      {required this.beginToken, required this.endToken})
      : super("RedirectingFactoryBody", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "beginToken": beginToken,
        "endToken": endToken,
      };
}

class ReturnStatementBegin extends ParserAstNode {
  final Token token;

  ReturnStatementBegin(ParserAstType type, {required this.token})
      : super("ReturnStatement", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
      };
}

class NativeFunctionBodyHandle extends ParserAstNode {
  final Token nativeToken;
  final Token semicolon;

  NativeFunctionBodyHandle(ParserAstType type,
      {required this.nativeToken, required this.semicolon})
      : super("NativeFunctionBody", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "nativeToken": nativeToken,
        "semicolon": semicolon,
      };
}

class NativeFunctionBodyIgnoredHandle extends ParserAstNode {
  final Token nativeToken;
  final Token semicolon;

  NativeFunctionBodyIgnoredHandle(ParserAstType type,
      {required this.nativeToken, required this.semicolon})
      : super("NativeFunctionBodyIgnored", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "nativeToken": nativeToken,
        "semicolon": semicolon,
      };
}

class NativeFunctionBodySkippedHandle extends ParserAstNode {
  final Token nativeToken;
  final Token semicolon;

  NativeFunctionBodySkippedHandle(ParserAstType type,
      {required this.nativeToken, required this.semicolon})
      : super("NativeFunctionBodySkipped", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "nativeToken": nativeToken,
        "semicolon": semicolon,
      };
}

class EmptyFunctionBodyHandle extends ParserAstNode {
  final Token semicolon;

  EmptyFunctionBodyHandle(ParserAstType type, {required this.semicolon})
      : super("EmptyFunctionBody", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "semicolon": semicolon,
      };
}

class ExpressionFunctionBodyHandle extends ParserAstNode {
  final Token arrowToken;
  final Token? endToken;

  ExpressionFunctionBodyHandle(ParserAstType type,
      {required this.arrowToken, this.endToken})
      : super("ExpressionFunctionBody", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "arrowToken": arrowToken,
        "endToken": endToken,
      };
}

class ReturnStatementEnd extends ParserAstNode {
  final bool hasExpression;
  final Token beginToken;
  final Token endToken;

  ReturnStatementEnd(ParserAstType type,
      {required this.hasExpression,
      required this.beginToken,
      required this.endToken})
      : super("ReturnStatement", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "hasExpression": hasExpression,
        "beginToken": beginToken,
        "endToken": endToken,
      };
}

class SendHandle extends ParserAstNode {
  final Token beginToken;
  final Token endToken;

  SendHandle(ParserAstType type,
      {required this.beginToken, required this.endToken})
      : super("Send", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "beginToken": beginToken,
        "endToken": endToken,
      };
}

class ShowBegin extends ParserAstNode {
  final Token showKeyword;

  ShowBegin(ParserAstType type, {required this.showKeyword})
      : super("Show", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "showKeyword": showKeyword,
      };
}

class ShowEnd extends ParserAstNode {
  final Token showKeyword;

  ShowEnd(ParserAstType type, {required this.showKeyword})
      : super("Show", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "showKeyword": showKeyword,
      };
}

class SwitchStatementBegin extends ParserAstNode {
  final Token token;

  SwitchStatementBegin(ParserAstType type, {required this.token})
      : super("SwitchStatement", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
      };
}

class SwitchStatementEnd extends ParserAstNode {
  final Token switchKeyword;
  final Token endToken;

  SwitchStatementEnd(ParserAstType type,
      {required this.switchKeyword, required this.endToken})
      : super("SwitchStatement", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "switchKeyword": switchKeyword,
        "endToken": endToken,
      };
}

class SwitchExpressionBegin extends ParserAstNode {
  final Token token;

  SwitchExpressionBegin(ParserAstType type, {required this.token})
      : super("SwitchExpression", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
      };
}

class SwitchExpressionEnd extends ParserAstNode {
  final Token switchKeyword;
  final Token endToken;

  SwitchExpressionEnd(ParserAstType type,
      {required this.switchKeyword, required this.endToken})
      : super("SwitchExpression", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "switchKeyword": switchKeyword,
        "endToken": endToken,
      };
}

class SwitchBlockBegin extends ParserAstNode {
  final Token token;

  SwitchBlockBegin(ParserAstType type, {required this.token})
      : super("SwitchBlock", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
      };
}

class SwitchBlockEnd extends ParserAstNode {
  final int caseCount;
  final Token beginToken;
  final Token endToken;

  SwitchBlockEnd(ParserAstType type,
      {required this.caseCount,
      required this.beginToken,
      required this.endToken})
      : super("SwitchBlock", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "caseCount": caseCount,
        "beginToken": beginToken,
        "endToken": endToken,
      };
}

class SwitchExpressionBlockBegin extends ParserAstNode {
  final Token token;

  SwitchExpressionBlockBegin(ParserAstType type, {required this.token})
      : super("SwitchExpressionBlock", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
      };
}

class SwitchExpressionBlockEnd extends ParserAstNode {
  final int caseCount;
  final Token beginToken;
  final Token endToken;

  SwitchExpressionBlockEnd(ParserAstType type,
      {required this.caseCount,
      required this.beginToken,
      required this.endToken})
      : super("SwitchExpressionBlock", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "caseCount": caseCount,
        "beginToken": beginToken,
        "endToken": endToken,
      };
}

class LiteralSymbolBegin extends ParserAstNode {
  final Token token;

  LiteralSymbolBegin(ParserAstType type, {required this.token})
      : super("LiteralSymbol", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
      };
}

class LiteralSymbolEnd extends ParserAstNode {
  final Token hashToken;
  final int identifierCount;

  LiteralSymbolEnd(ParserAstType type,
      {required this.hashToken, required this.identifierCount})
      : super("LiteralSymbol", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "hashToken": hashToken,
        "identifierCount": identifierCount,
      };
}

class ThrowExpressionHandle extends ParserAstNode {
  final Token throwToken;
  final Token endToken;

  ThrowExpressionHandle(ParserAstType type,
      {required this.throwToken, required this.endToken})
      : super("ThrowExpression", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "throwToken": throwToken,
        "endToken": endToken,
      };
}

class RethrowStatementBegin extends ParserAstNode {
  final Token token;

  RethrowStatementBegin(ParserAstType type, {required this.token})
      : super("RethrowStatement", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
      };
}

class RethrowStatementEnd extends ParserAstNode {
  final Token rethrowToken;
  final Token endToken;

  RethrowStatementEnd(ParserAstType type,
      {required this.rethrowToken, required this.endToken})
      : super("RethrowStatement", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "rethrowToken": rethrowToken,
        "endToken": endToken,
      };
}

class TopLevelDeclarationEnd extends ParserAstNode {
  final Token nextToken;

  TopLevelDeclarationEnd(ParserAstType type, {required this.nextToken})
      : super("TopLevelDeclaration", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "nextToken": nextToken,
      };
}

class InvalidTopLevelDeclarationHandle extends ParserAstNode {
  final Token endToken;

  InvalidTopLevelDeclarationHandle(ParserAstType type, {required this.endToken})
      : super("InvalidTopLevelDeclaration", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "endToken": endToken,
      };
}

class TopLevelMemberBegin extends ParserAstNode {
  final Token token;

  TopLevelMemberBegin(ParserAstType type, {required this.token})
      : super("TopLevelMember", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
      };
}

class FieldsBegin extends ParserAstNode {
  final DeclarationKind declarationKind;
  final Token? abstractToken;
  final Token? augmentToken;
  final Token? externalToken;
  final Token? staticToken;
  final Token? covariantToken;
  final Token? lateToken;
  final Token? varFinalOrConst;
  final Token lastConsumed;

  FieldsBegin(ParserAstType type,
      {required this.declarationKind,
      this.abstractToken,
      this.augmentToken,
      this.externalToken,
      this.staticToken,
      this.covariantToken,
      this.lateToken,
      this.varFinalOrConst,
      required this.lastConsumed})
      : super("Fields", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "declarationKind": declarationKind,
        "abstractToken": abstractToken,
        "augmentToken": augmentToken,
        "externalToken": externalToken,
        "staticToken": staticToken,
        "covariantToken": covariantToken,
        "lateToken": lateToken,
        "varFinalOrConst": varFinalOrConst,
        "lastConsumed": lastConsumed,
      };
}

class TopLevelFieldsEnd extends ParserAstNode {
  final Token? externalToken;
  final Token? staticToken;
  final Token? covariantToken;
  final Token? lateToken;
  final Token? varFinalOrConst;
  final int count;
  final Token beginToken;
  final Token endToken;

  TopLevelFieldsEnd(ParserAstType type,
      {this.externalToken,
      this.staticToken,
      this.covariantToken,
      this.lateToken,
      this.varFinalOrConst,
      required this.count,
      required this.beginToken,
      required this.endToken})
      : super("TopLevelFields", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "externalToken": externalToken,
        "staticToken": staticToken,
        "covariantToken": covariantToken,
        "lateToken": lateToken,
        "varFinalOrConst": varFinalOrConst,
        "count": count,
        "beginToken": beginToken,
        "endToken": endToken,
      };
}

class TopLevelMethodBegin extends ParserAstNode {
  final Token lastConsumed;
  final Token? augmentToken;
  final Token? externalToken;

  TopLevelMethodBegin(ParserAstType type,
      {required this.lastConsumed, this.augmentToken, this.externalToken})
      : super("TopLevelMethod", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "lastConsumed": lastConsumed,
        "augmentToken": augmentToken,
        "externalToken": externalToken,
      };
}

class TopLevelMethodEnd extends ParserAstNode {
  final Token beginToken;
  final Token? getOrSet;
  final Token endToken;

  TopLevelMethodEnd(ParserAstType type,
      {required this.beginToken, this.getOrSet, required this.endToken})
      : super("TopLevelMethod", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "beginToken": beginToken,
        "getOrSet": getOrSet,
        "endToken": endToken,
      };
}

class TryStatementBegin extends ParserAstNode {
  final Token token;

  TryStatementBegin(ParserAstType type, {required this.token})
      : super("TryStatement", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
      };
}

class CatchClauseBegin extends ParserAstNode {
  final Token token;

  CatchClauseBegin(ParserAstType type, {required this.token})
      : super("CatchClause", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
      };
}

class CatchClauseEnd extends ParserAstNode {
  final Token token;

  CatchClauseEnd(ParserAstType type, {required this.token})
      : super("CatchClause", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
      };
}

class CatchBlockHandle extends ParserAstNode {
  final Token? onKeyword;
  final Token? catchKeyword;
  final Token? comma;

  CatchBlockHandle(ParserAstType type,
      {this.onKeyword, this.catchKeyword, this.comma})
      : super("CatchBlock", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "onKeyword": onKeyword,
        "catchKeyword": catchKeyword,
        "comma": comma,
      };
}

class FinallyBlockHandle extends ParserAstNode {
  final Token finallyKeyword;

  FinallyBlockHandle(ParserAstType type, {required this.finallyKeyword})
      : super("FinallyBlock", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "finallyKeyword": finallyKeyword,
      };
}

class TryStatementEnd extends ParserAstNode {
  final int catchCount;
  final Token tryKeyword;
  final Token? finallyKeyword;

  TryStatementEnd(ParserAstType type,
      {required this.catchCount, required this.tryKeyword, this.finallyKeyword})
      : super("TryStatement", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "catchCount": catchCount,
        "tryKeyword": tryKeyword,
        "finallyKeyword": finallyKeyword,
      };
}

class TypeHandle extends ParserAstNode {
  final Token beginToken;
  final Token? questionMark;

  TypeHandle(ParserAstType type, {required this.beginToken, this.questionMark})
      : super("Type", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "beginToken": beginToken,
        "questionMark": questionMark,
      };
}

class NonNullAssertExpressionHandle extends ParserAstNode {
  final Token bang;

  NonNullAssertExpressionHandle(ParserAstType type, {required this.bang})
      : super("NonNullAssertExpression", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "bang": bang,
      };
}

class NullAssertPatternHandle extends ParserAstNode {
  final Token bang;

  NullAssertPatternHandle(ParserAstType type, {required this.bang})
      : super("NullAssertPattern", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "bang": bang,
      };
}

class NullCheckPatternHandle extends ParserAstNode {
  final Token question;

  NullCheckPatternHandle(ParserAstType type, {required this.question})
      : super("NullCheckPattern", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "question": question,
      };
}

class VariablePatternHandle extends ParserAstNode {
  final Token? keyword;
  final Token variable;
  final bool inAssignmentPattern;

  VariablePatternHandle(ParserAstType type,
      {this.keyword, required this.variable, required this.inAssignmentPattern})
      : super("VariablePattern", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "keyword": keyword,
        "variable": variable,
        "inAssignmentPattern": inAssignmentPattern,
      };
}

class NoNameHandle extends ParserAstNode {
  final Token token;

  NoNameHandle(ParserAstType type, {required this.token})
      : super("NoName", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
      };
}

class RecordTypeBegin extends ParserAstNode {
  final Token leftBracket;

  RecordTypeBegin(ParserAstType type, {required this.leftBracket})
      : super("RecordType", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "leftBracket": leftBracket,
      };
}

class RecordTypeEnd extends ParserAstNode {
  final Token leftBracket;
  final Token? questionMark;
  final int count;
  final bool hasNamedFields;

  RecordTypeEnd(ParserAstType type,
      {required this.leftBracket,
      this.questionMark,
      required this.count,
      required this.hasNamedFields})
      : super("RecordType", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "leftBracket": leftBracket,
        "questionMark": questionMark,
        "count": count,
        "hasNamedFields": hasNamedFields,
      };
}

class RecordTypeEntryBegin extends ParserAstNode {
  RecordTypeEntryBegin(ParserAstType type) : super("RecordTypeEntry", type);

  @override
  Map<String, Object?> get deprecatedArguments => {};
}

class RecordTypeEntryEnd extends ParserAstNode {
  RecordTypeEntryEnd(ParserAstType type) : super("RecordTypeEntry", type);

  @override
  Map<String, Object?> get deprecatedArguments => {};
}

class RecordTypeNamedFieldsBegin extends ParserAstNode {
  final Token leftBracket;

  RecordTypeNamedFieldsBegin(ParserAstType type, {required this.leftBracket})
      : super("RecordTypeNamedFields", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "leftBracket": leftBracket,
      };
}

class RecordTypeNamedFieldsEnd extends ParserAstNode {
  final int count;
  final Token leftBracket;

  RecordTypeNamedFieldsEnd(ParserAstType type,
      {required this.count, required this.leftBracket})
      : super("RecordTypeNamedFields", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "count": count,
        "leftBracket": leftBracket,
      };
}

class FunctionTypeBegin extends ParserAstNode {
  final Token beginToken;

  FunctionTypeBegin(ParserAstType type, {required this.beginToken})
      : super("FunctionType", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "beginToken": beginToken,
      };
}

class FunctionTypeEnd extends ParserAstNode {
  final Token functionToken;
  final Token? questionMark;

  FunctionTypeEnd(ParserAstType type,
      {required this.functionToken, this.questionMark})
      : super("FunctionType", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "functionToken": functionToken,
        "questionMark": questionMark,
      };
}

class TypeArgumentsBegin extends ParserAstNode {
  final Token token;

  TypeArgumentsBegin(ParserAstType type, {required this.token})
      : super("TypeArguments", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
      };
}

class TypeArgumentsEnd extends ParserAstNode {
  final int count;
  final Token beginToken;
  final Token endToken;

  TypeArgumentsEnd(ParserAstType type,
      {required this.count, required this.beginToken, required this.endToken})
      : super("TypeArguments", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "count": count,
        "beginToken": beginToken,
        "endToken": endToken,
      };
}

class InvalidTypeArgumentsHandle extends ParserAstNode {
  final Token token;

  InvalidTypeArgumentsHandle(ParserAstType type, {required this.token})
      : super("InvalidTypeArguments", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
      };
}

class NoTypeArgumentsHandle extends ParserAstNode {
  final Token token;

  NoTypeArgumentsHandle(ParserAstType type, {required this.token})
      : super("NoTypeArguments", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
      };
}

class TypeVariableBegin extends ParserAstNode {
  final Token token;

  TypeVariableBegin(ParserAstType type, {required this.token})
      : super("TypeVariable", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
      };
}

class TypeVariablesDefinedHandle extends ParserAstNode {
  final Token token;
  final int count;

  TypeVariablesDefinedHandle(ParserAstType type,
      {required this.token, required this.count})
      : super("TypeVariablesDefined", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
        "count": count,
      };
}

class TypeVariableEnd extends ParserAstNode {
  final Token token;
  final int index;
  final Token? extendsOrSuper;
  final Token? variance;

  TypeVariableEnd(ParserAstType type,
      {required this.token,
      required this.index,
      this.extendsOrSuper,
      this.variance})
      : super("TypeVariable", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
        "index": index,
        "extendsOrSuper": extendsOrSuper,
        "variance": variance,
      };
}

class TypeVariablesBegin extends ParserAstNode {
  final Token token;

  TypeVariablesBegin(ParserAstType type, {required this.token})
      : super("TypeVariables", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
      };
}

class TypeVariablesEnd extends ParserAstNode {
  final Token beginToken;
  final Token endToken;

  TypeVariablesEnd(ParserAstType type,
      {required this.beginToken, required this.endToken})
      : super("TypeVariables", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "beginToken": beginToken,
        "endToken": endToken,
      };
}

class FunctionExpressionBegin extends ParserAstNode {
  final Token token;

  FunctionExpressionBegin(ParserAstType type, {required this.token})
      : super("FunctionExpression", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
      };
}

class FunctionExpressionEnd extends ParserAstNode {
  final Token beginToken;
  final Token token;

  FunctionExpressionEnd(ParserAstType type,
      {required this.beginToken, required this.token})
      : super("FunctionExpression", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "beginToken": beginToken,
        "token": token,
      };
}

class VariablesDeclarationBegin extends ParserAstNode {
  final Token token;
  final Token? lateToken;
  final Token? varFinalOrConst;

  VariablesDeclarationBegin(ParserAstType type,
      {required this.token, this.lateToken, this.varFinalOrConst})
      : super("VariablesDeclaration", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
        "lateToken": lateToken,
        "varFinalOrConst": varFinalOrConst,
      };
}

class VariablesDeclarationEnd extends ParserAstNode {
  final int count;
  final Token? endToken;

  VariablesDeclarationEnd(ParserAstType type,
      {required this.count, this.endToken})
      : super("VariablesDeclaration", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "count": count,
        "endToken": endToken,
      };
}

class WhileStatementBegin extends ParserAstNode {
  final Token token;

  WhileStatementBegin(ParserAstType type, {required this.token})
      : super("WhileStatement", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
      };
}

class WhileStatementEnd extends ParserAstNode {
  final Token whileKeyword;
  final Token endToken;

  WhileStatementEnd(ParserAstType type,
      {required this.whileKeyword, required this.endToken})
      : super("WhileStatement", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "whileKeyword": whileKeyword,
        "endToken": endToken,
      };
}

class AsOperatorTypeBegin extends ParserAstNode {
  final Token operator;

  AsOperatorTypeBegin(ParserAstType type, {required this.operator})
      : super("AsOperatorType", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "operator": operator,
      };
}

class AsOperatorTypeEnd extends ParserAstNode {
  final Token operator;

  AsOperatorTypeEnd(ParserAstType type, {required this.operator})
      : super("AsOperatorType", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "operator": operator,
      };
}

class AsOperatorHandle extends ParserAstNode {
  final Token operator;

  AsOperatorHandle(ParserAstType type, {required this.operator})
      : super("AsOperator", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "operator": operator,
      };
}

class CastPatternHandle extends ParserAstNode {
  final Token operator;

  CastPatternHandle(ParserAstType type, {required this.operator})
      : super("CastPattern", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "operator": operator,
      };
}

class AssignmentExpressionHandle extends ParserAstNode {
  final Token token;

  AssignmentExpressionHandle(ParserAstType type, {required this.token})
      : super("AssignmentExpression", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
      };
}

class BinaryExpressionBegin extends ParserAstNode {
  final Token token;

  BinaryExpressionBegin(ParserAstType type, {required this.token})
      : super("BinaryExpression", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
      };
}

class BinaryExpressionEnd extends ParserAstNode {
  final Token token;

  BinaryExpressionEnd(ParserAstType type, {required this.token})
      : super("BinaryExpression", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
      };
}

class BinaryPatternBegin extends ParserAstNode {
  final Token token;

  BinaryPatternBegin(ParserAstType type, {required this.token})
      : super("BinaryPattern", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
      };
}

class BinaryPatternEnd extends ParserAstNode {
  final Token token;

  BinaryPatternEnd(ParserAstType type, {required this.token})
      : super("BinaryPattern", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
      };
}

class EndingBinaryExpressionHandle extends ParserAstNode {
  final Token token;

  EndingBinaryExpressionHandle(ParserAstType type, {required this.token})
      : super("EndingBinaryExpression", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
      };
}

class ConditionalExpressionBegin extends ParserAstNode {
  final Token question;

  ConditionalExpressionBegin(ParserAstType type, {required this.question})
      : super("ConditionalExpression", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "question": question,
      };
}

class ConditionalExpressionColonHandle extends ParserAstNode {
  ConditionalExpressionColonHandle(ParserAstType type)
      : super("ConditionalExpressionColon", type);

  @override
  Map<String, Object?> get deprecatedArguments => {};
}

class ConditionalExpressionEnd extends ParserAstNode {
  final Token question;
  final Token colon;

  ConditionalExpressionEnd(ParserAstType type,
      {required this.question, required this.colon})
      : super("ConditionalExpression", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "question": question,
        "colon": colon,
      };
}

class ConstExpressionBegin extends ParserAstNode {
  final Token constKeyword;

  ConstExpressionBegin(ParserAstType type, {required this.constKeyword})
      : super("ConstExpression", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "constKeyword": constKeyword,
      };
}

class ConstExpressionEnd extends ParserAstNode {
  final Token token;

  ConstExpressionEnd(ParserAstType type, {required this.token})
      : super("ConstExpression", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
      };
}

class ConstFactoryHandle extends ParserAstNode {
  final Token constKeyword;

  ConstFactoryHandle(ParserAstType type, {required this.constKeyword})
      : super("ConstFactory", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "constKeyword": constKeyword,
      };
}

class ForControlFlowBegin extends ParserAstNode {
  final Token? awaitToken;
  final Token forToken;

  ForControlFlowBegin(ParserAstType type,
      {this.awaitToken, required this.forToken})
      : super("ForControlFlow", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "awaitToken": awaitToken,
        "forToken": forToken,
      };
}

class ForControlFlowEnd extends ParserAstNode {
  final Token token;

  ForControlFlowEnd(ParserAstType type, {required this.token})
      : super("ForControlFlow", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
      };
}

class ForInControlFlowEnd extends ParserAstNode {
  final Token token;

  ForInControlFlowEnd(ParserAstType type, {required this.token})
      : super("ForInControlFlow", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
      };
}

class IfControlFlowBegin extends ParserAstNode {
  final Token ifToken;

  IfControlFlowBegin(ParserAstType type, {required this.ifToken})
      : super("IfControlFlow", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "ifToken": ifToken,
      };
}

class ThenControlFlowHandle extends ParserAstNode {
  final Token token;

  ThenControlFlowHandle(ParserAstType type, {required this.token})
      : super("ThenControlFlow", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
      };
}

class ElseControlFlowHandle extends ParserAstNode {
  final Token elseToken;

  ElseControlFlowHandle(ParserAstType type, {required this.elseToken})
      : super("ElseControlFlow", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "elseToken": elseToken,
      };
}

class IfControlFlowEnd extends ParserAstNode {
  final Token token;

  IfControlFlowEnd(ParserAstType type, {required this.token})
      : super("IfControlFlow", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
      };
}

class IfElseControlFlowEnd extends ParserAstNode {
  final Token token;

  IfElseControlFlowEnd(ParserAstType type, {required this.token})
      : super("IfElseControlFlow", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
      };
}

class SpreadExpressionHandle extends ParserAstNode {
  final Token spreadToken;

  SpreadExpressionHandle(ParserAstType type, {required this.spreadToken})
      : super("SpreadExpression", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "spreadToken": spreadToken,
      };
}

class RestPatternHandle extends ParserAstNode {
  final Token dots;
  final bool hasSubPattern;

  RestPatternHandle(ParserAstType type,
      {required this.dots, required this.hasSubPattern})
      : super("RestPattern", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "dots": dots,
        "hasSubPattern": hasSubPattern,
      };
}

class FunctionTypedFormalParameterBegin extends ParserAstNode {
  final Token token;

  FunctionTypedFormalParameterBegin(ParserAstType type, {required this.token})
      : super("FunctionTypedFormalParameter", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
      };
}

class FunctionTypedFormalParameterEnd extends ParserAstNode {
  final Token nameToken;
  final Token? question;

  FunctionTypedFormalParameterEnd(ParserAstType type,
      {required this.nameToken, this.question})
      : super("FunctionTypedFormalParameter", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "nameToken": nameToken,
        "question": question,
      };
}

class IdentifierHandle extends ParserAstNode {
  final Token token;
  final IdentifierContext context;

  IdentifierHandle(ParserAstType type,
      {required this.token, required this.context})
      : super("Identifier", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
        "context": context,
      };
}

class ShowHideIdentifierHandle extends ParserAstNode {
  final Token? modifier;
  final Token identifier;

  ShowHideIdentifierHandle(ParserAstType type,
      {this.modifier, required this.identifier})
      : super("ShowHideIdentifier", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "modifier": modifier,
        "identifier": identifier,
      };
}

class IndexedExpressionHandle extends ParserAstNode {
  final Token? question;
  final Token openSquareBracket;
  final Token closeSquareBracket;

  IndexedExpressionHandle(ParserAstType type,
      {this.question,
      required this.openSquareBracket,
      required this.closeSquareBracket})
      : super("IndexedExpression", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "question": question,
        "openSquareBracket": openSquareBracket,
        "closeSquareBracket": closeSquareBracket,
      };
}

class IsOperatorTypeBegin extends ParserAstNode {
  final Token operator;

  IsOperatorTypeBegin(ParserAstType type, {required this.operator})
      : super("IsOperatorType", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "operator": operator,
      };
}

class IsOperatorTypeEnd extends ParserAstNode {
  final Token operator;

  IsOperatorTypeEnd(ParserAstType type, {required this.operator})
      : super("IsOperatorType", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "operator": operator,
      };
}

class IsOperatorHandle extends ParserAstNode {
  final Token isOperator;
  final Token? not;

  IsOperatorHandle(ParserAstType type, {required this.isOperator, this.not})
      : super("IsOperator", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "isOperator": isOperator,
        "not": not,
      };
}

class LiteralBoolHandle extends ParserAstNode {
  final Token token;

  LiteralBoolHandle(ParserAstType type, {required this.token})
      : super("LiteralBool", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
      };
}

class BreakStatementHandle extends ParserAstNode {
  final bool hasTarget;
  final Token breakKeyword;
  final Token endToken;

  BreakStatementHandle(ParserAstType type,
      {required this.hasTarget,
      required this.breakKeyword,
      required this.endToken})
      : super("BreakStatement", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "hasTarget": hasTarget,
        "breakKeyword": breakKeyword,
        "endToken": endToken,
      };
}

class ContinueStatementHandle extends ParserAstNode {
  final bool hasTarget;
  final Token continueKeyword;
  final Token endToken;

  ContinueStatementHandle(ParserAstType type,
      {required this.hasTarget,
      required this.continueKeyword,
      required this.endToken})
      : super("ContinueStatement", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "hasTarget": hasTarget,
        "continueKeyword": continueKeyword,
        "endToken": endToken,
      };
}

class EmptyStatementHandle extends ParserAstNode {
  final Token token;

  EmptyStatementHandle(ParserAstType type, {required this.token})
      : super("EmptyStatement", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
      };
}

class AssertBegin extends ParserAstNode {
  final Token assertKeyword;
  final Assert kind;

  AssertBegin(ParserAstType type,
      {required this.assertKeyword, required this.kind})
      : super("Assert", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "assertKeyword": assertKeyword,
        "kind": kind,
      };
}

class AssertEnd extends ParserAstNode {
  final Token assertKeyword;
  final Assert kind;
  final Token leftParenthesis;
  final Token? commaToken;
  final Token semicolonToken;

  AssertEnd(ParserAstType type,
      {required this.assertKeyword,
      required this.kind,
      required this.leftParenthesis,
      this.commaToken,
      required this.semicolonToken})
      : super("Assert", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "assertKeyword": assertKeyword,
        "kind": kind,
        "leftParenthesis": leftParenthesis,
        "commaToken": commaToken,
        "semicolonToken": semicolonToken,
      };
}

class LiteralDoubleHandle extends ParserAstNode {
  final Token token;

  LiteralDoubleHandle(ParserAstType type, {required this.token})
      : super("LiteralDouble", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
      };
}

class LiteralIntHandle extends ParserAstNode {
  final Token token;

  LiteralIntHandle(ParserAstType type, {required this.token})
      : super("LiteralInt", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
      };
}

class LiteralListHandle extends ParserAstNode {
  final int count;
  final Token leftBracket;
  final Token? constKeyword;
  final Token rightBracket;

  LiteralListHandle(ParserAstType type,
      {required this.count,
      required this.leftBracket,
      this.constKeyword,
      required this.rightBracket})
      : super("LiteralList", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "count": count,
        "leftBracket": leftBracket,
        "constKeyword": constKeyword,
        "rightBracket": rightBracket,
      };
}

class ListPatternHandle extends ParserAstNode {
  final int count;
  final Token leftBracket;
  final Token rightBracket;

  ListPatternHandle(ParserAstType type,
      {required this.count,
      required this.leftBracket,
      required this.rightBracket})
      : super("ListPattern", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "count": count,
        "leftBracket": leftBracket,
        "rightBracket": rightBracket,
      };
}

class LiteralSetOrMapHandle extends ParserAstNode {
  final int count;
  final Token leftBrace;
  final Token? constKeyword;
  final Token rightBrace;
  final bool hasSetEntry;

  LiteralSetOrMapHandle(ParserAstType type,
      {required this.count,
      required this.leftBrace,
      this.constKeyword,
      required this.rightBrace,
      required this.hasSetEntry})
      : super("LiteralSetOrMap", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "count": count,
        "leftBrace": leftBrace,
        "constKeyword": constKeyword,
        "rightBrace": rightBrace,
        "hasSetEntry": hasSetEntry,
      };
}

class MapPatternHandle extends ParserAstNode {
  final int count;
  final Token leftBrace;
  final Token rightBrace;

  MapPatternHandle(ParserAstType type,
      {required this.count, required this.leftBrace, required this.rightBrace})
      : super("MapPattern", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "count": count,
        "leftBrace": leftBrace,
        "rightBrace": rightBrace,
      };
}

class LiteralNullHandle extends ParserAstNode {
  final Token token;

  LiteralNullHandle(ParserAstType type, {required this.token})
      : super("LiteralNull", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
      };
}

class NativeClauseHandle extends ParserAstNode {
  final Token nativeToken;
  final bool hasName;

  NativeClauseHandle(ParserAstType type,
      {required this.nativeToken, required this.hasName})
      : super("NativeClause", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "nativeToken": nativeToken,
        "hasName": hasName,
      };
}

class NamedArgumentHandle extends ParserAstNode {
  final Token colon;

  NamedArgumentHandle(ParserAstType type, {required this.colon})
      : super("NamedArgument", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "colon": colon,
      };
}

class PatternFieldHandle extends ParserAstNode {
  final Token? colon;

  PatternFieldHandle(ParserAstType type, {this.colon})
      : super("PatternField", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "colon": colon,
      };
}

class NamedRecordFieldHandle extends ParserAstNode {
  final Token colon;

  NamedRecordFieldHandle(ParserAstType type, {required this.colon})
      : super("NamedRecordField", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "colon": colon,
      };
}

class NewExpressionBegin extends ParserAstNode {
  final Token token;

  NewExpressionBegin(ParserAstType type, {required this.token})
      : super("NewExpression", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
      };
}

class NewExpressionEnd extends ParserAstNode {
  final Token token;

  NewExpressionEnd(ParserAstType type, {required this.token})
      : super("NewExpression", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
      };
}

class NoArgumentsHandle extends ParserAstNode {
  final Token token;

  NoArgumentsHandle(ParserAstType type, {required this.token})
      : super("NoArguments", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
      };
}

class NoConstructorReferenceContinuationAfterTypeArgumentsHandle
    extends ParserAstNode {
  final Token token;

  NoConstructorReferenceContinuationAfterTypeArgumentsHandle(ParserAstType type,
      {required this.token})
      : super("NoConstructorReferenceContinuationAfterTypeArguments", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
      };
}

class NoTypeNameInConstructorReferenceHandle extends ParserAstNode {
  final Token token;

  NoTypeNameInConstructorReferenceHandle(ParserAstType type,
      {required this.token})
      : super("NoTypeNameInConstructorReference", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
      };
}

class NoTypeHandle extends ParserAstNode {
  final Token lastConsumed;

  NoTypeHandle(ParserAstType type, {required this.lastConsumed})
      : super("NoType", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "lastConsumed": lastConsumed,
      };
}

class NoTypeVariablesHandle extends ParserAstNode {
  final Token token;

  NoTypeVariablesHandle(ParserAstType type, {required this.token})
      : super("NoTypeVariables", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
      };
}

class OperatorHandle extends ParserAstNode {
  final Token token;

  OperatorHandle(ParserAstType type, {required this.token})
      : super("Operator", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
      };
}

class SwitchCaseNoWhenClauseHandle extends ParserAstNode {
  final Token token;

  SwitchCaseNoWhenClauseHandle(ParserAstType type, {required this.token})
      : super("SwitchCaseNoWhenClause", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
      };
}

class SwitchExpressionCasePatternHandle extends ParserAstNode {
  final Token token;

  SwitchExpressionCasePatternHandle(ParserAstType type, {required this.token})
      : super("SwitchExpressionCasePattern", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
      };
}

class SymbolVoidHandle extends ParserAstNode {
  final Token token;

  SymbolVoidHandle(ParserAstType type, {required this.token})
      : super("SymbolVoid", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
      };
}

class OperatorNameHandle extends ParserAstNode {
  final Token operatorKeyword;
  final Token token;

  OperatorNameHandle(ParserAstType type,
      {required this.operatorKeyword, required this.token})
      : super("OperatorName", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "operatorKeyword": operatorKeyword,
        "token": token,
      };
}

class InvalidOperatorNameHandle extends ParserAstNode {
  final Token operatorKeyword;
  final Token token;

  InvalidOperatorNameHandle(ParserAstType type,
      {required this.operatorKeyword, required this.token})
      : super("InvalidOperatorName", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "operatorKeyword": operatorKeyword,
        "token": token,
      };
}

class ParenthesizedConditionHandle extends ParserAstNode {
  final Token token;
  final Token? case_;
  final Token? when;

  ParenthesizedConditionHandle(ParserAstType type,
      {required this.token, this.case_, this.when})
      : super("ParenthesizedCondition", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
        "case_": case_,
        "when": when,
      };
}

class PatternGuardBegin extends ParserAstNode {
  final Token when;

  PatternGuardBegin(ParserAstType type, {required this.when})
      : super("PatternGuard", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "when": when,
      };
}

class ParenthesizedExpressionOrRecordLiteralBegin extends ParserAstNode {
  final Token token;

  ParenthesizedExpressionOrRecordLiteralBegin(ParserAstType type,
      {required this.token})
      : super("ParenthesizedExpressionOrRecordLiteral", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
      };
}

class SwitchCaseWhenClauseBegin extends ParserAstNode {
  final Token when;

  SwitchCaseWhenClauseBegin(ParserAstType type, {required this.when})
      : super("SwitchCaseWhenClause", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "when": when,
      };
}

class RecordLiteralEnd extends ParserAstNode {
  final Token token;
  final int count;
  final Token? constKeyword;

  RecordLiteralEnd(ParserAstType type,
      {required this.token, required this.count, this.constKeyword})
      : super("RecordLiteral", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
        "count": count,
        "constKeyword": constKeyword,
      };
}

class RecordPatternHandle extends ParserAstNode {
  final Token token;
  final int count;

  RecordPatternHandle(ParserAstType type,
      {required this.token, required this.count})
      : super("RecordPattern", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
        "count": count,
      };
}

class PatternGuardEnd extends ParserAstNode {
  final Token token;

  PatternGuardEnd(ParserAstType type, {required this.token})
      : super("PatternGuard", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
      };
}

class ParenthesizedExpressionEnd extends ParserAstNode {
  final Token token;

  ParenthesizedExpressionEnd(ParserAstType type, {required this.token})
      : super("ParenthesizedExpression", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
      };
}

class SwitchCaseWhenClauseEnd extends ParserAstNode {
  final Token token;

  SwitchCaseWhenClauseEnd(ParserAstType type, {required this.token})
      : super("SwitchCaseWhenClause", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
      };
}

class ParenthesizedPatternHandle extends ParserAstNode {
  final Token token;

  ParenthesizedPatternHandle(ParserAstType type, {required this.token})
      : super("ParenthesizedPattern", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
      };
}

class ConstantPatternBegin extends ParserAstNode {
  final Token? constKeyword;

  ConstantPatternBegin(ParserAstType type, {this.constKeyword})
      : super("ConstantPattern", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "constKeyword": constKeyword,
      };
}

class ConstantPatternEnd extends ParserAstNode {
  final Token? constKeyword;

  ConstantPatternEnd(ParserAstType type, {this.constKeyword})
      : super("ConstantPattern", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "constKeyword": constKeyword,
      };
}

class ObjectPatternHandle extends ParserAstNode {
  final Token firstIdentifier;
  final Token? dot;
  final Token? secondIdentifier;

  ObjectPatternHandle(ParserAstType type,
      {required this.firstIdentifier, this.dot, this.secondIdentifier})
      : super("ObjectPattern", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "firstIdentifier": firstIdentifier,
        "dot": dot,
        "secondIdentifier": secondIdentifier,
      };
}

class QualifiedHandle extends ParserAstNode {
  final Token period;

  QualifiedHandle(ParserAstType type, {required this.period})
      : super("Qualified", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "period": period,
      };
}

class StringPartHandle extends ParserAstNode {
  final Token token;

  StringPartHandle(ParserAstType type, {required this.token})
      : super("StringPart", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
      };
}

class SuperExpressionHandle extends ParserAstNode {
  final Token token;
  final IdentifierContext context;

  SuperExpressionHandle(ParserAstType type,
      {required this.token, required this.context})
      : super("SuperExpression", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
        "context": context,
      };
}

class AugmentSuperExpressionHandle extends ParserAstNode {
  final Token augmentToken;
  final Token superToken;
  final IdentifierContext context;

  AugmentSuperExpressionHandle(ParserAstType type,
      {required this.augmentToken,
      required this.superToken,
      required this.context})
      : super("AugmentSuperExpression", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "augmentToken": augmentToken,
        "superToken": superToken,
        "context": context,
      };
}

class SwitchCaseBegin extends ParserAstNode {
  final int labelCount;
  final int expressionCount;
  final Token firstToken;

  SwitchCaseBegin(ParserAstType type,
      {required this.labelCount,
      required this.expressionCount,
      required this.firstToken})
      : super("SwitchCase", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "labelCount": labelCount,
        "expressionCount": expressionCount,
        "firstToken": firstToken,
      };
}

class SwitchCaseEnd extends ParserAstNode {
  final int labelCount;
  final int expressionCount;
  final Token? defaultKeyword;
  final Token? colonAfterDefault;
  final int statementCount;
  final Token firstToken;
  final Token endToken;

  SwitchCaseEnd(ParserAstType type,
      {required this.labelCount,
      required this.expressionCount,
      this.defaultKeyword,
      this.colonAfterDefault,
      required this.statementCount,
      required this.firstToken,
      required this.endToken})
      : super("SwitchCase", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "labelCount": labelCount,
        "expressionCount": expressionCount,
        "defaultKeyword": defaultKeyword,
        "colonAfterDefault": colonAfterDefault,
        "statementCount": statementCount,
        "firstToken": firstToken,
        "endToken": endToken,
      };
}

class SwitchExpressionCaseBegin extends ParserAstNode {
  SwitchExpressionCaseBegin(ParserAstType type)
      : super("SwitchExpressionCase", type);

  @override
  Map<String, Object?> get deprecatedArguments => {};
}

class SwitchExpressionCaseEnd extends ParserAstNode {
  final Token? when;
  final Token arrow;
  final Token endToken;

  SwitchExpressionCaseEnd(ParserAstType type,
      {this.when, required this.arrow, required this.endToken})
      : super("SwitchExpressionCase", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "when": when,
        "arrow": arrow,
        "endToken": endToken,
      };
}

class ThisExpressionHandle extends ParserAstNode {
  final Token token;
  final IdentifierContext context;

  ThisExpressionHandle(ParserAstType type,
      {required this.token, required this.context})
      : super("ThisExpression", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
        "context": context,
      };
}

class UnaryPostfixAssignmentExpressionHandle extends ParserAstNode {
  final Token token;

  UnaryPostfixAssignmentExpressionHandle(ParserAstType type,
      {required this.token})
      : super("UnaryPostfixAssignmentExpression", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
      };
}

class UnaryPrefixExpressionHandle extends ParserAstNode {
  final Token token;

  UnaryPrefixExpressionHandle(ParserAstType type, {required this.token})
      : super("UnaryPrefixExpression", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
      };
}

class RelationalPatternHandle extends ParserAstNode {
  final Token token;

  RelationalPatternHandle(ParserAstType type, {required this.token})
      : super("RelationalPattern", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
      };
}

class UnaryPrefixAssignmentExpressionHandle extends ParserAstNode {
  final Token token;

  UnaryPrefixAssignmentExpressionHandle(ParserAstType type,
      {required this.token})
      : super("UnaryPrefixAssignmentExpression", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
      };
}

class FormalParameterDefaultValueExpressionBegin extends ParserAstNode {
  FormalParameterDefaultValueExpressionBegin(ParserAstType type)
      : super("FormalParameterDefaultValueExpression", type);

  @override
  Map<String, Object?> get deprecatedArguments => {};
}

class FormalParameterDefaultValueExpressionEnd extends ParserAstNode {
  FormalParameterDefaultValueExpressionEnd(ParserAstType type)
      : super("FormalParameterDefaultValueExpression", type);

  @override
  Map<String, Object?> get deprecatedArguments => {};
}

class ValuedFormalParameterHandle extends ParserAstNode {
  final Token equals;
  final Token token;
  final FormalParameterKind kind;

  ValuedFormalParameterHandle(ParserAstType type,
      {required this.equals, required this.token, required this.kind})
      : super("ValuedFormalParameter", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "equals": equals,
        "token": token,
        "kind": kind,
      };
}

class FormalParameterWithoutValueHandle extends ParserAstNode {
  final Token token;

  FormalParameterWithoutValueHandle(ParserAstType type, {required this.token})
      : super("FormalParameterWithoutValue", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
      };
}

class VoidKeywordHandle extends ParserAstNode {
  final Token token;

  VoidKeywordHandle(ParserAstType type, {required this.token})
      : super("VoidKeyword", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
      };
}

class VoidKeywordWithTypeArgumentsHandle extends ParserAstNode {
  final Token token;

  VoidKeywordWithTypeArgumentsHandle(ParserAstType type, {required this.token})
      : super("VoidKeywordWithTypeArguments", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
      };
}

class YieldStatementBegin extends ParserAstNode {
  final Token token;

  YieldStatementBegin(ParserAstType type, {required this.token})
      : super("YieldStatement", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
      };
}

class YieldStatementEnd extends ParserAstNode {
  final Token yieldToken;
  final Token? starToken;
  final Token endToken;

  YieldStatementEnd(ParserAstType type,
      {required this.yieldToken, this.starToken, required this.endToken})
      : super("YieldStatement", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "yieldToken": yieldToken,
        "starToken": starToken,
        "endToken": endToken,
      };
}

class InvalidYieldStatementEnd extends ParserAstNode {
  final Token beginToken;
  final Token? starToken;
  final Token endToken;
  final MessageCode errorCode;

  InvalidYieldStatementEnd(ParserAstType type,
      {required this.beginToken,
      this.starToken,
      required this.endToken,
      required this.errorCode})
      : super("InvalidYieldStatement", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "beginToken": beginToken,
        "starToken": starToken,
        "endToken": endToken,
        "errorCode": errorCode,
      };
}

class RecoverableErrorHandle extends ParserAstNode {
  final Message message;
  final Token startToken;
  final Token endToken;

  RecoverableErrorHandle(ParserAstType type,
      {required this.message, required this.startToken, required this.endToken})
      : super("RecoverableError", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "message": message,
        "startToken": startToken,
        "endToken": endToken,
      };
}

class ExperimentNotEnabledHandle extends ParserAstNode {
  final ExperimentalFlag experimentalFlag;
  final Token startToken;
  final Token endToken;

  ExperimentNotEnabledHandle(ParserAstType type,
      {required this.experimentalFlag,
      required this.startToken,
      required this.endToken})
      : super("ExperimentNotEnabled", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "experimentalFlag": experimentalFlag,
        "startToken": startToken,
        "endToken": endToken,
      };
}

class ErrorTokenHandle extends ParserAstNode {
  final ErrorToken token;

  ErrorTokenHandle(ParserAstType type, {required this.token})
      : super("ErrorToken", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
      };
}

class UnescapeErrorHandle extends ParserAstNode {
  final Message message;
  final Token location;
  final int stringOffset;
  final int length;

  UnescapeErrorHandle(ParserAstType type,
      {required this.message,
      required this.location,
      required this.stringOffset,
      required this.length})
      : super("UnescapeError", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "message": message,
        "location": location,
        "stringOffset": stringOffset,
        "length": length,
      };
}

class InvalidStatementHandle extends ParserAstNode {
  final Token token;
  final Message message;

  InvalidStatementHandle(ParserAstType type,
      {required this.token, required this.message})
      : super("InvalidStatement", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
        "message": message,
      };
}

class ScriptHandle extends ParserAstNode {
  final Token token;

  ScriptHandle(ParserAstType type, {required this.token})
      : super("Script", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
      };
}

class CommentReferenceTextHandle extends ParserAstNode {
  final String referenceSource;
  final int referenceOffset;

  CommentReferenceTextHandle(ParserAstType type,
      {required this.referenceSource, required this.referenceOffset})
      : super("CommentReferenceText", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "referenceSource": referenceSource,
        "referenceOffset": referenceOffset,
      };
}

class CommentReferenceHandle extends ParserAstNode {
  final Token? newKeyword;
  final Token? firstToken;
  final Token? firstPeriod;
  final Token? secondToken;
  final Token? secondPeriod;
  final Token thirdToken;

  CommentReferenceHandle(ParserAstType type,
      {this.newKeyword,
      this.firstToken,
      this.firstPeriod,
      this.secondToken,
      this.secondPeriod,
      required this.thirdToken})
      : super("CommentReference", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "newKeyword": newKeyword,
        "firstToken": firstToken,
        "firstPeriod": firstPeriod,
        "secondToken": secondToken,
        "secondPeriod": secondPeriod,
        "thirdToken": thirdToken,
      };
}

class NoCommentReferenceHandle extends ParserAstNode {
  NoCommentReferenceHandle(ParserAstType type)
      : super("NoCommentReference", type);

  @override
  Map<String, Object?> get deprecatedArguments => {};
}

class TypeArgumentApplicationHandle extends ParserAstNode {
  final Token openAngleBracket;

  TypeArgumentApplicationHandle(ParserAstType type,
      {required this.openAngleBracket})
      : super("TypeArgumentApplication", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "openAngleBracket": openAngleBracket,
      };
}

class NewAsIdentifierHandle extends ParserAstNode {
  final Token token;

  NewAsIdentifierHandle(ParserAstType type, {required this.token})
      : super("NewAsIdentifier", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "token": token,
      };
}

class PatternVariableDeclarationStatementHandle extends ParserAstNode {
  final Token keyword;
  final Token equals;
  final Token semicolon;

  PatternVariableDeclarationStatementHandle(ParserAstType type,
      {required this.keyword, required this.equals, required this.semicolon})
      : super("PatternVariableDeclarationStatement", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "keyword": keyword,
        "equals": equals,
        "semicolon": semicolon,
      };
}

class PatternAssignmentHandle extends ParserAstNode {
  final Token equals;

  PatternAssignmentHandle(ParserAstType type, {required this.equals})
      : super("PatternAssignment", type);

  @override
  Map<String, Object?> get deprecatedArguments => {
        "equals": equals,
      };
}
