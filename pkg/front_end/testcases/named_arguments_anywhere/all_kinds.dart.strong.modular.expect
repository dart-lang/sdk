library;
import self as self;
import "dart:core" as core;

typedef B = self::A;
class A extends core::Object {
  constructor •(core::int x, core::int y, {required core::int z}) → self::A
    : super core::Object::•()
    ;
  static factory foo(core::int x, core::int y, {required core::int z}) → self::A
    return new self::A::•(x, y, z: z);
  get property() → (core::int, core::int, {required z: core::int}) → void
    return (core::int x, core::int y, {required core::int z}) → void {};
  method bar(core::int x, core::int y, {required core::int z}) → void {}
}
class Test extends self::A {
  constructor •() → self::Test
    : super self::A::•(self::t(1), self::t(2), z: self::t(3))
    ;
  constructor c1() → self::Test
    : final core::int #t1 = self::t(1), final core::int #t2 = self::t(2), super self::A::•(#t1, self::t(3), z: #t2)
    ;
  constructor c2() → self::Test
    : final core::int #t3 = self::t(1), super self::A::•(self::t(2), self::t(3), z: #t3)
    ;
  method test() → dynamic {
    self::reset();
    super.{self::A::bar}(self::t(1), self::t(2), z: self::t(3));
    self::reset();
    let final core::int #t4 = self::t(1) in let final core::int #t5 = self::t(2) in super.{self::A::bar}(#t4, self::t(3), z: #t5);
    self::reset();
    let final core::int #t6 = self::t(1) in super.{self::A::bar}(self::t(2), self::t(3), z: #t6);
  }
}
extension E on core::int {
  method method1 = self::E|method1;
  method tearoff method1 = self::E|get#method1;
  method method2 = self::E|method2;
  method tearoff method2 = self::E|get#method2;
  static method staticMethod2 = self::E|staticMethod2;
}
static field core::int counter = 1;
static method reset() → void {
  self::counter = 1;
}
static method t(core::int value) → core::int {
  if(!(self::counter =={core::num::==}{(core::Object) → core::bool} value)) {
    throw "Expected ${self::counter}, actual ${value}";
  }
  self::counter = self::counter.{core::num::+}(1){(core::num) → core::int};
  return value;
}
static method foo(core::int x, core::int y, {required core::int z}) → dynamic {}
static extension-member method E|method1(lowered final core::int #this) → dynamic {
  self::reset();
  let final core::int #t7 = #this in let final core::int #t8 = self::t(1) in self::E|method2(#t7, self::t(2), foo: #t8);
  self::reset();
  let final core::int #t9 = self::t(1) in self::E|staticMethod2(self::t(2), foo: #t9);
}
static extension-member method E|get#method1(lowered final core::int #this) → () → dynamic
  return () → dynamic => self::E|method1(#this);
static extension-member method E|method2(lowered final core::int #this, core::int bar, {core::int? foo = #C1}) → dynamic {}
static extension-member method E|get#method2(lowered final core::int #this) → (core::int, {foo: core::int?}) → dynamic
  return (core::int bar, {core::int? foo = #C1}) → dynamic => self::E|method2(#this, bar, foo: foo);
static extension-member method E|staticMethod2(core::int bar, {core::int? foo = #C1}) → dynamic {}
static method test(dynamic d, core::Function f, self::A a) → dynamic {
  function local(core::int x, core::int y, {required core::int z}) → void {}
  self::reset();
  self::foo(self::t(1), self::t(2), z: self::t(3));
  self::reset();
  let final core::int #t10 = self::t(1) in let final core::int #t11 = self::t(2) in self::foo(#t10, self::t(3), z: #t11);
  self::reset();
  let final core::int #t12 = self::t(1) in self::foo(self::t(2), self::t(3), z: #t12);
  self::reset();
  self::A::foo(self::t(1), self::t(2), z: self::t(3));
  self::reset();
  let final core::int #t13 = self::t(1) in let final core::int #t14 = self::t(2) in self::A::foo(#t13, self::t(3), z: #t14);
  self::reset();
  let final core::int #t15 = self::t(1) in self::A::foo(self::t(2), self::t(3), z: #t15);
  self::reset();
  self::A::foo(self::t(1), self::t(2), z: self::t(3));
  self::reset();
  let final core::int #t16 = self::t(1) in let final core::int #t17 = self::t(2) in self::A::foo(#t16, self::t(3), z: #t17);
  self::reset();
  let final core::int #t18 = self::t(1) in self::A::foo(self::t(2), self::t(3), z: #t18);
  self::reset();
  new self::A::•(self::t(1), self::t(2), z: self::t(3));
  self::reset();
  let final core::int #t19 = self::t(1) in let final core::int #t20 = self::t(2) in new self::A::•(#t19, self::t(3), z: #t20);
  self::reset();
  let final core::int #t21 = self::t(1) in new self::A::•(self::t(2), self::t(3), z: #t21);
  self::reset();
  new self::A::•(self::t(1), self::t(2), z: self::t(3));
  self::reset();
  let final core::int #t22 = self::t(1) in let final core::int #t23 = self::t(2) in new self::A::•(#t22, self::t(3), z: #t23);
  self::reset();
  let final core::int #t24 = self::t(1) in new self::A::•(self::t(2), self::t(3), z: #t24);
  self::reset();
  d{dynamic}(self::t(1), self::t(2), z: self::t(3));
  self::reset();
  let final core::int #t25 = self::t(1) in let final core::int #t26 = self::t(2) in d{dynamic}(#t25, self::t(3), z: #t26);
  self::reset();
  let final core::int #t27 = self::t(1) in d{dynamic}(self::t(2), self::t(3), z: #t27);
  self::reset();
  f(self::t(1), self::t(2), z: self::t(3));
  self::reset();
  let final core::int #t28 = self::t(1) in let final core::int #t29 = self::t(2) in f(#t28, self::t(3), z: #t29);
  self::reset();
  let final core::int #t30 = self::t(1) in f(self::t(2), self::t(3), z: #t30);
  self::reset();
  let final self::A #t31 = a in let final core::int #t32 = self::t(1) in let final core::int #t33 = self::t(2) in let final core::int #t34 = self::t(3) in #t31.{self::A::property}{(core::int, core::int, {required z: core::int}) → void}(#t32, #t33, z: #t34){(core::int, core::int, {required z: core::int}) → void};
  self::reset();
  let final self::A #t35 = a in let final core::int #t36 = self::t(1) in let final core::int #t37 = self::t(2) in let final core::int #t38 = self::t(3) in #t35.{self::A::property}{(core::int, core::int, {required z: core::int}) → void}(#t36, #t38, z: #t37){(core::int, core::int, {required z: core::int}) → void};
  self::reset();
  let final self::A #t39 = a in let final core::int #t40 = self::t(1) in let final core::int #t41 = self::t(2) in let final core::int #t42 = self::t(3) in #t39.{self::A::property}{(core::int, core::int, {required z: core::int}) → void}(#t41, #t42, z: #t40){(core::int, core::int, {required z: core::int}) → void};
  self::reset();
  a.{self::A::bar}(self::t(1), self::t(2), z: self::t(3)){(core::int, core::int, {required z: core::int}) → void};
  self::reset();
  let final self::A #t43 = a in let final core::int #t44 = self::t(1) in let final core::int #t45 = self::t(2) in #t43.{self::A::bar}(#t44, self::t(3), z: #t45){(core::int, core::int, {required z: core::int}) → void};
  self::reset();
  let final self::A #t46 = a in let final core::int #t47 = self::t(1) in #t46.{self::A::bar}(self::t(2), self::t(3), z: #t47){(core::int, core::int, {required z: core::int}) → void};
  self::reset();
  local(self::t(1), self::t(2), z: self::t(3)){(core::int, core::int, {required z: core::int}) → void};
  self::reset();
  let final core::int #t48 = self::t(1) in let final core::int #t49 = self::t(2) in local(#t48, self::t(3), z: #t49){(core::int, core::int, {required z: core::int}) → void};
  self::reset();
  let final core::int #t50 = self::t(1) in local(self::t(2), self::t(3), z: #t50){(core::int, core::int, {required z: core::int}) → void};
  self::reset();
  let final core::int #t51 = self::t(1) in let final core::int #t52 = self::t(2) in self::E|method2(#t51, self::t(3), foo: #t52);
  self::reset();
  self::E|method2(self::t(1), self::t(2), foo: self::t(3));
  self::reset();
  let final core::int #t53 = self::t(1) in let final core::int #t54 = self::t(2) in self::E|method2(#t53, self::t(3), foo: #t54);
  self::reset();
  self::E|method2(self::t(1), self::t(2), foo: self::t(3));
  self::reset();
  let final core::int #t55 = self::t(1) in self::E|staticMethod2(self::t(2), foo: #t55);
  self::reset();
  self::E|staticMethod2(self::t(1), foo: self::t(2));
}
static method main() → dynamic {
  self::reset();
  new self::Test::•().{self::Test::test}(){() → dynamic};
  self::reset();
  new self::Test::c1();
  self::reset();
  new self::Test::c2();
  self::A a = new self::A::•(1.{core::int::unary-}(){() → core::int}, 1.{core::int::unary-}(){() → core::int}, z: 1.{core::int::unary-}(){() → core::int});
  (core::int, core::int, {required z: core::int}) → Null f = (core::int x, core::int y, {required core::int z}) → Null {};
  self::test(f, f, a);
  self::E|method1(0);
}

constants  {
  #C1 = null
}
