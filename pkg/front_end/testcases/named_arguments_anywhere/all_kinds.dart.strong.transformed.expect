library;
import self as self;
import "dart:core" as core;

typedef B = self::A;
class A extends core::Object {
  constructor •(core::int x, core::int y, {required core::int z}) → self::A
    : super core::Object::•()
    ;
  static factory foo(core::int x, core::int y, {required core::int z}) → self::A
    return new self::A::•(x, y, z: z);
  get property() → (core::int, core::int, {required z: core::int}) → void
    return (core::int x, core::int y, {required core::int z}) → void {};
  method bar(core::int x, core::int y, {required core::int z}) → void {}
}
class Test extends self::A {
  constructor •() → self::Test
    : super self::A::•(self::t(1), self::t(2), z: self::t(3))
    ;
  constructor c1() → self::Test
    : final core::int #t1 = self::t(1), final core::int #t2 = self::t(2), super self::A::•(#t1, self::t(3), z: #t2)
    ;
  constructor c2() → self::Test
    : final core::int #t3 = self::t(1), super self::A::•(self::t(2), self::t(3), z: #t3)
    ;
  method test() → dynamic {
    self::reset();
    super.{self::A::bar}(self::t(1), self::t(2), z: self::t(3));
    self::reset();
    let final core::int #t4 = self::t(1) in let final core::int #t5 = self::t(2) in super.{self::A::bar}(#t4, self::t(3), z: #t5);
    self::reset();
    let final core::int #t6 = self::t(1) in super.{self::A::bar}(self::t(2), self::t(3), z: #t6);
  }
}
extension E on core::int {
  method method1 = self::E|method1;
  method tearoff method1 = self::E|get#method1;
  method method2 = self::E|method2;
  method tearoff method2 = self::E|get#method2;
  static method staticMethod2 = self::E|staticMethod2;
}
static field core::int counter = 1;
static method reset() → void {
  self::counter = 1;
}
static method t(core::int value) → core::int {
  if(!(self::counter =={core::num::==}{(core::Object) → core::bool} value)) {
    throw "Expected ${self::counter}, actual ${value}";
  }
  self::counter = self::counter.{core::num::+}(1){(core::num) → core::int};
  return value;
}
static method foo(core::int x, core::int y, {required core::int z}) → dynamic {}
static extension-member method E|method1(lowered final core::int #this) → dynamic {
  self::reset();
  let final core::int #t7 = self::t(1) in self::E|method2(#this, self::t(2), foo: #t7);
  self::reset();
  let final core::int #t8 = self::t(1) in self::E|staticMethod2(self::t(2), foo: #t8);
}
static extension-member method E|get#method1(lowered final core::int #this) → () → dynamic
  return () → dynamic => self::E|method1(#this);
static extension-member method E|method2(lowered final core::int #this, core::int bar, {core::int? foo = #C1}) → dynamic {}
static extension-member method E|get#method2(lowered final core::int #this) → (core::int, {foo: core::int?}) → dynamic
  return (core::int bar, {core::int? foo = #C1}) → dynamic => self::E|method2(#this, bar, foo: foo);
static extension-member method E|staticMethod2(core::int bar, {core::int? foo = #C1}) → dynamic {}
static method test(dynamic d, core::Function f, self::A a) → dynamic {
  function local(core::int x, core::int y, {required core::int z}) → void {}
  self::reset();
  self::foo(self::t(1), self::t(2), z: self::t(3));
  self::reset();
  let final core::int #t9 = self::t(1) in let final core::int #t10 = self::t(2) in self::foo(#t9, self::t(3), z: #t10);
  self::reset();
  let final core::int #t11 = self::t(1) in self::foo(self::t(2), self::t(3), z: #t11);
  self::reset();
  self::A::foo(self::t(1), self::t(2), z: self::t(3));
  self::reset();
  let final core::int #t12 = self::t(1) in let final core::int #t13 = self::t(2) in self::A::foo(#t12, self::t(3), z: #t13);
  self::reset();
  let final core::int #t14 = self::t(1) in self::A::foo(self::t(2), self::t(3), z: #t14);
  self::reset();
  self::A::foo(self::t(1), self::t(2), z: self::t(3));
  self::reset();
  let final core::int #t15 = self::t(1) in let final core::int #t16 = self::t(2) in self::A::foo(#t15, self::t(3), z: #t16);
  self::reset();
  let final core::int #t17 = self::t(1) in self::A::foo(self::t(2), self::t(3), z: #t17);
  self::reset();
  new self::A::•(self::t(1), self::t(2), z: self::t(3));
  self::reset();
  let final core::int #t18 = self::t(1) in let final core::int #t19 = self::t(2) in new self::A::•(#t18, self::t(3), z: #t19);
  self::reset();
  let final core::int #t20 = self::t(1) in new self::A::•(self::t(2), self::t(3), z: #t20);
  self::reset();
  new self::A::•(self::t(1), self::t(2), z: self::t(3));
  self::reset();
  let final core::int #t21 = self::t(1) in let final core::int #t22 = self::t(2) in new self::A::•(#t21, self::t(3), z: #t22);
  self::reset();
  let final core::int #t23 = self::t(1) in new self::A::•(self::t(2), self::t(3), z: #t23);
  self::reset();
  d{dynamic}(self::t(1), self::t(2), z: self::t(3));
  self::reset();
  let final core::int #t24 = self::t(1) in let final core::int #t25 = self::t(2) in d{dynamic}(#t24, self::t(3), z: #t25);
  self::reset();
  let final core::int #t26 = self::t(1) in d{dynamic}(self::t(2), self::t(3), z: #t26);
  self::reset();
  f(self::t(1), self::t(2), z: self::t(3));
  self::reset();
  let final core::int #t27 = self::t(1) in let final core::int #t28 = self::t(2) in f(#t27, self::t(3), z: #t28);
  self::reset();
  let final core::int #t29 = self::t(1) in f(self::t(2), self::t(3), z: #t29);
  self::reset();
  let final self::A #t30 = a in let final core::int #t31 = self::t(1) in let final core::int #t32 = self::t(2) in let final core::int #t33 = self::t(3) in #t30.{self::A::property}{(core::int, core::int, {required z: core::int}) → void}(#t31, #t32, z: #t33){(core::int, core::int, {required z: core::int}) → void};
  self::reset();
  let final self::A #t34 = a in let final core::int #t35 = self::t(1) in let final core::int #t36 = self::t(2) in let final core::int #t37 = self::t(3) in #t34.{self::A::property}{(core::int, core::int, {required z: core::int}) → void}(#t35, #t37, z: #t36){(core::int, core::int, {required z: core::int}) → void};
  self::reset();
  let final self::A #t38 = a in let final core::int #t39 = self::t(1) in let final core::int #t40 = self::t(2) in let final core::int #t41 = self::t(3) in #t38.{self::A::property}{(core::int, core::int, {required z: core::int}) → void}(#t40, #t41, z: #t39){(core::int, core::int, {required z: core::int}) → void};
  self::reset();
  a.{self::A::bar}(self::t(1), self::t(2), z: self::t(3)){(core::int, core::int, {required z: core::int}) → void};
  self::reset();
  let final self::A #t42 = a in let final core::int #t43 = self::t(1) in let final core::int #t44 = self::t(2) in #t42.{self::A::bar}(#t43, self::t(3), z: #t44){(core::int, core::int, {required z: core::int}) → void};
  self::reset();
  let final self::A #t45 = a in let final core::int #t46 = self::t(1) in #t45.{self::A::bar}(self::t(2), self::t(3), z: #t46){(core::int, core::int, {required z: core::int}) → void};
  self::reset();
  local(self::t(1), self::t(2), z: self::t(3)){(core::int, core::int, {required z: core::int}) → void};
  self::reset();
  let final core::int #t47 = self::t(1) in let final core::int #t48 = self::t(2) in local(#t47, self::t(3), z: #t48){(core::int, core::int, {required z: core::int}) → void};
  self::reset();
  let final core::int #t49 = self::t(1) in local(self::t(2), self::t(3), z: #t49){(core::int, core::int, {required z: core::int}) → void};
  self::reset();
  let final core::int #t50 = self::t(1) in let final core::int #t51 = self::t(2) in self::E|method2(#t50, self::t(3), foo: #t51);
  self::reset();
  self::E|method2(self::t(1), self::t(2), foo: self::t(3));
  self::reset();
  let final core::int #t52 = self::t(1) in let final core::int #t53 = self::t(2) in self::E|method2(#t52, self::t(3), foo: #t53);
  self::reset();
  self::E|method2(self::t(1), self::t(2), foo: self::t(3));
  self::reset();
  let final core::int #t54 = self::t(1) in self::E|staticMethod2(self::t(2), foo: #t54);
  self::reset();
  self::E|staticMethod2(self::t(1), foo: self::t(2));
}
static method main() → dynamic {
  self::reset();
  new self::Test::•().{self::Test::test}(){() → dynamic};
  self::reset();
  new self::Test::c1();
  self::reset();
  new self::Test::c2();
  self::A a = new self::A::•(1.{core::int::unary-}(){() → core::int}, 1.{core::int::unary-}(){() → core::int}, z: 1.{core::int::unary-}(){() → core::int});
  (core::int, core::int, {required z: core::int}) → Null f = (core::int x, core::int y, {required core::int z}) → Null {};
  self::test(f, f, a);
  self::E|method1(0);
}

constants  {
  #C1 = null
}

Extra constant evaluation status:
Evaluated: InstanceInvocation @ org-dartlang-testcase:///all_kinds.dart:170:13 -> IntConstant(-1)
Evaluated: InstanceInvocation @ org-dartlang-testcase:///all_kinds.dart:170:17 -> IntConstant(-1)
Evaluated: InstanceInvocation @ org-dartlang-testcase:///all_kinds.dart:170:24 -> IntConstant(-1)
Extra constant evaluation: evaluated: 374, effectively constant: 3
