library test;
//
// Problems in library:
//
// pkg/front_end/testcases/inference_new/infer_assign_to_index_this_upwards.dart:109:27: Error: A value of type 'int' can't be assigned to a variable of type 'double'.
//         /*@target=num.+*/ += getInt();
//                           ^
//
// pkg/front_end/testcases/inference_new/infer_assign_to_index_this_upwards.dart:119:50: Error: A value of type 'int' can't be assigned to a variable of type 'double'.
//     var /*@ type=int* */ v10 = /*@target=num.+*/ ++this
//                                                  ^
//
// pkg/front_end/testcases/inference_new/infer_assign_to_index_this_upwards.dart:124:27: Error: A value of type 'int' can't be assigned to a variable of type 'double'.
//         /*@target=num.+*/ ++;
//                           ^
//
// pkg/front_end/testcases/inference_new/infer_assign_to_index_this_upwards.dart:264:30: Error: A value of type 'double' can't be assigned to a variable of type 'int'.
//         /*@target=double.+*/ += getInt();
//                              ^
//
// pkg/front_end/testcases/inference_new/infer_assign_to_index_this_upwards.dart:268:30: Error: A value of type 'double' can't be assigned to a variable of type 'int'.
//         /*@target=double.+*/ += getNum();
//                              ^
//
// pkg/front_end/testcases/inference_new/infer_assign_to_index_this_upwards.dart:270:56: Error: A value of type 'double' can't be assigned to a variable of type 'int'.
//     var /*@ type=double* */ v10 = /*@target=double.+*/ ++this
//                                                        ^
//
// pkg/front_end/testcases/inference_new/infer_assign_to_index_this_upwards.dart:275:30: Error: A value of type 'double' can't be assigned to a variable of type 'int'.
//         /*@target=double.+*/ ++;
//                              ^
//
import self as self;
import "dart:core" as core;

abstract class Test1 extends core::Object {
  synthetic constructor •() → self::Test1*
    : super core::Object::•()
    ;
  abstract operator [](core::String* s) → core::int*;
  abstract operator []=(core::String* s, core::int* v) → void;
  method test() → void {
    core::int* v1 = let final core::String* #t1 = "x" in let final core::int* #t2 = self::getInt() in let final void #t3 = this.{self::Test1::[]=}(#t1, #t2){(core::String*, core::int*) →* void} in #t2;
    core::num* v2 = let final core::String* #t4 = "x" in let final core::num* #t5 = self::getNum() as{TypeError} core::int* in let final void #t6 = this.{self::Test1::[]=}(#t4, #t5){(core::String*, core::int*) →* void} in #t5;
    core::int* v4 = let final core::String* #t7 = "x" in let final core::int* #t8 = this.{self::Test1::[]}(#t7){(core::String*) →* core::int*} in #t8 == null ?{core::int*} let final core::int* #t9 = self::getInt() in let final void #t10 = this.{self::Test1::[]=}(#t7, #t9){(core::String*, core::int*) →* void} in #t9 : #t8;
    core::num* v5 = let final core::String* #t11 = "x" in let final core::int* #t12 = this.{self::Test1::[]}(#t11){(core::String*) →* core::int*} in #t12 == null ?{core::num*} let final core::num* #t13 = self::getNum() as{TypeError} core::int* in let final void #t14 = this.{self::Test1::[]=}(#t11, #t13){(core::String*, core::int*) →* void} in #t13 : #t12;
    core::int* v7 = let final core::String* #t15 = "x" in let final core::int* #t16 = this.{self::Test1::[]}(#t15){(core::String*) →* core::int*}.{core::num::+}(self::getInt()){(core::num*) →* core::int*} in let final void #t17 = this.{self::Test1::[]=}(#t15, #t16){(core::String*, core::int*) →* void} in #t16;
    core::num* v8 = let final core::String* #t18 = "x" in let final core::num* #t19 = this.{self::Test1::[]}(#t18){(core::String*) →* core::int*}.{core::num::+}(self::getNum()){(core::num*) →* core::num*} as{TypeError} core::int* in let final void #t20 = this.{self::Test1::[]=}(#t18, #t19){(core::String*, core::int*) →* void} in #t19;
    core::int* v10 = let final core::String* #t21 = "x" in let final core::int* #t22 = this.{self::Test1::[]}(#t21){(core::String*) →* core::int*}.{core::num::+}(1){(core::num*) →* core::int*} in let final void #t23 = this.{self::Test1::[]=}(#t21, #t22){(core::String*, core::int*) →* void} in #t22;
    core::int* v11 = let final core::String* #t24 = "x" in let final core::int* #t25 = this.{self::Test1::[]}(#t24){(core::String*) →* core::int*} in let final void #t26 = this.{self::Test1::[]=}(#t24, #t25.{core::num::+}(1){(core::num*) →* core::int*}){(core::String*, core::int*) →* void} in #t25;
  }
  abstract member-signature get _identityHashCode() → core::int*; -> core::Object::_identityHashCode
  abstract member-signature method _instanceOf(dynamic instantiatorTypeArguments, dynamic functionTypeArguments, dynamic type) → core::bool*; -> core::Object::_instanceOf
  abstract member-signature method _simpleInstanceOf(dynamic type) → core::bool*; -> core::Object::_simpleInstanceOf
  abstract member-signature method _simpleInstanceOfTrue(dynamic type) → core::bool*; -> core::Object::_simpleInstanceOfTrue
  abstract member-signature method _simpleInstanceOfFalse(dynamic type) → core::bool*; -> core::Object::_simpleInstanceOfFalse
  abstract member-signature operator ==(dynamic other) → core::bool*; -> core::Object::==
  abstract member-signature get hashCode() → core::int*; -> core::Object::hashCode
  abstract member-signature method toString() → core::String*; -> core::Object::toString
  abstract member-signature method noSuchMethod(core::Invocation* invocation) → dynamic; -> core::Object::noSuchMethod
  abstract member-signature get runtimeType() → core::Type*; -> core::Object::runtimeType
}
abstract class Test2 extends core::Object {
  synthetic constructor •() → self::Test2*
    : super core::Object::•()
    ;
  abstract operator [](core::String* s) → core::int*;
  abstract operator []=(core::String* s, core::num* v) → void;
  method test() → void {
    core::int* v1 = let final core::String* #t27 = "x" in let final core::int* #t28 = self::getInt() in let final void #t29 = this.{self::Test2::[]=}(#t27, #t28){(core::String*, core::num*) →* void} in #t28;
    core::num* v2 = let final core::String* #t30 = "x" in let final core::num* #t31 = self::getNum() in let final void #t32 = this.{self::Test2::[]=}(#t30, #t31){(core::String*, core::num*) →* void} in #t31;
    core::double* v3 = let final core::String* #t33 = "x" in let final core::double* #t34 = self::getDouble() in let final void #t35 = this.{self::Test2::[]=}(#t33, #t34){(core::String*, core::num*) →* void} in #t34;
    core::int* v4 = let final core::String* #t36 = "x" in let final core::int* #t37 = this.{self::Test2::[]}(#t36){(core::String*) →* core::int*} in #t37 == null ?{core::int*} let final core::int* #t38 = self::getInt() in let final void #t39 = this.{self::Test2::[]=}(#t36, #t38){(core::String*, core::num*) →* void} in #t38 : #t37;
    core::num* v5 = let final core::String* #t40 = "x" in let final core::int* #t41 = this.{self::Test2::[]}(#t40){(core::String*) →* core::int*} in #t41 == null ?{core::num*} let final core::num* #t42 = self::getNum() in let final void #t43 = this.{self::Test2::[]=}(#t40, #t42){(core::String*, core::num*) →* void} in #t42 : #t41;
    core::num* v6 = let final core::String* #t44 = "x" in let final core::int* #t45 = this.{self::Test2::[]}(#t44){(core::String*) →* core::int*} in #t45 == null ?{core::num*} let final core::double* #t46 = self::getDouble() in let final void #t47 = this.{self::Test2::[]=}(#t44, #t46){(core::String*, core::num*) →* void} in #t46 : #t45;
    core::int* v7 = let final core::String* #t48 = "x" in let final core::int* #t49 = this.{self::Test2::[]}(#t48){(core::String*) →* core::int*}.{core::num::+}(self::getInt()){(core::num*) →* core::int*} in let final void #t50 = this.{self::Test2::[]=}(#t48, #t49){(core::String*, core::num*) →* void} in #t49;
    core::num* v8 = let final core::String* #t51 = "x" in let final core::num* #t52 = this.{self::Test2::[]}(#t51){(core::String*) →* core::int*}.{core::num::+}(self::getNum()){(core::num*) →* core::num*} in let final void #t53 = this.{self::Test2::[]=}(#t51, #t52){(core::String*, core::num*) →* void} in #t52;
    core::double* v9 = let final core::String* #t54 = "x" in let final core::double* #t55 = this.{self::Test2::[]}(#t54){(core::String*) →* core::int*}.{core::num::+}(self::getDouble()){(core::num*) →* core::double*} in let final void #t56 = this.{self::Test2::[]=}(#t54, #t55){(core::String*, core::num*) →* void} in #t55;
    core::int* v10 = let final core::String* #t57 = "x" in let final core::int* #t58 = this.{self::Test2::[]}(#t57){(core::String*) →* core::int*}.{core::num::+}(1){(core::num*) →* core::int*} in let final void #t59 = this.{self::Test2::[]=}(#t57, #t58){(core::String*, core::num*) →* void} in #t58;
    core::int* v11 = let final core::String* #t60 = "x" in let final core::int* #t61 = this.{self::Test2::[]}(#t60){(core::String*) →* core::int*} in let final void #t62 = this.{self::Test2::[]=}(#t60, #t61.{core::num::+}(1){(core::num*) →* core::int*}){(core::String*, core::num*) →* void} in #t61;
  }
  abstract member-signature get _identityHashCode() → core::int*; -> core::Object::_identityHashCode
  abstract member-signature method _instanceOf(dynamic instantiatorTypeArguments, dynamic functionTypeArguments, dynamic type) → core::bool*; -> core::Object::_instanceOf
  abstract member-signature method _simpleInstanceOf(dynamic type) → core::bool*; -> core::Object::_simpleInstanceOf
  abstract member-signature method _simpleInstanceOfTrue(dynamic type) → core::bool*; -> core::Object::_simpleInstanceOfTrue
  abstract member-signature method _simpleInstanceOfFalse(dynamic type) → core::bool*; -> core::Object::_simpleInstanceOfFalse
  abstract member-signature operator ==(dynamic other) → core::bool*; -> core::Object::==
  abstract member-signature get hashCode() → core::int*; -> core::Object::hashCode
  abstract member-signature method toString() → core::String*; -> core::Object::toString
  abstract member-signature method noSuchMethod(core::Invocation* invocation) → dynamic; -> core::Object::noSuchMethod
  abstract member-signature get runtimeType() → core::Type*; -> core::Object::runtimeType
}
abstract class Test3 extends core::Object {
  synthetic constructor •() → self::Test3*
    : super core::Object::•()
    ;
  abstract operator [](core::String* s) → core::int*;
  abstract operator []=(core::String* s, core::double* v) → void;
  method test() → void {
    core::num* v2 = let final core::String* #t63 = "x" in let final core::num* #t64 = self::getNum() as{TypeError} core::double* in let final void #t65 = this.{self::Test3::[]=}(#t63, #t64){(core::String*, core::double*) →* void} in #t64;
    core::double* v3 = let final core::String* #t66 = "x" in let final core::double* #t67 = self::getDouble() in let final void #t68 = this.{self::Test3::[]=}(#t66, #t67){(core::String*, core::double*) →* void} in #t67;
    core::num* v5 = let final core::String* #t69 = "x" in let final core::int* #t70 = this.{self::Test3::[]}(#t69){(core::String*) →* core::int*} in #t70 == null ?{core::num*} let final core::num* #t71 = self::getNum() as{TypeError} core::double* in let final void #t72 = this.{self::Test3::[]=}(#t69, #t71){(core::String*, core::double*) →* void} in #t71 : #t70;
    core::num* v6 = let final core::String* #t73 = "x" in let final core::int* #t74 = this.{self::Test3::[]}(#t73){(core::String*) →* core::int*} in #t74 == null ?{core::num*} let final core::double* #t75 = self::getDouble() in let final void #t76 = this.{self::Test3::[]=}(#t73, #t75){(core::String*, core::double*) →* void} in #t75 : #t74;
    core::int* v7 = let final core::String* #t77 = "x" in let final core::int* #t78 = invalid-expression "pkg/front_end/testcases/inference_new/infer_assign_to_index_this_upwards.dart:109:27: Error: A value of type 'int' can't be assigned to a variable of type 'double'.
        /*@target=num.+*/ += getInt();
                          ^" in this.{self::Test3::[]}(#t77){(core::String*) →* core::int*}.{core::num::+}(self::getInt()){(core::num*) →* core::int*} as{TypeError} core::double* in let final void #t79 = this.{self::Test3::[]=}(#t77, #t78){(core::String*, core::double*) →* void} in #t78;
    core::num* v8 = let final core::String* #t80 = "x" in let final core::num* #t81 = this.{self::Test3::[]}(#t80){(core::String*) →* core::int*}.{core::num::+}(self::getNum()){(core::num*) →* core::num*} as{TypeError} core::double* in let final void #t82 = this.{self::Test3::[]=}(#t80, #t81){(core::String*, core::double*) →* void} in #t81;
    core::double* v9 = let final core::String* #t83 = "x" in let final core::double* #t84 = this.{self::Test3::[]}(#t83){(core::String*) →* core::int*}.{core::num::+}(self::getDouble()){(core::num*) →* core::double*} in let final void #t85 = this.{self::Test3::[]=}(#t83, #t84){(core::String*, core::double*) →* void} in #t84;
    core::int* v10 = let final core::String* #t86 = "x" in let final core::int* #t87 = invalid-expression "pkg/front_end/testcases/inference_new/infer_assign_to_index_this_upwards.dart:119:50: Error: A value of type 'int' can't be assigned to a variable of type 'double'.
    var /*@ type=int* */ v10 = /*@target=num.+*/ ++this
                                                 ^" in this.{self::Test3::[]}(#t86){(core::String*) →* core::int*}.{core::num::+}(1){(core::num*) →* core::int*} as{TypeError} core::double* in let final void #t88 = this.{self::Test3::[]=}(#t86, #t87){(core::String*, core::double*) →* void} in #t87;
    core::int* v11 = let final core::String* #t89 = "x" in let final core::int* #t90 = this.{self::Test3::[]}(#t89){(core::String*) →* core::int*} in let final void #t91 = this.{self::Test3::[]=}(#t89, invalid-expression "pkg/front_end/testcases/inference_new/infer_assign_to_index_this_upwards.dart:124:27: Error: A value of type 'int' can't be assigned to a variable of type 'double'.
        /*@target=num.+*/ ++;
                          ^" in #t90.{core::num::+}(1){(core::num*) →* core::int*} as{TypeError} core::double*){(core::String*, core::double*) →* void} in #t90;
  }
  abstract member-signature get _identityHashCode() → core::int*; -> core::Object::_identityHashCode
  abstract member-signature method _instanceOf(dynamic instantiatorTypeArguments, dynamic functionTypeArguments, dynamic type) → core::bool*; -> core::Object::_instanceOf
  abstract member-signature method _simpleInstanceOf(dynamic type) → core::bool*; -> core::Object::_simpleInstanceOf
  abstract member-signature method _simpleInstanceOfTrue(dynamic type) → core::bool*; -> core::Object::_simpleInstanceOfTrue
  abstract member-signature method _simpleInstanceOfFalse(dynamic type) → core::bool*; -> core::Object::_simpleInstanceOfFalse
  abstract member-signature operator ==(dynamic other) → core::bool*; -> core::Object::==
  abstract member-signature get hashCode() → core::int*; -> core::Object::hashCode
  abstract member-signature method toString() → core::String*; -> core::Object::toString
  abstract member-signature method noSuchMethod(core::Invocation* invocation) → dynamic; -> core::Object::noSuchMethod
  abstract member-signature get runtimeType() → core::Type*; -> core::Object::runtimeType
}
abstract class Test4 extends core::Object {
  synthetic constructor •() → self::Test4*
    : super core::Object::•()
    ;
  abstract operator [](core::String* s) → core::num*;
  abstract operator []=(core::String* s, core::int* v) → void;
  method test() → void {
    core::int* v1 = let final core::String* #t92 = "x" in let final core::int* #t93 = self::getInt() in let final void #t94 = this.{self::Test4::[]=}(#t92, #t93){(core::String*, core::int*) →* void} in #t93;
    core::num* v2 = let final core::String* #t95 = "x" in let final core::num* #t96 = self::getNum() as{TypeError} core::int* in let final void #t97 = this.{self::Test4::[]=}(#t95, #t96){(core::String*, core::int*) →* void} in #t96;
    core::num* v4 = let final core::String* #t98 = "x" in let final core::num* #t99 = this.{self::Test4::[]}(#t98){(core::String*) →* core::num*} in #t99 == null ?{core::num*} let final core::int* #t100 = self::getInt() in let final void #t101 = this.{self::Test4::[]=}(#t98, #t100){(core::String*, core::int*) →* void} in #t100 : #t99;
    core::num* v5 = let final core::String* #t102 = "x" in let final core::num* #t103 = this.{self::Test4::[]}(#t102){(core::String*) →* core::num*} in #t103 == null ?{core::num*} let final core::num* #t104 = self::getNum() as{TypeError} core::int* in let final void #t105 = this.{self::Test4::[]=}(#t102, #t104){(core::String*, core::int*) →* void} in #t104 : #t103;
    core::num* v7 = let final core::String* #t106 = "x" in let final core::num* #t107 = this.{self::Test4::[]}(#t106){(core::String*) →* core::num*}.{core::num::+}(self::getInt()){(core::num*) →* core::num*} as{TypeError} core::int* in let final void #t108 = this.{self::Test4::[]=}(#t106, #t107){(core::String*, core::int*) →* void} in #t107;
    core::num* v8 = let final core::String* #t109 = "x" in let final core::num* #t110 = this.{self::Test4::[]}(#t109){(core::String*) →* core::num*}.{core::num::+}(self::getNum()){(core::num*) →* core::num*} as{TypeError} core::int* in let final void #t111 = this.{self::Test4::[]=}(#t109, #t110){(core::String*, core::int*) →* void} in #t110;
    core::num* v10 = let final core::String* #t112 = "x" in let final core::num* #t113 = this.{self::Test4::[]}(#t112){(core::String*) →* core::num*}.{core::num::+}(1){(core::num*) →* core::num*} as{TypeError} core::int* in let final void #t114 = this.{self::Test4::[]=}(#t112, #t113){(core::String*, core::int*) →* void} in #t113;
    core::num* v11 = let final core::String* #t115 = "x" in let final core::num* #t116 = this.{self::Test4::[]}(#t115){(core::String*) →* core::num*} in let final void #t117 = this.{self::Test4::[]=}(#t115, #t116.{core::num::+}(1){(core::num*) →* core::num*} as{TypeError} core::int*){(core::String*, core::int*) →* void} in #t116;
  }
  abstract member-signature get _identityHashCode() → core::int*; -> core::Object::_identityHashCode
  abstract member-signature method _instanceOf(dynamic instantiatorTypeArguments, dynamic functionTypeArguments, dynamic type) → core::bool*; -> core::Object::_instanceOf
  abstract member-signature method _simpleInstanceOf(dynamic type) → core::bool*; -> core::Object::_simpleInstanceOf
  abstract member-signature method _simpleInstanceOfTrue(dynamic type) → core::bool*; -> core::Object::_simpleInstanceOfTrue
  abstract member-signature method _simpleInstanceOfFalse(dynamic type) → core::bool*; -> core::Object::_simpleInstanceOfFalse
  abstract member-signature operator ==(dynamic other) → core::bool*; -> core::Object::==
  abstract member-signature get hashCode() → core::int*; -> core::Object::hashCode
  abstract member-signature method toString() → core::String*; -> core::Object::toString
  abstract member-signature method noSuchMethod(core::Invocation* invocation) → dynamic; -> core::Object::noSuchMethod
  abstract member-signature get runtimeType() → core::Type*; -> core::Object::runtimeType
}
abstract class Test5 extends core::Object {
  synthetic constructor •() → self::Test5*
    : super core::Object::•()
    ;
  abstract operator [](core::String* s) → core::num*;
  abstract operator []=(core::String* s, core::num* v) → void;
  method test() → void {
    core::int* v1 = let final core::String* #t118 = "x" in let final core::int* #t119 = self::getInt() in let final void #t120 = this.{self::Test5::[]=}(#t118, #t119){(core::String*, core::num*) →* void} in #t119;
    core::num* v2 = let final core::String* #t121 = "x" in let final core::num* #t122 = self::getNum() in let final void #t123 = this.{self::Test5::[]=}(#t121, #t122){(core::String*, core::num*) →* void} in #t122;
    core::double* v3 = let final core::String* #t124 = "x" in let final core::double* #t125 = self::getDouble() in let final void #t126 = this.{self::Test5::[]=}(#t124, #t125){(core::String*, core::num*) →* void} in #t125;
    core::num* v4 = let final core::String* #t127 = "x" in let final core::num* #t128 = this.{self::Test5::[]}(#t127){(core::String*) →* core::num*} in #t128 == null ?{core::num*} let final core::int* #t129 = self::getInt() in let final void #t130 = this.{self::Test5::[]=}(#t127, #t129){(core::String*, core::num*) →* void} in #t129 : #t128;
    core::num* v5 = let final core::String* #t131 = "x" in let final core::num* #t132 = this.{self::Test5::[]}(#t131){(core::String*) →* core::num*} in #t132 == null ?{core::num*} let final core::num* #t133 = self::getNum() in let final void #t134 = this.{self::Test5::[]=}(#t131, #t133){(core::String*, core::num*) →* void} in #t133 : #t132;
    core::num* v6 = let final core::String* #t135 = "x" in let final core::num* #t136 = this.{self::Test5::[]}(#t135){(core::String*) →* core::num*} in #t136 == null ?{core::num*} let final core::double* #t137 = self::getDouble() in let final void #t138 = this.{self::Test5::[]=}(#t135, #t137){(core::String*, core::num*) →* void} in #t137 : #t136;
    core::num* v7 = let final core::String* #t139 = "x" in let final core::num* #t140 = this.{self::Test5::[]}(#t139){(core::String*) →* core::num*}.{core::num::+}(self::getInt()){(core::num*) →* core::num*} in let final void #t141 = this.{self::Test5::[]=}(#t139, #t140){(core::String*, core::num*) →* void} in #t140;
    core::num* v8 = let final core::String* #t142 = "x" in let final core::num* #t143 = this.{self::Test5::[]}(#t142){(core::String*) →* core::num*}.{core::num::+}(self::getNum()){(core::num*) →* core::num*} in let final void #t144 = this.{self::Test5::[]=}(#t142, #t143){(core::String*, core::num*) →* void} in #t143;
    core::num* v9 = let final core::String* #t145 = "x" in let final core::num* #t146 = this.{self::Test5::[]}(#t145){(core::String*) →* core::num*}.{core::num::+}(self::getDouble()){(core::num*) →* core::num*} in let final void #t147 = this.{self::Test5::[]=}(#t145, #t146){(core::String*, core::num*) →* void} in #t146;
    core::num* v10 = let final core::String* #t148 = "x" in let final core::num* #t149 = this.{self::Test5::[]}(#t148){(core::String*) →* core::num*}.{core::num::+}(1){(core::num*) →* core::num*} in let final void #t150 = this.{self::Test5::[]=}(#t148, #t149){(core::String*, core::num*) →* void} in #t149;
    core::num* v11 = let final core::String* #t151 = "x" in let final core::num* #t152 = this.{self::Test5::[]}(#t151){(core::String*) →* core::num*} in let final void #t153 = this.{self::Test5::[]=}(#t151, #t152.{core::num::+}(1){(core::num*) →* core::num*}){(core::String*, core::num*) →* void} in #t152;
  }
  abstract member-signature get _identityHashCode() → core::int*; -> core::Object::_identityHashCode
  abstract member-signature method _instanceOf(dynamic instantiatorTypeArguments, dynamic functionTypeArguments, dynamic type) → core::bool*; -> core::Object::_instanceOf
  abstract member-signature method _simpleInstanceOf(dynamic type) → core::bool*; -> core::Object::_simpleInstanceOf
  abstract member-signature method _simpleInstanceOfTrue(dynamic type) → core::bool*; -> core::Object::_simpleInstanceOfTrue
  abstract member-signature method _simpleInstanceOfFalse(dynamic type) → core::bool*; -> core::Object::_simpleInstanceOfFalse
  abstract member-signature operator ==(dynamic other) → core::bool*; -> core::Object::==
  abstract member-signature get hashCode() → core::int*; -> core::Object::hashCode
  abstract member-signature method toString() → core::String*; -> core::Object::toString
  abstract member-signature method noSuchMethod(core::Invocation* invocation) → dynamic; -> core::Object::noSuchMethod
  abstract member-signature get runtimeType() → core::Type*; -> core::Object::runtimeType
}
abstract class Test6 extends core::Object {
  synthetic constructor •() → self::Test6*
    : super core::Object::•()
    ;
  abstract operator [](core::String* s) → core::num*;
  abstract operator []=(core::String* s, core::double* v) → void;
  method test() → void {
    core::num* v2 = let final core::String* #t154 = "x" in let final core::num* #t155 = self::getNum() as{TypeError} core::double* in let final void #t156 = this.{self::Test6::[]=}(#t154, #t155){(core::String*, core::double*) →* void} in #t155;
    core::double* v3 = let final core::String* #t157 = "x" in let final core::double* #t158 = self::getDouble() in let final void #t159 = this.{self::Test6::[]=}(#t157, #t158){(core::String*, core::double*) →* void} in #t158;
    core::num* v5 = let final core::String* #t160 = "x" in let final core::num* #t161 = this.{self::Test6::[]}(#t160){(core::String*) →* core::num*} in #t161 == null ?{core::num*} let final core::num* #t162 = self::getNum() as{TypeError} core::double* in let final void #t163 = this.{self::Test6::[]=}(#t160, #t162){(core::String*, core::double*) →* void} in #t162 : #t161;
    core::num* v6 = let final core::String* #t164 = "x" in let final core::num* #t165 = this.{self::Test6::[]}(#t164){(core::String*) →* core::num*} in #t165 == null ?{core::num*} let final core::double* #t166 = self::getDouble() in let final void #t167 = this.{self::Test6::[]=}(#t164, #t166){(core::String*, core::double*) →* void} in #t166 : #t165;
    core::num* v7 = let final core::String* #t168 = "x" in let final core::num* #t169 = this.{self::Test6::[]}(#t168){(core::String*) →* core::num*}.{core::num::+}(self::getInt()){(core::num*) →* core::num*} as{TypeError} core::double* in let final void #t170 = this.{self::Test6::[]=}(#t168, #t169){(core::String*, core::double*) →* void} in #t169;
    core::num* v8 = let final core::String* #t171 = "x" in let final core::num* #t172 = this.{self::Test6::[]}(#t171){(core::String*) →* core::num*}.{core::num::+}(self::getNum()){(core::num*) →* core::num*} as{TypeError} core::double* in let final void #t173 = this.{self::Test6::[]=}(#t171, #t172){(core::String*, core::double*) →* void} in #t172;
    core::num* v9 = let final core::String* #t174 = "x" in let final core::num* #t175 = this.{self::Test6::[]}(#t174){(core::String*) →* core::num*}.{core::num::+}(self::getDouble()){(core::num*) →* core::num*} as{TypeError} core::double* in let final void #t176 = this.{self::Test6::[]=}(#t174, #t175){(core::String*, core::double*) →* void} in #t175;
    core::num* v10 = let final core::String* #t177 = "x" in let final core::num* #t178 = this.{self::Test6::[]}(#t177){(core::String*) →* core::num*}.{core::num::+}(1){(core::num*) →* core::num*} as{TypeError} core::double* in let final void #t179 = this.{self::Test6::[]=}(#t177, #t178){(core::String*, core::double*) →* void} in #t178;
    core::num* v11 = let final core::String* #t180 = "x" in let final core::num* #t181 = this.{self::Test6::[]}(#t180){(core::String*) →* core::num*} in let final void #t182 = this.{self::Test6::[]=}(#t180, #t181.{core::num::+}(1){(core::num*) →* core::num*} as{TypeError} core::double*){(core::String*, core::double*) →* void} in #t181;
  }
  abstract member-signature get _identityHashCode() → core::int*; -> core::Object::_identityHashCode
  abstract member-signature method _instanceOf(dynamic instantiatorTypeArguments, dynamic functionTypeArguments, dynamic type) → core::bool*; -> core::Object::_instanceOf
  abstract member-signature method _simpleInstanceOf(dynamic type) → core::bool*; -> core::Object::_simpleInstanceOf
  abstract member-signature method _simpleInstanceOfTrue(dynamic type) → core::bool*; -> core::Object::_simpleInstanceOfTrue
  abstract member-signature method _simpleInstanceOfFalse(dynamic type) → core::bool*; -> core::Object::_simpleInstanceOfFalse
  abstract member-signature operator ==(dynamic other) → core::bool*; -> core::Object::==
  abstract member-signature get hashCode() → core::int*; -> core::Object::hashCode
  abstract member-signature method toString() → core::String*; -> core::Object::toString
  abstract member-signature method noSuchMethod(core::Invocation* invocation) → dynamic; -> core::Object::noSuchMethod
  abstract member-signature get runtimeType() → core::Type*; -> core::Object::runtimeType
}
abstract class Test7 extends core::Object {
  synthetic constructor •() → self::Test7*
    : super core::Object::•()
    ;
  abstract operator [](core::String* s) → core::double*;
  abstract operator []=(core::String* s, core::int* v) → void;
  method test() → void {
    core::int* v1 = let final core::String* #t183 = "x" in let final core::int* #t184 = self::getInt() in let final void #t185 = this.{self::Test7::[]=}(#t183, #t184){(core::String*, core::int*) →* void} in #t184;
    core::num* v2 = let final core::String* #t186 = "x" in let final core::num* #t187 = self::getNum() as{TypeError} core::int* in let final void #t188 = this.{self::Test7::[]=}(#t186, #t187){(core::String*, core::int*) →* void} in #t187;
    core::num* v4 = let final core::String* #t189 = "x" in let final core::double* #t190 = this.{self::Test7::[]}(#t189){(core::String*) →* core::double*} in #t190 == null ?{core::num*} let final core::int* #t191 = self::getInt() in let final void #t192 = this.{self::Test7::[]=}(#t189, #t191){(core::String*, core::int*) →* void} in #t191 : #t190;
    core::num* v5 = let final core::String* #t193 = "x" in let final core::double* #t194 = this.{self::Test7::[]}(#t193){(core::String*) →* core::double*} in #t194 == null ?{core::num*} let final core::num* #t195 = self::getNum() as{TypeError} core::int* in let final void #t196 = this.{self::Test7::[]=}(#t193, #t195){(core::String*, core::int*) →* void} in #t195 : #t194;
    core::double* v7 = let final core::String* #t197 = "x" in let final core::double* #t198 = invalid-expression "pkg/front_end/testcases/inference_new/infer_assign_to_index_this_upwards.dart:264:30: Error: A value of type 'double' can't be assigned to a variable of type 'int'.
        /*@target=double.+*/ += getInt();
                             ^" in this.{self::Test7::[]}(#t197){(core::String*) →* core::double*}.{core::double::+}(self::getInt()){(core::num*) →* core::double*} as{TypeError} core::int* in let final void #t199 = this.{self::Test7::[]=}(#t197, #t198){(core::String*, core::int*) →* void} in #t198;
    core::double* v8 = let final core::String* #t200 = "x" in let final core::double* #t201 = invalid-expression "pkg/front_end/testcases/inference_new/infer_assign_to_index_this_upwards.dart:268:30: Error: A value of type 'double' can't be assigned to a variable of type 'int'.
        /*@target=double.+*/ += getNum();
                             ^" in this.{self::Test7::[]}(#t200){(core::String*) →* core::double*}.{core::double::+}(self::getNum()){(core::num*) →* core::double*} as{TypeError} core::int* in let final void #t202 = this.{self::Test7::[]=}(#t200, #t201){(core::String*, core::int*) →* void} in #t201;
    core::double* v10 = let final core::String* #t203 = "x" in let final core::double* #t204 = invalid-expression "pkg/front_end/testcases/inference_new/infer_assign_to_index_this_upwards.dart:270:56: Error: A value of type 'double' can't be assigned to a variable of type 'int'.
    var /*@ type=double* */ v10 = /*@target=double.+*/ ++this
                                                       ^" in this.{self::Test7::[]}(#t203){(core::String*) →* core::double*}.{core::double::+}(1){(core::num*) →* core::double*} as{TypeError} core::int* in let final void #t205 = this.{self::Test7::[]=}(#t203, #t204){(core::String*, core::int*) →* void} in #t204;
    core::double* v11 = let final core::String* #t206 = "x" in let final core::double* #t207 = this.{self::Test7::[]}(#t206){(core::String*) →* core::double*} in let final void #t208 = this.{self::Test7::[]=}(#t206, invalid-expression "pkg/front_end/testcases/inference_new/infer_assign_to_index_this_upwards.dart:275:30: Error: A value of type 'double' can't be assigned to a variable of type 'int'.
        /*@target=double.+*/ ++;
                             ^" in #t207.{core::double::+}(1){(core::num*) →* core::double*} as{TypeError} core::int*){(core::String*, core::int*) →* void} in #t207;
  }
  abstract member-signature get _identityHashCode() → core::int*; -> core::Object::_identityHashCode
  abstract member-signature method _instanceOf(dynamic instantiatorTypeArguments, dynamic functionTypeArguments, dynamic type) → core::bool*; -> core::Object::_instanceOf
  abstract member-signature method _simpleInstanceOf(dynamic type) → core::bool*; -> core::Object::_simpleInstanceOf
  abstract member-signature method _simpleInstanceOfTrue(dynamic type) → core::bool*; -> core::Object::_simpleInstanceOfTrue
  abstract member-signature method _simpleInstanceOfFalse(dynamic type) → core::bool*; -> core::Object::_simpleInstanceOfFalse
  abstract member-signature operator ==(dynamic other) → core::bool*; -> core::Object::==
  abstract member-signature get hashCode() → core::int*; -> core::Object::hashCode
  abstract member-signature method toString() → core::String*; -> core::Object::toString
  abstract member-signature method noSuchMethod(core::Invocation* invocation) → dynamic; -> core::Object::noSuchMethod
  abstract member-signature get runtimeType() → core::Type*; -> core::Object::runtimeType
}
abstract class Test8 extends core::Object {
  synthetic constructor •() → self::Test8*
    : super core::Object::•()
    ;
  abstract operator [](core::String* s) → core::double*;
  abstract operator []=(core::String* s, core::num* v) → void;
  method test() → void {
    core::int* v1 = let final core::String* #t209 = "x" in let final core::int* #t210 = self::getInt() in let final void #t211 = this.{self::Test8::[]=}(#t209, #t210){(core::String*, core::num*) →* void} in #t210;
    core::num* v2 = let final core::String* #t212 = "x" in let final core::num* #t213 = self::getNum() in let final void #t214 = this.{self::Test8::[]=}(#t212, #t213){(core::String*, core::num*) →* void} in #t213;
    core::double* v3 = let final core::String* #t215 = "x" in let final core::double* #t216 = self::getDouble() in let final void #t217 = this.{self::Test8::[]=}(#t215, #t216){(core::String*, core::num*) →* void} in #t216;
    core::num* v4 = let final core::String* #t218 = "x" in let final core::double* #t219 = this.{self::Test8::[]}(#t218){(core::String*) →* core::double*} in #t219 == null ?{core::num*} let final core::int* #t220 = self::getInt() in let final void #t221 = this.{self::Test8::[]=}(#t218, #t220){(core::String*, core::num*) →* void} in #t220 : #t219;
    core::num* v5 = let final core::String* #t222 = "x" in let final core::double* #t223 = this.{self::Test8::[]}(#t222){(core::String*) →* core::double*} in #t223 == null ?{core::num*} let final core::num* #t224 = self::getNum() in let final void #t225 = this.{self::Test8::[]=}(#t222, #t224){(core::String*, core::num*) →* void} in #t224 : #t223;
    core::double* v6 = let final core::String* #t226 = "x" in let final core::double* #t227 = this.{self::Test8::[]}(#t226){(core::String*) →* core::double*} in #t227 == null ?{core::double*} let final core::double* #t228 = self::getDouble() in let final void #t229 = this.{self::Test8::[]=}(#t226, #t228){(core::String*, core::num*) →* void} in #t228 : #t227;
    core::double* v7 = let final core::String* #t230 = "x" in let final core::double* #t231 = this.{self::Test8::[]}(#t230){(core::String*) →* core::double*}.{core::double::+}(self::getInt()){(core::num*) →* core::double*} in let final void #t232 = this.{self::Test8::[]=}(#t230, #t231){(core::String*, core::num*) →* void} in #t231;
    core::double* v8 = let final core::String* #t233 = "x" in let final core::double* #t234 = this.{self::Test8::[]}(#t233){(core::String*) →* core::double*}.{core::double::+}(self::getNum()){(core::num*) →* core::double*} in let final void #t235 = this.{self::Test8::[]=}(#t233, #t234){(core::String*, core::num*) →* void} in #t234;
    core::double* v9 = let final core::String* #t236 = "x" in let final core::double* #t237 = this.{self::Test8::[]}(#t236){(core::String*) →* core::double*}.{core::double::+}(self::getDouble()){(core::num*) →* core::double*} in let final void #t238 = this.{self::Test8::[]=}(#t236, #t237){(core::String*, core::num*) →* void} in #t237;
    core::double* v10 = let final core::String* #t239 = "x" in let final core::double* #t240 = this.{self::Test8::[]}(#t239){(core::String*) →* core::double*}.{core::double::+}(1){(core::num*) →* core::double*} in let final void #t241 = this.{self::Test8::[]=}(#t239, #t240){(core::String*, core::num*) →* void} in #t240;
    core::double* v11 = let final core::String* #t242 = "x" in let final core::double* #t243 = this.{self::Test8::[]}(#t242){(core::String*) →* core::double*} in let final void #t244 = this.{self::Test8::[]=}(#t242, #t243.{core::double::+}(1){(core::num*) →* core::double*}){(core::String*, core::num*) →* void} in #t243;
  }
  abstract member-signature get _identityHashCode() → core::int*; -> core::Object::_identityHashCode
  abstract member-signature method _instanceOf(dynamic instantiatorTypeArguments, dynamic functionTypeArguments, dynamic type) → core::bool*; -> core::Object::_instanceOf
  abstract member-signature method _simpleInstanceOf(dynamic type) → core::bool*; -> core::Object::_simpleInstanceOf
  abstract member-signature method _simpleInstanceOfTrue(dynamic type) → core::bool*; -> core::Object::_simpleInstanceOfTrue
  abstract member-signature method _simpleInstanceOfFalse(dynamic type) → core::bool*; -> core::Object::_simpleInstanceOfFalse
  abstract member-signature operator ==(dynamic other) → core::bool*; -> core::Object::==
  abstract member-signature get hashCode() → core::int*; -> core::Object::hashCode
  abstract member-signature method toString() → core::String*; -> core::Object::toString
  abstract member-signature method noSuchMethod(core::Invocation* invocation) → dynamic; -> core::Object::noSuchMethod
  abstract member-signature get runtimeType() → core::Type*; -> core::Object::runtimeType
}
abstract class Test9 extends core::Object {
  synthetic constructor •() → self::Test9*
    : super core::Object::•()
    ;
  abstract operator [](core::String* s) → core::double*;
  abstract operator []=(core::String* s, core::double* v) → void;
  method test() → void {
    core::num* v2 = let final core::String* #t245 = "x" in let final core::num* #t246 = self::getNum() as{TypeError} core::double* in let final void #t247 = this.{self::Test9::[]=}(#t245, #t246){(core::String*, core::double*) →* void} in #t246;
    core::double* v3 = let final core::String* #t248 = "x" in let final core::double* #t249 = self::getDouble() in let final void #t250 = this.{self::Test9::[]=}(#t248, #t249){(core::String*, core::double*) →* void} in #t249;
    core::num* v5 = let final core::String* #t251 = "x" in let final core::double* #t252 = this.{self::Test9::[]}(#t251){(core::String*) →* core::double*} in #t252 == null ?{core::num*} let final core::num* #t253 = self::getNum() as{TypeError} core::double* in let final void #t254 = this.{self::Test9::[]=}(#t251, #t253){(core::String*, core::double*) →* void} in #t253 : #t252;
    core::double* v6 = let final core::String* #t255 = "x" in let final core::double* #t256 = this.{self::Test9::[]}(#t255){(core::String*) →* core::double*} in #t256 == null ?{core::double*} let final core::double* #t257 = self::getDouble() in let final void #t258 = this.{self::Test9::[]=}(#t255, #t257){(core::String*, core::double*) →* void} in #t257 : #t256;
    core::double* v7 = let final core::String* #t259 = "x" in let final core::double* #t260 = this.{self::Test9::[]}(#t259){(core::String*) →* core::double*}.{core::double::+}(self::getInt()){(core::num*) →* core::double*} in let final void #t261 = this.{self::Test9::[]=}(#t259, #t260){(core::String*, core::double*) →* void} in #t260;
    core::double* v8 = let final core::String* #t262 = "x" in let final core::double* #t263 = this.{self::Test9::[]}(#t262){(core::String*) →* core::double*}.{core::double::+}(self::getNum()){(core::num*) →* core::double*} in let final void #t264 = this.{self::Test9::[]=}(#t262, #t263){(core::String*, core::double*) →* void} in #t263;
    core::double* v9 = let final core::String* #t265 = "x" in let final core::double* #t266 = this.{self::Test9::[]}(#t265){(core::String*) →* core::double*}.{core::double::+}(self::getDouble()){(core::num*) →* core::double*} in let final void #t267 = this.{self::Test9::[]=}(#t265, #t266){(core::String*, core::double*) →* void} in #t266;
    core::double* v10 = let final core::String* #t268 = "x" in let final core::double* #t269 = this.{self::Test9::[]}(#t268){(core::String*) →* core::double*}.{core::double::+}(1){(core::num*) →* core::double*} in let final void #t270 = this.{self::Test9::[]=}(#t268, #t269){(core::String*, core::double*) →* void} in #t269;
    core::double* v11 = let final core::String* #t271 = "x" in let final core::double* #t272 = this.{self::Test9::[]}(#t271){(core::String*) →* core::double*} in let final void #t273 = this.{self::Test9::[]=}(#t271, #t272.{core::double::+}(1){(core::num*) →* core::double*}){(core::String*, core::double*) →* void} in #t272;
  }
  abstract member-signature get _identityHashCode() → core::int*; -> core::Object::_identityHashCode
  abstract member-signature method _instanceOf(dynamic instantiatorTypeArguments, dynamic functionTypeArguments, dynamic type) → core::bool*; -> core::Object::_instanceOf
  abstract member-signature method _simpleInstanceOf(dynamic type) → core::bool*; -> core::Object::_simpleInstanceOf
  abstract member-signature method _simpleInstanceOfTrue(dynamic type) → core::bool*; -> core::Object::_simpleInstanceOfTrue
  abstract member-signature method _simpleInstanceOfFalse(dynamic type) → core::bool*; -> core::Object::_simpleInstanceOfFalse
  abstract member-signature operator ==(dynamic other) → core::bool*; -> core::Object::==
  abstract member-signature get hashCode() → core::int*; -> core::Object::hashCode
  abstract member-signature method toString() → core::String*; -> core::Object::toString
  abstract member-signature method noSuchMethod(core::Invocation* invocation) → dynamic; -> core::Object::noSuchMethod
  abstract member-signature get runtimeType() → core::Type*; -> core::Object::runtimeType
}
static method getInt() → core::int*
  return 0;
static method getNum() → core::num*
  return 0;
static method getDouble() → core::double*
  return 0.0;
static method main() → dynamic {}
