library test;
//
// Problems in library:
//
// pkg/front_end/testcases/inference_new/infer_assign_to_index_this_upwards.dart:109:27: Error: A value of type 'int' can't be assigned to a variable of type 'double'.
//         /*@target=num.+*/ += getInt();
//                           ^
//
// pkg/front_end/testcases/inference_new/infer_assign_to_index_this_upwards.dart:119:50: Error: A value of type 'int' can't be assigned to a variable of type 'double'.
//     var /*@ type=int* */ v10 = /*@target=num.+*/ ++this
//                                                  ^
//
// pkg/front_end/testcases/inference_new/infer_assign_to_index_this_upwards.dart:124:27: Error: A value of type 'int' can't be assigned to a variable of type 'double'.
//         /*@target=num.+*/ ++;
//                           ^
//
// pkg/front_end/testcases/inference_new/infer_assign_to_index_this_upwards.dart:264:30: Error: A value of type 'double' can't be assigned to a variable of type 'int'.
//         /*@target=double.+*/ += getInt();
//                              ^
//
// pkg/front_end/testcases/inference_new/infer_assign_to_index_this_upwards.dart:268:30: Error: A value of type 'double' can't be assigned to a variable of type 'int'.
//         /*@target=double.+*/ += getNum();
//                              ^
//
// pkg/front_end/testcases/inference_new/infer_assign_to_index_this_upwards.dart:270:56: Error: A value of type 'double' can't be assigned to a variable of type 'int'.
//     var /*@ type=double* */ v10 = /*@target=double.+*/ ++this
//                                                        ^
//
// pkg/front_end/testcases/inference_new/infer_assign_to_index_this_upwards.dart:275:30: Error: A value of type 'double' can't be assigned to a variable of type 'int'.
//         /*@target=double.+*/ ++;
//                              ^
//
import self as self;
import "dart:core" as core;

abstract class Test1 extends core::Object {
  synthetic constructor •() → self::Test1*
    : super core::Object::•()
    ;
  abstract operator [](core::String* s) → core::int*;
  abstract operator []=(core::String* s, core::int* v) → void;
  method test() → void {
    core::int* v1 = let final core::String* #t1 = "x" in let final core::int* #t2 = self::getInt() in let final void #t3 = this.{self::Test1::[]=}(#t1, #t2){(core::String*, core::int*) →* void} in #t2;
    core::num* v2 = let final core::String* #t4 = "x" in let final core::num* #t5 = self::getNum() as{TypeError} core::int* in let final void #t6 = this.{self::Test1::[]=}(#t4, #t5){(core::String*, core::int*) →* void} in #t5;
    core::int* v4 = let final core::String* #t7 = "x" in let final core::int* #t8 = this.{self::Test1::[]}(#t7){(core::String*) →* core::int*} in #t8 == null ?{core::int*} let final core::int* #t9 = self::getInt() in let final void #t10 = this.{self::Test1::[]=}(#t7, #t9){(core::String*, core::int*) →* void} in #t9 : #t8;
    core::num* v5 = let final core::String* #t11 = "x" in let final core::int* #t12 = this.{self::Test1::[]}(#t11){(core::String*) →* core::int*} in #t12 == null ?{core::num*} let final core::num* #t13 = self::getNum() as{TypeError} core::int* in let final void #t14 = this.{self::Test1::[]=}(#t11, #t13){(core::String*, core::int*) →* void} in #t13 : #t12;
    core::int* v7 = let final core::String* #t15 = "x" in let final core::int* #t16 = this.{self::Test1::[]}(#t15){(core::String*) →* core::int*}.{core::num::+}(self::getInt()){(core::num*) →* core::int*} in let final void #t17 = this.{self::Test1::[]=}(#t15, #t16){(core::String*, core::int*) →* void} in #t16;
    core::num* v8 = let final core::String* #t18 = "x" in let final core::num* #t19 = this.{self::Test1::[]}(#t18){(core::String*) →* core::int*}.{core::num::+}(self::getNum()){(core::num*) →* core::num*} as{TypeError} core::int* in let final void #t20 = this.{self::Test1::[]=}(#t18, #t19){(core::String*, core::int*) →* void} in #t19;
    core::int* v10 = let final core::String* #t21 = "x" in let final core::int* #t22 = this.{self::Test1::[]}(#t21){(core::String*) →* core::int*}.{core::num::+}(1){(core::num*) →* core::int*} in let final void #t23 = this.{self::Test1::[]=}(#t21, #t22){(core::String*, core::int*) →* void} in #t22;
    core::int* v11 = let final core::String* #t24 = "x" in let final core::int* #t25 = this.{self::Test1::[]}(#t24){(core::String*) →* core::int*} in let final void #t26 = this.{self::Test1::[]=}(#t24, #t25.{core::num::+}(1){(core::num*) →* core::int*}){(core::String*, core::int*) →* void} in #t25;
  }
  abstract member-signature get _identityHashCode() → core::int*; -> core::Object::_identityHashCode
  abstract member-signature method _instanceOf(dynamic instantiatorTypeArguments, dynamic functionTypeArguments, dynamic type) → core::bool*; -> core::Object::_instanceOf
  abstract member-signature method _simpleInstanceOf(dynamic type) → core::bool*; -> core::Object::_simpleInstanceOf
  abstract member-signature method _simpleInstanceOfTrue(dynamic type) → core::bool*; -> core::Object::_simpleInstanceOfTrue
  abstract member-signature method _simpleInstanceOfFalse(dynamic type) → core::bool*; -> core::Object::_simpleInstanceOfFalse
  abstract member-signature operator ==(dynamic other) → core::bool*; -> core::Object::==
  abstract member-signature get hashCode() → core::int*; -> core::Object::hashCode
  abstract member-signature method toString() → core::String*; -> core::Object::toString
  abstract member-signature method noSuchMethod(core::Invocation* invocation) → dynamic; -> core::Object::noSuchMethod
  abstract member-signature get runtimeType() → core::Type*; -> core::Object::runtimeType
}
abstract class Test2 extends core::Object {
  synthetic constructor •() → self::Test2*
    : super core::Object::•()
    ;
  abstract operator [](core::String* s) → core::int*;
  abstract operator []=(core::String* s, core::num* v) → void;
  method test() → void {
    core::int* v1 = let final core::String* #t27 = "x" in let final core::int* #t28 = self::getInt() in let final void #t29 = this.{self::Test2::[]=}(#t27, #t28){(core::String*, core::num*) →* void} in #t28;
    core::num* v2 = let final core::String* #t30 = "x" in let final core::num* #t31 = self::getNum() in let final void #t32 = this.{self::Test2::[]=}(#t30, #t31){(core::String*, core::num*) →* void} in #t31;
    core::double* v3 = let final core::String* #t33 = "x" in let final core::double* #t34 = self::getDouble() in let final void #t35 = this.{self::Test2::[]=}(#t33, #t34){(core::String*, core::num*) →* void} in #t34;
    core::int* v4 = let final core::String* #t36 = "x" in let final core::int* #t37 = this.{self::Test2::[]}(#t36){(core::String*) →* core::int*} in #t37 == null ?{core::int*} let final core::int* #t38 = self::getInt() in let final void #t39 = this.{self::Test2::[]=}(#t36, #t38){(core::String*, core::num*) →* void} in #t38 : #t37;
    core::num* v5 = let final core::String* #t40 = "x" in let final core::int* #t41 = this.{self::Test2::[]}(#t40){(core::String*) →* core::int*} in #t41 == null ?{core::num*} let final core::num* #t42 = self::getNum() in let final void #t43 = this.{self::Test2::[]=}(#t40, #t42){(core::String*, core::num*) →* void} in #t42 : #t41;
    core::num* v6 = let final core::String* #t44 = "x" in let final core::int* #t45 = this.{self::Test2::[]}(#t44){(core::String*) →* core::int*} in #t45 == null ?{core::num*} let final core::double* #t46 = self::getDouble() in let final void #t47 = this.{self::Test2::[]=}(#t44, #t46){(core::String*, core::num*) →* void} in #t46 : #t45;
    core::int* v7 = let final core::String* #t48 = "x" in let final core::int* #t49 = this.{self::Test2::[]}(#t48){(core::String*) →* core::int*}.{core::num::+}(self::getInt()){(core::num*) →* core::int*} in let final void #t50 = this.{self::Test2::[]=}(#t48, #t49){(core::String*, core::num*) →* void} in #t49;
    core::num* v8 = let final core::String* #t51 = "x" in let final core::num* #t52 = this.{self::Test2::[]}(#t51){(core::String*) →* core::int*}.{core::num::+}(self::getNum()){(core::num*) →* core::num*} in let final void #t53 = this.{self::Test2::[]=}(#t51, #t52){(core::String*, core::num*) →* void} in #t52;
    core::double* v9 = let final core::String* #t54 = "x" in let final core::double* #t55 = this.{self::Test2::[]}(#t54){(core::String*) →* core::int*}.{core::num::+}(self::getDouble()){(core::num*) →* core::double*} in let final void #t56 = this.{self::Test2::[]=}(#t54, #t55){(core::String*, core::num*) →* void} in #t55;
    core::int* v10 = let final core::String* #t57 = "x" in let final core::int* #t58 = this.{self::Test2::[]}(#t57){(core::String*) →* core::int*}.{core::num::+}(1){(core::num*) →* core::int*} in let final void #t59 = this.{self::Test2::[]=}(#t57, #t58){(core::String*, core::num*) →* void} in #t58;
    core::int* v11 = let final core::String* #t60 = "x" in let final core::int* #t61 = this.{self::Test2::[]}(#t60){(core::String*) →* core::int*} in let final void #t62 = this.{self::Test2::[]=}(#t60, #t61.{core::num::+}(1){(core::num*) →* core::int*}){(core::String*, core::num*) →* void} in #t61;
  }
  abstract member-signature get _identityHashCode() → core::int*; -> core::Object::_identityHashCode
  abstract member-signature method _instanceOf(dynamic instantiatorTypeArguments, dynamic functionTypeArguments, dynamic type) → core::bool*; -> core::Object::_instanceOf
  abstract member-signature method _simpleInstanceOf(dynamic type) → core::bool*; -> core::Object::_simpleInstanceOf
  abstract member-signature method _simpleInstanceOfTrue(dynamic type) → core::bool*; -> core::Object::_simpleInstanceOfTrue
  abstract member-signature method _simpleInstanceOfFalse(dynamic type) → core::bool*; -> core::Object::_simpleInstanceOfFalse
  abstract member-signature operator ==(dynamic other) → core::bool*; -> core::Object::==
  abstract member-signature get hashCode() → core::int*; -> core::Object::hashCode
  abstract member-signature method toString() → core::String*; -> core::Object::toString
  abstract member-signature method noSuchMethod(core::Invocation* invocation) → dynamic; -> core::Object::noSuchMethod
  abstract member-signature get runtimeType() → core::Type*; -> core::Object::runtimeType
}
abstract class Test3 extends core::Object {
  synthetic constructor •() → self::Test3*
    : super core::Object::•()
    ;
  abstract operator [](core::String* s) → core::int*;
  abstract operator []=(core::String* s, core::double* v) → void;
  method test() → void {
    core::num* v2 = let final core::String* #t63 = "x" in let final core::num* #t64 = self::getNum() as{TypeError} core::double* in let final void #t65 = this.{self::Test3::[]=}(#t63, #t64){(core::String*, core::double*) →* void} in #t64;
    core::double* v3 = let final core::String* #t66 = "x" in let final core::double* #t67 = self::getDouble() in let final void #t68 = this.{self::Test3::[]=}(#t66, #t67){(core::String*, core::double*) →* void} in #t67;
    core::num* v5 = let final core::String* #t69 = "x" in let final core::int* #t70 = this.{self::Test3::[]}(#t69){(core::String*) →* core::int*} in #t70 == null ?{core::num*} let final core::num* #t71 = self::getNum() as{TypeError} core::double* in let final void #t72 = this.{self::Test3::[]=}(#t69, #t71){(core::String*, core::double*) →* void} in #t71 : #t70;
    core::num* v6 = let final core::String* #t73 = "x" in let final core::int* #t74 = this.{self::Test3::[]}(#t73){(core::String*) →* core::int*} in #t74 == null ?{core::num*} let final core::double* #t75 = self::getDouble() in let final void #t76 = this.{self::Test3::[]=}(#t73, #t75){(core::String*, core::double*) →* void} in #t75 : #t74;
    core::int* v7 = let final core::String* #t77 = "x" in let final core::int* #t78 = let final Never* #t79 = invalid-expression "pkg/front_end/testcases/inference_new/infer_assign_to_index_this_upwards.dart:109:27: Error: A value of type 'int' can't be assigned to a variable of type 'double'.
        /*@target=num.+*/ += getInt();
                          ^" in this.{self::Test3::[]}(#t77){(core::String*) →* core::int*}.{core::num::+}(self::getInt()){(core::num*) →* core::int*} as{TypeError} core::double* in let final void #t80 = this.{self::Test3::[]=}(#t77, #t78){(core::String*, core::double*) →* void} in #t78;
    core::num* v8 = let final core::String* #t81 = "x" in let final core::num* #t82 = this.{self::Test3::[]}(#t81){(core::String*) →* core::int*}.{core::num::+}(self::getNum()){(core::num*) →* core::num*} as{TypeError} core::double* in let final void #t83 = this.{self::Test3::[]=}(#t81, #t82){(core::String*, core::double*) →* void} in #t82;
    core::double* v9 = let final core::String* #t84 = "x" in let final core::double* #t85 = this.{self::Test3::[]}(#t84){(core::String*) →* core::int*}.{core::num::+}(self::getDouble()){(core::num*) →* core::double*} in let final void #t86 = this.{self::Test3::[]=}(#t84, #t85){(core::String*, core::double*) →* void} in #t85;
    core::int* v10 = let final core::String* #t87 = "x" in let final core::int* #t88 = let final Never* #t89 = invalid-expression "pkg/front_end/testcases/inference_new/infer_assign_to_index_this_upwards.dart:119:50: Error: A value of type 'int' can't be assigned to a variable of type 'double'.
    var /*@ type=int* */ v10 = /*@target=num.+*/ ++this
                                                 ^" in this.{self::Test3::[]}(#t87){(core::String*) →* core::int*}.{core::num::+}(1){(core::num*) →* core::int*} as{TypeError} core::double* in let final void #t90 = this.{self::Test3::[]=}(#t87, #t88){(core::String*, core::double*) →* void} in #t88;
    core::int* v11 = let final core::String* #t91 = "x" in let final core::int* #t92 = this.{self::Test3::[]}(#t91){(core::String*) →* core::int*} in let final void #t93 = this.{self::Test3::[]=}(#t91, let final Never* #t94 = invalid-expression "pkg/front_end/testcases/inference_new/infer_assign_to_index_this_upwards.dart:124:27: Error: A value of type 'int' can't be assigned to a variable of type 'double'.
        /*@target=num.+*/ ++;
                          ^" in #t92.{core::num::+}(1){(core::num*) →* core::int*} as{TypeError} core::double*){(core::String*, core::double*) →* void} in #t92;
  }
  abstract member-signature get _identityHashCode() → core::int*; -> core::Object::_identityHashCode
  abstract member-signature method _instanceOf(dynamic instantiatorTypeArguments, dynamic functionTypeArguments, dynamic type) → core::bool*; -> core::Object::_instanceOf
  abstract member-signature method _simpleInstanceOf(dynamic type) → core::bool*; -> core::Object::_simpleInstanceOf
  abstract member-signature method _simpleInstanceOfTrue(dynamic type) → core::bool*; -> core::Object::_simpleInstanceOfTrue
  abstract member-signature method _simpleInstanceOfFalse(dynamic type) → core::bool*; -> core::Object::_simpleInstanceOfFalse
  abstract member-signature operator ==(dynamic other) → core::bool*; -> core::Object::==
  abstract member-signature get hashCode() → core::int*; -> core::Object::hashCode
  abstract member-signature method toString() → core::String*; -> core::Object::toString
  abstract member-signature method noSuchMethod(core::Invocation* invocation) → dynamic; -> core::Object::noSuchMethod
  abstract member-signature get runtimeType() → core::Type*; -> core::Object::runtimeType
}
abstract class Test4 extends core::Object {
  synthetic constructor •() → self::Test4*
    : super core::Object::•()
    ;
  abstract operator [](core::String* s) → core::num*;
  abstract operator []=(core::String* s, core::int* v) → void;
  method test() → void {
    core::int* v1 = let final core::String* #t95 = "x" in let final core::int* #t96 = self::getInt() in let final void #t97 = this.{self::Test4::[]=}(#t95, #t96){(core::String*, core::int*) →* void} in #t96;
    core::num* v2 = let final core::String* #t98 = "x" in let final core::num* #t99 = self::getNum() as{TypeError} core::int* in let final void #t100 = this.{self::Test4::[]=}(#t98, #t99){(core::String*, core::int*) →* void} in #t99;
    core::num* v4 = let final core::String* #t101 = "x" in let final core::num* #t102 = this.{self::Test4::[]}(#t101){(core::String*) →* core::num*} in #t102 == null ?{core::num*} let final core::int* #t103 = self::getInt() in let final void #t104 = this.{self::Test4::[]=}(#t101, #t103){(core::String*, core::int*) →* void} in #t103 : #t102;
    core::num* v5 = let final core::String* #t105 = "x" in let final core::num* #t106 = this.{self::Test4::[]}(#t105){(core::String*) →* core::num*} in #t106 == null ?{core::num*} let final core::num* #t107 = self::getNum() as{TypeError} core::int* in let final void #t108 = this.{self::Test4::[]=}(#t105, #t107){(core::String*, core::int*) →* void} in #t107 : #t106;
    core::num* v7 = let final core::String* #t109 = "x" in let final core::num* #t110 = this.{self::Test4::[]}(#t109){(core::String*) →* core::num*}.{core::num::+}(self::getInt()){(core::num*) →* core::num*} as{TypeError} core::int* in let final void #t111 = this.{self::Test4::[]=}(#t109, #t110){(core::String*, core::int*) →* void} in #t110;
    core::num* v8 = let final core::String* #t112 = "x" in let final core::num* #t113 = this.{self::Test4::[]}(#t112){(core::String*) →* core::num*}.{core::num::+}(self::getNum()){(core::num*) →* core::num*} as{TypeError} core::int* in let final void #t114 = this.{self::Test4::[]=}(#t112, #t113){(core::String*, core::int*) →* void} in #t113;
    core::num* v10 = let final core::String* #t115 = "x" in let final core::num* #t116 = this.{self::Test4::[]}(#t115){(core::String*) →* core::num*}.{core::num::+}(1){(core::num*) →* core::num*} as{TypeError} core::int* in let final void #t117 = this.{self::Test4::[]=}(#t115, #t116){(core::String*, core::int*) →* void} in #t116;
    core::num* v11 = let final core::String* #t118 = "x" in let final core::num* #t119 = this.{self::Test4::[]}(#t118){(core::String*) →* core::num*} in let final void #t120 = this.{self::Test4::[]=}(#t118, #t119.{core::num::+}(1){(core::num*) →* core::num*} as{TypeError} core::int*){(core::String*, core::int*) →* void} in #t119;
  }
  abstract member-signature get _identityHashCode() → core::int*; -> core::Object::_identityHashCode
  abstract member-signature method _instanceOf(dynamic instantiatorTypeArguments, dynamic functionTypeArguments, dynamic type) → core::bool*; -> core::Object::_instanceOf
  abstract member-signature method _simpleInstanceOf(dynamic type) → core::bool*; -> core::Object::_simpleInstanceOf
  abstract member-signature method _simpleInstanceOfTrue(dynamic type) → core::bool*; -> core::Object::_simpleInstanceOfTrue
  abstract member-signature method _simpleInstanceOfFalse(dynamic type) → core::bool*; -> core::Object::_simpleInstanceOfFalse
  abstract member-signature operator ==(dynamic other) → core::bool*; -> core::Object::==
  abstract member-signature get hashCode() → core::int*; -> core::Object::hashCode
  abstract member-signature method toString() → core::String*; -> core::Object::toString
  abstract member-signature method noSuchMethod(core::Invocation* invocation) → dynamic; -> core::Object::noSuchMethod
  abstract member-signature get runtimeType() → core::Type*; -> core::Object::runtimeType
}
abstract class Test5 extends core::Object {
  synthetic constructor •() → self::Test5*
    : super core::Object::•()
    ;
  abstract operator [](core::String* s) → core::num*;
  abstract operator []=(core::String* s, core::num* v) → void;
  method test() → void {
    core::int* v1 = let final core::String* #t121 = "x" in let final core::int* #t122 = self::getInt() in let final void #t123 = this.{self::Test5::[]=}(#t121, #t122){(core::String*, core::num*) →* void} in #t122;
    core::num* v2 = let final core::String* #t124 = "x" in let final core::num* #t125 = self::getNum() in let final void #t126 = this.{self::Test5::[]=}(#t124, #t125){(core::String*, core::num*) →* void} in #t125;
    core::double* v3 = let final core::String* #t127 = "x" in let final core::double* #t128 = self::getDouble() in let final void #t129 = this.{self::Test5::[]=}(#t127, #t128){(core::String*, core::num*) →* void} in #t128;
    core::num* v4 = let final core::String* #t130 = "x" in let final core::num* #t131 = this.{self::Test5::[]}(#t130){(core::String*) →* core::num*} in #t131 == null ?{core::num*} let final core::int* #t132 = self::getInt() in let final void #t133 = this.{self::Test5::[]=}(#t130, #t132){(core::String*, core::num*) →* void} in #t132 : #t131;
    core::num* v5 = let final core::String* #t134 = "x" in let final core::num* #t135 = this.{self::Test5::[]}(#t134){(core::String*) →* core::num*} in #t135 == null ?{core::num*} let final core::num* #t136 = self::getNum() in let final void #t137 = this.{self::Test5::[]=}(#t134, #t136){(core::String*, core::num*) →* void} in #t136 : #t135;
    core::num* v6 = let final core::String* #t138 = "x" in let final core::num* #t139 = this.{self::Test5::[]}(#t138){(core::String*) →* core::num*} in #t139 == null ?{core::num*} let final core::double* #t140 = self::getDouble() in let final void #t141 = this.{self::Test5::[]=}(#t138, #t140){(core::String*, core::num*) →* void} in #t140 : #t139;
    core::num* v7 = let final core::String* #t142 = "x" in let final core::num* #t143 = this.{self::Test5::[]}(#t142){(core::String*) →* core::num*}.{core::num::+}(self::getInt()){(core::num*) →* core::num*} in let final void #t144 = this.{self::Test5::[]=}(#t142, #t143){(core::String*, core::num*) →* void} in #t143;
    core::num* v8 = let final core::String* #t145 = "x" in let final core::num* #t146 = this.{self::Test5::[]}(#t145){(core::String*) →* core::num*}.{core::num::+}(self::getNum()){(core::num*) →* core::num*} in let final void #t147 = this.{self::Test5::[]=}(#t145, #t146){(core::String*, core::num*) →* void} in #t146;
    core::num* v9 = let final core::String* #t148 = "x" in let final core::num* #t149 = this.{self::Test5::[]}(#t148){(core::String*) →* core::num*}.{core::num::+}(self::getDouble()){(core::num*) →* core::num*} in let final void #t150 = this.{self::Test5::[]=}(#t148, #t149){(core::String*, core::num*) →* void} in #t149;
    core::num* v10 = let final core::String* #t151 = "x" in let final core::num* #t152 = this.{self::Test5::[]}(#t151){(core::String*) →* core::num*}.{core::num::+}(1){(core::num*) →* core::num*} in let final void #t153 = this.{self::Test5::[]=}(#t151, #t152){(core::String*, core::num*) →* void} in #t152;
    core::num* v11 = let final core::String* #t154 = "x" in let final core::num* #t155 = this.{self::Test5::[]}(#t154){(core::String*) →* core::num*} in let final void #t156 = this.{self::Test5::[]=}(#t154, #t155.{core::num::+}(1){(core::num*) →* core::num*}){(core::String*, core::num*) →* void} in #t155;
  }
  abstract member-signature get _identityHashCode() → core::int*; -> core::Object::_identityHashCode
  abstract member-signature method _instanceOf(dynamic instantiatorTypeArguments, dynamic functionTypeArguments, dynamic type) → core::bool*; -> core::Object::_instanceOf
  abstract member-signature method _simpleInstanceOf(dynamic type) → core::bool*; -> core::Object::_simpleInstanceOf
  abstract member-signature method _simpleInstanceOfTrue(dynamic type) → core::bool*; -> core::Object::_simpleInstanceOfTrue
  abstract member-signature method _simpleInstanceOfFalse(dynamic type) → core::bool*; -> core::Object::_simpleInstanceOfFalse
  abstract member-signature operator ==(dynamic other) → core::bool*; -> core::Object::==
  abstract member-signature get hashCode() → core::int*; -> core::Object::hashCode
  abstract member-signature method toString() → core::String*; -> core::Object::toString
  abstract member-signature method noSuchMethod(core::Invocation* invocation) → dynamic; -> core::Object::noSuchMethod
  abstract member-signature get runtimeType() → core::Type*; -> core::Object::runtimeType
}
abstract class Test6 extends core::Object {
  synthetic constructor •() → self::Test6*
    : super core::Object::•()
    ;
  abstract operator [](core::String* s) → core::num*;
  abstract operator []=(core::String* s, core::double* v) → void;
  method test() → void {
    core::num* v2 = let final core::String* #t157 = "x" in let final core::num* #t158 = self::getNum() as{TypeError} core::double* in let final void #t159 = this.{self::Test6::[]=}(#t157, #t158){(core::String*, core::double*) →* void} in #t158;
    core::double* v3 = let final core::String* #t160 = "x" in let final core::double* #t161 = self::getDouble() in let final void #t162 = this.{self::Test6::[]=}(#t160, #t161){(core::String*, core::double*) →* void} in #t161;
    core::num* v5 = let final core::String* #t163 = "x" in let final core::num* #t164 = this.{self::Test6::[]}(#t163){(core::String*) →* core::num*} in #t164 == null ?{core::num*} let final core::num* #t165 = self::getNum() as{TypeError} core::double* in let final void #t166 = this.{self::Test6::[]=}(#t163, #t165){(core::String*, core::double*) →* void} in #t165 : #t164;
    core::num* v6 = let final core::String* #t167 = "x" in let final core::num* #t168 = this.{self::Test6::[]}(#t167){(core::String*) →* core::num*} in #t168 == null ?{core::num*} let final core::double* #t169 = self::getDouble() in let final void #t170 = this.{self::Test6::[]=}(#t167, #t169){(core::String*, core::double*) →* void} in #t169 : #t168;
    core::num* v7 = let final core::String* #t171 = "x" in let final core::num* #t172 = this.{self::Test6::[]}(#t171){(core::String*) →* core::num*}.{core::num::+}(self::getInt()){(core::num*) →* core::num*} as{TypeError} core::double* in let final void #t173 = this.{self::Test6::[]=}(#t171, #t172){(core::String*, core::double*) →* void} in #t172;
    core::num* v8 = let final core::String* #t174 = "x" in let final core::num* #t175 = this.{self::Test6::[]}(#t174){(core::String*) →* core::num*}.{core::num::+}(self::getNum()){(core::num*) →* core::num*} as{TypeError} core::double* in let final void #t176 = this.{self::Test6::[]=}(#t174, #t175){(core::String*, core::double*) →* void} in #t175;
    core::num* v9 = let final core::String* #t177 = "x" in let final core::num* #t178 = this.{self::Test6::[]}(#t177){(core::String*) →* core::num*}.{core::num::+}(self::getDouble()){(core::num*) →* core::num*} as{TypeError} core::double* in let final void #t179 = this.{self::Test6::[]=}(#t177, #t178){(core::String*, core::double*) →* void} in #t178;
    core::num* v10 = let final core::String* #t180 = "x" in let final core::num* #t181 = this.{self::Test6::[]}(#t180){(core::String*) →* core::num*}.{core::num::+}(1){(core::num*) →* core::num*} as{TypeError} core::double* in let final void #t182 = this.{self::Test6::[]=}(#t180, #t181){(core::String*, core::double*) →* void} in #t181;
    core::num* v11 = let final core::String* #t183 = "x" in let final core::num* #t184 = this.{self::Test6::[]}(#t183){(core::String*) →* core::num*} in let final void #t185 = this.{self::Test6::[]=}(#t183, #t184.{core::num::+}(1){(core::num*) →* core::num*} as{TypeError} core::double*){(core::String*, core::double*) →* void} in #t184;
  }
  abstract member-signature get _identityHashCode() → core::int*; -> core::Object::_identityHashCode
  abstract member-signature method _instanceOf(dynamic instantiatorTypeArguments, dynamic functionTypeArguments, dynamic type) → core::bool*; -> core::Object::_instanceOf
  abstract member-signature method _simpleInstanceOf(dynamic type) → core::bool*; -> core::Object::_simpleInstanceOf
  abstract member-signature method _simpleInstanceOfTrue(dynamic type) → core::bool*; -> core::Object::_simpleInstanceOfTrue
  abstract member-signature method _simpleInstanceOfFalse(dynamic type) → core::bool*; -> core::Object::_simpleInstanceOfFalse
  abstract member-signature operator ==(dynamic other) → core::bool*; -> core::Object::==
  abstract member-signature get hashCode() → core::int*; -> core::Object::hashCode
  abstract member-signature method toString() → core::String*; -> core::Object::toString
  abstract member-signature method noSuchMethod(core::Invocation* invocation) → dynamic; -> core::Object::noSuchMethod
  abstract member-signature get runtimeType() → core::Type*; -> core::Object::runtimeType
}
abstract class Test7 extends core::Object {
  synthetic constructor •() → self::Test7*
    : super core::Object::•()
    ;
  abstract operator [](core::String* s) → core::double*;
  abstract operator []=(core::String* s, core::int* v) → void;
  method test() → void {
    core::int* v1 = let final core::String* #t186 = "x" in let final core::int* #t187 = self::getInt() in let final void #t188 = this.{self::Test7::[]=}(#t186, #t187){(core::String*, core::int*) →* void} in #t187;
    core::num* v2 = let final core::String* #t189 = "x" in let final core::num* #t190 = self::getNum() as{TypeError} core::int* in let final void #t191 = this.{self::Test7::[]=}(#t189, #t190){(core::String*, core::int*) →* void} in #t190;
    core::num* v4 = let final core::String* #t192 = "x" in let final core::double* #t193 = this.{self::Test7::[]}(#t192){(core::String*) →* core::double*} in #t193 == null ?{core::num*} let final core::int* #t194 = self::getInt() in let final void #t195 = this.{self::Test7::[]=}(#t192, #t194){(core::String*, core::int*) →* void} in #t194 : #t193;
    core::num* v5 = let final core::String* #t196 = "x" in let final core::double* #t197 = this.{self::Test7::[]}(#t196){(core::String*) →* core::double*} in #t197 == null ?{core::num*} let final core::num* #t198 = self::getNum() as{TypeError} core::int* in let final void #t199 = this.{self::Test7::[]=}(#t196, #t198){(core::String*, core::int*) →* void} in #t198 : #t197;
    core::double* v7 = let final core::String* #t200 = "x" in let final core::double* #t201 = let final Never* #t202 = invalid-expression "pkg/front_end/testcases/inference_new/infer_assign_to_index_this_upwards.dart:264:30: Error: A value of type 'double' can't be assigned to a variable of type 'int'.
        /*@target=double.+*/ += getInt();
                             ^" in this.{self::Test7::[]}(#t200){(core::String*) →* core::double*}.{core::double::+}(self::getInt()){(core::num*) →* core::double*} as{TypeError} core::int* in let final void #t203 = this.{self::Test7::[]=}(#t200, #t201){(core::String*, core::int*) →* void} in #t201;
    core::double* v8 = let final core::String* #t204 = "x" in let final core::double* #t205 = let final Never* #t206 = invalid-expression "pkg/front_end/testcases/inference_new/infer_assign_to_index_this_upwards.dart:268:30: Error: A value of type 'double' can't be assigned to a variable of type 'int'.
        /*@target=double.+*/ += getNum();
                             ^" in this.{self::Test7::[]}(#t204){(core::String*) →* core::double*}.{core::double::+}(self::getNum()){(core::num*) →* core::double*} as{TypeError} core::int* in let final void #t207 = this.{self::Test7::[]=}(#t204, #t205){(core::String*, core::int*) →* void} in #t205;
    core::double* v10 = let final core::String* #t208 = "x" in let final core::double* #t209 = let final Never* #t210 = invalid-expression "pkg/front_end/testcases/inference_new/infer_assign_to_index_this_upwards.dart:270:56: Error: A value of type 'double' can't be assigned to a variable of type 'int'.
    var /*@ type=double* */ v10 = /*@target=double.+*/ ++this
                                                       ^" in this.{self::Test7::[]}(#t208){(core::String*) →* core::double*}.{core::double::+}(1){(core::num*) →* core::double*} as{TypeError} core::int* in let final void #t211 = this.{self::Test7::[]=}(#t208, #t209){(core::String*, core::int*) →* void} in #t209;
    core::double* v11 = let final core::String* #t212 = "x" in let final core::double* #t213 = this.{self::Test7::[]}(#t212){(core::String*) →* core::double*} in let final void #t214 = this.{self::Test7::[]=}(#t212, let final Never* #t215 = invalid-expression "pkg/front_end/testcases/inference_new/infer_assign_to_index_this_upwards.dart:275:30: Error: A value of type 'double' can't be assigned to a variable of type 'int'.
        /*@target=double.+*/ ++;
                             ^" in #t213.{core::double::+}(1){(core::num*) →* core::double*} as{TypeError} core::int*){(core::String*, core::int*) →* void} in #t213;
  }
  abstract member-signature get _identityHashCode() → core::int*; -> core::Object::_identityHashCode
  abstract member-signature method _instanceOf(dynamic instantiatorTypeArguments, dynamic functionTypeArguments, dynamic type) → core::bool*; -> core::Object::_instanceOf
  abstract member-signature method _simpleInstanceOf(dynamic type) → core::bool*; -> core::Object::_simpleInstanceOf
  abstract member-signature method _simpleInstanceOfTrue(dynamic type) → core::bool*; -> core::Object::_simpleInstanceOfTrue
  abstract member-signature method _simpleInstanceOfFalse(dynamic type) → core::bool*; -> core::Object::_simpleInstanceOfFalse
  abstract member-signature operator ==(dynamic other) → core::bool*; -> core::Object::==
  abstract member-signature get hashCode() → core::int*; -> core::Object::hashCode
  abstract member-signature method toString() → core::String*; -> core::Object::toString
  abstract member-signature method noSuchMethod(core::Invocation* invocation) → dynamic; -> core::Object::noSuchMethod
  abstract member-signature get runtimeType() → core::Type*; -> core::Object::runtimeType
}
abstract class Test8 extends core::Object {
  synthetic constructor •() → self::Test8*
    : super core::Object::•()
    ;
  abstract operator [](core::String* s) → core::double*;
  abstract operator []=(core::String* s, core::num* v) → void;
  method test() → void {
    core::int* v1 = let final core::String* #t216 = "x" in let final core::int* #t217 = self::getInt() in let final void #t218 = this.{self::Test8::[]=}(#t216, #t217){(core::String*, core::num*) →* void} in #t217;
    core::num* v2 = let final core::String* #t219 = "x" in let final core::num* #t220 = self::getNum() in let final void #t221 = this.{self::Test8::[]=}(#t219, #t220){(core::String*, core::num*) →* void} in #t220;
    core::double* v3 = let final core::String* #t222 = "x" in let final core::double* #t223 = self::getDouble() in let final void #t224 = this.{self::Test8::[]=}(#t222, #t223){(core::String*, core::num*) →* void} in #t223;
    core::num* v4 = let final core::String* #t225 = "x" in let final core::double* #t226 = this.{self::Test8::[]}(#t225){(core::String*) →* core::double*} in #t226 == null ?{core::num*} let final core::int* #t227 = self::getInt() in let final void #t228 = this.{self::Test8::[]=}(#t225, #t227){(core::String*, core::num*) →* void} in #t227 : #t226;
    core::num* v5 = let final core::String* #t229 = "x" in let final core::double* #t230 = this.{self::Test8::[]}(#t229){(core::String*) →* core::double*} in #t230 == null ?{core::num*} let final core::num* #t231 = self::getNum() in let final void #t232 = this.{self::Test8::[]=}(#t229, #t231){(core::String*, core::num*) →* void} in #t231 : #t230;
    core::double* v6 = let final core::String* #t233 = "x" in let final core::double* #t234 = this.{self::Test8::[]}(#t233){(core::String*) →* core::double*} in #t234 == null ?{core::double*} let final core::double* #t235 = self::getDouble() in let final void #t236 = this.{self::Test8::[]=}(#t233, #t235){(core::String*, core::num*) →* void} in #t235 : #t234;
    core::double* v7 = let final core::String* #t237 = "x" in let final core::double* #t238 = this.{self::Test8::[]}(#t237){(core::String*) →* core::double*}.{core::double::+}(self::getInt()){(core::num*) →* core::double*} in let final void #t239 = this.{self::Test8::[]=}(#t237, #t238){(core::String*, core::num*) →* void} in #t238;
    core::double* v8 = let final core::String* #t240 = "x" in let final core::double* #t241 = this.{self::Test8::[]}(#t240){(core::String*) →* core::double*}.{core::double::+}(self::getNum()){(core::num*) →* core::double*} in let final void #t242 = this.{self::Test8::[]=}(#t240, #t241){(core::String*, core::num*) →* void} in #t241;
    core::double* v9 = let final core::String* #t243 = "x" in let final core::double* #t244 = this.{self::Test8::[]}(#t243){(core::String*) →* core::double*}.{core::double::+}(self::getDouble()){(core::num*) →* core::double*} in let final void #t245 = this.{self::Test8::[]=}(#t243, #t244){(core::String*, core::num*) →* void} in #t244;
    core::double* v10 = let final core::String* #t246 = "x" in let final core::double* #t247 = this.{self::Test8::[]}(#t246){(core::String*) →* core::double*}.{core::double::+}(1){(core::num*) →* core::double*} in let final void #t248 = this.{self::Test8::[]=}(#t246, #t247){(core::String*, core::num*) →* void} in #t247;
    core::double* v11 = let final core::String* #t249 = "x" in let final core::double* #t250 = this.{self::Test8::[]}(#t249){(core::String*) →* core::double*} in let final void #t251 = this.{self::Test8::[]=}(#t249, #t250.{core::double::+}(1){(core::num*) →* core::double*}){(core::String*, core::num*) →* void} in #t250;
  }
  abstract member-signature get _identityHashCode() → core::int*; -> core::Object::_identityHashCode
  abstract member-signature method _instanceOf(dynamic instantiatorTypeArguments, dynamic functionTypeArguments, dynamic type) → core::bool*; -> core::Object::_instanceOf
  abstract member-signature method _simpleInstanceOf(dynamic type) → core::bool*; -> core::Object::_simpleInstanceOf
  abstract member-signature method _simpleInstanceOfTrue(dynamic type) → core::bool*; -> core::Object::_simpleInstanceOfTrue
  abstract member-signature method _simpleInstanceOfFalse(dynamic type) → core::bool*; -> core::Object::_simpleInstanceOfFalse
  abstract member-signature operator ==(dynamic other) → core::bool*; -> core::Object::==
  abstract member-signature get hashCode() → core::int*; -> core::Object::hashCode
  abstract member-signature method toString() → core::String*; -> core::Object::toString
  abstract member-signature method noSuchMethod(core::Invocation* invocation) → dynamic; -> core::Object::noSuchMethod
  abstract member-signature get runtimeType() → core::Type*; -> core::Object::runtimeType
}
abstract class Test9 extends core::Object {
  synthetic constructor •() → self::Test9*
    : super core::Object::•()
    ;
  abstract operator [](core::String* s) → core::double*;
  abstract operator []=(core::String* s, core::double* v) → void;
  method test() → void {
    core::num* v2 = let final core::String* #t252 = "x" in let final core::num* #t253 = self::getNum() as{TypeError} core::double* in let final void #t254 = this.{self::Test9::[]=}(#t252, #t253){(core::String*, core::double*) →* void} in #t253;
    core::double* v3 = let final core::String* #t255 = "x" in let final core::double* #t256 = self::getDouble() in let final void #t257 = this.{self::Test9::[]=}(#t255, #t256){(core::String*, core::double*) →* void} in #t256;
    core::num* v5 = let final core::String* #t258 = "x" in let final core::double* #t259 = this.{self::Test9::[]}(#t258){(core::String*) →* core::double*} in #t259 == null ?{core::num*} let final core::num* #t260 = self::getNum() as{TypeError} core::double* in let final void #t261 = this.{self::Test9::[]=}(#t258, #t260){(core::String*, core::double*) →* void} in #t260 : #t259;
    core::double* v6 = let final core::String* #t262 = "x" in let final core::double* #t263 = this.{self::Test9::[]}(#t262){(core::String*) →* core::double*} in #t263 == null ?{core::double*} let final core::double* #t264 = self::getDouble() in let final void #t265 = this.{self::Test9::[]=}(#t262, #t264){(core::String*, core::double*) →* void} in #t264 : #t263;
    core::double* v7 = let final core::String* #t266 = "x" in let final core::double* #t267 = this.{self::Test9::[]}(#t266){(core::String*) →* core::double*}.{core::double::+}(self::getInt()){(core::num*) →* core::double*} in let final void #t268 = this.{self::Test9::[]=}(#t266, #t267){(core::String*, core::double*) →* void} in #t267;
    core::double* v8 = let final core::String* #t269 = "x" in let final core::double* #t270 = this.{self::Test9::[]}(#t269){(core::String*) →* core::double*}.{core::double::+}(self::getNum()){(core::num*) →* core::double*} in let final void #t271 = this.{self::Test9::[]=}(#t269, #t270){(core::String*, core::double*) →* void} in #t270;
    core::double* v9 = let final core::String* #t272 = "x" in let final core::double* #t273 = this.{self::Test9::[]}(#t272){(core::String*) →* core::double*}.{core::double::+}(self::getDouble()){(core::num*) →* core::double*} in let final void #t274 = this.{self::Test9::[]=}(#t272, #t273){(core::String*, core::double*) →* void} in #t273;
    core::double* v10 = let final core::String* #t275 = "x" in let final core::double* #t276 = this.{self::Test9::[]}(#t275){(core::String*) →* core::double*}.{core::double::+}(1){(core::num*) →* core::double*} in let final void #t277 = this.{self::Test9::[]=}(#t275, #t276){(core::String*, core::double*) →* void} in #t276;
    core::double* v11 = let final core::String* #t278 = "x" in let final core::double* #t279 = this.{self::Test9::[]}(#t278){(core::String*) →* core::double*} in let final void #t280 = this.{self::Test9::[]=}(#t278, #t279.{core::double::+}(1){(core::num*) →* core::double*}){(core::String*, core::double*) →* void} in #t279;
  }
  abstract member-signature get _identityHashCode() → core::int*; -> core::Object::_identityHashCode
  abstract member-signature method _instanceOf(dynamic instantiatorTypeArguments, dynamic functionTypeArguments, dynamic type) → core::bool*; -> core::Object::_instanceOf
  abstract member-signature method _simpleInstanceOf(dynamic type) → core::bool*; -> core::Object::_simpleInstanceOf
  abstract member-signature method _simpleInstanceOfTrue(dynamic type) → core::bool*; -> core::Object::_simpleInstanceOfTrue
  abstract member-signature method _simpleInstanceOfFalse(dynamic type) → core::bool*; -> core::Object::_simpleInstanceOfFalse
  abstract member-signature operator ==(dynamic other) → core::bool*; -> core::Object::==
  abstract member-signature get hashCode() → core::int*; -> core::Object::hashCode
  abstract member-signature method toString() → core::String*; -> core::Object::toString
  abstract member-signature method noSuchMethod(core::Invocation* invocation) → dynamic; -> core::Object::noSuchMethod
  abstract member-signature get runtimeType() → core::Type*; -> core::Object::runtimeType
}
static method getInt() → core::int*
  return 0;
static method getNum() → core::num*
  return 0;
static method getDouble() → core::double*
  return 0.0;
static method main() → dynamic {}
