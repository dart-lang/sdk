library test;
import self as self;
import "dart:core" as core;

class Test1 extends core::Object {
  field core::int* prop = null;
  synthetic constructor •() → self::Test1*
    : super core::Object::•()
    ;
  static method test(self::Test1* t) → void {
    core::int* v1 = let final self::Test1* #t1 = t in #t1 == null ?{core::int*} null : #t1.{self::Test1::prop} = self::getInt();
    core::num* v2 = let final self::Test1* #t2 = t in #t2 == null ?{core::num*} null : #t2.{self::Test1::prop} = self::getNum() as{TypeError} core::int*;
    core::int* v4 = let final self::Test1* #t3 = t in #t3 == null ?{core::int*} null : let final core::int* #t4 = #t3.{self::Test1::prop}{core::int*} in #t4 == null ?{core::int*} #t3.{self::Test1::prop} = self::getInt() : #t4;
    core::num* v5 = let final self::Test1* #t5 = t in #t5 == null ?{core::num*} null : let final core::int* #t6 = #t5.{self::Test1::prop}{core::int*} in #t6 == null ?{core::num*} #t5.{self::Test1::prop} = self::getNum() as{TypeError} core::int* : #t6;
    core::int* v7 = let final self::Test1* #t7 = t in #t7 == null ?{core::int*} null : let final core::int* #t8 = #t7.{self::Test1::prop}{core::int*}.{core::num::+}(self::getInt()){(core::num*) →* core::int*} in let final void #t9 = #t7.{self::Test1::prop} = #t8 in #t8;
    core::num* v8 = let final self::Test1* #t10 = t in #t10 == null ?{core::num*} null : let final core::num* #t11 = #t10.{self::Test1::prop}{core::int*}.{core::num::+}(self::getNum()){(core::num*) →* core::num*} as{TypeError} core::int* in let final void #t12 = #t10.{self::Test1::prop} = #t11 in #t11;
    core::int* v10 = let final self::Test1* #t13 = t in #t13 == null ?{core::int*} null : let final core::int* #t14 = #t13.{self::Test1::prop}{core::int*}.{core::num::+}(1){(core::num*) →* core::int*} in let final void #t15 = #t13.{self::Test1::prop} = #t14 in #t14;
    core::int* v11 = let final self::Test1* #t16 = t in #t16 == null ?{core::int*} null : let final core::int* #t17 = #t16.{self::Test1::prop}{core::int*} in let final void #t18 = #t16.{self::Test1::prop} = #t17.{core::num::+}(1){(core::num*) →* core::int*} in #t17;
  }
  abstract member-signature get _identityHashCode() → core::int*; -> core::Object::_identityHashCode
  abstract member-signature method _instanceOf(dynamic instantiatorTypeArguments, dynamic functionTypeArguments, dynamic type) → core::bool*; -> core::Object::_instanceOf
  abstract member-signature method _simpleInstanceOf(dynamic type) → core::bool*; -> core::Object::_simpleInstanceOf
  abstract member-signature method _simpleInstanceOfTrue(dynamic type) → core::bool*; -> core::Object::_simpleInstanceOfTrue
  abstract member-signature method _simpleInstanceOfFalse(dynamic type) → core::bool*; -> core::Object::_simpleInstanceOfFalse
  abstract member-signature operator ==(dynamic other) → core::bool*; -> core::Object::==
  abstract member-signature get hashCode() → core::int*; -> core::Object::hashCode
  abstract member-signature method toString() → core::String*; -> core::Object::toString
  abstract member-signature method noSuchMethod(core::Invocation* invocation) → dynamic; -> core::Object::noSuchMethod
  abstract member-signature get runtimeType() → core::Type*; -> core::Object::runtimeType
}
class Test2 extends core::Object {
  field core::num* prop = null;
  synthetic constructor •() → self::Test2*
    : super core::Object::•()
    ;
  static method test(self::Test2* t) → void {
    core::int* v1 = let final self::Test2* #t19 = t in #t19 == null ?{core::int*} null : #t19.{self::Test2::prop} = self::getInt();
    core::num* v2 = let final self::Test2* #t20 = t in #t20 == null ?{core::num*} null : #t20.{self::Test2::prop} = self::getNum();
    core::double* v3 = let final self::Test2* #t21 = t in #t21 == null ?{core::double*} null : #t21.{self::Test2::prop} = self::getDouble();
    core::num* v4 = let final self::Test2* #t22 = t in #t22 == null ?{core::num*} null : let final core::num* #t23 = #t22.{self::Test2::prop}{core::num*} in #t23 == null ?{core::num*} #t22.{self::Test2::prop} = self::getInt() : #t23;
    core::num* v5 = let final self::Test2* #t24 = t in #t24 == null ?{core::num*} null : let final core::num* #t25 = #t24.{self::Test2::prop}{core::num*} in #t25 == null ?{core::num*} #t24.{self::Test2::prop} = self::getNum() : #t25;
    core::num* v6 = let final self::Test2* #t26 = t in #t26 == null ?{core::num*} null : let final core::num* #t27 = #t26.{self::Test2::prop}{core::num*} in #t27 == null ?{core::num*} #t26.{self::Test2::prop} = self::getDouble() : #t27;
    core::num* v7 = let final self::Test2* #t28 = t in #t28 == null ?{core::num*} null : let final core::num* #t29 = #t28.{self::Test2::prop}{core::num*}.{core::num::+}(self::getInt()){(core::num*) →* core::num*} in let final void #t30 = #t28.{self::Test2::prop} = #t29 in #t29;
    core::num* v8 = let final self::Test2* #t31 = t in #t31 == null ?{core::num*} null : let final core::num* #t32 = #t31.{self::Test2::prop}{core::num*}.{core::num::+}(self::getNum()){(core::num*) →* core::num*} in let final void #t33 = #t31.{self::Test2::prop} = #t32 in #t32;
    core::num* v9 = let final self::Test2* #t34 = t in #t34 == null ?{core::num*} null : let final core::num* #t35 = #t34.{self::Test2::prop}{core::num*}.{core::num::+}(self::getDouble()){(core::num*) →* core::num*} in let final void #t36 = #t34.{self::Test2::prop} = #t35 in #t35;
    core::num* v10 = let final self::Test2* #t37 = t in #t37 == null ?{core::num*} null : let final core::num* #t38 = #t37.{self::Test2::prop}{core::num*}.{core::num::+}(1){(core::num*) →* core::num*} in let final void #t39 = #t37.{self::Test2::prop} = #t38 in #t38;
    core::num* v11 = let final self::Test2* #t40 = t in #t40 == null ?{core::num*} null : let final core::num* #t41 = #t40.{self::Test2::prop}{core::num*} in let final void #t42 = #t40.{self::Test2::prop} = #t41.{core::num::+}(1){(core::num*) →* core::num*} in #t41;
  }
  abstract member-signature get _identityHashCode() → core::int*; -> core::Object::_identityHashCode
  abstract member-signature method _instanceOf(dynamic instantiatorTypeArguments, dynamic functionTypeArguments, dynamic type) → core::bool*; -> core::Object::_instanceOf
  abstract member-signature method _simpleInstanceOf(dynamic type) → core::bool*; -> core::Object::_simpleInstanceOf
  abstract member-signature method _simpleInstanceOfTrue(dynamic type) → core::bool*; -> core::Object::_simpleInstanceOfTrue
  abstract member-signature method _simpleInstanceOfFalse(dynamic type) → core::bool*; -> core::Object::_simpleInstanceOfFalse
  abstract member-signature operator ==(dynamic other) → core::bool*; -> core::Object::==
  abstract member-signature get hashCode() → core::int*; -> core::Object::hashCode
  abstract member-signature method toString() → core::String*; -> core::Object::toString
  abstract member-signature method noSuchMethod(core::Invocation* invocation) → dynamic; -> core::Object::noSuchMethod
  abstract member-signature get runtimeType() → core::Type*; -> core::Object::runtimeType
}
class Test3 extends core::Object {
  field core::double* prop = null;
  synthetic constructor •() → self::Test3*
    : super core::Object::•()
    ;
  static method test3(self::Test3* t) → void {
    core::num* v2 = let final self::Test3* #t43 = t in #t43 == null ?{core::num*} null : #t43.{self::Test3::prop} = self::getNum() as{TypeError} core::double*;
    core::double* v3 = let final self::Test3* #t44 = t in #t44 == null ?{core::double*} null : #t44.{self::Test3::prop} = self::getDouble();
    core::num* v5 = let final self::Test3* #t45 = t in #t45 == null ?{core::num*} null : let final core::double* #t46 = #t45.{self::Test3::prop}{core::double*} in #t46 == null ?{core::num*} #t45.{self::Test3::prop} = self::getNum() as{TypeError} core::double* : #t46;
    core::double* v6 = let final self::Test3* #t47 = t in #t47 == null ?{core::double*} null : let final core::double* #t48 = #t47.{self::Test3::prop}{core::double*} in #t48 == null ?{core::double*} #t47.{self::Test3::prop} = self::getDouble() : #t48;
    core::double* v7 = let final self::Test3* #t49 = t in #t49 == null ?{core::double*} null : let final core::double* #t50 = #t49.{self::Test3::prop}{core::double*}.{core::double::+}(self::getInt()){(core::num*) →* core::double*} in let final void #t51 = #t49.{self::Test3::prop} = #t50 in #t50;
    core::double* v8 = let final self::Test3* #t52 = t in #t52 == null ?{core::double*} null : let final core::double* #t53 = #t52.{self::Test3::prop}{core::double*}.{core::double::+}(self::getNum()){(core::num*) →* core::double*} in let final void #t54 = #t52.{self::Test3::prop} = #t53 in #t53;
    core::double* v9 = let final self::Test3* #t55 = t in #t55 == null ?{core::double*} null : let final core::double* #t56 = #t55.{self::Test3::prop}{core::double*}.{core::double::+}(self::getDouble()){(core::num*) →* core::double*} in let final void #t57 = #t55.{self::Test3::prop} = #t56 in #t56;
    core::double* v10 = let final self::Test3* #t58 = t in #t58 == null ?{core::double*} null : let final core::double* #t59 = #t58.{self::Test3::prop}{core::double*}.{core::double::+}(1){(core::num*) →* core::double*} in let final void #t60 = #t58.{self::Test3::prop} = #t59 in #t59;
    core::double* v11 = let final self::Test3* #t61 = t in #t61 == null ?{core::double*} null : let final core::double* #t62 = #t61.{self::Test3::prop}{core::double*} in let final void #t63 = #t61.{self::Test3::prop} = #t62.{core::double::+}(1){(core::num*) →* core::double*} in #t62;
  }
  abstract member-signature get _identityHashCode() → core::int*; -> core::Object::_identityHashCode
  abstract member-signature method _instanceOf(dynamic instantiatorTypeArguments, dynamic functionTypeArguments, dynamic type) → core::bool*; -> core::Object::_instanceOf
  abstract member-signature method _simpleInstanceOf(dynamic type) → core::bool*; -> core::Object::_simpleInstanceOf
  abstract member-signature method _simpleInstanceOfTrue(dynamic type) → core::bool*; -> core::Object::_simpleInstanceOfTrue
  abstract member-signature method _simpleInstanceOfFalse(dynamic type) → core::bool*; -> core::Object::_simpleInstanceOfFalse
  abstract member-signature operator ==(dynamic other) → core::bool*; -> core::Object::==
  abstract member-signature get hashCode() → core::int*; -> core::Object::hashCode
  abstract member-signature method toString() → core::String*; -> core::Object::toString
  abstract member-signature method noSuchMethod(core::Invocation* invocation) → dynamic; -> core::Object::noSuchMethod
  abstract member-signature get runtimeType() → core::Type*; -> core::Object::runtimeType
}
static method getInt() → core::int*
  return 0;
static method getNum() → core::num*
  return 0;
static method getDouble() → core::double*
  return 0.0;
static method main() → dynamic {}
