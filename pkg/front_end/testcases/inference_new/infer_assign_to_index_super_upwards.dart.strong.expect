library test;
//
// Problems in library:
//
// pkg/front_end/testcases/inference_new/infer_assign_to_index_super_upwards.dart:108:34: Error: A value of type 'int' can't be assigned to a variable of type 'double'.
//             /*@ target=num::+ */ += getInt();
//                                  ^
//
// pkg/front_end/testcases/inference_new/infer_assign_to_index_super_upwards.dart:118:53: Error: A value of type 'int' can't be assigned to a variable of type 'double'.
//     var /*@ type=int* */ v10 = /*@ target=num::+ */ ++super
//                                                     ^
//
// pkg/front_end/testcases/inference_new/infer_assign_to_index_super_upwards.dart:122:36: Error: A value of type 'int' can't be assigned to a variable of type 'double'.
//         ['x'] /*@ target=num::+ */ ++;
//                                    ^
//
// pkg/front_end/testcases/inference_new/infer_assign_to_index_super_upwards.dart:248:37: Error: A value of type 'double' can't be assigned to a variable of type 'int'.
//             /*@ target=double::+ */ += getInt();
//                                     ^
//
// pkg/front_end/testcases/inference_new/infer_assign_to_index_super_upwards.dart:252:37: Error: A value of type 'double' can't be assigned to a variable of type 'int'.
//             /*@ target=double::+ */ += getNum();
//                                     ^
//
// pkg/front_end/testcases/inference_new/infer_assign_to_index_super_upwards.dart:254:59: Error: A value of type 'double' can't be assigned to a variable of type 'int'.
//     var /*@ type=double* */ v10 = /*@ target=double::+ */ ++super
//                                                           ^
//
// pkg/front_end/testcases/inference_new/infer_assign_to_index_super_upwards.dart:259:43: Error: A value of type 'double' can't be assigned to a variable of type 'int'.
//             ['x'] /*@ target=double::+ */ ++;
//                                           ^
//
import self as self;
import "dart:core" as core;

abstract class Base<T extends core::Object* = dynamic, U extends core::Object* = dynamic> extends core::Object {
  synthetic constructor •() → self::Base<self::Base::T*, self::Base::U*>*
    : super core::Object::•()
    ;
  operator [](core::String* s) → self::Base::T*
    return this.{self::Base::getValue}(s);
  operator []=(core::String* s, generic-covariant-impl self::Base::U* v) → void
    return this.{self::Base::setValue}(s, v);
  abstract method getValue(core::String* s) → self::Base::T*;
  abstract method setValue(core::String* s, generic-covariant-impl self::Base::U* v) → void;
}
abstract class Test1 extends self::Base<core::int*, core::int*> {
  synthetic constructor •() → self::Test1*
    : super self::Base::•()
    ;
  method test() → void {
    core::int* v1 = let final core::String* #t1 = "x" in let final core::int* #t2 = self::getInt() in let final void #t3 = super.{self::Base::[]=}(#t1, #t2) in #t2;
    core::num* v2 = let final core::String* #t4 = "x" in let final core::num* #t5 = self::getNum() as{TypeError} core::int* in let final void #t6 = super.{self::Base::[]=}(#t4, #t5) in #t5;
    core::int* v4 = let final core::String* #t7 = "x" in let final core::int* #t8 = super.{self::Base::[]}(#t7) in #t8.{core::num::==}(null) ?{core::int*} let final core::int* #t9 = self::getInt() in let final void #t10 = super.{self::Base::[]=}(#t7, #t9) in #t9 : #t8;
    core::num* v5 = let final core::String* #t11 = "x" in let final core::int* #t12 = super.{self::Base::[]}(#t11) in #t12.{core::num::==}(null) ?{core::num*} let final core::num* #t13 = self::getNum() as{TypeError} core::int* in let final void #t14 = super.{self::Base::[]=}(#t11, #t13) in #t13 : #t12;
    core::int* v7 = let final core::String* #t15 = "x" in let final core::int* #t16 = super.{self::Base::[]}(#t15).{core::num::+}(self::getInt()) in let final void #t17 = super.{self::Base::[]=}(#t15, #t16) in #t16;
    core::num* v8 = let final core::String* #t18 = "x" in let final core::num* #t19 = super.{self::Base::[]}(#t18).{core::num::+}(self::getNum()) as{TypeError} core::int* in let final void #t20 = super.{self::Base::[]=}(#t18, #t19) in #t19;
    core::int* v10 = let final core::String* #t21 = "x" in let final core::int* #t22 = super.{self::Base::[]}(#t21).{core::num::+}(1) in let final void #t23 = super.{self::Base::[]=}(#t21, #t22) in #t22;
    core::int* v11 = let final core::String* #t24 = "x" in let final core::int* #t25 = super.{self::Base::[]}(#t24) in let final void #t26 = super.{self::Base::[]=}(#t24, #t25.{core::num::+}(1)) in #t25;
  }
}
abstract class Test2 extends self::Base<core::int*, core::num*> {
  synthetic constructor •() → self::Test2*
    : super self::Base::•()
    ;
  method test() → void {
    core::int* v1 = let final core::String* #t27 = "x" in let final core::int* #t28 = self::getInt() in let final void #t29 = super.{self::Base::[]=}(#t27, #t28) in #t28;
    core::num* v2 = let final core::String* #t30 = "x" in let final core::num* #t31 = self::getNum() in let final void #t32 = super.{self::Base::[]=}(#t30, #t31) in #t31;
    core::double* v3 = let final core::String* #t33 = "x" in let final core::double* #t34 = self::getDouble() in let final void #t35 = super.{self::Base::[]=}(#t33, #t34) in #t34;
    core::int* v4 = let final core::String* #t36 = "x" in let final core::int* #t37 = super.{self::Base::[]}(#t36) in #t37.{core::num::==}(null) ?{core::int*} let final core::int* #t38 = self::getInt() in let final void #t39 = super.{self::Base::[]=}(#t36, #t38) in #t38 : #t37;
    core::num* v5 = let final core::String* #t40 = "x" in let final core::int* #t41 = super.{self::Base::[]}(#t40) in #t41.{core::num::==}(null) ?{core::num*} let final core::num* #t42 = self::getNum() in let final void #t43 = super.{self::Base::[]=}(#t40, #t42) in #t42 : #t41;
    core::num* v6 = let final core::String* #t44 = "x" in let final core::int* #t45 = super.{self::Base::[]}(#t44) in #t45.{core::num::==}(null) ?{core::num*} let final core::double* #t46 = self::getDouble() in let final void #t47 = super.{self::Base::[]=}(#t44, #t46) in #t46 : #t45;
    core::int* v7 = let final core::String* #t48 = "x" in let final core::int* #t49 = super.{self::Base::[]}(#t48).{core::num::+}(self::getInt()) in let final void #t50 = super.{self::Base::[]=}(#t48, #t49) in #t49;
    core::num* v8 = let final core::String* #t51 = "x" in let final core::num* #t52 = super.{self::Base::[]}(#t51).{core::num::+}(self::getNum()) in let final void #t53 = super.{self::Base::[]=}(#t51, #t52) in #t52;
    core::double* v9 = let final core::String* #t54 = "x" in let final core::double* #t55 = super.{self::Base::[]}(#t54).{core::num::+}(self::getDouble()) in let final void #t56 = super.{self::Base::[]=}(#t54, #t55) in #t55;
    core::int* v10 = let final core::String* #t57 = "x" in let final core::int* #t58 = super.{self::Base::[]}(#t57).{core::num::+}(1) in let final void #t59 = super.{self::Base::[]=}(#t57, #t58) in #t58;
    core::int* v11 = let final core::String* #t60 = "x" in let final core::int* #t61 = super.{self::Base::[]}(#t60) in let final void #t62 = super.{self::Base::[]=}(#t60, #t61.{core::num::+}(1)) in #t61;
  }
}
abstract class Test3 extends self::Base<core::int*, core::double*> {
  synthetic constructor •() → self::Test3*
    : super self::Base::•()
    ;
  method test() → void {
    core::num* v2 = let final core::String* #t63 = "x" in let final core::num* #t64 = self::getNum() as{TypeError} core::double* in let final void #t65 = super.{self::Base::[]=}(#t63, #t64) in #t64;
    core::double* v3 = let final core::String* #t66 = "x" in let final core::double* #t67 = self::getDouble() in let final void #t68 = super.{self::Base::[]=}(#t66, #t67) in #t67;
    core::num* v5 = let final core::String* #t69 = "x" in let final core::int* #t70 = super.{self::Base::[]}(#t69) in #t70.{core::num::==}(null) ?{core::num*} let final core::num* #t71 = self::getNum() as{TypeError} core::double* in let final void #t72 = super.{self::Base::[]=}(#t69, #t71) in #t71 : #t70;
    core::num* v6 = let final core::String* #t73 = "x" in let final core::int* #t74 = super.{self::Base::[]}(#t73) in #t74.{core::num::==}(null) ?{core::num*} let final core::double* #t75 = self::getDouble() in let final void #t76 = super.{self::Base::[]=}(#t73, #t75) in #t75 : #t74;
    core::int* v7 = let final core::String* #t77 = "x" in let final core::int* #t78 = let final<BottomType> #t79 = invalid-expression "pkg/front_end/testcases/inference_new/infer_assign_to_index_super_upwards.dart:108:34: Error: A value of type 'int' can't be assigned to a variable of type 'double'.
            /*@ target=num::+ */ += getInt();
                                 ^" in super.{self::Base::[]}(#t77).{core::num::+}(self::getInt()) as{TypeError} core::double* in let final void #t80 = super.{self::Base::[]=}(#t77, #t78) in #t78;
    core::num* v8 = let final core::String* #t81 = "x" in let final core::num* #t82 = super.{self::Base::[]}(#t81).{core::num::+}(self::getNum()) as{TypeError} core::double* in let final void #t83 = super.{self::Base::[]=}(#t81, #t82) in #t82;
    core::double* v9 = let final core::String* #t84 = "x" in let final core::double* #t85 = super.{self::Base::[]}(#t84).{core::num::+}(self::getDouble()) in let final void #t86 = super.{self::Base::[]=}(#t84, #t85) in #t85;
    core::int* v10 = let final core::String* #t87 = "x" in let final core::int* #t88 = let final<BottomType> #t89 = invalid-expression "pkg/front_end/testcases/inference_new/infer_assign_to_index_super_upwards.dart:118:53: Error: A value of type 'int' can't be assigned to a variable of type 'double'.
    var /*@ type=int* */ v10 = /*@ target=num::+ */ ++super
                                                    ^" in super.{self::Base::[]}(#t87).{core::num::+}(1) as{TypeError} core::double* in let final void #t90 = super.{self::Base::[]=}(#t87, #t88) in #t88;
    core::int* v11 = let final core::String* #t91 = "x" in let final core::int* #t92 = super.{self::Base::[]}(#t91) in let final void #t93 = super.{self::Base::[]=}(#t91, let final<BottomType> #t94 = invalid-expression "pkg/front_end/testcases/inference_new/infer_assign_to_index_super_upwards.dart:122:36: Error: A value of type 'int' can't be assigned to a variable of type 'double'.
        ['x'] /*@ target=num::+ */ ++;
                                   ^" in #t92.{core::num::+}(1) as{TypeError} core::double*) in #t92;
  }
}
abstract class Test4 extends self::Base<core::num*, core::int*> {
  synthetic constructor •() → self::Test4*
    : super self::Base::•()
    ;
  method test() → void {
    core::int* v1 = let final core::String* #t95 = "x" in let final core::int* #t96 = self::getInt() in let final void #t97 = super.{self::Base::[]=}(#t95, #t96) in #t96;
    core::num* v2 = let final core::String* #t98 = "x" in let final core::num* #t99 = self::getNum() as{TypeError} core::int* in let final void #t100 = super.{self::Base::[]=}(#t98, #t99) in #t99;
    core::num* v4 = let final core::String* #t101 = "x" in let final core::num* #t102 = super.{self::Base::[]}(#t101) in #t102.{core::num::==}(null) ?{core::num*} let final core::int* #t103 = self::getInt() in let final void #t104 = super.{self::Base::[]=}(#t101, #t103) in #t103 : #t102;
    core::num* v5 = let final core::String* #t105 = "x" in let final core::num* #t106 = super.{self::Base::[]}(#t105) in #t106.{core::num::==}(null) ?{core::num*} let final core::num* #t107 = self::getNum() as{TypeError} core::int* in let final void #t108 = super.{self::Base::[]=}(#t105, #t107) in #t107 : #t106;
    core::num* v7 = let final core::String* #t109 = "x" in let final core::num* #t110 = super.{self::Base::[]}(#t109).{core::num::+}(self::getInt()) as{TypeError} core::int* in let final void #t111 = super.{self::Base::[]=}(#t109, #t110) in #t110;
    core::num* v8 = let final core::String* #t112 = "x" in let final core::num* #t113 = super.{self::Base::[]}(#t112).{core::num::+}(self::getNum()) as{TypeError} core::int* in let final void #t114 = super.{self::Base::[]=}(#t112, #t113) in #t113;
    core::num* v10 = let final core::String* #t115 = "x" in let final core::num* #t116 = super.{self::Base::[]}(#t115).{core::num::+}(1) as{TypeError} core::int* in let final void #t117 = super.{self::Base::[]=}(#t115, #t116) in #t116;
    core::num* v11 = let final core::String* #t118 = "x" in let final core::num* #t119 = super.{self::Base::[]}(#t118) in let final void #t120 = super.{self::Base::[]=}(#t118, #t119.{core::num::+}(1) as{TypeError} core::int*) in #t119;
  }
}
abstract class Test5 extends self::Base<core::num*, core::num*> {
  synthetic constructor •() → self::Test5*
    : super self::Base::•()
    ;
  method test() → void {
    core::int* v1 = let final core::String* #t121 = "x" in let final core::int* #t122 = self::getInt() in let final void #t123 = super.{self::Base::[]=}(#t121, #t122) in #t122;
    core::num* v2 = let final core::String* #t124 = "x" in let final core::num* #t125 = self::getNum() in let final void #t126 = super.{self::Base::[]=}(#t124, #t125) in #t125;
    core::double* v3 = let final core::String* #t127 = "x" in let final core::double* #t128 = self::getDouble() in let final void #t129 = super.{self::Base::[]=}(#t127, #t128) in #t128;
    core::num* v4 = let final core::String* #t130 = "x" in let final core::num* #t131 = super.{self::Base::[]}(#t130) in #t131.{core::num::==}(null) ?{core::num*} let final core::int* #t132 = self::getInt() in let final void #t133 = super.{self::Base::[]=}(#t130, #t132) in #t132 : #t131;
    core::num* v5 = let final core::String* #t134 = "x" in let final core::num* #t135 = super.{self::Base::[]}(#t134) in #t135.{core::num::==}(null) ?{core::num*} let final core::num* #t136 = self::getNum() in let final void #t137 = super.{self::Base::[]=}(#t134, #t136) in #t136 : #t135;
    core::num* v6 = let final core::String* #t138 = "x" in let final core::num* #t139 = super.{self::Base::[]}(#t138) in #t139.{core::num::==}(null) ?{core::num*} let final core::double* #t140 = self::getDouble() in let final void #t141 = super.{self::Base::[]=}(#t138, #t140) in #t140 : #t139;
    core::num* v7 = let final core::String* #t142 = "x" in let final core::num* #t143 = super.{self::Base::[]}(#t142).{core::num::+}(self::getInt()) in let final void #t144 = super.{self::Base::[]=}(#t142, #t143) in #t143;
    core::num* v8 = let final core::String* #t145 = "x" in let final core::num* #t146 = super.{self::Base::[]}(#t145).{core::num::+}(self::getNum()) in let final void #t147 = super.{self::Base::[]=}(#t145, #t146) in #t146;
    core::num* v9 = let final core::String* #t148 = "x" in let final core::num* #t149 = super.{self::Base::[]}(#t148).{core::num::+}(self::getDouble()) in let final void #t150 = super.{self::Base::[]=}(#t148, #t149) in #t149;
    core::num* v10 = let final core::String* #t151 = "x" in let final core::num* #t152 = super.{self::Base::[]}(#t151).{core::num::+}(1) in let final void #t153 = super.{self::Base::[]=}(#t151, #t152) in #t152;
    core::num* v11 = let final core::String* #t154 = "x" in let final core::num* #t155 = super.{self::Base::[]}(#t154) in let final void #t156 = super.{self::Base::[]=}(#t154, #t155.{core::num::+}(1)) in #t155;
  }
}
abstract class Test6 extends self::Base<core::num*, core::double*> {
  synthetic constructor •() → self::Test6*
    : super self::Base::•()
    ;
  method test() → void {
    core::num* v2 = let final core::String* #t157 = "x" in let final core::num* #t158 = self::getNum() as{TypeError} core::double* in let final void #t159 = super.{self::Base::[]=}(#t157, #t158) in #t158;
    core::double* v3 = let final core::String* #t160 = "x" in let final core::double* #t161 = self::getDouble() in let final void #t162 = super.{self::Base::[]=}(#t160, #t161) in #t161;
    core::num* v5 = let final core::String* #t163 = "x" in let final core::num* #t164 = super.{self::Base::[]}(#t163) in #t164.{core::num::==}(null) ?{core::num*} let final core::num* #t165 = self::getNum() as{TypeError} core::double* in let final void #t166 = super.{self::Base::[]=}(#t163, #t165) in #t165 : #t164;
    core::num* v6 = let final core::String* #t167 = "x" in let final core::num* #t168 = super.{self::Base::[]}(#t167) in #t168.{core::num::==}(null) ?{core::num*} let final core::double* #t169 = self::getDouble() in let final void #t170 = super.{self::Base::[]=}(#t167, #t169) in #t169 : #t168;
    core::num* v7 = let final core::String* #t171 = "x" in let final core::num* #t172 = super.{self::Base::[]}(#t171).{core::num::+}(self::getInt()) as{TypeError} core::double* in let final void #t173 = super.{self::Base::[]=}(#t171, #t172) in #t172;
    core::num* v8 = let final core::String* #t174 = "x" in let final core::num* #t175 = super.{self::Base::[]}(#t174).{core::num::+}(self::getNum()) as{TypeError} core::double* in let final void #t176 = super.{self::Base::[]=}(#t174, #t175) in #t175;
    core::num* v9 = let final core::String* #t177 = "x" in let final core::num* #t178 = super.{self::Base::[]}(#t177).{core::num::+}(self::getDouble()) as{TypeError} core::double* in let final void #t179 = super.{self::Base::[]=}(#t177, #t178) in #t178;
    core::num* v10 = let final core::String* #t180 = "x" in let final core::num* #t181 = super.{self::Base::[]}(#t180).{core::num::+}(1) as{TypeError} core::double* in let final void #t182 = super.{self::Base::[]=}(#t180, #t181) in #t181;
    core::num* v11 = let final core::String* #t183 = "x" in let final core::num* #t184 = super.{self::Base::[]}(#t183) in let final void #t185 = super.{self::Base::[]=}(#t183, #t184.{core::num::+}(1) as{TypeError} core::double*) in #t184;
  }
}
abstract class Test7 extends self::Base<core::double*, core::int*> {
  synthetic constructor •() → self::Test7*
    : super self::Base::•()
    ;
  method test() → void {
    core::int* v1 = let final core::String* #t186 = "x" in let final core::int* #t187 = self::getInt() in let final void #t188 = super.{self::Base::[]=}(#t186, #t187) in #t187;
    core::num* v2 = let final core::String* #t189 = "x" in let final core::num* #t190 = self::getNum() as{TypeError} core::int* in let final void #t191 = super.{self::Base::[]=}(#t189, #t190) in #t190;
    core::num* v4 = let final core::String* #t192 = "x" in let final core::double* #t193 = super.{self::Base::[]}(#t192) in #t193.{core::num::==}(null) ?{core::num*} let final core::int* #t194 = self::getInt() in let final void #t195 = super.{self::Base::[]=}(#t192, #t194) in #t194 : #t193;
    core::num* v5 = let final core::String* #t196 = "x" in let final core::double* #t197 = super.{self::Base::[]}(#t196) in #t197.{core::num::==}(null) ?{core::num*} let final core::num* #t198 = self::getNum() as{TypeError} core::int* in let final void #t199 = super.{self::Base::[]=}(#t196, #t198) in #t198 : #t197;
    core::double* v7 = let final core::String* #t200 = "x" in let final core::double* #t201 = let final<BottomType> #t202 = invalid-expression "pkg/front_end/testcases/inference_new/infer_assign_to_index_super_upwards.dart:248:37: Error: A value of type 'double' can't be assigned to a variable of type 'int'.
            /*@ target=double::+ */ += getInt();
                                    ^" in super.{self::Base::[]}(#t200).{core::double::+}(self::getInt()) as{TypeError} core::int* in let final void #t203 = super.{self::Base::[]=}(#t200, #t201) in #t201;
    core::double* v8 = let final core::String* #t204 = "x" in let final core::double* #t205 = let final<BottomType> #t206 = invalid-expression "pkg/front_end/testcases/inference_new/infer_assign_to_index_super_upwards.dart:252:37: Error: A value of type 'double' can't be assigned to a variable of type 'int'.
            /*@ target=double::+ */ += getNum();
                                    ^" in super.{self::Base::[]}(#t204).{core::double::+}(self::getNum()) as{TypeError} core::int* in let final void #t207 = super.{self::Base::[]=}(#t204, #t205) in #t205;
    core::double* v10 = let final core::String* #t208 = "x" in let final core::double* #t209 = let final<BottomType> #t210 = invalid-expression "pkg/front_end/testcases/inference_new/infer_assign_to_index_super_upwards.dart:254:59: Error: A value of type 'double' can't be assigned to a variable of type 'int'.
    var /*@ type=double* */ v10 = /*@ target=double::+ */ ++super
                                                          ^" in super.{self::Base::[]}(#t208).{core::double::+}(1) as{TypeError} core::int* in let final void #t211 = super.{self::Base::[]=}(#t208, #t209) in #t209;
    core::double* v11 = let final core::String* #t212 = "x" in let final core::double* #t213 = super.{self::Base::[]}(#t212) in let final void #t214 = super.{self::Base::[]=}(#t212, let final<BottomType> #t215 = invalid-expression "pkg/front_end/testcases/inference_new/infer_assign_to_index_super_upwards.dart:259:43: Error: A value of type 'double' can't be assigned to a variable of type 'int'.
            ['x'] /*@ target=double::+ */ ++;
                                          ^" in #t213.{core::double::+}(1) as{TypeError} core::int*) in #t213;
  }
}
abstract class Test8 extends self::Base<core::double*, core::num*> {
  synthetic constructor •() → self::Test8*
    : super self::Base::•()
    ;
  method test() → void {
    core::int* v1 = let final core::String* #t216 = "x" in let final core::int* #t217 = self::getInt() in let final void #t218 = super.{self::Base::[]=}(#t216, #t217) in #t217;
    core::num* v2 = let final core::String* #t219 = "x" in let final core::num* #t220 = self::getNum() in let final void #t221 = super.{self::Base::[]=}(#t219, #t220) in #t220;
    core::double* v3 = let final core::String* #t222 = "x" in let final core::double* #t223 = self::getDouble() in let final void #t224 = super.{self::Base::[]=}(#t222, #t223) in #t223;
    core::num* v4 = let final core::String* #t225 = "x" in let final core::double* #t226 = super.{self::Base::[]}(#t225) in #t226.{core::num::==}(null) ?{core::num*} let final core::int* #t227 = self::getInt() in let final void #t228 = super.{self::Base::[]=}(#t225, #t227) in #t227 : #t226;
    core::num* v5 = let final core::String* #t229 = "x" in let final core::double* #t230 = super.{self::Base::[]}(#t229) in #t230.{core::num::==}(null) ?{core::num*} let final core::num* #t231 = self::getNum() in let final void #t232 = super.{self::Base::[]=}(#t229, #t231) in #t231 : #t230;
    core::double* v6 = let final core::String* #t233 = "x" in let final core::double* #t234 = super.{self::Base::[]}(#t233) in #t234.{core::num::==}(null) ?{core::double*} let final core::double* #t235 = self::getDouble() in let final void #t236 = super.{self::Base::[]=}(#t233, #t235) in #t235 : #t234;
    core::double* v7 = let final core::String* #t237 = "x" in let final core::double* #t238 = super.{self::Base::[]}(#t237).{core::double::+}(self::getInt()) in let final void #t239 = super.{self::Base::[]=}(#t237, #t238) in #t238;
    core::double* v8 = let final core::String* #t240 = "x" in let final core::double* #t241 = super.{self::Base::[]}(#t240).{core::double::+}(self::getNum()) in let final void #t242 = super.{self::Base::[]=}(#t240, #t241) in #t241;
    core::double* v9 = let final core::String* #t243 = "x" in let final core::double* #t244 = super.{self::Base::[]}(#t243).{core::double::+}(self::getDouble()) in let final void #t245 = super.{self::Base::[]=}(#t243, #t244) in #t244;
    core::double* v10 = let final core::String* #t246 = "x" in let final core::double* #t247 = super.{self::Base::[]}(#t246).{core::double::+}(1) in let final void #t248 = super.{self::Base::[]=}(#t246, #t247) in #t247;
    core::double* v11 = let final core::String* #t249 = "x" in let final core::double* #t250 = super.{self::Base::[]}(#t249) in let final void #t251 = super.{self::Base::[]=}(#t249, #t250.{core::double::+}(1)) in #t250;
  }
}
abstract class Test9 extends self::Base<core::double*, core::double*> {
  synthetic constructor •() → self::Test9*
    : super self::Base::•()
    ;
  method test() → void {
    core::num* v2 = let final core::String* #t252 = "x" in let final core::num* #t253 = self::getNum() as{TypeError} core::double* in let final void #t254 = super.{self::Base::[]=}(#t252, #t253) in #t253;
    core::double* v3 = let final core::String* #t255 = "x" in let final core::double* #t256 = self::getDouble() in let final void #t257 = super.{self::Base::[]=}(#t255, #t256) in #t256;
    core::num* v5 = let final core::String* #t258 = "x" in let final core::double* #t259 = super.{self::Base::[]}(#t258) in #t259.{core::num::==}(null) ?{core::num*} let final core::num* #t260 = self::getNum() as{TypeError} core::double* in let final void #t261 = super.{self::Base::[]=}(#t258, #t260) in #t260 : #t259;
    core::double* v6 = let final core::String* #t262 = "x" in let final core::double* #t263 = super.{self::Base::[]}(#t262) in #t263.{core::num::==}(null) ?{core::double*} let final core::double* #t264 = self::getDouble() in let final void #t265 = super.{self::Base::[]=}(#t262, #t264) in #t264 : #t263;
    core::double* v7 = let final core::String* #t266 = "x" in let final core::double* #t267 = super.{self::Base::[]}(#t266).{core::double::+}(self::getInt()) in let final void #t268 = super.{self::Base::[]=}(#t266, #t267) in #t267;
    core::double* v8 = let final core::String* #t269 = "x" in let final core::double* #t270 = super.{self::Base::[]}(#t269).{core::double::+}(self::getNum()) in let final void #t271 = super.{self::Base::[]=}(#t269, #t270) in #t270;
    core::double* v9 = let final core::String* #t272 = "x" in let final core::double* #t273 = super.{self::Base::[]}(#t272).{core::double::+}(self::getDouble()) in let final void #t274 = super.{self::Base::[]=}(#t272, #t273) in #t273;
    core::double* v10 = let final core::String* #t275 = "x" in let final core::double* #t276 = super.{self::Base::[]}(#t275).{core::double::+}(1) in let final void #t277 = super.{self::Base::[]=}(#t275, #t276) in #t276;
    core::double* v11 = let final core::String* #t278 = "x" in let final core::double* #t279 = super.{self::Base::[]}(#t278) in let final void #t280 = super.{self::Base::[]=}(#t278, #t279.{core::double::+}(1)) in #t279;
  }
}
static method getInt() → core::int*
  return 0;
static method getNum() → core::num*
  return 0;
static method getDouble() → core::double*
  return 0.0;
static method main() → dynamic {}
