library;
//
// Problems in library:
//
// pkg/front_end/testcases/general/issue41842.dart:16:35: Error: Expected ';' after this.
//   factory A.foo8(int x) = lib.Foo.foo<T>; // Error. Not allowed by parser.
//                                   ^^^
//
// pkg/front_end/testcases/general/issue41842.dart:16:38: Error: Expected a class member, but got '<'.
//   factory A.foo8(int x) = lib.Foo.foo<T>; // Error. Not allowed by parser.
//                                      ^
//
// pkg/front_end/testcases/general/issue41842.dart:16:39: Error: Variables must be declared using the keywords 'const', 'final', 'var' or a type name.
// Try adding the name of the type of the variable or the keyword 'var'.
//   factory A.foo8(int x) = lib.Foo.foo<T>; // Error. Not allowed by parser.
//                                       ^
//
// pkg/front_end/testcases/general/issue41842.dart:16:39: Error: Expected ';' after this.
//   factory A.foo8(int x) = lib.Foo.foo<T>; // Error. Not allowed by parser.
//                                       ^
//
// pkg/front_end/testcases/general/issue41842.dart:16:40: Error: Operator declarations must be preceded by the keyword 'operator'.
// Try adding the keyword 'operator'.
//   factory A.foo8(int x) = lib.Foo.foo<T>; // Error. Not allowed by parser.
//                                        ^
//
// pkg/front_end/testcases/general/issue41842.dart:16:40: Error: A method declaration needs an explicit list of parameters.
// Try adding a parameter list to the method declaration.
//   factory A.foo8(int x) = lib.Foo.foo<T>; // Error. Not allowed by parser.
//                                        ^
//
// pkg/front_end/testcases/general/issue41842.dart:16:40: Error: Operator '>' should have exactly one parameter.
//   factory A.foo8(int x) = lib.Foo.foo<T>; // Error. Not allowed by parser.
//                                        ^
//
// pkg/front_end/testcases/general/issue41842.dart:18:36: Error: Expected ';' after this.
//   factory A.foo10(int x) = lib.Foo.bar<T>; // Error. Not allowed by parser.
//                                    ^^^
//
// pkg/front_end/testcases/general/issue41842.dart:18:39: Error: Expected a class member, but got '<'.
//   factory A.foo10(int x) = lib.Foo.bar<T>; // Error. Not allowed by parser.
//                                       ^
//
// pkg/front_end/testcases/general/issue41842.dart:18:40: Error: Variables must be declared using the keywords 'const', 'final', 'var' or a type name.
// Try adding the name of the type of the variable or the keyword 'var'.
//   factory A.foo10(int x) = lib.Foo.bar<T>; // Error. Not allowed by parser.
//                                        ^
//
// pkg/front_end/testcases/general/issue41842.dart:18:40: Error: Expected ';' after this.
//   factory A.foo10(int x) = lib.Foo.bar<T>; // Error. Not allowed by parser.
//                                        ^
//
// pkg/front_end/testcases/general/issue41842.dart:18:40: Error: 'T' is already declared in this scope.
//   factory A.foo10(int x) = lib.Foo.bar<T>; // Error. Not allowed by parser.
//                                        ^
// pkg/front_end/testcases/general/issue41842.dart:16:39: Context: Previous declaration of 'T'.
//   factory A.foo8(int x) = lib.Foo.foo<T>; // Error. Not allowed by parser.
//                                       ^
//
// pkg/front_end/testcases/general/issue41842.dart:18:41: Error: Operator declarations must be preceded by the keyword 'operator'.
// Try adding the keyword 'operator'.
//   factory A.foo10(int x) = lib.Foo.bar<T>; // Error. Not allowed by parser.
//                                         ^
//
// pkg/front_end/testcases/general/issue41842.dart:18:41: Error: A method declaration needs an explicit list of parameters.
// Try adding a parameter list to the method declaration.
//   factory A.foo10(int x) = lib.Foo.bar<T>; // Error. Not allowed by parser.
//                                         ^
//
// pkg/front_end/testcases/general/issue41842.dart:18:41: Error: Operator '>' should have exactly one parameter.
//   factory A.foo10(int x) = lib.Foo.bar<T>; // Error. Not allowed by parser.
//                                         ^
//
// pkg/front_end/testcases/general/issue41842.dart:18:41: Error: '>' is already declared in this scope.
//   factory A.foo10(int x) = lib.Foo.bar<T>; // Error. Not allowed by parser.
//                                         ^
// pkg/front_end/testcases/general/issue41842.dart:16:40: Context: Previous declaration of '>'.
//   factory A.foo8(int x) = lib.Foo.foo<T>; // Error. Not allowed by parser.
//                                        ^
//
// pkg/front_end/testcases/general/issue41842.dart:20:33: Error: Expected ';' after this.
//   factory A.foo12(int x) = B<T>.foo<T>; // Error. Not allowed by parser.
//                                 ^^^
//
// pkg/front_end/testcases/general/issue41842.dart:20:36: Error: Expected a class member, but got '<'.
//   factory A.foo12(int x) = B<T>.foo<T>; // Error. Not allowed by parser.
//                                    ^
//
// pkg/front_end/testcases/general/issue41842.dart:20:37: Error: Variables must be declared using the keywords 'const', 'final', 'var' or a type name.
// Try adding the name of the type of the variable or the keyword 'var'.
//   factory A.foo12(int x) = B<T>.foo<T>; // Error. Not allowed by parser.
//                                     ^
//
// pkg/front_end/testcases/general/issue41842.dart:20:37: Error: Expected ';' after this.
//   factory A.foo12(int x) = B<T>.foo<T>; // Error. Not allowed by parser.
//                                     ^
//
// pkg/front_end/testcases/general/issue41842.dart:20:37: Error: 'T' is already declared in this scope.
//   factory A.foo12(int x) = B<T>.foo<T>; // Error. Not allowed by parser.
//                                     ^
// pkg/front_end/testcases/general/issue41842.dart:18:40: Context: Previous declaration of 'T'.
//   factory A.foo10(int x) = lib.Foo.bar<T>; // Error. Not allowed by parser.
//                                        ^
//
// pkg/front_end/testcases/general/issue41842.dart:20:38: Error: Operator declarations must be preceded by the keyword 'operator'.
// Try adding the keyword 'operator'.
//   factory A.foo12(int x) = B<T>.foo<T>; // Error. Not allowed by parser.
//                                      ^
//
// pkg/front_end/testcases/general/issue41842.dart:20:38: Error: A method declaration needs an explicit list of parameters.
// Try adding a parameter list to the method declaration.
//   factory A.foo12(int x) = B<T>.foo<T>; // Error. Not allowed by parser.
//                                      ^
//
// pkg/front_end/testcases/general/issue41842.dart:20:38: Error: Operator '>' should have exactly one parameter.
//   factory A.foo12(int x) = B<T>.foo<T>; // Error. Not allowed by parser.
//                                      ^
//
// pkg/front_end/testcases/general/issue41842.dart:20:38: Error: '>' is already declared in this scope.
//   factory A.foo12(int x) = B<T>.foo<T>; // Error. Not allowed by parser.
//                                      ^
// pkg/front_end/testcases/general/issue41842.dart:18:41: Context: Previous declaration of '>'.
//   factory A.foo10(int x) = lib.Foo.bar<T>; // Error. Not allowed by parser.
//                                         ^
//
// pkg/front_end/testcases/general/issue41842.dart:21:33: Error: Expected ';' after this.
//   factory A.foo13(int x) = B<T>.bar<T>; // Error. Not allowed by parser.
//                                 ^^^
//
// pkg/front_end/testcases/general/issue41842.dart:21:36: Error: Expected a class member, but got '<'.
//   factory A.foo13(int x) = B<T>.bar<T>; // Error. Not allowed by parser.
//                                    ^
//
// pkg/front_end/testcases/general/issue41842.dart:21:37: Error: Variables must be declared using the keywords 'const', 'final', 'var' or a type name.
// Try adding the name of the type of the variable or the keyword 'var'.
//   factory A.foo13(int x) = B<T>.bar<T>; // Error. Not allowed by parser.
//                                     ^
//
// pkg/front_end/testcases/general/issue41842.dart:21:37: Error: Expected ';' after this.
//   factory A.foo13(int x) = B<T>.bar<T>; // Error. Not allowed by parser.
//                                     ^
//
// pkg/front_end/testcases/general/issue41842.dart:21:37: Error: 'T' is already declared in this scope.
//   factory A.foo13(int x) = B<T>.bar<T>; // Error. Not allowed by parser.
//                                     ^
// pkg/front_end/testcases/general/issue41842.dart:20:37: Context: Previous declaration of 'T'.
//   factory A.foo12(int x) = B<T>.foo<T>; // Error. Not allowed by parser.
//                                     ^
//
// pkg/front_end/testcases/general/issue41842.dart:21:38: Error: Operator declarations must be preceded by the keyword 'operator'.
// Try adding the keyword 'operator'.
//   factory A.foo13(int x) = B<T>.bar<T>; // Error. Not allowed by parser.
//                                      ^
//
// pkg/front_end/testcases/general/issue41842.dart:21:38: Error: A method declaration needs an explicit list of parameters.
// Try adding a parameter list to the method declaration.
//   factory A.foo13(int x) = B<T>.bar<T>; // Error. Not allowed by parser.
//                                      ^
//
// pkg/front_end/testcases/general/issue41842.dart:21:38: Error: Operator '>' should have exactly one parameter.
//   factory A.foo13(int x) = B<T>.bar<T>; // Error. Not allowed by parser.
//                                      ^
//
// pkg/front_end/testcases/general/issue41842.dart:21:38: Error: '>' is already declared in this scope.
//   factory A.foo13(int x) = B<T>.bar<T>; // Error. Not allowed by parser.
//                                      ^
// pkg/front_end/testcases/general/issue41842.dart:20:38: Context: Previous declaration of '>'.
//   factory A.foo12(int x) = B<T>.foo<T>; // Error. Not allowed by parser.
//                                      ^
//
// pkg/front_end/testcases/general/issue41842.dart:21:37: Error: Conflicts with type variable 'T'.
//   factory A.foo13(int x) = B<T>.bar<T>; // Error. Not allowed by parser.
//                                     ^
// pkg/front_end/testcases/general/issue41842.dart:7:9: Context: This is the type variable.
// class A<T> {
//         ^
//
// pkg/front_end/testcases/general/issue41842.dart:10:29: Error: A constructor invocation can't have type arguments after the constructor name.
// Try removing the type arguments or placing them after the class name.
//   factory A.foo2(int x) = B.foo<T>; // Error.
//                             ^^^
//
// pkg/front_end/testcases/general/issue41842.dart:12:29: Error: A constructor invocation can't have type arguments after the constructor name.
// Try removing the type arguments or placing them after the class name.
//   factory A.foo5(int x) = B.bar<T>; // Error.
//                             ^^^
//
// pkg/front_end/testcases/general/issue41842.dart:7:7: Error: The non-abstract class 'A' is missing implementations for these members:
//  - A.>
// Try to either
//  - provide an implementation,
//  - inherit an implementation from a superclass or mixin,
//  - mark the class as abstract, or
//  - provide a 'noSuchMethod' implementation.
//
// class A<T> {
//       ^
// pkg/front_end/testcases/general/issue41842.dart:16:40: Context: 'A.>' is defined here.
//   factory A.foo8(int x) = lib.Foo.foo<T>; // Error. Not allowed by parser.
//                                        ^
//
// pkg/front_end/testcases/general/issue41842.dart:24:7: Error: The non-abstract class 'B' is missing implementations for these members:
//  - A.>
// Try to either
//  - provide an implementation,
//  - inherit an implementation from a superclass or mixin,
//  - mark the class as abstract, or
//  - provide a 'noSuchMethod' implementation.
//
// class B<T> extends A<T> {
//       ^
// pkg/front_end/testcases/general/issue41842.dart:16:40: Context: 'A.>' is defined here.
//   factory A.foo8(int x) = lib.Foo.foo<T>; // Error. Not allowed by parser.
//                                        ^
//
// pkg/front_end/testcases/general/issue41842.dart:31:9: Error: A constructor invocation can't have type arguments after the constructor name.
// Try removing the type arguments or placing them after the class name.
//   new B.foo<int>(24); // Error.
//         ^^^
//
import self as self;
import "dart:core" as core;
import "issue41842_lib.dart" as iss;

import "org-dartlang-testcase:///issue41842_lib.dart" as lib;

class A<T extends core::Object? = dynamic> extends core::Object {
  field dynamic T = null;
  static final field dynamic _redirecting# = <dynamic>[#C1, #C2, #C3, #C4, #C5, #C6, #C7, #C8, #C9, #C10, #C11, #C12, #C13]/*isLegacy*/;
  constructor •() → self::A<self::A::T%>
    : super core::Object::•()
    ;
  static factory foo1<T extends core::Object? = dynamic>(core::int x) → self::A<self::A::foo1::T%>
    return new self::B::•<self::A::foo1::T%>(x);
  static factory foo2<T extends core::Object? = dynamic>(core::int x) → self::A<self::A::foo2::T%>
    return new self::B::foo<self::A::foo2::T%>(x);
  static factory foo3<T extends core::Object? = dynamic>(core::int x) → self::A<self::A::foo3::T%>
    return new self::B::foo<self::A::foo3::T%>(x);
  static factory foo5<T extends core::Object? = dynamic>(core::int x) → self::A<self::A::foo5::T%>
    return self::B::bar<self::A::foo5::T%>(x);
  static factory foo6<T extends core::Object? = dynamic>(core::int x) → self::A<self::A::foo6::T%>
    return self::B::bar<self::A::foo6::T%>(x);
  static factory foo4<T extends core::Object? = dynamic>(core::int x) → self::A<self::A::foo4::T%>
    return new iss::Foo::•<self::A::foo4::T%>(x);
  static factory foo7<T extends core::Object? = dynamic>(core::int x) → self::A<self::A::foo7::T%>
    return iss::Bar::•<self::A::foo7::T%>(x);
  static factory foo8<T extends core::Object? = dynamic>(core::int x) → self::A<self::A::foo8::T%>
    return new iss::Foo::foo<self::A::foo8::T%>(x);
  abstract operator >() → dynamic;
  static factory foo9<T extends core::Object? = dynamic>(core::int x) → self::A<self::A::foo9::T%>
    return new iss::Foo::foo<self::A::foo9::T%>(x);
  static factory foo10<T extends core::Object? = dynamic>(core::int x) → self::A<self::A::foo10::T%>
    return iss::Foo::bar<self::A::foo10::T%>(x);
  static factory foo11<T extends core::Object? = dynamic>(core::int x) → self::A<self::A::foo11::T%>
    return iss::Foo::bar<self::A::foo11::T%>(x);
  static factory foo12<T extends core::Object? = dynamic>(core::int x) → self::A<self::A::foo12::T%>
    return new self::B::foo<self::A::foo12::T%>(x);
  static factory foo13<T extends core::Object? = dynamic>(core::int x) → self::A<self::A::foo13::T%>
    return self::B::bar<self::A::foo13::T%>(x);
}
class B<T extends core::Object? = dynamic> extends self::A<self::B::T%> {
  constructor •(core::int x) → self::B<self::B::T%>
    : super self::A::•()
    ;
  constructor foo(core::int x) → self::B<self::B::T%>
    : super self::A::•()
    ;
  static factory bar<T extends core::Object? = dynamic>(core::int x) → self::B<self::B::bar::T%>
    return new self::B::foo<self::B::bar::T%>(x);
}
static method main() → void {
  new self::B::foo<core::int>(24);
}

library;
//
// Problems in library:
//
// pkg/front_end/testcases/general/issue41842_lib.dart:7:7: Error: The non-abstract class 'Foo' is missing implementations for these members:
//  - A.>
// Try to either
//  - provide an implementation,
//  - inherit an implementation from a superclass or mixin,
//  - mark the class as abstract, or
//  - provide a 'noSuchMethod' implementation.
//
// class Foo<T> extends A<T> {
//       ^^^
// pkg/front_end/testcases/general/issue41842.dart:16:40: Context: 'A.>' is defined here.
//   factory A.foo8(int x) = lib.Foo.foo<T>; // Error. Not allowed by parser.
//                                        ^
//
// pkg/front_end/testcases/general/issue41842_lib.dart:13:7: Error: The non-abstract class 'Bar' is missing implementations for these members:
//  - A.>
// Try to either
//  - provide an implementation,
//  - inherit an implementation from a superclass or mixin,
//  - mark the class as abstract, or
//  - provide a 'noSuchMethod' implementation.
//
// class Bar<T> extends A<T> {
//       ^^^
// pkg/front_end/testcases/general/issue41842.dart:16:40: Context: 'A.>' is defined here.
//   factory A.foo8(int x) = lib.Foo.foo<T>; // Error. Not allowed by parser.
//                                        ^
//
import self as iss;
import "dart:core" as core;
import "issue41842.dart" as self;

import "org-dartlang-testcase:///issue41842.dart";

class Foo<T extends core::Object? = dynamic> extends self::A<iss::Foo::T%> {
  constructor •(core::int x) → iss::Foo<iss::Foo::T%>
    : super self::A::•()
    ;
  constructor foo(core::int x) → iss::Foo<iss::Foo::T%>
    : super self::A::•()
    ;
  static factory bar<T extends core::Object? = dynamic>(core::int x) → iss::Foo<iss::Foo::bar::T%>
    return new iss::Foo::foo<iss::Foo::bar::T%>(x);
}
class Bar<T extends core::Object? = dynamic> extends self::A<iss::Bar::T%> {
  constructor named(core::int x) → iss::Bar<iss::Bar::T%>
    : super self::A::•()
    ;
  constructor foo(core::int x) → iss::Bar<iss::Bar::T%>
    : super self::A::•()
    ;
  static factory •<T extends core::Object? = dynamic>(core::int x) → iss::Bar<iss::Bar::•::T%>
    return new iss::Bar::named<iss::Bar::•::T%>(x);
  static factory bar<T extends core::Object? = dynamic>(core::int x) → iss::Bar<iss::Bar::bar::T%>
    return new iss::Bar::foo<iss::Bar::bar::T%>(x);
}

constants  {
  #C1 = constructor-tearoff self::A::foo1
  #C2 = constructor-tearoff self::A::foo2
  #C3 = constructor-tearoff self::A::foo3
  #C4 = constructor-tearoff self::A::foo5
  #C5 = constructor-tearoff self::A::foo6
  #C6 = constructor-tearoff self::A::foo4
  #C7 = constructor-tearoff self::A::foo7
  #C8 = constructor-tearoff self::A::foo8
  #C9 = constructor-tearoff self::A::foo9
  #C10 = constructor-tearoff self::A::foo10
  #C11 = constructor-tearoff self::A::foo11
  #C12 = constructor-tearoff self::A::foo12
  #C13 = constructor-tearoff self::A::foo13
}
