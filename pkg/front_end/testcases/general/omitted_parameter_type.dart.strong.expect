library;
//
// Problems in library:
//
// pkg/front_end/testcases/general/omitted_parameter_type.dart:55:16: Error: A value of type 'int' can't be assigned to a variable of type 'String'.
//     String y = a; // Error
//                ^
//
// pkg/front_end/testcases/general/omitted_parameter_type.dart:57:17: Error: A value of type 'int?' can't be assigned to a variable of type 'String?'.
//     String? w = b; // Error
//                 ^
//
import self as self;
import "dart:core" as core;

typedef Typedef1 = (dynamic, {b: dynamic}) → void;
class SuperClass extends core::Object {
  synthetic constructor •() → self::SuperClass
    : super core::Object::•()
    ;
  method method((dynamic, {b: dynamic}) → void f) → void {
    function local(dynamic a, {dynamic b = #C1}) → Null {
      core::int x = a as{TypeError,ForDynamic} core::int;
      core::String y = a as{TypeError,ForDynamic} core::String;
      core::int z = b as{TypeError,ForDynamic} core::int;
      core::String w = b as{TypeError,ForDynamic} core::String;
    }
    try {
    }
    on core::Object catch(final core::Object e, final core::StackTrace s) {
    }
  }
  method method1(core::int a, {core::int? b = #C2}) → void {}
}
class SubClass extends self::SuperClass {
  constructor •() → self::SubClass
    : super self::SuperClass::•()
    ;
  constructor constructor1(dynamic a, {dynamic b = #C1}) → self::SubClass
    : super self::SuperClass::•() {
    core::int x = a as{TypeError,ForDynamic} core::int;
    core::String y = a as{TypeError,ForDynamic} core::String;
    core::int z = b as{TypeError,ForDynamic} core::int;
    core::String w = b as{TypeError,ForDynamic} core::String;
  }
  constructor constructor2(core::int x, core::String y, core::int z, core::String w) → self::SubClass
    : super self::SuperClass::•()
    ;
  constructor constructor3(dynamic a, {dynamic b = #C1}) → self::SubClass
    : this self::SubClass::constructor2(a as{TypeError,ForDynamic} core::int, a as{TypeError,ForDynamic} core::String, b as{TypeError,ForDynamic} core::int, b as{TypeError,ForDynamic} core::String)
    ;
  static factory constructor4(dynamic a, {dynamic b = #C1}) → self::SubClass {
    core::int x = a as{TypeError,ForDynamic} core::int;
    core::String y = a as{TypeError,ForDynamic} core::String;
    core::int z = b as{TypeError,ForDynamic} core::int;
    core::String w = b as{TypeError,ForDynamic} core::String;
    return new self::SubClass::•();
  }
  method method1(core::int a, {core::int? b = #C2}) → void {
    core::int x = a;
    core::String y = invalid-expression "pkg/front_end/testcases/general/omitted_parameter_type.dart:55:16: Error: A value of type 'int' can't be assigned to a variable of type 'String'.
    String y = a; // Error
               ^" in a as{TypeError} core::String;
    core::int? z = b;
    core::String? w = invalid-expression "pkg/front_end/testcases/general/omitted_parameter_type.dart:57:17: Error: A value of type 'int?' can't be assigned to a variable of type 'String?'.
    String? w = b; // Error
                ^" in b as{TypeError} core::String?;
  }
  method method2(dynamic a, {dynamic b = #C1}) → dynamic {
    core::int x = a as{TypeError,ForDynamic} core::int;
    core::String y = a as{TypeError,ForDynamic} core::String;
    core::int z = b as{TypeError,ForDynamic} core::int;
    core::String w = b as{TypeError,ForDynamic} core::String;
  }
  static method method3(dynamic a, {dynamic b = #C1}) → dynamic {
    core::int x = a as{TypeError,ForDynamic} core::int;
    core::String y = a as{TypeError,ForDynamic} core::String;
    core::int z = b as{TypeError,ForDynamic} core::int;
    core::String w = b as{TypeError,ForDynamic} core::String;
  }
}
extension /* unnamed */ _extension#0 on core::int {
  method method1 = self::_extension#0|method1;
  method tearoff method1 = self::_extension#0|get#method1;
  static method method2 = self::_extension#0|method2;
}
extension type SuperExtensionType(core::int i) {
  abstract extension-type-member representation-field get i() → core::int;
  method method3 = self::SuperExtensionType|method3;
  method tearoff method3 = self::SuperExtensionType|get#method3;
  constructor • = self::SuperExtensionType|constructor#;
  constructor tearoff • = self::SuperExtensionType|constructor#_#new#tearOff;
}
extension type SubExtensionType(core::int i) implements self::SuperExtensionType% /* erasure=core::int, declared=! */ {
  abstract extension-type-member representation-field get i() → core::int;
  method method3 = self::SubExtensionType|method3;
  method tearoff method3 = self::SubExtensionType|get#method3;
  method method4 = self::SubExtensionType|method4;
  method tearoff method4 = self::SubExtensionType|get#method4;
  constructor • = self::SubExtensionType|constructor#;
  constructor tearoff • = self::SubExtensionType|constructor#_#new#tearOff;
}
static method method0(dynamic a, {dynamic b = #C1}) → dynamic {
  core::int x = a as{TypeError,ForDynamic} core::int;
  core::String y = a as{TypeError,ForDynamic} core::String;
  core::int z = b as{TypeError,ForDynamic} core::int;
  core::String w = b as{TypeError,ForDynamic} core::String;
}
static extension-member method _extension#0|method1(lowered final core::int #this, dynamic a, {dynamic b = #C1}) → dynamic {
  core::int x = a as{TypeError,ForDynamic} core::int;
  core::String y = a as{TypeError,ForDynamic} core::String;
  core::int z = b as{TypeError,ForDynamic} core::int;
  core::String w = b as{TypeError,ForDynamic} core::String;
}
static extension-member method _extension#0|get#method1(lowered final core::int #this) → (dynamic, {b: dynamic}) → dynamic
  return (dynamic a, {dynamic b = #C1}) → dynamic => self::_extension#0|method1(#this, a, b: b);
static extension-member method _extension#0|method2(dynamic a, {dynamic b = #C1}) → dynamic {
  core::int x = a as{TypeError,ForDynamic} core::int;
  core::String y = a as{TypeError,ForDynamic} core::String;
  core::int z = b as{TypeError,ForDynamic} core::int;
  core::String w = b as{TypeError,ForDynamic} core::String;
}
static extension-type-member method SuperExtensionType|constructor#(core::int i) → self::SuperExtensionType% /* erasure=core::int, declared=! */ {
  lowered final self::SuperExtensionType% /* erasure=core::int, declared=! */ #this = i;
  return #this;
}
static extension-type-member synthetic method SuperExtensionType|constructor#_#new#tearOff(core::int i) → self::SuperExtensionType% /* erasure=core::int, declared=! */
  return self::SuperExtensionType|constructor#(i);
static extension-type-member method SuperExtensionType|method3(lowered final self::SuperExtensionType% /* erasure=core::int, declared=! */ #this, core::int a, {core::int? b = #C2}) → void {}
static extension-type-member method SuperExtensionType|get#method3(lowered final self::SuperExtensionType% /* erasure=core::int, declared=! */ #this) → (core::int, {b: core::int?}) → void
  return (core::int a, {core::int? b = #C2}) → void => self::SuperExtensionType|method3(#this, a, b: b);
static extension-type-member method SubExtensionType|constructor#(core::int i) → self::SubExtensionType% /* erasure=core::int, declared=! */ {
  lowered final self::SubExtensionType% /* erasure=core::int, declared=! */ #this = i;
  return #this;
}
static extension-type-member synthetic method SubExtensionType|constructor#_#new#tearOff(core::int i) → self::SubExtensionType% /* erasure=core::int, declared=! */
  return self::SubExtensionType|constructor#(i);
static extension-type-member method SubExtensionType|method3(lowered final self::SubExtensionType% /* erasure=core::int, declared=! */ #this, dynamic a, {dynamic b = #C2}) → dynamic {
  core::int x = a as{TypeError,ForDynamic} core::int;
  core::String y = a as{TypeError,ForDynamic} core::String;
  core::int? z = b as{TypeError,ForDynamic} core::int?;
  core::String? w = b as{TypeError,ForDynamic} core::String?;
}
static extension-type-member method SubExtensionType|get#method3(lowered final self::SubExtensionType% /* erasure=core::int, declared=! */ #this) → (dynamic, {b: dynamic}) → dynamic
  return (dynamic a, {dynamic b = #C2}) → dynamic => self::SubExtensionType|method3(#this, a, b: b);
static extension-type-member method SubExtensionType|method4(lowered final self::SubExtensionType% /* erasure=core::int, declared=! */ #this, dynamic a, {dynamic b = #C1}) → dynamic {
  core::int x = a as{TypeError,ForDynamic} core::int;
  core::String y = a as{TypeError,ForDynamic} core::String;
  core::int z = b as{TypeError,ForDynamic} core::int;
  core::String w = b as{TypeError,ForDynamic} core::String;
}
static extension-type-member method SubExtensionType|get#method4(lowered final self::SubExtensionType% /* erasure=core::int, declared=! */ #this) → (dynamic, {b: dynamic}) → dynamic
  return (dynamic a, {dynamic b = #C1}) → dynamic => self::SubExtensionType|method4(#this, a, b: b);

constants  {
  #C1 = 0
  #C2 = null
}
