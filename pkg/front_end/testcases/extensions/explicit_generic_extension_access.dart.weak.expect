library;
import self as self;
import "dart:core" as core;

class Class<T extends core::num* = core::num*> extends core::Object {
  generic-covariant-impl field self::Class::T* field1;
  generic-covariant-impl field self::Class::T* field2;
  constructor •(self::Class::T* field1, self::Class::T* field2) → self::Class<self::Class::T*>*
    : self::Class::field1 = field1, self::Class::field2 = field2, super core::Object::•()
    ;
  abstract member-signature get _identityHashCode() → core::int*; -> core::Object::_identityHashCode
  abstract member-signature method _instanceOf(dynamic instantiatorTypeArguments, dynamic functionTypeArguments, dynamic type) → core::bool*; -> core::Object::_instanceOf
  abstract member-signature method _simpleInstanceOf(dynamic type) → core::bool*; -> core::Object::_simpleInstanceOf
  abstract member-signature method _simpleInstanceOfTrue(dynamic type) → core::bool*; -> core::Object::_simpleInstanceOfTrue
  abstract member-signature method _simpleInstanceOfFalse(dynamic type) → core::bool*; -> core::Object::_simpleInstanceOfFalse
  abstract member-signature operator ==(dynamic other) → core::bool*; -> core::Object::==
  abstract member-signature get hashCode() → core::int*; -> core::Object::hashCode
  abstract member-signature method toString() → core::String*; -> core::Object::toString
  abstract member-signature method noSuchMethod(core::Invocation* invocation) → dynamic; -> core::Object::noSuchMethod
  abstract member-signature get runtimeType() → core::Type*; -> core::Object::runtimeType
}
extension Extension1<T extends core::num* = core::num*> on self::Class<T*>* {
  static field latestType = self::Extension1|latestType;
  get field = self::Extension1|get#field;
  method method = self::Extension1|method;
  tearoff method = self::Extension1|get#method;
  method genericMethod = self::Extension1|genericMethod;
  tearoff genericMethod = self::Extension1|get#genericMethod;
  set field = self::Extension1|set#field;
}
extension Extension2<T extends core::num* = core::num*> on self::Class<T*>* {
  get field = self::Extension2|get#field;
  method method = self::Extension2|method;
  tearoff method = self::Extension2|get#method;
  method genericMethod = self::Extension2|genericMethod;
  tearoff genericMethod = self::Extension2|get#genericMethod;
  set field = self::Extension2|set#field;
}
static field core::String* Extension1|latestType;
static method Extension1|get#field<T extends core::num* = core::num*>(lowered final self::Class<self::Extension1|get#field::T*>* #this) → self::Extension1|get#field::T* {
  self::Extension1|latestType = "${self::Extension1|get#field::T*}";
  return #this.{self::Class::field1};
}
static method Extension1|set#field<T extends core::num* = core::num*>(lowered final self::Class<self::Extension1|set#field::T*>* #this, self::Extension1|set#field::T* value) → void {
  self::Extension1|latestType = "${self::Extension1|set#field::T*}";
  #this.{self::Class::field1} = value;
}
static method Extension1|method<T extends core::num* = core::num*>(lowered final self::Class<self::Extension1|method::T*>* #this) → self::Extension1|method::T* {
  self::Extension1|latestType = "${self::Extension1|method::T*}";
  return #this.{self::Class::field1};
}
static method Extension1|get#method<T extends core::num* = core::num*>(lowered final self::Class<self::Extension1|get#method::T*>* #this) → () →* self::Extension1|get#method::T*
  return () → self::Extension1|get#method::T* => self::Extension1|method<self::Extension1|get#method::T*>(#this);
static method Extension1|genericMethod<T extends core::num* = core::num*, S extends core::num* = core::num*>(lowered final self::Class<self::Extension1|genericMethod::T*>* #this, self::Extension1|genericMethod::S* t) → self::Extension1|genericMethod::T* {
  self::Extension1|latestType = "${self::Extension1|genericMethod::T*}:${self::Extension1|genericMethod::S*}";
  return #this.{self::Class::field1}.{core::num::+}(t) as{TypeError} self::Extension1|genericMethod::T*;
}
static method Extension1|get#genericMethod<T extends core::num* = core::num*>(lowered final self::Class<self::Extension1|get#genericMethod::T*>* #this) → <S extends core::num* = core::num*>(S*) →* self::Extension1|get#genericMethod::T*
  return <S extends core::num* = core::num*>(S* t) → self::Extension1|get#genericMethod::T* => self::Extension1|genericMethod<self::Extension1|get#genericMethod::T*, S*>(#this, t);
static method Extension2|get#field<T extends core::num* = core::num*>(lowered final self::Class<self::Extension2|get#field::T*>* #this) → self::Extension2|get#field::T*
  return #this.{self::Class::field2};
static method Extension2|set#field<T extends core::num* = core::num*>(lowered final self::Class<self::Extension2|set#field::T*>* #this, self::Extension2|set#field::T* value) → void {
  #this.{self::Class::field2} = value;
}
static method Extension2|method<T extends core::num* = core::num*>(lowered final self::Class<self::Extension2|method::T*>* #this) → self::Extension2|method::T*
  return #this.{self::Class::field2};
static method Extension2|get#method<T extends core::num* = core::num*>(lowered final self::Class<self::Extension2|get#method::T*>* #this) → () →* self::Extension2|get#method::T*
  return () → self::Extension2|get#method::T* => self::Extension2|method<self::Extension2|get#method::T*>(#this);
static method Extension2|genericMethod<T extends core::num* = core::num*, S extends core::num* = core::num*>(lowered final self::Class<self::Extension2|genericMethod::T*>* #this, self::Extension2|genericMethod::S* t) → self::Extension2|genericMethod::T*
  return #this.{self::Class::field2}.{core::num::+}(t) as{TypeError} self::Extension2|genericMethod::T*;
static method Extension2|get#genericMethod<T extends core::num* = core::num*>(lowered final self::Class<self::Extension2|get#genericMethod::T*>* #this) → <S extends core::num* = core::num*>(S*) →* self::Extension2|get#genericMethod::T*
  return <S extends core::num* = core::num*>(S* t) → self::Extension2|get#genericMethod::T* => self::Extension2|genericMethod<self::Extension2|get#genericMethod::T*, S*>(#this, t);
static method main() → dynamic {
  self::Class<core::int*>* c = new self::Class::•<core::int*>(42, 87);
  self::expect(42, self::Extension1|get#field<core::num*>(c));
  self::expect("num", self::Extension1|latestType);
  self::expect(42, self::Extension1|get#field<core::int*>(c));
  self::expect("int", self::Extension1|latestType);
  self::expect(87, self::Extension2|get#field<core::num*>(c));
  self::expect(42, self::Extension1|method<core::num*>(c));
  self::expect("num", self::Extension1|latestType);
  self::expect(42, self::Extension1|method<core::int*>(c));
  self::expect("int", self::Extension1|latestType);
  self::expect(87, self::Extension2|method<core::num*>(c));
  () →* core::num* tearOffNumber1 = self::Extension1|get#method<core::num*>(c);
  () →* core::int* tearOffInteger1 = self::Extension1|get#method<core::int*>(c);
  () →* core::num* tearOff2 = self::Extension2|get#method<core::num*>(c);
  self::expect(42, tearOffNumber1.call());
  self::expect("num", self::Extension1|latestType);
  self::expect(42, tearOffInteger1.call());
  self::expect("int", self::Extension1|latestType);
  self::expect(87, tearOff2.call());
  self::expect(52, self::Extension1|genericMethod<core::num*, core::int*>(c, 10));
  self::expect("num:int", self::Extension1|latestType);
  self::expect(52, self::Extension1|genericMethod<core::int*, core::int*>(c, 10));
  self::expect("int:int", self::Extension1|latestType);
  self::expect(97, self::Extension2|genericMethod<core::num*, core::int*>(c, 10));
  self::expect(52, self::Extension1|genericMethod<core::num*, core::num*>(c, 10));
  self::expect("num:num", self::Extension1|latestType);
  self::expect(52, self::Extension1|genericMethod<core::int*, core::num*>(c, 10));
  self::expect("int:num", self::Extension1|latestType);
  self::expect(97, self::Extension2|genericMethod<core::num*, core::num*>(c, 10));
  self::expect(52, self::Extension1|genericMethod<core::int*, core::int*>(c, 10));
  self::expect("int:int", self::Extension1|latestType);
  self::expect(52, self::Extension1|genericMethod<core::int*, core::num*>(c, 10));
  self::expect("int:num", self::Extension1|latestType);
  self::expect(52, self::Extension1|genericMethod<core::int*, core::int*>(c, 10));
  self::expect("int:int", self::Extension1|latestType);
  <S extends core::num* = core::num*>(S*) →* core::num* genericTearOffNumber1 = self::Extension1|get#genericMethod<core::num*>(c);
  <S extends core::num* = core::num*>(S*) →* core::int* genericTearOffInteger1 = self::Extension1|get#genericMethod<core::int*>(c);
  <S extends core::num* = core::num*>(S*) →* core::num* genericTearOff2 = self::Extension2|get#genericMethod<core::num*>(c);
  self::expect(52, genericTearOffNumber1.call<core::int*>(10));
  self::expect("num:int", self::Extension1|latestType);
  self::expect(52, genericTearOffInteger1.call<core::int*>(10));
  self::expect("int:int", self::Extension1|latestType);
  self::expect(97, genericTearOff2.call<core::int*>(10));
  self::expect(52, genericTearOffNumber1.call<core::num*>(10));
  self::expect("num:num", self::Extension1|latestType);
  self::expect(52, genericTearOffInteger1.call<core::num*>(10));
  self::expect("int:num", self::Extension1|latestType);
  self::expect(97, genericTearOff2.call<core::num*>(10));
  self::expect(23, let final self::Class<core::int*>* #t1 = c in let final core::int* #t2 = 23 in let final void #t3 = self::Extension1|set#field<core::num*>(#t1, #t2) in #t2);
  self::expect("num", self::Extension1|latestType);
  self::expect(23, let final self::Class<core::int*>* #t4 = c in let final core::int* #t5 = 23 in let final void #t6 = self::Extension1|set#field<core::int*>(#t4, #t5) in #t5);
  self::expect("int", self::Extension1|latestType);
  self::expect(67, let final self::Class<core::int*>* #t7 = c in let final core::int* #t8 = 67 in let final void #t9 = self::Extension2|set#field<core::num*>(#t7, #t8) in #t8);
  self::expect(23, self::Extension1|get#field<core::num*>(c));
  self::expect(67, self::Extension2|get#field<core::num*>(c));
}
static method expect(dynamic expected, dynamic actual) → dynamic {
  if(!expected.{core::Object::==}(actual)) {
    throw "Mismatch: expected=${expected}, actual=${actual}";
  }
}
