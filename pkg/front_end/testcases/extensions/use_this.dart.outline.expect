library;
import self as self;
import "dart:core" as core;

class A1 extends core::Object {
  synthetic constructor •() → self::A1*
    ;
  abstract member-signature get _identityHashCode() → core::int*;
  abstract member-signature method _instanceOf(dynamic instantiatorTypeArguments, dynamic functionTypeArguments, dynamic type) → core::bool*;
  abstract member-signature method _simpleInstanceOf(dynamic type) → core::bool*;
  abstract member-signature method _simpleInstanceOfTrue(dynamic type) → core::bool*;
  abstract member-signature method _simpleInstanceOfFalse(dynamic type) → core::bool*;
  abstract member-signature operator ==(dynamic other) → core::bool*;
  abstract member-signature get hashCode() → core::int*;
  abstract member-signature method toString() → core::String*;
  abstract member-signature method noSuchMethod(core::Invocation* invocation) → dynamic;
  abstract member-signature get runtimeType() → core::Type*;
}
class B1<T extends core::Object* = dynamic> extends core::Object {
  synthetic constructor •() → self::B1<self::B1::T*>*
    ;
  abstract member-signature get _identityHashCode() → core::int*;
  abstract member-signature method _instanceOf(dynamic instantiatorTypeArguments, dynamic functionTypeArguments, dynamic type) → core::bool*;
  abstract member-signature method _simpleInstanceOf(dynamic type) → core::bool*;
  abstract member-signature method _simpleInstanceOfTrue(dynamic type) → core::bool*;
  abstract member-signature method _simpleInstanceOfFalse(dynamic type) → core::bool*;
  abstract member-signature operator ==(dynamic other) → core::bool*;
  abstract member-signature get hashCode() → core::int*;
  abstract member-signature method toString() → core::String*;
  abstract member-signature method noSuchMethod(core::Invocation* invocation) → dynamic;
  abstract member-signature get runtimeType() → core::Type*;
}
extension A2 on self::A1* {
  method method1 = self::A2|method1;
  tearoff method1 = self::A2|get#method1;
  method method2 = self::A2|method2;
  tearoff method2 = self::A2|get#method2;
}
extension B2<T extends core::Object* = dynamic> on self::B1<T*>* {
  method method1 = self::B2|method1;
  tearoff method1 = self::B2|get#method1;
  method method2 = self::B2|method2;
  tearoff method2 = self::B2|get#method2;
}
static method A2|method1(final self::A1* #this) → self::A1*
  ;
static method A2|get#method1(final self::A1* #this) → () →* self::A1*
  return () → self::A1* => self::A2|method1(#this);
static method A2|method2<T extends core::Object* = dynamic>(final self::A1* #this, self::A2|method2::T* o) → self::A1*
  ;
static method A2|get#method2(final self::A1* #this) → <T extends core::Object* = dynamic>(T*) →* self::A1*
  return <T extends core::Object* = dynamic>(T* o) → self::A1* => self::A2|method2<T*>(#this, o);
static method B2|method1<T extends core::Object* = dynamic>(final self::B1<self::B2|method1::T*>* #this) → self::B1<self::B2|method1::T*>*
  ;
static method B2|get#method1<T extends core::Object* = dynamic>(final self::B1<self::B2|get#method1::T*>* #this) → () →* self::B1<self::B2|get#method1::T*>*
  return () → self::B1<self::B2|get#method1::T*>* => self::B2|method1<self::B2|get#method1::T*>(#this);
static method B2|method2<T extends core::Object* = dynamic, S extends core::Object* = dynamic>(final self::B1<self::B2|method2::T*>* #this, self::B2|method2::S* o) → self::B1<self::B2|method2::T*>*
  ;
static method B2|get#method2<T extends core::Object* = dynamic>(final self::B1<self::B2|get#method2::T*>* #this) → <S extends core::Object* = dynamic>(S*) →* self::B1<self::B2|get#method2::T*>*
  return <S extends core::Object* = dynamic>(S* o) → self::B1<self::B2|get#method2::T*>* => self::B2|method2<self::B2|get#method2::T*, S*>(#this, o);
static method main() → dynamic
  ;
