library;
import self as self;
import "dart:core" as core;

static method testNotCaptured() → dynamic /* scope=[
  not-captured VariableContext([
    local-variable a;
  ]),
] */ {
  a := 0;
  return a;
}
static method testCaptured() → dynamic /* scope=[
  captured VariableContext([
    local-variable a;
  ]),
] */ {
  a := 0;
  return () → core::int => a;
}
static method testForCounterNotCaptured() → dynamic /* scope=[
  not-captured VariableContext([
    local-variable a;
  ]),
] */ {
  a := 0;
  for /* scope=[
    not-captured VariableContext([
      local-variable i;
    ]),
  ] */ (i := 0; i.{core::num::<}(10){(core::num) → core::bool}; i = i.{core::num::+}(1){(core::num) → core::int}) {
    a = a.{core::num::+}(i){(core::num) → core::int};
  }
  return a;
}
static method testForCounterCaptured() → dynamic /* scope=[
  not-captured VariableContext([
    local-variable closures;
  ]),
] */ {
  closures := <core::Function>[];
  for /* scope=[
    captured VariableContext([
      local-variable i;
    ]),
  ] */ (i := 0; i.{core::num::<}(10){(core::num) → core::bool}; i = i.{core::num::+}(1){(core::num) → core::int}) {
    closures.{core::List::add}(() → core::int => i){(core::Function) → void};
  }
  return closures;
}
static method testForInCounterNotCaptured(core::List<core::int> list) → dynamic /* scope=[
  not-captured VariableContext([
    local-variable a;
  ]),
] */ {
  a := 0;
  for (local-variable i in list) {
    a = a.{core::num::+}(i){(core::num) → core::int};
  }
  return a;
}
static method testForInCounterCaptured(core::List<core::int> list) → dynamic /* scope=[
  not-captured VariableContext([
    local-variable closures;
  ]),
] */ {
  closures := <core::Function>[];
  for (local-variable i in list) {
    closures.{core::List::add}(() → core::int => i){(core::Function) → void};
  }
  return closures;
}
static method testForInElementCounterNotCaptured(core::List<core::int> list) → dynamic /* scope=[
  not-captured VariableContext([
    local-variable list2;
  ]),
] */ {
  list2 := block {
    final core::List<core::int> #t1 = <core::int>[];
    for /* scope=[
      not-captured VariableContext([
        local-variable i;
      ]),
    ] */ (local-variable i in list)
      #t1.{core::List::add}{Invariant}(i){(core::int) → void};
  } =>#t1;
  return list2;
}
static method testForInElementCounterCaptured(core::List<core::int> list) → dynamic /* scope=[
  not-captured VariableContext([
    local-variable closures;
  ]),
] */ {
  closures := block {
    final core::List<core::Function> #t2 = <core::Function>[];
    for /* scope=[
      captured VariableContext([
        local-variable i;
      ]),
    ] */ (local-variable i in list)
      #t2.{core::List::add}{Invariant}(() → core::int => i){(core::Function) → void};
  } =>#t2;
  return closures;
}
static method testForInMapEntryCounterNotCaptured(core::List<core::int> list) → dynamic /* scope=[
  not-captured VariableContext([
    local-variable list2;
  ]),
] */ {
  list2 := block {
    final core::Map<core::int, core::String> #t3 = <core::int, core::String>{};
    for /* scope=[
      not-captured VariableContext([
        local-variable i;
      ]),
    ] */ (local-variable i in list)
      #t3.{core::Map::[]=}{Invariant}(i, "${i}"){(core::int, core::String) → void};
  } =>#t3;
  return list2;
}
static method testForInMapEntryCounterCaptured(core::List<core::int> list) → dynamic /* scope=[
  not-captured VariableContext([
    local-variable closures;
  ]),
] */ {
  closures := block {
    final core::Map<core::int, core::Function> #t4 = <core::int, core::Function>{};
    for /* scope=[
      captured VariableContext([
        local-variable i;
      ]),
    ] */ (local-variable i in list)
      #t4.{core::Map::[]=}{Invariant}(i, () → core::int => i){(core::int, core::Function) → void};
  } =>#t4;
  return closures;
}
