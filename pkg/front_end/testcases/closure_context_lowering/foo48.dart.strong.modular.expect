library;
import self as self;
import "dart:core" as core;

@#C3
@#C5
@#C7
static method opaqueVal() → core::int
  return core::int::parse("42");
@#C3
@#C5
@#C7
static method callClosure(positional-parameter func) → void/* scope=[
  #ctx1: not-captured VariableContext([
    positional-parameter func;
  ]),
] */ {
  if(self::opaqueVal() =={core::num::==}{(core::Object) → core::bool} 1)
    func(){() → void};
}
static method foo48() → void {
  if(self::opaqueVal() =={core::num::==}{(core::Object) → core::bool} 1)/* scope=[
    #ctx2: direct-captured VariableContext([
      local-variable a;
    ]),
  ] */ {
    a := 10;
    self::callClosure(() /* #ctx2 */ → void {
      a = a.{core::num::+}(11){(core::num) → core::int};
    });
  }
  if(self::opaqueVal() =={core::num::==}{(core::Object) → core::bool} 1)/* scope=[
    #ctx3: direct-captured VariableContext([
      local-variable b;
    ]),
  ] */ {
    b := 20;
    self::callClosure(() /* #ctx3 */ → void {
      b = b.{core::num::+}(22){(core::num) → core::int};
    });
  }
}

constants  {
  #C1 = "vm:never-inline"
  #C2 = null
  #C3 = core::pragma {name:#C1, options:#C2}
  #C4 = "wasm:never-inline"
  #C5 = core::pragma {name:#C4, options:#C2}
  #C6 = "dart2js:noInline"
  #C7 = core::pragma {name:#C6, options:#C2}
}


Constructor coverage from constants:
org-dartlang-testcase:///foo48.dart:
- pragma._ (from org-dartlang-sdk:///sdk/lib/core/annotations.dart)
- Object. (from org-dartlang-sdk:///sdk/lib/core/object.dart)
