abstract class D<T> {
  int method(T x);
}
class A<in T, out U, V> {
  Map<U, ContraFunction<V>> get mapContraFn => new Map<U, ContraFunction<V>>();
  Map<U, Contravariant<V>> get mapContra => new Map<U, Contravariant<V>>();
  Map<U, InvFunction<V>> get mapInvFn => new Map<U, InvFunction<V>>();
  Map<U, Invariant<V>> get mapInv => new Map<U, Invariant<V>>();
  final void Function(T)? field = null;
  void method(T t, void Function(U) u, V v) {}
  void method2(T x, [T? y]) {}
  void set x(T t) {}
}
class B<inout T> {
  T? x;
  T method(T x) => x;
  void set y(T x) {}
}
class C<in T> {
  final void Function(T)? field = null;
  void method(T x, [T? y]) {}
  void set x(T t) {}
}
class Contravariant<in T> {}
class E<inout T> {
  E(this.f);
  final void Function(T) f;
  int method(T x) {}
}
class F<inout T> extends E<T> implements D<T> {
  F(void Function(T) f) : super(f);
}
class Invariant<inout T> {}
class NoSuchMethod<inout T> implements B<T> {
  noSuchMethod(_) => 3;
}
expect(expected, actual) {}
main() {}
typedef ContraFunction<T> = void Function(T);
typedef InvFunction<T> = T Function(T);
