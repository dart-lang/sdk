library test;
import self as self;
import "dart:core" as core;
import "dart:async" as asy;

import "dart:async";

abstract class MyFuture extends core::Object implements asy::Future<core::int> {
  synthetic constructor •() → self::MyFuture
    : super core::Object::•()
    ;
}
static method test() → void /* originally async */ {
  final asy::_AsyncAwaitCompleter<dynamic> :async_completer = new asy::_AsyncAwaitCompleter::•<dynamic>();
  asy::FutureOr<dynamic> :return_value;
  dynamic :async_stack_trace;
  dynamic :async_op_then;
  dynamic :async_op_error;
  dynamic :await_jump_var = 0;
  dynamic :await_ctx_var;
  dynamic :saved_try_context_var0;
  function :async_op([dynamic :result, dynamic :exception, dynamic :stack_trace]) → dynamic yielding 
    try {
      #L1:
      {
        core::int x0;
        asy::Future<core::int> x1;
        asy::Future<asy::Future<core::int>> x2;
        asy::Future<asy::FutureOr<core::int>> x3;
        asy::Future<self::MyFuture> x4;
        asy::FutureOr<core::int> x5;
        asy::FutureOr<asy::Future<core::int>> x6;
        asy::FutureOr<asy::FutureOr<core::int>> x7;
        asy::FutureOr<self::MyFuture> x8;
        self::MyFuture x9;
        function test0() → asy::Future<core::int> /* originally async */ {
          final asy::_AsyncAwaitCompleter<core::int> :async_completer = new asy::_AsyncAwaitCompleter::•<core::int>();
          asy::FutureOr<core::int> :return_value;
          dynamic :async_stack_trace;
          dynamic :async_op_then;
          dynamic :async_op_error;
          dynamic :await_jump_var = 0;
          dynamic :await_ctx_var;
          function :async_op([dynamic :result, dynamic :exception, dynamic :stack_trace]) → dynamic yielding 
            try {
              #L2:
              {
                :return_value = x0;
                break #L2;
              }
              asy::_completeOnAsyncReturn(:async_completer, :return_value);
              return;
            }
            on dynamic catch(dynamic :exception, dynamic :stack_trace) {
              :async_completer.{asy::Completer::completeError}(:exception, :stack_trace);
            }
          :async_stack_trace = asy::_asyncStackTraceHelper(:async_op);
          :async_op_then = asy::_asyncThenWrapperHelper(:async_op);
          :async_op_error = asy::_asyncErrorWrapperHelper(:async_op);
          :async_completer.start(:async_op);
          return :async_completer.{asy::Completer::future};
        }
        function test1() → asy::Future<core::int> /* originally async */ {
          final asy::_AsyncAwaitCompleter<core::int> :async_completer = new asy::_AsyncAwaitCompleter::•<core::int>();
          asy::FutureOr<core::int> :return_value;
          dynamic :async_stack_trace;
          dynamic :async_op_then;
          dynamic :async_op_error;
          dynamic :await_jump_var = 0;
          dynamic :await_ctx_var;
          function :async_op([dynamic :result, dynamic :exception, dynamic :stack_trace]) → dynamic yielding 
            try {
              #L3:
              {
                :return_value = x1;
                break #L3;
              }
              asy::_completeOnAsyncReturn(:async_completer, :return_value);
              return;
            }
            on dynamic catch(dynamic :exception, dynamic :stack_trace) {
              :async_completer.{asy::Completer::completeError}(:exception, :stack_trace);
            }
          :async_stack_trace = asy::_asyncStackTraceHelper(:async_op);
          :async_op_then = asy::_asyncThenWrapperHelper(:async_op);
          :async_op_error = asy::_asyncErrorWrapperHelper(:async_op);
          :async_completer.start(:async_op);
          return :async_completer.{asy::Completer::future};
        }
        function test2() → asy::Future<asy::Future<core::int>> /* originally async */ {
          final asy::_AsyncAwaitCompleter<asy::Future<core::int>> :async_completer = new asy::_AsyncAwaitCompleter::•<asy::Future<core::int>>();
          asy::FutureOr<asy::Future<core::int>> :return_value;
          dynamic :async_stack_trace;
          dynamic :async_op_then;
          dynamic :async_op_error;
          dynamic :await_jump_var = 0;
          dynamic :await_ctx_var;
          function :async_op([dynamic :result, dynamic :exception, dynamic :stack_trace]) → dynamic yielding 
            try {
              #L4:
              {
                :return_value = x2;
                break #L4;
              }
              asy::_completeOnAsyncReturn(:async_completer, :return_value);
              return;
            }
            on dynamic catch(dynamic :exception, dynamic :stack_trace) {
              :async_completer.{asy::Completer::completeError}(:exception, :stack_trace);
            }
          :async_stack_trace = asy::_asyncStackTraceHelper(:async_op);
          :async_op_then = asy::_asyncThenWrapperHelper(:async_op);
          :async_op_error = asy::_asyncErrorWrapperHelper(:async_op);
          :async_completer.start(:async_op);
          return :async_completer.{asy::Completer::future};
        }
        function test3() → asy::Future<asy::FutureOr<core::int>> /* originally async */ {
          final asy::_AsyncAwaitCompleter<asy::FutureOr<core::int>> :async_completer = new asy::_AsyncAwaitCompleter::•<asy::FutureOr<core::int>>();
          asy::FutureOr<asy::FutureOr<core::int>> :return_value;
          dynamic :async_stack_trace;
          dynamic :async_op_then;
          dynamic :async_op_error;
          dynamic :await_jump_var = 0;
          dynamic :await_ctx_var;
          function :async_op([dynamic :result, dynamic :exception, dynamic :stack_trace]) → dynamic yielding 
            try {
              #L5:
              {
                :return_value = x3;
                break #L5;
              }
              asy::_completeOnAsyncReturn(:async_completer, :return_value);
              return;
            }
            on dynamic catch(dynamic :exception, dynamic :stack_trace) {
              :async_completer.{asy::Completer::completeError}(:exception, :stack_trace);
            }
          :async_stack_trace = asy::_asyncStackTraceHelper(:async_op);
          :async_op_then = asy::_asyncThenWrapperHelper(:async_op);
          :async_op_error = asy::_asyncErrorWrapperHelper(:async_op);
          :async_completer.start(:async_op);
          return :async_completer.{asy::Completer::future};
        }
        function test4() → asy::Future<self::MyFuture> /* originally async */ {
          final asy::_AsyncAwaitCompleter<self::MyFuture> :async_completer = new asy::_AsyncAwaitCompleter::•<self::MyFuture>();
          asy::FutureOr<self::MyFuture> :return_value;
          dynamic :async_stack_trace;
          dynamic :async_op_then;
          dynamic :async_op_error;
          dynamic :await_jump_var = 0;
          dynamic :await_ctx_var;
          function :async_op([dynamic :result, dynamic :exception, dynamic :stack_trace]) → dynamic yielding 
            try {
              #L6:
              {
                :return_value = x4;
                break #L6;
              }
              asy::_completeOnAsyncReturn(:async_completer, :return_value);
              return;
            }
            on dynamic catch(dynamic :exception, dynamic :stack_trace) {
              :async_completer.{asy::Completer::completeError}(:exception, :stack_trace);
            }
          :async_stack_trace = asy::_asyncStackTraceHelper(:async_op);
          :async_op_then = asy::_asyncThenWrapperHelper(:async_op);
          :async_op_error = asy::_asyncErrorWrapperHelper(:async_op);
          :async_completer.start(:async_op);
          return :async_completer.{asy::Completer::future};
        }
        function test5() → asy::Future<core::int> /* originally async */ {
          final asy::_AsyncAwaitCompleter<core::int> :async_completer = new asy::_AsyncAwaitCompleter::•<core::int>();
          asy::FutureOr<core::int> :return_value;
          dynamic :async_stack_trace;
          dynamic :async_op_then;
          dynamic :async_op_error;
          dynamic :await_jump_var = 0;
          dynamic :await_ctx_var;
          function :async_op([dynamic :result, dynamic :exception, dynamic :stack_trace]) → dynamic yielding 
            try {
              #L7:
              {
                :return_value = x5;
                break #L7;
              }
              asy::_completeOnAsyncReturn(:async_completer, :return_value);
              return;
            }
            on dynamic catch(dynamic :exception, dynamic :stack_trace) {
              :async_completer.{asy::Completer::completeError}(:exception, :stack_trace);
            }
          :async_stack_trace = asy::_asyncStackTraceHelper(:async_op);
          :async_op_then = asy::_asyncThenWrapperHelper(:async_op);
          :async_op_error = asy::_asyncErrorWrapperHelper(:async_op);
          :async_completer.start(:async_op);
          return :async_completer.{asy::Completer::future};
        }
        function test6() → asy::Future<asy::Future<core::int>> /* originally async */ {
          final asy::_AsyncAwaitCompleter<asy::Future<core::int>> :async_completer = new asy::_AsyncAwaitCompleter::•<asy::Future<core::int>>();
          asy::FutureOr<asy::Future<core::int>> :return_value;
          dynamic :async_stack_trace;
          dynamic :async_op_then;
          dynamic :async_op_error;
          dynamic :await_jump_var = 0;
          dynamic :await_ctx_var;
          function :async_op([dynamic :result, dynamic :exception, dynamic :stack_trace]) → dynamic yielding 
            try {
              #L8:
              {
                :return_value = x6;
                break #L8;
              }
              asy::_completeOnAsyncReturn(:async_completer, :return_value);
              return;
            }
            on dynamic catch(dynamic :exception, dynamic :stack_trace) {
              :async_completer.{asy::Completer::completeError}(:exception, :stack_trace);
            }
          :async_stack_trace = asy::_asyncStackTraceHelper(:async_op);
          :async_op_then = asy::_asyncThenWrapperHelper(:async_op);
          :async_op_error = asy::_asyncErrorWrapperHelper(:async_op);
          :async_completer.start(:async_op);
          return :async_completer.{asy::Completer::future};
        }
        function test7() → asy::Future<asy::FutureOr<core::int>> /* originally async */ {
          final asy::_AsyncAwaitCompleter<asy::FutureOr<core::int>> :async_completer = new asy::_AsyncAwaitCompleter::•<asy::FutureOr<core::int>>();
          asy::FutureOr<asy::FutureOr<core::int>> :return_value;
          dynamic :async_stack_trace;
          dynamic :async_op_then;
          dynamic :async_op_error;
          dynamic :await_jump_var = 0;
          dynamic :await_ctx_var;
          function :async_op([dynamic :result, dynamic :exception, dynamic :stack_trace]) → dynamic yielding 
            try {
              #L9:
              {
                :return_value = x7;
                break #L9;
              }
              asy::_completeOnAsyncReturn(:async_completer, :return_value);
              return;
            }
            on dynamic catch(dynamic :exception, dynamic :stack_trace) {
              :async_completer.{asy::Completer::completeError}(:exception, :stack_trace);
            }
          :async_stack_trace = asy::_asyncStackTraceHelper(:async_op);
          :async_op_then = asy::_asyncThenWrapperHelper(:async_op);
          :async_op_error = asy::_asyncErrorWrapperHelper(:async_op);
          :async_completer.start(:async_op);
          return :async_completer.{asy::Completer::future};
        }
        function test8() → asy::Future<self::MyFuture> /* originally async */ {
          final asy::_AsyncAwaitCompleter<self::MyFuture> :async_completer = new asy::_AsyncAwaitCompleter::•<self::MyFuture>();
          asy::FutureOr<self::MyFuture> :return_value;
          dynamic :async_stack_trace;
          dynamic :async_op_then;
          dynamic :async_op_error;
          dynamic :await_jump_var = 0;
          dynamic :await_ctx_var;
          function :async_op([dynamic :result, dynamic :exception, dynamic :stack_trace]) → dynamic yielding 
            try {
              #L10:
              {
                :return_value = x8;
                break #L10;
              }
              asy::_completeOnAsyncReturn(:async_completer, :return_value);
              return;
            }
            on dynamic catch(dynamic :exception, dynamic :stack_trace) {
              :async_completer.{asy::Completer::completeError}(:exception, :stack_trace);
            }
          :async_stack_trace = asy::_asyncStackTraceHelper(:async_op);
          :async_op_then = asy::_asyncThenWrapperHelper(:async_op);
          :async_op_error = asy::_asyncErrorWrapperHelper(:async_op);
          :async_completer.start(:async_op);
          return :async_completer.{asy::Completer::future};
        }
        function test9() → asy::Future<core::int> /* originally async */ {
          final asy::_AsyncAwaitCompleter<core::int> :async_completer = new asy::_AsyncAwaitCompleter::•<core::int>();
          asy::FutureOr<core::int> :return_value;
          dynamic :async_stack_trace;
          dynamic :async_op_then;
          dynamic :async_op_error;
          dynamic :await_jump_var = 0;
          dynamic :await_ctx_var;
          function :async_op([dynamic :result, dynamic :exception, dynamic :stack_trace]) → dynamic yielding 
            try {
              #L11:
              {
                :return_value = x9;
                break #L11;
              }
              asy::_completeOnAsyncReturn(:async_completer, :return_value);
              return;
            }
            on dynamic catch(dynamic :exception, dynamic :stack_trace) {
              :async_completer.{asy::Completer::completeError}(:exception, :stack_trace);
            }
          :async_stack_trace = asy::_asyncStackTraceHelper(:async_op);
          :async_op_then = asy::_asyncThenWrapperHelper(:async_op);
          :async_op_error = asy::_asyncErrorWrapperHelper(:async_op);
          :async_completer.start(:async_op);
          return :async_completer.{asy::Completer::future};
        }
        [yield] let dynamic #t1 = asy::_awaitHelper(x0, :async_op_then, :async_op_error, :async_op) in null;
        core::int y0 = :result;
        [yield] let dynamic #t2 = asy::_awaitHelper(x1, :async_op_then, :async_op_error, :async_op) in null;
        core::int y1 = :result;
        [yield] let dynamic #t3 = asy::_awaitHelper(x2, :async_op_then, :async_op_error, :async_op) in null;
        asy::Future<core::int> y2 = :result;
        [yield] let dynamic #t4 = asy::_awaitHelper(x3, :async_op_then, :async_op_error, :async_op) in null;
        asy::FutureOr<core::int> y3 = :result;
        [yield] let dynamic #t5 = asy::_awaitHelper(x4, :async_op_then, :async_op_error, :async_op) in null;
        self::MyFuture y4 = :result;
        [yield] let dynamic #t6 = asy::_awaitHelper(x5, :async_op_then, :async_op_error, :async_op) in null;
        core::int y5 = :result;
        [yield] let dynamic #t7 = asy::_awaitHelper(x6, :async_op_then, :async_op_error, :async_op) in null;
        asy::Future<core::int> y6 = :result;
        [yield] let dynamic #t8 = asy::_awaitHelper(x7, :async_op_then, :async_op_error, :async_op) in null;
        asy::FutureOr<core::int> y7 = :result;
        [yield] let dynamic #t9 = asy::_awaitHelper(x8, :async_op_then, :async_op_error, :async_op) in null;
        self::MyFuture y8 = :result;
        [yield] let dynamic #t10 = asy::_awaitHelper(x9, :async_op_then, :async_op_error, :async_op) in null;
        core::int y9 = :result;
      }
      asy::_completeOnAsyncReturn(:async_completer, :return_value);
      return;
    }
    on dynamic catch(dynamic :exception, dynamic :stack_trace) {
      :async_completer.{asy::Completer::completeError}(:exception, :stack_trace);
    }
  :async_stack_trace = asy::_asyncStackTraceHelper(:async_op);
  :async_op_then = asy::_asyncThenWrapperHelper(:async_op);
  :async_op_error = asy::_asyncErrorWrapperHelper(:async_op);
  :async_completer.start(:async_op);
  return :async_completer.{asy::Completer::future};
}
static method main() → dynamic {}
