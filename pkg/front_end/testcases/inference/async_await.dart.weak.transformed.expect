library test;
import self as self;
import "dart:core" as core;
import "dart:async" as asy;
import "dart:_internal" as _in;

import "dart:async";

abstract class MyFuture extends core::Object implements asy::Future<core::int*> {
  synthetic constructor •() → self::MyFuture*
    : super core::Object::•()
    ;
  abstract member-signature get _identityHashCode() → core::int*; -> core::Object::_identityHashCode
  abstract member-signature method _instanceOf(dynamic instantiatorTypeArguments, dynamic functionTypeArguments, dynamic type) → core::bool*; -> core::Object::_instanceOf
  abstract member-signature method _simpleInstanceOf(dynamic type) → core::bool*; -> core::Object::_simpleInstanceOf
  abstract member-signature method _simpleInstanceOfTrue(dynamic type) → core::bool*; -> core::Object::_simpleInstanceOfTrue
  abstract member-signature method _simpleInstanceOfFalse(dynamic type) → core::bool*; -> core::Object::_simpleInstanceOfFalse
  abstract member-signature operator ==(dynamic other) → core::bool*; -> core::Object::==
  abstract member-signature get hashCode() → core::int*; -> core::Object::hashCode
  abstract member-signature method toString() → core::String*; -> core::Object::toString
  abstract member-signature method noSuchMethod(core::Invocation* invocation) → dynamic; -> core::Object::noSuchMethod
  abstract member-signature get runtimeType() → core::Type*; -> core::Object::runtimeType
  abstract member-signature method then<R extends core::Object* = dynamic>((core::int*) →* FutureOr<self::MyFuture::then::R*>* onValue, {core::Function* onError = #C1}) → asy::Future<self::MyFuture::then::R*>*; -> asy::Future::then
  abstract member-signature method catchError(core::Function* onError, {(core::Object*) →* core::bool* test = #C1}) → asy::Future<core::int*>*; -> asy::Future::catchError
  abstract member-signature method whenComplete(() →* FutureOr<void>* action) → asy::Future<core::int*>*; -> asy::Future::whenComplete
  abstract member-signature method asStream() → asy::Stream<core::int*>*; -> asy::Future::asStream
  abstract member-signature method timeout(core::Duration* timeLimit, {generic-covariant-impl () →* FutureOr<core::int*>* onTimeout = #C1}) → asy::Future<core::int*>*; -> asy::Future::timeout
}
static method test() → void /* originally async */ {
  final asy::_Future<dynamic>* :async_future = new asy::_Future::•<dynamic>();
  core::bool* :is_sync = false;
  FutureOr<dynamic>* :return_value;
  (dynamic) →* dynamic :async_op_then;
  (core::Object*, core::StackTrace*) →* dynamic :async_op_error;
  core::int* :await_jump_var = 0;
  dynamic :await_ctx_var;
  dynamic :saved_try_context_var0;
  function :async_op([dynamic :result, dynamic :exception, dynamic :stack_trace]) → dynamic yielding 
    try {
      #L1:
      {
        core::int* x0;
        asy::Future<core::int*>* x1;
        asy::Future<asy::Future<core::int*>*>* x2;
        asy::Future<FutureOr<core::int*>*>* x3;
        asy::Future<self::MyFuture*>* x4;
        FutureOr<core::int*>* x5;
        FutureOr<asy::Future<core::int*>*>* x6;
        FutureOr<FutureOr<core::int*>*>* x7;
        FutureOr<self::MyFuture*>* x8;
        self::MyFuture* x9;
        function test0() → asy::Future<core::int*>* /* originally async */ {
          final asy::_Future<core::int*>* :async_future = new asy::_Future::•<core::int*>();
          core::bool* :is_sync = false;
          FutureOr<core::int*>* :return_value;
          (dynamic) →* dynamic :async_op_then;
          (core::Object*, core::StackTrace*) →* dynamic :async_op_error;
          core::int* :await_jump_var = 0;
          dynamic :await_ctx_var;
          function :async_op([dynamic :result, dynamic :exception, dynamic :stack_trace]) → dynamic yielding 
            try {
              #L2:
              {
                :return_value = x0;
                break #L2;
              }
              asy::_completeOnAsyncReturn(:async_future, :return_value, :is_sync);
              return;
            }
            on dynamic catch(dynamic exception, core::StackTrace* stack_trace) {
              asy::_completeOnAsyncError(:async_future, exception, stack_trace, :is_sync);
            }
          :async_op_then = asy::_asyncThenWrapperHelper(:async_op);
          :async_op_error = asy::_asyncErrorWrapperHelper(:async_op);
          :async_op.call();
          :is_sync = true;
          return :async_future;
        }
        function test1() → asy::Future<core::int*>* /* originally async */ {
          final asy::_Future<core::int*>* :async_future = new asy::_Future::•<core::int*>();
          core::bool* :is_sync = false;
          FutureOr<core::int*>* :return_value;
          (dynamic) →* dynamic :async_op_then;
          (core::Object*, core::StackTrace*) →* dynamic :async_op_error;
          core::int* :await_jump_var = 0;
          dynamic :await_ctx_var;
          function :async_op([dynamic :result, dynamic :exception, dynamic :stack_trace]) → dynamic yielding 
            try {
              #L3:
              {
                :return_value = x1;
                break #L3;
              }
              asy::_completeOnAsyncReturn(:async_future, :return_value, :is_sync);
              return;
            }
            on dynamic catch(dynamic exception, core::StackTrace* stack_trace) {
              asy::_completeOnAsyncError(:async_future, exception, stack_trace, :is_sync);
            }
          :async_op_then = asy::_asyncThenWrapperHelper(:async_op);
          :async_op_error = asy::_asyncErrorWrapperHelper(:async_op);
          :async_op.call();
          :is_sync = true;
          return :async_future;
        }
        function test2() → asy::Future<asy::Future<core::int*>*>* /* originally async */ {
          final asy::_Future<asy::Future<core::int*>*>* :async_future = new asy::_Future::•<asy::Future<core::int*>*>();
          core::bool* :is_sync = false;
          FutureOr<asy::Future<core::int*>*>* :return_value;
          (dynamic) →* dynamic :async_op_then;
          (core::Object*, core::StackTrace*) →* dynamic :async_op_error;
          core::int* :await_jump_var = 0;
          dynamic :await_ctx_var;
          function :async_op([dynamic :result, dynamic :exception, dynamic :stack_trace]) → dynamic yielding 
            try {
              #L4:
              {
                :return_value = x2;
                break #L4;
              }
              asy::_completeOnAsyncReturn(:async_future, :return_value, :is_sync);
              return;
            }
            on dynamic catch(dynamic exception, core::StackTrace* stack_trace) {
              asy::_completeOnAsyncError(:async_future, exception, stack_trace, :is_sync);
            }
          :async_op_then = asy::_asyncThenWrapperHelper(:async_op);
          :async_op_error = asy::_asyncErrorWrapperHelper(:async_op);
          :async_op.call();
          :is_sync = true;
          return :async_future;
        }
        function test3() → asy::Future<FutureOr<core::int*>*>* /* originally async */ {
          final asy::_Future<FutureOr<core::int*>*>* :async_future = new asy::_Future::•<FutureOr<core::int*>*>();
          core::bool* :is_sync = false;
          FutureOr<FutureOr<core::int*>*>* :return_value;
          (dynamic) →* dynamic :async_op_then;
          (core::Object*, core::StackTrace*) →* dynamic :async_op_error;
          core::int* :await_jump_var = 0;
          dynamic :await_ctx_var;
          function :async_op([dynamic :result, dynamic :exception, dynamic :stack_trace]) → dynamic yielding 
            try {
              #L5:
              {
                :return_value = x3;
                break #L5;
              }
              asy::_completeOnAsyncReturn(:async_future, :return_value, :is_sync);
              return;
            }
            on dynamic catch(dynamic exception, core::StackTrace* stack_trace) {
              asy::_completeOnAsyncError(:async_future, exception, stack_trace, :is_sync);
            }
          :async_op_then = asy::_asyncThenWrapperHelper(:async_op);
          :async_op_error = asy::_asyncErrorWrapperHelper(:async_op);
          :async_op.call();
          :is_sync = true;
          return :async_future;
        }
        function test4() → asy::Future<self::MyFuture*>* /* originally async */ {
          final asy::_Future<self::MyFuture*>* :async_future = new asy::_Future::•<self::MyFuture*>();
          core::bool* :is_sync = false;
          FutureOr<self::MyFuture*>* :return_value;
          (dynamic) →* dynamic :async_op_then;
          (core::Object*, core::StackTrace*) →* dynamic :async_op_error;
          core::int* :await_jump_var = 0;
          dynamic :await_ctx_var;
          function :async_op([dynamic :result, dynamic :exception, dynamic :stack_trace]) → dynamic yielding 
            try {
              #L6:
              {
                :return_value = x4;
                break #L6;
              }
              asy::_completeOnAsyncReturn(:async_future, :return_value, :is_sync);
              return;
            }
            on dynamic catch(dynamic exception, core::StackTrace* stack_trace) {
              asy::_completeOnAsyncError(:async_future, exception, stack_trace, :is_sync);
            }
          :async_op_then = asy::_asyncThenWrapperHelper(:async_op);
          :async_op_error = asy::_asyncErrorWrapperHelper(:async_op);
          :async_op.call();
          :is_sync = true;
          return :async_future;
        }
        function test5() → asy::Future<core::int*>* /* originally async */ {
          final asy::_Future<core::int*>* :async_future = new asy::_Future::•<core::int*>();
          core::bool* :is_sync = false;
          FutureOr<core::int*>* :return_value;
          (dynamic) →* dynamic :async_op_then;
          (core::Object*, core::StackTrace*) →* dynamic :async_op_error;
          core::int* :await_jump_var = 0;
          dynamic :await_ctx_var;
          function :async_op([dynamic :result, dynamic :exception, dynamic :stack_trace]) → dynamic yielding 
            try {
              #L7:
              {
                :return_value = x5;
                break #L7;
              }
              asy::_completeOnAsyncReturn(:async_future, :return_value, :is_sync);
              return;
            }
            on dynamic catch(dynamic exception, core::StackTrace* stack_trace) {
              asy::_completeOnAsyncError(:async_future, exception, stack_trace, :is_sync);
            }
          :async_op_then = asy::_asyncThenWrapperHelper(:async_op);
          :async_op_error = asy::_asyncErrorWrapperHelper(:async_op);
          :async_op.call();
          :is_sync = true;
          return :async_future;
        }
        function test6() → asy::Future<asy::Future<core::int*>*>* /* originally async */ {
          final asy::_Future<asy::Future<core::int*>*>* :async_future = new asy::_Future::•<asy::Future<core::int*>*>();
          core::bool* :is_sync = false;
          FutureOr<asy::Future<core::int*>*>* :return_value;
          (dynamic) →* dynamic :async_op_then;
          (core::Object*, core::StackTrace*) →* dynamic :async_op_error;
          core::int* :await_jump_var = 0;
          dynamic :await_ctx_var;
          function :async_op([dynamic :result, dynamic :exception, dynamic :stack_trace]) → dynamic yielding 
            try {
              #L8:
              {
                :return_value = x6;
                break #L8;
              }
              asy::_completeOnAsyncReturn(:async_future, :return_value, :is_sync);
              return;
            }
            on dynamic catch(dynamic exception, core::StackTrace* stack_trace) {
              asy::_completeOnAsyncError(:async_future, exception, stack_trace, :is_sync);
            }
          :async_op_then = asy::_asyncThenWrapperHelper(:async_op);
          :async_op_error = asy::_asyncErrorWrapperHelper(:async_op);
          :async_op.call();
          :is_sync = true;
          return :async_future;
        }
        function test7() → asy::Future<FutureOr<core::int*>*>* /* originally async */ {
          final asy::_Future<FutureOr<core::int*>*>* :async_future = new asy::_Future::•<FutureOr<core::int*>*>();
          core::bool* :is_sync = false;
          FutureOr<FutureOr<core::int*>*>* :return_value;
          (dynamic) →* dynamic :async_op_then;
          (core::Object*, core::StackTrace*) →* dynamic :async_op_error;
          core::int* :await_jump_var = 0;
          dynamic :await_ctx_var;
          function :async_op([dynamic :result, dynamic :exception, dynamic :stack_trace]) → dynamic yielding 
            try {
              #L9:
              {
                :return_value = x7;
                break #L9;
              }
              asy::_completeOnAsyncReturn(:async_future, :return_value, :is_sync);
              return;
            }
            on dynamic catch(dynamic exception, core::StackTrace* stack_trace) {
              asy::_completeOnAsyncError(:async_future, exception, stack_trace, :is_sync);
            }
          :async_op_then = asy::_asyncThenWrapperHelper(:async_op);
          :async_op_error = asy::_asyncErrorWrapperHelper(:async_op);
          :async_op.call();
          :is_sync = true;
          return :async_future;
        }
        function test8() → asy::Future<self::MyFuture*>* /* originally async */ {
          final asy::_Future<self::MyFuture*>* :async_future = new asy::_Future::•<self::MyFuture*>();
          core::bool* :is_sync = false;
          FutureOr<self::MyFuture*>* :return_value;
          (dynamic) →* dynamic :async_op_then;
          (core::Object*, core::StackTrace*) →* dynamic :async_op_error;
          core::int* :await_jump_var = 0;
          dynamic :await_ctx_var;
          function :async_op([dynamic :result, dynamic :exception, dynamic :stack_trace]) → dynamic yielding 
            try {
              #L10:
              {
                :return_value = x8;
                break #L10;
              }
              asy::_completeOnAsyncReturn(:async_future, :return_value, :is_sync);
              return;
            }
            on dynamic catch(dynamic exception, core::StackTrace* stack_trace) {
              asy::_completeOnAsyncError(:async_future, exception, stack_trace, :is_sync);
            }
          :async_op_then = asy::_asyncThenWrapperHelper(:async_op);
          :async_op_error = asy::_asyncErrorWrapperHelper(:async_op);
          :async_op.call();
          :is_sync = true;
          return :async_future;
        }
        function test9() → asy::Future<core::int*>* /* originally async */ {
          final asy::_Future<core::int*>* :async_future = new asy::_Future::•<core::int*>();
          core::bool* :is_sync = false;
          FutureOr<core::int*>* :return_value;
          (dynamic) →* dynamic :async_op_then;
          (core::Object*, core::StackTrace*) →* dynamic :async_op_error;
          core::int* :await_jump_var = 0;
          dynamic :await_ctx_var;
          function :async_op([dynamic :result, dynamic :exception, dynamic :stack_trace]) → dynamic yielding 
            try {
              #L11:
              {
                :return_value = x9;
                break #L11;
              }
              asy::_completeOnAsyncReturn(:async_future, :return_value, :is_sync);
              return;
            }
            on dynamic catch(dynamic exception, core::StackTrace* stack_trace) {
              asy::_completeOnAsyncError(:async_future, exception, stack_trace, :is_sync);
            }
          :async_op_then = asy::_asyncThenWrapperHelper(:async_op);
          :async_op_error = asy::_asyncErrorWrapperHelper(:async_op);
          :async_op.call();
          :is_sync = true;
          return :async_future;
        }
        [yield] let dynamic #t1 = asy::_awaitHelper(x0, :async_op_then, :async_op_error, :async_op) in null;
        core::int* y0 = _in::unsafeCast<core::int*>(:result);
        [yield] let dynamic #t2 = asy::_awaitHelper(x1, :async_op_then, :async_op_error, :async_op) in null;
        core::int* y1 = _in::unsafeCast<core::int*>(:result);
        [yield] let dynamic #t3 = asy::_awaitHelper(x2, :async_op_then, :async_op_error, :async_op) in null;
        asy::Future<core::int*>* y2 = _in::unsafeCast<asy::Future<core::int*>*>(:result);
        [yield] let dynamic #t4 = asy::_awaitHelper(x3, :async_op_then, :async_op_error, :async_op) in null;
        FutureOr<core::int*>* y3 = _in::unsafeCast<FutureOr<core::int*>*>(:result);
        [yield] let dynamic #t5 = asy::_awaitHelper(x4, :async_op_then, :async_op_error, :async_op) in null;
        self::MyFuture* y4 = _in::unsafeCast<self::MyFuture*>(:result);
        [yield] let dynamic #t6 = asy::_awaitHelper(x5, :async_op_then, :async_op_error, :async_op) in null;
        core::int* y5 = _in::unsafeCast<core::int*>(:result);
        [yield] let dynamic #t7 = asy::_awaitHelper(x6, :async_op_then, :async_op_error, :async_op) in null;
        asy::Future<core::int*>* y6 = _in::unsafeCast<asy::Future<core::int*>*>(:result);
        [yield] let dynamic #t8 = asy::_awaitHelper(x7, :async_op_then, :async_op_error, :async_op) in null;
        FutureOr<core::int*>* y7 = _in::unsafeCast<FutureOr<core::int*>*>(:result);
        [yield] let dynamic #t9 = asy::_awaitHelper(x8, :async_op_then, :async_op_error, :async_op) in null;
        self::MyFuture* y8 = _in::unsafeCast<self::MyFuture*>(:result);
        [yield] let dynamic #t10 = asy::_awaitHelper(x9, :async_op_then, :async_op_error, :async_op) in null;
        core::int* y9 = _in::unsafeCast<core::int*>(:result);
      }
      asy::_completeOnAsyncReturn(:async_future, :return_value, :is_sync);
      return;
    }
    on dynamic catch(dynamic exception, core::StackTrace* stack_trace) {
      asy::_completeOnAsyncError(:async_future, exception, stack_trace, :is_sync);
    }
  :async_op_then = asy::_asyncThenWrapperHelper(:async_op);
  :async_op_error = asy::_asyncErrorWrapperHelper(:async_op);
  :async_op.call();
  :is_sync = true;
  return :async_future;
}
static method main() → dynamic {}

constants  {
  #C1 = null
}
