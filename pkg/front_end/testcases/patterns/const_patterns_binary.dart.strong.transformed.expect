library;
//
// Problems in library:
//
// pkg/front_end/testcases/patterns/const_patterns_binary.dart:19:12: Error: The binary operator + is not supported as a constant pattern.
// Try wrapping the expression in 'const ( ... )'.
//     case 1 + 2: // Error
//            ^
//
// pkg/front_end/testcases/patterns/const_patterns_binary.dart:20:12: Error: The binary operator - is not supported as a constant pattern.
// Try wrapping the expression in 'const ( ... )'.
//     case 1 - 2: // Error
//            ^
//
// pkg/front_end/testcases/patterns/const_patterns_binary.dart:21:12: Error: The binary operator * is not supported as a constant pattern.
// Try wrapping the expression in 'const ( ... )'.
//     case 1 * 2: // Error
//            ^
//
// pkg/front_end/testcases/patterns/const_patterns_binary.dart:22:12: Error: The binary operator / is not supported as a constant pattern.
// Try wrapping the expression in 'const ( ... )'.
//     case 1 / 2: // Error
//            ^
//
// pkg/front_end/testcases/patterns/const_patterns_binary.dart:23:12: Error: The binary operator ~/ is not supported as a constant pattern.
// Try wrapping the expression in 'const ( ... )'.
//     case 1 ~/ 2: // Error
//            ^^
//
// pkg/front_end/testcases/patterns/const_patterns_binary.dart:24:12: Error: The binary operator % is not supported as a constant pattern.
// Try wrapping the expression in 'const ( ... )'.
//     case 1 % 2: // Error
//            ^
//
// pkg/front_end/testcases/patterns/const_patterns_binary.dart:25:12: Error: The binary operator == is not supported as a constant pattern.
// Try wrapping the expression in 'const ( ... )'.
//     case 1 == 2: // Error
//            ^^
//
// pkg/front_end/testcases/patterns/const_patterns_binary.dart:26:12: Error: The binary operator != is not supported as a constant pattern.
// Try wrapping the expression in 'const ( ... )'.
//     case 1 != 2: // Error
//            ^^
//
// pkg/front_end/testcases/patterns/const_patterns_binary.dart:27:12: Error: The binary operator ^ is not supported as a constant pattern.
// Try wrapping the expression in 'const ( ... )'.
//     case 1 ^ 2: // Error
//            ^
//
// pkg/front_end/testcases/patterns/const_patterns_binary.dart:28:12: Error: The binary operator & is not supported as a constant pattern.
// Try wrapping the expression in 'const ( ... )'.
//     case 1 & 2: // Error
//            ^
//
// pkg/front_end/testcases/patterns/const_patterns_binary.dart:29:12: Error: The binary operator | is not supported as a constant pattern.
// Try wrapping the expression in 'const ( ... )'.
//     case 1 | 2: // Error
//            ^
//
// pkg/front_end/testcases/patterns/const_patterns_binary.dart:30:12: Error: The binary operator < is not supported as a constant pattern.
// Try wrapping the expression in 'const ( ... )'.
//     case 1 < 2: // Error
//            ^
//
// pkg/front_end/testcases/patterns/const_patterns_binary.dart:31:12: Error: The binary operator <= is not supported as a constant pattern.
// Try wrapping the expression in 'const ( ... )'.
//     case 1 <= 2: // Error
//            ^^
//
// pkg/front_end/testcases/patterns/const_patterns_binary.dart:32:12: Error: The binary operator > is not supported as a constant pattern.
// Try wrapping the expression in 'const ( ... )'.
//     case 1 > 2: // Error
//            ^
//
// pkg/front_end/testcases/patterns/const_patterns_binary.dart:33:12: Error: The binary operator >= is not supported as a constant pattern.
// Try wrapping the expression in 'const ( ... )'.
//     case 1 >= 2: // Error
//            ^^
//
// pkg/front_end/testcases/patterns/const_patterns_binary.dart:34:12: Error: The binary operator << is not supported as a constant pattern.
// Try wrapping the expression in 'const ( ... )'.
//     case 1 << 2: // Error
//            ^^
//
// pkg/front_end/testcases/patterns/const_patterns_binary.dart:35:12: Error: The binary operator >> is not supported as a constant pattern.
// Try wrapping the expression in 'const ( ... )'.
//     case 1 >> 2: // Error
//            ^^
//
// pkg/front_end/testcases/patterns/const_patterns_binary.dart:36:12: Error: The binary operator >>> is not supported as a constant pattern.
// Try wrapping the expression in 'const ( ... )'.
//     case 1 >>> 2: // Error
//            ^^^
//
// pkg/front_end/testcases/patterns/const_patterns_binary.dart:37:12: Error: The binary operator + is not supported as a constant pattern.
// Try wrapping the expression in 'const ( ... )'.
//     case 1 + 2 + 3: // Error
//            ^
//
// pkg/front_end/testcases/patterns/const_patterns_binary.dart:40:16: Error: The expression can't be prefixed by 'const' to form a constant pattern.
// Try wrapping the expression in 'const ( ... )' instead.
//     case const 1 as int: // Error
//                ^
//
// pkg/front_end/testcases/patterns/const_patterns_binary.dart:41:16: Error: The expression can't be prefixed by 'const' to form a constant pattern.
// Try wrapping the expression in 'const ( ... )' instead.
//     case const 1 + 2: // Error
//                ^
//
// pkg/front_end/testcases/patterns/const_patterns_binary.dart:42:16: Error: The expression can't be prefixed by 'const' to form a constant pattern.
// Try wrapping the expression in 'const ( ... )' instead.
//     case const 1 - 2: // Error
//                ^
//
// pkg/front_end/testcases/patterns/const_patterns_binary.dart:43:16: Error: The expression can't be prefixed by 'const' to form a constant pattern.
// Try wrapping the expression in 'const ( ... )' instead.
//     case const 1 * 2: // Error
//                ^
//
// pkg/front_end/testcases/patterns/const_patterns_binary.dart:44:16: Error: The expression can't be prefixed by 'const' to form a constant pattern.
// Try wrapping the expression in 'const ( ... )' instead.
//     case const 1 / 2: // Error
//                ^
//
// pkg/front_end/testcases/patterns/const_patterns_binary.dart:45:16: Error: The expression can't be prefixed by 'const' to form a constant pattern.
// Try wrapping the expression in 'const ( ... )' instead.
//     case const 1 ~/ 2: // Error
//                ^
//
// pkg/front_end/testcases/patterns/const_patterns_binary.dart:46:16: Error: The expression can't be prefixed by 'const' to form a constant pattern.
// Try wrapping the expression in 'const ( ... )' instead.
//     case const 1 % 2: // Error
//                ^
//
// pkg/front_end/testcases/patterns/const_patterns_binary.dart:47:16: Error: The expression can't be prefixed by 'const' to form a constant pattern.
// Try wrapping the expression in 'const ( ... )' instead.
//     case const 1 == 2: // Error
//                ^
//
// pkg/front_end/testcases/patterns/const_patterns_binary.dart:48:16: Error: The expression can't be prefixed by 'const' to form a constant pattern.
// Try wrapping the expression in 'const ( ... )' instead.
//     case const 1 != 2: // Error
//                ^
//
// pkg/front_end/testcases/patterns/const_patterns_binary.dart:49:16: Error: The expression can't be prefixed by 'const' to form a constant pattern.
// Try wrapping the expression in 'const ( ... )' instead.
//     case const 1 ^ 2: // Error
//                ^
//
// pkg/front_end/testcases/patterns/const_patterns_binary.dart:50:16: Error: The expression can't be prefixed by 'const' to form a constant pattern.
// Try wrapping the expression in 'const ( ... )' instead.
//     case const 1 & 2: // Error
//                ^
//
// pkg/front_end/testcases/patterns/const_patterns_binary.dart:51:16: Error: The expression can't be prefixed by 'const' to form a constant pattern.
// Try wrapping the expression in 'const ( ... )' instead.
//     case const 1 | 2: // Error
//                ^
//
// pkg/front_end/testcases/patterns/const_patterns_binary.dart:52:16: Error: The expression can't be prefixed by 'const' to form a constant pattern.
// Try wrapping the expression in 'const ( ... )' instead.
//     case const 1 < 2: // Error
//                ^
//
// pkg/front_end/testcases/patterns/const_patterns_binary.dart:53:16: Error: The expression can't be prefixed by 'const' to form a constant pattern.
// Try wrapping the expression in 'const ( ... )' instead.
//     case const 1 <= 2: // Error
//                ^
//
// pkg/front_end/testcases/patterns/const_patterns_binary.dart:54:16: Error: The expression can't be prefixed by 'const' to form a constant pattern.
// Try wrapping the expression in 'const ( ... )' instead.
//     case const 1 > 2: // Error
//                ^
//
// pkg/front_end/testcases/patterns/const_patterns_binary.dart:55:16: Error: The expression can't be prefixed by 'const' to form a constant pattern.
// Try wrapping the expression in 'const ( ... )' instead.
//     case const 1 >= 2: // Error
//                ^
//
// pkg/front_end/testcases/patterns/const_patterns_binary.dart:56:16: Error: The expression can't be prefixed by 'const' to form a constant pattern.
// Try wrapping the expression in 'const ( ... )' instead.
//     case const 1 << 2: // Error
//                ^
//
// pkg/front_end/testcases/patterns/const_patterns_binary.dart:57:16: Error: The expression can't be prefixed by 'const' to form a constant pattern.
// Try wrapping the expression in 'const ( ... )' instead.
//     case const 1 >> 2: // Error
//                ^
//
// pkg/front_end/testcases/patterns/const_patterns_binary.dart:58:16: Error: The expression can't be prefixed by 'const' to form a constant pattern.
// Try wrapping the expression in 'const ( ... )' instead.
//     case const 1 >>> 2: // Error
//                ^
//
// pkg/front_end/testcases/patterns/const_patterns_binary.dart:59:16: Error: The expression can't be prefixed by 'const' to form a constant pattern.
// Try wrapping the expression in 'const ( ... )' instead.
//     case const 1 + 2 + 3: // Error
//                ^
//
// pkg/front_end/testcases/patterns/const_patterns_binary.dart:60:23: Error: The expression can't be prefixed by 'const' to form a constant pattern.
// Try wrapping the expression in 'const ( ... )' instead.
//     case const Object() == 2: // Error
//                       ^
//
// pkg/front_end/testcases/patterns/const_patterns_binary.dart:81:12: Error: Expected ':' before this.
//     case 1 ?? 2: // Error
//            ^^
//
// pkg/front_end/testcases/patterns/const_patterns_binary.dart:81:12: Error: Expected an identifier, but got '??'.
// Try inserting an identifier before '??'.
//     case 1 ?? 2: // Error
//            ^^
//
// pkg/front_end/testcases/patterns/const_patterns_binary.dart:81:15: Error: Expected ';' after this.
//     case 1 ?? 2: // Error
//               ^
//
// pkg/front_end/testcases/patterns/const_patterns_binary.dart:81:16: Error: Expected an identifier, but got ':'.
// Try inserting an identifier before ':'.
//     case 1 ?? 2: // Error
//                ^
//
// pkg/front_end/testcases/patterns/const_patterns_binary.dart:81:16: Error: Unexpected token ':'.
//     case 1 ?? 2: // Error
//                ^
//
// pkg/front_end/testcases/patterns/const_patterns_binary.dart:82:10: Error: Not a constant expression.
//     case o++: // Error
//          ^
//
// pkg/front_end/testcases/patterns/const_patterns_binary.dart:83:10: Error: Not a constant expression.
//     case o--: // Error
//          ^
//
// pkg/front_end/testcases/patterns/const_patterns_binary.dart:84:12: Error: Not a constant expression.
//     case ++o: // Error
//            ^
//
// pkg/front_end/testcases/patterns/const_patterns_binary.dart:85:12: Error: Not a constant expression.
//     case --o: // Error
//            ^
//
import self as self;
import "dart:core" as core;

import "org-dartlang-testcase:///const_patterns_binary.dart" as prefix;

class Class extends core::Object {
  static const field core::int value = #C1;
  synthetic constructor •() → self::Class
    : super core::Object::•()
    ;
}
static const field core::int value = #C2;
static method method<T extends core::Object? = dynamic>(dynamic o) → dynamic {
  #L1:
  {
    final synthesized dynamic #0#0 = o;
    synthesized core::bool #0#2;
    synthesized core::bool #0#2#isSet = false;
    synthesized core::bool #0#4;
    synthesized core::bool #0#4#isSet = false;
    synthesized core::bool #0#6;
    synthesized core::bool #0#6#isSet = false;
    synthesized core::bool #0#10;
    synthesized core::bool #0#10#isSet = false;
    synthesized core::bool #0#12;
    synthesized core::bool #0#12#isSet = false;
    synthesized core::bool #0#14;
    synthesized core::bool #0#14#isSet = false;
    synthesized core::bool #0#16;
    synthesized core::bool #0#16#isSet = false;
    synthesized core::bool #0#18;
    synthesized core::bool #0#18#isSet = false;
    synthesized core::bool #0#20;
    synthesized core::bool #0#20#isSet = false;
    synthesized core::bool #0#22;
    synthesized core::bool #0#22#isSet = false;
    synthesized core::bool #0#24;
    synthesized core::bool #0#24#isSet = false;
    final const synthesized invalid-type #0#31 = invalid-expression "pkg/front_end/testcases/patterns/const_patterns_binary.dart:82:10: Error: Not a constant expression.
    case o++: // Error
         ^";
    final const synthesized invalid-type #0#33 = invalid-expression "pkg/front_end/testcases/patterns/const_patterns_binary.dart:83:10: Error: Not a constant expression.
    case o--: // Error
         ^";
    final const synthesized invalid-type #0#35 = invalid-expression "pkg/front_end/testcases/patterns/const_patterns_binary.dart:84:12: Error: Not a constant expression.
    case ++o: // Error
           ^";
    final const synthesized invalid-type #0#37 = invalid-expression "pkg/front_end/testcases/patterns/const_patterns_binary.dart:85:12: Error: Not a constant expression.
    case --o: // Error
           ^";
    {
      if((#0#2#isSet ?{core::bool} #0#2{core::bool} : let final core::bool* #t1 = #0#2#isSet = true in #0#2 = #C2 =={core::num::==}{(core::Object) → core::bool} #0#0) || (#0#4#isSet ?{core::bool} #0#4{core::bool} : let final core::bool* #t2 = #0#4#isSet = true in #0#4 = #C1 =={core::num::==}{(core::Object) → core::bool} #0#0) || (#0#2#isSet ?{core::bool} #0#2{core::bool} : let final core::bool* #t3 = #0#2#isSet = true in #0#2 = #C2 =={core::num::==}{(core::Object) → core::bool} #0#0) && (#0#4#isSet ?{core::bool} #0#4{core::bool} : let final core::bool* #t4 = #0#4#isSet = true in #0#4 = #C1 =={core::num::==}{(core::Object) → core::bool} #0#0) || (let final self::method::T% #t5 = #0#0 as self::method::T% in #0#6#isSet ?{core::bool} #0#6{core::bool} : let final core::bool* #t6 = #0#6#isSet = true in #0#6 = #C2 =={core::num::==}{(core::Object) → core::bool} #0#0 as self::method::T%) || #C3 =={core::Object::==}{(core::Object) → core::bool} #0#0 || (#0#10#isSet ?{core::bool} #0#10{core::bool} : let final core::bool* #t7 = #0#10#isSet = true in #0#10 = #C4 =={core::num::==}{(core::Object) → core::bool} #0#0) || (#0#12#isSet ?{core::bool} #0#12{core::bool} : let final core::bool* #t8 = #0#12#isSet = true in #0#12 = #C5 =={core::num::==}{(core::Object) → core::bool} #0#0) || (#0#4#isSet ?{core::bool} #0#4{core::bool} : let final core::bool* #t9 = #0#4#isSet = true in #0#4 = #C1 =={core::num::==}{(core::Object) → core::bool} #0#0) || (#0#14#isSet ?{core::bool} #0#14{core::bool} : let final core::bool* #t10 = #0#14#isSet = true in #0#14 = #C6 =={core::num::==}{(core::Object) → core::bool} #0#0) || (#0#16#isSet ?{core::bool} #0#16{core::bool} : let final core::bool* #t11 = #0#16#isSet = true in #0#16 = #C7 =={core::num::==}{(core::Object) → core::bool} #0#0) || (#0#2#isSet ?{core::bool} #0#2{core::bool} : let final core::bool* #t12 = #0#2#isSet = true in #0#2 = #C2 =={core::num::==}{(core::Object) → core::bool} #0#0) || (#0#18#isSet ?{core::bool} #0#18{core::bool} : let final core::bool* #t13 = #0#18#isSet = true in #0#18 = #C8 =={core::Object::==}{(core::Object) → core::bool} #0#0) || (#0#20#isSet ?{core::bool} #0#20{core::bool} : let final core::bool* #t14 = #0#20#isSet = true in #0#20 = #C9 =={core::Object::==}{(core::Object) → core::bool} #0#0) || (#0#10#isSet ?{core::bool} #0#10{core::bool} : let final core::bool* #t15 = #0#10#isSet = true in #0#10 = #C4 =={core::num::==}{(core::Object) → core::bool} #0#0) || (#0#16#isSet ?{core::bool} #0#16{core::bool} : let final core::bool* #t16 = #0#16#isSet = true in #0#16 = #C7 =={core::num::==}{(core::Object) → core::bool} #0#0) || (#0#10#isSet ?{core::bool} #0#10{core::bool} : let final core::bool* #t17 = #0#10#isSet = true in #0#10 = #C4 =={core::num::==}{(core::Object) → core::bool} #0#0) || (#0#20#isSet ?{core::bool} #0#20{core::bool} : let final core::bool* #t18 = #0#20#isSet = true in #0#20 = #C9 =={core::Object::==}{(core::Object) → core::bool} #0#0) || (#0#20#isSet ?{core::bool} #0#20{core::bool} : let final core::bool* #t19 = #0#20#isSet = true in #0#20 = #C9 =={core::Object::==}{(core::Object) → core::bool} #0#0) || (#0#18#isSet ?{core::bool} #0#18{core::bool} : let final core::bool* #t20 = #0#18#isSet = true in #0#18 = #C8 =={core::Object::==}{(core::Object) → core::bool} #0#0) || (#0#18#isSet ?{core::bool} #0#18{core::bool} : let final core::bool* #t21 = #0#18#isSet = true in #0#18 = #C8 =={core::Object::==}{(core::Object) → core::bool} #0#0) || (#0#22#isSet ?{core::bool} #0#22{core::bool} : let final core::bool* #t22 = #0#22#isSet = true in #0#22 = #C10 =={core::num::==}{(core::Object) → core::bool} #0#0) || (#0#16#isSet ?{core::bool} #0#16{core::bool} : let final core::bool* #t23 = #0#16#isSet = true in #0#16 = #C7 =={core::num::==}{(core::Object) → core::bool} #0#0) || (#0#16#isSet ?{core::bool} #0#16{core::bool} : let final core::bool* #t24 = #0#16#isSet = true in #0#16 = #C7 =={core::num::==}{(core::Object) → core::bool} #0#0) || (#0#24#isSet ?{core::bool} #0#24{core::bool} : let final core::bool* #t25 = #0#24#isSet = true in #0#24 = #C11 =={core::num::==}{(core::Object) → core::bool} #0#0) || (let final self::method::T% #t26 = #0#0 as self::method::T% in #0#6#isSet ?{core::bool} #0#6{core::bool} : let final core::bool* #t27 = #0#6#isSet = true in #0#6 = #C2 =={core::num::==}{(core::Object) → core::bool} #0#0 as self::method::T%) || (let final self::method::T% #t28 = #0#0 as self::method::T% in #C1 =={core::num::==}{(core::Object) → core::bool} #0#0 as self::method::T%) || (let final core::int #t29 = #0#0 as core::int in #C2 =={core::num::==}{(core::Object) → core::bool} #0#0 as core::int) || (#0#10#isSet ?{core::bool} #0#10{core::bool} : let final core::bool* #t30 = #0#10#isSet = true in #0#10 = #C4 =={core::num::==}{(core::Object) → core::bool} #0#0) || (#0#12#isSet ?{core::bool} #0#12{core::bool} : let final core::bool* #t31 = #0#12#isSet = true in #0#12 = #C5 =={core::num::==}{(core::Object) → core::bool} #0#0) || (#0#4#isSet ?{core::bool} #0#4{core::bool} : let final core::bool* #t32 = #0#4#isSet = true in #0#4 = #C1 =={core::num::==}{(core::Object) → core::bool} #0#0) || (#0#14#isSet ?{core::bool} #0#14{core::bool} : let final core::bool* #t33 = #0#14#isSet = true in #0#14 = #C6 =={core::num::==}{(core::Object) → core::bool} #0#0) || (#0#16#isSet ?{core::bool} #0#16{core::bool} : let final core::bool* #t34 = #0#16#isSet = true in #0#16 = #C7 =={core::num::==}{(core::Object) → core::bool} #0#0) || (#0#2#isSet ?{core::bool} #0#2{core::bool} : let final core::bool* #t35 = #0#2#isSet = true in #0#2 = #C2 =={core::num::==}{(core::Object) → core::bool} #0#0) || (#0#18#isSet ?{core::bool} #0#18{core::bool} : let final core::bool* #t36 = #0#18#isSet = true in #0#18 = #C8 =={core::Object::==}{(core::Object) → core::bool} #0#0) || (#0#20#isSet ?{core::bool} #0#20{core::bool} : let final core::bool* #t37 = #0#20#isSet = true in #0#20 = #C9 =={core::Object::==}{(core::Object) → core::bool} #0#0) || (#0#10#isSet ?{core::bool} #0#10{core::bool} : let final core::bool* #t38 = #0#10#isSet = true in #0#10 = #C4 =={core::num::==}{(core::Object) → core::bool} #0#0) || (#0#16#isSet ?{core::bool} #0#16{core::bool} : let final core::bool* #t39 = #0#16#isSet = true in #0#16 = #C7 =={core::num::==}{(core::Object) → core::bool} #0#0) || (#0#10#isSet ?{core::bool} #0#10{core::bool} : let final core::bool* #t40 = #0#10#isSet = true in #0#10 = #C4 =={core::num::==}{(core::Object) → core::bool} #0#0) || (#0#20#isSet ?{core::bool} #0#20{core::bool} : let final core::bool* #t41 = #0#20#isSet = true in #0#20 = #C9 =={core::Object::==}{(core::Object) → core::bool} #0#0) || (#0#20#isSet ?{core::bool} #0#20{core::bool} : let final core::bool* #t42 = #0#20#isSet = true in #0#20 = #C9 =={core::Object::==}{(core::Object) → core::bool} #0#0) || (#0#18#isSet ?{core::bool} #0#18{core::bool} : let final core::bool* #t43 = #0#18#isSet = true in #0#18 = #C8 =={core::Object::==}{(core::Object) → core::bool} #0#0) || (#0#18#isSet ?{core::bool} #0#18{core::bool} : let final core::bool* #t44 = #0#18#isSet = true in #0#18 = #C8 =={core::Object::==}{(core::Object) → core::bool} #0#0) || (#0#22#isSet ?{core::bool} #0#22{core::bool} : let final core::bool* #t45 = #0#22#isSet = true in #0#22 = #C10 =={core::num::==}{(core::Object) → core::bool} #0#0) || (#0#16#isSet ?{core::bool} #0#16{core::bool} : let final core::bool* #t46 = #0#16#isSet = true in #0#16 = #C7 =={core::num::==}{(core::Object) → core::bool} #0#0) || (#0#16#isSet ?{core::bool} #0#16{core::bool} : let final core::bool* #t47 = #0#16#isSet = true in #0#16 = #C7 =={core::num::==}{(core::Object) → core::bool} #0#0) || (#0#24#isSet ?{core::bool} #0#24{core::bool} : let final core::bool* #t48 = #0#24#isSet = true in #0#24 = #C11 =={core::num::==}{(core::Object) → core::bool} #0#0) || (#0#18#isSet ?{core::bool} #0#18{core::bool} : let final core::bool* #t49 = #0#18#isSet = true in #0#18 = #C8 =={core::Object::==}{(core::Object) → core::bool} #0#0) || (let final core::List<self::method::T%> #t50 = #0#0 as core::List<self::method::T%> in #C12 =={core::List::==}{(core::Object) → core::bool} #0#0 as core::List<self::method::T%>) || (#0#10#isSet ?{core::bool} #0#10{core::bool} : let final core::bool* #t51 = #0#10#isSet = true in #0#10 = #C4 =={core::num::==}{(core::Object) → core::bool} #0#0) || (#0#12#isSet ?{core::bool} #0#12{core::bool} : let final core::bool* #t52 = #0#12#isSet = true in #0#12 = #C5 =={core::num::==}{(core::Object) → core::bool} #0#0) || (#0#4#isSet ?{core::bool} #0#4{core::bool} : let final core::bool* #t53 = #0#4#isSet = true in #0#4 = #C1 =={core::num::==}{(core::Object) → core::bool} #0#0) || (#0#14#isSet ?{core::bool} #0#14{core::bool} : let final core::bool* #t54 = #0#14#isSet = true in #0#14 = #C6 =={core::num::==}{(core::Object) → core::bool} #0#0) || (#0#16#isSet ?{core::bool} #0#16{core::bool} : let final core::bool* #t55 = #0#16#isSet = true in #0#16 = #C7 =={core::num::==}{(core::Object) → core::bool} #0#0) || (#0#2#isSet ?{core::bool} #0#2{core::bool} : let final core::bool* #t56 = #0#2#isSet = true in #0#2 = #C2 =={core::num::==}{(core::Object) → core::bool} #0#0) || (#0#18#isSet ?{core::bool} #0#18{core::bool} : let final core::bool* #t57 = #0#18#isSet = true in #0#18 = #C8 =={core::Object::==}{(core::Object) → core::bool} #0#0) || (#0#20#isSet ?{core::bool} #0#20{core::bool} : let final core::bool* #t58 = #0#20#isSet = true in #0#20 = #C9 =={core::Object::==}{(core::Object) → core::bool} #0#0) || (#0#10#isSet ?{core::bool} #0#10{core::bool} : let final core::bool* #t59 = #0#10#isSet = true in #0#10 = #C4 =={core::num::==}{(core::Object) → core::bool} #0#0) || (#0#16#isSet ?{core::bool} #0#16{core::bool} : let final core::bool* #t60 = #0#16#isSet = true in #0#16 = #C7 =={core::num::==}{(core::Object) → core::bool} #0#0) || (#0#10#isSet ?{core::bool} #0#10{core::bool} : let final core::bool* #t61 = #0#10#isSet = true in #0#10 = #C4 =={core::num::==}{(core::Object) → core::bool} #0#0) || (#0#20#isSet ?{core::bool} #0#20{core::bool} : let final core::bool* #t62 = #0#20#isSet = true in #0#20 = #C9 =={core::Object::==}{(core::Object) → core::bool} #0#0) || (#0#20#isSet ?{core::bool} #0#20{core::bool} : let final core::bool* #t63 = #0#20#isSet = true in #0#20 = #C9 =={core::Object::==}{(core::Object) → core::bool} #0#0) || (#0#18#isSet ?{core::bool} #0#18{core::bool} : let final core::bool* #t64 = #0#18#isSet = true in #0#18 = #C8 =={core::Object::==}{(core::Object) → core::bool} #0#0) || (#0#18#isSet ?{core::bool} #0#18{core::bool} : let final core::bool* #t65 = #0#18#isSet = true in #0#18 = #C8 =={core::Object::==}{(core::Object) → core::bool} #0#0) || (#0#22#isSet ?{core::bool} #0#22{core::bool} : let final core::bool* #t66 = #0#22#isSet = true in #0#22 = #C10 =={core::num::==}{(core::Object) → core::bool} #0#0) || (#0#16#isSet ?{core::bool} #0#16{core::bool} : let final core::bool* #t67 = #0#16#isSet = true in #0#16 = #C7 =={core::num::==}{(core::Object) → core::bool} #0#0) || (#0#16#isSet ?{core::bool} #0#16{core::bool} : let final core::bool* #t68 = #0#16#isSet = true in #0#16 = #C7 =={core::num::==}{(core::Object) → core::bool} #0#0) || (#0#24#isSet ?{core::bool} #0#24{core::bool} : let final core::bool* #t69 = #0#24#isSet = true in #0#24 = #C11 =={core::num::==}{(core::Object) → core::bool} #0#0) || (#0#2#isSet ?{core::bool} #0#2{core::bool} : let final core::bool* #t70 = #0#2#isSet = true in #0#2 = #C2 =={core::num::==}{(core::Object) → core::bool} #0#0)) {
        {
          let final invalid-type #t71 = invalid-expression "pkg/front_end/testcases/patterns/const_patterns_binary.dart:81:12: Error: This couldn't be parsed.
    case 1 ?? 2: // Error
           ^" in #t71 == null ?{invalid-type} 2 : #t71;
          invalid-expression "pkg/front_end/testcases/patterns/const_patterns_binary.dart:81:16: Error: This couldn't be parsed.
    case 1 ?? 2: // Error
               ^";
          break #L1;
        }
      }
    }
    {
      if(invalid-expression "pkg/front_end/testcases/patterns/const_patterns_binary.dart:82:10: Error: Not a constant expression.
    case o++: // Error
         ^" =={core::Object::==}{(core::Object) → core::bool} #0#0 || invalid-expression "pkg/front_end/testcases/patterns/const_patterns_binary.dart:83:10: Error: Not a constant expression.
    case o--: // Error
         ^" =={core::Object::==}{(core::Object) → core::bool} #0#0 || invalid-expression "pkg/front_end/testcases/patterns/const_patterns_binary.dart:84:12: Error: Not a constant expression.
    case ++o: // Error
           ^" =={core::Object::==}{(core::Object) → core::bool} #0#0 || invalid-expression "pkg/front_end/testcases/patterns/const_patterns_binary.dart:85:12: Error: Not a constant expression.
    case --o: // Error
           ^" =={core::Object::==}{(core::Object) → core::bool} #0#0) {
      }
    }
  }
}

constants  {
  #C1 = 2
  #C2 = 1
  #C3 = core::Object {}
  #C4 = 3
  #C5 = -1
  #C6 = 0.5
  #C7 = 0
  #C8 = false
  #C9 = true
  #C10 = 4
  #C11 = 6
  #C12 = <core::int>[]
}


Constructor coverage from constants:
org-dartlang-testcase:///const_patterns_binary.dart:
- Object. (from org-dartlang-sdk:///sdk/lib/core/object.dart)
