library;
import self as self;
import "dart:core" as core;
import "dart:collection" as col;

static method test1() → dynamic {
  for (final core::List<core::int> #t1 in <core::List<core::int>>[<core::int>[3, 4, 5, 6]]) {
    hoisted core::int a2;
    hoisted core::int b2;
    hoisted core::List<core::int> c2;
    {
      final synthesized core::List<core::int> #0#0 = #t1;
      synthesized core::int #0#4;
      synthesized core::bool #0#4#isSet = false;
      synthesized core::List<core::int> #0#6;
      synthesized core::bool #0#6#isSet = false;
      if(!(#0#0.{core::List::length}{core::int}.{core::num::>=}(#C1){(core::num) → core::bool} && ((#0#4#isSet ?{core::int} #0#4{core::int} : let final dynamic #t2 = #0#4#isSet = true in #0#4 = #0#0.{core::List::[]}(0){(core::int) → core::int}) is core::int && (let final dynamic #t3 = a2 = #0#4#isSet ?{core::int} #0#4{core::int} : let final dynamic #t4 = #0#4#isSet = true in #0#4 = #0#0.{core::List::[]}(0){(core::int) → core::int} in true)) && (let final dynamic #t5 = b2 = #0#0.{core::List::[]}(1){(core::int) → core::int} in true) && ((#0#6#isSet ?{core::List<core::int>} #0#6{core::List<core::int>} : let final dynamic #t6 = #0#6#isSet = true in #0#6 = #0#0.{core::List::sublist}(2){(core::int, [core::int?]) → core::List<core::int>}) is core::List<core::int> && (let final dynamic #t7 = c2 = #0#6#isSet ?{core::List<core::int>} #0#6{core::List<core::int>} : let final dynamic #t8 = #0#6#isSet = true in #0#6 = #0#0.{core::List::sublist}(2){(core::int, [core::int?]) → core::List<core::int>} in true))))
        throw{for-error-handling} new core::StateError::•("Pattern matching error");
    }
    return c2.{core::Iterable::first}{core::int}.{core::int::isEven}{core::bool};
  }
}
static method test2() → dynamic {
  return block {
    final core::List<core::bool> #t9 = <core::bool>[];
    for (final core::List<core::int> #t10 in <core::List<core::int>>[<core::int>[3, 4, 5, 6]]) {
      hoisted core::int a2;
      hoisted core::int b2;
      hoisted core::List<core::int> c2;
      {
        final synthesized core::List<core::int> #0#0 = #t10;
        synthesized core::int #0#4;
        synthesized core::bool #0#4#isSet = false;
        synthesized core::List<core::int> #0#6;
        synthesized core::bool #0#6#isSet = false;
        if(!(#0#0.{core::List::length}{core::int}.{core::num::>=}(#C1){(core::num) → core::bool} && ((#0#4#isSet ?{core::int} #0#4{core::int} : let final dynamic #t11 = #0#4#isSet = true in #0#4 = #0#0.{core::List::[]}(0){(core::int) → core::int}) is core::int && (let final dynamic #t12 = a2 = #0#4#isSet ?{core::int} #0#4{core::int} : let final dynamic #t13 = #0#4#isSet = true in #0#4 = #0#0.{core::List::[]}(0){(core::int) → core::int} in true)) && (let final dynamic #t14 = b2 = #0#0.{core::List::[]}(1){(core::int) → core::int} in true) && ((#0#6#isSet ?{core::List<core::int>} #0#6{core::List<core::int>} : let final dynamic #t15 = #0#6#isSet = true in #0#6 = #0#0.{core::List::sublist}(2){(core::int, [core::int?]) → core::List<core::int>}) is core::List<core::int> && (let final dynamic #t16 = c2 = #0#6#isSet ?{core::List<core::int>} #0#6{core::List<core::int>} : let final dynamic #t17 = #0#6#isSet = true in #0#6 = #0#0.{core::List::sublist}(2){(core::int, [core::int?]) → core::List<core::int>} in true))))
          throw{for-error-handling} new core::StateError::•("Pattern matching error");
      }
      #t9.{core::List::add}{Invariant}(c2.{core::Iterable::first}{core::int}.{core::int::isEven}{core::bool}){(core::bool) → void};
    }
  } =>#t9;
}
static method test3() → core::Iterable<core::bool> {
  return block {
    final core::Set<core::bool> #t18 = col::LinkedHashSet::•<core::bool>();
    for (final core::List<core::int> #t19 in <core::List<core::int>>[<core::int>[3, 4, 5, 6]]) {
      hoisted core::int a2;
      hoisted core::int b2;
      hoisted core::List<core::int> c2;
      {
        final synthesized core::List<core::int> #0#0 = #t19;
        synthesized core::int #0#4;
        synthesized core::bool #0#4#isSet = false;
        synthesized core::List<core::int> #0#6;
        synthesized core::bool #0#6#isSet = false;
        if(!(#0#0.{core::List::length}{core::int}.{core::num::>=}(#C1){(core::num) → core::bool} && ((#0#4#isSet ?{core::int} #0#4{core::int} : let final dynamic #t20 = #0#4#isSet = true in #0#4 = #0#0.{core::List::[]}(0){(core::int) → core::int}) is core::int && (let final dynamic #t21 = a2 = #0#4#isSet ?{core::int} #0#4{core::int} : let final dynamic #t22 = #0#4#isSet = true in #0#4 = #0#0.{core::List::[]}(0){(core::int) → core::int} in true)) && (let final dynamic #t23 = b2 = #0#0.{core::List::[]}(1){(core::int) → core::int} in true) && ((#0#6#isSet ?{core::List<core::int>} #0#6{core::List<core::int>} : let final dynamic #t24 = #0#6#isSet = true in #0#6 = #0#0.{core::List::sublist}(2){(core::int, [core::int?]) → core::List<core::int>}) is core::List<core::int> && (let final dynamic #t25 = c2 = #0#6#isSet ?{core::List<core::int>} #0#6{core::List<core::int>} : let final dynamic #t26 = #0#6#isSet = true in #0#6 = #0#0.{core::List::sublist}(2){(core::int, [core::int?]) → core::List<core::int>} in true))))
          throw{for-error-handling} new core::StateError::•("Pattern matching error");
      }
      #t18.{core::Set::add}{Invariant}(c2.{core::Iterable::first}{core::int}.{core::int::isEven}{core::bool}){(core::bool) → core::bool};
    }
  } =>#t18;
}
static method test4() → dynamic {
  return block {
    final core::Map<core::int, core::bool> #t27 = <core::int, core::bool>{};
    for (final core::List<core::int> #t28 in <core::List<core::int>>[<core::int>[3, 4, 5, 6]]) {
      hoisted core::int a2;
      hoisted core::int b2;
      hoisted core::List<core::int> c2;
      {
        final synthesized core::List<core::int> #0#0 = #t28;
        synthesized core::int #0#4;
        synthesized core::bool #0#4#isSet = false;
        synthesized core::List<core::int> #0#6;
        synthesized core::bool #0#6#isSet = false;
        if(!(#0#0.{core::List::length}{core::int}.{core::num::>=}(#C1){(core::num) → core::bool} && ((#0#4#isSet ?{core::int} #0#4{core::int} : let final dynamic #t29 = #0#4#isSet = true in #0#4 = #0#0.{core::List::[]}(0){(core::int) → core::int}) is core::int && (let final dynamic #t30 = a2 = #0#4#isSet ?{core::int} #0#4{core::int} : let final dynamic #t31 = #0#4#isSet = true in #0#4 = #0#0.{core::List::[]}(0){(core::int) → core::int} in true)) && (let final dynamic #t32 = b2 = #0#0.{core::List::[]}(1){(core::int) → core::int} in true) && ((#0#6#isSet ?{core::List<core::int>} #0#6{core::List<core::int>} : let final dynamic #t33 = #0#6#isSet = true in #0#6 = #0#0.{core::List::sublist}(2){(core::int, [core::int?]) → core::List<core::int>}) is core::List<core::int> && (let final dynamic #t34 = c2 = #0#6#isSet ?{core::List<core::int>} #0#6{core::List<core::int>} : let final dynamic #t35 = #0#6#isSet = true in #0#6 = #0#0.{core::List::sublist}(2){(core::int, [core::int?]) → core::List<core::int>} in true))))
          throw{for-error-handling} new core::StateError::•("Pattern matching error");
      }
      #t27.{core::Map::[]=}{Invariant}(c2.{core::Iterable::first}{core::int}, c2.{core::Iterable::first}{core::int}.{core::int::isEven}{core::bool}){(core::int, core::bool) → void};
    }
  } =>#t27;
}

constants  {
  #C1 = 2
}
