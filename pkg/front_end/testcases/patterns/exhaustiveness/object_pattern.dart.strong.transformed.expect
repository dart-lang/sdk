library /*isNonNullableByDefault*/;
//
// Problems in library:
//
// pkg/front_end/testcases/patterns/exhaustiveness/object_pattern.dart:28:41: Error: The type 'A' is not exhaustively matched by the switch cases since it doesn't match 'A(field1: int())'.
//  - 'A' is from 'pkg/front_end/testcases/patterns/exhaustiveness/object_pattern.dart'.
// Try adding a wildcard pattern or cases that match 'A()'.
// nonExhaustiveFixedField(A a) => switch (a) {
//                                         ^
//
// pkg/front_end/testcases/patterns/exhaustiveness/object_pattern.dart:32:41: Error: The type 'A' is not exhaustively matched by the switch cases since it doesn't match 'A(field2: double())'.
//  - 'A' is from 'pkg/front_end/testcases/patterns/exhaustiveness/object_pattern.dart'.
// Try adding a wildcard pattern or cases that match 'A(field2: double())'.
// nonExhaustiveTypedField(A a) => switch (a) {
//                                         ^
//
import self as self;
import "dart:core" as core;

class A extends core::Object {
  field core::int field1;
  field core::num field2;
  constructor •(core::int field1, core::num field2) → self::A
    : self::A::field1 = field1, self::A::field2 = field2, super core::Object::•()
    ;
}
static method exhaustiveDirect(self::A a) → dynamic
  return block {
    core::int #t1;
    final synthesized self::A #0#0 = a;
    #L1:
    {
      {
        if(true) {
          #t1 = 0;
          break #L1;
        }
      }
    }
  } =>#t1;
static method exhaustiveWithWildcards(self::A a) → dynamic
  return block {
    core::int #t2;
    final synthesized self::A #0#0 = a;
    #L2:
    {
      {
        if((let final core::int #t3 = #0#0.{self::A::field1}{core::int} in true) && (let final core::num #t4 = #0#0.{self::A::field2}{core::num} in true)) {
          #t2 = 0;
          break #L2;
        }
      }
    }
  } =>#t2;
static method exhaustiveWithFields(self::A a) → dynamic
  return block {
    core::int #t5;
    final synthesized self::A #0#0 = a;
    #L3:
    {
      {
        hoisted core::int field1;
        hoisted core::num field2;
        if((let final core::int #t6 = field1 = #0#0.{self::A::field1}{core::int} in true) && (let final core::num #t7 = field2 = #0#0.{self::A::field2}{core::num} in true)) {
          #t5 = 0;
          break #L3;
        }
      }
    }
  } =>#t5;
static method exhaustiveWithTypedFields(self::A a) → dynamic
  return block {
    core::int #t8;
    final synthesized self::A #0#0 = a;
    function ##0#1#initializer() → core::int
      return #0#0.{self::A::field1}{core::int};
    late final synthesized core::int #0#1 = ##0#1#initializer(){() → core::int};
    function ##0#2#initializer() → core::num
      return #0#0.{self::A::field2}{core::num};
    late final synthesized core::num #0#2 = ##0#2#initializer(){() → core::num};
    #L4:
    {
      {
        hoisted core::int field1;
        hoisted core::num field2;
        if(#0#1 is{ForNonNullableByDefault} core::int && (let final core::int #t9 = field1 = #0#1 in true) && (#0#2 is{ForNonNullableByDefault} core::num && (let final core::num #t10 = field2 = #0#2 in true))) {
          #t8 = 0;
          break #L4;
        }
      }
    }
  } =>#t8;
static method nonExhaustiveFixedField(self::A a) → dynamic
  return block {
    core::int #t11;
    final synthesized self::A #0#0 = a;
    #L5:
    {
      {
        if(#C1 =={core::num::==}{(core::Object) → core::bool} #0#0.{self::A::field1}{core::int}) {
          #t11 = 0;
          break #L5;
        }
      }
    }
  } =>#t11;
static method nonExhaustiveTypedField(self::A a) → dynamic
  return block {
    core::int #t12;
    final synthesized self::A #0#0 = a;
    function ##0#1#initializer() → core::num
      return #0#0.{self::A::field2}{core::num};
    late final synthesized core::num #0#1 = ##0#1#initializer(){() → core::num};
    #L6:
    {
      {
        hoisted core::int field2;
        if(#0#1 is{ForNonNullableByDefault} core::int && (let final core::int #t13 = field2 = #0#1{core::int} in true)) {
          #t12 = 0;
          break #L6;
        }
      }
    }
  } =>#t12;

constants  {
  #C1 = 5
}
