library;
//
// Problems in library:
//
// pkg/front_end/testcases/patterns/exhaustiveness/list.dart:37:51: Error: The type 'List<num>' is not exhaustively matched by the switch cases since it doesn't match '[]'.
//  - 'List' is from 'dart:core'.
// Try adding a wildcard pattern or cases that match '[]'.
// nonExhaustive1aMissing(List<num> list) => switch (list) {
//                                                   ^
//
// pkg/front_end/testcases/patterns/exhaustiveness/list.dart:41:51: Error: The type 'List<num>' is not exhaustively matched by the switch cases since it doesn't match '[]'.
//  - 'List' is from 'dart:core'.
// Try adding a wildcard pattern or cases that match '[]'.
// nonExhaustive1bMissing(List<num> list) => switch (list) {
//                                                   ^
//
// pkg/front_end/testcases/patterns/exhaustiveness/list.dart:45:51: Error: The type 'List<num>' is not exhaustively matched by the switch cases since it doesn't match '[_]'.
//  - 'List' is from 'dart:core'.
// Try adding a wildcard pattern or cases that match '[_]'.
// nonExhaustive2aMissing(List<num> list) => switch (list) {
//                                                   ^
//
// pkg/front_end/testcases/patterns/exhaustiveness/list.dart:50:51: Error: The type 'List<num>' is not exhaustively matched by the switch cases since it doesn't match '[_]'.
//  - 'List' is from 'dart:core'.
// Try adding a wildcard pattern or cases that match '[_]'.
// nonExhaustive2bMissing(List<num> list) => switch (list) {
//                                                   ^
//
// pkg/front_end/testcases/patterns/exhaustiveness/list.dart:55:51: Error: The type 'List<num>' is not exhaustively matched by the switch cases since it doesn't match '[_]'.
//  - 'List' is from 'dart:core'.
// Try adding a wildcard pattern or cases that match '[_]'.
// nonExhaustive2cMissing(List<num> list) => switch (list) {
//                                                   ^
//
// pkg/front_end/testcases/patterns/exhaustiveness/list.dart:60:56: Error: The type 'List<num>' is not exhaustively matched by the switch cases since it doesn't match '[...[...]]'.
//  - 'List' is from 'dart:core'.
// Try adding a wildcard pattern or cases that match '[...]'.
// nonExhaustiveRestrictedType(List<num> list) => switch (list) {
//                                                        ^
//
// pkg/front_end/testcases/patterns/exhaustiveness/list.dart:64:59: Error: The type 'List<num>' is not exhaustively matched by the switch cases since it doesn't match '[double(), ...[...]]'.
//  - 'List' is from 'dart:core'.
// Try adding a wildcard pattern or cases that match '[double(), ...]'.
// nonExhaustive1aRestrictedValue(List<num> list) => switch (list) {
//                                                           ^
//
// pkg/front_end/testcases/patterns/exhaustiveness/list.dart:69:58: Error: The type 'List<num>' is not exhaustively matched by the switch cases since it doesn't match '[]'.
//  - 'List' is from 'dart:core'.
// Try adding a wildcard pattern or cases that match '[]'.
// nonExhaustive1aRestrictedType(List<num> list) => switch (list) {
//                                                          ^
//
// pkg/front_end/testcases/patterns/exhaustiveness/list.dart:74:59: Error: The type 'List<num>' is not exhaustively matched by the switch cases since it doesn't match '[...[...], double()]'.
//  - 'List' is from 'dart:core'.
// Try adding a wildcard pattern or cases that match '[..., double()]'.
// nonExhaustive1bRestrictedValue(List<num> list) => switch (list) {
//                                                           ^
//
// pkg/front_end/testcases/patterns/exhaustiveness/list.dart:79:58: Error: The type 'List<num>' is not exhaustively matched by the switch cases since it doesn't match '[...[...], double()]'.
//  - 'List' is from 'dart:core'.
// Try adding a wildcard pattern or cases that match '[..., double()]'.
// nonExhaustive1bRestrictedType(List<num> list) => switch (list) {
//                                                          ^
//
// pkg/front_end/testcases/patterns/exhaustiveness/list.dart:84:59: Error: The type 'List<num>' is not exhaustively matched by the switch cases since it doesn't match '[double()]'.
//  - 'List' is from 'dart:core'.
// Try adding a wildcard pattern or cases that match '[double()]'.
// nonExhaustive2aRestrictedValue(List<num> list) => switch (list) {
//                                                           ^
//
// pkg/front_end/testcases/patterns/exhaustiveness/list.dart:90:59: Error: The type 'List<num>' is not exhaustively matched by the switch cases since it doesn't match '[double(), double(), ...[...]]'.
//  - 'List' is from 'dart:core'.
// Try adding a wildcard pattern or cases that match '[double(), double(), ...]'.
// nonExhaustive2bRestrictedValue(List<num> list) => switch (list) {
//                                                           ^
//
// pkg/front_end/testcases/patterns/exhaustiveness/list.dart:96:59: Error: The type 'List<num>' is not exhaustively matched by the switch cases since it doesn't match '[double(), double(), ...[...]]'.
//  - 'List' is from 'dart:core'.
// Try adding a wildcard pattern or cases that match '[double(), double(), ...]'.
// nonExhaustive2cRestrictedValue(List<num> list) => switch (list) {
//                                                           ^
//
// pkg/front_end/testcases/patterns/exhaustiveness/list.dart:102:59: Error: The type 'List<num>' is not exhaustively matched by the switch cases since it doesn't match '[double(), _, ...[...]]'.
//  - 'List' is from 'dart:core'.
// Try adding a wildcard pattern or cases that match '[double(), _, ...]'.
// nonExhaustive2dRestrictedValue(List<num> list) => switch (list) {
//                                                           ^
//
// pkg/front_end/testcases/patterns/exhaustiveness/list.dart:108:59: Error: The type 'List<num>' is not exhaustively matched by the switch cases since it doesn't match '[_, double()]'.
//  - 'List' is from 'dart:core'.
// Try adding a wildcard pattern or cases that match '[_, double()]'.
// nonExhaustive2eRestrictedValue(List<num> list) => switch (list) {
//                                                           ^
//
// pkg/front_end/testcases/patterns/exhaustiveness/list.dart:114:59: Error: The type 'List<num>' is not exhaustively matched by the switch cases since it doesn't match '[_, double()]'.
//  - 'List' is from 'dart:core'.
// Try adding a wildcard pattern or cases that match '[_, double()]'.
// nonExhaustive2fRestrictedValue(List<num> list) => switch (list) {
//                                                           ^
//
import self as self;
import "dart:core" as core;

static method exhaustive(core::List<core::num> list) → dynamic
  return block {
    core::int #t1;
    final synthesized core::List<core::num> #0#0 = list;
    #L1:
    {
      {
        if(true) {
          #t1 = 0;
          break #L1;
        }
      }
    }
  } =>#t1;
static method exhaustive1a(core::List<core::num> list) → dynamic
  return block {
    core::int #t2;
    final synthesized core::List<core::num> #0#0 = list;
    synthesized core::int #0#1;
    synthesized core::bool #0#1#isSet = false;
    #L2:
    {
      {
        if((#0#1#isSet ?{core::int} #0#1{core::int} : let final core::bool* #t3 = #0#1#isSet = true in #0#1 = #0#0.{core::List::length}{core::int}).{core::num::<=}(#C1){(core::num) → core::bool}) {
          #t2 = 0;
          break #L2;
        }
      }
      {
        if((#0#1#isSet ?{core::int} #0#1{core::int} : let final core::bool* #t4 = #0#1#isSet = true in #0#1 = #0#0.{core::List::length}{core::int}).{core::num::>=}(#C2){(core::num) → core::bool}) {
          #t2 = 1;
          break #L2;
        }
      }
    }
  } =>#t2;
static method exhaustive1b(core::List<core::num> list) → dynamic
  return block {
    core::int #t5;
    final synthesized core::List<core::num> #0#0 = list;
    synthesized core::int #0#1;
    synthesized core::bool #0#1#isSet = false;
    #L3:
    {
      {
        if((#0#1#isSet ?{core::int} #0#1{core::int} : let final core::bool* #t6 = #0#1#isSet = true in #0#1 = #0#0.{core::List::length}{core::int}).{core::num::<=}(#C1){(core::num) → core::bool}) {
          #t5 = 0;
          break #L3;
        }
      }
      {
        if((#0#1#isSet ?{core::int} #0#1{core::int} : let final core::bool* #t7 = #0#1#isSet = true in #0#1 = #0#0.{core::List::length}{core::int}).{core::num::>=}(#C2){(core::num) → core::bool}) {
          #t5 = 1;
          break #L3;
        }
      }
    }
  } =>#t5;
static method exhaustive2a(core::List<core::num> list) → dynamic
  return block {
    core::int #t8;
    final synthesized core::List<core::num> #0#0 = list;
    synthesized core::int #0#1;
    synthesized core::bool #0#1#isSet = false;
    #L4:
    {
      {
        if((#0#1#isSet ?{core::int} #0#1{core::int} : let final core::bool* #t9 = #0#1#isSet = true in #0#1 = #0#0.{core::List::length}{core::int}).{core::num::<=}(#C1){(core::num) → core::bool}) {
          #t8 = 0;
          break #L4;
        }
      }
      {
        if((#0#1#isSet ?{core::int} #0#1{core::int} : let final core::bool* #t10 = #0#1#isSet = true in #0#1 = #0#0.{core::List::length}{core::int}) =={core::num::==}{(core::Object) → core::bool} #C2) {
          #t8 = 1;
          break #L4;
        }
      }
      {
        if((#0#1#isSet ?{core::int} #0#1{core::int} : let final core::bool* #t11 = #0#1#isSet = true in #0#1 = #0#0.{core::List::length}{core::int}).{core::num::>=}(#C3){(core::num) → core::bool}) {
          #t8 = 2;
          break #L4;
        }
      }
    }
  } =>#t8;
static method exhaustive2b(core::List<core::num> list) → dynamic
  return block {
    core::int #t12;
    final synthesized core::List<core::num> #0#0 = list;
    synthesized core::int #0#1;
    synthesized core::bool #0#1#isSet = false;
    #L5:
    {
      {
        if((#0#1#isSet ?{core::int} #0#1{core::int} : let final core::bool* #t13 = #0#1#isSet = true in #0#1 = #0#0.{core::List::length}{core::int}).{core::num::<=}(#C1){(core::num) → core::bool}) {
          #t12 = 0;
          break #L5;
        }
      }
      {
        if((#0#1#isSet ?{core::int} #0#1{core::int} : let final core::bool* #t14 = #0#1#isSet = true in #0#1 = #0#0.{core::List::length}{core::int}) =={core::num::==}{(core::Object) → core::bool} #C2) {
          #t12 = 1;
          break #L5;
        }
      }
      {
        if((#0#1#isSet ?{core::int} #0#1{core::int} : let final core::bool* #t15 = #0#1#isSet = true in #0#1 = #0#0.{core::List::length}{core::int}).{core::num::>=}(#C3){(core::num) → core::bool}) {
          #t12 = 2;
          break #L5;
        }
      }
    }
  } =>#t12;
static method exhaustive2c(core::List<core::num> list) → dynamic
  return block {
    core::int #t16;
    final synthesized core::List<core::num> #0#0 = list;
    synthesized core::int #0#1;
    synthesized core::bool #0#1#isSet = false;
    #L6:
    {
      {
        if((#0#1#isSet ?{core::int} #0#1{core::int} : let final core::bool* #t17 = #0#1#isSet = true in #0#1 = #0#0.{core::List::length}{core::int}).{core::num::<=}(#C1){(core::num) → core::bool}) {
          #t16 = 0;
          break #L6;
        }
      }
      {
        if((#0#1#isSet ?{core::int} #0#1{core::int} : let final core::bool* #t18 = #0#1#isSet = true in #0#1 = #0#0.{core::List::length}{core::int}) =={core::num::==}{(core::Object) → core::bool} #C2) {
          #t16 = 1;
          break #L6;
        }
      }
      {
        if((#0#1#isSet ?{core::int} #0#1{core::int} : let final core::bool* #t19 = #0#1#isSet = true in #0#1 = #0#0.{core::List::length}{core::int}).{core::num::>=}(#C3){(core::num) → core::bool}) {
          #t16 = 2;
          break #L6;
        }
      }
    }
  } =>#t16;
static method nonExhaustive1aMissing(core::List<core::num> list) → dynamic
  return block {
    core::int #t20;
    final synthesized core::List<core::num> #0#0 = list;
    #L7:
    {
      {
        if(#0#0.{core::List::length}{core::int}.{core::num::>=}(#C2){(core::num) → core::bool}) {
          #t20 = 1;
          break #L7;
        }
      }
    }
  } =>#t20;
static method nonExhaustive1bMissing(core::List<core::num> list) → dynamic
  return block {
    core::int #t21;
    final synthesized core::List<core::num> #0#0 = list;
    #L8:
    {
      {
        if(#0#0.{core::List::length}{core::int}.{core::num::>=}(#C2){(core::num) → core::bool}) {
          #t21 = 1;
          break #L8;
        }
      }
    }
  } =>#t21;
static method nonExhaustive2aMissing(core::List<core::num> list) → dynamic
  return block {
    core::int #t22;
    final synthesized core::List<core::num> #0#0 = list;
    synthesized core::int #0#1;
    synthesized core::bool #0#1#isSet = false;
    #L9:
    {
      {
        if((#0#1#isSet ?{core::int} #0#1{core::int} : let final core::bool* #t23 = #0#1#isSet = true in #0#1 = #0#0.{core::List::length}{core::int}).{core::num::<=}(#C1){(core::num) → core::bool}) {
          #t22 = 0;
          break #L9;
        }
      }
      {
        if((#0#1#isSet ?{core::int} #0#1{core::int} : let final core::bool* #t24 = #0#1#isSet = true in #0#1 = #0#0.{core::List::length}{core::int}).{core::num::>=}(#C3){(core::num) → core::bool}) {
          #t22 = 2;
          break #L9;
        }
      }
    }
  } =>#t22;
static method nonExhaustive2bMissing(core::List<core::num> list) → dynamic
  return block {
    core::int #t25;
    final synthesized core::List<core::num> #0#0 = list;
    synthesized core::int #0#1;
    synthesized core::bool #0#1#isSet = false;
    #L10:
    {
      {
        if((#0#1#isSet ?{core::int} #0#1{core::int} : let final core::bool* #t26 = #0#1#isSet = true in #0#1 = #0#0.{core::List::length}{core::int}).{core::num::<=}(#C1){(core::num) → core::bool}) {
          #t25 = 0;
          break #L10;
        }
      }
      {
        if((#0#1#isSet ?{core::int} #0#1{core::int} : let final core::bool* #t27 = #0#1#isSet = true in #0#1 = #0#0.{core::List::length}{core::int}).{core::num::>=}(#C3){(core::num) → core::bool}) {
          #t25 = 2;
          break #L10;
        }
      }
    }
  } =>#t25;
static method nonExhaustive2cMissing(core::List<core::num> list) → dynamic
  return block {
    core::int #t28;
    final synthesized core::List<core::num> #0#0 = list;
    synthesized core::int #0#1;
    synthesized core::bool #0#1#isSet = false;
    #L11:
    {
      {
        if((#0#1#isSet ?{core::int} #0#1{core::int} : let final core::bool* #t29 = #0#1#isSet = true in #0#1 = #0#0.{core::List::length}{core::int}).{core::num::<=}(#C1){(core::num) → core::bool}) {
          #t28 = 0;
          break #L11;
        }
      }
      {
        if((#0#1#isSet ?{core::int} #0#1{core::int} : let final core::bool* #t30 = #0#1#isSet = true in #0#1 = #0#0.{core::List::length}{core::int}).{core::num::>=}(#C3){(core::num) → core::bool}) {
          #t28 = 2;
          break #L11;
        }
      }
    }
  } =>#t28;
static method nonExhaustiveRestrictedType(core::List<core::num> list) → dynamic
  return block {
    core::int #t31;
    final synthesized core::List<core::num> #0#0 = list;
    #L12:
    {
      {
        if(#0#0.{core::List::sublist}(0){(core::int, [core::int?]) → core::List<core::num>} is core::List<core::int>) {
          #t31 = 0;
          break #L12;
        }
      }
    }
  } =>#t31;
static method nonExhaustive1aRestrictedValue(core::List<core::num> list) → dynamic
  return block {
    core::int #t32;
    final synthesized core::List<core::num> #0#0 = list;
    synthesized core::int #0#1;
    synthesized core::bool #0#1#isSet = false;
    #L13:
    {
      {
        if((#0#1#isSet ?{core::int} #0#1{core::int} : let final core::bool* #t33 = #0#1#isSet = true in #0#1 = #0#0.{core::List::length}{core::int}).{core::num::<=}(#C1){(core::num) → core::bool}) {
          #t32 = 0;
          break #L13;
        }
      }
      {
        if((#0#1#isSet ?{core::int} #0#1{core::int} : let final core::bool* #t34 = #0#1#isSet = true in #0#1 = #0#0.{core::List::length}{core::int}).{core::num::>=}(#C2){(core::num) → core::bool} && #C2 =={core::num::==}{(core::Object) → core::bool} #0#0.{core::List::[]}(0){(core::int) → core::num}) {
          #t32 = 1;
          break #L13;
        }
      }
    }
  } =>#t32;
static method nonExhaustive1aRestrictedType(core::List<core::num> list) → dynamic
  return block {
    core::int #t35;
    final synthesized core::List<core::num> #0#0 = list;
    synthesized core::int #0#2;
    synthesized core::bool #0#2#isSet = false;
    #L14:
    {
      {
        if(#0#0 is core::List<core::int> && (#0#2#isSet ?{core::int} #0#2{core::int} : let final core::bool* #t36 = #0#2#isSet = true in #0#2 = #0#0{core::List<core::int>}.{core::List::length}{core::int}).{core::num::<=}(#C1){(core::num) → core::bool}) {
          #t35 = 0;
          break #L14;
        }
      }
      {
        if((#0#2#isSet ?{core::int} #0#2{core::int} : let final core::bool* #t37 = #0#2#isSet = true in #0#2 = #0#0.{core::List::length}{core::int}).{core::num::>=}(#C2){(core::num) → core::bool}) {
          #t35 = 1;
          break #L14;
        }
      }
    }
  } =>#t35;
static method nonExhaustive1bRestrictedValue(core::List<core::num> list) → dynamic
  return block {
    core::int #t38;
    final synthesized core::List<core::num> #0#0 = list;
    synthesized core::int #0#1;
    synthesized core::bool #0#1#isSet = false;
    #L15:
    {
      {
        if((#0#1#isSet ?{core::int} #0#1{core::int} : let final core::bool* #t39 = #0#1#isSet = true in #0#1 = #0#0.{core::List::length}{core::int}).{core::num::<=}(#C1){(core::num) → core::bool}) {
          #t38 = 0;
          break #L15;
        }
      }
      {
        if((#0#1#isSet ?{core::int} #0#1{core::int} : let final core::bool* #t40 = #0#1#isSet = true in #0#1 = #0#0.{core::List::length}{core::int}).{core::num::>=}(#C2){(core::num) → core::bool} && #C2 =={core::num::==}{(core::Object) → core::bool} #0#0.{core::List::[]}((#0#1#isSet ?{core::int} #0#1{core::int} : let final core::bool* #t41 = #0#1#isSet = true in #0#1 = #0#0.{core::List::length}{core::int}).{core::num::-}(1){(core::num) → core::int}){(core::int) → core::num}) {
          #t38 = 1;
          break #L15;
        }
      }
    }
  } =>#t38;
static method nonExhaustive1bRestrictedType(core::List<core::num> list) → dynamic
  return block {
    core::int #t42;
    final synthesized core::List<core::num> #0#0 = list;
    synthesized core::int #0#1;
    synthesized core::bool #0#1#isSet = false;
    #L16:
    {
      {
        if((#0#1#isSet ?{core::int} #0#1{core::int} : let final core::bool* #t43 = #0#1#isSet = true in #0#1 = #0#0.{core::List::length}{core::int}).{core::num::<=}(#C1){(core::num) → core::bool}) {
          #t42 = 0;
          break #L16;
        }
      }
      {
        if((#0#1#isSet ?{core::int} #0#1{core::int} : let final core::bool* #t44 = #0#1#isSet = true in #0#1 = #0#0.{core::List::length}{core::int}).{core::num::>=}(#C2){(core::num) → core::bool} && #0#0.{core::List::sublist}(0, (#0#1#isSet ?{core::int} #0#1{core::int} : let final core::bool* #t45 = #0#1#isSet = true in #0#1 = #0#0.{core::List::length}{core::int}).{core::num::-}(1){(core::num) → core::int}){(core::int, [core::int?]) → core::List<core::num>} is core::List<core::int>) {
          #t42 = 1;
          break #L16;
        }
      }
    }
  } =>#t42;
static method nonExhaustive2aRestrictedValue(core::List<core::num> list) → dynamic
  return block {
    core::int #t46;
    final synthesized core::List<core::num> #0#0 = list;
    synthesized core::int #0#1;
    synthesized core::bool #0#1#isSet = false;
    #L17:
    {
      {
        if((#0#1#isSet ?{core::int} #0#1{core::int} : let final core::bool* #t47 = #0#1#isSet = true in #0#1 = #0#0.{core::List::length}{core::int}).{core::num::<=}(#C1){(core::num) → core::bool}) {
          #t46 = 0;
          break #L17;
        }
      }
      {
        if((#0#1#isSet ?{core::int} #0#1{core::int} : let final core::bool* #t48 = #0#1#isSet = true in #0#1 = #0#0.{core::List::length}{core::int}) =={core::num::==}{(core::Object) → core::bool} #C2 && #C2 =={core::num::==}{(core::Object) → core::bool} #0#0.{core::List::[]}(0){(core::int) → core::num}) {
          #t46 = 1;
          break #L17;
        }
      }
      {
        if((#0#1#isSet ?{core::int} #0#1{core::int} : let final core::bool* #t49 = #0#1#isSet = true in #0#1 = #0#0.{core::List::length}{core::int}).{core::num::>=}(#C3){(core::num) → core::bool}) {
          #t46 = 2;
          break #L17;
        }
      }
    }
  } =>#t46;
static method nonExhaustive2bRestrictedValue(core::List<core::num> list) → dynamic
  return block {
    core::int #t50;
    final synthesized core::List<core::num> #0#0 = list;
    synthesized core::int #0#1;
    synthesized core::bool #0#1#isSet = false;
    #L18:
    {
      {
        if((#0#1#isSet ?{core::int} #0#1{core::int} : let final core::bool* #t51 = #0#1#isSet = true in #0#1 = #0#0.{core::List::length}{core::int}).{core::num::<=}(#C1){(core::num) → core::bool}) {
          #t50 = 0;
          break #L18;
        }
      }
      {
        if((#0#1#isSet ?{core::int} #0#1{core::int} : let final core::bool* #t52 = #0#1#isSet = true in #0#1 = #0#0.{core::List::length}{core::int}) =={core::num::==}{(core::Object) → core::bool} #C2) {
          #t50 = 1;
          break #L18;
        }
      }
      {
        if((#0#1#isSet ?{core::int} #0#1{core::int} : let final core::bool* #t53 = #0#1#isSet = true in #0#1 = #0#0.{core::List::length}{core::int}).{core::num::>=}(#C3){(core::num) → core::bool} && #C2 =={core::num::==}{(core::Object) → core::bool} #0#0.{core::List::[]}(0){(core::int) → core::num}) {
          #t50 = 2;
          break #L18;
        }
      }
    }
  } =>#t50;
static method nonExhaustive2cRestrictedValue(core::List<core::num> list) → dynamic
  return block {
    core::int #t54;
    final synthesized core::List<core::num> #0#0 = list;
    synthesized core::int #0#1;
    synthesized core::bool #0#1#isSet = false;
    #L19:
    {
      {
        if((#0#1#isSet ?{core::int} #0#1{core::int} : let final core::bool* #t55 = #0#1#isSet = true in #0#1 = #0#0.{core::List::length}{core::int}).{core::num::<=}(#C1){(core::num) → core::bool}) {
          #t54 = 0;
          break #L19;
        }
      }
      {
        if((#0#1#isSet ?{core::int} #0#1{core::int} : let final core::bool* #t56 = #0#1#isSet = true in #0#1 = #0#0.{core::List::length}{core::int}) =={core::num::==}{(core::Object) → core::bool} #C2) {
          #t54 = 1;
          break #L19;
        }
      }
      {
        if((#0#1#isSet ?{core::int} #0#1{core::int} : let final core::bool* #t57 = #0#1#isSet = true in #0#1 = #0#0.{core::List::length}{core::int}).{core::num::>=}(#C3){(core::num) → core::bool} && #C2 =={core::num::==}{(core::Object) → core::bool} #0#0.{core::List::[]}(1){(core::int) → core::num}) {
          #t54 = 2;
          break #L19;
        }
      }
    }
  } =>#t54;
static method nonExhaustive2dRestrictedValue(core::List<core::num> list) → dynamic
  return block {
    core::int #t58;
    final synthesized core::List<core::num> #0#0 = list;
    synthesized core::int #0#1;
    synthesized core::bool #0#1#isSet = false;
    #L20:
    {
      {
        if((#0#1#isSet ?{core::int} #0#1{core::int} : let final core::bool* #t59 = #0#1#isSet = true in #0#1 = #0#0.{core::List::length}{core::int}).{core::num::<=}(#C1){(core::num) → core::bool}) {
          #t58 = 0;
          break #L20;
        }
      }
      {
        if((#0#1#isSet ?{core::int} #0#1{core::int} : let final core::bool* #t60 = #0#1#isSet = true in #0#1 = #0#0.{core::List::length}{core::int}) =={core::num::==}{(core::Object) → core::bool} #C2) {
          #t58 = 1;
          break #L20;
        }
      }
      {
        if((#0#1#isSet ?{core::int} #0#1{core::int} : let final core::bool* #t61 = #0#1#isSet = true in #0#1 = #0#0.{core::List::length}{core::int}).{core::num::>=}(#C3){(core::num) → core::bool} && #C2 =={core::num::==}{(core::Object) → core::bool} #0#0.{core::List::[]}((#0#1#isSet ?{core::int} #0#1{core::int} : let final core::bool* #t62 = #0#1#isSet = true in #0#1 = #0#0.{core::List::length}{core::int}).{core::num::-}(1){(core::num) → core::int}){(core::int) → core::num}) {
          #t58 = 2;
          break #L20;
        }
      }
    }
  } =>#t58;
static method nonExhaustive2eRestrictedValue(core::List<core::num> list) → dynamic
  return block {
    core::int #t63;
    final synthesized core::List<core::num> #0#0 = list;
    synthesized core::int #0#1;
    synthesized core::bool #0#1#isSet = false;
    #L21:
    {
      {
        if((#0#1#isSet ?{core::int} #0#1{core::int} : let final core::bool* #t64 = #0#1#isSet = true in #0#1 = #0#0.{core::List::length}{core::int}).{core::num::<=}(#C1){(core::num) → core::bool}) {
          #t63 = 0;
          break #L21;
        }
      }
      {
        if((#0#1#isSet ?{core::int} #0#1{core::int} : let final core::bool* #t65 = #0#1#isSet = true in #0#1 = #0#0.{core::List::length}{core::int}) =={core::num::==}{(core::Object) → core::bool} #C2) {
          #t63 = 1;
          break #L21;
        }
      }
      {
        if((#0#1#isSet ?{core::int} #0#1{core::int} : let final core::bool* #t66 = #0#1#isSet = true in #0#1 = #0#0.{core::List::length}{core::int}).{core::num::>=}(#C3){(core::num) → core::bool} && #C2 =={core::num::==}{(core::Object) → core::bool} #0#0.{core::List::[]}((#0#1#isSet ?{core::int} #0#1{core::int} : let final core::bool* #t67 = #0#1#isSet = true in #0#1 = #0#0.{core::List::length}{core::int}).{core::num::-}(2){(core::num) → core::int}){(core::int) → core::num}) {
          #t63 = 2;
          break #L21;
        }
      }
    }
  } =>#t63;
static method nonExhaustive2fRestrictedValue(core::List<core::num> list) → dynamic
  return block {
    core::int #t68;
    final synthesized core::List<core::num> #0#0 = list;
    synthesized core::int #0#1;
    synthesized core::bool #0#1#isSet = false;
    #L22:
    {
      {
        if((#0#1#isSet ?{core::int} #0#1{core::int} : let final core::bool* #t69 = #0#1#isSet = true in #0#1 = #0#0.{core::List::length}{core::int}).{core::num::<=}(#C1){(core::num) → core::bool}) {
          #t68 = 0;
          break #L22;
        }
      }
      {
        if((#0#1#isSet ?{core::int} #0#1{core::int} : let final core::bool* #t70 = #0#1#isSet = true in #0#1 = #0#0.{core::List::length}{core::int}) =={core::num::==}{(core::Object) → core::bool} #C2) {
          #t68 = 1;
          break #L22;
        }
      }
      {
        if((#0#1#isSet ?{core::int} #0#1{core::int} : let final core::bool* #t71 = #0#1#isSet = true in #0#1 = #0#0.{core::List::length}{core::int}).{core::num::>=}(#C3){(core::num) → core::bool} && #C2 =={core::num::==}{(core::Object) → core::bool} #0#0.{core::List::[]}((#0#1#isSet ?{core::int} #0#1{core::int} : let final core::bool* #t72 = #0#1#isSet = true in #0#1 = #0#0.{core::List::length}{core::int}).{core::num::-}(1){(core::num) → core::int}){(core::int) → core::num}) {
          #t68 = 2;
          break #L22;
        }
      }
    }
  } =>#t68;

constants  {
  #C1 = 0
  #C2 = 1
  #C3 = 2
}
