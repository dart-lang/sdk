library;
//
// Problems in library:
//
// pkg/front_end/testcases/patterns/non_type_object_pattern.dart:12:7: Error: 'Unresolved' isn't a type.
//   var Unresolved(:int field) = o;
//       ^^^^^^^^^^
//
// pkg/front_end/testcases/patterns/non_type_object_pattern.dart:13:9: Error: 'Unresolved' isn't a type.
//   final Unresolved(:o) = o;
//         ^^^^^^^^^^
//
// pkg/front_end/testcases/patterns/non_type_object_pattern.dart:12:32: Error: Local variable 'o' can't be referenced before it is declared.
//   var Unresolved(:int field) = o;
//                                ^
// pkg/front_end/testcases/patterns/non_type_object_pattern.dart:13:21: Context: This is the declaration of the variable 'o'.
//   final Unresolved(:o) = o;
//                     ^
//
// pkg/front_end/testcases/patterns/non_type_object_pattern.dart:13:26: Error: Local variable 'o' can't be referenced before it is declared.
//   final Unresolved(:o) = o;
//                          ^
// pkg/front_end/testcases/patterns/non_type_object_pattern.dart:13:21: Context: This is the declaration of the variable 'o'.
//   final Unresolved(:o) = o;
//                     ^
//
// pkg/front_end/testcases/patterns/non_type_object_pattern.dart:15:14: Error: 'Unresolved' isn't a type.
//   if (o case Unresolved(:var field)) {}
//              ^^^^^^^^^^
//
// pkg/front_end/testcases/patterns/non_type_object_pattern.dart:18:10: Error: 'Unresolved' isn't a type.
//     case Unresolved(:var field):
//          ^^^^^^^^^^
//
// pkg/front_end/testcases/patterns/non_type_object_pattern.dart:22:5: Error: 'Unresolved' isn't a type.
//     Unresolved(:var field) => "matched",
//     ^^^^^^^^^^
//
// pkg/front_end/testcases/patterns/non_type_object_pattern.dart:28:7: Error: 'NonType' isn't a type.
//   var NonType(:int field) = o;
//       ^^^^^^^
//
// pkg/front_end/testcases/patterns/non_type_object_pattern.dart:29:9: Error: 'NonType' isn't a type.
//   final NonType(:o) = o;
//         ^^^^^^^
//
// pkg/front_end/testcases/patterns/non_type_object_pattern.dart:28:29: Error: Local variable 'o' can't be referenced before it is declared.
//   var NonType(:int field) = o;
//                             ^
// pkg/front_end/testcases/patterns/non_type_object_pattern.dart:29:18: Context: This is the declaration of the variable 'o'.
//   final NonType(:o) = o;
//                  ^
//
// pkg/front_end/testcases/patterns/non_type_object_pattern.dart:29:23: Error: Local variable 'o' can't be referenced before it is declared.
//   final NonType(:o) = o;
//                       ^
// pkg/front_end/testcases/patterns/non_type_object_pattern.dart:29:18: Context: This is the declaration of the variable 'o'.
//   final NonType(:o) = o;
//                  ^
//
// pkg/front_end/testcases/patterns/non_type_object_pattern.dart:31:14: Error: 'NonType' isn't a type.
//   if (o case NonType(:var field)) {}
//              ^^^^^^^
//
// pkg/front_end/testcases/patterns/non_type_object_pattern.dart:34:10: Error: 'NonType' isn't a type.
//     case NonType(:var field):
//          ^^^^^^^
//
// pkg/front_end/testcases/patterns/non_type_object_pattern.dart:38:5: Error: 'NonType' isn't a type.
//     NonType(:var field) => "matched",
//     ^^^^^^^
//
// pkg/front_end/testcases/patterns/non_type_object_pattern.dart:44:7: Error: 'Extension' isn't a type.
//   var Extension(:int field) = o;
//       ^^^^^^^^^
//
// pkg/front_end/testcases/patterns/non_type_object_pattern.dart:45:9: Error: 'Extension' isn't a type.
//   final Extension(:o) = o;
//         ^^^^^^^^^
//
// pkg/front_end/testcases/patterns/non_type_object_pattern.dart:44:31: Error: Local variable 'o' can't be referenced before it is declared.
//   var Extension(:int field) = o;
//                               ^
// pkg/front_end/testcases/patterns/non_type_object_pattern.dart:45:20: Context: This is the declaration of the variable 'o'.
//   final Extension(:o) = o;
//                    ^
//
// pkg/front_end/testcases/patterns/non_type_object_pattern.dart:45:25: Error: Local variable 'o' can't be referenced before it is declared.
//   final Extension(:o) = o;
//                         ^
// pkg/front_end/testcases/patterns/non_type_object_pattern.dart:45:20: Context: This is the declaration of the variable 'o'.
//   final Extension(:o) = o;
//                    ^
//
// pkg/front_end/testcases/patterns/non_type_object_pattern.dart:47:14: Error: 'Extension' isn't a type.
//   if (o case Extension(:var field)) {}
//              ^^^^^^^^^
//
// pkg/front_end/testcases/patterns/non_type_object_pattern.dart:50:10: Error: 'Extension' isn't a type.
//     case Extension(:var field):
//          ^^^^^^^^^
//
// pkg/front_end/testcases/patterns/non_type_object_pattern.dart:54:5: Error: 'Extension' isn't a type.
//     Extension(:var field) => "matched",
//     ^^^^^^^^^
//
// pkg/front_end/testcases/patterns/non_type_object_pattern.dart:60:14: Error: 'Unresolved' isn't a type.
//   var prefix.Unresolved(:int field) = o;
//              ^^^^^^^^^^
//
// pkg/front_end/testcases/patterns/non_type_object_pattern.dart:61:16: Error: 'Unresolved' isn't a type.
//   final prefix.Unresolved(:o) = o;
//                ^^^^^^^^^^
//
// pkg/front_end/testcases/patterns/non_type_object_pattern.dart:60:39: Error: Local variable 'o' can't be referenced before it is declared.
//   var prefix.Unresolved(:int field) = o;
//                                       ^
// pkg/front_end/testcases/patterns/non_type_object_pattern.dart:61:28: Context: This is the declaration of the variable 'o'.
//   final prefix.Unresolved(:o) = o;
//                            ^
//
// pkg/front_end/testcases/patterns/non_type_object_pattern.dart:61:33: Error: Local variable 'o' can't be referenced before it is declared.
//   final prefix.Unresolved(:o) = o;
//                                 ^
// pkg/front_end/testcases/patterns/non_type_object_pattern.dart:61:28: Context: This is the declaration of the variable 'o'.
//   final prefix.Unresolved(:o) = o;
//                            ^
//
// pkg/front_end/testcases/patterns/non_type_object_pattern.dart:63:21: Error: 'Unresolved' isn't a type.
//   if (o case prefix.Unresolved(:var field)) {}
//                     ^^^^^^^^^^
//
// pkg/front_end/testcases/patterns/non_type_object_pattern.dart:66:17: Error: 'Unresolved' isn't a type.
//     case prefix.Unresolved(:var field):
//                 ^^^^^^^^^^
//
// pkg/front_end/testcases/patterns/non_type_object_pattern.dart:70:11: Error: 'Unresolved' isn't a type.
//    prefix.Unresolved(:var field) => "matched",
//           ^^^^^^^^^^
//
// pkg/front_end/testcases/patterns/non_type_object_pattern.dart:76:14: Error: 'NonType' isn't a type.
//   var prefix.NonType(:int field) = o;
//              ^^^^^^^
//
// pkg/front_end/testcases/patterns/non_type_object_pattern.dart:77:16: Error: 'NonType' isn't a type.
//   final prefix.NonType(:o) = o;
//                ^^^^^^^
//
// pkg/front_end/testcases/patterns/non_type_object_pattern.dart:76:36: Error: Local variable 'o' can't be referenced before it is declared.
//   var prefix.NonType(:int field) = o;
//                                    ^
// pkg/front_end/testcases/patterns/non_type_object_pattern.dart:77:25: Context: This is the declaration of the variable 'o'.
//   final prefix.NonType(:o) = o;
//                         ^
//
// pkg/front_end/testcases/patterns/non_type_object_pattern.dart:77:30: Error: Local variable 'o' can't be referenced before it is declared.
//   final prefix.NonType(:o) = o;
//                              ^
// pkg/front_end/testcases/patterns/non_type_object_pattern.dart:77:25: Context: This is the declaration of the variable 'o'.
//   final prefix.NonType(:o) = o;
//                         ^
//
// pkg/front_end/testcases/patterns/non_type_object_pattern.dart:79:21: Error: 'NonType' isn't a type.
//   if (o case prefix.NonType(:var field)) {}
//                     ^^^^^^^
//
// pkg/front_end/testcases/patterns/non_type_object_pattern.dart:82:17: Error: 'NonType' isn't a type.
//     case prefix.NonType(:var field):
//                 ^^^^^^^
//
// pkg/front_end/testcases/patterns/non_type_object_pattern.dart:86:12: Error: 'NonType' isn't a type.
//     prefix.NonType(:var field) => "matched",
//            ^^^^^^^
//
// pkg/front_end/testcases/patterns/non_type_object_pattern.dart:92:14: Error: 'Extension' isn't a type.
//   var prefix.Extension(:int field) = o;
//              ^^^^^^^^^
//
// pkg/front_end/testcases/patterns/non_type_object_pattern.dart:93:16: Error: 'Extension' isn't a type.
//   final prefix.Extension(:o) = o;
//                ^^^^^^^^^
//
// pkg/front_end/testcases/patterns/non_type_object_pattern.dart:92:38: Error: Local variable 'o' can't be referenced before it is declared.
//   var prefix.Extension(:int field) = o;
//                                      ^
// pkg/front_end/testcases/patterns/non_type_object_pattern.dart:93:27: Context: This is the declaration of the variable 'o'.
//   final prefix.Extension(:o) = o;
//                           ^
//
// pkg/front_end/testcases/patterns/non_type_object_pattern.dart:93:32: Error: Local variable 'o' can't be referenced before it is declared.
//   final prefix.Extension(:o) = o;
//                                ^
// pkg/front_end/testcases/patterns/non_type_object_pattern.dart:93:27: Context: This is the declaration of the variable 'o'.
//   final prefix.Extension(:o) = o;
//                           ^
//
// pkg/front_end/testcases/patterns/non_type_object_pattern.dart:95:21: Error: 'Extension' isn't a type.
//   if (o case prefix.Extension(:var field)) {}
//                     ^^^^^^^^^
//
// pkg/front_end/testcases/patterns/non_type_object_pattern.dart:98:17: Error: 'Extension' isn't a type.
//     case prefix.Extension(:var field):
//                 ^^^^^^^^^
//
// pkg/front_end/testcases/patterns/non_type_object_pattern.dart:102:12: Error: 'Extension' isn't a type.
//     prefix.Extension(:var field) => "matched",
//            ^^^^^^^^^
//
// pkg/front_end/testcases/patterns/non_type_object_pattern.dart:108:7: Error: 'unresolved.Type' can't be used as a type because 'unresolved' isn't defined.
//   var unresolved.Type(:int field) = o;
//       ^^^^^^^^^^^^^^^
//
// pkg/front_end/testcases/patterns/non_type_object_pattern.dart:109:9: Error: 'unresolved.Type' can't be used as a type because 'unresolved' isn't defined.
//   final unresolved.Type(:o) = o;
//         ^^^^^^^^^^^^^^^
//
// pkg/front_end/testcases/patterns/non_type_object_pattern.dart:108:37: Error: Local variable 'o' can't be referenced before it is declared.
//   var unresolved.Type(:int field) = o;
//                                     ^
// pkg/front_end/testcases/patterns/non_type_object_pattern.dart:109:26: Context: This is the declaration of the variable 'o'.
//   final unresolved.Type(:o) = o;
//                          ^
//
// pkg/front_end/testcases/patterns/non_type_object_pattern.dart:109:31: Error: Local variable 'o' can't be referenced before it is declared.
//   final unresolved.Type(:o) = o;
//                               ^
// pkg/front_end/testcases/patterns/non_type_object_pattern.dart:109:26: Context: This is the declaration of the variable 'o'.
//   final unresolved.Type(:o) = o;
//                          ^
//
// pkg/front_end/testcases/patterns/non_type_object_pattern.dart:111:14: Error: 'unresolved.Type' can't be used as a type because 'unresolved' isn't defined.
//   if (o case unresolved.Type(:var field)) {}
//              ^^^^^^^^^^^^^^^
//
// pkg/front_end/testcases/patterns/non_type_object_pattern.dart:114:10: Error: 'unresolved.Type' can't be used as a type because 'unresolved' isn't defined.
//     case unresolved.Type(:var field):
//          ^^^^^^^^^^^^^^^
//
// pkg/front_end/testcases/patterns/non_type_object_pattern.dart:118:5: Error: 'unresolved.Type' can't be used as a type because 'unresolved' isn't defined.
//     unresolved.Type(:var field) => "matched",
//     ^^^^^^^^^^^^^^^
//
// pkg/front_end/testcases/patterns/non_type_object_pattern.dart:124:7: Error: 'NonType.hashCode' can't be used as a type because 'NonType' doesn't refer to an import prefix.
//   var NonType.hashCode(:int field) = o;
//       ^^^^^^^^^^^^^^^^
//
// pkg/front_end/testcases/patterns/non_type_object_pattern.dart:125:9: Error: 'NonType.hashCode' can't be used as a type because 'NonType' doesn't refer to an import prefix.
//   final NonType.hashCode(:o) = o;
//         ^^^^^^^^^^^^^^^^
//
// pkg/front_end/testcases/patterns/non_type_object_pattern.dart:124:38: Error: Local variable 'o' can't be referenced before it is declared.
//   var NonType.hashCode(:int field) = o;
//                                      ^
// pkg/front_end/testcases/patterns/non_type_object_pattern.dart:125:27: Context: This is the declaration of the variable 'o'.
//   final NonType.hashCode(:o) = o;
//                           ^
//
// pkg/front_end/testcases/patterns/non_type_object_pattern.dart:125:32: Error: Local variable 'o' can't be referenced before it is declared.
//   final NonType.hashCode(:o) = o;
//                                ^
// pkg/front_end/testcases/patterns/non_type_object_pattern.dart:125:27: Context: This is the declaration of the variable 'o'.
//   final NonType.hashCode(:o) = o;
//                           ^
//
// pkg/front_end/testcases/patterns/non_type_object_pattern.dart:127:14: Error: 'NonType.hashCode' can't be used as a type because 'NonType' doesn't refer to an import prefix.
//   if (o case NonType.hashCode(:var field)) {}
//              ^^^^^^^^^^^^^^^^
//
// pkg/front_end/testcases/patterns/non_type_object_pattern.dart:130:10: Error: 'NonType.hashCode' can't be used as a type because 'NonType' doesn't refer to an import prefix.
//     case NonType.hashCode(:var field):
//          ^^^^^^^^^^^^^^^^
//
// pkg/front_end/testcases/patterns/non_type_object_pattern.dart:134:5: Error: 'NonType.hashCode' can't be used as a type because 'NonType' doesn't refer to an import prefix.
//     NonType.hashCode(:var field) => "matched",
//     ^^^^^^^^^^^^^^^^
//
import self as self;
import "dart:core" as core;
import "dart:_internal" as _in;

import "org-dartlang-testcase:///non_type_object_pattern.dart" as prefix;

extension Extension on core::int {
}
static field core::int NonType = 0;
static method testUnresolved(dynamic o) → dynamic {
  hoisted has-declared-initializer core::int field;
  {
    final synthesized dynamic #0#0 = o;
    late final synthesized invalid-type #0#2 = (#0#0 as{Unchecked} invalid-type){<invalid>}.field;
    if(!(#0#0 is invalid-type && (#0#2 is core::int && (let final dynamic #t1 = field = #0#2 in true))))
      throw new core::StateError::•("Pattern matching error");
  }
  final hoisted has-declared-initializer invalid-type o;
  {
    final synthesized dynamic #1#0 = o;
    if(!(#1#0 is invalid-type && (let final dynamic #t2 = o = #1#0{invalid-type}{<invalid>}.o in true)))
      throw new core::StateError::•("Pattern matching error");
  }
  {
    hoisted invalid-type field;
    final synthesized dynamic #2#0 = o;
    if(#2#0 is invalid-type && (let final dynamic #t3 = field = #2#0{invalid-type}{<invalid>}.field in true)) {
    }
  }
  #L1:
  {
    final synthesized dynamic #3#0 = o;
    {
      hoisted invalid-type field;
      if(#3#0 is invalid-type && (let final dynamic #t4 = field = #3#0{invalid-type}{<invalid>}.field in true)) {
        {
          break #L1;
        }
      }
    }
  }
  o = block {
    core::String #t5;
    final synthesized dynamic #4#0 = o;
    #L2:
    {
      {
        hoisted invalid-type field;
        if(#4#0 is invalid-type && (let final dynamic #t6 = field = #4#0{invalid-type}{<invalid>}.field in true)) {
          #t5 = "matched";
          break #L2;
        }
      }
      {
        if(true) {
          #t5 = "";
          break #L2;
        }
      }
      throw new _in::ReachabilityError::•("`null` encountered as case in a switch expression with a non-nullable type.");
    }
  } =>#t5;
}
static method testNonType(dynamic o) → dynamic {
  hoisted has-declared-initializer core::int field;
  {
    final synthesized dynamic #0#0 = o;
    late final synthesized invalid-type #0#2 = (#0#0 as{Unchecked} invalid-type){<invalid>}.field;
    if(!(#0#0 is invalid-type && (#0#2 is core::int && (let final dynamic #t7 = field = #0#2 in true))))
      throw new core::StateError::•("Pattern matching error");
  }
  final hoisted has-declared-initializer invalid-type o;
  {
    final synthesized dynamic #1#0 = o;
    if(!(#1#0 is invalid-type && (let final dynamic #t8 = o = #1#0{invalid-type}{<invalid>}.o in true)))
      throw new core::StateError::•("Pattern matching error");
  }
  {
    hoisted invalid-type field;
    final synthesized dynamic #2#0 = o;
    if(#2#0 is invalid-type && (let final dynamic #t9 = field = #2#0{invalid-type}{<invalid>}.field in true)) {
    }
  }
  #L3:
  {
    final synthesized dynamic #3#0 = o;
    {
      hoisted invalid-type field;
      if(#3#0 is invalid-type && (let final dynamic #t10 = field = #3#0{invalid-type}{<invalid>}.field in true)) {
        {
          break #L3;
        }
      }
    }
  }
  o = block {
    core::String #t11;
    final synthesized dynamic #4#0 = o;
    #L4:
    {
      {
        hoisted invalid-type field;
        if(#4#0 is invalid-type && (let final dynamic #t12 = field = #4#0{invalid-type}{<invalid>}.field in true)) {
          #t11 = "matched";
          break #L4;
        }
      }
      {
        if(true) {
          #t11 = "";
          break #L4;
        }
      }
      throw new _in::ReachabilityError::•("`null` encountered as case in a switch expression with a non-nullable type.");
    }
  } =>#t11;
}
static method testExtension(dynamic o) → dynamic {
  hoisted has-declared-initializer core::int field;
  {
    final synthesized dynamic #0#0 = o;
    late final synthesized invalid-type #0#2 = (#0#0 as{Unchecked} invalid-type){<invalid>}.field;
    if(!(#0#0 is invalid-type && (#0#2 is core::int && (let final dynamic #t13 = field = #0#2 in true))))
      throw new core::StateError::•("Pattern matching error");
  }
  final hoisted has-declared-initializer invalid-type o;
  {
    final synthesized dynamic #1#0 = o;
    if(!(#1#0 is invalid-type && (let final dynamic #t14 = o = #1#0{invalid-type}{<invalid>}.o in true)))
      throw new core::StateError::•("Pattern matching error");
  }
  {
    hoisted invalid-type field;
    final synthesized dynamic #2#0 = o;
    if(#2#0 is invalid-type && (let final dynamic #t15 = field = #2#0{invalid-type}{<invalid>}.field in true)) {
    }
  }
  #L5:
  {
    final synthesized dynamic #3#0 = o;
    {
      hoisted invalid-type field;
      if(#3#0 is invalid-type && (let final dynamic #t16 = field = #3#0{invalid-type}{<invalid>}.field in true)) {
        {
          break #L5;
        }
      }
    }
  }
  o = block {
    core::String #t17;
    final synthesized dynamic #4#0 = o;
    #L6:
    {
      {
        hoisted invalid-type field;
        if(#4#0 is invalid-type && (let final dynamic #t18 = field = #4#0{invalid-type}{<invalid>}.field in true)) {
          #t17 = "matched";
          break #L6;
        }
      }
      {
        if(true) {
          #t17 = "";
          break #L6;
        }
      }
      throw new _in::ReachabilityError::•("`null` encountered as case in a switch expression with a non-nullable type.");
    }
  } =>#t17;
}
static method testPrefixedUnresolved(dynamic o) → dynamic {
  hoisted has-declared-initializer core::int field;
  {
    final synthesized dynamic #0#0 = o;
    late final synthesized invalid-type #0#2 = (#0#0 as{Unchecked} invalid-type){<invalid>}.field;
    if(!(#0#0 is invalid-type && (#0#2 is core::int && (let final dynamic #t19 = field = #0#2 in true))))
      throw new core::StateError::•("Pattern matching error");
  }
  final hoisted has-declared-initializer invalid-type o;
  {
    final synthesized dynamic #1#0 = o;
    if(!(#1#0 is invalid-type && (let final dynamic #t20 = o = #1#0{invalid-type}{<invalid>}.o in true)))
      throw new core::StateError::•("Pattern matching error");
  }
  {
    hoisted invalid-type field;
    final synthesized dynamic #2#0 = o;
    if(#2#0 is invalid-type && (let final dynamic #t21 = field = #2#0{invalid-type}{<invalid>}.field in true)) {
    }
  }
  #L7:
  {
    final synthesized dynamic #3#0 = o;
    {
      hoisted invalid-type field;
      if(#3#0 is invalid-type && (let final dynamic #t22 = field = #3#0{invalid-type}{<invalid>}.field in true)) {
        {
          break #L7;
        }
      }
    }
  }
  o = block {
    core::String #t23;
    final synthesized dynamic #4#0 = o;
    #L8:
    {
      {
        hoisted invalid-type field;
        if(#4#0 is invalid-type && (let final dynamic #t24 = field = #4#0{invalid-type}{<invalid>}.field in true)) {
          #t23 = "matched";
          break #L8;
        }
      }
      {
        if(true) {
          #t23 = "";
          break #L8;
        }
      }
      throw new _in::ReachabilityError::•("`null` encountered as case in a switch expression with a non-nullable type.");
    }
  } =>#t23;
}
static method testPrefixedNonType(dynamic o) → dynamic {
  hoisted has-declared-initializer core::int field;
  {
    final synthesized dynamic #0#0 = o;
    late final synthesized invalid-type #0#2 = (#0#0 as{Unchecked} invalid-type){<invalid>}.field;
    if(!(#0#0 is invalid-type && (#0#2 is core::int && (let final dynamic #t25 = field = #0#2 in true))))
      throw new core::StateError::•("Pattern matching error");
  }
  final hoisted has-declared-initializer invalid-type o;
  {
    final synthesized dynamic #1#0 = o;
    if(!(#1#0 is invalid-type && (let final dynamic #t26 = o = #1#0{invalid-type}{<invalid>}.o in true)))
      throw new core::StateError::•("Pattern matching error");
  }
  {
    hoisted invalid-type field;
    final synthesized dynamic #2#0 = o;
    if(#2#0 is invalid-type && (let final dynamic #t27 = field = #2#0{invalid-type}{<invalid>}.field in true)) {
    }
  }
  #L9:
  {
    final synthesized dynamic #3#0 = o;
    {
      hoisted invalid-type field;
      if(#3#0 is invalid-type && (let final dynamic #t28 = field = #3#0{invalid-type}{<invalid>}.field in true)) {
        {
          break #L9;
        }
      }
    }
  }
  o = block {
    core::String #t29;
    final synthesized dynamic #4#0 = o;
    #L10:
    {
      {
        hoisted invalid-type field;
        if(#4#0 is invalid-type && (let final dynamic #t30 = field = #4#0{invalid-type}{<invalid>}.field in true)) {
          #t29 = "matched";
          break #L10;
        }
      }
      {
        if(true) {
          #t29 = "";
          break #L10;
        }
      }
      throw new _in::ReachabilityError::•("`null` encountered as case in a switch expression with a non-nullable type.");
    }
  } =>#t29;
}
static method testPrefixedExtension(dynamic o) → dynamic {
  hoisted has-declared-initializer core::int field;
  {
    final synthesized dynamic #0#0 = o;
    late final synthesized invalid-type #0#2 = (#0#0 as{Unchecked} invalid-type){<invalid>}.field;
    if(!(#0#0 is invalid-type && (#0#2 is core::int && (let final dynamic #t31 = field = #0#2 in true))))
      throw new core::StateError::•("Pattern matching error");
  }
  final hoisted has-declared-initializer invalid-type o;
  {
    final synthesized dynamic #1#0 = o;
    if(!(#1#0 is invalid-type && (let final dynamic #t32 = o = #1#0{invalid-type}{<invalid>}.o in true)))
      throw new core::StateError::•("Pattern matching error");
  }
  {
    hoisted invalid-type field;
    final synthesized dynamic #2#0 = o;
    if(#2#0 is invalid-type && (let final dynamic #t33 = field = #2#0{invalid-type}{<invalid>}.field in true)) {
    }
  }
  #L11:
  {
    final synthesized dynamic #3#0 = o;
    {
      hoisted invalid-type field;
      if(#3#0 is invalid-type && (let final dynamic #t34 = field = #3#0{invalid-type}{<invalid>}.field in true)) {
        {
          break #L11;
        }
      }
    }
  }
  o = block {
    core::String #t35;
    final synthesized dynamic #4#0 = o;
    #L12:
    {
      {
        hoisted invalid-type field;
        if(#4#0 is invalid-type && (let final dynamic #t36 = field = #4#0{invalid-type}{<invalid>}.field in true)) {
          #t35 = "matched";
          break #L12;
        }
      }
      {
        if(true) {
          #t35 = "";
          break #L12;
        }
      }
      throw new _in::ReachabilityError::•("`null` encountered as case in a switch expression with a non-nullable type.");
    }
  } =>#t35;
}
static method testUnresolvedPrefix(dynamic o) → dynamic {
  hoisted has-declared-initializer core::int field;
  {
    final synthesized dynamic #0#0 = o;
    late final synthesized invalid-type #0#2 = (#0#0 as{Unchecked} invalid-type){<invalid>}.field;
    if(!(#0#0 is invalid-type && (#0#2 is core::int && (let final dynamic #t37 = field = #0#2 in true))))
      throw new core::StateError::•("Pattern matching error");
  }
  final hoisted has-declared-initializer invalid-type o;
  {
    final synthesized dynamic #1#0 = o;
    if(!(#1#0 is invalid-type && (let final dynamic #t38 = o = #1#0{invalid-type}{<invalid>}.o in true)))
      throw new core::StateError::•("Pattern matching error");
  }
  {
    hoisted invalid-type field;
    final synthesized dynamic #2#0 = o;
    if(#2#0 is invalid-type && (let final dynamic #t39 = field = #2#0{invalid-type}{<invalid>}.field in true)) {
    }
  }
  #L13:
  {
    final synthesized dynamic #3#0 = o;
    {
      hoisted invalid-type field;
      if(#3#0 is invalid-type && (let final dynamic #t40 = field = #3#0{invalid-type}{<invalid>}.field in true)) {
        {
          break #L13;
        }
      }
    }
  }
  o = block {
    core::String #t41;
    final synthesized dynamic #4#0 = o;
    #L14:
    {
      {
        hoisted invalid-type field;
        if(#4#0 is invalid-type && (let final dynamic #t42 = field = #4#0{invalid-type}{<invalid>}.field in true)) {
          #t41 = "matched";
          break #L14;
        }
      }
      {
        if(true) {
          #t41 = "";
          break #L14;
        }
      }
      throw new _in::ReachabilityError::•("`null` encountered as case in a switch expression with a non-nullable type.");
    }
  } =>#t41;
}
static method testMemberAccess(dynamic o) → dynamic {
  hoisted has-declared-initializer core::int field;
  {
    final synthesized dynamic #0#0 = o;
    late final synthesized invalid-type #0#2 = (#0#0 as{Unchecked} invalid-type){<invalid>}.field;
    if(!(#0#0 is invalid-type && (#0#2 is core::int && (let final dynamic #t43 = field = #0#2 in true))))
      throw new core::StateError::•("Pattern matching error");
  }
  final hoisted has-declared-initializer invalid-type o;
  {
    final synthesized dynamic #1#0 = o;
    if(!(#1#0 is invalid-type && (let final dynamic #t44 = o = #1#0{invalid-type}{<invalid>}.o in true)))
      throw new core::StateError::•("Pattern matching error");
  }
  {
    hoisted invalid-type field;
    final synthesized dynamic #2#0 = o;
    if(#2#0 is invalid-type && (let final dynamic #t45 = field = #2#0{invalid-type}{<invalid>}.field in true)) {
    }
  }
  #L15:
  {
    final synthesized dynamic #3#0 = o;
    {
      hoisted invalid-type field;
      if(#3#0 is invalid-type && (let final dynamic #t46 = field = #3#0{invalid-type}{<invalid>}.field in true)) {
        {
          break #L15;
        }
      }
    }
  }
  o = block {
    core::String #t47;
    final synthesized dynamic #4#0 = o;
    #L16:
    {
      {
        hoisted invalid-type field;
        if(#4#0 is invalid-type && (let final dynamic #t48 = field = #4#0{invalid-type}{<invalid>}.field in true)) {
          #t47 = "matched";
          break #L16;
        }
      }
      {
        if(true) {
          #t47 = "";
          break #L16;
        }
      }
      throw new _in::ReachabilityError::•("`null` encountered as case in a switch expression with a non-nullable type.");
    }
  } =>#t47;
}
