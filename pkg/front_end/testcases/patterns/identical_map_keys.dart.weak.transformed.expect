library;
//
// Problems in library:
//
// pkg/front_end/testcases/patterns/identical_map_keys.dart:55:14: Error: Variable patterns in declaration context can't specify 'var' or 'final' keyword.
// Try removing the keyword.
//   final {c1: var a1, c2: final b1} = {c2: 2};
//              ^^^
//
// pkg/front_end/testcases/patterns/identical_map_keys.dart:55:26: Error: Variable patterns in declaration context can't specify 'var' or 'final' keyword.
// Try removing the keyword.
//   final {c1: var a1, c2: final b1} = {c2: 2};
//                          ^^^^^
//
// pkg/front_end/testcases/patterns/identical_map_keys.dart:56:16: Error: Variable patterns in declaration context can't specify 'var' or 'final' keyword.
// Try removing the keyword.
//   final {3.14: var a2, 3.14: final b2} = {3.14: 1};
//                ^^^
//
// pkg/front_end/testcases/patterns/identical_map_keys.dart:56:30: Error: Variable patterns in declaration context can't specify 'var' or 'final' keyword.
// Try removing the keyword.
//   final {3.14: var a2, 3.14: final b2} = {3.14: 1};
//                              ^^^^^
//
// pkg/front_end/testcases/patterns/identical_map_keys.dart:57:15: Error: Variable patterns in declaration context can't specify 'var' or 'final' keyword.
// Try removing the keyword.
//   final {"x": var a3, "x": final b3} = {"x": 1};
//               ^^^
//
// pkg/front_end/testcases/patterns/identical_map_keys.dart:57:28: Error: Variable patterns in declaration context can't specify 'var' or 'final' keyword.
// Try removing the keyword.
//   final {"x": var a3, "x": final b3} = {"x": 1};
//                            ^^^^^
//
// pkg/front_end/testcases/patterns/identical_map_keys.dart:16:26: Error: Two keys in a map pattern can't be equal.
// Change or remove the duplicate key.
//     {const C(): 1, const C(): 2} => "",
//                          ^
// pkg/front_end/testcases/patterns/identical_map_keys.dart:16:12: Context: This is the previous use of the same key.
//     {const C(): 1, const C(): 2} => "",
//            ^
//
// pkg/front_end/testcases/patterns/identical_map_keys.dart:17:12: Error: Two keys in a map pattern can't be equal.
// Change or remove the duplicate key.
//     {1: 1, 1: 2} => "",
//            ^
// pkg/front_end/testcases/patterns/identical_map_keys.dart:17:6: Context: This is the previous use of the same key.
//     {1: 1, 1: 2} => "",
//      ^
//
// pkg/front_end/testcases/patterns/identical_map_keys.dart:18:18: Error: Two keys in a map pattern can't be equal.
// Change or remove the duplicate key.
//     {c1: var a1, c2: final b1} => "",
//                  ^
// pkg/front_end/testcases/patterns/identical_map_keys.dart:18:6: Context: This is the previous use of the same key.
//     {c1: var a1, c2: final b1} => "",
//      ^
//
// pkg/front_end/testcases/patterns/identical_map_keys.dart:19:20: Error: Two keys in a map pattern can't be equal.
// Change or remove the duplicate key.
//     {3.14: var a2, 3.14: final b2} => "",
//                    ^
// pkg/front_end/testcases/patterns/identical_map_keys.dart:19:6: Context: This is the previous use of the same key.
//     {3.14: var a2, 3.14: final b2} => "",
//      ^
//
// pkg/front_end/testcases/patterns/identical_map_keys.dart:20:19: Error: Two keys in a map pattern can't be equal.
// Change or remove the duplicate key.
//     {"x": var a3, "x": final b3} => "",
//                   ^
// pkg/front_end/testcases/patterns/identical_map_keys.dart:20:6: Context: This is the previous use of the same key.
//     {"x": var a3, "x": final b3} => "",
//      ^
//
// pkg/front_end/testcases/patterns/identical_map_keys.dart:27:31: Error: Two keys in a map pattern can't be equal.
// Change or remove the duplicate key.
//     case {const C(): 1, const C(): 2}:
//                               ^
// pkg/front_end/testcases/patterns/identical_map_keys.dart:27:17: Context: This is the previous use of the same key.
//     case {const C(): 1, const C(): 2}:
//                 ^
//
// pkg/front_end/testcases/patterns/identical_map_keys.dart:29:17: Error: Two keys in a map pattern can't be equal.
// Change or remove the duplicate key.
//     case {1: 1, 1: 2}:
//                 ^
// pkg/front_end/testcases/patterns/identical_map_keys.dart:29:11: Context: This is the previous use of the same key.
//     case {1: 1, 1: 2}:
//           ^
//
// pkg/front_end/testcases/patterns/identical_map_keys.dart:31:23: Error: Two keys in a map pattern can't be equal.
// Change or remove the duplicate key.
//     case {c1: var a1, c2: final b1}:
//                       ^
// pkg/front_end/testcases/patterns/identical_map_keys.dart:31:11: Context: This is the previous use of the same key.
//     case {c1: var a1, c2: final b1}:
//           ^
//
// pkg/front_end/testcases/patterns/identical_map_keys.dart:32:25: Error: Two keys in a map pattern can't be equal.
// Change or remove the duplicate key.
//     case {3.14: var a2, 3.14: final b2}:
//                         ^
// pkg/front_end/testcases/patterns/identical_map_keys.dart:32:11: Context: This is the previous use of the same key.
//     case {3.14: var a2, 3.14: final b2}:
//           ^
//
// pkg/front_end/testcases/patterns/identical_map_keys.dart:34:24: Error: Two keys in a map pattern can't be equal.
// Change or remove the duplicate key.
//     case {"x": var a3, "x": final b3}:
//                        ^
// pkg/front_end/testcases/patterns/identical_map_keys.dart:34:11: Context: This is the previous use of the same key.
//     case {"x": var a3, "x": final b3}:
//           ^
//
// pkg/front_end/testcases/patterns/identical_map_keys.dart:40:37: Error: Two keys in a map pattern can't be equal.
// Change or remove the duplicate key.
//   if (map case {const C(): 1, const C(): 2}) {
//                                     ^
// pkg/front_end/testcases/patterns/identical_map_keys.dart:40:23: Context: This is the previous use of the same key.
//   if (map case {const C(): 1, const C(): 2}) {
//                       ^
//
// pkg/front_end/testcases/patterns/identical_map_keys.dart:42:23: Error: Two keys in a map pattern can't be equal.
// Change or remove the duplicate key.
//   if (map case {1: 1, 1: 2}) {
//                       ^
// pkg/front_end/testcases/patterns/identical_map_keys.dart:42:17: Context: This is the previous use of the same key.
//   if (map case {1: 1, 1: 2}) {
//                 ^
//
// pkg/front_end/testcases/patterns/identical_map_keys.dart:44:29: Error: Two keys in a map pattern can't be equal.
// Change or remove the duplicate key.
//   if (map case {c1: var a1, c2: final b1}) {
//                             ^
// pkg/front_end/testcases/patterns/identical_map_keys.dart:44:17: Context: This is the previous use of the same key.
//   if (map case {c1: var a1, c2: final b1}) {
//                 ^
//
// pkg/front_end/testcases/patterns/identical_map_keys.dart:46:31: Error: Two keys in a map pattern can't be equal.
// Change or remove the duplicate key.
//   if (map case {3.14: var a2, 3.14: final b2}) {
//                               ^
// pkg/front_end/testcases/patterns/identical_map_keys.dart:46:17: Context: This is the previous use of the same key.
//   if (map case {3.14: var a2, 3.14: final b2}) {
//                 ^
//
// pkg/front_end/testcases/patterns/identical_map_keys.dart:48:30: Error: Two keys in a map pattern can't be equal.
// Change or remove the duplicate key.
//   if (map case {"x": var a3, "x": final b3}) {
//                              ^
// pkg/front_end/testcases/patterns/identical_map_keys.dart:48:17: Context: This is the previous use of the same key.
//   if (map case {"x": var a3, "x": final b3}) {
//                 ^
//
// pkg/front_end/testcases/patterns/identical_map_keys.dart:53:28: Error: Two keys in a map pattern can't be equal.
// Change or remove the duplicate key.
//   var {const C(): a, const C(): b} = {const C(): 1};
//                            ^
// pkg/front_end/testcases/patterns/identical_map_keys.dart:53:14: Context: This is the previous use of the same key.
//   var {const C(): a, const C(): b} = {const C(): 1};
//              ^
//
// pkg/front_end/testcases/patterns/identical_map_keys.dart:54:14: Error: Two keys in a map pattern can't be equal.
// Change or remove the duplicate key.
//   var {1: c, 1: d} = {1: 2};
//              ^
// pkg/front_end/testcases/patterns/identical_map_keys.dart:54:8: Context: This is the previous use of the same key.
//   var {1: c, 1: d} = {1: 2};
//        ^
//
// pkg/front_end/testcases/patterns/identical_map_keys.dart:55:22: Error: Two keys in a map pattern can't be equal.
// Change or remove the duplicate key.
//   final {c1: var a1, c2: final b1} = {c2: 2};
//                      ^
// pkg/front_end/testcases/patterns/identical_map_keys.dart:55:10: Context: This is the previous use of the same key.
//   final {c1: var a1, c2: final b1} = {c2: 2};
//          ^
//
// pkg/front_end/testcases/patterns/identical_map_keys.dart:56:24: Error: Two keys in a map pattern can't be equal.
// Change or remove the duplicate key.
//   final {3.14: var a2, 3.14: final b2} = {3.14: 1};
//                        ^
// pkg/front_end/testcases/patterns/identical_map_keys.dart:56:10: Context: This is the previous use of the same key.
//   final {3.14: var a2, 3.14: final b2} = {3.14: 1};
//          ^
//
// pkg/front_end/testcases/patterns/identical_map_keys.dart:57:23: Error: Two keys in a map pattern can't be equal.
// Change or remove the duplicate key.
//   final {"x": var a3, "x": final b3} = {"x": 1};
//                       ^
// pkg/front_end/testcases/patterns/identical_map_keys.dart:57:10: Context: This is the previous use of the same key.
//   final {"x": var a3, "x": final b3} = {"x": 1};
//          ^
//
import self as self;
import "dart:core" as core;
import "dart:_internal" as _in;

class C extends core::Object /*hasConstConstructor*/  {
  const constructor •() → self::C
    : super core::Object::•()
    ;
}
static const field self::C c1 = #C1;
static const field self::C c2 = #C1;
static method test1(core::Map<dynamic, dynamic> map) → core::String {
  return block {
    core::String #t1;
    final synthesized core::Map<dynamic, dynamic> #0#0 = map;
    synthesized core::bool #0#2;
    synthesized core::bool #0#2#isSet = false;
    synthesized dynamic #0#3;
    synthesized core::bool #0#3#isSet = false;
    synthesized core::bool #0#8;
    synthesized core::bool #0#8#isSet = false;
    synthesized dynamic #0#9;
    synthesized core::bool #0#9#isSet = false;
    synthesized core::bool #0#13;
    synthesized core::bool #0#13#isSet = false;
    synthesized dynamic #0#14;
    synthesized core::bool #0#14#isSet = false;
    synthesized core::bool #0#16;
    synthesized core::bool #0#16#isSet = false;
    synthesized dynamic #0#17;
    synthesized core::bool #0#17#isSet = false;
    #L1:
    {
      {
        if((#0#2#isSet ?{core::bool} #0#2{core::bool} : let final core::bool* #t2 = #0#2#isSet = true in #0#2 = #0#0.{core::Map::containsKey}(#C1){(core::Object?) → core::bool}) && #C2 =={core::num::==}{(core::Object) → core::bool} (#0#3#isSet ?{dynamic} #0#3{dynamic} : let final core::bool* #t3 = #0#3#isSet = true in #0#3 = #0#0.{core::Map::[]}(#C1){(core::Object?) → dynamic}) && (#0#2#isSet ?{core::bool} #0#2{core::bool} : let final core::bool* #t4 = #0#2#isSet = true in #0#2 = #0#0.{core::Map::containsKey}(#C1){(core::Object?) → core::bool}) && #C3 =={core::num::==}{(core::Object) → core::bool} (#0#3#isSet ?{dynamic} #0#3{dynamic} : let final core::bool* #t5 = #0#3#isSet = true in #0#3 = #0#0.{core::Map::[]}(#C1){(core::Object?) → dynamic})) {
          #t1 = "";
          break #L1;
        }
      }
      {
        if((#0#8#isSet ?{core::bool} #0#8{core::bool} : let final core::bool* #t6 = #0#8#isSet = true in #0#8 = #0#0.{core::Map::containsKey}(#C2){(core::Object?) → core::bool}) && #C2 =={core::num::==}{(core::Object) → core::bool} (#0#9#isSet ?{dynamic} #0#9{dynamic} : let final core::bool* #t7 = #0#9#isSet = true in #0#9 = #0#0.{core::Map::[]}(#C2){(core::Object?) → dynamic}) && (#0#8#isSet ?{core::bool} #0#8{core::bool} : let final core::bool* #t8 = #0#8#isSet = true in #0#8 = #0#0.{core::Map::containsKey}(#C2){(core::Object?) → core::bool}) && #C3 =={core::num::==}{(core::Object) → core::bool} (#0#9#isSet ?{dynamic} #0#9{dynamic} : let final core::bool* #t9 = #0#9#isSet = true in #0#9 = #0#0.{core::Map::[]}(#C2){(core::Object?) → dynamic})) {
          #t1 = "";
          break #L1;
        }
      }
      {
        hoisted dynamic a1;
        final hoisted dynamic b1;
        if((#0#2#isSet ?{core::bool} #0#2{core::bool} : let final core::bool* #t10 = #0#2#isSet = true in #0#2 = #0#0.{core::Map::containsKey}(#C1){(core::Object?) → core::bool}) && (let final dynamic #t11 = a1 = #0#3#isSet ?{dynamic} #0#3{dynamic} : let final core::bool* #t12 = #0#3#isSet = true in #0#3 = #0#0.{core::Map::[]}(#C1){(core::Object?) → dynamic} in true) && (#0#2#isSet ?{core::bool} #0#2{core::bool} : let final core::bool* #t13 = #0#2#isSet = true in #0#2 = #0#0.{core::Map::containsKey}(#C1){(core::Object?) → core::bool})) {
          b1 = #0#3#isSet ?{dynamic} #0#3{dynamic} : let final core::bool* #t14 = #0#3#isSet = true in #0#3 = #0#0.{core::Map::[]}(#C1){(core::Object?) → dynamic};
          #t1 = "";
          break #L1;
        }
      }
      {
        hoisted dynamic a2;
        final hoisted dynamic b2;
        if((#0#13#isSet ?{core::bool} #0#13{core::bool} : let final core::bool* #t15 = #0#13#isSet = true in #0#13 = #0#0.{core::Map::containsKey}(#C4){(core::Object?) → core::bool}) && (let final dynamic #t16 = a2 = #0#14#isSet ?{dynamic} #0#14{dynamic} : let final core::bool* #t17 = #0#14#isSet = true in #0#14 = #0#0.{core::Map::[]}(#C4){(core::Object?) → dynamic} in true) && (#0#13#isSet ?{core::bool} #0#13{core::bool} : let final core::bool* #t18 = #0#13#isSet = true in #0#13 = #0#0.{core::Map::containsKey}(#C4){(core::Object?) → core::bool})) {
          b2 = #0#14#isSet ?{dynamic} #0#14{dynamic} : let final core::bool* #t19 = #0#14#isSet = true in #0#14 = #0#0.{core::Map::[]}(#C4){(core::Object?) → dynamic};
          #t1 = "";
          break #L1;
        }
      }
      {
        hoisted dynamic a3;
        final hoisted dynamic b3;
        if((#0#16#isSet ?{core::bool} #0#16{core::bool} : let final core::bool* #t20 = #0#16#isSet = true in #0#16 = #0#0.{core::Map::containsKey}(#C5){(core::Object?) → core::bool}) && (let final dynamic #t21 = a3 = #0#17#isSet ?{dynamic} #0#17{dynamic} : let final core::bool* #t22 = #0#17#isSet = true in #0#17 = #0#0.{core::Map::[]}(#C5){(core::Object?) → dynamic} in true) && (#0#16#isSet ?{core::bool} #0#16{core::bool} : let final core::bool* #t23 = #0#16#isSet = true in #0#16 = #0#0.{core::Map::containsKey}(#C5){(core::Object?) → core::bool})) {
          b3 = #0#17#isSet ?{dynamic} #0#17{dynamic} : let final core::bool* #t24 = #0#17#isSet = true in #0#17 = #0#0.{core::Map::[]}(#C5){(core::Object?) → dynamic};
          #t1 = "";
          break #L1;
        }
      }
      {
        if(true) {
          #t1 = "default";
          break #L1;
        }
      }
      throw new _in::ReachabilityError::•("`null` encountered as case in a switch expression with a non-nullable type.");
    }
  } =>#t1;
}
static method test2(core::Map<dynamic, dynamic> map) → void {
  #L2:
  {
    final synthesized core::Map<dynamic, dynamic> #0#0 = map;
    synthesized core::bool #0#2;
    synthesized core::bool #0#2#isSet = false;
    synthesized dynamic #0#3;
    synthesized core::bool #0#3#isSet = false;
    synthesized core::bool #0#8;
    synthesized core::bool #0#8#isSet = false;
    synthesized dynamic #0#9;
    synthesized core::bool #0#9#isSet = false;
    synthesized core::bool #0#13;
    synthesized core::bool #0#13#isSet = false;
    synthesized dynamic #0#14;
    synthesized core::bool #0#14#isSet = false;
    synthesized core::bool #0#16;
    synthesized core::bool #0#16#isSet = false;
    synthesized dynamic #0#17;
    synthesized core::bool #0#17#isSet = false;
    {
      if((#0#2#isSet ?{core::bool} #0#2{core::bool} : let final core::bool* #t25 = #0#2#isSet = true in #0#2 = #0#0.{core::Map::containsKey}(#C1){(core::Object?) → core::bool}) && #C2 =={core::num::==}{(core::Object) → core::bool} (#0#3#isSet ?{dynamic} #0#3{dynamic} : let final core::bool* #t26 = #0#3#isSet = true in #0#3 = #0#0.{core::Map::[]}(#C1){(core::Object?) → dynamic}) && (#0#2#isSet ?{core::bool} #0#2{core::bool} : let final core::bool* #t27 = #0#2#isSet = true in #0#2 = #0#0.{core::Map::containsKey}(#C1){(core::Object?) → core::bool}) && #C3 =={core::num::==}{(core::Object) → core::bool} (#0#3#isSet ?{dynamic} #0#3{dynamic} : let final core::bool* #t28 = #0#3#isSet = true in #0#3 = #0#0.{core::Map::[]}(#C1){(core::Object?) → dynamic})) {
        {
          break #L2;
        }
      }
    }
    {
      if((#0#8#isSet ?{core::bool} #0#8{core::bool} : let final core::bool* #t29 = #0#8#isSet = true in #0#8 = #0#0.{core::Map::containsKey}(#C2){(core::Object?) → core::bool}) && #C2 =={core::num::==}{(core::Object) → core::bool} (#0#9#isSet ?{dynamic} #0#9{dynamic} : let final core::bool* #t30 = #0#9#isSet = true in #0#9 = #0#0.{core::Map::[]}(#C2){(core::Object?) → dynamic}) && (#0#8#isSet ?{core::bool} #0#8{core::bool} : let final core::bool* #t31 = #0#8#isSet = true in #0#8 = #0#0.{core::Map::containsKey}(#C2){(core::Object?) → core::bool}) && #C3 =={core::num::==}{(core::Object) → core::bool} (#0#9#isSet ?{dynamic} #0#9{dynamic} : let final core::bool* #t32 = #0#9#isSet = true in #0#9 = #0#0.{core::Map::[]}(#C2){(core::Object?) → dynamic})) {
        {
          break #L2;
        }
      }
    }
    {
      hoisted dynamic a1;
      final hoisted dynamic b1;
      hoisted dynamic a2;
      final hoisted dynamic b2;
      if((#0#2#isSet ?{core::bool} #0#2{core::bool} : let final core::bool* #t33 = #0#2#isSet = true in #0#2 = #0#0.{core::Map::containsKey}(#C1){(core::Object?) → core::bool}) && (let final dynamic #t34 = a1 = #0#3#isSet ?{dynamic} #0#3{dynamic} : let final core::bool* #t35 = #0#3#isSet = true in #0#3 = #0#0.{core::Map::[]}(#C1){(core::Object?) → dynamic} in true) && (#0#2#isSet ?{core::bool} #0#2{core::bool} : let final core::bool* #t36 = #0#2#isSet = true in #0#2 = #0#0.{core::Map::containsKey}(#C1){(core::Object?) → core::bool}) && (let final dynamic #t37 = b1 = #0#3#isSet ?{dynamic} #0#3{dynamic} : let final core::bool* #t38 = #0#3#isSet = true in #0#3 = #0#0.{core::Map::[]}(#C1){(core::Object?) → dynamic} in true) || (#0#13#isSet ?{core::bool} #0#13{core::bool} : let final core::bool* #t39 = #0#13#isSet = true in #0#13 = #0#0.{core::Map::containsKey}(#C4){(core::Object?) → core::bool}) && (let final dynamic #t40 = a2 = #0#14#isSet ?{dynamic} #0#14{dynamic} : let final core::bool* #t41 = #0#14#isSet = true in #0#14 = #0#0.{core::Map::[]}(#C4){(core::Object?) → dynamic} in true) && (#0#13#isSet ?{core::bool} #0#13{core::bool} : let final core::bool* #t42 = #0#13#isSet = true in #0#13 = #0#0.{core::Map::containsKey}(#C4){(core::Object?) → core::bool}) && (let final dynamic #t43 = b2 = #0#14#isSet ?{dynamic} #0#14{dynamic} : let final core::bool* #t44 = #0#14#isSet = true in #0#14 = #0#0.{core::Map::[]}(#C4){(core::Object?) → dynamic} in true)) {
        {
          break #L2;
        }
      }
    }
    {
      hoisted dynamic a3;
      final hoisted dynamic b3;
      if((#0#16#isSet ?{core::bool} #0#16{core::bool} : let final core::bool* #t45 = #0#16#isSet = true in #0#16 = #0#0.{core::Map::containsKey}(#C5){(core::Object?) → core::bool}) && (let final dynamic #t46 = a3 = #0#17#isSet ?{dynamic} #0#17{dynamic} : let final core::bool* #t47 = #0#17#isSet = true in #0#17 = #0#0.{core::Map::[]}(#C5){(core::Object?) → dynamic} in true) && (#0#16#isSet ?{core::bool} #0#16{core::bool} : let final core::bool* #t48 = #0#16#isSet = true in #0#16 = #0#0.{core::Map::containsKey}(#C5){(core::Object?) → core::bool}) && (let final dynamic #t49 = b3 = #0#17#isSet ?{dynamic} #0#17{dynamic} : let final core::bool* #t50 = #0#17#isSet = true in #0#17 = #0#0.{core::Map::[]}(#C5){(core::Object?) → dynamic} in true)) {
        {
          break #L2;
        }
      }
    }
  }
}
static method test3(core::Map<dynamic, dynamic> map) → void {
  {
    final synthesized core::Map<dynamic, dynamic> #0#0 = map;
    synthesized core::bool #0#2;
    synthesized core::bool #0#2#isSet = false;
    synthesized dynamic #0#3;
    synthesized core::bool #0#3#isSet = false;
    if((#0#2#isSet ?{core::bool} #0#2{core::bool} : let final core::bool* #t51 = #0#2#isSet = true in #0#2 = #0#0.{core::Map::containsKey}(#C1){(core::Object?) → core::bool}) && #C2 =={core::num::==}{(core::Object) → core::bool} (#0#3#isSet ?{dynamic} #0#3{dynamic} : let final core::bool* #t52 = #0#3#isSet = true in #0#3 = #0#0.{core::Map::[]}(#C1){(core::Object?) → dynamic}) && (#0#2#isSet ?{core::bool} #0#2{core::bool} : let final core::bool* #t53 = #0#2#isSet = true in #0#2 = #0#0.{core::Map::containsKey}(#C1){(core::Object?) → core::bool}) && #C3 =={core::num::==}{(core::Object) → core::bool} (#0#3#isSet ?{dynamic} #0#3{dynamic} : let final core::bool* #t54 = #0#3#isSet = true in #0#3 = #0#0.{core::Map::[]}(#C1){(core::Object?) → dynamic})) {
    }
  }
  {
    final synthesized core::Map<dynamic, dynamic> #1#0 = map;
    synthesized core::bool #1#2;
    synthesized core::bool #1#2#isSet = false;
    synthesized dynamic #1#3;
    synthesized core::bool #1#3#isSet = false;
    if((#1#2#isSet ?{core::bool} #1#2{core::bool} : let final core::bool* #t55 = #1#2#isSet = true in #1#2 = #1#0.{core::Map::containsKey}(#C2){(core::Object?) → core::bool}) && #C2 =={core::num::==}{(core::Object) → core::bool} (#1#3#isSet ?{dynamic} #1#3{dynamic} : let final core::bool* #t56 = #1#3#isSet = true in #1#3 = #1#0.{core::Map::[]}(#C2){(core::Object?) → dynamic}) && (#1#2#isSet ?{core::bool} #1#2{core::bool} : let final core::bool* #t57 = #1#2#isSet = true in #1#2 = #1#0.{core::Map::containsKey}(#C2){(core::Object?) → core::bool}) && #C3 =={core::num::==}{(core::Object) → core::bool} (#1#3#isSet ?{dynamic} #1#3{dynamic} : let final core::bool* #t58 = #1#3#isSet = true in #1#3 = #1#0.{core::Map::[]}(#C2){(core::Object?) → dynamic})) {
    }
  }
  {
    final synthesized core::Map<dynamic, dynamic> #2#0 = map;
    synthesized core::bool #2#2;
    synthesized core::bool #2#2#isSet = false;
    synthesized dynamic #2#3;
    synthesized core::bool #2#3#isSet = false;
    {
      hoisted dynamic a1;
      final hoisted dynamic b1;
      if((#2#2#isSet ?{core::bool} #2#2{core::bool} : let final core::bool* #t59 = #2#2#isSet = true in #2#2 = #2#0.{core::Map::containsKey}(#C1){(core::Object?) → core::bool}) && (let final dynamic #t60 = a1 = #2#3#isSet ?{dynamic} #2#3{dynamic} : let final core::bool* #t61 = #2#3#isSet = true in #2#3 = #2#0.{core::Map::[]}(#C1){(core::Object?) → dynamic} in true) && (#2#2#isSet ?{core::bool} #2#2{core::bool} : let final core::bool* #t62 = #2#2#isSet = true in #2#2 = #2#0.{core::Map::containsKey}(#C1){(core::Object?) → core::bool})) {
        b1 = #2#3#isSet ?{dynamic} #2#3{dynamic} : let final core::bool* #t63 = #2#3#isSet = true in #2#3 = #2#0.{core::Map::[]}(#C1){(core::Object?) → dynamic};
        {}
      }
    }
  }
  {
    final synthesized core::Map<dynamic, dynamic> #3#0 = map;
    synthesized core::bool #3#2;
    synthesized core::bool #3#2#isSet = false;
    synthesized dynamic #3#3;
    synthesized core::bool #3#3#isSet = false;
    {
      hoisted dynamic a2;
      final hoisted dynamic b2;
      if((#3#2#isSet ?{core::bool} #3#2{core::bool} : let final core::bool* #t64 = #3#2#isSet = true in #3#2 = #3#0.{core::Map::containsKey}(#C4){(core::Object?) → core::bool}) && (let final dynamic #t65 = a2 = #3#3#isSet ?{dynamic} #3#3{dynamic} : let final core::bool* #t66 = #3#3#isSet = true in #3#3 = #3#0.{core::Map::[]}(#C4){(core::Object?) → dynamic} in true) && (#3#2#isSet ?{core::bool} #3#2{core::bool} : let final core::bool* #t67 = #3#2#isSet = true in #3#2 = #3#0.{core::Map::containsKey}(#C4){(core::Object?) → core::bool})) {
        b2 = #3#3#isSet ?{dynamic} #3#3{dynamic} : let final core::bool* #t68 = #3#3#isSet = true in #3#3 = #3#0.{core::Map::[]}(#C4){(core::Object?) → dynamic};
        {}
      }
    }
  }
  {
    final synthesized core::Map<dynamic, dynamic> #4#0 = map;
    synthesized core::bool #4#2;
    synthesized core::bool #4#2#isSet = false;
    synthesized dynamic #4#3;
    synthesized core::bool #4#3#isSet = false;
    {
      hoisted dynamic a3;
      final hoisted dynamic b3;
      if((#4#2#isSet ?{core::bool} #4#2{core::bool} : let final core::bool* #t69 = #4#2#isSet = true in #4#2 = #4#0.{core::Map::containsKey}(#C5){(core::Object?) → core::bool}) && (let final dynamic #t70 = a3 = #4#3#isSet ?{dynamic} #4#3{dynamic} : let final core::bool* #t71 = #4#3#isSet = true in #4#3 = #4#0.{core::Map::[]}(#C5){(core::Object?) → dynamic} in true) && (#4#2#isSet ?{core::bool} #4#2{core::bool} : let final core::bool* #t72 = #4#2#isSet = true in #4#2 = #4#0.{core::Map::containsKey}(#C5){(core::Object?) → core::bool})) {
        b3 = #4#3#isSet ?{dynamic} #4#3{dynamic} : let final core::bool* #t73 = #4#3#isSet = true in #4#3 = #4#0.{core::Map::[]}(#C5){(core::Object?) → dynamic};
        {}
      }
    }
  }
}
static method test() → dynamic {
  hoisted has-declared-initializer core::int a;
  hoisted has-declared-initializer core::int b;
  {
    final synthesized core::Map<self::C, core::int> #0#0 = <self::C, core::int>{#C1: 1};
    synthesized core::bool #0#2;
    synthesized core::bool #0#2#isSet = false;
    synthesized core::int? #0#3;
    synthesized core::bool #0#3#isSet = false;
    if(!((#0#2#isSet ?{core::bool} #0#2{core::bool} : let final core::bool* #t74 = #0#2#isSet = true in #0#2 = #0#0.{core::Map::containsKey}(#C1){(core::Object?) → core::bool}) && (let final core::int #t75 = a = #0#3#isSet ?{core::int?} #0#3{core::int?} : let final core::bool* #t76 = #0#3#isSet = true in #0#3 = #0#0.{core::Map::[]}(#C1){(core::Object?) → core::int?} in true) && (#0#2#isSet ?{core::bool} #0#2{core::bool} : let final core::bool* #t77 = #0#2#isSet = true in #0#2 = #0#0.{core::Map::containsKey}(#C1){(core::Object?) → core::bool}) && (let final core::int #t78 = b = #0#3#isSet ?{core::int?} #0#3{core::int?} : let final core::bool* #t79 = #0#3#isSet = true in #0#3 = #0#0.{core::Map::[]}(#C1){(core::Object?) → core::int?} in true)))
      throw new core::StateError::•("Pattern matching error");
  }
  hoisted has-declared-initializer core::int c;
  hoisted has-declared-initializer core::int d;
  {
    final synthesized core::Map<core::int, core::int> #1#0 = <core::int, core::int>{1: 2};
    synthesized core::bool #1#2;
    synthesized core::bool #1#2#isSet = false;
    synthesized core::int? #1#3;
    synthesized core::bool #1#3#isSet = false;
    if(!((#1#2#isSet ?{core::bool} #1#2{core::bool} : let final core::bool* #t80 = #1#2#isSet = true in #1#2 = #1#0.{core::Map::containsKey}(#C2){(core::Object?) → core::bool}) && (let final core::int #t81 = c = #1#3#isSet ?{core::int?} #1#3{core::int?} : let final core::bool* #t82 = #1#3#isSet = true in #1#3 = #1#0.{core::Map::[]}(#C2){(core::Object?) → core::int?} in true) && (#1#2#isSet ?{core::bool} #1#2{core::bool} : let final core::bool* #t83 = #1#2#isSet = true in #1#2 = #1#0.{core::Map::containsKey}(#C2){(core::Object?) → core::bool}) && (let final core::int #t84 = d = #1#3#isSet ?{core::int?} #1#3{core::int?} : let final core::bool* #t85 = #1#3#isSet = true in #1#3 = #1#0.{core::Map::[]}(#C2){(core::Object?) → core::int?} in true)))
      throw new core::StateError::•("Pattern matching error");
  }
  final hoisted has-declared-initializer core::int a1;
  final hoisted has-declared-initializer core::int b1;
  {
    final synthesized core::Map<self::C, core::int> #2#0 = <self::C, core::int>{#C1: 2};
    synthesized core::bool #2#2;
    synthesized core::bool #2#2#isSet = false;
    synthesized core::int? #2#3;
    synthesized core::bool #2#3#isSet = false;
    if(!((#2#2#isSet ?{core::bool} #2#2{core::bool} : let final core::bool* #t86 = #2#2#isSet = true in #2#2 = #2#0.{core::Map::containsKey}(#C1){(core::Object?) → core::bool}) && (let final core::int #t87 = a1 = #2#3#isSet ?{core::int?} #2#3{core::int?} : let final core::bool* #t88 = #2#3#isSet = true in #2#3 = #2#0.{core::Map::[]}(#C1){(core::Object?) → core::int?} in true) && (#2#2#isSet ?{core::bool} #2#2{core::bool} : let final core::bool* #t89 = #2#2#isSet = true in #2#2 = #2#0.{core::Map::containsKey}(#C1){(core::Object?) → core::bool}) && (let final core::int #t90 = b1 = #2#3#isSet ?{core::int?} #2#3{core::int?} : let final core::bool* #t91 = #2#3#isSet = true in #2#3 = #2#0.{core::Map::[]}(#C1){(core::Object?) → core::int?} in true)))
      throw new core::StateError::•("Pattern matching error");
  }
  final hoisted has-declared-initializer core::int a2;
  final hoisted has-declared-initializer core::int b2;
  {
    final synthesized core::Map<core::double, core::int> #3#0 = <core::double, core::int>{3.14: 1};
    synthesized core::bool #3#2;
    synthesized core::bool #3#2#isSet = false;
    synthesized core::int? #3#3;
    synthesized core::bool #3#3#isSet = false;
    if(!((#3#2#isSet ?{core::bool} #3#2{core::bool} : let final core::bool* #t92 = #3#2#isSet = true in #3#2 = #3#0.{core::Map::containsKey}(#C4){(core::Object?) → core::bool}) && (let final core::int #t93 = a2 = #3#3#isSet ?{core::int?} #3#3{core::int?} : let final core::bool* #t94 = #3#3#isSet = true in #3#3 = #3#0.{core::Map::[]}(#C4){(core::Object?) → core::int?} in true) && (#3#2#isSet ?{core::bool} #3#2{core::bool} : let final core::bool* #t95 = #3#2#isSet = true in #3#2 = #3#0.{core::Map::containsKey}(#C4){(core::Object?) → core::bool}) && (let final core::int #t96 = b2 = #3#3#isSet ?{core::int?} #3#3{core::int?} : let final core::bool* #t97 = #3#3#isSet = true in #3#3 = #3#0.{core::Map::[]}(#C4){(core::Object?) → core::int?} in true)))
      throw new core::StateError::•("Pattern matching error");
  }
  final hoisted has-declared-initializer core::int a3;
  final hoisted has-declared-initializer core::int b3;
  {
    final synthesized core::Map<core::String, core::int> #4#0 = <core::String, core::int>{"x": 1};
    synthesized core::bool #4#2;
    synthesized core::bool #4#2#isSet = false;
    synthesized core::int? #4#3;
    synthesized core::bool #4#3#isSet = false;
    if(!((#4#2#isSet ?{core::bool} #4#2{core::bool} : let final core::bool* #t98 = #4#2#isSet = true in #4#2 = #4#0.{core::Map::containsKey}(#C5){(core::Object?) → core::bool}) && (let final core::int #t99 = a3 = #4#3#isSet ?{core::int?} #4#3{core::int?} : let final core::bool* #t100 = #4#3#isSet = true in #4#3 = #4#0.{core::Map::[]}(#C5){(core::Object?) → core::int?} in true) && (#4#2#isSet ?{core::bool} #4#2{core::bool} : let final core::bool* #t101 = #4#2#isSet = true in #4#2 = #4#0.{core::Map::containsKey}(#C5){(core::Object?) → core::bool}) && (let final core::int #t102 = b3 = #4#3#isSet ?{core::int?} #4#3{core::int?} : let final core::bool* #t103 = #4#3#isSet = true in #4#3 = #4#0.{core::Map::[]}(#C5){(core::Object?) → core::int?} in true)))
      throw new core::StateError::•("Pattern matching error");
  }
}

constants  {
  #C1 = self::C {}
  #C2 = 1
  #C3 = 2
  #C4 = 3.14
  #C5 = "x"
}


Constructor coverage from constants:
org-dartlang-testcase:///identical_map_keys.dart:
- C. (from org-dartlang-testcase:///identical_map_keys.dart:8:9)
- Object. (from org-dartlang-sdk:///sdk/lib/core/object.dart)
