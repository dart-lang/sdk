library /*isNonNullableByDefault*/;
import self as self;
import "dart:core" as core;
import "dart:collection" as col;
import "dart:math" as math;

import "dart:collection";

abstract class _NegativeLengthList&Object&ListMixin<E extends core::Object? = dynamic> = core::Object with col::ListMixin<self::_NegativeLengthList&Object&ListMixin::E%> /*isAnonymousMixin,hasConstConstructor*/  {
  const synthetic constructor •() → self::_NegativeLengthList&Object&ListMixin<self::_NegativeLengthList&Object&ListMixin::E%>
    : super core::Object::•()
    ;
  mixin-super-stub get first() → self::_NegativeLengthList&Object&ListMixin::E%
    return super.{col::ListMixin::first};
  mixin-super-stub set first(covariant-by-class self::_NegativeLengthList&Object&ListMixin::E% value) → void
    return super.{col::ListMixin::first} = value;
  mixin-super-stub get last() → self::_NegativeLengthList&Object&ListMixin::E%
    return super.{col::ListMixin::last};
  mixin-super-stub set last(covariant-by-class self::_NegativeLengthList&Object&ListMixin::E% value) → void
    return super.{col::ListMixin::last} = value;
  mixin-super-stub get iterator() → core::Iterator<self::_NegativeLengthList&Object&ListMixin::E%>
    return super.{col::ListMixin::iterator};
  mixin-super-stub method elementAt(core::int index) → self::_NegativeLengthList&Object&ListMixin::E%
    return super.{col::ListMixin::elementAt}(index);
  mixin-super-stub method followedBy(covariant-by-class core::Iterable<self::_NegativeLengthList&Object&ListMixin::E%> other) → core::Iterable<self::_NegativeLengthList&Object&ListMixin::E%>
    return super.{col::ListMixin::followedBy}(other);
  mixin-super-stub method forEach((self::_NegativeLengthList&Object&ListMixin::E%) → void action) → void
    return super.{col::ListMixin::forEach}(action);
  mixin-super-stub get isEmpty() → core::bool
    return super.{col::ListMixin::isEmpty};
  mixin-super-stub get isNotEmpty() → core::bool
    return super.{col::ListMixin::isNotEmpty};
  mixin-super-stub get single() → self::_NegativeLengthList&Object&ListMixin::E%
    return super.{col::ListMixin::single};
  mixin-super-stub method contains(core::Object? element) → core::bool
    return super.{col::ListMixin::contains}(element);
  mixin-super-stub method every((self::_NegativeLengthList&Object&ListMixin::E%) → core::bool test) → core::bool
    return super.{col::ListMixin::every}(test);
  mixin-super-stub method any((self::_NegativeLengthList&Object&ListMixin::E%) → core::bool test) → core::bool
    return super.{col::ListMixin::any}(test);
  mixin-super-stub method firstWhere((self::_NegativeLengthList&Object&ListMixin::E%) → core::bool test, {covariant-by-class () →? self::_NegativeLengthList&Object&ListMixin::E% orElse}) → self::_NegativeLengthList&Object&ListMixin::E%
    return super.{col::ListMixin::firstWhere}(test, orElse: orElse);
  mixin-super-stub method lastWhere((self::_NegativeLengthList&Object&ListMixin::E%) → core::bool test, {covariant-by-class () →? self::_NegativeLengthList&Object&ListMixin::E% orElse}) → self::_NegativeLengthList&Object&ListMixin::E%
    return super.{col::ListMixin::lastWhere}(test, orElse: orElse);
  mixin-super-stub method singleWhere((self::_NegativeLengthList&Object&ListMixin::E%) → core::bool test, {covariant-by-class () →? self::_NegativeLengthList&Object&ListMixin::E% orElse}) → self::_NegativeLengthList&Object&ListMixin::E%
    return super.{col::ListMixin::singleWhere}(test, orElse: orElse);
  mixin-super-stub method join([core::String separator]) → core::String
    return super.{col::ListMixin::join}(separator);
  mixin-super-stub method where((self::_NegativeLengthList&Object&ListMixin::E%) → core::bool test) → core::Iterable<self::_NegativeLengthList&Object&ListMixin::E%>
    return super.{col::ListMixin::where}(test);
  mixin-super-stub method whereType<T extends core::Object? = dynamic>() → core::Iterable<self::_NegativeLengthList&Object&ListMixin::whereType::T%>
    return super.{col::ListMixin::whereType}<self::_NegativeLengthList&Object&ListMixin::whereType::T%>();
  mixin-super-stub method map<T extends core::Object? = dynamic>((self::_NegativeLengthList&Object&ListMixin::E%) → self::_NegativeLengthList&Object&ListMixin::map::T% f) → core::Iterable<self::_NegativeLengthList&Object&ListMixin::map::T%>
    return super.{col::ListMixin::map}<self::_NegativeLengthList&Object&ListMixin::map::T%>(f);
  mixin-super-stub method expand<T extends core::Object? = dynamic>((self::_NegativeLengthList&Object&ListMixin::E%) → core::Iterable<self::_NegativeLengthList&Object&ListMixin::expand::T%> f) → core::Iterable<self::_NegativeLengthList&Object&ListMixin::expand::T%>
    return super.{col::ListMixin::expand}<self::_NegativeLengthList&Object&ListMixin::expand::T%>(f);
  mixin-super-stub method reduce(covariant-by-class (self::_NegativeLengthList&Object&ListMixin::E%, self::_NegativeLengthList&Object&ListMixin::E%) → self::_NegativeLengthList&Object&ListMixin::E% combine) → self::_NegativeLengthList&Object&ListMixin::E%
    return super.{col::ListMixin::reduce}(combine);
  mixin-super-stub method fold<T extends core::Object? = dynamic>(self::_NegativeLengthList&Object&ListMixin::fold::T% initialValue, (self::_NegativeLengthList&Object&ListMixin::fold::T%, self::_NegativeLengthList&Object&ListMixin::E%) → self::_NegativeLengthList&Object&ListMixin::fold::T% combine) → self::_NegativeLengthList&Object&ListMixin::fold::T%
    return super.{col::ListMixin::fold}<self::_NegativeLengthList&Object&ListMixin::fold::T%>(initialValue, combine);
  mixin-super-stub method skip(core::int count) → core::Iterable<self::_NegativeLengthList&Object&ListMixin::E%>
    return super.{col::ListMixin::skip}(count);
  mixin-super-stub method skipWhile((self::_NegativeLengthList&Object&ListMixin::E%) → core::bool test) → core::Iterable<self::_NegativeLengthList&Object&ListMixin::E%>
    return super.{col::ListMixin::skipWhile}(test);
  mixin-super-stub method take(core::int count) → core::Iterable<self::_NegativeLengthList&Object&ListMixin::E%>
    return super.{col::ListMixin::take}(count);
  mixin-super-stub method takeWhile((self::_NegativeLengthList&Object&ListMixin::E%) → core::bool test) → core::Iterable<self::_NegativeLengthList&Object&ListMixin::E%>
    return super.{col::ListMixin::takeWhile}(test);
  mixin-super-stub method toList({core::bool growable}) → core::List<self::_NegativeLengthList&Object&ListMixin::E%>
    return super.{col::ListMixin::toList}(growable: growable);
  mixin-super-stub method toSet() → core::Set<self::_NegativeLengthList&Object&ListMixin::E%>
    return super.{col::ListMixin::toSet}();
  mixin-super-stub method add(covariant-by-class self::_NegativeLengthList&Object&ListMixin::E% element) → void
    return super.{col::ListMixin::add}(element);
  mixin-super-stub method addAll(covariant-by-class core::Iterable<self::_NegativeLengthList&Object&ListMixin::E%> iterable) → void
    return super.{col::ListMixin::addAll}(iterable);
  mixin-super-stub method remove(core::Object? element) → core::bool
    return super.{col::ListMixin::remove}(element);
  mixin-super-stub method _closeGap(core::int start, core::int end) → void
    return super.{col::ListMixin::_closeGap}(start, end);
  mixin-super-stub method removeWhere((self::_NegativeLengthList&Object&ListMixin::E%) → core::bool test) → void
    return super.{col::ListMixin::removeWhere}(test);
  mixin-super-stub method retainWhere((self::_NegativeLengthList&Object&ListMixin::E%) → core::bool test) → void
    return super.{col::ListMixin::retainWhere}(test);
  mixin-super-stub method _filter((self::_NegativeLengthList&Object&ListMixin::E%) → core::bool test, core::bool retainMatching) → void
    return super.{col::ListMixin::_filter}(test, retainMatching);
  mixin-super-stub method clear() → void
    return super.{col::ListMixin::clear}();
  mixin-super-stub method cast<R extends core::Object? = dynamic>() → core::List<self::_NegativeLengthList&Object&ListMixin::cast::R%>
    return super.{col::ListMixin::cast}<self::_NegativeLengthList&Object&ListMixin::cast::R%>();
  mixin-super-stub method removeLast() → self::_NegativeLengthList&Object&ListMixin::E%
    return super.{col::ListMixin::removeLast}();
  mixin-super-stub method sort([(self::_NegativeLengthList&Object&ListMixin::E%, self::_NegativeLengthList&Object&ListMixin::E%) →? core::int compare]) → void
    return super.{col::ListMixin::sort}(compare);
  mixin-super-stub method shuffle([math::Random? random]) → void
    return super.{col::ListMixin::shuffle}(random);
  mixin-super-stub method asMap() → core::Map<core::int, self::_NegativeLengthList&Object&ListMixin::E%>
    return super.{col::ListMixin::asMap}();
  mixin-super-stub operator +(covariant-by-class core::List<self::_NegativeLengthList&Object&ListMixin::E%> other) → core::List<self::_NegativeLengthList&Object&ListMixin::E%>
    return super.{col::ListMixin::+}(other);
  mixin-super-stub method sublist(core::int start, [core::int? end]) → core::List<self::_NegativeLengthList&Object&ListMixin::E%>
    return super.{col::ListMixin::sublist}(start, end);
  mixin-super-stub method getRange(core::int start, core::int end) → core::Iterable<self::_NegativeLengthList&Object&ListMixin::E%>
    return super.{col::ListMixin::getRange}(start, end);
  mixin-super-stub method removeRange(core::int start, core::int end) → void
    return super.{col::ListMixin::removeRange}(start, end);
  mixin-super-stub method fillRange(core::int start, core::int end, [covariant-by-class self::_NegativeLengthList&Object&ListMixin::E? fill]) → void
    return super.{col::ListMixin::fillRange}(start, end, fill);
  mixin-super-stub method setRange(core::int start, core::int end, covariant-by-class core::Iterable<self::_NegativeLengthList&Object&ListMixin::E%> iterable, [core::int skipCount]) → void
    return super.{col::ListMixin::setRange}(start, end, iterable, skipCount);
  mixin-super-stub method replaceRange(core::int start, core::int end, covariant-by-class core::Iterable<self::_NegativeLengthList&Object&ListMixin::E%> newContents) → void
    return super.{col::ListMixin::replaceRange}(start, end, newContents);
  mixin-super-stub method indexOf(covariant-by-class core::Object? element, [core::int start]) → core::int
    return super.{col::ListMixin::indexOf}(element, start);
  mixin-super-stub method indexWhere((self::_NegativeLengthList&Object&ListMixin::E%) → core::bool test, [core::int start]) → core::int
    return super.{col::ListMixin::indexWhere}(test, start);
  mixin-super-stub method lastIndexOf(covariant-by-class core::Object? element, [core::int? start]) → core::int
    return super.{col::ListMixin::lastIndexOf}(element, start);
  mixin-super-stub method lastIndexWhere((self::_NegativeLengthList&Object&ListMixin::E%) → core::bool test, [core::int? start]) → core::int
    return super.{col::ListMixin::lastIndexWhere}(test, start);
  mixin-super-stub method insert(core::int index, covariant-by-class self::_NegativeLengthList&Object&ListMixin::E% element) → void
    return super.{col::ListMixin::insert}(index, element);
  mixin-super-stub method removeAt(core::int index) → self::_NegativeLengthList&Object&ListMixin::E%
    return super.{col::ListMixin::removeAt}(index);
  mixin-super-stub method insertAll(core::int index, covariant-by-class core::Iterable<self::_NegativeLengthList&Object&ListMixin::E%> iterable) → void
    return super.{col::ListMixin::insertAll}(index, iterable);
  mixin-super-stub method setAll(core::int index, covariant-by-class core::Iterable<self::_NegativeLengthList&Object&ListMixin::E%> iterable) → void
    return super.{col::ListMixin::setAll}(index, iterable);
  mixin-super-stub get reversed() → core::Iterable<self::_NegativeLengthList&Object&ListMixin::E%>
    return super.{col::ListMixin::reversed};
  mixin-super-stub method toString() → core::String
    return super.{col::ListMixin::toString}();
}
class NegativeLengthList<E extends core::Object? = dynamic> extends self::_NegativeLengthList&Object&ListMixin<self::NegativeLengthList::E%> {
  final field core::List<self::NegativeLengthList::E%> _list;
  constructor •(core::List<self::NegativeLengthList::E%> _list) → self::NegativeLengthList<self::NegativeLengthList::E%>
    ;
  get length() → core::int
    ;
  set length(core::int value) → void
    ;
  operator [](core::int index) → self::NegativeLengthList::E%
    ;
  operator []=(core::int index, covariant-by-class self::NegativeLengthList::E% value) → void
    ;
}
abstract class _NegativeLengthMap&Object&MapMixin<K extends core::Object? = dynamic, V extends core::Object? = dynamic> = core::Object with col::MapMixin<self::_NegativeLengthMap&Object&MapMixin::K%, self::_NegativeLengthMap&Object&MapMixin::V%> /*isAnonymousMixin,hasConstConstructor*/  {
  const synthetic constructor •() → self::_NegativeLengthMap&Object&MapMixin<self::_NegativeLengthMap&Object&MapMixin::K%, self::_NegativeLengthMap&Object&MapMixin::V%>
    : super core::Object::•()
    ;
  abstract mixin-stub operator [](core::Object? key) → self::_NegativeLengthMap&Object&MapMixin::V?; -> col::MapMixin::[]
  abstract mixin-stub operator []=(covariant-by-class self::_NegativeLengthMap&Object&MapMixin::K% key, covariant-by-class self::_NegativeLengthMap&Object&MapMixin::V% value) → void; -> col::MapMixin::[]=
  abstract mixin-stub method remove(core::Object? key) → self::_NegativeLengthMap&Object&MapMixin::V?; -> col::MapMixin::remove
  abstract mixin-stub method clear() → void; -> col::MapMixin::clear
  mixin-super-stub get length() → core::int
    return super.{col::MapMixin::length};
  abstract mixin-stub get keys() → core::Iterable<self::_NegativeLengthMap&Object&MapMixin::K%>; -> col::MapMixin::keys
  mixin-super-stub method cast<RK extends core::Object? = dynamic, RV extends core::Object? = dynamic>() → core::Map<self::_NegativeLengthMap&Object&MapMixin::cast::RK%, self::_NegativeLengthMap&Object&MapMixin::cast::RV%>
    return super.{col::MapMixin::cast}<self::_NegativeLengthMap&Object&MapMixin::cast::RK%, self::_NegativeLengthMap&Object&MapMixin::cast::RV%>();
  mixin-super-stub method forEach((self::_NegativeLengthMap&Object&MapMixin::K%, self::_NegativeLengthMap&Object&MapMixin::V%) → void action) → void
    return super.{col::MapMixin::forEach}(action);
  mixin-super-stub method addAll(covariant-by-class core::Map<self::_NegativeLengthMap&Object&MapMixin::K%, self::_NegativeLengthMap&Object&MapMixin::V%> other) → void
    return super.{col::MapMixin::addAll}(other);
  mixin-super-stub method containsValue(core::Object? value) → core::bool
    return super.{col::MapMixin::containsValue}(value);
  mixin-super-stub method putIfAbsent(covariant-by-class self::_NegativeLengthMap&Object&MapMixin::K% key, covariant-by-class () → self::_NegativeLengthMap&Object&MapMixin::V% ifAbsent) → self::_NegativeLengthMap&Object&MapMixin::V%
    return super.{col::MapMixin::putIfAbsent}(key, ifAbsent);
  mixin-super-stub method update(covariant-by-class self::_NegativeLengthMap&Object&MapMixin::K% key, covariant-by-class (self::_NegativeLengthMap&Object&MapMixin::V%) → self::_NegativeLengthMap&Object&MapMixin::V% update, {covariant-by-class () →? self::_NegativeLengthMap&Object&MapMixin::V% ifAbsent}) → self::_NegativeLengthMap&Object&MapMixin::V%
    return super.{col::MapMixin::update}(key, update, ifAbsent: ifAbsent);
  mixin-super-stub method updateAll(covariant-by-class (self::_NegativeLengthMap&Object&MapMixin::K%, self::_NegativeLengthMap&Object&MapMixin::V%) → self::_NegativeLengthMap&Object&MapMixin::V% update) → void
    return super.{col::MapMixin::updateAll}(update);
  mixin-super-stub get entries() → core::Iterable<core::MapEntry<self::_NegativeLengthMap&Object&MapMixin::K%, self::_NegativeLengthMap&Object&MapMixin::V%>>
    return super.{col::MapMixin::entries};
  mixin-super-stub method map<K2 extends core::Object? = dynamic, V2 extends core::Object? = dynamic>((self::_NegativeLengthMap&Object&MapMixin::K%, self::_NegativeLengthMap&Object&MapMixin::V%) → core::MapEntry<self::_NegativeLengthMap&Object&MapMixin::map::K2%, self::_NegativeLengthMap&Object&MapMixin::map::V2%> transform) → core::Map<self::_NegativeLengthMap&Object&MapMixin::map::K2%, self::_NegativeLengthMap&Object&MapMixin::map::V2%>
    return super.{col::MapMixin::map}<self::_NegativeLengthMap&Object&MapMixin::map::K2%, self::_NegativeLengthMap&Object&MapMixin::map::V2%>(transform);
  mixin-super-stub method addEntries(covariant-by-class core::Iterable<core::MapEntry<self::_NegativeLengthMap&Object&MapMixin::K%, self::_NegativeLengthMap&Object&MapMixin::V%>> newEntries) → void
    return super.{col::MapMixin::addEntries}(newEntries);
  mixin-super-stub method removeWhere((self::_NegativeLengthMap&Object&MapMixin::K%, self::_NegativeLengthMap&Object&MapMixin::V%) → core::bool test) → void
    return super.{col::MapMixin::removeWhere}(test);
  mixin-super-stub method containsKey(core::Object? key) → core::bool
    return super.{col::MapMixin::containsKey}(key);
  mixin-super-stub get isEmpty() → core::bool
    return super.{col::MapMixin::isEmpty};
  mixin-super-stub get isNotEmpty() → core::bool
    return super.{col::MapMixin::isNotEmpty};
  mixin-super-stub get values() → core::Iterable<self::_NegativeLengthMap&Object&MapMixin::V%>
    return super.{col::MapMixin::values};
  mixin-super-stub method toString() → core::String
    return super.{col::MapMixin::toString}();
}
class NegativeLengthMap<K extends core::Object? = dynamic, V extends core::Object? = dynamic> extends self::_NegativeLengthMap&Object&MapMixin<self::NegativeLengthMap::K%, self::NegativeLengthMap::V%> {
  final field core::Map<self::NegativeLengthMap::K%, self::NegativeLengthMap::V%> _map;
  constructor •(core::Map<self::NegativeLengthMap::K%, self::NegativeLengthMap::V%> _map) → self::NegativeLengthMap<self::NegativeLengthMap::K%, self::NegativeLengthMap::V%>
    ;
  get length() → core::int
    ;
  operator [](core::Object? key) → self::NegativeLengthMap::V?
    ;
  operator []=(covariant-by-class self::NegativeLengthMap::K% key, covariant-by-class self::NegativeLengthMap::V% value) → void
    ;
  get keys() → core::Iterable<self::NegativeLengthMap::K%>
    ;
  method remove(core::Object? key) → self::NegativeLengthMap::V?
    ;
  method clear() → void
    ;
}
static method switchList(core::List<core::int> list) → core::int
  ;
static method switchMap(core::Map<core::int, core::String> map) → core::int
  ;
static method main() → dynamic
  ;
static method expect(dynamic expected, dynamic actual) → dynamic
  ;
