library;
//
// Problems in library:
//
// pkg/front_end/testcases/patterns/identical_map_keys.dart:55:14: Error: Variable patterns in declaration context can't specify 'var' or 'final' keyword.
// Try removing the keyword.
//   final {c1: var a1, c2: final b1} = {c2: 2};
//              ^^^
//
// pkg/front_end/testcases/patterns/identical_map_keys.dart:55:26: Error: Variable patterns in declaration context can't specify 'var' or 'final' keyword.
// Try removing the keyword.
//   final {c1: var a1, c2: final b1} = {c2: 2};
//                          ^^^^^
//
// pkg/front_end/testcases/patterns/identical_map_keys.dart:56:16: Error: Variable patterns in declaration context can't specify 'var' or 'final' keyword.
// Try removing the keyword.
//   final {3.14: var a2, 3.14: final b2} = {3.14: 1};
//                ^^^
//
// pkg/front_end/testcases/patterns/identical_map_keys.dart:56:30: Error: Variable patterns in declaration context can't specify 'var' or 'final' keyword.
// Try removing the keyword.
//   final {3.14: var a2, 3.14: final b2} = {3.14: 1};
//                              ^^^^^
//
// pkg/front_end/testcases/patterns/identical_map_keys.dart:57:15: Error: Variable patterns in declaration context can't specify 'var' or 'final' keyword.
// Try removing the keyword.
//   final {"x": var a3, "x": final b3} = {"x": 1};
//               ^^^
//
// pkg/front_end/testcases/patterns/identical_map_keys.dart:57:28: Error: Variable patterns in declaration context can't specify 'var' or 'final' keyword.
// Try removing the keyword.
//   final {"x": var a3, "x": final b3} = {"x": 1};
//                            ^^^^^
//
// pkg/front_end/testcases/patterns/identical_map_keys.dart:16:26: Error: Two keys in a map pattern can't be equal.
// Change or remove the duplicate key.
//     {const C(): 1, const C(): 2} => "",
//                          ^
// pkg/front_end/testcases/patterns/identical_map_keys.dart:16:12: Context: This is the previous use of the same key.
//     {const C(): 1, const C(): 2} => "",
//            ^
//
// pkg/front_end/testcases/patterns/identical_map_keys.dart:17:12: Error: Two keys in a map pattern can't be equal.
// Change or remove the duplicate key.
//     {1: 1, 1: 2} => "",
//            ^
// pkg/front_end/testcases/patterns/identical_map_keys.dart:17:6: Context: This is the previous use of the same key.
//     {1: 1, 1: 2} => "",
//      ^
//
// pkg/front_end/testcases/patterns/identical_map_keys.dart:18:18: Error: Two keys in a map pattern can't be equal.
// Change or remove the duplicate key.
//     {c1: var a1, c2: final b1} => "",
//                  ^
// pkg/front_end/testcases/patterns/identical_map_keys.dart:18:6: Context: This is the previous use of the same key.
//     {c1: var a1, c2: final b1} => "",
//      ^
//
// pkg/front_end/testcases/patterns/identical_map_keys.dart:19:20: Error: Two keys in a map pattern can't be equal.
// Change or remove the duplicate key.
//     {3.14: var a2, 3.14: final b2} => "",
//                    ^
// pkg/front_end/testcases/patterns/identical_map_keys.dart:19:6: Context: This is the previous use of the same key.
//     {3.14: var a2, 3.14: final b2} => "",
//      ^
//
// pkg/front_end/testcases/patterns/identical_map_keys.dart:20:19: Error: Two keys in a map pattern can't be equal.
// Change or remove the duplicate key.
//     {"x": var a3, "x": final b3} => "",
//                   ^
// pkg/front_end/testcases/patterns/identical_map_keys.dart:20:6: Context: This is the previous use of the same key.
//     {"x": var a3, "x": final b3} => "",
//      ^
//
// pkg/front_end/testcases/patterns/identical_map_keys.dart:27:31: Error: Two keys in a map pattern can't be equal.
// Change or remove the duplicate key.
//     case {const C(): 1, const C(): 2}:
//                               ^
// pkg/front_end/testcases/patterns/identical_map_keys.dart:27:17: Context: This is the previous use of the same key.
//     case {const C(): 1, const C(): 2}:
//                 ^
//
// pkg/front_end/testcases/patterns/identical_map_keys.dart:29:17: Error: Two keys in a map pattern can't be equal.
// Change or remove the duplicate key.
//     case {1: 1, 1: 2}:
//                 ^
// pkg/front_end/testcases/patterns/identical_map_keys.dart:29:11: Context: This is the previous use of the same key.
//     case {1: 1, 1: 2}:
//           ^
//
// pkg/front_end/testcases/patterns/identical_map_keys.dart:31:23: Error: Two keys in a map pattern can't be equal.
// Change or remove the duplicate key.
//     case {c1: var a1, c2: final b1}:
//                       ^
// pkg/front_end/testcases/patterns/identical_map_keys.dart:31:11: Context: This is the previous use of the same key.
//     case {c1: var a1, c2: final b1}:
//           ^
//
// pkg/front_end/testcases/patterns/identical_map_keys.dart:32:25: Error: Two keys in a map pattern can't be equal.
// Change or remove the duplicate key.
//     case {3.14: var a2, 3.14: final b2}:
//                         ^
// pkg/front_end/testcases/patterns/identical_map_keys.dart:32:11: Context: This is the previous use of the same key.
//     case {3.14: var a2, 3.14: final b2}:
//           ^
//
// pkg/front_end/testcases/patterns/identical_map_keys.dart:34:24: Error: Two keys in a map pattern can't be equal.
// Change or remove the duplicate key.
//     case {"x": var a3, "x": final b3}:
//                        ^
// pkg/front_end/testcases/patterns/identical_map_keys.dart:34:11: Context: This is the previous use of the same key.
//     case {"x": var a3, "x": final b3}:
//           ^
//
// pkg/front_end/testcases/patterns/identical_map_keys.dart:40:37: Error: Two keys in a map pattern can't be equal.
// Change or remove the duplicate key.
//   if (map case {const C(): 1, const C(): 2}) {
//                                     ^
// pkg/front_end/testcases/patterns/identical_map_keys.dart:40:23: Context: This is the previous use of the same key.
//   if (map case {const C(): 1, const C(): 2}) {
//                       ^
//
// pkg/front_end/testcases/patterns/identical_map_keys.dart:42:23: Error: Two keys in a map pattern can't be equal.
// Change or remove the duplicate key.
//   if (map case {1: 1, 1: 2}) {
//                       ^
// pkg/front_end/testcases/patterns/identical_map_keys.dart:42:17: Context: This is the previous use of the same key.
//   if (map case {1: 1, 1: 2}) {
//                 ^
//
// pkg/front_end/testcases/patterns/identical_map_keys.dart:44:29: Error: Two keys in a map pattern can't be equal.
// Change or remove the duplicate key.
//   if (map case {c1: var a1, c2: final b1}) {
//                             ^
// pkg/front_end/testcases/patterns/identical_map_keys.dart:44:17: Context: This is the previous use of the same key.
//   if (map case {c1: var a1, c2: final b1}) {
//                 ^
//
// pkg/front_end/testcases/patterns/identical_map_keys.dart:46:31: Error: Two keys in a map pattern can't be equal.
// Change or remove the duplicate key.
//   if (map case {3.14: var a2, 3.14: final b2}) {
//                               ^
// pkg/front_end/testcases/patterns/identical_map_keys.dart:46:17: Context: This is the previous use of the same key.
//   if (map case {3.14: var a2, 3.14: final b2}) {
//                 ^
//
// pkg/front_end/testcases/patterns/identical_map_keys.dart:48:30: Error: Two keys in a map pattern can't be equal.
// Change or remove the duplicate key.
//   if (map case {"x": var a3, "x": final b3}) {
//                              ^
// pkg/front_end/testcases/patterns/identical_map_keys.dart:48:17: Context: This is the previous use of the same key.
//   if (map case {"x": var a3, "x": final b3}) {
//                 ^
//
// pkg/front_end/testcases/patterns/identical_map_keys.dart:53:28: Error: Two keys in a map pattern can't be equal.
// Change or remove the duplicate key.
//   var {const C(): a, const C(): b} = {const C(): 1};
//                            ^
// pkg/front_end/testcases/patterns/identical_map_keys.dart:53:14: Context: This is the previous use of the same key.
//   var {const C(): a, const C(): b} = {const C(): 1};
//              ^
//
// pkg/front_end/testcases/patterns/identical_map_keys.dart:54:14: Error: Two keys in a map pattern can't be equal.
// Change or remove the duplicate key.
//   var {1: c, 1: d} = {1: 2};
//              ^
// pkg/front_end/testcases/patterns/identical_map_keys.dart:54:8: Context: This is the previous use of the same key.
//   var {1: c, 1: d} = {1: 2};
//        ^
//
// pkg/front_end/testcases/patterns/identical_map_keys.dart:55:22: Error: Two keys in a map pattern can't be equal.
// Change or remove the duplicate key.
//   final {c1: var a1, c2: final b1} = {c2: 2};
//                      ^
// pkg/front_end/testcases/patterns/identical_map_keys.dart:55:10: Context: This is the previous use of the same key.
//   final {c1: var a1, c2: final b1} = {c2: 2};
//          ^
//
// pkg/front_end/testcases/patterns/identical_map_keys.dart:56:24: Error: Two keys in a map pattern can't be equal.
// Change or remove the duplicate key.
//   final {3.14: var a2, 3.14: final b2} = {3.14: 1};
//                        ^
// pkg/front_end/testcases/patterns/identical_map_keys.dart:56:10: Context: This is the previous use of the same key.
//   final {3.14: var a2, 3.14: final b2} = {3.14: 1};
//          ^
//
// pkg/front_end/testcases/patterns/identical_map_keys.dart:57:23: Error: Two keys in a map pattern can't be equal.
// Change or remove the duplicate key.
//   final {"x": var a3, "x": final b3} = {"x": 1};
//                       ^
// pkg/front_end/testcases/patterns/identical_map_keys.dart:57:10: Context: This is the previous use of the same key.
//   final {"x": var a3, "x": final b3} = {"x": 1};
//          ^
//
import self as self;
import "dart:core" as core;

class C extends core::Object /*hasConstConstructor*/  {
  const constructor •() → self::C
    : super core::Object::•()
    ;
}
static const field self::C c1 = #C1;
static const field self::C c2 = #C1;
static method test1(core::Map<dynamic, dynamic> map) → core::String {
  return block {
    core::String #t1;
    final synthesized core::Map<dynamic, dynamic> #0#0 = map;
    function ##0#3#initializer() → dynamic
      return #0#0.{core::Map::[]}(#C1){(core::Object?) → dynamic};
    late final synthesized dynamic #0#3 = ##0#3#initializer(){() → dynamic};
    function ##0#2#initializer() → core::bool
      return #0#0.{core::Map::containsKey}(#C1){(core::Object?) → core::bool};
    late final synthesized core::bool #0#2 = ##0#2#initializer(){() → core::bool};
    function ##0#9#initializer() → dynamic
      return #0#0.{core::Map::[]}(#C2){(core::Object?) → dynamic};
    late final synthesized dynamic #0#9 = ##0#9#initializer(){() → dynamic};
    function ##0#8#initializer() → core::bool
      return #0#0.{core::Map::containsKey}(#C2){(core::Object?) → core::bool};
    late final synthesized core::bool #0#8 = ##0#8#initializer(){() → core::bool};
    function ##0#14#initializer() → dynamic
      return #0#0.{core::Map::[]}(#C3){(core::Object?) → dynamic};
    late final synthesized dynamic #0#14 = ##0#14#initializer(){() → dynamic};
    function ##0#13#initializer() → core::bool
      return #0#0.{core::Map::containsKey}(#C3){(core::Object?) → core::bool};
    late final synthesized core::bool #0#13 = ##0#13#initializer(){() → core::bool};
    function ##0#17#initializer() → dynamic
      return #0#0.{core::Map::[]}(#C4){(core::Object?) → dynamic};
    late final synthesized dynamic #0#17 = ##0#17#initializer(){() → dynamic};
    function ##0#16#initializer() → core::bool
      return #0#0.{core::Map::containsKey}(#C4){(core::Object?) → core::bool};
    late final synthesized core::bool #0#16 = ##0#16#initializer(){() → core::bool};
    #L1:
    {
      {
        if((!(#0#3 == null) || null is dynamic && #0#2) && #C2 =={core::num::==}{(core::Object) → core::bool} #0#3 && (!(#0#3 == null) || null is dynamic && #0#2) && #C5 =={core::num::==}{(core::Object) → core::bool} #0#3) {
          #t1 = "";
          break #L1;
        }
      }
      {
        if((!(#0#9 == null) || null is dynamic && #0#8) && #C2 =={core::num::==}{(core::Object) → core::bool} #0#9 && (!(#0#9 == null) || null is dynamic && #0#8) && #C5 =={core::num::==}{(core::Object) → core::bool} #0#9) {
          #t1 = "";
          break #L1;
        }
      }
      {
        hoisted dynamic a1;
        final hoisted dynamic b1;
        if((!(#0#3 == null) || null is dynamic && #0#2) && (let final dynamic #t2 = a1 = #0#3 in true) && (!(#0#3 == null) || null is dynamic && #0#2) && (let final dynamic #t3 = b1 = #0#3 in true)) {
          #t1 = "";
          break #L1;
        }
      }
      {
        hoisted dynamic a2;
        final hoisted dynamic b2;
        if((!(#0#14 == null) || null is dynamic && #0#13) && (let final dynamic #t4 = a2 = #0#14 in true) && (!(#0#14 == null) || null is dynamic && #0#13) && (let final dynamic #t5 = b2 = #0#14 in true)) {
          #t1 = "";
          break #L1;
        }
      }
      {
        hoisted dynamic a3;
        final hoisted dynamic b3;
        if((!(#0#17 == null) || null is dynamic && #0#16) && (let final dynamic #t6 = a3 = #0#17 in true) && (!(#0#17 == null) || null is dynamic && #0#16) && (let final dynamic #t7 = b3 = #0#17 in true)) {
          #t1 = "";
          break #L1;
        }
      }
      {
        if(true) {
          #t1 = "default";
          break #L1;
        }
      }
    }
  } =>#t1;
}
static method test2(core::Map<dynamic, dynamic> map) → void {
  #L2:
  {
    final synthesized core::Map<dynamic, dynamic> #0#0 = map;
    function ##0#3#initializer() → dynamic
      return #0#0.{core::Map::[]}(#C1){(core::Object?) → dynamic};
    late final synthesized dynamic #0#3 = ##0#3#initializer(){() → dynamic};
    function ##0#2#initializer() → core::bool
      return #0#0.{core::Map::containsKey}(#C1){(core::Object?) → core::bool};
    late final synthesized core::bool #0#2 = ##0#2#initializer(){() → core::bool};
    function ##0#9#initializer() → dynamic
      return #0#0.{core::Map::[]}(#C2){(core::Object?) → dynamic};
    late final synthesized dynamic #0#9 = ##0#9#initializer(){() → dynamic};
    function ##0#8#initializer() → core::bool
      return #0#0.{core::Map::containsKey}(#C2){(core::Object?) → core::bool};
    late final synthesized core::bool #0#8 = ##0#8#initializer(){() → core::bool};
    function ##0#14#initializer() → dynamic
      return #0#0.{core::Map::[]}(#C3){(core::Object?) → dynamic};
    late final synthesized dynamic #0#14 = ##0#14#initializer(){() → dynamic};
    function ##0#13#initializer() → core::bool
      return #0#0.{core::Map::containsKey}(#C3){(core::Object?) → core::bool};
    late final synthesized core::bool #0#13 = ##0#13#initializer(){() → core::bool};
    function ##0#17#initializer() → dynamic
      return #0#0.{core::Map::[]}(#C4){(core::Object?) → dynamic};
    late final synthesized dynamic #0#17 = ##0#17#initializer(){() → dynamic};
    function ##0#16#initializer() → core::bool
      return #0#0.{core::Map::containsKey}(#C4){(core::Object?) → core::bool};
    late final synthesized core::bool #0#16 = ##0#16#initializer(){() → core::bool};
    {
      if((!(#0#3 == null) || null is dynamic && #0#2) && #C2 =={core::num::==}{(core::Object) → core::bool} #0#3 && (!(#0#3 == null) || null is dynamic && #0#2) && #C5 =={core::num::==}{(core::Object) → core::bool} #0#3) {
        {
          break #L2;
        }
      }
    }
    {
      if((!(#0#9 == null) || null is dynamic && #0#8) && #C2 =={core::num::==}{(core::Object) → core::bool} #0#9 && (!(#0#9 == null) || null is dynamic && #0#8) && #C5 =={core::num::==}{(core::Object) → core::bool} #0#9) {
        {
          break #L2;
        }
      }
    }
    {
      hoisted dynamic a1;
      final hoisted dynamic b1;
      hoisted dynamic a2;
      final hoisted dynamic b2;
      if((!(#0#3 == null) || null is dynamic && #0#2) && (let final dynamic #t8 = a1 = #0#3 in true) && (!(#0#3 == null) || null is dynamic && #0#2) && (let final dynamic #t9 = b1 = #0#3 in true) || (!(#0#14 == null) || null is dynamic && #0#13) && (let final dynamic #t10 = a2 = #0#14 in true) && (!(#0#14 == null) || null is dynamic && #0#13) && (let final dynamic #t11 = b2 = #0#14 in true)) {
        {
          break #L2;
        }
      }
    }
    {
      hoisted dynamic a3;
      final hoisted dynamic b3;
      if((!(#0#17 == null) || null is dynamic && #0#16) && (let final dynamic #t12 = a3 = #0#17 in true) && (!(#0#17 == null) || null is dynamic && #0#16) && (let final dynamic #t13 = b3 = #0#17 in true)) {
        {
          break #L2;
        }
      }
    }
  }
}
static method test3(core::Map<dynamic, dynamic> map) → void {
  {
    final synthesized core::Map<dynamic, dynamic> #0#0 = map;
    function ##0#3#initializer() → dynamic
      return #0#0.{core::Map::[]}(#C1){(core::Object?) → dynamic};
    late final synthesized dynamic #0#3 = ##0#3#initializer(){() → dynamic};
    function ##0#2#initializer() → core::bool
      return #0#0.{core::Map::containsKey}(#C1){(core::Object?) → core::bool};
    late final synthesized core::bool #0#2 = ##0#2#initializer(){() → core::bool};
    if((!(#0#3 == null) || null is dynamic && #0#2) && #C2 =={core::num::==}{(core::Object) → core::bool} #0#3 && (!(#0#3 == null) || null is dynamic && #0#2) && #C5 =={core::num::==}{(core::Object) → core::bool} #0#3) {
    }
  }
  {
    final synthesized core::Map<dynamic, dynamic> #1#0 = map;
    function ##1#3#initializer() → dynamic
      return #1#0.{core::Map::[]}(#C2){(core::Object?) → dynamic};
    late final synthesized dynamic #1#3 = ##1#3#initializer(){() → dynamic};
    function ##1#2#initializer() → core::bool
      return #1#0.{core::Map::containsKey}(#C2){(core::Object?) → core::bool};
    late final synthesized core::bool #1#2 = ##1#2#initializer(){() → core::bool};
    if((!(#1#3 == null) || null is dynamic && #1#2) && #C2 =={core::num::==}{(core::Object) → core::bool} #1#3 && (!(#1#3 == null) || null is dynamic && #1#2) && #C5 =={core::num::==}{(core::Object) → core::bool} #1#3) {
    }
  }
  {
    hoisted dynamic a1;
    final hoisted dynamic b1;
    final synthesized core::Map<dynamic, dynamic> #2#0 = map;
    function ##2#3#initializer() → dynamic
      return #2#0.{core::Map::[]}(#C1){(core::Object?) → dynamic};
    late final synthesized dynamic #2#3 = ##2#3#initializer(){() → dynamic};
    function ##2#2#initializer() → core::bool
      return #2#0.{core::Map::containsKey}(#C1){(core::Object?) → core::bool};
    late final synthesized core::bool #2#2 = ##2#2#initializer(){() → core::bool};
    if((!(#2#3 == null) || null is dynamic && #2#2) && (let final dynamic #t14 = a1 = #2#3 in true) && (!(#2#3 == null) || null is dynamic && #2#2) && (let final dynamic #t15 = b1 = #2#3 in true)) {
    }
  }
  {
    hoisted dynamic a2;
    final hoisted dynamic b2;
    final synthesized core::Map<dynamic, dynamic> #3#0 = map;
    function ##3#3#initializer() → dynamic
      return #3#0.{core::Map::[]}(#C3){(core::Object?) → dynamic};
    late final synthesized dynamic #3#3 = ##3#3#initializer(){() → dynamic};
    function ##3#2#initializer() → core::bool
      return #3#0.{core::Map::containsKey}(#C3){(core::Object?) → core::bool};
    late final synthesized core::bool #3#2 = ##3#2#initializer(){() → core::bool};
    if((!(#3#3 == null) || null is dynamic && #3#2) && (let final dynamic #t16 = a2 = #3#3 in true) && (!(#3#3 == null) || null is dynamic && #3#2) && (let final dynamic #t17 = b2 = #3#3 in true)) {
    }
  }
  {
    hoisted dynamic a3;
    final hoisted dynamic b3;
    final synthesized core::Map<dynamic, dynamic> #4#0 = map;
    function ##4#3#initializer() → dynamic
      return #4#0.{core::Map::[]}(#C4){(core::Object?) → dynamic};
    late final synthesized dynamic #4#3 = ##4#3#initializer(){() → dynamic};
    function ##4#2#initializer() → core::bool
      return #4#0.{core::Map::containsKey}(#C4){(core::Object?) → core::bool};
    late final synthesized core::bool #4#2 = ##4#2#initializer(){() → core::bool};
    if((!(#4#3 == null) || null is dynamic && #4#2) && (let final dynamic #t18 = a3 = #4#3 in true) && (!(#4#3 == null) || null is dynamic && #4#2) && (let final dynamic #t19 = b3 = #4#3 in true)) {
    }
  }
}
static method test() → dynamic {
  hoisted has-declared-initializer core::int a;
  hoisted has-declared-initializer core::int b;
  {
    final synthesized core::Map<self::C, core::int> #0#0 = <self::C, core::int>{#C1: 1};
    function ##0#3#initializer() → core::int?
      return #0#0.{core::Map::[]}(#C1){(core::Object?) → core::int?};
    late final synthesized core::int? #0#3 = ##0#3#initializer(){() → core::int?};
    function ##0#2#initializer() → core::bool
      return #0#0.{core::Map::containsKey}(#C1){(core::Object?) → core::bool};
    late final synthesized core::bool #0#2 = ##0#2#initializer(){() → core::bool};
    if(!((!(#0#3 == null) || null is core::int && #0#2) && (let final core::int #t20 = a = #0#3{core::int} in true) && (!(#0#3 == null) || null is core::int && #0#2) && (let final core::int #t21 = b = #0#3{core::int} in true)))
      throw new core::StateError::•("Pattern matching error");
  }
  hoisted has-declared-initializer core::int c;
  hoisted has-declared-initializer core::int d;
  {
    final synthesized core::Map<core::int, core::int> #1#0 = <core::int, core::int>{1: 2};
    function ##1#3#initializer() → core::int?
      return #1#0.{core::Map::[]}(#C2){(core::Object?) → core::int?};
    late final synthesized core::int? #1#3 = ##1#3#initializer(){() → core::int?};
    function ##1#2#initializer() → core::bool
      return #1#0.{core::Map::containsKey}(#C2){(core::Object?) → core::bool};
    late final synthesized core::bool #1#2 = ##1#2#initializer(){() → core::bool};
    if(!((!(#1#3 == null) || null is core::int && #1#2) && (let final core::int #t22 = c = #1#3{core::int} in true) && (!(#1#3 == null) || null is core::int && #1#2) && (let final core::int #t23 = d = #1#3{core::int} in true)))
      throw new core::StateError::•("Pattern matching error");
  }
  final hoisted has-declared-initializer core::int a1;
  final hoisted has-declared-initializer core::int b1;
  {
    final synthesized core::Map<self::C, core::int> #2#0 = <self::C, core::int>{#C1: 2};
    function ##2#3#initializer() → core::int?
      return #2#0.{core::Map::[]}(#C1){(core::Object?) → core::int?};
    late final synthesized core::int? #2#3 = ##2#3#initializer(){() → core::int?};
    function ##2#2#initializer() → core::bool
      return #2#0.{core::Map::containsKey}(#C1){(core::Object?) → core::bool};
    late final synthesized core::bool #2#2 = ##2#2#initializer(){() → core::bool};
    if(!((!(#2#3 == null) || null is core::int && #2#2) && (let final core::int #t24 = a1 = #2#3{core::int} in true) && (!(#2#3 == null) || null is core::int && #2#2) && (let final core::int #t25 = b1 = #2#3{core::int} in true)))
      throw new core::StateError::•("Pattern matching error");
  }
  final hoisted has-declared-initializer core::int a2;
  final hoisted has-declared-initializer core::int b2;
  {
    final synthesized core::Map<core::double, core::int> #3#0 = <core::double, core::int>{3.14: 1};
    function ##3#3#initializer() → core::int?
      return #3#0.{core::Map::[]}(#C3){(core::Object?) → core::int?};
    late final synthesized core::int? #3#3 = ##3#3#initializer(){() → core::int?};
    function ##3#2#initializer() → core::bool
      return #3#0.{core::Map::containsKey}(#C3){(core::Object?) → core::bool};
    late final synthesized core::bool #3#2 = ##3#2#initializer(){() → core::bool};
    if(!((!(#3#3 == null) || null is core::int && #3#2) && (let final core::int #t26 = a2 = #3#3{core::int} in true) && (!(#3#3 == null) || null is core::int && #3#2) && (let final core::int #t27 = b2 = #3#3{core::int} in true)))
      throw new core::StateError::•("Pattern matching error");
  }
  final hoisted has-declared-initializer core::int a3;
  final hoisted has-declared-initializer core::int b3;
  {
    final synthesized core::Map<core::String, core::int> #4#0 = <core::String, core::int>{"x": 1};
    function ##4#3#initializer() → core::int?
      return #4#0.{core::Map::[]}(#C4){(core::Object?) → core::int?};
    late final synthesized core::int? #4#3 = ##4#3#initializer(){() → core::int?};
    function ##4#2#initializer() → core::bool
      return #4#0.{core::Map::containsKey}(#C4){(core::Object?) → core::bool};
    late final synthesized core::bool #4#2 = ##4#2#initializer(){() → core::bool};
    if(!((!(#4#3 == null) || null is core::int && #4#2) && (let final core::int #t28 = a3 = #4#3{core::int} in true) && (!(#4#3 == null) || null is core::int && #4#2) && (let final core::int #t29 = b3 = #4#3{core::int} in true)))
      throw new core::StateError::•("Pattern matching error");
  }
}

constants  {
  #C1 = self::C {}
  #C2 = 1
  #C3 = 3.14
  #C4 = "x"
  #C5 = 2
}

Extra constant evaluation status:
Evaluated: IsExpression @ org-dartlang-testcase:///identical_map_keys.dart:16:15 -> BoolConstant(true)
Evaluated: IsExpression @ org-dartlang-testcase:///identical_map_keys.dart:16:29 -> BoolConstant(true)
Evaluated: IsExpression @ org-dartlang-testcase:///identical_map_keys.dart:17:7 -> BoolConstant(true)
Evaluated: IsExpression @ org-dartlang-testcase:///identical_map_keys.dart:17:13 -> BoolConstant(true)
Evaluated: IsExpression @ org-dartlang-testcase:///identical_map_keys.dart:18:8 -> BoolConstant(true)
Evaluated: IsExpression @ org-dartlang-testcase:///identical_map_keys.dart:18:20 -> BoolConstant(true)
Evaluated: IsExpression @ org-dartlang-testcase:///identical_map_keys.dart:19:10 -> BoolConstant(true)
Evaluated: IsExpression @ org-dartlang-testcase:///identical_map_keys.dart:19:24 -> BoolConstant(true)
Evaluated: IsExpression @ org-dartlang-testcase:///identical_map_keys.dart:20:9 -> BoolConstant(true)
Evaluated: IsExpression @ org-dartlang-testcase:///identical_map_keys.dart:20:22 -> BoolConstant(true)
Evaluated: IsExpression @ org-dartlang-testcase:///identical_map_keys.dart:27:20 -> BoolConstant(true)
Evaluated: IsExpression @ org-dartlang-testcase:///identical_map_keys.dart:27:34 -> BoolConstant(true)
Evaluated: IsExpression @ org-dartlang-testcase:///identical_map_keys.dart:29:12 -> BoolConstant(true)
Evaluated: IsExpression @ org-dartlang-testcase:///identical_map_keys.dart:29:18 -> BoolConstant(true)
Evaluated: IsExpression @ org-dartlang-testcase:///identical_map_keys.dart:31:13 -> BoolConstant(true)
Evaluated: IsExpression @ org-dartlang-testcase:///identical_map_keys.dart:31:25 -> BoolConstant(true)
Evaluated: IsExpression @ org-dartlang-testcase:///identical_map_keys.dart:32:15 -> BoolConstant(true)
Evaluated: IsExpression @ org-dartlang-testcase:///identical_map_keys.dart:32:29 -> BoolConstant(true)
Evaluated: IsExpression @ org-dartlang-testcase:///identical_map_keys.dart:34:14 -> BoolConstant(true)
Evaluated: IsExpression @ org-dartlang-testcase:///identical_map_keys.dart:34:27 -> BoolConstant(true)
Evaluated: IsExpression @ org-dartlang-testcase:///identical_map_keys.dart:40:26 -> BoolConstant(true)
Evaluated: IsExpression @ org-dartlang-testcase:///identical_map_keys.dart:40:40 -> BoolConstant(true)
Evaluated: IsExpression @ org-dartlang-testcase:///identical_map_keys.dart:42:18 -> BoolConstant(true)
Evaluated: IsExpression @ org-dartlang-testcase:///identical_map_keys.dart:42:24 -> BoolConstant(true)
Evaluated: IsExpression @ org-dartlang-testcase:///identical_map_keys.dart:44:19 -> BoolConstant(true)
Evaluated: IsExpression @ org-dartlang-testcase:///identical_map_keys.dart:44:31 -> BoolConstant(true)
Evaluated: IsExpression @ org-dartlang-testcase:///identical_map_keys.dart:46:21 -> BoolConstant(true)
Evaluated: IsExpression @ org-dartlang-testcase:///identical_map_keys.dart:46:35 -> BoolConstant(true)
Evaluated: IsExpression @ org-dartlang-testcase:///identical_map_keys.dart:48:20 -> BoolConstant(true)
Evaluated: IsExpression @ org-dartlang-testcase:///identical_map_keys.dart:48:33 -> BoolConstant(true)
Evaluated: LogicalExpression @ org-dartlang-testcase:///identical_map_keys.dart:53:17 -> BoolConstant(false)
Evaluated: LogicalExpression @ org-dartlang-testcase:///identical_map_keys.dart:53:31 -> BoolConstant(false)
Evaluated: LogicalExpression @ org-dartlang-testcase:///identical_map_keys.dart:54:9 -> BoolConstant(false)
Evaluated: LogicalExpression @ org-dartlang-testcase:///identical_map_keys.dart:54:15 -> BoolConstant(false)
Evaluated: LogicalExpression @ org-dartlang-testcase:///identical_map_keys.dart:55:12 -> BoolConstant(false)
Evaluated: LogicalExpression @ org-dartlang-testcase:///identical_map_keys.dart:55:24 -> BoolConstant(false)
Evaluated: LogicalExpression @ org-dartlang-testcase:///identical_map_keys.dart:56:14 -> BoolConstant(false)
Evaluated: LogicalExpression @ org-dartlang-testcase:///identical_map_keys.dart:56:28 -> BoolConstant(false)
Evaluated: LogicalExpression @ org-dartlang-testcase:///identical_map_keys.dart:57:13 -> BoolConstant(false)
Evaluated: LogicalExpression @ org-dartlang-testcase:///identical_map_keys.dart:57:26 -> BoolConstant(false)
Extra constant evaluation: evaluated: 572, effectively constant: 40


Constructor coverage from constants:
org-dartlang-testcase:///identical_map_keys.dart:
- C. (from org-dartlang-testcase:///identical_map_keys.dart:8:9)
- Object. (from org-dartlang-sdk:///sdk/lib/core/object.dart)
