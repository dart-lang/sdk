library;
import self as self;
import "dart:core" as core;
import "dart:collection" as col;

static method test1() → dynamic {
  {
    synthesized core::Iterator<core::List<core::int>> :sync-for-iterator = core::_GrowableList::_literal1<core::List<core::int>>(core::_GrowableList::_literal4<core::int>(3, 4, 5, 6)).{core::Iterable::iterator}{core::Iterator<core::List<core::int>>};
    for (; :sync-for-iterator.{core::Iterator::moveNext}(){() → core::bool}; ) {
      final core::List<core::int> #t1 = :sync-for-iterator.{core::Iterator::current}{core::List<core::int>};
      {
        hoisted core::int a2;
        hoisted core::int b2;
        hoisted core::List<core::int> c2;
        {
          final synthesized core::List<core::int> #0#0 = #t1;
          synthesized core::int #0#4;
          synthesized core::bool #0#4#isSet = false;
          synthesized core::List<core::int> #0#6;
          synthesized core::bool #0#6#isSet = false;
          if(!(#0#0.{core::List::length}{core::int}.{core::num::>=}(#C1){(core::num) → core::bool} && ((#0#4#isSet ?{core::int} #0#4{core::int} : let final core::bool* #t2 = #0#4#isSet = true in #0#4 = #0#0.{core::List::[]}(0){(core::int) → core::int}) is core::int && (let final core::int #t3 = a2 = #0#4#isSet ?{core::int} #0#4{core::int} : let final core::bool* #t4 = #0#4#isSet = true in #0#4 = #0#0.{core::List::[]}(0){(core::int) → core::int} in true)) && (let final core::int #t5 = b2 = #0#0.{core::List::[]}(1){(core::int) → core::int} in true) && ((#0#6#isSet ?{core::List<core::int>} #0#6{core::List<core::int>} : let final core::bool* #t6 = #0#6#isSet = true in #0#6 = #0#0.{core::List::sublist}(2){(core::int, [core::int?]) → core::List<core::int>}) is core::List<core::int> && (let final core::List<core::int> #t7 = c2 = #0#6#isSet ?{core::List<core::int>} #0#6{core::List<core::int>} : let final core::bool* #t8 = #0#6#isSet = true in #0#6 = #0#0.{core::List::sublist}(2){(core::int, [core::int?]) → core::List<core::int>} in true))))
            throw new core::StateError::•("Pattern matching error");
        }
        return c2.{core::Iterable::first}{core::int}.{core::int::isEven}{core::bool};
      }
    }
  }
}
static method test2() → dynamic {
  return block {
    final core::List<core::bool> #t9 = core::_GrowableList::•<core::bool>(0);
    {
      synthesized core::Iterator<core::List<core::int>> :sync-for-iterator = core::_GrowableList::_literal1<core::List<core::int>>(core::_GrowableList::_literal4<core::int>(3, 4, 5, 6)).{core::Iterable::iterator}{core::Iterator<core::List<core::int>>};
      for (; :sync-for-iterator.{core::Iterator::moveNext}(){() → core::bool}; ) {
        final core::List<core::int> #t10 = :sync-for-iterator.{core::Iterator::current}{core::List<core::int>};
        {
          hoisted core::int a2;
          hoisted core::int b2;
          hoisted core::List<core::int> c2;
          {
            final synthesized core::List<core::int> #0#0 = #t10;
            synthesized core::int #0#4;
            synthesized core::bool #0#4#isSet = false;
            synthesized core::List<core::int> #0#6;
            synthesized core::bool #0#6#isSet = false;
            if(!(#0#0.{core::List::length}{core::int}.{core::num::>=}(#C1){(core::num) → core::bool} && ((#0#4#isSet ?{core::int} #0#4{core::int} : let final core::bool* #t11 = #0#4#isSet = true in #0#4 = #0#0.{core::List::[]}(0){(core::int) → core::int}) is core::int && (let final core::int #t12 = a2 = #0#4#isSet ?{core::int} #0#4{core::int} : let final core::bool* #t13 = #0#4#isSet = true in #0#4 = #0#0.{core::List::[]}(0){(core::int) → core::int} in true)) && (let final core::int #t14 = b2 = #0#0.{core::List::[]}(1){(core::int) → core::int} in true) && ((#0#6#isSet ?{core::List<core::int>} #0#6{core::List<core::int>} : let final core::bool* #t15 = #0#6#isSet = true in #0#6 = #0#0.{core::List::sublist}(2){(core::int, [core::int?]) → core::List<core::int>}) is core::List<core::int> && (let final core::List<core::int> #t16 = c2 = #0#6#isSet ?{core::List<core::int>} #0#6{core::List<core::int>} : let final core::bool* #t17 = #0#6#isSet = true in #0#6 = #0#0.{core::List::sublist}(2){(core::int, [core::int?]) → core::List<core::int>} in true))))
              throw new core::StateError::•("Pattern matching error");
          }
          #t9.{core::List::add}{Invariant}(c2.{core::Iterable::first}{core::int}.{core::int::isEven}{core::bool}){(core::bool) → void};
        }
      }
    }
  } =>#t9;
}
static method test3() → core::Iterable<core::bool> {
  return block {
    final core::Set<core::bool> #t18 = new col::_Set::•<core::bool>();
    {
      synthesized core::Iterator<core::List<core::int>> :sync-for-iterator = core::_GrowableList::_literal1<core::List<core::int>>(core::_GrowableList::_literal4<core::int>(3, 4, 5, 6)).{core::Iterable::iterator}{core::Iterator<core::List<core::int>>};
      for (; :sync-for-iterator.{core::Iterator::moveNext}(){() → core::bool}; ) {
        final core::List<core::int> #t19 = :sync-for-iterator.{core::Iterator::current}{core::List<core::int>};
        {
          hoisted core::int a2;
          hoisted core::int b2;
          hoisted core::List<core::int> c2;
          {
            final synthesized core::List<core::int> #0#0 = #t19;
            synthesized core::int #0#4;
            synthesized core::bool #0#4#isSet = false;
            synthesized core::List<core::int> #0#6;
            synthesized core::bool #0#6#isSet = false;
            if(!(#0#0.{core::List::length}{core::int}.{core::num::>=}(#C1){(core::num) → core::bool} && ((#0#4#isSet ?{core::int} #0#4{core::int} : let final core::bool* #t20 = #0#4#isSet = true in #0#4 = #0#0.{core::List::[]}(0){(core::int) → core::int}) is core::int && (let final core::int #t21 = a2 = #0#4#isSet ?{core::int} #0#4{core::int} : let final core::bool* #t22 = #0#4#isSet = true in #0#4 = #0#0.{core::List::[]}(0){(core::int) → core::int} in true)) && (let final core::int #t23 = b2 = #0#0.{core::List::[]}(1){(core::int) → core::int} in true) && ((#0#6#isSet ?{core::List<core::int>} #0#6{core::List<core::int>} : let final core::bool* #t24 = #0#6#isSet = true in #0#6 = #0#0.{core::List::sublist}(2){(core::int, [core::int?]) → core::List<core::int>}) is core::List<core::int> && (let final core::List<core::int> #t25 = c2 = #0#6#isSet ?{core::List<core::int>} #0#6{core::List<core::int>} : let final core::bool* #t26 = #0#6#isSet = true in #0#6 = #0#0.{core::List::sublist}(2){(core::int, [core::int?]) → core::List<core::int>} in true))))
              throw new core::StateError::•("Pattern matching error");
          }
          #t18.{core::Set::add}{Invariant}(c2.{core::Iterable::first}{core::int}.{core::int::isEven}{core::bool}){(core::bool) → core::bool};
        }
      }
    }
  } =>#t18;
}
static method test4() → dynamic {
  return block {
    final core::Map<core::int, core::bool> #t27 = <core::int, core::bool>{};
    {
      synthesized core::Iterator<core::List<core::int>> :sync-for-iterator = core::_GrowableList::_literal1<core::List<core::int>>(core::_GrowableList::_literal4<core::int>(3, 4, 5, 6)).{core::Iterable::iterator}{core::Iterator<core::List<core::int>>};
      for (; :sync-for-iterator.{core::Iterator::moveNext}(){() → core::bool}; ) {
        final core::List<core::int> #t28 = :sync-for-iterator.{core::Iterator::current}{core::List<core::int>};
        {
          hoisted core::int a2;
          hoisted core::int b2;
          hoisted core::List<core::int> c2;
          {
            final synthesized core::List<core::int> #0#0 = #t28;
            synthesized core::int #0#4;
            synthesized core::bool #0#4#isSet = false;
            synthesized core::List<core::int> #0#6;
            synthesized core::bool #0#6#isSet = false;
            if(!(#0#0.{core::List::length}{core::int}.{core::num::>=}(#C1){(core::num) → core::bool} && ((#0#4#isSet ?{core::int} #0#4{core::int} : let final core::bool* #t29 = #0#4#isSet = true in #0#4 = #0#0.{core::List::[]}(0){(core::int) → core::int}) is core::int && (let final core::int #t30 = a2 = #0#4#isSet ?{core::int} #0#4{core::int} : let final core::bool* #t31 = #0#4#isSet = true in #0#4 = #0#0.{core::List::[]}(0){(core::int) → core::int} in true)) && (let final core::int #t32 = b2 = #0#0.{core::List::[]}(1){(core::int) → core::int} in true) && ((#0#6#isSet ?{core::List<core::int>} #0#6{core::List<core::int>} : let final core::bool* #t33 = #0#6#isSet = true in #0#6 = #0#0.{core::List::sublist}(2){(core::int, [core::int?]) → core::List<core::int>}) is core::List<core::int> && (let final core::List<core::int> #t34 = c2 = #0#6#isSet ?{core::List<core::int>} #0#6{core::List<core::int>} : let final core::bool* #t35 = #0#6#isSet = true in #0#6 = #0#0.{core::List::sublist}(2){(core::int, [core::int?]) → core::List<core::int>} in true))))
              throw new core::StateError::•("Pattern matching error");
          }
          #t27.{core::Map::[]=}{Invariant}(c2.{core::Iterable::first}{core::int}, c2.{core::Iterable::first}{core::int}.{core::int::isEven}{core::bool}){(core::int, core::bool) → void};
        }
      }
    }
  } =>#t27;
}

constants  {
  #C1 = 2
}
