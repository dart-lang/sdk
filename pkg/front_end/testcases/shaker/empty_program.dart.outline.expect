This file was autogenerated from running the shaker test suite.
To update this file, either copy the output from a failing test or run
pkg/front_end/tool/fasta testing shaker -DupdateExpectations=true
----- pkg/front_end/testcases/shaker/empty_program.dart
library;
import self as self;

static method main() → dynamic;

----- external dart:async
library dart.async;
import self as self;
import "dart:core" as core;

typedef ControllerCallback = () → void;
typedef ControllerCancelCallback = () → dynamic;
class _AsyncStarStreamController<T extends core::Object> extends core::Object {
  field self::StreamController<self::_AsyncStarStreamController::T> controller;
  field core::Function asyncStarBody;
  field core::bool isAdding;
  field core::bool onListenReceived;
  field core::bool isScheduled;
  field core::bool isSuspendedAtYield;
  field self::Completer<dynamic> cancellationCompleter;
  constructor •(core::Function asyncStarBody) → void;
  get stream() → self::Stream<self::_AsyncStarStreamController::T>;
  method runBody() → void;
  method scheduleGenerator() → void;
  method add(self::_AsyncStarStreamController::T event) → core::bool;
  method addStream(self::Stream<self::_AsyncStarStreamController::T> stream) → core::bool;
  method addError(core::Object error, core::StackTrace stackTrace) → void;
  method close() → dynamic;
  method onListen() → dynamic;
  method onResume() → dynamic;
  method onCancel() → dynamic;
}
abstract class FutureOr<T extends core::Object> extends core::Object {
}
abstract class Future<T extends core::Object> extends core::Object {
  static factory microtask<T extends core::Object>(() → self::FutureOr<self::Future::microtask::T> computation) → self::Future<self::Future::microtask::T>;
  abstract method then<S extends core::Object>((self::Future::T) → self::FutureOr<self::Future::then::S> onValue, {core::Function onError}) → self::Future<self::Future::then::S>;
  abstract method catchError(core::Function onError, {(core::Object) → core::bool test}) → self::Future<self::Future::T>;
  abstract method whenComplete(() → self::FutureOr<dynamic> action) → self::Future<self::Future::T>;
  abstract method asStream() → self::Stream<self::Future::T>;
  abstract method timeout(core::Duration timeLimit, {() → self::FutureOr<self::Future::T> onTimeout}) → self::Future<self::Future::T>;
}
abstract class Completer<T extends core::Object> extends core::Object {
  static factory sync<T extends core::Object>() → self::Completer<self::Completer::sync::T>;
  abstract get future() → self::Future<self::Completer::T>;
  abstract method complete([self::FutureOr<self::Completer::T> value]) → void;
  abstract method completeError(core::Object error, [core::StackTrace stackTrace]) → void;
  abstract get isCompleted() → core::bool;
}
abstract class Stream<T extends core::Object> extends core::Object {
  get isBroadcast() → core::bool;
  method asBroadcastStream({(self::StreamSubscription<self::Stream::T>) → void onListen, (self::StreamSubscription<self::Stream::T>) → void onCancel}) → self::Stream<self::Stream::T>;
  abstract method listen((self::Stream::T) → void onData, {core::Function onError, () → void onDone, core::bool cancelOnError}) → self::StreamSubscription<self::Stream::T>;
  method where((self::Stream::T) → core::bool test) → self::Stream<self::Stream::T>;
  method map<S extends core::Object>((self::Stream::T) → self::Stream::map::S convert) → self::Stream<self::Stream::map::S>;
  method asyncMap<E extends core::Object>((self::Stream::T) → self::FutureOr<self::Stream::asyncMap::E> convert) → self::Stream<self::Stream::asyncMap::E>;
  method asyncExpand<E extends core::Object>((self::Stream::T) → self::Stream<self::Stream::asyncExpand::E> convert) → self::Stream<self::Stream::asyncExpand::E>;
  method handleError(core::Function onError, {(dynamic) → core::bool test}) → self::Stream<self::Stream::T>;
  method expand<S extends core::Object>((self::Stream::T) → core::Iterable<self::Stream::expand::S> convert) → self::Stream<self::Stream::expand::S>;
  method pipe(self::StreamConsumer<self::Stream::T> streamConsumer) → self::Future<dynamic>;
  method transform<S extends core::Object>(self::StreamTransformer<self::Stream::T, self::Stream::transform::S> streamTransformer) → self::Stream<self::Stream::transform::S>;
  method reduce((self::Stream::T, self::Stream::T) → self::Stream::T combine) → self::Future<self::Stream::T>;
  method fold<S extends core::Object>(self::Stream::fold::S initialValue, (self::Stream::fold::S, self::Stream::T) → self::Stream::fold::S combine) → self::Future<self::Stream::fold::S>;
  method join([core::String separator]) → self::Future<core::String>;
  method contains(core::Object needle) → self::Future<core::bool>;
  method forEach((self::Stream::T) → void action) → self::Future<dynamic>;
  method every((self::Stream::T) → core::bool test) → self::Future<core::bool>;
  method any((self::Stream::T) → core::bool test) → self::Future<core::bool>;
  get length() → self::Future<core::int>;
  get isEmpty() → self::Future<core::bool>;
  method cast<R extends core::Object>() → self::Stream<self::Stream::cast::R>;
  method retype<R extends core::Object>() → self::Stream<self::Stream::retype::R>;
  method toList() → self::Future<core::List<self::Stream::T>>;
  method toSet() → self::Future<core::Set<self::Stream::T>>;
  method drain<E extends core::Object>([self::Stream::drain::E futureValue]) → self::Future<self::Stream::drain::E>;
  method take(core::int count) → self::Stream<self::Stream::T>;
  method takeWhile((self::Stream::T) → core::bool test) → self::Stream<self::Stream::T>;
  method skip(core::int count) → self::Stream<self::Stream::T>;
  method skipWhile((self::Stream::T) → core::bool test) → self::Stream<self::Stream::T>;
  method distinct([(self::Stream::T, self::Stream::T) → core::bool equals]) → self::Stream<self::Stream::T>;
  get first() → self::Future<self::Stream::T>;
  get last() → self::Future<self::Stream::T>;
  get single() → self::Future<self::Stream::T>;
  method firstWhere((self::Stream::T) → core::bool test, {() → self::Stream::T orElse}) → self::Future<self::Stream::T>;
  method lastWhere((self::Stream::T) → core::bool test, {() → self::Stream::T orElse}) → self::Future<self::Stream::T>;
  method singleWhere((self::Stream::T) → core::bool test, {() → self::Stream::T orElse}) → self::Future<self::Stream::T>;
  method elementAt(core::int index) → self::Future<self::Stream::T>;
  method timeout(core::Duration timeLimit, {(self::EventSink<self::Stream::T>) → void onTimeout}) → self::Stream<self::Stream::T>;
}
abstract class StreamSubscription<T extends core::Object> extends core::Object {
  abstract method cancel() → self::Future<dynamic>;
  abstract method onData((self::StreamSubscription::T) → void handleData) → void;
  abstract method onError(core::Function handleError) → void;
  abstract method onDone(() → void handleDone) → void;
  abstract method pause([self::Future<dynamic> resumeSignal]) → void;
  abstract method resume() → void;
  abstract get isPaused() → core::bool;
  abstract method asFuture<E extends core::Object>([self::StreamSubscription::asFuture::E futureValue]) → self::Future<self::StreamSubscription::asFuture::E>;
}
abstract class EventSink<T extends core::Object> extends core::Object implements core::Sink<self::EventSink::T> {
  abstract method add(self::EventSink::T event) → void;
  abstract method addError(core::Object error, [core::StackTrace stackTrace]) → void;
  abstract method close() → void;
}
abstract class StreamConsumer<S extends core::Object> extends core::Object {
  abstract method addStream(self::Stream<self::StreamConsumer::S> stream) → self::Future<dynamic>;
  abstract method close() → self::Future<dynamic>;
}
abstract class StreamSink<S extends core::Object> extends core::Object implements self::EventSink<self::StreamSink::S>, self::StreamConsumer<self::StreamSink::S> {
  abstract method close() → self::Future<dynamic>;
  abstract get done() → self::Future<dynamic>;
}
abstract class StreamTransformer<S extends core::Object, T extends core::Object> extends core::Object {
  abstract method bind(self::Stream<self::StreamTransformer::S> stream) → self::Stream<self::StreamTransformer::T>;
  abstract method cast<RS extends core::Object, RT extends core::Object>() → self::StreamTransformer<self::StreamTransformer::cast::RS, self::StreamTransformer::cast::RT>;
  abstract method retype<RS extends core::Object, RT extends core::Object>() → self::StreamTransformer<self::StreamTransformer::retype::RS, self::StreamTransformer::retype::RT>;
}
abstract class StreamIterator<T extends core::Object> extends core::Object {
  abstract method moveNext() → self::Future<core::bool>;
  abstract get current() → self::StreamIterator::T;
  abstract method cancel() → self::Future<dynamic>;
}
abstract class StreamController<T extends core::Object> extends core::Object implements self::StreamSink<self::StreamController::T> {
  abstract get stream() → self::Stream<self::StreamController::T>;
  abstract get onListen() → () → void;
  abstract set onListen(() → void onListenHandler) → void;
  abstract get onPause() → () → void;
  abstract set onPause(() → void onPauseHandler) → void;
  abstract get onResume() → () → void;
  abstract set onResume(() → void onResumeHandler) → void;
  abstract get onCancel() → () → dynamic;
  abstract set onCancel(() → dynamic onCancelHandler) → void;
  abstract get sink() → self::StreamSink<self::StreamController::T>;
  abstract get isClosed() → core::bool;
  abstract get isPaused() → core::bool;
  abstract get hasListener() → core::bool;
  abstract method add(self::StreamController::T event) → void;
  abstract method addError(core::Object error, [core::StackTrace stackTrace]) → void;
  abstract method close() → self::Future<dynamic>;
  abstract method addStream(self::Stream<self::StreamController::T> source, {core::bool cancelOnError}) → self::Future<dynamic>;
}
class _StreamIterator<T extends core::Object> extends core::Object implements self::StreamIterator<self::_StreamIterator::T> {
  constructor •(final self::Stream<self::_StreamIterator::T> stream) → void;
  get current() → self::_StreamIterator::T;
  method moveNext() → self::Future<core::bool>;
  method cancel() → self::Future<dynamic>;
}
static method _asyncThenWrapperHelper(dynamic continuation) → core::Function;
static method _asyncErrorWrapperHelper(dynamic continuation) → core::Function;
static method _awaitHelper(dynamic object, core::Function thenCallback, core::Function errorCallback, dynamic awaiter) → self::Future<dynamic>;

----- external dart:collection
library dart.collection;
import self as self;
import "dart:core" as core;

abstract class IterableBase<E extends core::Object> extends core::Iterable<self::IterableBase::E> {
}

----- external dart:_internal
library dart._internal;
import self as self;
import "dart:core" as core;

class ExternalName extends core::Object {
  final field core::String name;
  const constructor •(core::String name) → void;
}
abstract class EfficientLengthIterable<T extends core::Object> extends core::Iterable<self::EfficientLengthIterable::T> {
  abstract get length() → core::int;
}
class Symbol extends core::Object implements core::Symbol {
  operator ==(dynamic other) → core::bool;
  external get hashCode() → core::int;
  external method toString() → dynamic;
}

----- external dart:math
library dart.math;
import self as self;
import "dart:core" as core;

abstract class Random extends core::Object {
  abstract method nextInt(core::int max) → core::int;
  abstract method nextDouble() → core::double;
  abstract method nextBool() → core::bool;
}

----- external dart:core
library dart.core;
import self as self;
import "dart:collection" as col;
import "dart:_internal" as _in;
import "dart:math" as math;

typedef _SyncGeneratorCallback<T extends self::Object> = (self::_SyncIterator<T>) → self::bool;
class _SyncIterable<T extends self::Object> extends col::IterableBase<self::_SyncIterable::T> {
  const constructor •((self::_SyncIterator<self::_SyncIterable::T>) → self::bool _moveNextFn) → void;
  get iterator() → self::Iterator<self::_SyncIterable::T>;
}
class _SyncIterator<T extends self::Object> extends self::Object implements self::Iterator<self::_SyncIterator::T> {
  get current() → self::_SyncIterator::T;
  method moveNext() → self::bool;
}
class _CompileTimeError extends self::Error {
  constructor •(self::String _errorMsg) → void;
  method toString() → self::String;
}
class _DuplicatedFieldInitializerError extends self::Error {
  constructor •(self::String _name) → void;
  method toString() → dynamic;
}
class _InvocationMirror extends self::Object implements self::Invocation {
  constructor _withoutType(self::String _functionName, self::List<self::Type> _typeArguments, self::List<dynamic> _positionalArguments, self::Map<self::Symbol, dynamic> _namedArguments, self::bool _isSuperInvocation) → void;
  get memberName() → self::Symbol;
  get typeArguments() → self::List<self::Type>;
  get positionalArguments() → self::List<dynamic>;
  get namedArguments() → self::Map<self::Symbol, dynamic>;
  get isMethod() → self::bool;
  get isAccessor() → self::bool;
  get isGetter() → self::bool;
  get isSetter() → self::bool;
}
class bool extends self::Object {
  external get hashCode() → self::int;
  method toString() → self::String;
}
abstract class Comparable<T extends self::Object> extends self::Object {
  abstract method compareTo(self::Comparable::T other) → self::int;
}
abstract class double extends self::num {
  abstract method remainder(self::num other) → self::double;
  abstract operator +(self::num other) → self::double;
  abstract operator -(self::num other) → self::double;
  abstract operator *(self::num other) → self::double;
  abstract operator %(self::num other) → self::double;
  abstract operator /(self::num other) → self::double;
  abstract operator ~/(self::num other) → self::int;
  abstract operator unary-() → self::double;
  abstract method abs() → self::double;
  abstract get sign() → self::double;
  abstract method round() → self::int;
  abstract method floor() → self::int;
  abstract method ceil() → self::int;
  abstract method truncate() → self::int;
  abstract method roundToDouble() → self::double;
  abstract method floorToDouble() → self::double;
  abstract method ceilToDouble() → self::double;
  abstract method truncateToDouble() → self::double;
  abstract method toString() → self::String;
}
class Duration extends self::Object implements self::Comparable<self::Duration> {
  operator +(self::Duration other) → self::Duration;
  operator -(self::Duration other) → self::Duration;
  operator *(self::num factor) → self::Duration;
  operator ~/(self::int quotient) → self::Duration;
  operator <(self::Duration other) → self::bool;
  operator >(self::Duration other) → self::bool;
  operator <=(self::Duration other) → self::bool;
  operator >=(self::Duration other) → self::bool;
  get inDays() → self::int;
  get inHours() → self::int;
  get inMinutes() → self::int;
  get inSeconds() → self::int;
  get inMilliseconds() → self::int;
  get inMicroseconds() → self::int;
  operator ==(dynamic other) → self::bool;
  get hashCode() → self::int;
  method compareTo(self::Duration other) → self::int;
  method toString() → self::String;
  get isNegative() → self::bool;
  method abs() → self::Duration;
  operator unary-() → self::Duration;
}
class Error extends self::Object {
  external get stackTrace() → self::StackTrace;
}
class FallThroughError extends self::Error {
  external constructor _create(self::String url, self::int line) → void;
  external method toString() → self::String;
}
class _ConstantExpressionError extends self::Object {
  const constructor •() → void;
}
abstract class Function extends self::Object {
  abstract get hashCode() → self::int;
  abstract operator ==(self::Object other) → self::bool;
}
abstract class int extends self::num {
  abstract operator &(self::int other) → self::int;
  abstract operator |(self::int other) → self::int;
  abstract operator ^(self::int other) → self::int;
  abstract operator ~() → self::int;
  abstract operator <<(self::int shiftAmount) → self::int;
  abstract operator >>(self::int shiftAmount) → self::int;
  abstract method modPow(self::int exponent, self::int modulus) → self::int;
  abstract method modInverse(self::int modulus) → self::int;
  abstract method gcd(self::int other) → self::int;
  abstract get isEven() → self::bool;
  abstract get isOdd() → self::bool;
  abstract get bitLength() → self::int;
  abstract method toUnsigned(self::int width) → self::int;
  abstract method toSigned(self::int width) → self::int;
  abstract operator unary-() → self::int;
  abstract method abs() → self::int;
  abstract get sign() → self::int;
  abstract method round() → self::int;
  abstract method floor() → self::int;
  abstract method ceil() → self::int;
  abstract method truncate() → self::int;
  abstract method roundToDouble() → self::double;
  abstract method floorToDouble() → self::double;
  abstract method ceilToDouble() → self::double;
  abstract method truncateToDouble() → self::double;
  abstract method toString() → self::String;
  abstract method toRadixString(self::int radix) → self::String;
}
abstract class Invocation extends self::Object {
  abstract get memberName() → self::Symbol;
  get typeArguments() → self::List<self::Type>;
  abstract get positionalArguments() → self::List<dynamic>;
  abstract get namedArguments() → self::Map<self::Symbol, dynamic>;
  abstract get isMethod() → self::bool;
  abstract get isGetter() → self::bool;
  abstract get isSetter() → self::bool;
  get isAccessor() → self::bool;
}
abstract class Iterable<E extends self::Object> extends self::Object {
  abstract get iterator() → self::Iterator<self::Iterable::E>;
  method cast<R extends self::Object>() → self::Iterable<self::Iterable::cast::R>;
  method retype<R extends self::Object>() → self::Iterable<self::Iterable::retype::R>;
  method followedBy(self::Iterable<self::Iterable::E> other) → self::Iterable<self::Iterable::E>;
  method map<T extends self::Object>((self::Iterable::E) → self::Iterable::map::T f) → self::Iterable<self::Iterable::map::T>;
  method where((self::Iterable::E) → self::bool test) → self::Iterable<self::Iterable::E>;
  method whereType<T extends self::Object>() → self::Iterable<self::Iterable::whereType::T>;
  method expand<T extends self::Object>((self::Iterable::E) → self::Iterable<self::Iterable::expand::T> f) → self::Iterable<self::Iterable::expand::T>;
  method contains(self::Object element) → self::bool;
  method forEach((self::Iterable::E) → void f) → void;
  method reduce((self::Iterable::E, self::Iterable::E) → self::Iterable::E combine) → self::Iterable::E;
  method fold<T extends self::Object>(self::Iterable::fold::T initialValue, (self::Iterable::fold::T, self::Iterable::E) → self::Iterable::fold::T combine) → self::Iterable::fold::T;
  method every((self::Iterable::E) → self::bool test) → self::bool;
  method join([self::String separator]) → self::String;
  method any((self::Iterable::E) → self::bool test) → self::bool;
  method toList({self::bool growable}) → self::List<self::Iterable::E>;
  method toSet() → self::Set<self::Iterable::E>;
  get length() → self::int;
  get isEmpty() → self::bool;
  get isNotEmpty() → self::bool;
  method take(self::int count) → self::Iterable<self::Iterable::E>;
  method takeWhile((self::Iterable::E) → self::bool test) → self::Iterable<self::Iterable::E>;
  method skip(self::int count) → self::Iterable<self::Iterable::E>;
  method skipWhile((self::Iterable::E) → self::bool test) → self::Iterable<self::Iterable::E>;
  get first() → self::Iterable::E;
  get last() → self::Iterable::E;
  get single() → self::Iterable::E;
  method firstWhere((self::Iterable::E) → self::bool test, {() → self::Iterable::E orElse}) → self::Iterable::E;
  method lastWhere((self::Iterable::E) → self::bool test, {() → self::Iterable::E orElse}) → self::Iterable::E;
  method singleWhere((self::Iterable::E) → self::bool test, {() → self::Iterable::E orElse}) → self::Iterable::E;
  method elementAt(self::int index) → self::Iterable::E;
  method toString() → self::String;
}
abstract class BidirectionalIterator<E extends self::Object> extends self::Object implements self::Iterator<self::BidirectionalIterator::E> {
  abstract method movePrevious() → self::bool;
}
abstract class Iterator<E extends self::Object> extends self::Object {
  abstract method moveNext() → self::bool;
  abstract get current() → self::Iterator::E;
}
abstract class List<E extends self::Object> extends self::Object implements _in::EfficientLengthIterable<self::List::E> {
  external static factory from<E extends self::Object>(self::Iterable<dynamic> elements, {self::bool growable}) → self::List<self::List::from::E>;
  abstract method cast<R extends self::Object>() → self::List<self::List::cast::R>;
  abstract method retype<R extends self::Object>() → self::List<self::List::retype::R>;
  abstract operator [](self::int index) → self::List::E;
  abstract operator []=(self::int index, self::List::E value) → void;
  abstract set first(self::List::E value) → void;
  abstract set last(self::List::E value) → void;
  abstract get length() → self::int;
  abstract set length(self::int newLength) → dynamic;
  abstract method add(self::List::E value) → void;
  abstract method addAll(self::Iterable<self::List::E> iterable) → void;
  abstract get reversed() → self::Iterable<self::List::E>;
  abstract method sort([(self::List::E, self::List::E) → self::int compare]) → void;
  abstract method shuffle([math::Random random]) → void;
  abstract method indexOf(self::List::E element, [self::int start]) → self::int;
  abstract method indexWhere((self::List::E) → self::bool test, [self::int start]) → self::int;
  abstract method lastIndexWhere((self::List::E) → self::bool test, [self::int start]) → self::int;
  abstract method lastIndexOf(self::List::E element, [self::int start]) → self::int;
  abstract method clear() → void;
  abstract method insert(self::int index, self::List::E element) → void;
  abstract method insertAll(self::int index, self::Iterable<self::List::E> iterable) → void;
  abstract method setAll(self::int index, self::Iterable<self::List::E> iterable) → void;
  abstract method remove(self::Object value) → self::bool;
  abstract method removeAt(self::int index) → self::List::E;
  abstract method removeLast() → self::List::E;
  abstract method removeWhere((self::List::E) → self::bool test) → void;
  abstract method retainWhere((self::List::E) → self::bool test) → void;
  abstract operator +(self::List<self::List::E> other) → self::List<self::List::E>;
  abstract method sublist(self::int start, [self::int end]) → self::List<self::List::E>;
  abstract method getRange(self::int start, self::int end) → self::Iterable<self::List::E>;
  abstract method setRange(self::int start, self::int end, self::Iterable<self::List::E> iterable, [self::int skipCount]) → void;
  abstract method removeRange(self::int start, self::int end) → void;
  abstract method fillRange(self::int start, self::int end, [self::List::E fillValue]) → void;
  abstract method replaceRange(self::int start, self::int end, self::Iterable<self::List::E> replacement) → void;
  abstract method asMap() → self::Map<self::int, self::List::E>;
}
abstract class Map<K extends self::Object, V extends self::Object> extends self::Object {
  abstract method cast<RK extends self::Object, RV extends self::Object>() → self::Map<self::Map::cast::RK, self::Map::cast::RV>;
  abstract method retype<RK extends self::Object, RV extends self::Object>() → self::Map<self::Map::retype::RK, self::Map::retype::RV>;
  abstract method containsValue(self::Object value) → self::bool;
  abstract method containsKey(self::Object key) → self::bool;
  abstract operator [](self::Object key) → self::Map::V;
  abstract operator []=(self::Map::K key, self::Map::V value) → void;
  abstract get entries() → self::Iterable<self::MapEntry<self::Map::K, self::Map::V>>;
  abstract method map<K2 extends self::Object, V2 extends self::Object>((self::Map::K, self::Map::V) → self::MapEntry<self::Map::map::K2, self::Map::map::V2> f) → self::Map<self::Map::map::K2, self::Map::map::V2>;
  abstract method addEntries(self::Iterable<self::MapEntry<self::Map::K, self::Map::V>> newEntries) → void;
  abstract method update(self::Map::K key, (self::Map::V) → self::Map::V update, {() → self::Map::V ifAbsent}) → self::Map::V;
  abstract method updateAll((self::Map::K, self::Map::V) → self::Map::V update) → void;
  abstract method removeWhere((self::Map::K, self::Map::V) → self::bool predicate) → void;
  abstract method putIfAbsent(self::Map::K key, () → self::Map::V ifAbsent) → self::Map::V;
  abstract method addAll(self::Map<self::Map::K, self::Map::V> other) → void;
  abstract method remove(self::Object key) → self::Map::V;
  abstract method clear() → void;
  abstract method forEach((self::Map::K, self::Map::V) → void f) → void;
  abstract get keys() → self::Iterable<self::Map::K>;
  abstract get values() → self::Iterable<self::Map::V>;
  abstract get length() → self::int;
  abstract get isEmpty() → self::bool;
  abstract get isNotEmpty() → self::bool;
}
class MapEntry<K extends self::Object, V extends self::Object> extends self::Object {
  final field self::MapEntry::K key;
  final field self::MapEntry::V value;
  method toString() → self::String;
}
class Null extends self::Object {
  external get hashCode() → self::int;
  method toString() → self::String;
}
abstract class num extends self::Object implements self::Comparable<self::num> {
  abstract operator ==(self::Object other) → self::bool;
  abstract get hashCode() → self::int;
  abstract method compareTo(self::num other) → self::int;
  abstract operator +(self::num other) → self::num;
  abstract operator -(self::num other) → self::num;
  abstract operator *(self::num other) → self::num;
  abstract operator %(self::num other) → self::num;
  abstract operator /(self::num other) → self::double;
  abstract operator ~/(self::num other) → self::int;
  abstract operator unary-() → self::num;
  abstract method remainder(self::num other) → self::num;
  abstract operator <(self::num other) → self::bool;
  abstract operator <=(self::num other) → self::bool;
  abstract operator >(self::num other) → self::bool;
  abstract operator >=(self::num other) → self::bool;
  abstract get isNaN() → self::bool;
  abstract get isNegative() → self::bool;
  abstract get isInfinite() → self::bool;
  abstract get isFinite() → self::bool;
  abstract method abs() → self::num;
  abstract get sign() → self::num;
  abstract method round() → self::int;
  abstract method floor() → self::int;
  abstract method ceil() → self::int;
  abstract method truncate() → self::int;
  abstract method roundToDouble() → self::double;
  abstract method floorToDouble() → self::double;
  abstract method ceilToDouble() → self::double;
  abstract method truncateToDouble() → self::double;
  abstract method clamp(self::num lowerLimit, self::num upperLimit) → self::num;
  abstract method toInt() → self::int;
  abstract method toDouble() → self::double;
  abstract method toStringAsFixed(self::int fractionDigits) → self::String;
  abstract method toStringAsExponential([self::int fractionDigits]) → self::String;
  abstract method toStringAsPrecision(self::int precision) → self::String;
  abstract method toString() → self::String;
}
class Object {
  static final field dynamic _hashCodeRnd;
  const constructor •() → void;
  static method _objectHashCode(dynamic obj) → self::int;
  get _identityHashCode() → self::int;
  static method _toString(dynamic obj) → self::String;
  static method _haveSameRuntimeType(dynamic a, dynamic b) → self::bool;
  method _instanceOf(dynamic instantiatorTypeArguments, dynamic functionTypeArguments, dynamic type) → self::bool;
  method _simpleInstanceOf(dynamic type) → self::bool;
  method _simpleInstanceOfTrue(dynamic type) → self::bool;
  method _simpleInstanceOfFalse(dynamic type) → self::bool;
  method _as(dynamic instantiatorTypeArguments, dynamic functionTypeArguments, dynamic type) → dynamic;
  external operator ==(dynamic other) → self::bool;
  external get hashCode() → self::int;
  external method toString() → self::String;
  external method noSuchMethod(self::Invocation invocation) → dynamic;
  external get runtimeType() → self::Type;
}
abstract class Pattern extends self::Object {
  abstract method allMatches(self::String string, [self::int start]) → self::Iterable<self::Match>;
  abstract method matchAsPrefix(self::String string, [self::int start]) → self::Match;
}
abstract class Match extends self::Object {
  abstract get start() → self::int;
  abstract get end() → self::int;
  abstract method group(self::int group) → self::String;
  abstract operator [](self::int group) → self::String;
  abstract method groups(self::List<self::int> groupIndices) → self::List<self::String>;
  abstract get groupCount() → self::int;
  abstract get input() → self::String;
  abstract get pattern() → self::Pattern;
}
abstract class Set<E extends self::Object> extends _in::EfficientLengthIterable<self::Set::E> {
  abstract method cast<R extends self::Object>() → self::Set<self::Set::cast::R>;
  abstract method retype<R extends self::Object>() → self::Set<self::Set::retype::R>;
  abstract get iterator() → self::Iterator<self::Set::E>;
  abstract method contains(self::Object value) → self::bool;
  abstract method add(self::Set::E value) → self::bool;
  abstract method addAll(self::Iterable<self::Set::E> elements) → void;
  abstract method remove(self::Object value) → self::bool;
  abstract method lookup(self::Object object) → self::Set::E;
  abstract method removeAll(self::Iterable<self::Object> elements) → void;
  abstract method retainAll(self::Iterable<self::Object> elements) → void;
  abstract method removeWhere((self::Set::E) → self::bool test) → void;
  abstract method retainWhere((self::Set::E) → self::bool test) → void;
  abstract method containsAll(self::Iterable<self::Object> other) → self::bool;
  abstract method intersection(self::Set<self::Object> other) → self::Set<self::Set::E>;
  abstract method union(self::Set<self::Set::E> other) → self::Set<self::Set::E>;
  abstract method difference(self::Set<self::Object> other) → self::Set<self::Set::E>;
  abstract method clear() → void;
  abstract method toSet() → self::Set<self::Set::E>;
}
abstract class Sink<T extends self::Object> extends self::Object {
  abstract method add(self::Sink::T data) → void;
  abstract method close() → void;
}
abstract class StackTrace extends self::Object {
  abstract method toString() → self::String;
}
abstract class String extends self::Object implements self::Comparable<self::String>, self::Pattern {
  abstract operator [](self::int index) → self::String;
  abstract method codeUnitAt(self::int index) → self::int;
  abstract get length() → self::int;
  abstract get hashCode() → self::int;
  abstract operator ==(self::Object other) → self::bool;
  abstract method endsWith(self::String other) → self::bool;
  abstract method startsWith(self::Pattern pattern, [self::int index]) → self::bool;
  abstract method indexOf(self::Pattern pattern, [self::int start]) → self::int;
  abstract method lastIndexOf(self::Pattern pattern, [self::int start]) → self::int;
  abstract get isEmpty() → self::bool;
  abstract get isNotEmpty() → self::bool;
  abstract operator +(self::String other) → self::String;
  abstract method substring(self::int startIndex, [self::int endIndex]) → self::String;
  abstract method trim() → self::String;
  abstract method trimLeft() → self::String;
  abstract method trimRight() → self::String;
  abstract operator *(self::int times) → self::String;
  abstract method padLeft(self::int width, [self::String padding]) → self::String;
  abstract method padRight(self::int width, [self::String padding]) → self::String;
  abstract method contains(self::Pattern other, [self::int startIndex]) → self::bool;
  abstract method replaceFirst(self::Pattern from, self::String to, [self::int startIndex]) → self::String;
  abstract method replaceFirstMapped(self::Pattern from, (self::Match) → self::String replace, [self::int startIndex]) → self::String;
  abstract method replaceAll(self::Pattern from, self::String replace) → self::String;
  abstract method replaceAllMapped(self::Pattern from, (self::Match) → self::String replace) → self::String;
  abstract method replaceRange(self::int start, self::int end, self::String replacement) → self::String;
  abstract method split(self::Pattern pattern) → self::List<self::String>;
  abstract method splitMapJoin(self::Pattern pattern, {(self::Match) → self::String onMatch, (self::String) → self::String onNonMatch}) → self::String;
  abstract get codeUnits() → self::List<self::int>;
  abstract get runes() → self::Runes;
  abstract method toLowerCase() → self::String;
  abstract method toUpperCase() → self::String;
}
class Runes extends self::Iterable<self::int> {
  final field self::String string;
  get iterator() → self::RuneIterator;
  get last() → self::int;
}
class RuneIterator extends self::Object implements self::BidirectionalIterator<self::int> {
  final field self::String string;
  get rawIndex() → self::int;
  set rawIndex(self::int rawIndex) → void;
  method reset([self::int rawIndex]) → void;
  get current() → self::int;
  get currentSize() → self::int;
  get currentAsString() → self::String;
  method moveNext() → self::bool;
  method movePrevious() → self::bool;
}
abstract class Symbol extends self::Object {
  abstract get hashCode() → self::int;
  abstract operator ==(dynamic other) → self::bool;
}
abstract class Type extends self::Object {
}
static method print(self::Object object) → void;

