DO NOT EDIT -- this file is autogenerated ---
----- pkg/front_end/testcases/shaker/transitive_annotations.dart
library;
import self as self;
import "./transitive_annotations_lib.dart" as tra;
import "dart:core" as core;

class X1 extends tra::C1 {
  default constructor •() → void
    : super tra::C1::•();
  @tra::forMethod2
  method publicMethodX1() → void;
  @tra::B2::•(tra::forSubexpression2)
  method publicMethodX2() → void;
}
static field tra::C2<core::int> y1;
static field () → void y2;
static field core::int y3;

----- external pkg/front_end/testcases/shaker/transitive_annotations_lib.dart
library;
import self as self;
import "dart:core" as core;

@self::forTypedef
typedef F1 = () → void;
class B1 extends core::Object {
  const constructor •(dynamic _) → void
    : super core::Object::•();
}
class B2 extends core::Object {
  const constructor •(dynamic _) → void
    : super core::Object::•();
}
class C1 extends core::Object {
  @self::forClassField
  field core::int publicField;
  default constructor •() → void
    : super core::Object::•();
  @self::forMethod1
  method publicMethod1() → void;
  @self::B1::•(self::forSubexpression1)
  method publicMethod2() → void;
}
class C2<T extends core::Object> extends core::Object {
  field self::C2::T field;
}
static const field dynamic forClassField = const core::Object::•();
static const field dynamic forMethod1 = const core::Object::•();
static const field dynamic forMethod2 = const core::Object::•();
static const field dynamic forSubexpression1 = const core::Object::•();
static const field dynamic forSubexpression2 = const core::Object::•();
static const field dynamic forTypedef = const core::Object::•();

