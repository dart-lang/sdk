library;
import self as self;
import "dart:core" as core;
import "dart:async" as asy;
import "dart:_internal" as _in;

import "dart:async";

class C extends core::Object {
  static field core::int* staticField = 1;
  field core::int* field = 1;
  synthetic constructor •() → self::C*
    : super core::Object::•()
    ;
  static get staticGetter() → core::int*
    return self::C::staticField;
  static set staticSetter(dynamic val) → void {
    self::C::staticField = val as{TypeError,ForDynamic} core::int*;
  }
  static method staticFoo(core::int* param) → core::int*
    return param;
  get getter() → core::int*
    return this.{self::C::field};
  set setter(dynamic val) → void {
    this.{self::C::field} = val as{TypeError,ForDynamic} core::int*;
  }
  method foo(core::int* param) → core::int*
    return param;
  abstract member-signature get _identityHashCode() → core::int*; -> core::Object::_identityHashCode
  abstract member-signature method _instanceOf(dynamic instantiatorTypeArguments, dynamic functionTypeArguments, dynamic type) → core::bool*; -> core::Object::_instanceOf
  abstract member-signature method _simpleInstanceOf(dynamic type) → core::bool*; -> core::Object::_simpleInstanceOf
  abstract member-signature method _simpleInstanceOfTrue(dynamic type) → core::bool*; -> core::Object::_simpleInstanceOfTrue
  abstract member-signature method _simpleInstanceOfFalse(dynamic type) → core::bool*; -> core::Object::_simpleInstanceOfFalse
  abstract member-signature operator ==(dynamic other) → core::bool*; -> core::Object::==
  abstract member-signature get hashCode() → core::int*; -> core::Object::hashCode
  abstract member-signature method toString() → core::String*; -> core::Object::toString
  abstract member-signature method noSuchMethod(core::Invocation* invocation) → dynamic; -> core::Object::noSuchMethod
  abstract member-signature get runtimeType() → core::Type*; -> core::Object::runtimeType
}
static field core::int* globalVariable = 1;
static final field core::bool* assertStatementsEnabled = (() → core::bool* {
  try {
    assert(false);
    return false;
  }
  on dynamic catch(final dynamic _) {
    return true;
  }
}).call();
static method topLevelFoo(core::int* param) → core::int*
  return 1;
static get topLevelGetter() → core::int*
  return self::globalVariable;
static set topLevelSetter(dynamic val) → void {
  self::globalVariable = val as{TypeError,ForDynamic} core::int*;
}
static method dummy() → dynamic
  return 1;
static method staticMembers() → dynamic /* originally async */ {
  final asy::_AsyncAwaitCompleter<dynamic>* :async_completer = new asy::_AsyncAwaitCompleter::•<dynamic>();
  FutureOr<dynamic>* :return_value;
  dynamic :async_stack_trace;
  (dynamic) →* dynamic :async_op_then;
  (core::Object*, core::StackTrace*) →* dynamic :async_op_error;
  core::int* :await_jump_var = 0;
  dynamic :await_ctx_var;
  dynamic :saved_try_context_var0;
  dynamic :async_temporary_0;
  dynamic :async_temporary_1;
  dynamic :async_temporary_2;
  dynamic :async_temporary_3;
  dynamic :async_temporary_4;
  dynamic :async_temporary_5;
  function :async_op([dynamic :result, dynamic :exception, dynamic :stack_trace]) → dynamic yielding 
    try {
      #L1:
      {
        :async_temporary_0 = self::C::staticField;
        [yield] let dynamic #t1 = asy::_awaitHelper(self::dummy(), :async_op_then, :async_op_error, :async_op) in null;
        core::num* a = _in::unsafeCast<core::int*>(:async_temporary_0).{core::num::+}(:result as{TypeError,ForDynamic} core::num);
        self::expect(2, a);
        :async_temporary_1 = self::C::staticField = 1;
        [yield] let dynamic #t2 = asy::_awaitHelper(self::dummy(), :async_op_then, :async_op_error, :async_op) in null;
        core::num* f = _in::unsafeCast<core::int*>(:async_temporary_1).{core::num::+}(:result as{TypeError,ForDynamic} core::num);
        self::expect(2, f);
        :async_temporary_2 = self::C::staticGetter;
        [yield] let dynamic #t3 = asy::_awaitHelper(self::dummy(), :async_op_then, :async_op_error, :async_op) in null;
        core::num* b = _in::unsafeCast<core::int*>(:async_temporary_2).{core::num::+}(:result as{TypeError,ForDynamic} core::num);
        self::expect(2, b);
        :async_temporary_3 = self::C::staticSetter = 1;
        [yield] let dynamic #t4 = asy::_awaitHelper(self::dummy(), :async_op_then, :async_op_error, :async_op) in null;
        core::num* c = _in::unsafeCast<core::int*>(:async_temporary_3).{core::num::+}(:result as{TypeError,ForDynamic} core::num);
        self::expect(2, c);
        :async_temporary_4 = self::C::staticFoo(2);
        [yield] let dynamic #t5 = asy::_awaitHelper(self::dummy(), :async_op_then, :async_op_error, :async_op) in null;
        core::num* d = _in::unsafeCast<core::int*>(:async_temporary_4).{core::num::+}(:result as{TypeError,ForDynamic} core::num);
        self::expect(3, d);
        :async_temporary_5 = self::C::staticField.{core::num::+}(self::C::staticGetter).{core::num::+}(self::C::staticSetter = 1).{core::num::+}(self::C::staticFoo(1));
        [yield] let dynamic #t6 = asy::_awaitHelper(self::dummy(), :async_op_then, :async_op_error, :async_op) in null;
        core::num* e = _in::unsafeCast<core::int*>(:async_temporary_5).{core::num::+}(:result as{TypeError,ForDynamic} core::num);
        self::expect(5, e);
      }
      asy::_completeOnAsyncReturn(:async_completer, :return_value);
      return;
    }
    on dynamic catch(dynamic exception, core::StackTrace* stack_trace) {
      :async_completer.{asy::Completer::completeError}(exception, stack_trace);
    }
  :async_stack_trace = asy::_asyncStackTraceHelper(:async_op);
  :async_op_then = asy::_asyncThenWrapperHelper(:async_op);
  :async_op_error = asy::_asyncErrorWrapperHelper(:async_op);
  :async_completer.{asy::_AsyncAwaitCompleter::start}(:async_op);
  return :async_completer.{asy::Completer::future};
}
static method topLevelMembers() → dynamic /* originally async */ {
  final asy::_AsyncAwaitCompleter<dynamic>* :async_completer = new asy::_AsyncAwaitCompleter::•<dynamic>();
  FutureOr<dynamic>* :return_value;
  dynamic :async_stack_trace;
  (dynamic) →* dynamic :async_op_then;
  (core::Object*, core::StackTrace*) →* dynamic :async_op_error;
  core::int* :await_jump_var = 0;
  dynamic :await_ctx_var;
  dynamic :saved_try_context_var0;
  dynamic :async_temporary_0;
  dynamic :async_temporary_1;
  dynamic :async_temporary_2;
  dynamic :async_temporary_3;
  dynamic :async_temporary_4;
  function :async_op([dynamic :result, dynamic :exception, dynamic :stack_trace]) → dynamic yielding 
    try {
      #L2:
      {
        :async_temporary_0 = self::globalVariable;
        [yield] let dynamic #t7 = asy::_awaitHelper(self::dummy(), :async_op_then, :async_op_error, :async_op) in null;
        core::num* a = _in::unsafeCast<core::int*>(:async_temporary_0).{core::num::+}(:result as{TypeError,ForDynamic} core::num);
        self::expect(2, a);
        :async_temporary_1 = self::topLevelGetter;
        [yield] let dynamic #t8 = asy::_awaitHelper(self::dummy(), :async_op_then, :async_op_error, :async_op) in null;
        core::num* b = _in::unsafeCast<core::int*>(:async_temporary_1).{core::num::+}(:result as{TypeError,ForDynamic} core::num);
        self::expect(2, b);
        :async_temporary_2 = self::topLevelSetter = 1;
        [yield] let dynamic #t9 = asy::_awaitHelper(self::dummy(), :async_op_then, :async_op_error, :async_op) in null;
        core::num* c = _in::unsafeCast<core::int*>(:async_temporary_2).{core::num::+}(:result as{TypeError,ForDynamic} core::num);
        self::expect(2, c);
        :async_temporary_3 = self::topLevelFoo(1);
        [yield] let dynamic #t10 = asy::_awaitHelper(self::dummy(), :async_op_then, :async_op_error, :async_op) in null;
        core::num* d = _in::unsafeCast<core::int*>(:async_temporary_3).{core::num::+}(:result as{TypeError,ForDynamic} core::num);
        self::expect(2, d);
        :async_temporary_4 = self::globalVariable.{core::num::+}(self::topLevelGetter).{core::num::+}(self::topLevelSetter = 1).{core::num::+}(self::topLevelFoo(1));
        [yield] let dynamic #t11 = asy::_awaitHelper(self::dummy(), :async_op_then, :async_op_error, :async_op) in null;
        core::num* e = _in::unsafeCast<core::int*>(:async_temporary_4).{core::num::+}(:result as{TypeError,ForDynamic} core::num);
        self::expect(5, e);
      }
      asy::_completeOnAsyncReturn(:async_completer, :return_value);
      return;
    }
    on dynamic catch(dynamic exception, core::StackTrace* stack_trace) {
      :async_completer.{asy::Completer::completeError}(exception, stack_trace);
    }
  :async_stack_trace = asy::_asyncStackTraceHelper(:async_op);
  :async_op_then = asy::_asyncThenWrapperHelper(:async_op);
  :async_op_error = asy::_asyncErrorWrapperHelper(:async_op);
  :async_completer.{asy::_AsyncAwaitCompleter::start}(:async_op);
  return :async_completer.{asy::Completer::future};
}
static method instanceMembers() → dynamic /* originally async */ {
  final asy::_AsyncAwaitCompleter<dynamic>* :async_completer = new asy::_AsyncAwaitCompleter::•<dynamic>();
  FutureOr<dynamic>* :return_value;
  dynamic :async_stack_trace;
  (dynamic) →* dynamic :async_op_then;
  (core::Object*, core::StackTrace*) →* dynamic :async_op_error;
  core::int* :await_jump_var = 0;
  dynamic :await_ctx_var;
  dynamic :saved_try_context_var0;
  dynamic :async_temporary_0;
  dynamic :async_temporary_1;
  dynamic :async_temporary_2;
  dynamic :async_temporary_3;
  dynamic :async_temporary_4;
  function :async_op([dynamic :result, dynamic :exception, dynamic :stack_trace]) → dynamic yielding 
    try {
      #L3:
      {
        self::C* inst = new self::C::•();
        :async_temporary_0 = inst.{self::C::field};
        [yield] let dynamic #t12 = asy::_awaitHelper(self::dummy(), :async_op_then, :async_op_error, :async_op) in null;
        core::num* a = _in::unsafeCast<core::int*>(:async_temporary_0).{core::num::+}(:result as{TypeError,ForDynamic} core::num);
        self::expect(2, a);
        :async_temporary_1 = inst.{self::C::getter};
        [yield] let dynamic #t13 = asy::_awaitHelper(self::dummy(), :async_op_then, :async_op_error, :async_op) in null;
        core::num* b = _in::unsafeCast<core::int*>(:async_temporary_1).{core::num::+}(:result as{TypeError,ForDynamic} core::num);
        self::expect(2, b);
        :async_temporary_2 = inst.{self::C::setter} = 1;
        [yield] let dynamic #t14 = asy::_awaitHelper(self::dummy(), :async_op_then, :async_op_error, :async_op) in null;
        core::num* c = _in::unsafeCast<core::int*>(:async_temporary_2).{core::num::+}(:result as{TypeError,ForDynamic} core::num);
        self::expect(2, c);
        :async_temporary_3 = inst.{self::C::foo}(1);
        [yield] let dynamic #t15 = asy::_awaitHelper(self::dummy(), :async_op_then, :async_op_error, :async_op) in null;
        core::num* d = _in::unsafeCast<core::int*>(:async_temporary_3).{core::num::+}(:result as{TypeError,ForDynamic} core::num);
        self::expect(2, d);
        :async_temporary_4 = inst.{self::C::field}.{core::num::+}(inst.{self::C::getter}).{core::num::+}(inst.{self::C::setter} = 1).{core::num::+}(inst.{self::C::foo}(1));
        [yield] let dynamic #t16 = asy::_awaitHelper(self::dummy(), :async_op_then, :async_op_error, :async_op) in null;
        core::num* e = _in::unsafeCast<core::int*>(:async_temporary_4).{core::num::+}(:result as{TypeError,ForDynamic} core::num);
        self::expect(5, e);
      }
      asy::_completeOnAsyncReturn(:async_completer, :return_value);
      return;
    }
    on dynamic catch(dynamic exception, core::StackTrace* stack_trace) {
      :async_completer.{asy::Completer::completeError}(exception, stack_trace);
    }
  :async_stack_trace = asy::_asyncStackTraceHelper(:async_op);
  :async_op_then = asy::_asyncThenWrapperHelper(:async_op);
  :async_op_error = asy::_asyncErrorWrapperHelper(:async_op);
  :async_completer.{asy::_AsyncAwaitCompleter::start}(:async_op);
  return :async_completer.{asy::Completer::future};
}
static method others() → dynamic /* originally async */ {
  final asy::_AsyncAwaitCompleter<dynamic>* :async_completer = new asy::_AsyncAwaitCompleter::•<dynamic>();
  FutureOr<dynamic>* :return_value;
  dynamic :async_stack_trace;
  (dynamic) →* dynamic :async_op_then;
  (core::Object*, core::StackTrace*) →* dynamic :async_op_error;
  core::int* :await_jump_var = 0;
  dynamic :await_ctx_var;
  dynamic :saved_try_context_var0;
  dynamic :async_temporary_0;
  dynamic :async_temporary_1;
  dynamic :async_temporary_2;
  dynamic :async_temporary_3;
  dynamic :async_temporary_4;
  function :async_op([dynamic :result, dynamic :exception, dynamic :stack_trace]) → dynamic yielding 
    try {
      #L4:
      {
        :async_temporary_0 = self::globalVariable;
        [yield] let dynamic #t17 = asy::_awaitHelper(self::dummy(), :async_op_then, :async_op_error, :async_op) in null;
        :async_temporary_0 = "${_in::unsafeCast<core::int*>(:async_temporary_0)} ${:result} ";
        [yield] let dynamic #t18 = asy::_awaitHelper("someString", :async_op_then, :async_op_error, :async_op) in null;
        core::String* a = _in::unsafeCast<core::String*>(:async_temporary_0).{core::String::+}(_in::unsafeCast<core::String*>(:result));
        self::expect("1 1 someString", a);
        self::C* c = new self::C::•();
        :async_temporary_1 = c.{self::C::field};
        [yield] let dynamic #t19 = asy::_awaitHelper(self::dummy(), :async_op_then, :async_op_error, :async_op) in null;
        core::num* d = _in::unsafeCast<core::int*>(:async_temporary_1).{core::num::+}(:result as{TypeError,ForDynamic} core::num);
        core::int* cnt = 2;
        core::List<core::int*>* b = <core::int*>[1, 2, 3];
        :async_temporary_3 = b;
        :async_temporary_2 = cnt;
        [yield] let dynamic #t20 = asy::_awaitHelper(self::dummy(), :async_op_then, :async_op_error, :async_op) in null;
        _in::unsafeCast<core::List<core::int*>*>(:async_temporary_3).{core::List::[]=}(_in::unsafeCast<core::int*>(:async_temporary_2), :result as{TypeError,ForDynamic} core::int*);
        self::expect(1, b.{core::List::[]}(cnt));
        :async_temporary_4 = b.{core::List::[]}(0);
        [yield] let dynamic #t21 = asy::_awaitHelper(self::dummy(), :async_op_then, :async_op_error, :async_op) in null;
        core::num* e = _in::unsafeCast<core::int*>(:async_temporary_4).{core::num::+}(:result as{TypeError,ForDynamic} core::num);
        self::expect(2, e);
      }
      asy::_completeOnAsyncReturn(:async_completer, :return_value);
      return;
    }
    on dynamic catch(dynamic exception, core::StackTrace* stack_trace) {
      :async_completer.{asy::Completer::completeError}(exception, stack_trace);
    }
  :async_stack_trace = asy::_asyncStackTraceHelper(:async_op);
  :async_op_then = asy::_asyncThenWrapperHelper(:async_op);
  :async_op_error = asy::_asyncErrorWrapperHelper(:async_op);
  :async_completer.{asy::_AsyncAwaitCompleter::start}(:async_op);
  return :async_completer.{asy::Completer::future};
}
static method conditionals() → dynamic /* originally async */ {
  final asy::_AsyncAwaitCompleter<dynamic>* :async_completer = new asy::_AsyncAwaitCompleter::•<dynamic>();
  FutureOr<dynamic>* :return_value;
  dynamic :async_stack_trace;
  (dynamic) →* dynamic :async_op_then;
  (core::Object*, core::StackTrace*) →* dynamic :async_op_error;
  core::int* :await_jump_var = 0;
  dynamic :await_ctx_var;
  dynamic :saved_try_context_var0;
  dynamic :saved_try_context_var1;
  core::bool* :async_temporary_0;
  dynamic :async_temporary_1;
  dynamic :async_temporary_2;
  dynamic :async_temporary_3;
  function :async_op([dynamic :result, dynamic :exception, dynamic :stack_trace]) → dynamic yielding 
    try {
      #L5:
      {
        core::bool* a = false;
        core::bool* b = true;
        :async_temporary_0 = (a || b).==(true);
        if(:async_temporary_0)
          ;
        else {
          [yield] let dynamic #t22 = asy::_awaitHelper(self::dummy(), :async_op_then, :async_op_error, :async_op) in null;
          :async_temporary_0 = (:result as{TypeError,ForDynamic} core::bool*).==(true);
        }
        core::bool* c = :async_temporary_0;
        self::expect(true, c);
        if(a || b) {
          :async_temporary_1 = a;
        }
        else {
          [yield] let dynamic #t23 = asy::_awaitHelper(self::dummy(), :async_op_then, :async_op_error, :async_op) in null;
          :async_temporary_1 = :result;
        }
        dynamic d = :async_temporary_1;
        self::expect(false, d);
        if(a is core::int*) {
          [yield] let dynamic #t24 = asy::_awaitHelper(self::dummy(), :async_op_then, :async_op_error, :async_op) in null;
          :async_temporary_2 = :result;
        }
        else {
          :async_temporary_2 = 2;
        }
        dynamic e = :async_temporary_2;
        self::expect(2, e);
        try {
          if(a is core::int*) {
            [yield] let dynamic #t25 = asy::_awaitHelper(self::dummy(), :async_op_then, :async_op_error, :async_op) in null;
            :async_temporary_3 = :result;
          }
          else {
            :async_temporary_3 = 2;
          }
          dynamic f = :async_temporary_3;
        }
        on dynamic catch(final dynamic e) {
        }
      }
      asy::_completeOnAsyncReturn(:async_completer, :return_value);
      return;
    }
    on dynamic catch(dynamic exception, core::StackTrace* stack_trace) {
      :async_completer.{asy::Completer::completeError}(exception, stack_trace);
    }
  :async_stack_trace = asy::_asyncStackTraceHelper(:async_op);
  :async_op_then = asy::_asyncThenWrapperHelper(:async_op);
  :async_op_error = asy::_asyncErrorWrapperHelper(:async_op);
  :async_completer.{asy::_AsyncAwaitCompleter::start}(:async_op);
  return :async_completer.{asy::Completer::future};
}
static method asserts() → dynamic /* originally async */ {
  final asy::_AsyncAwaitCompleter<dynamic>* :async_completer = new asy::_AsyncAwaitCompleter::•<dynamic>();
  FutureOr<dynamic>* :return_value;
  dynamic :async_stack_trace;
  (dynamic) →* dynamic :async_op_then;
  (core::Object*, core::StackTrace*) →* dynamic :async_op_error;
  core::int* :await_jump_var = 0;
  dynamic :await_ctx_var;
  dynamic :saved_try_context_var0;
  dynamic :saved_try_context_var1;
  function :async_op([dynamic :result, dynamic :exception, dynamic :stack_trace]) → dynamic yielding 
    try {
      #L6:
      {
        {
          core::Iterator<core::Function*>* :sync-for-iterator = <core::Function*>[#C1, #C2].{core::Iterable::iterator};
          for (; :sync-for-iterator.{core::Iterator::moveNext}(); ) {
            final core::Function* #t26 = :sync-for-iterator.{core::Iterator::current};
            {
              final <T extends core::Object* = dynamic>(T*) →* FutureOr<T*>* func = #t26 as{TypeError} <T extends core::Object* = dynamic>(T*) →* FutureOr<T*>*;
              assert {
                [yield] let dynamic #t27 = asy::_awaitHelper(func.call<core::bool*>(true), :async_op_then, :async_op_error, :async_op) in null;
                assert(_in::unsafeCast<core::bool*>(:result));
              }
              assert {
                if(self::id<core::bool*>(true) as{TypeError} core::bool*)
                  ;
                else {
                  [yield] let dynamic #t28 = asy::_awaitHelper(func.call<core::String*>("message"), :async_op_then, :async_op_error, :async_op) in null;
                  assert(false, _in::unsafeCast<core::String*>(:result));
                }
              }
              assert {
                [yield] let dynamic #t29 = asy::_awaitHelper(func.call<core::bool*>(true), :async_op_then, :async_op_error, :async_op) in null;
                if(_in::unsafeCast<core::bool*>(:result))
                  ;
                else {
                  [yield] let dynamic #t30 = asy::_awaitHelper(func.call<core::String*>("message"), :async_op_then, :async_op_error, :async_op) in null;
                  assert(false, _in::unsafeCast<core::String*>(:result));
                }
              }
              try {
                assert {
                  [yield] let dynamic #t31 = asy::_awaitHelper(func.call<core::bool*>(false), :async_op_then, :async_op_error, :async_op) in null;
                  if(_in::unsafeCast<core::bool*>(:result))
                    ;
                  else {
                    [yield] let dynamic #t32 = asy::_awaitHelper(func.call<core::String*>("message"), :async_op_then, :async_op_error, :async_op) in null;
                    assert(false, _in::unsafeCast<core::String*>(:result));
                  }
                }
                if(self::assertStatementsEnabled)
                  throw "Didn't throw";
              }
              on core::AssertionError* catch(final core::AssertionError* e) {
                self::expect("message", e.{core::AssertionError::message});
              }
            }
          }
        }
      }
      asy::_completeOnAsyncReturn(:async_completer, :return_value);
      return;
    }
    on dynamic catch(dynamic exception, core::StackTrace* stack_trace) {
      :async_completer.{asy::Completer::completeError}(exception, stack_trace);
    }
  :async_stack_trace = asy::_asyncStackTraceHelper(:async_op);
  :async_op_then = asy::_asyncThenWrapperHelper(:async_op);
  :async_op_error = asy::_asyncErrorWrapperHelper(:async_op);
  :async_completer.{asy::_AsyncAwaitCompleter::start}(:async_op);
  return :async_completer.{asy::Completer::future};
}
static method controlFlow() → dynamic /* originally async */ {
  final asy::_AsyncAwaitCompleter<dynamic>* :async_completer = new asy::_AsyncAwaitCompleter::•<dynamic>();
  FutureOr<dynamic>* :return_value;
  dynamic :async_stack_trace;
  (dynamic) →* dynamic :async_op_then;
  (core::Object*, core::StackTrace*) →* dynamic :async_op_error;
  core::int* :await_jump_var = 0;
  dynamic :await_ctx_var;
  dynamic :saved_try_context_var0;
  dynamic :saved_try_context_var1;
  dynamic :saved_try_context_var2;
  dynamic :saved_try_context_var3;
  dynamic :exception0;
  dynamic :stack_trace0;
  dynamic :async_temporary_0;
  dynamic :async_temporary_1;
  function :async_op([dynamic :result, dynamic :exception, dynamic :stack_trace]) → dynamic yielding 
    try {
      #L7:
      {
        {
          core::Iterator<core::Function*>* :sync-for-iterator = <core::Function*>[#C1, #C2].{core::Iterable::iterator};
          for (; :sync-for-iterator.{core::Iterator::moveNext}(); ) {
            final core::Function* #t33 = :sync-for-iterator.{core::Iterator::current};
            {
              final <T extends core::Object* = dynamic>(T*) →* FutureOr<T*>* func = #t33 as{TypeError} <T extends core::Object* = dynamic>(T*) →* FutureOr<T*>*;
              core::int* c = 0;
              {
                dynamic #t34 = true;
                core::int* #t35;
                #L8:
                while (true) {
                  core::int* i;
                  if(#t34) {
                    #t34 = false;
                    [yield] let dynamic #t36 = asy::_awaitHelper(func.call<core::int*>(0), :async_op_then, :async_op_error, :async_op) in null;
                    i = _in::unsafeCast<core::int*>(:result);
                  }
                  else {
                    i = #t35;
                    [yield] let dynamic #t37 = asy::_awaitHelper(func.call<core::int*>(let final core::int* #t38 = i in let final core::int* #t39 = i = #t38.{core::num::+}(1) in #t38), :async_op_then, :async_op_error, :async_op) in null;
                    _in::unsafeCast<core::int*>(:result);
                  }
                  [yield] let dynamic #t40 = asy::_awaitHelper(func.call<core::bool*>(i.{core::num::<}(5)), :async_op_then, :async_op_error, :async_op) in null;
                  if(_in::unsafeCast<core::bool*>(:result)) {
                    {
                      c = c.{core::num::+}(1);
                    }
                    #t35 = i;
                  }
                  else
                    break #L8;
                }
              }
              self::expect(5, c);
              c = 0;
              #L9:
              while (true) {
                [yield] let dynamic #t41 = asy::_awaitHelper(func.call<core::bool*>(c.{core::num::<}(5)), :async_op_then, :async_op_error, :async_op) in null;
                if(_in::unsafeCast<core::bool*>(:result))
                  c = c.{core::num::+}(1);
                else
                  break #L9;
              }
              self::expect(5, c);
              c = 0;
              do {
                c = c.{core::num::+}(1);
                [yield] let dynamic #t42 = asy::_awaitHelper(func.call<core::bool*>(c.{core::num::<}(5)), :async_op_then, :async_op_error, :async_op) in null;
              }
              while (_in::unsafeCast<core::bool*>(:result))
              self::expect(5, c);
              [yield] let dynamic #t43 = asy::_awaitHelper(func.call<core::bool*>(c.{core::num::==}(5)), :async_op_then, :async_op_error, :async_op) in null;
              if(_in::unsafeCast<core::bool*>(:result)) {
                self::expect(5, c);
              }
              else {
                throw "unreachable";
              }
              try {
                [yield] let dynamic #t44 = asy::_awaitHelper(func.call<core::String*>("string"), :async_op_then, :async_op_error, :async_op) in null;
                throw _in::unsafeCast<core::String*>(:result);
              }
              on core::String* catch(no-exception-var) {
              }
              try {
                [yield] let dynamic #t45 = asy::_awaitHelper(throw "string", :async_op_then, :async_op_error, :async_op) in null;
                _in::unsafeCast<<BottomType>>(:result);
              }
              on core::String* catch(no-exception-var) {
              }
              try
                try {
                  try
                    try {
                      throw "string";
                    }
                    on dynamic catch(final dynamic e) {
                      self::expect("string", e);
                      [yield] let dynamic #t46 = asy::_awaitHelper(func.call<core::int*>(0), :async_op_then, :async_op_error, :async_op) in null;
                      self::expect(0, _in::unsafeCast<core::int*>(:result));
                      rethrow;
                    }
                  finally {
                    [yield] let dynamic #t47 = asy::_awaitHelper(func.call<core::int*>(0), :async_op_then, :async_op_error, :async_op) in null;
                    self::expect(0, _in::unsafeCast<core::int*>(:result));
                  }
                }
                on dynamic catch(final dynamic e) {
                  [yield] let dynamic #t48 = asy::_awaitHelper(func.call<core::int*>(0), :async_op_then, :async_op_error, :async_op) in null;
                  self::expect(0, _in::unsafeCast<core::int*>(:result));
                  self::expect("string", e);
                }
              finally {
                [yield] let dynamic #t49 = asy::_awaitHelper(func.call<core::int*>(0), :async_op_then, :async_op_error, :async_op) in null;
                self::expect(0, _in::unsafeCast<core::int*>(:result));
              }
              #L10:
              {
                [yield] let dynamic #t50 = asy::_awaitHelper(func.call<core::int*>(2), :async_op_then, :async_op_error, :async_op) in null;
                switch(_in::unsafeCast<core::int*>(:result)) {
                  #L11:
                  case #C3:
                    {
                      break #L10;
                    }
                  #L12:
                  default:
                    {
                      throw "unreachable";
                    }
                }
              }
              [yield] let dynamic #t51 = asy::_awaitHelper((() → asy::Future<dynamic>* /* originally async */ {
                final asy::_AsyncAwaitCompleter<dynamic>* :async_completer = new asy::_AsyncAwaitCompleter::•<dynamic>();
                FutureOr<dynamic>* :return_value;
                dynamic :async_stack_trace;
                (dynamic) →* dynamic :async_op_then;
                (core::Object*, core::StackTrace*) →* dynamic :async_op_error;
                core::int* :await_jump_var = 0;
                dynamic :await_ctx_var;
                dynamic :saved_try_context_var0;
                function :async_op([dynamic :result, dynamic :exception, dynamic :stack_trace]) → dynamic yielding 
                  try {
                    #L13:
                    {
                      [yield] let dynamic #t52 = asy::_awaitHelper(func.call<dynamic>(42), :async_op_then, :async_op_error, :async_op) in null;
                      :return_value = :result;
                      break #L13;
                    }
                    asy::_completeOnAsyncReturn(:async_completer, :return_value);
                    return;
                  }
                  on dynamic catch(dynamic exception, core::StackTrace* stack_trace) {
                    :async_completer.{asy::Completer::completeError}(exception, stack_trace);
                  }
                :async_stack_trace = asy::_asyncStackTraceHelper(:async_op);
                :async_op_then = asy::_asyncThenWrapperHelper(:async_op);
                :async_op_error = asy::_asyncErrorWrapperHelper(:async_op);
                :async_completer.{asy::_AsyncAwaitCompleter::start}(:async_op);
                return :async_completer.{asy::Completer::future};
              }).call(), :async_op_then, :async_op_error, :async_op) in null;
              self::expect(42, :result);
              [yield] let dynamic #t53 = asy::_awaitHelper((() → asy::Future<dynamic>* /* originally async */ {
                final asy::_AsyncAwaitCompleter<dynamic>* :async_completer = new asy::_AsyncAwaitCompleter::•<dynamic>();
                FutureOr<dynamic>* :return_value;
                dynamic :async_stack_trace;
                (dynamic) →* dynamic :async_op_then;
                (core::Object*, core::StackTrace*) →* dynamic :async_op_error;
                core::int* :await_jump_var = 0;
                dynamic :await_ctx_var;
                function :async_op([dynamic :result, dynamic :exception, dynamic :stack_trace]) → dynamic yielding 
                  try {
                    #L14:
                    {
                      :return_value = func.call<dynamic>(42);
                      break #L14;
                    }
                    asy::_completeOnAsyncReturn(:async_completer, :return_value);
                    return;
                  }
                  on dynamic catch(dynamic exception, core::StackTrace* stack_trace) {
                    :async_completer.{asy::Completer::completeError}(exception, stack_trace);
                  }
                :async_stack_trace = asy::_asyncStackTraceHelper(:async_op);
                :async_op_then = asy::_asyncThenWrapperHelper(:async_op);
                :async_op_error = asy::_asyncErrorWrapperHelper(:async_op);
                :async_completer.{asy::_AsyncAwaitCompleter::start}(:async_op);
                return :async_completer.{asy::Completer::future};
              }).call(), :async_op_then, :async_op_error, :async_op) in null;
              self::expect(42, :result);
              function testStream1() → asy::Stream<core::int*>* /* originally async* */ {
                asy::_AsyncStarStreamController<core::int*>* :controller;
                dynamic :controller_stream;
                dynamic :async_stack_trace;
                (dynamic) →* dynamic :async_op_then;
                (core::Object*, core::StackTrace*) →* dynamic :async_op_error;
                core::int* :await_jump_var = 0;
                dynamic :await_ctx_var;
                dynamic :saved_try_context_var0;
                dynamic :saved_try_context_var1;
                function :async_op([dynamic :result, dynamic :exception, dynamic :stack_trace]) → dynamic yielding 
                  try
                    try {
                      #L15:
                      {
                        [yield] let dynamic #t54 = asy::_awaitHelper(func.call<core::int*>(42), :async_op_then, :async_op_error, :async_op) in null;
                        if(:controller.{asy::_AsyncStarStreamController::add}(_in::unsafeCast<core::int*>(:result)))
                          return null;
                        else
                          [yield] null;
                      }
                      return;
                    }
                    on dynamic catch(dynamic exception, core::StackTrace* stack_trace) {
                      :controller.{asy::_AsyncStarStreamController::addError}(exception, stack_trace);
                    }
                  finally {
                    :controller.{asy::_AsyncStarStreamController::close}();
                  }
                :async_stack_trace = asy::_asyncStackTraceHelper(:async_op);
                :async_op_then = asy::_asyncThenWrapperHelper(:async_op);
                :async_op_error = asy::_asyncErrorWrapperHelper(:async_op);
                :controller = new asy::_AsyncStarStreamController::•<core::int*>(:async_op);
                :controller_stream = :controller.{asy::_AsyncStarStreamController::stream};
                return :controller_stream;
              }
              :async_temporary_0 = <dynamic>[42];
              [yield] let dynamic #t55 = asy::_awaitHelper(testStream1.call().{asy::Stream::toList}(), :async_op_then, :async_op_error, :async_op) in null;
              self::expectList(_in::unsafeCast<core::List<dynamic>*>(:async_temporary_0), _in::unsafeCast<core::List<core::int*>>(:result));
              function testStream2() → asy::Stream<core::int*>* /* originally async* */ {
                asy::_AsyncStarStreamController<core::int*>* :controller;
                dynamic :controller_stream;
                dynamic :async_stack_trace;
                (dynamic) →* dynamic :async_op_then;
                (core::Object*, core::StackTrace*) →* dynamic :async_op_error;
                core::int* :await_jump_var = 0;
                dynamic :await_ctx_var;
                dynamic :saved_try_context_var0;
                dynamic :saved_try_context_var1;
                function :async_op([dynamic :result, dynamic :exception, dynamic :stack_trace]) → dynamic yielding 
                  try
                    try {
                      #L16:
                      {
                        [yield] let dynamic #t56 = asy::_awaitHelper(func.call<asy::Stream<core::int*>*>(self::intStream()), :async_op_then, :async_op_error, :async_op) in null;
                        if(:controller.{asy::_AsyncStarStreamController::addStream}(_in::unsafeCast<asy::Stream<core::int*>*>(:result)))
                          return null;
                        else
                          [yield] null;
                      }
                      return;
                    }
                    on dynamic catch(dynamic exception, core::StackTrace* stack_trace) {
                      :controller.{asy::_AsyncStarStreamController::addError}(exception, stack_trace);
                    }
                  finally {
                    :controller.{asy::_AsyncStarStreamController::close}();
                  }
                :async_stack_trace = asy::_asyncStackTraceHelper(:async_op);
                :async_op_then = asy::_asyncThenWrapperHelper(:async_op);
                :async_op_error = asy::_asyncErrorWrapperHelper(:async_op);
                :controller = new asy::_AsyncStarStreamController::•<core::int*>(:async_op);
                :controller_stream = :controller.{asy::_AsyncStarStreamController::stream};
                return :controller_stream;
              }
              :async_temporary_1 = <dynamic>[42];
              [yield] let dynamic #t57 = asy::_awaitHelper(testStream2.call().{asy::Stream::toList}(), :async_op_then, :async_op_error, :async_op) in null;
              self::expectList(_in::unsafeCast<core::List<dynamic>*>(:async_temporary_1), _in::unsafeCast<core::List<core::int*>>(:result));
            }
          }
        }
      }
      asy::_completeOnAsyncReturn(:async_completer, :return_value);
      return;
    }
    on dynamic catch(dynamic exception, core::StackTrace* stack_trace) {
      :async_completer.{asy::Completer::completeError}(exception, stack_trace);
    }
  :async_stack_trace = asy::_asyncStackTraceHelper(:async_op);
  :async_op_then = asy::_asyncThenWrapperHelper(:async_op);
  :async_op_error = asy::_asyncErrorWrapperHelper(:async_op);
  :async_completer.{asy::_AsyncAwaitCompleter::start}(:async_op);
  return :async_completer.{asy::Completer::future};
}
static method future<T extends core::Object* = dynamic>(self::future::T* value) → FutureOr<self::future::T*>* /* originally async */ {
  final asy::_AsyncAwaitCompleter<self::future::T*>* :async_completer = new asy::_AsyncAwaitCompleter::•<self::future::T*>();
  FutureOr<self::future::T*>* :return_value;
  dynamic :async_stack_trace;
  (dynamic) →* dynamic :async_op_then;
  (core::Object*, core::StackTrace*) →* dynamic :async_op_error;
  core::int* :await_jump_var = 0;
  dynamic :await_ctx_var;
  function :async_op([dynamic :result, dynamic :exception, dynamic :stack_trace]) → dynamic yielding 
    try {
      #L17:
      {
        :return_value = value;
        break #L17;
      }
      asy::_completeOnAsyncReturn(:async_completer, :return_value);
      return;
    }
    on dynamic catch(dynamic exception, core::StackTrace* stack_trace) {
      :async_completer.{asy::Completer::completeError}(exception, stack_trace);
    }
  :async_stack_trace = asy::_asyncStackTraceHelper(:async_op);
  :async_op_then = asy::_asyncThenWrapperHelper(:async_op);
  :async_op_error = asy::_asyncErrorWrapperHelper(:async_op);
  :async_completer.{asy::_AsyncAwaitCompleter::start}(:async_op);
  return :async_completer.{asy::Completer::future};
}
static method id<T extends core::Object* = dynamic>(self::id::T* value) → FutureOr<self::id::T*>*
  return value;
static method intStream() → asy::Stream<core::int*>* /* originally async* */ {
  asy::_AsyncStarStreamController<core::int*>* :controller;
  dynamic :controller_stream;
  dynamic :async_stack_trace;
  (dynamic) →* dynamic :async_op_then;
  (core::Object*, core::StackTrace*) →* dynamic :async_op_error;
  core::int* :await_jump_var = 0;
  dynamic :await_ctx_var;
  dynamic :saved_try_context_var0;
  dynamic :saved_try_context_var1;
  function :async_op([dynamic :result, dynamic :exception, dynamic :stack_trace]) → dynamic yielding 
    try
      try {
        #L18:
        {
          if(:controller.{asy::_AsyncStarStreamController::add}(42))
            return null;
          else
            [yield] null;
        }
        return;
      }
      on dynamic catch(dynamic exception, core::StackTrace* stack_trace) {
        :controller.{asy::_AsyncStarStreamController::addError}(exception, stack_trace);
      }
    finally {
      :controller.{asy::_AsyncStarStreamController::close}();
    }
  :async_stack_trace = asy::_asyncStackTraceHelper(:async_op);
  :async_op_then = asy::_asyncThenWrapperHelper(:async_op);
  :async_op_error = asy::_asyncErrorWrapperHelper(:async_op);
  :controller = new asy::_AsyncStarStreamController::•<core::int*>(:async_op);
  :controller_stream = :controller.{asy::_AsyncStarStreamController::stream};
  return :controller_stream;
}
static method main() → dynamic /* originally async */ {
  final asy::_AsyncAwaitCompleter<dynamic>* :async_completer = new asy::_AsyncAwaitCompleter::•<dynamic>();
  FutureOr<dynamic>* :return_value;
  dynamic :async_stack_trace;
  (dynamic) →* dynamic :async_op_then;
  (core::Object*, core::StackTrace*) →* dynamic :async_op_error;
  core::int* :await_jump_var = 0;
  dynamic :await_ctx_var;
  dynamic :saved_try_context_var0;
  function :async_op([dynamic :result, dynamic :exception, dynamic :stack_trace]) → dynamic yielding 
    try {
      #L19:
      {
        for (core::int* i = 0; i.{core::num::<}(11); i = i.{core::num::+}(1)) {
          [yield] let dynamic #t58 = asy::_awaitHelper(self::staticMembers(), :async_op_then, :async_op_error, :async_op) in null;
          :result;
          [yield] let dynamic #t59 = asy::_awaitHelper(self::topLevelMembers(), :async_op_then, :async_op_error, :async_op) in null;
          :result;
          [yield] let dynamic #t60 = asy::_awaitHelper(self::instanceMembers(), :async_op_then, :async_op_error, :async_op) in null;
          :result;
          [yield] let dynamic #t61 = asy::_awaitHelper(self::conditionals(), :async_op_then, :async_op_error, :async_op) in null;
          :result;
          [yield] let dynamic #t62 = asy::_awaitHelper(self::others(), :async_op_then, :async_op_error, :async_op) in null;
          :result;
          [yield] let dynamic #t63 = asy::_awaitHelper(self::asserts(), :async_op_then, :async_op_error, :async_op) in null;
          :result;
          [yield] let dynamic #t64 = asy::_awaitHelper(self::controlFlow(), :async_op_then, :async_op_error, :async_op) in null;
          :result;
        }
      }
      asy::_completeOnAsyncReturn(:async_completer, :return_value);
      return;
    }
    on dynamic catch(dynamic exception, core::StackTrace* stack_trace) {
      :async_completer.{asy::Completer::completeError}(exception, stack_trace);
    }
  :async_stack_trace = asy::_asyncStackTraceHelper(:async_op);
  :async_op_then = asy::_asyncThenWrapperHelper(:async_op);
  :async_op_error = asy::_asyncErrorWrapperHelper(:async_op);
  :async_completer.{asy::_AsyncAwaitCompleter::start}(:async_op);
  return :async_completer.{asy::Completer::future};
}
static method expect(dynamic expected, dynamic actual) → dynamic {
  if(!expected.{core::Object::==}(actual))
    throw "Expected ${expected}, actual ${actual}";
}
static method expectList(core::List<dynamic>* expected, core::List<dynamic>* actual) → dynamic {
  if(!expected.{core::List::length}.{core::num::==}(actual.{core::List::length})) {
    throw "Expected ${expected}, actual ${actual}";
  }
  for (core::int* i = 0; i.{core::num::<}(expected.{core::List::length}); i = i.{core::num::+}(1)) {
    self::expect(expected.{core::List::[]}(i), actual.{core::List::[]}(i));
  }
}

constants  {
  #C1 = tearoff self::id
  #C2 = tearoff self::future
  #C3 = 2
}
