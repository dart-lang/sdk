library;
import self as self;
import "dart:core" as core;

extension type E<T extends core::Object? = dynamic>(({required t: T%}) it) {
  abstract extension-type-member representation-field get it() → ({required t: T%});
  get t = self::E|get#t;
  constructor • = self::E|constructor#;
  constructor tearoff • = self::E|constructor#_#new#tearOff;
}
static extension-type-member method E|constructor#<T extends core::Object? = dynamic>(({required t: self::E|constructor#::T%}) it) → self::E<self::E|constructor#::T%> /* =({required t: self::E|constructor#::T%}) */ {
  lowered final self::E<self::E|constructor#::T%> /* =({required t: self::E|constructor#::T%}) */ #this = it;
  return #this;
}
static extension-type-member method E|constructor#_#new#tearOff<T extends core::Object? = dynamic>(({required t: self::E|constructor#_#new#tearOff::T%}) it) → self::E<self::E|constructor#_#new#tearOff::T%> /* =({required t: self::E|constructor#_#new#tearOff::T%}) */
  return self::E|constructor#<self::E|constructor#_#new#tearOff::T%>(it);
static extension-type-member method E|get#t<T extends core::Object? = dynamic>(lowered final self::E<self::E|get#t::T%> /* =({required t: self::E|get#t::T%}) */ #this) → self::E|get#t::T%
  return (#this as{Unchecked} ({required t: self::E|get#t::T%})).t{self::E|get#t::T%};
static method run<T extends core::Object? = dynamic>(self::E<self::run::T%> /* =({required t: self::run::T%}) */ e) → self::run::T%
  return block {
    self::run::T% #t1;
    final synthesized self::E<self::run::T%> /* =({required t: self::run::T%}) */ #0#0 = e;
    #L1:
    {
      {
        hoisted self::run::T% t;
        if(let final self::run::T% #t2 = t = self::E|get#t<self::run::T%>(#0#0) in true) {
          #t1 = t;
          break #L1;
        }
      }
    }
  } =>#t1;
static method main() → void {}
