library;
import self as self;
import "dart:core" as core;

typedef ACI = self::C<core::int>;
typedef ACR<T extends core::Object? = dynamic> = self::C<T%>;
typedef ACN<T extends core::num> = self::C<T>;
typedef AEI = self::E<core::int> /* = core::int */;
typedef AER<T extends core::Object? = dynamic> = self::E<T%> /* = T% */;
typedef AEN<T extends core::num> = self::E<T> /* = T */;
class AssertIdentical extends core::Object /*hasConstConstructor*/  {
  const constructor •(core::Object? v1, core::Object? v2) → self::AssertIdentical
    : assert(core::identical(v1, v2), "${(v1, v2)}"), super core::Object::•()
    ;
  const constructor not(core::Object? v1, core::Object? v2) → self::AssertIdentical
    : assert(!core::identical(v1, v2), "${(v1, v2)}"), super core::Object::•()
    ;
}
class C<T extends core::Object? = dynamic> extends core::Object {
  final field self::C::T% value;
  constructor •(self::C::T% value) → self::C<self::C::T%>
    : self::C::value = value, super core::Object::•()
    ;
  constructor named(self::C::T% value) → self::C<self::C::T%>
    : self::C::value = value, super core::Object::•()
    ;
  constructor redirect(self::C::T% value) → self::C<self::C::T%>
    : this self::C::named(value)
    ;
  static factory factory<T extends core::Object? = dynamic>(self::C::factory::T% value) → self::C<self::C::factory::T%>
    return new self::C::•<self::C::factory::T%>(value);
  static factory factoryRedirect<T extends core::Object? = dynamic>(self::C::factoryRedirect::T% value) → self::C<self::C::factoryRedirect::T%> /* redirection-target: self::C::•<self::C::factoryRedirect::T%>*/
    return new self::C::•<self::C::factoryRedirect::T%>(value);
}
extension type E<T extends core::Object? = dynamic>(T% value) {
  abstract extension-type-member representation-field get value() → T%;
  constructor • = self::E|constructor#;
  constructor tearoff • = self::E|constructor#_#new#tearOff;
  constructor named = self::E|constructor#named;
  constructor tearoff named = self::E|constructor#_#named#tearOff;
  constructor redirect = self::E|constructor#redirect;
  constructor tearoff redirect = self::E|constructor#_#redirect#tearOff;
  static factory factory = self::E|constructor#factory;
  static factory tearoff factory = self::E|constructor#_#factory#tearOff;
  static redirecting-factory factoryRedirect = self::E|constructor#factoryRedirect;
  static redirecting-factory tearoff factoryRedirect = self::E|constructor#_#factoryRedirect#tearOff;
}
static method main() → void {
  self::checkClass();
  self::checkExtensionType();
}
static method checkClass() → void {
  #C1;
  #C1;
  #C1;
  #C1;
  #C1;
  #C1;
  #C1;
  #C1;
  #C1;
  #C1;
  #C1;
  #C1;
  #C1;
  #C1;
  #C1;
  #C1;
  #C1;
  #C1;
  #C1;
  #C1;
  #C1;
  #C1;
  #C1;
  #C1;
  #C1;
  #C1;
  #C1;
  #C1;
  #C1;
  #C1;
  #C1;
  #C1;
  #C1;
  #C1;
  #C1;
}
static extension-type-member method E|constructor#<T extends core::Object? = dynamic>(self::E|constructor#::T% value) → self::E<self::E|constructor#::T%> /* = self::E|constructor#::T% */ {
  lowered final self::E<self::E|constructor#::T%> /* = self::E|constructor#::T% */ #this = value;
  return #this;
}
static extension-type-member method E|constructor#_#new#tearOff<T extends core::Object? = dynamic>(self::E|constructor#_#new#tearOff::T% value) → self::E<self::E|constructor#_#new#tearOff::T%>% /* = self::E|constructor#_#new#tearOff::T% */
  return self::E|constructor#<self::E|constructor#_#new#tearOff::T%>(value);
static extension-type-member method E|constructor#named<T extends core::Object? = dynamic>(self::E|constructor#named::T% value) → self::E<self::E|constructor#named::T%> /* = self::E|constructor#named::T% */ {
  lowered final self::E<self::E|constructor#named::T%> /* = self::E|constructor#named::T% */ #this = value;
  return #this;
}
static extension-type-member method E|constructor#_#named#tearOff<T extends core::Object? = dynamic>(self::E|constructor#_#named#tearOff::T% value) → self::E<self::E|constructor#_#named#tearOff::T%>% /* = self::E|constructor#_#named#tearOff::T% */
  return self::E|constructor#named<self::E|constructor#_#named#tearOff::T%>(value);
static extension-type-member method E|constructor#redirect<T extends core::Object? = dynamic>(self::E|constructor#redirect::T% value) → self::E<self::E|constructor#redirect::T%> /* = self::E|constructor#redirect::T% */ {
  lowered final self::E<self::E|constructor#redirect::T%> /* = self::E|constructor#redirect::T% */ #this;
  #this = self::E|constructor#named<self::E|constructor#redirect::T%>(value);
  return #this;
}
static extension-type-member method E|constructor#_#redirect#tearOff<T extends core::Object? = dynamic>(self::E|constructor#_#redirect#tearOff::T% value) → self::E<self::E|constructor#_#redirect#tearOff::T%>% /* = self::E|constructor#_#redirect#tearOff::T% */
  return self::E|constructor#redirect<self::E|constructor#_#redirect#tearOff::T%>(value);
static extension-type-member method E|constructor#factory<T extends core::Object? = dynamic>(self::E|constructor#factory::T% value) → self::E<self::E|constructor#factory::T%> /* = self::E|constructor#factory::T% */
  return self::E|constructor#<self::E|constructor#factory::T%>(value);
static extension-type-member method E|constructor#_#factory#tearOff<T extends core::Object? = dynamic>(self::E|constructor#_#factory#tearOff::T% value) → self::E<self::E|constructor#_#factory#tearOff::T%>% /* = self::E|constructor#_#factory#tearOff::T% */
  return self::E|constructor#factory<self::E|constructor#_#factory#tearOff::T%>(value);
static extension-type-member method E|constructor#factoryRedirect<T extends core::Object? = dynamic>(self::E|constructor#factoryRedirect::T% value) → self::E<self::E|constructor#factoryRedirect::T%> /* = self::E|constructor#factoryRedirect::T% */ /* redirection-target: self::E|constructor#<self::E|constructor#factoryRedirect::T%>*/
  return self::E|constructor#<self::E|constructor#factoryRedirect::T%>(value);
static extension-type-member method E|constructor#_#factoryRedirect#tearOff<T extends core::Object? = dynamic>(self::E|constructor#_#factoryRedirect#tearOff::T% value) → self::E<self::E|constructor#_#factoryRedirect#tearOff::T%>% /* = self::E|constructor#_#factoryRedirect#tearOff::T% */
  return self::E|constructor#<self::E|constructor#_#factoryRedirect#tearOff::T%>(value);
static method checkExtensionType() → void {
  #C1;
  #C1;
  #C1;
  #C1;
  #C1;
  #C1;
  #C1;
  #C1;
  #C1;
  #C1;
  #C1;
  #C1;
  #C1;
  #C1;
  #C1;
  #C1;
  #C1;
  #C1;
  #C1;
  #C1;
  #C1;
  #C1;
  #C1;
  #C1;
  #C1;
  #C1;
  #C1;
  #C1;
  #C1;
  #C1;
  #C1;
  #C1;
  #C1;
  #C1;
  #C1;
  #C1;
  #C1;
  #C1;
  #C1;
  #C1;
}
static method _#ACN#new#tearOff<T extends core::num>(self::_#ACN#new#tearOff::T value) → self::C<self::_#ACN#new#tearOff::T>
  return new self::C::•<self::_#ACN#new#tearOff::T>(value);
static method _#ACN#named#tearOff<T extends core::num>(self::_#ACN#named#tearOff::T value) → self::C<self::_#ACN#named#tearOff::T>
  return new self::C::named<self::_#ACN#named#tearOff::T>(value);
static method _#ACN#redirect#tearOff<T extends core::num>(self::_#ACN#redirect#tearOff::T value) → self::C<self::_#ACN#redirect#tearOff::T>
  return new self::C::redirect<self::_#ACN#redirect#tearOff::T>(value);
static method _#ACN#factory#tearOff<T extends core::num>(self::_#ACN#factory#tearOff::T value) → self::C<self::_#ACN#factory#tearOff::T>
  return self::C::factory<self::_#ACN#factory#tearOff::T>(value);
static method _#ACN#factoryRedirect#tearOff<T extends core::num>(self::_#ACN#factoryRedirect#tearOff::T value) → self::C<self::_#ACN#factoryRedirect#tearOff::T>
  return self::C::factoryRedirect<self::_#ACN#factoryRedirect#tearOff::T>(value);
static method _#AEN#new#tearOff<T extends core::num>(self::_#AEN#new#tearOff::T value) → self::E<self::_#AEN#new#tearOff::T>% /* = self::_#AEN#new#tearOff::T */
  return self::E|constructor#<self::_#AEN#new#tearOff::T>(value);
static method _#AEN#named#tearOff<T extends core::num>(self::_#AEN#named#tearOff::T value) → self::E<self::_#AEN#named#tearOff::T>% /* = self::_#AEN#named#tearOff::T */
  return self::E|constructor#named<self::_#AEN#named#tearOff::T>(value);
static method _#AEN#redirect#tearOff<T extends core::num>(self::_#AEN#redirect#tearOff::T value) → self::E<self::_#AEN#redirect#tearOff::T>% /* = self::_#AEN#redirect#tearOff::T */
  return self::E|constructor#redirect<self::_#AEN#redirect#tearOff::T>(value);
static method _#AEN#factory#tearOff<T extends core::num>(self::_#AEN#factory#tearOff::T value) → self::E<self::_#AEN#factory#tearOff::T>% /* = self::_#AEN#factory#tearOff::T */
  return self::E|constructor#factory<self::_#AEN#factory#tearOff::T>(value);
static method _#AEN#factoryRedirect#tearOff<T extends core::num>(self::_#AEN#factoryRedirect#tearOff::T value) → self::E<self::_#AEN#factoryRedirect#tearOff::T>% /* = self::_#AEN#factoryRedirect#tearOff::T */
  return self::E|constructor#_#factoryRedirect#tearOff<self::_#AEN#factoryRedirect#tearOff::T>(value);

constants  {
  #C1 = self::AssertIdentical {}
}


Constructor coverage from constants:
org-dartlang-testcase:///issue54070.dart:
- AssertIdentical. (from org-dartlang-testcase:///issue54070.dart:15:9)
- Object. (from org-dartlang-sdk:///sdk/lib/core/object.dart)
- AssertIdentical.not (from org-dartlang-testcase:///issue54070.dart:17:9)
