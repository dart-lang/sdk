library;
import self as self;
import "dart:core" as core;
import "main_lib.dart" as mai;

import "org-dartlang-testcase:///main_lib.dart";

extension type H<T extends core::Object? = dynamic>(mai::E<T%> e) implements mai::F<T%> /* = mai::C<T%> */, mai::D<T%> {
  abstract extension-type-member representation-field get e() → mai::E<T%>;
  abstract member-signature method method(covariant-by-class T% t) → (core::Object?, core::Object?, core::Object?); -> mai::D::method
  constructor • = self::H|constructor#;
  constructor tearoff • = self::H|constructor#_#new#tearOff;
}
static extension-type-member method H|constructor#<T extends core::Object? = dynamic>(mai::E<self::H|constructor#::T%> e) → self::H<self::H|constructor#::T%> /* = mai::E<self::H|constructor#::T%> */ {
  lowered final self::H<self::H|constructor#::T%> /* = mai::E<self::H|constructor#::T%> */ #this = e;
  return #this;
}
static extension-type-member method H|constructor#_#new#tearOff<T extends core::Object? = dynamic>(mai::E<self::H|constructor#_#new#tearOff::T%> e) → self::H<self::H|constructor#_#new#tearOff::T%> /* = mai::E<self::H|constructor#_#new#tearOff::T%> */
  return self::H|constructor#<self::H|constructor#_#new#tearOff::T%>(e);
