library /*isNonNullableByDefault*/;
import self as self;
import "dart:core" as core;
import "typedef_identical_lib.dart" as typ;

import "org-dartlang-testcase:///typedef_identical_lib.dart";

typedef H<unrelated X extends core::Object? = dynamic, Y extends core::Object? = dynamic> = typ::A<Y%>;
static field dynamic H_new;
static field dynamic H_named;
static field dynamic H_fact;
static field dynamic H_redirect;
static field dynamic F_new;
static field dynamic F_named;
static field dynamic F_fact;
static field dynamic F_redirect;
static method main() → dynamic
  ;
static method expect(dynamic expected, dynamic actual) → dynamic
  ;
static method _#H#new#tearOff<unrelated X extends core::Object? = dynamic, Y extends core::Object? = dynamic>() → typ::A<self::_#H#new#tearOff::Y%>
  return new typ::A::•<self::_#H#new#tearOff::Y%>();
static method _#H#named#tearOff<unrelated X extends core::Object? = dynamic, Y extends core::Object? = dynamic>(self::_#H#named#tearOff::Y% a, [core::int? b]) → typ::A<self::_#H#named#tearOff::Y%>
  return new typ::A::named<self::_#H#named#tearOff::Y%>(a, b);
static method _#H#fact#tearOff<unrelated X extends core::Object? = dynamic, Y extends core::Object? = dynamic>(self::_#H#fact#tearOff::Y% a, {core::int? b, core::int c}) → typ::A<self::_#H#fact#tearOff::Y%>
  return typ::A::fact<self::_#H#fact#tearOff::Y%>(a, b: b, c: c);
static method _#H#redirect#tearOff<unrelated X extends core::Object? = dynamic, Y extends core::Object? = dynamic>() → typ::A<self::_#H#redirect#tearOff::Y%>
  return typ::A::_#redirect#tearOff<self::_#H#redirect#tearOff::Y%>();

library /*isNonNullableByDefault*/;
import self as typ;
import "dart:core" as core;

typedef F<unrelated X extends core::Object? = dynamic, Y extends core::Object? = dynamic> = typ::A<Y%>;
typedef G<unrelated X extends core::Object? = dynamic, Y extends core::Object? = dynamic> = typ::A<Y%>;
class A<T extends core::Object? = dynamic> extends core::Object {
  static final field dynamic _redirecting# = <dynamic>[typ::A::redirect]/*isLegacy*/;
  constructor •() → typ::A<typ::A::T%>
    ;
  constructor named(typ::A::T% a, [core::int? b]) → typ::A<typ::A::T%>
    ;
  static method _#new#tearOff<T extends core::Object? = dynamic>() → typ::A<typ::A::_#new#tearOff::T%>
    return new typ::A::•<typ::A::_#new#tearOff::T%>();
  static method _#named#tearOff<T extends core::Object? = dynamic>(typ::A::_#named#tearOff::T% a, [core::int? b]) → typ::A<typ::A::_#named#tearOff::T%>
    return new typ::A::named<typ::A::_#named#tearOff::T%>(a, b);
  static factory fact<T extends core::Object? = dynamic>(typ::A::fact::T% a, {core::int? b, core::int c}) → typ::A<typ::A::fact::T%>
    ;
  static method _#fact#tearOff<T extends core::Object? = dynamic>(typ::A::_#fact#tearOff::T% a, {core::int? b, core::int c}) → typ::A<typ::A::_#fact#tearOff::T%>
    return typ::A::fact<typ::A::_#fact#tearOff::T%>(a, b: b, c: c);
  static factory redirect<T extends core::Object? = dynamic>() → typ::A<typ::A::redirect::T%>
    let dynamic #redirecting_factory = typ::A::• in let typ::A::redirect::T% #typeArg0 = null in invalid-expression;
  static method _#redirect#tearOff<T extends core::Object? = dynamic>() → typ::A<typ::A::_#redirect#tearOff::T%>
    return new typ::A::•<typ::A::_#redirect#tearOff::T%>();
}
static field dynamic F_new_lib;
static field dynamic F_named_lib;
static field dynamic F_fact_lib;
static field dynamic F_redirect_lib;
static field dynamic G_new_lib;
static field dynamic G_named_lib;
static field dynamic G_fact_lib;
static field dynamic G_redirect_lib;
static method _#F#new#tearOff<unrelated X extends core::Object? = dynamic, Y extends core::Object? = dynamic>() → typ::A<typ::_#F#new#tearOff::Y%>
  return new typ::A::•<typ::_#F#new#tearOff::Y%>();
static method _#F#named#tearOff<unrelated X extends core::Object? = dynamic, Y extends core::Object? = dynamic>(typ::_#F#named#tearOff::Y% a, [core::int? b]) → typ::A<typ::_#F#named#tearOff::Y%>
  return new typ::A::named<typ::_#F#named#tearOff::Y%>(a, b);
static method _#F#fact#tearOff<unrelated X extends core::Object? = dynamic, Y extends core::Object? = dynamic>(typ::_#F#fact#tearOff::Y% a, {core::int? b, core::int c}) → typ::A<typ::_#F#fact#tearOff::Y%>
  return typ::A::fact<typ::_#F#fact#tearOff::Y%>(a, b: b, c: c);
static method _#F#redirect#tearOff<unrelated X extends core::Object? = dynamic, Y extends core::Object? = dynamic>() → typ::A<typ::_#F#redirect#tearOff::Y%>
  return typ::A::_#redirect#tearOff<typ::_#F#redirect#tearOff::Y%>();
static method _#G#new#tearOff<unrelated X extends core::Object? = dynamic, Y extends core::Object? = dynamic>() → typ::A<typ::_#G#new#tearOff::Y%>
  return new typ::A::•<typ::_#G#new#tearOff::Y%>();
static method _#G#named#tearOff<unrelated X extends core::Object? = dynamic, Y extends core::Object? = dynamic>(typ::_#G#named#tearOff::Y% a, [core::int? b]) → typ::A<typ::_#G#named#tearOff::Y%>
  return new typ::A::named<typ::_#G#named#tearOff::Y%>(a, b);
static method _#G#fact#tearOff<unrelated X extends core::Object? = dynamic, Y extends core::Object? = dynamic>(typ::_#G#fact#tearOff::Y% a, {core::int? b, core::int c}) → typ::A<typ::_#G#fact#tearOff::Y%>
  return typ::A::fact<typ::_#G#fact#tearOff::Y%>(a, b: b, c: c);
static method _#G#redirect#tearOff<unrelated X extends core::Object? = dynamic, Y extends core::Object? = dynamic>() → typ::A<typ::_#G#redirect#tearOff::Y%>
  return typ::A::_#redirect#tearOff<typ::_#G#redirect#tearOff::Y%>();
