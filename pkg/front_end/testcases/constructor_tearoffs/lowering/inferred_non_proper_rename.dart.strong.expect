library /*isNonNullableByDefault*/;
import self as self;
import "dart:core" as core;

typedef F<X extends core::num> = self::A<X>;
typedef G<unrelated Y extends core::Object? = dynamic> = self::A<core::int>;
typedef H<X extends core::Object? = dynamic, unrelated Y extends core::Object? = dynamic> = self::A<X%>;
class A<T extends core::Object? = dynamic> extends core::Object {
  static final field dynamic _redirecting# = <dynamic>[self::A::redirect]/*isLegacy*/;
  constructor •() → self::A<self::A::T%>
    : super core::Object::•()
    ;
  static method _#new#tearOff<T extends core::Object? = dynamic>() → self::A<self::A::_#new#tearOff::T%>
    return new self::A::•<self::A::_#new#tearOff::T%>();
  static factory fact<T extends core::Object? = dynamic>() → self::A<self::A::fact::T%>
    return new self::A::•<self::A::fact::T%>();
  static method _#fact#tearOff<T extends core::Object? = dynamic>() → self::A<self::A::_#fact#tearOff::T%>
    return self::A::fact<self::A::_#fact#tearOff::T%>();
  static factory redirect<T extends core::Object? = dynamic>() → self::A<self::A::redirect::T%>
    return new self::A::•<self::A::redirect::T%>();
  static method _#redirect#tearOff<T extends core::Object? = dynamic>() → self::A<self::A::_#redirect#tearOff::T%>
    return new self::A::•<self::A::_#redirect#tearOff::T%>();
}
static final field core::bool inSoundMode = !(<core::int?>[] is{ForNonNullableByDefault} core::List<core::int>);
static const field () → self::A<core::int> f1a = #C2;
static const field () → self::A<core::int> f1b = #C2;
static const field () → self::A<core::int> f1c = #C2;
static const field () → self::A<core::int> f1d = #C4;
static const field () → self::A<core::int> f1e = #C4;
static const field () → self::A<core::int> f1f = #C4;
static const field () → self::A<core::int> f1g = #C6;
static const field () → self::A<core::int> f1h = #C6;
static const field () → self::A<core::int> f1i = #C6;
static const field () → self::A<core::int> g1a = #C2;
static const field () → self::A<core::int> g1b = #C2;
static const field () → self::A<core::int> g1c = #C2;
static const field () → self::A<core::int> h1a = #C2;
static const field () → self::A<core::int> h1b = #C2;
static const field () → self::A<core::int> h1c = #C2;
static method main() → dynamic {
  self::test<core::int>();
  core::identical(#C2, #C2);
  core::identical(#C2, #C2);
  core::identical(#C4, #C4);
  core::identical(#C4, #C4);
  core::identical(#C6, #C6);
  core::identical(#C6, #C6);
  core::identical(#C2, #C2);
  core::identical(#C2, #C2);
  core::identical(#C2, #C2);
  core::identical(#C2, #C2);
}
static method test<T extends core::num>() → dynamic {
  () → self::A<self::test::T> f2a = #C1<self::test::T>;
  () → self::A<self::test::T> f2b = #C1<self::test::T>;
  () → self::A<self::test::T> f2c = #C1<self::test::T>;
  () → self::A<self::test::T> f2d = #C3<self::test::T>;
  () → self::A<self::test::T> f2e = #C3<self::test::T>;
  () → self::A<self::test::T> f2f = #C3<self::test::T>;
  () → self::A<self::test::T> f2g = #C5<self::test::T>;
  () → self::A<self::test::T> f2h = #C5<self::test::T>;
  () → self::A<self::test::T> f2i = #C5<self::test::T>;
  () → self::A<core::int> g2a = #C2;
  () → self::A<core::int> g2b = #C2;
  () → self::A<core::int> g2c = #C2;
  () → self::A<self::test::T> h2a = #C1<self::test::T>;
  () → self::A<self::test::T> h2b = #C1<self::test::T>;
  () → self::A<self::test::T> h2c = #C1<self::test::T>;
  self::expect(#C2, g2a);
  self::expect(g2a, g2b);
  if(self::inSoundMode) {
    self::expect(g2a, g2c);
  }
}
static method expect(dynamic expected, dynamic actual) → dynamic {
  if(!(expected =={core::Object::==}{(core::Object) → core::bool} actual))
    throw "Expected ${expected}, actual ${actual}";
}
static method _#F#new#tearOff<X extends core::num>() → self::A<self::_#F#new#tearOff::X>
  return new self::A::•<self::_#F#new#tearOff::X>();
static method _#F#fact#tearOff<X extends core::num>() → self::A<self::_#F#fact#tearOff::X>
  return self::A::fact<self::_#F#fact#tearOff::X>();
static method _#F#redirect#tearOff<X extends core::num>() → self::A<self::_#F#redirect#tearOff::X>
  return self::A::_#redirect#tearOff<self::_#F#redirect#tearOff::X>();
static method _#G#new#tearOff<unrelated Y extends core::Object? = dynamic>() → self::A<core::int>
  return new self::A::•<core::int>();
static method _#G#fact#tearOff<unrelated Y extends core::Object? = dynamic>() → self::A<core::int>
  return self::A::fact<core::int>();
static method _#G#redirect#tearOff<unrelated Y extends core::Object? = dynamic>() → self::A<core::int>
  return self::A::_#redirect#tearOff<core::int>();
static method _#H#new#tearOff<X extends core::Object? = dynamic, unrelated Y extends core::Object? = dynamic>() → self::A<self::_#H#new#tearOff::X%>
  return new self::A::•<self::_#H#new#tearOff::X%>();
static method _#H#fact#tearOff<X extends core::Object? = dynamic, unrelated Y extends core::Object? = dynamic>() → self::A<self::_#H#fact#tearOff::X%>
  return self::A::fact<self::_#H#fact#tearOff::X%>();
static method _#H#redirect#tearOff<X extends core::Object? = dynamic, unrelated Y extends core::Object? = dynamic>() → self::A<self::_#H#redirect#tearOff::X%>
  return self::A::_#redirect#tearOff<self::_#H#redirect#tearOff::X%>();

constants  {
  #C1 = static-tearoff self::A::_#new#tearOff
  #C2 = instantiation self::A::_#new#tearOff <core::int>
  #C3 = static-tearoff self::A::_#fact#tearOff
  #C4 = instantiation self::A::_#fact#tearOff <core::int>
  #C5 = static-tearoff self::A::_#redirect#tearOff
  #C6 = instantiation self::A::_#redirect#tearOff <core::int>
}
