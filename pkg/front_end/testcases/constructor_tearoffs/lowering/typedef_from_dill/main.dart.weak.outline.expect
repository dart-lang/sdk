library /*isNonNullableByDefault*/;
import self as self;
import "dart:core" as core;
import "main_lib.dart" as mai;

import "org-dartlang-testcase:///main_lib.dart";

typedef H<unrelated X extends core::Object? = dynamic, Y extends core::Object? = dynamic> = mai::A<Y%>;
static field dynamic H_new;
static field dynamic H_named;
static field dynamic H_fact;
static field dynamic H_redirect;
static field dynamic F_new;
static field dynamic F_named;
static field dynamic F_fact;
static field dynamic F_redirect;
static method main() → dynamic
  ;
static method expect(dynamic expected, dynamic actual) → dynamic
  ;
static method _#H#fact#tearOff<unrelated X extends core::Object? = dynamic, Y extends core::Object? = dynamic>(self::_#H#fact#tearOff::Y% a, {core::int? b, core::int c}) → mai::A<self::_#H#fact#tearOff::Y%>
  return mai::A::fact<self::_#H#fact#tearOff::Y%>(a, b: b, c: c);
static method _#H#redirect#tearOff<unrelated X extends core::Object? = dynamic, Y extends core::Object? = dynamic>() → mai::A<self::_#H#redirect#tearOff::Y%>
  return mai::A::_#redirect#tearOff<self::_#H#redirect#tearOff::Y%>();
static method _#H#new#tearOff<unrelated X extends core::Object? = dynamic, Y extends core::Object? = dynamic>() → mai::A<self::_#H#new#tearOff::Y%>
  return new mai::A::•<self::_#H#new#tearOff::Y%>();
static method _#H#named#tearOff<unrelated X extends core::Object? = dynamic, Y extends core::Object? = dynamic>(self::_#H#named#tearOff::Y% a, [core::int? b]) → mai::A<self::_#H#named#tearOff::Y%>
  return new mai::A::named<self::_#H#named#tearOff::Y%>(a, b);

library /*isNonNullableByDefault*/;
import self as mai;
import "dart:core" as core;

typedef F<unrelated X extends core::Object? = dynamic, Y extends core::Object? = dynamic> = mai::A<Y%>;
typedef G<unrelated X extends core::Object? = dynamic, Y extends core::Object? = dynamic> = mai::A<Y%>;
class A<T extends core::Object? = dynamic> extends core::Object {
  static final field dynamic _redirecting# = <dynamic>[mai::A::redirect]/*isLegacy*/;
  constructor •() → mai::A<mai::A::T%>
    ;
  constructor named(mai::A::T% a, [core::int? b]) → mai::A<mai::A::T%>
    ;
  static method _#new#tearOff<T extends core::Object? = dynamic>() → mai::A<mai::A::_#new#tearOff::T%>
    return new mai::A::•<mai::A::_#new#tearOff::T%>();
  static method _#named#tearOff<T extends core::Object? = dynamic>(mai::A::_#named#tearOff::T% a, [core::int? b]) → mai::A<mai::A::_#named#tearOff::T%>
    return new mai::A::named<mai::A::_#named#tearOff::T%>(a, b);
  static factory fact<T extends core::Object? = dynamic>(mai::A::fact::T% a, {core::int? b, core::int c}) → mai::A<mai::A::fact::T%>
    ;
  static method _#fact#tearOff<T extends core::Object? = dynamic>(mai::A::_#fact#tearOff::T% a, {core::int? b, core::int c}) → mai::A<mai::A::_#fact#tearOff::T%>
    return mai::A::fact<mai::A::_#fact#tearOff::T%>(a, b: b, c: c);
  static factory redirect<T extends core::Object? = dynamic>() → mai::A<mai::A::redirect::T%>
    return new mai::A::•<mai::A::redirect::T%>();
  static method _#redirect#tearOff<T extends core::Object? = dynamic>() → mai::A<mai::A::_#redirect#tearOff::T%>
    return new mai::A::•<mai::A::_#redirect#tearOff::T%>();
}
static field dynamic F_new_lib;
static field dynamic F_named_lib;
static field dynamic F_fact_lib;
static field dynamic F_redirect_lib;
static field dynamic G_new_lib;
static field dynamic G_named_lib;
static field dynamic G_fact_lib;
static field dynamic G_redirect_lib;
static method _#F#new#tearOff<unrelated X extends core::Object? = dynamic, Y extends core::Object? = dynamic>() → mai::A<mai::_#F#new#tearOff::Y%>
  return new mai::A::•<mai::_#F#new#tearOff::Y%>();
static method _#F#named#tearOff<unrelated X extends core::Object? = dynamic, Y extends core::Object? = dynamic>(mai::_#F#named#tearOff::Y% a, [core::int? b]) → mai::A<mai::_#F#named#tearOff::Y%>
  return new mai::A::named<mai::_#F#named#tearOff::Y%>(a, b);
static method _#F#fact#tearOff<unrelated X extends core::Object? = dynamic, Y extends core::Object? = dynamic>(mai::_#F#fact#tearOff::Y% a, {core::int? b, core::int c}) → mai::A<mai::_#F#fact#tearOff::Y%>
  return mai::A::fact<mai::_#F#fact#tearOff::Y%>(a, b: b, c: c);
static method _#F#redirect#tearOff<unrelated X extends core::Object? = dynamic, Y extends core::Object? = dynamic>() → mai::A<mai::_#F#redirect#tearOff::Y%>
  return mai::A::_#redirect#tearOff<mai::_#F#redirect#tearOff::Y%>();
static method _#G#new#tearOff<unrelated X extends core::Object? = dynamic, Y extends core::Object? = dynamic>() → mai::A<mai::_#G#new#tearOff::Y%>
  return new mai::A::•<mai::_#G#new#tearOff::Y%>();
static method _#G#named#tearOff<unrelated X extends core::Object? = dynamic, Y extends core::Object? = dynamic>(mai::_#G#named#tearOff::Y% a, [core::int? b]) → mai::A<mai::_#G#named#tearOff::Y%>
  return new mai::A::named<mai::_#G#named#tearOff::Y%>(a, b);
static method _#G#fact#tearOff<unrelated X extends core::Object? = dynamic, Y extends core::Object? = dynamic>(mai::_#G#fact#tearOff::Y% a, {core::int? b, core::int c}) → mai::A<mai::_#G#fact#tearOff::Y%>
  return mai::A::fact<mai::_#G#fact#tearOff::Y%>(a, b: b, c: c);
static method _#G#redirect#tearOff<unrelated X extends core::Object? = dynamic, Y extends core::Object? = dynamic>() → mai::A<mai::_#G#redirect#tearOff::Y%>
  return mai::A::_#redirect#tearOff<mai::_#G#redirect#tearOff::Y%>();
