library /*isNonNullableByDefault*/;
//
// Problems in library:
//
// pkg/front_end/testcases/class_modifiers/mixin/mixin_class_core_libraries.dart:7:14: Error: The class 'Comparable' can't be used as a mixin because it isn't a mixin class nor a mixin.
// class A with Comparable<int> {
//              ^
//
// pkg/front_end/testcases/class_modifiers/mixin/mixin_class_core_libraries.dart:11:7: Error: Can't use 'Error' as a mixin because it has constructors.
// class B with Error {} /* Error */
//       ^
// sdk/lib/core/errors.dart:73:3: Context: This constructor prevents using 'Error' as a mixin.
//   Error(); // Prevent use as mixin.
//   ^
//
// pkg/front_end/testcases/class_modifiers/mixin/mixin_class_core_libraries.dart:11:14: Error: The class 'Error' can't be used as a mixin because it isn't a mixin class nor a mixin.
// class B with Error {} /* Error */
//              ^
//
import self as self;
import "dart:core" as core;

abstract class _A&Object&Comparable = core::Object with core::Comparable<core::int> /*isAnonymousMixin,hasConstConstructor*/  {
  const synthetic constructor •() → self::_A&Object&Comparable
    : super core::Object::•()
    ;
  abstract mixin-stub method compareTo(covariant-by-class core::int other) → core::int; -> core::Comparable::compareTo
}
class A extends self::_A&Object&Comparable {
  synthetic constructor •() → self::A
    : super self::_A&Object&Comparable::•()
    ;
  method compareTo(covariant-by-class core::int x) → core::int
    return 0;
}
abstract class _B&Object&Error = core::Object with core::Error /*isAnonymousMixin*/  {
  synthetic constructor •() → self::_B&Object&Error
    : super core::Object::•()
    ;
  mixin-super-stub get _stackTrace() → core::StackTrace?
    return super.{core::Error::_stackTrace};
  mixin-super-stub set _stackTrace(core::StackTrace? value) → void
    return super.{core::Error::_stackTrace} = value;
  mixin-super-stub get stackTrace() → core::StackTrace?
    return super.{core::Error::stackTrace};
}
class B extends self::_B&Object&Error {
  synthetic constructor •() → self::B
    : super self::_B&Object&Error::•()
    ;
}
