library /*isNonNullableByDefault*/;
import self as self;
import "dart:core" as core;
import "constants_lib.dart" as con;

import "org-dartlang-testcase:///constants_lib.dart" as lib;

static const field (core::int) → core::int partialInstantiation = con::id<core::int>;
static const field con::Class<core::int> instance = const con::Class::•<core::int>(0);
static const field core::List<core::int> listLiteral = const <core::int>[0];
static const field core::Set<core::int> setLiteral = const <core::int>{0};
static const field core::Map<core::int, core::String> mapLiteral = const <core::int, core::String>{0: "foo"};
static const field core::List<core::int> listConcatenation = self::listLiteral;
static const field core::Set<core::int> setConcatenation = self::setLiteral;
static const field core::Map<core::int, core::String> mapConcatenation = self::mapLiteral;
static const field core::bool partialInstantiationIdentical = core::identical(self::partialInstantiation, con::partialInstantiation);
static const field core::bool instanceIdentical = core::identical(self::instance, con::instance);
static const field core::bool listLiteralIdentical = core::identical(self::listLiteral, con::listLiteral);
static const field core::bool setLiteralIdentical = core::identical(self::setLiteral, con::setLiteral);
static const field core::bool mapLiteralIdentical = core::identical(self::mapLiteral, con::mapLiteral);
static const field core::bool listConcatenationIdentical = core::identical(self::listConcatenation, con::listConcatenation);
static const field core::bool setConcatenationIdentical = core::identical(self::setConcatenation, con::setConcatenation);
static const field core::bool mapConcatenationIdentical = core::identical(self::mapConcatenation, con::mapConcatenation);
static method main() → dynamic
  ;
static method test(dynamic expected, dynamic actual) → dynamic
  ;

library;
import self as con;
import "dart:core" as core;

typedef F1<invariant T extends core::Object* = dynamic> = (T*) →* T*;
typedef F2 = <T extends core::Object* = dynamic>(T*) →* T*;
class Class<T extends core::Object* = dynamic> extends core::Object /*hasConstConstructor*/  {
  final field con::Class::T* field;
  const constructor •(con::Class::T* field) → con::Class<con::Class::T*>*
    : con::Class::field = field, super core::Object::•()
    ;
  abstract member-signature get _identityHashCode() → core::int*; -> core::Object::_identityHashCode
  abstract member-signature method _instanceOf(dynamic instantiatorTypeArguments, dynamic functionTypeArguments, dynamic type) → core::bool*; -> core::Object::_instanceOf
  abstract member-signature method _simpleInstanceOf(dynamic type) → core::bool*; -> core::Object::_simpleInstanceOf
  abstract member-signature method _simpleInstanceOfTrue(dynamic type) → core::bool*; -> core::Object::_simpleInstanceOfTrue
  abstract member-signature method _simpleInstanceOfFalse(dynamic type) → core::bool*; -> core::Object::_simpleInstanceOfFalse
  abstract member-signature operator ==(dynamic other) → core::bool*; -> core::Object::==
  abstract member-signature get hashCode() → core::int*; -> core::Object::hashCode
  abstract member-signature method toString() → core::String*; -> core::Object::toString
  abstract member-signature method noSuchMethod(core::Invocation* invocation) → dynamic; -> core::Object::noSuchMethod
  abstract member-signature get runtimeType() → core::Type*; -> core::Object::runtimeType
}
static const field (core::Object*, core::Object*) →* core::bool* c2 = core::identical;
static const field (core::int*) →* core::int* partialInstantiation = con::id<core::int*>;
static const field con::Class<core::int*>* instance = const con::Class::•<core::int*>(0);
static const field core::List<core::int*>* listLiteral = const <core::int*>[0];
static const field core::Set<core::int*>* setLiteral = const <core::int*>{0};
static const field core::Map<core::int*, core::String*>* mapLiteral = const <core::int*, core::String*>{0: "foo"};
static const field core::List<core::int*>* listConcatenation = con::listLiteral;
static const field core::Set<core::int*>* setConcatenation = con::setLiteral;
static const field core::Map<core::int*, core::String*>* mapConcatenation = con::mapLiteral;
static method id<T extends core::Object* = dynamic>(con::id::T* t) → con::id::T*
  ;


Extra constant evaluation status:
Evaluated: Instantiation @ org-dartlang-testcase:///constants.dart:7:52 -> InstantiationConstant(id<int*>)
Evaluated: ConstructorInvocation @ org-dartlang-testcase:///constants.dart:8:24 -> InstanceConstant(const Class<int*>{Class.field: 0})
Evaluated: ListLiteral @ org-dartlang-testcase:///constants.dart:9:26 -> ListConstant(const <int*>[0])
Evaluated: SetLiteral @ org-dartlang-testcase:///constants.dart:10:25 -> InstanceConstant(const _UnmodifiableSet<int*>{_UnmodifiableSet._map: const _ImmutableMap<int*, Null>{_ImmutableMap._kvPairs: const <dynamic>[0, null]}})
Evaluated: MapLiteral @ org-dartlang-testcase:///constants.dart:11:33 -> InstanceConstant(const _ImmutableMap<int*, String*>{_ImmutableMap._kvPairs: const <dynamic>[0, "foo"]})
Evaluated: ListConcatenation @ org-dartlang-testcase:///constants.dart:12:32 -> ListConstant(const <int*>[0])
Evaluated: SetConcatenation @ org-dartlang-testcase:///constants.dart:13:31 -> InstanceConstant(const _UnmodifiableSet<int*>{_UnmodifiableSet._map: const _ImmutableMap<int*, Null>{_ImmutableMap._kvPairs: const <dynamic>[0, null]}})
Evaluated: MapConcatenation @ org-dartlang-testcase:///constants.dart:14:7 -> InstanceConstant(const _ImmutableMap<int*, String*>{_ImmutableMap._kvPairs: const <dynamic>[0, "foo"]})
Evaluated: StaticInvocation @ org-dartlang-testcase:///constants.dart:17:5 -> BoolConstant(true)
Evaluated: StaticInvocation @ org-dartlang-testcase:///constants.dart:18:27 -> BoolConstant(true)
Evaluated: StaticInvocation @ org-dartlang-testcase:///constants.dart:19:30 -> BoolConstant(true)
Evaluated: StaticInvocation @ org-dartlang-testcase:///constants.dart:20:29 -> BoolConstant(true)
Evaluated: StaticInvocation @ org-dartlang-testcase:///constants.dart:21:29 -> BoolConstant(true)
Evaluated: StaticInvocation @ org-dartlang-testcase:///constants.dart:23:5 -> BoolConstant(true)
Evaluated: StaticInvocation @ org-dartlang-testcase:///constants.dart:25:5 -> BoolConstant(true)
Evaluated: StaticInvocation @ org-dartlang-testcase:///constants.dart:27:5 -> BoolConstant(true)
Evaluated: StaticTearOff @ org-dartlang-testcase:///constants_lib.dart:18:12 -> StaticTearOffConstant(identical)
Evaluated: Instantiation @ org-dartlang-testcase:///constants_lib.dart:19:48 -> InstantiationConstant(id<int*>)
Evaluated: ConstructorInvocation @ org-dartlang-testcase:///constants_lib.dart:20:24 -> InstanceConstant(const Class<int*>{Class.field: 0})
Evaluated: ListLiteral @ org-dartlang-testcase:///constants_lib.dart:21:26 -> ListConstant(const <int*>[0])
Evaluated: SetLiteral @ org-dartlang-testcase:///constants_lib.dart:22:25 -> InstanceConstant(const _UnmodifiableSet<int*>{_UnmodifiableSet._map: const _ImmutableMap<int*, Null>{_ImmutableMap._kvPairs: const <dynamic>[0, null]}})
Evaluated: MapLiteral @ org-dartlang-testcase:///constants_lib.dart:23:33 -> InstanceConstant(const _ImmutableMap<int*, String*>{_ImmutableMap._kvPairs: const <dynamic>[0, "foo"]})
Evaluated: ListConcatenation @ org-dartlang-testcase:///constants_lib.dart:24:32 -> ListConstant(const <int*>[0])
Evaluated: SetConcatenation @ org-dartlang-testcase:///constants_lib.dart:25:31 -> InstanceConstant(const _UnmodifiableSet<int*>{_UnmodifiableSet._map: const _ImmutableMap<int*, Null>{_ImmutableMap._kvPairs: const <dynamic>[0, null]}})
Evaluated: MapConcatenation @ org-dartlang-testcase:///constants_lib.dart:26:7 -> InstanceConstant(const _ImmutableMap<int*, String*>{_ImmutableMap._kvPairs: const <dynamic>[0, "foo"]})
Extra constant evaluation: evaluated: 26, effectively constant: 25
