library /*isNonNullableByDefault*/;
import self as self;
import "dart:core" as core;
import "constants_lib.dart" as con;

import "org-dartlang-testcase:///constants_lib.dart" as lib;

static const field (core::int) → core::int partialInstantiation = #C2;
static const field con::Class<core::int> instance = #C4;
static const field core::List<core::int> listLiteral = #C5;
static const field core::Set<core::int> setLiteral = #C9;
static const field core::Map<core::int, core::String> mapLiteral = #C12;
static const field core::List<core::int> listConcatenation = #C5;
static const field core::Set<core::int> setConcatenation = #C9;
static const field core::Map<core::int, core::String> mapConcatenation = #C12;
static const field core::bool partialInstantiationIdentical = #C13;
static const field core::bool instanceIdentical = #C13;
static const field core::bool listLiteralIdentical = #C13;
static const field core::bool setLiteralIdentical = #C13;
static const field core::bool mapLiteralIdentical = #C13;
static const field core::bool listConcatenationIdentical = #C13;
static const field core::bool setConcatenationIdentical = #C13;
static const field core::bool mapConcatenationIdentical = #C13;
static method main() → dynamic {
  self::test(#C2, #C2);
  self::test(#C4, #C4);
  self::test(#C5, #C5);
  self::test(#C9, #C9);
  self::test(#C12, #C12);
  self::test(#C5, #C5);
  self::test(#C9, #C9);
  self::test(#C12, #C12);
  self::test(true, #C13);
  self::test(true, #C13);
  self::test(true, #C13);
  self::test(true, #C13);
  self::test(true, #C13);
  self::test(true, #C13);
  self::test(true, #C13);
  self::test(true, #C13);
}
static method test(dynamic expected, dynamic actual) → dynamic {
  core::print("test(${expected}, ${actual})");
  if(!core::identical(expected, actual)) {
    throw "Expected ${expected}, actual ${actual}";
  }
}

library;
import self as con;
import "dart:core" as core;

typedef F1<invariant T extends core::Object* = dynamic> = (T*) →* T*;
typedef F2 = <T extends core::Object* = dynamic>(T*) →* T*;
class Class<T extends core::Object* = dynamic> extends core::Object /*hasConstConstructor*/  {
  final field con::Class::T* field;
  const constructor •(con::Class::T* field) → con::Class<con::Class::T*>*
    : con::Class::field = field, super core::Object::•()
    ;
  abstract member-signature get _identityHashCode() → core::int*; -> core::Object::_identityHashCode
  abstract member-signature method _instanceOf(dynamic instantiatorTypeArguments, dynamic functionTypeArguments, dynamic type) → core::bool*; -> core::Object::_instanceOf
  abstract member-signature method _simpleInstanceOf(dynamic type) → core::bool*; -> core::Object::_simpleInstanceOf
  abstract member-signature method _simpleInstanceOfTrue(dynamic type) → core::bool*; -> core::Object::_simpleInstanceOfTrue
  abstract member-signature method _simpleInstanceOfFalse(dynamic type) → core::bool*; -> core::Object::_simpleInstanceOfFalse
  abstract member-signature operator ==(dynamic other) → core::bool*; -> core::Object::==
  abstract member-signature get hashCode() → core::int*; -> core::Object::hashCode
  abstract member-signature method toString() → core::String*; -> core::Object::toString
  abstract member-signature method noSuchMethod(core::Invocation* invocation) → dynamic; -> core::Object::noSuchMethod
  abstract member-signature get runtimeType() → core::Type*; -> core::Object::runtimeType
}
static const field (core::Object*, core::Object*) →* core::bool* c2 = #C14;
static const field (core::int*) →* core::int* partialInstantiation = #C2;
static const field con::Class<core::int*>* instance = #C4;
static const field core::List<core::int*>* listLiteral = #C5;
static const field core::Set<core::int*>* setLiteral = #C9;
static const field core::Map<core::int*, core::String*>* mapLiteral = #C12;
static const field core::List<core::int*>* listConcatenation = #C5;
static const field core::Set<core::int*>* setConcatenation = #C9;
static const field core::Map<core::int*, core::String*>* mapConcatenation = #C12;
static method id<T extends core::Object* = dynamic>(con::id::T* t) → con::id::T*
  return t;

constants  {
  #C1 = tearoff con::id
  #C2 = partial-instantiation con::id <core::int*>
  #C3 = 0
  #C4 = con::Class<core::int*> {field:#C3}
  #C5 = <core::int*>[#C3]
  #C6 = null
  #C7 = <dynamic>[#C3, #C6]
  #C8 = core::_ImmutableMap<core::int*, core::Null?> {_kvPairs:#C7}
  #C9 = col::_UnmodifiableSet<core::int*> {_map:#C8}
  #C10 = "foo"
  #C11 = <dynamic>[#C3, #C10]
  #C12 = core::_ImmutableMap<core::int*, core::String*> {_kvPairs:#C11}
  #C13 = true
  #C14 = tearoff core::identical
}
