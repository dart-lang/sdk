library /*isNonNullableByDefault*/;
//
// Problems in library:
//
// pkg/front_end/testcases/rasta/unresolved_for_in.dart:14:10: Error: Can't assign to a type literal.
//     for (Fisk in x) {
//          ^^^^
//
// pkg/front_end/testcases/rasta/unresolved_for_in.dart:18:13: Error: A prefix can't be used as an expression.
//       print(collection);
//             ^^^^^^^^^^
//
// pkg/front_end/testcases/rasta/unresolved_for_in.dart:17:10: Error: A prefix can't be used as an expression.
//     for (collection in x) {
//          ^^^^^^^^^^
//
// pkg/front_end/testcases/rasta/unresolved_for_in.dart:20:10: Error: Can't assign to a type literal.
//     for (VoidFunction in x) {
//          ^^^^^^^^^^^^
//
// pkg/front_end/testcases/rasta/unresolved_for_in.dart:23:10: Error: Expected an identifier, but got '1'.
// Try inserting an identifier before '1'.
//     for (1 in x) {
//          ^
//
// pkg/front_end/testcases/rasta/unresolved_for_in.dart:23:10: Error: Can't assign to this, so it can't be used in a for-in loop.
//     for (1 in x) {
//          ^
//
// pkg/front_end/testcases/rasta/unresolved_for_in.dart:11:10: Error: The setter 'key' isn't defined for the class 'Fisk'.
//  - 'Fisk' is from 'pkg/front_end/testcases/rasta/unresolved_for_in.dart'.
// Try correcting the name to the name of an existing setter, or defining a setter or field named 'key'.
//     for (key in x) {
//          ^^^
//
// pkg/front_end/testcases/rasta/unresolved_for_in.dart:12:13: Error: The getter 'key' isn't defined for the class 'Fisk'.
//  - 'Fisk' is from 'pkg/front_end/testcases/rasta/unresolved_for_in.dart'.
// Try correcting the name to the name of an existing getter, or defining a getter or field named 'key'.
//       print(key);
//             ^^^
//
// pkg/front_end/testcases/rasta/unresolved_for_in.dart:24:13: Error: The getter 'key' isn't defined for the class 'Fisk'.
//  - 'Fisk' is from 'pkg/front_end/testcases/rasta/unresolved_for_in.dart'.
// Try correcting the name to the name of an existing getter, or defining a getter or field named 'key'.
//       print(key);
//             ^^^
//
// pkg/front_end/testcases/rasta/unresolved_for_in.dart:32:11: Error: Undefined name 'key'.
//     print(key);
//           ^^^
//
// pkg/front_end/testcases/rasta/unresolved_for_in.dart:31:8: Error: Setter not found: 'key'.
//   for (key in arguments) {
//        ^^^
//
// pkg/front_end/testcases/rasta/unresolved_for_in.dart:34:8: Error: Can't assign to a type literal.
//   for (Fisk in arguments) {
//        ^^^^
//
// pkg/front_end/testcases/rasta/unresolved_for_in.dart:38:11: Error: A prefix can't be used as an expression.
//     print(collection);
//           ^^^^^^^^^^
//
// pkg/front_end/testcases/rasta/unresolved_for_in.dart:37:8: Error: A prefix can't be used as an expression.
//   for (collection in arguments) {
//        ^^^^^^^^^^
//
// pkg/front_end/testcases/rasta/unresolved_for_in.dart:40:8: Error: Can't assign to a type literal.
//   for (VoidFunction in arguments) {
//        ^^^^^^^^^^^^
//
// pkg/front_end/testcases/rasta/unresolved_for_in.dart:43:8: Error: Expected an identifier, but got '1'.
// Try inserting an identifier before '1'.
//   for (1 in arguments) {
//        ^
//
// pkg/front_end/testcases/rasta/unresolved_for_in.dart:44:11: Error: Undefined name 'key'.
//     print(key);
//           ^^^
//
// pkg/front_end/testcases/rasta/unresolved_for_in.dart:43:8: Error: Can't assign to this, so it can't be used in a for-in loop.
//   for (1 in arguments) {
//        ^
//
import self as self;
import "dart:core" as core;

import "dart:collection" as collection;

typedef VoidFunction = () → void;
class Fisk extends core::Object {
  synthetic constructor •() → self::Fisk
    : super core::Object::•()
    ;
  method it1(dynamic x) → dynamic {
    {
      synthesized core::Iterator<dynamic> :sync-for-iterator = (x as{TypeError,ForDynamic,ForNonNullableByDefault} core::Iterable<dynamic>).{core::Iterable::iterator}{core::Iterator<dynamic>};
      for (; :sync-for-iterator.{core::Iterator::moveNext}(){() → core::bool}; ) {
        final dynamic #t1 = :sync-for-iterator.{core::Iterator::current}{dynamic};
        {
          invalid-expression "pkg/front_end/testcases/rasta/unresolved_for_in.dart:11:10: Error: The setter 'key' isn't defined for the class 'Fisk'.
 - 'Fisk' is from 'pkg/front_end/testcases/rasta/unresolved_for_in.dart'.
Try correcting the name to the name of an existing setter, or defining a setter or field named 'key'.
    for (key in x) {
         ^^^" in this{<unresolved>}.key = invalid-expression "pkg/front_end/testcases/rasta/unresolved_for_in.dart:11:10: Error: The setter 'key' isn't defined for the class 'Fisk'.
 - 'Fisk' is from 'pkg/front_end/testcases/rasta/unresolved_for_in.dart'.
Try correcting the name to the name of an existing setter, or defining a setter or field named 'key'.
    for (key in x) {
         ^^^";
          core::print(invalid-expression "pkg/front_end/testcases/rasta/unresolved_for_in.dart:12:13: Error: The getter 'key' isn't defined for the class 'Fisk'.
 - 'Fisk' is from 'pkg/front_end/testcases/rasta/unresolved_for_in.dart'.
Try correcting the name to the name of an existing getter, or defining a getter or field named 'key'.
      print(key);
            ^^^" in this{<unresolved>}.key);
        }
      }
    }
    {
      synthesized core::Iterator<dynamic> :sync-for-iterator = (x as{TypeError,ForDynamic,ForNonNullableByDefault} core::Iterable<dynamic>).{core::Iterable::iterator}{core::Iterator<dynamic>};
      for (; :sync-for-iterator.{core::Iterator::moveNext}(){() → core::bool}; ) {
        final dynamic #t2 = :sync-for-iterator.{core::Iterator::current}{dynamic};
        {
          invalid-expression "pkg/front_end/testcases/rasta/unresolved_for_in.dart:14:10: Error: Can't assign to a type literal.
    for (Fisk in x) {
         ^^^^";
          core::print(#C1);
        }
      }
    }
    {
      synthesized core::Iterator<dynamic> :sync-for-iterator = (x as{TypeError,ForDynamic,ForNonNullableByDefault} core::Iterable<dynamic>).{core::Iterable::iterator}{core::Iterator<dynamic>};
      for (; :sync-for-iterator.{core::Iterator::moveNext}(){() → core::bool}; ) {
        final dynamic #t3 = :sync-for-iterator.{core::Iterator::current}{dynamic};
        {
          invalid-expression "pkg/front_end/testcases/rasta/unresolved_for_in.dart:17:10: Error: A prefix can't be used as an expression.
    for (collection in x) {
         ^^^^^^^^^^";
          core::print(invalid-expression "pkg/front_end/testcases/rasta/unresolved_for_in.dart:18:13: Error: A prefix can't be used as an expression.
      print(collection);
            ^^^^^^^^^^");
        }
      }
    }
    {
      synthesized core::Iterator<dynamic> :sync-for-iterator = (x as{TypeError,ForDynamic,ForNonNullableByDefault} core::Iterable<dynamic>).{core::Iterable::iterator}{core::Iterator<dynamic>};
      for (; :sync-for-iterator.{core::Iterator::moveNext}(){() → core::bool}; ) {
        final dynamic #t4 = :sync-for-iterator.{core::Iterator::current}{dynamic};
        {
          invalid-expression "pkg/front_end/testcases/rasta/unresolved_for_in.dart:20:10: Error: Can't assign to a type literal.
    for (VoidFunction in x) {
         ^^^^^^^^^^^^";
          core::print(#C2);
        }
      }
    }
    {
      invalid-expression "pkg/front_end/testcases/rasta/unresolved_for_in.dart:23:10: Error: Can't assign to this, so it can't be used in a for-in loop.
    for (1 in x) {
         ^";
      {
        synthesized core::Iterator<dynamic> :sync-for-iterator = (x as{TypeError,ForDynamic,ForNonNullableByDefault} core::Iterable<dynamic>).{core::Iterable::iterator}{core::Iterator<dynamic>};
        for (; :sync-for-iterator.{core::Iterator::moveNext}(){() → core::bool}; ) {
          final dynamic #t5 = :sync-for-iterator.{core::Iterator::current}{dynamic};
          {
            invalid-expression "pkg/front_end/testcases/rasta/unresolved_for_in.dart:23:10: Error: Can't assign to this, so it can't be used in a for-in loop.
    for (1 in x) {
         ^";
            1;
            core::print(invalid-expression "pkg/front_end/testcases/rasta/unresolved_for_in.dart:24:13: Error: The getter 'key' isn't defined for the class 'Fisk'.
 - 'Fisk' is from 'pkg/front_end/testcases/rasta/unresolved_for_in.dart'.
Try correcting the name to the name of an existing getter, or defining a getter or field named 'key'.
      print(key);
            ^^^" in this{<unresolved>}.key);
          }
        }
      }
    }
  }
}
static method main(dynamic arguments) → dynamic {
  new self::Fisk::•();
  {
    synthesized core::Iterator<dynamic> :sync-for-iterator = (arguments as{TypeError,ForDynamic,ForNonNullableByDefault} core::Iterable<dynamic>).{core::Iterable::iterator}{core::Iterator<dynamic>};
    for (; :sync-for-iterator.{core::Iterator::moveNext}(){() → core::bool}; ) {
      final dynamic #t6 = :sync-for-iterator.{core::Iterator::current}{dynamic};
      {
        invalid-expression "pkg/front_end/testcases/rasta/unresolved_for_in.dart:31:8: Error: Setter not found: 'key'.
  for (key in arguments) {
       ^^^";
        core::print(invalid-expression "pkg/front_end/testcases/rasta/unresolved_for_in.dart:32:11: Error: Undefined name 'key'.
    print(key);
          ^^^");
      }
    }
  }
  {
    synthesized core::Iterator<dynamic> :sync-for-iterator = (arguments as{TypeError,ForDynamic,ForNonNullableByDefault} core::Iterable<dynamic>).{core::Iterable::iterator}{core::Iterator<dynamic>};
    for (; :sync-for-iterator.{core::Iterator::moveNext}(){() → core::bool}; ) {
      final dynamic #t7 = :sync-for-iterator.{core::Iterator::current}{dynamic};
      {
        invalid-expression "pkg/front_end/testcases/rasta/unresolved_for_in.dart:34:8: Error: Can't assign to a type literal.
  for (Fisk in arguments) {
       ^^^^";
        core::print(#C1);
      }
    }
  }
  {
    synthesized core::Iterator<dynamic> :sync-for-iterator = (arguments as{TypeError,ForDynamic,ForNonNullableByDefault} core::Iterable<dynamic>).{core::Iterable::iterator}{core::Iterator<dynamic>};
    for (; :sync-for-iterator.{core::Iterator::moveNext}(){() → core::bool}; ) {
      final dynamic #t8 = :sync-for-iterator.{core::Iterator::current}{dynamic};
      {
        invalid-expression "pkg/front_end/testcases/rasta/unresolved_for_in.dart:37:8: Error: A prefix can't be used as an expression.
  for (collection in arguments) {
       ^^^^^^^^^^";
        core::print(invalid-expression "pkg/front_end/testcases/rasta/unresolved_for_in.dart:38:11: Error: A prefix can't be used as an expression.
    print(collection);
          ^^^^^^^^^^");
      }
    }
  }
  {
    synthesized core::Iterator<dynamic> :sync-for-iterator = (arguments as{TypeError,ForDynamic,ForNonNullableByDefault} core::Iterable<dynamic>).{core::Iterable::iterator}{core::Iterator<dynamic>};
    for (; :sync-for-iterator.{core::Iterator::moveNext}(){() → core::bool}; ) {
      final dynamic #t9 = :sync-for-iterator.{core::Iterator::current}{dynamic};
      {
        invalid-expression "pkg/front_end/testcases/rasta/unresolved_for_in.dart:40:8: Error: Can't assign to a type literal.
  for (VoidFunction in arguments) {
       ^^^^^^^^^^^^";
        core::print(#C2);
      }
    }
  }
  {
    invalid-expression "pkg/front_end/testcases/rasta/unresolved_for_in.dart:43:8: Error: Can't assign to this, so it can't be used in a for-in loop.
  for (1 in arguments) {
       ^";
    {
      synthesized core::Iterator<dynamic> :sync-for-iterator = (arguments as{TypeError,ForDynamic,ForNonNullableByDefault} core::Iterable<dynamic>).{core::Iterable::iterator}{core::Iterator<dynamic>};
      for (; :sync-for-iterator.{core::Iterator::moveNext}(){() → core::bool}; ) {
        final dynamic #t10 = :sync-for-iterator.{core::Iterator::current}{dynamic};
        {
          invalid-expression "pkg/front_end/testcases/rasta/unresolved_for_in.dart:43:8: Error: Can't assign to this, so it can't be used in a for-in loop.
  for (1 in arguments) {
       ^";
          1;
          core::print(invalid-expression "pkg/front_end/testcases/rasta/unresolved_for_in.dart:44:11: Error: Undefined name 'key'.
    print(key);
          ^^^");
        }
      }
    }
  }
}

constants  {
  #C1 = TypeLiteralConstant(self::Fisk*)
  #C2 = TypeLiteralConstant(() →* void)
}
