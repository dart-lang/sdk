library;
import self as self;
import "dart:core" as core;

typedef Public_E = self::_E% /* erasure=core::int, declared=! */;
typedef Public_EConst = self::_EConst% /* erasure=core::int, declared=! */;
extension type _E(core::int x) {
  abstract extension-type-member representation-field get x() → core::int;
  static get getter = get self::_E|getter;
  static method method = self::_E|method;
  constructor • = self::_E|constructor#;
  constructor tearoff • = self::_E|constructor#_#new#tearOff;
  constructor named = self::_E|constructor#named;
  constructor tearoff named = self::_E|constructor#_#named#tearOff;
}
extension type _EConst(core::int x) {
  abstract extension-type-member representation-field get x() → core::int;
  constructor • = self::_EConst|constructor#;
  constructor tearoff • = self::_EConst|constructor#_#new#tearOff;
  constructor named = self::_EConst|constructor#named;
  constructor tearoff named = self::_EConst|constructor#_#named#tearOff;
}
static final field self::_E% /* erasure=core::int, declared=! */ one;
static const field self::_EConst% /* erasure=core::int, declared=! */ constOne = const self::_EConst|constructor#(1);
static extension-type-member method _E|constructor#(core::int x) → self::_E% /* erasure=core::int, declared=! */
  ;
static extension-type-member synthetic method _E|constructor#_#new#tearOff(core::int x) → self::_E% /* erasure=core::int, declared=! */
  return self::_E|constructor#(x);
static extension-type-member get _E|getter() → self::_E% /* erasure=core::int, declared=! */
  ;
static extension-type-member method _E|method() → self::_E% /* erasure=core::int, declared=! */
  ;
static extension-type-member method _E|constructor#named(core::int x) → self::_E% /* erasure=core::int, declared=! */
  ;
static extension-type-member synthetic method _E|constructor#_#named#tearOff(core::int x) → self::_E% /* erasure=core::int, declared=! */
  return self::_E|constructor#named(x);
static extension-type-member method _EConst|constructor#(core::int x) → self::_EConst% /* erasure=core::int, declared=! */ {
  lowered final self::_EConst% /* erasure=core::int, declared=! */ #this = x;
  return #this;
}
static extension-type-member synthetic method _EConst|constructor#_#new#tearOff(core::int x) → self::_EConst% /* erasure=core::int, declared=! */
  return self::_EConst|constructor#(x);
static extension-type-member method _EConst|constructor#named(core::int x) → self::_EConst% /* erasure=core::int, declared=! */ {
  lowered final self::_EConst% /* erasure=core::int, declared=! */ #this = x;
  return #this;
}
static extension-type-member synthetic method _EConst|constructor#_#named#tearOff(core::int x) → self::_EConst% /* erasure=core::int, declared=! */
  return self::_EConst|constructor#named(x);
static method test() → void
  ;


Extra constant evaluation status:
Evaluated: StaticInvocation @ org-dartlang-testcase:///private_extension_type_in_library.dart:19:32 -> IntConstant(1)
Extra constant evaluation: evaluated: 13, effectively constant: 1
