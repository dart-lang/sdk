library;
//
// Problems in library:
//
// pkg/front_end/testcases/dart2js/mixin_super/main.dart:43:36: Error: The class doesn't have a concrete implementation of the super-invoked member 'method1'.
// class Class2b extends Class2a with Mixin1 /* Error */ {}
//                                    ^
// pkg/front_end/testcases/dart2js/mixin_super/main.dart:17:11: Context: This is the super-access that doesn't have a concrete target.
//     super.method1();
//           ^
//
// pkg/front_end/testcases/dart2js/mixin_super/main.dart:43:36: Error: The class doesn't have a concrete implementation of the super-accessed member 'property1'.
// class Class2b extends Class2a with Mixin1 /* Error */ {}
//                                    ^
// pkg/front_end/testcases/dart2js/mixin_super/main.dart:23:18: Context: This is the super-access that doesn't have a concrete target.
//     return super.property1;
//                  ^
//
// pkg/front_end/testcases/dart2js/mixin_super/main.dart:43:36: Error: The class doesn't have a concrete implementation of the super-accessed setter 'property1'.
// class Class2b extends Class2a with Mixin1 /* Error */ {}
//                                    ^
// pkg/front_end/testcases/dart2js/mixin_super/main.dart:27:11: Context: This is the super-access that doesn't have a concrete target.
//     super.property1 = value;
//           ^
//
// pkg/front_end/testcases/dart2js/mixin_super/main.dart:43:36: Error: The class doesn't have a concrete implementation of the super-accessed member 'field1'.
// class Class2b extends Class2a with Mixin1 /* Error */ {}
//                                    ^
// pkg/front_end/testcases/dart2js/mixin_super/main.dart:9:33: Context: This is the super-access that doesn't have a concrete target.
//     return super.field1 = super.field1 + 1;
//                                 ^
//
// pkg/front_end/testcases/dart2js/mixin_super/main.dart:43:36: Error: The class doesn't have a concrete implementation of the super-accessed setter 'field1'.
// class Class2b extends Class2a with Mixin1 /* Error */ {}
//                                    ^
// pkg/front_end/testcases/dart2js/mixin_super/main.dart:9:18: Context: This is the super-access that doesn't have a concrete target.
//     return super.field1 = super.field1 + 1;
//                  ^
//
// pkg/front_end/testcases/dart2js/mixin_super/main.dart:47:36: Error: The class doesn't have a concrete implementation of the super-invoked member 'method1'.
// class Class3b extends Class3a with Mixin1 /* Error */ {}
//                                    ^
// pkg/front_end/testcases/dart2js/mixin_super/main.dart:17:11: Context: This is the super-access that doesn't have a concrete target.
//     super.method1();
//           ^
//
// pkg/front_end/testcases/dart2js/mixin_super/main.dart:47:36: Error: The class doesn't have a concrete implementation of the super-accessed member 'property1'.
// class Class3b extends Class3a with Mixin1 /* Error */ {}
//                                    ^
// pkg/front_end/testcases/dart2js/mixin_super/main.dart:23:18: Context: This is the super-access that doesn't have a concrete target.
//     return super.property1;
//                  ^
//
// pkg/front_end/testcases/dart2js/mixin_super/main.dart:47:36: Error: The class doesn't have a concrete implementation of the super-accessed setter 'property1'.
// class Class3b extends Class3a with Mixin1 /* Error */ {}
//                                    ^
// pkg/front_end/testcases/dart2js/mixin_super/main.dart:27:11: Context: This is the super-access that doesn't have a concrete target.
//     super.property1 = value;
//           ^
//
// pkg/front_end/testcases/dart2js/mixin_super/main.dart:47:36: Error: The class doesn't have a concrete implementation of the super-accessed member 'field1'.
// class Class3b extends Class3a with Mixin1 /* Error */ {}
//                                    ^
// pkg/front_end/testcases/dart2js/mixin_super/main.dart:9:33: Context: This is the super-access that doesn't have a concrete target.
//     return super.field1 = super.field1 + 1;
//                                 ^
//
// pkg/front_end/testcases/dart2js/mixin_super/main.dart:47:36: Error: The class doesn't have a concrete implementation of the super-accessed setter 'field1'.
// class Class3b extends Class3a with Mixin1 /* Error */ {}
//                                    ^
// pkg/front_end/testcases/dart2js/mixin_super/main.dart:9:18: Context: This is the super-access that doesn't have a concrete target.
//     return super.field1 = super.field1 + 1;
//                  ^
//
// pkg/front_end/testcases/dart2js/mixin_super/main.dart:55:36: Error: The class doesn't have a concrete implementation of the super-invoked member 'method1'.
// class Class5b extends Class5a with Mixin2 /* Error */ {}
//                                    ^
// pkg/front_end/testcases/dart2js/mixin_super/main_lib.dart:27:11: Context: This is the super-access that doesn't have a concrete target.
//     super.method1();
//           ^
//
// pkg/front_end/testcases/dart2js/mixin_super/main.dart:55:36: Error: The class doesn't have a concrete implementation of the super-accessed member 'property1'.
// class Class5b extends Class5a with Mixin2 /* Error */ {}
//                                    ^
// pkg/front_end/testcases/dart2js/mixin_super/main_lib.dart:33:18: Context: This is the super-access that doesn't have a concrete target.
//     return super.property1;
//                  ^
//
// pkg/front_end/testcases/dart2js/mixin_super/main.dart:55:36: Error: The class doesn't have a concrete implementation of the super-accessed setter 'property1'.
// class Class5b extends Class5a with Mixin2 /* Error */ {}
//                                    ^
// pkg/front_end/testcases/dart2js/mixin_super/main_lib.dart:37:11: Context: This is the super-access that doesn't have a concrete target.
//     super.property1 = value;
//           ^
//
// pkg/front_end/testcases/dart2js/mixin_super/main.dart:55:36: Error: The class doesn't have a concrete implementation of the super-accessed member 'field1'.
// class Class5b extends Class5a with Mixin2 /* Error */ {}
//                                    ^
// pkg/front_end/testcases/dart2js/mixin_super/main_lib.dart:19:33: Context: This is the super-access that doesn't have a concrete target.
//     return super.field1 = super.field1 + 1;
//                                 ^
//
// pkg/front_end/testcases/dart2js/mixin_super/main.dart:55:36: Error: The class doesn't have a concrete implementation of the super-accessed setter 'field1'.
// class Class5b extends Class5a with Mixin2 /* Error */ {}
//                                    ^
// pkg/front_end/testcases/dart2js/mixin_super/main_lib.dart:19:18: Context: This is the super-access that doesn't have a concrete target.
//     return super.field1 = super.field1 + 1;
//                  ^
//
// pkg/front_end/testcases/dart2js/mixin_super/main.dart:59:36: Error: The class doesn't have a concrete implementation of the super-invoked member 'method1'.
// class Class6b extends Class6a with Mixin2 /* Error */ {}
//                                    ^
// pkg/front_end/testcases/dart2js/mixin_super/main_lib.dart:27:11: Context: This is the super-access that doesn't have a concrete target.
//     super.method1();
//           ^
//
// pkg/front_end/testcases/dart2js/mixin_super/main.dart:59:36: Error: The class doesn't have a concrete implementation of the super-accessed member 'property1'.
// class Class6b extends Class6a with Mixin2 /* Error */ {}
//                                    ^
// pkg/front_end/testcases/dart2js/mixin_super/main_lib.dart:33:18: Context: This is the super-access that doesn't have a concrete target.
//     return super.property1;
//                  ^
//
// pkg/front_end/testcases/dart2js/mixin_super/main.dart:59:36: Error: The class doesn't have a concrete implementation of the super-accessed setter 'property1'.
// class Class6b extends Class6a with Mixin2 /* Error */ {}
//                                    ^
// pkg/front_end/testcases/dart2js/mixin_super/main_lib.dart:37:11: Context: This is the super-access that doesn't have a concrete target.
//     super.property1 = value;
//           ^
//
// pkg/front_end/testcases/dart2js/mixin_super/main.dart:59:36: Error: The class doesn't have a concrete implementation of the super-accessed member 'field1'.
// class Class6b extends Class6a with Mixin2 /* Error */ {}
//                                    ^
// pkg/front_end/testcases/dart2js/mixin_super/main_lib.dart:19:33: Context: This is the super-access that doesn't have a concrete target.
//     return super.field1 = super.field1 + 1;
//                                 ^
//
// pkg/front_end/testcases/dart2js/mixin_super/main.dart:59:36: Error: The class doesn't have a concrete implementation of the super-accessed setter 'field1'.
// class Class6b extends Class6a with Mixin2 /* Error */ {}
//                                    ^
// pkg/front_end/testcases/dart2js/mixin_super/main_lib.dart:19:18: Context: This is the super-access that doesn't have a concrete target.
//     return super.field1 = super.field1 + 1;
//                  ^
//
import self as self;
import "dart:core" as core;
import "main_lib.dart" as mai;

import "org-dartlang-testcase:///main_lib.dart";

abstract class _Mixin1&Super1&Super2 extends core::Object implements mai::Super1, mai::Super2 /*isAnonymousMixin*/  {
  synthetic constructor •() → self::_Mixin1&Super1&Super2
    : super core::Object::•()
    ;
}
abstract class Mixin1 extends self::_Mixin1&Super1&Super2 /*isMixinDeclaration*/  {
  late field core::int field1 = (() → core::int {
    return super.{mai::Super1::field1} = super.{mai::Super1::field1}.{core::num::+}(1){(core::num) → core::int};
  })(){() → core::int};
  late field core::int field2 = (() → core::int {
    return 88;
  })(){() → core::int};
  method method1() → void {
    super.{mai::Super1::method1}();
  }
  method method2() → void {}
  get property1() → core::int {
    return super.{mai::Super1::property1};
  }
  set property1(core::int value) → void {
    super.{mai::Super1::property1} = value;
  }
  get property2() → core::int {
    return 42;
  }
  set property2(core::int value) → void {}
}
abstract class Class1a extends mai::Super1 implements mai::Super2 {
  synthetic constructor •() → self::Class1a
    : super mai::Super1::•()
    ;
}
abstract class _Class1b&Class1a&Mixin1 = self::Class1a with self::Mixin1 /*isAnonymousMixin*/  {
  synthetic constructor •() → self::_Class1b&Class1a&Mixin1
    : super self::Class1a::•()
    ;
  mixin-super-stub get field1() → core::int
    return super.{self::Mixin1::field1};
  mixin-super-stub set field1(core::int value) → void
    return super.{self::Mixin1::field1} = value;
  mixin-super-stub get field2() → core::int
    return super.{self::Mixin1::field2};
  mixin-super-stub set field2(core::int value) → void
    return super.{self::Mixin1::field2} = value;
  mixin-super-stub get property1() → core::int
    return super.{self::Mixin1::property1};
  mixin-super-stub set property1(core::int value) → void
    return super.{self::Mixin1::property1} = value;
  mixin-super-stub get property2() → core::int
    return super.{self::Mixin1::property2};
  mixin-super-stub set property2(core::int value) → void
    return super.{self::Mixin1::property2} = value;
  mixin-super-stub method method1() → void
    return super.{self::Mixin1::method1}();
  mixin-super-stub method method2() → void
    return super.{self::Mixin1::method2}();
}
class Class1b extends self::_Class1b&Class1a&Mixin1 {
  synthetic constructor •() → self::Class1b
    : super self::_Class1b&Class1a&Mixin1::•()
    ;
  static method _#new#tearOff() → self::Class1b
    return new self::Class1b::•();
}
abstract class Class2a extends mai::Super2 implements mai::Super1 {
  synthetic constructor •() → self::Class2a
    : super mai::Super2::•()
    ;
}
abstract class _Class2b&Class2a&Mixin1 = self::Class2a with self::Mixin1 /*isAnonymousMixin*/  {
  synthetic constructor •() → self::_Class2b&Class2a&Mixin1
    : super self::Class2a::•()
    ;
  mixin-super-stub get field1() → core::int
    return super.{self::Mixin1::field1};
  mixin-super-stub set field1(core::int value) → void
    return super.{self::Mixin1::field1} = value;
  mixin-super-stub get field2() → core::int
    return super.{self::Mixin1::field2};
  mixin-super-stub set field2(core::int value) → void
    return super.{self::Mixin1::field2} = value;
  mixin-super-stub get property1() → core::int
    return super.{self::Mixin1::property1};
  mixin-super-stub set property1(core::int value) → void
    return super.{self::Mixin1::property1} = value;
  mixin-super-stub get property2() → core::int
    return super.{self::Mixin1::property2};
  mixin-super-stub set property2(core::int value) → void
    return super.{self::Mixin1::property2} = value;
  mixin-super-stub method method1() → void
    return super.{self::Mixin1::method1}();
  mixin-super-stub method method2() → void
    return super.{self::Mixin1::method2}();
}
class Class2b extends self::_Class2b&Class2a&Mixin1 {
  synthetic constructor •() → self::Class2b
    : super self::_Class2b&Class2a&Mixin1::•()
    ;
  static method _#new#tearOff() → self::Class2b
    return new self::Class2b::•();
}
abstract class Class3a extends core::Object implements mai::Super1, mai::Super2 {
  synthetic constructor •() → self::Class3a
    : super core::Object::•()
    ;
}
abstract class _Class3b&Class3a&Mixin1 = self::Class3a with self::Mixin1 /*isAnonymousMixin*/  {
  synthetic constructor •() → self::_Class3b&Class3a&Mixin1
    : super self::Class3a::•()
    ;
  mixin-super-stub get field1() → core::int
    return super.{self::Mixin1::field1};
  mixin-super-stub set field1(core::int value) → void
    return super.{self::Mixin1::field1} = value;
  mixin-super-stub get field2() → core::int
    return super.{self::Mixin1::field2};
  mixin-super-stub set field2(core::int value) → void
    return super.{self::Mixin1::field2} = value;
  mixin-super-stub get property1() → core::int
    return super.{self::Mixin1::property1};
  mixin-super-stub set property1(core::int value) → void
    return super.{self::Mixin1::property1} = value;
  mixin-super-stub get property2() → core::int
    return super.{self::Mixin1::property2};
  mixin-super-stub set property2(core::int value) → void
    return super.{self::Mixin1::property2} = value;
  mixin-super-stub method method1() → void
    return super.{self::Mixin1::method1}();
  mixin-super-stub method method2() → void
    return super.{self::Mixin1::method2}();
}
class Class3b extends self::_Class3b&Class3a&Mixin1 {
  synthetic constructor •() → self::Class3b
    : super self::_Class3b&Class3a&Mixin1::•()
    ;
  static method _#new#tearOff() → self::Class3b
    return new self::Class3b::•();
}
abstract class Class4a extends mai::Super1 implements mai::Super2 {
  synthetic constructor •() → self::Class4a
    : super mai::Super1::•()
    ;
}
abstract class _Class4b&Class4a&Mixin2 = self::Class4a with mai::Mixin2 /*isAnonymousMixin*/  {
  synthetic constructor •() → self::_Class4b&Class4a&Mixin2
    : super self::Class4a::•()
    ;
  mixin-super-stub get property1() → core::int
    return super.{mai::Mixin2::property1};
  mixin-super-stub set property1(core::int value) → void
    return super.{mai::Mixin2::property1} = value;
  mixin-super-stub get property2() → core::int
    return super.{mai::Mixin2::property2};
  mixin-super-stub set property2(core::int value) → void
    return super.{mai::Mixin2::property2} = value;
  mixin-super-stub get field1() → core::int
    return super.{mai::Mixin2::field1};
  mixin-super-stub set field1(core::int value) → void
    return super.{mai::Mixin2::field1} = value;
  mixin-super-stub get field2() → core::int
    return super.{mai::Mixin2::field2};
  mixin-super-stub set field2(core::int value) → void
    return super.{mai::Mixin2::field2} = value;
  mixin-super-stub get _#Mixin2#field1#AI() → core::int
    return super.{mai::Mixin2::_#Mixin2#field1#AI};
  mixin-super-stub set _#Mixin2#field1#AI(core::int value) → void
    return super.{mai::Mixin2::_#Mixin2#field1#AI} = value;
  mixin-super-stub get _#Mixin2#field2#AI() → core::int
    return super.{mai::Mixin2::_#Mixin2#field2#AI};
  mixin-super-stub set _#Mixin2#field2#AI(core::int value) → void
    return super.{mai::Mixin2::_#Mixin2#field2#AI} = value;
  mixin-super-stub method method1() → void
    return super.{mai::Mixin2::method1}();
  mixin-super-stub method method2() → void
    return super.{mai::Mixin2::method2}();
}
class Class4b extends self::_Class4b&Class4a&Mixin2 {
  synthetic constructor •() → self::Class4b
    : super self::_Class4b&Class4a&Mixin2::•()
    ;
  static method _#new#tearOff() → self::Class4b
    return new self::Class4b::•();
}
abstract class Class5a extends mai::Super2 implements mai::Super1 {
  synthetic constructor •() → self::Class5a
    : super mai::Super2::•()
    ;
}
abstract class _Class5b&Class5a&Mixin2 = self::Class5a with mai::Mixin2 /*isAnonymousMixin*/  {
  synthetic constructor •() → self::_Class5b&Class5a&Mixin2
    : super self::Class5a::•()
    ;
  mixin-super-stub get property1() → core::int
    return super.{mai::Mixin2::property1};
  mixin-super-stub set property1(core::int value) → void
    return super.{mai::Mixin2::property1} = value;
  mixin-super-stub get property2() → core::int
    return super.{mai::Mixin2::property2};
  mixin-super-stub set property2(core::int value) → void
    return super.{mai::Mixin2::property2} = value;
  mixin-super-stub get field1() → core::int
    return super.{mai::Mixin2::field1};
  mixin-super-stub set field1(core::int value) → void
    return super.{mai::Mixin2::field1} = value;
  mixin-super-stub get field2() → core::int
    return super.{mai::Mixin2::field2};
  mixin-super-stub set field2(core::int value) → void
    return super.{mai::Mixin2::field2} = value;
  mixin-super-stub get _#Mixin2#field1#AI() → core::int
    return super.{mai::Mixin2::_#Mixin2#field1#AI};
  mixin-super-stub set _#Mixin2#field1#AI(core::int value) → void
    return super.{mai::Mixin2::_#Mixin2#field1#AI} = value;
  mixin-super-stub get _#Mixin2#field2#AI() → core::int
    return super.{mai::Mixin2::_#Mixin2#field2#AI};
  mixin-super-stub set _#Mixin2#field2#AI(core::int value) → void
    return super.{mai::Mixin2::_#Mixin2#field2#AI} = value;
  mixin-super-stub method method1() → void
    return super.{mai::Mixin2::method1}();
  mixin-super-stub method method2() → void
    return super.{mai::Mixin2::method2}();
}
class Class5b extends self::_Class5b&Class5a&Mixin2 {
  synthetic constructor •() → self::Class5b
    : super self::_Class5b&Class5a&Mixin2::•()
    ;
  static method _#new#tearOff() → self::Class5b
    return new self::Class5b::•();
}
abstract class Class6a extends core::Object implements mai::Super1, mai::Super2 {
  synthetic constructor •() → self::Class6a
    : super core::Object::•()
    ;
}
abstract class _Class6b&Class6a&Mixin2 = self::Class6a with mai::Mixin2 /*isAnonymousMixin*/  {
  synthetic constructor •() → self::_Class6b&Class6a&Mixin2
    : super self::Class6a::•()
    ;
  mixin-super-stub get property1() → core::int
    return super.{mai::Mixin2::property1};
  mixin-super-stub set property1(core::int value) → void
    return super.{mai::Mixin2::property1} = value;
  mixin-super-stub get property2() → core::int
    return super.{mai::Mixin2::property2};
  mixin-super-stub set property2(core::int value) → void
    return super.{mai::Mixin2::property2} = value;
  mixin-super-stub get field1() → core::int
    return super.{mai::Mixin2::field1};
  mixin-super-stub set field1(core::int value) → void
    return super.{mai::Mixin2::field1} = value;
  mixin-super-stub get field2() → core::int
    return super.{mai::Mixin2::field2};
  mixin-super-stub set field2(core::int value) → void
    return super.{mai::Mixin2::field2} = value;
  mixin-super-stub get _#Mixin2#field1#AI() → core::int
    return super.{mai::Mixin2::_#Mixin2#field1#AI};
  mixin-super-stub set _#Mixin2#field1#AI(core::int value) → void
    return super.{mai::Mixin2::_#Mixin2#field1#AI} = value;
  mixin-super-stub get _#Mixin2#field2#AI() → core::int
    return super.{mai::Mixin2::_#Mixin2#field2#AI};
  mixin-super-stub set _#Mixin2#field2#AI(core::int value) → void
    return super.{mai::Mixin2::_#Mixin2#field2#AI} = value;
  mixin-super-stub method method1() → void
    return super.{mai::Mixin2::method1}();
  mixin-super-stub method method2() → void
    return super.{mai::Mixin2::method2}();
}
class Class6b extends self::_Class6b&Class6a&Mixin2 {
  synthetic constructor •() → self::Class6b
    : super self::_Class6b&Class6a&Mixin2::•()
    ;
  static method _#new#tearOff() → self::Class6b
    return new self::Class6b::•();
}

library;
import self as mai;
import "dart:core" as core;
import "dart:_internal" as _in;

class Super1 extends core::Object {
  field core::int field1 = 42;
  field core::int property1 = 42;
  synthetic constructor •() → mai::Super1
    : super core::Object::•()
    ;
  method method1() → void {}
  static method _#new#tearOff() → mai::Super1
    return new mai::Super1::•();
}
class Super2 extends core::Object {
  field core::int field2 = 87;
  field core::int property2 = 87;
  synthetic constructor •() → mai::Super2
    : super core::Object::•()
    ;
  method method2() → void {}
  static method _#new#tearOff() → mai::Super2
    return new mai::Super2::•();
}
abstract class _Mixin2&Super1&Super2 extends core::Object implements mai::Super1, mai::Super2 /*isAnonymousMixin*/  {
  synthetic constructor •() → mai::_Mixin2&Super1&Super2
    : super core::Object::•()
    ;
}
abstract class Mixin2 extends mai::_Mixin2&Super1&Super2 /*isMixinDeclaration*/  {
  field core::int _#Mixin2#field1#AI = _in::createSentinel<core::int>();
  field core::int _#Mixin2#field2#AI = _in::createSentinel<core::int>();
  method method1() → void {
    super.{mai::Super1::method1}();
  }
  method method2() → void {}
  get property1() → core::int {
    return super.{mai::Super1::property1};
  }
  set property1(core::int value) → void {
    super.{mai::Super1::property1} = value;
  }
  get property2() → core::int {
    return 42;
  }
  set property2(core::int value) → void {}
  get field1() → core::int {
    synthesized core::int value = this.{mai::Mixin2::_#Mixin2#field1#AI}{core::int};
    if(_in::isSentinel(value))
      value = this.{mai::Mixin2::_#Mixin2#field1#AI} = (() → core::int {
        return super.{mai::Super1::field1} = super.{mai::Super1::field1}.{core::num::+}(1){(core::num) → core::int};
      })(){() → core::int};
    return value;
  }
  set field1(synthesized core::int value) → void
    this.{mai::Mixin2::_#Mixin2#field1#AI} = value;
  get field2() → core::int {
    synthesized core::int value = this.{mai::Mixin2::_#Mixin2#field2#AI}{core::int};
    if(_in::isSentinel(value))
      value = this.{mai::Mixin2::_#Mixin2#field2#AI} = (() → core::int {
        return 88;
      })(){() → core::int};
    return value;
  }
  set field2(synthesized core::int value) → void
    this.{mai::Mixin2::_#Mixin2#field2#AI} = value;
}
