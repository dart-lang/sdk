# Copyright (c) 2017, the Dart project authors.  Please see the AUTHORS file
# for details. All rights reserved. Use of this source code is governed by a
# BSD-style license that can be found in the LICENSE file.

# Run
#
#     dart run pkg/front_end/tool/_fasta/generate_messages.dart
#
# to regenerate messages after having edited this file.
#
# If entries with 'analyzerCode' and 'index' have been changed, run
#
#     dart run pkg/analyzer/tool/messages/generate.dart
#
# to regenerate analyzer messages.

# Each entry in this map corresponds to a diagnostic message. Ideally, each
# entry contains three parts:
#
# 1. A message template (problemMessage).
#
# 2. A suggestion for how to correct the problem (correctionMessage).
#
# 3. Examples that produce the message (one of expression, statement,
#    declaration, member, script, bytes or external). Note that 'external'
#    should be the path to an external test. The external test will not be run,
#    but the existence of the file will be verified.
#
#    Multiple scripts can start with a `// @dart=` annotation to enforce the
#    language version used for the example code.
#
# Note that it can be hard or impossible to write an example that only gives the
# specific error. To allow for this, one can specify
# "exampleAllowMoreCodes: true" which filters out every message with a
# different code, and just verifies we got exactly one message of the code in
# question (in addition too different codes).
#
# A message shouldn't indicate which kind of diagnostic it is, for example,
# warning or error. Tools are expected to prepend "Warning: ", or "Error: ",
# and should be allowed to change the kind of diagnostic without affecting the
# message. For example, an error might be turned into a warning by the tool.
#
# See the file [lib/src/fasta/diagnostics.md] for more details on how to write
# good diagnostic messages.
#
# A message used for internal errors should have key that starts with
# "InternalProblem". This way, UX review can prioritize it accordingly.
#
# Eventually, we'd like to have all diagnostics in one shared
# location. However, for now, the analyzer needs to translate error codes to
# its own format. To support this, an entry can contain an analyzer error code
# (analyzerCode).
#
# Long term, the analyzer and front-end need to share the same error codes. So
# eventually all error codes should have an `analyzerCode` field.
# Any error code with an `index` field and an `analyzerCode` field
# will be auto generated as an Analyzer error code.
# `index` field values should be unique, consecutive whole numbers starting with 1.
# If `index` is defined, then `analyzerCode` should be the fully formed
# name of the corresponding public Analyzer error const
# (e.g. ParserErrorCode.EQUALITY_CANNOT_BE_EQUALITY_OPERAND)
# which will be used when generating code in Analyzer for translating
# fasta error codes to Analyzer error codes.
#
# Errors with an `index` can also optionally contain user-facing documentation
# for the problem (documentation), which will be extracted to
# `pkg/analyzer/tool/diagnostics/diagnostics.md`, as well as internal
# documentation (comment), which will be included in the code generated for the
# analyzer.
#
# In some cases a message is internal to the frontend, and no meaningful
# analyzer code can be provided. In such cases set `frontendInternal: true`.
#
# ## Parameter Substitution in problemMessage and correctionMessage
#
# The fields `problemMessage` and `correctionMessage` are subject to parameter
# substitution. When the compiler reports a problem, it may also specify a map
# with the following keys to be substituted into the message:
#
# `#character` a Unicode character.
#
# `#unicode` a Unicode short identifier (U+xxxx). We use this to represent code
#  units or code points.
#
# `#name`, `#name2`, `#name3`, `#name4`: names (as strings). Note that asserts
#    check if these are empty. If they can be empty use an available `OKEmpty`
#    version (or add the missing needed one(s)) to avoid triggering an assert.
#
# `#nameOKEmpty`: name (as string). Will use an "(unnamed)" default message if
#    the string is null or empty. Otherwise see the description above.
#
# `#names`: A list of names (strings).
#
# `#lexeme` a token. The token's `lexeme` property is used.
#
# `#string`, `#string2`, `#string3`: strings (that aren't names).
#    Note: as a rule of thumb, avoid using the `#string` keys. In particular,
#    do not use them for composing error messages, see [diagnostics.md](
#    lib/src/fasta/diagnostics.md#avoid-composing-messages-programmatically).
#    Note that asserts check if these are empty. If they can be empty use an
#    available `OKEmpty` version (or add the missing needed one(s)) to avoid
#    triggering an assert.
#
# `#stringOKEmpty`: string (that isn't a name). Will use an "(empty)" default
#    message if the string is null or empty.
#    Otherwise see the description above.
#
# `#type`, #type2`, `#type3`: Kernel types.
#
# `#uri`, `#uri2`, `#uri3`: URIs.
#
# `#count`, `#count2`: counts (as integers)
#
# `#constant` a Kernel constant.
#
# `#num1%N.M`, `#num2%N.M`, `#num3%N.M`: numbers (doubles) formatted to minimum
# width N and with M fraction digits.

AsciiControlCharacter:
  problemMessage: "The control character #unicode can only be used in strings and comments."
  analyzerCode: ILLEGAL_CHARACTER
  expression: "\x1b 1"

ConstEvalStartingPoint:
  problemMessage: "Constant evaluation error:"

ConstEvalContext:
  problemMessage: "While analyzing:"

ConstEvalDuplicateElement:
  problemMessage: "The element '#constant' conflicts with another existing element in the set."
  analyzerCode: EQUAL_ELEMENTS_IN_CONST_SET

ConstEvalDuplicateKey:
  problemMessage: "The key '#constant' conflicts with another existing key in the map."
  analyzerCode: EQUAL_KEYS_IN_CONST_MAP

ConstEvalElementImplementsEqual:
  problemMessage: "The element '#constant' does not have a primitive operator '=='."
  analyzerCode: CONST_SET_ELEMENT_TYPE_IMPLEMENTS_EQUALS

ConstEvalElementNotPrimitiveEquality:
  problemMessage: "The element '#constant' does not have a primitive equality."

ConstEvalKeyImplementsEqual:
  problemMessage: "The key '#constant' does not have a primitive operator '=='."
  analyzerCode: CONST_MAP_KEY_EXPRESSION_TYPE_IMPLEMENTS_EQUALS

ConstEvalKeyNotPrimitiveEquality:
  problemMessage: "The key '#constant' does not have a primitive equality."

ConstEvalCaseImplementsEqual:
  problemMessage: "Case expression '#constant' does not have a primitive operator '=='."

ConstEvalInvalidType:
  problemMessage: "Expected constant '#constant' to be of type '#type', but was of type '#type2'."

ConstEvalInvalidBinaryOperandType:
  problemMessage: "Binary operator '#stringOKEmpty' on '#constant' requires operand of type '#type', but was of type '#type2'."

ConstEvalInvalidEqualsOperandType:
  problemMessage: "Binary operator '==' requires receiver constant '#constant' of type 'Null', 'bool', 'int', 'double', or 'String', but was of type '#type'."

ConstEvalEqualsOperandNotPrimitiveEquality:
  problemMessage: "Binary operator '==' requires receiver constant '#constant' of a type with primitive equality or type 'double', but was of type '#type'."

ConstEvalZeroDivisor:
  problemMessage: "Binary operator '#string' on '#string2' requires non-zero divisor, but divisor was '0'."
  analyzerCode: CONST_EVAL_THROWS_IDBZE

ConstEvalNegativeShift:
  problemMessage: "Binary operator '#string' on '#string2' requires non-negative operand, but was '#string3'."

ConstEvalTruncateError:
  problemMessage: "Binary operator '#string ~/ #string2' results is Infinity or NaN."

ConstEvalNonNull:
  problemMessage: "Constant expression must be non-null."

ConstEvalGetterNotFound:
  problemMessage: "Variable get not found: '#nameOKEmpty'"

ConstEvalInvalidMethodInvocation:
  problemMessage: "The method '#stringOKEmpty' can't be invoked on '#constant' in a constant expression."
  analyzerCode: UNDEFINED_OPERATOR

ConstEvalInvalidPropertyGet:
  problemMessage: "The property '#stringOKEmpty' can't be accessed on '#constant' in a constant expression."
  analyzerCode: CONST_EVAL_THROWS_EXCEPTION

ConstEvalInvalidRecordIndexGet:
  problemMessage: "The property '#stringOKEmpty' can't be accessed on '#constant' in a constant expression."
  analyzerCode: CONST_EVAL_THROWS_EXCEPTION

ConstEvalInvalidRecordNameGet:
  problemMessage: "The property '#stringOKEmpty' can't be accessed on '#constant' in a constant expression."
  analyzerCode: CONST_EVAL_THROWS_EXCEPTION

ConstEvalInvalidStringInterpolationOperand:
  problemMessage: |
    The constant value '#constant' can't be used as part of a string interpolation in a constant expression.
    Only values of type 'null', 'bool', 'int', 'double', or 'String' can be used.
  analyzerCode: CONST_EVAL_TYPE_BOOL_NUM_STRING

ConstEvalInvalidStaticInvocation:
  problemMessage: "The invocation of '#nameOKEmpty' is not allowed in a constant expression."
  analyzerCode: CONST_INITIALIZED_WITH_NON_CONSTANT_VALUE

ConstEvalInvalidSymbolName:
  problemMessage: "The symbol name must be a valid public Dart member name, public constructor name, or library name, optionally qualified, but was '#constant'."
  analyzerCode: CONST_EVAL_THROWS_EXCEPTION

ConstEvalFailedAssertion:
  problemMessage: "This assertion failed."
  analyzerCode: CONST_EVAL_THROWS_EXCEPTION

ConstEvalFailedAssertionWithMessage:
  problemMessage: "This assertion failed with message: #stringOKEmpty"
  analyzerCode: CONST_EVAL_THROWS_EXCEPTION

ConstEvalFailedAssertionWithNonStringMessage:
  problemMessage: "This assertion failed with a non-String message."
  analyzerCode: CONST_EVAL_THROWS_EXCEPTION

ConstEvalNonConstantVariableGet:
  problemMessage: "The variable '#nameOKEmpty' is not a constant, only constant expressions are allowed."
  analyzerCode: NON_CONSTANT_VALUE_IN_INITIALIZER

ConstEvalDeferredLibrary:
  problemMessage: >
    '#nameOKEmpty' can't be used in a constant expression because it's marked as
    'deferred' which means it isn't available until loaded.
  correctionMessage: >
    Try moving the constant from the deferred library, or removing 'deferred'
    from the import.
  analyzerCode: INVALID_ANNOTATION_CONSTANT_VALUE_FROM_DEFERRED_LIBRARY

ConstEvalFreeTypeParameter:
  problemMessage: "The type '#type' is not a constant because it depends on a type parameter, only instantiated types are allowed."

ConstEvalCircularity:
  problemMessage: "Constant expression depends on itself."
  analyzerCode: RECURSIVE_COMPILE_TIME_CONSTANT

ConstEvalNullValue:
  problemMessage: "Null value during constant evaluation."
  analyzerCode: CONST_EVAL_THROWS_EXCEPTION

ConstEvalNotListOrSetInSpread:
  problemMessage: "Only lists and sets can be used in spreads in constant lists and sets."
  analyzerCode: CONST_SPREAD_EXPECTED_LIST_OR_SET

ConstEvalNotMapInSpread:
  problemMessage: "Only maps can be used in spreads in constant maps."
  analyzerCode: CONST_SPREAD_EXPECTED_MAP

ConstEvalExtension:
  problemMessage: "Extension operations can't be used in constant expressions."
  analyzerCode: NOT_CONSTANT_EXPRESSION

ConstEvalExternalConstructor:
  problemMessage: "External constructors can't be evaluated in constant expressions."

ConstEvalExternalFactory:
  problemMessage: "External factory constructors can't be evaluated in constant expressions."

ConstEvalUnevaluated:
  problemMessage: "Couldn't evaluate constant expression."

ConstEvalError:
  problemMessage: "Error evaluating constant expression: #string"

ConstEvalUnhandledCoreException:
  problemMessage: "Unhandled core exception: #stringOKEmpty"

ConstEvalUnhandledException:
  problemMessage: "Unhandled exception: #constant"

NotConstantExpression:
  problemMessage: "#string is not a constant expression."
  analyzerCode: NOT_CONSTANT_EXPRESSION

NotAConstantExpression:
  problemMessage: "Not a constant expression."
  analyzerCode: NOT_CONSTANT_EXPRESSION

MissingExplicitConst:
  problemMessage: "Constant expression expected."
  correctionMessage: "Try inserting 'const'."
  analyzerCode: NOT_CONSTANT_EXPRESSION
  script: >
    class A {
      final x;
      const A(): x = [];
    }

NonAsciiIdentifier:
  problemMessage: "The non-ASCII character '#character' (#unicode) can't be used in identifiers, only in strings and comments."
  correctionMessage: "Try using an US-ASCII letter, a digit, '_' (an underscore), or '$' (a dollar sign)."
  analyzerCode: ILLEGAL_CHARACTER
  expression: "Ã¥"

NonAsciiWhitespace:
  problemMessage: "The non-ASCII space character #unicode can only be used in strings and comments."
  analyzerCode: ILLEGAL_CHARACTER
  expression: "\u2028 1"

Encoding:
  problemMessage: "Unable to decode bytes as UTF-8."
  bytes: [255]

ExperimentNotEnabled:
  index: 48
  problemMessage: "This requires the '#string' language feature to be enabled."
  correctionMessage: "Try updating your pubspec.yaml to set the minimum SDK constraint to #string2 or higher, and running 'pub get'."
  analyzerCode: ParserErrorCode.EXPERIMENT_NOT_ENABLED

ExperimentNotEnabledOffByDefault:
  index: 133
  problemMessage: "This requires the experimental '#string' language feature to be enabled."
  correctionMessage: "Try passing the '--enable-experiment=#string' command line option."
  analyzerCode: ParserErrorCode.EXPERIMENT_NOT_ENABLED_OFF_BY_DEFAULT

ExperimentDisabled:
  problemMessage: "This requires the '#string' language feature to be enabled."
  correctionMessage: "The feature is on by default but is currently disabled, maybe because the '--enable-experiment=no-#string' command line option is passed."
  analyzerCode: ParserErrorCode.EXPERIMENT_NOT_ENABLED

NullSafetyDisabledInvalidLanguageVersion:
  problemMessage: "This requires null safety, which requires language version of #string2 or higher."
  analyzerCode: ParserErrorCode.EXPERIMENT_NOT_ENABLED

ExperimentDisabledInvalidLanguageVersion:
  problemMessage: "This requires the '#string' language feature, which requires language version of #string2 or higher."
  analyzerCode: ParserErrorCode.EXPERIMENT_NOT_ENABLED

EmptyNamedParameterList:
  problemMessage: "Named parameter lists cannot be empty."
  correctionMessage: "Try adding a named parameter to the list."
  analyzerCode: "MISSING_IDENTIFIER"
  script: >
    foo({}) {}

    main() {
      foo();
    }

RecordLiteralOnePositionalFieldNoTrailingComma:
  problemMessage: "A record literal with exactly one positional field requires a trailing comma."
  correctionMessage: "Try adding a trailing comma."
  analyzerCode: ParserErrorCode.RECORD_LITERAL_ONE_POSITIONAL_NO_TRAILING_COMMA
  index: 127
  hasPublishedDocs: true
  documentation: |-
    #### Description

    The analyzer produces this diagnostic when a record literal with a single
    positional field doesn't have a trailing comma after the field.

    In some locations a record literal with a single positional field could
    also be a parenthesized expression. A trailing comma is required to
    disambiguate these two valid interpretations.

    #### Example

    The following code produces this diagnostic because the record literal has
    one positional field but doesn't have a trailing comma:

    ```dart
    var r = const (1[!)!];
    ```

    #### Common fixes

    Add a trailing comma:

    ```dart
    var r = const (1,);
    ```
  experiments: records
  script: >
    main() {
      var record = const (1);
    }

RecordLiteralZeroFieldsWithTrailingComma:
  problemMessage: "A record literal without fields can't have a trailing comma."
  correctionMessage: "Try removing the trailing comma."
  analyzerCode: ParserErrorCode.EMPTY_RECORD_LITERAL_WITH_COMMA
  index: 128
  hasPublishedDocs: true
  documentation: |-
    #### Description

    The analyzer produces this diagnostic when a record literal that has no
    fields has a trailing comma. Empty record literals can't contain a comma.

    #### Example

    The following code produces this diagnostic because the empty record
    literal has a trailing comma:

    ```dart
    var r = ([!,!]);
    ```

    #### Common fixes

    If the record is intended to be empty, then remove the comma:

    ```dart
    var r = ();
    ```

    If the record is intended to have one or more fields, then add the
    expressions used to compute the values of those fields:

    ```dart
    var r = (3, 4);
    ```
  experiments: records
  script: >
    main() {
      var record = (,);
    }

EmptyRecordTypeNamedFieldsList:
  problemMessage: "The list of named fields in a record type can't be empty."
  correctionMessage: "Try adding a named field to the list."
  analyzerCode: ParserErrorCode.EMPTY_RECORD_TYPE_NAMED_FIELDS_LIST
  index: 129
  hasPublishedDocs: true
  documentation: |-
    #### Description

    The analyzer produces this diagnostic when a record type has an empty list
    of named fields.

    #### Example

    The following code produces this diagnostic because the record type has an
    empty list of named fields:

    ```dart
    void f((int, int, {[!}!]) r) {}
    ```

    #### Common fixes

    If the record is intended to have named fields, then add the types and
    names of the fields:

    ```dart
    void f((int, int, {int z}) r) {}
    ```

    If the record isn't intended to have named fields, then remove the curly
    braces:

    ```dart
    void f((int, int) r) {}
    ```
  experiments: records
  script: >
    main() {
      (int, int, {/*missing*/}) record = (1, 2,);
    }

RecordTypeZeroFieldsButTrailingComma:
  problemMessage: "A record type without fields can't have a trailing comma."
  correctionMessage: "Try removing the trailing comma."
  analyzerCode: ParserErrorCode.EMPTY_RECORD_TYPE_WITH_COMMA
  index: 130
  hasPublishedDocs: true
  documentation: |-
    #### Description

    The analyzer produces this diagnostic when a record type that has no
    fields has a trailing comma. Empty record types can't contain a comma.

    #### Example

    The following code produces this diagnostic because the empty record type
    has a trailing comma:

    ```dart
    void f(([!,!]) r) {}
    ```

    #### Common fixes

    If the record type is intended to be empty, then remove the comma:

    ```dart
    void f(() r) {}
    ```

    If the record type is intended to have one or more fields, then add the
    types of those fields:

    ```dart
    void f((int, int) r) {}
    ```
  experiments: records
  script: >
    main() {
      (,) record = ();
    }

RecordTypeOnePositionalFieldNoTrailingComma:
  problemMessage: "A record type with exactly one positional field requires a trailing comma."
  correctionMessage: "Try adding a trailing comma."
  analyzerCode: ParserErrorCode.RECORD_TYPE_ONE_POSITIONAL_NO_TRAILING_COMMA
  index: 131
  hasPublishedDocs: true
  documentation: |-
    #### Description

    The analyzer produces this diagnostic when a record type annotation with a
    single positional field doesn't have a trailing comma after the field.

    In some locations a record type with a single positional field could also
    be a parenthesized expression. A trailing comma is required to
    disambiguate these two valid interpretations.

    #### Example

    The following code produces this diagnostic because the record type has
    one positional field, but doesn't have a trailing comma:

    ```dart
    void f((int[!)!] r) {}
    ```

    #### Common fixes

    Add a trailing comma:

    ```dart
    void f((int,) r) {}
    ```
  experiments: records
  script: >
    main() {
      (int /* missing trailing comma */) record = const (1, );
    }

DuplicatedRecordTypeFieldName:
  problemMessage: "Duplicated record type field name '#name'."
  correctionMessage: "Try renaming or removing one of the named record type fields."
  experiments: records
  script: |
    ({int a, String a}) record = throw '';

DuplicatedRecordTypeFieldNameContext:
  problemMessage: "This is the existing record type field named '#name'."
  severity: CONTEXT

DuplicatedRecordLiteralFieldName:
  problemMessage: "Duplicated record literal field name '#name'."
  correctionMessage: "Try renaming or removing one of the named record literal fields."
  experiments: records
  script: |
    dynamic field = (a: 0, a: 1);

DuplicatedRecordLiteralFieldNameContext:
  problemMessage: "This is the existing record literal field named '#name'."
  severity: CONTEXT

EmptyOptionalParameterList:
  problemMessage: "Optional parameter lists cannot be empty."
  correctionMessage: "Try adding an optional parameter to the list."
  analyzerCode: "MISSING_IDENTIFIER"
  script: >
    foo([]) {}

    main() {
      foo();
    }

ExpectedElseOrComma:
  index: 46
  problemMessage: "Expected 'else' or comma."
  analyzerCode: ParserErrorCode.EXPECTED_ELSE_OR_COMMA

ExpectedBlock:
  problemMessage: "Expected a block."
  correctionMessage: "Try adding {}."
  analyzerCode: EXPECTED_TOKEN
  script: "try finally {}"

ExpectedBlockToSkip:
  problemMessage: "Expected a function body or '=>'."
  # TODO(ahe): In some scenarios, we can suggest removing the 'static' keyword.
  correctionMessage: "Try adding {}."
  analyzerCode: MISSING_FUNCTION_BODY
  script: "main();"

ExpectedBody:
  problemMessage: "Expected a function body or '=>'."
  # TODO(ahe): In some scenarios, we can suggest removing the 'static' keyword.
  correctionMessage: "Try adding {}."
  analyzerCode: MISSING_FUNCTION_BODY
  script: "main();"

ExpectedStatement:
  index: 29
  problemMessage: "Expected a statement."
  analyzerCode: ParserErrorCode.MISSING_STATEMENT
  statement: "void;"

ExpectedButGot:
  # Also see ExpectedAfterButGot and ExpectedInstead
  problemMessage: "Expected '#string' before this."
  # Consider the second example below: the parser expects a ')' before 'y', but
  # a ',' would also have worked. We don't have enough information to give a
  # good suggestion.
  analyzerCode: EXPECTED_TOKEN
  script:
    - "main() => true ? 1;"
    - "main() => foo(x: 1 y: 2);"

ExpectedAfterButGot:
  # Also see ExpectedButGot and ExpectedInstead
  problemMessage: "Expected '#string' after this."
  # This is an alternative to ExpectedButGot when it's better for the error to be
  # associated with the last consumed token rather than the token being parsed.
  # Doing so can make it cognitively easier for the user to understand and fix.
  #
  # For example, this is ok...
  #
  #    x = 7
  #    class Foo {
  #    ^^^^^
  #        Expected ';' before this
  #
  # but this is easier for the user...
  #
  #    x = 7
  #        ^
  #        Expected ';' after this
  #    class Foo {
  #
  analyzerCode: EXPECTED_TOKEN
  script:
    - "main() { return true }"

ExpectedInstead:
  # Also see ExpectedButGot and ExpectedAfterButGot
  index: 41
  problemMessage: "Expected '#string' instead of this."
  # This is an alternative to ExpectedButGot when the last consumed token
  # should be replaced with a different token.
  #
  # For example, this is ok...
  #
  #    mixin Foo extends Bar {
  #              ^^^^^^^
  #              Expected 'on' before this
  #
  # but this is easier for the user...
  #
  #    mixin Foo extends Bar {
  #              ^^^^^^^
  #              Expected 'on' instead of this
  #
  analyzerCode: ParserErrorCode.EXPECTED_INSTEAD
  script:
    - "class B {} mixin A extends B { }"

MultipleLibraryDirectives:
  index: 27
  problemMessage: "Only one library directive may be declared in a file."
  correctionMessage: "Try removing all but one of the library directives."
  analyzerCode: ParserErrorCode.MULTIPLE_LIBRARY_DIRECTIVES

MultipleExtends:
  index: 28
  problemMessage: "Each class definition can have at most one extends clause."
  correctionMessage: "Try choosing one superclass and define your class to implement (or mix in) the others."
  analyzerCode: ParserErrorCode.MULTIPLE_EXTENDS_CLAUSES
  script:
    - "class B{} class C{} class A extends B extends C {}"
    - "class B{} class C{} class A extends B, C {}"

MultipleWith:
  index: 24
  problemMessage: "Each class definition can have at most one with clause."
  correctionMessage: "Try combining all of the with clauses into a single clause."
  analyzerCode: ParserErrorCode.MULTIPLE_WITH_CLAUSES
  script: "class A extends B with C, D with E {}"

WithBeforeExtends:
  index: 11
  problemMessage: "The extends clause must be before the with clause."
  correctionMessage: "Try moving the extends clause before the with clause."
  analyzerCode: ParserErrorCode.WITH_BEFORE_EXTENDS
  script: "mixin B {} class C {} class A with B extends C {}"

ImplementsBeforeExtends:
  index: 44
  problemMessage: "The extends clause must be before the implements clause."
  correctionMessage: "Try moving the extends clause before the implements clause."
  analyzerCode: ParserErrorCode.IMPLEMENTS_BEFORE_EXTENDS
  script: "class A implements B extends C {}"

ImplementsBeforeOn:
  index: 43
  problemMessage: "The on clause must be before the implements clause."
  correctionMessage: "Try moving the on clause before the implements clause."
  analyzerCode: ParserErrorCode.IMPLEMENTS_BEFORE_ON
  script: "mixin A implements B on C {}"

ImplementsBeforeWith:
  index: 42
  problemMessage: "The with clause must be before the implements clause."
  correctionMessage: "Try moving the with clause before the implements clause."
  analyzerCode: ParserErrorCode.IMPLEMENTS_BEFORE_WITH
  script: "class A extends B implements C with D {}"

ImplementsRepeated:
  problemMessage: "'#name' can only be implemented once."
  analyzerCode: IMPLEMENTS_REPEATED
  correctionMessage: "Try removing #count of the occurrences."
  script:
    - >-
      abstract class I {}
      abstract class J {}
      class K implements I, J, I {}

ImplementsSuperClass:
  problemMessage: "'#name' can't be used in both 'extends' and 'implements' clauses."
  analyzerCode: IMPLEMENTS_SUPER_CLASS
  correctionMessage: "Try removing one of the occurrences."
  script:
    - >-
      abstract class A {}
      class C extends A implements A {}

MultipleImplements:
  problemMessage: "Each class definition can have at most one implements clause."
  correctionMessage: "Try combining all of the implements clauses into a single clause."
  analyzerCode: MULTIPLE_IMPLEMENTS_CLAUSES
  script: "class A implements B implements C, D {}"

MultipleClauses:
  problemMessage: "Each '#string' definition can have at most one '#string2' clause."
  correctionMessage: "Try combining all of the '#string2' clauses into a single clause."
  experiments: enhanced-enums
  analyzerCode: ParserErrorCode.MULTIPLE_CLAUSES
  index: 121
  script:
    - "mixin B {} enum A implements B implements C, D { v; }"
    - "mixin B {} enum A with B with C, D { v; }"

OutOfOrderClauses:
  problemMessage: "The '#string' clause must come before the '#string2' clause."
  correctionMessage: "Try moving the '#string' clause before the '#string2' clause."
  experiments: enhanced-enums
  analyzerCode: ParserErrorCode.OUT_OF_ORDER_CLAUSES
  index: 122
  script: "class B {} class D {} enum A implements B with D { v; }"

MultipleOnClauses:
  index: 26
  problemMessage: "Each mixin definition can have at most one on clause."
  correctionMessage: "Try combining all of the on clauses into a single clause."
  analyzerCode: ParserErrorCode.MULTIPLE_ON_CLAUSES
  script: "mixin A on B on C, D {}"

MixinWithClause:
  index: 154
  problemMessage: "A mixin can't have a with clause."
  analyzerCode: ParserErrorCode.MIXIN_WITH_CLAUSE
  script: "mixin M {} mixin N with M {}"

ExtendsFutureOr:
  problemMessage: "The type 'FutureOr' can't be used in an 'extends' clause."

ImplementsFutureOr:
  problemMessage: "The type 'FutureOr' can't be used in an 'implements' clause."

ExtendsNever:
  problemMessage: "The type 'Never' can't be used in an 'extends' clause."

ImplementsNever:
  problemMessage: "The type 'Never' can't be used in an 'implements' clause."

ExtendsVoid:
  problemMessage: "The type 'void' can't be used in an 'extends' clause."

ImplementsVoid:
  problemMessage: "The type 'void' can't be used in an 'implements' clause."

ExpectedClassOrMixinBody:
  index: 8
  problemMessage: "A #string must have a body, even if it is empty."
  correctionMessage: "Try adding an empty body."
  analyzerCode: ParserErrorCode.EXPECTED_BODY

ExpectedDeclaration:
  problemMessage: "Expected a declaration, but got '#lexeme'."
  analyzerCode: EXPECTED_EXECUTABLE

ExpectedClassMember:
  problemMessage: "Expected a class member, but got '#lexeme'."
  analyzerCode: EXPECTED_CLASS_MEMBER

ExpectedFunctionBody:
  problemMessage: "Expected a function body, but got '#lexeme'."
  analyzerCode: MISSING_FUNCTION_BODY

ExpectedHexDigit:
  problemMessage: "A hex digit (0-9 or A-F) must follow '0x'."
  # No tip, seems obvious from the error message.
  analyzerCode: MISSING_HEX_DIGIT
  script: >
    main() {
      var i = 0x;
    }

ExpectedIdentifier:
  problemMessage: "Expected an identifier, but got '#lexeme'."
  correctionMessage: "Try inserting an identifier before '#lexeme'."
  analyzerCode: MISSING_IDENTIFIER
  script: "var = 42;"

ExpectedIdentifierButGotKeyword:
  problemMessage: "'#lexeme' can't be used as an identifier because it's a keyword."
  correctionMessage: "Try renaming this to be an identifier that isn't a keyword."
  index: 113
  analyzerCode: ParserErrorCode.EXPECTED_IDENTIFIER_BUT_GOT_KEYWORD
  script: "var default = 42;"

EqualityCannotBeEqualityOperand:
  index: 1
  problemMessage: "A comparison expression can't be an operand of another comparison expression."
  correctionMessage: "Try putting parentheses around one of the comparisons."
  analyzerCode: ParserErrorCode.EQUALITY_CANNOT_BE_EQUALITY_OPERAND
  script:
    - "main() { var b = a < b < c; }"
    - "main() { var b = a == b != c; }"

ExpectedOpenParens:
  problemMessage: "Expected '('."

ExpectedString:
  problemMessage: "Expected a String, but got '#lexeme'."
  analyzerCode: EXPECTED_STRING_LITERAL

ExpectedToken:
  problemMessage: "Expected to find '#string'."
  analyzerCode: EXPECTED_TOKEN

ExpectedType:
  problemMessage: "Expected a type, but got '#lexeme'."
  analyzerCode: EXPECTED_TYPE_NAME

VarAsTypeName:
  index: 61
  problemMessage: "The keyword 'var' can't be used as a type name."
  analyzerCode: ParserErrorCode.VAR_AS_TYPE_NAME
  script:
    - "class A { Map<String, var> m; }"

MissingExpressionInThrow:
  index: 32
  problemMessage: "Missing expression after 'throw'."
  correctionMessage: "Add an expression after 'throw' or use 'rethrow' to throw a caught exception"
  analyzerCode: ParserErrorCode.MISSING_EXPRESSION_IN_THROW
  statement:
    - "throw;"

MissingConstFinalVarOrType:
  index: 33
  problemMessage: "Variables must be declared using the keywords 'const', 'final', 'var' or a type name."
  correctionMessage: "Try adding the name of the type of the variable or the keyword 'var'."
  analyzerCode: ParserErrorCode.MISSING_CONST_FINAL_VAR_OR_TYPE
  script:
    - "class C { static f; }"

FunctionTypedParameterVar:
  index: 119
  problemMessage: "Function-typed parameters can't specify 'const', 'final' or 'var' in place of a return type."
  correctionMessage: "Try replacing the keyword with a return type."
  analyzerCode: ParserErrorCode.FUNCTION_TYPED_PARAMETER_VAR
  script:
    - "void f(const x()) {}"
    - "void f(final x()) {}"
    - "void f(var x()) {}"

AbstractClassMember:
  index: 51
  problemMessage: "Members of classes can't be declared to be 'abstract'."
  correctionMessage: "Try removing the 'abstract' keyword. You can add the 'abstract' keyword before the class declaration."
  analyzerCode: ParserErrorCode.ABSTRACT_CLASS_MEMBER
  script:
    - |
      abstract class C {abstract C.c();}
    - |
      abstract class C {abstract m();}
    - |
      abstract class C {abstract get m;}
    - |
      abstract class C {abstract set m(int x);}
    - |
      // @dart=2.9
      abstract class C {abstract var f;}
    - |
      // @dart=2.9
      abstract class C {abstract static var f;}

AbstractExternalField:
  index: 110
  problemMessage: "Fields can't be declared both 'abstract' and 'external'."
  analyzerCode: ParserErrorCode.ABSTRACT_EXTERNAL_FIELD
  correctionMessage: "Try removing the 'abstract' or 'external' keyword."
  configuration: nnbd-strong
  script:
    - "abstract class C {abstract external var f;}"
    - "abstract class C {external abstract var f;}"

AbstractStaticField:
  index: 107
  problemMessage: "Static fields can't be declared 'abstract'."
  analyzerCode: ParserErrorCode.ABSTRACT_STATIC_FIELD
  correctionMessage: "Try removing the 'abstract' or 'static' keyword."
  configuration: nnbd-strong
  script:
    - "abstract class C {abstract static var f;}"

AbstractExtensionField:
  problemMessage: "Extension fields can't be declared 'abstract'."
  correctionMessage: "Try removing the 'abstract' keyword."
# Separate class and extension field handling to support this.
#  configuration: nnbd-strong
#  script:
#    - "extension C on int {abstract static var f;}"

AbstractFieldInitializer:
  problemMessage: "Abstract fields cannot have initializers."
  correctionMessage: "Try removing the initializer or the 'abstract' keyword."
  configuration: nnbd-strong
  script:
    - "abstract class C {abstract var f = 0;}"

AbstractFieldConstructorInitializer:
  problemMessage: "Abstract fields cannot have initializers."
  correctionMessage: "Try removing the field initializer or the 'abstract' keyword from the field declaration."
  configuration: nnbd-strong
  script:
    - "abstract class C {abstract var f; C(this.f);}"
    - "abstract class C {abstract var f; C() : this.f = 0;}"

AbstractLateField:
  index: 108
  problemMessage: "Abstract fields cannot be late."
  analyzerCode: ParserErrorCode.ABSTRACT_LATE_FIELD
  correctionMessage: "Try removing the 'abstract' or 'late' keyword."
  configuration: nnbd-strong
  script:
    - "abstract class C {abstract late var f;}"

AbstractSealedClass:
  problemMessage: "A 'sealed' class can't be marked 'abstract' because it's already implicitly abstract."
  correctionMessage: "Try removing the 'abstract' keyword."
  analyzerCode: ParserErrorCode.ABSTRACT_SEALED_CLASS
  index: 132
  hasPublishedDocs: true
  documentation: |-
    #### Description

    The analyzer produces this diagnostic when a class is declared using both
    the modifier `abstract` and the modifier `sealed`. Sealed classes are
    implicitly abstract, so explicitly using both modifiers is not allowed.

    #### Example

    The following code produces this diagnostic because the class `C` is
    declared using both `abstract` and `sealed`:

    ```dart
    abstract [!sealed!] class C {}
    ```

    #### Common fixes

    If the class should be abstract but not sealed, then remove the `sealed`
    modifier:

    ```dart
    abstract class C {}
    ```

    If the class should be both abstract and sealed, then remove the
    `abstract` modifier:

    ```dart
    sealed class C {}
    ```
  experiments: sealed-class
  script:
    - "sealed abstract class C {}"
    - "abstract sealed class C {}"

ClassInClass:
  index: 53
  problemMessage: "Classes can't be declared inside other classes."
  correctionMessage: "Try moving the class to the top-level."
  analyzerCode: ParserErrorCode.CLASS_IN_CLASS
  script:
    - "class C { class B {} }"

EnumInClass:
  index: 74
  problemMessage: "Enums can't be declared inside classes."
  correctionMessage: "Try moving the enum to the top-level."
  analyzerCode: ParserErrorCode.ENUM_IN_CLASS
  script:
    - "class Foo { enum Bar { Bar1, Bar2, Bar3 } }"

TypedefInClass:
  index: 7
  problemMessage: "Typedefs can't be declared inside classes."
  correctionMessage: "Try moving the typedef to the top-level."
  analyzerCode: ParserErrorCode.TYPEDEF_IN_CLASS
  script:
    - "abstract class C { typedef int F(int x); }"

CovariantMember:
  index: 67
  problemMessage: "Getters, setters and methods can't be declared to be 'covariant'."
  correctionMessage: "Try removing the 'covariant' keyword."
  analyzerCode: ParserErrorCode.COVARIANT_MEMBER
  script:
    - "static covariant get x => 0;"
    - "covariant int m() => 0;"

VarReturnType:
  index: 12
  problemMessage: "The return type can't be 'var'."
  correctionMessage: "Try removing the keyword 'var', or replacing it with the name of the return type."
  analyzerCode: ParserErrorCode.VAR_RETURN_TYPE
  script:
    - "class C { var m() {} }"
    - "class C { var C() {} }"

ConstClass:
  index: 60
  problemMessage: "Classes can't be declared to be 'const'."
  correctionMessage: "Try removing the 'const' keyword. If you're trying to indicate that instances of the class can be constants, place the 'const' keyword on  the class' constructor(s)."
  analyzerCode: ParserErrorCode.CONST_CLASS
  script: "const class C {}"

ConstAndFinal:
  index: 58
  problemMessage: "Members can't be declared to be both 'const' and 'final'."
  correctionMessage: "Try removing either the 'const' or 'final' keyword."
  analyzerCode: ParserErrorCode.CONST_AND_FINAL
  declaration:
    - "class C { static const final int x = 5; }"
    - "class C { static final const int x = 5; }"
    - "const final int x = 5;"
    - "final const int x = 5;"

ConflictingModifiers:
  index: 59
  problemMessage: "Members can't be declared to be both '#string' and '#string2'."
  correctionMessage: "Try removing one of the keywords."
  analyzerCode: ParserErrorCode.CONFLICTING_MODIFIERS
  script:
    - "class C { const var x; }"
    - "class C { var const x; }"

ConstFactory:
  index: 62
  problemMessage: "Only redirecting factory constructors can be declared to be 'const'."
  correctionMessage: "Try removing the 'const' keyword, or replacing the body with '=' followed by a valid target."
  analyzerCode: ParserErrorCode.CONST_FACTORY
  script: |
    class C {
      const factory C() => const C.internal();
      const C.internal();
    }

ConstFactoryRedirectionToNonConst:
  problemMessage: "Constant factory constructor can't delegate to a non-constant constructor."
  correctionMessage: "Try redirecting to a different constructor or marking the target constructor 'const'."
  analyzerCode: REDIRECT_TO_NON_CONST_CONSTRUCTOR
  script:
    - >-
      class A {
        const factory A.foo() = A.bar;
        A.bar() {}
      }

NonConstFactory:
  problemMessage: "Cannot invoke a non-'const' factory where a const expression is expected."
  correctionMessage: "Try using a constructor or factory that is 'const'."
  analyzerCode: NOT_CONSTANT_EXPRESSION

NonConstConstructor:
  problemMessage: "Cannot invoke a non-'const' constructor where a const expression is expected."
  correctionMessage: "Try using a constructor or factory that is 'const'."
  analyzerCode: NOT_CONSTANT_EXPRESSION

ModifierOutOfOrder:
  index: 56
  problemMessage: "The modifier '#string' should be before the modifier '#string2'."
  correctionMessage: "Try re-ordering the modifiers."
  analyzerCode: ParserErrorCode.MODIFIER_OUT_OF_ORDER
  script:
    - "class C { factory const C() = prefix.B.foo; }"
    - "class C { factory external C(); }"
    - "class C { const external C(); }"
    - "class C { static external f(); }"
    - "class C { final static int f = 5; }"
    - "class C { var static f; }"

TypeBeforeFactory:
  index: 57
  problemMessage: "Factory constructors cannot have a return type."
  correctionMessage: "Try removing the type appearing before 'factory'."
  analyzerCode: ParserErrorCode.TYPE_BEFORE_FACTORY
  script: |
    class C {
      T factory C() { return new C.constructor(); }
      C.constructor();
    }

ConstConstructorWithBody:
  problemMessage: "A const constructor can't have a body."
  correctionMessage: "Try removing either the 'const' keyword or the body."
  analyzerCode: CONST_CONSTRUCTOR_WITH_BODY
  script:
    - "class C { const C() {} }"

ConstMethod:
  index: 63
  problemMessage: "Getters, setters and methods can't be declared to be 'const'."
  correctionMessage: "Try removing the 'const' keyword."
  analyzerCode: ParserErrorCode.CONST_METHOD
  script:
    - "class C { const m() {} }"

CovariantAndStatic:
  index: 66
  problemMessage: "Members can't be declared to be both 'covariant' and 'static'."
  correctionMessage: "Try removing either the 'covariant' or 'static' keyword."
  analyzerCode: ParserErrorCode.COVARIANT_AND_STATIC
  script:
    - "class C { covariant static A f; }"
    - "class C { static covariant A f; }"

DuplicatedModifier:
  index: 70
  problemMessage: "The modifier '#lexeme' was already specified."
  correctionMessage: "Try removing all but one occurrence of the modifier."
  analyzerCode: ParserErrorCode.DUPLICATED_MODIFIER
  comment: |-
    Parameters:
    0: the modifier that was duplicated
  script:
    - "class C { const const m; }"
    - "class C { external external f(); }"
    - "class C { final final m = 5; }"
    - "class C { static static var m; }"
    - "class C { var var m; }"

ExternalConstructorWithBody:
  index: 87
  problemMessage: "External constructors can't have a body."
  correctionMessage: "Try removing the body of the constructor, or removing the keyword 'external'."
  analyzerCode: ParserErrorCode.EXTERNAL_CONSTRUCTOR_WITH_BODY
  script:
    - "class C { external C() {} }"

ExternalConstructorWithFieldInitializers:
  problemMessage: "An external constructor can't initialize fields."
  correctionMessage: "Try removing the field initializers, or removing the keyword 'external'."
  analyzerCode: EXTERNAL_CONSTRUCTOR_WITH_FIELD_INITIALIZERS

ExternalFactoryWithBody:
  index: 86
  problemMessage: "External factories can't have a body."
  correctionMessage: "Try removing the body of the factory, or removing the keyword 'external'."
  analyzerCode: ParserErrorCode.EXTERNAL_FACTORY_WITH_BODY
  script:
    - "class C { external factory C() {} }"

ExternalField:
  index: 50
  problemMessage: "Fields can't be declared to be 'external'."
  correctionMessage: "Try removing the keyword 'external', or replacing the field by an external getter and/or setter."
  analyzerCode: ParserErrorCode.EXTERNAL_FIELD
  script:
    - |
      // @dart=2.9
      class C { external var f; }


ExternalFieldInitializer:
  problemMessage: "External fields cannot have initializers."
  correctionMessage: "Try removing the initializer or the 'external' keyword."
  configuration: nnbd-strong
  script:
    - "external var f = 0;"
    - "abstract class C {external var f = 0;}"

ExternalFieldConstructorInitializer:
  problemMessage: "External fields cannot have initializers."
  correctionMessage: "Try removing the field initializer or the 'external' keyword from the field declaration."
  configuration: nnbd-strong
  script:
    - "abstract class C {external var f; C(this.f);}"
    - "abstract class C {external var f; C() : this.f = 0;}"

ExternalLateField:
  index: 109
  problemMessage: "External fields cannot be late."
  analyzerCode: ParserErrorCode.EXTERNAL_LATE_FIELD
  correctionMessage: "Try removing the 'external' or 'late' keyword."
  configuration: nnbd-strong
  script:
    - "external late var f;"
    - "abstract class C {external late var f;}"

InitializerForStaticField:
  problemMessage: "'#name' isn't an instance field of this class."
  analyzerCode: INITIALIZER_FOR_STATIC_FIELD

MoreThanOneSuperInitializer:
  problemMessage: "Can't have more than one 'super' initializer."
  analyzerCode: MULTIPLE_SUPER_INITIALIZERS
  script:
    - "class C { C.bad() : super(), super(); }"

RedirectingConstructorWithSuperInitializer:
  problemMessage: "A redirecting constructor can't have a 'super' initializer."
  analyzerCode: SUPER_IN_REDIRECTING_CONSTRUCTOR
  script:
    - "class C { C(); C.bad() : super(), this(); }"
    - "class C { C(); C.bad() : this(), super(); }"

RedirectingConstructorWithMultipleRedirectInitializers:
  problemMessage: "A redirecting constructor can't have more than one redirection."
  analyzerCode: MULTIPLE_REDIRECTING_CONSTRUCTOR_INVOCATIONS
  script:
    - "class C { C(); C.bad() : this(), this(); }"

RedirectingConstructorWithAnotherInitializer:
  problemMessage: "A redirecting constructor can't have other initializers."
  # also ASSERT_IN_REDIRECTING_CONSTRUCTOR
  analyzerCode: FIELD_INITIALIZER_REDIRECTING_CONSTRUCTOR
  script:
    - "class C { int? x; C(); C.bad() : x = 5, this(); }"
    - "class C { int? x; C(); C.bad() : this(), x = 5; }"
    - "class C { int? x; C(); C.bad() : assert(true), this(); }"
    - "class C { int? x; C(); C.bad() : this(), assert(true); }"

SuperInitializerNotLast:
  problemMessage: "Can't have initializers after 'super'."
  analyzerCode: SUPER_INVOCATION_NOT_LAST
  script:
    - "class C { int x; C.bad() : super(), x = 5; }"

ExtraneousModifier:
  index: 77
  problemMessage: "Can't have modifier '#lexeme' here."
  correctionMessage: "Try removing '#lexeme'."
  analyzerCode: ParserErrorCode.EXTRANEOUS_MODIFIER
  script:
    - "var String foo; main(){}"
    - "var set foo; main(){}"
    - "var final foo; main(){}"
    - "var var foo; main(){}"
    - "var const foo; main(){}"
    - "var abstract foo; main(){}"
    - "var static foo; main(){}"
    - "var external foo; main(){}"
    - "get var foo; main(){}"
    - "set var foo; main(){}"
    - "final var foo; main(){}"
    - "var var foo; main(){}"
    - "const var foo; main(){}"
    - "abstract var foo; main(){}"
    - "static var foo; main(){}"
    - "external var foo; main(){}"
    - "set foo; main(){}"
    - "abstract foo; main(){}"
    - "static foo; main(){}"
    - "external foo; main(){}"
    - "abstract enum foo {bar}"
    - "abstract void foo() {}"
    - "static void foo() {}"
    - "abstract typedef foo();"
    - "static typedef foo();"

ExtraneousModifierInExtension:
  index: 98
  problemMessage: "Can't have modifier '#lexeme' in an extension."
  correctionMessage: "Try removing '#lexeme'."
  analyzerCode: ParserErrorCode.INVALID_USE_OF_COVARIANT_IN_EXTENSION
  hasPublishedDocs: true
  comment: No parameters.
  documentation: |-
    #### Description

    The analyzer produces this diagnostic when a member declared inside an
    extension uses the keyword `covariant` in the declaration of a parameter.
    Extensions aren't classes and don't have subclasses, so the keyword serves
    no purpose.

    #### Example

    The following code produces this diagnostic because `i` is marked as being
    covariant:

    ```dart
    extension E on String {
      void a([!covariant!] int i) {}
    }
    ```

    #### Common fixes

    Remove the `covariant` keyword:

    ```dart
    extension E on String {
      void a(int i) {}
    }
    ```
  script:
    - "extension on String { foo(covariant String child) {} }"

FinalAndCovariant:
  index: 80
  problemMessage: "Members can't be declared to be both 'final' and 'covariant'."
  correctionMessage: "Try removing either the 'final' or 'covariant' keyword."
  analyzerCode: ParserErrorCode.FINAL_AND_COVARIANT
  script:
    - "class C { covariant final f = 5; }"
    - "class C { final covariant f = 5; }"

FinalAndCovariantLateWithInitializer:
  index: 101
  problemMessage: "Members marked 'late' with an initializer can't be declared to be both 'final' and 'covariant'."
  correctionMessage: "Try removing either the 'final' or 'covariant' keyword, or removing the initializer."
  analyzerCode: ParserErrorCode.FINAL_AND_COVARIANT_LATE_WITH_INITIALIZER
  # Weak and strong doesn't matter in this instance.
  configuration: nnbd-strong
  script:
    - "class C { covariant late final f = 5; }"

FinalAndVar:
  index: 81
  problemMessage: "Members can't be declared to be both 'final' and 'var'."
  correctionMessage: "Try removing the keyword 'var'."
  analyzerCode: ParserErrorCode.FINAL_AND_VAR
  script:
    - "class C { final var x = 5; }"
    - "class C { var final x = 5; }"

StaticConstructor:
  index: 4
  problemMessage: "Constructors can't be static."
  correctionMessage: "Try removing the keyword 'static'."
  analyzerCode: ParserErrorCode.STATIC_CONSTRUCTOR
  script:
    - "class C { static C() {} }"
    - "class C { static C.m() {} }"

GetterConstructor:
  index: 103
  problemMessage: "Constructors can't be a getter."
  correctionMessage: "Try removing 'get'."
  analyzerCode: ParserErrorCode.GETTER_CONSTRUCTOR
  script:
    - "class C { get C.m() {} }"

SetterConstructor:
  index: 104
  problemMessage: "Constructors can't be a setter."
  correctionMessage: "Try removing 'set'."
  analyzerCode: ParserErrorCode.SETTER_CONSTRUCTOR
  script:
    - "class C { set C.m(x) {} }"

StaticOperator:
  index: 17
  problemMessage: "Operators can't be static."
  correctionMessage: "Try removing the keyword 'static'."
  analyzerCode: ParserErrorCode.STATIC_OPERATOR
  script:
    - "class C { static operator +(int x) => x + 1; }"

BreakOutsideOfLoop:
  index: 52
  problemMessage: "A break statement can't be used outside of a loop or switch statement."
  correctionMessage: "Try removing the break statement."
  analyzerCode: ParserErrorCode.BREAK_OUTSIDE_OF_LOOP
  script:
    - "main() { break; }"

InvalidBreakTarget:
  problemMessage: "Can't break to '#name'."

BreakTargetOutsideFunction:
  problemMessage: "Can't break to '#name' in a different function."
  analyzerCode: LABEL_IN_OUTER_SCOPE
  statement: |
    label: while (true) {
      void f() {
        while (true) {
          break label;
        }
      }
    }

AnonymousBreakTargetOutsideFunction:
  problemMessage: "Can't break to a target in a different function."
  analyzerCode: LABEL_IN_OUTER_SCOPE
  statement: |
    while (true) {
      void f() {
        break;
      }
    }

ContinueLabelInvalid:
  problemMessage: "A 'continue' label must be on a loop or a switch member."
  analyzerCode: CONTINUE_LABEL_INVALID
  statement:
    - "L: { for (var i in [ ]) { continue L; } }"

ContinueOutsideOfLoop:
  index: 2
  problemMessage: "A continue statement can't be used outside of a loop or switch statement."
  correctionMessage: "Try removing the continue statement."
  analyzerCode: ParserErrorCode.CONTINUE_OUTSIDE_OF_LOOP
  script:
    - "main() { continue; }"

InvalidContinueTarget:
  problemMessage: "Can't continue at '#name'."

ContinueTargetOutsideFunction:
  problemMessage: "Can't continue at '#name' in a different function."
  analyzerCode: LABEL_IN_OUTER_SCOPE
  statement: |
    label: while (true) {
      void f() {
        while (true) {
          continue label;
        }
      }
    }

AnonymousContinueTargetOutsideFunction:
  problemMessage: "Can't continue at a target in a different function."
  analyzerCode: LABEL_IN_OUTER_SCOPE
  statement: |
    while (true) {
      void f() {
        continue;
      }
    }

ContinueWithoutLabelInCase:
  index: 64
  problemMessage: "A continue statement in a switch statement must have a label as a target."
  correctionMessage: "Try adding a label associated with one of the case clauses to the continue statement."
  analyzerCode: ParserErrorCode.CONTINUE_WITHOUT_LABEL_IN_CASE
  script:
    - "main() { switch (x) {case 1: continue;} }"

DuplicateLabelInSwitchStatement:
  index: 72
  problemMessage: "The label '#name' was already used in this switch statement."
  correctionMessage: "Try choosing a different name for this label."
  analyzerCode: ParserErrorCode.DUPLICATE_LABEL_IN_SWITCH_STATEMENT
  comment: |-
    Parameters:
    0: the label that was duplicated
  statement:
    - "switch (0) {l1: case 0: break; l1: case 1: break;}"

LabelNotFound:
  problemMessage: "Can't find label '#name'."
  correctionMessage: "Try defining the label, or correcting the name to match an existing label."
  analyzerCode: LABEL_UNDEFINED
  statement:
    - "switch (0) {case 0: continue L;}"

InitializedVariableInForEach:
  index: 82
  problemMessage: "The loop variable in a for-each loop can't be initialized."
  correctionMessage: "Try removing the initializer, or using a different kind of loop."
  analyzerCode: ParserErrorCode.INITIALIZED_VARIABLE_IN_FOR_EACH
  statement:
    - "for (int a = 0 in <int>[10]) {}"

InvalidAwaitFor:
  index: 9
  problemMessage: "The keyword 'await' isn't allowed for a normal 'for' statement."
  correctionMessage: "Try removing the keyword, or use a for-each statement."
  analyzerCode: ParserErrorCode.INVALID_AWAIT_IN_FOR
  script:
    - "f() async {await for (int i = 0; i < 5; i++) {}}"

InvalidSyncModifier:
  problemMessage: "Invalid modifier 'sync'."
  correctionMessage: "Try replacing 'sync' with 'sync*'."
  analyzerCode: MISSING_STAR_AFTER_SYNC
  script: "main() sync {}"

InvalidVoid:
  problemMessage: "Type 'void' can't be used here."
  correctionMessage: "Try removing 'void' keyword or replace it with 'var', 'final', or a type."
  analyzerCode: EXPECTED_TYPE_NAME
  script:
    - "void x; main() {}"
    - "foo(void x) {} main() { foo(null); }"

VoidWithTypeArguments:
  problemMessage: "Type 'void' can't have type arguments."
  correctionMessage: "Try removing the type arguments."
  index: 100
  analyzerCode: ParserErrorCode.VOID_WITH_TYPE_ARGUMENTS
  script:
    - "void<int> f() {}"

# TODO(danrubel): Review where this error is generated and consider generating
# FieldInitializedOutsideDeclaringClass instead of this in some situations.
InvalidInitializer:
  index: 90
  problemMessage: "Not a valid initializer."
  correctionMessage: "To initialize a field, use the syntax 'name = value'."
  analyzerCode: ParserErrorCode.INVALID_INITIALIZER

FieldInitializedOutsideDeclaringClass:
  index: 88
  problemMessage: "A field can only be initialized in its declaring class"
  correctionMessage: "Try passing a value into the superclass constructor, or moving the initialization into the constructor body."
  analyzerCode: ParserErrorCode.FIELD_INITIALIZED_OUTSIDE_DECLARING_CLASS
  script:
    - "class A { int a; } class C extends A { C() : super.a = 42; }"

FinalFieldNotInitialized:
  problemMessage: "Final field '#name' is not initialized."
  correctionMessage: "Try to initialize the field in the declaration or in every constructor."
  analyzerCode: FINAL_NOT_INITIALIZED
  script: >
    class C {
      final int x;
    }

FinalFieldNotInitializedByConstructor:
  problemMessage: "Final field '#name' is not initialized by this constructor."
  correctionMessage: "Try to initialize the field using an initializing formal or a field initializer."
  analyzerCode: FINAL_NOT_INITIALIZED_CONSTRUCTOR_1
  script: >
    class C {
      final int x;
      C(this.x) {}
      C.missing() {}
    }

MissingExponent:
  problemMessage: "Numbers in exponential notation should always contain an exponent (an integer number with an optional sign)."
  correctionMessage: "Make sure there is an exponent, and remove any whitespace before it."
  analyzerCode: MISSING_DIGIT
  script: >
    main() {
      var i = 1e;
    }

PositionalParameterWithEquals:
  problemMessage: "Positional optional parameters can't use ':' to specify a default value."
  correctionMessage: "Try replacing ':' with '='."
  analyzerCode: WRONG_SEPARATOR_FOR_POSITIONAL_PARAMETER
  script: >
    main() {
      foo([a: 1]) => print(a);
      foo(2);
    }

RequiredParameterWithDefault:
  problemMessage: "Non-optional parameters can't have a default value."
  correctionMessage: "Try removing the default value or making the parameter optional."
  analyzerCode: NAMED_PARAMETER_OUTSIDE_GROUP
  script:
    - >
      main() {
        foo(a: 1) => print(a);
        foo(2);
      }
    - >
      main() {
        foo(a = 1) => print(a);
        foo(2);
      }

StackOverflow:
  index: 19
  problemMessage: "The file has too many nested expressions or statements."
  correctionMessage: "Try simplifying the code."
  analyzerCode: ParserErrorCode.STACK_OVERFLOW

InvalidCodePoint:
  problemMessage: "The escape sequence starting with '\\u' isn't a valid code point."
  analyzerCode: INVALID_CODE_POINT
  expression:
    - "'\\u{110000}'"

InvalidHexEscape:
  index: 40
  problemMessage: "An escape sequence starting with '\\x' must be followed by 2 hexadecimal digits."
  analyzerCode: ParserErrorCode.INVALID_HEX_ESCAPE
  expression:
    - "'\\x0'"
    - "'\\x0y'"

InvalidUnicodeEscapeUStarted:
  index: 38
  problemMessage: "An escape sequence starting with '\\u' must be followed by 4 hexadecimal digits or from 1 to 6 digits between '{' and '}'."
  analyzerCode: ParserErrorCode.INVALID_UNICODE_ESCAPE_U_STARTED
  expression:
    - "'\\u'"

InvalidUnicodeEscapeUNoBracket:
  index: 124
  problemMessage: "An escape sequence starting with '\\u' must be followed by 4 hexadecimal digits."
  analyzerCode: ParserErrorCode.INVALID_UNICODE_ESCAPE_U_NO_BRACKET
  expression:
    - "'\\u0F'"

InvalidUnicodeEscapeUBracket:
  index: 125
  problemMessage: "An escape sequence starting with '\\u{' must be followed by 1 to 6 hexadecimal digits followed by a '}'."
  analyzerCode: ParserErrorCode.INVALID_UNICODE_ESCAPE_U_BRACKET
  expression:
    - "'\\u{'"
    - "'\\u{03'"
    - "'\\u{0Z}'"
    - "'\\u{0000003}'"

InvalidEscapeStarted:
  index: 126
  problemMessage: "The string '\\' can't stand alone."
  correctionMessage: "Try adding another backslash (\\) to escape the '\\'."
  analyzerCode: ParserErrorCode.INVALID_UNICODE_ESCAPE_STARTED
  exampleAllowMoreCodes: true
  expression:
    - |
      print('Hello, World!\
      ');

UnexpectedDollarInString:
  problemMessage: "A '$' has special meaning inside a string, and must be followed by an identifier or an expression in curly braces ({})."
  correctionMessage: "Try adding a backslash (\\) to escape the '$'."
  analyzerCode: UNEXPECTED_DOLLAR_IN_STRING
  expression:
    - "'$'"
    - '"$"'
    - "'''$'''"
    - '"""$"""'

UnexpectedToken:
  problemMessage: "Unexpected token '#lexeme'."
  analyzerCode: UNEXPECTED_TOKEN
  script:
    - "import 'b.dart' d as b;"

UnexpectedTokens:
  problemMessage: "Unexpected tokens."
  analyzerCode: ParserErrorCode.UNEXPECTED_TOKENS
  index: 123
  script: "enum E w Foo { v; }"

LiteralWithClassAndNew:
  problemMessage: "A #string literal can't be prefixed by 'new #lexeme'."
  correctionMessage: "Try removing 'new' and '#lexeme'"
  analyzerCode: ParserErrorCode.LITERAL_WITH_CLASS_AND_NEW
  index: 115
  script:
    - "var x = new Map{};"
    - "var x = new Set{};"
    - "var x = new List[];"
    - "var x = new Map{1: 2};"
    - "var x = new Set{1};"
    - "var x = new List[1];"

LiteralWithClass:
  problemMessage: "A #string literal can't be prefixed by '#lexeme'."
  correctionMessage: "Try removing '#lexeme'"
  analyzerCode: ParserErrorCode.LITERAL_WITH_CLASS
  index: 116
  script:
    - "var x = Map{};"
    - "var x = Set{};"
    - "var x = List<String>[];"
    - "var x = Map{1: 2};"
    - "var x = Set{1};"
    - "var x = List<int>[1];"
    - "var x = const Map{};"
    - "var x = const Set{};"
    - "var x = const List[];"
    - "var x = const Map{1: 2};"
    - "var x = const Set{1};"
    - "var x = const List[1];"

LiteralWithNew:
  problemMessage: "A literal can't be prefixed by 'new'."
  correctionMessage: "Try removing 'new'"
  analyzerCode: ParserErrorCode.LITERAL_WITH_NEW
  index: 117
  script:
    - "var x = new <String, String>{};"
    - "var x = new <String>{};"
    - "var x = new {};"
    - "var x = new [];"
    - "var x = new <String, String>{'a': 'b'};"
    - "var x = new <String>{'a'};"
    - "var x = new {'a': 'b'};"
    - "var x = new {'a'};"
    - "var x = new ['a'];"

UnmatchedToken:
  problemMessage: "Can't find '#string' to match '#lexeme'."
  analyzerCode: EXPECTED_TOKEN
  script:
    - "main("
    - "main(){"
    - "main(){[}"

UnsupportedOperator:
  problemMessage: "The '#lexeme' operator is not supported."
  analyzerCode: UNSUPPORTED_OPERATOR
  script:
    - "class C { void operator ===(x) {} }"
    - "class C { void operator !==(x) {} }"

UnsupportedPrefixPlus:
  problemMessage: "'+' is not a prefix operator."
  correctionMessage: "Try removing '+'."
  analyzerCode: MISSING_IDENTIFIER
  expression: "+2" # No longer a valid way to write '2'

UnterminatedComment:
  problemMessage: "Comment starting with '/*' must end with '*/'."
  analyzerCode: UNTERMINATED_MULTI_LINE_COMMENT
  script:
    main() {
    }
    /*

UnterminatedString:
  problemMessage: "String starting with #string must end with #string2."
  analyzerCode: UNTERMINATED_STRING_LITERAL
  script:
    - >
      main() {
        return '
      ;
      }
    - >
      main() {
        return \"
      ;
      }
    - >
      main() {
        return r'
      ;
      }
    - >
      main() {
        return r\"
      ;
      }
    - >
      main() => '''
    - >
      main() => \"\"\"
    - >
      main() => r'''
    - >
      main() => r\"\"\"

UnterminatedToken:
  # This is a fall-back message that shouldn't happen.
  problemMessage: "Incomplete token."

# Note: avoid using this template, it should only be used for debugging and
# prototyping, see [diagnostics.md](
# lib/src/fasta/diagnostics.md#avoid-composing-messages-programmatically).
Unspecified:
  problemMessage: "#string"

StrongModeNNBDButOptOut:
  problemMessage: "Library doesn't support null safety."

StrongModeNNBDPackageOptOut:
  problemMessage:  |
    The following dependencies don't support null safety:

    #names

    For solutions, see https://dart.dev/go/unsound-null-safety

WeakWithStrongDillLibrary:
  problemMessage: "Loaded library is compiled with sound null safety and cannot be used in compilation for unsound null safety."

StrongWithWeakDillLibrary:
  problemMessage: "Loaded library is compiled with unsound null safety and cannot be used in compilation for sound null safety."

AgnosticWithStrongDillLibrary:
  problemMessage: "Loaded library is compiled with sound null safety and cannot be used in compilation for agnostic null safety."

AgnosticWithWeakDillLibrary:
  problemMessage: "Loaded library is compiled with unsound null safety and cannot be used in compilation for agnostic null safety."

InvalidNnbdDillLibrary:
  problemMessage: "Trying to use library with invalid null safety."

AbstractNotSync:
  problemMessage: "Abstract methods can't use 'async', 'async*', or 'sync*'."
  analyzerCode: NON_SYNC_ABSTRACT_METHOD

AwaitAsIdentifier:
  problemMessage: "'await' can't be used as an identifier in 'async', 'async*', or 'sync*' methods."
  analyzerCode: ASYNC_KEYWORD_USED_AS_IDENTIFIER

AwaitNotAsync:
  problemMessage: "'await' can only be used in 'async' or 'async*' methods."
  analyzerCode: AWAIT_IN_WRONG_CONTEXT

BuiltInIdentifierAsType:
  problemMessage: "The built-in identifier '#lexeme' can't be used as a type."
  analyzerCode: BUILT_IN_IDENTIFIER_AS_TYPE

BuiltInIdentifierInDeclaration:
  problemMessage: "Can't use '#lexeme' as a name here."
  analyzerCode: BUILT_IN_IDENTIFIER_IN_DECLARATION

AwaitForNotAsync:
  problemMessage: "The asynchronous for-in can only be used in functions marked with 'async' or 'async*'."
  correctionMessage: "Try marking the function body with either 'async' or 'async*', or removing the 'await' before the for loop."
  analyzerCode: ASYNC_FOR_IN_WRONG_CONTEXT
  script: >
    main(o) sync* {
      await for (var e in o) {}
    }

ConstructorNotSync:
  problemMessage: "Constructor bodies can't use 'async', 'async*', or 'sync*'."
  analyzerCode: NON_SYNC_CONSTRUCTOR

FactoryNotSync:
  problemMessage: "Factory bodies can't use 'async', 'async*', or 'sync*'."
  analyzerCode: NON_SYNC_FACTORY

GeneratorReturnsValue:
  problemMessage: "'sync*' and 'async*' can't return a value."
  analyzerCode: RETURN_IN_GENERATOR

InvalidInlineFunctionType:
  problemMessage: "Inline function types cannot be used for parameters in a generic function type."
  correctionMessage: "Try changing the inline function type (as in 'int f()') to a prefixed function type using the `Function` keyword (as in 'int Function() f')."
  analyzerCode: INVALID_INLINE_FUNCTION_TYPE
  declaration: "typedef F = Function(int f(String x));"

SetterNotSync:
  problemMessage: "Setters can't use 'async', 'async*', or 'sync*'."
  analyzerCode: INVALID_MODIFIER_ON_SETTER

YieldAsIdentifier:
  problemMessage: "'yield' can't be used as an identifier in 'async', 'async*', or 'sync*' methods."
  analyzerCode: ASYNC_KEYWORD_USED_AS_IDENTIFIER

YieldNotGenerator:
  problemMessage: "'yield' can only be used in 'sync*' or 'async*' methods."
  analyzerCode: YIELD_IN_NON_GENERATOR

OnlyTry:
  index: 20
  problemMessage: "A try block must be followed by an 'on', 'catch', or 'finally' clause."
  correctionMessage: "Try adding either a catch or finally clause, or remove the try statement."
  analyzerCode: ParserErrorCode.MISSING_CATCH_OR_FINALLY
  statement: "try {}"

TypeAfterVar:
  index: 89
  problemMessage: "Variables can't be declared using both 'var' and a type name."
  correctionMessage: "Try removing 'var.'"
  analyzerCode: ParserErrorCode.VAR_AND_TYPE

AssertExtraneousArgument:
  problemMessage: "`assert` can't have more than two arguments."

PositionalAfterNamedArgument:
  problemMessage: "Place positional arguments before named arguments."
  correctionMessage: "Try moving the positional argument before the named arguments, or add a name to the argument."
  analyzerCode: POSITIONAL_AFTER_NAMED_ARGUMENT

ExpectedNamedArgument:
  problemMessage: "Expected named argument."
  analyzerCode: EXTRA_POSITIONAL_ARGUMENTS

AssertAsExpression:
  problemMessage: "`assert` can't be used as an expression."

FunctionTypeDefaultValue:
  problemMessage: "Can't have a default value in a function type."
  analyzerCode: DEFAULT_VALUE_IN_FUNCTION_TYPE

PrivateNamedParameter:
  problemMessage: "An optional named parameter can't start with '_'."
  analyzerCode: PRIVATE_OPTIONAL_PARAMETER

NoFormals:
  problemMessage: "A function should have formal parameters."
  correctionMessage: "Try adding '()' after '#lexeme', or add 'get' before '#lexeme' to declare a getter."
  analyzerCode: MISSING_FUNCTION_PARAMETERS

GetterWithFormals:
  problemMessage: "A getter can't have formal parameters."
  correctionMessage: "Try removing '(...)'."
  analyzerCode: GETTER_WITH_PARAMETERS

SetterWithWrongNumberOfFormals:
  problemMessage: "A setter should have exactly one formal parameter."
  analyzerCode: WRONG_NUMBER_OF_PARAMETERS_FOR_SETTER

CatchSyntax:
  index: 84
  problemMessage: "'catch' must be followed by '(identifier)' or '(identifier, identifier)'."
  correctionMessage: "No types are needed, the first is given by 'on', the second is always 'StackTrace'."
  analyzerCode: ParserErrorCode.CATCH_SYNTAX
  statement:
    - "try {} catch {}"
    - "try {} catch () {}"
    - "try {} catch (e,) {}"

CatchSyntaxExtraParameters:
  index: 83
  problemMessage: "'catch' must be followed by '(identifier)' or '(identifier, identifier)'."
  correctionMessage: "No types are needed, the first is given by 'on', the second is always 'StackTrace'."
  analyzerCode: ParserErrorCode.CATCH_SYNTAX_EXTRA_PARAMETERS
  statement:
    - "try {} catch (e, s, x) {}"

SuperNullAware:
  index: 18
  problemMessage: "The operator '?.' cannot be used with 'super' because 'super' cannot be null."
  correctionMessage: "Try replacing '?.' with '.'"
  analyzerCode: ParserErrorCode.INVALID_OPERATOR_QUESTIONMARK_PERIOD_FOR_SUPER

NullAwareCascadeOutOfOrder:
  index: 96
  problemMessage: "The '?..' cascade operator must be first in the cascade sequence."
  correctionMessage: "Try moving the '?..' operator to be the first cascade operator in the sequence."
  analyzerCode: ParserErrorCode.NULL_AWARE_CASCADE_OUT_OF_ORDER

ConstFieldWithoutInitializer:
  problemMessage: "The const variable '#name' must be initialized."
  correctionMessage: "Try adding an initializer ('= expression') to the declaration."
  analyzerCode: CONST_NOT_INITIALIZED

FinalFieldWithoutInitializer:
  problemMessage: "The final variable '#name' must be initialized."
  correctionMessage: "Try adding an initializer ('= expression') to the declaration."
  analyzerCode: FINAL_NOT_INITIALIZED

MetadataTypeArguments:
  index: 91
  problemMessage: "An annotation can't use type arguments."
  analyzerCode: ParserErrorCode.ANNOTATION_WITH_TYPE_ARGUMENTS

MetadataTypeArgumentsUninstantiated:
  index: 114
  problemMessage: "An annotation with type arguments must be followed by an argument list."
  analyzerCode: ParserErrorCode.ANNOTATION_WITH_TYPE_ARGUMENTS_UNINSTANTIATED
  script:
    - "@deprecated<int> class C {}"

MetadataSpaceBeforeParenthesis:
  index: 134
  problemMessage: "Annotations can't have spaces or comments before the parenthesis."
  correctionMessage: Remove any spaces or comments before the parenthesis.
  analyzerCode: ParserErrorCode.ANNOTATION_SPACE_BEFORE_PARENTHESIS
  script:
    - >-
      class Foo<T> {
        const Foo();
      }
      @Foo<int> () var bar;
    - >-
      class Foo {
        const Foo();
      }
      @Foo () class Bar {}

ConstructorNotFound:
  problemMessage: "Couldn't find constructor '#name'."
  analyzerCode: CONSTRUCTOR_NOT_FOUND

ConstructorWithReturnType:
  index: 55
  problemMessage: "Constructors can't have a return type."
  correctionMessage: "Try removing the return type."
  analyzerCode: ParserErrorCode.CONSTRUCTOR_WITH_RETURN_TYPE
  script:
    - "class C { int C() {} }"
    - "class C { void C.m() {} }"

ConstructorWithTypeParameters:
  index: 99
  problemMessage: "Constructors can't have type parameters."
  analyzerCode: ParserErrorCode.TYPE_PARAMETER_ON_CONSTRUCTOR
  correctionMessage: "Try removing the type parameters."
  script:
    - >-
      class C { C<T>() {} }
    - >-
      class C { C.foo<T>() {} }
    - >-
      class C {
        factory C<T>() => new C.internal();
        C.internal();
      }
    - >-
      class C {
        factory C.foo<T>() => new C.internal();
        C.internal();
      }

ConstructorWithTypeArguments:
  problemMessage: "A constructor invocation can't have type arguments after the constructor name."
  correctionMessage: "Try removing the type arguments or placing them after the class name."
  analyzerCode: ParserErrorCode.CONSTRUCTOR_WITH_TYPE_ARGUMENTS
  index: 118
  script:
    - "class C<X> { C.foo(); } bar() { new C.foo<int>(); }"
    - "class C<X> { C.foo(); } bar() { C.foo<int>(); }"

ConstructorWithWrongName:
  problemMessage: "The name of a constructor must match the name of the enclosing class."
  analyzerCode: ParserErrorCode.INVALID_CONSTRUCTOR_NAME
  index: 102
  script:
    - >-
      class A { B.foo() {} }
    - >-
      class A {
        factory B() => new A.internal();
        A.internal();
      }
    - >-
      class A {
        factory B.foo() => new A.internal();
        A.internal();
      }

ConstructorWithWrongNameContext:
  problemMessage: "The name of the enclosing class is '#name'."
  severity: CONTEXT

ConstructorCyclic:
  problemMessage: "Redirecting constructors can't be cyclic."
  correctionMessage: "Try to have all constructors eventually redirect to a non-redirecting constructor."
  analyzerCode: RECURSIVE_CONSTRUCTOR_REDIRECT
  script:
    - "class C { C.foo() : this.bar(); C.bar() : this.foo(); }"

FieldInitializerOutsideConstructor:
  index: 79
  problemMessage: "Field formal parameters can only be used in a constructor."
  correctionMessage: "Try removing 'this.'."
  analyzerCode: ParserErrorCode.FIELD_INITIALIZER_OUTSIDE_CONSTRUCTOR
  hasPublishedDocs: true
  script:
    - "class C { void m(this.x); }"

SuperParameterInitializerOutsideConstructor:
  problemMessage: "Super-initializer formal parameters can only be used in generative constructors."
  correctionMessage: "Try removing 'super.'."

RedirectionTargetNotFound:
  problemMessage: "Redirection constructor target not found: '#name'"
  analyzerCode: REDIRECT_TO_MISSING_CONSTRUCTOR

CyclicTypedef:
  problemMessage: "The typedef '#name' has a reference to itself."
  analyzerCode: TYPE_ALIAS_CANNOT_REFERENCE_ITSELF

TypeNotFound:
  problemMessage: "Type '#name' not found."
  analyzerCode: UNDEFINED_CLASS

NameNotFound:
  problemMessage: "Undefined name '#name'."
  analyzerCode: UNDEFINED_NAME

MemberNotFound:
  problemMessage: "Member not found: '#name'."
  analyzerCode: UNDEFINED_GETTER

GetterNotFound:
  problemMessage: "Getter not found: '#name'."
  analyzerCode: UNDEFINED_GETTER

SetterNotFound:
  problemMessage: "Setter not found: '#name'."
  analyzerCode: UNDEFINED_SETTER

MethodNotFound:
  problemMessage: "Method not found: '#name'."
  analyzerCode: UNDEFINED_METHOD

CandidateFound:
  problemMessage: "Found this candidate, but the arguments don't match."
  severity: CONTEXT

CandidateFoundIsDefaultConstructor:
  problemMessage: "The class '#name' has a constructor that takes no arguments."
  severity: CONTEXT

MissingArgumentList:
  problemMessage: "Constructor invocations must have an argument list."

TooFewArguments:
  problemMessage: "Too few positional arguments: #count required, #count2 given."
  analyzerCode: NOT_ENOUGH_REQUIRED_ARGUMENTS

TooManyArguments:
  problemMessage: "Too many positional arguments: #count allowed, but #count2 found."
  correctionMessage: "Try removing the extra positional arguments."
  analyzerCode: EXTRA_POSITIONAL_ARGUMENTS

NoSuchNamedParameter:
  problemMessage: "No named parameter with the name '#name'."
  analyzerCode: UNDEFINED_NAMED_PARAMETER

AbstractClassInstantiation:
  problemMessage: "The class '#name' is abstract and can't be instantiated."
  analyzerCode: NEW_WITH_ABSTRACT_CLASS

EnumInstantiation:
  problemMessage: "Enums can't be instantiated."
  analyzerCode: INSTANTIATE_ENUM

AbstractRedirectedClassInstantiation:
  problemMessage: "Factory redirects to class '#name', which is abstract and can't be instantiated."
  analyzerCode: FACTORY_REDIRECTS_TO_ABSTRACT_CLASS

MissingImplementationNotAbstract:
  problemMessage: |
    The non-abstract class '#name' is missing implementations for these members:
    #names
  correctionMessage: |
    Try to either
     - provide an implementation,
     - inherit an implementation from a superclass or mixin,
     - mark the class as abstract, or
     - provide a 'noSuchMethod' implementation.
  analyzerCode: CONCRETE_CLASS_WITH_ABSTRACT_MEMBER
  script:
    - "class C {foo();}"

MissingImplementationCause:
  problemMessage: "'#name' is defined here."
  severity: CONTEXT

InterfaceCheck:
  problemMessage: "The implementation of '#name' in the non-abstract class '#name2' does not conform to its interface."

NamedMixinOverride:
  problemMessage: "The mixin application class '#name' introduces an erroneous override of '#name2'."

ImplicitMixinOverride:
  problemMessage: "Applying the mixin '#name' to '#name2' introduces an erroneous override of '#name3'."

ListLiteralTooManyTypeArguments:
  problemMessage: "List literal requires exactly one type argument."
  analyzerCode: EXPECTED_ONE_LIST_TYPE_ARGUMENTS

SetLiteralTooManyTypeArguments:
  problemMessage: "A set literal requires exactly one type argument."

MapLiteralTypeArgumentMismatch:
  problemMessage: "A map literal requires exactly two type arguments."
  analyzerCode: EXPECTED_TWO_MAP_TYPE_ARGUMENTS

SetOrMapLiteralTooManyTypeArguments:
  problemMessage: "A set or map literal requires exactly one or two type arguments, respectively."

LoadLibraryTakesNoArguments:
  problemMessage: "'loadLibrary' takes no arguments."
  analyzerCode: LOAD_LIBRARY_TAKES_NO_ARGUMENTS

TypeArgumentMismatch:
  problemMessage: "Expected #count type arguments."
  analyzerCode: WRONG_NUMBER_OF_TYPE_ARGUMENTS

NotAType:
  problemMessage: "'#name' isn't a type."
  analyzerCode: NOT_A_TYPE

NotATypeContext:
  problemMessage: "This isn't a type."
  severity: CONTEXT

NotAPrefixInTypeAnnotation:
  problemMessage: "'#name.#name2' can't be used as a type because '#name' doesn't refer to an import prefix."
  analyzerCode: NOT_A_TYPE
  declaration:
    - |
        class C<T> {
          T.String method() {}
        }
    - |
        class C<T> {
          T.String field;
        }

UnresolvedPrefixInTypeAnnotation:
  problemMessage: "'#name.#name2' can't be used as a type because '#name' isn't defined."
  analyzerCode: NOT_A_TYPE
  statement: "T.String x;"

FastaUsageShort:
  problemMessage: |
    Frequently used options:

      -o <file> Generate the output into <file>.
      -h        Display this message (add -v for information about all options).

FastaUsageLong:
  # TODO(ahe): Consider if the reference to platform.dill needs to change below?
  problemMessage: |
    Supported options:

      -o <file>, --output=<file>
        Generate the output into <file>.

      -h, /h, /?, --help
        Display this message (add -v for information about all options).

      -v, --verbose
        Display verbose information.

      -Dname
      -Dname=value
        Define an environment variable in the compile-time environment.

      --no-defines
        Ignore all -D options and leave environment constants unevaluated.

      --
        Stop option parsing, the rest of the command line is assumed to be
        file names or arguments to the Dart program.

      --packages=<file>
        Use package resolution configuration <file>, which should contain a mapping
        of package names to paths.

      --platform=<file>
        Read the SDK platform from <file>, which should be in Dill/Kernel IR format
        and contain the Dart SDK.

      --target=dart2js|dart2js_server|dart2wasm|dart_runner|dartdevc|flutter|flutter_runner|none|vm
        Specify the target configuration.

      --enable-asserts
        Check asserts in initializers during constant evaluation.

      --verify
        Check that the generated output is free of various problems. This is mostly
        useful for developers of this compiler or Kernel transformations.

      --dump-ir
        Print compiled libraries in Kernel source notation.

      --omit-platform
        Exclude the platform from the serialized dill file.

      --exclude-source
        Do not include source code in the dill file.

      --compile-sdk=<sdk>
        Compile the SDK from scratch instead of reading it from a .dill file
        (see --platform).

      --sdk=<sdk>
        Location of the SDK sources for use when compiling additional platform
        libraries.

      --single-root-scheme=String
      --single-root-base=<dir>
        Specify a custom URI scheme and a location on disk where such URIs are
        mapped to.

        When specified, the compiler can be invoked with inputs using the custom
        URI scheme. The compiler can ignore the exact location of files on disk
        and as a result to produce output that is independent of the absolute
        location of files on disk. This is mostly useful for integrating with
        build systems.

      --fatal=errors
      --fatal=warnings
        Makes messages of the given kinds fatal, that is, immediately stop the
        compiler with a non-zero exit-code. In --verbose mode, also display an
        internal stack trace from the compiler. Multiple kinds can be separated by
        commas, for example, --fatal=errors,warnings.

      --fatal-skip=<number>
      --fatal-skip=trace
        Skip this many messages that would otherwise be fatal before aborting the
        compilation. Default is 0, which stops at the first message. Specify
        'trace' to print a stack trace for every message without stopping.

      --enable-experiment=<flag>
        Enable or disable an experimental flag, used to guard features currently
        in development. Prefix an experiment name with 'no-' to disable it.
        Multiple experiments can be separated by commas.

FastaCLIArgumentRequired:
  problemMessage: "Expected value after '#name'."

NamedFunctionExpression:
  problemMessage: "A function expression can't have a name."
  analyzerCode: NAMED_FUNCTION_EXPRESSION

NativeClauseShouldBeAnnotation:
  index: 23
  problemMessage: "Native clause in this form is deprecated."
  correctionMessage: "Try removing this native clause and adding @native() or @native('native-name') before the declaration."
  analyzerCode: ParserErrorCode.NATIVE_CLAUSE_SHOULD_BE_ANNOTATION

ReturnTypeFunctionExpression:
  problemMessage: "A function expression can't have a return type."

InternalProblemUnhandled:
  problemMessage: "Unhandled #string in #string2."
  severity: INTERNAL_PROBLEM

InternalProblemUnimplemented:
  problemMessage: "Unimplemented #string."
  severity: INTERNAL_PROBLEM

InternalProblemUnexpected:
  problemMessage: "Expected '#string', but got '#string2'."
  severity: INTERNAL_PROBLEM

InternalProblemUnsupported:
  problemMessage: "Unsupported operation: '#name'."
  severity: INTERNAL_PROBLEM

InternalProblemNotFound:
  problemMessage: "Couldn't find '#name'."
  severity: INTERNAL_PROBLEM

InternalProblemNotFoundIn:
  problemMessage: "Couldn't find '#name' in '#name2'."
  severity: INTERNAL_PROBLEM

InternalProblemPrivateConstructorAccess:
  problemMessage: "Can't access private constructor '#name'."
  severity: INTERNAL_PROBLEM

InternalProblemConstructorNotFound:
  problemMessage: "No constructor named '#name' in '#uri'."
  severity: INTERNAL_PROBLEM

InternalProblemExtendingUnmodifiableScope:
  problemMessage: "Can't extend an unmodifiable scope."
  severity: INTERNAL_PROBLEM

InternalProblemPreviousTokenNotFound:
  problemMessage: "Couldn't find previous token."
  severity: INTERNAL_PROBLEM

InternalProblemStackNotEmpty:
  problemMessage: "#name.stack isn't empty:\n  #string"
  severity: INTERNAL_PROBLEM

InternalProblemAlreadyInitialized:
  problemMessage: "Attempt to set initializer on field without initializer."
  severity: INTERNAL_PROBLEM

InternalProblemBodyOnAbstractMethod:
  problemMessage: "Attempting to set body on abstract method."
  severity: INTERNAL_PROBLEM

InternalProblemMissingContext:
  problemMessage: "Compiler cannot run without a compiler context."
  correctionMessage: "Are calls to the compiler wrapped in CompilerContext.runInContext?"
  severity: INTERNAL_PROBLEM

InternalProblemProvidedBothCompileSdkAndSdkSummary:
  problemMessage: "The compileSdk and sdkSummary options are mutually exclusive"
  severity: INTERNAL_PROBLEM

InternalProblemUriMissingScheme:
  problemMessage: "The URI '#uri' has no scheme."
  severity: INTERNAL_PROBLEM

InternalProblemContextSeverity:
  problemMessage: "Non-context message has context severity: #string"
  severity: INTERNAL_PROBLEM

InternalProblemVerificationError:
  problemMessage: |
    Verification of the generated program failed:
    #string
  severity: INTERNAL_PROBLEM

VerificationErrorOriginContext:
  problemMessage: "The node most likely is taken from here by a transformer."
  severity: CONTEXT

InternalProblemDebugAbort:
  problemMessage: "Compilation aborted due to fatal '#name' at:\n#string"
  severity: INTERNAL_PROBLEM

InternalProblemLabelUsageInVariablesDeclaration:
  problemMessage: "Unexpected usage of label inside declaration of variables."
  severity: INTERNAL_PROBLEM

InternalProblemUnfinishedTypeVariable:
  problemMessage: "Unfinished type variable '#name' found in non-source library '#uri'."
  severity: INTERNAL_PROBLEM

InternalProblemUnsupportedNullability:
  problemMessage: "Unsupported nullability value '#string' on type '#type'."
  severity: INTERNAL_PROBLEM

InternalProblemOmittedTypeNameInConstructorReference:
  problemMessage: "Unsupported omission of the type name in a constructor reference outside of an enum element declaration."
  severity: INTERNAL_PROBLEM

IncrementalCompilerIllegalParameter:
  problemMessage: "Illegal parameter name '#string' found during expression compilation."

IncrementalCompilerIllegalTypeParameter:
  problemMessage: "Illegal type parameter name '#string' found during expression compilation."

DebugTrace:
  problemMessage: "Fatal '#name' at:\n#string"
  severity: IGNORED

MissingPrefixInDeferredImport:
  index: 30
  problemMessage: "Deferred imports should have a prefix."
  correctionMessage: "Try adding a prefix to the import by adding an 'as' clause."
  analyzerCode: ParserErrorCode.MISSING_PREFIX_IN_DEFERRED_IMPORT

DeferredAfterPrefix:
  index: 68
  problemMessage: "The deferred keyword should come immediately before the prefix ('as' clause)."
  correctionMessage: "Try moving the deferred keyword before the prefix."
  analyzerCode: ParserErrorCode.DEFERRED_AFTER_PREFIX

DuplicateDeferred:
  index: 71
  problemMessage: "An import directive can only have one 'deferred' keyword."
  correctionMessage: "Try removing all but one 'deferred' keyword."
  analyzerCode: ParserErrorCode.DUPLICATE_DEFERRED

DeferredTypeAnnotation:
  problemMessage: "The type '#type' is deferred loaded via prefix '#name' and can't be used as a type annotation."
  correctionMessage: "Try removing 'deferred' from the import of '#name' or use a supertype of '#type' that isn't deferred."
  analyzerCode: TYPE_ANNOTATION_DEFERRED_CLASS

DuplicatePrefix:
  index: 73
  problemMessage: "An import directive can only have one prefix ('as' clause)."
  correctionMessage: "Try removing all but one prefix."
  analyzerCode: ParserErrorCode.DUPLICATE_PREFIX

PrefixAfterCombinator:
  index: 6
  problemMessage: "The prefix ('as' clause) should come before any show/hide combinators."
  correctionMessage: "Try moving the prefix before the combinators."
  analyzerCode: ParserErrorCode.PREFIX_AFTER_COMBINATOR

DuplicatedExport:
  problemMessage: "'#name' is exported from both '#uri' and '#uri2'."
  analyzerCode: AMBIGUOUS_EXPORT
  script:
    lib1.dart: "class A {}"
    lib2.dart: "class A {}"
    main.dart: "export 'lib1.dart'; export 'lib2.dart';"

DuplicatedExportInType:
  problemMessage: "'#name' is exported from both '#uri' and '#uri2'."

DuplicatedImportInType:
  problemMessage: "'#name' is imported from both '#uri' and '#uri2'."
  analyzerCode: AMBIGUOUS_IMPORT
  script:
    lib1.dart: "class A {}"
    lib2.dart: "class A {}"
    main.dart: "import 'lib1.dart'; import 'lib2.dart'; A a;"

CyclicClassHierarchy:
  problemMessage: "'#name' is a supertype of itself."
  analyzerCode: RECURSIVE_INTERFACE_INHERITANCE
  script:
    - |
      class A extends B {}
      class B extends A {}
    - |
      class A implements B {}
      class B implements A {}
    - "class C = Object with C;"
    - "class C extends C {}"
    - "class C implements C {}"

ExtendingEnum:
  problemMessage: "'#name' is an enum and can't be extended or implemented."
  analyzerCode: EXTENDS_ENUM

ExtendingRestricted:
  problemMessage: "'#name' is restricted and can't be extended or implemented."
  analyzerCode: EXTENDS_DISALLOWED_CLASS

NoUnnamedConstructorInObject:
  problemMessage: "'Object' has no unnamed constructor."

IllegalAsyncGeneratorReturnType:
  problemMessage: "Functions marked 'async*' must have a return type assignable to 'Stream'."
  analyzerCode: ILLEGAL_ASYNC_GENERATOR_RETURN_TYPE
  script:
    - >-
      int g() async* {
        yield 0;
      }

IllegalAsyncGeneratorVoidReturnType:
  problemMessage: "Functions marked 'async*' can't have return type 'void'."
  script:
    - >-
      void g() async* {
      }

IllegalAsyncReturnType:
  problemMessage: "Functions marked 'async' must have a return type assignable to 'Future'."
  analyzerCode: ILLEGAL_ASYNC_RETURN_TYPE
  script:
    - >-
      int f() async {
        return 0;
      }

IllegalSyncGeneratorReturnType:
  problemMessage: "Functions marked 'sync*' must have a return type assignable to 'Iterable'."
  analyzerCode: ILLEGAL_SYNC_GENERATOR_RETURN_TYPE
  script:
    - >-
      int g() sync* {
        yield 0;
      }

IllegalSyncGeneratorVoidReturnType:
  problemMessage: "Functions marked 'sync*' can't have return type 'void'."
  script:
    - >-
      void g() sync* {
      }

IllegalMixinDueToConstructors:
  # a class with a constructor is used as a mixin
  problemMessage: "Can't use '#name' as a mixin because it has constructors."
  analyzerCode: MIXIN_DECLARES_CONSTRUCTOR # CompileTimeErrorCode

MixinDeclaresConstructor:
  # a mixin declaration contains a constructor declaration
  index: 95
  problemMessage: "Mixins can't declare constructors."
  analyzerCode: ParserErrorCode.MIXIN_DECLARES_CONSTRUCTOR

IllegalMixinDueToConstructorsCause:
  problemMessage: "This constructor prevents using '#name' as a mixin."
  severity: CONTEXT

ExtensionDeclaresAbstractMember:
  index: 94
  problemMessage: "Extensions can't declare abstract members."
  correctionMessage: "Try providing an implementation for the member."
  analyzerCode: ParserErrorCode.EXTENSION_DECLARES_ABSTRACT_MEMBER
  comment: No parameters.
  documentation: |-
    #### Description

    The analyzer produces this diagnostic when an abstract declaration is
    declared in an extension. Extensions can declare only concrete members.

    #### Example

    The following code produces this diagnostic because the method `a` doesn't
    have a body:

    ```dart
    extension E on String {
      int [!a!]();
    }
    ```

    #### Common fixes

    Either provide an implementation for the member or remove it.
  hasPublishedDocs: true

ExtensionDeclaresConstructor:
  index: 92
  problemMessage: "Extensions can't declare constructors."
  correctionMessage: "Try removing the constructor declaration."
  analyzerCode: ParserErrorCode.EXTENSION_DECLARES_CONSTRUCTOR
  comment: No parameters.
  documentation: |-
    #### Description

    The analyzer produces this diagnostic when a constructor declaration is
    found in an extension. It isn't valid to define a constructor because
    extensions aren't classes, and it isn't possible to create an instance of
    an extension.

    #### Example

    The following code produces this diagnostic because there is a constructor
    declaration in `E`:

    ```dart
    extension E on String {
      [!E!]() : super();
    }
    ```

    #### Common fixes

    Remove the constructor or replace it with a static method.
  hasPublishedDocs: true

ExtensionDeclaresInstanceField:
  index: 93
  problemMessage: "Extensions can't declare instance fields"
  correctionMessage: "Try removing the field declaration or making it a static field"
  analyzerCode: ParserErrorCode.EXTENSION_DECLARES_INSTANCE_FIELD
  comment: No parameters.
  documentation: |-
    #### Description

    The analyzer produces this diagnostic when an instance field declaration is
    found in an extension. It isn't valid to define an instance field because
    extensions can only add behavior, not state.

    #### Example

    The following code produces this diagnostic because `s` is an instance
    field:

    ```dart
    %language=2.9
    extension E on String {
      String [!s!];
    }
    ```

    #### Common fixes

    Remove the field, make it a static field, or convert it to be a getter,
    setter, or method.
  hasPublishedDocs: true

ConflictsWithConstructor:
  problemMessage: "Conflicts with constructor '#name'."
  analyzerCode: CONFLICTS_WITH_CONSTRUCTOR

ConflictsWithFactory:
  problemMessage: "Conflicts with factory '#name'."

ConflictsWithMember:
  problemMessage: "Conflicts with member '#name'."
  analyzerCode: CONFLICTS_WITH_MEMBER

ConflictsWithImplicitSetter:
  problemMessage: "Conflicts with the implicit setter of the field '#name'."
  analyzerCode: CONFLICTS_WITH_MEMBER

ConflictsWithSetter:
  problemMessage: "Conflicts with setter '#name'."
  analyzerCode: CONFLICTS_WITH_MEMBER

ConflictsWithTypeVariable:
  problemMessage: "Conflicts with type variable '#name'."
  analyzerCode: CONFLICTING_TYPE_VARIABLE_AND_MEMBER

ConflictsWithTypeVariableCause:
  problemMessage: "This is the type variable."
  severity: CONTEXT

ExtensionMemberConflictsWithObjectMember:
  problemMessage: "This extension member conflicts with Object member '#name'."
  script:
    extension Extension on String {
      int get noSuchMethod => 42;
    }

DeclaredMemberConflictsWithInheritedMember:
  problemMessage: "Can't declare a member that conflicts with an inherited one."
  analyzerCode: DECLARED_MEMBER_CONFLICTS_WITH_INHERITED
  script:
    - >-
      class A {
        var foo;
      }
      class B extends A {
        foo() {}
      }
    - >-
      abstract class A {
        get foo;
      }
      class B implements A {
        foo() {}
      }
    - >-
      class A {
        foo() {}
      }
      class B extends A {
        var foo;
      }
    - >-
      abstract class A {
        foo();
      }
      class B implements A {
        var foo;
      }

DeclaredMemberConflictsWithInheritedMemberCause:
  problemMessage: "This is the inherited member."
  severity: CONTEXT

DeclaredMemberConflictsWithOverriddenMembersCause:
  problemMessage: "This is one of the overridden members."
  severity: CONTEXT

InheritedMembersConflict:
  problemMessage: "Can't inherit members that conflict with each other."
  analyzerCode: CONFLICTS_WITH_INHERITED_MEMBER
  script:
    - >-
      class A {
        foo() {}
      }
      abstract class B {
        get foo;
      }
      abstract class C extends A implements B {}
    - >-
      class A {
        var foo;
      }
      abstract class B {
        foo();
      }
      abstract class C extends A implements B {}
    - >-
      class A {
        get foo => 0;
      }
      abstract class B {
        foo();
      }
      abstract class C extends A implements B {}

InheritedMembersConflictCause1:
  problemMessage: "This is one inherited member."
  severity: CONTEXT

InheritedMembersConflictCause2:
  problemMessage: "This is the other inherited member."
  severity: CONTEXT

IllegalMixin:
  problemMessage: "The type '#name' can't be mixed in."
  analyzerCode: ILLEGAL_MIXIN

OverrideTypeVariablesMismatch:
  problemMessage: "Declared type variables of '#name' doesn't match those on overridden method '#name2'."
  analyzerCode: INVALID_METHOD_OVERRIDE_TYPE_PARAMETERS

OverrideTypeVariablesBoundMismatch:
  problemMessage: "Declared bound '#type' of type variable '#name' of '#name2' doesn't match the bound '#type2' on overridden method '#name3'."

OverriddenMethodCause:
  problemMessage: "This is the overridden method ('#name')."
  severity: CONTEXT

OverrideMismatchNamedParameter:
  problemMessage: "The method '#name' doesn't have the named parameter '#name2' of overridden method '#name3'."
  analyzerCode: INVALID_OVERRIDE_NAMED

OverrideFewerNamedArguments:
  problemMessage: "The method '#name' has fewer named arguments than those of overridden method '#name2'."
  analyzerCode: INVALID_OVERRIDE_NAMED

OverrideFewerPositionalArguments:
  problemMessage: "The method '#name' has fewer positional arguments than those of overridden method '#name2'."
  analyzerCode: INVALID_OVERRIDE_POSITIONAL

OverrideMoreRequiredArguments:
  problemMessage: "The method '#name' has more required arguments than those of overridden method '#name2'."
  analyzerCode: INVALID_OVERRIDE_REQUIRED

OverrideTypeMismatchParameter:
  problemMessage: "The parameter '#name' of the method '#name2' has type '#type', which does not match the corresponding type, '#type2', in the overridden method, '#name3'."
  correctionMessage: "Change to a supertype of '#type2', or, for a covariant parameter, a subtype."
  analyzerCode: INVALID_METHOD_OVERRIDE

OverrideTypeMismatchReturnType:
  problemMessage: "The return type of the method '#name' is '#type', which does not match the return type, '#type2', of the overridden method, '#name2'."
  correctionMessage: "Change to a subtype of '#type2'."
  analyzerCode: INVALID_METHOD_OVERRIDE

OverrideTypeMismatchSetter:
  problemMessage: "The field '#name' has type '#type', which does not match the corresponding type, '#type2', in the overridden setter, '#name2'."
  analyzerCode: INVALID_METHOD_OVERRIDE

OverrideMismatchRequiredNamedParameter:
  problemMessage: "The required named parameter '#name' in method '#name2' is not required in overridden method '#name3'."
  configuration: nnbd-strong
  script: |
    abstract class A {
      method({int? a});
    }
    abstract class B implements A {
      method({required int? a});
    }

InvalidGetterSetterType:
  problemMessage: "The type '#type' of the getter '#name' is not a subtype of the type '#type2' of the setter '#name2'."
  configuration: nnbd-strong
  script: |
    abstract class A {
      num get property;
      void set property(int i);
    }

InvalidGetterSetterTypeGetterInherited:
  problemMessage: "The type '#type' of the inherited getter '#name' is not a subtype of the type '#type2' of the setter '#name2'."
  configuration: nnbd-strong
  script: |
    abstract class A {
      num get property;
    }
    abstract class B implements A {
      void set property(int i);
    }

InvalidGetterSetterTypeFieldInherited:
  problemMessage: "The type '#type' of the inherited field '#name' is not a subtype of the type '#type2' of the setter '#name2'."
  configuration: nnbd-strong
  script: |
    abstract class A {
      final num property;
      A(this.property);
    }
    abstract class B implements A {
      void set property(int i);
    }

InvalidGetterSetterTypeSetterInheritedGetter:
  problemMessage: "The type '#type' of the getter '#name' is not a subtype of the type '#type2' of the inherited setter '#name2'."
  configuration: nnbd-strong
  script: |
    abstract class A {
      void set property(int i);
    }
    abstract class B implements A {
      num get property;
    }

InvalidGetterSetterTypeSetterInheritedField:
  problemMessage: "The type '#type' of the field '#name' is not a subtype of the type '#type2' of the inherited setter '#name2'."
  configuration: nnbd-strong
  script: |
    abstract class A {
      void set property(int i);
    }
    abstract class B implements A {
      final num property;
      B(this.property);
    }

InvalidGetterSetterTypeBothInheritedField:
  problemMessage: "The type '#type' of the inherited field '#name' is not a subtype of the type '#type2' of the inherited setter '#name2'."
  configuration: nnbd-strong
  script: |
    abstract class A {
      final num property;
      A(this.property);
    }
    abstract class B {
      void set property(int i);
    }
    abstract class C implements A, B {}

InvalidGetterSetterTypeBothInheritedGetter:
  problemMessage: "The type '#type' of the inherited getter '#name' is not a subtype of the type '#type2' of the inherited setter '#name2'."
  configuration: nnbd-strong
  script: |
    abstract class A {
      num get property;
    }
    abstract class B {
      void set property(int i);
    }
    abstract class C implements A, B {}

InvalidGetterSetterTypeLegacy:
  problemMessage: "The type '#type' of the getter '#name' is not assignable to the type '#type2' of the setter '#name2'."
  script: |
    // @dart=2.9
    abstract class A {
      String get property;
      void set property(int i);
    }

InvalidGetterSetterTypeGetterInheritedLegacy:
  problemMessage: "The type '#type' of the inherited getter '#name' is not assignable to the type '#type2' of the setter '#name2'."
  script: |
    // @dart=2.9
    abstract class A {
      String get property;
    }
    abstract class B implements A {
      void set property(int i);
    }

InvalidGetterSetterTypeFieldInheritedLegacy:
  problemMessage: "The type '#type' of the inherited field '#name' is not assignable to the type '#type2' of the setter '#name2'."
  script: |
    // @dart=2.9
    abstract class A {
      final String property;
      A(this.property);
    }
    abstract class B implements A {
      void set property(int i);
    }

InvalidGetterSetterTypeSetterInheritedGetterLegacy:
  problemMessage: "The type '#type' of the getter '#name' is not assignable to the type '#type2' of the inherited setter '#name2'."
  script: |
    // @dart=2.9
    abstract class A {
      void set property(int i);
    }
    abstract class B implements A {
      String get property;
    }

InvalidGetterSetterTypeSetterInheritedFieldLegacy:
  problemMessage: "The type '#type' of the field '#name' is not assignable to the type '#type2' of the inherited setter '#name2'."
  script: |
    // @dart=2.9
    abstract class A {
      void set property(int i);
    }
    abstract class B implements A {
      final String property;
      B(this.property);
    }

InvalidGetterSetterTypeBothInheritedFieldLegacy:
  problemMessage: "The type '#type' of the inherited field '#name' is not assignable to the type '#type2' of the inherited setter '#name2'."
  script: |
    // @dart=2.9
    abstract class A {
      final String property;
      A(this.property);
    }
    abstract class B {
      void set property(int i);
    }
    abstract class C implements A, B {}

InvalidGetterSetterTypeBothInheritedGetterLegacy:
  problemMessage: "The type '#type' of the inherited getter '#name' is not assignable to the type '#type2' of the inherited setter '#name2'."
  script: |
    // @dart=2.9
    abstract class A {
      String get property;
    }
    abstract class B {
      void set property(int i);
    }
    abstract class C implements A, B {}

InvalidGetterSetterTypeFieldContext:
  problemMessage: "This is the declaration of the field '#name'."
  severity: CONTEXT

InvalidGetterSetterTypeGetterContext:
  problemMessage: "This is the declaration of the getter '#name'."
  severity: CONTEXT

InvalidGetterSetterTypeSetterContext:
  problemMessage: "This is the declaration of the setter '#name'."
  severity: CONTEXT

PartOfSelf:
  problemMessage: "A file can't be a part of itself."
  analyzerCode: PART_OF_NON_PART
  script:
    main.dart: "part 'main.dart';"

TypeVariableDuplicatedName:
  problemMessage: "A type variable can't have the same name as another."
  analyzerCode: DUPLICATE_DEFINITION

TypeVariableDuplicatedNameCause:
  problemMessage: "The other type variable named '#name'."
  severity: CONTEXT

TypeVariableSameNameAsEnclosing:
  problemMessage: "A type variable can't have the same name as its enclosing declaration."
  analyzerCode: CONFLICTING_TYPE_VARIABLE_AND_CLASS

AnnotationOnTypeArgument:
  problemMessage: "Type arguments can't have annotations because they aren't declarations."
  analyzerCode: ParserErrorCode.ANNOTATION_ON_TYPE_ARGUMENT
  index: 111
  script:
    - "class A<E> {} class C { m() => new A<@Object() C>(); }"

AnnotationOnFunctionTypeTypeVariable:
  problemMessage: "A type variable on a function type can't have annotations."
  script: |
     // @dart=2.13
     main() { Function<@Object() T>() x; }

ExpectedEnumBody:
  problemMessage: "Expected a enum body, but got '#lexeme'."
  correctionMessage: "An enum definition must have a body with at least one constant name."
  analyzerCode: MISSING_ENUM_BODY
  script:
    - "enum E"

EnumDeclarationEmpty:
  problemMessage: "An enum declaration can't be empty."
  analyzerCode: EMPTY_ENUM_BODY
  script:
    - "enum E {}"

ExternalClass:
  index: 3
  problemMessage: "Classes can't be declared to be 'external'."
  correctionMessage: "Try removing the keyword 'external'."
  analyzerCode: ParserErrorCode.EXTERNAL_CLASS
  script:
    - "external class C {}"

ExternalEnum:
  index: 5
  problemMessage: "Enums can't be declared to be 'external'."
  correctionMessage: "Try removing the keyword 'external'."
  analyzerCode: ParserErrorCode.EXTERNAL_ENUM
  script:
    - "external enum E {ONE}"

ExternalMethodWithBody:
  # TODO(danrubel): remove reference to `native` once support has been removed
  index: 49
  problemMessage: "An external or native method can't have a body."
  analyzerCode: ParserErrorCode.EXTERNAL_METHOD_WITH_BODY
  script:
    - "class C {external foo() {}}"
    - "class C {foo() native {}}"
    - "class C {foo() native 'bar' {}}"

ExternalConstructorWithInitializer:
  index: 106
  problemMessage: "An external constructor can't have any initializers."
  analyzerCode: ParserErrorCode.EXTERNAL_CONSTRUCTOR_WITH_INITIALIZER
  script:
    - "class C { int? x; external C() : x = 1; }"
    - "class C { int? x; external C.foo() : x = 1; }"

ExternalTypedef:
  index: 76
  problemMessage: "Typedefs can't be declared to be 'external'."
  correctionMessage: "Try removing the keyword 'external'."
  analyzerCode: ParserErrorCode.EXTERNAL_TYPEDEF
  script:
    - "external typedef F();"

OperatorWithOptionalFormals:
  problemMessage: "An operator can't have optional parameters."

OperatorWithTypeParameters:
  index: 120
  problemMessage: "Types parameters aren't allowed when defining an operator."
  correctionMessage: "Try removing the type parameters."
  analyzerCode: ParserErrorCode.TYPE_PARAMETER_ON_OPERATOR
  comment: |-
    7.1.1 Operators: Type parameters are not syntactically supported on an
    operator.
  script:
    - "class C { operator []<T>(T t) => null; }"

PlatformPrivateLibraryAccess:
  problemMessage: "Can't access platform private library."
  analyzerCode: IMPORT_INTERNAL_LIBRARY

TypedefNotFunction:
  problemMessage: "Can't create typedef from non-function type."
  analyzerCode: INVALID_GENERIC_FUNCTION_TYPE

TypedefNotType:
  problemMessage: "Can't create typedef from non-type."
  analyzerCode: INVALID_TYPE_IN_TYPEDEF

TypedefTypeVariableNotConstructor:
  problemMessage: "Can't use a typedef denoting a type variable as a constructor, nor for a static member access."

TypedefTypeVariableNotConstructorCause:
  problemMessage: "This is the type variable ultimately denoted."
  severity: CONTEXT

TypedefNullableType:
  problemMessage: "Can't create typedef from nullable type."
  configuration: nnbd-strong
  script: |
    // @dart=2.12
    typedef F = void Function()?;

TypedefUnaliasedTypeCause:
  problemMessage: "This is the type denoted by the type alias."
  severity: CONTEXT

TypedefCause:
  problemMessage: "The issue arises via this type alias."
  severity: CONTEXT

LibraryDirectiveNotFirst:
  index: 37
  problemMessage: "The library directive must appear before all other directives."
  correctionMessage: "Try moving the library directive before any other directives."
  analyzerCode: ParserErrorCode.LIBRARY_DIRECTIVE_NOT_FIRST
  script:
    - "class Foo{} library l;"
    - "import 'x.dart'; library l;"
    - "part 'a.dart'; library l;"

ImportAfterPart:
  index: 10
  problemMessage: "Import directives must precede part directives."
  correctionMessage: "Try moving the import directives before the part directives."
  analyzerCode: ParserErrorCode.IMPORT_DIRECTIVE_AFTER_PART_DIRECTIVE
  script:
    - "part 'foo.dart'; import 'bar.dart';"

ExportAfterPart:
  index: 75
  problemMessage: "Export directives must precede part directives."
  correctionMessage: "Try moving the export directives before the part directives."
  analyzerCode: ParserErrorCode.EXPORT_DIRECTIVE_AFTER_PART_DIRECTIVE
  script:
    - "part 'foo.dart'; export 'bar.dart';"

DirectiveAfterDeclaration:
  index: 69
  problemMessage: "Directives must appear before any declarations."
  correctionMessage: "Try moving the directive before any declarations."
  analyzerCode: ParserErrorCode.DIRECTIVE_AFTER_DECLARATION
  script:
    - "class foo { } import 'bar.dart';"
    - "class foo { } export 'bar.dart';"

NonPartOfDirectiveInPart:
  problemMessage: "The part-of directive must be the only directive in a part."
  correctionMessage: "Try removing the other directives, or moving them to the library for which this is a part."
  analyzerCode: NON_PART_OF_DIRECTIVE_IN_PART
  script:
    - "part of l; part 'f.dart';"

PartOfTwice:
  index: 25
  problemMessage: "Only one part-of directive may be declared in a file."
  correctionMessage: "Try removing all but one of the part-of directives."
  analyzerCode: ParserErrorCode.MULTIPLE_PART_OF_DIRECTIVES
  script:
    - main.dart: |
        part "part.dart";
        main() {}
      other.dart: ""
      part.dart: |
        part of "other.dart";
        part of "main.dart";
    - main.dart: |
        part of "lib.dart";
        part of "lib.dart";
        main() {}
      lib.dart: |
        part "main.dart";
    - main.dart: |
        part "part.dart";
      part.dart: |
        part of "main.dart";
        part of "main.dart";

PartTwice:
  problemMessage: "Can't use '#uri' as a part more than once."
  analyzerCode: DUPLICATE_PART
  script:
    part.dart: "part of 'main.dart';"
    main.dart: "part 'part.dart'; part 'part.dart';"

PartOfTwoLibraries:
  problemMessage: "A file can't be part of more than one library."
  correctionMessage: "Try moving the shared declarations into the libraries, or into a new library."
  analyzerCode: PART_OF_DIFFERENT_LIBRARY
  script:
    main.dart: "library lib; import 'lib.dart'; part 'part.dart';"
    lib.dart: "library lib; part 'part.dart';"
    part.dart: "part of lib;"

PartOfTwoLibrariesContext:
  problemMessage: "Used as a part in this library."
  severity: CONTEXT

FactoryTopLevelDeclaration:
  index: 78
  problemMessage: "Top-level declarations can't be declared to be 'factory'."
  correctionMessage: "Try removing the keyword 'factory'."
  analyzerCode: ParserErrorCode.FACTORY_TOP_LEVEL_DECLARATION
  script:
    - "factory class C {}"

RedirectionInNonFactory:
  index: 21
  problemMessage: "Only factory constructor can specify '=' redirection."
  correctionMessage: "Try making this a factory constructor, or remove the redirection."
  analyzerCode: ParserErrorCode.REDIRECTION_IN_NON_FACTORY_CONSTRUCTOR
  script:
    - "class C { C() = D; }"

TopLevelOperator:
  index: 14
  problemMessage: "Operators must be declared within a class."
  correctionMessage: "Try removing the operator, moving it to a class, or converting it to be a function."
  analyzerCode: ParserErrorCode.TOP_LEVEL_OPERATOR
  script:
    - "operator +(bool x, bool y) => x | y;"
    - "bool operator +(bool x, bool y) => x | y;"
    - "void operator +(bool x, bool y) => x | y;"

MissingFunctionParameters:
  problemMessage: "A function declaration needs an explicit list of parameters."
  correctionMessage: "Try adding a parameter list to the function declaration."
  analyzerCode: MISSING_FUNCTION_PARAMETERS
  script:
    - "void f {}"

MissingMethodParameters:
  problemMessage: "A method declaration needs an explicit list of parameters."
  correctionMessage: "Try adding a parameter list to the method declaration."
  analyzerCode: MISSING_METHOD_PARAMETERS
  script:
    - "class C { void m {} }"

MissingTypedefParameters:
  problemMessage: "A typedef needs an explicit list of parameters."
  correctionMessage: "Try adding a parameter list to the typedef."
  analyzerCode: MISSING_TYPEDEF_PARAMETERS
  script:
    - "typedef void F;"

MissingPartOf:
  problemMessage: "Can't use '#uri' as a part, because it has no 'part of' declaration."
  analyzerCode: PART_OF_NON_PART
  script:
    part.dart: ""
    main.dart: "part 'part.dart';"

PartOfInLibrary:
  problemMessage: "Can't import '#uri', because it has a 'part of' declaration."
  correctionMessage: "Try removing the 'part of' declaration, or using '#uri' as a part."
  analyzerCode: IMPORT_OF_NON_LIBRARY
  script:
    main.dart: |
      import "part.dart";
      import "lib.dart";
      main() {}

    part.dart: |
      part of "lib.dart";

    lib.dart: |
      part "part.dart";

PartInPart:
  problemMessage: "A file that's a part of a library can't have parts itself."
  correctionMessage: "Try moving the 'part' declaration to the containing library."
  analyzerCode: NON_PART_OF_DIRECTIVE_IN_PART
  script:
    main.dart: |
      part "part.dart";
      main() {}

    part.dart: |
      part of "main.dart";
      part "part_part.dart";

    part_part.dart: |
      part of "part.dart";

PartInPartLibraryContext:
  problemMessage: "This is the containing library."
  severity: CONTEXT

PartOrphan:
  problemMessage: "This part doesn't have a containing library."
  correctionMessage: "Try removing the 'part of' declaration."
  script: "part of none; main() {}"

PartExport:
  problemMessage: "Can't export this file because it contains a 'part of' declaration."
  analyzerCode: EXPORT_OF_NON_LIBRARY
  script:
    main.dart: |
      export "part.dart";
      import "lib.dart";
      main() {}

    part.dart: |
      part of "lib.dart";

    lib.dart: |
      part "part.dart";

PartExportContext:
  problemMessage: "This is the file that can't be exported."
  severity: CONTEXT

SupertypeIsFunction:
  problemMessage: "Can't use a function type as supertype."

DeferredPrefixDuplicated:
  problemMessage: "Can't use the name '#name' for a deferred library, as the name is used elsewhere."
  analyzerCode: SHARED_DEFERRED_PREFIX

DeferredPrefixDuplicatedCause:
  problemMessage: "'#name' is used here."
  severity: CONTEXT

TypeArgumentsOnTypeVariable:
  index: 13
  problemMessage: "Can't use type arguments with type variable '#name'."
  correctionMessage: "Try removing the type arguments."
  analyzerCode: ParserErrorCode.TYPE_ARGUMENTS_ON_TYPE_VARIABLE
  script:
    - "dynamic<T>(x) => 0"

# Use this message when a duplicated declaration is introduced.  For example:
#
#    class C {} // First declaration (related information points here).
#    class C {} // Duplicated declaration (error here).
#    main() {
#      new C(); // Use of duplicated declaration.
#    }
#
# We follow the convention from C that a definition is the unique element that
# provides the implementation of a name, and a declaration may not be unique
# (for example, forward declaration). Using this terminology, one could argue
# that a method that is abstract or external is a declaration, not a
# definition. Similarly, imported names are declarations, not
# definitions. Consequently, it is more convenient to use the word
# "declaration" instead of "definition" as the former implies less.
DuplicatedDeclaration:
  problemMessage: "'#name' is already declared in this scope."
  analyzerCode: DUPLICATE_DEFINITION
  script: |
    class C {} // First declaration (related information points here).
    class C {} // Duplicated declaration (error here).
    main() {
      // The following line is commented out as it would lead to an extraneous
      // diagnostic.
      // new C(); // Use of duplicated declaration.
    }

DuplicatedDeclarationCause:
  problemMessage: "Previous declaration of '#name'."
  severity: CONTEXT

DuplicatedDeclarationSyntheticCause:
  problemMessage: "Previous declaration of '#name' is implied by this definition."
  severity: CONTEXT

# Use this message when a duplicated declaration is used.
DuplicatedDeclarationUse:
  problemMessage: "Can't use '#name' because it is declared more than once."
  exampleAllowMoreCodes: true
  script:
    - main.dart: |
        // This test can't pass as tests must produce only one error message.
        class C {} // First declaration (related information points here).
        class C {} // Duplicated declaration (error here).
        main() {
          new C(); // Use of duplicated declaration.
        }
    - main.dart: |
        import 'lib1.dart';
        import 'lib2.dart';

        main() {
          new C(); // Use of duplicated declaration.
        }
      lib1.dart: |
        class C {}
      lib2.dart: |
        class C {}

DuplicatedNamePreviouslyUsed:
  problemMessage: "Can't declare '#name' because it was already used in this scope."
  analyzerCode: REFERENCED_BEFORE_DECLARATION
  script:
    - "main(arguments) { arguments; var arguments; }"

DuplicatedNamePreviouslyUsedCause:
  problemMessage: "Previous use of '#name'."
  severity: CONTEXT

DuplicatedNamedArgument:
  problemMessage: "Duplicated named argument '#name'."
  analyzerCode: DUPLICATE_NAMED_ARGUMENT

DuplicatedParameterName:
  problemMessage: "Duplicated parameter name '#name'."
  analyzerCode: DUPLICATE_DEFINITION

DuplicatedParameterNameCause:
  problemMessage: "Other parameter named '#name'."
  severity: CONTEXT

MemberWithSameNameAsClass:
  problemMessage: "A class member can't have the same name as the enclosing class."
  correctionMessage: "Try renaming the member."
  analyzerCode: ParserErrorCode.MEMBER_WITH_CLASS_NAME
  index: 105
  script:
    - "class C { get C {} }"
    - "class C { get C => 42; }"
    - "class C { set C(x) {} }"
    - "class C { set C(x) => 42; }"
    - "class C { int? C; }"
    - "class C { int? A, B, C, D, E; }"

EnumConstantSameNameAsEnclosing:
  problemMessage: "Name of enum constant '#name' can't be the same as the enum's own name."
  analyzerCode: ENUM_CONSTANT_WITH_ENUM_NAME

MissingOperatorKeyword:
  index: 31
  problemMessage: "Operator declarations must be preceded by the keyword 'operator'."
  correctionMessage: "Try adding the keyword 'operator'."
  analyzerCode: ParserErrorCode.MISSING_KEYWORD_OPERATOR
  script:
    - "class C { +(x) {} }"

InvalidOperator:
  index: 39
  problemMessage: "The string '#lexeme' isn't a user-definable operator."
  analyzerCode: ParserErrorCode.INVALID_OPERATOR
  comment: |-
    Parameters:
    0: the operator that is invalid
  script:
    - "class C { void operator %=(x) {} }"

NotBinaryOperator:
  problemMessage: "'#lexeme' isn't a binary operator."
  script: >
    class C { operator~() { return null; } }

    main() {
      C c = new C();
      print(c ~ 2);
    }

OperatorParameterMismatch0:
  problemMessage: "Operator '#name' shouldn't have any parameters."

OperatorParameterMismatch1:
  problemMessage: "Operator '#name' should have exactly one parameter."
  analyzerCode: WRONG_NUMBER_OF_PARAMETERS_FOR_OPERATOR

OperatorParameterMismatch2:
  problemMessage: "Operator '#name' should have exactly two parameters."
  analyzerCode: WRONG_NUMBER_OF_PARAMETERS_FOR_OPERATOR

OperatorMinusParameterMismatch:
  problemMessage: "Operator '#name' should have zero or one parameter."
  correctionMessage: >-
    With zero parameters, it has the syntactic form '-a', formally known as 'unary-'.
    With one parameter, it has the syntactic form 'a - b', formally known as '-'.
  analyzerCode: WRONG_NUMBER_OF_PARAMETERS_FOR_OPERATOR_MINUS

SupertypeIsIllegal:
  problemMessage: "The type '#name' can't be used as supertype."
  analyzerCode: EXTENDS_NON_CLASS
  script: |


    class C extends dynamic {}

SupertypeIsIllegalAliased:
  problemMessage: "The type '#name' which is an alias of '#type' can't be used as supertype."
  analyzerCode: EXTENDS_NON_CLASS
  script: |
    typedef F = void Function();
    class C extends F {}

SupertypeIsNullableAliased:
  problemMessage: "The type '#name' which is an alias of '#type' can't be used as supertype because it is nullable."
  analyzerCode: EXTENDS_NON_CLASS
  experiments: nonfunction-type-aliases
  script: |
    class A {}
    typedef B = A?;
    class C extends B {}

SupertypeIsTypeVariable:
  problemMessage: "The type variable '#name' can't be used as supertype."
  analyzerCode: EXTENDS_NON_CLASS
  script: |
    class C<T> extends T {}

PartOfLibraryNameMismatch:
  problemMessage: "Using '#uri' as part of '#name' but its 'part of' declaration says '#name2'."
  analyzerCode: PART_OF_DIFFERENT_LIBRARY

PartOfUseUri:
  problemMessage: "Using '#uri' as part of '#uri2' but its 'part of' declaration says '#name'."
  correctionMessage: "Try changing the 'part of' declaration to use a relative file name."
  analyzerCode: PART_OF_UNNAMED_LIBRARY

PartOfUriMismatch:
  problemMessage: "Using '#uri' as part of '#uri2' but its 'part of' declaration says '#uri3'."
  analyzerCode: PART_OF_DIFFERENT_LIBRARY

MissingMain:
  problemMessage: "No 'main' method found."
  correctionMessage: "Try adding a method named 'main' to your program."

MissingInput:
  problemMessage: "No input file provided to the compiler."

InputFileNotFound:
  problemMessage: "Input file not found: #uri."

SdkRootNotFound:
  problemMessage: "SDK root directory not found: #uri."

SdkSummaryNotFound:
  problemMessage: "SDK summary not found: #uri."

SdkSpecificationNotFound:
  problemMessage: "SDK libraries specification not found: #uri."
  correctionMessage: "Normally, the specification is a file named 'libraries.json' in the Dart SDK install location."

InvalidSuperInInitializer:
  index: 47
  problemMessage: "Can only use 'super' in an initializer for calling the superclass constructor (e.g. 'super()' or 'super.namedConstructor()')"
  analyzerCode: ParserErrorCode.INVALID_SUPER_IN_INITIALIZER

InvalidThisInInitializer:
  index: 65
  problemMessage: "Can only use 'this' in an initializer for field initialization (e.g. 'this.x = something') and constructor redirection (e.g. 'this()' or 'this.namedConstructor())"
  analyzerCode: ParserErrorCode.INVALID_THIS_IN_INITIALIZER

ThisAccessInFieldInitializer:
  problemMessage: "Can't access 'this' in a field initializer to read '#name'."
  analyzerCode: THIS_ACCESS_FROM_FIELD_INITIALIZER

ThisOrSuperAccessInFieldInitializer:
  problemMessage: "Can't access '#string' in a field initializer."
  analyzerCode: THIS_ACCESS_FROM_INITIALIZER

ThisAsIdentifier:
  problemMessage: "Expected identifier, but got 'this'."
  analyzerCode: INVALID_REFERENCE_TO_THIS

# TODO(johnniwinther): Confusing message, it should probably mention that `super` is not available.
SuperAsIdentifier:
  problemMessage: "Expected identifier, but got 'super'."
  analyzerCode: SUPER_AS_EXPRESSION

InvalidAugmentSuper:
  problemMessage: "'augment super' is only allowed in member augmentations."

SuperAsExpression:
  problemMessage: "Can't use 'super' as an expression."
  correctionMessage: "To delegate a constructor to a super constructor, put the super call as an initializer."
  analyzerCode: SUPER_AS_EXPRESSION

SwitchExpressionNotAssignable:
  problemMessage: "Type '#type' of the switch expression isn't assignable to the type '#type2' of this case expression."
  analyzerCode: SWITCH_EXPRESSION_NOT_ASSIGNABLE
  script:
    - |
      // @dart=2.9
      void f() {
        switch (42) {
          case "foo": break;
        }
      }

SwitchExpressionNotAssignableCause:
  problemMessage: "The switch expression is here."
  severity: CONTEXT

SwitchExpressionNotSubtype:
  problemMessage: "Type '#type' of the case expression is not a subtype of type '#type2' of this switch expression."
  script:
    - |
      // @dart=2.19
      void f() {
        switch (42) {
          case "foo": break;
        }
      }

SwitchHasCaseAfterDefault:
  index: 16
  problemMessage: "The default case should be the last case in a switch statement."
  correctionMessage: "Try moving the default case after the other case clauses."
  analyzerCode: ParserErrorCode.SWITCH_HAS_CASE_AFTER_DEFAULT_CASE
  script:
    - "class C { foo(int a) {switch (a) {default: return 0; case 1: return 1;}} }"

SwitchHasMultipleDefaults:
  index: 15
  problemMessage: "The 'default' case can only be declared once."
  correctionMessage: "Try removing all but one default case."
  analyzerCode: ParserErrorCode.SWITCH_HAS_MULTIPLE_DEFAULT_CASES
  script:
    - "class C { foo(int a) {switch (a) {default: return 0; default: return 1;}} }"

SwitchCaseFallThrough:
  problemMessage: "Switch case may fall through to the next case."
  analyzerCode: CASE_BLOCK_NOT_TERMINATED

FieldAlreadyInitializedAtDeclaration:
  problemMessage: "'#name' is a final instance variable that was initialized at the declaration."
  analyzerCode: FIELD_INITIALIZED_IN_INITIALIZER_AND_DECLARATION
  script:
    - "class C { final int x = 2; C(): this.x = 3 {} }"

FieldAlreadyInitializedAtDeclarationCause:
  problemMessage: "'#name' was initialized here."
  severity: CONTEXT

ConstructorInitializeSameInstanceVariableSeveralTimes:
  problemMessage: "'#name' was already initialized by this constructor."
  analyzerCode: FIELD_INITIALIZED_BY_MULTIPLE_INITIALIZERS
  script:
    - "class C { final int x; C(): this.x = 1, this.x = 2 {} }"
    - "class C { int x; C(): this.x = 1, this.x = 2 {} }"

TypeVariableInStaticContext:
  problemMessage: "Type variables can't be used in static members."
  analyzerCode: TYPE_PARAMETER_REFERENCED_BY_STATIC
  declaration:
    - |
      class C<T> {
        static List<T> staticMethod() {}
      }
    - |
      class C<T> {
        static T staticMethod() {}
      }
    - |
      class C<T> {
        static staticMethod(List<T> argument) {}
      }
    - |
      class C<T> {
        static staticMethod(T argument) {}
      }
    - |
      class C<T> {
        static staticMethod() {
          List<T>? t = null;
          return t;
        }
      }
    - |
      class C<T> {
        static staticMethod() {
          T? t = null;
          return t;
        }
      }

TypeVariableInConstantContext:
  problemMessage: "Type variables can't be used as constants."
  analyzerCode: TYPE_PARAMETER_IN_CONST_EXPRESSION
  declaration:
    - |
      class C<T> {
        instanceMethod() {
          return const <Object>[T];
        }
      }
    - |
      class C<T> {
        instanceMethod() {
          return const <T>[];
        }
      }
    - |
      class C<T> {
        instanceMethod() {
          return const <List<T>>[];
        }
      }

SuperclassMethodArgumentMismatch:
  problemMessage: "Superclass doesn't have a method named '#name' with matching arguments."

SuperclassHasNoMember:
  problemMessage: "Superclass has no member named '#name'."
  analyzerCode: UNDEFINED_SUPER_GETTER

SuperclassHasNoGetter:
  problemMessage: "Superclass has no getter named '#name'."
  analyzerCode: UNDEFINED_SUPER_GETTER

SuperclassHasNoSetter:
  problemMessage: "Superclass has no setter named '#name'."
  analyzerCode: UNDEFINED_SUPER_SETTER

SuperclassHasNoMethod:
  problemMessage: "Superclass has no method named '#name'."
  analyzerCode: UNDEFINED_SUPER_METHOD

SuperclassHasNoConstructor:
  problemMessage: "Superclass has no constructor named '#name'."
  analyzerCode:
    - UNDEFINED_CONSTRUCTOR_IN_INITIALIZER
    - UNDEFINED_CONSTRUCTOR_IN_INITIALIZER_DEFAULT
  script:
    - |
      class Super {
        Super._();
      }

      class Sub extends Super {
        Sub() : super();
      }
    - |
      class Super {
        Super._();
      }

      class Sub extends Super {
        Sub.foo() : super.foo();
      }

SuperclassHasNoDefaultConstructor:
  problemMessage: "The superclass, '#name', has no unnamed constructor that takes no arguments."
  analyzerCode: NO_DEFAULT_SUPER_CONSTRUCTOR_IMPLICIT

ConstConstructorNonFinalField:
  problemMessage: "Constructor is marked 'const' so all fields must be final."
  analyzerCode: CONST_CONSTRUCTOR_WITH_NON_FINAL_FIELD

ConstConstructorNonFinalFieldCause:
  problemMessage: "Field isn't final, but constructor is 'const'."
  severity: CONTEXT

ConstConstructorLateFinalFieldError:
  problemMessage: "Can't have a late final field in a class with a const constructor."

ConstConstructorLateFinalFieldCause:
  problemMessage: "This constructor is const."
  severity: CONTEXT

ConstConstructorRedirectionToNonConst:
  problemMessage: "A constant constructor can't call a non-constant constructor."
  script:
    - >-
      class A {
        const A.foo() : this.bar();
        A.bar() {}
      }

ConstConstructorWithNonConstSuper:
  problemMessage: "A constant constructor can't call a non-constant super constructor."
  analyzerCode: CONST_CONSTRUCTOR_WITH_NON_CONST_SUPER
  script:
    - >-
      class A {
        A.bar() {}
      }
      class B extends A {
        const B.foo() : super.bar();
      }

AccessError:
  problemMessage: "Access error: '#name'."

ExpressionNotMetadata:
  problemMessage: "This can't be used as an annotation; an annotation should be a reference to a compile-time constant variable, or a call to a constant constructor."

ExpectedAnInitializer:
  index: 36
  problemMessage: "Expected an initializer."
  analyzerCode: ParserErrorCode.MISSING_INITIALIZER
  script:
    - "class C { C() : {} }"

MissingAssignmentInInitializer:
  index: 34
  problemMessage: "Expected an assignment after the field name."
  correctionMessage: "To initialize a field, use the syntax 'name = value'."
  analyzerCode: ParserErrorCode.MISSING_ASSIGNMENT_IN_INITIALIZER
  script:
    - "class C { C() : x(3) {} }"

RedirectingConstructorWithBody:
  index: 22
  problemMessage: "Redirecting constructors can't have a body."
  correctionMessage: "Try removing the body, or not making this a redirecting constructor."
  analyzerCode: ParserErrorCode.REDIRECTING_CONSTRUCTOR_WITH_BODY
  script:
    - "class C { C() : this.x() {} }"

CannotAssignToParenthesizedExpression:
  problemMessage: "Can't assign to a parenthesized expression."
  analyzerCode: ASSIGNMENT_TO_PARENTHESIZED_EXPRESSION

NotAnLvalue:
  problemMessage: "Can't assign to this."
  analyzerCode: NOT_AN_LVALUE

CannotAssignToSuper:
  problemMessage: "Can't assign to super."
  analyzerCode: NOT_AN_LVALUE

IllegalAssignmentToNonAssignable:
  index: 45
  problemMessage: "Illegal assignment to non-assignable expression."
  analyzerCode: ParserErrorCode.ILLEGAL_ASSIGNMENT_TO_NON_ASSIGNABLE
  script:
    - "main(){ f()++; }"

MissingAssignableSelector:
  index: 35
  problemMessage: "Missing selector such as '.identifier' or '[0]'."
  correctionMessage: "Try adding a selector."
  analyzerCode: ParserErrorCode.MISSING_ASSIGNABLE_SELECTOR
  script:
    - "main(){ ++f(); }"

CannotReadSdkSpecification:
  problemMessage: "Unable to read the 'libraries.json' specification file:\n  #string."

CantInferPackagesFromManyInputs:
  problemMessage: "Can't infer a packages file when compiling multiple inputs."
  correctionMessage: "Try specifying the file explicitly with the --packages option."

CantInferPackagesFromPackageUri:
  problemMessage: "Can't infer a packages file from an input 'package:*' URI."
  correctionMessage: "Try specifying the file explicitly with the --packages option."

PackageNotFound:
  problemMessage: "Couldn't resolve the package '#name' in '#uri'."

InvalidPackageUri:
  problemMessage: "Invalid package URI '#uri':\n  #string."

CouldNotParseUri:
  problemMessage: "Couldn't parse URI '#string':\n  #string2."

ExpectedUri:
  problemMessage: "Expected a URI."

InterpolationInUri:
  problemMessage: "Can't use string interpolation in a URI."
  analyzerCode: INVALID_LITERAL_IN_CONFIGURATION

IntegerLiteralIsOutOfRange:
  problemMessage: "The integer literal #string can't be represented in 64 bits."
  correctionMessage: "Try using the BigInt class if you need an integer larger than 9,223,372,036,854,775,807 or less than -9,223,372,036,854,775,808."
  analyzerCode: INTEGER_LITERAL_OUT_OF_RANGE

ColonInPlaceOfIn:
  index: 54
  problemMessage: "For-in loops use 'in' rather than a colon."
  correctionMessage: "Try replacing the colon with the keyword 'in'."
  analyzerCode: ParserErrorCode.COLON_IN_PLACE_OF_IN

BinaryOperatorWrittenOut:
  index: 112
  problemMessage: "Binary operator '#string' is written as '#string2' instead of the written out word."
  correctionMessage: "Try replacing '#string' with '#string2'."
  analyzerCode: ParserErrorCode.BINARY_OPERATOR_WRITTEN_OUT
  script: >
    int foo(int x, int y) => x xor y;

ExternalFactoryRedirection:
  index: 85
  problemMessage: "A redirecting factory can't be external."
  correctionMessage: "Try removing the 'external' modifier."
  analyzerCode: ParserErrorCode.EXTERNAL_FACTORY_REDIRECTION

ArgumentTypeNotAssignable:
  problemMessage: "The argument type '#type' can't be assigned to the parameter type '#type2'."
  analyzerCode: ARGUMENT_TYPE_NOT_ASSIGNABLE
  script: >
    method(int i) {}
    main() {
      method(1.5);
    }

ArgumentTypeNotAssignableNullability:
  problemMessage: "The argument type '#type' can't be assigned to the parameter type '#type2' because '#type' is nullable and '#type2' isn't."
  analyzerCode: ARGUMENT_TYPE_NOT_ASSIGNABLE
  configuration: nnbd-strong
  script: >
    method(int i) {}
    main() {
      int? j = null;
      method(j);
    }

ArgumentTypeNotAssignablePartNullability:
  problemMessage: "The argument type '#type' can't be assigned to the parameter type '#type2' because '#type3' is nullable and '#type4' isn't."
  analyzerCode: ARGUMENT_TYPE_NOT_ASSIGNABLE
  configuration: nnbd-strong
  script: >
    method(List<int> i) {}
    main() {
      List<int?> j = [null];
      method(j);
    }

ArgumentTypeNotAssignableNullabilityNull:
  problemMessage: "The value 'null' can't be assigned to the parameter type '#type' because '#type' is not nullable."
  analyzerCode: ARGUMENT_TYPE_NOT_ASSIGNABLE
  configuration: nnbd-strong
  script: >
    method(int i) {}
    main() {
      method(null);
    }

ArgumentTypeNotAssignableNullabilityNullType:
  problemMessage: "The argument type '#type' can't be assigned to the parameter type '#type2' because '#type2' is not nullable."
  analyzerCode: ARGUMENT_TYPE_NOT_ASSIGNABLE
  configuration: nnbd-strong
  script: >
    method(int i) {}
    main() {
      Null n;
      method(n);
    }

InvalidAssignmentError:
  problemMessage: "A value of type '#type' can't be assigned to a variable of type '#type2'."
  analyzerCode: INVALID_ASSIGNMENT
  script: >
    main() {
      int i;
      i = 1.5;
    }

InvalidAssignmentErrorNullability:
  problemMessage: "A value of type '#type' can't be assigned to a variable of type '#type2' because '#type' is nullable and '#type2' isn't."
  analyzerCode: INVALID_ASSIGNMENT
  configuration: nnbd-strong
  script: >
    main() {
      int i = 0;
      int? j;
      i = j;
    }

InvalidAssignmentErrorPartNullability:
  problemMessage: "A value of type '#type' can't be assigned to a variable of type '#type2' because '#type3' is nullable and '#type4' isn't."
  analyzerCode: INVALID_ASSIGNMENT
  configuration: nnbd-strong
  script: >
    main() {
      List<int> i = [];
      List<int?> j = [null];
      i = j;
    }

InvalidAssignmentErrorNullabilityNull:
  problemMessage: "The value 'null' can't be assigned to a variable of type '#type' because '#type' is not nullable."
  analyzerCode: INVALID_ASSIGNMENT
  configuration: nnbd-strong
  script: >
    main() {
      int i = 0;
      i = null;
    }

InvalidAssignmentErrorNullabilityNullType:
  problemMessage: "A value of type '#type' can't be assigned to a variable of type '#type2' because '#type2' is not nullable."
  analyzerCode: INVALID_ASSIGNMENT
  configuration: nnbd-strong
  script: >
    main() {
      Null n;
      int i = 0;
      i = n;
    }

PatchClassTypeVariablesMismatch:
  problemMessage: "A patch class must have the same number of type variables as its origin class."

PatchClassOrigin:
  problemMessage: "This is the origin class."
  severity: CONTEXT

PatchDeclarationMismatch:
  problemMessage: "This patch doesn't match origin declaration."

PatchDeclarationOrigin:
  problemMessage: "This is the origin declaration."
  severity: CONTEXT

PatchInjectionFailed:
  problemMessage: "Can't inject public '#name' into '#uri'."
  correctionMessage: "Make '#name' private, or make sure injected library has \"dart\" scheme and is private (e.g. \"dart:_internal\")."

PatchNonExternal:
  problemMessage: "Can't apply this patch as its origin declaration isn't external."
  correctionMessage: "Try adding 'external' to the origin declaration."

InvalidCastFunctionExpr:
  problemMessage: "The function expression type '#type' isn't of expected type '#type2'."
  correctionMessage: "Change the type of the function expression or the context in which it is used."
  analyzerCode: INVALID_CAST_FUNCTION_EXPR

InvalidCastLiteralList:
  problemMessage: "The list literal type '#type' isn't of expected type '#type2'."
  correctionMessage: "Change the type of the list literal or the context in which it is used."
  analyzerCode: INVALID_CAST_LITERAL_LIST

InvalidCastLiteralMap:
  problemMessage: "The map literal type '#type' isn't of expected type '#type2'."
  correctionMessage: "Change the type of the map literal or the context in which it is used."
  analyzerCode: INVALID_CAST_LITERAL_MAP

InvalidCastLiteralSet:
  problemMessage: "The set literal type '#type' isn't of expected type '#type2'."
  correctionMessage: "Change the type of the set literal or the context in which it is used."
  analyzerCode: INVALID_CAST_LITERAL_SET

InvalidCastLocalFunction:
  problemMessage: "The local function has type '#type' that isn't of expected type '#type2'."
  correctionMessage: "Change the type of the function or the context in which it is used."
  analyzerCode: INVALID_CAST_FUNCTION

InvalidCastNewExpr:
  problemMessage: "The constructor returns type '#type' that isn't of expected type '#type2'."
  correctionMessage: "Change the type of the object being constructed or the context in which it is used."
  analyzerCode: INVALID_CAST_NEW_EXPR

InvalidCastStaticMethod:
  problemMessage: "The static method has type '#type' that isn't of expected type '#type2'."
  correctionMessage: "Change the type of the method or the context in which it is used."
  analyzerCode: INVALID_CAST_METHOD

InvalidCastTopLevelFunction:
  problemMessage: "The top level function has type '#type' that isn't of expected type '#type2'."
  correctionMessage: "Change the type of the function or the context in which it is used."
  analyzerCode: INVALID_CAST_FUNCTION

InvalidCatchArguments:
  problemMessage: "Invalid catch arguments."
  analyzerCode: INVALID_CATCH_ARGUMENTS

InvalidUseOfNullAwareAccess:
  problemMessage: "Cannot use '?.' here."
  correctionMessage: "Try using '.'."
  analyzerCode: INVALID_USE_OF_NULL_AWARE_ACCESS

UndefinedGetter:
  problemMessage: "The getter '#name' isn't defined for the class '#type'."
  correctionMessage: "Try correcting the name to the name of an existing getter, or defining a getter or field named '#name'."
  analyzerCode: UNDEFINED_GETTER
  script: >
    class C {}
    test(C c) {
      print(c.foo);
    }

UndefinedSetter:
  problemMessage: "The setter '#name' isn't defined for the class '#type'."
  correctionMessage: "Try correcting the name to the name of an existing setter, or defining a setter or field named '#name'."
  analyzerCode: UNDEFINED_SETTER
  script: >
    class C {}
    test(C c) {
      c.foo = 0;
    }

UndefinedMethod:
  problemMessage: "The method '#name' isn't defined for the class '#type'."
  correctionMessage: "Try correcting the name to the name of an existing method, or defining a method named '#name'."
  analyzerCode: UNDEFINED_METHOD
  script: >
    class C {}
    test(C c) {
      c.foo();
    }

UndefinedOperator:
  problemMessage: "The operator '#name' isn't defined for the class '#type'."
  correctionMessage: "Try correcting the operator to an existing operator, or defining a '#name' operator."
  analyzerCode: UNDEFINED_METHOD
  script: >
    class C {}
    test(C c) {
      c + 0;
    }

UndefinedExtensionGetter:
  problemMessage: "The getter '#name' isn't defined for the extension '#type'."
  correctionMessage: "Try correcting the name to the name of an existing getter, or defining a getter or field named '#name'."

UndefinedExtensionSetter:
  problemMessage: "The setter '#name' isn't defined for the extension '#type'."
  correctionMessage: "Try correcting the name to the name of an existing setter, or defining a setter or field named '#name'."

UndefinedExtensionMethod:
  problemMessage: "The method '#name' isn't defined for the extension '#type'."
  correctionMessage: "Try correcting the name to the name of an existing method, or defining a method name '#name'."

UndefinedExtensionOperator:
  problemMessage: "The operator '#name' isn't defined for the extension '#type'."
  correctionMessage: "Try correcting the operator to an existing operator, or defining a '#name' operator."

AmbiguousExtensionMethod:
  problemMessage: "The method '#name' is defined in multiple extensions for '#type' and neither is more specific."
  correctionMessage: "Try using an explicit extension application of the wanted extension or hiding unwanted extensions from scope."
  script: |
    class C {}
    extension A on C { method() {} }
    extension B on C { method() {} }
    main() {
      C c = new C();
      c.method();
    }

AmbiguousExtensionProperty:
  problemMessage: "The property '#name' is defined in multiple extensions for '#type' and neither is more specific."
  correctionMessage: "Try using an explicit extension application of the wanted extension or hiding unwanted extensions from scope."
  script: |
    class C {}
    extension A on C { get property => null; }
    extension B on C { set property(_) {} }
    main() {
      C c = new C();
      c.property;
    }

AmbiguousExtensionOperator:
  problemMessage: "The operator '#name' is defined in multiple extensions for '#type' and neither is more specific."
  correctionMessage: "Try using an explicit extension application of the wanted extension or hiding unwanted extensions from scope."
  script: |
    class C {}
    extension A on C { operator +(int i) {} }
    extension B on C { operator +(int i) {}  }
    main() {
      C c = new C();
      c + 0;
    }

AmbiguousExtensionCause:
  problemMessage: "This is one of the extension members."
  severity: CONTEXT

SourceOutlineSummary:
  problemMessage: |
    Built outlines for #count compilation units (#count2 bytes) in #num1%.3ms, that is,
    #num2%12.3 bytes/ms, and
    #num3%12.3 ms/compilation unit.

SourceBodySummary:
  problemMessage: |
    Built bodies for #count compilation units (#count2 bytes) in #num1%.3ms, that is,
    #num2%12.3 bytes/ms, and
    #num3%12.3 ms/compilation unit.

DillOutlineSummary:
  problemMessage: |
    Indexed #count libraries (#count2 bytes) in #num1%.3ms, that is,
    #num2%12.3 bytes/ms, and
    #num3%12.3 ms/libraries.

CantInferTypesDueToNoCombinedSignature:
  problemMessage: "Can't infer types for '#name' as the overridden members don't have a combined signature."
  correctionMessage: "Try adding explicit types."
  analyzerCode: COMPILE_TIME_ERROR.NO_COMBINED_SUPER_SIGNATURE
  script: |
    class A {
      void method(int a, String b) {}
    }
    class B {
      void method(String a, int b) {}
    }
    class C implements A, B {
      void method(a, b) {}
    }

CantInferTypeDueToNoCombinedSignature:
  problemMessage: "Can't infer a type for '#name' as the overridden members don't have a combined signature."
  correctionMessage: "Try adding an explicit type."
  analyzerCode: COMPILE_TIME_ERROR.NO_COMBINED_SUPER_SIGNATURE
  configuration: nnbd-strong
  script: |
    class A {
      void method(int a) {}
    }
    class B {
      void method(String a) {}
    }
    class C implements A, B {
      void method(a) {}
    }

CantInferReturnTypeDueToNoCombinedSignature:
  problemMessage: "Can't infer a return type for '#name' as the overridden members don't have a combined signature."
  correctionMessage: "Try adding an explicit type."
  analyzerCode: COMPILE_TIME_ERROR.NO_COMBINED_SUPER_SIGNATURE
  configuration: nnbd-strong
  script: |
    abstract class A {
      int get getter;
    }
    abstract class B {
      String get getter;
    }
    abstract class C implements A, B {
      get getter;
    }

CantInferTypeDueToCircularity:
  problemMessage: "Can't infer the type of '#string': circularity found during type inference."
  correctionMessage: "Specify the type explicitly."
  analyzerCode: RECURSIVE_COMPILE_TIME_CONSTANT

AmbiguousSupertypes:
  problemMessage: "'#name' can't implement both '#type' and '#type2'"
  analyzerCode: AMBIGUOUS_SUPERTYPES

MixinInferenceNoMatchingClass:
  problemMessage: "Type parameters couldn't be inferred for the mixin '#name' because '#name2' does not implement the mixin's supertype constraint '#type'."
  analyzerCode: MIXIN_INFERENCE_NO_POSSIBLE_SUBSTITUTION

ImplicitCallOfNonMethod:
  problemMessage: "Cannot invoke an instance of '#type' because it declares 'call' to be something other than a method."
  correctionMessage: "Try changing 'call' to a method or explicitly invoke 'call'."
  analyzerCode: IMPLICIT_CALL_OF_NON_METHOD
  script: |
    class Class { void Function() get call => () {}; }
    method(Class c) => c();

ImplicitSuperCallOfNonMethod:
  problemMessage: "Cannot invoke `super` because it declares 'call' to be something other than a method."
  correctionMessage: "Try changing 'call' to a method or explicitly invoke 'call'."
  analyzerCode: IMPLICIT_CALL_OF_NON_METHOD
  script: |
    class Super { void Function() get call => () {}; }
    class Class extends Super { void method() => super(); }

ExpectedOneExpression:
  problemMessage: "Expected one expression, but found additional input."

ForInLoopNotAssignable:
  problemMessage: "Can't assign to this, so it can't be used in a for-in loop."
  statement: "for (1 in []) {}"

ForInLoopExactlyOneVariable:
  problemMessage: "A for-in loop can't have more than one loop variable."
  statement: "for (var x, y in []) {}"

ForInLoopWithConstVariable:
  problemMessage: "A for-in loop-variable can't be 'const'."
  correctionMessage: "Try removing the 'const' modifier."
  analyzerCode: FOR_IN_WITH_CONST_VARIABLE

ForInLoopElementTypeNotAssignable:
  problemMessage: "A value of type '#type' can't be assigned to a variable of type '#type2'."
  correctionMessage: "Try changing the type of the variable."
  analyzerCode: FOR_IN_OF_INVALID_ELEMENT_TYPE
  script: |
    method() {
      List<String> list = [];
      for (int i in list) {}
    }

ForInLoopElementTypeNotAssignableNullability:
  problemMessage: "A value of type '#type' can't be assigned to a variable of type '#type2' because '#type' is nullable and '#type2' isn't."
  correctionMessage: "Try changing the type of the variable."
  analyzerCode: FOR_IN_OF_INVALID_ELEMENT_TYPE
  configuration: nnbd-strong
  script: |
    method() {
      List<int?> list = [];
      for (int i in list) {}
    }

ForInLoopElementTypeNotAssignablePartNullability:
  problemMessage: "A value of type '#type' can't be assigned to a variable of type '#type2' because '#type3' is nullable and '#type4' isn't."
  correctionMessage: "Try changing the type of the variable."
  analyzerCode: FOR_IN_OF_INVALID_ELEMENT_TYPE
  configuration: nnbd-strong
  script: |
    method() {
      List<List<int?>> list = [[]];
      for (List<int> i in list) {}
    }

ForInLoopTypeNotIterable:
  problemMessage: "The type '#type' used in the 'for' loop must implement '#type2'."
  analyzerCode: FOR_IN_OF_INVALID_TYPE
  script: |
    method() {
      String list = '';
      for (int i in list) {}
    }

ForInLoopTypeNotIterableNullability:
  problemMessage: "The type '#type' used in the 'for' loop must implement '#type2' because '#type' is nullable and '#type2' isn't."
  analyzerCode: FOR_IN_OF_INVALID_TYPE
  configuration: nnbd-strong
  script: |
    method() {
      List<int>? list = null;
      for (int i in list) {}
    }

# This cannot never occur since the iterable is checked to be assignable to `Iterable<dynamic>` so nullability can
# only be a problem at the immediate level as in [ForInLoopTypeNotIterableNullability]. The message is needed for
# symmetry in the call site.
ForInLoopTypeNotIterablePartNullability:
  problemMessage: "The type '#type' used in the 'for' loop must implement '#type2' because '#type3' is nullable and '#type4' isn't."
  analyzerCode: FOR_IN_OF_INVALID_TYPE

InitializingFormalTypeMismatch:
  problemMessage: "The type of parameter '#name', '#type' is not a subtype of the corresponding field's type, '#type2'."
  correctionMessage: "Try changing the type of parameter '#name' to a subtype of '#type2'."
  analyzerCode: INVALID_PARAMETER_DECLARATION
  script: >
    class C {
      int x;
      C(num this.x);
    }

InitializingFormalTypeMismatchField:
  problemMessage: "The field that corresponds to the parameter."
  severity: CONTEXT

InitializeFromDillNotSelfContained:
  problemMessage: |
    Tried to initialize from a previous compilation (#string), but the file was not self-contained. This might be a bug.

    The Dart team would greatly appreciate it if you would take a moment to report this problem at http://dartbug.com/new.
    If you are comfortable with it, it would improve the chances of fixing any bug if you included the file #uri in your error report, but be aware that this file includes your source code.
    Either way, you should probably delete the file so it doesn't use unnecessary disk space.

  severity: WARNING
  frontendInternal: true
  external: test/incremental_load_from_invalid_dill_test.dart

InitializeFromDillNotSelfContainedNoDump:
  problemMessage: |
    Tried to initialize from a previous compilation (#string), but the file was not self-contained. This might be a bug.

    The Dart team would greatly appreciate it if you would take a moment to report this problem at http://dartbug.com/new.

  severity: WARNING
  frontendInternal: true
  external: test/incremental_load_from_invalid_dill_test.dart

InitializeFromDillUnknownProblem:
  problemMessage: |
    Tried to initialize from a previous compilation (#string), but couldn't.
    Error message was '#string2'.
    Stacktrace included '#string3'.
    This might be a bug.

    The Dart team would greatly appreciate it if you would take a moment to report this problem at http://dartbug.com/new.
    If you are comfortable with it, it would improve the chances of fixing any bug if you included the file #uri in your error report, but be aware that this file includes your source code.
    Either way, you should probably delete the file so it doesn't use unnecessary disk space.

  severity: WARNING
  frontendInternal: true
  external: test/incremental_load_from_invalid_dill_test.dart

InitializeFromDillUnknownProblemNoDump:
  problemMessage: |
    Tried to initialize from a previous compilation (#string), but couldn't.
    Error message was '#string2'.
    Stacktrace included '#string3'.
    This might be a bug.

    The Dart team would greatly appreciate it if you would take a moment to report this problem at http://dartbug.com/new.

  severity: WARNING
  frontendInternal: true
  external: test/incremental_load_from_invalid_dill_test.dart

WebLiteralCannotBeRepresentedExactly:
  problemMessage: "The integer literal #string can't be represented exactly in JavaScript."
  correctionMessage: "Try changing the literal to something that can be represented in JavaScript. In JavaScript #string2 is the nearest value that can be represented exactly."

BoundIssueViaRawTypeWithNonSimpleBounds:
  problemMessage: "Generic type '#name' can't be used without type arguments in a type variable bound."
  correctionMessage: "Try providing type arguments to '#name' here."
  analyzerCode: NOT_INSTANTIATED_BOUND
  script: >
    class Hest<X extends Hest<X>> {}
    class Fisk<Y extends Hest> {}

NonSimpleBoundViaVariable:
  problemMessage: "Bound of this variable references variable '#name' from the same declaration."
  severity: CONTEXT

BoundIssueViaLoopNonSimplicity:
  problemMessage: "Generic type '#name' can't be used without type arguments in the bounds of its own type variables."
  correctionMessage: "Try providing type arguments to '#name' here."
  analyzerCode: NOT_INSTANTIATED_BOUND
  script: >
    class Hest<X extends Hest> {}

BoundIssueViaCycleNonSimplicity:
  problemMessage: "Generic type '#name' can't be used without type arguments in the bounds of its own type variables. It is referenced indirectly through '#name2'."
  correctionMessage: "Try providing type arguments to '#name2' here or to some other raw types in the bounds along the reference chain."
  analyzerCode: NOT_INSTANTIATED_BOUND
  script: >
    class Hest<X extends Fisk> {}
    class Fisk<Y extends Hest> {}

NonSimpleBoundViaReference:
  problemMessage: "Bound of this variable references raw type '#name'."
  severity: CONTEXT

CycleInTypeVariables:
  problemMessage: "Type '#name' is a bound of itself via '#string'."
  correctionMessage: "Try breaking the cycle by removing at least on of the 'extends' clauses in the cycle."
  analyzerCode: TYPE_PARAMETER_SUPERTYPE_OF_ITS_BOUND
  script:
    - "foo<A extends B, B extends A>() {}"

DirectCycleInTypeVariables:
  problemMessage: "Type '#name' can't use itself as a bound."
  correctionMessage: "Try breaking the cycle by removing at least on of the 'extends' clauses in the cycle."
  analyzerCode: TYPE_PARAMETER_SUPERTYPE_OF_ITS_BOUND
  script:
    - "foo<A extends A>() {}"

CantUsePrefixAsExpression:
  problemMessage: "A prefix can't be used as an expression."
  analyzerCode: PREFIX_IDENTIFIER_NOT_FOLLOWED_BY_DOT
  script: |
    import "dart:core" as prefix;

    main() {
      for (prefix in []) {}
    }

CantUsePrefixWithNullAware:
  problemMessage: "A prefix can't be used with null-aware operators."
  correctionMessage: "Try replacing '?.' with '.'"
  analyzerCode: PREFIX_IDENTIFIER_NOT_FOLLOWED_BY_DOT
  script: |
    import "dart:core" as prefix;

    main() {
      prefix?.Object;
    }

CantUseControlFlowOrSpreadAsConstant:
  problemMessage: "'#lexeme' is not supported in constant expressions."
  analyzerCode: NOT_CONSTANT_EXPRESSION

CantUseDeferredPrefixAsConstant:
  problemMessage: >
    '#lexeme' can't be used in a constant expression because it's marked as
    'deferred' which means it isn't available until loaded.
  correctionMessage: >
    Try moving the constant from the deferred library, or removing 'deferred'
    from the import.
  analyzerCode: CONST_DEFERRED_CLASS
  script: |
    import "dart:convert" deferred as prefix;

    main() {
      const prefix.JsonCodec();
    }

CyclicRedirectingFactoryConstructors:
  problemMessage: "Cyclic definition of factory '#name'."
  analyzerCode: RECURSIVE_FACTORY_REDIRECT
  script: |
    class Foo {
      factory Foo.foo() = Foo.bar;
      factory Foo.bar() = Foo.foo;
    }
    main() { var foo = new Foo.foo(); }

GenericFunctionTypeInBound:
  problemMessage: "Type variables can't have generic function types in their bounds."
  analyzerCode: GENERIC_FUNCTION_TYPE_CANNOT_BE_BOUND
  script: |
    // @dart=2.13
    class Hest<X extends Y Function<Y>(Y)> {}

VoidExpression:
  problemMessage: "This expression has type 'void' and can't be used."
  analyzerCode: USE_OF_VOID_RESULT
  statement: |
    {
      void x;
      int y = x;
    }

ReturnFromVoidFunction:
  problemMessage: "Can't return a value from a void function."
  analyzerCode: RETURN_OF_INVALID_TYPE
  declaration: "void foo() { return 1; }"

ReturnWithoutExpression:
  problemMessage: "Must explicitly return a value from a non-void function."
  severity: WARNING
  analyzerCode: RETURN_WITHOUT_VALUE
  script: |
    // @dart=2.9
    int foo() { return; }

ReturnWithoutExpressionSync:
  problemMessage: "A value must be explicitly returned from a non-void function."
  configuration: nnbd-strong
  script: |
    import "dart:async";
    FutureOr<Object?> foo() { return; }

ReturnWithoutExpressionAsync:
  problemMessage: "A value must be explicitly returned from a non-void async function."
  configuration: nnbd-strong
  declaration: "Future<int> foo() async { return; }"

InvalidReturn:
  problemMessage: "A value of type '#type' can't be returned from a function with return type '#type2'."
  configuration: nnbd-strong
  declaration: "int foo() { return true; }"

InvalidReturnNullability:
  problemMessage: "A value of type '#type' can't be returned from a function with return type '#type2' because '#type' is nullable and '#type2' isn't."
  configuration: nnbd-strong
  declaration: "int foo(int? i) { return i; }"

InvalidReturnPartNullability:
  problemMessage: "A value of type '#type' can't be returned from a function with return type '#type2' because '#type3' is nullable and '#type4' isn't."
  configuration: nnbd-strong
  declaration: "List<int> foo(List<int?> list) { return list; }"

InvalidReturnNullabilityNull:
  problemMessage: "The value 'null' can't be returned from a function with return type '#type' because '#type' is not nullable."
  configuration: nnbd-strong
  declaration: "int foo() { return null; }"

InvalidReturnNullabilityNullType:
  problemMessage: "A value of type '#type' can't be returned from a function with return type '#type2' because '#type2' is not nullable."
  configuration: nnbd-strong
  declaration: "int foo(Null i) { return i; }"

InvalidReturnAsync:
  problemMessage: "A value of type '#type' can't be returned from an async function with return type '#type2'."
  configuration: nnbd-strong
  declaration: "Future<int> foo() async { return true; }"

InvalidReturnAsyncNullability:
  problemMessage: "A value of type '#type' can't be returned from an async function with return type '#type2' because '#type' is nullable and '#type2' isn't."
  configuration: nnbd-strong
  declaration: "Future<int> foo(int? i) async { return i; }"

InvalidReturnAsyncPartNullability:
  problemMessage: "A value of type '#type' can't be returned from an async function with return type '#type2' because '#type3' is nullable and '#type4' isn't."
  configuration: nnbd-strong
  declaration: "Future<List<int>> foo(List<int?> list) async { return list; }"

InvalidReturnAsyncNullabilityNull:
  problemMessage: "The value 'null' can't be returned from an async function with return type '#type' because '#type' is not nullable."
  configuration: nnbd-strong
  declaration: "Future<int> foo() async { return null; }"

InvalidReturnAsyncNullabilityNullType:
  problemMessage: "A value of type '#type' can't be returned from an async function with return type '#type2' because '#type2' is not nullable."
  configuration: nnbd-strong
  declaration: "Future<int> foo(Null n) async { return n; }"

ImplicitReturnNull:
  problemMessage: "A non-null value must be returned since the return type '#type' doesn't allow null."
  configuration: nnbd-strong
  script: |
    String method() {}

RethrowNotCatch:
  problemMessage: "'rethrow' can only be used in catch clauses."
  analyzerCode: RETHROW_OUTSIDE_CATCH

InvokeNonFunction:
  problemMessage: "'#name' isn't a function or method and can't be invoked."
  analyzerCode: INVOCATION_OF_NON_FUNCTION
  script: |
    // @dart=2.9
    class Foo {
      int f;
    }
    main() {
      Foo foo = new Foo();
      foo.f();
    }

ConstInstanceField:
  problemMessage: "Only static fields can be declared as const."
  correctionMessage: "Try using 'final' instead of 'const', or adding the keyword 'static'."
  analyzerCode: CONST_INSTANCE_FIELD
  script:
    - "class C { const field = 0; }"

DefaultValueInRedirectingFactoryConstructor:
  problemMessage: "Can't have a default value here because any default values of '#name' would be used instead."
  correctionMessage: "Try removing the default value."
  analyzerCode: DEFAULT_VALUE_IN_REDIRECTING_FACTORY_CONSTRUCTOR
  script:
    - >-
      class A {
        factory A.f({int x = 42}) = A.g;
        A.g({int x = 40}) {}
      }

UntranslatableUri:
  problemMessage: "Not found: '#uri'"
  analyzerCode: URI_DOES_NOT_EXIST
  exampleAllowMoreCodes: true # PackageNotFound will precede this message.
  script: |
    import "package:expect/non_existing_file";

UnavailableDartLibrary:
  problemMessage: "Dart library '#uri' is not available on this platform."
  analyzerCode: URI_DOES_NOT_EXIST
  script: |
    import "dart:non_existing_library";

ImportChainContext:
  problemMessage: |
    The unavailable library '#uri' is imported through these packages:

    #string
    Detailed import paths for (some of) the these imports:

    #string2
  severity: CONTEXT

ImportChainContextSimple:
  problemMessage: |
    The unavailable library '#uri' is imported through these paths:

    #string
  severity: CONTEXT

CantReadFile:
  problemMessage: "Error when reading '#uri': #string"
  analyzerCode: URI_DOES_NOT_EXIST
  external: test/packages_format_error_test.dart
  script: |
    import "non_existing_file.dart";

ExceptionReadingFile:
  problemMessage: "Exception when reading '#uri': #string"

PackagesFileFormat:
  problemMessage: "Problem in packages configuration file: #string"
  external: test/packages_format_error_test.dart

IncompatibleRedirecteeFunctionType:
  problemMessage: "The constructor function type '#type' isn't a subtype of '#type2'."
  analyzerCode: REDIRECT_TO_INVALID_TYPE
  script:
    - >-
      class A {
        factory A() = B;
      }
      class B {
        B();
      }
    - >-
      class A {
        factory A.one(int x) = A.zero;
        A.zero() {}
      }
    - >-
      class A {
        factory A.i(int x) = A.s;
        A.s(String x) { }
      }
    - >-
      class A {
        factory A.f({int? x}) = A.g;
        A.g({int? y}) { }
      }
    - >-
      class A {
        factory A.f(int x) = A.g;
        A.g(int x, int y) {}
      }
    - >-
      class A<T extends int> {
         factory A() = B<T, int>;
      }
      class B<T extends int, S extends String> implements A<T> {}

RedirectingFactoryIncompatibleTypeArgument:
  problemMessage: "The type '#type' doesn't extend '#type2'."
  correctionMessage: "Try using a different type as argument."
  analyzerCode: TYPE_ARGUMENT_NOT_MATCHING_BOUNDS
  script:
    - >-
      class A<T extends int> {
         factory A() = B<T, int>;
      }
      class B<T extends int, S extends String> implements A<T> {}

SyntheticToken:
  problemMessage: "This couldn't be parsed."
  frontendInternal: true

IncorrectTypeArgument:
  problemMessage: "Type argument '#type' doesn't conform to the bound '#type2' of the type variable '#name' on '#name2'."
  correctionMessage: "Try changing type arguments so that they conform to the bounds."
  analyzerCode: TYPE_ARGUMENT_NOT_MATCHING_BOUNDS
  script: >
    class C<T extends num> {}
    main() { new C<String>(); }

IncorrectTypeArgumentQualified:
  problemMessage: "Type argument '#type' doesn't conform to the bound '#type2' of the type variable '#name' on '#type3.#name2'."
  correctionMessage: "Try changing type arguments so that they conform to the bounds."
  analyzerCode: TYPE_ARGUMENT_NOT_MATCHING_BOUNDS
  script: >
    class C<T> { foo<U extends num>() {} }
    main() { new C<String>().foo<String>(); }

IncorrectTypeArgumentInferred:
  problemMessage: "Inferred type argument '#type' doesn't conform to the bound '#type2' of the type variable '#name' on '#name2'."
  correctionMessage: "Try specifying type arguments explicitly so that they conform to the bounds."
  analyzerCode: TYPE_ARGUMENT_NOT_MATCHING_BOUNDS
  script: >
    void foo<T extends num>(T t) {}
    main() { foo("bar"); }

IncorrectTypeArgumentQualifiedInferred:
  problemMessage: "Inferred type argument '#type' doesn't conform to the bound '#type2' of the type variable '#name' on '#type3.#name2'."
  correctionMessage: "Try specifying type arguments explicitly so that they conform to the bounds."
  analyzerCode: TYPE_ARGUMENT_NOT_MATCHING_BOUNDS
  script: >
    class C<T> { foo<U extends num>(U u) {} }
    main() { new C<String>().foo(""); }

IncorrectTypeArgumentInstantiation:
  problemMessage: "Type argument '#type' doesn't conform to the bound '#type2' of the type variable '#name' on '#type3'."
  correctionMessage: "Try changing type arguments so that they conform to the bounds."
  analyzerCode: TYPE_ARGUMENT_NOT_MATCHING_BOUNDS
  experiments: constructor-tearoffs
  script: |
    X bounded<X extends num>(X x) => x;
    main() {
      bounded<String>;
    }

IncorrectTypeArgumentInstantiationInferred:
  problemMessage: "Inferred type argument '#type' doesn't conform to the bound '#type2' of the type variable '#name' on '#type3'."
  correctionMessage: "Try specifying type arguments explicitly so that they conform to the bounds."
  analyzerCode: TYPE_ARGUMENT_NOT_MATCHING_BOUNDS
  script: |
    X bounded<X extends num>(X x) => x;
    main() {
      String Function(String) c = bounded;
    }

IncorrectTypeArgumentVariable:
  problemMessage: "This is the type variable whose bound isn't conformed to."
  severity: CONTEXT

SuperBoundedHint:
  problemMessage: "If you want '#type' to be a super-bounded type, note that the inverted type '#type2' must then satisfy its bounds, which it does not."
  severity: CONTEXT

MixinApplicationIncompatibleSupertype:
  problemMessage: "'#type' doesn't implement '#type2' so it can't be used with '#type3'."
  analyzerCode: MIXIN_APPLICATION_NOT_IMPLEMENTED_INTERFACE
  script: >-
    class I {}
    mixin M on I {}
    class C = Object with M;

GenericFunctionTypeUsedAsActualTypeArgument:
  problemMessage: "A generic function type can't be used as a type argument."
  correctionMessage: "Try using a non-generic function type."
  analyzerCode: GENERIC_FUNCTION_CANNOT_BE_TYPE_ARGUMENT
  script:
    - |
      // @dart=2.13
      typedef F = Class<T> Function<T>(T);
      class Class<T> {}
      main() {
        Class<F> class1;
      }
    - |
      // @dart=2.13
      typedef F = Class<T> Function<T>(T);
      class Class<T> {}
      main() {
        Class<F>();
      }

GenericFunctionTypeInferredAsActualTypeArgument:
  problemMessage: "Generic function type '#type' inferred as a type argument."
  correctionMessage: "Try providing a non-generic function type explicitly."
  analyzerCode: GENERIC_FUNCTION_CANNOT_BE_TYPE_ARGUMENT
  script: |
    // @dart=2.13
    foo<X>(X x) => null;
    bar<Y>(Y y) => null;
    main() { foo(bar); }

GenericFunctionTypeAsTypeArgumentThroughTypedef:
  problemMessage: "Generic function type '#type' used as a type argument through typedef '#type2'."
  correctionMessage: "Try providing a non-generic function type explicitly."
  analyzerCode: GENERIC_FUNCTION_CANNOT_BE_TYPE_ARGUMENT

# These two message templates are used for constructing supplemental text
# about the origins of raw interface types in error messages containing types.
TypeOrigin:
  problemMessage: "'#name' is from '#uri'."
  frontendInternal: true
  external: test/type_labeler_test.dart

TypeOriginWithFileUri:
  problemMessage: "'#name' is from '#uri' ('#uri2')."
  frontendInternal: true
  external: test/type_labeler_test.dart

ObjectExtends:
  problemMessage: "The class 'Object' can't have a superclass."
  frontendInternal: true
  external: test/fasta/object_supertype_test.dart

ObjectImplements:
  problemMessage: "The class 'Object' can't implement anything."
  frontendInternal: true
  external: test/fasta/object_supertype_test.dart

ObjectMixesIn:
  problemMessage: "The class 'Object' can't use mixins."
  frontendInternal: true
  external: test/fasta/object_supertype_test.dart

StaticAndInstanceConflict:
  problemMessage: "This static member conflicts with an instance member."
  script:
    - |
      class C {
        set foo(value) {}
        static get foo => 42;
      }
    - |
      class C {
        static set foo(value) {}
        get foo => 42;
      }
  analyzerCode: CONFLICTING_STATIC_AND_INSTANCE

StaticAndInstanceConflictCause:
  problemMessage: "This is the instance member."
  severity: CONTEXT

InstanceAndSynthesizedStaticConflict:
  problemMessage: "This instance member conflicts with the synthesized static member called '#name'."
  analyzerCode: CONFLICTING_STATIC_AND_INSTANCE

FfiAbiSpecificIntegerInvalid:
  # Used by dart:ffi
  problemMessage: "Classes extending 'AbiSpecificInteger' must have exactly one const constructor, no other members, and no type arguments."
  external: test/ffi_test.dart

FfiAbiSpecificIntegerMappingInvalid:
  # Used by dart:ffi
  problemMessage: "Classes extending 'AbiSpecificInteger' must have exactly one 'AbiSpecificIntegerMapping' annotation specifying the mapping from ABI to a NativeType integer with a fixed size."
  external: test/ffi_test.dart

FfiCreateOfStructOrUnion:
  # Used by dart:ffi
  problemMessage: "Subclasses of 'Struct' and 'Union' are backed by native memory, and can't be instantiated by a generative constructor. Try allocating it via allocation, or load from a 'Pointer'."
  external: test/ffi_test.dart

FfiTypeMismatch:
  # Used by dart:ffi
  problemMessage: "Expected type '#type' to be '#type2', which is the Dart type corresponding to '#type3'."
  external: test/ffi_test.dart

FfiEmptyStruct:
  # Used by dart:ffi
  problemMessage: "#string '#name' is empty. Empty structs and unions are undefined behavior."
  external: test/ffi_test.dart

FfiTypeInvalid:
  # Used by dart:ffi
  problemMessage: "Expected type '#type' to be a valid and instantiated subtype of 'NativeType'."
  external: test/ffi_test.dart

FfiFieldNull:
  # Used by dart:ffi
  problemMessage: "Field '#name' cannot be nullable or have type 'Null', it must be `int`, `double`, `Pointer`, or a subtype of `Struct` or `Union`."
  external: test/ffi_test.dart

FfiFieldAnnotation:
  # Used by dart:ffi
  problemMessage: "Field '#name' requires exactly one annotation to declare its native type, which cannot be Void. dart:ffi Structs and Unions cannot have regular Dart fields."
  external: test/ffi_test.dart

FfiFieldNoAnnotation:
  # Used by dart:ffi
  problemMessage: "Field '#name' requires no annotation to declare its native type, it is a Pointer which is represented by the same type in Dart and native code."
  external: test/ffi_test.dart

FfiFieldCyclic:
  # Used by dart:ffi
  problemMessage: |
    #string '#name' contains itself. Cycle elements:
    #names
  external: test/ffi_test.dart

FfiNotStatic:
  # Used by dart:ffi
  problemMessage: "#name expects a static function as parameter. dart:ffi only supports calling static Dart functions from native code. Closures and tear-offs are not supported because they can capture context."
  external: test/ffi_test.dart

FfiFieldInitializer:
  # Used by dart:ffi
  problemMessage: "Field '#name' is a dart:ffi Pointer to a struct field and therefore cannot be initialized before constructor execution."
  correctionMessage: "Mark the field as external to avoid having to initialize it."
  external: test/ffi_test.dart

FfiExtendsOrImplementsSealedClass:
  # Used by dart:ffi
  problemMessage: "Class '#name' cannot be extended or implemented."
  external: test/ffi_test.dart

FfiPackedAnnotation:
  # Used by dart:ffi
  problemMessage: "Struct '#name' must have at most one 'Packed' annotation."
  external: test/ffi_test.dart

FfiPackedAnnotationAlignment:
  # Used by dart:ffi
  problemMessage: "Only packing to 1, 2, 4, 8, and 16 bytes is supported."
  external: test/ffi_test.dart

FfiSizeAnnotation:
  # Used by dart:ffi
  problemMessage: "Field '#name' must have exactly one 'Array' annotation."
  external: test/ffi_test.dart

FfiSizeAnnotationDimensions:
  # Used by dart:ffi
  problemMessage: "Field '#name' must have an 'Array' annotation that matches the dimensions."
  external: test/ffi_test.dart

FfiStructGeneric:
  # Used by dart:ffi
  problemMessage: "#string '#name' should not be generic."
  external: test/ffi_test.dart

FfiCompoundImplementsFinalizable:
  # Used by dart:ffi
  problemMessage: "#string '#name' can't implement Finalizable."
  correctionMessage: "Try removing the implements clause from '#name'."
  external: test/ffi_test.dart

FfiDartTypeMismatch:
  # Used by dart:ffi
  problemMessage: "Expected '#type' to be a subtype of '#type2'."
  external: test/ffi_test.dart

FfiExpectedExceptionalReturn:
  # Used by dart:ffi
  problemMessage: "Expected an exceptional return value for a native callback returning '#type'."
  external: test/ffi_test.dart

FfiExpectedNoExceptionalReturn:
  # Used by dart:ffi
  problemMessage: "Exceptional return value cannot be provided for a native callback returning '#type'."
  external: test/ffi_test.dart

FfiExpectedConstant:
  # Used by dart:ffi
  problemMessage: "Exceptional return value must be a constant."
  external: test/ffi_test.dart

FfiExceptionalReturnNull:
  # Used by dart:ffi
  problemMessage: "Exceptional return value must not be null."
  external: test/ffi_test.dart

FfiExpectedConstantArg:
  # Used by dart:ffi
  problemMessage: "Argument '#name' must be a constant."
  external: test/ffi_test.dart

FfiLeafCallMustNotTakeHandle:
  # Used by dart:ffi
  problemMessage: "FFI leaf call must not have Handle argument types."
  external: test/ffi_test.dart

FfiLeafCallMustNotReturnHandle:
  # Used by dart:ffi
  problemMessage: "FFI leaf call must not have Handle return type."
  external: test/ffi_test.dart

FfiNativeUnexpectedNumberOfParametersWithReceiver:
  # Used by dart:ffi
  problemMessage: "Unexpected number of FfiNative annotation parameters. Expected #count but has #count2. FfiNative instance method annotation must have receiver as first argument."
  external: test/ffi_test.dart

FfiNativeUnexpectedNumberOfParameters:
  # Used by dart:ffi
  problemMessage: "Unexpected number of FfiNative annotation parameters. Expected #count but has #count2."
  external: test/ffi_test.dart

FfiNativeOnlyNativeFieldWrapperClassCanBePointer:
  # Used by dart:ffi
  problemMessage: "Only classes extending NativeFieldWrapperClass1 can be passed as Pointer."
  external: test/ffi_test.dart

FfiNativeMustBeExternal:
  # Used by dart:ffi
  problemMessage: "FfiNative functions must be marked external."
  external: test/ffi_test.dart

SpreadTypeMismatch:
  problemMessage: "Unexpected type '#type' of a spread.  Expected 'dynamic' or an Iterable."
  script:
    - |
      main() {
        int a = 42;
        var b = [...a];
      }
    - |
      main() {
        int Function() a = () => 42;
        var b = [...a];
      }

CantHaveNamedParameters:
  # Used by dart:ffi
  problemMessage: "'#name' can't be declared with named parameters."
  external: test/ffi_test.dart

CantHaveOptionalParameters:
  # Used by dart:ffi
  problemMessage: "'#name' can't be declared with optional parameters."
  external: test/ffi_test.dart

SpreadElementTypeMismatch:
  problemMessage: "Can't assign spread elements of type '#type' to collection elements of type '#type2'."
  analyzerCode: LIST_ELEMENT_TYPE_NOT_ASSIGNABLE
  script: >
    main() {
      List<String> a = <String>["foo"];
      List<int> b = <int>[...a];
    }

SpreadElementTypeMismatchNullability:
  problemMessage: "Can't assign spread elements of type '#type' to collection elements of type '#type2' because '#type' is nullable and '#type2' isn't."
  analyzerCode: LIST_ELEMENT_TYPE_NOT_ASSIGNABLE
  configuration: nnbd-strong
  script: >
    main() {
      List<int?> a = <int?>[0, null];
      List<int> b = <int>[...a];
    }

SpreadElementTypeMismatchPartNullability:
  problemMessage: "Can't assign spread elements of type '#type' to collection elements of type '#type2' because '#type3' is nullable and '#type4' isn't."
  analyzerCode: LIST_ELEMENT_TYPE_NOT_ASSIGNABLE
  configuration: nnbd-strong
  script: >
    main() {
      List<List<int?>> a = <List<int?>>[[0, null]];
      List<List<int>> b = <List<int>>[...a];
    }

SpreadMapEntryTypeMismatch:
  problemMessage: "Unexpected type '#type' of a map spread entry.  Expected 'dynamic' or a Map."
  script:
    - |
      main() {
        int a = 42;
        var b = <dynamic, dynamic>{...a};
      }
    - |
      main() {
        int Function() a = () => 42;
        var b = <dynamic, dynamic>{...a};
      }

SpreadMapEntryElementKeyTypeMismatch:
  problemMessage: "Can't assign spread entry keys of type '#type' to map entry keys of type '#type2'."
  analyzerCode: MAP_KEY_TYPE_NOT_ASSIGNABLE
  script: >
    main() {
      Map<String, int> a = <String, int>{"foo": 42};
      Map<int, int> b = <int, int>{...a};
    }

SpreadMapEntryElementKeyTypeMismatchNullability:
  problemMessage: "Can't assign spread entry keys of type '#type' to map entry keys of type '#type2' because '#type' is nullable and '#type2' isn't."
  analyzerCode: MAP_KEY_TYPE_NOT_ASSIGNABLE
  configuration: nnbd-strong
  script: >
    main() {
      Map<String?, int> a = <String?, int>{"foo": 42, null: 87};
      Map<String, int> b = <String, int>{...a};
    }

SpreadMapEntryElementKeyTypeMismatchPartNullability:
  problemMessage: "Can't assign spread entry keys of type '#type' to map entry keys of type '#type2' because '#type3' is nullable and '#type4' isn't."
  analyzerCode: MAP_KEY_TYPE_NOT_ASSIGNABLE
  configuration: nnbd-strong
  script: >
    main() {
      Map<List<String?>, int> a = <List<String?>, int>{["foo"]: 42, [null]: 87};
      Map<List<String>, int> b = <List<String>, int>{...a};
    }

SpreadMapEntryElementValueTypeMismatch:
  problemMessage: "Can't assign spread entry values of type '#type' to map entry values of type '#type2'."
  analyzerCode: MAP_VALUE_TYPE_NOT_ASSIGNABLE
  script: >
    main() {
      Map<String, int> a = <String, int>{"foo": 42};
      Map<String, String> b = <String, String>{...a};
    }

SpreadMapEntryElementValueTypeMismatchNullability:
  problemMessage: "Can't assign spread entry values of type '#type' to map entry values of type '#type2' because '#type' is nullable and '#type2' isn't."
  analyzerCode: MAP_VALUE_TYPE_NOT_ASSIGNABLE
  configuration: nnbd-strong
  script: >
    main() {
      Map<String, int?> a = <String, int?>{"foo": 42, "bar": null};
      Map<String, int> b = <String, int>{...a};
    }

SpreadMapEntryElementValueTypeMismatchPartNullability:
  problemMessage: "Can't assign spread entry values of type '#type' to map entry values of type '#type2' because '#type3' is nullable and '#type4' isn't."
  analyzerCode: MAP_VALUE_TYPE_NOT_ASSIGNABLE
  configuration: nnbd-strong
  script: >
    main() {
      Map<String, List<int?>> a = <String, List<int?>>{"foo": [42], "bar": [null]};
      Map<String, List<int>> b = <String, List<int>>{...a};
    }

CantDisambiguateNotEnoughInformation:
  problemMessage: "Not enough type information to disambiguate between literal set and literal map."
  correctionMessage: "Try providing type arguments for the literal explicitly to disambiguate it."
  script: >
    foo(dynamic spread) {
      var a = {...spread};
    }

CantDisambiguateAmbiguousInformation:
  problemMessage: "Both Iterable and Map spread elements encountered in ambiguous literal."
  script: >
    foo(Iterable<int> iterableSpread, Map<int, int> mapSpread) {
      var c = {...iterableSpread, ...mapSpread};
    }

SpreadElement:
  problemMessage: "Iterable spread."
  severity: CONTEXT

SpreadMapElement:
  problemMessage: "Map spread."
  severity: CONTEXT

NonNullAwareSpreadIsNull:
  problemMessage: "Can't spread a value with static type '#type'."
  script: >
    main() {
      <int>[...null];
    }

NonPositiveArrayDimensions:
  # Used by dart:ffi
  problemMessage: "Array dimensions must be positive numbers."
  external: test/ffi_test.dart

InvalidTypeVariableInSupertype:
  problemMessage: "Can't use implicitly 'out' variable '#name' in an '#string2' position in supertype '#name2'."
  script: >
    class A<X> {}
    class B<Y> extends A<Function(Y)> {}

InvalidTypeVariableInSupertypeWithVariance:
  problemMessage: "Can't use '#string' type variable '#name' in an '#string2' position in supertype '#name2'."
  script: >
    class A<out X> {}
    class B<out Y> extends A<Function(Y)> {}

InvalidTypeVariableVariancePosition:
  problemMessage: "Can't use '#string' type variable '#name' in an '#string2' position."
  script: >
    class A<out T> {
      void method(T x) {}
    }

InvalidTypeVariableVariancePositionInReturnType:
  problemMessage: "Can't use '#string' type variable '#name' in an '#string2' position in the return type."
  script: >
    class A<in T> {
      T method() {
        return null;
      }
    }

CombinedMemberSignatureFailed:
  problemMessage: "Class '#name' inherits multiple members named '#name2' with incompatible signatures."
  correctionMessage: "Try adding a declaration of '#name2' to '#name'."
  analyzerCode: INCONSISTENT_INHERITANCE
  script:
    - |
      abstract class I1 {
        foo(x);
      }

      abstract class I2 {
        foo();
      }

      abstract class C implements I2, I1 {}

LanguageVersionTooHigh:
  problemMessage: "The specified language version is too high. The highest supported language version is #count.#count2."
  script: >
    // @dart = 100.200

LanguageVersionInvalidInDotPackages:
  problemMessage: "The language version is not specified correctly in the packages file."
  exampleAllowMoreCodes: true
  script:
    main.dart: "import 'package:foo/foo.dart';"
    lib/foo.dart: "// blah blah blah"
    .dart_tool/package_config.json: >
      {
          "configVersion": 2,
          "packages": [
              {
                  "name": "foo",
                  "rootUri": "../lib/",
                  "languageVersion": "arglebargle"
              }
          ]
      }

LanguageVersionMismatchInPart:
  problemMessage: "The language version override has to be the same in the library and its part(s)."
  script:
    main.dart: >
      // @dart = 2.4

      part 'part.dart';
    part.dart: >
      // @dart = 2.3

      part of 'main.dart';

LanguageVersionMismatchInPatch:
  problemMessage: "The language version override has to be the same in the library and its patch(es)."

LanguageVersionLibraryContext:
  problemMessage: "This is language version annotation in the library."
  severity: CONTEXT

LanguageVersionPartContext:
  problemMessage: "This is language version annotation in the part."
  severity: CONTEXT

LanguageVersionPatchContext:
  problemMessage: "This is language version annotation in the patch."
  severity: CONTEXT

ExplicitExtensionArgumentMismatch:
  problemMessage: "Explicit extension application requires exactly 1 positional argument."

ExplicitExtensionTypeArgumentMismatch:
  problemMessage: "Explicit extension application of extension '#name' takes '#count' type argument(s)."

ExplicitExtensionAsExpression:
  problemMessage: "Explicit extension application cannot be used as an expression."

ExplicitExtensionAsLvalue:
  problemMessage: "Explicit extension application cannot be a target for assignment."

DeferredExtensionImport:
  problemMessage: "Extension '#name' cannot be imported through a deferred import."
  correctionMessage: "Try adding the `hide #name` to the import."
  script:
    main.dart: "import 'lib.dart' deferred as prefix;"
    lib.dart: "extension Extension on void {}"

MultipleVarianceModifiers:
  index: 97
  problemMessage: "Each type parameter can have at most one variance modifier."
  correctionMessage: "Use at most one of the 'in', 'out', or 'inout' modifiers."
  analyzerCode: ParserErrorCode.MULTIPLE_VARIANCE_MODIFIERS

VariableCouldBeNullDueToWrite:
  problemMessage: "Variable '#name' could not be promoted due to an assignment."
  correctionMessage: "Try null checking the variable after the assignment.  See #string"

FieldNotPromoted:
  problemMessage: "'#name' refers to a property so it couldn't be promoted."
  correctionMessage: "See #string"

ThisNotPromoted:
  problemMessage: "'this' can't be promoted."
  correctionMessage: "See #string"

NullablePropertyAccessError:
  problemMessage: "Property '#name' cannot be accessed on '#type' because it is potentially null."
  correctionMessage: "Try accessing using ?. instead."

NullableMethodCallError:
  problemMessage: "Method '#name' cannot be called on '#type' because it is potentially null."
  correctionMessage: "Try calling using ?. instead."

NullableExpressionCallError:
  problemMessage: "Can't use an expression of type '#type' as a function because it's potentially null."
  correctionMessage: "Try calling using ?.call instead."

NullableOperatorCallError:
  problemMessage: "Operator '#name' cannot be called on '#type' because it is potentially null."

NullableTearoffError:
  problemMessage: "Can't tear off method '#name' from a potentially null value."

NullableSpreadError:
  problemMessage: "An expression whose value can be 'null' must be null-checked before it can be dereferenced."

ThrowingNotAssignableToObjectError:
  problemMessage: "Can't throw a value of '#type' since it is neither dynamic nor non-nullable."

RequiredNamedParameterHasDefaultValueError:
  problemMessage: "Named parameter '#name' is required and can't have a default value."

ValueForRequiredParameterNotProvidedError:
  problemMessage: "Required named parameter '#name' must be provided."

OptionalNonNullableWithoutInitializerError:
  problemMessage: "The parameter '#name' can't have a value of 'null' because of its type '#type', but the implicit default value is 'null'."
  correctionMessage: "Try adding either an explicit non-'null' default value or the 'required' modifier."
  analyzerCode: MISSING_DEFAULT_VALUE_FOR_PARAMETER
  configuration: nnbd-strong
  script:
    - method1({int a}) {}
    - method2([int a]) {}

FieldNonNullableWithoutInitializerError:
  problemMessage: "Field '#name' should be initialized because its type '#type' doesn't allow null."

FieldNonNullableNotInitializedByConstructorError:
  problemMessage: "This constructor should initialize field '#name' because its type '#type' doesn't allow null."

NullSafetyOptOutExplicit:
  problemMessage: "Null safety is disabled for this library."
  correctionMessage: "Try removing the `@dart=` annotation or setting the language version to #string or higher."

ExperimentOptOutExplicit:
  problemMessage: "The '#string' language feature is disabled for this library."
  correctionMessage: "Try removing the `@dart=` annotation or setting the language version to #string2 or higher."

NullSafetyOptOutImplicit:
  problemMessage: "Null safety is disabled for this library."
  correctionMessage: "Try removing the package language version or setting the language version to #string or higher."

NullSafetyOptOutComment:
  problemMessage: "This is the annotation that opts out this library from null safety features."
  severity: CONTEXT

ExperimentOptOutImplicit:
  problemMessage: "The '#string' language feature is disabled for this library."
  correctionMessage: "Try removing the package language version or setting the language version to #string2 or higher."

ExperimentOptOutComment:
  problemMessage: "This is the annotation that opts out this library from the '#string' language feature."
  severity: CONTEXT

AwaitInLateLocalInitializer:
  problemMessage: "`await` expressions are not supported in late local initializers."

NullableSuperclassError:
  problemMessage: "Can't extend '#name' because it's marked with '?'."

NullableInterfaceError:
  problemMessage: "Can't implement '#name' because it's marked with '?'."

NullableMixinError:
  problemMessage: "Can't mix '#name' in because it's marked with '?'."

JsInteropDartClassExtendsJSClass:
  problemMessage: "Dart class '#name' cannot extend JS interop class '#name2'."
  correctionMessage: "Try adding the JS interop annotation or removing it from the parent class."

JsInteropDartJsInteropAnnotationForStaticInteropOnly:
  problemMessage: "The '@JS' annotation from 'dart:js_interop' can only be used for static interop, either through inline classes or '@staticInterop'."
  correctionMessage: "Try making this class an inline class or marking it as '@staticInterop'."

JsInteropEnclosingClassJSAnnotation:
  problemMessage: "Member has a JS interop annotation but the enclosing class does not."
  correctionMessage: "Try adding the annotation to the enclosing class."

JsInteropEnclosingClassJSAnnotationContext:
  problemMessage: "This is the enclosing class."
  severity: CONTEXT

JsInteropExportClassNotMarkedExportable:
  problemMessage: "Class '#name' does not have a `@JSExport` on it or any of its members."
  correctionMessage: "Use the `@JSExport` annotation on this class."

JsInteropExportDartInterfaceHasNonEmptyJSExportValue:
  problemMessage: "The value in the `@JSExport` annotation on the class or mixin '#name' will be ignored."
  correctionMessage: "Remove the value in the annotation."
  severity: WARNING

JsInteropExportDisallowedMember:
  problemMessage: "Member '#name' is not a concrete instance member, and therefore can't be exported."
  correctionMessage: "Remove the `@JSExport` annotation from the member, and use an instance member to call this member instead."

JsInteropExportInvalidInteropTypeArgument:
  problemMessage: "Type argument '#type' needs to be a non-JS interop type."
  correctionMessage: "Use a non-JS interop class that uses `@JSExport` instead."

JsInteropExportInvalidTypeArgument:
  problemMessage: "Type argument '#type' needs to be an interface type."
  correctionMessage: "Use a non-JS interop class that uses `@JSExport` instead."

JsInteropExportMemberCollision:
  problemMessage: "The following class members collide with the same export '#name': #string."
  correctionMessage: "Either remove the conflicting members or use a different export name."

JsInteropExportNoExportableMembers:
  problemMessage: "Class '#name' has no exportable members in the class or the inheritance chain."
  correctionMessage: "Using `@JSExport`, annotate at least one instance member with a body or annotate a class that has such a member in the inheritance chain."

JsInteropExternalExtensionMemberOnTypeInvalid:
  problemMessage: "JS interop or Native class required for 'external' extension members."
  correctionMessage: "Try adding a JS interop annotation to the on type class of the extension."

JsInteropExternalExtensionMemberWithStaticDisallowed:
  problemMessage: "External extension members with the keyword 'static' on JS interop and @Native types are disallowed."
  correctionMessage: "Try putting the member in the on-type instead."

JsInteropExternalMemberNotJSAnnotated:
  problemMessage: "Only JS interop members may be 'external'."
  correctionMessage: "Try removing the 'external' keyword or adding a JS interop annotation."

JsInteropInlineClassUsedWithWrongJsAnnotation:
  problemMessage: "Inline classes should use the '@JS' annotation from 'dart:js_interop' and not from 'package:js'."
  correctionMessage: "Try using the '@JS' annotation from 'dart:js_interop' annotation on this inline class instead."

JsInteropInvalidStaticClassMemberName:
  problemMessage: "JS interop static class members cannot have '.' in their JS name."

JsInteropJSClassExtendsDartClass:
  problemMessage: "JS interop class '#name' cannot extend Dart class '#name2'."
  correctionMessage: "Try removing the JS interop annotation or adding it to the parent class."

JsInteropNamedParameters:
  problemMessage: "Named parameters for JS interop functions are only allowed in object literal constructors or @anonymous factories."
  correctionMessage: "Try replacing them with normal or optional parameters."

JsInteropNativeClassInAnnotation:
  problemMessage: "Non-static JS interop class '#name' conflicts with natively supported class '#name2' in '#string3'."
  correctionMessage: "Try replacing it with a static JS interop class using `@staticInterop` with extension methods, or use js_util to interact with the native object of type '#name2'."

JsInteropNonExternalConstructor:
  problemMessage: "JS interop classes do not support non-external constructors."
  correctionMessage: "Try annotating with `external`."

JsInteropNonExternalMember:
  problemMessage: "This JS interop member must be annotated with `external`. Only factories and static methods can be non-external."
  correctionMessage: "Try annotating the member with `external`."

JsInteropObjectLiteralConstructorPositionalParameters:
  problemMessage: "#string should not contain any positional parameters."
  correctionMessage: "Try replacing them with named parameters instead."

JsInteropOperatorCannotBeRenamed:
  problemMessage: "JS interop operator methods cannot be renamed using the '@JS' annotation."
  correctionMessage: "Remove the annotation or remove the value inside the annotation."

JsInteropOperatorsNotSupported:
  problemMessage: "JS interop classes do not support operator methods, with the exception of '[]' and '[]=' using static interop."
  correctionMessage: "Try replacing this with a normal method."

JsInteropNonStaticWithStaticInteropSupertype:
  problemMessage: "Class '#name' does not have an `@staticInterop` annotation, but has supertype '#name2', which does."
  correctionMessage: "Try marking '#name' as a `@staticInterop` class, or don't inherit '#name2'."

JsInteropStaticInteropExternalExtensionMembersWithTypeParameters:
  problemMessage: "`@staticInterop` classes cannot have external extension members with type parameters."
  correctionMessage: "Try using a Dart extension member if you need type parameters instead."

JsInteropStaticInteropGenerativeConstructor:
  problemMessage: "`@staticInterop` classes should not contain any generative constructors."
  correctionMessage: "Use factory constructors instead."

JsInteropStaticInteropMockMissingGetterOrSetter:
  problemMessage: "Dart class '#name' has a #string, but does not have a #string2 to implement any of the following extension member(s) with export name '#name2': #string3."
  correctionMessage: "Declare an exportable #string2 that implements one of these extension members."

JsInteropStaticInteropMockMissingImplements:
  problemMessage: "Dart class '#name' does not have any members that implement any of the following extension member(s) with export name '#name2': #string."
  correctionMessage: "Declare an exportable member that implements one of these extension members."

JsInteropStaticInteropMockNotStaticInteropType:
  problemMessage: "Type argument '#type' needs to be a `@staticInterop` type."
  correctionMessage: "Use a `@staticInterop` class instead."

JsInteropStaticInteropNoJSAnnotation:
  problemMessage: "`@staticInterop` classes should also have the `@JS` annotation."
  correctionMessage: "Add `@JS` to class '#name'."

JsInteropStaticInteropParameterInitializersAreIgnored:
  problemMessage: "Initializers for parameters are ignored on static interop external functions."
  correctionMessage: "Declare a forwarding non-external function with this initializer, or remove the initializer."
  severity: WARNING

JsInteropStaticInteropSyntheticConstructor:
  problemMessage: "Synthetic constructors on `@staticInterop` classes can not be used."
  correctionMessage: "Declare an external factory constructor for this `@staticInterop` class and use that instead."

JsInteropStaticInteropTearOffsDisallowed:
  problemMessage: "Tear-offs of external #string '#name' are disallowed."
  correctionMessage: "Declare a closure that calls this member instead."

JsInteropStaticInteropTrustTypesUsedWithoutStaticInterop:
  problemMessage: "JS interop class '#name' has an `@trustTypes` annotation, but no `@staticInterop` annotation."
  correctionMessage: "Try marking the class using `@staticInterop`."

JsInteropStaticInteropTrustTypesUsageNotAllowed:
  problemMessage: "JS interop class '#name' has an `@trustTypes` annotation, but `@trustTypes` is only supported within the sdk."
  correctionMessage: "Try removing the `@trustTypes` annotation."

JsInteropStaticInteropWithInstanceMembers:
  problemMessage: "JS interop class '#name' with `@staticInterop` annotation cannot declare instance members."
  correctionMessage: "Try moving the instance member to a static extension."

JsInteropStaticInteropWithNonStaticSupertype:
  problemMessage: "JS interop class '#name' has an `@staticInterop` annotation, but has supertype '#name2', which does not."
  correctionMessage: "Try marking the supertype as a static interop class using `@staticInterop`."

JsInteropStrictModeViolation:
  problemMessage: "JS interop requires JS types when strict mode is enabled, but Type '#type' is not a type or subtype of a type from `dart:js_interop`."
  correctionMessage: "Use a JS type instead."

JsInteropStrictModeForbiddenLibrary:
  problemMessage: "Library '#name' is forbidden when strict mode is enabled."
  correctionMessage: "Remove the import of a forbidden library."

JsInteropFunctionToJSRequiresStaticType:
  problemMessage: "`Function.toJS` requires a statically known function type, but Type '#type' is not a function type, e.g., `void Function()`."
  correctionMessage: "Insert an explicit cast to the expected function type."

NonNullableInNullAware:
  problemMessage: "Operand of null-aware operation '#name' has type '#type' which excludes null."
  severity: WARNING

ThisInNullAwareReceiver:
  problemMessage: "The receiver 'this' cannot be null."
  correctionMessage: "Try replacing '?.' with '.'"
  severity: WARNING
  configuration: nnbd-strong
  script: |
    class C {
      var field;
      method() {
        this?.field;
      }
    }

ClassInNullAwareReceiver:
  problemMessage: "The class '#name' cannot be null."
  correctionMessage: "Try replacing '?.' with '.'"
  severity: WARNING
  configuration: nnbd-strong
  script: |
    class C {
      static var field;
    }
    method() {
      C?.field;
    }

ExtensionInNullAwareReceiver:
  problemMessage: "The extension '#name' cannot be null."
  correctionMessage: "Try replacing '?.' with '.'"
  severity: WARNING
  configuration: nnbd-strong
  script: |
    extension E on int {
      static var field;
    }
    method() {
      E?.field;
    }

NonNullableNotAssignedError:
  problemMessage: "Non-nullable variable '#name' must be assigned before it can be used."
  configuration: nnbd-strong
  script: |
    method<T>() {
      T t; t;
    }

FinalNotAssignedError:
  problemMessage: "Final variable '#name' must be assigned before it can be used."
  analyzerCode: READ_POTENTIALLY_UNASSIGNED_FINAL
  configuration: nnbd-strong
  script: >
    method(bool b) {
      final int i;
      if (b) {
        i = 0;
      }
      i;
    }

LateDefinitelyUnassignedError:
  problemMessage: "Late variable '#name' without initializer is definitely unassigned."
  configuration: nnbd-strong
  script: |
    method<T>() {
      late T t; t;
    }

LateDefinitelyAssignedError:
  problemMessage: "Late final variable '#name' definitely assigned."
  configuration: nnbd-strong
  script: |
    method() {
      late final int t;
      t = 0;
      t = 0;
    }

FinalPossiblyAssignedError:
  problemMessage: "Final variable '#name' might already be assigned at this point."
  analyzerCode: ASSIGNMENT_TO_FINAL_LOCAL
  configuration: nnbd-strong
  script: |
    method() {
      final int i;
      i = 0;
      i = 0;
    }

NonAgnosticConstant:
  problemMessage: "Constant value is not strong/weak mode agnostic."

ExportOptOutFromOptIn:
  problemMessage: "Null safe libraries are not allowed to export declarations from of opt-out libraries."
  configuration: nnbd-weak
  script:
    main.dart: |
      export 'lib.dart';
    lib.dart: |
      // @dart=2.5
      class A {}

CannotAssignToFinalVariable:
  problemMessage: "Can't assign to the final variable '#name'."
  script: |
     main() {
       final int i = 0;
       i = 42;
     }

CannotAssignToConstVariable:
  problemMessage: "Can't assign to the const variable '#name'."
  script: |
    main() {
      const int i = 0;
      i = 42;
    }

CannotAssignToExtensionThis:
  problemMessage: "Can't assign to 'this'."
  script: |
    extension E on String {
      method() {
        this = "";
      }
    }

CannotAssignToTypeLiteral:
  problemMessage: "Can't assign to a type literal."
  script: |
    main() {
      Object = String;
    }

NonVoidReturnOperator:
  problemMessage: "The return type of the operator []= must be 'void'."
  correctionMessage: "Try changing the return type to 'void'."
  analyzerCode: NON_VOID_RETURN_FOR_OPERATOR
  script:
    - class Class { int operator[]=(a, b) {} }
    - class Class { dynamic operator[]=(a, b) {} }

NonVoidReturnSetter:
  problemMessage: "The return type of the setter must be 'void' or absent."
  correctionMessage: "Try removing the return type, or define a method rather than a setter."
  analyzerCode: NON_VOID_RETURN_FOR_SETTER
  script:
    - int set setter(_) {}
    - dynamic set setter(_) {}

NeverReachableSwitchDefaultError:
  problemMessage: "`null` encountered as case in a switch expression with a non-nullable enum type."

NeverReachableSwitchDefaultWarning:
  problemMessage: "The default case is not reachable with sound null safety because the switch expression is non-nullable."
  severity: WARNING

NeverReachableSwitchExpressionError:
  problemMessage: "`null` encountered as case in a switch expression with a non-nullable type."

NeverReachableSwitchStatementError:
  problemMessage: "`null` encountered as case in a switch statement with a non-nullable type."

NeverValueError:
  problemMessage: "`null` encountered as the result from expression with type `Never`."

NeverValueWarning:
  problemMessage: "The expression can not result in a value with sound null safety because the expression type is `Never`."
  severity: WARNING

MainNotFunctionDeclaration:
  problemMessage: "The 'main' declaration must be a function declaration."
  configuration: nnbd-strong
  script:
    - var main;

MainNotFunctionDeclarationExported:
  problemMessage: "The exported 'main' declaration must be a function declaration."
  configuration: nnbd-strong
  exampleAllowMoreCodes: true
  script:
    main.dart:
      export 'lib.dart';
    lib.dart:
      var main;

MainTooManyRequiredParameters:
  problemMessage: "The 'main' method must have at most 2 required parameters."
  configuration: nnbd-strong
  script:
    - main(a, b, c) {}

MainTooManyRequiredParametersExported:
  problemMessage: "The exported 'main' method must have at most 2 required parameters."
  configuration: nnbd-strong
  exampleAllowMoreCodes: true
  script:
    main.dart:
      export 'lib.dart';
    lib.dart:
      main(a, b, c) {}

MainRequiredNamedParameters:
  problemMessage: "The 'main' method cannot have required named parameters."
  configuration: nnbd-strong
  script:
    - main({required a}) {}

MainRequiredNamedParametersExported:
  problemMessage: "The exported 'main' method cannot have required named parameters."
  configuration: nnbd-strong
  exampleAllowMoreCodes: true
  script:
    main.dart:
      export 'lib.dart';
    lib.dart:
      main({required a}) {}

MainWrongParameterType:
  problemMessage: "The type '#type' of the first parameter of the 'main' method is not a supertype of '#type2'."
  configuration: nnbd-strong
  script:
    - main(Set<String> args) {}

MainWrongParameterTypeExported:
  problemMessage: "The type '#type' of the first parameter of the exported 'main' method is not a supertype of '#type2'."
  configuration: nnbd-strong
  exampleAllowMoreCodes: true
  script:
    main.dart:
      export 'lib.dart';
    lib.dart:
      main(Set<String> args) {}

ExportedMain:
  problemMessage: "This is exported 'main' declaration."
  severity: CONTEXT

UnexpectedModifierInNonNnbd:
  problemMessage: "The modifier '#lexeme' is only available in null safe libraries."
  exampleAllowMoreCodes: true
  analyzerCode: UNEXPECTED_TOKEN
  script: |
    // @dart=2.9
    late int x;

CompilingWithoutSoundNullSafety:
  problemMessage: "Compiling without sound null safety!\nDart 3 will only support sound null safety, see https://dart.dev/null-safety"
  configuration: nnbd-weak,compile
  severity: INFO
  script: |
    // @dart=2.9
    main() {}

UnsupportedDartExt:
  problemMessage: "Dart native extensions are no longer supported."
  correctionMessage: "Migrate to using FFI instead (https://dart.dev/guides/libraries/c-interop)"
  script: |
    import 'dart-ext:foo.dart';

InstantiationNonGenericFunctionType:
  problemMessage: "The static type of the explicit instantiation operand must be a generic function type but is '#type'."
  correctionMessage: "Try changing the operand or remove the type arguments."
  experiments: constructor-tearoffs
  script: |
    f() {}
    main() => f<int>;

InstantiationNullableGenericFunctionType:
  problemMessage: "The static type of the explicit instantiation operand must be a non-null generic function type but is '#type'."
  correctionMessage: "Try changing the operand or remove the type arguments."
  analyzerCode: DISALLOWED_TYPE_INSTANTIATION_EXPRESSION
  experiments: constructor-tearoffs
  script: |
    test(void Function<T>()? f) => f<int>;

InstantiationTooFewArguments:
  problemMessage: "Too few type arguments: #count required, #count2 given."
  correctionMessage: "Try adding the missing type arguments."
  experiments: constructor-tearoffs
  script: |
    f<X, Y>() {}
    main() => f<int>;

InstantiationTooManyArguments:
  problemMessage: "Too many type arguments: #count allowed, but #count2 found."
  correctionMessage: "Try removing the extra type arguments."
  experiments: constructor-tearoffs
  script: |
    f<X>() {}
    main() => f<int, String>;

AbstractClassConstructorTearOff:
  problemMessage: "Constructors on abstract classes can't be torn off."
  experiments: constructor-tearoffs
  script: |
    abstract class Class {}
    main() => Class.new;

StaticTearOffFromInstantiatedClass:
  problemMessage: "Cannot access static member on an instantiated generic class."
  correctionMessage: "Try removing the type arguments or placing them after the member name."
  experiments: constructor-tearoffs
  script: |
    class A<X> { static f() {} }
    main() => A<int>.f;


ConstructorTearOffWithTypeArguments:
  problemMessage: "A constructor tear-off can't have type arguments after the constructor name."
  correctionMessage: "Try removing the type arguments or placing them after the class name."
  experiments: constructor-tearoffs
  script:
    - "class C<X> { C.foo(); } bar() { C.foo<int>; }"

NewAsSelector:
  problemMessage: "'new' can only be used as a constructor reference."
  experiments: constructor-tearoffs
  script: |
    method(dynamic d) => d.new;

EnumDeclaresConstFactory:
  problemMessage: "Enums can't declare const factory constructors."
  correctionMessage: "Try removing the factory constructor declaration."

PositionalSuperParametersAndArguments:
  problemMessage: "Positional super-initializer parameters cannot be used when the super initializer has positional arguments."

SuperInitializerParameter:
  problemMessage: "This is the super-initializer parameter."
  severity: CONTEXT

EnumSupertypeOfNonAbstractClass:
  problemMessage: "Non-abstract class '#name' has 'Enum' as a superinterface."

EnumNonConstConstructor:
  problemMessage: "Generative enum constructors must be marked as 'const'."

EnumConstructorSuperInitializer:
  problemMessage: "Enum constructors can't contain super-initializers."

EnumConstructorTearoff:
  problemMessage: "Enum constructors can't be torn off."

EnumFactoryRedirectsToConstructor:
  problemMessage: "Enum factory constructors can't redirect to generative constructors."

EnumContainsValuesDeclaration:
  problemMessage: "An enum can't declare a member named 'values'."

EnumImplementerContainsValuesDeclaration:
  problemMessage: "'#name' has 'Enum' as a superinterface and can't contain non-static member with name 'values'."

EnumInheritsRestricted:
  problemMessage: "An enum can't inherit a member named '#name'."

EnumInheritsRestrictedMember:
  problemMessage: "This is the inherited member"
  severity: CONTEXT

MacroClassNotDeclaredMacro:
  problemMessage: "Non-abstract class '#name' implements 'Macro' but isn't declared as a macro class."
  correctionMessage: "Try adding the 'macro' class modifier."

UnmatchedAugmentationClassMember:
  problemMessage: "Augmentation member '#name' doesn't match a member in the augmented class."
  correctionMessage: "Try changing the name to an existing member or removing the 'augment' modifier."
  experiments: macros
  script:
    main.dart:
      import augment 'lib.dart';
      class Class {}
    lib.dart:
      augment class Class {
        augment void method() {}
      }

UnmatchedAugmentationLibraryMember:
  problemMessage: "Augmentation member '#name' doesn't match a member in the augmented library."
  correctionMessage: "Try changing the name to an existing member or removing the 'augment' modifier."
  experiments: macros
  script:
    main.dart:
      import augment 'lib.dart';
    lib.dart:
      augment void method() {}

UnmatchedAugmentationClass:
  problemMessage: "Augmentation class '#name' doesn't match a class in the augmented library."
  correctionMessage: "Try changing the name to an existing class or removing the 'augment' modifier."
  experiments: macros
  script:
    main.dart:
      import augment 'lib.dart';
    lib.dart:
      augment class Class {}

UnmatchedAugmentationDeclaration:
  problemMessage: "Augmentation '#name' doesn't match a declaration in the augmented library."
  correctionMessage: "Try changing the name to an existing declaration or removing the 'augment' modifier."
  experiments: macros

UnmatchedAugmentationConstructor:
  problemMessage: "Augmentation constructor '#name' doesn't match a constructor in the augmented class."
  correctionMessage: "Try changing the name to an existing constructor or removing the 'augment' modifier."
  experiments: macros
  script:
    main.dart:
      import augment 'lib.dart';
      class Class {
        Class.name1();
      }
    lib.dart:
      augment class Class {
        augment Class.name2();
      }


NonAugmentationClassMemberConflict:
  problemMessage: "Member '#name' conflicts with an existing member of the same name in the augmented class."
  correctionMessage: "Try changing the name of the member or adding an 'augment' modifier."
  experiments: macros
  script:
    main.dart:
      import augment 'lib.dart';
      class Class {
        void method() {}
      }
    lib.dart:
      augment class Class {
        void method() {}
      }

NonAugmentationLibraryMemberConflict:
  problemMessage: "Member '#name' conflicts with an existing member of the same name in the augmented library."
  correctionMessage: "Try changing the name of the member or adding an 'augment' modifier."
  experiments: macros
  script:
    main.dart:
      import augment 'lib.dart';
      void method() {}
    lib.dart:
      void method() {}

NonAugmentationLibraryConflict:
  problemMessage: "Declaration '#name' conflicts with an existing declaration of the same name in the augmented library."
  correctionMessage: "Try changing the name of the declaration."
  experiments: macros
  script:
    main.dart:
      import augment 'lib.dart';
      void method() {}
    lib.dart:
      class method {}

NonAugmentationClassConflict:
  problemMessage: "Class '#name' conflicts with an existing class of the same name in the augmented library."
  correctionMessage: "Try changing the name of the class or adding an 'augment' modifier."
  experiments: macros
  script:
    main.dart:
      import augment 'lib.dart';
      class Class {}
    lib.dart:
      class Class {}

NonAugmentationConstructorConflict:
  problemMessage: "Constructor '#name' conflicts with an existing constructor of the same name in the augmented class."
  correctionMessage: "Try changing the name of the constructor or adding an 'augment' modifier."
  experiments: macros
  script:
    main.dart:
      import augment 'lib.dart';
      class Class {
        Class.name();
      }
    lib.dart:
      augment class Class {
        Class.name();
      }

NonAugmentationMemberConflictCause:
  problemMessage: "This is the existing member."
  severity: CONTEXT

NonAugmentationClassConflictCause:
  problemMessage: "This is the existing class."
  severity: CONTEXT

NonAugmentationDeclarationConflictCause:
  problemMessage: "This is the existing declaration."
  severity: CONTEXT

NonAugmentationConstructorConflictCause:
  problemMessage: "This is the existing constructor."
  severity: CONTEXT

OptionalSuperParameterWithoutInitializer:
  problemMessage: "Type '#type' of the optional super-initializer parameter '#name' doesn't allow 'null', but the parameter doesn't have a default value, and the default value can't be copied from the corresponding parameter of the super constructor."

EnumContainsRestrictedInstanceDeclaration:
  problemMessage: "An enum can't declare a non-abstract member named '#name'."

EnumImplementerContainsRestrictedInstanceDeclaration:
  problemMessage: "'#name' has 'Enum' as a superinterface and can't contain non-static members with name '#name2'."

EnumAbstractMember:
  problemMessage: "Enums can't declare abstract members."

MixinInheritsFromNotObject:
  problemMessage: "The class '#name' can't be used as a mixin because it extends a class other than 'Object'."
  analyzerCode: MIXIN_INHERITS_FROM_NOT_OBJECT
  script: |
    // @dart=2.19
    class Base {}
    class Mixin extends Base {}
    class C extends Base with Mixin {}

MixinApplicationNoConcreteMethod:
  problemMessage: "The class doesn't have a concrete implementation of the super-invoked member '#name'."
  analyzerCode: MIXIN_APPLICATION_NO_CONCRETE_SUPER_INVOKED_MEMBER
  script: |
    class Super {
      void method() {}
    }
    mixin Mixin on Super {
      void method() {
        super.method();
      }
    }
    abstract class AbstractSuper implements Super {}
    class Class extends AbstractSuper with Mixin {}

MixinApplicationNoConcreteGetter:
  problemMessage: "The class doesn't have a concrete implementation of the super-accessed member '#name'."
  analyzerCode: MIXIN_APPLICATION_NO_CONCRETE_SUPER_INVOKED_MEMBER
  script: |
    class Super {
      int get getter => 42;
    }
    mixin Mixin on Super {
      int get getter {
        return super.getter;
      }
    }
    abstract class AbstractSuper implements Super {}
    class Class extends AbstractSuper with Mixin {}

MixinApplicationNoConcreteSetter:
  problemMessage: "The class doesn't have a concrete implementation of the super-accessed setter '#name'."
  analyzerCode: MIXIN_APPLICATION_NO_CONCRETE_SUPER_INVOKED_MEMBER
  script: |
    class Super {
      void set setter(int value) {}
    }
    mixin Mixin on Super {
      void set setter(int value) {
        super.setter = value;
      }
    }
    abstract class AbstractSuper implements Super {}
    class Class extends AbstractSuper with Mixin {}

MixinApplicationNoConcreteMemberContext:
  problemMessage: "This is the super-access that doesn't have a concrete target."
  severity: CONTEXT

NoAugmentSuperReadTarget:
  problemMessage: "Cannot read from 'augment super'."
  experiments: macros
  script:
    main.dart:
      import augment 'lib.dart';
      void set setter(value) {}
    lib.dart:
      augment void set setter(value) {
        augment super;
      }

NoAugmentSuperWriteTarget:
  problemMessage: "Cannot write to 'augment super'."
  experiments: macros
  script:
    main.dart:
      import augment 'lib.dart';
      void method() {}
    lib.dart:
      augment void method() {
        augment super = 42;
      }

NoAugmentSuperInvokeTarget:
  problemMessage: "Cannot call 'augment super'."
  experiments: macros
  script:
    main.dart:
      import augment 'lib.dart';
      void set setter(value) {}
    lib.dart:
      augment void set setter(value) {
        augment super();
      }

IndexOutOfBoundInRecordIndexGet:
  problemMessage: "Index #count is out of range 0..#count2 of positional fields of records #type."

NameNotFoundInRecordNameGet:
  problemMessage: "Field name #string isn't found in records of type #type."

ObjectMemberNameUsedForRecordField:
  problemMessage: "Record field names can't be the same as a member from 'Object'."

RecordFieldsCantBePrivate:
  problemMessage: "Record field names can't be private."
  analyzerCode: INVALID_FIELD_NAME
  experiments: records
  script: |
    foo() => (_bar: 1);

NamedFieldClashesWithPositionalFieldInRecord:
  problemMessage: "Record field names can't be a dollar sign followed by an integer when integer is the index of a positional field."
  analyzerCode: INVALID_FIELD_NAME
  experiments: records
  script: |
    foo() => (0, $1: 0);

EnumWithNameValues:
  problemMessage: "The name 'values' is not a valid name for an enum. Try using a different name."
  analyzerCode: ENUM_WITH_NAME_VALUES

InheritedRestrictedMemberOfEnumImplementer:
  problemMessage: "A concrete instance member named '#name' can't be inherited from '#name2' in a class that implements 'Enum'."
  analyzerCode: ILLEGAL_CONCRETE_ENUM_MEMBER
  script: |
    abstract class A { int get hashCode => 0; }
    abstract class B extends A implements Enum {}

SealedClassSubtypeOutsideOfLibrary:
  problemMessage: "The class '#name' can't be extended, implemented, or mixed in outside of its library because it's a sealed class."
  analyzerCode: SEALED_CLASS_SUBTYPE_OUTSIDE_OF_LIBRARY
  experiments: sealed-class
  script:
    main.dart:
      import 'lib.dart';
      class B extends A {}
    lib.dart:
      sealed class A {}

CantUseClassAsMixin:
  problemMessage: "The class '#name' can't be used as a mixin because it isn't a mixin class nor a mixin."
  analyzerCode: CLASS_USED_AS_MIXIN
  experiments: class-modifiers
  script:
    main.dart:
      import 'lib.dart';
      class B with A {}
    lib.dart:
      class A {}

BaseEnum:
  index: 155
  problemMessage: "Enums can't be declared to be 'base'."
  correctionMessage: "Try removing the keyword 'base'."
  analyzerCode: ParserErrorCode.BASE_ENUM
  experiments: class-modifiers
  script:
    - "base enum E { v }"

FinalEnum:
  index: 156
  problemMessage: "Enums can't be declared to be 'final'."
  correctionMessage: "Try removing the keyword 'final'."
  analyzerCode: ParserErrorCode.FINAL_ENUM
  experiments: class-modifiers
  script:
    - "final enum E { v }"

InterfaceEnum:
  index: 157
  problemMessage: "Enums can't be declared to be 'interface'."
  correctionMessage: "Try removing the keyword 'interface'."
  analyzerCode: ParserErrorCode.INTERFACE_ENUM
  experiments: class-modifiers
  script:
    - "interface enum E { v }"

SealedEnum:
  index: 158
  problemMessage: "Enums can't be declared to be 'sealed'."
  correctionMessage: "Try removing the keyword 'sealed'."
  analyzerCode: ParserErrorCode.SEALED_ENUM
  experiments: class-modifiers,sealed-class
  script:
    - "sealed enum E { v }"

FinalMixin:
  index: 146
  problemMessage: "A mixin can't be declared 'final'."
  correctionMessage: "Try removing the 'final' keyword."
  analyzerCode: ParserErrorCode.FINAL_MIXIN
  experiments: class-modifiers
  script:
    - "final mixin M {}"

InterfaceMixin:
  index: 147
  problemMessage: "A mixin can't be declared 'interface'."
  correctionMessage: "Try removing the 'interface' keyword."
  analyzerCode: ParserErrorCode.INTERFACE_MIXIN
  experiments: class-modifiers
  script:
    - "interface mixin M {}"

SealedMixin:
  index: 148
  problemMessage: "A mixin can't be declared 'sealed'."
  correctionMessage: "Try removing the 'sealed' keyword."
  analyzerCode: ParserErrorCode.SEALED_MIXIN
  experiments: class-modifiers,sealed-class
  script:
    - "sealed mixin M {}"

FinalMixinClass:
  index: 142
  problemMessage: "A mixin class can't be declared 'final'."
  correctionMessage: "Try removing the 'final' keyword."
  analyzerCode: ParserErrorCode.FINAL_MIXIN_CLASS
  experiments: class-modifiers
  script:
    - "final mixin class C {}"

InterfaceMixinClass:
  index: 143
  problemMessage: "A mixin class can't be declared 'interface'."
  correctionMessage: "Try removing the 'interface' keyword."
  analyzerCode: ParserErrorCode.INTERFACE_MIXIN_CLASS
  experiments: class-modifiers
  script:
    - "interface mixin class C {}"

SealedMixinClass:
  index: 144
  problemMessage: "A mixin class can't be declared 'sealed'."
  correctionMessage: "Try removing the 'sealed' keyword."
  analyzerCode: ParserErrorCode.SEALED_MIXIN_CLASS
  experiments: class-modifiers,sealed-class
  script:
    - "sealed mixin class C {}"

BaseClassImplementedOutsideOfLibrary:
  problemMessage: "The class '#name' can't be implemented outside of its library because it's a base class."
  analyzerCode: BASE_CLASS_IMPLEMENTED_OUTSIDE_OF_LIBRARY
  experiments: class-modifiers
  script:
    main.dart:
      import 'lib.dart';
      base class B implements A {}
    lib.dart:
      base class A {}

BaseOrFinalClassImplementedOutsideOfLibraryCause:
  problemMessage: "The type '#name' is a subtype of '#name2', and '#name2' is defined here."
  severity: CONTEXT

BaseMixinImplementedOutsideOfLibrary:
  problemMessage: "The mixin '#name' can't be implemented outside of its library because it's a base mixin."
  analyzerCode: BASE_MIXIN_IMPLEMENTED_OUTSIDE_OF_LIBRARY
  experiments: class-modifiers
  script:
    main.dart:
      import 'lib.dart';
      base class B implements A {}
    lib.dart:
      base mixin A {}

InterfaceClassExtendedOutsideOfLibrary:
  problemMessage: "The class '#name' can't be extended outside of its library because it's an interface class."
  analyzerCode: INTERFACE_CLASS_EXTENDED_OUTSIDE_OF_LIBRARY
  experiments: class-modifiers
  script:
    main.dart:
      import 'lib.dart';
      class B extends A {}
    lib.dart:
      interface class A {}

FinalClassExtendedOutsideOfLibrary:
  problemMessage: "The class '#name' can't be extended outside of its library because it's a final class."
  analyzerCode: FINAL_CLASS_EXTENDED_OUTSIDE_OF_LIBRARY
  experiments: class-modifiers
  script:
    main.dart:
      import 'lib.dart';
      final class B extends A {}
    lib.dart:
      final class A {}

FinalClassImplementedOutsideOfLibrary:
  problemMessage: "The class '#name' can't be implemented outside of its library because it's a final class."
  analyzerCode: FINAL_CLASS_IMPLEMENTED_OUTSIDE_OF_LIBRARY
  experiments: class-modifiers
  script:
    main.dart:
      import 'lib.dart';
      final class B implements A {}
    lib.dart:
      final class A {}

FinalClassUsedAsMixinConstraintOutsideOfLibrary:
  problemMessage: "The class '#name' can't be used as a mixin superclass constraint outside of its library because it's a final class."
  analyzerCode: FINAL_CLASS_USED_AS_MIXIN_CONSTRAINT_OUTSIDE_OF_LIBRARY
  experiments: class-modifiers
  script:
    main.dart:
      import 'lib.dart';
      base mixin B on A {}
    lib.dart:
      final class A {}

SubtypeOfBaseIsNotBaseFinalOrSealed:
  problemMessage: "The type '#name' must be 'base', 'final' or 'sealed' because the supertype '#name2' is 'base'."
  correctionMessage: "Try adding 'base', 'final', or 'sealed' to the type."
  analyzerCode: SUBTYPE_OF_BASE_IS_NOT_BASE_FINAL_OR_SEALED
  experiments: class-modifiers,sealed-class
  script: |
      base class A {}
      class B extends A {}

SubtypeOfFinalIsNotBaseFinalOrSealed:
  problemMessage: "The type '#name' must be 'base', 'final' or 'sealed' because the supertype '#name2' is 'final'."
  correctionMessage: "Try adding 'base', 'final', or 'sealed' to the type."
  analyzerCode: SUBTYPE_OF_FINAL_IS_NOT_BASE_FINAL_OR_SEALED
  experiments: class-modifiers,sealed-class
  script: |
      final class A {}
      class B extends A {}

UnspecifiedGetterNameInObjectPattern:
  problemMessage: "The getter name is not specified explicitly, and the pattern is not a variable. Try specifying the getter name explicitly, or using a variable pattern."
  experiments: patterns
  analyzerCode: MISSING_OBJECT_PATTERN_GETTER_NAME
  script: |
    abstract class A { int get foo;}
    test(dynamic x) { if (x case A(: 0)) {} }

JointPatternVariablesMismatch:
  problemMessage: "Variable pattern '#name' doesn't have the same type or finality in all cases."
  experiments: patterns
  script: |
    test(dynamic x) { switch (x) { case [int a]: case [double a] : return a; default: return null; } }

NonExhaustiveSwitchExpression:
  problemMessage: "The type '#type' is not exhaustively matched by the switch cases since it doesn't match '#string'."
  correctionMessage: "Try adding a wildcard pattern or cases that match '#string2'."
  analyzerCode: NON_EXHAUSTIVE_SWITCH_EXPRESSION
  experiments: patterns
  script: |
    enum Enum { a, b }
    String method(Enum e) => switch (e) {
        Enum.a => 'a',
      };

NonExhaustiveSwitchStatement:
  problemMessage: "The type '#type' is not exhaustively matched by the switch cases since it doesn't match '#string'."
  correctionMessage: "Try adding a default case or cases that match '#string2'."
  analyzerCode: NON_EXHAUSTIVE_SWITCH_STATEMENT
  experiments: patterns
  script: |
    enum Enum { a, b }
    method(Enum e) {
      switch (e) {
        case Enum.a:
          break;
      }
    }

UnreachableSwitchCase:
  problemMessage: "This case is covered by the previous cases."
  analyzerCode: UNREACHABLE_SWITCH_CASE
  severity: WARNING # TODO(johnniwinther): Should this be an error, warning or not emitted at all?
  experiments: patterns
  script: |
    enum Enum { a, b }
    method(Enum e) {
      switch (e) {
        case Enum.a:
          break;
        case Enum.b:
          break;
        case Enum.a:
          break;
      }
    }

PatternTypeMismatchInIrrefutableContext:
  problemMessage: "The matched value of type '#type' isn't assignable to the required type '#type2'."
  correctionMessage: "Try changing the required type of the pattern, or the matched value type."
  analyzerCode: PATTERN_TYPE_MISMATCH_IN_IRREFUTABLE_CONTEXT
  experiments: patterns
  script: |
    method(List<String> list) {
      var <int>[a] = list;
    }

DuplicatePatternAssignmentVariable:
  problemMessage: The variable '#name' is already assigned in this pattern.
  correctionMessage: Try renaming the variable.
  analyzerCode: DUPLICATE_PATTERN_ASSIGNMENT_VARIABLE
  experiments: patterns
  script: |
    method(List<String> list) {
      String a = '';
      [a, a] = list;
    }

DuplicatePatternAssignmentVariableContext:
  problemMessage: The first assigned variable pattern.
  severity: CONTEXT

DuplicateRecordPatternField:
  problemMessage: The field '#name' is already matched in this pattern.
  correctionMessage: Try removing the duplicate field.
  analyzerCode: DUPLICATE_RECORD_PATTERN_FIELD
  experiments: patterns
  script: |
    method(o) {
      switch (o) {
        case (field: 1, field: 2):
      }
    }

DuplicateRecordPatternFieldContext:
  problemMessage: The first field.
  severity: CONTEXT

DuplicateRestElementInPattern:
  problemMessage: At most one rest element is allowed in a list or map pattern.
  correctionMessage: Try removing the duplicate rest element.
  analyzerCode: DUPLICATE_REST_ELEMENT_IN_PATTERN
  experiments: patterns
  script: |
    method(o) {
      switch (o) {
        case [..., ...]:
      }
    }

DuplicateRestElementInPatternContext:
  problemMessage: The first rest element.
  severity: CONTEXT

RestPatternInMapPattern:
  problemMessage: "The '...' pattern can't appear in map patterns."
  experiments: patterns
  script: |
    test(dynamic x) { if (x case {1: 1, ...}) {} }

UnnecessaryNullAssertPattern:
  problemMessage: The null-assert pattern will have no effect because the matched type isn't nullable.
  correctionMessage: Try replacing the null-assert pattern with its nested pattern.
  analyzerCode: UNNECESSARY_NULL_ASSERT_PATTERN
  severity: WARNING
  experiments: patterns
  script: |
    method(List<int> list) {
      if (list case [var a!]) {}
    }

UnnecessaryNullCheckPattern:
  problemMessage: The null-check pattern will have no effect because the matched type isn't nullable.
  correctionMessage: Try replacing the null-check pattern with its nested pattern.
  analyzerCode: UNNECESSARY_NULL_CHECK_PATTERN
  comment: No parameters.
  severity: WARNING
  experiments: patterns
  script: |
    method(List<int> list) {
      if (list case [var a?]) {}
    }

NonBoolCondition:
  problemMessage: "Conditions must have a static type of 'bool'."
  correctionMessage: Try changing the condition.
  analyzerCode: NON_BOOL_CONDITION
  experiments: patterns
  script: |
    method(int i) {
      if (i case 5 when i) {}
    }

RefutablePatternInIrrefutableContext:
  problemMessage: Refutable patterns can't be used in an irrefutable context.
  correctionMessage: Try using an if-case, a 'switch' statement, or a 'switch' expression instead.
  analyzerCode: REFUTABLE_PATTERN_IN_IRREFUTABLE_CONTEXT
  experiments: patterns
  script: |
    method(int? x) {
      var (a?) = x;
    }

MissingVariablePattern:
  problemMessage: "Variable pattern '#name' is missing in this branch of the logical-or pattern."
  correctionMessage: "Try declaring this variable pattern in the branch."
  analyzerCode: MISSING_VARIABLE_PATTERN
  experiments: patterns
  script: |
    method(x) {
      if (x case [var a] || _) {}
    }

MapPatternTypeArgumentMismatch:
  problemMessage: "A map pattern requires exactly two type arguments."
  analyzerCode: EXPECTED_TWO_MAP_PATTERN_TYPE_ARGUMENTS
  experiments: patterns
  script: |
    method(x) {
      if (x case <int>{0: 0}) {}
    }

ListPatternTooManyTypeArguments:
  problemMessage: "A list pattern requires exactly one type argument."
  analyzerCode: EXPECTED_ONE_LIST_PATTERN_TYPE_ARGUMENTS
  experiments: patterns
  script: |
    method(x) {
      if (x case <int, int>[]) {}
    }

UnnamedObjectPatternField:
  problemMessage: "A pattern field in an object pattern must be named."
  correctionMessage: "Try adding a pattern name or ':' before the pattern."
  experiments: patterns
  script: |
    method(x) {
      if (x case int(5)) {}
    }

InvalidConstantPatternNegation:
  problemMessage: "Only negation of a numeric literal is supported as a constant pattern."
  correctionMessage: "Try wrapping the expression in 'const ( ... )'."
  experiments: patterns
  analyzerCode: ParserErrorCode.INVALID_CONSTANT_PATTERN_NEGATION
  index: 135
  script: |
    method(x) {
      const y = 5;
      if (x case -y) {}
    }

InvalidConstantPatternUnary:
  problemMessage: "The unary operator #name is not supported as a constant pattern."
  correctionMessage: "Try wrapping the expression in 'const ( ... )'."
  experiments: patterns
  analyzerCode: ParserErrorCode.INVALID_CONSTANT_PATTERN_UNARY
  index: 136
  script: |
    method(x) {
      const y = false;
      if (x case !y) {}
    }

InvalidConstantPatternDuplicateConst:
  problemMessage: "Duplicate 'const' keyword in constant expression."
  correctionMessage: "Try removing one of the 'const' keywords."
  analyzerCode: ParserErrorCode.INVALID_CONSTANT_PATTERN_DUPLICATE_CONST
  index: 137
  experiments: patterns
  script: |
    method(x) {
      if (x case const const []) {}
    }

InvalidConstantPatternEmptyRecordLiteral:
  problemMessage: "The empty record literal is not supported as a constant pattern."
  analyzerCode: ParserErrorCode.INVALID_CONSTANT_PATTERN_EMPTY_RECORD_LITERAL
  index: 138
  experiments: patterns,records
  script: |
    method(x) {
      if (x case const ()) {}
    }

InvalidConstantPatternGeneric:
  problemMessage: "This expression is not supported as a constant pattern."
  correctionMessage: "Try wrapping the expression in 'const ( ... )'."
  analyzerCode: ParserErrorCode.INVALID_CONSTANT_PATTERN_GENERIC
  index: 139
  experiments: patterns
  script: |
    method(x) {
      if (x case List<int>) {}
    }

InvalidConstantPatternConstPrefix:
  problemMessage: "The expression can't be prefixed by 'const' to form a constant pattern."
  correctionMessage: "Try wrapping the expression in 'const ( ... )' instead."
  analyzerCode: ParserErrorCode.INVALID_CONSTANT_CONST_PREFIX
  index: 140
  experiments: patterns
  script: |
    method(x) {
      if (x case const 1) {}
    }

InvalidConstantPatternBinary:
  problemMessage: "The binary operator #name is not supported as a constant pattern."
  correctionMessage: "Try wrapping the expression in 'const ( ... )'."
  analyzerCode: ParserErrorCode.INVALID_CONSTANT_PATTERN_BINARY
  index: 141
  experiments: patterns
  script: |
    method(x) {
      if (x case 1 + 2) {}
    }

PatternAssignmentDeclaresVariable:
  problemMessage: "Variable '#name' can't be declared in a pattern assignment."
  correctionMessage: "Try using a preexisting variable or changing the assignment to a pattern variable declaration."
  analyzerCode: ParserErrorCode.PATTERN_ASSIGNMENT_DECLARES_VARIABLE
  index: 145
  experiments: patterns
  script: |
    method(x) {
      var y;
      [y, var z] = x;
    }

PatternAssignmentNotLocalVariable:
  problemMessage: Only local variables or formal parameters can be used in pattern assignments.
  correctionMessage: Try assigning to a local variable.
  analyzerCode: PATTERN_ASSIGNMENT_NOT_LOCAL_VARIABLE
  experiments: patterns
  script: |
    var global;
    method(x) {
      [global] = x;
    }

VariablePatternKeywordInDeclarationContext:
  problemMessage: Variable patterns in declaration context can't specify 'var' or 'final' keyword.
  correctionMessage: Try removing the keyword.
  analyzerCode: ParserErrorCode.VARIABLE_PATTERN_KEYWORD_IN_DECLARATION_CONTEXT
  index: 149
  experiments: patterns
  comment: No parameters.
  hasPublishedDocs: true
  script: |
    void f((int, int) r) {
      var (var x, y) = r;
      print(x + y);
    }
  documentation: |-
    #### Description

    The analyzer produces this diagnostic when a variable pattern is used
    within a declaration context.

    #### Example

    The following code produces this diagnostic because the variable patterns
    in the record pattern are in a declaration context:

    ```dart
    void f((int, int) r) {
      var ([!var!] x, y) = r;
      print(x + y);
    }
    ```

    #### Common fixes

    Remove the `var` or `final` keyword(s) within the variable pattern:

    ```dart
    void f((int, int) r) {
      var (x, y) = r;
      print(x + y);
    }
    ```

IllegalPatternVariableName:
  problemMessage: The variable declared by a variable pattern can't be named '#lexeme'.
  correctionMessage: Choose a different name.
  analyzerCode: ParserErrorCode.ILLEGAL_PATTERN_VARIABLE_NAME
  index: 159
  experiments: patterns
  comment: |-
    Parameters:
    0: the illegal name
  script: |
    void f(x) {
      switch (x) {
        case var when:
      }
    }

IllegalPatternAssignmentVariableName:
  problemMessage: A variable assigned by a pattern assignment can't be named '#lexeme'.
  correctionMessage: Choose a different name.
  analyzerCode: ParserErrorCode.ILLEGAL_PATTERN_ASSIGNMENT_VARIABLE_NAME
  index: 160
  experiments: patterns
  comment: |-
    Parameters:
    0: the illegal name
  script: |
    void f(x) {
      dynamic when;
      (when) = x;
    }

IllegalPatternIdentifierName:
  problemMessage: A pattern can't refer to an identifier named '#lexeme'.
  correctionMessage: Match the identifier using '== #lexeme'.
  analyzerCode: ParserErrorCode.ILLEGAL_PATTERN_IDENTIFIER_NAME
  index: 161
  experiments: patterns
  comment: |-
    Parameters:
    0: the illegal name
  script: |
    void f(x) {
      const when = 0;
      switch (x) {
        case when:
      }
    }

InvalidInsideUnaryPattern:
  problemMessage: This pattern cannot appear inside a unary pattern (cast pattern, null check pattern, or null assert pattern) without parentheses.
  correctionMessage: Try combining into a single pattern if possible, or enclose the inner pattern in parentheses.
  analyzerCode: ParserErrorCode.INVALID_INSIDE_UNARY_PATTERN
  index: 150
  experiments: patterns
  comment: No parameters.
  script: |
    void f(x) {
      if (x case _ as int as num) {}
    }

LatePatternVariableDeclaration:
  problemMessage: A pattern variable declaration may not use the `late` keyword.
  correctionMessage: Try removing the keyword `late`.
  analyzerCode: ParserErrorCode.LATE_PATTERN_VARIABLE_DECLARATION
  index: 151
  experiments: patterns
  comment: No parameters.
  script: |
    void f(x) {
      late var (y, z) = x;
    }

PatternVariableDeclarationOutsideFunctionOrMethod:
  problemMessage: A pattern variable declaration may not appear outside a function or method.
  correctionMessage: Try declaring ordinary variables and assigning from within a function or method.
  analyzerCode: ParserErrorCode.PATTERN_VARIABLE_DECLARATION_OUTSIDE_FUNCTION_OR_METHOD
  index: 152
  experiments: patterns
  comment: No parameters.
  script: |
    class C {
      var (a, b) = (0, 1);
    }

DefaultInSwitchExpression:
  problemMessage: A switch expression may not use the `default` keyword.
  correctionMessage: Try replacing `default` with `_`.
  analyzerCode: ParserErrorCode.DEFAULT_IN_SWITCH_EXPRESSION
  index: 153
  experiments: patterns
  comment: No parameters.
  script: |
    void f(x) => switch (x) {
      1 => 'one',
      default => 'other'
    };

WeakReferenceNotStatic:
  problemMessage: "Weak reference pragma can be used on a static method only."

WeakReferenceNotOneArgument:
  problemMessage: "Weak reference should take one required positional argument."

WeakReferenceReturnTypeNotNullable:
  problemMessage: "Return type of a weak reference should be nullable."

WeakReferenceMismatchReturnAndArgumentTypes:
  problemMessage: "Return and argument types of a weak reference should match."

WeakReferenceTargetNotStaticTearoff:
  problemMessage: "The target of weak reference should be a tearoff of a static method."

WeakReferenceTargetHasParameters:
  problemMessage: "The target of weak reference should not take parameters."

ObsoleteColonForDefaultValue:
  problemMessage: "Using a colon as a separator before a default value is no longer supported."
  correctionMessage: "Try replacing the colon with an equal sign."
  script: |
    method({int x: 3}) {}

EqualKeysInMapPattern:
  problemMessage: Two keys in a map pattern can't be equal.
  correctionMessage: Change or remove the duplicate key.
  analyzerCode: EQUAL_KEYS_IN_MAP_PATTERN
  script: |
    method(o) {
      if (o case {1: 'foo', 1: 'bar'}) {}
    }

EqualKeysInMapPatternContext:
  problemMessage: This is the previous use of the same key.
  severity: CONTEXT

PatternMatchingError:
  problemMessage: "Pattern matching error"

EmptyMapPattern:
  problemMessage: A map pattern must have at least one entry.
  correctionMessage: Try replacing it with an object pattern 'Map()'.
  analyzerCode: EMPTY_MAP_PATTERN
  script: |
    method(Map m) => switch (m) {
        {} => 0,
        _ => 1,
      };

PatternVariableAssignmentInsideGuard:
  problemMessage: Pattern variables can't be assigned inside the guard of the enclosing guarded pattern.
  correctionMessage: Try assigning to a different variable.
  analyzerCode: PATTERN_VARIABLE_ASSIGNMENT_INSIDE_GUARD
  script: |
    method(o) => switch (o) {
      int i when (i = 5) > 0 => 0,
      _ => -1,
    };

JointPatternVariableNotInAll:
  problemMessage: "The variable '#name' is available in some, but not all cases that share this body."
  analyzerCode: INVALID_PATTERN_VARIABLE_IN_SHARED_CASE_SCOPE
  script: |
    test(x) { switch(x) { case var a: case < 0: case [var a]: return a; default: return null; } }

JointPatternVariableWithLabelDefault:
  problemMessage: "The variable '#name' is not available because there is a label or 'default' case."
  analyzerCode: INVALID_PATTERN_VARIABLE_IN_SHARED_CASE_SCOPE
  script: |
    test(x) { switch(x) { case var a: default: return a; } }
