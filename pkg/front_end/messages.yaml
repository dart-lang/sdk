# Copyright (c) 2017, the Dart project authors.  Please see the AUTHORS file
# for details. All rights reserved. Use of this source code is governed by a
# BSD-style license that can be found in the LICENSE file.

# Run
#
#     dart pkg/front_end/tool/generate_messages.dart
#
# to regenerate messages after having edited this file.
#
# If entries with 'analyzerCode', 'sharedName', or 'index' have been changed,
# run both
#
#     dart pkg/front_end/tool/generate_messages.dart
#     dart pkg/analyzer/tool/messages/generate.dart
#
# to regenerate analyzer messages.

# Each entry in this map corresponds to a diagnostic message. Ideally, each
# entry contains three parts:
#
# 1. A message template (problemMessage).
#
# 2. A suggestion for how to correct the problem (correctionMessage).
#
# 3. Examples that produce the message (one of expression, statement,
#    declaration, member, script, bytes or external). Note that 'external'
#    should be the path to an external test. The external test will not be run,
#    but the existence of the file will be verified.
#
#    Multiple scripts can start with a `// @dart=` annotation to enforce the
#    language version used for the example code.
#
# Note that it can be hard or impossible to write an example that only gives the
# specific error. To allow for this, one can specify
# "exampleAllowOtherCodes: true" which filters out every message with a
# different code, and just verifies we got exactly one message of the code in
# question (in addition to different codes).
#
# Note that it can be hard or impossible to write an example that gives the
# specified error exactly once. To allow for this, one can specify
# "exampleAllowMultipleReports: true" which allows for the wanted error to occur
# several times.
#
# If we should also look for the code in the context given on an error pass
# "includeErrorContext: true".
#
# To add examples to experimental features enable the experiment with
# "experiments: <experiment>"
#
# A message shouldn't indicate which kind of diagnostic it is, for example,
# warning or error. Tools are expected to prepend "Warning: ", or "Error: ",
# and should be allowed to change the kind of diagnostic without affecting the
# message. For example, an error might be turned into a warning by the tool.
#
# See the file [lib/src/base/diagnostics.md] for more details on how to write
# good diagnostic messages.
#
# A message used for internal errors should have key that starts with
# "InternalProblem". This way, UX review can prioritize it accordingly.
#
# Eventually, we'd like to have all diagnostics in one shared
# location. However, for now, the analyzer needs to translate error codes to
# its own format. To support this, an entry can contain an analyzer error code
# (analyzerCode).
#
# Long term, the analyzer and front-end need to share the same error codes. So
# eventually all error codes should have an `analyzerCode` field.
# Any error code with an `index` field and an `analyzerCode` field
# will be auto generated as an Analyzer error code.
# `index` field values should be unique, consecutive whole numbers starting with 1.
# If `index` is defined, then `analyzerCode` should be the fully formed
# name of the corresponding public Analyzer error const
# (e.g. ParserErrorCode.EQUALITY_CANNOT_BE_EQUALITY_OPERAND)
# which will be used when generating code in Analyzer for translating
# cfe error codes to Analyzer error codes.
# If `index` is ever removed, then a new entry needs to be added at
# `pkg\analyzer\messages.yaml` for that code and the biggest index can be replaced
# by the removed one.
# If `sharedName` is defined, the generated analyzer code will use this as the
# user-facing analyzer code instead of `analyzerCode`. Multiple messages can share
# the `sharedName`.
#
# Errors with an `index` can also optionally contain user-facing documentation
# for the problem (documentation), which dart.dev will extract,
# as well as internal documentation (comment), which will be included in
# the code generated for the analyzer.
#
# In some cases a message is internal to the frontend, and no meaningful
# analyzer code can be provided. In such cases set `frontendInternal: true`.
#
# ## Parameter Substitution in problemMessage and correctionMessage
#
# The fields `problemMessage` and `correctionMessage` are subject to parameter
# substitution. When the compiler reports a problem, it must also specify
# parameters to be substituted into the message.
#
# Parameters are declared using a map called `parameters`; each map key is of
# the form `TYPE NAME`, and each map value is a comment describing the
# parameter. Placeholders in the `problemMessage` and `correctionMessage`
# strings take the form `#NAME`.
#
# If a diagnostic takes no parameters, it must have an entry of the
# form `parameters: none`.
#
# The following TYPEs are supported:
#
# - `Character`: a Unicode character.
#
# - `Constant`: a Kernel constant.
#
# - `int`: an integer (typically a count).
#
# - `Name` a name string. Note that asserts check to make sure the
#   parameter is not empty. If the diagnostic needs to support an
#   empty name, use `NameOKEmpty` instead.
#
# - `NameOKEmpty`: a name string. Will use an "(unnamed)" default message if
#   the string is empty.
#
# - `Names`: A list of names (strings).
#
# - `Num`: a number (int or double). Formatting can be controlled
#   using a `%` in the placeholder: `#NAME%N.M` formats the number to
#   minimum width N with M fraction digits.
#
# - `String`: a string that isn't a name.  Note: as a rule of thumb,
#    avoid using this type. In particular, do not it for composing
#    error messages, see [diagnostics.md](
#    lib/src/base/diagnostics.md#avoid-composing-messages-programmatically).
#    Note that asserts check to make sure the parameter is not
#    empty. If the diagnostic needs to support an empty name, use
#    `StringOKEmpty` instead.
#
# - `StringOKEmpty`: a string (that isn't a name). Will use an
#    "(empty)" default message if the string is empty.
#
# - `Token`: a token. The token's `lexeme` property is used.
#
# - `Type`: a kernel type.
#
# - `Unicode`: a Unicode short identifier (U+xxxx). We use this to
#   represent code units or code points.
#
# - `Uri`: a URI.

AsciiControlCharacter:
  pseudoSharedCode: ILLEGAL_CHARACTER
  parameters:
    Unicode character: the unexpected control character.
  problemMessage: "The control character #character can only be used in strings and comments."
  expression: "\x1b 1"

ConstEvalStartingPoint:
  parameters: none
  problemMessage: "Constant evaluation error:"

ConstEvalContext:
  parameters: none
  problemMessage: "While analyzing:"
  severity: CONTEXT

ConstEvalDuplicateElement:
  parameters:
    Constant constant: undocumented
  problemMessage: "The element '#constant' conflicts with another existing element in the set."
  script: |
    const foo = {1, 1};
  includeErrorContext: true
  exampleAllowOtherCodes: true

ConstEvalDuplicateKey:
  parameters:
    Constant constant: undocumented
  problemMessage: "The key '#constant' conflicts with another existing key in the map."
  script: |
    const foo = {1: 2, 1: 3};
  includeErrorContext: true
  exampleAllowOtherCodes: true

ConstEvalElementImplementsEqual:
  parameters:
    Constant constant: undocumented
  problemMessage: "The element '#constant' does not have a primitive operator '=='."
  script: |
    //@dart=2.18
    const Set<dynamic> setWithNonPrimitiveEquals = {const WithEquals(42)};
    class WithEquals {
      final int i;
      const WithEquals(this.i);
      operator ==(Object o) {
        return o is WithEquals && (o as WithEquals).i == i;
      }
    }
  includeErrorContext: true
  exampleAllowOtherCodes: true

ConstEvalElementNotPrimitiveEquality:
  parameters:
    Constant constant: undocumented
  problemMessage: "The element '#constant' does not have a primitive equality."
  script: |
    const Set<dynamic> setWithNonPrimitiveEquals = {const WithEquals(42)};
    class WithEquals {
      final int i;
      const WithEquals(this.i);
      operator ==(Object o) {
        return o is WithEquals && (o as WithEquals).i == i;
      }
    }
  includeErrorContext: true
  exampleAllowOtherCodes: true

ConstEvalKeyImplementsEqual:
  parameters:
    Constant constant: undocumented
  problemMessage: "The key '#constant' does not have a primitive operator '=='."

ConstEvalKeyNotPrimitiveEquality:
  parameters:
    Constant constant: undocumented
  problemMessage: "The key '#constant' does not have a primitive equality."
  script: |
    const Map<dynamic, int> mapWithNonPrimitiveEqualsKey = {
      const WithEquals(42): 42
    };

    class WithEquals {
      final int i;
      const WithEquals(this.i);
      operator ==(Object o) {
        return o is WithEquals && (o as WithEquals).i == i;
      }
    }
  includeErrorContext: true
  exampleAllowOtherCodes: true

ConstEvalCaseImplementsEqual:
  parameters:
    Constant constant: undocumented
  problemMessage: "Case expression '#constant' does not have a primitive operator '=='."
  script: |
    // @dart=2.19
    bar(dynamic x) {
      switch (x) {
        case const D(): break;
        default:
      }
    }
    class D {
      const D();
      bool operator ==(dynamic other) => identical(this, other);
    }

ConstEvalInvalidType:
  parameters:
    Constant constant: undocumented
    Type type: undocumented
    Type type2: undocumented
  problemMessage: "Expected constant '#constant' to be of type '#type', but was of type '#type2'."
  script: |
    const Map foo = {...bar};
    const dynamic bar = "Hello";
  includeErrorContext: true
  exampleAllowOtherCodes: true

ConstEvalInvalidBinaryOperandType:
  parameters:
    StringOKEmpty stringOKEmpty: undocumented
    Constant constant: undocumented
    Type type: undocumented
    Type type2: undocumented
  problemMessage: "Binary operator '#stringOKEmpty' on '#constant' requires operand of type '#type', but was of type '#type2'."
  script: |
    const dynamic willBeDouble = const bool.fromEnvironment("foo") ? 42 : 42.42;
    const binaryOnDouble = willBeDouble << 2;
  includeErrorContext: true
  exampleAllowOtherCodes: true

ConstEvalInvalidEqualsOperandType:
  parameters:
    Constant constant: undocumented
    Type type: undocumented
  problemMessage: "Binary operator '==' requires receiver constant '#constant' of type 'Null', 'bool', 'int', 'double', or 'String', but was of type '#type'."
  script: |
    //@dart=2.18
    class Foo {
      const Foo();
    }
    const f = Foo();
    const b = f == f;
  includeErrorContext: true
  exampleAllowOtherCodes: true

ConstEvalEqualsOperandNotPrimitiveEquality:
  parameters:
    Constant constant: undocumented
    Type type: undocumented
  problemMessage: "Binary operator '==' requires receiver constant '#constant' of a type with primitive equality or type 'double', but was of type '#type'."
  script: |
    const FooWithHashCodeField fooWithHashCodeField1 = const FooWithHashCodeField(42);
    const FooWithHashCodeField fooWithHashCodeField2 = const FooWithHashCodeField(42);
    const bool fooWithHashCodeFieldEqual = fooWithHashCodeField1 == fooWithHashCodeField2;
    class FooWithHashCodeField {
      final int x;
      final int hashCode;
      const FooWithHashCodeField(int x) : this.x = x, this.hashCode = x * 42;
    }
  includeErrorContext: true
  exampleAllowOtherCodes: true

ConstEvalZeroDivisor:
  parameters:
    String string: undocumented
    String string2: undocumented
  problemMessage: "Binary operator '#string' on '#string2' requires non-zero divisor, but divisor was '0'."
  script: |
    const int i = 42 ~/ 0;
  includeErrorContext: true
  exampleAllowOtherCodes: true

ConstEvalNegativeShift:
  parameters:
    String string: undocumented
    String string2: undocumented
    String string3: undocumented
  problemMessage: "Binary operator '#string' on '#string2' requires non-negative operand, but was '#string3'."
  script: |
    const int foo = 42 >> -1;
  includeErrorContext: true
  exampleAllowOtherCodes: true

ConstEvalTruncateError:
  parameters:
    String string: undocumented
    String string2: undocumented
  problemMessage: "Binary operator '#string ~/ #string2' results is Infinity or NaN."
  script: |
    const double doubleNan = 0/0;
    const int doubleTruncateDivNaN = 84.2 ~/ doubleNan;
  includeErrorContext: true
  exampleAllowOtherCodes: true

ConstEvalNonNull:
  parameters: none
  problemMessage: "Constant expression must be non-null."
  experiments: const-functions
  script: |
    const int x = y!;
    const dynamic y = null;
  includeErrorContext: true
  exampleAllowOtherCodes: true

ConstEvalGetterNotFound:
  parameters:
    NameOKEmpty nameOKEmpty: undocumented
  problemMessage: "Variable get not found: '#nameOKEmpty'"

ConstEvalInvalidMethodInvocation:
  parameters:
    StringOKEmpty stringOKEmpty: undocumented
    Constant constant: undocumented
  problemMessage: "The method '#stringOKEmpty' can't be invoked on '#constant' in a constant expression."
  script: |
    const List<String> listConcat = ["Hello"] + ["World"];
  includeErrorContext: true
  exampleAllowOtherCodes: true

ConstEvalInvalidPropertyGet:
  parameters:
    StringOKEmpty stringOKEmpty: undocumented
    Constant constant: undocumented
  problemMessage: "The property '#stringOKEmpty' can't be accessed on '#constant' in a constant expression."

ConstEvalInvalidRecordIndexGet:
  parameters:
    StringOKEmpty stringOKEmpty: undocumented
    Constant constant: undocumented
  problemMessage: "The property '#stringOKEmpty' can't be accessed on '#constant' in a constant expression."

ConstEvalInvalidRecordNameGet:
  parameters:
    StringOKEmpty stringOKEmpty: undocumented
    Constant constant: undocumented
  problemMessage: "The property '#stringOKEmpty' can't be accessed on '#constant' in a constant expression."

ConstEvalInvalidStringInterpolationOperand:
  parameters:
    Constant constant: undocumented
  problemMessage: |
    The constant value '#constant' can't be used as part of a string interpolation in a constant expression.
    Only values of type 'null', 'bool', 'int', 'double', or 'String' can be used.
  script: |
    class Foo {
      const Foo();
    }
    const f = Foo();
    const bar = "hello $f";
  includeErrorContext: true
  exampleAllowOtherCodes: true

ConstEvalInvalidStaticInvocation:
  parameters:
    NameOKEmpty nameOKEmpty: undocumented
  problemMessage: "The invocation of '#nameOKEmpty' is not allowed in a constant expression."

ConstEvalInvalidSymbolName:
  parameters:
    Constant constant: undocumented
  problemMessage: "The symbol name must be a valid public Dart member name, public constructor name, or library name, optionally qualified, but was '#constant'."

ConstEvalFailedAssertion:
  parameters: none
  problemMessage: "This assertion failed."
  script: |
    class Foo {
      final int x;
      const Foo(this.x) : assert(x < 0);
    }
    const Foo foo = const Foo(42);
  includeErrorContext: true
  exampleAllowOtherCodes: true

ConstEvalFailedAssertionWithMessage:
  parameters:
    StringOKEmpty stringOKEmpty: undocumented
  problemMessage: "This assertion failed with message: #stringOKEmpty"
  script: |
    class Foo {
      final int x;
      const Foo(this.x) : assert(x < 0, "non-negative");
    }
    const Foo foo = const Foo(42);
  includeErrorContext: true
  exampleAllowOtherCodes: true

ConstEvalFailedAssertionWithNonStringMessage:
  parameters: none
  problemMessage: "This assertion failed with a non-String message."
  script: |
    class Foo {
      final int x;
      const Foo(this.x) : assert(x < 0, x);
    }
    const Foo foo = const Foo(42);
  includeErrorContext: true
  exampleAllowOtherCodes: true

ConstEvalNonConstantVariableGet:
  parameters:
    NameOKEmpty nameOKEmpty: undocumented
  problemMessage: "The variable '#nameOKEmpty' is not a constant, only constant expressions are allowed."

ConstEvalDeferredLibrary:
  parameters:
    NameOKEmpty nameOKEmpty: undocumented
  problemMessage: >
    '#nameOKEmpty' can't be used in a constant expression because it's marked as
    'deferred' which means it isn't available until loaded.
  correctionMessage: >
    Try moving the constant from the deferred library, or removing 'deferred'
    from the import.
  script:
    main.dart: |
      import "lib.dart" deferred as foo;
      void bar() => const [foo.c];
    lib.dart: |
      const c = const C();
      class C {
        const C();
      }
  includeErrorContext: true
  exampleAllowOtherCodes: true

ConstEvalCircularity:
  parameters: none
  problemMessage: "Constant expression depends on itself."
  script: |
    const foo = bar;
    const bar = foo;
  includeErrorContext: true
  exampleAllowOtherCodes: true

ConstEvalNullValue:
  parameters: none
  problemMessage: "Null value during constant evaluation."
  experiments: const-functions
  script: |
    const dynamic a = null;
    const dynamic b = a();
  includeErrorContext: true
  exampleAllowOtherCodes: true

ConstEvalNotListOrSetInSpread:
  parameters: none
  problemMessage: "Only lists and sets can be used in spreads in constant lists and sets."
  script: |
    import 'dart:collection';
    class CustomIterable extends IterableBase<String> {
      const CustomIterable();
      Iterator<String> get iterator => <String>[].iterator;
    }
    const List<String> barWithCustomIterableSpread1 = [
      ...const CustomIterable()
    ];
  includeErrorContext: true
  exampleAllowOtherCodes: true

ConstEvalNotMapInSpread:
  parameters: none
  problemMessage: "Only maps can be used in spreads in constant maps."
  script: |
    const Map<String, String> mapWithCustomMap1 = {...const CustomMap()};
    class CustomMap implements Map<String, String> {
      const CustomMap();

      @override
      Iterable<MapEntry<String, String>> get entries => [];

      @override
      String operator [](Object? key) => throw new UnimplementedError();

      @override
      void operator []=(String key, String value) => throw new UnimplementedError();

      @override
      Map<RK, RV> cast<RK, RV>() => throw new UnimplementedError();

      @override
      void clear() => throw new UnimplementedError();

      @override
      bool containsKey(Object? key) => throw new UnimplementedError();

      @override
      bool containsValue(Object? value) => throw new UnimplementedError();

      @override
      bool get isEmpty => throw new UnimplementedError();

      @override
      bool get isNotEmpty => throw new UnimplementedError();

      @override
      Iterable<String> get keys => throw new UnimplementedError();

      @override
      int get length => throw new UnimplementedError();

      @override
      String remove(Object? key) => throw new UnimplementedError();

      @override
      Iterable<String> get values => throw new UnimplementedError();

      @override
      void addAll(Map<String, String> other) => throw new UnimplementedError();

      @override
      void addEntries(Iterable<MapEntry<String, String>> newEntries) =>
          throw new UnimplementedError();

      @override
      void forEach(void f(String key, String value)) =>
          throw new UnimplementedError();

      @override
      String putIfAbsent(String key, String ifAbsent()) =>
          throw new UnimplementedError();

      @override
      void updateAll(String update(String key, String value)) =>
          throw new UnimplementedError();

      @override
      void removeWhere(bool predicate(String key, String value)) =>
          throw new UnimplementedError();

      String update(String key, String update(String value),
              {String ifAbsent()?}) =>
          throw new UnimplementedError();

      Map<K2, V2> map<K2, V2>(MapEntry<K2, V2> f(String key, String value)) =>
          throw new UnimplementedError();
    }
  includeErrorContext: true
  exampleAllowOtherCodes: true

ConstEvalExtension:
  parameters: none
  problemMessage: "Extension operations can't be used in constant expressions."
  experiments: const-functions
  script: |
    extension Foo on int {
      int x() => 42;
    }
    const bar = 1.x();
  includeErrorContext: true
  exampleAllowOtherCodes: true

ConstEvalExternalConstructor:
  parameters: none
  problemMessage: "External constructors can't be evaluated in constant expressions."
  script: |
    class Foo {
      external const Foo();
    }
    const bar = Foo();
  includeErrorContext: true
  exampleAllowOtherCodes: true

ConstEvalExternalFactory:
  parameters: none
  problemMessage: "External factory constructors can't be evaluated in constant expressions."
  script: |
    class Foo {
      external const factory Foo();
    }
    const bar = Foo();
  includeErrorContext: true
  exampleAllowOtherCodes: true

ConstEvalUnevaluated:
  parameters: none
  problemMessage: "Couldn't evaluate constant expression."

ConstEvalError:
  parameters:
    String string: undocumented
  problemMessage: "Error evaluating constant expression: #string"

ConstEvalUnhandledCoreException:
  parameters:
    StringOKEmpty stringOKEmpty: undocumented
  problemMessage: "Unhandled core exception: #stringOKEmpty"
  experiments: const-functions
  script: |
    const foo = [].single;
  includeErrorContext: true
  exampleAllowOtherCodes: true

ConstEvalUnhandledException:
  parameters:
    Constant constant: undocumented
  problemMessage: "Unhandled exception: #constant"
  experiments: const-functions
  script: |
    const foo = doThrow();
    int doThrow() => throw 42;
  includeErrorContext: true
  exampleAllowOtherCodes: true

NotConstantExpression:
  parameters:
    String string: undocumented
  problemMessage: "#string is not a constant expression."
  script: |
    void foo() {
      const x = new Map();
    }
  exampleAllowMultipleReports: true

NotAConstantExpression:
  parameters: none
  problemMessage: "Not a constant expression."
  script: |
    foo() {
      var a = 0;
      const b = a;
    }

MissingExplicitConst:
  parameters: none
  problemMessage: "Constant expression expected."
  correctionMessage: "Try inserting 'const'."
  script: |
    class A {
      final x;
      const A(): x = [];
    }

DynamicCallsAreNotAllowedInDynamicModule:
  parameters: none
  problemMessage: "Dynamic calls are not allowed in a dynamic module."

ConstructorShouldBeListedAsCallableInDynamicInterface:
  parameters:
    Name name: undocumented
  problemMessage: "Cannot invoke constructor '#name' from a dynamic module."
  correctionMessage: "Try removing the call or update the dynamic interface to list constructor '#name' as callable."

MemberShouldBeListedAsCallableInDynamicInterface:
  parameters:
    Name name: undocumented
  problemMessage: "Cannot invoke member '#name' from a dynamic module."
  correctionMessage: "Try removing the call or update the dynamic interface to list member '#name' as callable."

ExtensionTypeShouldBeListedAsCallableInDynamicInterface:
  parameters:
    Name name: undocumented
  problemMessage: "Cannot use extension type '#name' in a dynamic module."
  correctionMessage: "Try removing the reference to extension type '#name' or update the dynamic interface to list extension type '#name' as callable."

ClassShouldBeListedAsCallableInDynamicInterface:
  parameters:
    Name name: undocumented
  problemMessage: "Cannot use class '#name' in a dynamic module."
  correctionMessage: "Try removing the reference to class '#name' or update the dynamic interface to list class '#name' as callable."

ClassShouldBeListedAsExtendableInDynamicInterface:
  parameters:
    Name name: undocumented
  problemMessage: "Cannot extend, implement or mix-in class '#name' in a dynamic module."
  correctionMessage: "Try removing the reference to class '#name' or update the dynamic interface to list class '#name' as extendable."

MemberShouldBeListedAsCanBeOverriddenInDynamicInterface:
  parameters:
    Name name: undocumented
    Name name2: undocumented
  problemMessage: "Cannot override member '#name.#name2' in a dynamic module."
  correctionMessage: "Try removing the override or update the dynamic interface to list member '#name.#name2' as can-be-overridden."

NonAsciiIdentifier:
  pseudoSharedCode: ILLEGAL_CHARACTER
  parameters:
    Character character: undocumented
    Unicode unicode: undocumented
  problemMessage: "The non-ASCII character '#character' (#unicode) can't be used in identifiers, only in strings and comments."
  correctionMessage: "Try using an US-ASCII letter, a digit, '_' (an underscore), or '$' (a dollar sign)."
  expression: "Ã¥"
  exampleAllowOtherCodes: true

NonAsciiWhitespace:
  pseudoSharedCode: ILLEGAL_CHARACTER
  parameters:
    Unicode unicode: undocumented
  problemMessage: "The non-ASCII space character #unicode can only be used in strings and comments."
  expression: "\u2028 1"

Encoding:
  pseudoSharedCode: ENCODING
  parameters: none
  problemMessage: "Unable to decode bytes as UTF-8."
  bytes: [255]

ExperimentDisabled:
  parameters:
    String string: undocumented
  problemMessage: "This requires the '#string' language feature to be enabled."
  correctionMessage: "The feature is on by default but is currently disabled, maybe because the '--enable-experiment=no-#string' command line option is passed."

ExperimentDisabledInvalidLanguageVersion:
  parameters:
    String string: undocumented
    String string2: undocumented
  problemMessage: "This requires the '#string' language feature, which requires language version of #string2 or higher."

EmptyNamedParameterList:
  pseudoSharedCode: "MISSING_IDENTIFIER"
  parameters: none
  problemMessage: "Named parameter lists cannot be empty."
  correctionMessage: "Try adding a named parameter to the list."
  script: |
    foo({}) {}

    main() {
      foo();
    }

DuplicatedRecordTypeFieldName:
  parameters:
    Name name: undocumented
  problemMessage: "Duplicated record type field name '#name'."
  correctionMessage: "Try renaming or removing one of the named record type fields."
  script: |
    ({int a, String a}) record = throw '';

DuplicatedRecordTypeFieldNameContext:
  parameters:
    Name name: undocumented
  problemMessage: "This is the existing record type field named '#name'."
  severity: CONTEXT

DuplicatedRecordLiteralFieldName:
  parameters:
    Name name: undocumented
  problemMessage: "Duplicated record literal field name '#name'."
  correctionMessage: "Try renaming or removing one of the named record literal fields."
  script: |
    dynamic field = (a: 0, a: 1);

DuplicatedRecordLiteralFieldNameContext:
  parameters:
    Name name: undocumented
  problemMessage: "This is the existing record literal field named '#name'."
  severity: CONTEXT

EmptyOptionalParameterList:
  pseudoSharedCode: "MISSING_IDENTIFIER"
  parameters: none
  problemMessage: "Optional parameter lists cannot be empty."
  correctionMessage: "Try adding an optional parameter to the list."
  script: |
    foo([]) {}

    main() {
      foo();
    }

ExpectedBlockToSkip:
  parameters: none
  problemMessage: "Expected a function body or '=>'."
  # TODO(ahe): In some scenarios, we can suggest removing the 'static' keyword.
  correctionMessage: "Try adding {}."

ExpectedBody:
  pseudoSharedCode: MISSING_FUNCTION_BODY
  parameters: none
  problemMessage: "Expected a function body or '=>'."
  # TODO(ahe): In some scenarios, we can suggest removing the 'static' keyword.
  correctionMessage: "Try adding {}."
  script: "main();"

ExpectedButGot:
  # Also see ExpectedAfterButGot and ExpectedInstead
  pseudoSharedCode: EXPECTED_TOKEN
  parameters:
    String string: undocumented
  problemMessage: "Expected '#string' before this."
  # Consider the second example below: the parser expects a ')' before 'y', but
  # a ',' would also have worked. We don't have enough information to give a
  # good suggestion.
  exampleAllowOtherCodes: true
  script:
    - "main() => true ? 1;"
    - "main() => foo(x: 1 y: 2);"

ExpectedAfterButGot:
  # Also see ExpectedButGot and ExpectedInstead
  pseudoSharedCode: EXPECTED_TOKEN
  parameters:
    String string: undocumented
  problemMessage: "Expected '#string' after this."
  # This is an alternative to ExpectedButGot when it's better for the error to be
  # associated with the last consumed token rather than the token being parsed.
  # Doing so can make it cognitively easier for the user to understand and fix.
  #
  # For example, this is ok...
  #
  #    x = 7
  #    class Foo {
  #    ^^^^^
  #        Expected ';' before this
  #
  # but this is easier for the user...
  #
  #    x = 7
  #        ^
  #        Expected ';' after this
  #    class Foo {
  #
  script:
    - "main() { return true }"

ImplementsRepeated:
  parameters:
    Name name: undocumented
    int count: undocumented
  problemMessage: "'#name' can only be implemented once."
  correctionMessage: "Try removing #count of the occurrences."
  script:
    - >-
      abstract class I {}
      abstract class J {}
      class K implements I, J, I {}

ImplementsSuperClass:
  parameters:
    Name name: undocumented
  problemMessage: "'#name' can't be used in both 'extends' and 'implements' clauses."
  correctionMessage: "Try removing one of the occurrences."
  script:
    - >-
      abstract class A {}
      class C extends A implements A {}

MultipleImplements:
  pseudoSharedCode: MULTIPLE_IMPLEMENTS_CLAUSES
  parameters: none
  problemMessage: "Each class definition can have at most one implements clause."
  correctionMessage: "Try combining all of the implements clauses into a single clause."
  script: "class A implements B implements C, D {}"
  exampleAllowOtherCodes: true

ImplementsFutureOr:
  parameters: none
  problemMessage: "The type 'FutureOr' can't be used in an 'implements' clause."
  script: |
    import 'dart:async';
    class Foo implements FutureOr<String> {}

ExtendsNever:
  parameters: none
  problemMessage: "The type 'Never' can't be used in an 'extends' clause."
  script: |
    class Foo extends Never {}
  exampleAllowOtherCodes: true

ImplementsNever:
  parameters: none
  problemMessage: "The type 'Never' can't be used in an 'implements' clause."
  script:
    class Foo implements Never {}
  exampleAllowOtherCodes: true

ExpectedDeclaration:
  pseudoSharedCode: EXPECTED_EXECUTABLE
  parameters:
    Token lexeme: undocumented
  problemMessage: "Expected a declaration, but got '#lexeme'."
  script: |
    var get b, c;
  exampleAllowOtherCodes: true

ExpectedClassMember:
  pseudoSharedCode: EXPECTED_CLASS_MEMBER
  parameters:
    Token lexeme: undocumented
  problemMessage: "Expected a class member, but got '#lexeme'."
  script: |
    class Foo {
      Foo() : this.new = 42;
    }
  exampleAllowOtherCodes: true
  exampleAllowMultipleReports: true

ExpectedFunctionBody:
  pseudoSharedCode: MISSING_FUNCTION_BODY
  parameters:
    Token lexeme: undocumented
  problemMessage: "Expected a function body, but got '#lexeme'."
  script: |
    var get b, c;
  exampleAllowOtherCodes: true
  exampleAllowMultipleReports: true

ExpectedHexDigit:
  pseudoSharedCode: MISSING_HEX_DIGIT
  parameters: none
  problemMessage: "A hex digit (0-9 or A-F) must follow '0x'."
  # No tip, seems obvious from the error message.
  script: |
    main() {
      var i = 0x;
    }

ExpectedIdentifier:
  pseudoSharedCode: MISSING_IDENTIFIER
  parameters:
    Token lexeme: undocumented
  problemMessage: "Expected an identifier, but got '#lexeme'."
  correctionMessage: "Try inserting an identifier before '#lexeme'."
  script: "var = 42;"

ExpectedString:
  pseudoSharedCode: EXPECTED_STRING_LITERAL
  parameters:
    Token lexeme: undocumented
  problemMessage: "Expected a String, but got '#lexeme'."
  script: |
    import foo;
  exampleAllowOtherCodes: true

ExpectedToken:
  pseudoSharedCode: EXPECTED_TOKEN
  parameters:
    String string: undocumented
  problemMessage: "Expected to find '#string'."
  script: |
    void foo() {
      switch (1) {
        C<int, int> case 1: break;
      }
    }

ExpectedType:
  pseudoSharedCode: EXPECTED_TYPE_NAME
  parameters:
    Token lexeme: undocumented
  problemMessage: "Expected a type, but got '#lexeme'."
  script: |
    extension try<T> on Class<T> {}
  exampleAllowOtherCodes: true

AbstractExtensionField:
  pseudoSharedCode: ABSTRACT_EXTENSION_FIELD
  parameters: none
  problemMessage: "Extension fields can't be declared 'abstract'."
  correctionMessage: "Try removing the 'abstract' keyword."
  exampleAllowOtherCodes: true
  script:
    - "extension C on int {abstract static var f;}"

AbstractFieldInitializer:
  parameters: none
  problemMessage: "Abstract fields cannot have initializers."
  correctionMessage: "Try removing the initializer or the 'abstract' keyword."
  script:
    - "abstract class C {abstract var f = 0;}"

AbstractFieldConstructorInitializer:
  parameters: none
  problemMessage: "Abstract fields cannot have initializers."
  correctionMessage: "Try removing the field initializer or the 'abstract' keyword from the field declaration."
  script:
    - "abstract class C {abstract var f; C(this.f);}"
    - "abstract class C {abstract var f; C() : this.f = 0;}"

ConstFactoryRedirectionToNonConst:
  parameters: none
  problemMessage: "Constant factory constructor can't delegate to a non-constant constructor."
  correctionMessage: "Try redirecting to a different constructor or marking the target constructor 'const'."
  script:
    - >-
      class A {
        const factory A.foo() = A.bar;
        A.bar() {}
      }

NonConstFactory:
  parameters: none
  problemMessage: "Cannot invoke a non-'const' factory where a const expression is expected."
  correctionMessage: "Try using a constructor or factory that is 'const'."
  script: |
    class Foo {
      Foo();
      factory Foo.f() => new Foo();
    }
    void foo() {
      const Foo.f();
    }

NonConstConstructor:
  parameters: none
  problemMessage: "Cannot invoke a non-'const' constructor where a const expression is expected."
  correctionMessage: "Try using a constructor or factory that is 'const'."
  script: |
    class Foo {
      Foo();
    }
    void foo() {
      const Foo();
    }

ConstConstructorWithBody:
  pseudoSharedCode: CONST_CONSTRUCTOR_WITH_BODY
  parameters: none
  problemMessage: "A const constructor can't have a body."
  correctionMessage: "Try removing either the 'const' keyword or the body."
  script:
    - "class C { const C() {} }"

ExternalFieldInitializer:
  parameters: none
  problemMessage: "External fields cannot have initializers."
  correctionMessage: "Try removing the initializer or the 'external' keyword."
  script:
    - "external var f = 0;"
    - "abstract class C {external var f = 0;}"

ExternalFieldConstructorInitializer:
  parameters: none
  problemMessage: "External fields cannot have initializers."
  correctionMessage: "Try removing the field initializer or the 'external' keyword from the field declaration."
  script:
    - "abstract class C {external var f; C(this.f);}"
    - "abstract class C {external var f; C() : this.f = 0;}"

InitializerForStaticField:
  parameters:
    Name name: undocumented
  problemMessage: "'#name' isn't an instance field of this class."
  script: |
    class Foo {
      Foo() : initializer = true { }
    }

MoreThanOneSuperInitializer:
  parameters: none
  problemMessage: "Can't have more than one 'super' initializer."
  script:
    - "class C { C.bad() : super(), super(); }"

RedirectingConstructorWithSuperInitializer:
  parameters: none
  problemMessage: "A redirecting constructor can't have a 'super' initializer."
  script:
    - "class C { C(); C.bad() : super(), this(); }"
    - "class C { C(); C.bad() : this(), super(); }"

RedirectingConstructorWithMultipleRedirectInitializers:
  parameters: none
  problemMessage: "A redirecting constructor can't have more than one redirection."
  script:
    - "class C { C(); C.bad() : this(), this(); }"

RedirectingConstructorWithAnotherInitializer:
  parameters: none
  problemMessage: "A redirecting constructor can't have other initializers."
  # also ASSERT_IN_REDIRECTING_CONSTRUCTOR
  script:
    - "class C { int? x; C(); C.bad() : x = 5, this(); }"
    - "class C { int? x; C(); C.bad() : this(), x = 5; }"
    - "class C { int? x; C(); C.bad() : assert(true), this(); }"
    - "class C { int? x; C(); C.bad() : this(), assert(true); }"

SuperInitializerNotLast:
  parameters: none
  problemMessage: "Can't have initializers after 'super'."
  script:
    - "class C { int x; C.bad() : super(), x = 5; }"

InvalidBreakTarget:
  parameters:
    Name name: undocumented
  problemMessage: "Can't break to '#name'."
  script: |
    void foo() {
      switch (1) {
        L: case 1:
          foo() {
            break L;
          }
      }
    }

BreakTargetOutsideFunction:
  parameters:
    Name name: undocumented
  problemMessage: "Can't break to '#name' in a different function."
  statement: |
    label: while (true) {
      void f() {
        while (true) {
          break label;
        }
      }
    }

AnonymousBreakTargetOutsideFunction:
  parameters: none
  problemMessage: "Can't break to a target in a different function."
  statement: |
    while (true) {
      void f() {
        break;
      }
    }
  exampleAllowOtherCodes: true

ContinueLabelInvalid:
  parameters: none
  problemMessage: "A 'continue' label must be on a loop or a switch member."
  statement:
    - "L: { for (var i in [ ]) { continue L; } }"

InvalidContinueTarget:
  parameters:
    Name name: undocumented
  problemMessage: "Can't continue at '#name'."
  script: |
    void foo() {
      switch (1) {
        L: case 1:
          foo() {
            continue L;
          }
      }
    }
  exampleAllowOtherCodes: true

ContinueTargetOutsideFunction:
  parameters:
    Name name: undocumented
  problemMessage: "Can't continue at '#name' in a different function."
  statement: |
    label: while (true) {
      void f() {
        while (true) {
          continue label;
        }
      }
    }

AnonymousContinueTargetOutsideFunction:
  parameters: none
  problemMessage: "Can't continue at a target in a different function."
  statement: |
    while (true) {
      void f() {
        continue;
      }
    }
  exampleAllowOtherCodes: true

LabelNotFound:
  parameters:
    Name name: undocumented
  problemMessage: "Can't find label '#name'."
  correctionMessage: "Try defining the label, or correcting the name to match an existing label."
  statement:
    - "switch (0) {case 0: continue L;}"

InvalidSyncModifier:
  pseudoSharedCode: MISSING_STAR_AFTER_SYNC
  parameters: none
  problemMessage: "Invalid modifier 'sync'."
  correctionMessage: "Try replacing 'sync' with 'sync*'."
  script: "main() sync {}"

InvalidVoid:
  pseudoSharedCode: EXPECTED_TYPE_NAME
  parameters: none
  problemMessage: "Type 'void' can't be used here."
  correctionMessage: "Try removing 'void' keyword or replace it with 'var', 'final', or a type."
  script:
    - "class Foo extends void {}"
  exampleAllowOtherCodes: true

FinalFieldNotInitialized:
  parameters:
    Name name: undocumented
  problemMessage: "Final field '#name' is not initialized."
  correctionMessage: "Try to initialize the field in the declaration or in every constructor."
  script: |
    class C {
      final int x;
    }

FinalFieldNotInitializedByConstructor:
  parameters:
    Name name: undocumented
  problemMessage: "Final field '#name' is not initialized by this constructor."
  correctionMessage: "Try to initialize the field using an initializing formal or a field initializer."
  script: |
    class C {
      final int x;
      C(this.x) {}
      C.missing() {}
    }

MissingExponent:
  pseudoSharedCode: MISSING_DIGIT
  parameters: none
  problemMessage: "Numbers in exponential notation should always contain an exponent (an integer number with an optional sign)."
  correctionMessage: "Make sure there is an exponent, and remove any whitespace before it."
  script: |
    main() {
      var i = 1e;
    }

PositionalParameterWithEquals:
  pseudoSharedCode: WRONG_SEPARATOR_FOR_POSITIONAL_PARAMETER
  parameters: none
  problemMessage: "Positional optional parameters can't use ':' to specify a default value."
  correctionMessage: "Try replacing ':' with '='."
  script: |
    main() {
      foo([a: 1]) => print(a);
      foo(2);
    }

RequiredParameterWithDefault:
  pseudoSharedCode: NAMED_PARAMETER_OUTSIDE_GROUP
  parameters: none
  problemMessage: "Non-optional parameters can't have a default value."
  correctionMessage: "Try removing the default value or making the parameter optional."
  script:
    - >
      main() {
        foo(a: 1) => print(a);
        foo(2);
      }
    - >
      main() {
        foo(a = 1) => print(a);
        foo(2);
      }

InvalidCodePoint:
  pseudoSharedCode: INVALID_CODE_POINT
  parameters: none
  problemMessage: "The escape sequence starting with '\\u' isn't a valid code point."
  expression:
    - "'\\u{110000}'"

UnexpectedDollarInString:
  pseudoSharedCode: UNEXPECTED_DOLLAR_IN_STRING
  parameters: none
  problemMessage: "A '$' has special meaning inside a string, and must be followed by an identifier or an expression in curly braces ({})."
  correctionMessage: "Try adding a backslash (\\) to escape the '$'."
  expression:
    - "'$'"
    - '"$"'
    - "'''$'''"
    - '"""$"""'

UnexpectedSeparatorInNumber:
  pseudoSharedCode: UNEXPECTED_SEPARATOR_IN_NUMBER
  parameters: none
  problemMessage: "Digit separators ('_') in a number literal can only be placed between two digits."
  correctionMessage: "Try removing the '_'."
  expression:
    - '123_'
    - '1.23_'
    - '1_.23'
    - '0x_123'
    - '0x123_'
    - '1_e23'
    - '1e_23'
    - '1.2_e3'
    - '1.2e_3'

UnexpectedToken:
  pseudoSharedCode: UNEXPECTED_TOKEN
  parameters:
    Token lexeme: undocumented
  problemMessage: "Unexpected token '#lexeme'."
  script:
    - "import 'b.dart' d as b;"
  exampleAllowOtherCodes: true

UnmatchedToken:
  pseudoSharedCode: EXPECTED_TOKEN
  parameters:
    String string: undocumented
    Token lexeme: undocumented
  problemMessage: "Can't find '#string' to match '#lexeme'."
  script:
    - "main("
    - "main(){"
    - "main(){[}"
  exampleAllowOtherCodes: true

UnsupportedOperator:
  pseudoSharedCode: UNSUPPORTED_OPERATOR
  parameters:
    Token lexeme: undocumented
  problemMessage: "The '#lexeme' operator is not supported."
  script:
    - "class C { void operator ===(x) {} }"
    - "class C { void operator !==(x) {} }"

UnsupportedPrefixPlus:
  pseudoSharedCode: MISSING_IDENTIFIER
  parameters: none
  problemMessage: "'+' is not a prefix operator."
  correctionMessage: "Try removing '+'."
  expression: "+2" # No longer a valid way to write '2'

UnterminatedComment:
  pseudoSharedCode: UNTERMINATED_MULTI_LINE_COMMENT
  parameters: none
  problemMessage: "Comment starting with '/*' must end with '*/'."
  script:
    main() {
    }
    /*

UnterminatedString:
  pseudoSharedCode: UNTERMINATED_STRING_LITERAL
  parameters:
    String string: undocumented
    String string2: undocumented
  problemMessage: "String starting with #string must end with #string2."
  script:
    - >
      main() {
        return '
      ;
      }
    - >
      main() {
        return \"
      ;
      }
    - >
      main() {
        return r'
      ;
      }
    - >
      main() {
        return r\"
      ;
      }
    - >
      main() => '''
    - >
      main() => \"\"\"
    - >
      main() => r'''
    - >
      main() => r\"\"\"
  exampleAllowOtherCodes: true

UnterminatedToken:
  # This is a fall-back message that shouldn't happen.
  parameters: none
  problemMessage: "Incomplete token."

# Note: avoid using this template, it should only be used for debugging and
# prototyping, see [diagnostics.md](
# lib/src/base/diagnostics.md#avoid-composing-messages-programmatically).
Unspecified:
  pseudoSharedCode: UNSPECIFIED
  parameters:
    String string: undocumented
  problemMessage: "#string"

AbstractNotSync:
  pseudoSharedCode: NON_SYNC_ABSTRACT_METHOD
  parameters: none
  problemMessage: "Abstract methods can't use 'async', 'async*', or 'sync*'."
  script: |
    abstract class Foo {
      Future<void> bar() async;
    }
  exampleAllowOtherCodes: true

AwaitAsIdentifier:
  pseudoSharedCode: ASYNC_KEYWORD_USED_AS_IDENTIFIER
  parameters: none
  problemMessage: "'await' can't be used as an identifier in 'async', 'async*', or 'sync*' methods."
  script: |
    Future<void> foo() async {
      int await = 1;
    }

AwaitNotAsync:
  pseudoSharedCode: AWAIT_IN_WRONG_CONTEXT
  parameters: none
  problemMessage: "'await' can only be used in 'async' or 'async*' methods."
  script: |
    void foo() {
      await null;
    }

BuiltInIdentifierAsType:
  pseudoSharedCode: BUILT_IN_IDENTIFIER_AS_TYPE
  parameters:
    Token lexeme: undocumented
  problemMessage: "The built-in identifier '#lexeme' can't be used as a type."
  script: |
    class Foo<as extends Comparable<as>> {}
  exampleAllowOtherCodes: true

BuiltInIdentifierInDeclaration:
  pseudoSharedCode: BUILT_IN_IDENTIFIER_IN_DECLARATION
  parameters:
    Token lexeme: undocumented
  problemMessage: "Can't use '#lexeme' as a name here."
  script: |
    class late {}

AwaitForNotAsync:
  pseudoSharedCode: ASYNC_FOR_IN_WRONG_CONTEXT
  parameters: none
  problemMessage: "The asynchronous for-in can only be used in functions marked with 'async' or 'async*'."
  correctionMessage: "Try marking the function body with either 'async' or 'async*', or removing the 'await' before the for loop."
  script: |
    main(o) sync* {
      await for (var e in o) {}
    }

ConstructorNotSync:
  parameters: none
  problemMessage: "Constructor bodies can't use 'async', 'async*', or 'sync*'."
  script: |
    class Foo {
      Foo() async {}
    }

FactoryNotSync:
  pseudoSharedCode: NON_SYNC_FACTORY
  parameters: none
  problemMessage: "Factory bodies can't use 'async', 'async*', or 'sync*'."
  script: |
    class Foo {
      Foo._();
      factory Foo.x() async => new Foo._();
    }

GeneratorReturnsValue:
  pseudoSharedCode: RETURN_IN_GENERATOR
  parameters: none
  problemMessage: "'sync*' and 'async*' can't return a value."
  script: |
    Iterable<int> foo() sync* {
      return [42];
    }

InvalidInlineFunctionType:
  pseudoSharedCode: INVALID_INLINE_FUNCTION_TYPE
  parameters: none
  problemMessage: "Inline function types cannot be used for parameters in a generic function type."
  correctionMessage: "Try changing the inline function type (as in 'int f()') to a prefixed function type using the `Function` keyword (as in 'int Function() f')."
  declaration: "typedef F = Function(int f(String x));"

SetterNotSync:
  pseudoSharedCode: INVALID_MODIFIER_ON_SETTER
  parameters: none
  problemMessage: "Setters can't use 'async', 'async*', or 'sync*'."
  script: |
    set foo(int x) async {}

YieldAsIdentifier:
  pseudoSharedCode: ASYNC_KEYWORD_USED_AS_IDENTIFIER
  parameters: none
  problemMessage: "'yield' can't be used as an identifier in 'async', 'async*', or 'sync*' methods."
  script: |
    Future<void> foo() async {
      int yield = 1;
    }

YieldNotGenerator:
  pseudoSharedCode: YIELD_IN_NON_GENERATOR
  parameters: none
  problemMessage: "'yield' can only be used in 'sync*' or 'async*' methods."
  script: |
    Future<int> f() => Future.value(7);
    List<int> g() {
      yield f();
      return [];
    }

PositionalAfterNamedArgument:
  pseudoSharedCode: POSITIONAL_AFTER_NAMED_ARGUMENT
  parameters: none
  problemMessage: "Place positional arguments before named arguments."
  correctionMessage: "Try moving the positional argument before the named arguments, or add a name to the argument."

ExpectedNamedArgument:
  parameters: none
  problemMessage: "Expected named argument."
  script: |
    // @dart=2.16
    void foo({int x = 1, int y = 2}) {}
    void bar() => foo(x: 42, ,);
  exampleAllowOtherCodes: true

AssertAsExpression:
  pseudoSharedCode: ASSERT_AS_EXPRESSION
  parameters: none
  problemMessage: "`assert` can't be used as an expression."
  script: |
    int assert(int x) {
      if (x == 0) return 42;
      return assert(x-1) + 1;
    }
  exampleAllowOtherCodes: true

FunctionTypeDefaultValue:
  pseudoSharedCode: DEFAULT_VALUE_IN_FUNCTION_TYPE
  parameters: none
  problemMessage: "Can't have a default value in a function type."
  script: |
    void Function({dynamic obj = Object})? x;

PrivateNamedParameter:
  pseudoSharedCode: PRIVATE_OPTIONAL_PARAMETER
  parameters: none
  problemMessage: "A named parameter can't start with an underscore ('_')."
  script: |
    void foo({int? _hello}) {}

PrivateNamedNonFieldParameter:
  pseudoSharedCode: PRIVATE_NAMED_NON_FIELD_PARAMETER
  parameters: none
  problemMessage: "A named parameter that doesn't refer to an instance variable can't start with an underscore ('_')."
  script: |
    void foo({int? _hello}) {}

GetterWithFormals:
  pseudoSharedCode: GETTER_WITH_PARAMETERS
  parameters: none
  problemMessage: "A getter can't have formal parameters."
  correctionMessage: "Try removing '(...)'."
  script: |
    int get foo(int x) => 42;

SetterWithWrongNumberOfFormals:
  parameters: none
  problemMessage: "A setter should have exactly one formal parameter."
  script:
    - "var set foo; main(){}"
  exampleAllowOtherCodes: true

ConstFieldWithoutInitializer:
  pseudoSharedCode: CONST_NOT_INITIALIZED
  parameters:
    Name name: undocumented
  problemMessage: "The const variable '#name' must be initialized."
  correctionMessage: "Try adding an initializer ('= expression') to the declaration."
  script:
    - "var const foo; main(){}"
  exampleAllowOtherCodes: true

FinalFieldWithoutInitializer:
  pseudoSharedCode: FINAL_NOT_INITIALIZED
  parameters:
    Name name: undocumented
  problemMessage: "The final variable '#name' must be initialized."
  correctionMessage: "Try adding an initializer ('= expression') to the declaration."
  script:
    - "var final foo; main(){}"
  exampleAllowOtherCodes: true

ConstructorNotFound:
  parameters:
    Name name: undocumented
  problemMessage: "Couldn't find constructor '#name'."
  script: |
    class Foo {
      Foo.bar() {}
    }
    void baz() {
      new Foo.baz();
    }

ConstructorWithWrongNameContext:
  parameters:
    Name name: undocumented
  problemMessage: "The name of the enclosing class is '#name'."
  severity: CONTEXT

ConstructorCyclic:
  parameters: none
  problemMessage: "Redirecting constructors can't be cyclic."
  correctionMessage: "Try to have all constructors eventually redirect to a non-redirecting constructor."
  script:
    - "class C { C.foo() : this.bar(); C.bar() : this.foo(); }"

SuperParameterInitializerOutsideConstructor:
  parameters: none
  problemMessage: "Super-initializer formal parameters can only be used in generative constructors."
  correctionMessage: "Try removing 'super.'."
  script: |
    class A {
      A(int x);
    }
    class C extends A {
      C(super._);
      factory C.r2(super._) = C; // Error.
    }
  exampleAllowOtherCodes: true

RedirectionTargetNotFound:
  parameters:
    Name name: undocumented
  problemMessage: "Redirection constructor target not found: '#name'"
  script: |
    class Class {
      factory Class.a() = Class.nonexisting;
    }

CyclicTypedef:
  parameters:
    Name name: undocumented
  problemMessage: "The typedef '#name' has a reference to itself."
  script: |
    typedef Foo = Foo;

TypeNotFound:
  parameters:
    Name name: undocumented
  problemMessage: "Type '#name' not found."
  script: |
    Bar? foo() {
      return null;
    }

NameNotFound:
  parameters:
    Name name: undocumented
  problemMessage: "Undefined name '#name'."
  script: |
    void foo() => bar;

MemberNotFound:
  parameters:
    Name name: undocumented
  problemMessage: "Member not found: '#name'."
  script: |
    class Foo {}
    void bar() => Foo.baz();

GetterNotFound:
  parameters:
    Name name: undocumented
  problemMessage: "Getter not found: '#name'."
  script:
    void set onlySetter(value) {}
    void foo() => print(onlySetter);

SetterNotFound:
  parameters:
    Name name: undocumented
  problemMessage: "Setter not found: '#name'."
  script: |
    void x() {
      foo = 42;
    }

MethodNotFound:
  parameters:
    Name name: undocumented
  problemMessage: "Method not found: '#name'."
  script: |
    void foo() => z("Hello, World!");

CandidateFound:
  parameters: none
  problemMessage: "Found this candidate, but the arguments don't match."
  severity: CONTEXT

CandidateFoundIsDefaultConstructor:
  parameters:
    Name name: undocumented
  problemMessage: "The class '#name' has a constructor that takes no arguments."
  severity: CONTEXT

TooFewArguments:
  parameters:
    int count: undocumented
    int count2: undocumented
  problemMessage: "Too few positional arguments: #count required, #count2 given."
  script: |
    void foo(int i) {}
    void bar() {
      foo();
    }

TooManyArguments:
  parameters:
    int count: undocumented
    int count2: undocumented
  problemMessage: "Too many positional arguments: #count allowed, but #count2 found."
  correctionMessage: "Try removing the extra positional arguments."
  script: |
    void foo(int i) {}
    void bar() {
      foo(1, 2);
    }

NoSuchNamedParameter:
  parameters:
    Name name: undocumented
  problemMessage: "No named parameter with the name '#name'."
  script: |
    void foo(int i) => i.toString(hello: 42);

AbstractClassInstantiation:
  parameters:
    Name name: undocumented
  problemMessage: "The class '#name' is abstract and can't be instantiated."
  script: |
    abstract class Foo {}
    main() { new Foo(); }

EnumInstantiation:
  parameters: none
  problemMessage: "Enums can't be instantiated."
  script: |
    enum E {
      a, b, c;
      factory E.x() {
        return const E();
      }
    }

AbstractRedirectedClassInstantiation:
  parameters:
    Name name: undocumented
  problemMessage: "Factory redirects to class '#name', which is abstract and can't be instantiated."
  script: |
    abstract class A {
      A._();
      factory A() = B;
    }

    abstract class B extends A {
      B() : super._();
    }

MissingImplementationNotAbstract:
  parameters:
    Name name: undocumented
    Names names: undocumented
  problemMessage: |
    The non-abstract class '#name' is missing implementations for these members:
    #names
  correctionMessage: |
    Try to either
     - provide an implementation,
     - inherit an implementation from a superclass or mixin,
     - mark the class as abstract, or
     - provide a 'noSuchMethod' implementation.
  script:
    - "class C {foo();}"

MissingImplementationCause:
  parameters:
    Name name: undocumented
  problemMessage: "'#name' is defined here."
  severity: CONTEXT

InterfaceCheck:
  parameters:
    Name name: undocumented
    Name name2: undocumented
  problemMessage: "The implementation of '#name' in the non-abstract class '#name2' does not conform to its interface."
  script: |
    class A {
      void foo() {}
    }

    abstract class B extends A {
      void foo([a]);
    }

    class C extends B {}

NamedMixinOverride:
  parameters:
    Name name: undocumented
    Name name2: undocumented
  problemMessage: "The mixin application class '#name' introduces an erroneous override of '#name2'."
  script: |
    class Super {
      void extendedConcreteMixedInConcreteMethod() {}
    }

    mixin class Mixin {
      void extendedConcreteMixedInConcreteMethod(int i) {}
    }

    class NamedMixin = Super with Mixin;

ImplicitMixinOverride:
  parameters:
    Name name: undocumented
    Name name2: undocumented
    Name name3: undocumented
  problemMessage: "Applying the mixin '#name' to '#name2' introduces an erroneous override of '#name3'."
  script: |
    abstract class Super {
      String get extendedGetterMixedInField => '';
    }

    mixin Mixin {
      int extendedGetterMixedInField = 0;
    }

    abstract class Class extends Super with Mixin { }

ListLiteralTooManyTypeArguments:
  parameters: none
  problemMessage: "List literal requires exactly one type argument."
  script: |
    void foo() {
      var x = <int, int>[];
    }

SetOrMapLiteralTooManyTypeArguments:
  pseudoSharedCode: SET_OR_MAP_LITERAL_TOO_MANY_TYPE_ARGUMENTS
  parameters: none
  problemMessage: "A set or map literal requires exactly one or two type arguments, respectively."
  script: |
    var x = <int, int, int>{};

LoadLibraryTakesNoArguments:
  parameters: none
  problemMessage: "'loadLibrary' takes no arguments."
  script:
    main.dart: |
      import "lib.dart" deferred as lib;
      void main() {
        lib.loadLibrary(10);
      }
    lib.dart: ""

TypeArgumentMismatch:
  parameters:
    int count: undocumented
  problemMessage: "Expected #count type arguments."
  script: |
    void foo() {
      new List<int, int>.filled(0, 42);
    }

NotAType:
  parameters:
    Name name: undocumented
  problemMessage: "'#name' isn't a type."
  script:
    main.dart: |
      import 'lib.dart' as prefix;

      void foo() {
        prefix.NonExisting? e;
      }
    lib.dart: ""

NotATypeContext:
  parameters: none
  problemMessage: "This isn't a type."
  severity: CONTEXT

NotAPrefixInTypeAnnotation:
  parameters:
    Name name: undocumented
    Name name2: undocumented
  problemMessage: "'#name.#name2' can't be used as a type because '#name' doesn't refer to an import prefix."
  declaration:
    - |
        class C<T> {
          T.String method() {}
        }
    - |
        class C<T> {
          T.String field;
        }

FastaUsageShort:
  parameters: none
  problemMessage: |
    Frequently used options:

      -o <file> Generate the output into <file>.
      -h        Display this message (add -v for information about all options).

FastaUsageLong:
  # TODO(ahe): Consider if the reference to platform.dill needs to change below?
  parameters: none
  problemMessage: |
    Supported options:

      -o <file>, --output=<file>
        Generate the output into <file>.

      -h, /h, /?, --help
        Display this message (add -v for information about all options).

      -v, --verbose
        Display verbose information.

      -Dname
      -Dname=value
        Define an environment variable in the compile-time environment.

      --no-defines
        Ignore all -D options and leave environment constants unevaluated.

      --
        Stop option parsing, the rest of the command line is assumed to be
        file names or arguments to the Dart program.

      --packages=<file>
        Use package resolution configuration <file>, which should contain a mapping
        of package names to paths.

      --platform=<file>
        Read the SDK platform from <file>, which should be in Dill/Kernel IR format
        and contain the Dart SDK.

      --target=dart2js|dart2js_server|dart2wasm|dart2wasm_js_compatibility|dart_runner|dartdevc|flutter|flutter_runner|none|vm
        Specify the target configuration.

      --enable-asserts
        Check asserts in initializers during constant evaluation.

      --verify
        Check that the generated output is free of various problems. This is mostly
        useful for developers of this compiler or Kernel transformations.

      --dump-ir
        Print compiled libraries in Kernel source notation.

      --omit-platform
        Exclude the platform from the serialized dill file.

      --exclude-source
        Do not include source code in the dill file.

      --compile-sdk=<sdk>
        Compile the SDK from scratch instead of reading it from a .dill file
        (see --platform).

      --sdk=<sdk>
        Location of the SDK sources for use when compiling additional platform
        libraries.

      --single-root-scheme=String
      --single-root-base=<dir>
        Specify a custom URI scheme and a location on disk where such URIs are
        mapped to.

        When specified, the compiler can be invoked with inputs using the custom
        URI scheme. The compiler can ignore the exact location of files on disk
        and as a result to produce output that is independent of the absolute
        location of files on disk. This is mostly useful for integrating with
        build systems.

      --fatal=errors
      --fatal=warnings
        Makes messages of the given kinds fatal, that is, immediately stop the
        compiler with a non-zero exit-code. In --verbose mode, also display an
        internal stack trace from the compiler. Multiple kinds can be separated by
        commas, for example, --fatal=errors,warnings.

      --fatal-skip=<number>
      --fatal-skip=trace
        Skip this many messages that would otherwise be fatal before aborting the
        compilation. Default is 0, which stops at the first message. Specify
        'trace' to print a stack trace for every message without stopping.

      --enable-experiment=<flag>
        Enable or disable an experimental flag, used to guard features currently
        in development. Prefix an experiment name with 'no-' to disable it.
        Multiple experiments can be separated by commas.

FastaCLIArgumentRequired:
  pseudoSharedCode: FASTA_CLI_ARGUMENT_REQUIRED
  parameters:
    Name name: undocumented
  problemMessage: "Expected value after '#name'."

NamedFunctionExpression:
  pseudoSharedCode: NAMED_FUNCTION_EXPRESSION
  parameters: none
  problemMessage: "A function expression can't have a name."
  script: |
    var x = void f<T>(T t) {};

InternalProblemUnhandled:
  pseudoSharedCode: INTERNAL_PROBLEM_UNHANDLED
  parameters:
    String string: undocumented
    String string2: undocumented
  problemMessage: "Unhandled #string in #string2."
  severity: INTERNAL_PROBLEM

InternalProblemUnimplemented:
  parameters:
    String string: undocumented
  problemMessage: "Unimplemented #string."
  severity: INTERNAL_PROBLEM

InternalProblemUnexpected:
  parameters:
    String string: undocumented
    String string2: undocumented
  problemMessage: "Expected '#string', but got '#string2'."
  severity: INTERNAL_PROBLEM

InternalProblemUnsupported:
  pseudoSharedCode: INTERNAL_PROBLEM_UNSUPPORTED
  parameters:
    Name name: undocumented
  problemMessage: "Unsupported operation: '#name'."
  severity: INTERNAL_PROBLEM

InternalProblemNotFound:
  parameters:
    Name name: undocumented
  problemMessage: "Couldn't find '#name'."
  severity: INTERNAL_PROBLEM

InternalProblemNotFoundIn:
  parameters:
    Name name: undocumented
    Name name2: undocumented
  problemMessage: "Couldn't find '#name' in '#name2'."
  severity: INTERNAL_PROBLEM

InternalProblemPrivateConstructorAccess:
  parameters:
    Name name: undocumented
  problemMessage: "Can't access private constructor '#name'."
  severity: INTERNAL_PROBLEM

InternalProblemConstructorNotFound:
  parameters:
    Name name: undocumented
    Uri uri: undocumented
  problemMessage: "No constructor named '#name' in '#uri'."
  severity: INTERNAL_PROBLEM

InternalProblemExtendingUnmodifiableScope:
  parameters: none
  problemMessage: "Can't extend an unmodifiable scope."
  severity: INTERNAL_PROBLEM

InternalProblemPreviousTokenNotFound:
  parameters: none
  problemMessage: "Couldn't find previous token."
  severity: INTERNAL_PROBLEM

InternalProblemStackNotEmpty:
  pseudoSharedCode: INTERNAL_PROBLEM_STACK_NOT_EMPTY
  parameters:
    Name name: undocumented
    String string: undocumented
  problemMessage: "#name.stack isn't empty:\n  #string"
  severity: INTERNAL_PROBLEM

InternalProblemAlreadyInitialized:
  parameters: none
  problemMessage: "Attempt to set initializer on field without initializer."
  severity: INTERNAL_PROBLEM

InternalProblemBodyOnAbstractMethod:
  parameters: none
  problemMessage: "Attempting to set body on abstract method."
  severity: INTERNAL_PROBLEM

InternalProblemMissingContext:
  parameters: none
  problemMessage: "Compiler cannot run without a compiler context."
  correctionMessage: "Are calls to the compiler wrapped in CompilerContext.runInContext?"
  severity: INTERNAL_PROBLEM

InternalProblemProvidedBothCompileSdkAndSdkSummary:
  parameters: none
  problemMessage: "The compileSdk and sdkSummary options are mutually exclusive"
  severity: INTERNAL_PROBLEM

InternalProblemUriMissingScheme:
  parameters:
    Uri uri: undocumented
  problemMessage: "The URI '#uri' has no scheme."
  severity: INTERNAL_PROBLEM

InternalProblemContextSeverity:
  parameters:
    String string: undocumented
  problemMessage: "Non-context message has context severity: #string"
  severity: INTERNAL_PROBLEM

InternalProblemVerificationError:
  parameters:
    String string: undocumented
  problemMessage: |
    Verification of the generated program failed:
    #string
  severity: INTERNAL_PROBLEM

VerificationErrorOriginContext:
  parameters: none
  problemMessage: "The node most likely is taken from here by a transformer."
  severity: CONTEXT

InternalProblemDebugAbort:
  parameters:
    Name name: undocumented
    String string: undocumented
  problemMessage: "Compilation aborted due to fatal '#name' at:\n#string"
  severity: INTERNAL_PROBLEM

InternalProblemLabelUsageInVariablesDeclaration:
  parameters: none
  problemMessage: "Unexpected usage of label inside declaration of variables."
  severity: INTERNAL_PROBLEM

InternalProblemUnsupportedNullability:
  parameters:
    String string: undocumented
    Type type: undocumented
  problemMessage: "Unsupported nullability value '#string' on type '#type'."
  severity: INTERNAL_PROBLEM

InternalProblemOmittedTypeNameInConstructorReference:
  parameters: none
  problemMessage: "Unsupported omission of the type name in a constructor reference outside of an enum element declaration."
  severity: INTERNAL_PROBLEM

IncrementalCompilerIllegalParameter:
  parameters:
    String string: undocumented
  problemMessage: "Illegal parameter name '#string' found during expression compilation."

IncrementalCompilerIllegalTypeParameter:
  parameters:
    String string: undocumented
  problemMessage: "Illegal type parameter name '#string' found during expression compilation."

DebugTrace:
  parameters:
    Name name: undocumented
    String string: undocumented
  problemMessage: "Fatal '#name' at:\n#string"
  severity: IGNORED

DeferredTypeAnnotation:
  parameters:
    Type type: undocumented
    Name name: undocumented
  problemMessage: "The type '#type' is deferred loaded via prefix '#name' and can't be used as a type annotation."
  correctionMessage: "Try removing 'deferred' from the import of '#name' or use a supertype of '#type' that isn't deferred."
  script:
    main.dart: |
      import 'lib.dart' deferred as lib;
      void foo(Object x) {
        x as lib.C;
      }
    lib.dart: |
      class C {}

DuplicatedExport:
  parameters:
    Name name: undocumented
    Uri uri: undocumented
    Uri uri2: undocumented
  problemMessage: "'#name' is exported from both '#uri' and '#uri2'."
  script:
    lib1.dart: "class A {}"
    lib2.dart: "class A {}"
    main.dart: "export 'lib1.dart'; export 'lib2.dart';"

DuplicatedImport:
  parameters:
    Name name: undocumented
    Uri uri: undocumented
    Uri uri2: undocumented
  problemMessage: "'#name' is imported from both '#uri' and '#uri2'."
  script:
    lib1.dart: "class A {}"
    lib2.dart: "class A {}"
    main.dart: "import 'lib1.dart'; import 'lib2.dart'; A a;"

CyclicClassHierarchy:
  parameters:
    Name name: undocumented
  problemMessage: "'#name' is a supertype of itself."
  script:
    - |
      class A extends B {}
      class B extends A {}
    - |
      class A implements B {}
      class B implements A {}
    - "class C = Object with C;"
    - "class C extends C {}"
    - "class C implements C {}"
  exampleAllowMultipleReports: true

ExtendingEnum:
  parameters:
    Name name: undocumented
  problemMessage: "'#name' is an enum and can't be extended or implemented."
  script: |
    enum Foo { a, b, c; }
    abstract class Bar extends Foo {}
  exampleAllowOtherCodes: true

ExtendingRestricted:
  parameters:
    Name name: undocumented
  problemMessage: "'#name' is restricted and can't be extended or implemented."
  script: |
    abstract class Foo extends String {}
  exampleAllowOtherCodes: true

NoUnnamedConstructorInObject:
  parameters: none
  problemMessage: "'Object' has no unnamed constructor."

IllegalAsyncGeneratorReturnType:
  parameters: none
  problemMessage: "Functions marked 'async*' must have a return type assignable to 'Stream'."
  script:
    - >-
      int g() async* {
        yield 0;
      }

IllegalAsyncGeneratorVoidReturnType:
  parameters: none
  problemMessage: "Functions marked 'async*' can't have return type 'void'."
  script:
    - >-
      void g() async* {
      }

IllegalAsyncReturnType:
  parameters: none
  problemMessage: "Functions marked 'async' must have a return type assignable to 'Future'."
  script:
    - >-
      int f() async {
        return 0;
      }

IllegalSyncGeneratorReturnType:
  parameters: none
  problemMessage: "Functions marked 'sync*' must have a return type assignable to 'Iterable'."
  script:
    - >-
      int g() sync* {
        yield 0;
      }

IllegalSyncGeneratorVoidReturnType:
  parameters: none
  problemMessage: "Functions marked 'sync*' can't have return type 'void'."
  script:
    - >-
      void g() sync* {
      }

IllegalMixinDueToConstructors:
  # a class with a constructor is used as a mixin
  parameters:
    Name name: undocumented
  problemMessage: "Can't use '#name' as a mixin because it has constructors."
  script: |
    // @dart=2.19
    class B with Error {}

IllegalMixinDueToConstructorsCause:
  parameters:
    Name name: undocumented
  problemMessage: "This constructor prevents using '#name' as a mixin."
  severity: CONTEXT

ExtensionTypeDeclaresAbstractMember:
  pseudoSharedCode: EXTENSION_TYPE_WITH_ABSTRACT_MEMBER
  parameters: none
  problemMessage: "Extension types can't declare abstract members."
  correctionMessage: "Try providing an implementation for the member."
  script: |
    extension type ET(int id) {
      void method();
    }

ExtensionDeclaresInstanceField:
  pseudoSharedCode: EXTENSION_DECLARES_INSTANCE_FIELD
  parameters: none
  problemMessage: "Extensions can't declare instance fields"
  correctionMessage: "Try removing the field declaration or making it a static field"
  script: |
    extension E on int {
      int? field;
    }

ExtensionTypeDeclaresInstanceField:
  pseudoSharedCode: EXTENSION_TYPE_DECLARES_INSTANCE_FIELD
  parameters: none
  problemMessage: "Extension types can't declare instance fields"
  correctionMessage: "Try removing the field declaration or making it a static field"
  script: |
    extension type ET(int id) {
      int? field;
    }

StaticConflictsWithInstance:
  parameters:
    Name name: undocumented
  problemMessage: "Static property '#name' conflicts with instance property of the same name."
  script: |
    class A {
      void set foo(_) {}
      static int get foo => 42;
    }

StaticConflictsWithInstanceCause:
  parameters:
    Name name: undocumented
  problemMessage: "Conflicting instance property '#name'."
  severity: CONTEXT

InstanceConflictsWithStatic:
  parameters:
    Name name: undocumented
  problemMessage: "Instance property '#name' conflicts with static property of the same name."
  script: |
    class A {
      static void set foo(_) {}
      int get foo => 42;
    }

InstanceConflictsWithStaticCause:
  parameters:
    Name name: undocumented
  problemMessage: "Conflicting static property '#name'."
  severity: CONTEXT

SetterConflictsWithDeclaration:
  parameters:
    Name name: undocumented
  problemMessage: "The setter conflicts with declaration '#name'."
  script: |
    class Foo {}
    set Foo(_) {}

SetterConflictsWithDeclarationCause:
  parameters:
    Name name: undocumented
  problemMessage: "Conflicting declaration '#name'."
  severity: CONTEXT

ConstructorConflictsWithMember:
  parameters:
    Name name: undocumented
  problemMessage: "The constructor conflicts with member '#name'."
  script: |
    class A {
      static int get foo => 42;
      A.foo();
    }

ConstructorConflictsWithMemberCause:
  parameters:
    Name name: undocumented
  problemMessage: "Conflicting member '#name'."
  severity: CONTEXT

FactoryConflictsWithMember:
  parameters:
    Name name: undocumented
  problemMessage: "The factory conflicts with member '#name'."
  script: |
    class A {
      static int get foo => 42;
      factory A.foo() => throw '';
    }

FactoryConflictsWithMemberCause:
  parameters:
    Name name: undocumented
  problemMessage: "Conflicting member '#name'."
  severity: CONTEXT

MemberConflictsWithConstructor:
  parameters:
    Name name: undocumented
  problemMessage: "The member conflicts with constructor '#name'."
  script: |
    class A {
      A.foo();
      static void foo() {}
    }

MemberConflictsWithConstructorCause:
  parameters:
    Name name: undocumented
  problemMessage: "Conflicting constructor '#name'."
  severity: CONTEXT

MemberConflictsWithFactory:
  parameters:
    Name name: undocumented
  problemMessage: "The member conflicts with factory '#name'."
  script: |
    class A {
      factory A.foo() => throw '';
      static void foo() {}
    }

MemberConflictsWithFactoryCause:
  parameters:
    Name name: undocumented
  problemMessage: "Conflicting factory '#name'."
  severity: CONTEXT

DeclarationConflictsWithSetter:
  parameters:
    Name name: undocumented
  problemMessage: "The declaration conflicts with setter '#name'."
  script: |
    void set foo(_) {}
    void foo() {}

DeclarationConflictsWithSetterCause:
  parameters:
    Name name: undocumented
  problemMessage: "Conflicting setter '#name'."
  severity: CONTEXT

ConflictsWithImplicitSetter:
  parameters:
    Name name: undocumented
  problemMessage: "Conflicts with the implicit setter of the field '#name'."
  script: |
    int? foo;
    void set foo(_) {}

ConflictsWithImplicitSetterCause:
  parameters:
    Name name: undocumented
  problemMessage: "Field '#name' with the implicit setter."
  severity: CONTEXT

ConflictsWithTypeParameter:
  parameters:
    Name name: undocumented
  problemMessage: "Conflicts with type variable '#name'."
  script: |
    enum E2<values> {
      element;
    }

ConflictsWithTypeParameterCause:
  parameters: none
  problemMessage: "This is the type variable."
  severity: CONTEXT

ExtensionMemberConflictsWithObjectMember:
  parameters:
    Name name: undocumented
  problemMessage: "This extension member conflicts with Object member '#name'."
  script:
    extension Extension on String {
      int get noSuchMethod => 42;
    }

DeclaredMemberConflictsWithInheritedMember:
  parameters: none
  problemMessage: "Can't declare a member that conflicts with an inherited one."
  script:
    - >-
      class A {
        var foo;
      }
      class B extends A {
        foo() {}
      }
    - >-
      abstract class A {
        get foo;
      }
      class B implements A {
        foo() {}
      }
    - >-
      class A {
        foo() {}
      }
      class B extends A {
        var foo;
      }
    - >-
      abstract class A {
        foo();
      }
      class B implements A {
        var foo;
      }

DeclaredMemberConflictsWithInheritedMemberCause:
  parameters: none
  problemMessage: "This is the inherited member."
  severity: CONTEXT

DeclaredMemberConflictsWithInheritedMembersCause:
  parameters: none
  problemMessage: "This is one of the inherited members."
  severity: CONTEXT

DeclaredMemberConflictsWithOverriddenMembersCause:
  parameters: none
  problemMessage: "This is one of the overridden members."
  severity: CONTEXT

InheritedMembersConflict:
  parameters: none
  problemMessage: "Can't inherit members that conflict with each other."
  script:
    - >-
      class A {
        foo() {}
      }
      abstract class B {
        get foo;
      }
      abstract class C extends A implements B {}
    - >-
      class A {
        var foo;
      }
      abstract class B {
        foo();
      }
      abstract class C extends A implements B {}
    - >-
      class A {
        get foo => 0;
      }
      abstract class B {
        foo();
      }
      abstract class C extends A implements B {}

InheritedMembersConflictCause1:
  parameters: none
  problemMessage: "This is one inherited member."
  severity: CONTEXT

InheritedMembersConflictCause2:
  parameters: none
  problemMessage: "This is the other inherited member."
  severity: CONTEXT

IllegalMixin:
  parameters:
    Name name: undocumented
  problemMessage: "The type '#name' can't be mixed in."
  script: |
    class SuperClass {}
    mixin Mixin<T> {}
    class Class<T, M extends Mixin<T>> extends SuperClass with M {}
  exampleAllowOtherCodes: true

OverrideTypeParametersMismatch:
  parameters:
    Name name: undocumented
    Name name2: undocumented
  problemMessage: "Declared type variables of '#name' doesn't match those on overridden method '#name2'."
  script: |
    class Super {
      void foo<X>() {}
    }

    class Sub extends Super {
      void foo<X, Y>() {}
    }

OverrideTypeParametersBoundMismatch:
  parameters:
    Type type: undocumented
    Name name: undocumented
    Name name2: undocumented
    Type type2: undocumented
    Name name3: undocumented
  problemMessage: "Declared bound '#type' of type variable '#name' of '#name2' doesn't match the bound '#type2' on overridden method '#name3'."
  script: |
    class Super {
      void foo<X extends String>() {}
    }

    class Sub extends Super {
      void foo<X extends bool>() {}
    }

OverriddenMethodCause:
  parameters:
    Name name: undocumented
  problemMessage: "This is the overridden method ('#name')."
  severity: CONTEXT

OverrideMismatchNamedParameter:
  parameters:
    Name name: undocumented
    Name name2: undocumented
    Name name3: undocumented
  problemMessage: "The method '#name' doesn't have the named parameter '#name2' of overridden method '#name3'."
  script: |
    abstract class A {
      int foo({int x = 0}) => x + 42;
    }

    class B implements A {
      int foo({int y = 0}) => y + 42;
    }

OverrideFewerNamedArguments:
  parameters:
    Name name: undocumented
    Name name2: undocumented
  problemMessage: "The method '#name' has fewer named arguments than those of overridden method '#name2'."
  script: |
    abstract class A {
      int foo({int x = 0, int y = 0}) => x + y + 42;
    }

    class B implements A {
      int foo({int x = 0}) => x + 42;
    }

OverrideFewerPositionalArguments:
  parameters:
    Name name: undocumented
    Name name2: undocumented
  problemMessage: "The method '#name' has fewer positional arguments than those of overridden method '#name2'."
  script: |
    abstract class A {
      int foo(int x, int y) => x + y + 42;
    }

    class B implements A {
      int foo(int x) => x + 42;
    }

OverrideMoreRequiredArguments:
  parameters:
    Name name: undocumented
    Name name2: undocumented
  problemMessage: "The method '#name' has more required arguments than those of overridden method '#name2'."
  script: |
    abstract class A {
      int foo(int x) => x + 42;
    }

    class B implements A {
      int foo(int x, int y) => x + y + 42;
    }

OverrideTypeMismatchParameter:
  parameters:
    Name name: undocumented
    Name name2: undocumented
    Type type: undocumented
    Type type2: undocumented
    Name name3: undocumented
  problemMessage: "The parameter '#name' of the method '#name2' has type '#type', which does not match the corresponding type, '#type2', in the overridden method, '#name3'."
  correctionMessage: "Change to a supertype of '#type2', or, for a covariant parameter, a subtype."
  script: |
    abstract class A {
      int foo(int x) => x + 42;
    }

    class B implements A {
      int foo(String x) => x.length + 42;
    }

OverrideTypeMismatchReturnType:
  parameters:
    Name name: undocumented
    Type type: undocumented
    Type type2: undocumented
    Name name2: undocumented
  problemMessage: "The return type of the method '#name' is '#type', which does not match the return type, '#type2', of the overridden method, '#name2'."
  correctionMessage: "Change to a subtype of '#type2'."
  script: |
    abstract class A {
      int foo() => 42;
    }

    class B implements A {
      String foo() => "42";
    }

OverrideTypeMismatchSetter:
  parameters:
    Name name: undocumented
    Type type: undocumented
    Type type2: undocumented
    Name name2: undocumented
  problemMessage: "The field '#name' has type '#type', which does not match the corresponding type, '#type2', in the overridden setter, '#name2'."
  script: |
    abstract class A {
      void set x(Object? y);
    }

    class B implements A {
      int? x;
    }

OverrideMismatchRequiredNamedParameter:
  parameters:
    Name name: undocumented
    Name name2: undocumented
    Name name3: undocumented
  problemMessage: "The required named parameter '#name' in method '#name2' is not required in overridden method '#name3'."
  script: |
    abstract class A {
      method({int? a});
    }
    abstract class B implements A {
      method({required int? a});
    }

InvalidGetterSetterType:
  parameters:
    Type type: undocumented
    Name name: undocumented
    Type type2: undocumented
    Name name2: undocumented
  problemMessage: "The type '#type' of the getter '#name' is not a subtype of the type '#type2' of the setter '#name2'."
  script: |
    //@dart=3.5
    abstract class A {
      num get property;
      set property(int i);
    }

InvalidGetterSetterTypeGetterInherited:
  parameters:
    Type type: undocumented
    Name name: undocumented
    Type type2: undocumented
    Name name2: undocumented
  problemMessage: "The type '#type' of the inherited getter '#name' is not a subtype of the type '#type2' of the setter '#name2'."
  script: |
    //@dart=3.5
    abstract class A {
      num get property;
    }
    abstract class B implements A {
      void set property(int i);
    }

InvalidGetterSetterTypeFieldInherited:
  parameters:
    Type type: undocumented
    Name name: undocumented
    Type type2: undocumented
    Name name2: undocumented
  problemMessage: "The type '#type' of the inherited field '#name' is not a subtype of the type '#type2' of the setter '#name2'."
  script: |
    //@dart=3.5
    abstract class A {
      final num property;
      A(this.property);
    }
    abstract class B implements A {
      void set property(int i);
    }

InvalidGetterSetterTypeSetterInheritedGetter:
  parameters:
    Type type: undocumented
    Name name: undocumented
    Type type2: undocumented
    Name name2: undocumented
  problemMessage: "The type '#type' of the getter '#name' is not a subtype of the type '#type2' of the inherited setter '#name2'."
  script: |
    //@dart=3.5
    abstract class A {
      void set property(int i);
    }
    abstract class B implements A {
      num get property;
    }

InvalidGetterSetterTypeSetterInheritedField:
  parameters:
    Type type: undocumented
    Name name: undocumented
    Type type2: undocumented
    Name name2: undocumented
  problemMessage: "The type '#type' of the field '#name' is not a subtype of the type '#type2' of the inherited setter '#name2'."
  script: |
    //@dart=3.5
    abstract class A {
      void set property(int i);
    }
    abstract class B implements A {
      final num property;
      B(this.property);
    }

InvalidGetterSetterTypeBothInheritedField:
  parameters:
    Type type: undocumented
    Name name: undocumented
    Type type2: undocumented
    Name name2: undocumented
  problemMessage: "The type '#type' of the inherited field '#name' is not a subtype of the type '#type2' of the inherited setter '#name2'."
  script: |
    //@dart=3.5
    abstract class A {
      final num property;
      A(this.property);
    }
    abstract class B {
      void set property(int i);
    }
    abstract class C implements A, B {}

InvalidGetterSetterTypeBothInheritedGetter:
  parameters:
    Type type: undocumented
    Name name: undocumented
    Type type2: undocumented
    Name name2: undocumented
  problemMessage: "The type '#type' of the inherited getter '#name' is not a subtype of the type '#type2' of the inherited setter '#name2'."
  script: |
    //@dart=3.5
    abstract class A {
      num get property;
    }
    abstract class B {
      void set property(int i);
    }
    abstract class C implements A, B {}

InvalidGetterSetterTypeFieldContext:
  parameters:
    Name name: undocumented
  problemMessage: "This is the declaration of the field '#name'."
  severity: CONTEXT

InvalidGetterSetterTypeGetterContext:
  parameters:
    Name name: undocumented
  problemMessage: "This is the declaration of the getter '#name'."
  severity: CONTEXT

InvalidGetterSetterTypeSetterContext:
  parameters:
    Name name: undocumented
  problemMessage: "This is the declaration of the setter '#name'."
  severity: CONTEXT

PartOfSelf:
  parameters: none
  problemMessage: "A file can't be a part of itself."
  script:
    main.dart: "part 'main.dart';"

TypeParameterDuplicatedName:
  parameters: none
  problemMessage: "A type variable can't have the same name as another."
  script: |
    class C<A, A> {}

TypeParameterDuplicatedNameCause:
  parameters:
    Name name: undocumented
  problemMessage: "The other type variable named '#name'."
  severity: CONTEXT

TypeParameterSameNameAsEnclosing:
  parameters: none
  problemMessage: "A type variable can't have the same name as its enclosing declaration."
  script: |
    class C<C> {}

AnnotationOnFunctionTypeTypeParameter:
  parameters: none
  problemMessage: "A type variable on a function type can't have annotations."
  script: |
     // @dart=2.13
     main() { Function<@Object() T>() x; }

ExpectedEnumBody:
  pseudoSharedCode: MISSING_ENUM_BODY
  parameters:
    Token lexeme: undocumented
  problemMessage: "Expected a enum body, but got '#lexeme'."
  correctionMessage: "An enum definition must have a body with at least one constant name."
  script:
    - "enum E"

EnumDeclarationEmpty:
  parameters: none
  problemMessage: "An enum declaration can't be empty."
  script:
    - "enum E {}"

OperatorWithOptionalFormals:
  parameters: none
  problemMessage: "An operator can't have optional parameters."
  script: |
    class Foo {
      operator ==([Object a = 0]) => true;
    }

PlatformPrivateLibraryAccess:
  parameters: none
  problemMessage: "Can't access platform private library."
  script: |
    import "dart:_internal";

TypedefNotFunction:
  parameters: none
  problemMessage: "Can't create typedef from non-function type."
  script: |
    // @dart=2.12
    class Foo<X> {}
    typedef Bar<X> = Foo<X>;

TypedefNotType:
  parameters: none
  problemMessage: "Can't create typedef from non-type."
  script: |
    typedef Foo = ;
  exampleAllowOtherCodes: true

TypedefTypeParameterNotConstructor:
  parameters: none
  problemMessage: "Can't use a typedef denoting a type variable as a constructor, nor for a static member access."
  script: |
    typedef Foo<Bar> = Bar;
    class Baz extends Foo<C> {}
    class C {}

TypedefTypeParameterNotConstructorCause:
  parameters: none
  problemMessage: "This is the type variable ultimately denoted."
  severity: CONTEXT

TypedefNullableType:
  parameters: none
  problemMessage: "Can't create typedef from nullable type."
  script: |
    // @dart=2.12
    typedef F = void Function()?;

TypedefUnaliasedTypeCause:
  parameters: none
  problemMessage: "This is the type denoted by the type alias."
  severity: CONTEXT

TypedefCause:
  parameters: none
  problemMessage: "The issue arises via this type alias."
  severity: CONTEXT

NonPartOfDirectiveInPart:
  pseudoSharedCode: NON_PART_OF_DIRECTIVE_IN_PART
  parameters: none
  problemMessage: "The part-of directive must be the only directive in a part."
  correctionMessage: "Try removing the other directives, or moving them to the library for which this is a part."
  script:
    - "part of l; part 'f.dart';"

PartTwice:
  parameters:
    Uri uri: undocumented
  problemMessage: "Can't use '#uri' as a part more than once."
  script:
    part.dart: "part of 'main.dart';"
    main.dart: "part 'part.dart'; part 'part.dart';"

PartOfTwoLibraries:
  parameters: none
  problemMessage: "A file can't be part of more than one library."
  correctionMessage: "Try moving the shared declarations into the libraries, or into a new library."
  script:
    main.dart: "library lib; import 'lib.dart'; part 'part.dart';"
    lib.dart: "library lib; part 'part.dart';"
    part.dart: "part of lib;"

PartOfTwoLibrariesContext:
  parameters: none
  problemMessage: "Used as a part in this library."
  severity: CONTEXT

MissingFunctionParameters:
  pseudoSharedCode: MISSING_FUNCTION_PARAMETERS
  parameters: none
  problemMessage: "A function declaration needs an explicit list of parameters."
  correctionMessage: "Try adding a parameter list to the function declaration."
  script:
    - "void f {}"

MissingMethodParameters:
  pseudoSharedCode: MISSING_METHOD_PARAMETERS
  parameters: none
  problemMessage: "A method declaration needs an explicit list of parameters."
  correctionMessage: "Try adding a parameter list to the method declaration."
  script:
    - "class C { void m {} }"

MissingTypedefParameters:
  pseudoSharedCode: MISSING_TYPEDEF_PARAMETERS
  parameters: none
  problemMessage: "A typedef needs an explicit list of parameters."
  correctionMessage: "Try adding a parameter list to the typedef."
  script:
    - "typedef void F;"

MissingPartOf:
  parameters:
    Uri uri: undocumented
  problemMessage: "Can't use '#uri' as a part, because it has no 'part of' declaration."
  script:
    part.dart: ""
    main.dart: "part 'part.dart';"

PartOfInLibrary:
  parameters:
    Uri uri: undocumented
  problemMessage: "Can't import '#uri', because it has a 'part of' declaration."
  correctionMessage: "Try removing the 'part of' declaration, or using '#uri' as a part."
  script:
    main.dart: |
      import "part.dart";
      import "lib.dart";
      main() {}

    part.dart: |
      part of "lib.dart";

    lib.dart: |
      part "part.dart";

PartInPart:
  parameters: none
  problemMessage: "A file that's a part of a library can't have parts itself."
  correctionMessage: "Try moving the 'part' declaration to the containing library."
  script:
    main.dart: |
      part "part.dart";
      main() {}

    part.dart: |
      part of "main.dart";
      part "part_part.dart";

    part_part.dart: |
      part of "part.dart";

PartInPartLibraryContext:
  parameters: none
  problemMessage: "This is the containing library."
  severity: CONTEXT

PartOrphan:
  parameters: none
  problemMessage: "This part doesn't have a containing library."
  correctionMessage: "Try removing the 'part of' declaration."
  script: "part of none; main() {}"

PartExport:
  parameters: none
  problemMessage: "Can't export this file because it contains a 'part of' declaration."
  script:
    main.dart: |
      export "part.dart";
      import "lib.dart";
      main() {}

    part.dart: |
      part of "lib.dart";

    lib.dart: |
      part "part.dart";

PartExportContext:
  parameters: none
  problemMessage: "This is the file that can't be exported."
  severity: CONTEXT

SupertypeIsFunction:
  parameters: none
  problemMessage: "Can't use a function type as supertype."
  script: |
    mixin M on Function() {}

DeferredPrefixDuplicated:
  parameters:
    Name name: undocumented
  problemMessage: "Can't use the name '#name' for a deferred library, as the name is used elsewhere."
  script:
    main.dart: |
      import 'lib1.dart' deferred as foo;
      import 'lib2.dart' as foo;
    lib1.dart: ""
    lib2.dart: ""

DeferredPrefixDuplicatedCause:
  parameters:
    Name name: undocumented
  problemMessage: "'#name' is used here."
  severity: CONTEXT

DuplicatedDeclaration:
  parameters:
    Name name: undocumented
  problemMessage: "'#name' is already declared in this scope."
  script: |
    class C {} // First declaration (related information points here).
    class C {} // Duplicated declaration (error here).
    main() {
      // The following line is commented out as it would lead to an extraneous
      // diagnostic.
      // new C(); // Use of duplicated declaration.
    }

DuplicatedDeclarationCause:
  parameters:
    Name name: undocumented
  problemMessage: "Previous declaration of '#name'."
  severity: CONTEXT

DuplicatedDeclarationSyntheticCause:
  parameters:
    Name name: undocumented
  problemMessage: "Previous declaration of '#name' is implied by this definition."
  severity: CONTEXT

# Use this message when a duplicated declaration is used.
DuplicatedDeclarationUse:
  parameters:
    Name name: undocumented
  problemMessage: "Can't use '#name' because it is declared more than once."
  script:
    - main.dart: |
        // This test can't pass as tests must produce only one error message.
        class C {} // First declaration (related information points here).
        class C {} // Duplicated declaration (error here).
        main() {
          new C(); // Use of duplicated declaration.
        }
    - main.dart: |
        import 'lib1.dart';
        import 'lib2.dart';

        main() {
          new C(); // Use of duplicated declaration.
        }
      lib1.dart: |
        class C {}
      lib2.dart: |
        class C {}

DuplicatedNamedArgument:
  parameters:
    Name name: undocumented
  problemMessage: "Duplicated named argument '#name'."
  script: |
    foo({required int named}) {}

    main() {
      foo(named: 1, named: 2);
    }

DuplicatedParameterName:
  parameters:
    Name name: undocumented
  problemMessage: "Duplicated parameter name '#name'."
  script: |
    foo({required int named, required int named}) {}

DuplicatedParameterNameCause:
  parameters:
    Name name: undocumented
  problemMessage: "Other parameter named '#name'."
  severity: CONTEXT

NotBinaryOperator:
  parameters:
    Token lexeme: undocumented
  problemMessage: "'#lexeme' isn't a binary operator."
  script: |
    class C { operator~() { return null; } }

    main() {
      C c = new C();
      print(c ~ 2);
    }

OperatorParameterMismatch0:
  parameters:
    Name name: undocumented
  problemMessage: "Operator '#name' shouldn't have any parameters."
  script: |
    class Foo {
      operator ~(a) => true;
    }

OperatorParameterMismatch1:
  parameters:
    Name name: undocumented
  problemMessage: "Operator '#name' should have exactly one parameter."
  script: |
    class Foo {
      operator ==() => true;
    }
  exampleAllowOtherCodes: true

OperatorParameterMismatch2:
  parameters:
    Name name: undocumented
  problemMessage: "Operator '#name' should have exactly two parameters."
  script: |
    class Foo {
      operator []=(a, b, c) => true;
    }

OperatorMinusParameterMismatch:
  parameters:
    Name name: undocumented
  problemMessage: "Operator '#name' should have zero or one parameter."
  correctionMessage: >-
    With zero parameters, it has the syntactic form '-a', formally known as 'unary-'.
    With one parameter, it has the syntactic form 'a - b', formally known as '-'.
  script: |
    class Foo {
      operator -(a, b) => true;
    }

SupertypeIsIllegal:
  parameters:
    Name name: undocumented
  problemMessage: "The type '#name' can't be used as supertype."
  script: |
    class C extends dynamic {}

SupertypeIsIllegalAliased:
  parameters:
    Name name: undocumented
    Type type: undocumented
  problemMessage: "The type '#name' which is an alias of '#type' can't be used as supertype."
  script: |
    typedef F = void Function();
    class C extends F {}

SupertypeIsNullableAliased:
  parameters:
    Name name: undocumented
    Type type: undocumented
  problemMessage: "The type '#name' which is an alias of '#type' can't be used as supertype because it is nullable."
  script: |
    class A {}
    typedef B = A?;
    class C extends B {}

SupertypeIsTypeParameter:
  parameters:
    Name name: undocumented
  problemMessage: "The type variable '#name' can't be used as supertype."
  script: |
    class C<T> extends T {}

SuperExtensionTypeIsIllegal:
  parameters:
    Name name: undocumented
  problemMessage: "The type '#name' can't be implemented by an extension type."
  script: |
    extension type E(dynamic it) implements dynamic {}

SuperExtensionTypeIsIllegalAliased:
  parameters:
    Name name: undocumented
    Type type: undocumented
  problemMessage: "The type '#name' which is an alias of '#type' can't be implemented by an extension type."
  script: |
    typedef F = void Function();
    extension type E(F it) implements F {}

SuperExtensionTypeIsNullableAliased:
  parameters:
    Name name: undocumented
    Type type: undocumented
  problemMessage: "The type '#name' which is an alias of '#type' can't be implemented by an extension type because it is nullable."
  script: |
    class A {}
    typedef B = A?;
    extension type E(B it) implements B {}

SuperExtensionTypeIsTypeParameter:
  parameters:
    Name name: undocumented
  problemMessage: "The type variable '#name' can't be implemented by an extension type."
  script: |
    extension type E<T>(T it) implements T {}

PartOfLibraryNameMismatch:
  parameters:
    Uri uri: undocumented
    Name name: undocumented
    Name name2: undocumented
  problemMessage: "Using '#uri' as part of '#name' but its 'part of' declaration says '#name2'."
  script:
    main.dart: |
      library foo;
      part 'lib.dart';
    lib.dart: |
      part of bar;

PartOfUseUri:
  parameters:
    Uri uri: undocumented
    Uri uri2: undocumented
    Name name: undocumented
  problemMessage: "Using '#uri' as part of '#uri2' but its 'part of' declaration says '#name'."
  correctionMessage: "Try changing the 'part of' declaration to use a relative file name."
  script:
    main.dart: |
      part 'lib.dart';
    lib.dart: |
      part of foo;

PartOfUriMismatch:
  parameters:
    Uri uri: undocumented
    Uri uri2: undocumented
    Uri uri3: undocumented
  problemMessage: "Using '#uri' as part of '#uri2' but its 'part of' declaration says '#uri3'."
  script:
    main.dart: |
      part 'lib.dart';
    lib.dart: |
      part of 'lib2.dart';
    lib2.dart: ""

MissingMain:
  parameters: none
  problemMessage: "No 'main' method found."
  correctionMessage: "Try adding a method named 'main' to your program."

MissingInput:
  parameters: none
  problemMessage: "No input file provided to the compiler."

InputFileNotFound:
  parameters:
    Uri uri: undocumented
  problemMessage: "Input file not found: #uri."

SdkRootNotFound:
  parameters:
    Uri uri: undocumented
  problemMessage: "SDK root directory not found: #uri."

SdkSummaryNotFound:
  parameters:
    Uri uri: undocumented
  problemMessage: "SDK summary not found: #uri."

SdkSpecificationNotFound:
  parameters:
    Uri uri: undocumented
  problemMessage: "SDK libraries specification not found: #uri."
  correctionMessage: "Normally, the specification is a file named 'libraries.json' in the Dart SDK install location."

ThisAccessInFieldInitializer:
  parameters:
    Name name: undocumented
  problemMessage: "Can't access 'this' in a field initializer to read '#name'."
  script: |
    class Foo {
      int a = 2;
      int b = a + 42;
    }

ThisOrSuperAccessInFieldInitializer:
  parameters:
    String string: undocumented
  problemMessage: "Can't access '#string' in a field initializer."
  script: |
    class C {
      var x = this;
    }

ThisAsIdentifier:
  parameters: none
  problemMessage: "Expected identifier, but got 'this'."
  script: |
    class C {}
    void foo() {
      C.this();
    }

# TODO(johnniwinther): Confusing message, it should probably mention that `super` is not available.
SuperAsIdentifier:
  parameters: none
  problemMessage: "Expected identifier, but got 'super'."
  script: |
    class C {}
    void foo() {
      C.super();
    }

InvalidAugmentSuper:
  parameters: none
  problemMessage: "'augment super' is only allowed in member augmentations."

SuperAsExpression:
  parameters: none
  problemMessage: "Can't use 'super' as an expression."
  correctionMessage: "To delegate a constructor to a super constructor, put the super call as an initializer."
  script: |
    abstract class A {}

    class B extends A {
      B(): super()?.foo() {}
    }
  exampleAllowOtherCodes: true

SwitchExpressionNotAssignableCause:
  parameters: none
  problemMessage: "The switch expression is here."
  severity: CONTEXT

SwitchExpressionNotSubtype:
  parameters:
    Type type: undocumented
    Type type2: undocumented
  problemMessage: "Type '#type' of the case expression is not a subtype of type '#type2' of this switch expression."
  script:
    - |
      // @dart=2.19
      void f() {
        switch (42) {
          case "foo": break;
        }
      }

SwitchCaseFallThrough:
  parameters: none
  problemMessage: "Switch case may fall through to the next case."
  script: |
    // @dart=2.19
    method(e) {
      switch (e) {
        case 0: print(0);
        case 1: print(1);
      }
    }

FieldAlreadyInitializedAtDeclaration:
  parameters:
    Name name: undocumented
  problemMessage: "'#name' is a final instance variable that was initialized at the declaration."
  script:
    - "class C { final int x = 2; C(): this.x = 3 {} }"

FieldAlreadyInitializedAtDeclarationCause:
  parameters:
    Name name: undocumented
  problemMessage: "'#name' was initialized here."
  severity: CONTEXT

ConstructorInitializeSameInstanceVariableSeveralTimes:
  parameters:
    Name name: undocumented
  problemMessage: "'#name' was already initialized by this constructor."
  script:
    - "class C { final int x; C(): this.x = 1, this.x = 2 {} }"
    - "class C { int x; C(): this.x = 1, this.x = 2 {} }"

TypeVariableInStaticContext:
  parameters: none
  problemMessage: "Type variables can't be used in static members."
  declaration:
    - |
      class C<T> {
        static List<T> staticMethod() {}
      }
    - |
      class C<T> {
        static T staticMethod() {}
      }
    - |
      class C<T> {
        static staticMethod(List<T> argument) {}
      }
    - |
      class C<T> {
        static staticMethod(T argument) {}
      }
    - |
      class C<T> {
        static staticMethod() {
          List<T>? t = null;
          return t;
        }
      }
    - |
      class C<T> {
        static staticMethod() {
          T? t = null;
          return t;
        }
      }

TypeVariableInConstantContext:
  parameters: none
  problemMessage: "Type variables can't be used as constants."
  declaration:
    - |
      class C<T> {
        instanceMethod() {
          return const <Object>[T];
        }
      }
    - |
      class C<T> {
        instanceMethod() {
          return const <T>[];
        }
      }
    - |
      class C<T> {
        instanceMethod() {
          return const <List<T>>[];
        }
      }

SuperclassHasNoMember:
  parameters:
    Name name: undocumented
  problemMessage: "Superclass has no member named '#name'."

SuperclassHasNoGetter:
  parameters:
    Name name: undocumented
  problemMessage: "Superclass has no getter named '#name'."
  script: |
    class Super {}

    class Class extends Super {
      method() {
        super.missingSuperGetter;
      }
    }

SuperclassHasNoSetter:
  parameters:
    Name name: undocumented
  problemMessage: "Superclass has no setter named '#name'."
  script: |
    class Super {}

    class Class extends Super {
      method() {
        super.missingSuperSetter = 42;
      }
    }

SuperclassHasNoMethod:
  parameters:
    Name name: undocumented
  problemMessage: "Superclass has no method named '#name'."
  script: |
    class Super {}

    class Class extends Super {
      method() {
        super.missingSuperMethod();
      }
    }

SuperclassHasNoConstructor:
  parameters:
    Name name: undocumented
  problemMessage: "Superclass has no constructor named '#name'."
  script:
    - |
      class Super {
        Super._();
      }

      class Sub extends Super {
        Sub() : super();
      }
    - |
      class Super {
        Super._();
      }

      class Sub extends Super {
        Sub.foo() : super.foo();
      }

SuperclassHasNoDefaultConstructor:
  parameters:
    Name name: undocumented
  problemMessage: "The superclass, '#name', has no unnamed constructor that takes no arguments."
  script: |
    class Foo {
      Foo(int x);
    }
    class Bar extends Foo { }

ConstConstructorNonFinalField:
  parameters: none
  problemMessage: "Constructor is marked 'const' so all fields must be final."
  script: |
    class Foo {
      int i;
      const Foo(this.i);
    }

ConstConstructorNonFinalFieldCause:
  parameters: none
  problemMessage: "Field isn't final, but constructor is 'const'."
  severity: CONTEXT

ConstConstructorLateFinalFieldError:
  parameters: none
  problemMessage: "Can't have a late final field in a class with a const constructor."
  script: |
    class Foo {
      late final int i = 42;
      const Foo();
    }

ConstConstructorLateFinalFieldCause:
  parameters: none
  problemMessage: "This constructor is const."
  severity: CONTEXT

ConstConstructorRedirectionToNonConst:
  parameters: none
  problemMessage: "A constant constructor can't call a non-constant constructor."
  script:
    - >-
      class A {
        const A.foo() : this.bar();
        A.bar() {}
      }

ConstConstructorWithNonConstSuper:
  parameters: none
  problemMessage: "A constant constructor can't call a non-constant super constructor."
  script:
    - >-
      class A {
        A.bar() {}
      }
      class B extends A {
        const B.foo() : super.bar();
      }

ExpressionNotMetadata:
  parameters: none
  problemMessage: "This can't be used as an annotation; an annotation should be a reference to a compile-time constant variable, or a call to a constant constructor."
  script: |
    @foo
    void foo() {}

CannotAssignToParenthesizedExpression:
  parameters: none
  problemMessage: "Can't assign to a parenthesized expression."
  script: |
    int i = 42;
    int test2() {
      return (i) ++ (i);
    }
  exampleAllowOtherCodes: true

NotAnLvalue:
  parameters: none
  problemMessage: "Can't assign to this."
  script: |
    class Foo {
      void bar() {
        --toString();
      }
    }

CannotAssignToSuper:
  parameters: none
  problemMessage: "Can't assign to super."

CannotReadSdkSpecification:
  parameters:
    String string: undocumented
  problemMessage: "Unable to read the 'libraries.json' specification file:\n  #string."

CantInferPackagesFromManyInputs:
  parameters: none
  problemMessage: "Can't infer a packages file when compiling multiple inputs."
  correctionMessage: "Try specifying the file explicitly with the --packages option."

CantInferPackagesFromPackageUri:
  parameters: none
  problemMessage: "Can't infer a packages file from an input 'package:*' URI."
  correctionMessage: "Try specifying the file explicitly with the --packages option."

PackageNotFound:
  parameters:
    Name name: undocumented
    Uri uri: undocumented
  problemMessage: "Couldn't resolve the package '#name' in '#uri'."
  script: |
    import 'package:foo/foo.dart';
  exampleAllowOtherCodes: true

InvalidPackageUri:
  parameters:
    Uri uri: undocumented
    String string: undocumented
  problemMessage: "Invalid package URI '#uri':\n  #string."
  script: |
    import 'package:foo';
  exampleAllowOtherCodes: true

CouldNotParseUri:
  parameters:
    String string: undocumented
    String string2: undocumented
  problemMessage: "Couldn't parse URI '#string':\n  #string2."
  script: |
    import ' dart:async';
  exampleAllowOtherCodes: true

ExpectedUri:
  parameters: none
  problemMessage: "Expected a URI."
  script: |
    import ' dart:async';
  exampleAllowOtherCodes: true

InterpolationInUri:
  pseudoSharedCode: INVALID_LITERAL_IN_CONFIGURATION
  parameters: none
  problemMessage: "Can't use string interpolation in a URI."
  script: |
    import 'package:/foo/$bar.dart';
  exampleAllowOtherCodes: true

IntegerLiteralIsOutOfRange:
  parameters:
    String string: undocumented
  problemMessage: "The integer literal #string can't be represented in 64 bits."
  correctionMessage: "Try using the BigInt class if you need an integer larger than 9,223,372,036,854,775,807 or less than -9,223,372,036,854,775,808."
  script: |
    void foo() {
      int i = 9223372036854775808;
    }

ArgumentTypeNotAssignable:
  parameters:
    Type type: undocumented
    Type type2: undocumented
  problemMessage: "The argument type '#type' can't be assigned to the parameter type '#type2'."
  script: |
    method(int i) {}
    main() {
      method(1.5);
    }

InvalidAssignmentError:
  parameters:
    Type type: undocumented
    Type type2: undocumented
  problemMessage: "A value of type '#type' can't be assigned to a variable of type '#type2'."
  script: |
    main() {
      int i;
      i = 1.5;
    }

PatchClassTypeParametersMismatch:
  parameters: none
  problemMessage: "A patch class must have the same number of type variables as its origin class."

PatchClassOrigin:
  parameters: none
  problemMessage: "This is the origin class."
  severity: CONTEXT

PatchExtensionTypeParametersMismatch:
  parameters: none
  problemMessage: "A patch extension must have the same number of type variables as its origin extension."

PatchExtensionOrigin:
  parameters: none
  problemMessage: "This is the origin extension."
  severity: CONTEXT

PatchDeclarationOrigin:
  parameters: none
  problemMessage: "This is the origin declaration."
  severity: CONTEXT

PatchInjectionFailed:
  parameters:
    Name name: undocumented
    Uri uri: undocumented
  problemMessage: "Can't inject public '#name' into '#uri'."
  correctionMessage: "Make '#name' private, or make sure injected library has \"dart\" scheme and is private (e.g. \"dart:_internal\")."

InvalidCastFunctionExpr:
  parameters:
    Type type: undocumented
    Type type2: undocumented
  problemMessage: "The function expression type '#type' isn't of expected type '#type2'."
  correctionMessage: "Change the type of the function expression or the context in which it is used."

InvalidCastLiteralList:
  parameters:
    Type type: undocumented
    Type type2: undocumented
  problemMessage: "The list literal type '#type' isn't of expected type '#type2'."
  correctionMessage: "Change the type of the list literal or the context in which it is used."

InvalidCastLiteralMap:
  parameters:
    Type type: undocumented
    Type type2: undocumented
  problemMessage: "The map literal type '#type' isn't of expected type '#type2'."
  correctionMessage: "Change the type of the map literal or the context in which it is used."

InvalidCastLiteralSet:
  parameters:
    Type type: undocumented
    Type type2: undocumented
  problemMessage: "The set literal type '#type' isn't of expected type '#type2'."
  correctionMessage: "Change the type of the set literal or the context in which it is used."

InvalidCastLocalFunction:
  parameters:
    Type type: undocumented
    Type type2: undocumented
  problemMessage: "The local function has type '#type' that isn't of expected type '#type2'."
  correctionMessage: "Change the type of the function or the context in which it is used."

InvalidCastNewExpr:
  parameters:
    Type type: undocumented
    Type type2: undocumented
  problemMessage: "The constructor returns type '#type' that isn't of expected type '#type2'."
  correctionMessage: "Change the type of the object being constructed or the context in which it is used."

InvalidCastStaticMethod:
  parameters:
    Type type: undocumented
    Type type2: undocumented
  problemMessage: "The static method has type '#type' that isn't of expected type '#type2'."
  correctionMessage: "Change the type of the method or the context in which it is used."

InvalidCastTopLevelFunction:
  parameters:
    Type type: undocumented
    Type type2: undocumented
  problemMessage: "The top level function has type '#type' that isn't of expected type '#type2'."
  correctionMessage: "Change the type of the function or the context in which it is used."

InvalidUseOfNullAwareAccess:
  parameters: none
  problemMessage: "Cannot use '?.' here."
  correctionMessage: "Try using '.'."
  script: |
    class Super {
      Super.named();
    }

    class Class extends Super {
      Class() : super?.named();
    }
  exampleAllowOtherCodes: true

UndefinedGetter:
  parameters:
    Name name: undocumented
    Type type: undocumented
  problemMessage: "The getter '#name' isn't defined for the type '#type'."
  correctionMessage: "Try correcting the name to the name of an existing getter, or defining a getter or field named '#name'."
  script: |
    class C {}
    test(C c) {
      print(c.foo);
    }

UndefinedSetter:
  parameters:
    Name name: undocumented
    Type type: undocumented
  problemMessage: "The setter '#name' isn't defined for the type '#type'."
  correctionMessage: "Try correcting the name to the name of an existing setter, or defining a setter or field named '#name'."
  script: |
    class C {}
    test(C c) {
      c.foo = 0;
    }

UndefinedMethod:
  parameters:
    Name name: undocumented
    Type type: undocumented
  problemMessage: "The method '#name' isn't defined for the type '#type'."
  correctionMessage: "Try correcting the name to the name of an existing method, or defining a method named '#name'."
  script: |
    class C {}
    test(C c) {
      c.foo();
    }

UndefinedOperator:
  parameters:
    Name name: undocumented
    Type type: undocumented
  problemMessage: "The operator '#name' isn't defined for the type '#type'."
  correctionMessage: "Try correcting the operator to an existing operator, or defining a '#name' operator."
  script: |
    class C {}
    test(C c) {
      c + 0;
    }

AmbiguousExtensionMethod:
  parameters:
    Name name: undocumented
    Type type: undocumented
  problemMessage: "The method '#name' is defined in multiple extensions for '#type' and neither is more specific."
  correctionMessage: "Try using an explicit extension application of the wanted extension or hiding unwanted extensions from scope."
  script: |
    class C {}
    extension A on C { method() {} }
    extension B on C { method() {} }
    main() {
      C c = new C();
      c.method();
    }

AmbiguousExtensionProperty:
  parameters:
    Name name: undocumented
    Type type: undocumented
  problemMessage: "The property '#name' is defined in multiple extensions for '#type' and neither is more specific."
  correctionMessage: "Try using an explicit extension application of the wanted extension or hiding unwanted extensions from scope."
  script: |
    class C {}
    extension A on C { get property => null; }
    extension B on C { set property(_) {} }
    main() {
      C c = new C();
      c.property;
    }

AmbiguousExtensionOperator:
  parameters:
    Name name: undocumented
    Type type: undocumented
  problemMessage: "The operator '#name' is defined in multiple extensions for '#type' and neither is more specific."
  correctionMessage: "Try using an explicit extension application of the wanted extension or hiding unwanted extensions from scope."
  script: |
    class C {}
    extension A on C { operator +(int i) {} }
    extension B on C { operator +(int i) {}  }
    main() {
      C c = new C();
      c + 0;
    }

AmbiguousExtensionCause:
  parameters: none
  problemMessage: "This is one of the extension members."
  severity: CONTEXT

SourceOutlineSummary:
  parameters:
    int count: undocumented
    int count2: undocumented
    num num1: undocumented
    num num2: undocumented
    num num3: undocumented
  problemMessage: |
    Built outlines for #count compilation units (#count2 bytes) in #num1%.3ms, that is,
    #num2%12.3 bytes/ms, and
    #num3%12.3 ms/compilation unit.

SourceBodySummary:
  parameters:
    int count: undocumented
    int count2: undocumented
    num num1: undocumented
    num num2: undocumented
    num num3: undocumented
  problemMessage: |
    Built bodies for #count compilation units (#count2 bytes) in #num1%.3ms, that is,
    #num2%12.3 bytes/ms, and
    #num3%12.3 ms/compilation unit.

DillOutlineSummary:
  parameters:
    int count: undocumented
    int count2: undocumented
    num num1: undocumented
    num num2: undocumented
    num num3: undocumented
  problemMessage: |
    Indexed #count libraries (#count2 bytes) in #num1%.3ms, that is,
    #num2%12.3 bytes/ms, and
    #num3%12.3 ms/libraries.

CantInferTypesDueToNoCombinedSignature:
  parameters:
    Name name: undocumented
  problemMessage: "Can't infer types for '#name' as the overridden members don't have a combined signature."
  correctionMessage: "Try adding explicit types."
  script: |
    class A {
      void method(int a, String b) {}
    }
    class B {
      void method(String a, int b) {}
    }
    class C implements A, B {
      void method(a, b) {}
    }

CantInferTypeDueToNoCombinedSignature:
  parameters:
    Name name: undocumented
  problemMessage: "Can't infer a type for '#name' as the overridden members don't have a combined signature."
  correctionMessage: "Try adding an explicit type."
  script: |
    class A {
      void method(int a) {}
    }
    class B {
      void method(String a) {}
    }
    class C implements A, B {
      void method(a) {}
    }

CantInferReturnTypeDueToNoCombinedSignature:
  parameters:
    Name name: undocumented
  problemMessage: "Can't infer a return type for '#name' as the overridden members don't have a combined signature."
  correctionMessage: "Try adding an explicit type."
  script: |
    abstract class A {
      int get getter;
    }
    abstract class B {
      String get getter;
    }
    abstract class C implements A, B {
      get getter;
    }

CantInferTypeDueToCircularity:
  parameters:
    String string: undocumented
  problemMessage: "Can't infer the type of '#string': circularity found during type inference."
  correctionMessage: "Specify the type explicitly."
  script: |
    enum CyclicReference {
      e1(e2),
      e2(e1);

      final CyclicReference other;
      const CyclicReference(this.other);
    }
  exampleAllowOtherCodes: true

AmbiguousSupertypes:
  parameters:
    Name name: undocumented
    Type type: undocumented
    Type type2: undocumented
  problemMessage: "'#name' can't implement both '#type' and '#type2'"
  script: |
    class A<T> {}
    mixin class B<T> implements A<T> {}
    class C<T> implements A<T> {}
    class D implements B<String>, C<int> {}

MixinInferenceNoMatchingClass:
  parameters:
    Name name: undocumented
    Name name2: undocumented
    Type type: undocumented
  problemMessage: "Type parameters couldn't be inferred for the mixin '#name' because '#name2' does not implement the mixin's supertype constraint '#type'."
  script: |
    abstract class A<T> {}
    mixin M<T> on A<T> {}
    class C extends Object with M {}
  exampleAllowOtherCodes: true

ImplicitCallOfNonMethod:
  parameters:
    Type type: undocumented
  problemMessage: "Cannot invoke an instance of '#type' because it declares 'call' to be something other than a method."
  correctionMessage: "Try changing 'call' to a method or explicitly invoke 'call'."
  script: |
    class Class { void Function() get call => () {}; }
    method(Class c) => c();

ImplicitSuperCallOfNonMethod:
  parameters: none
  problemMessage: "Cannot invoke `super` because it declares 'call' to be something other than a method."
  correctionMessage: "Try changing 'call' to a method or explicitly invoke 'call'."
  script: |
    class Super { void Function() get call => () {}; }
    class Class extends Super { void method() => super(); }

ExpectedOneExpression:
  parameters: none
  problemMessage: "Expected one expression, but found additional input."

ForInLoopNotAssignable:
  parameters: none
  problemMessage: "Can't assign to this, so it can't be used in a for-in loop."
  statement: "for (1 in []) {}"
  exampleAllowOtherCodes: true

ForInLoopExactlyOneVariable:
  parameters: none
  problemMessage: "A for-in loop can't have more than one loop variable."
  statement: "for (var x, y in []) {}"
  exampleAllowOtherCodes: true

ForInLoopWithConstVariable:
  parameters: none
  problemMessage: "A for-in loop-variable can't be 'const'."
  correctionMessage: "Try removing the 'const' modifier."
  script: |
    void foo() {
      for(const i in [42]) {}
    }

ForInLoopElementTypeNotAssignable:
  parameters:
    Type type: undocumented
    Type type2: undocumented
  problemMessage: "A value of type '#type' can't be assigned to a variable of type '#type2'."
  correctionMessage: "Try changing the type of the variable."
  script: |
    method() {
      List<String> list = [];
      for (int i in list) {}
    }

ForInLoopTypeNotIterable:
  parameters:
    Type type: undocumented
    Type type2: undocumented
  problemMessage: "The type '#type' used in the 'for' loop must implement '#type2'."
  script: |
    method() {
      String list = '';
      for (int i in list) {}
    }

InitializingFormalTypeMismatch:
  parameters:
    Name name: undocumented
    Type type: undocumented
    Type type2: undocumented
  problemMessage: "The type of parameter '#name', '#type' is not a subtype of the corresponding field's type, '#type2'."
  correctionMessage: "Try changing the type of parameter '#name' to a subtype of '#type2'."
  script: |
    class C {
      int x;
      C(num this.x);
    }

InitializingFormalTypeMismatchField:
  parameters: none
  problemMessage: "The field that corresponds to the parameter."
  severity: CONTEXT

InitializeFromDillNotSelfContained:
  parameters:
    String string: undocumented
    Uri uri: undocumented
  problemMessage: |
    Tried to initialize from a previous compilation (#string), but the file was not self-contained. This might be a bug.

    The Dart team would greatly appreciate it if you would take a moment to report this problem at http://dartbug.com/new.
    If you are comfortable with it, it would improve the chances of fixing any bug if you included the file #uri in your error report, but be aware that this file includes your source code.
    Either way, you should probably delete the file so it doesn't use unnecessary disk space.

  severity: WARNING
  frontendInternal: true
  external: test/incremental_load_from_invalid_dill_test.dart

InitializeFromDillNotSelfContainedNoDump:
  parameters:
    String string: undocumented
  problemMessage: |
    Tried to initialize from a previous compilation (#string), but the file was not self-contained. This might be a bug.

    The Dart team would greatly appreciate it if you would take a moment to report this problem at http://dartbug.com/new.

  severity: WARNING
  frontendInternal: true
  external: test/incremental_load_from_invalid_dill_test.dart

InitializeFromDillUnknownProblem:
  parameters:
    String string: undocumented
    String string2: undocumented
    String string3: undocumented
    Uri uri: undocumented
  problemMessage: |
    Tried to initialize from a previous compilation (#string), but couldn't.
    Error message was '#string2'.
    Stacktrace included '#string3'.
    This might be a bug.

    The Dart team would greatly appreciate it if you would take a moment to report this problem at http://dartbug.com/new.
    If you are comfortable with it, it would improve the chances of fixing any bug if you included the file #uri in your error report, but be aware that this file includes your source code.
    Either way, you should probably delete the file so it doesn't use unnecessary disk space.

  severity: WARNING
  frontendInternal: true
  external: test/incremental_load_from_invalid_dill_test.dart

InitializeFromDillUnknownProblemNoDump:
  parameters:
    String string: undocumented
    String string2: undocumented
    String string3: undocumented
  problemMessage: |
    Tried to initialize from a previous compilation (#string), but couldn't.
    Error message was '#string2'.
    Stacktrace included '#string3'.
    This might be a bug.

    The Dart team would greatly appreciate it if you would take a moment to report this problem at http://dartbug.com/new.

  severity: WARNING
  frontendInternal: true
  external: test/incremental_load_from_invalid_dill_test.dart

WebLiteralCannotBeRepresentedExactly:
  parameters:
    String string: undocumented
    String string2: undocumented
  problemMessage: "The integer literal #string can't be represented exactly in JavaScript."
  correctionMessage: "Try changing the literal to something that can be represented in JavaScript. In JavaScript #string2 is the nearest value that can be represented exactly."

BoundIssueViaRawTypeWithNonSimpleBounds:
  parameters:
    Name name: undocumented
  problemMessage: "Generic type '#name' can't be used without type arguments in a type variable bound."
  correctionMessage: "Try providing type arguments to '#name' here."
  script: |
    class Hest<X extends Hest<X>> {}
    class Fisk<Y extends Hest> {}

NonSimpleBoundViaVariable:
  parameters:
    Name name: undocumented
  problemMessage: "Bound of this variable references variable '#name' from the same declaration."
  severity: CONTEXT

BoundIssueViaLoopNonSimplicity:
  parameters:
    Name name: undocumented
  problemMessage: "Generic type '#name' can't be used without type arguments in the bounds of its own type variables."
  correctionMessage: "Try providing type arguments to '#name' here."
  script: |
    class Hest<X extends Hest> {}

BoundIssueViaCycleNonSimplicity:
  parameters:
    Name name: undocumented
    Name name2: undocumented
  problemMessage: "Generic type '#name' can't be used without type arguments in the bounds of its own type variables. It is referenced indirectly through '#name2'."
  correctionMessage: "Try providing type arguments to '#name2' here or to some other raw types in the bounds along the reference chain."
  script: |
    class Hest<X extends Fisk> {}
    class Fisk<Y extends Hest> {}

NonSimpleBoundViaReference:
  parameters:
    Name name: undocumented
  problemMessage: "Bound of this variable references raw type '#name'."
  severity: CONTEXT

CycleInTypeParameters:
  parameters:
    Name name: undocumented
    String string: undocumented
  problemMessage: "Type '#name' is a bound of itself via '#string'."
  correctionMessage: "Try breaking the cycle by removing at least one of the 'extends' clauses in the cycle."
  script:
    - "foo<A extends B, B extends A>() {}"

DirectCycleInTypeParameters:
  parameters:
    Name name: undocumented
  problemMessage: "Type '#name' can't use itself as a bound."
  correctionMessage: "Try breaking the cycle by removing at least one of the 'extends' clauses in the cycle."
  script:
    - "foo<A extends A>() {}"

CantUsePrefixAsExpression:
  parameters: none
  problemMessage: "A prefix can't be used as an expression."
  script: |
    import "dart:core" as prefix;

    main() {
      for (prefix in []) {}
    }

CantUsePrefixWithNullAware:
  parameters: none
  problemMessage: "A prefix can't be used with null-aware operators."
  correctionMessage: "Try replacing '?.' with '.'"
  script: |
    import "dart:core" as prefix;

    main() {
      prefix?.Object;
    }

CantUseControlFlowOrSpreadAsConstant:
  parameters:
    Token lexeme: undocumented
  problemMessage: "'#lexeme' is not supported in constant expressions."
  script: |
    test() {
      const List<int> list1 = const [for (var i = 1; i < 4; i++) i];
    }
  exampleAllowOtherCodes: true

CantUseDeferredPrefixAsConstant:
  parameters:
    Token lexeme: undocumented
  problemMessage: >
    '#lexeme' can't be used in a constant expression because it's marked as
    'deferred' which means it isn't available until loaded.
  correctionMessage: >
    Try moving the constant from the deferred library, or removing 'deferred'
    from the import.
  script: |
    import "dart:convert" deferred as prefix;

    main() {
      const prefix.JsonCodec();
    }

CyclicRedirectingFactoryConstructors:
  parameters:
    Name name: undocumented
  problemMessage: "Cyclic definition of factory '#name'."
  script: |
    class Foo {
      factory Foo.foo() = Foo.bar;
      factory Foo.bar() = Foo.foo;
    }
    main() { var foo = new Foo.foo(); }
  exampleAllowMultipleReports: true

GenericFunctionTypeInBound:
  parameters: none
  problemMessage: "Type variables can't have generic function types in their bounds."
  script: |
    // @dart=2.13
    class Hest<X extends Y Function<Y>(Y)> {}

VoidExpression:
  parameters: none
  problemMessage: "This expression has type 'void' and can't be used."
  statement: |
    {
      void x;
      int y = x;
    }

ReturnFromVoidFunction:
  parameters: none
  problemMessage: "Can't return a value from a void function."
  declaration: "void foo() { return 1; }"

ReturnWithoutExpressionSync:
  parameters: none
  problemMessage: "A value must be explicitly returned from a non-void function."
  script: |
    import "dart:async";
    FutureOr<Object?> foo() { return; }

ReturnWithoutExpressionAsync:
  parameters: none
  problemMessage: "A value must be explicitly returned from a non-void async function."
  declaration: "Future<int> foo() async { return; }"

InvalidReturn:
  parameters:
    Type type: undocumented
    Type type2: undocumented
  problemMessage: "A value of type '#type' can't be returned from a function with return type '#type2'."
  declaration: "int foo() { return true; }"

InvalidReturnAsync:
  parameters:
    Type type: undocumented
    Type type2: undocumented
  problemMessage: "A value of type '#type' can't be returned from an async function with return type '#type2'."
  declaration: "Future<int> foo() async { return true; }"

ImplicitReturnNull:
  parameters:
    Type type: undocumented
  problemMessage: "A non-null value must be returned since the return type '#type' doesn't allow null."
  script: |
    String method() {}

RethrowNotCatch:
  parameters: none
  problemMessage: "'rethrow' can only be used in catch clauses."
  script: |
    void foo() {
      try {
        rethrow;
      } catch (e) {}
    }

InvokeNonFunction:
  parameters:
    Name name: undocumented
  problemMessage: "'#name' isn't a function or method and can't be invoked."
  script: |
    abstract class Foo {
      int get f;
    }
    method(Foo foo) => foo.f();

ConstInstanceField:
  parameters: none
  problemMessage: "Only static fields can be declared as const."
  correctionMessage: "Try using 'final' instead of 'const', or adding the keyword 'static'."
  script:
    - "class C { const field = 0; }"

DefaultValueInRedirectingFactoryConstructor:
  parameters:
    Name name: undocumented
  problemMessage: "Can't have a default value here because any default values of '#name' would be used instead."
  correctionMessage: "Try removing the default value."
  script:
    - >-
      class A {
        factory A.f({int x = 42}) = A.g;
        A.g({int x = 40}) {}
      }

UntranslatableUri:
  parameters:
    Uri uri: undocumented
  problemMessage: "Not found: '#uri'"
  exampleAllowOtherCodes: true # PackageNotFound will precede this message.
  script: |
    import "package:expect/non_existing_file";

UnavailableDartLibrary:
  parameters:
    Uri uri: undocumented
  problemMessage: "Dart library '#uri' is not available on this platform."
  script: |
    import "dart:non_existing_library";

ImportChainContext:
  parameters:
    Uri uri: undocumented
    String string: undocumented
    String string2: undocumented
  problemMessage: |
    The unavailable library '#uri' is imported through these packages:

    #string
    Detailed import paths for (some of) the these imports:

    #string2
  severity: CONTEXT

ImportChainContextSimple:
  parameters:
    Uri uri: undocumented
    String string: undocumented
  problemMessage: |
    The unavailable library '#uri' is imported through these paths:

    #string
  severity: CONTEXT

CantReadFile:
  parameters:
    Uri uri: undocumented
    String string: undocumented
  problemMessage: "Error when reading '#uri': #string"
  external: test/packages_format_error_test.dart
  script: |
    import "non_existing_file.dart";

ExceptionReadingFile:
  parameters:
    Uri uri: undocumented
    String string: undocumented
  problemMessage: "Exception when reading '#uri': #string"

PackagesFileFormat:
  parameters:
    String string: undocumented
  problemMessage: "Problem in packages configuration file: #string"
  external: test/packages_format_error_test.dart

IncompatibleRedirecteeFunctionType:
  parameters:
    Type type: undocumented
    Type type2: undocumented
  problemMessage: "The constructor function type '#type' isn't a subtype of '#type2'."
  script:
    - >-
      class A {
        factory A() = B;
      }
      class B {
        B();
      }
    - >-
      class A {
        factory A.one(int x) = A.zero;
        A.zero() {}
      }
    - >-
      class A {
        factory A.i(int x) = A.s;
        A.s(String x) { }
      }
    - >-
      class A {
        factory A.f({int? x}) = A.g;
        A.g({int? y}) { }
      }
    - >-
      class A {
        factory A.f(int x) = A.g;
        A.g(int x, int y) {}
      }

RedirectingFactoryIncompatibleTypeArgument:
  parameters:
    Type type: undocumented
    Type type2: undocumented
  problemMessage: "The type '#type' doesn't extend '#type2'."
  correctionMessage: "Try using a different type as argument."
  script:
    - >-
      class A<T extends int> {
         factory A() = B<T, int>;
      }
      class B<T extends int, S extends String> implements A<T> {}

SyntheticToken:
  parameters: none
  problemMessage: "This couldn't be parsed."
  frontendInternal: true

IncorrectTypeArgument:
  parameters:
    Type type: undocumented
    Type type2: undocumented
    Name name: undocumented
    Name name2: undocumented
  problemMessage: "Type argument '#type' doesn't conform to the bound '#type2' of the type variable '#name' on '#name2'."
  correctionMessage: "Try changing type arguments so that they conform to the bounds."
  script: |
    class C<T extends num> {}
    main() { new C<String>(); }

IncorrectTypeArgumentQualified:
  parameters:
    Type type: undocumented
    Type type2: undocumented
    Name name: undocumented
    Type type3: undocumented
    Name name2: undocumented
  problemMessage: "Type argument '#type' doesn't conform to the bound '#type2' of the type variable '#name' on '#type3.#name2'."
  correctionMessage: "Try changing type arguments so that they conform to the bounds."
  script: |
    class C<T> { foo<U extends num>() {} }
    main() { new C<String>().foo<String>(); }

IncorrectTypeArgumentInferred:
  parameters:
    Type type: undocumented
    Type type2: undocumented
    Name name: undocumented
    Name name2: undocumented
  problemMessage: "Inferred type argument '#type' doesn't conform to the bound '#type2' of the type variable '#name' on '#name2'."
  correctionMessage: "Try specifying type arguments explicitly so that they conform to the bounds."
  script: |
    foo<T extends List<S>, S extends num>(T t) {}
    main() { foo(<String>[""]); }

IncorrectTypeArgumentQualifiedInferred:
  parameters:
    Type type: undocumented
    Type type2: undocumented
    Name name: undocumented
    Type type3: undocumented
    Name name2: undocumented
  problemMessage: "Inferred type argument '#type' doesn't conform to the bound '#type2' of the type variable '#name' on '#type3.#name2'."
  correctionMessage: "Try specifying type arguments explicitly so that they conform to the bounds."
  script: |
    class A { foo<T extends List<S>, S extends num>(T t) {} }
    main() { new A().foo(<String>[""]); }

IncorrectTypeArgumentInstantiation:
  parameters:
    Type type: undocumented
    Type type2: undocumented
    Name name: undocumented
    Type type3: undocumented
  problemMessage: "Type argument '#type' doesn't conform to the bound '#type2' of the type variable '#name' on '#type3'."
  correctionMessage: "Try changing type arguments so that they conform to the bounds."
  script: |
    X bounded<X extends num>(X x) => x;
    main() {
      bounded<String>;
    }

IncorrectTypeArgumentInstantiationInferred:
  parameters:
    Type type: undocumented
    Type type2: undocumented
    Name name: undocumented
    Type type3: undocumented
  problemMessage: "Inferred type argument '#type' doesn't conform to the bound '#type2' of the type variable '#name' on '#type3'."
  correctionMessage: "Try specifying type arguments explicitly so that they conform to the bounds."
  script: |
    X bounded<X extends List<Y>, Y extends num>(X x) => x;
    main() {
      List<String> Function(List<String>) c = bounded;
    }

IncorrectTypeArgumentVariable:
  parameters: none
  problemMessage: "This is the type variable whose bound isn't conformed to."
  severity: CONTEXT

SuperBoundedHint:
  parameters:
    Type type: undocumented
    Type type2: undocumented
  problemMessage: "If you want '#type' to be a super-bounded type, note that the inverted type '#type2' must then satisfy its bounds, which it does not."
  severity: CONTEXT

MixinApplicationIncompatibleSupertype:
  parameters:
    Type type: undocumented
    Type type2: undocumented
    Type type3: undocumented
  problemMessage: "'#type' doesn't implement '#type2' so it can't be used with '#type3'."
  script: |-
    class I {}
    mixin M on I {}
    class C = Object with M;

GenericFunctionTypeUsedAsActualTypeArgument:
  parameters: none
  problemMessage: "A generic function type can't be used as a type argument."
  correctionMessage: "Try using a non-generic function type."
  script:
    - |
      // @dart=2.13
      typedef F = Class<T> Function<T>(T);
      class Class<T> {}
      main() {
        Class<F> class1;
      }
    - |
      // @dart=2.13
      typedef F = Class<T> Function<T>(T);
      class Class<T> {}
      main() {
        Class<F>();
      }

GenericFunctionTypeInferredAsActualTypeArgument:
  parameters:
    Type type: undocumented
  problemMessage: "Generic function type '#type' inferred as a type argument."
  correctionMessage: "Try providing a non-generic function type explicitly."
  script: |
    // @dart=2.13
    foo<X>(X x) => null;
    bar<Y>(Y y) => null;
    main() { foo(bar); }

GenericFunctionTypeAsTypeArgumentThroughTypedef:
  parameters:
    Type type: undocumented
    Type type2: undocumented
  problemMessage: "Generic function type '#type' used as a type argument through typedef '#type2'."
  correctionMessage: "Try providing a non-generic function type explicitly."
  script:
    main.dart: |
      // @dart=2.12
      import 'lib.dart';
      test(T3 t3a) {}
    lib.dart: |
      typedef T3 = List<void Function<T>(T)>;

# These two message templates are used for constructing supplemental text
# about the origins of raw interface types in error messages containing types.
TypeOrigin:
  parameters:
    Name name: undocumented
    Uri uri: undocumented
  problemMessage: "'#name' is from '#uri'."
  frontendInternal: true
  external: test/type_labeler_test.dart

TypeOriginWithFileUri:
  parameters:
    Name name: undocumented
    Uri uri: undocumented
    Uri uri2: undocumented
  problemMessage: "'#name' is from '#uri' ('#uri2')."
  frontendInternal: true
  external: test/type_labeler_test.dart

ObjectExtends:
  parameters: none
  problemMessage: "The class 'Object' can't have a superclass."
  frontendInternal: true
  external: test/object_supertype_test.dart

ObjectImplements:
  parameters: none
  problemMessage: "The class 'Object' can't implement anything."
  frontendInternal: true
  external: test/object_supertype_test.dart

ObjectMixesIn:
  parameters: none
  problemMessage: "The class 'Object' can't use mixins."
  frontendInternal: true
  external: test/object_supertype_test.dart

InstanceAndSynthesizedStaticConflict:
  parameters:
    Name name: undocumented
  problemMessage: "This instance member conflicts with the synthesized static member called '#name'."
  script: |
    enum E {
      e1, e2;

      void set values(List<E> val) {}
    }

FfiAbiSpecificIntegerInvalid:
  # Used by dart:ffi
  parameters: none
  problemMessage: "Classes extending 'AbiSpecificInteger' must have exactly one const constructor, no other members, and no type arguments."
  external: test/ffi_test.dart

FfiAbiSpecificIntegerMappingInvalid:
  # Used by dart:ffi
  parameters: none
  problemMessage: "Classes extending 'AbiSpecificInteger' must have exactly one 'AbiSpecificIntegerMapping' annotation specifying the mapping from ABI to a NativeType integer with a fixed size."
  external: test/ffi_test.dart

FfiAddressPosition:
  # Used by dart:ffi
  parameters: none
  problemMessage: "The '.address' expression can only be used as argument to a leaf native external call."
  external: test/ffi_test.dart

FfiAddressReceiver:
  # Used by dart:ffi
  parameters: none
  problemMessage: "The receiver of '.address' must be a concrete 'TypedData', a concrete 'TypedData' '[]', an 'Array', an 'Array' '[]', a Struct field, or a Union field."
  correctionMessage: "Change the receiver of '.address' to one of the allowed kinds."
  external: test/ffi_test.dart

FfiCreateOfStructOrUnion:
  # Used by dart:ffi
  parameters: none
  problemMessage: "Subclasses of 'Struct' and 'Union' are backed by native memory, and can't be instantiated by a generative constructor. Try allocating it via allocation, or load from a 'Pointer'."
  external: test/ffi_test.dart

FfiTypeMismatch:
  # Used by dart:ffi
  parameters:
    Type type: undocumented
    Type type2: undocumented
    Type type3: undocumented
  problemMessage: "Expected type '#type' to be '#type2', which is the Dart type corresponding to '#type3'."
  external: test/ffi_test.dart

FfiEmptyStruct:
  # Used by dart:ffi
  parameters:
    String string: undocumented
    Name name: undocumented
  problemMessage: "#string '#name' is empty. Empty structs and unions are undefined behavior."
  external: test/ffi_test.dart

FfiTypeInvalid:
  # Used by dart:ffi
  parameters:
    Type type: undocumented
  problemMessage: "Expected type '#type' to be a valid and instantiated subtype of 'NativeType'."
  external: test/ffi_test.dart

FfiFieldNull:
  # Used by dart:ffi
  parameters:
    Name name: undocumented
  problemMessage: "Field '#name' cannot be nullable or have type 'Null', it must be `int`, `double`, `Pointer`, or a subtype of `Struct` or `Union`."
  external: test/ffi_test.dart

FfiFieldAnnotation:
  # Used by dart:ffi
  parameters:
    Name name: undocumented
  problemMessage: "Field '#name' requires exactly one annotation to declare its native type, which cannot be Void. dart:ffi Structs and Unions cannot have regular Dart fields."
  external: test/ffi_test.dart

FfiFieldNoAnnotation:
  # Used by dart:ffi
  parameters:
    Name name: undocumented
  problemMessage: "Field '#name' requires no annotation to declare its native type, it is a Pointer which is represented by the same type in Dart and native code."
  external: test/ffi_test.dart

FfiFieldCyclic:
  # Used by dart:ffi
  parameters:
    String string: undocumented
    Name name: undocumented
    Names names: undocumented
  problemMessage: |
    #string '#name' contains itself. Cycle elements:
    #names
  external: test/ffi_test.dart

FfiNotStatic:
  # Used by dart:ffi
  parameters:
    Name name: undocumented
  problemMessage: "#name expects a static function as parameter. dart:ffi only supports calling static Dart functions from native code. Closures and tear-offs are not supported because they can capture context."
  external: test/ffi_test.dart

FfiFieldInitializer:
  # Used by dart:ffi
  parameters:
    Name name: undocumented
  problemMessage: "Field '#name' is a dart:ffi Pointer to a struct field and therefore cannot be initialized before constructor execution."
  correctionMessage: "Mark the field as external to avoid having to initialize it."
  external: test/ffi_test.dart

FfiExtendsOrImplementsSealedClass:
  # Used by dart:ffi
  parameters:
    Name name: undocumented
  problemMessage: "Class '#name' cannot be extended or implemented."
  external: test/ffi_test.dart

FfiPackedAnnotation:
  # Used by dart:ffi
  parameters:
    Name name: undocumented
  problemMessage: "Struct '#name' must have at most one 'Packed' annotation."
  external: test/ffi_test.dart

FfiPackedAnnotationAlignment:
  # Used by dart:ffi
  parameters: none
  problemMessage: "Only packing to 1, 2, 4, 8, and 16 bytes is supported."
  external: test/ffi_test.dart

FfiSizeAnnotation:
  # Used by dart:ffi
  parameters:
    Name name: undocumented
  problemMessage: "Field '#name' must have exactly one 'Array' annotation."
  external: test/ffi_test.dart

FfiSizeAnnotationDimensions:
  # Used by dart:ffi
  parameters:
    Name name: undocumented
  problemMessage: "Field '#name' must have an 'Array' annotation that matches the dimensions."
  external: test/ffi_test.dart

FfiVariableLengthArrayNotLast:
  # Used by dart:ffi
  parameters: none
  problemMessage: "Variable length 'Array's must only occur as the last field of Structs."
  correctionMessage: "Try adjusting the arguments in the 'Array' annotation."
  external: test/ffi_test.dart

FfiStructGeneric:
  # Used by dart:ffi
  parameters:
    String string: undocumented
    Name name: undocumented
  problemMessage: "#string '#name' should not be generic."
  external: test/ffi_test.dart

FfiCompoundImplementsFinalizable:
  # Used by dart:ffi
  parameters:
    String string: undocumented
    Name name: undocumented
  problemMessage: "#string '#name' can't implement Finalizable."
  correctionMessage: "Try removing the implements clause from '#name'."
  external: test/ffi_test.dart

FfiDartTypeMismatch:
  # Used by dart:ffi
  parameters:
    Type type: undocumented
    Type type2: undocumented
  problemMessage: "Expected '#type' to be a subtype of '#type2'."
  external: test/ffi_test.dart

FfiDeeplyImmutableClassesMustBeFinalOrSealed:
  # Used by dart:ffi
  parameters: none
  problemMessage: 'Deeply immutable classes must be final or sealed.'
  correctionMessage: 'Try marking this class as final or sealed.'
  external: test/ffi_test.dart

FfiDeeplyImmutableFieldsMustBeDeeplyImmutable:
  # Used by dart:ffi
  parameters: none
  problemMessage: "Deeply immutable classes must only have deeply immutable instance fields. Deeply immutable types include 'int', 'double', 'bool', 'String', 'Pointer', 'Float32x4', 'Float64x2', 'Int32x4', and classes annotated with `@pragma('vm:deeply-immutable')`."
  correctionMessage: 'Try changing the type of this field to a deeply immutable type or mark the type of this field as deeply immutable.'
  external: test/ffi_test.dart

FfiDeeplyImmutableFieldsModifiers:
  # Used by dart:ffi
  parameters: none
  problemMessage: 'Deeply immutable classes must only have final non-late instance fields.'
  correctionMessage: "Add the 'final' modifier to this field, and remove 'late' modifier from this field."
  external: test/ffi_test.dart

FfiDeeplyImmutableSubtypesMustBeDeeplyImmutable:
  # Used by dart:ffi
  parameters: none
  problemMessage: 'Subtypes of deeply immutable classes must be deeply immutable.'
  correctionMessage: "Try marking this class deeply immutable by adding `@pragma('vm:deeply-immutable')`."
  external: test/ffi_test.dart

FfiDeeplyImmutableSupertypeMustBeDeeplyImmutable:
  # Used by dart:ffi
  parameters: none
  problemMessage: 'The super type of deeply immutable classes must be deeply immutable.'
  correctionMessage: "Try marking the super class deeply immutable by adding `@pragma('vm:deeply-immutable')`."
  external: test/ffi_test.dart

FfiDefaultAssetDuplicate:
  # Used by dart:ffi
  parameters: none
  problemMessage: "There may be at most one @DefaultAsset annotation on a library."
  external: test/ffi_test.dart

FfiExpectedExceptionalReturn:
  # Used by dart:ffi
  parameters:
    Type type: undocumented
  problemMessage: "Expected an exceptional return value for a native callback returning '#type'."
  external: test/ffi_test.dart

FfiExpectedNoExceptionalReturn:
  # Used by dart:ffi
  parameters:
    Type type: undocumented
  problemMessage: "Exceptional return value cannot be provided for a native callback returning '#type'."
  external: test/ffi_test.dart

FfiExpectedConstant:
  # Used by dart:ffi
  parameters: none
  problemMessage: "Exceptional return value must be a constant."
  external: test/ffi_test.dart

FfiExceptionalReturnNull:
  # Used by dart:ffi
  parameters: none
  problemMessage: "Exceptional return value must not be null."
  external: test/ffi_test.dart

FfiNativeCallableListenerReturnVoid:
  # Used by dart:ffi
  parameters:
    Type type: undocumented
  problemMessage: "The return type of the function passed to NativeCallable.listener must be void rather than '#type'."
  external: test/ffi_test.dart

FfiExpectedConstantArg:
  # Used by dart:ffi
  parameters:
    Name name: undocumented
  problemMessage: "Argument '#name' must be a constant."
  external: test/ffi_test.dart

FfiLeafCallMustNotTakeHandle:
  # Used by dart:ffi
  parameters: none
  problemMessage: "FFI leaf call must not have Handle argument types."
  external: test/ffi_test.dart

FfiLeafCallMustNotReturnHandle:
  # Used by dart:ffi
  parameters: none
  problemMessage: "FFI leaf call must not have Handle return type."
  external: test/ffi_test.dart

FfiNativeUnexpectedNumberOfParametersWithReceiver:
  # Used by dart:ffi
  parameters:
    int count: undocumented
    int count2: undocumented
  problemMessage: "Unexpected number of Native annotation parameters. Expected #count but has #count2. Native instance method annotation must have receiver as first argument."
  external: test/ffi_test.dart

FfiNativeUnexpectedNumberOfParameters:
  # Used by dart:ffi
  parameters:
    int count: undocumented
    int count2: undocumented
  problemMessage: "Unexpected number of Native annotation parameters. Expected #count but has #count2."
  external: test/ffi_test.dart

FfiNativeOnlyNativeFieldWrapperClassCanBePointer:
  # Used by dart:ffi
  parameters: none
  problemMessage: "Only classes extending NativeFieldWrapperClass1 can be passed as Pointer."
  external: test/ffi_test.dart

FfiNativeMustBeExternal:
  # Used by dart:ffi
  parameters: none
  problemMessage: "Native functions and fields must be marked external."
  external: test/ffi_test.dart

FfiNativeDuplicateAnnotations:
  # Used by dart:ffi
  parameters: none
  problemMessage: "Native functions and fields must not have more than @Native annotation."
  external: test/ffi_test.dart

FfiNativeFieldMustBeStatic:
  # Used by dart:ffi
  parameters: none
  problemMessage: "Native fields must be static."
  external: test/ffi_test.dart

FfiNativeFieldMissingType:
  # Used by dart:ffi
  parameters: none
  problemMessage: "The native type of this field could not be inferred and must be specified in the annotation."
  external: test/ffi_test.dart

FfiNativeFieldType:
  # Used by dart:ffi
  parameters: none
  problemMessage: "Unsupported type for native fields. Native fields only support pointers, compounds and numeric types."
  external: test/ffi_test.dart

FfiNativeFunctionMissingType:
  # Used by dart:ffi
  parameters: none
  problemMessage: "The native type of this function couldn't be inferred so it must be specified in the annotation."
  external: test/ffi_test.dart

FfiAddressOfMustBeNative:
  # Used by dart:ffi
  parameters: none
  problemMessage: "Argument to 'Native.addressOf' must be annotated with @Native."
  external: test/ffi_test.dart

SpreadTypeMismatch:
  parameters:
    Type type: undocumented
  problemMessage: "Unexpected type '#type' of a spread.  Expected 'dynamic' or an Iterable."
  script:
    - |
      main() {
        int a = 42;
        var b = [...a];
      }
    - |
      main() {
        int Function() a = () => 42;
        var b = [...a];
      }

CantHaveNamedParameters:
  # Used by dart:ffi
  parameters:
    Name name: undocumented
  problemMessage: "'#name' can't be declared with named parameters."
  external: test/ffi_test.dart

CantHaveOptionalParameters:
  # Used by dart:ffi
  parameters:
    Name name: undocumented
  problemMessage: "'#name' can't be declared with optional parameters."
  external: test/ffi_test.dart

SpreadElementTypeMismatch:
  parameters:
    Type type: undocumented
    Type type2: undocumented
  problemMessage: "Can't assign spread elements of type '#type' to collection elements of type '#type2'."
  script: |
    main() {
      List<String> a = <String>["foo"];
      List<int> b = <int>[...a];
    }

SpreadMapEntryTypeMismatch:
  parameters:
    Type type: undocumented
  problemMessage: "Unexpected type '#type' of a map spread entry.  Expected 'dynamic' or a Map."
  script:
    - |
      main() {
        int a = 42;
        var b = <dynamic, dynamic>{...a};
      }
    - |
      main() {
        int Function() a = () => 42;
        var b = <dynamic, dynamic>{...a};
      }

SpreadMapEntryElementKeyTypeMismatch:
  parameters:
    Type type: undocumented
    Type type2: undocumented
  problemMessage: "Can't assign spread entry keys of type '#type' to map entry keys of type '#type2'."
  script: |
    main() {
      Map<String, int> a = <String, int>{"foo": 42};
      Map<int, int> b = <int, int>{...a};
    }

SpreadMapEntryElementValueTypeMismatch:
  parameters:
    Type type: undocumented
    Type type2: undocumented
  problemMessage: "Can't assign spread entry values of type '#type' to map entry values of type '#type2'."
  script: |
    main() {
      Map<String, int> a = <String, int>{"foo": 42};
      Map<String, String> b = <String, String>{...a};
    }

CantDisambiguateNotEnoughInformation:
  parameters: none
  problemMessage: "Not enough type information to disambiguate between literal set and literal map."
  correctionMessage: "Try providing type arguments for the literal explicitly to disambiguate it."
  script: |
    foo(dynamic spread) {
      var a = {...spread};
    }

CantDisambiguateAmbiguousInformation:
  parameters: none
  problemMessage: "Both Iterable and Map spread elements encountered in ambiguous literal."
  script: |
    foo(Iterable<int> iterableSpread, Map<int, int> mapSpread) {
      var c = {...iterableSpread, ...mapSpread};
    }

SpreadElement:
  parameters: none
  problemMessage: "Iterable spread."
  severity: CONTEXT

SpreadMapElement:
  parameters: none
  problemMessage: "Map spread."
  severity: CONTEXT

NonNullAwareSpreadIsNull:
  parameters:
    Type type: undocumented
  problemMessage: "Can't spread a value with static type '#type'."
  script: |
    main() {
      <int>[...null];
    }

NegativeVariableDimension:
  # Used by dart:ffi
  parameters: none
  problemMessage: "The variable dimension of a variable-length array must be non-negative."
  external: test/ffi_test.dart

NonPositiveArrayDimensions:
  # Used by dart:ffi
  parameters: none
  problemMessage: "Array dimensions must be positive numbers."
  external: test/ffi_test.dart

InvalidTypeParameterInSupertype:
  parameters:
    Name name: undocumented
    String string2: undocumented
    Name name2: undocumented
  problemMessage: "Can't use implicitly 'out' variable '#name' in an '#string2' position in supertype '#name2'."
  script: |
    class A<X> {}
    class B<Y> extends A<Function(Y)> {}

InvalidTypeParameterInSupertypeWithVariance:
  parameters:
    String string: undocumented
    Name name: undocumented
    String string2: undocumented
    Name name2: undocumented
  problemMessage: "Can't use '#string' type variable '#name' in an '#string2' position in supertype '#name2'."
  script: |
    class A<out X> {}
    class B<out Y> extends A<Function(Y)> {}
  exampleAllowOtherCodes: true

InvalidTypeParameterVariancePosition:
  parameters:
    String string: undocumented
    Name name: undocumented
    String string2: undocumented
  problemMessage: "Can't use '#string' type variable '#name' in an '#string2' position."
  script: |
    class A<out T> {
      void method(T x) {}
  exampleAllowOtherCodes: true

InvalidTypeParameterVariancePositionInReturnType:
  parameters:
    String string: undocumented
    Name name: undocumented
    String string2: undocumented
  problemMessage: "Can't use '#string' type variable '#name' in an '#string2' position in the return type."
  script: |
    class A<in T> {
      T method() {
        return null;
      }
    }
  exampleAllowOtherCodes: true

CombinedMemberSignatureFailed:
  parameters:
    Name name: undocumented
    Name name2: undocumented
  problemMessage: "Class '#name' inherits multiple members named '#name2' with incompatible signatures."
  correctionMessage: "Try adding a declaration of '#name2' to '#name'."
  script:
    - |
      abstract class I1 {
        foo(x);
      }

      abstract class I2 {
        foo();
      }

      abstract class C implements I2, I1 {}

ExtensionTypeCombinedMemberSignatureFailed:
  parameters:
    Name name: undocumented
    Name name2: undocumented
  problemMessage: "Extension type '#name' inherits multiple members named '#name2' with incompatible signatures."
  correctionMessage: "Try adding a declaration of '#name2' to '#name'."
  script:
    - |
      abstract class I1 {
        void foo(int? x);
      }
      abstract class I2 {
        void foo();
      }
      abstract class I3 implements I1, I2 {
        void foo([int? x]);
      }
      extension type C(I3 i) implements I2, I1 {}

LanguageVersionTooHighExplicit:
  parameters:
    int count: undocumented
    int count2: undocumented
    int count3: undocumented
    int count4: undocumented
  problemMessage: "The specified language version #count.#count2 is too high. The highest supported language version is #count3.#count4."
  script: |
    // @dart=100.200
  exampleAllowMultipleReports: true

LanguageVersionTooHighPackage:
  parameters:
    int count: undocumented
    int count2: undocumented
    Name name: undocumented
    int count3: undocumented
    int count4: undocumented
  problemMessage: "The language version #count.#count2 specified for the package '#name' is too high. The highest supported language version is #count3.#count4."
  script:
    .dart_tool/package_config.json: |
      {
        "configVersion": 2,
        "packages": [
          {
            "name": "foo",
            "rootUri": "../foo/",
            "languageVersion": "42.84"
          }
        ]
      }
    main.dart: |
      import 'package:foo/lib.dart';
    foo/lib.dart: ""

LanguageVersionTooLowExplicit:
  parameters:
    int count: undocumented
    int count2: undocumented
    int count3: undocumented
    int count4: undocumented
  problemMessage: "The specified language version #count.#count2 is too low. The lowest supported language version is #count3.#count4."
  script: |
    // @dart=2.9
  exampleAllowMultipleReports: true

LanguageVersionTooLowPackage:
  parameters:
    int count: undocumented
    int count2: undocumented
    Name name: undocumented
    int count3: undocumented
    int count4: undocumented
  problemMessage: "The language version #count.#count2 specified for the package '#name' is too low. The lowest supported language version is #count3.#count4."
  script:
    .dart_tool/package_config.json: |
      {
        "configVersion": 2,
        "packages": [
          {
            "name": "foo",
            "rootUri": "../foo/",
            "languageVersion": "2.11"
          }
        ]
      }
    main.dart: |
      import 'package:foo/lib.dart';
    foo/lib.dart: ""

LanguageVersionInvalidInDotPackages:
  parameters: none
  problemMessage: "The language version is not specified correctly in the packages file."
  exampleAllowOtherCodes: true
  script:
    main.dart: "import 'package:foo/foo.dart';"
    lib/foo.dart: "// blah blah blah"
    .dart_tool/package_config.json: |
      {
          "configVersion": 2,
          "packages": [
              {
                  "name": "foo",
                  "rootUri": "../lib/",
                  "languageVersion": "arglebargle"
              }
          ]
      }

LanguageVersionMismatchInPart:
  parameters: none
  problemMessage: "The language version override has to be the same in the library and its part(s)."
  script:
    main.dart: |
      // @dart = 2.13
      part 'part.dart';
    part.dart: |
      // @dart = 2.12
      part of 'main.dart';

LanguageVersionMismatchInPatch:
  parameters: none
  problemMessage: "The language version override has to be the same in the library and its patch(es)."

LanguageVersionLibraryContext:
  parameters: none
  problemMessage: "This is language version annotation in the library."
  severity: CONTEXT

LanguageVersionPartContext:
  parameters: none
  problemMessage: "This is language version annotation in the part."
  severity: CONTEXT

LanguageVersionPatchContext:
  parameters: none
  problemMessage: "This is language version annotation in the patch."
  severity: CONTEXT

ExplicitExtensionArgumentMismatch:
  parameters: none
  problemMessage: "Explicit extension application requires exactly 1 positional argument."
  script: |
    extension Extension on int {
      method(a) {}
    }
    main() {
      int i = 42;
      Extension(i, i).method(null);
    }

ExplicitExtensionTypeArgumentMismatch:
  parameters:
    Name name: undocumented
    int count: undocumented
  problemMessage: "Explicit extension application of extension '#name' takes '#count' type argument(s)."
  script: |
    extension Extension on int {
      method(a) {}
    }
    main() {
      int i = 42;
      Extension<int>(i).method(null);
    }

ExplicitExtensionAsExpression:
  parameters: none
  problemMessage: "Explicit extension application cannot be used as an expression."
  script: |
    extension Extension on int {}
    errors(int i) {
      Extension(i);
    }

ExplicitExtensionAsLvalue:
  parameters: none
  problemMessage: "Explicit extension application cannot be a target for assignment."

DeferredExtensionImport:
  parameters:
    Name name: undocumented
  problemMessage: "Extension '#name' cannot be imported through a deferred import."
  correctionMessage: "Try adding the `hide #name` to the import."
  script:
    main.dart: "import 'lib.dart' deferred as prefix;"
    lib.dart: "extension Extension on void {}"

VariableCouldBeNullDueToWrite:
  parameters:
    Name name: undocumented
    String string: undocumented
  problemMessage: "Variable '#name' could not be promoted due to an assignment."
  correctionMessage: "Try null checking the variable after the assignment.  See #string"
  script: |
    void foo(int? i, int? j) {
      if (i == null) return;
      i = j;
      i.isEven;
    }
  includeErrorContext: true
  exampleAllowOtherCodes: true

FieldNotPromotedBecauseNotEnabled:
  parameters:
    Name name: undocumented
    String string: undocumented
  problemMessage: "'#name' couldn't be promoted because field promotion is only available in Dart 3.2 and above."
  correctionMessage: "See #string"
  script: |
    // @dart=3.1
    class C {
      final int? _i;
      C(this._i);
    }
    test(C c) {
      if (c._i != null) {
        c._i.isEven;
      }
    }
  includeErrorContext: true
  exampleAllowOtherCodes: true

FieldNotPromotedBecauseNotField:
  parameters:
    Name name: undocumented
    String string: undocumented
  problemMessage: "'#name' refers to a getter so it couldn't be promoted."
  correctionMessage: "See #string"
  script: |
    class C {
      int? get _i => 0;
    }
    test(C c) {
      if (c._i != null) {
        c._i.isEven;
      }
    }
  includeErrorContext: true
  exampleAllowOtherCodes: true

FieldNotPromotedBecauseNotPrivate:
  parameters:
    Name name: undocumented
    String string: undocumented
  problemMessage: "'#name' refers to a public property so it couldn't be promoted."
  correctionMessage: "See #string"
  script: |
    class C {
      final int? i;
      C(this.i);
    }
    test(C c) {
      if (c.i != null) {
        c.i.isEven;
      }
    }
  includeErrorContext: true
  exampleAllowOtherCodes: true

FieldNotPromotedBecauseExternal:
  parameters:
    Name name: undocumented
    String string: undocumented
  problemMessage: "'#name' refers to an external field so it couldn't be promoted."
  correctionMessage: "See #string"
  script: |
    class C {
      external final int? _i;
    }
    test(C c) {
      if (c._i != null) {
        c._i.isEven;
      }
    }
  includeErrorContext: true
  exampleAllowOtherCodes: true

FieldNotPromotedBecauseNotFinal:
  parameters:
    Name name: undocumented
    String string: undocumented
  problemMessage: "'#name' refers to a non-final field so it couldn't be promoted."
  correctionMessage: "See #string"
  script: |
    class C {
      int? _i;
      C(this._i);
    }
    test(C c) {
      if (c._i != null) {
        c._i.isEven;
      }
    }
  includeErrorContext: true
  exampleAllowOtherCodes: true

FieldNotPromotedBecauseConflictingGetter:
  parameters:
    Name name: undocumented
    Name name2: undocumented
    String string: undocumented
  problemMessage: "'#name' couldn't be promoted because there is a conflicting getter in class '#name2'."
  correctionMessage: "See #string"
  script: |
    class C {
      final int? _i;
      C(this._i);
    }
    class D {
      int? get _i => 0;
    }
    test(C c) {
      if (c._i != null) {
        c._i.isEven;
      }
    }
  includeErrorContext: true
  exampleAllowOtherCodes: true

FieldNotPromotedBecauseConflictingField:
  parameters:
    Name name: undocumented
    Name name2: undocumented
    String string: undocumented
  problemMessage: "'#name' couldn't be promoted because there is a conflicting non-promotable field in class '#name2'."
  correctionMessage: "See #string"
  script: |
    class C {
      final int? _i;
      C(this._i);
    }
    class D {
      int? _i;
      D(this._i);
    }
    test(C c) {
      if (c._i != null) {
        c._i.isEven;
      }
    }
  includeErrorContext: true
  exampleAllowOtherCodes: true

FieldNotPromotedBecauseConflictingNsmForwarder:
  parameters:
    Name name: undocumented
    Name name2: undocumented
    String string: undocumented
  problemMessage: "'#name' couldn't be promoted because there is a conflicting noSuchMethod forwarder in class '#name2'."
  correctionMessage: "See #string"
  script: |
    class C {
      final int? _i;
      C(this._i);
    }
    class D implements C {
      noSuchMethod(invocation) => 0;
    }
    test(C c) {
      if (c._i != null) {
        c._i.isEven;
      }
    }
  includeErrorContext: true
  exampleAllowOtherCodes: true

ThisNotPromoted:
  parameters:
    String string: undocumented
  problemMessage: "'this' can't be promoted."
  correctionMessage: "See #string"
  script: |
    extension on int? {
      bool extension_explicit_this() {
        if (this == null) return false;
        return this.isEven;
      }
    }
  includeErrorContext: true
  exampleAllowOtherCodes: true

NullablePropertyAccessError:
  parameters:
    Name name: undocumented
    Type type: undocumented
  problemMessage: "Property '#name' cannot be accessed on '#type' because it is potentially null."
  correctionMessage: "Try accessing using ?. instead."
  script: |
    bool foo(int? i) => i.isEven;

NullableMethodCallError:
  parameters:
    Name name: undocumented
    Type type: undocumented
  problemMessage: "Method '#name' cannot be called on '#type' because it is potentially null."
  correctionMessage: "Try calling using ?. instead."
  script: |
    void foo(int? i) => i.abs();

NullableExpressionCallError:
  parameters:
    Type type: undocumented
  problemMessage: "Can't use an expression of type '#type' as a function because it's potentially null."
  correctionMessage: "Try calling using ?.call instead."
  script: |
    void foo(Function()? f) => f();

NullableOperatorCallError:
  parameters:
    Name name: undocumented
    Type type: undocumented
  problemMessage: "Operator '#name' cannot be called on '#type' because it is potentially null."
  script: |
    void foo(int? i) => i - 1;

NullableTearoffError:
  parameters:
    Name name: undocumented
  problemMessage: "Can't tear off method '#name' from a potentially null value."
  script: |
    class Foo {
      void call() {}
    }
    void x(Foo? f) {
      Function y = f;
    }

NullableSpreadError:
  parameters: none
  problemMessage: "An expression whose value can be 'null' must be null-checked before it can be dereferenced."
  script: |
    void foo(List<int>? bar) => [...bar];

ThrowingNotAssignableToObjectError:
  parameters:
    Type type: undocumented
  problemMessage: "Can't throw a value of '#type' since it is neither dynamic nor non-nullable."
  script: |
    void foo(String? s) => throw s;

RequiredNamedParameterHasDefaultValueError:
  parameters:
    Name name: undocumented
  problemMessage: "Named parameter '#name' is required and can't have a default value."
  script: |
    error() {
      void g({required int b = 42}) {}
    }

ValueForRequiredParameterNotProvidedError:
  parameters:
    Name name: undocumented
  problemMessage: "Required named parameter '#name' must be provided."
  script: |
    void foo({required int i}) {}
    void bar() { foo(); }

OptionalNonNullableWithoutInitializerError:
  parameters:
    Name name: undocumented
    Type type: undocumented
  problemMessage: "The parameter '#name' can't have a value of 'null' because of its type '#type', but the implicit default value is 'null'."
  correctionMessage: "Try adding either an explicit non-'null' default value or the 'required' modifier."
  script:
    - method1({int a}) {}
    - method2([int a]) {}

FieldNonNullableWithoutInitializerError:
  parameters:
    Name name: undocumented
    Type type: undocumented
  problemMessage: "Field '#name' should be initialized because its type '#type' doesn't allow null."
  script: |
    class Foo {
      int x;
    }

FieldNonNullableNotInitializedByConstructorError:
  parameters:
    Name name: undocumented
    Type type: undocumented
  problemMessage: "This constructor should initialize field '#name' because its type '#type' doesn't allow null."
  script: |
    class Foo {
      int x;
      Foo(this.x);
      Foo.other();
    }

ExperimentOptOutExplicit:
  parameters:
    String string: undocumented
    String string2: undocumented
  problemMessage: "The '#string' language feature is disabled for this library."
  correctionMessage: "Try removing the `@dart=` annotation or setting the language version to #string2 or higher."
  script: |
    // @dart=2.14
    class Foo {}
    bar() {
      var baz = Foo.new;
    }
  exampleAllowOtherCodes: true

ExperimentOptOutImplicit:
  parameters:
    String string: undocumented
    String string2: undocumented
  problemMessage: "The '#string' language feature is disabled for this library."
  correctionMessage: "Try removing the package language version or setting the language version to #string2 or higher."
  script:
    .dart_tool/package_config.json: |
      {
        "configVersion": 2,
        "packages": [
          {
            "name": "foo",
            "rootUri": "../foo/",
            "languageVersion": "2.14"
          }
        ]
      }
    main.dart: |
      import 'package:foo/lib.dart';
    foo/lib.dart: |
      class Foo {}
      bar() {
        var baz = Foo.new;
      }
  exampleAllowOtherCodes: true

ExperimentOptOutComment:
  parameters:
    String string: undocumented
  problemMessage: "This is the annotation that opts out this library from the '#string' language feature."
  severity: CONTEXT

AwaitInLateLocalInitializer:
  parameters: none
  problemMessage: "`await` expressions are not supported in late local initializers."
  script: |
    Future<void> foo() async {
      late dynamic x = await null;
    }

NullableSuperclassError:
  parameters:
    Name name: undocumented
  problemMessage: "Can't extend '#name' because it's nullable."
  correctionMessage: "Try removing the question mark."
  script: |
    class Foo extends Object? {}

NullableInterfaceError:
  parameters:
    Name name: undocumented
  problemMessage: "Can't implement '#name' because it's nullable."
  correctionMessage: "Try removing the question mark."
  script: |
    class Foo {}
    class Bar implements Foo? {}

NullableMixinError:
  parameters:
    Name name: undocumented
  problemMessage: "Can't mix '#name' in because it's nullable."
  correctionMessage: "Try removing the question mark."
  script: |
    mixin Foo {}
    class Bar = Object with Foo?;

JsInteropDartClassExtendsJSClass:
  parameters:
    Name name: undocumented
    Name name2: undocumented
  problemMessage: "Dart class '#name' cannot extend JS interop class '#name2'."
  correctionMessage: "Try adding the JS interop annotation or removing it from the parent class."

JsInteropDartJsInteropAnnotationForStaticInteropOnly:
  parameters: none
  problemMessage: "The '@JS' annotation from 'dart:js_interop' can only be used for static interop, either through extension types or '@staticInterop' classes."
  correctionMessage: "Try making this class an extension type or marking it as '@staticInterop'."

JsInteropEnclosingClassJSAnnotation:
  parameters: none
  problemMessage: "Member has a JS interop annotation but the enclosing class does not."
  correctionMessage: "Try adding the annotation to the enclosing class."

JsInteropEnclosingClassJSAnnotationContext:
  parameters: none
  problemMessage: "This is the enclosing class."
  severity: CONTEXT

JsInteropExportClassNotMarkedExportable:
  parameters:
    Name name: undocumented
  problemMessage: "Class '#name' does not have a `@JSExport` on it or any of its members."
  correctionMessage: "Use the `@JSExport` annotation on this class."

JsInteropExportDartInterfaceHasNonEmptyJSExportValue:
  parameters:
    Name name: undocumented
  problemMessage: "The value in the `@JSExport` annotation on the class or mixin '#name' will be ignored."
  correctionMessage: "Remove the value in the annotation."
  severity: WARNING

JsInteropExportDisallowedMember:
  parameters:
    Name name: undocumented
  problemMessage: "Member '#name' is not a concrete instance member or declares type parameters, and therefore can't be exported."
  correctionMessage: "Remove the `@JSExport` annotation from the member, and use an instance member to call this member instead."

JsInteropExportInvalidInteropTypeArgument:
  parameters:
    Type type: undocumented
  problemMessage: "Type argument '#type' needs to be a non-JS interop type."
  correctionMessage: "Use a non-JS interop class that uses `@JSExport` instead."

JsInteropExportInvalidTypeArgument:
  parameters:
    Type type: undocumented
  problemMessage: "Type argument '#type' needs to be an interface type."
  correctionMessage: "Use a non-JS interop class that uses `@JSExport` instead."

JsInteropExportMemberCollision:
  parameters:
    Name name: undocumented
    String string: undocumented
  problemMessage: "The following class members collide with the same export '#name': #string."
  correctionMessage: "Either remove the conflicting members or use a different export name."

JsInteropExportNoExportableMembers:
  parameters:
    Name name: undocumented
  problemMessage: "Class '#name' has no exportable members in the class or the inheritance chain."
  correctionMessage: "Using `@JSExport`, annotate at least one instance member with a body or annotate a class that has such a member in the inheritance chain."

JsInteropIsAInvalidTypeVariable:
  parameters:
    Type type: undocumented
  problemMessage: "Type argument '#type' provided to 'isA' cannot be a type variable and must be an interop extension type that can be determined at compile-time."
  correctionMessage: "Use a valid interop extension type that can be determined at compile-time as the type argument instead."

JsInteropIsAObjectLiteralType:
  parameters:
    Type type: undocumented
  problemMessage: "Type argument '#type' has an object literal constructor. Because 'isA' uses the type's name or '@JS()' rename, this may result in an incorrect type check."
  correctionMessage: "Use 'JSObject' as the type argument instead."

JsInteropIsAPrimitiveExtensionType:
  parameters:
    Type type: undocumented
    String string: undocumented
  problemMessage: "Type argument '#type' wraps primitive JS type '#string', which is specially handled using 'typeof'."
  correctionMessage: "Use the primitive JS type '#string' as the type argument instead."

JsInteropIsATearoff:
  parameters: none
  problemMessage: "'isA' can't be torn off."
  correctionMessage: "Use a method that calls 'isA' and tear off that method instead."

JsInteropExtensionTypeNotInterop:
  parameters:
    Name name: undocumented
    Type type: undocumented
  problemMessage: "Extension type '#name' is marked with a '@JS' annotation, but its representation type is not a valid JS interop type: '#type'."
  correctionMessage: "Try declaring a valid JS interop representation type, which may include 'dart:js_interop' types, '@staticInterop' types, 'dart:html' types, or other interop extension types."

JsInteropExtensionTypeMemberNotInterop:
  parameters: none
  problemMessage: "Extension type member is marked 'external', but the representation type of its extension type is not a valid JS interop type."
  correctionMessage: "Try declaring a valid JS interop representation type, which may include 'dart:js_interop' types, '@staticInterop' types, 'dart:html' types, or other interop extension types."

JsInteropExtensionTypeUsedWithWrongJsAnnotation:
  parameters: none
  problemMessage: "Extension types should use the '@JS' annotation from 'dart:js_interop' and not from 'package:js'."
  correctionMessage: "Try using the '@JS' annotation from 'dart:js_interop' annotation on this extension type instead."

JsInteropExternalExtensionMemberOnTypeInvalid:
  parameters: none
  problemMessage: "JS interop type or @Native type from an SDK web library required for 'external' extension members."
  correctionMessage: "Try making the on-type a JS interop type or an @Native SDK web library type."

JsInteropExternalExtensionMemberWithStaticDisallowed:
  parameters: none
  problemMessage: "External extension members with the keyword 'static' on JS interop and @Native types are disallowed."
  correctionMessage: "Try putting the member in the on-type instead."

JsInteropExternalMemberNotJSAnnotated:
  parameters: none
  problemMessage: "Only JS interop members may be 'external'."
  correctionMessage: "Try removing the 'external' keyword or adding a JS interop annotation."

JsInteropFunctionToJSNamedParameters:
  parameters:
    String conversion: undocumented
  problemMessage: "Functions converted via '#conversion' cannot declare named parameters."
  correctionMessage: "Remove the declared named parameters from the function."

JsInteropFunctionToJSRequiresStaticType:
  parameters:
    String conversion: undocumented
    Type type: undocumented
  problemMessage: "Functions converted via '#conversion' require a statically known function type, but Type '#type' is not a precise function type, e.g., `void Function()`."
  correctionMessage: "Insert an explicit cast to the expected function type."

JsInteropFunctionToJSTypeParameters:
  parameters:
    String conversion: undocumented
  problemMessage: "Functions converted via '#conversion' cannot declare type parameters."
  correctionMessage: "Remove the declared type parameters from the function."

JsInteropFunctionToJSTypeViolation:
  parameters:
    String conversion: undocumented
    String string2: undocumented
  problemMessage: "Function converted via '#conversion' contains invalid types in its function signature: '#string2'."
  correctionMessage: "Use one of these valid types instead: JS types from 'dart:js_interop', ExternalDartReference, void, bool, num, double, int, String, extension types that erase to one of these types, '@staticInterop' types, 'dart:html' types when compiling to JS, or a type parameter that is a subtype of a valid non-primitive type."

JsInteropInvalidStaticClassMemberName:
  parameters: none
  problemMessage: "JS interop static class members cannot have '.' in their JS name."

JsInteropJSClassExtendsDartClass:
  parameters:
    Name name: undocumented
    Name name2: undocumented
  problemMessage: "JS interop class '#name' cannot extend Dart class '#name2'."
  correctionMessage: "Try removing the JS interop annotation or adding it to the parent class."

JsInteropNamedParameters:
  parameters: none
  problemMessage: "Named parameters for JS interop functions are only allowed in object literal constructors or @anonymous factories."
  correctionMessage: "Try replacing them with normal or optional parameters."

JsInteropNativeClassInAnnotation:
  parameters:
    Name name: undocumented
    Name name2: undocumented
    String string3: undocumented
  problemMessage: "Non-static JS interop class '#name' conflicts with natively supported class '#name2' in '#string3'."
  correctionMessage: "Try replacing it with a static JS interop class using `@staticInterop` with extension methods, or use js_util to interact with the native object of type '#name2'."

JsInteropNonExternalConstructor:
  parameters: none
  problemMessage: "JS interop classes do not support non-external constructors."
  correctionMessage: "Try annotating with `external`."

JsInteropNonExternalMember:
  parameters: none
  problemMessage: "This JS interop member must be annotated with `external`. Only factories and static methods can be non-external."
  correctionMessage: "Try annotating the member with `external`."

JsInteropObjectLiteralConstructorPositionalParameters:
  parameters:
    String string: undocumented
  problemMessage: "#string should not contain any positional parameters."
  correctionMessage: "Try replacing them with named parameters instead."

JsInteropOperatorCannotBeRenamed:
  parameters: none
  problemMessage: "JS interop operator methods cannot be renamed using the '@JS' annotation."
  correctionMessage: "Remove the annotation or remove the value inside the annotation."

JsInteropOperatorsNotSupported:
  parameters: none
  problemMessage: "JS interop types do not support overloading external operator methods, with the exception of '[]' and '[]=' using static interop."
  correctionMessage: "Try making this class a static interop type instead."

JsInteropNonStaticWithStaticInteropSupertype:
  parameters:
    Name name: undocumented
    Name name2: undocumented
  problemMessage: "Class '#name' does not have an `@staticInterop` annotation, but has supertype '#name2', which does."
  correctionMessage: "Try marking '#name' as a `@staticInterop` class, or don't inherit '#name2'."

# TODO(srujzs): Is there any way to save the correction message into a variable
# to avoid duplication?
JsInteropStaticInteropExternalAccessorTypeViolation:
  parameters:
    Type type: undocumented
  problemMessage: "External JS interop member contains an invalid type: '#type'."
  correctionMessage: "Use one of these valid types instead: JS types from 'dart:js_interop', ExternalDartReference, void, bool, num, double, int, String, extension types that erase to one of these types, '@staticInterop' types, 'dart:html' types when compiling to JS, or a type parameter that is a subtype of a valid non-primitive type."

JsInteropStaticInteropExternalFunctionTypeViolation:
  parameters:
    String string2: undocumented
  problemMessage: "External JS interop member contains invalid types in its function signature: '#string2'."
  correctionMessage: "Use one of these valid types instead: JS types from 'dart:js_interop', ExternalDartReference, void, bool, num, double, int, String, extension types that erase to one of these types, '@staticInterop' types, 'dart:html' types when compiling to JS, or a type parameter that is a subtype of a valid non-primitive type."

JsInteropStaticInteropGenerativeConstructor:
  parameters: none
  problemMessage: "`@staticInterop` classes should not contain any generative constructors."
  correctionMessage: "Use factory constructors instead."

JsInteropStaticInteropMockMissingGetterOrSetter:
  parameters:
    Name name: undocumented
    String string: undocumented
    String string2: undocumented
    Name name2: undocumented
    String string3: undocumented
  problemMessage: "Dart class '#name' has a #string, but does not have a #string2 to implement any of the following extension member(s) with export name '#name2': #string3."
  correctionMessage: "Declare an exportable #string2 that implements one of these extension members."

JsInteropStaticInteropMockMissingImplements:
  parameters:
    Name name: undocumented
    Name name2: undocumented
    String string: undocumented
  problemMessage: "Dart class '#name' does not have any members that implement any of the following extension member(s) with export name '#name2': #string."
  correctionMessage: "Declare an exportable member that implements one of these extension members."

JsInteropStaticInteropMockNotStaticInteropType:
  parameters:
    Type type: undocumented
  problemMessage: "Type argument '#type' needs to be a `@staticInterop` type."
  correctionMessage: "Use a `@staticInterop` class instead."

JsInteropStaticInteropMockTypeParametersNotAllowed:
  parameters:
    Type type: undocumented
  problemMessage: "Type argument '#type' has type parameters that do not match their bound. createStaticInteropMock requires instantiating all type parameters to their bound to ensure mocking conformance."
  correctionMessage: "Remove the type parameter in the type argument or replace it with its bound."

JsInteropStaticInteropNoJSAnnotation:
  parameters:
    Name name: undocumented
  problemMessage: "`@staticInterop` classes should also have the `@JS` annotation."
  correctionMessage: "Add `@JS` to class '#name'."

JsInteropStaticInteropParameterInitializersAreIgnored:
  parameters: none
  problemMessage: "Initializers for parameters are ignored on static interop external functions."
  correctionMessage: "Declare a forwarding non-external function with this initializer, or remove the initializer."
  severity: WARNING

JsInteropStaticInteropSyntheticConstructor:
  parameters: none
  problemMessage: "Synthetic constructors on `@staticInterop` classes can not be used."
  correctionMessage: "Declare an external factory constructor for this `@staticInterop` class and use that instead."

JsInteropStaticInteropTearOffsDisallowed:
  parameters:
    String string: undocumented
    Name name: undocumented
  problemMessage: "Tear-offs of external #string '#name' are disallowed."
  correctionMessage: "Declare a closure that calls this member instead."

JsInteropStaticInteropTrustTypesUsedWithoutStaticInterop:
  parameters:
    Name name: undocumented
  problemMessage: "JS interop class '#name' has an `@trustTypes` annotation, but no `@staticInterop` annotation."
  correctionMessage: "Try marking the class using `@staticInterop`."

JsInteropStaticInteropTrustTypesUsageNotAllowed:
  parameters:
    Name name: undocumented
  problemMessage: "JS interop class '#name' has an `@trustTypes` annotation, but `@trustTypes` is only supported within the sdk."
  correctionMessage: "Try removing the `@trustTypes` annotation."

JsInteropStaticInteropWithInstanceMembers:
  parameters:
    Name name: undocumented
  problemMessage: "JS interop class '#name' with `@staticInterop` annotation cannot declare instance members."
  correctionMessage: "Try moving the instance member to a static extension."

JsInteropStaticInteropWithNonStaticSupertype:
  parameters:
    Name name: undocumented
    Name name2: undocumented
  problemMessage: "JS interop class '#name' has an `@staticInterop` annotation, but has supertype '#name2', which does not."
  correctionMessage: "Try marking the supertype as a static interop class using `@staticInterop`."

NonNullableNotAssignedError:
  parameters:
    Name name: undocumented
  problemMessage: "Non-nullable variable '#name' must be assigned before it can be used."
  script: |
    method<T>() {
      T t; t;
    }

FinalNotAssignedError:
  parameters:
    Name name: undocumented
  problemMessage: "Final variable '#name' must be assigned before it can be used."
  script: |
    method(bool b) {
      final int i;
      if (b) {
        i = 0;
      }
      i;
    }

LateDefinitelyUnassignedError:
  parameters:
    Name name: undocumented
  problemMessage: "Late variable '#name' without initializer is definitely unassigned."
  script: |
    method<T>() {
      late T t; t;
    }

LateDefinitelyAssignedError:
  parameters:
    Name name: undocumented
  problemMessage: "Late final variable '#name' definitely assigned."
  script: |
    method() {
      late final int t;
      t = 0;
      t = 0;
    }

FinalPossiblyAssignedError:
  parameters:
    Name name: undocumented
  problemMessage: "Final variable '#name' might already be assigned at this point."
  script: |
    method() {
      final int i;
      i = 0;
      i = 0;
    }

CannotAssignToFinalVariable:
  parameters:
    Name name: undocumented
  problemMessage: "Can't assign to the final variable '#name'."
  script: |
     main() {
       final int i = 0;
       i = 42;
     }

CannotAssignToConstVariable:
  parameters:
    Name name: undocumented
  problemMessage: "Can't assign to the const variable '#name'."
  script: |
    main() {
      const int i = 0;
      i = 42;
    }

CannotAssignToExtensionThis:
  parameters: none
  problemMessage: "Can't assign to 'this'."
  script: |
    extension E on String {
      method() {
        this = "";
      }
    }

CannotAssignToTypeLiteral:
  parameters: none
  problemMessage: "Can't assign to a type literal."
  script: |
    main() {
      Object = String;
    }

NonVoidReturnOperator:
  parameters: none
  problemMessage: "The return type of the operator []= must be 'void'."
  correctionMessage: "Try changing the return type to 'void'."
  script:
    - class Class { int operator[]=(a, b) {} }
    - class Class { dynamic operator[]=(a, b) {} }

NonVoidReturnSetter:
  parameters: none
  problemMessage: "The return type of the setter must be 'void' or absent."
  correctionMessage: "Try removing the return type, or define a method rather than a setter."
  script:
    - int set setter(_) {}
    - dynamic set setter(_) {}

NeverReachableSwitchDefaultError:
  parameters: none
  problemMessage: "`null` encountered as case in a switch expression with a non-nullable enum type."

NeverReachableSwitchExpressionError:
  parameters: none
  problemMessage: "`null` encountered as case in a switch expression with a non-nullable type."

NeverReachableSwitchStatementError:
  parameters: none
  problemMessage: "`null` encountered as case in a switch statement with a non-nullable type."

UnsoundSwitchExpressionError:
  parameters: none
  problemMessage: "None of the patterns in the switch expression the matched input value. See https://github.com/dart-lang/language/issues/3488 for details."

UnsoundSwitchStatementError:
  parameters: none
  problemMessage: "None of the patterns in the exhaustive switch statement the matched input value. See https://github.com/dart-lang/language/issues/3488 for details."

NeverValueError:
  parameters: none
  problemMessage: "`null` encountered as the result from expression with type `Never`."

MainNotFunctionDeclaration:
  parameters: none
  problemMessage: "The 'main' declaration must be a function declaration."
  script:
    - var main;

MainNotFunctionDeclarationExported:
  parameters: none
  problemMessage: "The exported 'main' declaration must be a function declaration."
  exampleAllowOtherCodes: true
  script:
    main.dart:
      export 'lib.dart';
    lib.dart:
      var main;

MainTooManyRequiredParameters:
  parameters: none
  problemMessage: "The 'main' method must have at most 2 required parameters."
  script:
    - main(a, b, c) {}

MainTooManyRequiredParametersExported:
  parameters: none
  problemMessage: "The exported 'main' method must have at most 2 required parameters."
  exampleAllowOtherCodes: true
  script:
    main.dart:
      export 'lib.dart';
    lib.dart:
      main(a, b, c) {}

MainRequiredNamedParameters:
  parameters: none
  problemMessage: "The 'main' method cannot have required named parameters."
  script:
    - main({required a}) {}

MainRequiredNamedParametersExported:
  parameters: none
  problemMessage: "The exported 'main' method cannot have required named parameters."
  exampleAllowOtherCodes: true
  script:
    main.dart:
      export 'lib.dart';
    lib.dart:
      main({required a}) {}

MainWrongParameterType:
  parameters:
    Type type: undocumented
    Type type2: undocumented
  problemMessage: "The type '#type' of the first parameter of the 'main' method is not a supertype of '#type2'."
  script:
    - main(Set<String> args) {}

MainWrongParameterTypeExported:
  parameters:
    Type type: undocumented
    Type type2: undocumented
  problemMessage: "The type '#type' of the first parameter of the exported 'main' method is not a supertype of '#type2'."
  exampleAllowOtherCodes: true
  script:
    main.dart:
      export 'lib.dart';
    lib.dart:
      main(Set<String> args) {}

ExportedMain:
  parameters: none
  problemMessage: "This is exported 'main' declaration."
  severity: CONTEXT

UnsupportedDartExt:
  parameters: none
  problemMessage: "Dart native extensions are no longer supported."
  correctionMessage: "Migrate to using FFI instead (https://dart.dev/guides/libraries/c-interop)"
  script: |
    import 'dart-ext:foo.dart';

InstantiationNonGenericFunctionType:
  parameters:
    Type type: undocumented
  problemMessage: "The static type of the explicit instantiation operand must be a generic function type but is '#type'."
  correctionMessage: "Try changing the operand or remove the type arguments."
  script: |
    f() {}
    main() => f<int>;

InstantiationNullableGenericFunctionType:
  parameters:
    Type type: undocumented
  problemMessage: "The static type of the explicit instantiation operand must be a non-null generic function type but is '#type'."
  correctionMessage: "Try changing the operand or remove the type arguments."
  script: |
    test(void Function<T>()? f) => f<int>;

InstantiationTooFewArguments:
  parameters:
    int count: undocumented
    int count2: undocumented
  problemMessage: "Too few type arguments: #count required, #count2 given."
  correctionMessage: "Try adding the missing type arguments."
  script: |
    f<X, Y>() {}
    main() => f<int>;

InstantiationTooManyArguments:
  parameters:
    int count: undocumented
    int count2: undocumented
  problemMessage: "Too many type arguments: #count allowed, but #count2 found."
  correctionMessage: "Try removing the extra type arguments."
  script: |
    f<X>() {}
    main() => f<int, String>;

AbstractClassConstructorTearOff:
  parameters: none
  problemMessage: "Constructors on abstract classes can't be torn off."
  script: |
    abstract class Class {}
    main() => Class.new;

StaticTearOffFromInstantiatedClass:
  parameters: none
  problemMessage: "Cannot access static member on an instantiated generic class."
  correctionMessage: "Try removing the type arguments or placing them after the member name."
  script: |
    class A<X> { static f() {} }
    main() => A<int>.f;


ConstructorTearOffWithTypeArguments:
  parameters: none
  problemMessage: "A constructor tear-off can't have type arguments after the constructor name."
  correctionMessage: "Try removing the type arguments or placing them after the class name."
  script:
    - "class C<X> { C.foo(); } bar() { C.foo<int>; }"

NewAsSelector:
  parameters: none
  problemMessage: "'new' can only be used as a constructor reference."
  script: |
    method(dynamic d) => d.new;

PositionalSuperParametersAndArguments:
  parameters: none
  problemMessage: "Positional super-initializer parameters cannot be used when the super initializer has positional arguments."
  script: |
    class Foo {
      Foo(int foo);
    }

    class Bar extends Foo {
      Bar(super.foo) : super(42);
    }

SuperInitializerParameter:
  parameters: none
  problemMessage: "This is the super-initializer parameter."
  severity: CONTEXT

EnumSupertypeOfNonAbstractClass:
  parameters:
    Name name: undocumented
  problemMessage: "Non-abstract class '#name' has 'Enum' as a superinterface."
  script: |
    class Foo extends Enum {
      int get index => 42;
    }
  exampleAllowOtherCodes: true

EnumNonConstConstructor:
  parameters: none
  problemMessage: "Generative enum constructors must be marked as 'const'."
  script: |
    enum Foo {
      bar;

      Foo();
    }
  exampleAllowOtherCodes: true

EnumConstructorSuperInitializer:
  parameters: none
  problemMessage: "Enum constructors can't contain super-initializers."
  script: |
    enum E2 {
      one.named1();

      const E2.named1() : super();
    }

EnumConstructorTearoff:
  parameters: none
  problemMessage: "Enum constructors can't be torn off."
  script: |
    enum Foo { a, b, c}
    void bar() {
      Foo.new;
    }

EnumFactoryRedirectsToConstructor:
  parameters: none
  problemMessage: "Enum factory constructors can't redirect to generative constructors."
  script: |
    enum E {
      a, b, c;
      const factory E.f3() = E;
    }

EnumContainsValuesDeclaration:
  parameters: none
  problemMessage: "An enum can't declare a member named 'values'."
  script: |
    enum E1 {
      element;
      static const List<E1> values = [E1.element];
    }

EnumImplementerContainsValuesDeclaration:
  parameters:
    Name name: undocumented
  problemMessage: "'#name' has 'Enum' as a superinterface and can't contain non-static member with name 'values'."
  script: |
    mixin M1 on Enum {
      final int values = 42;
    }

EnumInheritsRestricted:
  parameters:
    Name name: undocumented
  problemMessage: "An enum can't inherit a member named '#name'."
  script: |
    mixin class A1 {
      int get hashCode => 42;
    }

    enum E1 with A1 {
      element
    }

EnumInheritsRestrictedMember:
  parameters: none
  problemMessage: "This is the inherited member"
  severity: CONTEXT

UnmatchedAugmentationClassMember:
  parameters:
    Name name: undocumented
  problemMessage: "Augmentation member '#name' doesn't match a member in the augmented class."
  correctionMessage: "Try changing the name to an existing member or removing the 'augment' modifier."
  experiments: augmentations

UnmatchedPatchClassMember:
  parameters:
    Name name: undocumented
  problemMessage: "Patch member '#name' doesn't match a member in the origin class."
  correctionMessage: "Try changing the name to an existing member or removing the '@patch' annotation."

UnmatchedAugmentationLibraryMember:
  parameters:
    Name name: undocumented
  problemMessage: "Augmentation member '#name' doesn't match a member in the augmented library."
  correctionMessage: "Try changing the name to an existing member or removing the 'augment' modifier."
  experiments: augmentations

UnmatchedPatchLibraryMember:
  parameters:
    Name name: undocumented
  problemMessage: "Patch member '#name' doesn't match a member in the origin library."
  correctionMessage: "Try changing the name to an existing member or removing the '@patch' annotation."

UnmatchedAugmentationClass:
  parameters:
    Name name: undocumented
  problemMessage: "Augmentation class '#name' doesn't match a class in the augmented library."
  correctionMessage: "Try changing the name to an existing class or removing the 'augment' modifier."
  experiments: augmentations

UnmatchedPatchClass:
  parameters:
    Name name: undocumented
  problemMessage: "Patch class '#name' doesn't match a class in the origin library."
  correctionMessage: "Try changing the name to an existing class or removing the '@patch' annotation."

UnmatchedAugmentationDeclaration:
  parameters:
    Name name: undocumented
  problemMessage: "Augmentation '#name' doesn't match a declaration in the augmented library."
  correctionMessage: "Try changing the name to an existing declaration or removing the 'augment' modifier."
  experiments: macros

UnmatchedPatchDeclaration:
  parameters:
    Name name: undocumented
  problemMessage: "Patch '#name' doesn't match a declaration in the origin library."
  correctionMessage: "Try changing the name to an existing declaration or removing the '@patch' annotation."

UnmatchedAugmentationConstructor:
  parameters:
    Name name: undocumented
  problemMessage: "Augmentation constructor '#name' doesn't match a constructor in the augmented class."
  correctionMessage: "Try changing the name to an existing constructor or removing the 'augment' modifier."
  experiments: augmentations

NonAugmentationMemberConflictCause:
  parameters: none
  problemMessage: "This is the existing member."
  severity: CONTEXT

NonAugmentationDeclarationConflictCause:
  parameters: none
  problemMessage: "This is the existing declaration."
  severity: CONTEXT

OptionalSuperParameterWithoutInitializer:
  parameters:
    Type type: undocumented
    Name name: undocumented
  problemMessage: "Type '#type' of the optional super-initializer parameter '#name' doesn't allow 'null', but the parameter doesn't have a default value, and the default value can't be copied from the corresponding parameter of the super constructor."
  script: |
    class Foo {
      Foo([num x = 3.14]) {}
    }

    class Bar extends Foo {
      Bar([int super.x]);
    }

EnumContainsRestrictedInstanceDeclaration:
  parameters:
    Name name: undocumented
  problemMessage: "An enum can't declare a non-abstract member named '#name'."
  script: |
    enum E1 {
      element;
      bool operator==(Object other) => true;
    }

EnumImplementerContainsRestrictedInstanceDeclaration:
  parameters:
    Name name: undocumented
    Name name2: undocumented
  problemMessage: "'#name' has 'Enum' as a superinterface and can't contain non-static members with name '#name2'."
  script: |
    class Foo extends Enum {
      int get index => 42;
    }
  exampleAllowOtherCodes: true

EnumAbstractMember:
  parameters: none
  problemMessage: "Enums can't declare abstract members."
  script: |
    enum E1 {
      element;
      void foo();
    }

MixinInheritsFromNotObject:
  parameters:
    Name name: undocumented
  problemMessage: "The class '#name' can't be used as a mixin because it extends a class other than 'Object'."
  script: |
    // @dart=2.19
    class Base {}
    class Mixin extends Base {}
    class C extends Base with Mixin {}

MixinApplicationNoConcreteMethod:
  parameters:
    Name name: undocumented
  problemMessage: "The class doesn't have a concrete implementation of the super-invoked member '#name'."
  script: |
    class Super {
      void method() {}
    }
    mixin Mixin on Super {
      void method() {
        super.method();
      }
    }
    abstract class AbstractSuper implements Super {}
    class Class extends AbstractSuper with Mixin {}

MixinApplicationNoConcreteGetter:
  parameters:
    Name name: undocumented
  problemMessage: "The class doesn't have a concrete implementation of the super-accessed member '#name'."
  script: |
    class Super {
      int get getter => 42;
    }
    mixin Mixin on Super {
      int get getter {
        return super.getter;
      }
    }
    abstract class AbstractSuper implements Super {}
    class Class extends AbstractSuper with Mixin {}

MixinApplicationNoConcreteSetter:
  parameters:
    Name name: undocumented
  problemMessage: "The class doesn't have a concrete implementation of the super-accessed setter '#name'."
  script: |
    class Super {
      void set setter(int value) {}
    }
    mixin Mixin on Super {
      void set setter(int value) {
        super.setter = value;
      }
    }
    abstract class AbstractSuper implements Super {}
    class Class extends AbstractSuper with Mixin {}

MixinApplicationNoConcreteMemberContext:
  parameters: none
  problemMessage: "This is the super-access that doesn't have a concrete target."
  severity: CONTEXT

NoAugmentSuperReadTarget:
  parameters: none
  problemMessage: "Cannot read from 'augment super'."
  experiments: augmentations

NoAugmentSuperWriteTarget:
  parameters: none
  problemMessage: "Cannot write to 'augment super'."
  experiments: augmentations

NoAugmentSuperInvokeTarget:
  parameters: none
  problemMessage: "Cannot call 'augment super'."
  experiments: augmentations

IndexOutOfBoundInRecordIndexGet:
  parameters:
    int count: undocumented
    int count2: undocumented
    Type type: undocumented
  problemMessage: "Index #count is out of range 0..#count2 of positional fields of records #type."

NameNotFoundInRecordNameGet:
  parameters:
    String string: undocumented
    Type type: undocumented
  problemMessage: "Field name #string isn't found in records of type #type."

ObjectMemberNameUsedForRecordField:
  parameters: none
  problemMessage: "Record field names can't be the same as a member from 'Object'."
  script: |
    (int hashCode,) foo1() => throw 0;

RecordFieldsCantBePrivate:
  parameters: none
  problemMessage: "Record field names can't be private."
  script: |
    foo() => (_bar: 1);

NamedFieldClashesWithPositionalFieldInRecord:
  parameters: none
  problemMessage: "Record field names can't be a dollar sign followed by an integer when integer is the index of a positional field."
  script: |
    foo() => (0, $1: 0);

EnumWithNameValues:
  parameters: none
  problemMessage: "The name 'values' is not a valid name for an enum. Try using a different name."
  script: |
    enum values {
      foo, bar;
    }
  exampleAllowOtherCodes: true

InheritedRestrictedMemberOfEnumImplementer:
  parameters:
    Name name: undocumented
    Name name2: undocumented
  problemMessage: "A concrete instance member named '#name' can't be inherited from '#name2' in a class that implements 'Enum'."
  script: |
    abstract class A { int get hashCode => 0; }
    abstract class B extends A implements Enum {}

SealedClassSubtypeOutsideOfLibrary:
  parameters:
    Name name: undocumented
  problemMessage: "The class '#name' can't be extended, implemented, or mixed in outside of its library because it's a sealed class."
  script:
    main.dart:
      import 'lib.dart';
      class B extends A {}
    lib.dart:
      sealed class A {}

CantUseClassAsMixin:
  parameters:
    Name name: undocumented
  problemMessage: "The class '#name' can't be used as a mixin because it isn't a mixin class nor a mixin."
  script:
    main.dart:
      import 'lib.dart';
      class B with A {}
    lib.dart:
      class A {}

BaseClassImplementedOutsideOfLibrary:
  parameters:
    Name name: undocumented
  problemMessage: "The class '#name' can't be implemented outside of its library because it's a base class."
  script:
    main.dart:
      import 'lib.dart';
      base class B implements A {}
    lib.dart:
      base class A {}

BaseOrFinalClassImplementedOutsideOfLibraryCause:
  parameters:
    Name name: undocumented
    Name name2: undocumented
  problemMessage: "The type '#name' is a subtype of '#name2', and '#name2' is defined here."
  severity: CONTEXT

BaseMixinImplementedOutsideOfLibrary:
  parameters:
    Name name: undocumented
  problemMessage: "The mixin '#name' can't be implemented outside of its library because it's a base mixin."
  script:
    main.dart:
      import 'lib.dart';
      base class B implements A {}
    lib.dart:
      base mixin A {}

InterfaceClassExtendedOutsideOfLibrary:
  parameters:
    Name name: undocumented
  problemMessage: "The class '#name' can't be extended outside of its library because it's an interface class."
  script:
    main.dart:
      import 'lib.dart';
      class B extends A {}
    lib.dart:
      interface class A {}

FinalClassExtendedOutsideOfLibrary:
  parameters:
    Name name: undocumented
  problemMessage: "The class '#name' can't be extended outside of its library because it's a final class."
  script:
    main.dart:
      import 'lib.dart';
      final class B extends A {}
    lib.dart:
      final class A {}

FinalClassImplementedOutsideOfLibrary:
  parameters:
    Name name: undocumented
  problemMessage: "The class '#name' can't be implemented outside of its library because it's a final class."
  script:
    main.dart:
      import 'lib.dart';
      final class B implements A {}
    lib.dart:
      final class A {}

FinalClassUsedAsMixinConstraintOutsideOfLibrary:
  parameters:
    Name name: undocumented
  problemMessage: "The class '#name' can't be used as a mixin superclass constraint outside of its library because it's a final class."
  script:
    main.dart:
      import 'lib.dart';
      base mixin B on A {}
    lib.dart:
      final class A {}

SubtypeOfBaseIsNotBaseFinalOrSealed:
  parameters:
    Name name: undocumented
    Name name2: undocumented
  problemMessage: "The type '#name' must be 'base', 'final' or 'sealed' because the supertype '#name2' is 'base'."
  correctionMessage: "Try adding 'base', 'final', or 'sealed' to the type."
  script: |
      base class A {}
      class B extends A {}

SubtypeOfFinalIsNotBaseFinalOrSealed:
  parameters:
    Name name: undocumented
    Name name2: undocumented
  problemMessage: "The type '#name' must be 'base', 'final' or 'sealed' because the supertype '#name2' is 'final'."
  correctionMessage: "Try adding 'base', 'final', or 'sealed' to the type."
  script: |
      final class A {}
      class B extends A {}

MixinSubtypeOfBaseIsNotBase:
  parameters:
    Name name: undocumented
    Name name2: undocumented
  problemMessage: "The mixin '#name' must be 'base' because the supertype '#name2' is 'base'."
  correctionMessage: "Try adding 'base' to the mixin."
  script: |
      base class A {}
      mixin B implements A {}

MixinSubtypeOfFinalIsNotBase:
  parameters:
    Name name: undocumented
    Name name2: undocumented
  problemMessage: "The mixin '#name' must be 'base' because the supertype '#name2' is 'final'."
  correctionMessage: "Try adding 'base' to the mixin."
  script: |
      final class A {}
      mixin B implements A {}

UnspecifiedGetterNameInObjectPattern:
  parameters: none
  problemMessage: "The getter name is not specified explicitly, and the pattern is not a variable. Try specifying the getter name explicitly, or using a variable pattern."
  script: |
    abstract class A { int get foo;}
    test(dynamic x) { if (x case A(: 0)) {} }

JointPatternVariablesMismatch:
  parameters:
    Name name: undocumented
  problemMessage: "Variable pattern '#name' doesn't have the same type or finality in all cases."
  script: |
    test(dynamic x) { switch (x) { case [int a]: case [double a] : return a; default: return null; } }

NonExhaustiveSwitchExpression:
  parameters:
    Type type: undocumented
    String string: undocumented
    String string2: undocumented
  problemMessage: "The type '#type' is not exhaustively matched by the switch cases since it doesn't match '#string'."
  correctionMessage: "Try adding a wildcard pattern or cases that match '#string2'."
  script: |
    enum Enum { a, b }
    String method(Enum e) => switch (e) {
        Enum.a => 'a',
      };

NonExhaustiveSwitchStatement:
  parameters:
    Type type: undocumented
    String string: undocumented
    String string2: undocumented
  problemMessage: "The type '#type' is not exhaustively matched by the switch cases since it doesn't match '#string'."
  correctionMessage: "Try adding a default case or cases that match '#string2'."
  script: |
    enum Enum { a, b }
    method(Enum e) {
      switch (e) {
        case Enum.a:
          break;
      }
    }

PatternTypeMismatchInIrrefutableContext:
  parameters:
    Type type: undocumented
    Type type2: undocumented
  problemMessage: "The matched value of type '#type' isn't assignable to the required type '#type2'."
  correctionMessage: "Try changing the required type of the pattern, or the matched value type."
  script: |
    method(List<String> list) {
      var <int>[a] = list;
    }

DuplicatePatternAssignmentVariable:
  parameters:
    Name name: undocumented
  problemMessage: The variable '#name' is already assigned in this pattern.
  correctionMessage: Try renaming the variable.
  script: |
    method(List<String> list) {
      String a = '';
      [a, a] = list;
    }

DuplicatePatternAssignmentVariableContext:
  parameters: none
  problemMessage: The first assigned variable pattern.
  severity: CONTEXT

DuplicateRecordPatternField:
  parameters:
    Name name: undocumented
  problemMessage: The field '#name' is already matched in this pattern.
  correctionMessage: Try removing the duplicate field.
  script: |
    method(o) {
      switch (o) {
        case (field: 1, field: 2):
      }
    }

DuplicateRecordPatternFieldContext:
  parameters: none
  problemMessage: The first field.
  severity: CONTEXT

DuplicateRestElementInPattern:
  parameters: none
  problemMessage: At most one rest element is allowed in a list or map pattern.
  correctionMessage: Try removing the duplicate rest element.
  script: |
    method(o) {
      switch (o) {
        case [..., ...]:
      }
    }

DuplicateRestElementInPatternContext:
  parameters: none
  problemMessage: The first rest element.
  severity: CONTEXT

RestPatternInMapPattern:
  parameters: none
  problemMessage: "The '...' pattern can't appear in map patterns."
  script: |
    test(dynamic x) { if (x case {1: 1, ...}) {} }

NonBoolCondition:
  parameters: none
  problemMessage: "Conditions must have a static type of 'bool'."
  correctionMessage: Try changing the condition.
  script: |
    method(int i) {
      if (i case 5 when i) {}
    }

RefutablePatternInIrrefutableContext:
  parameters: none
  problemMessage: Refutable patterns can't be used in an irrefutable context.
  correctionMessage: Try using an if-case, a 'switch' statement, or a 'switch' expression instead.
  script: |
    method(int? x) {
      var (a?) = x;
    }

MissingVariablePattern:
  parameters:
    Name name: undocumented
  problemMessage: "Variable pattern '#name' is missing in this branch of the logical-or pattern."
  correctionMessage: "Try declaring this variable pattern in the branch."
  script: |
    method(x) {
      if (x case [var a] || _) {}
    }

MapPatternTypeArgumentMismatch:
  parameters: none
  problemMessage: "A map pattern requires exactly two type arguments."
  script: |
    method(x) {
      if (x case <int>{0: 0}) {}
    }

ListPatternTooManyTypeArguments:
  parameters: none
  problemMessage: "A list pattern requires exactly one type argument."
  script: |
    method(x) {
      if (x case <int, int>[]) {}
    }

UnnamedObjectPatternField:
  parameters: none
  problemMessage: "A pattern field in an object pattern must be named."
  correctionMessage: "Try adding a pattern name or ':' before the pattern."
  script: |
    method(x) {
      if (x case int(5)) {}
    }

PatternAssignmentNotLocalVariable:
  parameters: none
  problemMessage: Only local variables or formal parameters can be used in pattern assignments.
  correctionMessage: Try assigning to a local variable.
  script: |
    var global;
    method(x) {
      [global] = x;
    }

RecordUseCannotBePlacedHere:
  parameters: none
  problemMessage: "`RecordUse` annotation cannot be placed on this element."

WasmImportOrExportInUserCode:
  parameters: none
  problemMessage: "Pragmas `wasm:import` and `wasm:export` are for internal use only and cannot be used by user code."

WeakReferenceNotStatic:
  parameters: none
  problemMessage: "Weak reference pragma can be used on a static method only."
  script: |
    class A {
      @pragma('weak-tearoff-reference')
      external T Function()? weakReference12<T>(T Function()? x);
    }

WeakReferenceNotOneArgument:
  parameters: none
  problemMessage: "Weak reference should take one required positional argument."
  script: |
    @pragma('weak-tearoff-reference')
    Function? weakRef1({Function? x}) => x;

WeakReferenceReturnTypeNotNullable:
  parameters: none
  problemMessage: "Return type of a weak reference should be nullable."
  script: |
    @pragma('weak-tearoff-reference')
    Function weakRef(Function x) => x;

WeakReferenceMismatchReturnAndArgumentTypes:
  parameters: none
  problemMessage: "Return and argument types of a weak reference should match."
  script: |
    @pragma('weak-tearoff-reference')
    Function? weakRef(void Function() x) => x;

WeakReferenceTargetNotStaticTearoff:
  parameters: none
  problemMessage: "The target of weak reference should be a tearoff of a static method."
  script: |
    @pragma('weak-tearoff-reference')
    Function? validWeakRef(Function? x) => x;
    class B {}
    void foo() {
      validWeakRef(B.new);
    }

WeakReferenceTargetHasParameters:
  parameters: none
  problemMessage: "The target of weak reference should not take parameters."
  script: |
    @pragma('weak-tearoff-reference')
    Function? validWeakRef(Function? x) => x;
    class B {
      static int arg1(int x) => 42;
    }
    void foo() {
      validWeakRef(B.arg1);
    }

ObsoleteColonForDefaultValue:
  parameters: none
  problemMessage: "Using a colon as a separator before a default value is no longer supported."
  correctionMessage: "Try replacing the colon with an equal sign."
  script: |
    method({int x: 3}) {}

EqualKeysInMapPattern:
  parameters: none
  problemMessage: Two keys in a map pattern can't be equal.
  correctionMessage: Change or remove the duplicate key.
  script: |
    method(o) {
      if (o case {1: 'foo', 1: 'bar'}) {}
    }

EqualKeysInMapPatternContext:
  parameters: none
  problemMessage: This is the previous use of the same key.
  severity: CONTEXT

PatternMatchingError:
  parameters: none
  problemMessage: "Pattern matching error"

EmptyMapPattern:
  parameters: none
  problemMessage: A map pattern must have at least one entry.
  correctionMessage: Try replacing it with an object pattern 'Map()'.
  script: |
    method(Map m) => switch (m) {
        {} => 0,
        _ => 1,
      };

PatternVariableAssignmentInsideGuard:
  parameters: none
  problemMessage: Pattern variables can't be assigned inside the guard of the enclosing guarded pattern.
  correctionMessage: Try assigning to a different variable.
  script: |
    method(o) => switch (o) {
      int i when (i = 5) > 0 => 0,
      _ => -1,
    };

JointPatternVariableNotInAll:
  parameters:
    Name name: undocumented
  problemMessage: "The variable '#name' is available in some, but not all cases that share this body."
  script: |
    test(x) { switch(x) { case var a: case < 0: case [var a]: return a; default: return null; } }

JointPatternVariableWithLabelDefault:
  parameters:
    Name name: undocumented
  problemMessage: "The variable '#name' is not available because there is a label or 'default' case."
  script: |
    test(x) { switch(x) { case var a: default: return a; } }

ScriptTagInPartFile:
  parameters: none
  problemMessage: "A part file cannot have script tag."
  correctionMessage: "Try removing the script tag or the 'part of' directive."
  script:
    main.dart: |
      part 'part.dart';
    part.dart: |
      #!dart
      part of 'main.dart';

NonCovariantTypeParameterInRepresentationType:
  parameters: none
  problemMessage: "An extension type parameter can't be used non-covariantly in its representation type."
  correctionMessage: "Try removing the type parameters from function parameter types and type parameter bounds."
  script: |
    extension type E<T>(void Function(T) f) {}

CyclicRepresentationDependency:
  parameters: none
  problemMessage: "An extension type can't depend on itself through its representation type."
  script: |
    extension type E(E it) {}

ExtensionTypeDeclarationCause:
  parameters: none
  problemMessage: "The issue arises via this extension type declaration."
  severity: CONTEXT

InvalidExtensionTypeSuperInterface:
  parameters:
    Type type: undocumented
    Type type2: undocumented
    Name name: undocumented
  problemMessage: "The implemented interface '#type' must be a supertype of the representation type '#type2' of extension type '#name'."
  correctionMessage: "Try changing the interface type to a supertype of '#type2' or the representation type to a subtype of '#type'."
  script: |
    extension type E(num n) implements int {}

InvalidExtensionTypeSuperExtensionType:
  parameters:
    Type type: undocumented
    Name name: undocumented
    Type type2: undocumented
    Type type3: undocumented
  problemMessage: "The representation type '#type' of extension type '#name' must be either a subtype of the representation type '#type2' of the implemented extension type '#type3' or a subtype of '#type3' itself."
  correctionMessage: "Try changing the representation type to a subtype of '#type2'."
  script: |
    extension type E1(int i) {}
    extension type E2(num n) implements E1 {}

LocalVariableUsedBeforeDeclared:
  parameters:
    Name name: undocumented
  problemMessage: "Local variable '#name' can't be referenced before it is declared."
  script: |
    foo(dynamic x, dynamic y) { y = x; dynamic x; }

LocalVariableUsedBeforeDeclaredContext:
  parameters:
    Name name: undocumented
  problemMessage: "This is the declaration of the variable '#name'."
  severity: CONTEXT

ImplementNonExtensionTypeAndExtensionTypeMember:
  parameters:
    Name name: undocumented
    Name name2: undocumented
  problemMessage: "The extension type '#name' can't inherit the member '#name2' as both an extension type member and a non-extension type member."
  correctionMessage: "Try declaring a member '#name2' in '#name' to resolve the conflict."
  script: |
    class Class {
      void method() {}
    }
    extension type ExtensionType(Class c) {
      void method() {}
    }
    extension type ExtensionType1(Class c) implements Class, ExtensionType {}

ExtensionTypeMemberContext:
  parameters: none
  problemMessage: "This is the inherited extension type member."
  severity: CONTEXT

ExtensionTypeMemberOneOfContext:
  parameters: none
  problemMessage: "This is one of the inherited extension type members."
  severity: CONTEXT

NonExtensionTypeMemberContext:
  parameters: none
  problemMessage: "This is the inherited non-extension type member."
  severity: CONTEXT

NonExtensionTypeMemberOneOfContext:
  parameters: none
  problemMessage: "This is one of the inherited non-extension type members."
  severity: CONTEXT

ImplementMultipleExtensionTypeMembers:
  parameters:
    Name name: undocumented
    Name name2: undocumented
  problemMessage: "The extension type '#name' can't inherit the member '#name2' from more than one extension type."
  correctionMessage: "Try declaring a member '#name2' in '#name' to resolve the conflict."
  script: |
    extension type ExtensionType1(int i) {
      void method() {}
    }
    extension type ExtensionType2(int i) {
      void method() {}
    }
    extension type ExtensionType3(int i) implements ExtensionType1, ExtensionType2 {}

RepresentationFieldModifier:
  parameters: none
  problemMessage: "Representation fields can't have modifiers."
  script: |
    extension type E(final int foo) {}

ExpectedRepresentationType:
  parameters: none
  problemMessage: "Expected a representation type."
  script: |
    extension type E(var foo) {}

ExpectedRepresentationField:
  parameters: none
  problemMessage: "Expected a representation field."
  script: |
    extension type E() {}

MultipleRepresentationFields:
  parameters: none
  problemMessage: "Each extension type should have exactly one representation field."
  script: |
    extension type E(int foo, String bar) {}

ExtensionTypeConstructorWithSuperFormalParameter:
  parameters: none
  problemMessage: "Extension type constructors can't declare super formal parameters."
  script: |
    extension type A(int foo) { A.named(this.foo, super.bar); }

ExtensionTypePrimaryConstructorWithInitializingFormal:
  parameters: none
  problemMessage: "Primary constructors in extension types can't use initializing formals."
  correctionMessage: "Try removing `this.` from the formal parameter."
  script: |
    extension type A(int this.foo) { }

ExtensionTypePrimaryConstructorFunctionFormalParameterSyntax:
  parameters: none
  problemMessage: "Primary constructors in extension types can't use function formal parameter syntax."
  correctionMessage: "Try rewriting with an explicit function type, like `int Function() f`."
  script: |
    extension type A(int foo()) { }

ExtensionTypeRepresentationTypeBottom:
  parameters: none
  problemMessage: "The representation type can't be a bottom type."
  script: |
    extension type E1(Never foo) {}

RepresentationFieldTrailingComma:
  parameters: none
  problemMessage: "The representation field can't have a trailing comma."
  script: |
    extension type E(int foo,) {}

WrongTypeParameterVarianceInSuperinterface:
  parameters:
    Name name: undocumented
    Type type: undocumented
  problemMessage: "'#name' can't be used contravariantly or invariantly in '#type'."
  script: |
    extension type E<X>(List<Function(Object?)> foo) implements List<Function(X)> {}

AwaitOfExtensionTypeNotFuture:
  parameters: none
  problemMessage: "The 'await' expression can't be used for an expression with an extension type that is not a subtype of 'Future'."
  script: |
    extension type E(num foo) { test(E e) async { await e; } }

NamedParametersInExtensionTypeDeclaration:
  parameters: none
  problemMessage: "Extension type declarations can't have named parameters."
  script: |
    extension type E(int foo, {dynamic bar}) {}

OptionalParametersInExtensionTypeDeclaration:
  parameters: none
  problemMessage: "Extension type declarations can't have optional parameters."
  script: |
    extension type E(int foo, [dynamic bar]) {}

ClassImplementsDeferredClass:
  parameters: none
  problemMessage: "Classes and mixins can't implement deferred classes."
  correctionMessage: Try specifying a different interface, removing the class from the list, or changing the import to not be deferred.
  script:
    main.dart: |
      import 'lib.dart' deferred as d;
      class B implements d.A {}
    lib.dart: |
      class A {}

MixinDeferredMixin:
  parameters: none
  problemMessage: "Classes can't mix in deferred mixins."
  correctionMessage: Try changing the import to not be deferred.
  script:
    main.dart: |
      import 'lib.dart' deferred as d;
      class B with d.A {}
    lib.dart: |
      mixin A {}

MixinSuperClassConstraintDeferredClass:
  parameters: none
  problemMessage: "Deferred classes can't be used as superclass constraints."
  correctionMessage: Try changing the import to not be deferred.
  script:
    main.dart: |
      import 'lib.dart' deferred as d;
      mixin B on d.A {}
    lib.dart: |
      class A {}

ExtendsDeferredClass:
  parameters: none
  problemMessage: "Classes can't extend deferred classes."
  correctionMessage: Try specifying a different superclass, or removing the extends clause.
  script:
    main.dart: |
      import 'lib.dart' deferred as d;
      class B extends d.A {}
    lib.dart: |
      class A {}

ExtensionTypeImplementsDeferred:
  parameters: none
  problemMessage: "Extension types can't implement deferred types."
  correctionMessage: Try specifying a different type, removing the type from the list, or changing the import to not be deferred.
  script:
    main.dart: |
      import 'lib.dart' deferred as d;
      extension type ET(d.A id) implements d.A {}
    lib.dart: |
      class A {}
  exampleAllowOtherCodes: true

RecordUsedAsCallable:
  parameters: none
  problemMessage: "The 'call' property on the record type isn't directly callable but could be invoked by `.call(...)`"
  script: |
    test(({dynamic call}) r) => r(0);

ExperimentExpiredEnabled:
  parameters:
    Name name: undocumented
  problemMessage: "The experiment '#name' has expired and can't be enabled."

ExperimentExpiredDisabled:
  parameters:
    Name name: undocumented
  problemMessage: "The experiment '#name' has expired and can't be disabled."

DartFfiLibraryInDart2Wasm:
  parameters: none
  problemMessage: "'dart:ffi' can't be imported when compiling to Wasm."

UnexpectedSuperParametersInGenerativeConstructors:
  parameters: none
  problemMessage: "Super parameters can only be used in non-redirecting generative constructors."
  script: |
    class A { A(); A.named(super.x) : this(); }

MissingPositionalSuperConstructorParameter:
  parameters: none
  problemMessage: "The super constructor has no corresponding positional parameter."
  script: |
    class A { A(); } class B { B(super.foo); }

MissingNamedSuperConstructorParameter:
  parameters: none
  problemMessage: "The super constructor has no corresponding named parameter."
  script: |
    class A { A(); } class B { B({super.foo}); }

ImplicitSuperInitializerMissingArguments:
  parameters:
    Name name: undocumented
  problemMessage: "The implicitly called unnamed constructor from '#name' has required parameters."
  correctionMessage: "Try adding an explicit super initializer with the required arguments."
  script: |
    class A { A(int foo); } class B extends A { B(); }

DotShorthandsConstructorInvocationWithTypeArguments:
  parameters: none
  problemMessage: "A dot shorthand constructor invocation can't have type arguments."
  correctionMessage: "Try adding the class name and type arguments explicitly before the constructor name."
  experiments: dot-shorthands
  script: |
    class C<X> {
      C.foo();
    }
    void main() {
      C c = .foo<int>();
    }

DotShorthandsInvalidContext:
  parameters:
    Name name: undocumented
  problemMessage: "No type was provided to find the dot shorthand '#name'."
  experiments: dot-shorthands
  script: |
    void main() {
      var x = .one;
    }

DotShorthandsUndefinedGetter:
  parameters:
    Name name: undocumented
    Type type: undocumented
  problemMessage: "The static getter or field '#name' isn't defined for the type '#type'."
  correctionMessage: "Try correcting the name to the name of an existing static getter or field, or defining a getter or field named '#name'."
  experiments: dot-shorthands
  script: |
    class C {
      C get foo => C();
    }
    void main() {
      C c = .foo;
    }

DotShorthandsUndefinedInvocation:
  parameters:
    Name name: undocumented
    Type type: undocumented
  problemMessage: "The static method or constructor '#name' isn't defined for the type '#type'."
  correctionMessage: "Try correcting the name to the name of an existing static method or constructor, or defining a static method or constructor named '#name'."
  experiments: dot-shorthands
  script: |
    class C {
      C foo() => C();
    }
    void main() {
      C c = .foo();
    }

ExpressionEvaluationKnownVariableUnavailable:
  parameters:
    Name name: undocumented
  problemMessage: "The variable '#name' is unavailable in this expression evaluation."

PartOfName:
  parameters: none
  problemMessage: "The 'part of' directive can't use a name with the enhanced-parts feature."
  correctionMessage: "Try using 'part of' with a URI instead."
  experiments: enhanced-parts
  script:
    main.dart: |
      library lib;
      part 'lib.dart';
    lib.dart: |
      part of lib;

PartWithLibraryDirective:
  parameters: none
  problemMessage: "A part cannot have a library directive."
  correctionMessage: "Try removing the library directive."
  script:
    main.dart: |
      library lib;
      part 'lib.dart';
    lib.dart: |
      library;
      part of 'main.dart';
