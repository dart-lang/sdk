# Copyright (c) 2017, the Dart project authors.  Please see the AUTHORS file
# for details. All rights reserved. Use of this source code is governed by a
# BSD-style license that can be found in the LICENSE file.

# Run
#
#     dart pkg/front_end/tool/generate_messages.dart
#
# to regenerate messages after having edited this file.
#
# If entries with 'analyzerCode', 'sharedName', or 'index' have been changed,
# run both
#
#     dart pkg/front_end/tool/generate_messages.dart
#     dart pkg/analyzer/tool/messages/generate.dart
#
# to regenerate analyzer messages.

# Each entry in this map corresponds to a diagnostic message. Ideally, each
# entry contains three parts:
#
# 1. A message template (problemMessage).
#
# 2. A suggestion for how to correct the problem (correctionMessage).
#
# 3. Examples that produce the message (one of expression, statement,
#    declaration, member, script, bytes or external). Note that 'external'
#    should be the path to an external test. The external test will not be run,
#    but the existence of the file will be verified.
#
#    Multiple scripts can start with a `// @dart=` annotation to enforce the
#    language version used for the example code.
#
# Note that it can be hard or impossible to write an example that only gives the
# specific error. To allow for this, one can specify
# "exampleAllowOtherCodes: true" which filters out every message with a
# different code, and just verifies we got exactly one message of the code in
# question (in addition to different codes).
#
# Note that it can be hard or impossible to write an example that gives the
# specified error exactly once. To allow for this, one can specify
# "exampleAllowMultipleReports: true" which allows for the wanted error to occur
# several times.
#
# If we should also look for the code in the context given on an error pass
# "includeErrorContext: true".
#
# To add examples to experimental features enable the experiment with
# "experiments: <experiment>"
#
# A message shouldn't indicate which kind of diagnostic it is, for example,
# warning or error. Tools are expected to prepend "Warning: ", or "Error: ",
# and should be allowed to change the kind of diagnostic without affecting the
# message. For example, an error might be turned into a warning by the tool.
#
# See the file [lib/src/base/diagnostics.md] for more details on how to write
# good diagnostic messages.
#
# A message used for internal errors should have key that starts with
# "InternalProblem". This way, UX review can prioritize it accordingly.
#
# Eventually, we'd like to have all diagnostics in one shared
# location. However, for now, the analyzer needs to translate error codes to
# its own format. To support this, an entry can contain an analyzer error code
# (analyzerCode).
#
# Long term, the analyzer and front-end need to share the same error codes. So
# eventually all error codes should have an `analyzerCode` field.
# Any error code with an `index` field and an `analyzerCode` field
# will be auto generated as an Analyzer error code.
# `index` field values should be unique, consecutive whole numbers starting with 1.
# If `index` is defined, then `analyzerCode` should be the fully formed
# name of the corresponding public Analyzer error const
# (e.g. ParserErrorCode.EQUALITY_CANNOT_BE_EQUALITY_OPERAND)
# which will be used when generating code in Analyzer for translating
# cfe error codes to Analyzer error codes.
# If `index` is ever removed, then a new entry needs to be added at
# `pkg\analyzer\messages.yaml` for that code and the biggest index can be replaced
# by the removed one.
# If `sharedName` is defined, the generated analyzer code will use this as the
# user-facing analyzer code instead of `analyzerCode`. Multiple messages can share
# the `sharedName`.
#
# Errors with an `index` can also optionally contain user-facing documentation
# for the problem (documentation), which dart.dev will extract,
# as well as internal documentation (comment), which will be included in
# the code generated for the analyzer.
#
# ## Parameter Substitution in problemMessage and correctionMessage
#
# The fields `problemMessage` and `correctionMessage` are subject to parameter
# substitution. When the compiler reports a problem, it must also specify
# parameters to be substituted into the message.
#
# Parameters are declared using a map called `parameters`; each map key is of
# the form `TYPE NAME`, and each map value is a comment describing the
# parameter. Placeholders in the `problemMessage` and `correctionMessage`
# strings take the form `#NAME`.
#
# If a diagnostic takes no parameters, it must have an entry of the
# form `parameters: none`.
#
# The following TYPEs are supported:
#
# - `Character`: a Unicode character.
#
# - `Constant`: a Kernel constant.
#
# - `int`: an integer (typically a count).
#
# - `Name` a name string. Note that asserts check to make sure the
#   parameter is not empty. If the diagnostic needs to support an
#   empty name, use `NameOKEmpty` instead.
#
# - `NameOKEmpty`: a name string. Will use an "(unnamed)" default message if
#   the string is empty.
#
# - `Names`: A list of names (strings).
#
# - `Num`: a number (int or double). Formatting can be controlled
#   using a `%` in the placeholder: `#NAME%N.M` formats the number to
#   minimum width N with M fraction digits.
#
# - `String`: a string that isn't a name.  Note: as a rule of thumb,
#    avoid using this type. In particular, do not it for composing
#    error messages, see [diagnostics.md](
#    lib/src/base/diagnostics.md#avoid-composing-messages-programmatically).
#    Note that asserts check to make sure the parameter is not
#    empty. If the diagnostic needs to support an empty name, use
#    `StringOKEmpty` instead.
#
# - `StringOKEmpty`: a string (that isn't a name). Will use an
#    "(empty)" default message if the string is empty.
#
# - `Token`: a token. The token's `lexeme` property is used.
#
# - `Type`: a kernel type.
#
# - `Unicode`: a Unicode short identifier (U+xxxx). We use this to
#   represent code units or code points.
#
# - `Uri`: a URI.

asciiControlCharacter:
  pseudoSharedCode: ILLEGAL_CHARACTER
  parameters:
    Unicode character: the unexpected control character.
  problemMessage: "The control character #character can only be used in strings and comments."
  expression: "\x1b 1"

constEvalStartingPoint:
  parameters: none
  problemMessage: "Constant evaluation error:"

constEvalContext:
  parameters: none
  problemMessage: "While analyzing:"
  severity: CONTEXT

constEvalDuplicateElement:
  parameters:
    Constant element: The duplicate element.
  problemMessage: "The element '#element' conflicts with another existing element in the set."
  script: |
    const foo = {1, 1};
  includeErrorContext: true
  exampleAllowOtherCodes: true

constEvalDuplicateKey:
  parameters:
    Constant key: The duplicate key.
  problemMessage: "The key '#key' conflicts with another existing key in the map."
  script: |
    const foo = {1: 2, 1: 3};
  includeErrorContext: true
  exampleAllowOtherCodes: true

constEvalElementImplementsEqual:
  parameters:
    Constant element: The element that implements `==`.
  problemMessage: "The element '#element' does not have a primitive operator '=='."
  script: |
    //@dart=2.18
    const Set<dynamic> setWithNonPrimitiveEquals = {const WithEquals(42)};
    class WithEquals {
      final int i;
      const WithEquals(this.i);
      operator ==(Object o) {
        return o is WithEquals && (o as WithEquals).i == i;
      }
    }
  includeErrorContext: true
  exampleAllowOtherCodes: true

constEvalElementNotPrimitiveEquality:
  parameters:
    Constant element: The element that doesn't have primitive equality.
  problemMessage: "The element '#element' does not have a primitive equality."
  script: |
    const Set<dynamic> setWithNonPrimitiveEquals = {const WithEquals(42)};
    class WithEquals {
      final int i;
      const WithEquals(this.i);
      operator ==(Object o) {
        return o is WithEquals && (o as WithEquals).i == i;
      }
    }
  includeErrorContext: true
  exampleAllowOtherCodes: true

constEvalKeyImplementsEqual:
  parameters:
    Constant key: The key that implements `==`.
  problemMessage: "The key '#key' does not have a primitive operator '=='."

constEvalKeyNotPrimitiveEquality:
  parameters:
    Constant key: The key that doesn't have primitive equality.
  problemMessage: "The key '#key' does not have a primitive equality."
  script: |
    const Map<dynamic, int> mapWithNonPrimitiveEqualsKey = {
      const WithEquals(42): 42
    };

    class WithEquals {
      final int i;
      const WithEquals(this.i);
      operator ==(Object o) {
        return o is WithEquals && (o as WithEquals).i == i;
      }
    }
  includeErrorContext: true
  exampleAllowOtherCodes: true

constEvalCaseImplementsEqual:
  parameters:
    Constant constant: The case expression that implements `==`.
  problemMessage: "Case expression '#constant' does not have a primitive operator '=='."
  script: |
    // @dart=2.19
    bar(dynamic x) {
      switch (x) {
        case const D(): break;
        default:
      }
    }
    class D {
      const D();
      bool operator ==(dynamic other) => identical(this, other);
    }

constEvalInvalidType:
  parameters:
    Constant constant: The constant that was of the wrong type.
    Type expectedType: The type required to avoid an error.
    Type actualType: The actual type of the constant.
  problemMessage: "Expected constant '#constant' to be of type '#expectedType', but was of type '#actualType'."
  script: |
    const Map foo = {...bar};
    const dynamic bar = "Hello";
  includeErrorContext: true
  exampleAllowOtherCodes: true

constEvalInvalidBinaryOperandType:
  parameters:
    StringOKEmpty operator: The binary operator.
    Constant receiver: The constant being acted upon.
    Type expectedType: The type required to avoid an error.
    Type actualType: The actual type of the operand.
  problemMessage: "Binary operator '#operator' on '#receiver' requires operand of type '#expectedType', but was of type '#actualType'."
  script: |
    const dynamic willBeDouble = const bool.fromEnvironment("foo") ? 42 : 42.42;
    const binaryOnDouble = willBeDouble << 2;
  includeErrorContext: true
  exampleAllowOtherCodes: true

constEvalInvalidEqualsOperandType:
  parameters:
    Constant receiver: The constant being acted upon.
    Type actualType: The actual type of the constant.
  problemMessage: "Binary operator '==' requires receiver constant '#receiver' of type 'Null', 'bool', 'int', 'double', or 'String', but was of type '#actualType'."
  script: |
    //@dart=2.18
    class Foo {
      const Foo();
    }
    const f = Foo();
    const b = f == f;
  includeErrorContext: true
  exampleAllowOtherCodes: true

constEvalEqualsOperandNotPrimitiveEquality:
  parameters:
    Constant receiver: The constant being acted upon.
    Type actualType: The actual type of the constant.
  problemMessage: "Binary operator '==' requires receiver constant '#receiver' of a type with primitive equality or type 'double', but was of type '#actualType'."
  script: |
    const FooWithHashCodeField fooWithHashCodeField1 = const FooWithHashCodeField(42);
    const FooWithHashCodeField fooWithHashCodeField2 = const FooWithHashCodeField(42);
    const bool fooWithHashCodeFieldEqual = fooWithHashCodeField1 == fooWithHashCodeField2;
    class FooWithHashCodeField {
      final int x;
      final int hashCode;
      const FooWithHashCodeField(int x) : this.x = x, this.hashCode = x * 42;
    }
  includeErrorContext: true
  exampleAllowOtherCodes: true

constEvalZeroDivisor:
  parameters:
    String operator: The operator used to divide by zero.
    String value: The value that was divided by zero.
  problemMessage: "Binary operator '#operator' on '#value' requires non-zero divisor, but divisor was '0'."
  script: |
    const int i = 42 ~/ 0;
  includeErrorContext: true
  exampleAllowOtherCodes: true

constEvalNegativeShift:
  parameters:
    String operator: The operator that was used to apply a negative shift.
    String receiver: The value that was shifted.
    String shiftAmount: The amount of shift that was requested.
  problemMessage: "Binary operator '#operator' on '#receiver' requires non-negative operand, but was '#shiftAmount'."
  script: |
    const int foo = 42 >> -1;
  includeErrorContext: true
  exampleAllowOtherCodes: true

constEvalTruncateError:
  parameters:
    String receiver: The value that the divide was applied to.
    String operand: The operand of the divide operation.
  problemMessage: "Binary operator '#receiver ~/ #operand' results is Infinity or NaN."
  script: |
    const double doubleNan = 0/0;
    const int doubleTruncateDivNaN = 84.2 ~/ doubleNan;
  includeErrorContext: true
  exampleAllowOtherCodes: true

constEvalNonNull:
  parameters: none
  problemMessage: "Constant expression must be non-null."
  experiments: const-functions
  script: |
    const int x = y!;
    const dynamic y = null;
  includeErrorContext: true
  exampleAllowOtherCodes: true

constEvalGetterNotFound:
  parameters:
    NameOKEmpty name: The name of the variable that was not found.
  problemMessage: "Variable get not found: '#name'"

constEvalInvalidMethodInvocation:
  parameters:
    StringOKEmpty method: The name of the method that was invoked.
    Constant receiver: The constant being acted upon.
  problemMessage: "The method '#method' can't be invoked on '#receiver' in a constant expression."
  script: |
    const List<String> listConcat = ["Hello"] + ["World"];
  includeErrorContext: true
  exampleAllowOtherCodes: true

constEvalInvalidPropertyGet:
  parameters:
    StringOKEmpty property: The name of the property that was invoked.
    Constant receiver: The constant being acted upon.
  problemMessage: "The property '#property' can't be accessed on '#receiver' in a constant expression."

constEvalInvalidRecordIndexGet:
  parameters:
    StringOKEmpty index: The index that was invoked.
    Constant receiver: The constant being acted upon.
  problemMessage: "The property '#index' can't be accessed on '#receiver' in a constant expression."

constEvalInvalidRecordNameGet:
  parameters:
    StringOKEmpty property: The name of the property that was invoked.
    Constant receiver: The constant being acted upon.
  problemMessage: "The property '#property' can't be accessed on '#receiver' in a constant expression."

constEvalInvalidStringInterpolationOperand:
  parameters:
    Constant constant: The constant being used as part of a string interpolation.
  problemMessage: |
    The constant value '#constant' can't be used as part of a string interpolation in a constant expression.
    Only values of type 'null', 'bool', 'int', 'double', or 'String' can be used.
  script: |
    class Foo {
      const Foo();
    }
    const f = Foo();
    const bar = "hello $f";
  includeErrorContext: true
  exampleAllowOtherCodes: true

constEvalInvalidStaticInvocation:
  parameters:
    NameOKEmpty target: The name of the member that was invoked.
  problemMessage: "The invocation of '#target' is not allowed in a constant expression."

constEvalInvalidSymbolName:
  parameters:
    Constant name: The name of the invalid symbol.
  problemMessage: "The symbol name must be a valid public Dart member name, public constructor name, or library name, optionally qualified, but was '#name'."

constEvalFailedAssertion:
  parameters: none
  problemMessage: "This assertion failed."
  script: |
    class Foo {
      final int x;
      const Foo(this.x) : assert(x < 0);
    }
    const Foo foo = const Foo(42);
  includeErrorContext: true
  exampleAllowOtherCodes: true

constEvalFailedAssertionWithMessage:
  parameters:
    StringOKEmpty message: The assertion failure message.
  problemMessage: "This assertion failed with message: #message"
  script: |
    class Foo {
      final int x;
      const Foo(this.x) : assert(x < 0, "non-negative");
    }
    const Foo foo = const Foo(42);
  includeErrorContext: true
  exampleAllowOtherCodes: true

constEvalFailedAssertionWithNonStringMessage:
  parameters: none
  problemMessage: "This assertion failed with a non-String message."
  script: |
    class Foo {
      final int x;
      const Foo(this.x) : assert(x < 0, x);
    }
    const Foo foo = const Foo(42);
  includeErrorContext: true
  exampleAllowOtherCodes: true

constEvalNonConstantVariableGet:
  parameters:
    NameOKEmpty name: The variable name.
  problemMessage: "The variable '#name' is not a constant, only constant expressions are allowed."

constEvalDeferredLibrary:
  parameters:
    NameOKEmpty importName: The name of the deferred library import.
  problemMessage: >
    '#importName' can't be used in a constant expression because it's marked as
    'deferred' which means it isn't available until loaded.
  correctionMessage: >
    Try moving the constant from the deferred library, or removing 'deferred'
    from the import.
  script:
    main.dart: |
      import "lib.dart" deferred as foo;
      void bar() => const [foo.c];
    lib.dart: |
      const c = const C();
      class C {
        const C();
      }
  includeErrorContext: true
  exampleAllowOtherCodes: true

constEvalCircularity:
  parameters: none
  problemMessage: "Constant expression depends on itself."
  script: |
    const foo = bar;
    const bar = foo;
  includeErrorContext: true
  exampleAllowOtherCodes: true

constEvalNullValue:
  parameters: none
  problemMessage: "Null value during constant evaluation."
  experiments: const-functions
  script: |
    const dynamic a = null;
    const dynamic b = a();
  includeErrorContext: true
  exampleAllowOtherCodes: true

constEvalNotListOrSetInSpread:
  parameters: none
  problemMessage: "Only lists and sets can be used in spreads in constant lists and sets."
  script: |
    import 'dart:collection';
    class CustomIterable extends IterableBase<String> {
      const CustomIterable();
      Iterator<String> get iterator => <String>[].iterator;
    }
    const List<String> barWithCustomIterableSpread1 = [
      ...const CustomIterable()
    ];
  includeErrorContext: true
  exampleAllowOtherCodes: true

constEvalNotMapInSpread:
  parameters: none
  problemMessage: "Only maps can be used in spreads in constant maps."
  script: |
    const Map<String, String> mapWithCustomMap1 = {...const CustomMap()};
    class CustomMap implements Map<String, String> {
      const CustomMap();

      @override
      Iterable<MapEntry<String, String>> get entries => [];

      @override
      String operator [](Object? key) => throw new UnimplementedError();

      @override
      void operator []=(String key, String value) => throw new UnimplementedError();

      @override
      Map<RK, RV> cast<RK, RV>() => throw new UnimplementedError();

      @override
      void clear() => throw new UnimplementedError();

      @override
      bool containsKey(Object? key) => throw new UnimplementedError();

      @override
      bool containsValue(Object? value) => throw new UnimplementedError();

      @override
      bool get isEmpty => throw new UnimplementedError();

      @override
      bool get isNotEmpty => throw new UnimplementedError();

      @override
      Iterable<String> get keys => throw new UnimplementedError();

      @override
      int get length => throw new UnimplementedError();

      @override
      String remove(Object? key) => throw new UnimplementedError();

      @override
      Iterable<String> get values => throw new UnimplementedError();

      @override
      void addAll(Map<String, String> other) => throw new UnimplementedError();

      @override
      void addEntries(Iterable<MapEntry<String, String>> newEntries) =>
          throw new UnimplementedError();

      @override
      void forEach(void f(String key, String value)) =>
          throw new UnimplementedError();

      @override
      String putIfAbsent(String key, String ifAbsent()) =>
          throw new UnimplementedError();

      @override
      void updateAll(String update(String key, String value)) =>
          throw new UnimplementedError();

      @override
      void removeWhere(bool predicate(String key, String value)) =>
          throw new UnimplementedError();

      String update(String key, String update(String value),
              {String ifAbsent()?}) =>
          throw new UnimplementedError();

      Map<K2, V2> map<K2, V2>(MapEntry<K2, V2> f(String key, String value)) =>
          throw new UnimplementedError();
    }
  includeErrorContext: true
  exampleAllowOtherCodes: true

constEvalExtension:
  parameters: none
  problemMessage: "Extension operations can't be used in constant expressions."
  experiments: const-functions
  script: |
    extension Foo on int {
      int x() => 42;
    }
    const bar = 1.x();
  includeErrorContext: true
  exampleAllowOtherCodes: true

constEvalExternalConstructor:
  parameters: none
  problemMessage: "External constructors can't be evaluated in constant expressions."
  script: |
    class Foo {
      external const Foo();
    }
    const bar = Foo();
  includeErrorContext: true
  exampleAllowOtherCodes: true

constEvalExternalFactory:
  parameters: none
  problemMessage: "External factory constructors can't be evaluated in constant expressions."
  script: |
    class Foo {
      external const factory Foo();
    }
    const bar = Foo();
  includeErrorContext: true
  exampleAllowOtherCodes: true

constEvalUnevaluated:
  parameters: none
  problemMessage: "Couldn't evaluate constant expression."

constEvalError:
  parameters:
    String message: A text description of the error.
  problemMessage: "Error evaluating constant expression: #message"

constEvalUnhandledCoreException:
  parameters:
    StringOKEmpty exceptionText: The text of the unhandled exception.
  problemMessage: "Unhandled core exception: #exceptionText"
  experiments: const-functions
  script: |
    const foo = [].single;
  includeErrorContext: true
  exampleAllowOtherCodes: true

constEvalUnhandledException:
  parameters:
    Constant exception: The exception object that was unhandled.
  problemMessage: "Unhandled exception: #exception"
  experiments: const-functions
  script: |
    const foo = doThrow();
    int doThrow() => throw 42;
  includeErrorContext: true
  exampleAllowOtherCodes: true

notConstantExpression:
  parameters:
    String description: A description of the kind of expression.
  problemMessage: "#description is not a constant expression."
  script: |
    void foo() {
      const x = new Map();
    }
  exampleAllowMultipleReports: true

notAConstantExpression:
  parameters: none
  problemMessage: "Not a constant expression."
  script: |
    foo() {
      var a = 0;
      const b = a;
    }

missingExplicitConst:
  parameters: none
  problemMessage: "Constant expression expected."
  correctionMessage: "Try inserting 'const'."
  script: |
    class A {
      final x;
      const A(): x = [];
    }

dynamicCallsAreNotAllowedInDynamicModule:
  parameters: none
  problemMessage: "Dynamic calls are not allowed in a dynamic module."

constructorShouldBeListedAsCallableInDynamicInterface:
  parameters:
    Name name: Constructor name.
  problemMessage: "Cannot invoke constructor '#name' from a dynamic module."
  correctionMessage: "Try removing the call or update the dynamic interface to list constructor '#name' as callable."

memberShouldBeListedAsCallableInDynamicInterface:
  parameters:
    Name name: Member name.
  problemMessage: "Cannot invoke member '#name' from a dynamic module."
  correctionMessage: "Try removing the call or update the dynamic interface to list member '#name' as callable."

extensionTypeShouldBeListedAsCallableInDynamicInterface:
  parameters:
    Name name: Extension type name.
  problemMessage: "Cannot use extension type '#name' in a dynamic module."
  correctionMessage: "Try removing the reference to extension type '#name' or update the dynamic interface to list extension type '#name' as callable."

classShouldBeListedAsCallableInDynamicInterface:
  parameters:
    Name name: Class name.
  problemMessage: "Cannot use class '#name' in a dynamic module."
  correctionMessage: "Try removing the reference to class '#name' or update the dynamic interface to list class '#name' as callable."

classShouldBeListedAsExtendableInDynamicInterface:
  parameters:
    Name name: Class name.
  problemMessage: "Cannot extend, implement or mix-in class '#name' in a dynamic module."
  correctionMessage: "Try removing the reference to class '#name' or update the dynamic interface to list class '#name' as extendable."

memberShouldBeListedAsCanBeOverriddenInDynamicInterface:
  parameters:
    Name className: The name of the class containing the problematic member.
    Name memberName: The name of the problematic member.
  problemMessage: "Cannot override member '#className.#memberName' in a dynamic module."
  correctionMessage: "Try removing the override or update the dynamic interface to list member '#className.#memberName' as can-be-overridden."

nonAsciiIdentifier:
  pseudoSharedCode: ILLEGAL_CHARACTER
  parameters:
    Character character: The non-ascii character
    Unicode codePoint: The unicode code point of the non-ascii character
  problemMessage: "The non-ASCII character '#character' (#codePoint) can't be used in identifiers, only in strings and comments."
  correctionMessage: "Try using an US-ASCII letter, a digit, '_' (an underscore), or '$' (a dollar sign)."
  expression: "Ã¥"
  exampleAllowOtherCodes: true

nonAsciiWhitespace:
  pseudoSharedCode: ILLEGAL_CHARACTER
  parameters:
    Unicode codePoint: The unicode code point of the non-ascii character
  problemMessage: "The non-ASCII space character #codePoint can only be used in strings and comments."
  expression: "\u2028 1"

encoding:
  pseudoSharedCode: ENCODING
  parameters: none
  problemMessage: "Unable to decode bytes as UTF-8."
  bytes: [255]

experimentDisabled:
  parameters:
    String featureName: The name of the experimental language feature.
  problemMessage: "This requires the '#featureName' language feature to be enabled."
  correctionMessage: "The feature is on by default but is currently disabled, maybe because the '--enable-experiment=no-#featureName' command line option is passed."

experimentDisabledInvalidLanguageVersion:
  parameters:
    String featureName: The name of the experimental language feature.
    String requiredLanguageVersion: The language version in which that language feature was enabled.
  problemMessage: "This requires the '#featureName' language feature, which requires language version of #requiredLanguageVersion or higher."

emptyNamedParameterList:
  pseudoSharedCode: "MISSING_IDENTIFIER"
  parameters: none
  problemMessage: "Named parameter lists cannot be empty."
  correctionMessage: "Try adding a named parameter to the list."
  script: |
    foo({}) {}

    main() {
      foo();
    }

duplicatedRecordTypeFieldName:
  parameters:
    Name fieldName: The name of the duplicated field.
  problemMessage: "Duplicated record type field name '#fieldName'."
  correctionMessage: "Try renaming or removing one of the named record type fields."
  script: |
    ({int a, String a}) record = throw '';

duplicatedRecordTypeFieldNameContext:
  parameters:
    Name fieldName: The name of the duplicated field.
  problemMessage: "This is the existing record type field named '#fieldName'."
  severity: CONTEXT

duplicatedRecordLiteralFieldName:
  parameters:
    Name fieldName: The name of the duplicated field.
  problemMessage: "Duplicated record literal field name '#fieldName'."
  correctionMessage: "Try renaming or removing one of the named record literal fields."
  script: |
    dynamic field = (a: 0, a: 1);

duplicatedRecordLiteralFieldNameContext:
  parameters:
    Name fieldName: The name of the duplicated field.
  problemMessage: "This is the existing record literal field named '#fieldName'."
  severity: CONTEXT

emptyOptionalParameterList:
  pseudoSharedCode: "MISSING_IDENTIFIER"
  parameters: none
  problemMessage: "Optional parameter lists cannot be empty."
  correctionMessage: "Try adding an optional parameter to the list."
  script: |
    foo([]) {}

    main() {
      foo();
    }

expectedBlockToSkip:
  parameters: none
  problemMessage: "Expected a function body or '=>'."
  # TODO(ahe): In some scenarios, we can suggest removing the 'static' keyword.
  correctionMessage: "Try adding {}."

expectedBody:
  pseudoSharedCode: MISSING_FUNCTION_BODY
  parameters: none
  problemMessage: "Expected a function body or '=>'."
  # TODO(ahe): In some scenarios, we can suggest removing the 'static' keyword.
  correctionMessage: "Try adding {}."
  script: "main();"

expectedButGot:
  # Also see ExpectedButGot2, ExpectedAfterButGot, and ExpectedInstead
  pseudoSharedCode: EXPECTED_TOKEN
  parameters:
    String expected: The text that was expected.
  problemMessage: "Expected '#expected' before this."
  # Consider the second example below: the parser expects a ')' before 'y', but
  # a ',' would also have worked. We don't have enough information to give a
  # good suggestion.
  exampleAllowOtherCodes: true
  script:
    - "main() => true ? 1;"
    - "main() => foo(x: 1 y: 2);"

expectedButGot2:
  # Also see ExpectedButGot, ExpectedAfterButGot, and ExpectedInstead
  pseudoSharedCode: EXPECTED_TOKEN
  parameters:
    String expected: The first possible text that was expected.
    String expected2: The second possible text that was expected.
  problemMessage: "Expected '#expected' or '#expected2' before this."
  # TODO(eernst): Enable this example when the feature is enabled.
  # exampleAllowOtherCodes: true
  # experiments: anonymous-methods
  # script:
  #   - "main() => 1.(it) it;"

expectedAfterButGot:
  # Also see ExpectedButGot, ExpectedButGot2, and ExpectedInstead
  pseudoSharedCode: EXPECTED_TOKEN
  parameters:
    String expected: The text that was expected.
  problemMessage: "Expected '#expected' after this."
  # This is an alternative to ExpectedButGot when it's better for the error to be
  # associated with the last consumed token rather than the token being parsed.
  # Doing so can make it cognitively easier for the user to understand and fix.
  #
  # For example, this is ok...
  #
  #    x = 7
  #    class Foo {
  #    ^^^^^
  #        Expected ';' before this
  #
  # but this is easier for the user...
  #
  #    x = 7
  #        ^
  #        Expected ';' after this
  #    class Foo {
  #
  script:
    - "main() { return true }"

implementsRepeated:
  parameters:
    Name name: The interface that was implemented more than once.
    int extraCount: The number of occurrences to suggest removing.
  problemMessage: "'#name' can only be implemented once."
  correctionMessage: "Try removing #extraCount of the occurrences."
  script:
    - >-
      abstract class I {}
      abstract class J {}
      class K implements I, J, I {}

implementsSuperClass:
  parameters:
    Name name: The interface that was mentioned in both `extends` and `implements` clauses.
  problemMessage: "'#name' can't be used in both 'extends' and 'implements' clauses."
  correctionMessage: "Try removing one of the occurrences."
  script:
    - >-
      abstract class A {}
      class C extends A implements A {}

multipleImplements:
  pseudoSharedCode: MULTIPLE_IMPLEMENTS_CLAUSES
  parameters: none
  problemMessage: "Each class definition can have at most one implements clause."
  correctionMessage: "Try combining all of the implements clauses into a single clause."
  script: "class A implements B implements C, D {}"
  exampleAllowOtherCodes: true

implementsFutureOr:
  parameters: none
  problemMessage: "The type 'FutureOr' can't be used in an 'implements' clause."
  script: |
    import 'dart:async';
    class Foo implements FutureOr<String> {}

extendsNever:
  parameters: none
  problemMessage: "The type 'Never' can't be used in an 'extends' clause."
  script: |
    class Foo extends Never {}
  exampleAllowOtherCodes: true

implementsNever:
  parameters: none
  problemMessage: "The type 'Never' can't be used in an 'implements' clause."
  script:
    class Foo implements Never {}
  exampleAllowOtherCodes: true

expectedDeclaration:
  pseudoSharedCode: EXPECTED_EXECUTABLE
  parameters:
    Token lexeme: The token that was found.
  problemMessage: "Expected a declaration, but got '#lexeme'."
  script: |
    var get b, c;
  exampleAllowOtherCodes: true

expectedClassMember:
  pseudoSharedCode: EXPECTED_CLASS_MEMBER
  parameters:
    Token lexeme: The token that was found.
  problemMessage: "Expected a class member, but got '#lexeme'."
  script: |
    class Foo {
      Foo() : this.new = 42;
    }
  exampleAllowOtherCodes: true
  exampleAllowMultipleReports: true

expectedFunctionBody:
  pseudoSharedCode: MISSING_FUNCTION_BODY
  parameters:
    Token lexeme: The token that was found.
  problemMessage: "Expected a function body, but got '#lexeme'."
  script: |
    var get b, c;
  exampleAllowOtherCodes: true
  exampleAllowMultipleReports: true

expectedHexDigit:
  pseudoSharedCode: MISSING_HEX_DIGIT
  parameters: none
  problemMessage: "A hex digit (0-9 or A-F) must follow '0x'."
  # No tip, seems obvious from the error message.
  script: |
    main() {
      var i = 0x;
    }

expectedIdentifier:
  pseudoSharedCode: MISSING_IDENTIFIER
  parameters:
    Token lexeme: The token that was found.
  problemMessage: "Expected an identifier, but got '#lexeme'."
  correctionMessage: "Try inserting an identifier before '#lexeme'."
  script: "var = 42;"

expectedString:
  pseudoSharedCode: EXPECTED_STRING_LITERAL
  parameters:
    Token lexeme: The token that was found.
  problemMessage: "Expected a String, but got '#lexeme'."
  script: |
    import foo;
  exampleAllowOtherCodes: true

expectedToken:
  pseudoSharedCode: EXPECTED_TOKEN
  parameters:
    String expected: The token that was expected.
  problemMessage: "Expected to find '#expected'."
  script: |
    void foo() {
      switch (1) {
        C<int, int> case 1: break;
      }
    }

expectedType:
  pseudoSharedCode: EXPECTED_TYPE_NAME
  parameters:
    Token lexeme: The token that was found.
  problemMessage: "Expected a type, but got '#lexeme'."
  script: |
    extension try<T> on Class<T> {}
  exampleAllowOtherCodes: true

abstractExtensionField:
  pseudoSharedCode: ABSTRACT_EXTENSION_FIELD
  parameters: none
  problemMessage: "Extension fields can't be declared 'abstract'."
  correctionMessage: "Try removing the 'abstract' keyword."
  exampleAllowOtherCodes: true
  script:
    - "extension C on int {abstract static var f;}"

abstractFieldInitializer:
  parameters: none
  problemMessage: "Abstract fields cannot have initializers."
  correctionMessage: "Try removing the initializer or the 'abstract' keyword."
  script:
    - "abstract class C {abstract var f = 0;}"

abstractFieldConstructorInitializer:
  parameters: none
  problemMessage: "Abstract fields cannot have initializers."
  correctionMessage: "Try removing the field initializer or the 'abstract' keyword from the field declaration."
  script:
    - "abstract class C {abstract var f; C(this.f);}"
    - "abstract class C {abstract var f; C() : this.f = 0;}"

constFactoryRedirectionToNonConst:
  parameters: none
  problemMessage: "Constant factory constructor can't delegate to a non-constant constructor."
  correctionMessage: "Try redirecting to a different constructor or marking the target constructor 'const'."
  script:
    - >-
      class A {
        const factory A.foo() = A.bar;
        A.bar() {}
      }

nonConstFactory:
  parameters: none
  problemMessage: "Cannot invoke a non-'const' factory where a const expression is expected."
  correctionMessage: "Try using a constructor or factory that is 'const'."
  script: |
    class Foo {
      Foo();
      factory Foo.f() => new Foo();
    }
    void foo() {
      const Foo.f();
    }

nonConstConstructor:
  parameters: none
  problemMessage: "Cannot invoke a non-'const' constructor where a const expression is expected."
  correctionMessage: "Try using a constructor or factory that is 'const'."
  script: |
    class Foo {
      Foo();
    }
    void foo() {
      const Foo();
    }

constConstructorWithBody:
  pseudoSharedCode: CONST_CONSTRUCTOR_WITH_BODY
  parameters: none
  problemMessage: "A const constructor can't have a body."
  correctionMessage: "Try removing either the 'const' keyword or the body."
  script:
    - "class C { const C() {} }"

externalFieldInitializer:
  parameters: none
  problemMessage: "External fields cannot have initializers."
  correctionMessage: "Try removing the initializer or the 'external' keyword."
  script:
    - "external var f = 0;"
    - "abstract class C {external var f = 0;}"

externalFieldConstructorInitializer:
  parameters: none
  problemMessage: "External fields cannot have initializers."
  correctionMessage: "Try removing the field initializer or the 'external' keyword from the field declaration."
  script:
    - "abstract class C {external var f; C(this.f);}"
    - "abstract class C {external var f; C() : this.f = 0;}"

initializerForStaticField:
  parameters:
    Name fieldName: The field name mentioned in the initializer.
  problemMessage: "'#fieldName' isn't an instance field of this class."
  script: |
    class Foo {
      Foo() : initializer = true { }
    }

moreThanOneSuperInitializer:
  parameters: none
  problemMessage: "Can't have more than one 'super' initializer."
  script:
    - "class C { C.bad() : super(), super(); }"

redirectingConstructorWithSuperInitializer:
  parameters: none
  problemMessage: "A redirecting constructor can't have a 'super' initializer."
  script:
    - "class C { C(); C.bad() : super(), this(); }"
    - "class C { C(); C.bad() : this(), super(); }"

redirectingConstructorWithMultipleRedirectInitializers:
  parameters: none
  problemMessage: "A redirecting constructor can't have more than one redirection."
  script:
    - "class C { C(); C.bad() : this(), this(); }"

redirectingConstructorWithAnotherInitializer:
  parameters: none
  problemMessage: "A redirecting constructor can't have other initializers."
  # also ASSERT_IN_REDIRECTING_CONSTRUCTOR
  script:
    - "class C { int? x; C(); C.bad() : x = 5, this(); }"
    - "class C { int? x; C(); C.bad() : this(), x = 5; }"
    - "class C { int? x; C(); C.bad() : assert(true), this(); }"
    - "class C { int? x; C(); C.bad() : this(), assert(true); }"

superInitializerNotLast:
  parameters: none
  problemMessage: "Can't have initializers after 'super'."
  script:
    - "class C { int x; C.bad() : super(), x = 5; }"

invalidBreakTarget:
  parameters:
    Name label: The label targeted by the `break`.
  problemMessage: "Can't break to '#label'."
  script: |
    void foo() {
      switch (1) {
        L: case 1:
          foo() {
            break L;
          }
      }
    }

breakTargetOutsideFunction:
  parameters:
    Name label: The label targeted by the `break`.
  problemMessage: "Can't break to '#label' in a different function."
  statement: |
    label: while (true) {
      void f() {
        while (true) {
          break label;
        }
      }
    }

anonymousBreakTargetOutsideFunction:
  parameters: none
  problemMessage: "Can't break to a target in a different function."
  statement: |
    while (true) {
      void f() {
        break;
      }
    }
  exampleAllowOtherCodes: true

continueLabelInvalid:
  parameters: none
  problemMessage: "A 'continue' label must be on a loop or a switch member."
  statement:
    - "L: { for (var i in [ ]) { continue L; } }"

invalidContinueTarget:
  parameters:
    Name label: The label targeted by the `continue`.
  problemMessage: "Can't continue at '#label'."
  script: |
    void foo() {
      switch (1) {
        L: case 1:
          foo() {
            continue L;
          }
      }
    }
  exampleAllowOtherCodes: true

continueTargetOutsideFunction:
  parameters:
    Name label: The label targeted by the `continue`.
  problemMessage: "Can't continue at '#label' in a different function."
  statement: |
    label: while (true) {
      void f() {
        while (true) {
          continue label;
        }
      }
    }

anonymousContinueTargetOutsideFunction:
  parameters: none
  problemMessage: "Can't continue at a target in a different function."
  statement: |
    while (true) {
      void f() {
        continue;
      }
    }
  exampleAllowOtherCodes: true

labelNotFound:
  parameters:
    Name label: The label that could not be found.
  problemMessage: "Can't find label '#label'."
  correctionMessage: "Try defining the label, or correcting the name to match an existing label."
  statement:
    - "switch (0) {case 0: continue L;}"

invalidSyncModifier:
  pseudoSharedCode: MISSING_STAR_AFTER_SYNC
  parameters: none
  problemMessage: "Invalid modifier 'sync'."
  correctionMessage: "Try replacing 'sync' with 'sync*'."
  script: "main() sync {}"

invalidVoid:
  pseudoSharedCode: EXPECTED_TYPE_NAME
  parameters: none
  problemMessage: "Type 'void' can't be used here."
  correctionMessage: "Try removing 'void' keyword or replace it with 'var', 'final', or a type."
  script:
    - "class Foo extends void {}"
  exampleAllowOtherCodes: true

finalFieldNotInitialized:
  parameters:
    Name fieldName: The name of the uninitialized field.
  problemMessage: "Final field '#fieldName' is not initialized."
  correctionMessage: "Try to initialize the field in the declaration or in every constructor."
  script: |
    class C {
      final int x;
    }

finalFieldNotInitializedByConstructor:
  parameters:
    Name fieldName: The name of the uninitialized field.
  problemMessage: "Final field '#fieldName' is not initialized by this constructor."
  correctionMessage: "Try to initialize the field using an initializing formal or a field initializer."
  script: |
    class C {
      final int x;
      C(this.x) {}
      C.missing() {}
    }

missingExponent:
  pseudoSharedCode: MISSING_DIGIT
  parameters: none
  problemMessage: "Numbers in exponential notation should always contain an exponent (an integer number with an optional sign)."
  correctionMessage: "Make sure there is an exponent, and remove any whitespace before it."
  script: |
    main() {
      var i = 1e;
    }

positionalParameterWithEquals:
  pseudoSharedCode: WRONG_SEPARATOR_FOR_POSITIONAL_PARAMETER
  parameters: none
  problemMessage: "Positional optional parameters can't use ':' to specify a default value."
  correctionMessage: "Try replacing ':' with '='."
  script: |
    main() {
      foo([a: 1]) => print(a);
      foo(2);
    }

requiredParameterWithDefault:
  pseudoSharedCode: NAMED_PARAMETER_OUTSIDE_GROUP
  parameters: none
  problemMessage: "Non-optional parameters can't have a default value."
  correctionMessage: "Try removing the default value or making the parameter optional."
  script:
    - >
      main() {
        foo(a: 1) => print(a);
        foo(2);
      }
    - >
      main() {
        foo(a = 1) => print(a);
        foo(2);
      }

invalidCodePoint:
  pseudoSharedCode: INVALID_CODE_POINT
  parameters: none
  problemMessage: "The escape sequence starting with '\\u' isn't a valid code point."
  expression:
    - "'\\u{110000}'"

unexpectedDollarInString:
  pseudoSharedCode: UNEXPECTED_DOLLAR_IN_STRING
  parameters: none
  problemMessage: "A '$' has special meaning inside a string, and must be followed by an identifier or an expression in curly braces ({})."
  correctionMessage: "Try adding a backslash (\\) to escape the '$'."
  expression:
    - "'$'"
    - '"$"'
    - "'''$'''"
    - '"""$"""'

unexpectedSeparatorInNumber:
  pseudoSharedCode: UNEXPECTED_SEPARATOR_IN_NUMBER
  parameters: none
  problemMessage: "Digit separators ('_') in a number literal can only be placed between two digits."
  correctionMessage: "Try removing the '_'."
  expression:
    - '123_'
    - '1.23_'
    - '1_.23'
    - '0x_123'
    - '0x123_'
    - '1_e23'
    - '1e_23'
    - '1.2_e3'
    - '1.2e_3'

unexpectedToken:
  pseudoSharedCode: UNEXPECTED_TOKEN
  parameters:
    Token lexeme: The token that was found.
  problemMessage: "Unexpected token '#lexeme'."
  script:
    - "import 'b.dart' d as b;"
  exampleAllowOtherCodes: true

unmatchedToken:
  pseudoSharedCode: EXPECTED_TOKEN
  parameters:
    String expected: The token that was expected.
    Token lexeme: The opening brace token that was unmatched.
  problemMessage: "Can't find '#expected' to match '#lexeme'."
  script:
    - "main("
    - "main(){"
    - "main(){[}"
  exampleAllowOtherCodes: true

unsupportedOperator:
  pseudoSharedCode: UNSUPPORTED_OPERATOR
  parameters:
    Token operator: The unsupported operator.
  problemMessage: "The '#operator' operator is not supported."
  script:
    - "class C { void operator ===(x) {} }"
    - "class C { void operator !==(x) {} }"

unsupportedPrefixPlus:
  pseudoSharedCode: MISSING_IDENTIFIER
  parameters: none
  problemMessage: "'+' is not a prefix operator."
  correctionMessage: "Try removing '+'."
  expression: "+2" # No longer a valid way to write '2'

unterminatedComment:
  pseudoSharedCode: UNTERMINATED_MULTI_LINE_COMMENT
  parameters: none
  problemMessage: "Comment starting with '/*' must end with '*/'."
  script:
    main() {
    }
    /*

unterminatedString:
  pseudoSharedCode: UNTERMINATED_STRING_LITERAL
  parameters:
    String openQuote: The quote sequence that opened the string.
    String expectedCloseQuote: The quote sequence that was expected to close the string.
  problemMessage: "String starting with #openQuote must end with #expectedCloseQuote."
  script:
    - >
      main() {
        return '
      ;
      }
    - >
      main() {
        return \"
      ;
      }
    - >
      main() {
        return r'
      ;
      }
    - >
      main() {
        return r\"
      ;
      }
    - >
      main() => '''
    - >
      main() => \"\"\"
    - >
      main() => r'''
    - >
      main() => r\"\"\"
  exampleAllowOtherCodes: true

unterminatedToken:
  # This is a fall-back message that shouldn't happen.
  parameters: none
  problemMessage: "Incomplete token."

# Note: avoid using this template, it should only be used for debugging and
# prototyping, see [diagnostics.md](
# lib/src/base/diagnostics.md#avoid-composing-messages-programmatically).
unspecified:
  pseudoSharedCode: UNSPECIFIED
  parameters:
    String message: The error message.
  problemMessage: "#message"

abstractNotSync:
  pseudoSharedCode: NON_SYNC_ABSTRACT_METHOD
  parameters: none
  problemMessage: "Abstract methods can't use 'async', 'async*', or 'sync*'."
  script: |
    abstract class Foo {
      Future<void> bar() async;
    }
  exampleAllowOtherCodes: true

awaitAsIdentifier:
  pseudoSharedCode: ASYNC_KEYWORD_USED_AS_IDENTIFIER
  parameters: none
  problemMessage: "'await' can't be used as an identifier in 'async', 'async*', or 'sync*' methods."
  script: |
    Future<void> foo() async {
      int await = 1;
    }

awaitNotAsync:
  pseudoSharedCode: AWAIT_IN_WRONG_CONTEXT
  parameters: none
  problemMessage: "'await' can only be used in 'async' or 'async*' methods."
  script: |
    void foo() {
      await null;
    }

builtInIdentifierAsType:
  pseudoSharedCode: BUILT_IN_IDENTIFIER_AS_TYPE
  parameters:
    Token lexeme: The token that was found.
  problemMessage: "The built-in identifier '#lexeme' can't be used as a type."
  script: |
    class Foo<as extends Comparable<as>> {}
  exampleAllowOtherCodes: true

builtInIdentifierInDeclaration:
  pseudoSharedCode: BUILT_IN_IDENTIFIER_IN_DECLARATION
  parameters:
    Token lexeme: The token that was found.
  problemMessage: "Can't use '#lexeme' as a name here."
  script: |
    class late {}

awaitForNotAsync:
  pseudoSharedCode: ASYNC_FOR_IN_WRONG_CONTEXT
  parameters: none
  problemMessage: "The asynchronous for-in can only be used in functions marked with 'async' or 'async*'."
  correctionMessage: "Try marking the function body with either 'async' or 'async*', or removing the 'await' before the for loop."
  script: |
    main(o) sync* {
      await for (var e in o) {}
    }

constructorNotSync:
  parameters: none
  problemMessage: "Constructor bodies can't use 'async', 'async*', or 'sync*'."
  script: |
    class Foo {
      Foo() async {}
    }

factoryNotSync:
  pseudoSharedCode: NON_SYNC_FACTORY
  parameters: none
  problemMessage: "Factory bodies can't use 'async', 'async*', or 'sync*'."
  script: |
    class Foo {
      Foo._();
      factory Foo.x() async => new Foo._();
    }

generatorReturnsValue:
  pseudoSharedCode: RETURN_IN_GENERATOR
  parameters: none
  problemMessage: "'sync*' and 'async*' can't return a value."
  script: |
    Iterable<int> foo() sync* {
      return [42];
    }

invalidInlineFunctionType:
  pseudoSharedCode: INVALID_INLINE_FUNCTION_TYPE
  parameters: none
  problemMessage: "Inline function types cannot be used for parameters in a generic function type."
  correctionMessage: "Try changing the inline function type (as in 'int f()') to a prefixed function type using the `Function` keyword (as in 'int Function() f')."
  declaration: "typedef F = Function(int f(String x));"

setterNotSync:
  pseudoSharedCode: INVALID_MODIFIER_ON_SETTER
  parameters: none
  problemMessage: "Setters can't use 'async', 'async*', or 'sync*'."
  script: |
    set foo(int x) async {}

yieldAsIdentifier:
  pseudoSharedCode: ASYNC_KEYWORD_USED_AS_IDENTIFIER
  parameters: none
  problemMessage: "'yield' can't be used as an identifier in 'async', 'async*', or 'sync*' methods."
  script: |
    Future<void> foo() async {
      int yield = 1;
    }

yieldNotGenerator:
  pseudoSharedCode: YIELD_IN_NON_GENERATOR
  parameters: none
  problemMessage: "'yield' can only be used in 'sync*' or 'async*' methods."
  script: |
    Future<int> f() => Future.value(7);
    List<int> g() {
      yield f();
      return [];
    }

positionalAfterNamedArgument:
  pseudoSharedCode: POSITIONAL_AFTER_NAMED_ARGUMENT
  parameters: none
  problemMessage: "Place positional arguments before named arguments."
  correctionMessage: "Try moving the positional argument before the named arguments, or add a name to the argument."

expectedNamedArgument:
  parameters: none
  problemMessage: "Expected named argument."
  script: |
    // @dart=2.16
    void foo({int x = 1, int y = 2}) {}
    void bar() => foo(x: 42, ,);
  exampleAllowOtherCodes: true

assertAsExpression:
  pseudoSharedCode: ASSERT_AS_EXPRESSION
  parameters: none
  problemMessage: "`assert` can't be used as an expression."
  script: |
    int assert(int x) {
      if (x == 0) return 42;
      return assert(x-1) + 1;
    }
  exampleAllowOtherCodes: true

functionTypeDefaultValue:
  pseudoSharedCode: DEFAULT_VALUE_IN_FUNCTION_TYPE
  parameters: none
  problemMessage: "Can't have a default value in a function type."
  script: |
    void Function({dynamic obj = Object})? x;

privateNamedParameter:
  pseudoSharedCode: PRIVATE_OPTIONAL_PARAMETER
  parameters: none
  problemMessage: "A named parameter can't start with an underscore ('_')."
  script: |
    // @dart=3.10
    void foo({int? _hello}) {}

privateNamedNonFieldParameter:
  pseudoSharedCode: PRIVATE_NAMED_NON_FIELD_PARAMETER
  parameters: none
  problemMessage: "A named parameter that doesn't refer to an instance variable can't start with an underscore ('_')."
  experiments: private-named-parameters
  script: |
    void foo({int? _hello}) {}

privateNamedParameterWithoutPublicName:
  parameters: none
  problemMessage: "A private named parameter must have a corresponding public name."
  experiments: private-named-parameters
  script: |
    class C {
      int? _123;
      C({this._123});
    }

privateNamedParameterDuplicatePublicName:
  parameters:
    String name: the corresponding public name of private named parameter
  problemMessage: "The corresponding public name '#name' is already the name of another parameter."
  experiments: private-named-parameters
  script: |
    class C {
      int? _x;
      C(int x, {this._x});
    }

getterWithFormals:
  pseudoSharedCode: GETTER_WITH_PARAMETERS
  parameters: none
  problemMessage: "A getter can't have formal parameters."
  correctionMessage: "Try removing '(...)'."
  script: |
    int get foo(int x) => 42;

setterWithWrongNumberOfFormals:
  parameters: none
  problemMessage: "A setter should have exactly one formal parameter."
  script:
    - "var set foo; main(){}"
  exampleAllowOtherCodes: true

constFieldWithoutInitializer:
  pseudoSharedCode: CONST_NOT_INITIALIZED
  parameters:
    Name name: The name of the uninitialized variable.
  problemMessage: "The const variable '#name' must be initialized."
  correctionMessage: "Try adding an initializer ('= expression') to the declaration."
  script:
    - "var const foo; main(){}"
  exampleAllowOtherCodes: true

finalFieldWithoutInitializer:
  pseudoSharedCode: FINAL_NOT_INITIALIZED
  parameters:
    Name name: The name of the uninitialized field.
  problemMessage: "The final variable '#name' must be initialized."
  correctionMessage: "Try adding an initializer ('= expression') to the declaration."
  script:
    - "var final foo; main(){}"
  exampleAllowOtherCodes: true

constructorNotFound:
  parameters:
    Name name: The name of the constructor that was not found.
  problemMessage: "Couldn't find constructor '#name'."
  script: |
    class Foo {
      Foo.bar() {}
    }
    void baz() {
      new Foo.baz();
    }

constructorWithWrongNameContext:
  parameters:
    Name name: The name of the enclosing class.
  problemMessage: "The name of the enclosing class is '#name'."
  severity: CONTEXT

constructorCyclic:
  parameters: none
  problemMessage: "Redirecting constructors can't be cyclic."
  correctionMessage: "Try to have all constructors eventually redirect to a non-redirecting constructor."
  script:
    - "class C { C.foo() : this.bar(); C.bar() : this.foo(); }"

superParameterInitializerOutsideConstructor:
  parameters: none
  problemMessage: "Super-initializer formal parameters can only be used in generative constructors."
  correctionMessage: "Try removing 'super.'."
  script: |
    class A {
      A(int x);
    }
    class C extends A {
      C(super._);
      factory C.r2(super._) = C; // Error.
    }
  exampleAllowOtherCodes: true

redirectionTargetNotFound:
  parameters:
    Name name: The name of the constructor target that was sought.
  problemMessage: "Redirection constructor target not found: '#name'"
  script: |
    class Class {
      factory Class.a() = Class.nonexisting;
    }

cyclicTypedef:
  parameters:
    Name name: The name of the cyclic typedef.
  problemMessage: "The typedef '#name' has a reference to itself."
  script: |
    typedef Foo = Foo;

typeNotFound:
  parameters:
    Name name: The name of the type that was not found.
  problemMessage: "Type '#name' not found."
  script: |
    Bar? foo() {
      return null;
    }

nameNotFound:
  parameters:
    Name name: The name that was undefined.
  problemMessage: "Undefined name '#name'."
  script: |
    void foo() => bar;

memberNotFound:
  parameters:
    Name name: The name of the member that was not found.
  problemMessage: "Member not found: '#name'."
  script: |
    class Foo {}
    void bar() => Foo.baz();

getterNotFound:
  parameters:
    Name name: The name of the getter that was not found.
  problemMessage: "Getter not found: '#name'."
  script:
    void set onlySetter(value) {}
    void foo() => print(onlySetter);

setterNotFound:
  parameters:
    Name name: The name of the setter that was not found.
  problemMessage: "Setter not found: '#name'."
  script: |
    void x() {
      foo = 42;
    }

methodNotFound:
  parameters:
    Name name: The name of the method that was not found.
  problemMessage: "Method not found: '#name'."
  script: |
    void foo() => z("Hello, World!");

candidateFound:
  parameters: none
  problemMessage: "Found this candidate, but the arguments don't match."
  severity: CONTEXT

candidateFoundIsDefaultConstructor:
  parameters:
    Name name: The name of the class with a candidate default constructor.
  problemMessage: "The class '#name' has a constructor that takes no arguments."
  severity: CONTEXT

tooFewArguments:
  parameters:
    int requiredParameterCount: The number of parameters required.
    int actualArgumentCount: The number of arguments given.
  problemMessage: "Too few positional arguments: #requiredParameterCount required, #actualArgumentCount given."
  script: |
    void foo(int i) {}
    void bar() {
      foo();
    }

tooManyArguments:
  parameters:
    int allowedParameterCount: The number of parameters allowed.
    int actualArgumentCount: The number of arguments given.
  problemMessage: "Too many positional arguments: #allowedParameterCount allowed, but #actualArgumentCount found."
  correctionMessage: "Try removing the extra positional arguments."
  script: |
    void foo(int i) {}
    void bar() {
      foo(1, 2);
    }

noSuchNamedParameter:
  parameters:
    Name name: The name of the parameter that was not found.
  problemMessage: "No named parameter with the name '#name'."
  script: |
    void foo(int i) => i.toString(hello: 42);

abstractClassInstantiation:
  parameters:
    Name name: The name of the abstract class.
  problemMessage: "The class '#name' is abstract and can't be instantiated."
  script: |
    abstract class Foo {}
    main() { new Foo(); }

enumInstantiation:
  parameters: none
  problemMessage: "Enums can't be instantiated."
  script: |
    enum E {
      a, b, c;
      factory E.x() {
        return const E();
      }
    }

abstractRedirectedClassInstantiation:
  parameters:
    Name name: The name of the class that was redirected to.
  problemMessage: "Factory redirects to class '#name', which is abstract and can't be instantiated."
  script: |
    abstract class A {
      A._();
      factory A() = B;
    }

    abstract class B extends A {
      B() : super._();
    }

missingImplementationNotAbstract:
  parameters:
    Name className: The name of the class that is missing implementations.
    Names memberNames: The names of the missing members.
  problemMessage: |
    The non-abstract class '#className' is missing implementations for these members:
    #memberNames
  correctionMessage: |
    Try to either
     - provide an implementation,
     - inherit an implementation from a superclass or mixin,
     - mark the class as abstract, or
     - provide a 'noSuchMethod' implementation.
  script:
    - "class C {foo();}"

missingImplementationCause:
  parameters:
    Name name: The name of the definition.
  problemMessage: "'#name' is defined here."
  severity: CONTEXT

interfaceCheck:
  parameters:
    Name memberName: The name of the problematic member.
    Name className: The name of the non-abstract class.
  problemMessage: "The implementation of '#memberName' in the non-abstract class '#className' does not conform to its interface."
  script: |
    class A {
      void foo() {}
    }

    abstract class B extends A {
      void foo([a]);
    }

    class C extends B {}

namedMixinOverride:
  parameters:
    Name className: The name of the mixin application class.
    Name overriddenMemberName: The name of the erroneously overridden member.
  problemMessage: "The mixin application class '#className' introduces an erroneous override of '#overriddenMemberName'."
  script: |
    class Super {
      void extendedConcreteMixedInConcreteMethod() {}
    }

    mixin class Mixin {
      void extendedConcreteMixedInConcreteMethod(int i) {}
    }

    class NamedMixin = Super with Mixin;

implicitMixinOverride:
  parameters:
    Name mixinName: The name of the problematic mixin.
    Name baseName: The name of the type the mixin is applied to.
    Name erroneousMember: The name of the member that is erroneously overridden.
  problemMessage: "Applying the mixin '#mixinName' to '#baseName' introduces an erroneous override of '#erroneousMember'."
  script: |
    abstract class Super {
      String get extendedGetterMixedInField => '';
    }

    mixin Mixin {
      int extendedGetterMixedInField = 0;
    }

    abstract class Class extends Super with Mixin { }

listLiteralTooManyTypeArguments:
  parameters: none
  problemMessage: "List literal requires exactly one type argument."
  script: |
    void foo() {
      var x = <int, int>[];
    }

setOrMapLiteralTooManyTypeArguments:
  pseudoSharedCode: SET_OR_MAP_LITERAL_TOO_MANY_TYPE_ARGUMENTS
  parameters: none
  problemMessage: "A set or map literal requires exactly one or two type arguments, respectively."
  script: |
    var x = <int, int, int>{};

loadLibraryTakesNoArguments:
  parameters: none
  problemMessage: "'loadLibrary' takes no arguments."
  script:
    main.dart: |
      import "lib.dart" deferred as lib;
      void main() {
        lib.loadLibrary(10);
      }
    lib.dart: ""

typeArgumentMismatch:
  parameters:
    int expectedCount: The number of type arguments that were expected.
  problemMessage: "Expected #expectedCount type arguments."
  script: |
    void foo() {
      new List<int, int>.filled(0, 42);
    }

notAType:
  parameters:
    Name name: The invalid type name.
  problemMessage: "'#name' isn't a type."
  script:
    main.dart: |
      import 'lib.dart' as prefix;

      void foo() {
        prefix.NonExisting? e;
      }
    lib.dart: ""

notATypeContext:
  parameters: none
  problemMessage: "This isn't a type."
  severity: CONTEXT

notAPrefixInTypeAnnotation:
  parameters:
    Name prefix: The purported import prefix.
    Name typeName: The erroneous type name (the identifier after the prefix).
  problemMessage: "'#prefix.#typeName' can't be used as a type because '#prefix' doesn't refer to an import prefix."
  declaration:
    - |
        class C<T> {
          T.String method() {}
        }
    - |
        class C<T> {
          T.String field;
        }

fastaUsageShort:
  parameters: none
  problemMessage: |
    Frequently used options:

      -o <file> Generate the output into <file>.
      -h        Display this message (add -v for information about all options).

fastaUsageLong:
  # TODO(ahe): Consider if the reference to platform.dill needs to change below?
  parameters: none
  problemMessage: |
    Supported options:

      -o <file>, --output=<file>
        Generate the output into <file>.

      -h, /h, /?, --help
        Display this message (add -v for information about all options).

      -v, --verbose
        Display verbose information.

      -Dname
      -Dname=value
        Define an environment variable in the compile-time environment.

      --no-defines
        Ignore all -D options and leave environment constants unevaluated.

      --
        Stop option parsing, the rest of the command line is assumed to be
        file names or arguments to the Dart program.

      --packages=<file>
        Use package resolution configuration <file>, which should contain a mapping
        of package names to paths.

      --platform=<file>
        Read the SDK platform from <file>, which should be in Dill/Kernel IR format
        and contain the Dart SDK.

      --target=dart2js|dart2js_server|dart2wasm|dart2wasm_js_compatibility|dart_runner|dartdevc|flutter|flutter_runner|none|vm
        Specify the target configuration.

      --enable-asserts
        Check asserts in initializers during constant evaluation.

      --verify
        Check that the generated output is free of various problems. This is mostly
        useful for developers of this compiler or Kernel transformations.

      --dump-ir
        Print compiled libraries in Kernel source notation.

      --omit-platform
        Exclude the platform from the serialized dill file.

      --exclude-source
        Do not include source code in the dill file.

      --compile-sdk=<sdk>
        Compile the SDK from scratch instead of reading it from a .dill file
        (see --platform).

      --sdk=<sdk>
        Location of the SDK sources for use when compiling additional platform
        libraries.

      --single-root-scheme=String
      --single-root-base=<dir>
        Specify a custom URI scheme and a location on disk where such URIs are
        mapped to.

        When specified, the compiler can be invoked with inputs using the custom
        URI scheme. The compiler can ignore the exact location of files on disk
        and as a result to produce output that is independent of the absolute
        location of files on disk. This is mostly useful for integrating with
        build systems.

      --fatal=errors
      --fatal=warnings
        Makes messages of the given kinds fatal, that is, immediately stop the
        compiler with a non-zero exit-code. In --verbose mode, also display an
        internal stack trace from the compiler. Multiple kinds can be separated by
        commas, for example, --fatal=errors,warnings.

      --fatal-skip=<number>
      --fatal-skip=trace
        Skip this many messages that would otherwise be fatal before aborting the
        compilation. Default is 0, which stops at the first message. Specify
        'trace' to print a stack trace for every message without stopping.

      --enable-experiment=<flag>
        Enable or disable an experimental flag, used to guard features currently
        in development. Prefix an experiment name with 'no-' to disable it.
        Multiple experiments can be separated by commas.

fastaCLIArgumentRequired:
  pseudoSharedCode: FASTA_CLI_ARGUMENT_REQUIRED
  parameters:
    Name argumentName: The name of the argument that requires a value.
  problemMessage: "Expected value after '#argumentName'."

namedFunctionExpression:
  pseudoSharedCode: NAMED_FUNCTION_EXPRESSION
  parameters: none
  problemMessage: "A function expression can't have a name."
  script: |
    var x = void f<T>(T t) {};

internalProblemUnhandled:
  pseudoSharedCode: INTERNAL_PROBLEM_UNHANDLED
  parameters:
    String what: The thing that was unhandled.
    String where: The context in which it was unhandled.
  problemMessage: "Unhandled #what in #where."
  severity: INTERNAL_PROBLEM

internalProblemUnimplemented:
  parameters:
    String what: The thing that was unimplemented.
  problemMessage: "Unimplemented #what."
  severity: INTERNAL_PROBLEM

internalProblemUnexpected:
  parameters:
    String expected: The thing that was expected.
    String actual: The thing that was found.
  problemMessage: "Expected '#expected', but got '#actual'."
  severity: INTERNAL_PROBLEM

internalProblemUnsupported:
  pseudoSharedCode: INTERNAL_PROBLEM_UNSUPPORTED
  parameters:
    Name operation: The operation that is unsupported.
  problemMessage: "Unsupported operation: '#operation'."
  severity: INTERNAL_PROBLEM

internalProblemNotFound:
  parameters:
    Name name: The name of the thing that couldn't be found.
  problemMessage: "Couldn't find '#name'."
  severity: INTERNAL_PROBLEM

internalProblemNotFoundIn:
  parameters:
    Name name: The name of the thing that couldn't be found.
    Name within: The thing it was sought within.
  problemMessage: "Couldn't find '#name' in '#within'."
  severity: INTERNAL_PROBLEM

internalProblemPrivateConstructorAccess:
  parameters:
    Name name: The name of the inaccessible private constructor.
  problemMessage: "Can't access private constructor '#name'."
  severity: INTERNAL_PROBLEM

internalProblemConstructorNotFound:
  parameters:
    Name name: The name of the constructor that was not found.
    Uri uri: The URI of the library in which the constructor was sought.
  problemMessage: "No constructor named '#name' in '#uri'."
  severity: INTERNAL_PROBLEM

internalProblemExtendingUnmodifiableScope:
  parameters: none
  problemMessage: "Can't extend an unmodifiable scope."
  severity: INTERNAL_PROBLEM

internalProblemPreviousTokenNotFound:
  parameters: none
  problemMessage: "Couldn't find previous token."
  severity: INTERNAL_PROBLEM

internalProblemStackNotEmpty:
  pseudoSharedCode: INTERNAL_PROBLEM_STACK_NOT_EMPTY
  parameters:
    Name typeName: The name of the type whose stack isn't empty.
    String stackContents: The contents of the stack.
  problemMessage: "#typeName.stack isn't empty:\n  #stackContents"
  severity: INTERNAL_PROBLEM

internalProblemAlreadyInitialized:
  parameters: none
  problemMessage: "Attempt to set initializer on field without initializer."
  severity: INTERNAL_PROBLEM

internalProblemBodyOnAbstractMethod:
  parameters: none
  problemMessage: "Attempting to set body on abstract method."
  severity: INTERNAL_PROBLEM

internalProblemMissingContext:
  parameters: none
  problemMessage: "Compiler cannot run without a compiler context."
  correctionMessage: "Are calls to the compiler wrapped in CompilerContext.runInContext?"
  severity: INTERNAL_PROBLEM

internalProblemProvidedBothCompileSdkAndSdkSummary:
  parameters: none
  problemMessage: "The compileSdk and sdkSummary options are mutually exclusive"
  severity: INTERNAL_PROBLEM

internalProblemUriMissingScheme:
  parameters:
    Uri uri: The URI that has no scheme.
  problemMessage: "The URI '#uri' has no scheme."
  severity: INTERNAL_PROBLEM

internalProblemContextSeverity:
  parameters:
    String messageCode: The message's diagnostic code.
  problemMessage: "Non-context message has context severity: #messageCode"
  severity: INTERNAL_PROBLEM

internalProblemVerificationError:
  parameters:
    String details: The details of the verification error.
  problemMessage: |
    Verification of the generated program failed:
    #details
  severity: INTERNAL_PROBLEM

verificationErrorOriginContext:
  parameters: none
  problemMessage: "The node most likely is taken from here by a transformer."
  severity: CONTEXT

internalProblemDebugAbort:
  parameters:
    Name severityName: The name of the severity.
    String stackTrace: The stack trace where the abort occurred.
  problemMessage: "Compilation aborted due to fatal '#severityName' at:\n#stackTrace"
  severity: INTERNAL_PROBLEM

internalProblemLabelUsageInVariablesDeclaration:
  parameters: none
  problemMessage: "Unexpected usage of label inside declaration of variables."
  severity: INTERNAL_PROBLEM

internalProblemUnsupportedNullability:
  parameters:
    String nullability: The unsupported nullability value.
    Type type: The type containing the unsupported nullability.
  problemMessage: "Unsupported nullability value '#nullability' on type '#type'."
  severity: INTERNAL_PROBLEM

internalProblemOmittedTypeNameInConstructorReference:
  parameters: none
  problemMessage: "Unsupported omission of the type name in a constructor reference outside of an enum element declaration."
  severity: INTERNAL_PROBLEM

incrementalCompilerIllegalParameter:
  parameters:
    String parameterName: The illegal parameter name.
  problemMessage: "Illegal parameter name '#parameterName' found during expression compilation."

incrementalCompilerIllegalTypeParameter:
  parameters:
    String typeParameterName: The illegal type parameter name.
  problemMessage: "Illegal type parameter name '#typeParameterName' found during expression compilation."

debugTrace:
  parameters:
    Name severity: The severity of the trace.
    String stackTrace: The stack trace.
  problemMessage: "Fatal '#severity' at:\n#stackTrace"
  severity: IGNORED

deferredTypeAnnotation:
  parameters:
    Type type: The type that is deferred loaded.
    Name prefix: The prefix by which the type is deferred loaded.
  problemMessage: "The type '#type' is deferred loaded via prefix '#prefix' and can't be used as a type annotation."
  correctionMessage: "Try removing 'deferred' from the import of '#prefix' or use a supertype of '#type' that isn't deferred."
  script:
    main.dart: |
      import 'lib.dart' deferred as lib;
      void foo(Object x) {
        x as lib.C;
      }
    lib.dart: |
      class C {}

duplicatedExport:
  parameters:
    Name name: The name that is exported from multiple URIs.
    Uri uri: The first URI the name is exported from.
    Uri uri2: The second URI the name is exported from.
  problemMessage: "'#name' is exported from both '#uri' and '#uri2'."
  script:
    lib1.dart: "class A {}"
    lib2.dart: "class A {}"
    main.dart: "export 'lib1.dart'; export 'lib2.dart';"

duplicatedImport:
  parameters:
    Name name: The name that is imported from multiple URIs.
    Uri uri: The first URI the name is imported from.
    Uri uri2: The second URI the name is imported from.
  problemMessage: "'#name' is imported from both '#uri' and '#uri2'."
  script:
    lib1.dart: "class A {}"
    lib2.dart: "class A {}"
    main.dart: "import 'lib1.dart'; import 'lib2.dart'; A a;"

cyclicClassHierarchy:
  parameters:
    Name typeName: The name of the type that is a supertype of itself.
  problemMessage: "'#typeName' is a supertype of itself."
  script:
    - |
      class A extends B {}
      class B extends A {}
    - |
      class A implements B {}
      class B implements A {}
    - "class C = Object with C;"
    - "class C extends C {}"
    - "class C implements C {}"
  exampleAllowMultipleReports: true

extendingEnum:
  parameters:
    Name enumName: The name of the enum that is being erroneously extended or implemented.
  problemMessage: "'#enumName' is an enum and can't be extended or implemented."
  script: |
    enum Foo { a, b, c; }
    abstract class Bar extends Foo {}
  exampleAllowOtherCodes: true

extendingRestricted:
  parameters:
    Name restrictedName: The name of the restricted type that is being erroneously extended or implemented.
  problemMessage: "'#restrictedName' is restricted and can't be extended or implemented."
  script: |
    abstract class Foo extends String {}
  exampleAllowOtherCodes: true

noUnnamedConstructorInObject:
  parameters: none
  problemMessage: "'Object' has no unnamed constructor."

illegalAsyncGeneratorReturnType:
  parameters: none
  problemMessage: "Functions marked 'async*' must have a return type assignable to 'Stream'."
  script:
    - >-
      int g() async* {
        yield 0;
      }

illegalAsyncGeneratorVoidReturnType:
  parameters: none
  problemMessage: "Functions marked 'async*' can't have return type 'void'."
  script:
    - >-
      void g() async* {
      }

illegalAsyncReturnType:
  parameters: none
  problemMessage: "Functions marked 'async' must have a return type assignable to 'Future'."
  script:
    - >-
      int f() async {
        return 0;
      }

illegalSyncGeneratorReturnType:
  parameters: none
  problemMessage: "Functions marked 'sync*' must have a return type assignable to 'Iterable'."
  script:
    - >-
      int g() sync* {
        yield 0;
      }

illegalSyncGeneratorVoidReturnType:
  parameters: none
  problemMessage: "Functions marked 'sync*' can't have return type 'void'."
  script:
    - >-
      void g() sync* {
      }

illegalMixinDueToConstructors:
  # a class with a constructor is used as a mixin
  parameters:
    Name className: The name of the class that can't be used as a mixin.
  problemMessage: "Can't use '#className' as a mixin because it has constructors."
  script: |
    // @dart=2.19
    class B with Error {}

illegalMixinDueToConstructorsCause:
  parameters:
    Name className: The name of the class that can't be used as a mixin.
  problemMessage: "This constructor prevents using '#className' as a mixin."
  severity: CONTEXT

extensionTypeDeclaresAbstractMember:
  pseudoSharedCode: EXTENSION_TYPE_WITH_ABSTRACT_MEMBER
  parameters: none
  problemMessage: "Extension types can't declare abstract members."
  correctionMessage: "Try providing an implementation for the member."
  script: |
    extension type ET(int id) {
      void method();
    }

extensionDeclaresInstanceField:
  pseudoSharedCode: EXTENSION_DECLARES_INSTANCE_FIELD
  parameters: none
  problemMessage: "Extensions can't declare instance fields"
  correctionMessage: "Try removing the field declaration or making it a static field"
  script: |
    extension E on int {
      int? field;
    }

extensionTypeDeclaresInstanceField:
  pseudoSharedCode: EXTENSION_TYPE_DECLARES_INSTANCE_FIELD
  parameters: none
  problemMessage: "Extension types can't declare instance fields"
  correctionMessage: "Try removing the field declaration or making it a static field"
  script: |
    extension type ET(int id) {
      int? field;
    }

staticConflictsWithInstance:
  parameters:
    Name propertyName: The name of the static property that has a conflict.
  problemMessage: "Static property '#propertyName' conflicts with instance property of the same name."
  script: |
    class A {
      void set foo(_) {}
      static int get foo => 42;
    }

staticConflictsWithInstanceCause:
  parameters:
    Name propertyName: The name of the static property that has a conflict.
  problemMessage: "Conflicting instance property '#propertyName'."
  severity: CONTEXT

instanceConflictsWithStatic:
  parameters:
    Name propertyName: The name of the instance property that has a conflict.
  problemMessage: "Instance property '#propertyName' conflicts with static property of the same name."
  script: |
    class A {
      static void set foo(_) {}
      int get foo => 42;
    }

instanceConflictsWithStaticCause:
  parameters:
    Name propertyName: The name of the instance property that has a conflict.
  problemMessage: "Conflicting static property '#propertyName'."
  severity: CONTEXT

setterConflictsWithDeclaration:
  parameters:
    Name setterName: The name of the setter that has a conflict.
  problemMessage: "The setter conflicts with declaration '#setterName'."
  script: |
    class Foo {}
    set Foo(_) {}

setterConflictsWithDeclarationCause:
  parameters:
    Name setterName: The name of the setter that has a conflict.
  problemMessage: "Conflicting declaration '#setterName'."
  severity: CONTEXT

constructorConflictsWithMember:
  parameters:
    Name memberName: The name of the member that the constructor conflicts with.
  problemMessage: "The constructor conflicts with member '#memberName'."
  script: |
    class A {
      static int get foo => 42;
      A.foo();
    }

constructorConflictsWithMemberCause:
  parameters:
    Name memberName: The name of the member that the constructor conflicts with.
  problemMessage: "Conflicting member '#memberName'."
  severity: CONTEXT

factoryConflictsWithMember:
  parameters:
    Name memberName: The name of the member that the factory conflicts with.
  problemMessage: "The factory conflicts with member '#memberName'."
  script: |
    class A {
      static int get foo => 42;
      factory A.foo() => throw '';
    }

factoryConflictsWithMemberCause:
  parameters:
    Name memberName: The name of the member that the factory conflicts with.
  problemMessage: "Conflicting member '#memberName'."
  severity: CONTEXT

memberConflictsWithConstructor:
  parameters:
    Name constructorName: The name of the constructor that the member conflicts with.
  problemMessage: "The member conflicts with constructor '#constructorName'."
  script: |
    class A {
      A.foo();
      static void foo() {}
    }

memberConflictsWithConstructorCause:
  parameters:
    Name constructorName: The name of the constructor that the member conflicts with.
  problemMessage: "Conflicting constructor '#constructorName'."
  severity: CONTEXT

memberConflictsWithFactory:
  parameters:
    Name factoryName: The name of the factory that the member conflicts with.
  problemMessage: "The member conflicts with factory '#factoryName'."
  script: |
    class A {
      factory A.foo() => throw '';
      static void foo() {}
    }

memberConflictsWithFactoryCause:
  parameters:
    Name factoryName: The name of the factory that the member conflicts with.
  problemMessage: "Conflicting factory '#factoryName'."
  severity: CONTEXT

declarationConflictsWithSetter:
  parameters:
    Name setterName: The name of the setter that the declaration conflicts with.
  problemMessage: "The declaration conflicts with setter '#setterName'."
  script: |
    void set foo(_) {}
    void foo() {}

declarationConflictsWithSetterCause:
  parameters:
    Name setterName: The name of the setter that the declaration conflicts with.
  problemMessage: "Conflicting setter '#setterName'."
  severity: CONTEXT

conflictsWithImplicitSetter:
  parameters:
    Name fieldName: The name of the field whose implicit setter has a conflict.
  problemMessage: "Conflicts with the implicit setter of the field '#fieldName'."
  script: |
    int? foo;
    void set foo(_) {}

conflictsWithImplicitSetterCause:
  parameters:
    Name fieldName: The name of the field whose implicit setter has a conflict.
  problemMessage: "Field '#fieldName' with the implicit setter."
  severity: CONTEXT

conflictsWithTypeParameter:
  parameters:
    Name typeVariableName: The name of the conflicting type variable.
  problemMessage: "Conflicts with type variable '#typeVariableName'."
  script: |
    enum E2<values> {
      element;
    }

conflictsWithTypeParameterCause:
  parameters: none
  problemMessage: "This is the type variable."
  severity: CONTEXT

extensionMemberConflictsWithObjectMember:
  parameters:
    Name memberName: The name of the conflicting object member.
  problemMessage: "This extension member conflicts with Object member '#memberName'."
  script:
    extension Extension on String {
      int get noSuchMethod => 42;
    }

declaredMemberConflictsWithInheritedMember:
  parameters: none
  problemMessage: "Can't declare a member that conflicts with an inherited one."
  script:
    - >-
      class A {
        var foo;
      }
      class B extends A {
        foo() {}
      }
    - >-
      abstract class A {
        get foo;
      }
      class B implements A {
        foo() {}
      }
    - >-
      class A {
        foo() {}
      }
      class B extends A {
        var foo;
      }
    - >-
      abstract class A {
        foo();
      }
      class B implements A {
        var foo;
      }

declaredMemberConflictsWithInheritedMemberCause:
  parameters: none
  problemMessage: "This is the inherited member."
  severity: CONTEXT

declaredMemberConflictsWithInheritedMembersCause:
  parameters: none
  problemMessage: "This is one of the inherited members."
  severity: CONTEXT

declaredMemberConflictsWithOverriddenMembersCause:
  parameters: none
  problemMessage: "This is one of the overridden members."
  severity: CONTEXT

inheritedMembersConflict:
  parameters: none
  problemMessage: "Can't inherit members that conflict with each other."
  script:
    - >-
      class A {
        foo() {}
      }
      abstract class B {
        get foo;
      }
      abstract class C extends A implements B {}
    - >-
      class A {
        var foo;
      }
      abstract class B {
        foo();
      }
      abstract class C extends A implements B {}
    - >-
      class A {
        get foo => 0;
      }
      abstract class B {
        foo();
      }
      abstract class C extends A implements B {}

inheritedMembersConflictCause1:
  parameters: none
  problemMessage: "This is one inherited member."
  severity: CONTEXT

inheritedMembersConflictCause2:
  parameters: none
  problemMessage: "This is the other inherited member."
  severity: CONTEXT

illegalMixin:
  parameters:
    Name typeName: The name of the type that can't be mixed in.
  problemMessage: "The type '#typeName' can't be mixed in."
  script: |
    class SuperClass {}
    mixin Mixin<T> {}
    class Class<T, M extends Mixin<T>> extends SuperClass with M {}
  exampleAllowOtherCodes: true

overrideTypeParametersMismatch:
  parameters:
    Name declaredMemberName: The name of the erroneous member.
    Name overriddenMemberName: The name of the overridden member.
  problemMessage: "Declared type variables of '#declaredMemberName' doesn't match those on overridden method '#overriddenMemberName'."
  script: |
    class Super {
      void foo<X>() {}
    }

    class Sub extends Super {
      void foo<X, Y>() {}
    }

overrideTypeParametersBoundMismatch:
  parameters:
    Type declaredBoundType: The bound type in the erroneous member.
    Name typeVariableName: The name of the type variable whose bound doesn't match.
    Name declaredMemberName: The name of the erroneous member.
    Type overriddenBoundType: The bound type in the overridden member.
    Name overriddenMemberName: The name of the overridden member.
  problemMessage: "Declared bound '#declaredBoundType' of type variable '#typeVariableName' of '#declaredMemberName' doesn't match the bound '#overriddenBoundType' on overridden method '#overriddenMemberName'."
  script: |
    class Super {
      void foo<X extends String>() {}
    }

    class Sub extends Super {
      void foo<X extends bool>() {}
    }

overriddenMethodCause:
  parameters:
    Name methodName: The name of the overridden method.
  problemMessage: "This is the overridden method ('#methodName')."
  severity: CONTEXT

overrideMismatchNamedParameter:
  parameters:
    Name declaredMemberName: The name of the erroneous member.
    Name parameterName: The name of the parameter that is missing.
    Name overriddenMemberName: The name of the overridden member.
  problemMessage: "The method '#declaredMemberName' doesn't have the named parameter '#parameterName' of overridden method '#overriddenMemberName'."
  script: |
    abstract class A {
      int foo({int x = 0}) => x + 42;
    }

    class B implements A {
      int foo({int y = 0}) => y + 42;
    }

overrideFewerNamedArguments:
  parameters:
    Name declaredMemberName: The name of the erroneous member.
    Name overriddenMemberName: The name of the overridden member.
  problemMessage: "The method '#declaredMemberName' has fewer named arguments than those of overridden method '#overriddenMemberName'."
  script: |
    abstract class A {
      int foo({int x = 0, int y = 0}) => x + y + 42;
    }

    class B implements A {
      int foo({int x = 0}) => x + 42;
    }

overrideFewerPositionalArguments:
  parameters:
    Name declaredMemberName: The name of the erroneous member.
    Name overriddenMemberName: The name of the overridden member.
  problemMessage: "The method '#declaredMemberName' has fewer positional arguments than those of overridden method '#overriddenMemberName'."
  script: |
    abstract class A {
      int foo(int x, int y) => x + y + 42;
    }

    class B implements A {
      int foo(int x) => x + 42;
    }

overrideMoreRequiredArguments:
  parameters:
    Name declaredMemberName: The name of the erroneous member.
    Name overriddenMemberName: The name of the overridden member.
  problemMessage: "The method '#declaredMemberName' has more required arguments than those of overridden method '#overriddenMemberName'."
  script: |
    abstract class A {
      int foo(int x) => x + 42;
    }

    class B implements A {
      int foo(int x, int y) => x + y + 42;
    }

overrideTypeMismatchParameter:
  parameters:
    Name parameterName: The name of the parameter with a type mismatch.
    Name declaredMemberName: The name of the erroneous member.
    Type declaredType: The type of the parameter in the erroneous member.
    Type overriddenType: The type of the corresponding parameter in the overridden member.
    Name overriddenMemberName: The name of the overridden member.
  problemMessage: "The parameter '#parameterName' of the method '#declaredMemberName' has type '#declaredType', which does not match the corresponding type, '#overriddenType', in the overridden method, '#overriddenMemberName'."
  correctionMessage: "Change to a supertype of '#overriddenType', or, for a covariant parameter, a subtype."
  script: |
    abstract class A {
      int foo(int x) => x + 42;
    }

    class B implements A {
      int foo(String x) => x.length + 42;
    }

overrideTypeMismatchReturnType:
  parameters:
    Name declaredMemberName: The name of the erroneous member.
    Type declaredType: The return type of the erroneous member.
    Type overriddenType: The return type of the overridden member.
    Name overriddenMemberName: The name of the overridden member.
  problemMessage: "The return type of the method '#declaredMemberName' is '#declaredType', which does not match the return type, '#overriddenType', of the overridden method, '#overriddenMemberName'."
  correctionMessage: "Change to a subtype of '#overriddenType'."
  script: |
    abstract class A {
      int foo() => 42;
    }

    class B implements A {
      String foo() => "42";
    }

overrideTypeMismatchSetter:
  parameters:
    Name declaredMemberName: The name of the erroneous member.
    Type declaredType: The type of the erroneous member.
    Type overriddenType: The type of the overridden member.
    Name overriddenMemberName: The name of the overridden member.
  problemMessage: "The field '#declaredMemberName' has type '#declaredType', which does not match the corresponding type, '#overriddenType', in the overridden setter, '#overriddenMemberName'."
  script: |
    abstract class A {
      void set x(Object? y);
    }

    class B implements A {
      int? x;
    }

overrideMismatchRequiredNamedParameter:
  parameters:
    Name parameterName: The name of the mismatched parameter.
    Name declaredMemberName: The name of the erroneous member.
    Name overriddenMemberName: The name of the overridden member.
  problemMessage: "The required named parameter '#parameterName' in method '#declaredMemberName' is not required in overridden method '#overriddenMemberName'."
  script: |
    abstract class A {
      method({int? a});
    }
    abstract class B implements A {
      method({required int? a});
    }

invalidGetterSetterType:
  parameters:
    Type getterType: The type of the getter.
    Name getterName: The name of the getter.
    Type setterType: The type of the setter.
    Name setterName: The name of the setter.
  problemMessage: "The type '#getterType' of the getter '#getterName' is not a subtype of the type '#setterType' of the setter '#setterName'."
  script: |
    //@dart=3.5
    abstract class A {
      num get property;
      set property(int i);
    }

invalidGetterSetterTypeGetterInherited:
  parameters:
    Type getterType: The type of the getter.
    Name getterName: The name of the getter.
    Type setterType: The type of the setter.
    Name setterName: The name of the setter.
  problemMessage: "The type '#getterType' of the inherited getter '#getterName' is not a subtype of the type '#setterType' of the setter '#setterName'."
  script: |
    //@dart=3.5
    abstract class A {
      num get property;
    }
    abstract class B implements A {
      void set property(int i);
    }

invalidGetterSetterTypeFieldInherited:
  parameters:
    Type getterType: The type of the getter.
    Name getterName: The name of the getter.
    Type setterType: The type of the setter.
    Name setterName: The name of the setter.
  problemMessage: "The type '#getterType' of the inherited field '#getterName' is not a subtype of the type '#setterType' of the setter '#setterName'."
  script: |
    //@dart=3.5
    abstract class A {
      final num property;
      A(this.property);
    }
    abstract class B implements A {
      void set property(int i);
    }

invalidGetterSetterTypeSetterInheritedGetter:
  parameters:
    Type getterType: The type of the getter.
    Name getterName: The name of the getter.
    Type setterType: The type of the setter.
    Name setterName: The name of the setter.
  problemMessage: "The type '#getterType' of the getter '#getterName' is not a subtype of the type '#setterType' of the inherited setter '#setterName'."
  script: |
    //@dart=3.5
    abstract class A {
      void set property(int i);
    }
    abstract class B implements A {
      num get property;
    }

invalidGetterSetterTypeSetterInheritedField:
  parameters:
    Type getterType: The type of the getter.
    Name getterName: The name of the getter.
    Type setterType: The type of the setter.
    Name setterName: The name of the setter.
  problemMessage: "The type '#getterType' of the field '#getterName' is not a subtype of the type '#setterType' of the inherited setter '#setterName'."
  script: |
    //@dart=3.5
    abstract class A {
      void set property(int i);
    }
    abstract class B implements A {
      final num property;
      B(this.property);
    }

invalidGetterSetterTypeBothInheritedField:
  parameters:
    Type getterType: The type of the getter.
    Name getterName: The name of the getter.
    Type setterType: The type of the setter.
    Name setterName: The name of the setter.
  problemMessage: "The type '#getterType' of the inherited field '#getterName' is not a subtype of the type '#setterType' of the inherited setter '#setterName'."
  script: |
    //@dart=3.5
    abstract class A {
      final num property;
      A(this.property);
    }
    abstract class B {
      void set property(int i);
    }
    abstract class C implements A, B {}

invalidGetterSetterTypeBothInheritedGetter:
  parameters:
    Type getterType: The type of the getter.
    Name getterName: The name of the getter.
    Type setterType: The type of the setter.
    Name setterName: The name of the setter.
  problemMessage: "The type '#getterType' of the inherited getter '#getterName' is not a subtype of the type '#setterType' of the inherited setter '#setterName'."
  script: |
    //@dart=3.5
    abstract class A {
      num get property;
    }
    abstract class B {
      void set property(int i);
    }
    abstract class C implements A, B {}

invalidGetterSetterTypeFieldContext:
  parameters:
    Name getterName: The name of the getter.
  problemMessage: "This is the declaration of the field '#getterName'."
  severity: CONTEXT

invalidGetterSetterTypeGetterContext:
  parameters:
    Name getterName: The name of the getter.
  problemMessage: "This is the declaration of the getter '#getterName'."
  severity: CONTEXT

invalidGetterSetterTypeSetterContext:
  parameters:
    Name setterName: The name of the setter.
  problemMessage: "This is the declaration of the setter '#setterName'."
  severity: CONTEXT

partOfSelf:
  parameters: none
  problemMessage: "A file can't be a part of itself."
  script:
    main.dart: "part 'main.dart';"

typeParameterDuplicatedName:
  parameters: none
  problemMessage: "A type variable can't have the same name as another."
  script: |
    class C<A, A> {}

typeParameterDuplicatedNameCause:
  parameters:
    Name typeVariableName: The name of the duplicated type variable.
  problemMessage: "The other type variable named '#typeVariableName'."
  severity: CONTEXT

typeParameterSameNameAsEnclosing:
  parameters: none
  problemMessage: "A type variable can't have the same name as its enclosing declaration."
  script: |
    class C<C> {}

annotationOnFunctionTypeTypeParameter:
  parameters: none
  problemMessage: "A type variable on a function type can't have annotations."
  script: |
     // @dart=2.13
     main() { Function<@Object() T>() x; }

expectedEnumBody:
  pseudoSharedCode: MISSING_ENUM_BODY
  parameters:
    Token lexeme: The token that was found.
  problemMessage: "Expected a enum body, but got '#lexeme'."
  correctionMessage: "An enum definition must have a body with at least one constant name."
  script:
    - "enum E"

enumDeclarationEmpty:
  parameters: none
  problemMessage: "An enum declaration can't be empty."
  script:
    - "enum E {}"

operatorWithOptionalFormals:
  parameters: none
  problemMessage: "An operator can't have optional parameters."
  script: |
    class Foo {
      operator ==([Object a = 0]) => true;
    }

platformPrivateLibraryAccess:
  parameters: none
  problemMessage: "Can't access platform private library."
  script: |
    import "dart:_internal";

typedefNotFunction:
  parameters: none
  problemMessage: "Can't create typedef from non-function type."
  script: |
    // @dart=2.12
    class Foo<X> {}
    typedef Bar<X> = Foo<X>;

typedefNotType:
  parameters: none
  problemMessage: "Can't create typedef from non-type."
  script: |
    typedef Foo = ;
  exampleAllowOtherCodes: true

typedefTypeParameterNotConstructor:
  parameters: none
  problemMessage: "Can't use a typedef denoting a type variable as a constructor, nor for a static member access."
  script: |
    typedef Foo<Bar> = Bar;
    class Baz extends Foo<C> {}
    class C {}

typedefTypeParameterNotConstructorCause:
  parameters: none
  problemMessage: "This is the type variable ultimately denoted."
  severity: CONTEXT

typedefNullableType:
  parameters: none
  problemMessage: "Can't create typedef from nullable type."
  script: |
    // @dart=2.12
    typedef F = void Function()?;

typedefUnaliasedTypeCause:
  parameters: none
  problemMessage: "This is the type denoted by the type alias."
  severity: CONTEXT

typedefCause:
  parameters: none
  problemMessage: "The issue arises via this type alias."
  severity: CONTEXT

nonPartOfDirectiveInPart:
  pseudoSharedCode: NON_PART_OF_DIRECTIVE_IN_PART
  parameters: none
  problemMessage: "The part-of directive must be the only directive in a part."
  correctionMessage: "Try removing the other directives, or moving them to the library for which this is a part."
  script:
    - "part of l; part 'f.dart';"

partTwice:
  parameters:
    Uri uri: The URI that is used as a part more than once.
  problemMessage: "Can't use '#uri' as a part more than once."
  script:
    part.dart: "part of 'main.dart';"
    main.dart: "part 'part.dart'; part 'part.dart';"

partOfTwoLibraries:
  parameters: none
  problemMessage: "A file can't be part of more than one library."
  correctionMessage: "Try moving the shared declarations into the libraries, or into a new library."
  script:
    main.dart: "library lib; import 'lib.dart'; part 'part.dart';"
    lib.dart: "library lib; part 'part.dart';"
    part.dart: "part of lib;"

partOfTwoLibrariesContext:
  parameters: none
  problemMessage: "Used as a part in this library."
  severity: CONTEXT

missingFunctionParameters:
  pseudoSharedCode: MISSING_FUNCTION_PARAMETERS
  parameters: none
  problemMessage: "A function declaration needs an explicit list of parameters."
  correctionMessage: "Try adding a parameter list to the function declaration."
  script:
    - "void f {}"

missingMethodParameters:
  pseudoSharedCode: MISSING_METHOD_PARAMETERS
  parameters: none
  problemMessage: "A method declaration needs an explicit list of parameters."
  correctionMessage: "Try adding a parameter list to the method declaration."
  script:
    - "class C { void m {} }"

missingTypedefParameters:
  pseudoSharedCode: MISSING_TYPEDEF_PARAMETERS
  parameters: none
  problemMessage: "A typedef needs an explicit list of parameters."
  correctionMessage: "Try adding a parameter list to the typedef."
  script:
    - "typedef void F;"

missingPartOf:
  parameters:
    Uri uri: The URI of the erroneous part.
  problemMessage: "Can't use '#uri' as a part, because it has no 'part of' declaration."
  script:
    part.dart: ""
    main.dart: "part 'part.dart';"

partOfInLibrary:
  parameters:
    Uri uri: The URI of the invalid library.
  problemMessage: "Can't import '#uri', because it has a 'part of' declaration."
  correctionMessage: "Try removing the 'part of' declaration, or using '#uri' as a part."
  script:
    main.dart: |
      import "part.dart";
      import "lib.dart";
      main() {}

    part.dart: |
      part of "lib.dart";

    lib.dart: |
      part "part.dart";

partInPart:
  parameters: none
  problemMessage: "A file that's a part of a library can't have parts itself."
  correctionMessage: "Try moving the 'part' declaration to the containing library."
  script:
    main.dart: |
      part "part.dart";
      main() {}

    part.dart: |
      part of "main.dart";
      part "part_part.dart";

    part_part.dart: |
      part of "part.dart";

partInPartLibraryContext:
  parameters: none
  problemMessage: "This is the containing library."
  severity: CONTEXT

partOrphan:
  parameters: none
  problemMessage: "This part doesn't have a containing library."
  correctionMessage: "Try removing the 'part of' declaration."
  script: "part of none; main() {}"

partExport:
  parameters: none
  problemMessage: "Can't export this file because it contains a 'part of' declaration."
  script:
    main.dart: |
      export "part.dart";
      import "lib.dart";
      main() {}

    part.dart: |
      part of "lib.dart";

    lib.dart: |
      part "part.dart";

partExportContext:
  parameters: none
  problemMessage: "This is the file that can't be exported."
  severity: CONTEXT

supertypeIsFunction:
  parameters: none
  problemMessage: "Can't use a function type as supertype."
  script: |
    mixin M on Function() {}

deferredPrefixDuplicated:
  parameters:
    Name prefixName: The prefix used to import the deferred library.
  problemMessage: "Can't use the name '#prefixName' for a deferred library, as the name is used elsewhere."
  script:
    main.dart: |
      import 'lib1.dart' deferred as foo;
      import 'lib2.dart' as foo;
    lib1.dart: ""
    lib2.dart: ""

deferredPrefixDuplicatedCause:
  parameters:
    Name prefixName: The prefix used to import the deferred library.
  problemMessage: "'#prefixName' is used here."
  severity: CONTEXT

duplicatedDeclaration:
  parameters:
    Name name: The name of the duplicated declaration.
  problemMessage: "'#name' is already declared in this scope."
  script: |
    class C {} // First declaration (related information points here).
    class C {} // Duplicated declaration (error here).
    main() {
      // The following line is commented out as it would lead to an extraneous
      // diagnostic.
      // new C(); // Use of duplicated declaration.
    }

duplicatedDeclarationCause:
  parameters:
    Name name: The name of the duplicated declaration.
  problemMessage: "Previous declaration of '#name'."
  severity: CONTEXT

# Use this message when a duplicated declaration is used.
duplicatedDeclarationUse:
  parameters:
    Name name: The name of the duplicated declaration.
  problemMessage: "Can't use '#name' because it is declared more than once."
  script:
    - main.dart: |
        // This test can't pass as tests must produce only one error message.
        class C {} // First declaration (related information points here).
        class C {} // Duplicated declaration (error here).
        main() {
          new C(); // Use of duplicated declaration.
        }
    - main.dart: |
        import 'lib1.dart';
        import 'lib2.dart';

        main() {
          new C(); // Use of duplicated declaration.
        }
      lib1.dart: |
        class C {}
      lib2.dart: |
        class C {}

duplicatedNamedArgument:
  parameters:
    Name name: The name of the duplicated named argument.
  problemMessage: "Duplicated named argument '#name'."
  script: |
    foo({required int named}) {}

    main() {
      foo(named: 1, named: 2);
    }

duplicatedParameterName:
  parameters:
    Name name: The name of the duplicated parameter.
  problemMessage: "Duplicated parameter name '#name'."
  script: |
    foo({required int named, required int named}) {}

duplicatedParameterNameCause:
  parameters:
    Name name: The name of the duplicated parameter.
  problemMessage: "Other parameter named '#name'."
  severity: CONTEXT

notBinaryOperator:
  parameters:
    Token token: The token that isn't a binary operator.
  problemMessage: "'#token' isn't a binary operator."
  script: |
    class C { operator~() { return null; } }

    main() {
      C c = new C();
      print(c ~ 2);
    }

operatorParameterMismatch0:
  parameters:
    Name operatorName: The name of the operator that shouldn't have any parameters.
  problemMessage: "Operator '#operatorName' shouldn't have any parameters."
  script: |
    class Foo {
      operator ~(a) => true;
    }

operatorParameterMismatch1:
  parameters:
    Name operatorName: The name of the operator that should have exactly one parameter.
  problemMessage: "Operator '#operatorName' should have exactly one parameter."
  script: |
    class Foo {
      operator ==() => true;
    }
  exampleAllowOtherCodes: true

operatorParameterMismatch2:
  parameters:
    Name operatorName: The name of the operator that should have exactly two parameters.
  problemMessage: "Operator '#operatorName' should have exactly two parameters."
  script: |
    class Foo {
      operator []=(a, b, c) => true;
    }

operatorMinusParameterMismatch:
  parameters:
    Name operatorName: The name of the operator that should have zero or one parameter.
  problemMessage: "Operator '#operatorName' should have zero or one parameter."
  correctionMessage: >-
    With zero parameters, it has the syntactic form '-a', formally known as 'unary-'.
    With one parameter, it has the syntactic form 'a - b', formally known as '-'.
  script: |
    class Foo {
      operator -(a, b) => true;
    }

supertypeIsIllegal:
  parameters:
    Name typeName: The name of the type that can't be used as a supertype.
  problemMessage: "The type '#typeName' can't be used as supertype."
  script: |
    class C extends dynamic {}

supertypeIsIllegalAliased:
  parameters:
    Name typeName: The name of the type alias that can't be used as a supertype.
    Type aliasedType: The type that the alias resolves to.
  problemMessage: "The type '#typeName' which is an alias of '#aliasedType' can't be used as supertype."
  script: |
    typedef F = void Function();
    class C extends F {}

supertypeIsNullableAliased:
  parameters:
    Name typeName: The name of the type alias that can't be used as a supertype.
    Type aliasedType: The type that the alias resolves to.
  problemMessage: "The type '#typeName' which is an alias of '#aliasedType' can't be used as supertype because it is nullable."
  script: |
    class A {}
    typedef B = A?;
    class C extends B {}

supertypeIsTypeParameter:
  parameters:
    Name typeName: The name of the type variable that can't be used as a supertype.
  problemMessage: "The type variable '#typeName' can't be used as supertype."
  script: |
    class C<T> extends T {}

superExtensionTypeIsIllegal:
  parameters:
    Name typeName: The name of the type that can't be implemented by an extension type.
  problemMessage: "The type '#typeName' can't be implemented by an extension type."
  script: |
    extension type E(dynamic it) implements dynamic {}

superExtensionTypeIsIllegalAliased:
  parameters:
    Name typeName: The name of the type alias that can't be implemented by an extension type.
    Type aliasedType: The type that the alias resolves to.
  problemMessage: "The type '#typeName' which is an alias of '#aliasedType' can't be implemented by an extension type."
  script: |
    typedef F = void Function();
    extension type E(F it) implements F {}

superExtensionTypeIsNullableAliased:
  parameters:
    Name typeName: The name of the type alias that can't be implemented by an extension type.
    Type aliasedType: The type that the alias resolves to.
  problemMessage: "The type '#typeName' which is an alias of '#aliasedType' can't be implemented by an extension type because it is nullable."
  script: |
    class A {}
    typedef B = A?;
    extension type E(B it) implements B {}

superExtensionTypeIsTypeParameter:
  parameters:
    Name typeName: The name of the type variable that can't be implemented by an extension type.
  problemMessage: "The type variable '#typeName' can't be implemented by an extension type."
  script: |
    extension type E<T>(T it) implements T {}

partOfLibraryNameMismatch:
  parameters:
    Uri uri: The URI of the part file.
    Name libraryName: The name of the library containing the problematic `part` directive.
    Name partOfName: The name in the `part of` directive.
  problemMessage: "Using '#uri' as part of '#libraryName' but its 'part of' declaration says '#partOfName'."
  script:
    main.dart: |
      library foo;
      part 'lib.dart';
    lib.dart: |
      part of bar;

partOfUseUri:
  parameters:
    Uri partFileUri: The URI of the part file.
    Uri libraryUri: The URI of the library containing the `part` directive.
    Name partOfName: The name in the `part of` directive.
  problemMessage: "Using '#partFileUri' as part of '#libraryUri' but its 'part of' declaration says '#partOfName'."
  correctionMessage: "Try changing the 'part of' declaration to use a relative file name."
  script:
    main.dart: |
      part 'lib.dart';
    lib.dart: |
      part of foo;

partOfUriMismatch:
  parameters:
    Uri partUri: The URI of the part file.
    Uri libraryUri: The URI of the library containing the `part` directive.
    Uri partOfUri: The URI in the `part of` directive.
  problemMessage: "Using '#partUri' as part of '#libraryUri' but its 'part of' declaration says '#partOfUri'."
  script:
    main.dart: |
      part 'lib.dart';
    lib.dart: |
      part of 'lib2.dart';
    lib2.dart: ""

missingMain:
  parameters: none
  problemMessage: "No 'main' method found."
  correctionMessage: "Try adding a method named 'main' to your program."

missingInput:
  parameters: none
  problemMessage: "No input file provided to the compiler."

inputFileNotFound:
  parameters:
    Uri uri: The URI of the input file that was sought.
  problemMessage: "Input file not found: #uri."

sdkRootNotFound:
  parameters:
    Uri uri: The purported URI of the SDK root directory.
  problemMessage: "SDK root directory not found: #uri."

sdkSummaryNotFound:
  parameters:
    Uri uri: The purported URI of the SDK summary.
  problemMessage: "SDK summary not found: #uri."

sdkSpecificationNotFound:
  parameters:
    Uri uri: The purported URI of the SDK libraries specification.
  problemMessage: "SDK libraries specification not found: #uri."
  correctionMessage: "Normally, the specification is a file named 'libraries.json' in the Dart SDK install location."

thisAccessInFieldInitializer:
  parameters:
    Name name: The name of the instance member that could not be used.
  problemMessage: "Can't access 'this' in a field initializer to read '#name'."
  script: |
    class Foo {
      int a = 2;
      int b = a + 42;
    }

thisOrSuperAccessInFieldInitializer:
  parameters:
    String string: The keyword (`this` or `super`) that could not be used.
  problemMessage: "Can't access '#string' in a field initializer."
  script: |
    class C {
      var x = this;
    }

thisAsIdentifier:
  parameters: none
  problemMessage: "Expected identifier, but got 'this'."
  script: |
    class C {}
    void foo() {
      C.this();
    }

# TODO(johnniwinther): Confusing message, it should probably mention that `super` is not available.
superAsIdentifier:
  parameters: none
  problemMessage: "Expected identifier, but got 'super'."
  script: |
    class C {}
    void foo() {
      C.super();
    }

invalidAugmentSuper:
  parameters: none
  problemMessage: "'augment super' is only allowed in member augmentations."

superAsExpression:
  parameters: none
  problemMessage: "Can't use 'super' as an expression."
  correctionMessage: "To delegate a constructor to a super constructor, put the super call as an initializer."
  script: |
    abstract class A {}

    class B extends A {
      B(): super()?.foo() {}
    }
  exampleAllowOtherCodes: true

switchExpressionNotAssignableCause:
  parameters: none
  problemMessage: "The switch expression is here."
  severity: CONTEXT

switchExpressionNotSubtype:
  parameters:
    Type caseExpressionType: The type of the case expression.
    Type scrutineeType: The type of the scrutinee.
  problemMessage: "Type '#caseExpressionType' of the case expression is not a subtype of type '#scrutineeType' of this switch expression."
  script:
    - |
      // @dart=2.19
      void f() {
        switch (42) {
          case "foo": break;
        }
      }

switchCaseFallThrough:
  parameters: none
  problemMessage: "Switch case may fall through to the next case."
  script: |
    // @dart=2.19
    method(e) {
      switch (e) {
        case 0: print(0);
        case 1: print(1);
      }
    }

fieldAlreadyInitializedAtDeclaration:
  parameters:
    Name fieldName: The name of the already-initialized field.
  problemMessage: "'#fieldName' is a final instance variable that was initialized at the declaration."
  script:
    - "class C { final int x = 2; C(): this.x = 3 {} }"

fieldAlreadyInitializedAtDeclarationCause:
  parameters:
    Name fieldName: The name of the already-initialized field.
  problemMessage: "'#fieldName' was initialized here."
  severity: CONTEXT

constructorInitializeSameInstanceVariableSeveralTimes:
  parameters:
    Name fieldName: The name of the already-initialized field.
  problemMessage: "'#fieldName' was already initialized by this constructor."
  script:
    - "class C { final int x; C(): this.x = 1, this.x = 2 {} }"
    - "class C { int x; C(): this.x = 1, this.x = 2 {} }"

typeVariableInStaticContext:
  parameters: none
  problemMessage: "Type variables can't be used in static members."
  declaration:
    - |
      class C<T> {
        static List<T> staticMethod() {}
      }
    - |
      class C<T> {
        static T staticMethod() {}
      }
    - |
      class C<T> {
        static staticMethod(List<T> argument) {}
      }
    - |
      class C<T> {
        static staticMethod(T argument) {}
      }
    - |
      class C<T> {
        static staticMethod() {
          List<T>? t = null;
          return t;
        }
      }
    - |
      class C<T> {
        static staticMethod() {
          T? t = null;
          return t;
        }
      }

typeVariableInConstantContext:
  parameters: none
  problemMessage: "Type variables can't be used as constants."
  declaration:
    - |
      class C<T> {
        instanceMethod() {
          return const <Object>[T];
        }
      }
    - |
      class C<T> {
        instanceMethod() {
          return const <T>[];
        }
      }
    - |
      class C<T> {
        instanceMethod() {
          return const <List<T>>[];
        }
      }

superclassHasNoMember:
  parameters:
    Name memberName: The name of the member that was sought.
  problemMessage: "Superclass has no member named '#memberName'."

superclassHasNoGetter:
  parameters:
    Name getterName: The name of the getter that was sought.
  problemMessage: "Superclass has no getter named '#getterName'."
  script: |
    class Super {}

    class Class extends Super {
      method() {
        super.missingSuperGetter;
      }
    }

superclassHasNoSetter:
  parameters:
    Name setterName: The name of the setter that was sought.
  problemMessage: "Superclass has no setter named '#setterName'."
  script: |
    class Super {}

    class Class extends Super {
      method() {
        super.missingSuperSetter = 42;
      }
    }

superclassHasNoMethod:
  parameters:
    Name name: The name of the method that was not found.
  problemMessage: "Superclass has no method named '#name'."
  script: |
    class Super {}

    class Class extends Super {
      method() {
        super.missingSuperMethod();
      }
    }

superclassHasNoConstructor:
  parameters:
    Name constructorName: The name of the constructor that was not found.
  problemMessage: "Superclass has no constructor named '#constructorName'."
  script:
    - |
      class Super {
        Super._();
      }

      class Sub extends Super {
        Sub() : super();
      }
    - |
      class Super {
        Super._();
      }

      class Sub extends Super {
        Sub.foo() : super.foo();
      }

superclassHasNoDefaultConstructor:
  parameters:
    Name className: The name of the class that in which a default constructor was sought.
  problemMessage: "The superclass, '#className', has no unnamed constructor that takes no arguments."
  script: |
    class Foo {
      Foo(int x);
    }
    class Bar extends Foo { }

constConstructorNonFinalField:
  parameters: none
  problemMessage: "Constructor is marked 'const' so all fields must be final."
  script: |
    class Foo {
      int i;
      const Foo(this.i);
    }

enumConstructorNonFinalField:
  parameters: none
  problemMessage: "Enum constructors are constant so all fields must be final."
  experiments: primary-constructors
  script:
    - |
      enum E(var int x) { a(0) }
    - |
      enum E() { a; int x = 0; }

constConstructorNonFinalFieldCause:
  parameters: none
  problemMessage: "Field isn't final, but constructor is 'const'."
  severity: CONTEXT

constConstructorLateFinalFieldError:
  parameters: none
  problemMessage: "Can't have a late final field in a class with a const constructor."
  script: |
    class Foo {
      late final int i = 42;
      const Foo();
    }

constConstructorLateFinalFieldCause:
  parameters: none
  problemMessage: "This constructor is const."
  severity: CONTEXT

constConstructorRedirectionToNonConst:
  parameters: none
  problemMessage: "A constant constructor can't call a non-constant constructor."
  script:
    - >-
      class A {
        const A.foo() : this.bar();
        A.bar() {}
      }

constConstructorWithNonConstSuper:
  parameters: none
  problemMessage: "A constant constructor can't call a non-constant super constructor."
  script:
    - >-
      class A {
        A.bar() {}
      }
      class B extends A {
        const B.foo() : super.bar();
      }

expressionNotMetadata:
  parameters: none
  problemMessage: "This can't be used as an annotation; an annotation should be a reference to a compile-time constant variable, or a call to a constant constructor."
  script: |
    @foo
    void foo() {}

cannotAssignToParenthesizedExpression:
  parameters: none
  problemMessage: "Can't assign to a parenthesized expression."
  script: |
    int i = 42;
    int test2() {
      return (i) ++ (i);
    }
  exampleAllowOtherCodes: true

notAnLvalue:
  parameters: none
  problemMessage: "Can't assign to this."
  script: |
    class Foo {
      void bar() {
        --toString();
      }
    }

cannotAssignToSuper:
  parameters: none
  problemMessage: "Can't assign to super."

cannotReadSdkSpecification:
  parameters:
    String details: Detailed error message.
  problemMessage: "Unable to read the 'libraries.json' specification file:\n  #details."

cantInferPackagesFromManyInputs:
  parameters: none
  problemMessage: "Can't infer a packages file when compiling multiple inputs."
  correctionMessage: "Try specifying the file explicitly with the --packages option."

cantInferPackagesFromPackageUri:
  parameters: none
  problemMessage: "Can't infer a packages file from an input 'package:*' URI."
  correctionMessage: "Try specifying the file explicitly with the --packages option."

packageNotFound:
  parameters:
    Name packageName: The name of the package that could not be resolved.
    Uri uri: The URI in which the resolution was attempted.
  problemMessage: "Couldn't resolve the package '#packageName' in '#uri'."
  script: |
    import 'package:foo/foo.dart';
  exampleAllowOtherCodes: true

invalidPackageUri:
  parameters:
    Uri uri: The invalid package URI.
    String details: Detailed error message.
  problemMessage: "Invalid package URI '#uri':\n  #details."
  script: |
    import 'package:foo';
  exampleAllowOtherCodes: true

couldNotParseUri:
  parameters:
    String uri: The URI that could not be parsed.
    String details: Detailed error message.
  problemMessage: "Couldn't parse URI '#uri':\n  #details."
  script: |
    import ' dart:async';
  exampleAllowOtherCodes: true

expectedUri:
  parameters: none
  problemMessage: "Expected a URI."
  script: |
    import ' dart:async';
  exampleAllowOtherCodes: true

interpolationInUri:
  pseudoSharedCode: INVALID_LITERAL_IN_CONFIGURATION
  parameters: none
  problemMessage: "Can't use string interpolation in a URI."
  script: |
    import 'package:/foo/$bar.dart';
  exampleAllowOtherCodes: true

integerLiteralIsOutOfRange:
  parameters:
    String literal: The integer literal.
  problemMessage: "The integer literal #literal can't be represented in 64 bits."
  correctionMessage: "Try using the BigInt class if you need an integer larger than 9,223,372,036,854,775,807 or less than -9,223,372,036,854,775,808."
  script: |
    void foo() {
      int i = 9223372036854775808;
    }

argumentTypeNotAssignable:
  parameters:
    Type actualType: The type that could not be assigned.
    Type expectedType: The type that was required.
  problemMessage: "The argument type '#actualType' can't be assigned to the parameter type '#expectedType'."
  script: |
    method(int i) {}
    main() {
      method(1.5);
    }

invalidAssignmentError:
  parameters:
    Type actualType: The type that could not be assigned.
    Type expectedType: The type that was required.
  problemMessage: "A value of type '#actualType' can't be assigned to a variable of type '#expectedType'."
  script: |
    main() {
      int i;
      i = 1.5;
    }

patchClassTypeParametersMismatch:
  parameters: none
  problemMessage: "A patch class must have the same number of type variables as its origin class."

patchClassOrigin:
  parameters: none
  problemMessage: "This is the origin class."
  severity: CONTEXT

patchExtensionTypeParametersMismatch:
  parameters: none
  problemMessage: "A patch extension must have the same number of type variables as its origin extension."

patchExtensionOrigin:
  parameters: none
  problemMessage: "This is the origin extension."
  severity: CONTEXT

patchDeclarationOrigin:
  parameters: none
  problemMessage: "This is the origin declaration."
  severity: CONTEXT

patchInjectionFailed:
  parameters:
    Name name: The public name that couldn't be injected.
    Uri uri: The URI that the public name couldn't be injected into.
  problemMessage: "Can't inject public '#name' into '#uri'."
  correctionMessage: "Make '#name' private, or make sure injected library has \"dart\" scheme and is private (e.g. \"dart:_internal\")."

invalidCastFunctionExpr:
  parameters:
    Type actualType: The invalid type.
    Type expectedType: The type that was expected.
  problemMessage: "The function expression type '#actualType' isn't of expected type '#expectedType'."
  correctionMessage: "Change the type of the function expression or the context in which it is used."

invalidCastLiteralList:
  parameters:
    Type actualType: The invalid type.
    Type expectedType: The type that was expected.
  problemMessage: "The list literal type '#actualType' isn't of expected type '#expectedType'."
  correctionMessage: "Change the type of the list literal or the context in which it is used."

invalidCastLiteralMap:
  parameters:
    Type actualType: The invalid type.
    Type expectedType: The type that was expected.
  problemMessage: "The map literal type '#actualType' isn't of expected type '#expectedType'."
  correctionMessage: "Change the type of the map literal or the context in which it is used."

invalidCastLiteralSet:
  parameters:
    Type actualType: The invalid type.
    Type expectedType: The type that was expected.
  problemMessage: "The set literal type '#actualType' isn't of expected type '#expectedType'."
  correctionMessage: "Change the type of the set literal or the context in which it is used."

invalidCastLocalFunction:
  parameters:
    Type actualType: The invalid type.
    Type expectedType: The type that was expected.
  problemMessage: "The local function has type '#actualType' that isn't of expected type '#expectedType'."
  correctionMessage: "Change the type of the function or the context in which it is used."

invalidCastNewExpr:
  parameters:
    Type actualType: The invalid type.
    Type expectedType: The type that was expected.
  problemMessage: "The constructor returns type '#actualType' that isn't of expected type '#expectedType'."
  correctionMessage: "Change the type of the object being constructed or the context in which it is used."

invalidCastStaticMethod:
  parameters:
    Type actualType: The invalid type.
    Type expectedType: The type that was expected.
  problemMessage: "The static method has type '#actualType' that isn't of expected type '#expectedType'."
  correctionMessage: "Change the type of the method or the context in which it is used."

invalidCastTopLevelFunction:
  parameters:
    Type actualType: The invalid type.
    Type expectedType: The type that was expected.
  problemMessage: "The top level function has type '#actualType' that isn't of expected type '#expectedType'."
  correctionMessage: "Change the type of the function or the context in which it is used."

invalidUseOfNullAwareAccess:
  parameters: none
  problemMessage: "Cannot use '?.' here."
  correctionMessage: "Try using '.'."
  script: |
    class Super {
      Super.named();
    }

    class Class extends Super {
      Class() : super?.named();
    }
  exampleAllowOtherCodes: true

undefinedGetter:
  parameters:
    Name name: The name of the undefined getter.
    Type type: The type in which the getter is undefined.
  problemMessage: "The getter '#name' isn't defined for the type '#type'."
  correctionMessage: "Try correcting the name to the name of an existing getter, or defining a getter or field named '#name'."
  script: |
    class C {}
    test(C c) {
      print(c.foo);
    }

undefinedSetter:
  parameters:
    Name name: The name of the undefined setter.
    Type type: The type in which the setter is undefined.
  problemMessage: "The setter '#name' isn't defined for the type '#type'."
  correctionMessage: "Try correcting the name to the name of an existing setter, or defining a setter or field named '#name'."
  script: |
    class C {}
    test(C c) {
      c.foo = 0;
    }

undefinedMethod:
  parameters:
    Name name: The name of the undefined method.
    Type type: The type in which the method is undefined.
  problemMessage: "The method '#name' isn't defined for the type '#type'."
  correctionMessage: "Try correcting the name to the name of an existing method, or defining a method named '#name'."
  script: |
    class C {}
    test(C c) {
      c.foo();
    }

undefinedOperator:
  parameters:
    Name name: The name of the undefined operator.
    Type type: The type in which the operator is undefined.
  problemMessage: "The operator '#name' isn't defined for the type '#type'."
  correctionMessage: "Try correcting the operator to an existing operator, or defining a '#name' operator."
  script: |
    class C {}
    test(C c) {
      c + 0;
    }

ambiguousExtensionMethod:
  parameters:
    Name name: The name of the ambiguous extension method.
    Type type: The type for which the extension method is ambiguous.
  problemMessage: "The method '#name' is defined in multiple extensions for '#type' and neither is more specific."
  correctionMessage: "Try using an explicit extension application of the wanted extension or hiding unwanted extensions from scope."
  script: |
    class C {}
    extension A on C { method() {} }
    extension B on C { method() {} }
    main() {
      C c = new C();
      c.method();
    }

ambiguousExtensionProperty:
  parameters:
    Name name: The name of the ambiguous extension property.
    Type type: The type for which the extension property is ambiguous.
  problemMessage: "The property '#name' is defined in multiple extensions for '#type' and neither is more specific."
  correctionMessage: "Try using an explicit extension application of the wanted extension or hiding unwanted extensions from scope."
  script: |
    class C {}
    extension A on C { get property => null; }
    extension B on C { set property(_) {} }
    main() {
      C c = new C();
      c.property;
    }

ambiguousExtensionOperator:
  parameters:
    Name name: The name of the ambiguous extension operator.
    Type type: The type for which the extension operator is ambiguous.
  problemMessage: "The operator '#name' is defined in multiple extensions for '#type' and neither is more specific."
  correctionMessage: "Try using an explicit extension application of the wanted extension or hiding unwanted extensions from scope."
  script: |
    class C {}
    extension A on C { operator +(int i) {} }
    extension B on C { operator +(int i) {}  }
    main() {
      C c = new C();
      c + 0;
    }

ambiguousExtensionCause:
  parameters: none
  problemMessage: "This is one of the extension members."
  severity: CONTEXT

sourceOutlineSummary:
  parameters:
    int count: The number of compilation units for which outlines were built.
    int bytes: The number of bytes in the compilation units for which outlines were built.
    num timeMs: The time it took to build outlines for the compilation units, in ms.
    num rateBytesPerMs: The outline building speed, in bytes/ms.
    num averageTimeMs: The average time it took to build outlines for each compilation unit, in ms.
  problemMessage: |
    Built outlines for #count compilation units (#bytes bytes) in #timeMs%.3ms, that is,
    #rateBytesPerMs%12.3 bytes/ms, and
    #averageTimeMs%12.3 ms/compilation unit.

sourceBodySummary:
  parameters:
    int count: The number of compilation units for which bodies were built.
    int bytes: The number of bytes in the compilation units for which bodies were built.
    num timeMs: The time it took to build bodies for the compilation units, in ms.
    num rateBytesPerMs: The body building speed, in bytes/ms.
    num averageTimeMs: The average time it took to build bodies for each compilation unit, in ms.
  problemMessage: |
    Built bodies for #count compilation units (#bytes bytes) in #timeMs%.3ms, that is,
    #rateBytesPerMs%12.3 bytes/ms, and
    #averageTimeMs%12.3 ms/compilation unit.

dillOutlineSummary:
  parameters:
    int count: The number of libraries that were indexed.
    int bytes: The number of bytes in the libraries that were indexed.
    num timeMs: The time it took to index the libraries, in ms.
    num rateBytesPerMs: The indexing speed, in bytes/ms.
    num averageTimeMs: The average time it took to index each library, in ms.
  problemMessage: |
    Indexed #count libraries (#bytes bytes) in #timeMs%.3ms, that is,
    #rateBytesPerMs%12.3 bytes/ms, and
    #averageTimeMs%12.3 ms/libraries.

cantInferTypesDueToNoCombinedSignature:
  parameters:
    Name name: The name of the element for which types can't be inferred.
  problemMessage: "Can't infer types for '#name' as the overridden members don't have a combined signature."
  correctionMessage: "Try adding explicit types."
  script: |
    class A {
      void method(int a, String b) {}
    }
    class B {
      void method(String a, int b) {}
    }
    class C implements A, B {
      void method(a, b) {}
    }

cantInferTypeDueToNoCombinedSignature:
  parameters:
    Name name: The name of the element for which a type can't be inferred.
  problemMessage: "Can't infer a type for '#name' as the overridden members don't have a combined signature."
  correctionMessage: "Try adding an explicit type."
  script: |
    class A {
      void method(int a) {}
    }
    class B {
      void method(String a) {}
    }
    class C implements A, B {
      void method(a) {}
    }

cantInferReturnTypeDueToNoCombinedSignature:
  parameters:
    Name name: The name of the element for which a return type can't be inferred.
  problemMessage: "Can't infer a return type for '#name' as the overridden members don't have a combined signature."
  correctionMessage: "Try adding an explicit type."
  script: |
    abstract class A {
      int get getter;
    }
    abstract class B {
      String get getter;
    }
    abstract class C implements A, B {
      get getter;
    }

cantInferTypeDueToCircularity:
  parameters:
    String name: The name of the element for which a type can't be inferred.
  problemMessage: "Can't infer the type of '#name': circularity found during type inference."
  correctionMessage: "Specify the type explicitly."
  script: |
    enum CyclicReference {
      e1(e2),
      e2(e1);

      final CyclicReference other;
      const CyclicReference(this.other);
    }
  exampleAllowOtherCodes: true

ambiguousSupertypes:
  parameters:
    Name name: The name of the element with ambiguous supertypes.
    Type type1: The first supertype.
    Type type2: The second supertype.
  problemMessage: "'#name' can't implement both '#type1' and '#type2'"
  script: |
    class A<T> {}
    mixin class B<T> implements A<T> {}
    class C<T> implements A<T> {}
    class D implements B<String>, C<int> {}

mixinInferenceNoMatchingClass:
  parameters:
    Name mixinName: The name of the mixin for which type parameters couldn't be inferred.
    Name baseTypeName: The name of the base type that doesn't implement the mixin's supertype constraint.
    Type supertypeConstraint: The supertype constraint that is not implemented.
  problemMessage: "Type parameters couldn't be inferred for the mixin '#mixinName' because '#baseTypeName' does not implement the mixin's supertype constraint '#supertypeConstraint'."
  script: |
    abstract class A<T> {}
    mixin M<T> on A<T> {}
    class C extends Object with M {}
  exampleAllowOtherCodes: true

implicitCallOfNonMethod:
  parameters:
    Type type: The type which cannot be invoked.
  problemMessage: "Cannot invoke an instance of '#type' because it declares 'call' to be something other than a method."
  correctionMessage: "Try changing 'call' to a method or explicitly invoke 'call'."
  script: |
    class Class { void Function() get call => () {}; }
    method(Class c) => c();

implicitSuperCallOfNonMethod:
  parameters: none
  problemMessage: "Cannot invoke `super` because it declares 'call' to be something other than a method."
  correctionMessage: "Try changing 'call' to a method or explicitly invoke 'call'."
  script: |
    class Super { void Function() get call => () {}; }
    class Class extends Super { void method() => super(); }

expectedOneExpression:
  parameters: none
  problemMessage: "Expected one expression, but found additional input."

forInLoopNotAssignable:
  parameters: none
  problemMessage: "Can't assign to this, so it can't be used in a for-in loop."
  statement: "for (1 in []) {}"
  exampleAllowOtherCodes: true

forInLoopExactlyOneVariable:
  parameters: none
  problemMessage: "A for-in loop can't have more than one loop variable."
  statement: "for (var x, y in []) {}"
  exampleAllowOtherCodes: true

forInLoopWithConstVariable:
  parameters: none
  problemMessage: "A for-in loop-variable can't be 'const'."
  correctionMessage: "Try removing the 'const' modifier."
  script: |
    void foo() {
      for(const i in [42]) {}
    }

forInLoopElementTypeNotAssignable:
  parameters:
    Type actualType: The type that could not be assigned.
    Type expectedType: The type that was required.
  problemMessage: "A value of type '#actualType' can't be assigned to a variable of type '#expectedType'."
  correctionMessage: "Try changing the type of the variable."
  script: |
    method() {
      List<String> list = [];
      for (int i in list) {}
    }

forInLoopTypeNotIterable:
  parameters:
    Type actualType: The type that could not be assigned.
    Type expectedType: The type that was required.
  problemMessage: "The type '#actualType' used in the 'for' loop must implement '#expectedType'."
  script: |
    method() {
      String list = '';
      for (int i in list) {}
    }

initializingFormalTypeMismatch:
  parameters:
    Name parameterName: The name of the parameter with a type mismatch.
    Type parameterType: The type of the parameter.
    Type fieldType: The type of the field.
  problemMessage: "The type of parameter '#parameterName', '#parameterType' is not a subtype of the corresponding field's type, '#fieldType'."
  correctionMessage: "Try changing the type of parameter '#parameterName' to a subtype of '#fieldType'."
  script: |
    class C {
      int x;
      C(num this.x);
    }

initializingFormalTypeMismatchField:
  parameters: none
  problemMessage: "The field that corresponds to the parameter."
  severity: CONTEXT

initializeFromDillNotSelfContained:
  parameters:
    String previousCompilationUri: The URI of the previous compilation.
    Uri gzFileUri: The URI of the gzipped data.
  problemMessage: |
    Tried to initialize from a previous compilation (#previousCompilationUri), but the file was not self-contained. This might be a bug.

    The Dart team would greatly appreciate it if you would take a moment to report this problem at http://dartbug.com/new.
    If you are comfortable with it, it would improve the chances of fixing any bug if you included the file #gzFileUri in your error report, but be aware that this file includes your source code.
    Either way, you should probably delete the file so it doesn't use unnecessary disk space.

  severity: WARNING
  external: test/incremental_load_from_invalid_dill_test.dart

initializeFromDillNotSelfContainedNoDump:
  parameters:
    String previousCompilationUri: The URI of the previous compilation.
  problemMessage: |
    Tried to initialize from a previous compilation (#previousCompilationUri), but the file was not self-contained. This might be a bug.

    The Dart team would greatly appreciate it if you would take a moment to report this problem at http://dartbug.com/new.

  severity: WARNING
  external: test/incremental_load_from_invalid_dill_test.dart

initializeFromDillUnknownProblem:
  parameters:
    String previousCompilationUri: The URI of the previous compilation.
    String exception: The exception string.
    String stackTrace: The exception stack trace.
    Uri gzFileUri: The URI of the gzipped data.
  problemMessage: |
    Tried to initialize from a previous compilation (#previousCompilationUri), but couldn't.
    Error message was '#exception'.
    Stacktrace included '#stackTrace'.
    This might be a bug.

    The Dart team would greatly appreciate it if you would take a moment to report this problem at http://dartbug.com/new.
    If you are comfortable with it, it would improve the chances of fixing any bug if you included the file #gzFileUri in your error report, but be aware that this file includes your source code.
    Either way, you should probably delete the file so it doesn't use unnecessary disk space.

  severity: WARNING
  external: test/incremental_load_from_invalid_dill_test.dart

initializeFromDillUnknownProblemNoDump:
  parameters:
    String previousCompilationUri: The URI of the previous compilation.
    String exception: The exception string.
    String stackTrace: The exception stack trace.
  problemMessage: |
    Tried to initialize from a previous compilation (#previousCompilationUri), but couldn't.
    Error message was '#exception'.
    Stacktrace included '#stackTrace'.
    This might be a bug.

    The Dart team would greatly appreciate it if you would take a moment to report this problem at http://dartbug.com/new.

  severity: WARNING
  external: test/incremental_load_from_invalid_dill_test.dart

webLiteralCannotBeRepresentedExactly:
  parameters:
    String integerLiteral: The integer literal that can't be represented exactly in JavaScript.
    String nearestJsValue: The nearest value that can be represented exactly.
  problemMessage: "The integer literal #integerLiteral can't be represented exactly in JavaScript."
  correctionMessage: "Try changing the literal to something that can be represented in JavaScript. In JavaScript #nearestJsValue is the nearest value that can be represented exactly."

boundIssueViaRawTypeWithNonSimpleBounds:
  parameters:
    Name typeName: The name of the generic type that can't be used without type arguments in a type variable bound.
  problemMessage: "Generic type '#typeName' can't be used without type arguments in a type variable bound."
  correctionMessage: "Try providing type arguments to '#typeName' here."
  script: |
    class Hest<X extends Hest<X>> {}
    class Fisk<Y extends Hest> {}

nonSimpleBoundViaVariable:
  parameters:
    Name typeName: The name of the referenced type.
  problemMessage: "Bound of this variable references variable '#typeName' from the same declaration."
  severity: CONTEXT

boundIssueViaLoopNonSimplicity:
  parameters:
    Name typeName: The name of the generic type that can't be used without type arguments in the bounds of its own type variables.
  problemMessage: "Generic type '#typeName' can't be used without type arguments in the bounds of its own type variables."
  correctionMessage: "Try providing type arguments to '#typeName' here."
  script: |
    class Hest<X extends Hest> {}

boundIssueViaCycleNonSimplicity:
  parameters:
    Name typeName: The name of the generic type that can't be used without type arguments in the bounds of its own type variables.
    Name firstTypeInCycle: The first type in the cycle.
  problemMessage: "Generic type '#typeName' can't be used without type arguments in the bounds of its own type variables. It is referenced indirectly through '#firstTypeInCycle'."
  correctionMessage: "Try providing type arguments to '#firstTypeInCycle' here or to some other raw types in the bounds along the reference chain."
  script: |
    class Hest<X extends Fisk> {}
    class Fisk<Y extends Hest> {}

nonSimpleBoundViaReference:
  parameters:
    Name typeName: The referenced type.
  problemMessage: "Bound of this variable references raw type '#typeName'."
  severity: CONTEXT

cycleInTypeParameters:
  parameters:
    Name typeName: The name of the type that is a bound of itself.
    String cycle: The non-trivial dependency cycle.
  problemMessage: "Type '#typeName' is a bound of itself via '#cycle'."
  correctionMessage: "Try breaking the cycle by removing at least one of the 'extends' clauses in the cycle."
  script:
    - "foo<A extends B, B extends A>() {}"

directCycleInTypeParameters:
  parameters:
    Name typeName: The name of the type that can't use itself as a bound.
  problemMessage: "Type '#typeName' can't use itself as a bound."
  correctionMessage: "Try breaking the cycle by removing at least one of the 'extends' clauses in the cycle."
  script:
    - "foo<A extends A>() {}"

cantUsePrefixAsExpression:
  parameters: none
  problemMessage: "A prefix can't be used as an expression."
  script: |
    import "dart:core" as prefix;

    main() {
      for (prefix in []) {}
    }

cantUsePrefixWithNullAware:
  parameters: none
  problemMessage: "A prefix can't be used with null-aware operators."
  correctionMessage: "Try replacing '?.' with '.'"
  script: |
    import "dart:core" as prefix;

    main() {
      prefix?.Object;
    }

cantUseControlFlowOrSpreadAsConstant:
  parameters:
    Token token: The token that can't be used in constant expressions.
  problemMessage: "'#token' is not supported in constant expressions."
  script: |
    test() {
      const List<int> list1 = const [for (var i = 1; i < 4; i++) i];
    }
  exampleAllowOtherCodes: true

cantUseDeferredPrefixAsConstant:
  parameters:
    Token token: The token that can't be used in a constant expression.
  problemMessage: >
    '#token' can't be used in a constant expression because it's marked as
    'deferred' which means it isn't available until loaded.
  correctionMessage: >
    Try moving the constant from the deferred library, or removing 'deferred'
    from the import.
  script: |
    import "dart:convert" deferred as prefix;

    main() {
      const prefix.JsonCodec();
    }

cyclicRedirectingFactoryConstructors:
  parameters:
    Name factoryName: The name of the factory with a cyclic definition.
  problemMessage: "Cyclic definition of factory '#factoryName'."
  script: |
    class Foo {
      factory Foo.foo() = Foo.bar;
      factory Foo.bar() = Foo.foo;
    }
    main() { var foo = new Foo.foo(); }
  exampleAllowMultipleReports: true

genericFunctionTypeInBound:
  parameters: none
  problemMessage: "Type variables can't have generic function types in their bounds."
  script: |
    // @dart=2.13
    class Hest<X extends Y Function<Y>(Y)> {}

voidExpression:
  parameters: none
  problemMessage: "This expression has type 'void' and can't be used."
  statement: |
    {
      void x;
      int y = x;
    }

returnFromVoidFunction:
  parameters: none
  problemMessage: "Can't return a value from a void function."
  declaration: "void foo() { return 1; }"

returnWithoutExpressionSync:
  parameters: none
  problemMessage: "A value must be explicitly returned from a non-void function."
  script: |
    import "dart:async";
    FutureOr<Object?> foo() { return; }

returnWithoutExpressionAsync:
  parameters: none
  problemMessage: "A value must be explicitly returned from a non-void async function."
  declaration: "Future<int> foo() async { return; }"

invalidReturn:
  parameters:
    Type actualType: The type that could not be assigned.
    Type expectedType: The type that was required.
  problemMessage: "A value of type '#actualType' can't be returned from a function with return type '#expectedType'."
  declaration: "int foo() { return true; }"

invalidReturnAsync:
  parameters:
    Type actualType: The type that could not be assigned.
    Type expectedType: The type that was required.
  problemMessage: "A value of type '#actualType' can't be returned from an async function with return type '#expectedType'."
  declaration: "Future<int> foo() async { return true; }"

implicitReturnNull:
  parameters:
    Type returnType: The return type that doesn't allow null.
  problemMessage: "A non-null value must be returned since the return type '#returnType' doesn't allow null."
  script: |
    String method() {}

rethrowNotCatch:
  parameters: none
  problemMessage: "'rethrow' can only be used in catch clauses."
  script: |
    void foo() {
      try {
        rethrow;
      } catch (e) {}
    }

invokeNonFunction:
  parameters:
    Name name: The name that can't be invoked.
  problemMessage: "'#name' isn't a function or method and can't be invoked."
  script: |
    abstract class Foo {
      int get f;
    }
    method(Foo foo) => foo.f();

constInstanceField:
  parameters: none
  problemMessage: "Only static fields can be declared as const."
  correctionMessage: "Try using 'final' instead of 'const', or adding the keyword 'static'."
  script:
    - "class C { const field = 0; }"

defaultValueInRedirectingFactoryConstructor:
  parameters:
    Name redirectionTarget: The redirection target whose default values would be used instead.
  problemMessage: "Can't have a default value here because any default values of '#redirectionTarget' would be used instead."
  correctionMessage: "Try removing the default value."
  script:
    - >-
      class A {
        factory A.f({int x = 42}) = A.g;
        A.g({int x = 40}) {}
      }

untranslatableUri:
  parameters:
    Uri uri: The URI that was not found.
  problemMessage: "Not found: '#uri'"
  exampleAllowOtherCodes: true # PackageNotFound will precede this message.
  script: |
    import "package:expect/non_existing_file";

unavailableDartLibrary:
  parameters:
    Uri uri: The URI of the library that is not available.
  problemMessage: "Dart library '#uri' is not available on this platform."
  script: |
    import "dart:non_existing_library";

unsupportedPlatformDartLibraryImport:
  parameters:
    Uri uri: The URI of the library that is unsupported.
  problemMessage: |
    Using stub implementations for APIs in platform-specific Dart library
    '#uri', which will throw 'UnsupportedError' if invoked.
  severity: WARNING
  external: test/unsupported_platform_dart_library_import_test.dart

importChainContext:
  parameters:
    Uri uri: The URI of the unavailable library.
    String importChain: The chain of imports that lead to the unavailable library.
    String verboseImportChain: The verbose chain of imports for some of these imports.
  problemMessage: |
    The unavailable library '#uri' is imported through these packages:

    #importChain
    Detailed import paths for (some of) the these imports:

    #verboseImportChain
  severity: CONTEXT

importChainContextSimple:
  parameters:
    Uri uri: The URi of the unavailable library.
    String importChain: The chain of imports that lead to the unavailable library.
  problemMessage: |
    The unavailable library '#uri' is imported through these paths:

    #importChain
  severity: CONTEXT

cantReadFile:
  parameters:
    Uri uri: The URI of the attempted read.
    String details: Details of the error.
  problemMessage: "Error when reading '#uri': #details"
  external: test/packages_format_error_test.dart
  script: |
    import "non_existing_file.dart";

exceptionReadingFile:
  parameters:
    Uri uri: The URI of the attempted read.
    String exception: The exception that occurred.
  problemMessage: "Exception when reading '#uri': #exception"

packagesFileFormat:
  parameters:
    String details: Details of the error.
  problemMessage: "Problem in packages configuration file: #details"
  external: test/packages_format_error_test.dart

incompatibleRedirecteeFunctionType:
  parameters:
    Type redirecteeType: The type of the constructor being redirected to.
    Type expectedType: The expected type.
  problemMessage: "The constructor function type '#redirecteeType' isn't a subtype of '#expectedType'."
  script:
    - >-
      class A {
        factory A() = B;
      }
      class B {
        B();
      }
    - >-
      class A {
        factory A.one(int x) = A.zero;
        A.zero() {}
      }
    - >-
      class A {
        factory A.i(int x) = A.s;
        A.s(String x) { }
      }
    - >-
      class A {
        factory A.f({int? x}) = A.g;
        A.g({int? y}) { }
      }
    - >-
      class A {
        factory A.f(int x) = A.g;
        A.g(int x, int y) {}
      }

redirectingFactoryIncompatibleTypeArgument:
  parameters:
    Type typeArgumentType: The type argument type.
    Type expectedType: The type that was expected.
  problemMessage: "The type '#typeArgumentType' doesn't extend '#expectedType'."
  correctionMessage: "Try using a different type as argument."
  script:
    - >-
      class A<T extends int> {
         factory A() = B<T, int>;
      }
      class B<T extends int, S extends String> implements A<T> {}

syntheticToken:
  parameters: none
  problemMessage: "This couldn't be parsed."

incorrectTypeArgument:
  parameters:
    Type typeArgument: The type argument.
    Type typeParameterBound: The bound of the corresponding type parameter.
    Name typeParameterName: The name of the type parameter.
    Name enclosingName: The name of the enclosing element.
  problemMessage: "Type argument '#typeArgument' doesn't conform to the bound '#typeParameterBound' of the type variable '#typeParameterName' on '#enclosingName'."
  correctionMessage: "Try changing type arguments so that they conform to the bounds."
  script: |
    class C<T extends num> {}
    main() { new C<String>(); }

incorrectTypeArgumentQualified:
  parameters:
    Type typeArgument: The type argument.
    Type typeParameterBound: The bound of the corresponding type parameter.
    Name typeParameterName: The name of the type parameter.
    Type receiverType: The type of the receiver.
    Name targetName: The name of the invoked method.
  problemMessage: "Type argument '#typeArgument' doesn't conform to the bound '#typeParameterBound' of the type variable '#typeParameterName' on '#receiverType.#targetName'."
  correctionMessage: "Try changing type arguments so that they conform to the bounds."
  script: |
    class C<T> { foo<U extends num>() {} }
    main() { new C<String>().foo<String>(); }

incorrectTypeArgumentInferred:
  parameters:
    Type typeArgument: The type argument.
    Type typeParameterBound: The bound of the corresponding type parameter.
    Name typeParameterName: The name of the type parameter.
    Name enclosingName: The name of the enclosing element.
  problemMessage: "Inferred type argument '#typeArgument' doesn't conform to the bound '#typeParameterBound' of the type variable '#typeParameterName' on '#enclosingName'."
  correctionMessage: "Try specifying type arguments explicitly so that they conform to the bounds."
  script: |
    foo<T extends List<S>, S extends num>(T t) {}
    main() { foo(<String>[""]); }

incorrectTypeArgumentQualifiedInferred:
  parameters:
    Type typeArgument: The type argument.
    Type typeParameterBound: The bound of the corresponding type parameter.
    Name typeParameterName: The name of the type parameter.
    Type receiverType: The type of the receiver.
    Name targetName: The name of the invoked method.
  problemMessage: "Inferred type argument '#typeArgument' doesn't conform to the bound '#typeParameterBound' of the type variable '#typeParameterName' on '#receiverType.#targetName'."
  correctionMessage: "Try specifying type arguments explicitly so that they conform to the bounds."
  script: |
    class A { foo<T extends List<S>, S extends num>(T t) {} }
    main() { new A().foo(<String>[""]); }

incorrectTypeArgumentInstantiation:
  parameters:
    Type typeArgument: The type argument.
    Type typeParameterBound: The bound of the corresponding type parameter.
    Name typeParameterName: The name of the type parameter.
    Type receiverType: The type of the receiver.
  problemMessage: "Type argument '#typeArgument' doesn't conform to the bound '#typeParameterBound' of the type variable '#typeParameterName' on '#receiverType'."
  correctionMessage: "Try changing type arguments so that they conform to the bounds."
  script: |
    X bounded<X extends num>(X x) => x;
    main() {
      bounded<String>;
    }

incorrectTypeArgumentInstantiationInferred:
  parameters:
    Type typeArgument: The type argument.
    Type typeParameterBound: The bound of the corresponding type parameter.
    Name typeParameterName: The name of the type parameter.
    Type receiverType: The type of the receiver.
  problemMessage: "Inferred type argument '#typeArgument' doesn't conform to the bound '#typeParameterBound' of the type variable '#typeParameterName' on '#receiverType'."
  correctionMessage: "Try specifying type arguments explicitly so that they conform to the bounds."
  script: |
    X bounded<X extends List<Y>, Y extends num>(X x) => x;
    main() {
      List<String> Function(List<String>) c = bounded;
    }

incorrectTypeArgumentVariable:
  parameters: none
  problemMessage: "This is the type variable whose bound isn't conformed to."
  severity: CONTEXT

superBoundedHint:
  parameters:
    Type attemptedType: The type that the user appears to be attempting to make super-bounded.
    Type invertedType: The inverted type, which does not satisfy its bounds.
  problemMessage: "If you want '#attemptedType' to be a super-bounded type, note that the inverted type '#invertedType' must then satisfy its bounds, which it does not."
  severity: CONTEXT

mixinApplicationIncompatibleSupertype:
  parameters:
    Type supertype: The mixin application supertype.
    Type requiredInterfaceType: The type that the supertype is required to implement.
    Type mixedInType: The mixed in type that can't be used.
  problemMessage: "'#supertype' doesn't implement '#requiredInterfaceType' so it can't be used with '#mixedInType'."
  script: |-
    class I {}
    mixin M on I {}
    class C = Object with M;

genericFunctionTypeUsedAsActualTypeArgument:
  parameters: none
  problemMessage: "A generic function type can't be used as a type argument."
  correctionMessage: "Try using a non-generic function type."
  script:
    - |
      // @dart=2.13
      typedef F = Class<T> Function<T>(T);
      class Class<T> {}
      main() {
        Class<F> class1;
      }
    - |
      // @dart=2.13
      typedef F = Class<T> Function<T>(T);
      class Class<T> {}
      main() {
        Class<F>();
      }

genericFunctionTypeInferredAsActualTypeArgument:
  parameters:
    Type type: The generic function type that was inferred.
  problemMessage: "Generic function type '#type' inferred as a type argument."
  correctionMessage: "Try providing a non-generic function type explicitly."
  script: |
    // @dart=2.13
    foo<X>(X x) => null;
    bar<Y>(Y y) => null;
    main() { foo(bar); }

genericFunctionTypeAsTypeArgumentThroughTypedef:
  parameters:
    Type genericFunctionType: The generic function type that was used as a type argument.
    Type aliasType: The type alias.
  problemMessage: "Generic function type '#genericFunctionType' used as a type argument through typedef '#aliasType'."
  correctionMessage: "Try providing a non-generic function type explicitly."
  script:
    main.dart: |
      // @dart=2.12
      import 'lib.dart';
      test(T3 t3a) {}
    lib.dart: |
      typedef T3 = List<void Function<T>(T)>;

# These two message templates are used for constructing supplemental text
# about the origins of raw interface types in error messages containing types.
typeOrigin:
  parameters:
    Name name: The name whose origin is being explained.
    Uri uri: The URI of the name's origin.
  problemMessage: "'#name' is from '#uri'."
  external: test/type_labeler_test.dart

typeOriginWithFileUri:
  parameters:
    Name name: The name whose origin is being explained.
    Uri importUri: The import URI of the name's origin.
    Uri fileUri: The file URI of the name's origin.
  problemMessage: "'#name' is from '#importUri' ('#fileUri')."
  external: test/type_labeler_test.dart

objectExtends:
  parameters: none
  problemMessage: "The class 'Object' can't have a superclass."
  external: test/object_supertype_test.dart

objectImplements:
  parameters: none
  problemMessage: "The class 'Object' can't implement anything."
  external: test/object_supertype_test.dart

objectMixesIn:
  parameters: none
  problemMessage: "The class 'Object' can't use mixins."
  external: test/object_supertype_test.dart

instanceAndSynthesizedStaticConflict:
  parameters:
    Name name: The name of the conflicting synthesized static member.
  problemMessage: "This instance member conflicts with the synthesized static member called '#name'."
  script: |
    enum E {
      e1, e2;

      void set values(List<E> val) {}
    }

ffiAbiSpecificIntegerInvalid:
  # Used by dart:ffi
  parameters: none
  problemMessage: "Classes extending 'AbiSpecificInteger' must have exactly one const constructor, no other members, and no type arguments."
  external: test/ffi_test.dart

ffiAbiSpecificIntegerMappingInvalid:
  # Used by dart:ffi
  parameters: none
  problemMessage: "Classes extending 'AbiSpecificInteger' must have exactly one 'AbiSpecificIntegerMapping' annotation specifying the mapping from ABI to a NativeType integer with a fixed size."
  external: test/ffi_test.dart

ffiAddressPosition:
  # Used by dart:ffi
  parameters: none
  problemMessage: "The '.address' expression can only be used as argument to a leaf native external call."
  external: test/ffi_test.dart

ffiAddressReceiver:
  # Used by dart:ffi
  parameters: none
  problemMessage: "The receiver of '.address' must be a concrete 'TypedData', a concrete 'TypedData' '[]', an 'Array', an 'Array' '[]', a Struct field, or a Union field."
  correctionMessage: "Change the receiver of '.address' to one of the allowed kinds."
  external: test/ffi_test.dart

ffiCreateOfStructOrUnion:
  # Used by dart:ffi
  parameters: none
  problemMessage: "Subclasses of 'Struct' and 'Union' are backed by native memory, and can't be instantiated by a generative constructor. Try allocating it via allocation, or load from a 'Pointer'."
  external: test/ffi_test.dart

ffiTypeMismatch:
  # Used by dart:ffi
  parameters:
    Type actualType: The erroneous type.
    Type expectedType: The expected type.
    Type nativeType: The corresponding native type.
  problemMessage: "Expected type '#actualType' to be '#expectedType', which is the Dart type corresponding to '#nativeType'."
  external: test/ffi_test.dart

ffiEmptyStruct:
  # Used by dart:ffi
  parameters:
    String superclass: The superclass name.
    Name name: The name of the problematic struct.
  problemMessage: "#superclass '#name' is empty. Empty structs and unions are undefined behavior."
  external: test/ffi_test.dart

ffiTypeInvalid:
  # Used by dart:ffi
  parameters:
    Type type: The invalid type.
  problemMessage: "Expected type '#type' to be a valid and instantiated subtype of 'NativeType'."
  external: test/ffi_test.dart

ffiFieldNull:
  # Used by dart:ffi
  parameters:
    Name fieldName: The name of the erroneous field.
  problemMessage: "Field '#fieldName' cannot be nullable or have type 'Null', it must be `int`, `double`, `Pointer`, or a subtype of `Struct` or `Union`."
  external: test/ffi_test.dart

ffiFieldAnnotation:
  # Used by dart:ffi
  parameters:
    Name fieldName: The name of the erroneous field.
  problemMessage: "Field '#fieldName' requires exactly one annotation to declare its native type, which cannot be Void. dart:ffi Structs and Unions cannot have regular Dart fields."
  external: test/ffi_test.dart

ffiFieldNoAnnotation:
  # Used by dart:ffi
  parameters:
    Name fieldName: The name of the erroneous field.
  problemMessage: "Field '#fieldName' requires no annotation to declare its native type, it is a Pointer which is represented by the same type in Dart and native code."
  external: test/ffi_test.dart

ffiFieldCyclic:
  # Used by dart:ffi
  parameters:
    String superclass: The superclass name.
    Name name: The name of the problematic struct.
    Names cycleElements: The components in the cycle.
  problemMessage: |
    #superclass '#name' contains itself. Cycle elements:
    #cycleElements
  external: test/ffi_test.dart

ffiNotStatic:
  # Used by dart:ffi
  parameters:
    Name name: The name of the problematic element.
  problemMessage: "#name expects a static function as parameter. dart:ffi only supports calling static Dart functions from native code. Closures and tear-offs are not supported because they can capture context."
  external: test/ffi_test.dart

ffiFieldInitializer:
  # Used by dart:ffi
  parameters:
    Name fieldName: The name of the problematic field.
  problemMessage: "Field '#fieldName' is a dart:ffi Pointer to a struct field and therefore cannot be initialized before constructor execution."
  correctionMessage: "Mark the field as external to avoid having to initialize it."
  external: test/ffi_test.dart

ffiExtendsOrImplementsSealedClass:
  # Used by dart:ffi
  parameters:
    Name sealedClassName: The name of the class that cannot be extended or implemented.
  problemMessage: "Class '#sealedClassName' cannot be extended or implemented."
  external: test/ffi_test.dart

ffiPackedAnnotation:
  # Used by dart:ffi
  parameters:
    Name name: The name of the problematic struct.
  problemMessage: "Struct '#name' must have at most one 'Packed' annotation."
  external: test/ffi_test.dart

ffiPackedAnnotationAlignment:
  # Used by dart:ffi
  parameters: none
  problemMessage: "Only packing to 1, 2, 4, 8, and 16 bytes is supported."
  external: test/ffi_test.dart

ffiSizeAnnotation:
  # Used by dart:ffi
  parameters:
    Name fieldName: The name of the problematic field.
  problemMessage: "Field '#fieldName' must have exactly one 'Array' annotation."
  external: test/ffi_test.dart

ffiSizeAnnotationDimensions:
  # Used by dart:ffi
  parameters:
    Name fieldName: The name of the problematic field.
  problemMessage: "Field '#fieldName' must have an 'Array' annotation that matches the dimensions."
  external: test/ffi_test.dart

ffiVariableLengthArrayNotLast:
  # Used by dart:ffi
  parameters: none
  problemMessage: "Variable length 'Array's must only occur as the last field of Structs."
  correctionMessage: "Try adjusting the arguments in the 'Array' annotation."
  external: test/ffi_test.dart

ffiStructGeneric:
  # Used by dart:ffi
  parameters:
    String superclass: The superclass name.
    Name name: The name of the problematic struct.
  problemMessage: "#superclass '#name' should not be generic."
  external: test/ffi_test.dart

ffiCompoundImplementsFinalizable:
  # Used by dart:ffi
  parameters:
    String superclass: The superclass name.
    Name name: The name of the problematic struct.
  problemMessage: "#superclass '#name' can't implement Finalizable."
  correctionMessage: "Try removing the implements clause from '#name'."
  external: test/ffi_test.dart

ffiDartTypeMismatch:
  # Used by dart:ffi
  parameters:
    Type actualType: The actual return type.
    Type expectedType: The expected return type.
  problemMessage: "Expected '#actualType' to be a subtype of '#expectedType'."
  external: test/ffi_test.dart

ffiDeeplyImmutableClassesMustBeFinalOrSealed:
  # Used by dart:ffi
  parameters: none
  problemMessage: 'Deeply immutable classes must be final or sealed.'
  correctionMessage: 'Try marking this class as final or sealed.'
  external: test/ffi_test.dart

ffiDeeplyImmutableFieldsMustBeDeeplyImmutable:
  # Used by dart:ffi
  parameters: none
  problemMessage: "Deeply immutable classes must only have deeply immutable instance fields. Deeply immutable types include 'int', 'double', 'bool', 'String', 'Pointer', 'Float32x4', 'Float64x2', 'Int32x4', function types and classes annotated with `@pragma('vm:deeply-immutable')`."
  correctionMessage: 'Try changing the type of this field to a deeply immutable type or mark the type of this field as deeply immutable.'
  external: test/ffi_test.dart

ffiDeeplyImmutableFieldsModifiers:
  # Used by dart:ffi
  parameters: none
  problemMessage: 'Deeply immutable classes must only have final non-late instance fields.'
  correctionMessage: "Add the 'final' modifier to this field, and remove 'late' modifier from this field."
  external: test/ffi_test.dart

ffiDeeplyImmutableSubtypesMustBeDeeplyImmutable:
  # Used by dart:ffi
  parameters: none
  problemMessage: 'Subtypes of deeply immutable classes must be deeply immutable.'
  correctionMessage: "Try marking this class deeply immutable by adding `@pragma('vm:deeply-immutable')`."
  external: test/ffi_test.dart

ffiDeeplyImmutableSupertypeMustBeDeeplyImmutable:
  # Used by dart:ffi
  parameters: none
  problemMessage: 'The super type of deeply immutable classes must be deeply immutable.'
  correctionMessage: "Try marking the super class deeply immutable by adding `@pragma('vm:deeply-immutable')`."
  external: test/ffi_test.dart

ffiDefaultAssetDuplicate:
  # Used by dart:ffi
  parameters: none
  problemMessage: "There may be at most one @DefaultAsset annotation on a library."
  external: test/ffi_test.dart

ffiExpectedExceptionalReturn:
  # Used by dart:ffi
  parameters:
    Type returnType: The return type of the native callback.
  problemMessage: "Expected an exceptional return value for a native callback returning '#returnType'."
  external: test/ffi_test.dart

ffiExpectedNoExceptionalReturn:
  # Used by dart:ffi
  parameters:
    Type returnType: The return type of the native callback.
  problemMessage: "Exceptional return value cannot be provided for a native callback returning '#returnType'."
  external: test/ffi_test.dart

ffiExpectedConstant:
  # Used by dart:ffi
  parameters: none
  problemMessage: "Exceptional return value must be a constant."
  external: test/ffi_test.dart

ffiExceptionalReturnNull:
  # Used by dart:ffi
  parameters: none
  problemMessage: "Exceptional return value must not be null."
  external: test/ffi_test.dart

ffiNativeCallableListenerReturnVoid:
  # Used by dart:ffi
  parameters:
    Type returnType: The return type of the function passed to `NativeCallable.listener`.
  problemMessage: "The return type of the function passed to NativeCallable.listener must be void rather than '#returnType'."
  external: test/ffi_test.dart

ffiExpectedConstantArg:
  # Used by dart:ffi
  parameters:
    Name name: The name of the non-constant argument.
  problemMessage: "Argument '#name' must be a constant."
  external: test/ffi_test.dart

ffiLeafCallMustNotTakeHandle:
  # Used by dart:ffi
  parameters: none
  problemMessage: "FFI leaf call must not have Handle argument types."
  external: test/ffi_test.dart

ffiLeafCallMustNotReturnHandle:
  # Used by dart:ffi
  parameters: none
  problemMessage: "FFI leaf call must not have Handle return type."
  external: test/ffi_test.dart

ffiNativeUnexpectedNumberOfParametersWithReceiver:
  # Used by dart:ffi
  parameters:
    int expectedCount: The expected number of parameters.
    int actualCount: The actual number of parameters.
  problemMessage: "Unexpected number of Native annotation parameters. Expected #expectedCount but has #actualCount. Native instance method annotation must have receiver as first argument."
  external: test/ffi_test.dart

ffiNativeUnexpectedNumberOfParameters:
  # Used by dart:ffi
  parameters:
    int expectedCount: The expected number of parameters.
    int actualCount: The actual number of parameters.
  problemMessage: "Unexpected number of Native annotation parameters. Expected #expectedCount but has #actualCount."
  external: test/ffi_test.dart

ffiNativeOnlyNativeFieldWrapperClassCanBePointer:
  # Used by dart:ffi
  parameters: none
  problemMessage: "Only classes extending NativeFieldWrapperClass1 can be passed as Pointer."
  external: test/ffi_test.dart

ffiNativeMustBeExternal:
  # Used by dart:ffi
  parameters: none
  problemMessage: "Native functions and fields must be marked external."
  external: test/ffi_test.dart

ffiNativeDuplicateAnnotations:
  # Used by dart:ffi
  parameters: none
  problemMessage: "Native functions and fields must not have more than @Native annotation."
  external: test/ffi_test.dart

ffiNativeFieldMustBeStatic:
  # Used by dart:ffi
  parameters: none
  problemMessage: "Native fields must be static."
  external: test/ffi_test.dart

ffiNativeFieldMissingType:
  # Used by dart:ffi
  parameters: none
  problemMessage: "The native type of this field could not be inferred and must be specified in the annotation."
  external: test/ffi_test.dart

ffiNativeFieldType:
  # Used by dart:ffi
  parameters: none
  problemMessage: "Unsupported type for native fields. Native fields only support pointers, compounds and numeric types."
  external: test/ffi_test.dart

ffiNativeFunctionMissingType:
  # Used by dart:ffi
  parameters: none
  problemMessage: "The native type of this function couldn't be inferred so it must be specified in the annotation."
  external: test/ffi_test.dart

ffiAddressOfMustBeNative:
  # Used by dart:ffi
  parameters: none
  problemMessage: "Argument to 'Native.addressOf' must be annotated with @Native."
  external: test/ffi_test.dart

spreadTypeMismatch:
  parameters:
    Type spreadType: The type of the spread.
  problemMessage: "Unexpected type '#spreadType' of a spread.  Expected 'dynamic' or an Iterable."
  script:
    - |
      main() {
        int a = 42;
        var b = [...a];
      }
    - |
      main() {
        int Function() a = () => 42;
        var b = [...a];
      }

cantHaveNamedParameters:
  # Used by dart:ffi
  parameters:
    Name name: The name of the entity that can't have named parameters.
  problemMessage: "'#name' can't be declared with named parameters."
  external: test/ffi_test.dart

cantHaveOptionalParameters:
  # Used by dart:ffi
  parameters:
    Name name: The name of the entity that can't have named parameters.
  problemMessage: "'#name' can't be declared with optional parameters."
  external: test/ffi_test.dart

spreadElementTypeMismatch:
  parameters:
    Type spreadElementType: The type of the spread element.
    Type collectionElementType: The type of the enclosing collection.
  problemMessage: "Can't assign spread elements of type '#spreadElementType' to collection elements of type '#collectionElementType'."
  script: |
    main() {
      List<String> a = <String>["foo"];
      List<int> b = <int>[...a];
    }

spreadMapEntryTypeMismatch:
  parameters:
    Type spreadType: The type of the spread.
  problemMessage: "Unexpected type '#spreadType' of a map spread entry.  Expected 'dynamic' or a Map."
  script:
    - |
      main() {
        int a = 42;
        var b = <dynamic, dynamic>{...a};
      }
    - |
      main() {
        int Function() a = () => 42;
        var b = <dynamic, dynamic>{...a};
      }

spreadMapEntryElementKeyTypeMismatch:
  parameters:
    Type spreadKeyType: The key type of the spread element.
    Type mapKeyType: The key type of the enclosing map.
  problemMessage: "Can't assign spread entry keys of type '#spreadKeyType' to map entry keys of type '#mapKeyType'."
  script: |
    main() {
      Map<String, int> a = <String, int>{"foo": 42};
      Map<int, int> b = <int, int>{...a};
    }

spreadMapEntryElementValueTypeMismatch:
  parameters:
    Type spreadValueType: The value type of the spread element.
    Type mapValueType: The value type of the enclosing map.
  problemMessage: "Can't assign spread entry values of type '#spreadValueType' to map entry values of type '#mapValueType'."
  script: |
    main() {
      Map<String, int> a = <String, int>{"foo": 42};
      Map<String, String> b = <String, String>{...a};
    }

cantDisambiguateNotEnoughInformation:
  parameters: none
  problemMessage: "Not enough type information to disambiguate between literal set and literal map."
  correctionMessage: "Try providing type arguments for the literal explicitly to disambiguate it."
  script: |
    foo(dynamic spread) {
      var a = {...spread};
    }

cantDisambiguateAmbiguousInformation:
  parameters: none
  problemMessage: "Both Iterable and Map spread elements encountered in ambiguous literal."
  script: |
    foo(Iterable<int> iterableSpread, Map<int, int> mapSpread) {
      var c = {...iterableSpread, ...mapSpread};
    }

spreadElement:
  parameters: none
  problemMessage: "Iterable spread."
  severity: CONTEXT

spreadMapElement:
  parameters: none
  problemMessage: "Map spread."
  severity: CONTEXT

nonNullAwareSpreadIsNull:
  parameters:
    Type spreadType: The static type of the spread.
  problemMessage: "Can't spread a value with static type '#spreadType'."
  script: |
    main() {
      <int>[...null];
    }

negativeVariableDimension:
  # Used by dart:ffi
  parameters: none
  problemMessage: "The variable dimension of a variable-length array must be non-negative."
  external: test/ffi_test.dart

nonPositiveArrayDimensions:
  # Used by dart:ffi
  parameters: none
  problemMessage: "Array dimensions must be positive numbers."
  external: test/ffi_test.dart

invalidTypeParameterInSupertype:
  parameters:
    Name typeVariableName: The implicitly 'out' type variable name.
    String useVariance: The variance keyword for the position in which the type variable is used.
    Name supertypeName: The supertype name.
  problemMessage: "Can't use implicitly 'out' variable '#typeVariableName' in an '#useVariance' position in supertype '#supertypeName'."
  script: |
    class A<X> {}
    class B<Y> extends A<Function(Y)> {}

invalidTypeParameterInSupertypeWithVariance:
  parameters:
    String typeVariableVariance: The variance of the type variable.
    Name typeVariableName: The type variable name.
    String useVariance: The variance keyword for the position in which the type variable is used.
    Name supertypeName: The supertype name.
  problemMessage: "Can't use '#typeVariableVariance' type variable '#typeVariableName' in an '#useVariance' position in supertype '#supertypeName'."
  script: |
    class A<out X> {}
    class B<out Y> extends A<Function(Y)> {}
  exampleAllowOtherCodes: true

invalidTypeParameterVariancePosition:
  parameters:
    String typeVariableVariance: The variance of the type variable.
    Name typeVariableName: The type variable name.
    String useVariance: The variance keyword for the position in which the type variable is used.
  problemMessage: "Can't use '#typeVariableVariance' type variable '#typeVariableName' in an '#useVariance' position."
  script: |
    class A<out T> {
      void method(T x) {}
  exampleAllowOtherCodes: true

invalidTypeParameterVariancePositionInReturnType:
  parameters:
    String typeVariableVariance: The variance of the type variable.
    Name typeVariableName: The type variable name.
    String useVariance: The variance keyword for the position in which the type variable is used.
  problemMessage: "Can't use '#typeVariableVariance' type variable '#typeVariableName' in an '#useVariance' position in the return type."
  script: |
    class A<in T> {
      T method() {
        return null;
      }
    }
  exampleAllowOtherCodes: true

combinedMemberSignatureFailed:
  parameters:
    Name className: The name of the class that inherits multiple members.
    Name memberName: The name of the member that is multiply inherited.
  problemMessage: "Class '#className' inherits multiple members named '#memberName' with incompatible signatures."
  correctionMessage: "Try adding a declaration of '#memberName' to '#className'."
  script:
    - |
      abstract class I1 {
        foo(x);
      }

      abstract class I2 {
        foo();
      }

      abstract class C implements I2, I1 {}

extensionTypeCombinedMemberSignatureFailed:
  parameters:
    Name extensionTypeName: The name of the extension type that inherits multiple members.
    Name memberName: The name of the member that is multiply inherited.
  problemMessage: "Extension type '#extensionTypeName' inherits multiple members named '#memberName' with incompatible signatures."
  correctionMessage: "Try adding a declaration of '#memberName' to '#extensionTypeName'."
  script:
    - |
      abstract class I1 {
        void foo(int? x);
      }
      abstract class I2 {
        void foo();
      }
      abstract class I3 implements I1, I2 {
        void foo([int? x]);
      }
      extension type C(I3 i) implements I2, I1 {}

languageVersionTooHighExplicit:
  parameters:
    int specifiedMajor: The specified major version.
    int specifiedMinor: The specified minor version.
    int highestSupportedMajor: The highest supported major version.
    int highestSupportedMinor: The highest supported minor version.
  problemMessage: "The specified language version #specifiedMajor.#specifiedMinor is too high. The highest supported language version is #highestSupportedMajor.#highestSupportedMinor."
  script: |
    // @dart=100.200
  exampleAllowMultipleReports: true

languageVersionTooHighPackage:
  parameters:
    int specifiedMajor: The specified major version.
    int specifiedMinor: The specified minor version.
    Name packageName: The package name.
    int highestSupportedMajor: The highest supported major version.
    int highestSupportedMinor: The highest supported minor version.
  problemMessage: "The language version #specifiedMajor.#specifiedMinor specified for the package '#packageName' is too high. The highest supported language version is #highestSupportedMajor.#highestSupportedMinor."
  script:
    .dart_tool/package_config.json: |
      {
        "configVersion": 2,
        "packages": [
          {
            "name": "foo",
            "rootUri": "../foo/",
            "languageVersion": "42.84"
          }
        ]
      }
    main.dart: |
      import 'package:foo/lib.dart';
    foo/lib.dart: ""

languageVersionTooLowExplicit:
  parameters:
    int specifiedMajor: The specified major version.
    int specifiedMinor: The specified minor version.
    int lowestSupportedMajor: The lowest supported major version.
    int lowestSupportedMinor: The lowest supported minor version.
  problemMessage: "The specified language version #specifiedMajor.#specifiedMinor is too low. The lowest supported language version is #lowestSupportedMajor.#lowestSupportedMinor."
  script: |
    // @dart=2.9
  exampleAllowMultipleReports: true

languageVersionTooLowPackage:
  parameters:
    int specifiedMajor: The specified major version.
    int specifiedMinor: The specified minor version.
    Name packageName: The package name.
    int lowestSupportedMajor: The lowest supported major version.
    int lowestSupportedMinor: The lowest supported minor version.
  problemMessage: "The language version #specifiedMajor.#specifiedMinor specified for the package '#packageName' is too low. The lowest supported language version is #lowestSupportedMajor.#lowestSupportedMinor."
  script:
    .dart_tool/package_config.json: |
      {
        "configVersion": 2,
        "packages": [
          {
            "name": "foo",
            "rootUri": "../foo/",
            "languageVersion": "2.11"
          }
        ]
      }
    main.dart: |
      import 'package:foo/lib.dart';
    foo/lib.dart: ""

languageVersionInvalidInDotPackages:
  parameters: none
  problemMessage: "The language version is not specified correctly in the packages file."
  exampleAllowOtherCodes: true
  script:
    main.dart: "import 'package:foo/foo.dart';"
    lib/foo.dart: "// blah blah blah"
    .dart_tool/package_config.json: |
      {
          "configVersion": 2,
          "packages": [
              {
                  "name": "foo",
                  "rootUri": "../lib/",
                  "languageVersion": "arglebargle"
              }
          ]
      }

languageVersionMismatchInPart:
  parameters: none
  problemMessage: "The language version override has to be the same in the library and its part(s)."
  script:
    main.dart: |
      // @dart = 2.13
      part 'part.dart';
    part.dart: |
      // @dart = 2.12
      part of 'main.dart';

languageVersionMismatchInPatch:
  parameters: none
  problemMessage: "The language version override has to be the same in the library and its patch(es)."

languageVersionLibraryContext:
  parameters: none
  problemMessage: "This is language version annotation in the library."
  severity: CONTEXT

languageVersionPartContext:
  parameters: none
  problemMessage: "This is language version annotation in the part."
  severity: CONTEXT

languageVersionPatchContext:
  parameters: none
  problemMessage: "This is language version annotation in the patch."
  severity: CONTEXT

explicitExtensionArgumentMismatch:
  parameters: none
  problemMessage: "Explicit extension application requires exactly 1 positional argument."
  script: |
    extension Extension on int {
      method(a) {}
    }
    main() {
      int i = 42;
      Extension(i, i).method(null);
    }

explicitExtensionTypeArgumentMismatch:
  parameters:
    Name extensionName: The name of the extension.
    int typeArgumentCount: The number of type arguments the extension takes.
  problemMessage: "Explicit extension application of extension '#extensionName' takes '#typeArgumentCount' type argument(s)."
  script: |
    extension Extension on int {
      method(a) {}
    }
    main() {
      int i = 42;
      Extension<int>(i).method(null);
    }

explicitExtensionAsExpression:
  parameters: none
  problemMessage: "Explicit extension application cannot be used as an expression."
  script: |
    extension Extension on int {}
    errors(int i) {
      Extension(i);
    }

explicitExtensionAsLvalue:
  parameters: none
  problemMessage: "Explicit extension application cannot be a target for assignment."

deferredExtensionImport:
  parameters:
    Name extensionName: The name of the extension.
  problemMessage: "Extension '#extensionName' cannot be imported through a deferred import."
  correctionMessage: "Try adding the `hide #extensionName` to the import."
  script:
    main.dart: "import 'lib.dart' deferred as prefix;"
    lib.dart: "extension Extension on void {}"

variableCouldBeNullDueToWrite:
  parameters:
    Name variableName: The name of the unpromoted variable.
    String documentationUrl: The URL of the documentation explaining the problem.
  problemMessage: "Variable '#variableName' could not be promoted due to an assignment."
  correctionMessage: "Try null checking the variable after the assignment.  See #documentationUrl"
  script: |
    void foo(int? i, int? j) {
      if (i == null) return;
      i = j;
      i.isEven;
    }
  includeErrorContext: true
  exampleAllowOtherCodes: true

fieldNotPromotedBecauseNotEnabled:
  parameters:
    Name variableName: The name of the unpromoted variable.
    String documentationUrl: The URL of the documentation explaining the problem.
  problemMessage: "'#variableName' couldn't be promoted because field promotion is only available in Dart 3.2 and above."
  correctionMessage: "See #documentationUrl"
  script: |
    // @dart=3.1
    class C {
      final int? _i;
      C(this._i);
    }
    test(C c) {
      if (c._i != null) {
        c._i.isEven;
      }
    }
  includeErrorContext: true
  exampleAllowOtherCodes: true

fieldNotPromotedBecauseNotField:
  parameters:
    Name propertyName: The name of the unpromoted property.
    String documentationUrl: The URL of the documentation explaining the problem.
  problemMessage: "'#propertyName' refers to a getter so it couldn't be promoted."
  correctionMessage: "See #documentationUrl"
  script: |
    class C {
      int? get _i => 0;
    }
    test(C c) {
      if (c._i != null) {
        c._i.isEven;
      }
    }
  includeErrorContext: true
  exampleAllowOtherCodes: true

fieldNotPromotedBecauseNotPrivate:
  parameters:
    Name propertyName: The name of the unpromoted property.
    String documentationUrl: The URL of the documentation explaining the problem.
  problemMessage: "'#propertyName' refers to a public property so it couldn't be promoted."
  correctionMessage: "See #documentationUrl"
  script: |
    class C {
      final int? i;
      C(this.i);
    }
    test(C c) {
      if (c.i != null) {
        c.i.isEven;
      }
    }
  includeErrorContext: true
  exampleAllowOtherCodes: true

fieldNotPromotedBecauseExternal:
  parameters:
    Name propertyName: The name of the unpromoted property.
    String documentationUrl: The URL of the documentation explaining the problem.
  problemMessage: "'#propertyName' refers to an external field so it couldn't be promoted."
  correctionMessage: "See #documentationUrl"
  script: |
    class C {
      external final int? _i;
    }
    test(C c) {
      if (c._i != null) {
        c._i.isEven;
      }
    }
  includeErrorContext: true
  exampleAllowOtherCodes: true

fieldNotPromotedBecauseNotFinal:
  parameters:
    Name propertyName: The name of the unpromoted property.
    String documentationUrl: The URL of the documentation explaining the problem.
  problemMessage: "'#propertyName' refers to a non-final field so it couldn't be promoted."
  correctionMessage: "See #documentationUrl"
  script: |
    class C {
      int? _i;
      C(this._i);
    }
    test(C c) {
      if (c._i != null) {
        c._i.isEven;
      }
    }
  includeErrorContext: true
  exampleAllowOtherCodes: true

fieldNotPromotedBecauseConflictingGetter:
  parameters:
    Name propertyName: The name of the unpromoted property.
    Name conflictingGetterClassName: The name of the class containing a conflicting getter.
    String documentationUrl: The URL of the documentation explaining the problem.
  problemMessage: "'#propertyName' couldn't be promoted because there is a conflicting getter in class '#conflictingGetterClassName'."
  correctionMessage: "See #documentationUrl"
  script: |
    class C {
      final int? _i;
      C(this._i);
    }
    class D {
      int? get _i => 0;
    }
    test(C c) {
      if (c._i != null) {
        c._i.isEven;
      }
    }
  includeErrorContext: true
  exampleAllowOtherCodes: true

fieldNotPromotedBecauseConflictingField:
  parameters:
    Name propertyName: The name of the unpromoted property.
    Name conflictingFieldClassName: The name of the class containing a conflicting field.
    String documentationUrl: The URL of the documentation explaining the problem.
  problemMessage: "'#propertyName' couldn't be promoted because there is a conflicting non-promotable field in class '#conflictingFieldClassName'."
  correctionMessage: "See #documentationUrl"
  script: |
    class C {
      final int? _i;
      C(this._i);
    }
    class D {
      int? _i;
      D(this._i);
    }
    test(C c) {
      if (c._i != null) {
        c._i.isEven;
      }
    }
  includeErrorContext: true
  exampleAllowOtherCodes: true

fieldNotPromotedBecauseConflictingNsmForwarder:
  parameters:
    Name propertyName: The name of the unpromoted property.
    Name conflictingNsmClassName: The name of the class containing a conflicting `noSuchMethod` forwarder.
    String documentationUrl: The URL of the documentation explaining the problem.
  problemMessage: "'#propertyName' couldn't be promoted because there is a conflicting noSuchMethod forwarder in class '#conflictingNsmClassName'."
  correctionMessage: "See #documentationUrl"
  script: |
    class C {
      final int? _i;
      C(this._i);
    }
    class D implements C {
      noSuchMethod(invocation) => 0;
    }
    test(C c) {
      if (c._i != null) {
        c._i.isEven;
      }
    }
  includeErrorContext: true
  exampleAllowOtherCodes: true

thisNotPromoted:
  parameters:
    String documentationUrl: The URL of the documentation explaining the problem.
  problemMessage: "'this' can't be promoted."
  correctionMessage: "See #documentationUrl"
  script: |
    extension on int? {
      bool extension_explicit_this() {
        if (this == null) return false;
        return this.isEven;
      }
    }
  includeErrorContext: true
  exampleAllowOtherCodes: true

nullablePropertyAccessError:
  parameters:
    Name propertyName: The name of the problematic property.
    Type receiverType: The type of the property access receiver.
  problemMessage: "Property '#propertyName' cannot be accessed on '#receiverType' because it is potentially null."
  correctionMessage: "Try accessing using ?. instead."
  script: |
    bool foo(int? i) => i.isEven;

nullableMethodCallError:
  parameters:
    Name methodName: The name of the problematic method.
    Type receiverType: The name of the method invocation recevier.
  problemMessage: "Method '#methodName' cannot be called on '#receiverType' because it is potentially null."
  correctionMessage: "Try calling using ?. instead."
  script: |
    void foo(int? i) => i.abs();

nullableExpressionCallError:
  parameters:
    Type type: The type that can't be used as a function.
  problemMessage: "Can't use an expression of type '#type' as a function because it's potentially null."
  correctionMessage: "Try calling using ?.call instead."
  script: |
    void foo(Function()? f) => f();

nullableOperatorCallError:
  parameters:
    Name operator: The operator that can't be called.
    Type receiverType: The receiver type of the operator invocation.
  problemMessage: "Operator '#operator' cannot be called on '#receiverType' because it is potentially null."
  script: |
    void foo(int? i) => i - 1;

nullableTearoffError:
  parameters:
    Name methodName: The name of the method that can't be torn off.
  problemMessage: "Can't tear off method '#methodName' from a potentially null value."
  script: |
    class Foo {
      void call() {}
    }
    void x(Foo? f) {
      Function y = f;
    }

nullableSpreadError:
  parameters: none
  problemMessage: "An expression whose value can be 'null' must be null-checked before it can be dereferenced."
  script: |
    void foo(List<int>? bar) => [...bar];

throwingNotAssignableToObjectError:
  parameters:
    Type thrownType: The static type of the thrown expression.
  problemMessage: "Can't throw a value of '#thrownType' since it is neither dynamic nor non-nullable."
  script: |
    void foo(String? s) => throw s;

requiredNamedParameterHasDefaultValueError:
  parameters:
    Name parameterName: The name of the problematic parameter.
  problemMessage: "Named parameter '#parameterName' is required and can't have a default value."
  script: |
    error() {
      void g({required int b = 42}) {}
    }

valueForRequiredParameterNotProvidedError:
  parameters:
    Name parameterName: The name of the problematic parameter.
  problemMessage: "Required named parameter '#parameterName' must be provided."
  script: |
    void foo({required int i}) {}
    void bar() { foo(); }

optionalNonNullableWithoutInitializerError:
  parameters:
    Name parameterName: The name of the problematic parameter.
    Type parameterType: The type of the problematic parameter.
  problemMessage: "The parameter '#parameterName' can't have a value of 'null' because of its type '#parameterType', but the implicit default value is 'null'."
  correctionMessage: "Try adding either an explicit non-'null' default value or the 'required' modifier."
  script:
    - method1({int a}) {}
    - method2([int a]) {}

fieldNonNullableWithoutInitializerError:
  parameters:
    Name fieldName: The name of the field.
    Type fieldType: The type of the field.
  problemMessage: "Field '#fieldName' should be initialized because its type '#fieldType' doesn't allow null."
  script: |
    class Foo {
      int x;
    }

fieldNonNullableNotInitializedByConstructorError:
  parameters:
    Name fieldName: The name of the field.
    Type fieldType: The type of the field.
  problemMessage: "This constructor should initialize field '#fieldName' because its type '#fieldType' doesn't allow null."
  script: |
    class Foo {
      int x;
      Foo(this.x);
      Foo.other();
    }

experimentOptOutExplicit:
  parameters:
    String featureName: The name of the language feature.
    String enabledVersion: The language version in which the feature was enabled.
  problemMessage: "The '#featureName' language feature is disabled for this library."
  correctionMessage: "Try removing the `@dart=` annotation or setting the language version to #enabledVersion or higher."
  script: |
    // @dart=2.14
    class Foo {}
    bar() {
      var baz = Foo.new;
    }
  exampleAllowOtherCodes: true

experimentOptOutImplicit:
  parameters:
    String featureName: The name of the language feature.
    String enabledVersion: The language version in which the feature was enabled.
  problemMessage: "The '#featureName' language feature is disabled for this library."
  correctionMessage: "Try removing the package language version or setting the language version to #enabledVersion or higher."
  script:
    .dart_tool/package_config.json: |
      {
        "configVersion": 2,
        "packages": [
          {
            "name": "foo",
            "rootUri": "../foo/",
            "languageVersion": "2.14"
          }
        ]
      }
    main.dart: |
      import 'package:foo/lib.dart';
    foo/lib.dart: |
      class Foo {}
      bar() {
        var baz = Foo.new;
      }
  exampleAllowOtherCodes: true

experimentOptOutComment:
  parameters:
    String featureName: The name of the language feature.
  problemMessage: "This is the annotation that opts out this library from the '#featureName' language feature."
  severity: CONTEXT

awaitInLateLocalInitializer:
  parameters: none
  problemMessage: "`await` expressions are not supported in late local initializers."
  script: |
    Future<void> foo() async {
      late dynamic x = await null;
    }

nullableSuperclassError:
  parameters:
    Name supertypeName: The name of the supertype.
  problemMessage: "Can't extend '#supertypeName' because it's nullable."
  correctionMessage: "Try removing the question mark."
  script: |
    class Foo extends Object? {}

nullableInterfaceError:
  parameters:
    Name interfaceName: The name of the interface that couldn't be implemented.
  problemMessage: "Can't implement '#interfaceName' because it's nullable."
  correctionMessage: "Try removing the question mark."
  script: |
    class Foo {}
    class Bar implements Foo? {}

nullableMixinError:
  parameters:
    Name mixinName: The name of the type that couldn't be mixed in.
  problemMessage: "Can't mix '#mixinName' in because it's nullable."
  correctionMessage: "Try removing the question mark."
  script: |
    mixin Foo {}
    class Bar = Object with Foo?;

jsInteropDartClassExtendsJSClass:
  parameters:
    Name className: The name of the class that cannot extend a JS interop class.
    Name superclassName: The name of the JS interop class.
  problemMessage: "Dart class '#className' cannot extend JS interop class '#superclassName'."
  correctionMessage: "Try adding the JS interop annotation or removing it from the parent class."

jsInteropDartJsInteropAnnotationForStaticInteropOnly:
  parameters: none
  problemMessage: "The '@JS' annotation from 'dart:js_interop' can only be used for static interop, either through extension types or '@staticInterop' classes."
  correctionMessage: "Try making this class an extension type or marking it as '@staticInterop'."

jsInteropEnclosingClassJSAnnotation:
  parameters: none
  problemMessage: "Member has a JS interop annotation but the enclosing class does not."
  correctionMessage: "Try adding the annotation to the enclosing class."

jsInteropEnclosingClassJSAnnotationContext:
  parameters: none
  problemMessage: "This is the enclosing class."
  severity: CONTEXT

jsInteropExportClassNotMarkedExportable:
  parameters:
    Name className: The name of the class that is not marked exportable.
  problemMessage: "Class '#className' does not have a `@JSExport` on it or any of its members."
  correctionMessage: "Use the `@JSExport` annotation on this class."

jsInteropExportDartInterfaceHasNonEmptyJSExportValue:
  parameters:
    Name className: The name of the class with a non-empty `@JSExport` value.
  problemMessage: "The value in the `@JSExport` annotation on the class or mixin '#className' will be ignored."
  correctionMessage: "Remove the value in the annotation."
  severity: WARNING

jsInteropExportDisallowedMember:
  parameters:
    Name memberName: The name of the problematic member.
  problemMessage: "Member '#memberName' is not a concrete instance member or declares type parameters, and therefore can't be exported."
  correctionMessage: "Remove the `@JSExport` annotation from the member, and use an instance member to call this member instead."

jsInteropExportInvalidInteropTypeArgument:
  parameters:
    Type type: The invalid type.
  problemMessage: "Type argument '#type' needs to be a non-JS interop type."
  correctionMessage: "Use a non-JS interop class that uses `@JSExport` instead."

jsInteropExportInvalidTypeArgument:
  parameters:
    Type type: The invalid type.
  problemMessage: "Type argument '#type' needs to be an interface type."
  correctionMessage: "Use a non-JS interop class that uses `@JSExport` instead."

jsInteropExportMemberCollision:
  parameters:
    Name exportName: The name of the conflicting export.
    String members: The class members that collide with the conflicting export, separated by `, `.
  problemMessage: "The following class members collide with the same export '#exportName': #members."
  correctionMessage: "Either remove the conflicting members or use a different export name."

jsInteropExportNoExportableMembers:
  parameters:
    Name className: The name of the class with no exportable members.
  problemMessage: "Class '#className' has no exportable members in the class or the inheritance chain."
  correctionMessage: "Using `@JSExport`, annotate at least one instance member with a body or annotate a class that has such a member in the inheritance chain."

jsInteropIsAInvalidTypeVariable:
  parameters:
    Type type: The type argument provided to `isA`.
  problemMessage: "Type argument '#type' provided to 'isA' cannot be a type variable and must be an interop extension type that can be determined at compile-time."
  correctionMessage: "Use a valid interop extension type that can be determined at compile-time as the type argument instead."

jsInteropIsAObjectLiteralType:
  parameters:
    Type type: The type with an object literal constructor.
  problemMessage: "Type argument '#type' has an object literal constructor. Because 'isA' uses the type's name or '@JS()' rename, this may result in an incorrect type check."
  correctionMessage: "Use 'JSObject' as the type argument instead."

jsInteropIsAPrimitiveExtensionType:
  parameters:
    Type interopType: The type that wraps a primitive JS type.
    String jsTypeName: The name of the JS type that is wrapped.
  problemMessage: "Type argument '#interopType' wraps primitive JS type '#jsTypeName', which is specially handled using 'typeof'."
  correctionMessage: "Use the primitive JS type '#jsTypeName' as the type argument instead."

jsInteropIsATearoff:
  parameters: none
  problemMessage: "'isA' can't be torn off."
  correctionMessage: "Use a method that calls 'isA' and tear off that method instead."

jsInteropExtensionTypeNotInterop:
  parameters:
    Name extensionTypeName: The name of the extension type that is marked with a `@JS` annotation.
    Type representationType: The type that is not a valid JS interop type.
  problemMessage: "Extension type '#extensionTypeName' is marked with a '@JS' annotation, but its representation type is not a valid JS interop type: '#representationType'."
  correctionMessage: "Try declaring a valid JS interop representation type, which may include 'dart:js_interop' types, '@staticInterop' types, 'dart:html' types, or other interop extension types."

jsInteropExtensionTypeMemberNotInterop:
  parameters: none
  problemMessage: "Extension type member is marked 'external', but the representation type of its extension type is not a valid JS interop type."
  correctionMessage: "Try declaring a valid JS interop representation type, which may include 'dart:js_interop' types, '@staticInterop' types, 'dart:html' types, or other interop extension types."

jsInteropExtensionTypeUsedWithWrongJsAnnotation:
  parameters: none
  problemMessage: "Extension types should use the '@JS' annotation from 'dart:js_interop' and not from 'package:js'."
  correctionMessage: "Try using the '@JS' annotation from 'dart:js_interop' annotation on this extension type instead."

jsInteropExternalExtensionMemberOnTypeInvalid:
  parameters: none
  problemMessage: "JS interop type or @Native type from an SDK web library required for 'external' extension members."
  correctionMessage: "Try making the on-type a JS interop type or an @Native SDK web library type."

jsInteropExternalExtensionMemberWithStaticDisallowed:
  parameters: none
  problemMessage: "External extension members with the keyword 'static' on JS interop and @Native types are disallowed."
  correctionMessage: "Try putting the member in the on-type instead."

jsInteropExternalMemberNotJSAnnotated:
  parameters: none
  problemMessage: "Only JS interop members may be 'external'."
  correctionMessage: "Try removing the 'external' keyword or adding a JS interop annotation."

jsInteropFunctionToJSNamedParameters:
  parameters:
    String conversion: The "toJS" conversion in use.
  problemMessage: "Functions converted via '#conversion' cannot declare named parameters."
  correctionMessage: "Remove the declared named parameters from the function."

jsInteropFunctionToJSRequiresStaticType:
  parameters:
    String conversion: The "toJS" conversion in use.
    Type functionType: The imprecise function type.
  problemMessage: "Functions converted via '#conversion' require a statically known function type, but Type '#functionType' is not a precise function type, e.g., `void Function()`."
  correctionMessage: "Insert an explicit cast to the expected function type."

jsInteropFunctionToJSTypeParameters:
  parameters:
    String conversion: The "toJS" conversion in use.
  problemMessage: "Functions converted via '#conversion' cannot declare type parameters."
  correctionMessage: "Remove the declared type parameters from the function."

jsInteropFunctionToJSTypeViolation:
  parameters:
    String conversion: The "toJS" conversion in use.
    String typeWithDiasllowedPartsHighlighted: The function type, with disallowed types surrounded by asterisks.
  problemMessage: "Function converted via '#conversion' contains invalid types in its function signature: '#typeWithDiasllowedPartsHighlighted'."
  correctionMessage: "Use one of these valid types instead: JS types from 'dart:js_interop', ExternalDartReference, void, bool, num, double, int, String, extension types that erase to one of these types, '@staticInterop' types, 'dart:html' types when compiling to JS, or a type parameter that is a subtype of a valid non-primitive type."

jsInteropInvalidStaticClassMemberName:
  parameters: none
  problemMessage: "JS interop static class members cannot have '.' in their JS name."

jsInteropJSClassExtendsDartClass:
  parameters:
    Name className: The name of the class that extends a Dart class.
    Name superclassName: The name of the extended Dart class.
  problemMessage: "JS interop class '#className' cannot extend Dart class '#superclassName'."
  correctionMessage: "Try removing the JS interop annotation or adding it to the parent class."

jsInteropNamedParameters:
  parameters: none
  problemMessage: "Named parameters for JS interop functions are only allowed in object literal constructors or @anonymous factories."
  correctionMessage: "Try replacing them with normal or optional parameters."

jsInteropNativeClassInAnnotation:
  parameters:
    Name className: The name of the problematic class.
    Name nativeClassName: The name of the conflicting natively supported class.
    String uri: The URI in which the conflict occurs.
  problemMessage: "Non-static JS interop class '#className' conflicts with natively supported class '#nativeClassName' in '#uri'."
  correctionMessage: "Try replacing it with a static JS interop class using `@staticInterop` with extension methods, or use js_util to interact with the native object of type '#nativeClassName'."

jsInteropNonExternalConstructor:
  parameters: none
  problemMessage: "JS interop classes do not support non-external constructors."
  correctionMessage: "Try annotating with `external`."

jsInteropNonExternalMember:
  parameters: none
  problemMessage: "This JS interop member must be annotated with `external`. Only factories and static methods can be non-external."
  correctionMessage: "Try annotating the member with `external`."

jsInteropObjectLiteralConstructorPositionalParameters:
  parameters:
    String kind: The kind of the erroneous construct.
  problemMessage: "#kind should not contain any positional parameters."
  correctionMessage: "Try replacing them with named parameters instead."

jsInteropOperatorCannotBeRenamed:
  parameters: none
  problemMessage: "JS interop operator methods cannot be renamed using the '@JS' annotation."
  correctionMessage: "Remove the annotation or remove the value inside the annotation."

jsInteropOperatorsNotSupported:
  parameters: none
  problemMessage: "JS interop types do not support overloading external operator methods, with the exception of '[]' and '[]=' using static interop."
  correctionMessage: "Try making this class a static interop type instead."

jsInteropNonStaticWithStaticInteropSupertype:
  parameters:
    Name className: The name of the problematic class.
    Name superclassName: The name of the conflicting superclass.
  problemMessage: "Class '#className' does not have an `@staticInterop` annotation, but has supertype '#superclassName', which does."
  correctionMessage: "Try marking '#className' as a `@staticInterop` class, or don't inherit '#superclassName'."

# TODO(srujzs): Is there any way to save the correction message into a variable
# to avoid duplication?
jsInteropStaticInteropExternalAccessorTypeViolation:
  parameters:
    Type type: The invalid type.
  problemMessage: "External JS interop member contains an invalid type: '#type'."
  correctionMessage: "Use one of these valid types instead: JS types from 'dart:js_interop', ExternalDartReference, void, bool, num, double, int, String, extension types that erase to one of these types, '@staticInterop' types, 'dart:html' types when compiling to JS, or a type parameter that is a subtype of a valid non-primitive type."

jsInteropStaticInteropExternalFunctionTypeViolation:
  parameters:
    String typeWithDiasllowedPartsHighlighted: The function type, with disallowed types surrounded by asterisks.
  problemMessage: "External JS interop member contains invalid types in its function signature: '#typeWithDiasllowedPartsHighlighted'."
  correctionMessage: "Use one of these valid types instead: JS types from 'dart:js_interop', ExternalDartReference, void, bool, num, double, int, String, extension types that erase to one of these types, '@staticInterop' types, 'dart:html' types when compiling to JS, or a type parameter that is a subtype of a valid non-primitive type."

jsInteropStaticInteropGenerativeConstructor:
  parameters: none
  problemMessage: "`@staticInterop` classes should not contain any generative constructors."
  correctionMessage: "Use factory constructors instead."

jsInteropStaticInteropMockMissingGetterOrSetter:
  parameters:
    Name className: The name of the problematic class.
    String accessorKindPresent: The kind of accessor that is present ("getter" or "setter").
    String accessorKindAbsent: The kind of accessor that is not present ("getter" or "setter").
    Name exportName: The export name.
    String missingMembers: A list of the missing members, separated by ", ".
  problemMessage: "Dart class '#className' has a #accessorKindPresent, but does not have a #accessorKindAbsent to implement any of the following extension member(s) with export name '#exportName': #missingMembers."
  correctionMessage: "Declare an exportable #accessorKindAbsent that implements one of these extension members."

jsInteropStaticInteropMockMissingImplements:
  parameters:
    Name className: The name of the problematic class.
    Name exportName: The export name.
    String missingMembers: A list of the missing members, separated by ", ".
  problemMessage: "Dart class '#className' does not have any members that implement any of the following extension member(s) with export name '#exportName': #missingMembers."
  correctionMessage: "Declare an exportable member that implements one of these extension members."

jsInteropStaticInteropMockNotStaticInteropType:
  parameters:
    Type type: The problematic type argument.
  problemMessage: "Type argument '#type' needs to be a `@staticInterop` type."
  correctionMessage: "Use a `@staticInterop` class instead."

jsInteropStaticInteropMockTypeParametersNotAllowed:
  parameters:
    Type type: The problematic type argument.
  problemMessage: "Type argument '#type' has type parameters that do not match their bound. createStaticInteropMock requires instantiating all type parameters to their bound to ensure mocking conformance."
  correctionMessage: "Remove the type parameter in the type argument or replace it with its bound."

jsInteropStaticInteropNoJSAnnotation:
  parameters:
    Name className: The name of the problematic class.
  problemMessage: "`@staticInterop` classes should also have the `@JS` annotation."
  correctionMessage: "Add `@JS` to class '#className'."

jsInteropStaticInteropParameterInitializersAreIgnored:
  parameters: none
  problemMessage: "Initializers for parameters are ignored on static interop external functions."
  correctionMessage: "Declare a forwarding non-external function with this initializer, or remove the initializer."
  severity: WARNING

jsInteropStaticInteropSyntheticConstructor:
  parameters: none
  problemMessage: "Synthetic constructors on `@staticInterop` classes can not be used."
  correctionMessage: "Declare an external factory constructor for this `@staticInterop` class and use that instead."

jsInteropStaticInteropTearOffsDisallowed:
  parameters:
    String memberKind: The kind of member that was torn off.
    Name memberName: The name of the member that was torn off.
  problemMessage: "Tear-offs of external #memberKind '#memberName' are disallowed."
  correctionMessage: "Declare a closure that calls this member instead."

jsInteropStaticInteropTrustTypesUsedWithoutStaticInterop:
  parameters:
    Name className: The name of the problematic class.
  problemMessage: "JS interop class '#className' has an `@trustTypes` annotation, but no `@staticInterop` annotation."
  correctionMessage: "Try marking the class using `@staticInterop`."

jsInteropStaticInteropTrustTypesUsageNotAllowed:
  parameters:
    Name className: The name of the problematic class.
  problemMessage: "JS interop class '#className' has an `@trustTypes` annotation, but `@trustTypes` is only supported within the sdk."
  correctionMessage: "Try removing the `@trustTypes` annotation."

jsInteropStaticInteropWithInstanceMembers:
  parameters:
    Name className: The name of the problematic class.
  problemMessage: "JS interop class '#className' with `@staticInterop` annotation cannot declare instance members."
  correctionMessage: "Try moving the instance member to a static extension."

jsInteropStaticInteropWithNonStaticSupertype:
  parameters:
    Name className: The name of the problematic class.
    Name superclassName: The name of the superclass, which is not annotated.
  problemMessage: "JS interop class '#className' has an `@staticInterop` annotation, but has supertype '#superclassName', which does not."
  correctionMessage: "Try marking the supertype as a static interop class using `@staticInterop`."

nonNullableNotAssignedError:
  parameters:
    Name variableName: The name of the unassigned variable.
  problemMessage: "Non-nullable variable '#variableName' must be assigned before it can be used."
  script: |
    method<T>() {
      T t; t;
    }

finalNotAssignedError:
  parameters:
    Name variableName: The name of the unassigned variable.
  problemMessage: "Final variable '#variableName' must be assigned before it can be used."
  script: |
    method(bool b) {
      final int i;
      if (b) {
        i = 0;
      }
      i;
    }

lateDefinitelyUnassignedError:
  parameters:
    Name variableName: The name of the unassigned variable.
  problemMessage: "Late variable '#variableName' without initializer is definitely unassigned."
  script: |
    method<T>() {
      late T t; t;
    }

lateDefinitelyAssignedError:
  parameters:
    Name variableName: The name of the definitely assigned variable.
  problemMessage: "Late final variable '#variableName' definitely assigned."
  script: |
    method() {
      late final int t;
      t = 0;
      t = 0;
    }

finalPossiblyAssignedError:
  parameters:
    Name variableName: The name of the possibly assigned variable.
  problemMessage: "Final variable '#variableName' might already be assigned at this point."
  script: |
    method() {
      final int i;
      i = 0;
      i = 0;
    }

cannotAssignToFinalVariable:
  parameters:
    Name variableName: The name of the final variable.
  problemMessage: "Can't assign to the final variable '#variableName'."
  script: |
     main() {
       final int i = 0;
       i = 42;
     }

cannotAssignToConstVariable:
  parameters:
    Name variableName: The name of the const variable.
  problemMessage: "Can't assign to the const variable '#variableName'."
  script: |
    main() {
      const int i = 0;
      i = 42;
    }

cannotAssignToExtensionThis:
  parameters: none
  problemMessage: "Can't assign to 'this'."
  script: |
    extension E on String {
      method() {
        this = "";
      }
    }

cannotAssignToTypeLiteral:
  parameters: none
  problemMessage: "Can't assign to a type literal."
  script: |
    main() {
      Object = String;
    }

nonVoidReturnOperator:
  parameters: none
  problemMessage: "The return type of the operator []= must be 'void'."
  correctionMessage: "Try changing the return type to 'void'."
  script:
    - class Class { int operator[]=(a, b) {} }
    - class Class { dynamic operator[]=(a, b) {} }

nonVoidReturnSetter:
  parameters: none
  problemMessage: "The return type of the setter must be 'void' or absent."
  correctionMessage: "Try removing the return type, or define a method rather than a setter."
  script:
    - int set setter(_) {}
    - dynamic set setter(_) {}

neverReachableSwitchDefaultError:
  parameters: none
  problemMessage: "`null` encountered as case in a switch expression with a non-nullable enum type."

neverReachableSwitchExpressionError:
  parameters: none
  problemMessage: "`null` encountered as case in a switch expression with a non-nullable type."

neverReachableSwitchStatementError:
  parameters: none
  problemMessage: "`null` encountered as case in a switch statement with a non-nullable type."

unsoundSwitchExpressionError:
  parameters: none
  problemMessage: "None of the patterns in the switch expression the matched input value. See https://github.com/dart-lang/language/issues/3488 for details."

unsoundSwitchStatementError:
  parameters: none
  problemMessage: "None of the patterns in the exhaustive switch statement the matched input value. See https://github.com/dart-lang/language/issues/3488 for details."

neverValueError:
  parameters: none
  problemMessage: "`null` encountered as the result from expression with type `Never`."

mainNotFunctionDeclaration:
  parameters: none
  problemMessage: "The 'main' declaration must be a function declaration."
  script:
    - var main;

mainNotFunctionDeclarationExported:
  parameters: none
  problemMessage: "The exported 'main' declaration must be a function declaration."
  exampleAllowOtherCodes: true
  script:
    main.dart:
      export 'lib.dart';
    lib.dart:
      var main;

mainTooManyRequiredParameters:
  parameters: none
  problemMessage: "The 'main' method must have at most 2 required parameters."
  script:
    - main(a, b, c) {}

mainTooManyRequiredParametersExported:
  parameters: none
  problemMessage: "The exported 'main' method must have at most 2 required parameters."
  exampleAllowOtherCodes: true
  script:
    main.dart:
      export 'lib.dart';
    lib.dart:
      main(a, b, c) {}

mainRequiredNamedParameters:
  parameters: none
  problemMessage: "The 'main' method cannot have required named parameters."
  script:
    - main({required a}) {}

mainRequiredNamedParametersExported:
  parameters: none
  problemMessage: "The exported 'main' method cannot have required named parameters."
  exampleAllowOtherCodes: true
  script:
    main.dart:
      export 'lib.dart';
    lib.dart:
      main({required a}) {}

mainWrongParameterType:
  parameters:
    Type actualType: The actual type of the parameter.
    Type expectedType: The expected type of the parameter.
  problemMessage: "The type '#actualType' of the first parameter of the 'main' method is not a supertype of '#expectedType'."
  script:
    - main(Set<String> args) {}

mainWrongParameterTypeExported:
  parameters:
    Type actualType: The actual type of the parameter.
    Type expectedType: The expected type of the parameter.
  problemMessage: "The type '#actualType' of the first parameter of the exported 'main' method is not a supertype of '#expectedType'."
  exampleAllowOtherCodes: true
  script:
    main.dart:
      export 'lib.dart';
    lib.dart:
      main(Set<String> args) {}

exportedMain:
  parameters: none
  problemMessage: "This is exported 'main' declaration."
  severity: CONTEXT

unsupportedDartExt:
  parameters: none
  problemMessage: "Dart native extensions are no longer supported."
  correctionMessage: "Migrate to using FFI instead (https://dart.dev/guides/libraries/c-interop)"
  script: |
    import 'dart-ext:foo.dart';

instantiationNonGenericFunctionType:
  parameters:
    Type operandType: The type of the explicit instantiation operand.
  problemMessage: "The static type of the explicit instantiation operand must be a generic function type but is '#operandType'."
  correctionMessage: "Try changing the operand or remove the type arguments."
  script: |
    f() {}
    main() => f<int>;

instantiationNullableGenericFunctionType:
  parameters:
    Type operandType: The type of the explicit instantiation operand.
  problemMessage: "The static type of the explicit instantiation operand must be a non-null generic function type but is '#operandType'."
  correctionMessage: "Try changing the operand or remove the type arguments."
  script: |
    test(void Function<T>()? f) => f<int>;

instantiationTooFewArguments:
  parameters:
    int expectedCount: The number of type arguments expected.
    int actualCount: The number of type arguments given.
  problemMessage: "Too few type arguments: #expectedCount required, #actualCount given."
  correctionMessage: "Try adding the missing type arguments."
  script: |
    f<X, Y>() {}
    main() => f<int>;

instantiationTooManyArguments:
  parameters:
    int expectedCount: The number of type arguments expected.
    int actualCount: The number of type arguments given.
  problemMessage: "Too many type arguments: #expectedCount allowed, but #actualCount found."
  correctionMessage: "Try removing the extra type arguments."
  script: |
    f<X>() {}
    main() => f<int, String>;

abstractClassConstructorTearOff:
  parameters: none
  problemMessage: "Constructors on abstract classes can't be torn off."
  script: |
    abstract class Class {}
    main() => Class.new;

staticTearOffFromInstantiatedClass:
  parameters: none
  problemMessage: "Cannot access static member on an instantiated generic class."
  correctionMessage: "Try removing the type arguments or placing them after the member name."
  script: |
    class A<X> { static f() {} }
    main() => A<int>.f;


constructorTearOffWithTypeArguments:
  parameters: none
  problemMessage: "A constructor tear-off can't have type arguments after the constructor name."
  correctionMessage: "Try removing the type arguments or placing them after the class name."
  script:
    - "class C<X> { C.foo(); } bar() { C.foo<int>; }"

newAsSelector:
  parameters: none
  problemMessage: "'new' can only be used as a constructor reference."
  script: |
    method(dynamic d) => d.new;

positionalSuperParametersAndArguments:
  parameters: none
  problemMessage: "Positional super-initializer parameters cannot be used when the super initializer has positional arguments."
  script: |
    class Foo {
      Foo(int foo);
    }

    class Bar extends Foo {
      Bar(super.foo) : super(42);
    }

superInitializerParameter:
  parameters: none
  problemMessage: "This is the super-initializer parameter."
  severity: CONTEXT

enumSupertypeOfNonAbstractClass:
  parameters:
    Name className: The name of the problematic class.
  problemMessage: "Non-abstract class '#className' has 'Enum' as a superinterface."
  script: |
    class Foo extends Enum {
      int get index => 42;
    }
  exampleAllowOtherCodes: true

enumNonConstConstructor:
  parameters: none
  problemMessage: "Generative enum constructors must be marked as 'const'."
  script: |
    enum Foo {
      bar;

      Foo();
    }
  exampleAllowOtherCodes: true

enumConstructorSuperInitializer:
  parameters: none
  problemMessage: "Enum constructors can't contain super-initializers."
  script: |
    enum E2 {
      one.named1();

      const E2.named1() : super();
    }

enumConstructorTearoff:
  parameters: none
  problemMessage: "Enum constructors can't be torn off."
  script: |
    enum Foo { a, b, c}
    void bar() {
      Foo.new;
    }

enumFactoryRedirectsToConstructor:
  parameters: none
  problemMessage: "Enum factory constructors can't redirect to generative constructors."
  script: |
    enum E {
      a, b, c;
      const factory E.f3() = E;
    }

enumContainsValuesDeclaration:
  parameters: none
  problemMessage: "An enum can't declare a member named 'values'."
  script: |
    enum E1 {
      element;
      static const List<E1> values = [E1.element];
    }

enumImplementerContainsValuesDeclaration:
  parameters:
    Name className: The name of the problematic class.
  problemMessage: "'#className' has 'Enum' as a superinterface and can't contain non-static member with name 'values'."
  script: |
    mixin M1 on Enum {
      final int values = 42;
    }

enumInheritsRestricted:
  parameters:
    Name memberName: The name of the member that can't be inherited.
  problemMessage: "An enum can't inherit a member named '#memberName'."
  script: |
    mixin class A1 {
      int get hashCode => 42;
    }

    enum E1 with A1 {
      element
    }

enumInheritsRestrictedMember:
  parameters: none
  problemMessage: "This is the inherited member"
  severity: CONTEXT

unmatchedAugmentationClassMember:
  parameters:
    Name memberName: The name of the unmatched augmentation member.
  problemMessage: "Augmentation member '#memberName' doesn't match a member in the augmented class."
  correctionMessage: "Try changing the name to an existing member or removing the 'augment' modifier."
  experiments: augmentations

unmatchedPatchClassMember:
  parameters:
    Name memberName: The name of the unmatched member.
  problemMessage: "Patch member '#memberName' doesn't match a member in the origin class."
  correctionMessage: "Try changing the name to an existing member or removing the '@patch' annotation."

unmatchedAugmentationLibraryMember:
  parameters:
    Name memberName: The name of the unmatched member.
  problemMessage: "Augmentation member '#memberName' doesn't match a member in the augmented library."
  correctionMessage: "Try changing the name to an existing member or removing the 'augment' modifier."
  experiments: augmentations

unmatchedPatchLibraryMember:
  parameters:
    Name memberName: The name of the unmatched member.
  problemMessage: "Patch member '#memberName' doesn't match a member in the origin library."
  correctionMessage: "Try changing the name to an existing member or removing the '@patch' annotation."

unmatchedAugmentationClass:
  parameters:
    Name className: The name of the unmatched class.
  problemMessage: "Augmentation class '#className' doesn't match a class in the augmented library."
  correctionMessage: "Try changing the name to an existing class or removing the 'augment' modifier."
  experiments: augmentations

unmatchedPatchClass:
  parameters:
    Name className: The name of the unmatched class.
  problemMessage: "Patch class '#className' doesn't match a class in the origin library."
  correctionMessage: "Try changing the name to an existing class or removing the '@patch' annotation."

unmatchedAugmentationDeclaration:
  parameters:
    Name declarationName: The name of the unmatched declaration.
  problemMessage: "Augmentation '#declarationName' doesn't match a declaration in the augmented library."
  correctionMessage: "Try changing the name to an existing declaration or removing the 'augment' modifier."
  experiments: macros

unmatchedPatchDeclaration:
  parameters:
    Name declarationName: The name of the unmatched declaration.
  problemMessage: "Patch '#declarationName' doesn't match a declaration in the origin library."
  correctionMessage: "Try changing the name to an existing declaration or removing the '@patch' annotation."

nonAugmentationMemberConflictCause:
  parameters: none
  problemMessage: "This is the existing member."
  severity: CONTEXT

nonAugmentationDeclarationConflictCause:
  parameters: none
  problemMessage: "This is the existing declaration."
  severity: CONTEXT

optionalSuperParameterWithoutInitializer:
  parameters:
    Type superParameterType: The type of the optional super-initializer parameter.
    Name superParameterName: The name of the optional super-initializer parameter.
  problemMessage: "Type '#superParameterType' of the optional super-initializer parameter '#superParameterName' doesn't allow 'null', but the parameter doesn't have a default value, and the default value can't be copied from the corresponding parameter of the super constructor."
  script: |
    class Foo {
      Foo([num x = 3.14]) {}
    }

    class Bar extends Foo {
      Bar([int super.x]);
    }

enumContainsRestrictedInstanceDeclaration:
  parameters:
    Name memberName: The name of the member that cnnot be declared.
  problemMessage: "An enum can't declare a non-abstract member named '#memberName'."
  script: |
    enum E1 {
      element;
      bool operator==(Object other) => true;
    }

enumImplementerContainsRestrictedInstanceDeclaration:
  parameters:
    Name className: The name of the problematic class.
    Name memberName: The name of the restricted static member.
  problemMessage: "'#className' has 'Enum' as a superinterface and can't contain non-static members with name '#memberName'."
  script: |
    class Foo extends Enum {
      int get index => 42;
    }
  exampleAllowOtherCodes: true

enumAbstractMember:
  parameters: none
  problemMessage: "Enums can't declare abstract members."
  script: |
    enum E1 {
      element;
      void foo();
    }

mixinInheritsFromNotObject:
  parameters:
    Name className: The name of the class that can't be used as a mixin.
  problemMessage: "The class '#className' can't be used as a mixin because it extends a class other than 'Object'."
  script: |
    // @dart=2.19
    class Base {}
    class Mixin extends Base {}
    class C extends Base with Mixin {}

mixinApplicationNoConcreteMethod:
  parameters:
    Name memberName: The name of the unimplemented member.
  problemMessage: "The class doesn't have a concrete implementation of the super-invoked member '#memberName'."
  script: |
    class Super {
      void method() {}
    }
    mixin Mixin on Super {
      void method() {
        super.method();
      }
    }
    abstract class AbstractSuper implements Super {}
    class Class extends AbstractSuper with Mixin {}

mixinApplicationNoConcreteGetter:
  parameters:
    Name memberName: The name of the unimplemented member.
  problemMessage: "The class doesn't have a concrete implementation of the super-accessed member '#memberName'."
  script: |
    class Super {
      int get getter => 42;
    }
    mixin Mixin on Super {
      int get getter {
        return super.getter;
      }
    }
    abstract class AbstractSuper implements Super {}
    class Class extends AbstractSuper with Mixin {}

mixinApplicationNoConcreteSetter:
  parameters:
    Name memberName: The name of the unimplemented member.
  problemMessage: "The class doesn't have a concrete implementation of the super-accessed setter '#memberName'."
  script: |
    class Super {
      void set setter(int value) {}
    }
    mixin Mixin on Super {
      void set setter(int value) {
        super.setter = value;
      }
    }
    abstract class AbstractSuper implements Super {}
    class Class extends AbstractSuper with Mixin {}

mixinApplicationNoConcreteMemberContext:
  parameters: none
  problemMessage: "This is the super-access that doesn't have a concrete target."
  severity: CONTEXT

noAugmentSuperReadTarget:
  parameters: none
  problemMessage: "Cannot read from 'augment super'."
  experiments: augmentations

noAugmentSuperWriteTarget:
  parameters: none
  problemMessage: "Cannot write to 'augment super'."
  experiments: augmentations

noAugmentSuperInvokeTarget:
  parameters: none
  problemMessage: "Cannot call 'augment super'."
  experiments: augmentations

indexOutOfBoundInRecordIndexGet:
  parameters:
    int index: The index that was used.
    int positionalFieldCount: The number of positional fields.
    Type recordType: The record type in question.
  problemMessage: "Index #index is out of range 0..#positionalFieldCount of positional fields of records #recordType."

nameNotFoundInRecordNameGet:
  parameters:
    String fieldName: The field name that was not found.
    Type recordType: The record type in question.
  problemMessage: "Field name #fieldName isn't found in records of type #recordType."

objectMemberNameUsedForRecordField:
  parameters: none
  problemMessage: "Record field names can't be the same as a member from 'Object'."
  script: |
    (int hashCode,) foo1() => throw 0;

recordFieldsCantBePrivate:
  parameters: none
  problemMessage: "Record field names can't be private."
  script: |
    foo() => (_bar: 1);

namedFieldClashesWithPositionalFieldInRecord:
  parameters: none
  problemMessage: "Record field names can't be a dollar sign followed by an integer when integer is the index of a positional field."
  script: |
    foo() => (0, $1: 0);

enumWithNameValues:
  parameters: none
  problemMessage: "The name 'values' is not a valid name for an enum. Try using a different name."
  script: |
    enum values {
      foo, bar;
    }
  exampleAllowOtherCodes: true

inheritedRestrictedMemberOfEnumImplementer:
  parameters:
    Name memberName: The name of the restricted member.
    Name superclassName: The name of the superclass the restricted member can't be inherited from.
  problemMessage: "A concrete instance member named '#memberName' can't be inherited from '#superclassName' in a class that implements 'Enum'."
  script: |
    abstract class A { int get hashCode => 0; }
    abstract class B extends A implements Enum {}

sealedClassSubtypeOutsideOfLibrary:
  parameters:
    Name sealedClassName: The name of the sealed class.
  problemMessage: "The class '#sealedClassName' can't be extended, implemented, or mixed in outside of its library because it's a sealed class."
  script:
    main.dart:
      import 'lib.dart';
      class B extends A {}
    lib.dart:
      sealed class A {}

cantUseClassAsMixin:
  parameters:
    Name className: The name of the class that can't be used as a mixin.
  problemMessage: "The class '#className' can't be used as a mixin because it isn't a mixin class nor a mixin."
  script:
    main.dart:
      import 'lib.dart';
      class B with A {}
    lib.dart:
      class A {}

baseClassImplementedOutsideOfLibrary:
  parameters:
    Name typeName: The name of the class that can't be implemented outside of its library.
  problemMessage: "The class '#typeName' can't be implemented outside of its library because it's a base class."
  script:
    main.dart:
      import 'lib.dart';
      base class B implements A {}
    lib.dart:
      base class A {}

baseOrFinalClassImplementedOutsideOfLibraryCause:
  parameters:
    Name subtypeName: The name of the subtype.
    Name causeName: The name of the supertype, which is the cause being identified by this context message.
  problemMessage: "The type '#subtypeName' is a subtype of '#causeName', and '#causeName' is defined here."
  severity: CONTEXT

baseMixinImplementedOutsideOfLibrary:
  parameters:
    Name typeName: The name of the mixin that can't be implemented outside of its library.
  problemMessage: "The mixin '#typeName' can't be implemented outside of its library because it's a base mixin."
  script:
    main.dart:
      import 'lib.dart';
      base class B implements A {}
    lib.dart:
      base mixin A {}

interfaceClassExtendedOutsideOfLibrary:
  parameters:
    Name interfaceClassName: The name of the class that can't be extended outsibe of its library.
  problemMessage: "The class '#interfaceClassName' can't be extended outside of its library because it's an interface class."
  script:
    main.dart:
      import 'lib.dart';
      class B extends A {}
    lib.dart:
      interface class A {}

finalClassExtendedOutsideOfLibrary:
  parameters:
    Name className: The name of the class that can't be extended outside its library.
  problemMessage: "The class '#className' can't be extended outside of its library because it's a final class."
  script:
    main.dart:
      import 'lib.dart';
      final class B extends A {}
    lib.dart:
      final class A {}

finalClassImplementedOutsideOfLibrary:
  parameters:
    Name className: The name of the class that can't be implemented outside of its library.
  problemMessage: "The class '#className' can't be implemented outside of its library because it's a final class."
  script:
    main.dart:
      import 'lib.dart';
      final class B implements A {}
    lib.dart:
      final class A {}

finalClassUsedAsMixinConstraintOutsideOfLibrary:
  parameters:
    Name className: The name of the class that can't be used as a mixin superclass constraint outside of its library.
  problemMessage: "The class '#className' can't be used as a mixin superclass constraint outside of its library because it's a final class."
  script:
    main.dart:
      import 'lib.dart';
      base mixin B on A {}
    lib.dart:
      final class A {}

subtypeOfBaseIsNotBaseFinalOrSealed:
  parameters:
    Name className: The name of the problematic class.
    Name superclassName: The name of the superclass that is `base`.
  problemMessage: "The type '#className' must be 'base', 'final' or 'sealed' because the supertype '#superclassName' is 'base'."
  correctionMessage: "Try adding 'base', 'final', or 'sealed' to the type."
  script: |
      base class A {}
      class B extends A {}

subtypeOfFinalIsNotBaseFinalOrSealed:
  parameters:
    Name typeName: The name of the problematic type.
    Name supertypeName: The name of the supertype that is `final`.
  problemMessage: "The type '#typeName' must be 'base', 'final' or 'sealed' because the supertype '#supertypeName' is 'final'."
  correctionMessage: "Try adding 'base', 'final', or 'sealed' to the type."
  script: |
      final class A {}
      class B extends A {}

mixinSubtypeOfBaseIsNotBase:
  parameters:
    Name className: The name of the problematic class.
    Name superclassName: The name of the superclass that is `base`.
  problemMessage: "The mixin '#className' must be 'base' because the supertype '#superclassName' is 'base'."
  correctionMessage: "Try adding 'base' to the mixin."
  script: |
      base class A {}
      mixin B implements A {}

mixinSubtypeOfFinalIsNotBase:
  parameters:
    Name typeName: The name of the problematic mixin.
    Name supertypeName: The name of the supertype that is `final`.
  problemMessage: "The mixin '#typeName' must be 'base' because the supertype '#supertypeName' is 'final'."
  correctionMessage: "Try adding 'base' to the mixin."
  script: |
      final class A {}
      mixin B implements A {}

unspecifiedGetterNameInObjectPattern:
  parameters: none
  problemMessage: "The getter name is not specified explicitly, and the pattern is not a variable. Try specifying the getter name explicitly, or using a variable pattern."
  script: |
    abstract class A { int get foo;}
    test(dynamic x) { if (x case A(: 0)) {} }

jointPatternVariablesMismatch:
  parameters:
    Name variableName: The name of the problematic variable.
  problemMessage: "Variable pattern '#variableName' doesn't have the same type or finality in all cases."
  script: |
    test(dynamic x) { switch (x) { case [int a]: case [double a] : return a; default: return null; } }

nonExhaustiveSwitchExpression:
  parameters:
    Type scrutineeType: The type of the scrutinee.
    String witness: Witness of the type that is not matched.
    String correction: Correction for the type that is not matched.
  problemMessage: "The type '#scrutineeType' is not exhaustively matched by the switch cases since it doesn't match '#witness'."
  correctionMessage: "Try adding a wildcard pattern or cases that match '#correction'."
  script: |
    enum Enum { a, b }
    String method(Enum e) => switch (e) {
        Enum.a => 'a',
      };

nonExhaustiveSwitchStatement:
  parameters:
    Type scrutineeType: The type of the scrutinee.
    String witness: Witness of the type that is not matched.
    String correction: Correction for the type that is not matched.
  problemMessage: "The type '#scrutineeType' is not exhaustively matched by the switch cases since it doesn't match '#witness'."
  correctionMessage: "Try adding a default case or cases that match '#correction'."
  script: |
    enum Enum { a, b }
    method(Enum e) {
      switch (e) {
        case Enum.a:
          break;
      }
    }

patternTypeMismatchInIrrefutableContext:
  parameters:
    Type actualType: The matched value type.
    Type expectedType: The type that the matched value isn't assignable to.
  problemMessage: "The matched value of type '#actualType' isn't assignable to the required type '#expectedType'."
  correctionMessage: "Try changing the required type of the pattern, or the matched value type."
  script: |
    method(List<String> list) {
      var <int>[a] = list;
    }

duplicatePatternAssignmentVariable:
  parameters:
    Name variableName: The name of the already-assigned variable.
  problemMessage: The variable '#variableName' is already assigned in this pattern.
  correctionMessage: Try renaming the variable.
  script: |
    method(List<String> list) {
      String a = '';
      [a, a] = list;
    }

duplicatePatternAssignmentVariableContext:
  parameters: none
  problemMessage: The first assigned variable pattern.
  severity: CONTEXT

duplicateRecordPatternField:
  parameters:
    Name fieldName: The name of the duplicated field.
  problemMessage: The field '#fieldName' is already matched in this pattern.
  correctionMessage: Try removing the duplicate field.
  script: |
    method(o) {
      switch (o) {
        case (field: 1, field: 2):
      }
    }

duplicateRecordPatternFieldContext:
  parameters: none
  problemMessage: The first field.
  severity: CONTEXT

duplicateRestElementInPattern:
  parameters: none
  problemMessage: At most one rest element is allowed in a list or map pattern.
  correctionMessage: Try removing the duplicate rest element.
  script: |
    method(o) {
      switch (o) {
        case [..., ...]:
      }
    }

duplicateRestElementInPatternContext:
  parameters: none
  problemMessage: The first rest element.
  severity: CONTEXT

restPatternInMapPattern:
  parameters: none
  problemMessage: "The '...' pattern can't appear in map patterns."
  script: |
    test(dynamic x) { if (x case {1: 1, ...}) {} }

nonBoolCondition:
  parameters: none
  problemMessage: "Conditions must have a static type of 'bool'."
  correctionMessage: Try changing the condition.
  script: |
    method(int i) {
      if (i case 5 when i) {}
    }

refutablePatternInIrrefutableContext:
  parameters: none
  problemMessage: Refutable patterns can't be used in an irrefutable context.
  correctionMessage: Try using an if-case, a 'switch' statement, or a 'switch' expression instead.
  script: |
    method(int? x) {
      var (a?) = x;
    }

missingVariablePattern:
  parameters:
    Name variableName: The name of the variable that's missing in this branch of the logical-or pattern.
  problemMessage: "Variable pattern '#variableName' is missing in this branch of the logical-or pattern."
  correctionMessage: "Try declaring this variable pattern in the branch."
  script: |
    method(x) {
      if (x case [var a] || _) {}
    }

mapPatternTypeArgumentMismatch:
  parameters: none
  problemMessage: "A map pattern requires exactly two type arguments."
  script: |
    method(x) {
      if (x case <int>{0: 0}) {}
    }

listPatternTooManyTypeArguments:
  parameters: none
  problemMessage: "A list pattern requires exactly one type argument."
  script: |
    method(x) {
      if (x case <int, int>[]) {}
    }

unnamedObjectPatternField:
  parameters: none
  problemMessage: "A pattern field in an object pattern must be named."
  correctionMessage: "Try adding a pattern name or ':' before the pattern."
  script: |
    method(x) {
      if (x case int(5)) {}
    }

patternAssignmentNotLocalVariable:
  parameters: none
  problemMessage: Only local variables or formal parameters can be used in pattern assignments.
  correctionMessage: Try assigning to a local variable.
  script: |
    var global;
    method(x) {
      [global] = x;
    }

recordUseCannotBePlacedHere:
  parameters: none
  problemMessage: "`RecordUse` annotation cannot be placed on this element."

recordUseOutsideOfPackage:
  parameters: none
  problemMessage: "`RecordUse` annotations are only supported in libraries with a `package:` URI."

recordUseClassesMustBeFinal:
  # Used by RecordUse validation
  parameters: none
  problemMessage: "Classes marked with '@RecordUse' must be final."
  correctionMessage: "Try marking the class as 'final' or removing the '@RecordUse' annotation."

recordUseSubtypingNotSupported:
  # Used by RecordUse validation
  parameters:
    Name name: The name of the recorded class.
  problemMessage: "Class '#name' is marked with '@RecordUse' and cannot be used as a supertype."
  correctionMessage: "Try removing the supertype or removing the '@RecordUse' annotation from '#name'."

wasmImportOrExportInUserCode:
  parameters: none
  problemMessage: "Pragmas `wasm:import` and `wasm:export` are for internal use only and cannot be used by user code."

wasmExternMemoryMissingAnnotation:
  parameters: none
  problemMessage: "This external getter returns a memory instance, but no annotation describing it was found"
  correctionMessage: "Try adding a `@MemoryType()` or `@Import.memory()` annotation."

wasmExternInvalidLoad:
  parameters: none
  problemMessage: "WebAssembly elements may only be referenced to directly call a method on them."

wasmExternInvalidTarget:
  parameters: none
  problemMessage: "The receiver of this call must be a top-level variable describing the WebAssembly element."

wasmIntrinsicTearOff:
  parameters: none
  problemMessage: This intrinsic extension member may not be torn off.

weakReferenceNotStatic:
  parameters: none
  problemMessage: "Weak reference pragma can be used on a static method only."
  script: |
    class A {
      @pragma('weak-tearoff-reference')
      external T Function()? weakReference12<T>(T Function()? x);
    }

weakReferenceNotOneArgument:
  parameters: none
  problemMessage: "Weak reference should take one required positional argument."
  script: |
    @pragma('weak-tearoff-reference')
    Function? weakRef1({Function? x}) => x;

weakReferenceReturnTypeNotNullable:
  parameters: none
  problemMessage: "Return type of a weak reference should be nullable."
  script: |
    @pragma('weak-tearoff-reference')
    Function weakRef(Function x) => x;

weakReferenceMismatchReturnAndArgumentTypes:
  parameters: none
  problemMessage: "Return and argument types of a weak reference should match."
  script: |
    @pragma('weak-tearoff-reference')
    Function? weakRef(void Function() x) => x;

weakReferenceTargetNotStaticTearoff:
  parameters: none
  problemMessage: "The target of weak reference should be a tearoff of a static method."
  script: |
    @pragma('weak-tearoff-reference')
    Function? validWeakRef(Function? x) => x;
    class B {}
    void foo() {
      validWeakRef(B.new);
    }

weakReferenceTargetHasParameters:
  parameters: none
  problemMessage: "The target of weak reference should not take parameters."
  script: |
    @pragma('weak-tearoff-reference')
    Function? validWeakRef(Function? x) => x;
    class B {
      static int arg1(int x) => 42;
    }
    void foo() {
      validWeakRef(B.arg1);
    }

obsoleteColonForDefaultValue:
  parameters: none
  problemMessage: "Using a colon as a separator before a default value is no longer supported."
  correctionMessage: "Try replacing the colon with an equal sign."
  script: |
    method({int x: 3}) {}

equalKeysInMapPattern:
  parameters: none
  problemMessage: Two keys in a map pattern can't be equal.
  correctionMessage: Change or remove the duplicate key.
  script: |
    method(o) {
      if (o case {1: 'foo', 1: 'bar'}) {}
    }

equalKeysInMapPatternContext:
  parameters: none
  problemMessage: This is the previous use of the same key.
  severity: CONTEXT

patternMatchingError:
  parameters: none
  problemMessage: "Pattern matching error"

emptyMapPattern:
  parameters: none
  problemMessage: A map pattern must have at least one entry.
  correctionMessage: Try replacing it with an object pattern 'Map()'.
  script: |
    method(Map m) => switch (m) {
        {} => 0,
        _ => 1,
      };

patternVariableAssignmentInsideGuard:
  parameters: none
  problemMessage: Pattern variables can't be assigned inside the guard of the enclosing guarded pattern.
  correctionMessage: Try assigning to a different variable.
  script: |
    method(o) => switch (o) {
      int i when (i = 5) > 0 => 0,
      _ => -1,
    };

jointPatternVariableNotInAll:
  parameters:
    Name variableName: The name of the variable that's not available in all cases that share this body.
  problemMessage: "The variable '#variableName' is available in some, but not all cases that share this body."
  script: |
    test(x) { switch(x) { case var a: case < 0: case [var a]: return a; default: return null; } }

jointPatternVariableWithLabelDefault:
  parameters:
    Name variableName: The name of the variable that's not available due to a label or `default` case.
  problemMessage: "The variable '#variableName' is not available because there is a label or 'default' case."
  script: |
    test(x) { switch(x) { case var a: default: return a; } }

scriptTagInPartFile:
  parameters: none
  problemMessage: "A part file cannot have script tag."
  correctionMessage: "Try removing the script tag or the 'part of' directive."
  script:
    main.dart: |
      part 'part.dart';
    part.dart: |
      #!dart
      part of 'main.dart';

nonCovariantTypeParameterInRepresentationType:
  parameters: none
  problemMessage: "An extension type parameter can't be used non-covariantly in its representation type."
  correctionMessage: "Try removing the type parameters from function parameter types and type parameter bounds."
  script: |
    extension type E<T>(void Function(T) f) {}

cyclicRepresentationDependency:
  parameters: none
  problemMessage: "An extension type can't depend on itself through its representation type."
  script: |
    extension type E(E it) {}

extensionTypeDeclarationCause:
  parameters: none
  problemMessage: "The issue arises via this extension type declaration."
  severity: CONTEXT

invalidExtensionTypeSuperInterface:
  parameters:
    Type interfaceType: The implemented interface type.
    Type representationType: The representation type.
    Name extensionTypeName: The extension type name.
  problemMessage: "The implemented interface '#interfaceType' must be a supertype of the representation type '#representationType' of extension type '#extensionTypeName'."
  correctionMessage: "Try changing the interface type to a supertype of '#representationType' or the representation type to a subtype of '#interfaceType'."
  script: |
    extension type E(num n) implements int {}

invalidExtensionTypeSuperExtensionType:
  parameters:
    Type representationType: The extension type's representation type.
    Name extensionTypeName: The name of the problematic extension type.
    Type implementedExtensionRepresentationType: The representation type of the implemented extension type.
    Type implementedExtensionType: The implemented extension type.
  problemMessage: "The representation type '#representationType' of extension type '#extensionTypeName' must be either a subtype of the representation type '#implementedExtensionRepresentationType' of the implemented extension type '#implementedExtensionType' or a subtype of '#implementedExtensionType' itself."
  correctionMessage: "Try changing the representation type to a subtype of '#implementedExtensionRepresentationType'."
  script: |
    extension type E1(int i) {}
    extension type E2(num n) implements E1 {}

localVariableUsedBeforeDeclared:
  parameters:
    Name variableName: The name of the not-yet-declared variable.
  problemMessage: "Local variable '#variableName' can't be referenced before it is declared."
  script: |
    foo(dynamic x, dynamic y) { y = x; dynamic x; }

localVariableUsedBeforeDeclaredContext:
  parameters:
    Name variableName: The name of the problematic variable.
  problemMessage: "This is the declaration of the variable '#variableName'."
  severity: CONTEXT

implementNonExtensionTypeAndExtensionTypeMember:
  parameters:
    Name extensionTypeName: The name of the extension type.
    Name memberName: The name of the member that is being inherited from both an extension type member and a non-extension type member.
  problemMessage: "The extension type '#extensionTypeName' can't inherit the member '#memberName' as both an extension type member and a non-extension type member."
  correctionMessage: "Try declaring a member '#memberName' in '#extensionTypeName' to resolve the conflict."
  script: |
    class Class {
      void method() {}
    }
    extension type ExtensionType(Class c) {
      void method() {}
    }
    extension type ExtensionType1(Class c) implements Class, ExtensionType {}

extensionTypeMemberContext:
  parameters: none
  problemMessage: "This is the inherited extension type member."
  severity: CONTEXT

extensionTypeMemberOneOfContext:
  parameters: none
  problemMessage: "This is one of the inherited extension type members."
  severity: CONTEXT

nonExtensionTypeMemberContext:
  parameters: none
  problemMessage: "This is the inherited non-extension type member."
  severity: CONTEXT

nonExtensionTypeMemberOneOfContext:
  parameters: none
  problemMessage: "This is one of the inherited non-extension type members."
  severity: CONTEXT

implementMultipleExtensionTypeMembers:
  parameters:
    Name extensionTypeName: The name of the problematic extension type.
    Name memberName: The name of the member that can't be inherited from more than one extension type.
  problemMessage: "The extension type '#extensionTypeName' can't inherit the member '#memberName' from more than one extension type."
  correctionMessage: "Try declaring a member '#memberName' in '#extensionTypeName' to resolve the conflict."
  script: |
    extension type ExtensionType1(int i) {
      void method() {}
    }
    extension type ExtensionType2(int i) {
      void method() {}
    }
    extension type ExtensionType3(int i) implements ExtensionType1, ExtensionType2 {}

representationFieldModifier:
  parameters: none
  problemMessage: "Representation fields can't have modifiers."
  script: |
    extension type E(final int foo) {}

expectedRepresentationType:
  parameters: none
  problemMessage: "Expected a representation type."
  script: |
    extension type E(var foo) {}

expectedRepresentationField:
  parameters: none
  problemMessage: "Expected a representation field."
  script: |
    extension type E() {}

multipleRepresentationFields:
  parameters: none
  problemMessage: "Each extension type should have exactly one representation field."
  script: |
    extension type E(int foo, String bar) {}

extensionTypeConstructorWithSuperFormalParameter:
  parameters: none
  problemMessage: "Extension type constructors can't declare super formal parameters."
  script: |
    extension type A(int foo) { A.named(this.foo, super.bar); }

extensionTypePrimaryConstructorWithInitializingFormal:
  parameters: none
  problemMessage: "Primary constructors in extension types can't use initializing formals."
  correctionMessage: "Try removing `this.` from the formal parameter."
  script: |
    extension type A(int this.foo) { }

extensionTypePrimaryConstructorFunctionFormalParameterSyntax:
  parameters: none
  problemMessage: "Primary constructors in extension types can't use function formal parameter syntax."
  correctionMessage: "Try rewriting with an explicit function type, like `int Function() f`."
  script: |
    extension type A(int foo()) { }

extensionTypeRepresentationTypeBottom:
  parameters: none
  problemMessage: "The representation type can't be a bottom type."
  script: |
    extension type E1(Never foo) {}

representationFieldTrailingComma:
  parameters: none
  problemMessage: "The representation field can't have a trailing comma."
  script: |
    extension type E(int foo,) {}

wrongTypeParameterVarianceInSuperinterface:
  parameters:
    Name typeVariableName: The name of the problematic type variable.
    Type type: The type in which the type variable is used contravariantly or invariantly.
  problemMessage: "'#typeVariableName' can't be used contravariantly or invariantly in '#type'."
  script: |
    extension type E<X>(List<Function(Object?)> foo) implements List<Function(X)> {}

awaitOfExtensionTypeNotFuture:
  parameters: none
  problemMessage: "The 'await' expression can't be used for an expression with an extension type that is not a subtype of 'Future'."
  script: |
    extension type E(num foo) { test(E e) async { await e; } }

namedParametersInExtensionTypeDeclaration:
  parameters: none
  problemMessage: "Extension type declarations can't have named parameters."
  script: |
    extension type E(int foo, {dynamic bar}) {}

optionalParametersInExtensionTypeDeclaration:
  parameters: none
  problemMessage: "Extension type declarations can't have optional parameters."
  script: |
    extension type E(int foo, [dynamic bar]) {}

classImplementsDeferredClass:
  parameters: none
  problemMessage: "Classes and mixins can't implement deferred classes."
  correctionMessage: Try specifying a different interface, removing the class from the list, or changing the import to not be deferred.
  script:
    main.dart: |
      import 'lib.dart' deferred as d;
      class B implements d.A {}
    lib.dart: |
      class A {}

mixinDeferredMixin:
  parameters: none
  problemMessage: "Classes can't mix in deferred mixins."
  correctionMessage: Try changing the import to not be deferred.
  script:
    main.dart: |
      import 'lib.dart' deferred as d;
      class B with d.A {}
    lib.dart: |
      mixin A {}

mixinSuperClassConstraintDeferredClass:
  parameters: none
  problemMessage: "Deferred classes can't be used as superclass constraints."
  correctionMessage: Try changing the import to not be deferred.
  script:
    main.dart: |
      import 'lib.dart' deferred as d;
      mixin B on d.A {}
    lib.dart: |
      class A {}

extendsDeferredClass:
  parameters: none
  problemMessage: "Classes can't extend deferred classes."
  correctionMessage: Try specifying a different superclass, or removing the extends clause.
  script:
    main.dart: |
      import 'lib.dart' deferred as d;
      class B extends d.A {}
    lib.dart: |
      class A {}

extensionTypeImplementsDeferred:
  parameters: none
  problemMessage: "Extension types can't implement deferred types."
  correctionMessage: Try specifying a different type, removing the type from the list, or changing the import to not be deferred.
  script:
    main.dart: |
      import 'lib.dart' deferred as d;
      extension type ET(d.A id) implements d.A {}
    lib.dart: |
      class A {}
  exampleAllowOtherCodes: true

recordUsedAsCallable:
  parameters: none
  problemMessage: "The 'call' property on the record type isn't directly callable but could be invoked by `.call(...)`"
  script: |
    test(({dynamic call}) r) => r(0);

experimentExpiredEnabled:
  parameters:
    Name experimentName: The name of the expired experiment.
  problemMessage: "The experiment '#experimentName' has expired and can't be enabled."

experimentExpiredDisabled:
  parameters:
    Name experimentName: The name of the expired experiment.
  problemMessage: "The experiment '#experimentName' has expired and can't be disabled."

dartFfiLibraryInDart2Wasm:
  parameters: none
  problemMessage: "'dart:ffi' can't be imported when compiling to Wasm."

unexpectedSuperParametersInGenerativeConstructors:
  parameters: none
  problemMessage: "Super parameters can only be used in non-redirecting generative constructors."
  script: |
    class A { A(); A.named(super.x) : this(); }

missingPositionalSuperConstructorParameter:
  parameters: none
  problemMessage: "The super constructor has no corresponding positional parameter."
  script: |
    class A { A(); } class B { B(super.foo); }

missingNamedSuperConstructorParameter:
  parameters: none
  problemMessage: "The super constructor has no corresponding named parameter."
  script: |
    class A { A(); } class B { B({super.foo}); }

implicitSuperInitializerMissingArguments:
  parameters:
    Name className: The name of the class containing the implicitly called unnamed constructor.
  problemMessage: "The implicitly called unnamed constructor from '#className' has required parameters."
  correctionMessage: "Try adding an explicit super initializer with the required arguments."
  script: |
    class A { A(int foo); } class B extends A { B(); }

dotShorthandsConstructorInvocationWithTypeArguments:
  parameters: none
  problemMessage: "A dot shorthand constructor invocation can't have type arguments."
  correctionMessage: "Try adding the class name and type arguments explicitly before the constructor name."
  script: |
    class C<X> {
      C.foo();
    }
    void main() {
      C c = .foo<int>();
    }

dotShorthandsInvalidContext:
  parameters:
    Name dotShorthandName: The name of the dot shorthand that was sought.
  problemMessage: "No type was provided to find the dot shorthand '#dotShorthandName'."
  script: |
    void main() {
      var x = .one;
    }

dotShorthandsUndefinedGetter:
  parameters:
    Name getterName: The name of the getter (or field) that isn't defined.
    Type contextType: The dot shorthand context type in which the getter was sought.
  problemMessage: "The static getter or field '#getterName' isn't defined for the type '#contextType'."
  correctionMessage: "Try correcting the name to the name of an existing static getter or field, or defining a getter or field named '#getterName'."
  script: |
    class C {
      C get foo => C();
    }
    void main() {
      C c = .foo;
    }

dotShorthandsUndefinedInvocation:
  parameters:
    Name memberName: The name of the static method or constructor that was sought.
    Type contextType: The dot shorthand context type in which the static method or constructor was sought.
  problemMessage: "The static method or constructor '#memberName' isn't defined for the type '#contextType'."
  correctionMessage: "Try correcting the name to the name of an existing static method or constructor, or defining a static method or constructor named '#memberName'."
  script: |
    class C {
      C foo() => C();
    }
    void main() {
      C c = .foo();
    }

expressionEvaluationKnownVariableUnavailable:
  parameters:
    Name variableName: The name of the unavailable variable.
  problemMessage: "The variable '#variableName' is unavailable in this expression evaluation."

partOfName:
  parameters: none
  problemMessage: "The 'part of' directive can't use a name with the enhanced-parts feature."
  correctionMessage: "Try using 'part of' with a URI instead."
  experiments: enhanced-parts
  script:
    main.dart: |
      library lib;
      part 'lib.dart';
    lib.dart: |
      part of lib;

partWithLibraryDirective:
  parameters: none
  problemMessage: "A part cannot have a library directive."
  correctionMessage: "Try removing the library directive."
  script:
    main.dart: |
      library lib;
      part 'lib.dart';
    lib.dart: |
      library;
      part of 'main.dart';
