parseUnit(augment)
  skipErrorTokens(augment)
  listener: beginCompilationUnit(augment)
  syntheticPreviousToken(augment)
  parseTopLevelDeclarationImpl(, DirectiveContext(DirectiveState.Unknown))
    parseMetadataStar()
      listener: beginMetadataStar(augment)
      listener: endMetadataStar(0)
    parseTopLevelMemberImpl()
      listener: beginTopLevelMember(augment)
      reportRecoverableErrorWithToken(augment, Template(DuplicatedModifier))
        listener: handleRecoverableError(Message[DuplicatedModifier, The modifier 'augment' was already specified., Try removing all but one occurrence of the modifier., {lexeme: augment}], augment, augment)
      isReservedKeyword(()
      parseTopLevelMethod(, augment, null, augment, NoType(), null, method, false)
        listener: beginTopLevelMethod(, augment, null)
        listener: handleNoType(augment)
        ensureIdentifierPotentiallyRecovered(augment, topLevelFunctionDeclaration, false)
          listener: handleIdentifier(method, topLevelFunctionDeclaration)
        parseMethodTypeVar(method)
          listener: handleNoTypeVariables(()
        parseGetterOrFormalParameters(method, method, false, MemberKind.TopLevelMethod)
          parseFormalParameters(method, MemberKind.TopLevelMethod)
            parseFormalParametersRest((, MemberKind.TopLevelMethod)
              listener: beginFormalParameters((, MemberKind.TopLevelMethod)
              listener: endFormalParameters(0, (, ), MemberKind.TopLevelMethod)
        parseAsyncModifierOpt())
          listener: handleAsyncModifier(null, null)
          inPlainSync()
        parseFunctionBody(), false, false)
          listener: beginBlockFunctionBody({)
          notEofOrValue(}, })
          listener: endBlockFunctionBody(0, {, })
        listener: endTopLevelMethod(augment, null, })
  listener: endTopLevelDeclaration(augment)
  parseTopLevelDeclarationImpl(}, DirectiveContext(DirectiveState.Declarations))
    parseMetadataStar(})
      listener: beginMetadataStar(augment)
      listener: endMetadataStar(0)
    parseTopLevelMemberImpl(})
      listener: beginTopLevelMember(augment)
      reportRecoverableError(external, Message[ConflictingModifiers, Members can't be declared to be both 'external' and 'augment'., Try removing one of the keywords., {string: external, string2: augment}])
        listener: handleRecoverableError(Message[ConflictingModifiers, Members can't be declared to be both 'external' and 'augment'., Try removing one of the keywords., {string: external, string2: augment}], external, external)
      isReservedKeyword(()
      parseTopLevelMethod(}, augment, external, external, NoType(), null, method, false)
        listener: beginTopLevelMethod(}, augment, external)
        listener: handleNoType(external)
        ensureIdentifierPotentiallyRecovered(external, topLevelFunctionDeclaration, false)
          listener: handleIdentifier(method, topLevelFunctionDeclaration)
        parseMethodTypeVar(method)
          listener: handleNoTypeVariables(()
        parseGetterOrFormalParameters(method, method, false, MemberKind.TopLevelMethod)
          parseFormalParameters(method, MemberKind.TopLevelMethod)
            parseFormalParametersRest((, MemberKind.TopLevelMethod)
              listener: beginFormalParameters((, MemberKind.TopLevelMethod)
              listener: endFormalParameters(0, (, ), MemberKind.TopLevelMethod)
        parseAsyncModifierOpt())
          listener: handleAsyncModifier(null, null)
          inPlainSync()
        parseFunctionBody(), false, true)
          listener: handleEmptyFunctionBody(;)
        listener: endTopLevelMethod(augment, null, ;)
  listener: endTopLevelDeclaration(external)
  parseTopLevelDeclarationImpl(;, DirectiveContext(DirectiveState.Declarations))
    parseMetadataStar(;)
      listener: beginMetadataStar(external)
      listener: endMetadataStar(0)
    parseTopLevelMemberImpl(;)
      listener: beginTopLevelMember(external)
      reportRecoverableError(augment, Message[ConflictingModifiers, Members can't be declared to be both 'augment' and 'external'., Try removing one of the keywords., {string: augment, string2: external}])
        listener: handleRecoverableError(Message[ConflictingModifiers, Members can't be declared to be both 'augment' and 'external'., Try removing one of the keywords., {string: augment, string2: external}], augment, augment)
      isReservedKeyword(()
      parseTopLevelMethod(;, augment, external, augment, NoType(), null, method, false)
        listener: beginTopLevelMethod(;, augment, external)
        listener: handleNoType(augment)
        ensureIdentifierPotentiallyRecovered(augment, topLevelFunctionDeclaration, false)
          listener: handleIdentifier(method, topLevelFunctionDeclaration)
        parseMethodTypeVar(method)
          listener: handleNoTypeVariables(()
        parseGetterOrFormalParameters(method, method, false, MemberKind.TopLevelMethod)
          parseFormalParameters(method, MemberKind.TopLevelMethod)
            parseFormalParametersRest((, MemberKind.TopLevelMethod)
              listener: beginFormalParameters((, MemberKind.TopLevelMethod)
              listener: endFormalParameters(0, (, ), MemberKind.TopLevelMethod)
        parseAsyncModifierOpt())
          listener: handleAsyncModifier(null, null)
          inPlainSync()
        parseFunctionBody(), false, true)
          listener: handleEmptyFunctionBody(;)
        listener: endTopLevelMethod(external, null, ;)
  listener: endTopLevelDeclaration(augment)
  parseTopLevelDeclarationImpl(;, DirectiveContext(DirectiveState.Declarations))
    parseMetadataStar(;)
      listener: beginMetadataStar(augment)
      listener: endMetadataStar(0)
    parseTopLevelMemberImpl(;)
      listener: beginTopLevelMember(augment)
      reportRecoverableErrorWithToken(augment, Template(DuplicatedModifier))
        listener: handleRecoverableError(Message[DuplicatedModifier, The modifier 'augment' was already specified., Try removing all but one occurrence of the modifier., {lexeme: augment}], augment, augment)
      parseTopLevelMethod(;, augment, null, augment, VoidType(), null, method, false)
        listener: beginTopLevelMethod(;, augment, null)
        listener: handleVoidKeyword(void)
        ensureIdentifierPotentiallyRecovered(void, topLevelFunctionDeclaration, false)
          listener: handleIdentifier(method, topLevelFunctionDeclaration)
        parseMethodTypeVar(method)
          listener: handleNoTypeVariables(()
        parseGetterOrFormalParameters(method, method, false, MemberKind.TopLevelMethod)
          parseFormalParameters(method, MemberKind.TopLevelMethod)
            parseFormalParametersRest((, MemberKind.TopLevelMethod)
              listener: beginFormalParameters((, MemberKind.TopLevelMethod)
              listener: endFormalParameters(0, (, ), MemberKind.TopLevelMethod)
        parseAsyncModifierOpt())
          listener: handleAsyncModifier(null, null)
          inPlainSync()
        parseFunctionBody(), false, false)
          listener: beginBlockFunctionBody({)
          notEofOrValue(}, })
          listener: endBlockFunctionBody(0, {, })
        listener: endTopLevelMethod(augment, null, })
  listener: endTopLevelDeclaration(augment)
  parseTopLevelDeclarationImpl(}, DirectiveContext(DirectiveState.Declarations))
    parseMetadataStar(})
      listener: beginMetadataStar(augment)
      listener: endMetadataStar(0)
    parseTopLevelMemberImpl(})
      listener: beginTopLevelMember(augment)
      reportRecoverableError(external, Message[ConflictingModifiers, Members can't be declared to be both 'external' and 'augment'., Try removing one of the keywords., {string: external, string2: augment}])
        listener: handleRecoverableError(Message[ConflictingModifiers, Members can't be declared to be both 'external' and 'augment'., Try removing one of the keywords., {string: external, string2: augment}], external, external)
      parseTopLevelMethod(}, augment, external, external, VoidType(), null, method, false)
        listener: beginTopLevelMethod(}, augment, external)
        listener: handleVoidKeyword(void)
        ensureIdentifierPotentiallyRecovered(void, topLevelFunctionDeclaration, false)
          listener: handleIdentifier(method, topLevelFunctionDeclaration)
        parseMethodTypeVar(method)
          listener: handleNoTypeVariables(()
        parseGetterOrFormalParameters(method, method, false, MemberKind.TopLevelMethod)
          parseFormalParameters(method, MemberKind.TopLevelMethod)
            parseFormalParametersRest((, MemberKind.TopLevelMethod)
              listener: beginFormalParameters((, MemberKind.TopLevelMethod)
              listener: endFormalParameters(0, (, ), MemberKind.TopLevelMethod)
        parseAsyncModifierOpt())
          listener: handleAsyncModifier(null, null)
          inPlainSync()
        parseFunctionBody(), false, true)
          listener: handleEmptyFunctionBody(;)
        listener: endTopLevelMethod(augment, null, ;)
  listener: endTopLevelDeclaration(external)
  parseTopLevelDeclarationImpl(;, DirectiveContext(DirectiveState.Declarations))
    parseMetadataStar(;)
      listener: beginMetadataStar(external)
      listener: endMetadataStar(0)
    parseTopLevelMemberImpl(;)
      listener: beginTopLevelMember(external)
      reportRecoverableError(augment, Message[ConflictingModifiers, Members can't be declared to be both 'augment' and 'external'., Try removing one of the keywords., {string: augment, string2: external}])
        listener: handleRecoverableError(Message[ConflictingModifiers, Members can't be declared to be both 'augment' and 'external'., Try removing one of the keywords., {string: augment, string2: external}], augment, augment)
      parseTopLevelMethod(;, augment, external, augment, VoidType(), null, method, false)
        listener: beginTopLevelMethod(;, augment, external)
        listener: handleVoidKeyword(void)
        ensureIdentifierPotentiallyRecovered(void, topLevelFunctionDeclaration, false)
          listener: handleIdentifier(method, topLevelFunctionDeclaration)
        parseMethodTypeVar(method)
          listener: handleNoTypeVariables(()
        parseGetterOrFormalParameters(method, method, false, MemberKind.TopLevelMethod)
          parseFormalParameters(method, MemberKind.TopLevelMethod)
            parseFormalParametersRest((, MemberKind.TopLevelMethod)
              listener: beginFormalParameters((, MemberKind.TopLevelMethod)
              listener: endFormalParameters(0, (, ), MemberKind.TopLevelMethod)
        parseAsyncModifierOpt())
          listener: handleAsyncModifier(null, null)
          inPlainSync()
        parseFunctionBody(), false, true)
          listener: handleEmptyFunctionBody(;)
        listener: endTopLevelMethod(external, null, ;)
  listener: endTopLevelDeclaration(augment)
  parseTopLevelDeclarationImpl(;, DirectiveContext(DirectiveState.Declarations))
    parseMetadataStar(;)
      listener: beginMetadataStar(augment)
      listener: endMetadataStar(0)
    parseTopLevelMemberImpl(;)
      listener: beginTopLevelMember(augment)
      reportRecoverableErrorWithToken(augment, Template(DuplicatedModifier))
        listener: handleRecoverableError(Message[DuplicatedModifier, The modifier 'augment' was already specified., Try removing all but one occurrence of the modifier., {lexeme: augment}], augment, augment)
      isReservedKeyword(=>)
      parseTopLevelMethod(;, augment, null, augment, NoType(), get, getter, false)
        listener: beginTopLevelMethod(;, augment, null)
        listener: handleNoType(augment)
        ensureIdentifierPotentiallyRecovered(get, topLevelFunctionDeclaration, false)
          listener: handleIdentifier(getter, topLevelFunctionDeclaration)
        listener: handleNoTypeVariables(=>)
        parseGetterOrFormalParameters(getter, getter, true, MemberKind.TopLevelMethod)
          listener: handleNoFormalParameters(=>, MemberKind.TopLevelMethod)
        parseAsyncModifierOpt(getter)
          listener: handleAsyncModifier(null, null)
          inPlainSync()
        inPlainSync()
        parseFunctionBody(getter, false, false)
          parseExpressionFunctionBody(=>, false)
            parseExpression(=>)
              parsePrecedenceExpression(=>, 1, true, ConstantPatternContext.none)
                parseUnaryExpression(=>, true, ConstantPatternContext.none)
                  parsePrimary(=>, expression, ConstantPatternContext.none)
                    parseLiteralNull(=>)
                      listener: handleLiteralNull(null)
            ensureSemicolon(null)
            listener: handleExpressionFunctionBody(=>, ;)
            inGenerator()
        listener: endTopLevelMethod(augment, get, ;)
  listener: endTopLevelDeclaration(augment)
  parseTopLevelDeclarationImpl(;, DirectiveContext(DirectiveState.Declarations))
    parseMetadataStar(;)
      listener: beginMetadataStar(augment)
      listener: endMetadataStar(0)
    parseTopLevelMemberImpl(;)
      listener: beginTopLevelMember(augment)
      reportRecoverableError(external, Message[ConflictingModifiers, Members can't be declared to be both 'external' and 'augment'., Try removing one of the keywords., {string: external, string2: augment}])
        listener: handleRecoverableError(Message[ConflictingModifiers, Members can't be declared to be both 'external' and 'augment'., Try removing one of the keywords., {string: external, string2: augment}], external, external)
      isReservedKeyword(;)
      parseTopLevelMethod(;, augment, external, external, NoType(), get, getter, false)
        listener: beginTopLevelMethod(;, augment, external)
        listener: handleNoType(external)
        ensureIdentifierPotentiallyRecovered(get, topLevelFunctionDeclaration, false)
          listener: handleIdentifier(getter, topLevelFunctionDeclaration)
        listener: handleNoTypeVariables(;)
        parseGetterOrFormalParameters(getter, getter, true, MemberKind.TopLevelMethod)
          listener: handleNoFormalParameters(;, MemberKind.TopLevelMethod)
        parseAsyncModifierOpt(getter)
          listener: handleAsyncModifier(null, null)
          inPlainSync()
        inPlainSync()
        parseFunctionBody(getter, false, true)
          listener: handleEmptyFunctionBody(;)
        listener: endTopLevelMethod(augment, get, ;)
  listener: endTopLevelDeclaration(external)
  parseTopLevelDeclarationImpl(;, DirectiveContext(DirectiveState.Declarations))
    parseMetadataStar(;)
      listener: beginMetadataStar(external)
      listener: endMetadataStar(0)
    parseTopLevelMemberImpl(;)
      listener: beginTopLevelMember(external)
      reportRecoverableError(augment, Message[ConflictingModifiers, Members can't be declared to be both 'augment' and 'external'., Try removing one of the keywords., {string: augment, string2: external}])
        listener: handleRecoverableError(Message[ConflictingModifiers, Members can't be declared to be both 'augment' and 'external'., Try removing one of the keywords., {string: augment, string2: external}], augment, augment)
      isReservedKeyword(;)
      parseTopLevelMethod(;, augment, external, augment, NoType(), get, getter, false)
        listener: beginTopLevelMethod(;, augment, external)
        listener: handleNoType(augment)
        ensureIdentifierPotentiallyRecovered(get, topLevelFunctionDeclaration, false)
          listener: handleIdentifier(getter, topLevelFunctionDeclaration)
        listener: handleNoTypeVariables(;)
        parseGetterOrFormalParameters(getter, getter, true, MemberKind.TopLevelMethod)
          listener: handleNoFormalParameters(;, MemberKind.TopLevelMethod)
        parseAsyncModifierOpt(getter)
          listener: handleAsyncModifier(null, null)
          inPlainSync()
        inPlainSync()
        parseFunctionBody(getter, false, true)
          listener: handleEmptyFunctionBody(;)
        listener: endTopLevelMethod(external, get, ;)
  listener: endTopLevelDeclaration(augment)
  parseTopLevelDeclarationImpl(;, DirectiveContext(DirectiveState.Declarations))
    parseMetadataStar(;)
      listener: beginMetadataStar(augment)
      listener: endMetadataStar(0)
    parseTopLevelMemberImpl(;)
      listener: beginTopLevelMember(augment)
      reportRecoverableErrorWithToken(augment, Template(DuplicatedModifier))
        listener: handleRecoverableError(Message[DuplicatedModifier, The modifier 'augment' was already specified., Try removing all but one occurrence of the modifier., {lexeme: augment}], augment, augment)
      parseTopLevelMethod(;, augment, null, augment, SimpleType(), get, getter, false)
        listener: beginTopLevelMethod(;, augment, null)
        listener: handleIdentifier(int, typeReference)
        listener: handleNoTypeArguments(get)
        listener: handleType(int, null)
        ensureIdentifierPotentiallyRecovered(get, topLevelFunctionDeclaration, false)
          listener: handleIdentifier(getter, topLevelFunctionDeclaration)
        listener: handleNoTypeVariables(=>)
        parseGetterOrFormalParameters(getter, getter, true, MemberKind.TopLevelMethod)
          listener: handleNoFormalParameters(=>, MemberKind.TopLevelMethod)
        parseAsyncModifierOpt(getter)
          listener: handleAsyncModifier(null, null)
          inPlainSync()
        inPlainSync()
        parseFunctionBody(getter, false, false)
          parseExpressionFunctionBody(=>, false)
            parseExpression(=>)
              parsePrecedenceExpression(=>, 1, true, ConstantPatternContext.none)
                parseUnaryExpression(=>, true, ConstantPatternContext.none)
                  parsePrimary(=>, expression, ConstantPatternContext.none)
                    parseLiteralInt(=>)
                      listener: handleLiteralInt(0)
            ensureSemicolon(0)
            listener: handleExpressionFunctionBody(=>, ;)
            inGenerator()
        listener: endTopLevelMethod(augment, get, ;)
  listener: endTopLevelDeclaration(augment)
  parseTopLevelDeclarationImpl(;, DirectiveContext(DirectiveState.Declarations))
    parseMetadataStar(;)
      listener: beginMetadataStar(augment)
      listener: endMetadataStar(0)
    parseTopLevelMemberImpl(;)
      listener: beginTopLevelMember(augment)
      reportRecoverableError(external, Message[ConflictingModifiers, Members can't be declared to be both 'external' and 'augment'., Try removing one of the keywords., {string: external, string2: augment}])
        listener: handleRecoverableError(Message[ConflictingModifiers, Members can't be declared to be both 'external' and 'augment'., Try removing one of the keywords., {string: external, string2: augment}], external, external)
      parseTopLevelMethod(;, augment, external, external, SimpleType(), get, getter, false)
        listener: beginTopLevelMethod(;, augment, external)
        listener: handleIdentifier(int, typeReference)
        listener: handleNoTypeArguments(get)
        listener: handleType(int, null)
        ensureIdentifierPotentiallyRecovered(get, topLevelFunctionDeclaration, false)
          listener: handleIdentifier(getter, topLevelFunctionDeclaration)
        listener: handleNoTypeVariables(;)
        parseGetterOrFormalParameters(getter, getter, true, MemberKind.TopLevelMethod)
          listener: handleNoFormalParameters(;, MemberKind.TopLevelMethod)
        parseAsyncModifierOpt(getter)
          listener: handleAsyncModifier(null, null)
          inPlainSync()
        inPlainSync()
        parseFunctionBody(getter, false, true)
          listener: handleEmptyFunctionBody(;)
        listener: endTopLevelMethod(augment, get, ;)
  listener: endTopLevelDeclaration(external)
  parseTopLevelDeclarationImpl(;, DirectiveContext(DirectiveState.Declarations))
    parseMetadataStar(;)
      listener: beginMetadataStar(external)
      listener: endMetadataStar(0)
    parseTopLevelMemberImpl(;)
      listener: beginTopLevelMember(external)
      reportRecoverableError(augment, Message[ConflictingModifiers, Members can't be declared to be both 'augment' and 'external'., Try removing one of the keywords., {string: augment, string2: external}])
        listener: handleRecoverableError(Message[ConflictingModifiers, Members can't be declared to be both 'augment' and 'external'., Try removing one of the keywords., {string: augment, string2: external}], augment, augment)
      parseTopLevelMethod(;, augment, external, augment, SimpleType(), get, getter, false)
        listener: beginTopLevelMethod(;, augment, external)
        listener: handleIdentifier(int, typeReference)
        listener: handleNoTypeArguments(get)
        listener: handleType(int, null)
        ensureIdentifierPotentiallyRecovered(get, topLevelFunctionDeclaration, false)
          listener: handleIdentifier(getter, topLevelFunctionDeclaration)
        listener: handleNoTypeVariables(;)
        parseGetterOrFormalParameters(getter, getter, true, MemberKind.TopLevelMethod)
          listener: handleNoFormalParameters(;, MemberKind.TopLevelMethod)
        parseAsyncModifierOpt(getter)
          listener: handleAsyncModifier(null, null)
          inPlainSync()
        inPlainSync()
        parseFunctionBody(getter, false, true)
          listener: handleEmptyFunctionBody(;)
        listener: endTopLevelMethod(external, get, ;)
  listener: endTopLevelDeclaration(augment)
  parseTopLevelDeclarationImpl(;, DirectiveContext(DirectiveState.Declarations))
    parseMetadataStar(;)
      listener: beginMetadataStar(augment)
      listener: endMetadataStar(0)
    parseTopLevelMemberImpl(;)
      listener: beginTopLevelMember(augment)
      reportRecoverableErrorWithToken(augment, Template(DuplicatedModifier))
        listener: handleRecoverableError(Message[DuplicatedModifier, The modifier 'augment' was already specified., Try removing all but one occurrence of the modifier., {lexeme: augment}], augment, augment)
      isReservedKeyword(()
      parseTopLevelMethod(;, augment, null, augment, NoType(), set, setter, false)
        listener: beginTopLevelMethod(;, augment, null)
        listener: handleNoType(augment)
        ensureIdentifierPotentiallyRecovered(set, topLevelFunctionDeclaration, false)
          listener: handleIdentifier(setter, topLevelFunctionDeclaration)
        listener: handleNoTypeVariables(()
        parseGetterOrFormalParameters(setter, setter, false, MemberKind.TopLevelMethod)
          parseFormalParameters(setter, MemberKind.TopLevelMethod)
            parseFormalParametersRest((, MemberKind.TopLevelMethod)
              listener: beginFormalParameters((, MemberKind.TopLevelMethod)
              parseFormalParameter((, FormalParameterKind.requiredPositional, MemberKind.TopLevelMethod)
                parseMetadataStar(()
                  listener: beginMetadataStar(value)
                  listener: endMetadataStar(0)
                listener: beginFormalParameter(value, MemberKind.TopLevelMethod, null, null, null)
                listener: handleNoType(()
                ensureIdentifier((, formalParameterDeclaration)
                  listener: handleIdentifier(value, formalParameterDeclaration)
                listener: handleFormalParameterWithoutValue())
                listener: endFormalParameter(null, null, null, value, null, null, FormalParameterKind.requiredPositional, MemberKind.TopLevelMethod)
              listener: endFormalParameters(1, (, ), MemberKind.TopLevelMethod)
        parseAsyncModifierOpt())
          listener: handleAsyncModifier(null, null)
          inPlainSync()
        inPlainSync()
        parseFunctionBody(), false, false)
          listener: beginBlockFunctionBody({)
          notEofOrValue(}, })
          listener: endBlockFunctionBody(0, {, })
        listener: endTopLevelMethod(augment, set, })
  listener: endTopLevelDeclaration(augment)
  parseTopLevelDeclarationImpl(}, DirectiveContext(DirectiveState.Declarations))
    parseMetadataStar(})
      listener: beginMetadataStar(augment)
      listener: endMetadataStar(0)
    parseTopLevelMemberImpl(})
      listener: beginTopLevelMember(augment)
      reportRecoverableError(external, Message[ConflictingModifiers, Members can't be declared to be both 'external' and 'augment'., Try removing one of the keywords., {string: external, string2: augment}])
        listener: handleRecoverableError(Message[ConflictingModifiers, Members can't be declared to be both 'external' and 'augment'., Try removing one of the keywords., {string: external, string2: augment}], external, external)
      isReservedKeyword(()
      parseTopLevelMethod(}, augment, external, external, NoType(), set, setter, false)
        listener: beginTopLevelMethod(}, augment, external)
        listener: handleNoType(external)
        ensureIdentifierPotentiallyRecovered(set, topLevelFunctionDeclaration, false)
          listener: handleIdentifier(setter, topLevelFunctionDeclaration)
        listener: handleNoTypeVariables(()
        parseGetterOrFormalParameters(setter, setter, false, MemberKind.TopLevelMethod)
          parseFormalParameters(setter, MemberKind.TopLevelMethod)
            parseFormalParametersRest((, MemberKind.TopLevelMethod)
              listener: beginFormalParameters((, MemberKind.TopLevelMethod)
              parseFormalParameter((, FormalParameterKind.requiredPositional, MemberKind.TopLevelMethod)
                parseMetadataStar(()
                  listener: beginMetadataStar(value)
                  listener: endMetadataStar(0)
                listener: beginFormalParameter(value, MemberKind.TopLevelMethod, null, null, null)
                listener: handleNoType(()
                ensureIdentifier((, formalParameterDeclaration)
                  listener: handleIdentifier(value, formalParameterDeclaration)
                listener: handleFormalParameterWithoutValue())
                listener: endFormalParameter(null, null, null, value, null, null, FormalParameterKind.requiredPositional, MemberKind.TopLevelMethod)
              listener: endFormalParameters(1, (, ), MemberKind.TopLevelMethod)
        parseAsyncModifierOpt())
          listener: handleAsyncModifier(null, null)
          inPlainSync()
        inPlainSync()
        parseFunctionBody(), false, true)
          listener: handleEmptyFunctionBody(;)
        listener: endTopLevelMethod(augment, set, ;)
  listener: endTopLevelDeclaration(external)
  parseTopLevelDeclarationImpl(;, DirectiveContext(DirectiveState.Declarations))
    parseMetadataStar(;)
      listener: beginMetadataStar(external)
      listener: endMetadataStar(0)
    parseTopLevelMemberImpl(;)
      listener: beginTopLevelMember(external)
      reportRecoverableError(augment, Message[ConflictingModifiers, Members can't be declared to be both 'augment' and 'external'., Try removing one of the keywords., {string: augment, string2: external}])
        listener: handleRecoverableError(Message[ConflictingModifiers, Members can't be declared to be both 'augment' and 'external'., Try removing one of the keywords., {string: augment, string2: external}], augment, augment)
      isReservedKeyword(()
      parseTopLevelMethod(;, augment, external, augment, NoType(), set, setter, false)
        listener: beginTopLevelMethod(;, augment, external)
        listener: handleNoType(augment)
        ensureIdentifierPotentiallyRecovered(set, topLevelFunctionDeclaration, false)
          listener: handleIdentifier(setter, topLevelFunctionDeclaration)
        listener: handleNoTypeVariables(()
        parseGetterOrFormalParameters(setter, setter, false, MemberKind.TopLevelMethod)
          parseFormalParameters(setter, MemberKind.TopLevelMethod)
            parseFormalParametersRest((, MemberKind.TopLevelMethod)
              listener: beginFormalParameters((, MemberKind.TopLevelMethod)
              parseFormalParameter((, FormalParameterKind.requiredPositional, MemberKind.TopLevelMethod)
                parseMetadataStar(()
                  listener: beginMetadataStar(value)
                  listener: endMetadataStar(0)
                listener: beginFormalParameter(value, MemberKind.TopLevelMethod, null, null, null)
                listener: handleNoType(()
                ensureIdentifier((, formalParameterDeclaration)
                  listener: handleIdentifier(value, formalParameterDeclaration)
                listener: handleFormalParameterWithoutValue())
                listener: endFormalParameter(null, null, null, value, null, null, FormalParameterKind.requiredPositional, MemberKind.TopLevelMethod)
              listener: endFormalParameters(1, (, ), MemberKind.TopLevelMethod)
        parseAsyncModifierOpt())
          listener: handleAsyncModifier(null, null)
          inPlainSync()
        inPlainSync()
        parseFunctionBody(), false, true)
          listener: handleEmptyFunctionBody(;)
        listener: endTopLevelMethod(external, set, ;)
  listener: endTopLevelDeclaration(augment)
  parseTopLevelDeclarationImpl(;, DirectiveContext(DirectiveState.Declarations))
    parseMetadataStar(;)
      listener: beginMetadataStar(augment)
      listener: endMetadataStar(0)
    parseTopLevelMemberImpl(;)
      listener: beginTopLevelMember(augment)
      reportRecoverableErrorWithToken(augment, Template(DuplicatedModifier))
        listener: handleRecoverableError(Message[DuplicatedModifier, The modifier 'augment' was already specified., Try removing all but one occurrence of the modifier., {lexeme: augment}], augment, augment)
      parseTopLevelMethod(;, augment, null, augment, VoidType(), set, setter, false)
        listener: beginTopLevelMethod(;, augment, null)
        listener: handleVoidKeyword(void)
        ensureIdentifierPotentiallyRecovered(set, topLevelFunctionDeclaration, false)
          listener: handleIdentifier(setter, topLevelFunctionDeclaration)
        listener: handleNoTypeVariables(()
        parseGetterOrFormalParameters(setter, setter, false, MemberKind.TopLevelMethod)
          parseFormalParameters(setter, MemberKind.TopLevelMethod)
            parseFormalParametersRest((, MemberKind.TopLevelMethod)
              listener: beginFormalParameters((, MemberKind.TopLevelMethod)
              parseFormalParameter((, FormalParameterKind.requiredPositional, MemberKind.TopLevelMethod)
                parseMetadataStar(()
                  listener: beginMetadataStar(value)
                  listener: endMetadataStar(0)
                listener: beginFormalParameter(value, MemberKind.TopLevelMethod, null, null, null)
                listener: handleNoType(()
                ensureIdentifier((, formalParameterDeclaration)
                  listener: handleIdentifier(value, formalParameterDeclaration)
                listener: handleFormalParameterWithoutValue())
                listener: endFormalParameter(null, null, null, value, null, null, FormalParameterKind.requiredPositional, MemberKind.TopLevelMethod)
              listener: endFormalParameters(1, (, ), MemberKind.TopLevelMethod)
        parseAsyncModifierOpt())
          listener: handleAsyncModifier(null, null)
          inPlainSync()
        inPlainSync()
        parseFunctionBody(), false, false)
          listener: beginBlockFunctionBody({)
          notEofOrValue(}, })
          listener: endBlockFunctionBody(0, {, })
        listener: endTopLevelMethod(augment, set, })
  listener: endTopLevelDeclaration(augment)
  parseTopLevelDeclarationImpl(}, DirectiveContext(DirectiveState.Declarations))
    parseMetadataStar(})
      listener: beginMetadataStar(augment)
      listener: endMetadataStar(0)
    parseTopLevelMemberImpl(})
      listener: beginTopLevelMember(augment)
      reportRecoverableError(external, Message[ConflictingModifiers, Members can't be declared to be both 'external' and 'augment'., Try removing one of the keywords., {string: external, string2: augment}])
        listener: handleRecoverableError(Message[ConflictingModifiers, Members can't be declared to be both 'external' and 'augment'., Try removing one of the keywords., {string: external, string2: augment}], external, external)
      parseTopLevelMethod(}, augment, external, external, VoidType(), set, setter, false)
        listener: beginTopLevelMethod(}, augment, external)
        listener: handleVoidKeyword(void)
        ensureIdentifierPotentiallyRecovered(set, topLevelFunctionDeclaration, false)
          listener: handleIdentifier(setter, topLevelFunctionDeclaration)
        listener: handleNoTypeVariables(()
        parseGetterOrFormalParameters(setter, setter, false, MemberKind.TopLevelMethod)
          parseFormalParameters(setter, MemberKind.TopLevelMethod)
            parseFormalParametersRest((, MemberKind.TopLevelMethod)
              listener: beginFormalParameters((, MemberKind.TopLevelMethod)
              parseFormalParameter((, FormalParameterKind.requiredPositional, MemberKind.TopLevelMethod)
                parseMetadataStar(()
                  listener: beginMetadataStar(value)
                  listener: endMetadataStar(0)
                listener: beginFormalParameter(value, MemberKind.TopLevelMethod, null, null, null)
                listener: handleNoType(()
                ensureIdentifier((, formalParameterDeclaration)
                  listener: handleIdentifier(value, formalParameterDeclaration)
                listener: handleFormalParameterWithoutValue())
                listener: endFormalParameter(null, null, null, value, null, null, FormalParameterKind.requiredPositional, MemberKind.TopLevelMethod)
              listener: endFormalParameters(1, (, ), MemberKind.TopLevelMethod)
        parseAsyncModifierOpt())
          listener: handleAsyncModifier(null, null)
          inPlainSync()
        inPlainSync()
        parseFunctionBody(), false, true)
          listener: handleEmptyFunctionBody(;)
        listener: endTopLevelMethod(augment, set, ;)
  listener: endTopLevelDeclaration(external)
  parseTopLevelDeclarationImpl(;, DirectiveContext(DirectiveState.Declarations))
    parseMetadataStar(;)
      listener: beginMetadataStar(external)
      listener: endMetadataStar(0)
    parseTopLevelMemberImpl(;)
      listener: beginTopLevelMember(external)
      reportRecoverableError(augment, Message[ConflictingModifiers, Members can't be declared to be both 'augment' and 'external'., Try removing one of the keywords., {string: augment, string2: external}])
        listener: handleRecoverableError(Message[ConflictingModifiers, Members can't be declared to be both 'augment' and 'external'., Try removing one of the keywords., {string: augment, string2: external}], augment, augment)
      parseTopLevelMethod(;, augment, external, augment, VoidType(), set, setter, false)
        listener: beginTopLevelMethod(;, augment, external)
        listener: handleVoidKeyword(void)
        ensureIdentifierPotentiallyRecovered(set, topLevelFunctionDeclaration, false)
          listener: handleIdentifier(setter, topLevelFunctionDeclaration)
        listener: handleNoTypeVariables(()
        parseGetterOrFormalParameters(setter, setter, false, MemberKind.TopLevelMethod)
          parseFormalParameters(setter, MemberKind.TopLevelMethod)
            parseFormalParametersRest((, MemberKind.TopLevelMethod)
              listener: beginFormalParameters((, MemberKind.TopLevelMethod)
              parseFormalParameter((, FormalParameterKind.requiredPositional, MemberKind.TopLevelMethod)
                parseMetadataStar(()
                  listener: beginMetadataStar(value)
                  listener: endMetadataStar(0)
                listener: beginFormalParameter(value, MemberKind.TopLevelMethod, null, null, null)
                listener: handleNoType(()
                ensureIdentifier((, formalParameterDeclaration)
                  listener: handleIdentifier(value, formalParameterDeclaration)
                listener: handleFormalParameterWithoutValue())
                listener: endFormalParameter(null, null, null, value, null, null, FormalParameterKind.requiredPositional, MemberKind.TopLevelMethod)
              listener: endFormalParameters(1, (, ), MemberKind.TopLevelMethod)
        parseAsyncModifierOpt())
          listener: handleAsyncModifier(null, null)
          inPlainSync()
        inPlainSync()
        parseFunctionBody(), false, true)
          listener: handleEmptyFunctionBody(;)
        listener: endTopLevelMethod(external, set, ;)
  listener: endTopLevelDeclaration(augment)
  parseTopLevelDeclarationImpl(;, DirectiveContext(DirectiveState.Declarations))
    parseMetadataStar(;)
      listener: beginMetadataStar(augment)
      listener: endMetadataStar(0)
    parseTopLevelMemberImpl(;)
      listener: beginTopLevelMember(augment)
      reportRecoverableErrorWithToken(augment, Template(DuplicatedModifier))
        listener: handleRecoverableError(Message[DuplicatedModifier, The modifier 'augment' was already specified., Try removing all but one occurrence of the modifier., {lexeme: augment}], augment, augment)
      skipOuterPattern(var)
        skipObjectPatternRest(field)
      parseFields(;, null, augment, null, null, null, null, var, var, NoType(), field, DeclarationKind.TopLevel, null, false)
        listener: beginFields(DeclarationKind.TopLevel, null, augment, null, null, null, null, var, ;)
        listener: handleNoType(var)
        ensureIdentifierPotentiallyRecovered(var, topLevelVariableDeclaration, false)
          listener: handleIdentifier(field, topLevelVariableDeclaration)
        parseFieldInitializerOpt(field, field, null, null, augment, null, var, DeclarationKind.TopLevel, null)
          listener: handleNoFieldInitializer(;)
        listener: endTopLevelFields(null, null, null, null, var, 1, augment, ;)
  listener: endTopLevelDeclaration(augment)
  parseTopLevelDeclarationImpl(;, DirectiveContext(DirectiveState.Declarations))
    parseMetadataStar(;)
      listener: beginMetadataStar(augment)
      listener: endMetadataStar(0)
    parseTopLevelMemberImpl(;)
      listener: beginTopLevelMember(augment)
      reportRecoverableError(external, Message[ConflictingModifiers, Members can't be declared to be both 'external' and 'augment'., Try removing one of the keywords., {string: external, string2: augment}])
        listener: handleRecoverableError(Message[ConflictingModifiers, Members can't be declared to be both 'external' and 'augment'., Try removing one of the keywords., {string: external, string2: augment}], external, external)
      skipOuterPattern(var)
        skipObjectPatternRest(field)
      parseFields(;, null, augment, external, null, null, null, var, var, NoType(), field, DeclarationKind.TopLevel, null, false)
        listener: beginFields(DeclarationKind.TopLevel, null, augment, external, null, null, null, var, ;)
        listener: handleNoType(var)
        ensureIdentifierPotentiallyRecovered(var, topLevelVariableDeclaration, false)
          listener: handleIdentifier(field, topLevelVariableDeclaration)
        parseFieldInitializerOpt(field, field, null, null, augment, external, var, DeclarationKind.TopLevel, null)
          listener: handleNoFieldInitializer(;)
        listener: endTopLevelFields(external, null, null, null, var, 1, augment, ;)
  listener: endTopLevelDeclaration(external)
  parseTopLevelDeclarationImpl(;, DirectiveContext(DirectiveState.Declarations))
    parseMetadataStar(;)
      listener: beginMetadataStar(external)
      listener: endMetadataStar(0)
    parseTopLevelMemberImpl(;)
      listener: beginTopLevelMember(external)
      reportRecoverableError(augment, Message[ConflictingModifiers, Members can't be declared to be both 'augment' and 'external'., Try removing one of the keywords., {string: augment, string2: external}])
        listener: handleRecoverableError(Message[ConflictingModifiers, Members can't be declared to be both 'augment' and 'external'., Try removing one of the keywords., {string: augment, string2: external}], augment, augment)
      skipOuterPattern(var)
        skipObjectPatternRest(field)
      parseFields(;, null, augment, external, null, null, null, var, var, NoType(), field, DeclarationKind.TopLevel, null, false)
        listener: beginFields(DeclarationKind.TopLevel, null, augment, external, null, null, null, var, ;)
        listener: handleNoType(var)
        ensureIdentifierPotentiallyRecovered(var, topLevelVariableDeclaration, false)
          listener: handleIdentifier(field, topLevelVariableDeclaration)
        parseFieldInitializerOpt(field, field, null, null, augment, external, var, DeclarationKind.TopLevel, null)
          listener: handleNoFieldInitializer(;)
        listener: endTopLevelFields(external, null, null, null, var, 1, external, ;)
  listener: endTopLevelDeclaration(augment)
  parseTopLevelDeclarationImpl(;, DirectiveContext(DirectiveState.Declarations))
    parseMetadataStar(;)
      listener: beginMetadataStar(augment)
      listener: endMetadataStar(0)
    parseTopLevelMemberImpl(;)
      listener: beginTopLevelMember(augment)
      reportRecoverableErrorWithToken(augment, Template(DuplicatedModifier))
        listener: handleRecoverableError(Message[DuplicatedModifier, The modifier 'augment' was already specified., Try removing all but one occurrence of the modifier., {lexeme: augment}], augment, augment)
      parseFields(;, null, augment, null, null, null, null, null, augment, SimpleType(), field, DeclarationKind.TopLevel, null, false)
        listener: beginFields(DeclarationKind.TopLevel, null, augment, null, null, null, null, null, ;)
        listener: handleIdentifier(int, typeReference)
        listener: handleNoTypeArguments(field)
        listener: handleType(int, null)
        ensureIdentifierPotentiallyRecovered(int, topLevelVariableDeclaration, false)
          listener: handleIdentifier(field, topLevelVariableDeclaration)
        parseFieldInitializerOpt(field, field, null, null, augment, null, null, DeclarationKind.TopLevel, null)
          listener: beginFieldInitializer(=)
          parseExpression(=)
            parsePrecedenceExpression(=, 1, true, ConstantPatternContext.none)
              parseUnaryExpression(=, true, ConstantPatternContext.none)
                parsePrimary(=, expression, ConstantPatternContext.none)
                  parseLiteralInt(=)
                    listener: handleLiteralInt(0)
          listener: endFieldInitializer(=, ;)
        listener: endTopLevelFields(null, null, null, null, null, 1, augment, ;)
  listener: endTopLevelDeclaration(augment)
  parseTopLevelDeclarationImpl(;, DirectiveContext(DirectiveState.Declarations))
    parseMetadataStar(;)
      listener: beginMetadataStar(augment)
      listener: endMetadataStar(0)
    parseTopLevelMemberImpl(;)
      listener: beginTopLevelMember(augment)
      reportRecoverableError(external, Message[ConflictingModifiers, Members can't be declared to be both 'external' and 'augment'., Try removing one of the keywords., {string: external, string2: augment}])
        listener: handleRecoverableError(Message[ConflictingModifiers, Members can't be declared to be both 'external' and 'augment'., Try removing one of the keywords., {string: external, string2: augment}], external, external)
      parseFields(;, null, augment, external, null, null, null, null, external, SimpleType(), field, DeclarationKind.TopLevel, null, false)
        listener: beginFields(DeclarationKind.TopLevel, null, augment, external, null, null, null, null, ;)
        listener: handleIdentifier(int, typeReference)
        listener: handleNoTypeArguments(field)
        listener: handleType(int, null)
        ensureIdentifierPotentiallyRecovered(int, topLevelVariableDeclaration, false)
          listener: handleIdentifier(field, topLevelVariableDeclaration)
        parseFieldInitializerOpt(field, field, null, null, augment, external, null, DeclarationKind.TopLevel, null)
          listener: handleNoFieldInitializer(;)
        listener: endTopLevelFields(external, null, null, null, null, 1, augment, ;)
  listener: endTopLevelDeclaration(external)
  parseTopLevelDeclarationImpl(;, DirectiveContext(DirectiveState.Declarations))
    parseMetadataStar(;)
      listener: beginMetadataStar(external)
      listener: endMetadataStar(0)
    parseTopLevelMemberImpl(;)
      listener: beginTopLevelMember(external)
      reportRecoverableError(augment, Message[ConflictingModifiers, Members can't be declared to be both 'augment' and 'external'., Try removing one of the keywords., {string: augment, string2: external}])
        listener: handleRecoverableError(Message[ConflictingModifiers, Members can't be declared to be both 'augment' and 'external'., Try removing one of the keywords., {string: augment, string2: external}], augment, augment)
      parseFields(;, null, augment, external, null, null, null, null, augment, SimpleType(), field, DeclarationKind.TopLevel, null, false)
        listener: beginFields(DeclarationKind.TopLevel, null, augment, external, null, null, null, null, ;)
        listener: handleIdentifier(int, typeReference)
        listener: handleNoTypeArguments(field)
        listener: handleType(int, null)
        ensureIdentifierPotentiallyRecovered(int, topLevelVariableDeclaration, false)
          listener: handleIdentifier(field, topLevelVariableDeclaration)
        parseFieldInitializerOpt(field, field, null, null, augment, external, null, DeclarationKind.TopLevel, null)
          listener: handleNoFieldInitializer(;)
        listener: endTopLevelFields(external, null, null, null, null, 1, external, ;)
  listener: endTopLevelDeclaration(augment)
  parseTopLevelDeclarationImpl(;, DirectiveContext(DirectiveState.Declarations))
    parseMetadataStar(;)
      listener: beginMetadataStar(augment)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(;, class, null, null, null, null, DirectiveContext(DirectiveState.Declarations))
      reportRecoverableErrorWithToken(augment, Template(DuplicatedModifier))
        listener: handleRecoverableError(Message[DuplicatedModifier, The modifier 'augment' was already specified., Try removing all but one occurrence of the modifier., {lexeme: augment}], augment, augment)
      parseClassOrNamedMixinApplication(null, null, null, null, null, null, augment, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(augment)
        ensureIdentifier(class, classOrMixinDeclaration)
          listener: handleIdentifier(Class, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(augment, null, null, null, null, null, null, augment, null, Class)
        parseClass(Class, augment, class, Class)
          parseClassHeaderOpt(Class, augment, class)
            parseClassExtendsOpt(Class, DeclarationHeaderKind.Class)
              listener: handleNoType(Class)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(Class)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(Class)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(augment, class, null)
          parseClassOrMixinOrExtensionBody(Class, DeclarationKind.Class, Class)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrValue(}, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(augment, })
  listener: endTopLevelDeclaration(abstract)
  parseTopLevelDeclarationImpl(}, DirectiveContext(DirectiveState.Declarations))
    parseMetadataStar(})
      listener: beginMetadataStar(abstract)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(}, class, null, null, null, null, DirectiveContext(DirectiveState.Declarations))
      reportRecoverableError(augment, Message[ModifierOutOfOrder, The modifier 'augment' should be before the modifier 'abstract'., Try re-ordering the modifiers., {string: augment, string2: abstract}])
        listener: handleRecoverableError(Message[ModifierOutOfOrder, The modifier 'augment' should be before the modifier 'abstract'., Try re-ordering the modifiers., {string: augment, string2: abstract}], augment, augment)
      parseClassOrNamedMixinApplication(abstract, null, null, null, null, null, augment, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(abstract)
        ensureIdentifier(class, classOrMixinDeclaration)
          listener: handleIdentifier(Class, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(abstract, abstract, null, null, null, null, null, augment, null, Class)
        parseClass(Class, abstract, class, Class)
          parseClassHeaderOpt(Class, abstract, class)
            parseClassExtendsOpt(Class, DeclarationHeaderKind.Class)
              listener: handleNoType(Class)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(Class)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(Class)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(abstract, class, null)
          parseClassOrMixinOrExtensionBody(Class, DeclarationKind.Class, Class)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrValue(}, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(abstract, })
  listener: endTopLevelDeclaration(augment)
  parseTopLevelDeclarationImpl(}, DirectiveContext(DirectiveState.Declarations))
    parseMetadataStar(})
      listener: beginMetadataStar(augment)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(}, class, null, null, null, null, DirectiveContext(DirectiveState.Declarations))
      reportRecoverableErrorWithToken(augment, Template(DuplicatedModifier))
        listener: handleRecoverableError(Message[DuplicatedModifier, The modifier 'augment' was already specified., Try removing all but one occurrence of the modifier., {lexeme: augment}], augment, augment)
      parseClassOrNamedMixinApplication(null, null, null, null, null, null, augment, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(augment)
        ensureIdentifier(class, classOrMixinDeclaration)
          listener: handleIdentifier(Class, classOrMixinDeclaration)
        listener: handleNoTypeVariables(=)
        listener: beginNamedMixinApplication(augment, null, null, null, null, null, null, augment, null, Class)
        parseNamedMixinApplication(Class, augment, class)
          listener: handleIdentifier(Object, typeReference)
          listener: handleNoTypeArguments(with)
          listener: handleType(Object, null)
          parseMixinApplicationRest(Object)
            parseTypeList(with)
              listener: beginTypeList(Mixin)
              listener: handleIdentifier(Mixin, typeReference)
              listener: handleNoTypeArguments(;)
              listener: handleType(Mixin, null)
              listener: endTypeList(1)
            listener: handleNamedMixinApplicationWithClause(with)
          ensureSemicolon(Mixin)
          listener: endNamedMixinApplication(augment, class, =, null, ;)
  listener: endTopLevelDeclaration(abstract)
  parseTopLevelDeclarationImpl(;, DirectiveContext(DirectiveState.Declarations))
    parseMetadataStar(;)
      listener: beginMetadataStar(abstract)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(;, class, null, null, null, null, DirectiveContext(DirectiveState.Declarations))
      reportRecoverableError(augment, Message[ModifierOutOfOrder, The modifier 'augment' should be before the modifier 'abstract'., Try re-ordering the modifiers., {string: augment, string2: abstract}])
        listener: handleRecoverableError(Message[ModifierOutOfOrder, The modifier 'augment' should be before the modifier 'abstract'., Try re-ordering the modifiers., {string: augment, string2: abstract}], augment, augment)
      parseClassOrNamedMixinApplication(abstract, null, null, null, null, null, augment, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(abstract)
        ensureIdentifier(class, classOrMixinDeclaration)
          listener: handleIdentifier(Class, classOrMixinDeclaration)
        listener: handleNoTypeVariables(=)
        listener: beginNamedMixinApplication(abstract, abstract, null, null, null, null, null, augment, null, Class)
        parseNamedMixinApplication(Class, abstract, class)
          listener: handleIdentifier(Object, typeReference)
          listener: handleNoTypeArguments(with)
          listener: handleType(Object, null)
          parseMixinApplicationRest(Object)
            parseTypeList(with)
              listener: beginTypeList(Mixin)
              listener: handleIdentifier(Mixin, typeReference)
              listener: handleNoTypeArguments(;)
              listener: handleType(Mixin, null)
              listener: endTypeList(1)
            listener: handleNamedMixinApplicationWithClause(with)
          ensureSemicolon(Mixin)
          listener: endNamedMixinApplication(abstract, class, =, null, ;)
  listener: endTopLevelDeclaration(augment)
  parseTopLevelDeclarationImpl(;, DirectiveContext(DirectiveState.Declarations))
    parseMetadataStar(;)
      listener: beginMetadataStar(augment)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(;, mixin, null, null, null, null, DirectiveContext(DirectiveState.Declarations))
      reportRecoverableErrorWithToken(augment, Template(DuplicatedModifier))
        listener: handleRecoverableError(Message[DuplicatedModifier, The modifier 'augment' was already specified., Try removing all but one occurrence of the modifier., {lexeme: augment}], augment, augment)
      parseMixin(augment, null, mixin)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(mixin)
        ensureIdentifier(mixin, classOrMixinDeclaration)
          listener: handleIdentifier(Mixin, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginMixinDeclaration(augment, null, mixin, Mixin)
        parseMixinHeaderOpt(Mixin, mixin)
          parseMixinOnOpt(Mixin)
            listener: handleMixinOn(null, 0)
          parseClassOrMixinOrEnumImplementsOpt(Mixin)
            listener: handleImplements(null, 0)
          listener: handleMixinHeader(mixin)
        parseClassOrMixinOrExtensionBody(Mixin, DeclarationKind.Mixin, Mixin)
          listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Mixin, {)
          notEofOrValue(}, })
          listener: endClassOrMixinOrExtensionBody(DeclarationKind.Mixin, 0, {, })
        listener: endMixinDeclaration(mixin, })
  listener: endTopLevelDeclaration()
  reportAllErrorTokens(augment)
  listener: endCompilationUnit(29, )
