parseUnit(class)
  skipErrorTokens(class)
  listener: beginCompilationUnit(class)
  syntheticPreviousToken(class)
  parseTopLevelDeclarationImpl(, Instance of 'DirectiveContext')
    parseMetadataStar()
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(, class, null, null, null, null, null, Instance of 'DirectiveContext')
      parseClassOrNamedMixinApplication(null, null, null, null, null, null, null, null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          listener: handleIdentifier(F, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, null, null, null, null, null, null, null, F)
        parseClass(F, class, class, F)
          parseClassHeaderOpt(F, class, class)
            parseClassExtendsOpt(F)
              listener: handleNoType(F)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(F)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(F)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(F, DeclarationKind.Class, F)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrValue(}, final)
            parseClassOrMixinOrExtensionOrEnumMemberImpl({, DeclarationKind.Class, F)
              parseMetadataStar({)
                listener: beginMetadataStar(final)
                listener: endMetadataStar(0)
              listener: beginMember()
              skipOuterPattern(final)
                skipObjectPatternRest(Set)
              parseFields({, null, null, null, null, null, null, final, final, Instance of 'SimpleTypeWith1Argument', foo1, DeclarationKind.Class, F, false)
                listener: beginFields(DeclarationKind.Class, null, null, null, null, null, null, final, {)
                listener: handleIdentifier(Set, typeReference)
                listener: beginTypeArguments(<)
                listener: handleIdentifier(Undefined, typeReference)
                listener: handleNoTypeArguments(>)
                listener: handleType(Undefined, null)
                listener: endTypeArguments(1, <, >)
                listener: handleType(Set, null)
                ensureIdentifierPotentiallyRecovered(>, fieldDeclaration, false)
                  listener: handleIdentifier(foo1, fieldDeclaration)
                parseFieldInitializerOpt(foo1, foo1, null, null, null, null, final, DeclarationKind.Class, F)
                  listener: beginFieldInitializer(=)
                  parseExpression(=)
                    parsePrecedenceExpression(=, 1, true, ConstantPatternContext.none)
                      parseUnaryExpression(=, true, ConstantPatternContext.none)
                        parsePrimary(=, expression, ConstantPatternContext.none)
                          parseConstExpression(=)
                            reportRecoverableError(Set, Message[LiteralWithClass, A set literal can't be prefixed by 'Set'., Try removing 'Set', {string: set, lexeme: Set}])
                              listener: handleRecoverableError(Message[LiteralWithClass, A set literal can't be prefixed by 'Set'., Try removing 'Set', {string: set, lexeme: Set}], Set, Set)
                            listener: beginConstLiteral(<)
                            parseLiteralListSetMapOrFunction(Set, const)
                              listener: beginTypeArguments(<)
                              listener: handleIdentifier(List, typeReference)
                              listener: beginTypeArguments(<)
                              listener: handleIdentifier(int, typeReference)
                              listener: handleNoTypeArguments(>)
                              listener: handleType(int, null)
                              listener: endTypeArguments(1, <, >)
                              listener: handleType(List, null)
                              listener: endTypeArguments(1, <, >)
                              parseLiteralSetOrMapSuffix(>, const)
                                listener: handleLiteralSetOrMap(0, {, const, }, false)
                            listener: endConstLiteral(;)
                  listener: endFieldInitializer(=, ;)
                listener: endClassFields(null, null, null, null, null, null, final, 1, final, ;)
              listener: endMember()
            notEofOrValue(}, final)
            parseClassOrMixinOrExtensionOrEnumMemberImpl(;, DeclarationKind.Class, F)
              parseMetadataStar(;)
                listener: beginMetadataStar(final)
                listener: endMetadataStar(0)
              listener: beginMember()
              skipOuterPattern(final)
                skipObjectPatternRest(Set)
              parseFields(;, null, null, null, null, null, null, final, final, Instance of 'SimpleTypeWith1Argument', foo2, DeclarationKind.Class, F, false)
                listener: beginFields(DeclarationKind.Class, null, null, null, null, null, null, final, ;)
                listener: handleIdentifier(Set, typeReference)
                listener: beginTypeArguments(<)
                listener: handleIdentifier(Undefined, typeReference)
                listener: handleNoTypeArguments(>)
                listener: handleType(Undefined, null)
                listener: endTypeArguments(1, <, >)
                listener: handleType(Set, null)
                ensureIdentifierPotentiallyRecovered(>, fieldDeclaration, false)
                  listener: handleIdentifier(foo2, fieldDeclaration)
                parseFieldInitializerOpt(foo2, foo2, null, null, null, null, final, DeclarationKind.Class, F)
                  listener: beginFieldInitializer(=)
                  parseExpression(=)
                    parsePrecedenceExpression(=, 1, true, ConstantPatternContext.none)
                      parseUnaryExpression(=, true, ConstantPatternContext.none)
                        parsePrimary(=, expression, ConstantPatternContext.none)
                          parseConstExpression(=)
                            listener: beginConstLiteral(<)
                            parseLiteralListSetMapOrFunction(const, const)
                              listener: beginTypeArguments(<)
                              listener: handleIdentifier(List, typeReference)
                              listener: beginTypeArguments(<)
                              listener: handleIdentifier(int, typeReference)
                              listener: handleNoTypeArguments(>)
                              listener: handleType(int, null)
                              listener: endTypeArguments(1, <, >)
                              listener: handleType(List, null)
                              listener: endTypeArguments(1, <, >)
                              parseLiteralSetOrMapSuffix(>, const)
                                listener: handleLiteralSetOrMap(0, {, const, }, false)
                            listener: endConstLiteral(;)
                  listener: endFieldInitializer(=, ;)
                listener: endClassFields(null, null, null, null, null, null, final, 1, final, ;)
              listener: endMember()
            notEofOrValue(}, final)
            parseClassOrMixinOrExtensionOrEnumMemberImpl(;, DeclarationKind.Class, F)
              parseMetadataStar(;)
                listener: beginMetadataStar(final)
                listener: endMetadataStar(0)
              listener: beginMember()
              skipOuterPattern(final)
                skipObjectPatternRest(Set)
              parseFields(;, null, null, null, null, null, null, final, final, Instance of 'SimpleTypeWith1Argument', foo3, DeclarationKind.Class, F, false)
                listener: beginFields(DeclarationKind.Class, null, null, null, null, null, null, final, ;)
                listener: handleIdentifier(Set, typeReference)
                listener: beginTypeArguments(<)
                listener: handleIdentifier(Undefined, typeReference)
                listener: handleNoTypeArguments(>)
                listener: handleType(Undefined, null)
                listener: endTypeArguments(1, <, >)
                listener: handleType(Set, null)
                ensureIdentifierPotentiallyRecovered(>, fieldDeclaration, false)
                  listener: handleIdentifier(foo3, fieldDeclaration)
                parseFieldInitializerOpt(foo3, foo3, null, null, null, null, final, DeclarationKind.Class, F)
                  listener: beginFieldInitializer(=)
                  parseExpression(=)
                    parsePrecedenceExpression(=, 1, true, ConstantPatternContext.none)
                      parseUnaryExpression(=, true, ConstantPatternContext.none)
                        parsePrimary(=, expression, ConstantPatternContext.none)
                          parseConstExpression(=)
                            reportRecoverableError(Set, Message[LiteralWithClass, A set literal can't be prefixed by 'Set'., Try removing 'Set', {string: set, lexeme: Set}])
                              listener: handleRecoverableError(Message[LiteralWithClass, A set literal can't be prefixed by 'Set'., Try removing 'Set', {string: set, lexeme: Set}], Set, Set)
                            listener: beginConstLiteral({)
                            listener: handleNoTypeArguments({)
                            parseLiteralSetOrMapSuffix(Set, const)
                              listener: handleLiteralSetOrMap(0, {, const, }, false)
                            listener: endConstLiteral(;)
                  listener: endFieldInitializer(=, ;)
                listener: endClassFields(null, null, null, null, null, null, final, 1, final, ;)
              listener: endMember()
            notEofOrValue(}, final)
            parseClassOrMixinOrExtensionOrEnumMemberImpl(;, DeclarationKind.Class, F)
              parseMetadataStar(;)
                listener: beginMetadataStar(final)
                listener: endMetadataStar(0)
              listener: beginMember()
              skipOuterPattern(final)
                skipObjectPatternRest(Set)
              parseFields(;, null, null, null, null, null, null, final, final, Instance of 'SimpleTypeWith1Argument', foo4, DeclarationKind.Class, F, false)
                listener: beginFields(DeclarationKind.Class, null, null, null, null, null, null, final, ;)
                listener: handleIdentifier(Set, typeReference)
                listener: beginTypeArguments(<)
                listener: handleIdentifier(Undefined, typeReference)
                listener: handleNoTypeArguments(>)
                listener: handleType(Undefined, null)
                listener: endTypeArguments(1, <, >)
                listener: handleType(Set, null)
                ensureIdentifierPotentiallyRecovered(>, fieldDeclaration, false)
                  listener: handleIdentifier(foo4, fieldDeclaration)
                parseFieldInitializerOpt(foo4, foo4, null, null, null, null, final, DeclarationKind.Class, F)
                  listener: beginFieldInitializer(=)
                  parseExpression(=)
                    parsePrecedenceExpression(=, 1, true, ConstantPatternContext.none)
                      parseUnaryExpression(=, true, ConstantPatternContext.none)
                        parsePrimary(=, expression, ConstantPatternContext.none)
                          parseConstExpression(=)
                            listener: beginConstExpression(const)
                            parseConstructorReference(const, ConstructorReferenceContext.Const, Instance of 'ComplexTypeParamOrArgInfo')
                              ensureIdentifier(const, constructorReference)
                                listener: handleIdentifier(Set, constructorReference)
                              listener: beginConstructorReference(Set)
                              parseQualifiedRestOpt(Set, constructorReferenceContinuation)
                              listener: beginTypeArguments(<)
                              listener: handleIdentifier(List, typeReference)
                              listener: beginTypeArguments(<)
                              listener: handleIdentifier(int, typeReference)
                              listener: handleNoTypeArguments(>)
                              listener: handleType(int, null)
                              listener: endTypeArguments(1, <, >)
                              listener: handleType(List, null)
                              listener: endTypeArguments(1, <, >)
                              listener: handleNoConstructorReferenceContinuationAfterTypeArguments(()
                              listener: endConstructorReference(Set, null, (, ConstructorReferenceContext.Const)
                            parseConstructorInvocationArguments(>)
                              parseArgumentsRest(()
                                listener: beginArguments(()
                                listener: endArguments(0, (, ))
                            listener: endConstExpression(const)
                  listener: endFieldInitializer(=, ;)
                listener: endClassFields(null, null, null, null, null, null, final, 1, final, ;)
              listener: endMember()
            notEofOrValue(}, final)
            parseClassOrMixinOrExtensionOrEnumMemberImpl(;, DeclarationKind.Class, F)
              parseMetadataStar(;)
                listener: beginMetadataStar(final)
                listener: endMetadataStar(0)
              listener: beginMember()
              skipOuterPattern(final)
                skipObjectPatternRest(Set)
              parseFields(;, null, null, null, null, null, null, final, final, Instance of 'SimpleTypeWith1Argument', foo5, DeclarationKind.Class, F, false)
                listener: beginFields(DeclarationKind.Class, null, null, null, null, null, null, final, ;)
                listener: handleIdentifier(Set, typeReference)
                listener: beginTypeArguments(<)
                listener: handleIdentifier(Undefined, typeReference)
                listener: handleNoTypeArguments(>)
                listener: handleType(Undefined, null)
                listener: endTypeArguments(1, <, >)
                listener: handleType(Set, null)
                ensureIdentifierPotentiallyRecovered(>, fieldDeclaration, false)
                  listener: handleIdentifier(foo5, fieldDeclaration)
                parseFieldInitializerOpt(foo5, foo5, null, null, null, null, final, DeclarationKind.Class, F)
                  listener: beginFieldInitializer(=)
                  parseExpression(=)
                    parsePrecedenceExpression(=, 1, true, ConstantPatternContext.none)
                      parseUnaryExpression(=, true, ConstantPatternContext.none)
                        parsePrimary(=, expression, ConstantPatternContext.none)
                          parseConstExpression(=)
                            listener: beginConstExpression(const)
                            parseConstructorReference(const, ConstructorReferenceContext.Const, Instance of 'NoTypeParamOrArg')
                              ensureIdentifier(const, constructorReference)
                                listener: handleIdentifier(Set, constructorReference)
                              listener: beginConstructorReference(Set)
                              parseQualifiedRestOpt(Set, constructorReferenceContinuation)
                              listener: handleNoTypeArguments(()
                              listener: handleNoConstructorReferenceContinuationAfterTypeArguments(()
                              listener: endConstructorReference(Set, null, (, ConstructorReferenceContext.Const)
                            parseConstructorInvocationArguments(Set)
                              parseArgumentsRest(()
                                listener: beginArguments(()
                                listener: endArguments(0, (, ))
                            listener: endConstExpression(const)
                  listener: endFieldInitializer(=, ;)
                listener: endClassFields(null, null, null, null, null, null, final, 1, final, ;)
              listener: endMember()
            notEofOrValue(}, final)
            parseClassOrMixinOrExtensionOrEnumMemberImpl(;, DeclarationKind.Class, F)
              parseMetadataStar(;)
                listener: beginMetadataStar(final)
                listener: endMetadataStar(0)
              listener: beginMember()
              skipOuterPattern(final)
                skipObjectPatternRest(Set)
              parseFields(;, null, null, null, null, null, null, final, final, Instance of 'SimpleTypeWith1Argument', foo6, DeclarationKind.Class, F, false)
                listener: beginFields(DeclarationKind.Class, null, null, null, null, null, null, final, ;)
                listener: handleIdentifier(Set, typeReference)
                listener: beginTypeArguments(<)
                listener: handleIdentifier(Undefined, typeReference)
                listener: handleNoTypeArguments(>)
                listener: handleType(Undefined, null)
                listener: endTypeArguments(1, <, >)
                listener: handleType(Set, null)
                ensureIdentifierPotentiallyRecovered(>, fieldDeclaration, false)
                  listener: handleIdentifier(foo6, fieldDeclaration)
                parseFieldInitializerOpt(foo6, foo6, null, null, null, null, final, DeclarationKind.Class, F)
                  listener: beginFieldInitializer(=)
                  parseExpression(=)
                    parsePrecedenceExpression(=, 1, true, ConstantPatternContext.none)
                      parseUnaryExpression(=, true, ConstantPatternContext.none)
                        parsePrimary(=, expression, ConstantPatternContext.none)
                          parseConstExpression(=)
                            reportRecoverableError(Set, Message[LiteralWithClass, A set literal can't be prefixed by 'Set'., Try removing 'Set', {string: set, lexeme: Set}])
                              listener: handleRecoverableError(Message[LiteralWithClass, A set literal can't be prefixed by 'Set'., Try removing 'Set', {string: set, lexeme: Set}], Set, Set)
                            listener: beginConstLiteral(<)
                            parseLiteralListSetMapOrFunction(Set, const)
                              listener: beginTypeArguments(<)
                              listener: handleIdentifier(List, typeReference)
                              listener: beginTypeArguments(<)
                              listener: handleIdentifier(int, typeReference)
                              listener: handleNoTypeArguments(>)
                              listener: handleType(int, null)
                              listener: endTypeArguments(1, <, >)
                              listener: handleType(List, null)
                              listener: endTypeArguments(1, <, >)
                              parseLiteralSetOrMapSuffix(>, const)
                                parseExpression({)
                                  parsePrecedenceExpression({, 1, true, ConstantPatternContext.none)
                                    parseUnaryExpression({, true, ConstantPatternContext.none)
                                      parsePrimary({, expression, ConstantPatternContext.none)
                                        parseLiteralNull({)
                                          listener: handleLiteralNull(null)
                                listener: handleLiteralSetOrMap(1, {, const, }, true)
                            listener: endConstLiteral(;)
                  listener: endFieldInitializer(=, ;)
                listener: endClassFields(null, null, null, null, null, null, final, 1, final, ;)
              listener: endMember()
            notEofOrValue(}, final)
            parseClassOrMixinOrExtensionOrEnumMemberImpl(;, DeclarationKind.Class, F)
              parseMetadataStar(;)
                listener: beginMetadataStar(final)
                listener: endMetadataStar(0)
              listener: beginMember()
              skipOuterPattern(final)
                skipObjectPatternRest(Set)
              parseFields(;, null, null, null, null, null, null, final, final, Instance of 'SimpleTypeWith1Argument', foo7, DeclarationKind.Class, F, false)
                listener: beginFields(DeclarationKind.Class, null, null, null, null, null, null, final, ;)
                listener: handleIdentifier(Set, typeReference)
                listener: beginTypeArguments(<)
                listener: handleIdentifier(Undefined, typeReference)
                listener: handleNoTypeArguments(>)
                listener: handleType(Undefined, null)
                listener: endTypeArguments(1, <, >)
                listener: handleType(Set, null)
                ensureIdentifierPotentiallyRecovered(>, fieldDeclaration, false)
                  listener: handleIdentifier(foo7, fieldDeclaration)
                parseFieldInitializerOpt(foo7, foo7, null, null, null, null, final, DeclarationKind.Class, F)
                  listener: beginFieldInitializer(=)
                  parseExpression(=)
                    parsePrecedenceExpression(=, 1, true, ConstantPatternContext.none)
                      parseUnaryExpression(=, true, ConstantPatternContext.none)
                        parsePrimary(=, expression, ConstantPatternContext.none)
                          parseConstExpression(=)
                            reportRecoverableError(Set, Message[LiteralWithClass, A set literal can't be prefixed by 'Set'., Try removing 'Set', {string: set, lexeme: Set}])
                              listener: handleRecoverableError(Message[LiteralWithClass, A set literal can't be prefixed by 'Set'., Try removing 'Set', {string: set, lexeme: Set}], Set, Set)
                            listener: beginConstLiteral({)
                            listener: handleNoTypeArguments({)
                            parseLiteralSetOrMapSuffix(Set, const)
                              parseExpression({)
                                parsePrecedenceExpression({, 1, true, ConstantPatternContext.none)
                                  parseUnaryExpression({, true, ConstantPatternContext.none)
                                    parsePrimary({, expression, ConstantPatternContext.none)
                                      parseLiteralNull({)
                                        listener: handleLiteralNull(null)
                              listener: handleLiteralSetOrMap(1, {, const, }, true)
                            listener: endConstLiteral(;)
                  listener: endFieldInitializer(=, ;)
                listener: endClassFields(null, null, null, null, null, null, final, 1, final, ;)
              listener: endMember()
            notEofOrValue(}, final)
            parseClassOrMixinOrExtensionOrEnumMemberImpl(;, DeclarationKind.Class, F)
              parseMetadataStar(;)
                listener: beginMetadataStar(final)
                listener: endMetadataStar(0)
              listener: beginMember()
              skipOuterPattern(final)
                skipObjectPatternRest(Set)
              parseFields(;, null, null, null, null, null, null, final, final, Instance of 'SimpleTypeWith1Argument', foo8, DeclarationKind.Class, F, false)
                listener: beginFields(DeclarationKind.Class, null, null, null, null, null, null, final, ;)
                listener: handleIdentifier(Set, typeReference)
                listener: beginTypeArguments(<)
                listener: handleIdentifier(Undefined, typeReference)
                listener: handleNoTypeArguments(>)
                listener: handleType(Undefined, null)
                listener: endTypeArguments(1, <, >)
                listener: handleType(Set, null)
                ensureIdentifierPotentiallyRecovered(>, fieldDeclaration, false)
                  listener: handleIdentifier(foo8, fieldDeclaration)
                parseFieldInitializerOpt(foo8, foo8, null, null, null, null, final, DeclarationKind.Class, F)
                  listener: beginFieldInitializer(=)
                  parseExpression(=)
                    parsePrecedenceExpression(=, 1, true, ConstantPatternContext.none)
                      parseUnaryExpression(=, true, ConstantPatternContext.none)
                        parsePrimary(=, expression, ConstantPatternContext.none)
                          parseConstExpression(=)
                            listener: beginConstLiteral(<)
                            parseLiteralListSetMapOrFunction(const, const)
                              listener: beginTypeArguments(<)
                              listener: handleIdentifier(List, typeReference)
                              listener: beginTypeArguments(<)
                              listener: handleIdentifier(int, typeReference)
                              listener: handleNoTypeArguments(>)
                              listener: handleType(int, null)
                              listener: endTypeArguments(1, <, >)
                              listener: handleType(List, null)
                              listener: endTypeArguments(1, <, >)
                              parseLiteralSetOrMapSuffix(>, const)
                                parseExpression({)
                                  parsePrecedenceExpression({, 1, true, ConstantPatternContext.none)
                                    parseUnaryExpression({, true, ConstantPatternContext.none)
                                      parsePrimary({, expression, ConstantPatternContext.none)
                                        parseLiteralNull({)
                                          listener: handleLiteralNull(null)
                                listener: handleLiteralSetOrMap(1, {, const, }, true)
                            listener: endConstLiteral(;)
                  listener: endFieldInitializer(=, ;)
                listener: endClassFields(null, null, null, null, null, null, final, 1, final, ;)
              listener: endMember()
            notEofOrValue(}, final)
            parseClassOrMixinOrExtensionOrEnumMemberImpl(;, DeclarationKind.Class, F)
              parseMetadataStar(;)
                listener: beginMetadataStar(final)
                listener: endMetadataStar(0)
              listener: beginMember()
              skipOuterPattern(final)
                skipObjectPatternRest(Set)
              parseFields(;, null, null, null, null, null, null, final, final, Instance of 'SimpleTypeWith1Argument', foo9, DeclarationKind.Class, F, false)
                listener: beginFields(DeclarationKind.Class, null, null, null, null, null, null, final, ;)
                listener: handleIdentifier(Set, typeReference)
                listener: beginTypeArguments(<)
                listener: handleIdentifier(Undefined, typeReference)
                listener: handleNoTypeArguments(>)
                listener: handleType(Undefined, null)
                listener: endTypeArguments(1, <, >)
                listener: handleType(Set, null)
                ensureIdentifierPotentiallyRecovered(>, fieldDeclaration, false)
                  listener: handleIdentifier(foo9, fieldDeclaration)
                parseFieldInitializerOpt(foo9, foo9, null, null, null, null, final, DeclarationKind.Class, F)
                  listener: beginFieldInitializer(=)
                  parseExpression(=)
                    parsePrecedenceExpression(=, 1, true, ConstantPatternContext.none)
                      parseUnaryExpression(=, true, ConstantPatternContext.none)
                        parsePrimary(=, expression, ConstantPatternContext.none)
                          parseConstExpression(=)
                            listener: beginConstLiteral({)
                            listener: handleNoTypeArguments({)
                            parseLiteralSetOrMapSuffix(const, const)
                              parseExpression({)
                                parsePrecedenceExpression({, 1, true, ConstantPatternContext.none)
                                  parseUnaryExpression({, true, ConstantPatternContext.none)
                                    parsePrimary({, expression, ConstantPatternContext.none)
                                      parseLiteralNull({)
                                        listener: handleLiteralNull(null)
                              listener: handleLiteralSetOrMap(1, {, const, }, true)
                            listener: endConstLiteral(;)
                  listener: endFieldInitializer(=, ;)
                listener: endClassFields(null, null, null, null, null, null, final, 1, final, ;)
              listener: endMember()
            notEofOrValue(}, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 9, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration()
  reportAllErrorTokens(class)
  listener: endCompilationUnit(1, )
