parseUnit(enum)
  skipErrorTokens(enum)
  listener: beginCompilationUnit(enum)
  syntheticPreviousToken(enum)
  parseTopLevelDeclarationImpl(, DirectiveContext(DirectiveState.Unknown))
    parseMetadataStar()
      listener: beginMetadataStar(enum)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(enum, , enum, null, null, null, null, DirectiveContext(DirectiveState.Unknown))
      parseEnum(enum, null, enum)
        listener: beginEnumDeclarationPrelude(enum)
        ensureIdentifier(enum, enumDeclaration)
          listener: handleIdentifier(E, enumDeclaration)
        listener: handleNoTypeVariables(w)
        listener: beginEnumDeclaration(enum, null, enum, E)
        parsePrimaryConstructorOpt(E, null, false)
          listener: handleNoPrimaryConstructor(E, null, false)
        parseEnumHeaderOpt(E, enum)
          recoverySmallLookAheadSkipTokens(E, [OPEN_CURLY_BRACKET, WITH, IMPLEMENTS])
            reportRecoverableError(w, Message[Template(UnexpectedToken), Unexpected token 'w'., null, {lexeme: w}])
              listener: handleRecoverableError(Message[Template(UnexpectedToken), Unexpected token 'w'., null, {lexeme: w}], w, w)
          parseEnumWithClauseOpt(w)
            listener: handleEnumNoWithClause()
          parseClassOrMixinOrEnumImplementsOpt(w)
            listener: handleImplements(null, 0)
        listener: handleEnumHeader(null, enum, {)
        listener: beginEnumBody({)
        parseEnumElement({)
          parseMetadataStar({)
            listener: beginMetadataStar(v)
            listener: endMetadataStar(0)
          ensureIdentifier({, enumValueDeclaration)
            listener: handleIdentifier(v, enumValueDeclaration)
          listener: handleNoTypeNameInConstructorReference(})
          listener: beginConstructorReference(v)
          listener: handleNoTypeArguments(})
          listener: handleNoConstructorReferenceContinuationAfterTypeArguments(v)
          listener: endConstructorReference(v, null, v, ConstructorReferenceContext.Const)
          listener: handleNoArguments(v)
          listener: handleEnumElement({, null)
        listener: handleEnumElements(}, 1)
        listener: endEnumBody({, })
        listener: endEnumDeclaration(enum, enum, {, 0, })
  listener: endTopLevelDeclaration(})
  parseTopLevelDeclarationImpl(}, DirectiveContext(DirectiveState.Declarations))
    parseMetadataStar(})
      listener: beginMetadataStar(enum)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(enum, }, enum, null, null, null, null, DirectiveContext(DirectiveState.Declarations))
      parseEnum(enum, null, enum)
        listener: beginEnumDeclarationPrelude(enum)
        ensureIdentifier(enum, enumDeclaration)
          listener: handleIdentifier(E, enumDeclaration)
        listener: handleNoTypeVariables(w)
        listener: beginEnumDeclaration(enum, null, enum, E)
        parsePrimaryConstructorOpt(E, null, false)
          listener: handleNoPrimaryConstructor(E, null, false)
        parseEnumHeaderOpt(E, enum)
          recoverySmallLookAheadSkipTokens(E, [OPEN_CURLY_BRACKET, WITH, IMPLEMENTS])
            reportRecoverableError(w, Message[Template(UnexpectedToken), Unexpected token 'w'., null, {lexeme: w}])
              listener: handleRecoverableError(Message[Template(UnexpectedToken), Unexpected token 'w'., null, {lexeme: w}], w, w)
          parseEnumWithClauseOpt(w)
            listener: handleEnumNoWithClause()
          parseClassOrMixinOrEnumImplementsOpt(w)
            listener: handleIdentifier(Foo, typeReference)
            listener: handleNoTypeArguments({)
            listener: handleType(Foo, null)
            listener: handleImplements(implements, 1)
        listener: handleEnumHeader(null, enum, {)
        listener: beginEnumBody({)
        parseEnumElement({)
          parseMetadataStar({)
            listener: beginMetadataStar(v)
            listener: endMetadataStar(0)
          ensureIdentifier({, enumValueDeclaration)
            listener: handleIdentifier(v, enumValueDeclaration)
          listener: handleNoTypeNameInConstructorReference(})
          listener: beginConstructorReference(v)
          listener: handleNoTypeArguments(})
          listener: handleNoConstructorReferenceContinuationAfterTypeArguments(v)
          listener: endConstructorReference(v, null, v, ConstructorReferenceContext.Const)
          listener: handleNoArguments(v)
          listener: handleEnumElement({, null)
        listener: handleEnumElements(}, 1)
        listener: endEnumBody({, })
        listener: endEnumDeclaration(enum, enum, {, 0, })
  listener: endTopLevelDeclaration(})
  parseTopLevelDeclarationImpl(}, DirectiveContext(DirectiveState.Declarations))
    parseMetadataStar(})
      listener: beginMetadataStar(enum)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(enum, }, enum, null, null, null, null, DirectiveContext(DirectiveState.Declarations))
      parseEnum(enum, null, enum)
        listener: beginEnumDeclarationPrelude(enum)
        ensureIdentifier(enum, enumDeclaration)
          listener: handleIdentifier(E, enumDeclaration)
        listener: handleNoTypeVariables(implements)
        listener: beginEnumDeclaration(enum, null, enum, E)
        parsePrimaryConstructorOpt(E, null, false)
          listener: handleNoPrimaryConstructor(E, null, false)
        parseEnumHeaderOpt(E, enum)
          parseEnumWithClauseOpt(E)
            listener: handleEnumNoWithClause()
          parseClassOrMixinOrEnumImplementsOpt(E)
            listener: handleIdentifier(Foo, typeReference)
            listener: handleNoTypeArguments(with)
            listener: handleType(Foo, null)
            listener: handleImplements(implements, 1)
          recoveryEnumWith(Foo, Message[Template(OutOfOrderClauses), The 'with' clause must come before the 'implements' clause., Try moving the 'with' clause before the 'implements' clause., {expectedEarlierClause: with, expectedLaterClause: implements}])
            reportRecoverableError(with, Message[Template(OutOfOrderClauses), The 'with' clause must come before the 'implements' clause., Try moving the 'with' clause before the 'implements' clause., {expectedEarlierClause: with, expectedLaterClause: implements}])
              listener: handleRecoverableError(Message[Template(OutOfOrderClauses), The 'with' clause must come before the 'implements' clause., Try moving the 'with' clause before the 'implements' clause., {expectedEarlierClause: with, expectedLaterClause: implements}], with, with)
            parseEnumWithClauseOpt(Foo)
              parseTypeList(with)
        listener: handleEnumHeader(null, enum, {)
        listener: beginEnumBody({)
        parseEnumElement({)
          parseMetadataStar({)
            listener: beginMetadataStar(v)
            listener: endMetadataStar(0)
          ensureIdentifier({, enumValueDeclaration)
            listener: handleIdentifier(v, enumValueDeclaration)
          listener: handleNoTypeNameInConstructorReference(})
          listener: beginConstructorReference(v)
          listener: handleNoTypeArguments(})
          listener: handleNoConstructorReferenceContinuationAfterTypeArguments(v)
          listener: endConstructorReference(v, null, v, ConstructorReferenceContext.Const)
          listener: handleNoArguments(v)
          listener: handleEnumElement({, null)
        listener: handleEnumElements(}, 1)
        listener: endEnumBody({, })
        listener: endEnumDeclaration(enum, enum, {, 0, })
  listener: endTopLevelDeclaration(})
  parseTopLevelDeclarationImpl(}, DirectiveContext(DirectiveState.Declarations))
    parseMetadataStar(})
      listener: beginMetadataStar(enum)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(enum, }, enum, null, null, null, null, DirectiveContext(DirectiveState.Declarations))
      parseEnum(enum, null, enum)
        listener: beginEnumDeclarationPrelude(enum)
        ensureIdentifier(enum, enumDeclaration)
          listener: handleIdentifier(E, enumDeclaration)
        listener: handleNoTypeVariables(implements)
        listener: beginEnumDeclaration(enum, null, enum, E)
        parsePrimaryConstructorOpt(E, null, false)
          listener: handleNoPrimaryConstructor(E, null, false)
        parseEnumHeaderOpt(E, enum)
          parseEnumWithClauseOpt(E)
            listener: handleEnumNoWithClause()
          parseClassOrMixinOrEnumImplementsOpt(E)
            listener: handleIdentifier(Foo, typeReference)
            listener: handleNoTypeArguments(implements)
            listener: handleType(Foo, null)
            listener: handleImplements(implements, 1)
          recoveryEnumWith(Foo, Message[Template(OutOfOrderClauses), The 'with' clause must come before the 'implements' clause., Try moving the 'with' clause before the 'implements' clause., {expectedEarlierClause: with, expectedLaterClause: implements}])
          recoveryEnumImplements(Foo, Message[Template(MultipleClauses), Each 'enum' definition can have at most one 'implements' clause., Try combining all of the 'implements' clauses into a single clause., {definitionKind: enum, clauseKind: implements}])
            reportRecoverableError(implements, Message[Template(MultipleClauses), Each 'enum' definition can have at most one 'implements' clause., Try combining all of the 'implements' clauses into a single clause., {definitionKind: enum, clauseKind: implements}])
              listener: handleRecoverableError(Message[Template(MultipleClauses), Each 'enum' definition can have at most one 'implements' clause., Try combining all of the 'implements' clauses into a single clause., {definitionKind: enum, clauseKind: implements}], implements, implements)
            parseClassOrMixinOrEnumImplementsOpt(Foo)
          recoveryEnumWith(Bar, Message[Template(OutOfOrderClauses), The 'with' clause must come before the 'implements' clause., Try moving the 'with' clause before the 'implements' clause., {expectedEarlierClause: with, expectedLaterClause: implements}])
          recoveryEnumImplements(Bar, Message[Template(MultipleClauses), Each 'enum' definition can have at most one 'implements' clause., Try combining all of the 'implements' clauses into a single clause., {definitionKind: enum, clauseKind: implements}])
            reportRecoverableError(implements, Message[Template(MultipleClauses), Each 'enum' definition can have at most one 'implements' clause., Try combining all of the 'implements' clauses into a single clause., {definitionKind: enum, clauseKind: implements}])
              listener: handleRecoverableError(Message[Template(MultipleClauses), Each 'enum' definition can have at most one 'implements' clause., Try combining all of the 'implements' clauses into a single clause., {definitionKind: enum, clauseKind: implements}], implements, implements)
            parseClassOrMixinOrEnumImplementsOpt(Bar)
        listener: handleEnumHeader(null, enum, {)
        listener: beginEnumBody({)
        parseEnumElement({)
          parseMetadataStar({)
            listener: beginMetadataStar(v)
            listener: endMetadataStar(0)
          ensureIdentifier({, enumValueDeclaration)
            listener: handleIdentifier(v, enumValueDeclaration)
          listener: handleNoTypeNameInConstructorReference(})
          listener: beginConstructorReference(v)
          listener: handleNoTypeArguments(})
          listener: handleNoConstructorReferenceContinuationAfterTypeArguments(v)
          listener: endConstructorReference(v, null, v, ConstructorReferenceContext.Const)
          listener: handleNoArguments(v)
          listener: handleEnumElement({, null)
        listener: handleEnumElements(}, 1)
        listener: endEnumBody({, })
        listener: endEnumDeclaration(enum, enum, {, 0, })
  listener: endTopLevelDeclaration(})
  parseTopLevelDeclarationImpl(}, DirectiveContext(DirectiveState.Declarations))
    parseMetadataStar(})
      listener: beginMetadataStar(enum)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(enum, }, enum, null, null, null, null, DirectiveContext(DirectiveState.Declarations))
      parseEnum(enum, null, enum)
        listener: beginEnumDeclarationPrelude(enum)
        ensureIdentifier(enum, enumDeclaration)
          listener: handleIdentifier(E, enumDeclaration)
        listener: handleNoTypeVariables(w)
        listener: beginEnumDeclaration(enum, null, enum, E)
        parsePrimaryConstructorOpt(E, null, false)
          listener: handleNoPrimaryConstructor(E, null, false)
        parseEnumHeaderOpt(E, enum)
          recoverySmallLookAheadSkipTokens(E, [OPEN_CURLY_BRACKET, WITH, IMPLEMENTS])
            reportRecoverableErrorWithEnd(w, Foo, UnexpectedTokens)
              listener: handleRecoverableError(UnexpectedTokens, w, Foo)
          parseEnumWithClauseOpt(Foo)
            listener: handleEnumNoWithClause()
          parseClassOrMixinOrEnumImplementsOpt(Foo)
            listener: handleImplements(null, 0)
        listener: handleEnumHeader(null, enum, {)
        listener: beginEnumBody({)
        parseEnumElement({)
          parseMetadataStar({)
            listener: beginMetadataStar(v)
            listener: endMetadataStar(0)
          ensureIdentifier({, enumValueDeclaration)
            listener: handleIdentifier(v, enumValueDeclaration)
          listener: handleNoTypeNameInConstructorReference(})
          listener: beginConstructorReference(v)
          listener: handleNoTypeArguments(})
          listener: handleNoConstructorReferenceContinuationAfterTypeArguments(v)
          listener: endConstructorReference(v, null, v, ConstructorReferenceContext.Const)
          listener: handleNoArguments(v)
          listener: handleEnumElement({, null)
        listener: handleEnumElements(}, 1)
        listener: endEnumBody({, })
        listener: endEnumDeclaration(enum, enum, {, 0, })
  listener: endTopLevelDeclaration(})
  parseTopLevelDeclarationImpl(}, DirectiveContext(DirectiveState.Declarations))
    parseMetadataStar(})
      listener: beginMetadataStar(enum)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(enum, }, enum, null, null, null, null, DirectiveContext(DirectiveState.Declarations))
      parseEnum(enum, null, enum)
        listener: beginEnumDeclarationPrelude(enum)
        ensureIdentifier(enum, enumDeclaration)
          listener: handleIdentifier(E, enumDeclaration)
        listener: handleNoTypeVariables(implemen)
        listener: beginEnumDeclaration(enum, null, enum, E)
        parsePrimaryConstructorOpt(E, null, false)
          listener: handleNoPrimaryConstructor(E, null, false)
        parseEnumHeaderOpt(E, enum)
          recoverySmallLookAheadSkipTokens(E, [OPEN_CURLY_BRACKET, WITH, IMPLEMENTS])
            reportRecoverableError(implemen, Message[Template(UnexpectedToken), Unexpected token 'implemen'., null, {lexeme: implemen}])
              listener: handleRecoverableError(Message[Template(UnexpectedToken), Unexpected token 'implemen'., null, {lexeme: implemen}], implemen, implemen)
          parseEnumWithClauseOpt(implemen)
            listener: handleEnumNoWithClause()
          parseClassOrMixinOrEnumImplementsOpt(implemen)
            listener: handleImplements(null, 0)
        listener: handleEnumHeader(null, enum, {)
        listener: beginEnumBody({)
        parseEnumElement({)
          parseMetadataStar({)
            listener: beginMetadataStar(v)
            listener: endMetadataStar(0)
          ensureIdentifier({, enumValueDeclaration)
            listener: handleIdentifier(v, enumValueDeclaration)
          listener: handleNoTypeNameInConstructorReference(})
          listener: beginConstructorReference(v)
          listener: handleNoTypeArguments(})
          listener: handleNoConstructorReferenceContinuationAfterTypeArguments(v)
          listener: endConstructorReference(v, null, v, ConstructorReferenceContext.Const)
          listener: handleNoArguments(v)
          listener: handleEnumElement({, null)
        listener: handleEnumElements(}, 1)
        listener: endEnumBody({, })
        listener: endEnumDeclaration(enum, enum, {, 0, })
  listener: endTopLevelDeclaration(})
  parseTopLevelDeclarationImpl(}, DirectiveContext(DirectiveState.Declarations))
    parseMetadataStar(})
      listener: beginMetadataStar(enum)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(enum, }, enum, null, null, null, null, DirectiveContext(DirectiveState.Declarations))
      parseEnum(enum, null, enum)
        listener: beginEnumDeclarationPrelude(enum)
        ensureIdentifier(enum, enumDeclaration)
          listener: handleIdentifier(E, enumDeclaration)
        listener: handleNoTypeVariables(implements)
        listener: beginEnumDeclaration(enum, null, enum, E)
        parsePrimaryConstructorOpt(E, null, false)
          listener: handleNoPrimaryConstructor(E, null, false)
        parseEnumHeaderOpt(E, enum)
          parseEnumWithClauseOpt(E)
            listener: handleEnumNoWithClause()
          parseClassOrMixinOrEnumImplementsOpt(E)
            listener: handleIdentifier(Foo, typeReference)
            listener: handleNoTypeArguments(w)
            listener: handleType(Foo, null)
            listener: handleImplements(implements, 1)
          recoveryEnumWith(Foo, Message[Template(OutOfOrderClauses), The 'with' clause must come before the 'implements' clause., Try moving the 'with' clause before the 'implements' clause., {expectedEarlierClause: with, expectedLaterClause: implements}])
          recoveryEnumImplements(Foo, Message[Template(MultipleClauses), Each 'enum' definition can have at most one 'implements' clause., Try combining all of the 'implements' clauses into a single clause., {definitionKind: enum, clauseKind: implements}])
          recoverySmallLookAheadSkipTokens(Foo, [OPEN_CURLY_BRACKET, WITH, IMPLEMENTS])
            reportRecoverableError(w, Message[Template(UnexpectedToken), Unexpected token 'w'., null, {lexeme: w}])
              listener: handleRecoverableError(Message[Template(UnexpectedToken), Unexpected token 'w'., null, {lexeme: w}], w, w)
        listener: handleEnumHeader(null, enum, {)
        listener: beginEnumBody({)
        parseEnumElement({)
          parseMetadataStar({)
            listener: beginMetadataStar(v)
            listener: endMetadataStar(0)
          ensureIdentifier({, enumValueDeclaration)
            listener: handleIdentifier(v, enumValueDeclaration)
          listener: handleNoTypeNameInConstructorReference(})
          listener: beginConstructorReference(v)
          listener: handleNoTypeArguments(})
          listener: handleNoConstructorReferenceContinuationAfterTypeArguments(v)
          listener: endConstructorReference(v, null, v, ConstructorReferenceContext.Const)
          listener: handleNoArguments(v)
          listener: handleEnumElement({, null)
        listener: handleEnumElements(}, 1)
        listener: endEnumBody({, })
        listener: endEnumDeclaration(enum, enum, {, 0, })
  listener: endTopLevelDeclaration(})
  parseTopLevelDeclarationImpl(}, DirectiveContext(DirectiveState.Declarations))
    parseMetadataStar(})
      listener: beginMetadataStar(enum)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(enum, }, enum, null, null, null, null, DirectiveContext(DirectiveState.Declarations))
      parseEnum(enum, null, enum)
        listener: beginEnumDeclarationPrelude(enum)
        ensureIdentifier(enum, enumDeclaration)
          listener: handleIdentifier(E, enumDeclaration)
        listener: handleNoTypeVariables(with)
        listener: beginEnumDeclaration(enum, null, enum, E)
        parsePrimaryConstructorOpt(E, null, false)
          listener: handleNoPrimaryConstructor(E, null, false)
        parseEnumHeaderOpt(E, enum)
          parseEnumWithClauseOpt(E)
            parseTypeList(with)
              listener: beginTypeList({)
              reportRecoverableErrorWithToken({, Template(ExpectedType))
                listener: handleRecoverableError(Message[Template(ExpectedType), Expected a type, but got '{'., null, {lexeme: {}], {, {)
              rewriter()
              listener: handleIdentifier(, typeReference)
              listener: handleNoTypeArguments({)
              listener: handleType(, null)
              listener: endTypeList(1)
            listener: handleEnumWithClause(with)
          parseClassOrMixinOrEnumImplementsOpt()
            listener: handleImplements(null, 0)
        listener: handleEnumHeader(null, enum, {)
        listener: beginEnumBody({)
        parseEnumElement({)
          parseMetadataStar({)
            listener: beginMetadataStar(v)
            listener: endMetadataStar(0)
          ensureIdentifier({, enumValueDeclaration)
            listener: handleIdentifier(v, enumValueDeclaration)
          listener: handleNoTypeNameInConstructorReference(})
          listener: beginConstructorReference(v)
          listener: handleNoTypeArguments(})
          listener: handleNoConstructorReferenceContinuationAfterTypeArguments(v)
          listener: endConstructorReference(v, null, v, ConstructorReferenceContext.Const)
          listener: handleNoArguments(v)
          listener: handleEnumElement({, null)
        listener: handleEnumElements(}, 1)
        listener: endEnumBody({, })
        listener: endEnumDeclaration(enum, enum, {, 0, })
  listener: endTopLevelDeclaration(})
  parseTopLevelDeclarationImpl(}, DirectiveContext(DirectiveState.Declarations))
    parseMetadataStar(})
      listener: beginMetadataStar(enum)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(enum, }, enum, null, null, null, null, DirectiveContext(DirectiveState.Declarations))
      parseEnum(enum, null, enum)
        listener: beginEnumDeclarationPrelude(enum)
        ensureIdentifier(enum, enumDeclaration)
          listener: handleIdentifier(E, enumDeclaration)
        listener: handleNoTypeVariables(impl)
        listener: beginEnumDeclaration(enum, null, enum, E)
        parsePrimaryConstructorOpt(E, null, false)
          listener: handleNoPrimaryConstructor(E, null, false)
        parseEnumHeaderOpt(E, enum)
          recoverySmallLookAheadSkipTokens(E, [OPEN_CURLY_BRACKET, WITH, IMPLEMENTS])
            reportRecoverableError(impl, Message[Template(UnexpectedToken), Unexpected token 'impl'., null, {lexeme: impl}])
              listener: handleRecoverableError(Message[Template(UnexpectedToken), Unexpected token 'impl'., null, {lexeme: impl}], impl, impl)
          parseEnumWithClauseOpt(impl)
            listener: handleEnumNoWithClause()
          parseClassOrMixinOrEnumImplementsOpt(impl)
            listener: handleIdentifier(Foo, typeReference)
            listener: handleNoTypeArguments({)
            listener: handleType(Foo, null)
            listener: handleImplements(implements, 1)
        listener: handleEnumHeader(null, enum, {)
        listener: beginEnumBody({)
        parseEnumElement({)
          parseMetadataStar({)
            listener: beginMetadataStar(v)
            listener: endMetadataStar(0)
          ensureIdentifier({, enumValueDeclaration)
            listener: handleIdentifier(v, enumValueDeclaration)
          listener: handleNoTypeNameInConstructorReference(})
          listener: beginConstructorReference(v)
          listener: handleNoTypeArguments(})
          listener: handleNoConstructorReferenceContinuationAfterTypeArguments(v)
          listener: endConstructorReference(v, null, v, ConstructorReferenceContext.Const)
          listener: handleNoArguments(v)
          listener: handleEnumElement({, null)
        listener: handleEnumElements(}, 1)
        listener: endEnumBody({, })
        listener: endEnumDeclaration(enum, enum, {, 0, })
  listener: endTopLevelDeclaration(})
  parseTopLevelDeclarationImpl(}, DirectiveContext(DirectiveState.Declarations))
    parseMetadataStar(})
      listener: beginMetadataStar(enum)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(enum, }, enum, null, null, null, null, DirectiveContext(DirectiveState.Declarations))
      parseEnum(enum, null, enum)
        listener: beginEnumDeclarationPrelude(enum)
        ensureIdentifier(enum, enumDeclaration)
          listener: handleIdentifier(E, enumDeclaration)
        listener: handleNoTypeVariables(with)
        listener: beginEnumDeclaration(enum, null, enum, E)
        parsePrimaryConstructorOpt(E, null, false)
          listener: handleNoPrimaryConstructor(E, null, false)
        parseEnumHeaderOpt(E, enum)
          parseEnumWithClauseOpt(E)
            parseTypeList(with)
              listener: beginTypeList(Foo)
              listener: handleIdentifier(Foo, typeReference)
              listener: handleNoTypeArguments(implements)
              listener: handleType(Foo, null)
              listener: endTypeList(1)
            listener: handleEnumWithClause(with)
          parseClassOrMixinOrEnumImplementsOpt(Foo)
            listener: handleIdentifier(Bar, typeReference)
            listener: handleNoTypeArguments({)
            listener: handleType(Bar, null)
            listener: handleImplements(implements, 1)
        listener: handleEnumHeader(null, enum, {)
        listener: beginEnumBody({)
        parseEnumElement({)
          parseMetadataStar({)
            listener: beginMetadataStar(v)
            listener: endMetadataStar(0)
          ensureIdentifier({, enumValueDeclaration)
            listener: handleIdentifier(v, enumValueDeclaration)
          listener: handleNoTypeNameInConstructorReference(})
          listener: beginConstructorReference(v)
          listener: handleNoTypeArguments(})
          listener: handleNoConstructorReferenceContinuationAfterTypeArguments(v)
          listener: endConstructorReference(v, null, v, ConstructorReferenceContext.Const)
          listener: handleNoArguments(v)
          listener: handleEnumElement({, null)
        listener: handleEnumElements(}, 1)
        listener: endEnumBody({, })
        listener: endEnumDeclaration(enum, enum, {, 0, })
  listener: endTopLevelDeclaration(})
  parseTopLevelDeclarationImpl(}, DirectiveContext(DirectiveState.Declarations))
    parseMetadataStar(})
      listener: beginMetadataStar(enum)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(enum, }, enum, null, null, null, null, DirectiveContext(DirectiveState.Declarations))
      parseEnum(enum, null, enum)
        listener: beginEnumDeclarationPrelude(enum)
        ensureIdentifier(enum, enumDeclaration)
          listener: handleIdentifier(E, enumDeclaration)
        listener: handleNoTypeVariables(implements)
        listener: beginEnumDeclaration(enum, null, enum, E)
        parsePrimaryConstructorOpt(E, null, false)
          listener: handleNoPrimaryConstructor(E, null, false)
        parseEnumHeaderOpt(E, enum)
          parseEnumWithClauseOpt(E)
            listener: handleEnumNoWithClause()
          parseClassOrMixinOrEnumImplementsOpt(E)
            listener: handleIdentifier(Bar, typeReference)
            listener: handleNoTypeArguments(with)
            listener: handleType(Bar, null)
            listener: handleImplements(implements, 1)
          recoveryEnumWith(Bar, Message[Template(OutOfOrderClauses), The 'with' clause must come before the 'implements' clause., Try moving the 'with' clause before the 'implements' clause., {expectedEarlierClause: with, expectedLaterClause: implements}])
            reportRecoverableError(with, Message[Template(OutOfOrderClauses), The 'with' clause must come before the 'implements' clause., Try moving the 'with' clause before the 'implements' clause., {expectedEarlierClause: with, expectedLaterClause: implements}])
              listener: handleRecoverableError(Message[Template(OutOfOrderClauses), The 'with' clause must come before the 'implements' clause., Try moving the 'with' clause before the 'implements' clause., {expectedEarlierClause: with, expectedLaterClause: implements}], with, with)
            parseEnumWithClauseOpt(Bar)
              parseTypeList(with)
        listener: handleEnumHeader(null, enum, {)
        listener: beginEnumBody({)
        parseEnumElement({)
          parseMetadataStar({)
            listener: beginMetadataStar(v)
            listener: endMetadataStar(0)
          ensureIdentifier({, enumValueDeclaration)
            listener: handleIdentifier(v, enumValueDeclaration)
          listener: handleNoTypeNameInConstructorReference(})
          listener: beginConstructorReference(v)
          listener: handleNoTypeArguments(})
          listener: handleNoConstructorReferenceContinuationAfterTypeArguments(v)
          listener: endConstructorReference(v, null, v, ConstructorReferenceContext.Const)
          listener: handleNoArguments(v)
          listener: handleEnumElement({, null)
        listener: handleEnumElements(}, 1)
        listener: endEnumBody({, })
        listener: endEnumDeclaration(enum, enum, {, 0, })
  listener: endTopLevelDeclaration(})
  parseTopLevelDeclarationImpl(}, DirectiveContext(DirectiveState.Declarations))
    parseMetadataStar(})
      listener: beginMetadataStar(enum)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(enum, }, enum, null, null, null, null, DirectiveContext(DirectiveState.Declarations))
      parseEnum(enum, null, enum)
        listener: beginEnumDeclarationPrelude(enum)
        ensureIdentifier(enum, enumDeclaration)
          listener: handleIdentifier(E, enumDeclaration)
        listener: handleNoTypeVariables(gunk1)
        listener: beginEnumDeclaration(enum, null, enum, E)
        parsePrimaryConstructorOpt(E, null, false)
          listener: handleNoPrimaryConstructor(E, null, false)
        parseEnumHeaderOpt(E, enum)
          recoverySmallLookAheadSkipTokens(E, [OPEN_CURLY_BRACKET, WITH, IMPLEMENTS])
            reportRecoverableError(gunk1, Message[Template(UnexpectedToken), Unexpected token 'gunk1'., null, {lexeme: gunk1}])
              listener: handleRecoverableError(Message[Template(UnexpectedToken), Unexpected token 'gunk1'., null, {lexeme: gunk1}], gunk1, gunk1)
          parseEnumWithClauseOpt(gunk1)
            parseTypeList(with)
              listener: beginTypeList(Foo)
              listener: handleIdentifier(Foo, typeReference)
              listener: handleNoTypeArguments(gunk2)
              listener: handleType(Foo, null)
              listener: endTypeList(1)
            listener: handleEnumWithClause(with)
          recoveryEnumWith(Foo, Message[Template(MultipleClauses), Each 'enum' definition can have at most one 'with' clause., Try combining all of the 'with' clauses into a single clause., {definitionKind: enum, clauseKind: with}])
          recoverySmallLookAheadSkipTokens(Foo, [OPEN_CURLY_BRACKET, WITH, IMPLEMENTS])
            reportRecoverableError(gunk2, Message[Template(UnexpectedToken), Unexpected token 'gunk2'., null, {lexeme: gunk2}])
              listener: handleRecoverableError(Message[Template(UnexpectedToken), Unexpected token 'gunk2'., null, {lexeme: gunk2}], gunk2, gunk2)
          parseClassOrMixinOrEnumImplementsOpt(gunk2)
            listener: handleIdentifier(Bar, typeReference)
            listener: handleNoTypeArguments({)
            listener: handleType(Bar, null)
            listener: handleImplements(implements, 1)
        listener: handleEnumHeader(null, enum, {)
        listener: beginEnumBody({)
        parseEnumElement({)
          parseMetadataStar({)
            listener: beginMetadataStar(v)
            listener: endMetadataStar(0)
          ensureIdentifier({, enumValueDeclaration)
            listener: handleIdentifier(v, enumValueDeclaration)
          listener: handleNoTypeNameInConstructorReference(})
          listener: beginConstructorReference(v)
          listener: handleNoTypeArguments(})
          listener: handleNoConstructorReferenceContinuationAfterTypeArguments(v)
          listener: endConstructorReference(v, null, v, ConstructorReferenceContext.Const)
          listener: handleNoArguments(v)
          listener: handleEnumElement({, null)
        listener: handleEnumElements(}, 1)
        listener: endEnumBody({, })
        listener: endEnumDeclaration(enum, enum, {, 0, })
  listener: endTopLevelDeclaration(})
  parseTopLevelDeclarationImpl(}, DirectiveContext(DirectiveState.Declarations))
    parseMetadataStar(})
      listener: beginMetadataStar(enum)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(enum, }, enum, null, null, null, null, DirectiveContext(DirectiveState.Declarations))
      parseEnum(enum, null, enum)
        listener: beginEnumDeclarationPrelude(enum)
        ensureIdentifier(enum, enumDeclaration)
          listener: handleIdentifier(E, enumDeclaration)
        listener: handleNoTypeVariables(gunk1)
        listener: beginEnumDeclaration(enum, null, enum, E)
        parsePrimaryConstructorOpt(E, null, false)
          listener: handleNoPrimaryConstructor(E, null, false)
        parseEnumHeaderOpt(E, enum)
          recoverySmallLookAheadSkipTokens(E, [OPEN_CURLY_BRACKET, WITH, IMPLEMENTS])
            reportRecoverableError(gunk1, Message[Template(UnexpectedToken), Unexpected token 'gunk1'., null, {lexeme: gunk1}])
              listener: handleRecoverableError(Message[Template(UnexpectedToken), Unexpected token 'gunk1'., null, {lexeme: gunk1}], gunk1, gunk1)
          parseEnumWithClauseOpt(gunk1)
            listener: handleEnumNoWithClause()
          parseClassOrMixinOrEnumImplementsOpt(gunk1)
            listener: handleIdentifier(Bar, typeReference)
            listener: handleNoTypeArguments(gunk2)
            listener: handleType(Bar, null)
            listener: handleImplements(implements, 1)
          recoveryEnumWith(Bar, Message[Template(OutOfOrderClauses), The 'with' clause must come before the 'implements' clause., Try moving the 'with' clause before the 'implements' clause., {expectedEarlierClause: with, expectedLaterClause: implements}])
          recoveryEnumImplements(Bar, Message[Template(MultipleClauses), Each 'enum' definition can have at most one 'implements' clause., Try combining all of the 'implements' clauses into a single clause., {definitionKind: enum, clauseKind: implements}])
          recoverySmallLookAheadSkipTokens(Bar, [OPEN_CURLY_BRACKET, WITH, IMPLEMENTS])
            reportRecoverableError(gunk2, Message[Template(UnexpectedToken), Unexpected token 'gunk2'., null, {lexeme: gunk2}])
              listener: handleRecoverableError(Message[Template(UnexpectedToken), Unexpected token 'gunk2'., null, {lexeme: gunk2}], gunk2, gunk2)
          recoveryEnumWith(gunk2, Message[Template(OutOfOrderClauses), The 'with' clause must come before the 'implements' clause., Try moving the 'with' clause before the 'implements' clause., {expectedEarlierClause: with, expectedLaterClause: implements}])
            reportRecoverableError(with, Message[Template(OutOfOrderClauses), The 'with' clause must come before the 'implements' clause., Try moving the 'with' clause before the 'implements' clause., {expectedEarlierClause: with, expectedLaterClause: implements}])
              listener: handleRecoverableError(Message[Template(OutOfOrderClauses), The 'with' clause must come before the 'implements' clause., Try moving the 'with' clause before the 'implements' clause., {expectedEarlierClause: with, expectedLaterClause: implements}], with, with)
            parseEnumWithClauseOpt(gunk2)
              parseTypeList(with)
        listener: handleEnumHeader(null, enum, {)
        listener: beginEnumBody({)
        parseEnumElement({)
          parseMetadataStar({)
            listener: beginMetadataStar(v)
            listener: endMetadataStar(0)
          ensureIdentifier({, enumValueDeclaration)
            listener: handleIdentifier(v, enumValueDeclaration)
          listener: handleNoTypeNameInConstructorReference(})
          listener: beginConstructorReference(v)
          listener: handleNoTypeArguments(})
          listener: handleNoConstructorReferenceContinuationAfterTypeArguments(v)
          listener: endConstructorReference(v, null, v, ConstructorReferenceContext.Const)
          listener: handleNoArguments(v)
          listener: handleEnumElement({, null)
        listener: handleEnumElements(}, 1)
        listener: endEnumBody({, })
        listener: endEnumDeclaration(enum, enum, {, 0, })
  listener: endTopLevelDeclaration(})
  parseTopLevelDeclarationImpl(}, DirectiveContext(DirectiveState.Declarations))
    parseMetadataStar(})
      listener: beginMetadataStar(enum)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(enum, }, enum, null, null, null, null, DirectiveContext(DirectiveState.Declarations))
      parseEnum(enum, null, enum)
        listener: beginEnumDeclarationPrelude(enum)
        ensureIdentifier(enum, enumDeclaration)
          listener: handleIdentifier(E, enumDeclaration)
        listener: handleNoTypeVariables(with)
        listener: beginEnumDeclaration(enum, null, enum, E)
        parsePrimaryConstructorOpt(E, null, false)
          listener: handleNoPrimaryConstructor(E, null, false)
        parseEnumHeaderOpt(E, enum)
          parseEnumWithClauseOpt(E)
            parseTypeList(with)
              listener: beginTypeList(Foo)
              listener: handleIdentifier(Foo, typeReference)
              listener: handleNoTypeArguments(with)
              listener: handleType(Foo, null)
              listener: endTypeList(1)
            listener: handleEnumWithClause(with)
          recoveryEnumWith(Foo, Message[Template(MultipleClauses), Each 'enum' definition can have at most one 'with' clause., Try combining all of the 'with' clauses into a single clause., {definitionKind: enum, clauseKind: with}])
            reportRecoverableError(with, Message[Template(MultipleClauses), Each 'enum' definition can have at most one 'with' clause., Try combining all of the 'with' clauses into a single clause., {definitionKind: enum, clauseKind: with}])
              listener: handleRecoverableError(Message[Template(MultipleClauses), Each 'enum' definition can have at most one 'with' clause., Try combining all of the 'with' clauses into a single clause., {definitionKind: enum, clauseKind: with}], with, with)
            parseEnumWithClauseOpt(Foo)
              parseTypeList(with)
          parseClassOrMixinOrEnumImplementsOpt(Foo2)
            listener: handleIdentifier(Bar, typeReference)
            listener: handleNoTypeArguments(implements)
            listener: handleType(Bar, null)
            listener: handleImplements(implements, 1)
          recoveryEnumWith(Bar, Message[Template(MultipleClauses), Each 'enum' definition can have at most one 'with' clause., Try combining all of the 'with' clauses into a single clause., {definitionKind: enum, clauseKind: with}])
          recoveryEnumImplements(Bar, Message[Template(MultipleClauses), Each 'enum' definition can have at most one 'implements' clause., Try combining all of the 'implements' clauses into a single clause., {definitionKind: enum, clauseKind: implements}])
            reportRecoverableError(implements, Message[Template(MultipleClauses), Each 'enum' definition can have at most one 'implements' clause., Try combining all of the 'implements' clauses into a single clause., {definitionKind: enum, clauseKind: implements}])
              listener: handleRecoverableError(Message[Template(MultipleClauses), Each 'enum' definition can have at most one 'implements' clause., Try combining all of the 'implements' clauses into a single clause., {definitionKind: enum, clauseKind: implements}], implements, implements)
            parseClassOrMixinOrEnumImplementsOpt(Bar)
          recoveryEnumWith(Bar2, Message[Template(MultipleClauses), Each 'enum' definition can have at most one 'with' clause., Try combining all of the 'with' clauses into a single clause., {definitionKind: enum, clauseKind: with}])
            reportRecoverableError(with, Message[Template(MultipleClauses), Each 'enum' definition can have at most one 'with' clause., Try combining all of the 'with' clauses into a single clause., {definitionKind: enum, clauseKind: with}])
              listener: handleRecoverableError(Message[Template(MultipleClauses), Each 'enum' definition can have at most one 'with' clause., Try combining all of the 'with' clauses into a single clause., {definitionKind: enum, clauseKind: with}], with, with)
            parseEnumWithClauseOpt(Bar2)
              parseTypeList(with)
          recoveryEnumWith(Foo3, Message[Template(MultipleClauses), Each 'enum' definition can have at most one 'with' clause., Try combining all of the 'with' clauses into a single clause., {definitionKind: enum, clauseKind: with}])
          recoveryEnumImplements(Foo3, Message[Template(MultipleClauses), Each 'enum' definition can have at most one 'implements' clause., Try combining all of the 'implements' clauses into a single clause., {definitionKind: enum, clauseKind: implements}])
            reportRecoverableError(implements, Message[Template(MultipleClauses), Each 'enum' definition can have at most one 'implements' clause., Try combining all of the 'implements' clauses into a single clause., {definitionKind: enum, clauseKind: implements}])
              listener: handleRecoverableError(Message[Template(MultipleClauses), Each 'enum' definition can have at most one 'implements' clause., Try combining all of the 'implements' clauses into a single clause., {definitionKind: enum, clauseKind: implements}], implements, implements)
            parseClassOrMixinOrEnumImplementsOpt(Foo3)
        listener: handleEnumHeader(null, enum, {)
        listener: beginEnumBody({)
        parseEnumElement({)
          parseMetadataStar({)
            listener: beginMetadataStar(v)
            listener: endMetadataStar(0)
          ensureIdentifier({, enumValueDeclaration)
            listener: handleIdentifier(v, enumValueDeclaration)
          listener: handleNoTypeNameInConstructorReference(})
          listener: beginConstructorReference(v)
          listener: handleNoTypeArguments(})
          listener: handleNoConstructorReferenceContinuationAfterTypeArguments(v)
          listener: endConstructorReference(v, null, v, ConstructorReferenceContext.Const)
          listener: handleNoArguments(v)
          listener: handleEnumElement({, null)
        listener: handleEnumElements(}, 1)
        listener: endEnumBody({, })
        listener: endEnumDeclaration(enum, enum, {, 0, })
  listener: endTopLevelDeclaration(})
  parseTopLevelDeclarationImpl(}, DirectiveContext(DirectiveState.Declarations))
    parseMetadataStar(})
      listener: beginMetadataStar(enum)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(enum, }, enum, null, null, null, null, DirectiveContext(DirectiveState.Declarations))
      parseEnum(enum, null, enum)
        listener: beginEnumDeclarationPrelude(enum)
        ensureIdentifier(enum, enumDeclaration)
          listener: handleIdentifier(E, enumDeclaration)
        listener: handleNoTypeVariables(implements)
        listener: beginEnumDeclaration(enum, null, enum, E)
        parsePrimaryConstructorOpt(E, null, false)
          listener: handleNoPrimaryConstructor(E, null, false)
        parseEnumHeaderOpt(E, enum)
          parseEnumWithClauseOpt(E)
            listener: handleEnumNoWithClause()
          parseClassOrMixinOrEnumImplementsOpt(E)
            listener: handleIdentifier(Bar, typeReference)
            listener: handleNoTypeArguments(implements)
            listener: handleType(Bar, null)
            listener: handleImplements(implements, 1)
          recoveryEnumWith(Bar, Message[Template(OutOfOrderClauses), The 'with' clause must come before the 'implements' clause., Try moving the 'with' clause before the 'implements' clause., {expectedEarlierClause: with, expectedLaterClause: implements}])
          recoveryEnumImplements(Bar, Message[Template(MultipleClauses), Each 'enum' definition can have at most one 'implements' clause., Try combining all of the 'implements' clauses into a single clause., {definitionKind: enum, clauseKind: implements}])
            reportRecoverableError(implements, Message[Template(MultipleClauses), Each 'enum' definition can have at most one 'implements' clause., Try combining all of the 'implements' clauses into a single clause., {definitionKind: enum, clauseKind: implements}])
              listener: handleRecoverableError(Message[Template(MultipleClauses), Each 'enum' definition can have at most one 'implements' clause., Try combining all of the 'implements' clauses into a single clause., {definitionKind: enum, clauseKind: implements}], implements, implements)
            parseClassOrMixinOrEnumImplementsOpt(Bar)
          recoveryEnumWith(Bar2, Message[Template(OutOfOrderClauses), The 'with' clause must come before the 'implements' clause., Try moving the 'with' clause before the 'implements' clause., {expectedEarlierClause: with, expectedLaterClause: implements}])
            reportRecoverableError(with, Message[Template(OutOfOrderClauses), The 'with' clause must come before the 'implements' clause., Try moving the 'with' clause before the 'implements' clause., {expectedEarlierClause: with, expectedLaterClause: implements}])
              listener: handleRecoverableError(Message[Template(OutOfOrderClauses), The 'with' clause must come before the 'implements' clause., Try moving the 'with' clause before the 'implements' clause., {expectedEarlierClause: with, expectedLaterClause: implements}], with, with)
            parseEnumWithClauseOpt(Bar2)
              parseTypeList(with)
          recoveryEnumWith(Foo, Message[Template(MultipleClauses), Each 'enum' definition can have at most one 'with' clause., Try combining all of the 'with' clauses into a single clause., {definitionKind: enum, clauseKind: with}])
            reportRecoverableError(with, Message[Template(MultipleClauses), Each 'enum' definition can have at most one 'with' clause., Try combining all of the 'with' clauses into a single clause., {definitionKind: enum, clauseKind: with}])
              listener: handleRecoverableError(Message[Template(MultipleClauses), Each 'enum' definition can have at most one 'with' clause., Try combining all of the 'with' clauses into a single clause., {definitionKind: enum, clauseKind: with}], with, with)
            parseEnumWithClauseOpt(Foo)
              parseTypeList(with)
          recoveryEnumWith(Foo2, Message[Template(MultipleClauses), Each 'enum' definition can have at most one 'with' clause., Try combining all of the 'with' clauses into a single clause., {definitionKind: enum, clauseKind: with}])
          recoveryEnumImplements(Foo2, Message[Template(MultipleClauses), Each 'enum' definition can have at most one 'implements' clause., Try combining all of the 'implements' clauses into a single clause., {definitionKind: enum, clauseKind: implements}])
            reportRecoverableError(implements, Message[Template(MultipleClauses), Each 'enum' definition can have at most one 'implements' clause., Try combining all of the 'implements' clauses into a single clause., {definitionKind: enum, clauseKind: implements}])
              listener: handleRecoverableError(Message[Template(MultipleClauses), Each 'enum' definition can have at most one 'implements' clause., Try combining all of the 'implements' clauses into a single clause., {definitionKind: enum, clauseKind: implements}], implements, implements)
            parseClassOrMixinOrEnumImplementsOpt(Foo2)
          recoveryEnumWith(Bar3, Message[Template(MultipleClauses), Each 'enum' definition can have at most one 'with' clause., Try combining all of the 'with' clauses into a single clause., {definitionKind: enum, clauseKind: with}])
            reportRecoverableError(with, Message[Template(MultipleClauses), Each 'enum' definition can have at most one 'with' clause., Try combining all of the 'with' clauses into a single clause., {definitionKind: enum, clauseKind: with}])
              listener: handleRecoverableError(Message[Template(MultipleClauses), Each 'enum' definition can have at most one 'with' clause., Try combining all of the 'with' clauses into a single clause., {definitionKind: enum, clauseKind: with}], with, with)
            parseEnumWithClauseOpt(Bar3)
              parseTypeList(with)
        listener: handleEnumHeader(null, enum, {)
        listener: beginEnumBody({)
        parseEnumElement({)
          parseMetadataStar({)
            listener: beginMetadataStar(v)
            listener: endMetadataStar(0)
          ensureIdentifier({, enumValueDeclaration)
            listener: handleIdentifier(v, enumValueDeclaration)
          listener: handleNoTypeNameInConstructorReference(})
          listener: beginConstructorReference(v)
          listener: handleNoTypeArguments(})
          listener: handleNoConstructorReferenceContinuationAfterTypeArguments(v)
          listener: endConstructorReference(v, null, v, ConstructorReferenceContext.Const)
          listener: handleNoArguments(v)
          listener: handleEnumElement({, null)
        listener: handleEnumElements(}, 1)
        listener: endEnumBody({, })
        listener: endEnumDeclaration(enum, enum, {, 0, })
  listener: endTopLevelDeclaration(})
  reportAllErrorTokens(enum)
  listener: endCompilationUnit(15, )
