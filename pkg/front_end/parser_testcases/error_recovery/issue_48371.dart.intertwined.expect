parseUnit(enum)
  skipErrorTokens(enum)
  listener: beginCompilationUnit(enum)
  syntheticPreviousToken(enum)
  parseTopLevelDeclarationImpl(, Instance of 'DirectiveContext')
    parseMetadataStar()
      listener: beginMetadataStar(enum)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(, enum, null, null, null, null, null, Instance of 'DirectiveContext')
      parseEnum(enum)
        listener: beginUncategorizedTopLevelDeclaration(enum)
        ensureIdentifier(enum, enumDeclaration)
          listener: handleIdentifier(E, enumDeclaration)
        listener: beginEnum(enum)
        parseEnumHeaderOpt(E, enum)
          listener: handleNoTypeVariables(w)
          recoverySmallLookAheadSkipTokens(E, [{, with, implements])
            reportRecoverableError(w, Message[UnexpectedToken, Unexpected token 'w'., null, {lexeme: w}])
              listener: handleRecoverableError(Message[UnexpectedToken, Unexpected token 'w'., null, {lexeme: w}], w, w)
          parseEnumWithClauseOpt(w)
            listener: handleEnumNoWithClause()
          parseClassOrMixinOrEnumImplementsOpt(w)
            listener: handleImplements(null, 0)
        listener: handleEnumHeader(enum, {)
        parseEnumElement({)
          parseMetadataStar({)
            listener: beginMetadataStar(v)
            listener: endMetadataStar(0)
          ensureIdentifier({, enumValueDeclaration)
            listener: handleIdentifier(v, enumValueDeclaration)
          listener: handleNoTypeNameInConstructorReference(})
          listener: beginConstructorReference(v)
          listener: handleNoTypeArguments(})
          listener: handleNoConstructorReferenceContinuationAfterTypeArguments(})
          listener: endConstructorReference(v, null, }, ConstructorReferenceContext.Const)
          listener: handleNoArguments(v)
          listener: handleEnumElement({)
        listener: handleEnumElements(}, 1)
        listener: endEnum(enum, {, 0)
  listener: endTopLevelDeclaration(enum)
  parseTopLevelDeclarationImpl(}, Instance of 'DirectiveContext')
    parseMetadataStar(})
      listener: beginMetadataStar(enum)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(}, enum, null, null, null, null, null, Instance of 'DirectiveContext')
      parseEnum(enum)
        listener: beginUncategorizedTopLevelDeclaration(enum)
        ensureIdentifier(enum, enumDeclaration)
          listener: handleIdentifier(E, enumDeclaration)
        listener: beginEnum(enum)
        parseEnumHeaderOpt(E, enum)
          listener: handleNoTypeVariables(w)
          recoverySmallLookAheadSkipTokens(E, [{, with, implements])
            reportRecoverableError(w, Message[UnexpectedToken, Unexpected token 'w'., null, {lexeme: w}])
              listener: handleRecoverableError(Message[UnexpectedToken, Unexpected token 'w'., null, {lexeme: w}], w, w)
          parseEnumWithClauseOpt(w)
            listener: handleEnumNoWithClause()
          parseClassOrMixinOrEnumImplementsOpt(w)
            listener: handleIdentifier(Foo, typeReference)
            listener: handleNoTypeArguments({)
            listener: handleType(Foo, null)
            listener: handleImplements(implements, 1)
        listener: handleEnumHeader(enum, {)
        parseEnumElement({)
          parseMetadataStar({)
            listener: beginMetadataStar(v)
            listener: endMetadataStar(0)
          ensureIdentifier({, enumValueDeclaration)
            listener: handleIdentifier(v, enumValueDeclaration)
          listener: handleNoTypeNameInConstructorReference(})
          listener: beginConstructorReference(v)
          listener: handleNoTypeArguments(})
          listener: handleNoConstructorReferenceContinuationAfterTypeArguments(})
          listener: endConstructorReference(v, null, }, ConstructorReferenceContext.Const)
          listener: handleNoArguments(v)
          listener: handleEnumElement({)
        listener: handleEnumElements(}, 1)
        listener: endEnum(enum, {, 0)
  listener: endTopLevelDeclaration(enum)
  parseTopLevelDeclarationImpl(}, Instance of 'DirectiveContext')
    parseMetadataStar(})
      listener: beginMetadataStar(enum)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(}, enum, null, null, null, null, null, Instance of 'DirectiveContext')
      parseEnum(enum)
        listener: beginUncategorizedTopLevelDeclaration(enum)
        ensureIdentifier(enum, enumDeclaration)
          listener: handleIdentifier(E, enumDeclaration)
        listener: beginEnum(enum)
        parseEnumHeaderOpt(E, enum)
          listener: handleNoTypeVariables(implements)
          parseEnumWithClauseOpt(E)
            listener: handleEnumNoWithClause()
          parseClassOrMixinOrEnumImplementsOpt(E)
            listener: handleIdentifier(Foo, typeReference)
            listener: handleNoTypeArguments(with)
            listener: handleType(Foo, null)
            listener: handleImplements(implements, 1)
          recoveryEnumWith(Foo, Message[OutOfOrderClauses, The 'with' clause must come before the 'implements' clause., Try moving the 'with' clause before the 'implements' clause., {string: with, string2: implements}])
            reportRecoverableError(with, Message[OutOfOrderClauses, The 'with' clause must come before the 'implements' clause., Try moving the 'with' clause before the 'implements' clause., {string: with, string2: implements}])
              listener: handleRecoverableError(Message[OutOfOrderClauses, The 'with' clause must come before the 'implements' clause., Try moving the 'with' clause before the 'implements' clause., {string: with, string2: implements}], with, with)
            parseEnumWithClauseOpt(Foo)
              parseTypeList(with)
        listener: handleEnumHeader(enum, {)
        parseEnumElement({)
          parseMetadataStar({)
            listener: beginMetadataStar(v)
            listener: endMetadataStar(0)
          ensureIdentifier({, enumValueDeclaration)
            listener: handleIdentifier(v, enumValueDeclaration)
          listener: handleNoTypeNameInConstructorReference(})
          listener: beginConstructorReference(v)
          listener: handleNoTypeArguments(})
          listener: handleNoConstructorReferenceContinuationAfterTypeArguments(})
          listener: endConstructorReference(v, null, }, ConstructorReferenceContext.Const)
          listener: handleNoArguments(v)
          listener: handleEnumElement({)
        listener: handleEnumElements(}, 1)
        listener: endEnum(enum, {, 0)
  listener: endTopLevelDeclaration(enum)
  parseTopLevelDeclarationImpl(}, Instance of 'DirectiveContext')
    parseMetadataStar(})
      listener: beginMetadataStar(enum)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(}, enum, null, null, null, null, null, Instance of 'DirectiveContext')
      parseEnum(enum)
        listener: beginUncategorizedTopLevelDeclaration(enum)
        ensureIdentifier(enum, enumDeclaration)
          listener: handleIdentifier(E, enumDeclaration)
        listener: beginEnum(enum)
        parseEnumHeaderOpt(E, enum)
          listener: handleNoTypeVariables(implements)
          parseEnumWithClauseOpt(E)
            listener: handleEnumNoWithClause()
          parseClassOrMixinOrEnumImplementsOpt(E)
            listener: handleIdentifier(Foo, typeReference)
            listener: handleNoTypeArguments(implements)
            listener: handleType(Foo, null)
            listener: handleImplements(implements, 1)
          recoveryEnumWith(Foo, Message[OutOfOrderClauses, The 'with' clause must come before the 'implements' clause., Try moving the 'with' clause before the 'implements' clause., {string: with, string2: implements}])
          recoveryEnumImplements(Foo, Message[MultipleClauses, Each 'enum' definition can have at most one 'implements' clause., Try combining all of the 'implements' clauses into a single clause., {string: enum, string2: implements}])
            reportRecoverableError(implements, Message[MultipleClauses, Each 'enum' definition can have at most one 'implements' clause., Try combining all of the 'implements' clauses into a single clause., {string: enum, string2: implements}])
              listener: handleRecoverableError(Message[MultipleClauses, Each 'enum' definition can have at most one 'implements' clause., Try combining all of the 'implements' clauses into a single clause., {string: enum, string2: implements}], implements, implements)
            parseClassOrMixinOrEnumImplementsOpt(Foo)
          recoveryEnumWith(Bar, Message[OutOfOrderClauses, The 'with' clause must come before the 'implements' clause., Try moving the 'with' clause before the 'implements' clause., {string: with, string2: implements}])
          recoveryEnumImplements(Bar, Message[MultipleClauses, Each 'enum' definition can have at most one 'implements' clause., Try combining all of the 'implements' clauses into a single clause., {string: enum, string2: implements}])
            reportRecoverableError(implements, Message[MultipleClauses, Each 'enum' definition can have at most one 'implements' clause., Try combining all of the 'implements' clauses into a single clause., {string: enum, string2: implements}])
              listener: handleRecoverableError(Message[MultipleClauses, Each 'enum' definition can have at most one 'implements' clause., Try combining all of the 'implements' clauses into a single clause., {string: enum, string2: implements}], implements, implements)
            parseClassOrMixinOrEnumImplementsOpt(Bar)
        listener: handleEnumHeader(enum, {)
        parseEnumElement({)
          parseMetadataStar({)
            listener: beginMetadataStar(v)
            listener: endMetadataStar(0)
          ensureIdentifier({, enumValueDeclaration)
            listener: handleIdentifier(v, enumValueDeclaration)
          listener: handleNoTypeNameInConstructorReference(})
          listener: beginConstructorReference(v)
          listener: handleNoTypeArguments(})
          listener: handleNoConstructorReferenceContinuationAfterTypeArguments(})
          listener: endConstructorReference(v, null, }, ConstructorReferenceContext.Const)
          listener: handleNoArguments(v)
          listener: handleEnumElement({)
        listener: handleEnumElements(}, 1)
        listener: endEnum(enum, {, 0)
  listener: endTopLevelDeclaration(enum)
  parseTopLevelDeclarationImpl(}, Instance of 'DirectiveContext')
    parseMetadataStar(})
      listener: beginMetadataStar(enum)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(}, enum, null, null, null, null, null, Instance of 'DirectiveContext')
      parseEnum(enum)
        listener: beginUncategorizedTopLevelDeclaration(enum)
        ensureIdentifier(enum, enumDeclaration)
          listener: handleIdentifier(E, enumDeclaration)
        listener: beginEnum(enum)
        parseEnumHeaderOpt(E, enum)
          listener: handleNoTypeVariables(w)
          recoverySmallLookAheadSkipTokens(E, [{, with, implements])
            reportRecoverableErrorWithEnd(w, Foo, UnexpectedTokens)
              listener: handleRecoverableError(UnexpectedTokens, w, Foo)
          parseEnumWithClauseOpt(Foo)
            listener: handleEnumNoWithClause()
          parseClassOrMixinOrEnumImplementsOpt(Foo)
            listener: handleImplements(null, 0)
        listener: handleEnumHeader(enum, {)
        parseEnumElement({)
          parseMetadataStar({)
            listener: beginMetadataStar(v)
            listener: endMetadataStar(0)
          ensureIdentifier({, enumValueDeclaration)
            listener: handleIdentifier(v, enumValueDeclaration)
          listener: handleNoTypeNameInConstructorReference(})
          listener: beginConstructorReference(v)
          listener: handleNoTypeArguments(})
          listener: handleNoConstructorReferenceContinuationAfterTypeArguments(})
          listener: endConstructorReference(v, null, }, ConstructorReferenceContext.Const)
          listener: handleNoArguments(v)
          listener: handleEnumElement({)
        listener: handleEnumElements(}, 1)
        listener: endEnum(enum, {, 0)
  listener: endTopLevelDeclaration(enum)
  parseTopLevelDeclarationImpl(}, Instance of 'DirectiveContext')
    parseMetadataStar(})
      listener: beginMetadataStar(enum)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(}, enum, null, null, null, null, null, Instance of 'DirectiveContext')
      parseEnum(enum)
        listener: beginUncategorizedTopLevelDeclaration(enum)
        ensureIdentifier(enum, enumDeclaration)
          listener: handleIdentifier(E, enumDeclaration)
        listener: beginEnum(enum)
        parseEnumHeaderOpt(E, enum)
          listener: handleNoTypeVariables(implemen)
          recoverySmallLookAheadSkipTokens(E, [{, with, implements])
            reportRecoverableError(implemen, Message[UnexpectedToken, Unexpected token 'implemen'., null, {lexeme: implemen}])
              listener: handleRecoverableError(Message[UnexpectedToken, Unexpected token 'implemen'., null, {lexeme: implemen}], implemen, implemen)
          parseEnumWithClauseOpt(implemen)
            listener: handleEnumNoWithClause()
          parseClassOrMixinOrEnumImplementsOpt(implemen)
            listener: handleImplements(null, 0)
        listener: handleEnumHeader(enum, {)
        parseEnumElement({)
          parseMetadataStar({)
            listener: beginMetadataStar(v)
            listener: endMetadataStar(0)
          ensureIdentifier({, enumValueDeclaration)
            listener: handleIdentifier(v, enumValueDeclaration)
          listener: handleNoTypeNameInConstructorReference(})
          listener: beginConstructorReference(v)
          listener: handleNoTypeArguments(})
          listener: handleNoConstructorReferenceContinuationAfterTypeArguments(})
          listener: endConstructorReference(v, null, }, ConstructorReferenceContext.Const)
          listener: handleNoArguments(v)
          listener: handleEnumElement({)
        listener: handleEnumElements(}, 1)
        listener: endEnum(enum, {, 0)
  listener: endTopLevelDeclaration(enum)
  parseTopLevelDeclarationImpl(}, Instance of 'DirectiveContext')
    parseMetadataStar(})
      listener: beginMetadataStar(enum)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(}, enum, null, null, null, null, null, Instance of 'DirectiveContext')
      parseEnum(enum)
        listener: beginUncategorizedTopLevelDeclaration(enum)
        ensureIdentifier(enum, enumDeclaration)
          listener: handleIdentifier(E, enumDeclaration)
        listener: beginEnum(enum)
        parseEnumHeaderOpt(E, enum)
          listener: handleNoTypeVariables(implements)
          parseEnumWithClauseOpt(E)
            listener: handleEnumNoWithClause()
          parseClassOrMixinOrEnumImplementsOpt(E)
            listener: handleIdentifier(Foo, typeReference)
            listener: handleNoTypeArguments(w)
            listener: handleType(Foo, null)
            listener: handleImplements(implements, 1)
          recoveryEnumWith(Foo, Message[OutOfOrderClauses, The 'with' clause must come before the 'implements' clause., Try moving the 'with' clause before the 'implements' clause., {string: with, string2: implements}])
          recoveryEnumImplements(Foo, Message[MultipleClauses, Each 'enum' definition can have at most one 'implements' clause., Try combining all of the 'implements' clauses into a single clause., {string: enum, string2: implements}])
          recoverySmallLookAheadSkipTokens(Foo, [{, with, implements])
            reportRecoverableError(w, Message[UnexpectedToken, Unexpected token 'w'., null, {lexeme: w}])
              listener: handleRecoverableError(Message[UnexpectedToken, Unexpected token 'w'., null, {lexeme: w}], w, w)
        listener: handleEnumHeader(enum, {)
        parseEnumElement({)
          parseMetadataStar({)
            listener: beginMetadataStar(v)
            listener: endMetadataStar(0)
          ensureIdentifier({, enumValueDeclaration)
            listener: handleIdentifier(v, enumValueDeclaration)
          listener: handleNoTypeNameInConstructorReference(})
          listener: beginConstructorReference(v)
          listener: handleNoTypeArguments(})
          listener: handleNoConstructorReferenceContinuationAfterTypeArguments(})
          listener: endConstructorReference(v, null, }, ConstructorReferenceContext.Const)
          listener: handleNoArguments(v)
          listener: handleEnumElement({)
        listener: handleEnumElements(}, 1)
        listener: endEnum(enum, {, 0)
  listener: endTopLevelDeclaration(enum)
  parseTopLevelDeclarationImpl(}, Instance of 'DirectiveContext')
    parseMetadataStar(})
      listener: beginMetadataStar(enum)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(}, enum, null, null, null, null, null, Instance of 'DirectiveContext')
      parseEnum(enum)
        listener: beginUncategorizedTopLevelDeclaration(enum)
        ensureIdentifier(enum, enumDeclaration)
          listener: handleIdentifier(E, enumDeclaration)
        listener: beginEnum(enum)
        parseEnumHeaderOpt(E, enum)
          listener: handleNoTypeVariables(with)
          parseEnumWithClauseOpt(E)
            parseTypeList(with)
              listener: beginTypeList({)
              reportRecoverableErrorWithToken({, Instance of 'Template<(Token) => Message>')
                listener: handleRecoverableError(Message[ExpectedType, Expected a type, but got '{'., null, {lexeme: {}], {, {)
              rewriter()
              listener: handleIdentifier(, typeReference)
              listener: handleNoTypeArguments({)
              listener: handleType(, null)
              listener: endTypeList(1)
            listener: handleEnumWithClause(with)
          parseClassOrMixinOrEnumImplementsOpt()
            listener: handleImplements(null, 0)
        listener: handleEnumHeader(enum, {)
        parseEnumElement({)
          parseMetadataStar({)
            listener: beginMetadataStar(v)
            listener: endMetadataStar(0)
          ensureIdentifier({, enumValueDeclaration)
            listener: handleIdentifier(v, enumValueDeclaration)
          listener: handleNoTypeNameInConstructorReference(})
          listener: beginConstructorReference(v)
          listener: handleNoTypeArguments(})
          listener: handleNoConstructorReferenceContinuationAfterTypeArguments(})
          listener: endConstructorReference(v, null, }, ConstructorReferenceContext.Const)
          listener: handleNoArguments(v)
          listener: handleEnumElement({)
        listener: handleEnumElements(}, 1)
        listener: endEnum(enum, {, 0)
  listener: endTopLevelDeclaration(enum)
  parseTopLevelDeclarationImpl(}, Instance of 'DirectiveContext')
    parseMetadataStar(})
      listener: beginMetadataStar(enum)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(}, enum, null, null, null, null, null, Instance of 'DirectiveContext')
      parseEnum(enum)
        listener: beginUncategorizedTopLevelDeclaration(enum)
        ensureIdentifier(enum, enumDeclaration)
          listener: handleIdentifier(E, enumDeclaration)
        listener: beginEnum(enum)
        parseEnumHeaderOpt(E, enum)
          listener: handleNoTypeVariables(impl)
          recoverySmallLookAheadSkipTokens(E, [{, with, implements])
            reportRecoverableError(impl, Message[UnexpectedToken, Unexpected token 'impl'., null, {lexeme: impl}])
              listener: handleRecoverableError(Message[UnexpectedToken, Unexpected token 'impl'., null, {lexeme: impl}], impl, impl)
          parseEnumWithClauseOpt(impl)
            listener: handleEnumNoWithClause()
          parseClassOrMixinOrEnumImplementsOpt(impl)
            listener: handleIdentifier(Foo, typeReference)
            listener: handleNoTypeArguments({)
            listener: handleType(Foo, null)
            listener: handleImplements(implements, 1)
        listener: handleEnumHeader(enum, {)
        parseEnumElement({)
          parseMetadataStar({)
            listener: beginMetadataStar(v)
            listener: endMetadataStar(0)
          ensureIdentifier({, enumValueDeclaration)
            listener: handleIdentifier(v, enumValueDeclaration)
          listener: handleNoTypeNameInConstructorReference(})
          listener: beginConstructorReference(v)
          listener: handleNoTypeArguments(})
          listener: handleNoConstructorReferenceContinuationAfterTypeArguments(})
          listener: endConstructorReference(v, null, }, ConstructorReferenceContext.Const)
          listener: handleNoArguments(v)
          listener: handleEnumElement({)
        listener: handleEnumElements(}, 1)
        listener: endEnum(enum, {, 0)
  listener: endTopLevelDeclaration(enum)
  parseTopLevelDeclarationImpl(}, Instance of 'DirectiveContext')
    parseMetadataStar(})
      listener: beginMetadataStar(enum)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(}, enum, null, null, null, null, null, Instance of 'DirectiveContext')
      parseEnum(enum)
        listener: beginUncategorizedTopLevelDeclaration(enum)
        ensureIdentifier(enum, enumDeclaration)
          listener: handleIdentifier(E, enumDeclaration)
        listener: beginEnum(enum)
        parseEnumHeaderOpt(E, enum)
          listener: handleNoTypeVariables(with)
          parseEnumWithClauseOpt(E)
            parseTypeList(with)
              listener: beginTypeList(Foo)
              listener: handleIdentifier(Foo, typeReference)
              listener: handleNoTypeArguments(implements)
              listener: handleType(Foo, null)
              listener: endTypeList(1)
            listener: handleEnumWithClause(with)
          parseClassOrMixinOrEnumImplementsOpt(Foo)
            listener: handleIdentifier(Bar, typeReference)
            listener: handleNoTypeArguments({)
            listener: handleType(Bar, null)
            listener: handleImplements(implements, 1)
        listener: handleEnumHeader(enum, {)
        parseEnumElement({)
          parseMetadataStar({)
            listener: beginMetadataStar(v)
            listener: endMetadataStar(0)
          ensureIdentifier({, enumValueDeclaration)
            listener: handleIdentifier(v, enumValueDeclaration)
          listener: handleNoTypeNameInConstructorReference(})
          listener: beginConstructorReference(v)
          listener: handleNoTypeArguments(})
          listener: handleNoConstructorReferenceContinuationAfterTypeArguments(})
          listener: endConstructorReference(v, null, }, ConstructorReferenceContext.Const)
          listener: handleNoArguments(v)
          listener: handleEnumElement({)
        listener: handleEnumElements(}, 1)
        listener: endEnum(enum, {, 0)
  listener: endTopLevelDeclaration(enum)
  parseTopLevelDeclarationImpl(}, Instance of 'DirectiveContext')
    parseMetadataStar(})
      listener: beginMetadataStar(enum)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(}, enum, null, null, null, null, null, Instance of 'DirectiveContext')
      parseEnum(enum)
        listener: beginUncategorizedTopLevelDeclaration(enum)
        ensureIdentifier(enum, enumDeclaration)
          listener: handleIdentifier(E, enumDeclaration)
        listener: beginEnum(enum)
        parseEnumHeaderOpt(E, enum)
          listener: handleNoTypeVariables(implements)
          parseEnumWithClauseOpt(E)
            listener: handleEnumNoWithClause()
          parseClassOrMixinOrEnumImplementsOpt(E)
            listener: handleIdentifier(Bar, typeReference)
            listener: handleNoTypeArguments(with)
            listener: handleType(Bar, null)
            listener: handleImplements(implements, 1)
          recoveryEnumWith(Bar, Message[OutOfOrderClauses, The 'with' clause must come before the 'implements' clause., Try moving the 'with' clause before the 'implements' clause., {string: with, string2: implements}])
            reportRecoverableError(with, Message[OutOfOrderClauses, The 'with' clause must come before the 'implements' clause., Try moving the 'with' clause before the 'implements' clause., {string: with, string2: implements}])
              listener: handleRecoverableError(Message[OutOfOrderClauses, The 'with' clause must come before the 'implements' clause., Try moving the 'with' clause before the 'implements' clause., {string: with, string2: implements}], with, with)
            parseEnumWithClauseOpt(Bar)
              parseTypeList(with)
        listener: handleEnumHeader(enum, {)
        parseEnumElement({)
          parseMetadataStar({)
            listener: beginMetadataStar(v)
            listener: endMetadataStar(0)
          ensureIdentifier({, enumValueDeclaration)
            listener: handleIdentifier(v, enumValueDeclaration)
          listener: handleNoTypeNameInConstructorReference(})
          listener: beginConstructorReference(v)
          listener: handleNoTypeArguments(})
          listener: handleNoConstructorReferenceContinuationAfterTypeArguments(})
          listener: endConstructorReference(v, null, }, ConstructorReferenceContext.Const)
          listener: handleNoArguments(v)
          listener: handleEnumElement({)
        listener: handleEnumElements(}, 1)
        listener: endEnum(enum, {, 0)
  listener: endTopLevelDeclaration(enum)
  parseTopLevelDeclarationImpl(}, Instance of 'DirectiveContext')
    parseMetadataStar(})
      listener: beginMetadataStar(enum)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(}, enum, null, null, null, null, null, Instance of 'DirectiveContext')
      parseEnum(enum)
        listener: beginUncategorizedTopLevelDeclaration(enum)
        ensureIdentifier(enum, enumDeclaration)
          listener: handleIdentifier(E, enumDeclaration)
        listener: beginEnum(enum)
        parseEnumHeaderOpt(E, enum)
          listener: handleNoTypeVariables(gunk1)
          recoverySmallLookAheadSkipTokens(E, [{, with, implements])
            reportRecoverableError(gunk1, Message[UnexpectedToken, Unexpected token 'gunk1'., null, {lexeme: gunk1}])
              listener: handleRecoverableError(Message[UnexpectedToken, Unexpected token 'gunk1'., null, {lexeme: gunk1}], gunk1, gunk1)
          parseEnumWithClauseOpt(gunk1)
            parseTypeList(with)
              listener: beginTypeList(Foo)
              listener: handleIdentifier(Foo, typeReference)
              listener: handleNoTypeArguments(gunk2)
              listener: handleType(Foo, null)
              listener: endTypeList(1)
            listener: handleEnumWithClause(with)
          recoveryEnumWith(Foo, Message[MultipleClauses, Each 'enum' definition can have at most one 'with' clause., Try combining all of the 'with' clauses into a single clause., {string: enum, string2: with}])
          recoverySmallLookAheadSkipTokens(Foo, [{, with, implements])
            reportRecoverableError(gunk2, Message[UnexpectedToken, Unexpected token 'gunk2'., null, {lexeme: gunk2}])
              listener: handleRecoverableError(Message[UnexpectedToken, Unexpected token 'gunk2'., null, {lexeme: gunk2}], gunk2, gunk2)
          parseClassOrMixinOrEnumImplementsOpt(gunk2)
            listener: handleIdentifier(Bar, typeReference)
            listener: handleNoTypeArguments({)
            listener: handleType(Bar, null)
            listener: handleImplements(implements, 1)
        listener: handleEnumHeader(enum, {)
        parseEnumElement({)
          parseMetadataStar({)
            listener: beginMetadataStar(v)
            listener: endMetadataStar(0)
          ensureIdentifier({, enumValueDeclaration)
            listener: handleIdentifier(v, enumValueDeclaration)
          listener: handleNoTypeNameInConstructorReference(})
          listener: beginConstructorReference(v)
          listener: handleNoTypeArguments(})
          listener: handleNoConstructorReferenceContinuationAfterTypeArguments(})
          listener: endConstructorReference(v, null, }, ConstructorReferenceContext.Const)
          listener: handleNoArguments(v)
          listener: handleEnumElement({)
        listener: handleEnumElements(}, 1)
        listener: endEnum(enum, {, 0)
  listener: endTopLevelDeclaration(enum)
  parseTopLevelDeclarationImpl(}, Instance of 'DirectiveContext')
    parseMetadataStar(})
      listener: beginMetadataStar(enum)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(}, enum, null, null, null, null, null, Instance of 'DirectiveContext')
      parseEnum(enum)
        listener: beginUncategorizedTopLevelDeclaration(enum)
        ensureIdentifier(enum, enumDeclaration)
          listener: handleIdentifier(E, enumDeclaration)
        listener: beginEnum(enum)
        parseEnumHeaderOpt(E, enum)
          listener: handleNoTypeVariables(gunk1)
          recoverySmallLookAheadSkipTokens(E, [{, with, implements])
            reportRecoverableError(gunk1, Message[UnexpectedToken, Unexpected token 'gunk1'., null, {lexeme: gunk1}])
              listener: handleRecoverableError(Message[UnexpectedToken, Unexpected token 'gunk1'., null, {lexeme: gunk1}], gunk1, gunk1)
          parseEnumWithClauseOpt(gunk1)
            listener: handleEnumNoWithClause()
          parseClassOrMixinOrEnumImplementsOpt(gunk1)
            listener: handleIdentifier(Bar, typeReference)
            listener: handleNoTypeArguments(gunk2)
            listener: handleType(Bar, null)
            listener: handleImplements(implements, 1)
          recoveryEnumWith(Bar, Message[OutOfOrderClauses, The 'with' clause must come before the 'implements' clause., Try moving the 'with' clause before the 'implements' clause., {string: with, string2: implements}])
          recoveryEnumImplements(Bar, Message[MultipleClauses, Each 'enum' definition can have at most one 'implements' clause., Try combining all of the 'implements' clauses into a single clause., {string: enum, string2: implements}])
          recoverySmallLookAheadSkipTokens(Bar, [{, with, implements])
            reportRecoverableError(gunk2, Message[UnexpectedToken, Unexpected token 'gunk2'., null, {lexeme: gunk2}])
              listener: handleRecoverableError(Message[UnexpectedToken, Unexpected token 'gunk2'., null, {lexeme: gunk2}], gunk2, gunk2)
          recoveryEnumWith(gunk2, Message[OutOfOrderClauses, The 'with' clause must come before the 'implements' clause., Try moving the 'with' clause before the 'implements' clause., {string: with, string2: implements}])
            reportRecoverableError(with, Message[OutOfOrderClauses, The 'with' clause must come before the 'implements' clause., Try moving the 'with' clause before the 'implements' clause., {string: with, string2: implements}])
              listener: handleRecoverableError(Message[OutOfOrderClauses, The 'with' clause must come before the 'implements' clause., Try moving the 'with' clause before the 'implements' clause., {string: with, string2: implements}], with, with)
            parseEnumWithClauseOpt(gunk2)
              parseTypeList(with)
        listener: handleEnumHeader(enum, {)
        parseEnumElement({)
          parseMetadataStar({)
            listener: beginMetadataStar(v)
            listener: endMetadataStar(0)
          ensureIdentifier({, enumValueDeclaration)
            listener: handleIdentifier(v, enumValueDeclaration)
          listener: handleNoTypeNameInConstructorReference(})
          listener: beginConstructorReference(v)
          listener: handleNoTypeArguments(})
          listener: handleNoConstructorReferenceContinuationAfterTypeArguments(})
          listener: endConstructorReference(v, null, }, ConstructorReferenceContext.Const)
          listener: handleNoArguments(v)
          listener: handleEnumElement({)
        listener: handleEnumElements(}, 1)
        listener: endEnum(enum, {, 0)
  listener: endTopLevelDeclaration(enum)
  parseTopLevelDeclarationImpl(}, Instance of 'DirectiveContext')
    parseMetadataStar(})
      listener: beginMetadataStar(enum)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(}, enum, null, null, null, null, null, Instance of 'DirectiveContext')
      parseEnum(enum)
        listener: beginUncategorizedTopLevelDeclaration(enum)
        ensureIdentifier(enum, enumDeclaration)
          listener: handleIdentifier(E, enumDeclaration)
        listener: beginEnum(enum)
        parseEnumHeaderOpt(E, enum)
          listener: handleNoTypeVariables(with)
          parseEnumWithClauseOpt(E)
            parseTypeList(with)
              listener: beginTypeList(Foo)
              listener: handleIdentifier(Foo, typeReference)
              listener: handleNoTypeArguments(with)
              listener: handleType(Foo, null)
              listener: endTypeList(1)
            listener: handleEnumWithClause(with)
          recoveryEnumWith(Foo, Message[MultipleClauses, Each 'enum' definition can have at most one 'with' clause., Try combining all of the 'with' clauses into a single clause., {string: enum, string2: with}])
            reportRecoverableError(with, Message[MultipleClauses, Each 'enum' definition can have at most one 'with' clause., Try combining all of the 'with' clauses into a single clause., {string: enum, string2: with}])
              listener: handleRecoverableError(Message[MultipleClauses, Each 'enum' definition can have at most one 'with' clause., Try combining all of the 'with' clauses into a single clause., {string: enum, string2: with}], with, with)
            parseEnumWithClauseOpt(Foo)
              parseTypeList(with)
          parseClassOrMixinOrEnumImplementsOpt(Foo2)
            listener: handleIdentifier(Bar, typeReference)
            listener: handleNoTypeArguments(implements)
            listener: handleType(Bar, null)
            listener: handleImplements(implements, 1)
          recoveryEnumWith(Bar, Message[MultipleClauses, Each 'enum' definition can have at most one 'with' clause., Try combining all of the 'with' clauses into a single clause., {string: enum, string2: with}])
          recoveryEnumImplements(Bar, Message[MultipleClauses, Each 'enum' definition can have at most one 'implements' clause., Try combining all of the 'implements' clauses into a single clause., {string: enum, string2: implements}])
            reportRecoverableError(implements, Message[MultipleClauses, Each 'enum' definition can have at most one 'implements' clause., Try combining all of the 'implements' clauses into a single clause., {string: enum, string2: implements}])
              listener: handleRecoverableError(Message[MultipleClauses, Each 'enum' definition can have at most one 'implements' clause., Try combining all of the 'implements' clauses into a single clause., {string: enum, string2: implements}], implements, implements)
            parseClassOrMixinOrEnumImplementsOpt(Bar)
          recoveryEnumWith(Bar2, Message[MultipleClauses, Each 'enum' definition can have at most one 'with' clause., Try combining all of the 'with' clauses into a single clause., {string: enum, string2: with}])
            reportRecoverableError(with, Message[MultipleClauses, Each 'enum' definition can have at most one 'with' clause., Try combining all of the 'with' clauses into a single clause., {string: enum, string2: with}])
              listener: handleRecoverableError(Message[MultipleClauses, Each 'enum' definition can have at most one 'with' clause., Try combining all of the 'with' clauses into a single clause., {string: enum, string2: with}], with, with)
            parseEnumWithClauseOpt(Bar2)
              parseTypeList(with)
          recoveryEnumWith(Foo3, Message[MultipleClauses, Each 'enum' definition can have at most one 'with' clause., Try combining all of the 'with' clauses into a single clause., {string: enum, string2: with}])
          recoveryEnumImplements(Foo3, Message[MultipleClauses, Each 'enum' definition can have at most one 'implements' clause., Try combining all of the 'implements' clauses into a single clause., {string: enum, string2: implements}])
            reportRecoverableError(implements, Message[MultipleClauses, Each 'enum' definition can have at most one 'implements' clause., Try combining all of the 'implements' clauses into a single clause., {string: enum, string2: implements}])
              listener: handleRecoverableError(Message[MultipleClauses, Each 'enum' definition can have at most one 'implements' clause., Try combining all of the 'implements' clauses into a single clause., {string: enum, string2: implements}], implements, implements)
            parseClassOrMixinOrEnumImplementsOpt(Foo3)
        listener: handleEnumHeader(enum, {)
        parseEnumElement({)
          parseMetadataStar({)
            listener: beginMetadataStar(v)
            listener: endMetadataStar(0)
          ensureIdentifier({, enumValueDeclaration)
            listener: handleIdentifier(v, enumValueDeclaration)
          listener: handleNoTypeNameInConstructorReference(})
          listener: beginConstructorReference(v)
          listener: handleNoTypeArguments(})
          listener: handleNoConstructorReferenceContinuationAfterTypeArguments(})
          listener: endConstructorReference(v, null, }, ConstructorReferenceContext.Const)
          listener: handleNoArguments(v)
          listener: handleEnumElement({)
        listener: handleEnumElements(}, 1)
        listener: endEnum(enum, {, 0)
  listener: endTopLevelDeclaration(enum)
  parseTopLevelDeclarationImpl(}, Instance of 'DirectiveContext')
    parseMetadataStar(})
      listener: beginMetadataStar(enum)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(}, enum, null, null, null, null, null, Instance of 'DirectiveContext')
      parseEnum(enum)
        listener: beginUncategorizedTopLevelDeclaration(enum)
        ensureIdentifier(enum, enumDeclaration)
          listener: handleIdentifier(E, enumDeclaration)
        listener: beginEnum(enum)
        parseEnumHeaderOpt(E, enum)
          listener: handleNoTypeVariables(implements)
          parseEnumWithClauseOpt(E)
            listener: handleEnumNoWithClause()
          parseClassOrMixinOrEnumImplementsOpt(E)
            listener: handleIdentifier(Bar, typeReference)
            listener: handleNoTypeArguments(implements)
            listener: handleType(Bar, null)
            listener: handleImplements(implements, 1)
          recoveryEnumWith(Bar, Message[OutOfOrderClauses, The 'with' clause must come before the 'implements' clause., Try moving the 'with' clause before the 'implements' clause., {string: with, string2: implements}])
          recoveryEnumImplements(Bar, Message[MultipleClauses, Each 'enum' definition can have at most one 'implements' clause., Try combining all of the 'implements' clauses into a single clause., {string: enum, string2: implements}])
            reportRecoverableError(implements, Message[MultipleClauses, Each 'enum' definition can have at most one 'implements' clause., Try combining all of the 'implements' clauses into a single clause., {string: enum, string2: implements}])
              listener: handleRecoverableError(Message[MultipleClauses, Each 'enum' definition can have at most one 'implements' clause., Try combining all of the 'implements' clauses into a single clause., {string: enum, string2: implements}], implements, implements)
            parseClassOrMixinOrEnumImplementsOpt(Bar)
          recoveryEnumWith(Bar2, Message[OutOfOrderClauses, The 'with' clause must come before the 'implements' clause., Try moving the 'with' clause before the 'implements' clause., {string: with, string2: implements}])
            reportRecoverableError(with, Message[OutOfOrderClauses, The 'with' clause must come before the 'implements' clause., Try moving the 'with' clause before the 'implements' clause., {string: with, string2: implements}])
              listener: handleRecoverableError(Message[OutOfOrderClauses, The 'with' clause must come before the 'implements' clause., Try moving the 'with' clause before the 'implements' clause., {string: with, string2: implements}], with, with)
            parseEnumWithClauseOpt(Bar2)
              parseTypeList(with)
          recoveryEnumWith(Foo, Message[MultipleClauses, Each 'enum' definition can have at most one 'with' clause., Try combining all of the 'with' clauses into a single clause., {string: enum, string2: with}])
            reportRecoverableError(with, Message[MultipleClauses, Each 'enum' definition can have at most one 'with' clause., Try combining all of the 'with' clauses into a single clause., {string: enum, string2: with}])
              listener: handleRecoverableError(Message[MultipleClauses, Each 'enum' definition can have at most one 'with' clause., Try combining all of the 'with' clauses into a single clause., {string: enum, string2: with}], with, with)
            parseEnumWithClauseOpt(Foo)
              parseTypeList(with)
          recoveryEnumWith(Foo2, Message[MultipleClauses, Each 'enum' definition can have at most one 'with' clause., Try combining all of the 'with' clauses into a single clause., {string: enum, string2: with}])
          recoveryEnumImplements(Foo2, Message[MultipleClauses, Each 'enum' definition can have at most one 'implements' clause., Try combining all of the 'implements' clauses into a single clause., {string: enum, string2: implements}])
            reportRecoverableError(implements, Message[MultipleClauses, Each 'enum' definition can have at most one 'implements' clause., Try combining all of the 'implements' clauses into a single clause., {string: enum, string2: implements}])
              listener: handleRecoverableError(Message[MultipleClauses, Each 'enum' definition can have at most one 'implements' clause., Try combining all of the 'implements' clauses into a single clause., {string: enum, string2: implements}], implements, implements)
            parseClassOrMixinOrEnumImplementsOpt(Foo2)
          recoveryEnumWith(Bar3, Message[MultipleClauses, Each 'enum' definition can have at most one 'with' clause., Try combining all of the 'with' clauses into a single clause., {string: enum, string2: with}])
            reportRecoverableError(with, Message[MultipleClauses, Each 'enum' definition can have at most one 'with' clause., Try combining all of the 'with' clauses into a single clause., {string: enum, string2: with}])
              listener: handleRecoverableError(Message[MultipleClauses, Each 'enum' definition can have at most one 'with' clause., Try combining all of the 'with' clauses into a single clause., {string: enum, string2: with}], with, with)
            parseEnumWithClauseOpt(Bar3)
              parseTypeList(with)
        listener: handleEnumHeader(enum, {)
        parseEnumElement({)
          parseMetadataStar({)
            listener: beginMetadataStar(v)
            listener: endMetadataStar(0)
          ensureIdentifier({, enumValueDeclaration)
            listener: handleIdentifier(v, enumValueDeclaration)
          listener: handleNoTypeNameInConstructorReference(})
          listener: beginConstructorReference(v)
          listener: handleNoTypeArguments(})
          listener: handleNoConstructorReferenceContinuationAfterTypeArguments(})
          listener: endConstructorReference(v, null, }, ConstructorReferenceContext.Const)
          listener: handleNoArguments(v)
          listener: handleEnumElement({)
        listener: handleEnumElements(}, 1)
        listener: endEnum(enum, {, 0)
  listener: endTopLevelDeclaration()
  reportAllErrorTokens(enum)
  listener: endCompilationUnit(15, )
