parseUnit(class)
  skipErrorTokens(class)
  listener: beginCompilationUnit(class)
  syntheticPreviousToken(class)
  parseTopLevelDeclarationImpl(, Instance of 'DirectiveContext')
    parseMetadataStar()
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(, class, null, Instance of 'DirectiveContext')
      parseClassDeclarationModifiers(, class)
      parseClassOrNamedMixinApplication(null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          reportRecoverableErrorWithToken(abstract, Instance of 'Template<(Token) => Message>')
            listener: handleRecoverableError(Message[BuiltInIdentifierInDeclaration, Can't use 'abstract' as a name here., null, {lexeme: abstract}], abstract, abstract)
          listener: handleIdentifier(abstract, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, abstract)
        parseClass(abstract, class, class, abstract)
          parseClassHeaderOpt(abstract, class, class)
            parseClassExtendsOpt(abstract)
              listener: handleNoType(abstract)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(abstract)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(abstract)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(abstract, DeclarationKind.Class, abstract)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrValue(}, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(class)
  parseTopLevelDeclarationImpl(}, Instance of 'DirectiveContext')
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(}, class, null, Instance of 'DirectiveContext')
      parseClassDeclarationModifiers(}, class)
      parseClassOrNamedMixinApplication(null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          reportRecoverableErrorWithToken(as, Instance of 'Template<(Token) => Message>')
            listener: handleRecoverableError(Message[BuiltInIdentifierInDeclaration, Can't use 'as' as a name here., null, {lexeme: as}], as, as)
          listener: handleIdentifier(as, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, as)
        parseClass(as, class, class, as)
          parseClassHeaderOpt(as, class, class)
            parseClassExtendsOpt(as)
              listener: handleNoType(as)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(as)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(as)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(as, DeclarationKind.Class, as)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrValue(}, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(class)
  parseTopLevelDeclarationImpl(}, Instance of 'DirectiveContext')
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(}, class, null, Instance of 'DirectiveContext')
      parseClassDeclarationModifiers(}, class)
      parseClassOrNamedMixinApplication(null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          reportRecoverableErrorWithToken(assert, Instance of 'Template<(Token) => Message>')
            listener: handleRecoverableError(Message[ExpectedIdentifierButGotKeyword, 'assert' can't be used as an identifier because it's a keyword., Try renaming this to be an identifier that isn't a keyword., {lexeme: assert}], assert, assert)
          listener: handleIdentifier(assert, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, assert)
        parseClass(assert, class, class, assert)
          parseClassHeaderOpt(assert, class, class)
            parseClassExtendsOpt(assert)
              listener: handleNoType(assert)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(assert)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(assert)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(assert, DeclarationKind.Class, assert)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrValue(}, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(class)
  parseTopLevelDeclarationImpl(}, Instance of 'DirectiveContext')
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(}, class, null, Instance of 'DirectiveContext')
      parseClassDeclarationModifiers(}, class)
      parseClassOrNamedMixinApplication(null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          listener: handleIdentifier(async, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, async)
        parseClass(async, class, class, async)
          parseClassHeaderOpt(async, class, class)
            parseClassExtendsOpt(async)
              listener: handleNoType(async)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(async)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(async)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(async, DeclarationKind.Class, async)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrValue(}, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(class)
  parseTopLevelDeclarationImpl(}, Instance of 'DirectiveContext')
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(}, class, null, Instance of 'DirectiveContext')
      parseClassDeclarationModifiers(}, class)
      parseClassOrNamedMixinApplication(null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          listener: handleIdentifier(await, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, await)
        parseClass(await, class, class, await)
          parseClassHeaderOpt(await, class, class)
            parseClassExtendsOpt(await)
              listener: handleNoType(await)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(await)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(await)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(await, DeclarationKind.Class, await)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrValue(}, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(class)
  parseTopLevelDeclarationImpl(}, Instance of 'DirectiveContext')
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(}, class, null, Instance of 'DirectiveContext')
      parseClassDeclarationModifiers(}, class)
      parseClassOrNamedMixinApplication(null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          reportRecoverableErrorWithToken(break, Instance of 'Template<(Token) => Message>')
            listener: handleRecoverableError(Message[ExpectedIdentifierButGotKeyword, 'break' can't be used as an identifier because it's a keyword., Try renaming this to be an identifier that isn't a keyword., {lexeme: break}], break, break)
          listener: handleIdentifier(break, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, break)
        parseClass(break, class, class, break)
          parseClassHeaderOpt(break, class, class)
            parseClassExtendsOpt(break)
              listener: handleNoType(break)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(break)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(break)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(break, DeclarationKind.Class, break)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrValue(}, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(class)
  parseTopLevelDeclarationImpl(}, Instance of 'DirectiveContext')
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(}, class, null, Instance of 'DirectiveContext')
      parseClassDeclarationModifiers(}, class)
      parseClassOrNamedMixinApplication(null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          reportRecoverableErrorWithToken(case, Instance of 'Template<(Token) => Message>')
            listener: handleRecoverableError(Message[ExpectedIdentifierButGotKeyword, 'case' can't be used as an identifier because it's a keyword., Try renaming this to be an identifier that isn't a keyword., {lexeme: case}], case, case)
          listener: handleIdentifier(case, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, case)
        parseClass(case, class, class, case)
          parseClassHeaderOpt(case, class, class)
            parseClassExtendsOpt(case)
              listener: handleNoType(case)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(case)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(case)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(case, DeclarationKind.Class, case)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrValue(}, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(class)
  parseTopLevelDeclarationImpl(}, Instance of 'DirectiveContext')
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(}, class, null, Instance of 'DirectiveContext')
      parseClassDeclarationModifiers(}, class)
      parseClassOrNamedMixinApplication(null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          reportRecoverableErrorWithToken(catch, Instance of 'Template<(Token) => Message>')
            listener: handleRecoverableError(Message[ExpectedIdentifierButGotKeyword, 'catch' can't be used as an identifier because it's a keyword., Try renaming this to be an identifier that isn't a keyword., {lexeme: catch}], catch, catch)
          listener: handleIdentifier(catch, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, catch)
        parseClass(catch, class, class, catch)
          parseClassHeaderOpt(catch, class, class)
            parseClassExtendsOpt(catch)
              listener: handleNoType(catch)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(catch)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(catch)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(catch, DeclarationKind.Class, catch)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrValue(}, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(class)
  parseTopLevelDeclarationImpl(}, Instance of 'DirectiveContext')
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(}, class, null, Instance of 'DirectiveContext')
      parseClassDeclarationModifiers(}, class)
      parseClassOrNamedMixinApplication(null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          reportRecoverableErrorWithToken(class, Instance of 'Template<(Token) => Message>')
            listener: handleRecoverableError(Message[ExpectedIdentifierButGotKeyword, 'class' can't be used as an identifier because it's a keyword., Try renaming this to be an identifier that isn't a keyword., {lexeme: class}], class, class)
          listener: handleIdentifier(class, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, class)
        parseClass(class, class, class, class)
          parseClassHeaderOpt(class, class, class)
            parseClassExtendsOpt(class)
              listener: handleNoType(class)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(class)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(class)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(class, DeclarationKind.Class, class)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrValue(}, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(class)
  parseTopLevelDeclarationImpl(}, Instance of 'DirectiveContext')
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(}, class, null, Instance of 'DirectiveContext')
      parseClassDeclarationModifiers(}, class)
      parseClassOrNamedMixinApplication(null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          reportRecoverableErrorWithToken(const, Instance of 'Template<(Token) => Message>')
            listener: handleRecoverableError(Message[ExpectedIdentifierButGotKeyword, 'const' can't be used as an identifier because it's a keyword., Try renaming this to be an identifier that isn't a keyword., {lexeme: const}], const, const)
          listener: handleIdentifier(const, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, const)
        parseClass(const, class, class, const)
          parseClassHeaderOpt(const, class, class)
            parseClassExtendsOpt(const)
              listener: handleNoType(const)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(const)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(const)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(const, DeclarationKind.Class, const)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrValue(}, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(class)
  parseTopLevelDeclarationImpl(}, Instance of 'DirectiveContext')
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(}, class, null, Instance of 'DirectiveContext')
      parseClassDeclarationModifiers(}, class)
      parseClassOrNamedMixinApplication(null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          reportRecoverableErrorWithToken(continue, Instance of 'Template<(Token) => Message>')
            listener: handleRecoverableError(Message[ExpectedIdentifierButGotKeyword, 'continue' can't be used as an identifier because it's a keyword., Try renaming this to be an identifier that isn't a keyword., {lexeme: continue}], continue, continue)
          listener: handleIdentifier(continue, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, continue)
        parseClass(continue, class, class, continue)
          parseClassHeaderOpt(continue, class, class)
            parseClassExtendsOpt(continue)
              listener: handleNoType(continue)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(continue)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(continue)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(continue, DeclarationKind.Class, continue)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrValue(}, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(class)
  parseTopLevelDeclarationImpl(}, Instance of 'DirectiveContext')
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(}, class, null, Instance of 'DirectiveContext')
      parseClassDeclarationModifiers(}, class)
      parseClassOrNamedMixinApplication(null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          reportRecoverableErrorWithToken(covariant, Instance of 'Template<(Token) => Message>')
            listener: handleRecoverableError(Message[BuiltInIdentifierInDeclaration, Can't use 'covariant' as a name here., null, {lexeme: covariant}], covariant, covariant)
          listener: handleIdentifier(covariant, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, covariant)
        parseClass(covariant, class, class, covariant)
          parseClassHeaderOpt(covariant, class, class)
            parseClassExtendsOpt(covariant)
              listener: handleNoType(covariant)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(covariant)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(covariant)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(covariant, DeclarationKind.Class, covariant)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrValue(}, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(class)
  parseTopLevelDeclarationImpl(}, Instance of 'DirectiveContext')
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(}, class, null, Instance of 'DirectiveContext')
      parseClassDeclarationModifiers(}, class)
      parseClassOrNamedMixinApplication(null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          reportRecoverableErrorWithToken(default, Instance of 'Template<(Token) => Message>')
            listener: handleRecoverableError(Message[ExpectedIdentifierButGotKeyword, 'default' can't be used as an identifier because it's a keyword., Try renaming this to be an identifier that isn't a keyword., {lexeme: default}], default, default)
          listener: handleIdentifier(default, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, default)
        parseClass(default, class, class, default)
          parseClassHeaderOpt(default, class, class)
            parseClassExtendsOpt(default)
              listener: handleNoType(default)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(default)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(default)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(default, DeclarationKind.Class, default)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrValue(}, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(class)
  parseTopLevelDeclarationImpl(}, Instance of 'DirectiveContext')
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(}, class, null, Instance of 'DirectiveContext')
      parseClassDeclarationModifiers(}, class)
      parseClassOrNamedMixinApplication(null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          reportRecoverableErrorWithToken(deferred, Instance of 'Template<(Token) => Message>')
            listener: handleRecoverableError(Message[BuiltInIdentifierInDeclaration, Can't use 'deferred' as a name here., null, {lexeme: deferred}], deferred, deferred)
          listener: handleIdentifier(deferred, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, deferred)
        parseClass(deferred, class, class, deferred)
          parseClassHeaderOpt(deferred, class, class)
            parseClassExtendsOpt(deferred)
              listener: handleNoType(deferred)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(deferred)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(deferred)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(deferred, DeclarationKind.Class, deferred)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrValue(}, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(class)
  parseTopLevelDeclarationImpl(}, Instance of 'DirectiveContext')
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(}, class, null, Instance of 'DirectiveContext')
      parseClassDeclarationModifiers(}, class)
      parseClassOrNamedMixinApplication(null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          reportRecoverableErrorWithToken(do, Instance of 'Template<(Token) => Message>')
            listener: handleRecoverableError(Message[ExpectedIdentifierButGotKeyword, 'do' can't be used as an identifier because it's a keyword., Try renaming this to be an identifier that isn't a keyword., {lexeme: do}], do, do)
          listener: handleIdentifier(do, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, do)
        parseClass(do, class, class, do)
          parseClassHeaderOpt(do, class, class)
            parseClassExtendsOpt(do)
              listener: handleNoType(do)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(do)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(do)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(do, DeclarationKind.Class, do)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrValue(}, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(class)
  parseTopLevelDeclarationImpl(}, Instance of 'DirectiveContext')
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(}, class, null, Instance of 'DirectiveContext')
      parseClassDeclarationModifiers(}, class)
      parseClassOrNamedMixinApplication(null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          reportRecoverableErrorWithToken(dynamic, Instance of 'Template<(Token) => Message>')
            listener: handleRecoverableError(Message[BuiltInIdentifierInDeclaration, Can't use 'dynamic' as a name here., null, {lexeme: dynamic}], dynamic, dynamic)
          listener: handleIdentifier(dynamic, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, dynamic)
        parseClass(dynamic, class, class, dynamic)
          parseClassHeaderOpt(dynamic, class, class)
            parseClassExtendsOpt(dynamic)
              listener: handleNoType(dynamic)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(dynamic)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(dynamic)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(dynamic, DeclarationKind.Class, dynamic)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrValue(}, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(class)
  parseTopLevelDeclarationImpl(}, Instance of 'DirectiveContext')
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(}, class, null, Instance of 'DirectiveContext')
      parseClassDeclarationModifiers(}, class)
      parseClassOrNamedMixinApplication(null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          reportRecoverableErrorWithToken(else, Instance of 'Template<(Token) => Message>')
            listener: handleRecoverableError(Message[ExpectedIdentifierButGotKeyword, 'else' can't be used as an identifier because it's a keyword., Try renaming this to be an identifier that isn't a keyword., {lexeme: else}], else, else)
          listener: handleIdentifier(else, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, else)
        parseClass(else, class, class, else)
          parseClassHeaderOpt(else, class, class)
            parseClassExtendsOpt(else)
              listener: handleNoType(else)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(else)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(else)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(else, DeclarationKind.Class, else)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrValue(}, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(class)
  parseTopLevelDeclarationImpl(}, Instance of 'DirectiveContext')
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(}, class, null, Instance of 'DirectiveContext')
      parseClassDeclarationModifiers(}, class)
      parseClassOrNamedMixinApplication(null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          reportRecoverableErrorWithToken(enum, Instance of 'Template<(Token) => Message>')
            listener: handleRecoverableError(Message[ExpectedIdentifierButGotKeyword, 'enum' can't be used as an identifier because it's a keyword., Try renaming this to be an identifier that isn't a keyword., {lexeme: enum}], enum, enum)
          listener: handleIdentifier(enum, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, enum)
        parseClass(enum, class, class, enum)
          parseClassHeaderOpt(enum, class, class)
            parseClassExtendsOpt(enum)
              listener: handleNoType(enum)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(enum)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(enum)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(enum, DeclarationKind.Class, enum)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrValue(}, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(class)
  parseTopLevelDeclarationImpl(}, Instance of 'DirectiveContext')
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(}, class, null, Instance of 'DirectiveContext')
      parseClassDeclarationModifiers(}, class)
      parseClassOrNamedMixinApplication(null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          reportRecoverableErrorWithToken(export, Instance of 'Template<(Token) => Message>')
            listener: handleRecoverableError(Message[BuiltInIdentifierInDeclaration, Can't use 'export' as a name here., null, {lexeme: export}], export, export)
          listener: handleIdentifier(export, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, export)
        parseClass(export, class, class, export)
          parseClassHeaderOpt(export, class, class)
            parseClassExtendsOpt(export)
              listener: handleNoType(export)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(export)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(export)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(export, DeclarationKind.Class, export)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrValue(}, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(class)
  parseTopLevelDeclarationImpl(}, Instance of 'DirectiveContext')
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(}, class, null, Instance of 'DirectiveContext')
      parseClassDeclarationModifiers(}, class)
      parseClassOrNamedMixinApplication(null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          reportRecoverableErrorWithToken(extends, Instance of 'Template<(Token) => Message>')
            listener: handleRecoverableError(Message[ExpectedIdentifierButGotKeyword, 'extends' can't be used as an identifier because it's a keyword., Try renaming this to be an identifier that isn't a keyword., {lexeme: extends}], extends, extends)
          listener: handleIdentifier(extends, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, extends)
        parseClass(extends, class, class, extends)
          parseClassHeaderOpt(extends, class, class)
            parseClassExtendsOpt(extends)
              listener: handleNoType(extends)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(extends)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(extends)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(extends, DeclarationKind.Class, extends)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrValue(}, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(class)
  parseTopLevelDeclarationImpl(}, Instance of 'DirectiveContext')
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(}, class, null, Instance of 'DirectiveContext')
      parseClassDeclarationModifiers(}, class)
      parseClassOrNamedMixinApplication(null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          reportRecoverableErrorWithToken(extension, Instance of 'Template<(Token) => Message>')
            listener: handleRecoverableError(Message[BuiltInIdentifierInDeclaration, Can't use 'extension' as a name here., null, {lexeme: extension}], extension, extension)
          listener: handleIdentifier(extension, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, extension)
        parseClass(extension, class, class, extension)
          parseClassHeaderOpt(extension, class, class)
            parseClassExtendsOpt(extension)
              listener: handleNoType(extension)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(extension)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(extension)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(extension, DeclarationKind.Class, extension)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrValue(}, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(class)
  parseTopLevelDeclarationImpl(}, Instance of 'DirectiveContext')
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(}, class, null, Instance of 'DirectiveContext')
      parseClassDeclarationModifiers(}, class)
      parseClassOrNamedMixinApplication(null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          reportRecoverableErrorWithToken(external, Instance of 'Template<(Token) => Message>')
            listener: handleRecoverableError(Message[BuiltInIdentifierInDeclaration, Can't use 'external' as a name here., null, {lexeme: external}], external, external)
          listener: handleIdentifier(external, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, external)
        parseClass(external, class, class, external)
          parseClassHeaderOpt(external, class, class)
            parseClassExtendsOpt(external)
              listener: handleNoType(external)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(external)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(external)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(external, DeclarationKind.Class, external)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrValue(}, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(class)
  parseTopLevelDeclarationImpl(}, Instance of 'DirectiveContext')
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(}, class, null, Instance of 'DirectiveContext')
      parseClassDeclarationModifiers(}, class)
      parseClassOrNamedMixinApplication(null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          reportRecoverableErrorWithToken(factory, Instance of 'Template<(Token) => Message>')
            listener: handleRecoverableError(Message[BuiltInIdentifierInDeclaration, Can't use 'factory' as a name here., null, {lexeme: factory}], factory, factory)
          listener: handleIdentifier(factory, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, factory)
        parseClass(factory, class, class, factory)
          parseClassHeaderOpt(factory, class, class)
            parseClassExtendsOpt(factory)
              listener: handleNoType(factory)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(factory)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(factory)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(factory, DeclarationKind.Class, factory)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrValue(}, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(class)
  parseTopLevelDeclarationImpl(}, Instance of 'DirectiveContext')
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(}, class, null, Instance of 'DirectiveContext')
      parseClassDeclarationModifiers(}, class)
      parseClassOrNamedMixinApplication(null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          reportRecoverableErrorWithToken(false, Instance of 'Template<(Token) => Message>')
            listener: handleRecoverableError(Message[ExpectedIdentifierButGotKeyword, 'false' can't be used as an identifier because it's a keyword., Try renaming this to be an identifier that isn't a keyword., {lexeme: false}], false, false)
          listener: handleIdentifier(false, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, false)
        parseClass(false, class, class, false)
          parseClassHeaderOpt(false, class, class)
            parseClassExtendsOpt(false)
              listener: handleNoType(false)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(false)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(false)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(false, DeclarationKind.Class, false)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrValue(}, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(class)
  parseTopLevelDeclarationImpl(}, Instance of 'DirectiveContext')
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(}, class, null, Instance of 'DirectiveContext')
      parseClassDeclarationModifiers(}, class)
      parseClassOrNamedMixinApplication(null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          reportRecoverableErrorWithToken(final, Instance of 'Template<(Token) => Message>')
            listener: handleRecoverableError(Message[ExpectedIdentifierButGotKeyword, 'final' can't be used as an identifier because it's a keyword., Try renaming this to be an identifier that isn't a keyword., {lexeme: final}], final, final)
          listener: handleIdentifier(final, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, final)
        parseClass(final, class, class, final)
          parseClassHeaderOpt(final, class, class)
            parseClassExtendsOpt(final)
              listener: handleNoType(final)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(final)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(final)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(final, DeclarationKind.Class, final)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrValue(}, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(class)
  parseTopLevelDeclarationImpl(}, Instance of 'DirectiveContext')
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(}, class, null, Instance of 'DirectiveContext')
      parseClassDeclarationModifiers(}, class)
      parseClassOrNamedMixinApplication(null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          reportRecoverableErrorWithToken(finally, Instance of 'Template<(Token) => Message>')
            listener: handleRecoverableError(Message[ExpectedIdentifierButGotKeyword, 'finally' can't be used as an identifier because it's a keyword., Try renaming this to be an identifier that isn't a keyword., {lexeme: finally}], finally, finally)
          listener: handleIdentifier(finally, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, finally)
        parseClass(finally, class, class, finally)
          parseClassHeaderOpt(finally, class, class)
            parseClassExtendsOpt(finally)
              listener: handleNoType(finally)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(finally)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(finally)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(finally, DeclarationKind.Class, finally)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrValue(}, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(class)
  parseTopLevelDeclarationImpl(}, Instance of 'DirectiveContext')
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(}, class, null, Instance of 'DirectiveContext')
      parseClassDeclarationModifiers(}, class)
      parseClassOrNamedMixinApplication(null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          reportRecoverableErrorWithToken(for, Instance of 'Template<(Token) => Message>')
            listener: handleRecoverableError(Message[ExpectedIdentifierButGotKeyword, 'for' can't be used as an identifier because it's a keyword., Try renaming this to be an identifier that isn't a keyword., {lexeme: for}], for, for)
          listener: handleIdentifier(for, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, for)
        parseClass(for, class, class, for)
          parseClassHeaderOpt(for, class, class)
            parseClassExtendsOpt(for)
              listener: handleNoType(for)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(for)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(for)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(for, DeclarationKind.Class, for)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrValue(}, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(class)
  parseTopLevelDeclarationImpl(}, Instance of 'DirectiveContext')
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(}, class, null, Instance of 'DirectiveContext')
      parseClassDeclarationModifiers(}, class)
      parseClassOrNamedMixinApplication(null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          listener: handleIdentifier(Function, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, Function)
        parseClass(Function, class, class, Function)
          parseClassHeaderOpt(Function, class, class)
            parseClassExtendsOpt(Function)
              listener: handleNoType(Function)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(Function)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(Function)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(Function, DeclarationKind.Class, Function)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrValue(}, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(class)
  parseTopLevelDeclarationImpl(}, Instance of 'DirectiveContext')
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(}, class, null, Instance of 'DirectiveContext')
      parseClassDeclarationModifiers(}, class)
      parseClassOrNamedMixinApplication(null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          reportRecoverableErrorWithToken(get, Instance of 'Template<(Token) => Message>')
            listener: handleRecoverableError(Message[BuiltInIdentifierInDeclaration, Can't use 'get' as a name here., null, {lexeme: get}], get, get)
          listener: handleIdentifier(get, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, get)
        parseClass(get, class, class, get)
          parseClassHeaderOpt(get, class, class)
            parseClassExtendsOpt(get)
              listener: handleNoType(get)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(get)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(get)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(get, DeclarationKind.Class, get)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrValue(}, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(class)
  parseTopLevelDeclarationImpl(}, Instance of 'DirectiveContext')
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(}, class, null, Instance of 'DirectiveContext')
      parseClassDeclarationModifiers(}, class)
      parseClassOrNamedMixinApplication(null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          listener: handleIdentifier(hide, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, hide)
        parseClass(hide, class, class, hide)
          parseClassHeaderOpt(hide, class, class)
            parseClassExtendsOpt(hide)
              listener: handleNoType(hide)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(hide)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(hide)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(hide, DeclarationKind.Class, hide)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrValue(}, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(class)
  parseTopLevelDeclarationImpl(}, Instance of 'DirectiveContext')
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(}, class, null, Instance of 'DirectiveContext')
      parseClassDeclarationModifiers(}, class)
      parseClassOrNamedMixinApplication(null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          reportRecoverableErrorWithToken(if, Instance of 'Template<(Token) => Message>')
            listener: handleRecoverableError(Message[ExpectedIdentifierButGotKeyword, 'if' can't be used as an identifier because it's a keyword., Try renaming this to be an identifier that isn't a keyword., {lexeme: if}], if, if)
          listener: handleIdentifier(if, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, if)
        parseClass(if, class, class, if)
          parseClassHeaderOpt(if, class, class)
            parseClassExtendsOpt(if)
              listener: handleNoType(if)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(if)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(if)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(if, DeclarationKind.Class, if)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrValue(}, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(class)
  parseTopLevelDeclarationImpl(}, Instance of 'DirectiveContext')
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(}, class, null, Instance of 'DirectiveContext')
      parseClassDeclarationModifiers(}, class)
      parseClassOrNamedMixinApplication(null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          reportRecoverableErrorWithToken(implements, Instance of 'Template<(Token) => Message>')
            listener: handleRecoverableError(Message[BuiltInIdentifierInDeclaration, Can't use 'implements' as a name here., null, {lexeme: implements}], implements, implements)
          listener: handleIdentifier(implements, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, implements)
        parseClass(implements, class, class, implements)
          parseClassHeaderOpt(implements, class, class)
            parseClassExtendsOpt(implements)
              listener: handleNoType(implements)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(implements)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(implements)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(implements, DeclarationKind.Class, implements)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrValue(}, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(class)
  parseTopLevelDeclarationImpl(}, Instance of 'DirectiveContext')
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(}, class, null, Instance of 'DirectiveContext')
      parseClassDeclarationModifiers(}, class)
      parseClassOrNamedMixinApplication(null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          reportRecoverableErrorWithToken(import, Instance of 'Template<(Token) => Message>')
            listener: handleRecoverableError(Message[BuiltInIdentifierInDeclaration, Can't use 'import' as a name here., null, {lexeme: import}], import, import)
          listener: handleIdentifier(import, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, import)
        parseClass(import, class, class, import)
          parseClassHeaderOpt(import, class, class)
            parseClassExtendsOpt(import)
              listener: handleNoType(import)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(import)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(import)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(import, DeclarationKind.Class, import)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrValue(}, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(class)
  parseTopLevelDeclarationImpl(}, Instance of 'DirectiveContext')
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(}, class, null, Instance of 'DirectiveContext')
      parseClassDeclarationModifiers(}, class)
      parseClassOrNamedMixinApplication(null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          reportRecoverableErrorWithToken(in, Instance of 'Template<(Token) => Message>')
            listener: handleRecoverableError(Message[ExpectedIdentifierButGotKeyword, 'in' can't be used as an identifier because it's a keyword., Try renaming this to be an identifier that isn't a keyword., {lexeme: in}], in, in)
          listener: handleIdentifier(in, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, in)
        parseClass(in, class, class, in)
          parseClassHeaderOpt(in, class, class)
            parseClassExtendsOpt(in)
              listener: handleNoType(in)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(in)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(in)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(in, DeclarationKind.Class, in)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrValue(}, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(class)
  parseTopLevelDeclarationImpl(}, Instance of 'DirectiveContext')
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(}, class, null, Instance of 'DirectiveContext')
      parseClassDeclarationModifiers(}, class)
      parseClassOrNamedMixinApplication(null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          listener: handleIdentifier(inout, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, inout)
        parseClass(inout, class, class, inout)
          parseClassHeaderOpt(inout, class, class)
            parseClassExtendsOpt(inout)
              listener: handleNoType(inout)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(inout)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(inout)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(inout, DeclarationKind.Class, inout)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrValue(}, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(class)
  parseTopLevelDeclarationImpl(}, Instance of 'DirectiveContext')
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(}, class, null, Instance of 'DirectiveContext')
      parseClassDeclarationModifiers(}, class)
      parseClassOrNamedMixinApplication(null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          reportRecoverableErrorWithToken(interface, Instance of 'Template<(Token) => Message>')
            listener: handleRecoverableError(Message[BuiltInIdentifierInDeclaration, Can't use 'interface' as a name here., null, {lexeme: interface}], interface, interface)
          listener: handleIdentifier(interface, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, interface)
        parseClass(interface, class, class, interface)
          parseClassHeaderOpt(interface, class, class)
            parseClassExtendsOpt(interface)
              listener: handleNoType(interface)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(interface)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(interface)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(interface, DeclarationKind.Class, interface)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrValue(}, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(class)
  parseTopLevelDeclarationImpl(}, Instance of 'DirectiveContext')
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(}, class, null, Instance of 'DirectiveContext')
      parseClassDeclarationModifiers(}, class)
      parseClassOrNamedMixinApplication(null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          reportRecoverableErrorWithToken(is, Instance of 'Template<(Token) => Message>')
            listener: handleRecoverableError(Message[ExpectedIdentifierButGotKeyword, 'is' can't be used as an identifier because it's a keyword., Try renaming this to be an identifier that isn't a keyword., {lexeme: is}], is, is)
          listener: handleIdentifier(is, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, is)
        parseClass(is, class, class, is)
          parseClassHeaderOpt(is, class, class)
            parseClassExtendsOpt(is)
              listener: handleNoType(is)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(is)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(is)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(is, DeclarationKind.Class, is)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrValue(}, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(class)
  parseTopLevelDeclarationImpl(}, Instance of 'DirectiveContext')
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(}, class, null, Instance of 'DirectiveContext')
      parseClassDeclarationModifiers(}, class)
      parseClassOrNamedMixinApplication(null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          reportRecoverableErrorWithToken(late, Instance of 'Template<(Token) => Message>')
            listener: handleRecoverableError(Message[BuiltInIdentifierInDeclaration, Can't use 'late' as a name here., null, {lexeme: late}], late, late)
          listener: handleIdentifier(late, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, late)
        parseClass(late, class, class, late)
          parseClassHeaderOpt(late, class, class)
            parseClassExtendsOpt(late)
              listener: handleNoType(late)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(late)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(late)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(late, DeclarationKind.Class, late)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrValue(}, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(class)
  parseTopLevelDeclarationImpl(}, Instance of 'DirectiveContext')
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(}, class, null, Instance of 'DirectiveContext')
      parseClassDeclarationModifiers(}, class)
      parseClassOrNamedMixinApplication(null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          reportRecoverableErrorWithToken(library, Instance of 'Template<(Token) => Message>')
            listener: handleRecoverableError(Message[BuiltInIdentifierInDeclaration, Can't use 'library' as a name here., null, {lexeme: library}], library, library)
          listener: handleIdentifier(library, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, library)
        parseClass(library, class, class, library)
          parseClassHeaderOpt(library, class, class)
            parseClassExtendsOpt(library)
              listener: handleNoType(library)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(library)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(library)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(library, DeclarationKind.Class, library)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrValue(}, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(class)
  parseTopLevelDeclarationImpl(}, Instance of 'DirectiveContext')
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(}, class, null, Instance of 'DirectiveContext')
      parseClassDeclarationModifiers(}, class)
      parseClassOrNamedMixinApplication(null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          reportRecoverableErrorWithToken(mixin, Instance of 'Template<(Token) => Message>')
            listener: handleRecoverableError(Message[BuiltInIdentifierInDeclaration, Can't use 'mixin' as a name here., null, {lexeme: mixin}], mixin, mixin)
          listener: handleIdentifier(mixin, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, mixin)
        parseClass(mixin, class, class, mixin)
          parseClassHeaderOpt(mixin, class, class)
            parseClassExtendsOpt(mixin)
              listener: handleNoType(mixin)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(mixin)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(mixin)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(mixin, DeclarationKind.Class, mixin)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrValue(}, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(class)
  parseTopLevelDeclarationImpl(}, Instance of 'DirectiveContext')
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(}, class, null, Instance of 'DirectiveContext')
      parseClassDeclarationModifiers(}, class)
      parseClassOrNamedMixinApplication(null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          listener: handleIdentifier(native, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, native)
        parseClass(native, class, class, native)
          parseClassHeaderOpt(native, class, class)
            parseClassExtendsOpt(native)
              listener: handleNoType(native)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(native)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(native)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(native, DeclarationKind.Class, native)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrValue(}, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(class)
  parseTopLevelDeclarationImpl(}, Instance of 'DirectiveContext')
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(}, class, null, Instance of 'DirectiveContext')
      parseClassDeclarationModifiers(}, class)
      parseClassOrNamedMixinApplication(null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          reportRecoverableErrorWithToken(new, Instance of 'Template<(Token) => Message>')
            listener: handleRecoverableError(Message[ExpectedIdentifierButGotKeyword, 'new' can't be used as an identifier because it's a keyword., Try renaming this to be an identifier that isn't a keyword., {lexeme: new}], new, new)
          listener: handleIdentifier(new, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, new)
        parseClass(new, class, class, new)
          parseClassHeaderOpt(new, class, class)
            parseClassExtendsOpt(new)
              listener: handleNoType(new)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(new)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(new)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(new, DeclarationKind.Class, new)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrValue(}, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(class)
  parseTopLevelDeclarationImpl(}, Instance of 'DirectiveContext')
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(}, class, null, Instance of 'DirectiveContext')
      parseClassDeclarationModifiers(}, class)
      parseClassOrNamedMixinApplication(null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          reportRecoverableErrorWithToken(null, Instance of 'Template<(Token) => Message>')
            listener: handleRecoverableError(Message[ExpectedIdentifierButGotKeyword, 'null' can't be used as an identifier because it's a keyword., Try renaming this to be an identifier that isn't a keyword., {lexeme: null}], null, null)
          listener: handleIdentifier(null, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, null)
        parseClass(null, class, class, null)
          parseClassHeaderOpt(null, class, class)
            parseClassExtendsOpt(null)
              listener: handleNoType(null)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(null)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(null)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(null, DeclarationKind.Class, null)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrValue(}, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(class)
  parseTopLevelDeclarationImpl(}, Instance of 'DirectiveContext')
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(}, class, null, Instance of 'DirectiveContext')
      parseClassDeclarationModifiers(}, class)
      parseClassOrNamedMixinApplication(null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          listener: handleIdentifier(of, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, of)
        parseClass(of, class, class, of)
          parseClassHeaderOpt(of, class, class)
            parseClassExtendsOpt(of)
              listener: handleNoType(of)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(of)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(of)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(of, DeclarationKind.Class, of)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrValue(}, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(class)
  parseTopLevelDeclarationImpl(}, Instance of 'DirectiveContext')
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(}, class, null, Instance of 'DirectiveContext')
      parseClassDeclarationModifiers(}, class)
      parseClassOrNamedMixinApplication(null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          listener: handleIdentifier(on, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, on)
        parseClass(on, class, class, on)
          parseClassHeaderOpt(on, class, class)
            parseClassExtendsOpt(on)
              listener: handleNoType(on)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(on)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(on)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(on, DeclarationKind.Class, on)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrValue(}, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(class)
  parseTopLevelDeclarationImpl(}, Instance of 'DirectiveContext')
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(}, class, null, Instance of 'DirectiveContext')
      parseClassDeclarationModifiers(}, class)
      parseClassOrNamedMixinApplication(null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          reportRecoverableErrorWithToken(operator, Instance of 'Template<(Token) => Message>')
            listener: handleRecoverableError(Message[BuiltInIdentifierInDeclaration, Can't use 'operator' as a name here., null, {lexeme: operator}], operator, operator)
          listener: handleIdentifier(operator, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, operator)
        parseClass(operator, class, class, operator)
          parseClassHeaderOpt(operator, class, class)
            parseClassExtendsOpt(operator)
              listener: handleNoType(operator)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(operator)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(operator)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(operator, DeclarationKind.Class, operator)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrValue(}, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(class)
  parseTopLevelDeclarationImpl(}, Instance of 'DirectiveContext')
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(}, class, null, Instance of 'DirectiveContext')
      parseClassDeclarationModifiers(}, class)
      parseClassOrNamedMixinApplication(null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          listener: handleIdentifier(out, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, out)
        parseClass(out, class, class, out)
          parseClassHeaderOpt(out, class, class)
            parseClassExtendsOpt(out)
              listener: handleNoType(out)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(out)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(out)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(out, DeclarationKind.Class, out)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrValue(}, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(class)
  parseTopLevelDeclarationImpl(}, Instance of 'DirectiveContext')
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(}, class, null, Instance of 'DirectiveContext')
      parseClassDeclarationModifiers(}, class)
      parseClassOrNamedMixinApplication(null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          reportRecoverableErrorWithToken(part, Instance of 'Template<(Token) => Message>')
            listener: handleRecoverableError(Message[BuiltInIdentifierInDeclaration, Can't use 'part' as a name here., null, {lexeme: part}], part, part)
          listener: handleIdentifier(part, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, part)
        parseClass(part, class, class, part)
          parseClassHeaderOpt(part, class, class)
            parseClassExtendsOpt(part)
              listener: handleNoType(part)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(part)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(part)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(part, DeclarationKind.Class, part)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrValue(}, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(class)
  parseTopLevelDeclarationImpl(}, Instance of 'DirectiveContext')
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(}, class, null, Instance of 'DirectiveContext')
      parseClassDeclarationModifiers(}, class)
      parseClassOrNamedMixinApplication(null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          listener: handleIdentifier(patch, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, patch)
        parseClass(patch, class, class, patch)
          parseClassHeaderOpt(patch, class, class)
            parseClassExtendsOpt(patch)
              listener: handleNoType(patch)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(patch)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(patch)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(patch, DeclarationKind.Class, patch)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrValue(}, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(class)
  parseTopLevelDeclarationImpl(}, Instance of 'DirectiveContext')
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(}, class, null, Instance of 'DirectiveContext')
      parseClassDeclarationModifiers(}, class)
      parseClassOrNamedMixinApplication(null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          reportRecoverableErrorWithToken(required, Instance of 'Template<(Token) => Message>')
            listener: handleRecoverableError(Message[BuiltInIdentifierInDeclaration, Can't use 'required' as a name here., null, {lexeme: required}], required, required)
          listener: handleIdentifier(required, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, required)
        parseClass(required, class, class, required)
          parseClassHeaderOpt(required, class, class)
            parseClassExtendsOpt(required)
              listener: handleNoType(required)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(required)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(required)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(required, DeclarationKind.Class, required)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrValue(}, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(class)
  parseTopLevelDeclarationImpl(}, Instance of 'DirectiveContext')
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(}, class, null, Instance of 'DirectiveContext')
      parseClassDeclarationModifiers(}, class)
      parseClassOrNamedMixinApplication(null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          reportRecoverableErrorWithToken(rethrow, Instance of 'Template<(Token) => Message>')
            listener: handleRecoverableError(Message[ExpectedIdentifierButGotKeyword, 'rethrow' can't be used as an identifier because it's a keyword., Try renaming this to be an identifier that isn't a keyword., {lexeme: rethrow}], rethrow, rethrow)
          listener: handleIdentifier(rethrow, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, rethrow)
        parseClass(rethrow, class, class, rethrow)
          parseClassHeaderOpt(rethrow, class, class)
            parseClassExtendsOpt(rethrow)
              listener: handleNoType(rethrow)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(rethrow)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(rethrow)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(rethrow, DeclarationKind.Class, rethrow)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrValue(}, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(class)
  parseTopLevelDeclarationImpl(}, Instance of 'DirectiveContext')
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(}, class, null, Instance of 'DirectiveContext')
      parseClassDeclarationModifiers(}, class)
      parseClassOrNamedMixinApplication(null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          reportRecoverableErrorWithToken(return, Instance of 'Template<(Token) => Message>')
            listener: handleRecoverableError(Message[ExpectedIdentifierButGotKeyword, 'return' can't be used as an identifier because it's a keyword., Try renaming this to be an identifier that isn't a keyword., {lexeme: return}], return, return)
          listener: handleIdentifier(return, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, return)
        parseClass(return, class, class, return)
          parseClassHeaderOpt(return, class, class)
            parseClassExtendsOpt(return)
              listener: handleNoType(return)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(return)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(return)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(return, DeclarationKind.Class, return)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrValue(}, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(class)
  parseTopLevelDeclarationImpl(}, Instance of 'DirectiveContext')
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(}, class, null, Instance of 'DirectiveContext')
      parseClassDeclarationModifiers(}, class)
      parseClassOrNamedMixinApplication(null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          reportRecoverableErrorWithToken(set, Instance of 'Template<(Token) => Message>')
            listener: handleRecoverableError(Message[BuiltInIdentifierInDeclaration, Can't use 'set' as a name here., null, {lexeme: set}], set, set)
          listener: handleIdentifier(set, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, set)
        parseClass(set, class, class, set)
          parseClassHeaderOpt(set, class, class)
            parseClassExtendsOpt(set)
              listener: handleNoType(set)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(set)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(set)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(set, DeclarationKind.Class, set)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrValue(}, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(class)
  parseTopLevelDeclarationImpl(}, Instance of 'DirectiveContext')
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(}, class, null, Instance of 'DirectiveContext')
      parseClassDeclarationModifiers(}, class)
      parseClassOrNamedMixinApplication(null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          listener: handleIdentifier(show, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, show)
        parseClass(show, class, class, show)
          parseClassHeaderOpt(show, class, class)
            parseClassExtendsOpt(show)
              listener: handleNoType(show)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(show)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(show)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(show, DeclarationKind.Class, show)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrValue(}, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(class)
  parseTopLevelDeclarationImpl(}, Instance of 'DirectiveContext')
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(}, class, null, Instance of 'DirectiveContext')
      parseClassDeclarationModifiers(}, class)
      parseClassOrNamedMixinApplication(null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          listener: handleIdentifier(source, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, source)
        parseClass(source, class, class, source)
          parseClassHeaderOpt(source, class, class)
            parseClassExtendsOpt(source)
              listener: handleNoType(source)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(source)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(source)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(source, DeclarationKind.Class, source)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrValue(}, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(class)
  parseTopLevelDeclarationImpl(}, Instance of 'DirectiveContext')
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(}, class, null, Instance of 'DirectiveContext')
      parseClassDeclarationModifiers(}, class)
      parseClassOrNamedMixinApplication(null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          reportRecoverableErrorWithToken(static, Instance of 'Template<(Token) => Message>')
            listener: handleRecoverableError(Message[BuiltInIdentifierInDeclaration, Can't use 'static' as a name here., null, {lexeme: static}], static, static)
          listener: handleIdentifier(static, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, static)
        parseClass(static, class, class, static)
          parseClassHeaderOpt(static, class, class)
            parseClassExtendsOpt(static)
              listener: handleNoType(static)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(static)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(static)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(static, DeclarationKind.Class, static)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrValue(}, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(class)
  parseTopLevelDeclarationImpl(}, Instance of 'DirectiveContext')
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(}, class, null, Instance of 'DirectiveContext')
      parseClassDeclarationModifiers(}, class)
      parseClassOrNamedMixinApplication(null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          reportRecoverableErrorWithToken(super, Instance of 'Template<(Token) => Message>')
            listener: handleRecoverableError(Message[ExpectedIdentifierButGotKeyword, 'super' can't be used as an identifier because it's a keyword., Try renaming this to be an identifier that isn't a keyword., {lexeme: super}], super, super)
          listener: handleIdentifier(super, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, super)
        parseClass(super, class, class, super)
          parseClassHeaderOpt(super, class, class)
            parseClassExtendsOpt(super)
              listener: handleNoType(super)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(super)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(super)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(super, DeclarationKind.Class, super)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrValue(}, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(class)
  parseTopLevelDeclarationImpl(}, Instance of 'DirectiveContext')
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(}, class, null, Instance of 'DirectiveContext')
      parseClassDeclarationModifiers(}, class)
      parseClassOrNamedMixinApplication(null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          reportRecoverableErrorWithToken(switch, Instance of 'Template<(Token) => Message>')
            listener: handleRecoverableError(Message[ExpectedIdentifierButGotKeyword, 'switch' can't be used as an identifier because it's a keyword., Try renaming this to be an identifier that isn't a keyword., {lexeme: switch}], switch, switch)
          listener: handleIdentifier(switch, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, switch)
        parseClass(switch, class, class, switch)
          parseClassHeaderOpt(switch, class, class)
            parseClassExtendsOpt(switch)
              listener: handleNoType(switch)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(switch)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(switch)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(switch, DeclarationKind.Class, switch)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrValue(}, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(class)
  parseTopLevelDeclarationImpl(}, Instance of 'DirectiveContext')
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(}, class, null, Instance of 'DirectiveContext')
      parseClassDeclarationModifiers(}, class)
      parseClassOrNamedMixinApplication(null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          listener: handleIdentifier(sync, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, sync)
        parseClass(sync, class, class, sync)
          parseClassHeaderOpt(sync, class, class)
            parseClassExtendsOpt(sync)
              listener: handleNoType(sync)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(sync)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(sync)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(sync, DeclarationKind.Class, sync)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrValue(}, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(class)
  parseTopLevelDeclarationImpl(}, Instance of 'DirectiveContext')
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(}, class, null, Instance of 'DirectiveContext')
      parseClassDeclarationModifiers(}, class)
      parseClassOrNamedMixinApplication(null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          reportRecoverableErrorWithToken(this, Instance of 'Template<(Token) => Message>')
            listener: handleRecoverableError(Message[ExpectedIdentifierButGotKeyword, 'this' can't be used as an identifier because it's a keyword., Try renaming this to be an identifier that isn't a keyword., {lexeme: this}], this, this)
          listener: handleIdentifier(this, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, this)
        parseClass(this, class, class, this)
          parseClassHeaderOpt(this, class, class)
            parseClassExtendsOpt(this)
              listener: handleNoType(this)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(this)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(this)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(this, DeclarationKind.Class, this)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrValue(}, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(class)
  parseTopLevelDeclarationImpl(}, Instance of 'DirectiveContext')
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(}, class, null, Instance of 'DirectiveContext')
      parseClassDeclarationModifiers(}, class)
      parseClassOrNamedMixinApplication(null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          reportRecoverableErrorWithToken(throw, Instance of 'Template<(Token) => Message>')
            listener: handleRecoverableError(Message[ExpectedIdentifierButGotKeyword, 'throw' can't be used as an identifier because it's a keyword., Try renaming this to be an identifier that isn't a keyword., {lexeme: throw}], throw, throw)
          listener: handleIdentifier(throw, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, throw)
        parseClass(throw, class, class, throw)
          parseClassHeaderOpt(throw, class, class)
            parseClassExtendsOpt(throw)
              listener: handleNoType(throw)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(throw)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(throw)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(throw, DeclarationKind.Class, throw)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrValue(}, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(class)
  parseTopLevelDeclarationImpl(}, Instance of 'DirectiveContext')
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(}, class, null, Instance of 'DirectiveContext')
      parseClassDeclarationModifiers(}, class)
      parseClassOrNamedMixinApplication(null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          reportRecoverableErrorWithToken(true, Instance of 'Template<(Token) => Message>')
            listener: handleRecoverableError(Message[ExpectedIdentifierButGotKeyword, 'true' can't be used as an identifier because it's a keyword., Try renaming this to be an identifier that isn't a keyword., {lexeme: true}], true, true)
          listener: handleIdentifier(true, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, true)
        parseClass(true, class, class, true)
          parseClassHeaderOpt(true, class, class)
            parseClassExtendsOpt(true)
              listener: handleNoType(true)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(true)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(true)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(true, DeclarationKind.Class, true)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrValue(}, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(class)
  parseTopLevelDeclarationImpl(}, Instance of 'DirectiveContext')
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(}, class, null, Instance of 'DirectiveContext')
      parseClassDeclarationModifiers(}, class)
      parseClassOrNamedMixinApplication(null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          reportRecoverableErrorWithToken(try, Instance of 'Template<(Token) => Message>')
            listener: handleRecoverableError(Message[ExpectedIdentifierButGotKeyword, 'try' can't be used as an identifier because it's a keyword., Try renaming this to be an identifier that isn't a keyword., {lexeme: try}], try, try)
          listener: handleIdentifier(try, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, try)
        parseClass(try, class, class, try)
          parseClassHeaderOpt(try, class, class)
            parseClassExtendsOpt(try)
              listener: handleNoType(try)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(try)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(try)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(try, DeclarationKind.Class, try)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrValue(}, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(class)
  parseTopLevelDeclarationImpl(}, Instance of 'DirectiveContext')
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(}, class, null, Instance of 'DirectiveContext')
      parseClassDeclarationModifiers(}, class)
      parseClassOrNamedMixinApplication(null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          reportRecoverableErrorWithToken(typedef, Instance of 'Template<(Token) => Message>')
            listener: handleRecoverableError(Message[BuiltInIdentifierInDeclaration, Can't use 'typedef' as a name here., null, {lexeme: typedef}], typedef, typedef)
          listener: handleIdentifier(typedef, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, typedef)
        parseClass(typedef, class, class, typedef)
          parseClassHeaderOpt(typedef, class, class)
            parseClassExtendsOpt(typedef)
              listener: handleNoType(typedef)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(typedef)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(typedef)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(typedef, DeclarationKind.Class, typedef)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrValue(}, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(class)
  parseTopLevelDeclarationImpl(}, Instance of 'DirectiveContext')
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(}, class, null, Instance of 'DirectiveContext')
      parseClassDeclarationModifiers(}, class)
      parseClassOrNamedMixinApplication(null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          reportRecoverableErrorWithToken(var, Instance of 'Template<(Token) => Message>')
            listener: handleRecoverableError(Message[ExpectedIdentifierButGotKeyword, 'var' can't be used as an identifier because it's a keyword., Try renaming this to be an identifier that isn't a keyword., {lexeme: var}], var, var)
          listener: handleIdentifier(var, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, var)
        parseClass(var, class, class, var)
          parseClassHeaderOpt(var, class, class)
            parseClassExtendsOpt(var)
              listener: handleNoType(var)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(var)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(var)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(var, DeclarationKind.Class, var)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrValue(}, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(class)
  parseTopLevelDeclarationImpl(}, Instance of 'DirectiveContext')
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(}, class, null, Instance of 'DirectiveContext')
      parseClassDeclarationModifiers(}, class)
      parseClassOrNamedMixinApplication(null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          reportRecoverableErrorWithToken(void, Instance of 'Template<(Token) => Message>')
            listener: handleRecoverableError(Message[ExpectedIdentifierButGotKeyword, 'void' can't be used as an identifier because it's a keyword., Try renaming this to be an identifier that isn't a keyword., {lexeme: void}], void, void)
          listener: handleIdentifier(void, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, void)
        parseClass(void, class, class, void)
          parseClassHeaderOpt(void, class, class)
            parseClassExtendsOpt(void)
              listener: handleNoType(void)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(void)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(void)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(void, DeclarationKind.Class, void)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrValue(}, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(class)
  parseTopLevelDeclarationImpl(}, Instance of 'DirectiveContext')
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(}, class, null, Instance of 'DirectiveContext')
      parseClassDeclarationModifiers(}, class)
      parseClassOrNamedMixinApplication(null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          reportRecoverableErrorWithToken(while, Instance of 'Template<(Token) => Message>')
            listener: handleRecoverableError(Message[ExpectedIdentifierButGotKeyword, 'while' can't be used as an identifier because it's a keyword., Try renaming this to be an identifier that isn't a keyword., {lexeme: while}], while, while)
          listener: handleIdentifier(while, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, while)
        parseClass(while, class, class, while)
          parseClassHeaderOpt(while, class, class)
            parseClassExtendsOpt(while)
              listener: handleNoType(while)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(while)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(while)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(while, DeclarationKind.Class, while)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrValue(}, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(class)
  parseTopLevelDeclarationImpl(}, Instance of 'DirectiveContext')
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(}, class, null, Instance of 'DirectiveContext')
      parseClassDeclarationModifiers(}, class)
      parseClassOrNamedMixinApplication(null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          reportRecoverableErrorWithToken(with, Instance of 'Template<(Token) => Message>')
            listener: handleRecoverableError(Message[ExpectedIdentifierButGotKeyword, 'with' can't be used as an identifier because it's a keyword., Try renaming this to be an identifier that isn't a keyword., {lexeme: with}], with, with)
          listener: handleIdentifier(with, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, with)
        parseClass(with, class, class, with)
          parseClassHeaderOpt(with, class, class)
            parseClassExtendsOpt(with)
              listener: handleNoType(with)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(with)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(with)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(with, DeclarationKind.Class, with)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrValue(}, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(class)
  parseTopLevelDeclarationImpl(}, Instance of 'DirectiveContext')
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(}, class, null, Instance of 'DirectiveContext')
      parseClassDeclarationModifiers(}, class)
      parseClassOrNamedMixinApplication(null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          listener: handleIdentifier(yield, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, yield)
        parseClass(yield, class, class, yield)
          parseClassHeaderOpt(yield, class, class)
            parseClassExtendsOpt(yield)
              listener: handleNoType(yield)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(yield)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(yield)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(yield, DeclarationKind.Class, yield)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrValue(}, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration()
  reportAllErrorTokens(class)
  listener: endCompilationUnit(69, )
