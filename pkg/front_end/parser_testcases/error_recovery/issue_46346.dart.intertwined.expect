parseUnit(class)
  skipErrorTokens(class)
  listener: beginCompilationUnit(class)
  syntheticPreviousToken(class)
  parseTopLevelDeclarationImpl(, DirectiveContext(DirectiveState.Unknown))
    parseMetadataStar()
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(class, , class, null, null, null, null, DirectiveContext(DirectiveState.Unknown))
      parseClassOrNamedMixinApplication(class, null, null, null, null, null, null, null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          reportRecoverableErrorWithToken(abstract, Template(BuiltInIdentifierInDeclaration))
            listener: handleRecoverableError(Message[Template(BuiltInIdentifierInDeclaration), Can't use 'abstract' as a name here., null, {lexeme: abstract}], abstract, abstract)
          listener: handleIdentifier(abstract, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, null, null, null, null, null, null, abstract)
        parseClass(abstract, class, class, null, abstract)
          parsePrimaryConstructorOpt(abstract, null, false)
            listener: handleNoPrimaryConstructor(abstract, null, false)
          parseClassHeaderOpt(abstract, class, class)
            parseClassExtendsOpt(abstract, DeclarationHeaderKind.Class)
              listener: handleNoType(abstract)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(abstract)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(abstract)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(abstract, DeclarationKind.Class, abstract)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrType(CLOSE_CURLY_BRACKET, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(})
  parseTopLevelDeclarationImpl(}, DirectiveContext(DirectiveState.Declarations))
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(class, }, class, null, null, null, null, DirectiveContext(DirectiveState.Declarations))
      parseClassOrNamedMixinApplication(class, null, null, null, null, null, null, null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          reportRecoverableErrorWithToken(as, Template(BuiltInIdentifierInDeclaration))
            listener: handleRecoverableError(Message[Template(BuiltInIdentifierInDeclaration), Can't use 'as' as a name here., null, {lexeme: as}], as, as)
          listener: handleIdentifier(as, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, null, null, null, null, null, null, as)
        parseClass(as, class, class, null, as)
          parsePrimaryConstructorOpt(as, null, false)
            listener: handleNoPrimaryConstructor(as, null, false)
          parseClassHeaderOpt(as, class, class)
            parseClassExtendsOpt(as, DeclarationHeaderKind.Class)
              listener: handleNoType(as)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(as)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(as)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(as, DeclarationKind.Class, as)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrType(CLOSE_CURLY_BRACKET, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(})
  parseTopLevelDeclarationImpl(}, DirectiveContext(DirectiveState.Declarations))
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(class, }, class, null, null, null, null, DirectiveContext(DirectiveState.Declarations))
      parseClassOrNamedMixinApplication(class, null, null, null, null, null, null, null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          reportRecoverableErrorWithToken(assert, Template(ExpectedIdentifierButGotKeyword))
            listener: handleRecoverableError(Message[Template(ExpectedIdentifierButGotKeyword), 'assert' can't be used as an identifier because it's a keyword., Try renaming this to be an identifier that isn't a keyword., {lexeme: assert}], assert, assert)
          listener: handleIdentifier(assert, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, null, null, null, null, null, null, assert)
        parseClass(assert, class, class, null, assert)
          parsePrimaryConstructorOpt(assert, null, false)
            listener: handleNoPrimaryConstructor(assert, null, false)
          parseClassHeaderOpt(assert, class, class)
            parseClassExtendsOpt(assert, DeclarationHeaderKind.Class)
              listener: handleNoType(assert)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(assert)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(assert)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(assert, DeclarationKind.Class, assert)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrType(CLOSE_CURLY_BRACKET, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(})
  parseTopLevelDeclarationImpl(}, DirectiveContext(DirectiveState.Declarations))
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(class, }, class, null, null, null, null, DirectiveContext(DirectiveState.Declarations))
      parseClassOrNamedMixinApplication(class, null, null, null, null, null, null, null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          listener: handleIdentifier(async, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, null, null, null, null, null, null, async)
        parseClass(async, class, class, null, async)
          parsePrimaryConstructorOpt(async, null, false)
            listener: handleNoPrimaryConstructor(async, null, false)
          parseClassHeaderOpt(async, class, class)
            parseClassExtendsOpt(async, DeclarationHeaderKind.Class)
              listener: handleNoType(async)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(async)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(async)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(async, DeclarationKind.Class, async)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrType(CLOSE_CURLY_BRACKET, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(})
  parseTopLevelDeclarationImpl(}, DirectiveContext(DirectiveState.Declarations))
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(class, }, class, null, null, null, null, DirectiveContext(DirectiveState.Declarations))
      parseClassOrNamedMixinApplication(class, null, null, null, null, null, null, null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          listener: handleIdentifier(await, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, null, null, null, null, null, null, await)
        parseClass(await, class, class, null, await)
          parsePrimaryConstructorOpt(await, null, false)
            listener: handleNoPrimaryConstructor(await, null, false)
          parseClassHeaderOpt(await, class, class)
            parseClassExtendsOpt(await, DeclarationHeaderKind.Class)
              listener: handleNoType(await)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(await)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(await)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(await, DeclarationKind.Class, await)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrType(CLOSE_CURLY_BRACKET, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(})
  parseTopLevelDeclarationImpl(}, DirectiveContext(DirectiveState.Declarations))
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(class, }, class, null, null, null, null, DirectiveContext(DirectiveState.Declarations))
      parseClassOrNamedMixinApplication(class, null, null, null, null, null, null, null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          reportRecoverableErrorWithToken(break, Template(ExpectedIdentifierButGotKeyword))
            listener: handleRecoverableError(Message[Template(ExpectedIdentifierButGotKeyword), 'break' can't be used as an identifier because it's a keyword., Try renaming this to be an identifier that isn't a keyword., {lexeme: break}], break, break)
          listener: handleIdentifier(break, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, null, null, null, null, null, null, break)
        parseClass(break, class, class, null, break)
          parsePrimaryConstructorOpt(break, null, false)
            listener: handleNoPrimaryConstructor(break, null, false)
          parseClassHeaderOpt(break, class, class)
            parseClassExtendsOpt(break, DeclarationHeaderKind.Class)
              listener: handleNoType(break)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(break)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(break)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(break, DeclarationKind.Class, break)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrType(CLOSE_CURLY_BRACKET, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(})
  parseTopLevelDeclarationImpl(}, DirectiveContext(DirectiveState.Declarations))
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(class, }, class, null, null, null, null, DirectiveContext(DirectiveState.Declarations))
      parseClassOrNamedMixinApplication(class, null, null, null, null, null, null, null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          reportRecoverableErrorWithToken(case, Template(ExpectedIdentifierButGotKeyword))
            listener: handleRecoverableError(Message[Template(ExpectedIdentifierButGotKeyword), 'case' can't be used as an identifier because it's a keyword., Try renaming this to be an identifier that isn't a keyword., {lexeme: case}], case, case)
          listener: handleIdentifier(case, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, null, null, null, null, null, null, case)
        parseClass(case, class, class, null, case)
          parsePrimaryConstructorOpt(case, null, false)
            listener: handleNoPrimaryConstructor(case, null, false)
          parseClassHeaderOpt(case, class, class)
            parseClassExtendsOpt(case, DeclarationHeaderKind.Class)
              listener: handleNoType(case)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(case)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(case)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(case, DeclarationKind.Class, case)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrType(CLOSE_CURLY_BRACKET, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(})
  parseTopLevelDeclarationImpl(}, DirectiveContext(DirectiveState.Declarations))
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(class, }, class, null, null, null, null, DirectiveContext(DirectiveState.Declarations))
      parseClassOrNamedMixinApplication(class, null, null, null, null, null, null, null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          reportRecoverableErrorWithToken(catch, Template(ExpectedIdentifierButGotKeyword))
            listener: handleRecoverableError(Message[Template(ExpectedIdentifierButGotKeyword), 'catch' can't be used as an identifier because it's a keyword., Try renaming this to be an identifier that isn't a keyword., {lexeme: catch}], catch, catch)
          listener: handleIdentifier(catch, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, null, null, null, null, null, null, catch)
        parseClass(catch, class, class, null, catch)
          parsePrimaryConstructorOpt(catch, null, false)
            listener: handleNoPrimaryConstructor(catch, null, false)
          parseClassHeaderOpt(catch, class, class)
            parseClassExtendsOpt(catch, DeclarationHeaderKind.Class)
              listener: handleNoType(catch)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(catch)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(catch)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(catch, DeclarationKind.Class, catch)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrType(CLOSE_CURLY_BRACKET, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(})
  parseTopLevelDeclarationImpl(}, DirectiveContext(DirectiveState.Declarations))
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(class, }, class, null, null, null, null, DirectiveContext(DirectiveState.Declarations))
      parseClassOrNamedMixinApplication(class, null, null, null, null, null, null, null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          reportRecoverableErrorWithToken(class, Template(ExpectedIdentifierButGotKeyword))
            listener: handleRecoverableError(Message[Template(ExpectedIdentifierButGotKeyword), 'class' can't be used as an identifier because it's a keyword., Try renaming this to be an identifier that isn't a keyword., {lexeme: class}], class, class)
          listener: handleIdentifier(class, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, null, null, null, null, null, null, class)
        parseClass(class, class, class, null, class)
          parsePrimaryConstructorOpt(class, null, false)
            listener: handleNoPrimaryConstructor(class, null, false)
          parseClassHeaderOpt(class, class, class)
            parseClassExtendsOpt(class, DeclarationHeaderKind.Class)
              listener: handleNoType(class)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(class)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(class)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(class, DeclarationKind.Class, class)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrType(CLOSE_CURLY_BRACKET, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(})
  parseTopLevelDeclarationImpl(}, DirectiveContext(DirectiveState.Declarations))
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(class, }, class, null, null, null, null, DirectiveContext(DirectiveState.Declarations))
      parseClassOrNamedMixinApplication(class, null, null, null, null, null, null, null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(const, classOrMixinDeclaration)
          insertSyntheticIdentifier(const, classOrMixinDeclaration, message: Message[Template(ExpectedIdentifier), Expected an identifier, but got '{'., Try inserting an identifier before '{'., {lexeme: {}], messageOnToken: null)
            reportRecoverableError({, Message[Template(ExpectedIdentifier), Expected an identifier, but got '{'., Try inserting an identifier before '{'., {lexeme: {}])
              listener: handleRecoverableError(Message[Template(ExpectedIdentifier), Expected an identifier, but got '{'., Try inserting an identifier before '{'., {lexeme: {}], {, {)
            rewriter()
          listener: handleIdentifier(, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, null, null, null, null, null, null, )
        parseClass(, class, class, const, )
          parsePrimaryConstructorOpt(, const, false)
            reportRecoverableError(const, ConstWithoutPrimaryConstructor)
              listener: handleRecoverableError(ConstWithoutPrimaryConstructor, const, const)
            listener: handleNoPrimaryConstructor(, const, false)
          parseClassHeaderOpt(, class, class)
            parseClassExtendsOpt(, DeclarationHeaderKind.Class)
              listener: handleNoType()
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt()
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt()
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(, DeclarationKind.Class, )
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrType(CLOSE_CURLY_BRACKET, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(})
  parseTopLevelDeclarationImpl(}, DirectiveContext(DirectiveState.Declarations))
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(class, }, class, null, null, null, null, DirectiveContext(DirectiveState.Declarations))
      parseClassOrNamedMixinApplication(class, null, null, null, null, null, null, null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          reportRecoverableErrorWithToken(continue, Template(ExpectedIdentifierButGotKeyword))
            listener: handleRecoverableError(Message[Template(ExpectedIdentifierButGotKeyword), 'continue' can't be used as an identifier because it's a keyword., Try renaming this to be an identifier that isn't a keyword., {lexeme: continue}], continue, continue)
          listener: handleIdentifier(continue, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, null, null, null, null, null, null, continue)
        parseClass(continue, class, class, null, continue)
          parsePrimaryConstructorOpt(continue, null, false)
            listener: handleNoPrimaryConstructor(continue, null, false)
          parseClassHeaderOpt(continue, class, class)
            parseClassExtendsOpt(continue, DeclarationHeaderKind.Class)
              listener: handleNoType(continue)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(continue)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(continue)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(continue, DeclarationKind.Class, continue)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrType(CLOSE_CURLY_BRACKET, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(})
  parseTopLevelDeclarationImpl(}, DirectiveContext(DirectiveState.Declarations))
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(class, }, class, null, null, null, null, DirectiveContext(DirectiveState.Declarations))
      parseClassOrNamedMixinApplication(class, null, null, null, null, null, null, null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          reportRecoverableErrorWithToken(covariant, Template(BuiltInIdentifierInDeclaration))
            listener: handleRecoverableError(Message[Template(BuiltInIdentifierInDeclaration), Can't use 'covariant' as a name here., null, {lexeme: covariant}], covariant, covariant)
          listener: handleIdentifier(covariant, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, null, null, null, null, null, null, covariant)
        parseClass(covariant, class, class, null, covariant)
          parsePrimaryConstructorOpt(covariant, null, false)
            listener: handleNoPrimaryConstructor(covariant, null, false)
          parseClassHeaderOpt(covariant, class, class)
            parseClassExtendsOpt(covariant, DeclarationHeaderKind.Class)
              listener: handleNoType(covariant)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(covariant)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(covariant)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(covariant, DeclarationKind.Class, covariant)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrType(CLOSE_CURLY_BRACKET, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(})
  parseTopLevelDeclarationImpl(}, DirectiveContext(DirectiveState.Declarations))
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(class, }, class, null, null, null, null, DirectiveContext(DirectiveState.Declarations))
      parseClassOrNamedMixinApplication(class, null, null, null, null, null, null, null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          reportRecoverableErrorWithToken(default, Template(ExpectedIdentifierButGotKeyword))
            listener: handleRecoverableError(Message[Template(ExpectedIdentifierButGotKeyword), 'default' can't be used as an identifier because it's a keyword., Try renaming this to be an identifier that isn't a keyword., {lexeme: default}], default, default)
          listener: handleIdentifier(default, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, null, null, null, null, null, null, default)
        parseClass(default, class, class, null, default)
          parsePrimaryConstructorOpt(default, null, false)
            listener: handleNoPrimaryConstructor(default, null, false)
          parseClassHeaderOpt(default, class, class)
            parseClassExtendsOpt(default, DeclarationHeaderKind.Class)
              listener: handleNoType(default)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(default)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(default)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(default, DeclarationKind.Class, default)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrType(CLOSE_CURLY_BRACKET, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(})
  parseTopLevelDeclarationImpl(}, DirectiveContext(DirectiveState.Declarations))
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(class, }, class, null, null, null, null, DirectiveContext(DirectiveState.Declarations))
      parseClassOrNamedMixinApplication(class, null, null, null, null, null, null, null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          reportRecoverableErrorWithToken(deferred, Template(BuiltInIdentifierInDeclaration))
            listener: handleRecoverableError(Message[Template(BuiltInIdentifierInDeclaration), Can't use 'deferred' as a name here., null, {lexeme: deferred}], deferred, deferred)
          listener: handleIdentifier(deferred, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, null, null, null, null, null, null, deferred)
        parseClass(deferred, class, class, null, deferred)
          parsePrimaryConstructorOpt(deferred, null, false)
            listener: handleNoPrimaryConstructor(deferred, null, false)
          parseClassHeaderOpt(deferred, class, class)
            parseClassExtendsOpt(deferred, DeclarationHeaderKind.Class)
              listener: handleNoType(deferred)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(deferred)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(deferred)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(deferred, DeclarationKind.Class, deferred)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrType(CLOSE_CURLY_BRACKET, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(})
  parseTopLevelDeclarationImpl(}, DirectiveContext(DirectiveState.Declarations))
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(class, }, class, null, null, null, null, DirectiveContext(DirectiveState.Declarations))
      parseClassOrNamedMixinApplication(class, null, null, null, null, null, null, null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          reportRecoverableErrorWithToken(do, Template(ExpectedIdentifierButGotKeyword))
            listener: handleRecoverableError(Message[Template(ExpectedIdentifierButGotKeyword), 'do' can't be used as an identifier because it's a keyword., Try renaming this to be an identifier that isn't a keyword., {lexeme: do}], do, do)
          listener: handleIdentifier(do, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, null, null, null, null, null, null, do)
        parseClass(do, class, class, null, do)
          parsePrimaryConstructorOpt(do, null, false)
            listener: handleNoPrimaryConstructor(do, null, false)
          parseClassHeaderOpt(do, class, class)
            parseClassExtendsOpt(do, DeclarationHeaderKind.Class)
              listener: handleNoType(do)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(do)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(do)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(do, DeclarationKind.Class, do)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrType(CLOSE_CURLY_BRACKET, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(})
  parseTopLevelDeclarationImpl(}, DirectiveContext(DirectiveState.Declarations))
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(class, }, class, null, null, null, null, DirectiveContext(DirectiveState.Declarations))
      parseClassOrNamedMixinApplication(class, null, null, null, null, null, null, null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          reportRecoverableErrorWithToken(dynamic, Template(BuiltInIdentifierInDeclaration))
            listener: handleRecoverableError(Message[Template(BuiltInIdentifierInDeclaration), Can't use 'dynamic' as a name here., null, {lexeme: dynamic}], dynamic, dynamic)
          listener: handleIdentifier(dynamic, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, null, null, null, null, null, null, dynamic)
        parseClass(dynamic, class, class, null, dynamic)
          parsePrimaryConstructorOpt(dynamic, null, false)
            listener: handleNoPrimaryConstructor(dynamic, null, false)
          parseClassHeaderOpt(dynamic, class, class)
            parseClassExtendsOpt(dynamic, DeclarationHeaderKind.Class)
              listener: handleNoType(dynamic)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(dynamic)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(dynamic)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(dynamic, DeclarationKind.Class, dynamic)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrType(CLOSE_CURLY_BRACKET, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(})
  parseTopLevelDeclarationImpl(}, DirectiveContext(DirectiveState.Declarations))
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(class, }, class, null, null, null, null, DirectiveContext(DirectiveState.Declarations))
      parseClassOrNamedMixinApplication(class, null, null, null, null, null, null, null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          reportRecoverableErrorWithToken(else, Template(ExpectedIdentifierButGotKeyword))
            listener: handleRecoverableError(Message[Template(ExpectedIdentifierButGotKeyword), 'else' can't be used as an identifier because it's a keyword., Try renaming this to be an identifier that isn't a keyword., {lexeme: else}], else, else)
          listener: handleIdentifier(else, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, null, null, null, null, null, null, else)
        parseClass(else, class, class, null, else)
          parsePrimaryConstructorOpt(else, null, false)
            listener: handleNoPrimaryConstructor(else, null, false)
          parseClassHeaderOpt(else, class, class)
            parseClassExtendsOpt(else, DeclarationHeaderKind.Class)
              listener: handleNoType(else)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(else)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(else)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(else, DeclarationKind.Class, else)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrType(CLOSE_CURLY_BRACKET, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(})
  parseTopLevelDeclarationImpl(}, DirectiveContext(DirectiveState.Declarations))
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(class, }, class, null, null, null, null, DirectiveContext(DirectiveState.Declarations))
      parseClassOrNamedMixinApplication(class, null, null, null, null, null, null, null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          reportRecoverableErrorWithToken(enum, Template(ExpectedIdentifierButGotKeyword))
            listener: handleRecoverableError(Message[Template(ExpectedIdentifierButGotKeyword), 'enum' can't be used as an identifier because it's a keyword., Try renaming this to be an identifier that isn't a keyword., {lexeme: enum}], enum, enum)
          listener: handleIdentifier(enum, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, null, null, null, null, null, null, enum)
        parseClass(enum, class, class, null, enum)
          parsePrimaryConstructorOpt(enum, null, false)
            listener: handleNoPrimaryConstructor(enum, null, false)
          parseClassHeaderOpt(enum, class, class)
            parseClassExtendsOpt(enum, DeclarationHeaderKind.Class)
              listener: handleNoType(enum)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(enum)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(enum)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(enum, DeclarationKind.Class, enum)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrType(CLOSE_CURLY_BRACKET, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(})
  parseTopLevelDeclarationImpl(}, DirectiveContext(DirectiveState.Declarations))
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(class, }, class, null, null, null, null, DirectiveContext(DirectiveState.Declarations))
      parseClassOrNamedMixinApplication(class, null, null, null, null, null, null, null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          reportRecoverableErrorWithToken(export, Template(BuiltInIdentifierInDeclaration))
            listener: handleRecoverableError(Message[Template(BuiltInIdentifierInDeclaration), Can't use 'export' as a name here., null, {lexeme: export}], export, export)
          listener: handleIdentifier(export, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, null, null, null, null, null, null, export)
        parseClass(export, class, class, null, export)
          parsePrimaryConstructorOpt(export, null, false)
            listener: handleNoPrimaryConstructor(export, null, false)
          parseClassHeaderOpt(export, class, class)
            parseClassExtendsOpt(export, DeclarationHeaderKind.Class)
              listener: handleNoType(export)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(export)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(export)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(export, DeclarationKind.Class, export)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrType(CLOSE_CURLY_BRACKET, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(})
  parseTopLevelDeclarationImpl(}, DirectiveContext(DirectiveState.Declarations))
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(class, }, class, null, null, null, null, DirectiveContext(DirectiveState.Declarations))
      parseClassOrNamedMixinApplication(class, null, null, null, null, null, null, null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          reportRecoverableErrorWithToken(extends, Template(ExpectedIdentifierButGotKeyword))
            listener: handleRecoverableError(Message[Template(ExpectedIdentifierButGotKeyword), 'extends' can't be used as an identifier because it's a keyword., Try renaming this to be an identifier that isn't a keyword., {lexeme: extends}], extends, extends)
          listener: handleIdentifier(extends, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, null, null, null, null, null, null, extends)
        parseClass(extends, class, class, null, extends)
          parsePrimaryConstructorOpt(extends, null, false)
            listener: handleNoPrimaryConstructor(extends, null, false)
          parseClassHeaderOpt(extends, class, class)
            parseClassExtendsOpt(extends, DeclarationHeaderKind.Class)
              listener: handleNoType(extends)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(extends)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(extends)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(extends, DeclarationKind.Class, extends)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrType(CLOSE_CURLY_BRACKET, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(})
  parseTopLevelDeclarationImpl(}, DirectiveContext(DirectiveState.Declarations))
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(class, }, class, null, null, null, null, DirectiveContext(DirectiveState.Declarations))
      parseClassOrNamedMixinApplication(class, null, null, null, null, null, null, null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          reportRecoverableErrorWithToken(extension, Template(BuiltInIdentifierInDeclaration))
            listener: handleRecoverableError(Message[Template(BuiltInIdentifierInDeclaration), Can't use 'extension' as a name here., null, {lexeme: extension}], extension, extension)
          listener: handleIdentifier(extension, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, null, null, null, null, null, null, extension)
        parseClass(extension, class, class, null, extension)
          parsePrimaryConstructorOpt(extension, null, false)
            listener: handleNoPrimaryConstructor(extension, null, false)
          parseClassHeaderOpt(extension, class, class)
            parseClassExtendsOpt(extension, DeclarationHeaderKind.Class)
              listener: handleNoType(extension)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(extension)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(extension)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(extension, DeclarationKind.Class, extension)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrType(CLOSE_CURLY_BRACKET, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(})
  parseTopLevelDeclarationImpl(}, DirectiveContext(DirectiveState.Declarations))
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(class, }, class, null, null, null, null, DirectiveContext(DirectiveState.Declarations))
      parseClassOrNamedMixinApplication(class, null, null, null, null, null, null, null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          reportRecoverableErrorWithToken(external, Template(BuiltInIdentifierInDeclaration))
            listener: handleRecoverableError(Message[Template(BuiltInIdentifierInDeclaration), Can't use 'external' as a name here., null, {lexeme: external}], external, external)
          listener: handleIdentifier(external, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, null, null, null, null, null, null, external)
        parseClass(external, class, class, null, external)
          parsePrimaryConstructorOpt(external, null, false)
            listener: handleNoPrimaryConstructor(external, null, false)
          parseClassHeaderOpt(external, class, class)
            parseClassExtendsOpt(external, DeclarationHeaderKind.Class)
              listener: handleNoType(external)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(external)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(external)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(external, DeclarationKind.Class, external)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrType(CLOSE_CURLY_BRACKET, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(})
  parseTopLevelDeclarationImpl(}, DirectiveContext(DirectiveState.Declarations))
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(class, }, class, null, null, null, null, DirectiveContext(DirectiveState.Declarations))
      parseClassOrNamedMixinApplication(class, null, null, null, null, null, null, null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          reportRecoverableErrorWithToken(factory, Template(BuiltInIdentifierInDeclaration))
            listener: handleRecoverableError(Message[Template(BuiltInIdentifierInDeclaration), Can't use 'factory' as a name here., null, {lexeme: factory}], factory, factory)
          listener: handleIdentifier(factory, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, null, null, null, null, null, null, factory)
        parseClass(factory, class, class, null, factory)
          parsePrimaryConstructorOpt(factory, null, false)
            listener: handleNoPrimaryConstructor(factory, null, false)
          parseClassHeaderOpt(factory, class, class)
            parseClassExtendsOpt(factory, DeclarationHeaderKind.Class)
              listener: handleNoType(factory)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(factory)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(factory)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(factory, DeclarationKind.Class, factory)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrType(CLOSE_CURLY_BRACKET, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(})
  parseTopLevelDeclarationImpl(}, DirectiveContext(DirectiveState.Declarations))
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(class, }, class, null, null, null, null, DirectiveContext(DirectiveState.Declarations))
      parseClassOrNamedMixinApplication(class, null, null, null, null, null, null, null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          reportRecoverableErrorWithToken(false, Template(ExpectedIdentifierButGotKeyword))
            listener: handleRecoverableError(Message[Template(ExpectedIdentifierButGotKeyword), 'false' can't be used as an identifier because it's a keyword., Try renaming this to be an identifier that isn't a keyword., {lexeme: false}], false, false)
          listener: handleIdentifier(false, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, null, null, null, null, null, null, false)
        parseClass(false, class, class, null, false)
          parsePrimaryConstructorOpt(false, null, false)
            listener: handleNoPrimaryConstructor(false, null, false)
          parseClassHeaderOpt(false, class, class)
            parseClassExtendsOpt(false, DeclarationHeaderKind.Class)
              listener: handleNoType(false)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(false)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(false)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(false, DeclarationKind.Class, false)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrType(CLOSE_CURLY_BRACKET, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(})
  parseTopLevelDeclarationImpl(}, DirectiveContext(DirectiveState.Declarations))
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(class, }, class, null, null, null, null, DirectiveContext(DirectiveState.Declarations))
      parseClassOrNamedMixinApplication(class, null, null, null, null, null, null, null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          reportRecoverableErrorWithToken(final, Template(ExpectedIdentifierButGotKeyword))
            listener: handleRecoverableError(Message[Template(ExpectedIdentifierButGotKeyword), 'final' can't be used as an identifier because it's a keyword., Try renaming this to be an identifier that isn't a keyword., {lexeme: final}], final, final)
          listener: handleIdentifier(final, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, null, null, null, null, null, null, final)
        parseClass(final, class, class, null, final)
          parsePrimaryConstructorOpt(final, null, false)
            listener: handleNoPrimaryConstructor(final, null, false)
          parseClassHeaderOpt(final, class, class)
            parseClassExtendsOpt(final, DeclarationHeaderKind.Class)
              listener: handleNoType(final)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(final)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(final)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(final, DeclarationKind.Class, final)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrType(CLOSE_CURLY_BRACKET, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(})
  parseTopLevelDeclarationImpl(}, DirectiveContext(DirectiveState.Declarations))
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(class, }, class, null, null, null, null, DirectiveContext(DirectiveState.Declarations))
      parseClassOrNamedMixinApplication(class, null, null, null, null, null, null, null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          reportRecoverableErrorWithToken(finally, Template(ExpectedIdentifierButGotKeyword))
            listener: handleRecoverableError(Message[Template(ExpectedIdentifierButGotKeyword), 'finally' can't be used as an identifier because it's a keyword., Try renaming this to be an identifier that isn't a keyword., {lexeme: finally}], finally, finally)
          listener: handleIdentifier(finally, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, null, null, null, null, null, null, finally)
        parseClass(finally, class, class, null, finally)
          parsePrimaryConstructorOpt(finally, null, false)
            listener: handleNoPrimaryConstructor(finally, null, false)
          parseClassHeaderOpt(finally, class, class)
            parseClassExtendsOpt(finally, DeclarationHeaderKind.Class)
              listener: handleNoType(finally)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(finally)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(finally)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(finally, DeclarationKind.Class, finally)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrType(CLOSE_CURLY_BRACKET, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(})
  parseTopLevelDeclarationImpl(}, DirectiveContext(DirectiveState.Declarations))
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(class, }, class, null, null, null, null, DirectiveContext(DirectiveState.Declarations))
      parseClassOrNamedMixinApplication(class, null, null, null, null, null, null, null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          reportRecoverableErrorWithToken(for, Template(ExpectedIdentifierButGotKeyword))
            listener: handleRecoverableError(Message[Template(ExpectedIdentifierButGotKeyword), 'for' can't be used as an identifier because it's a keyword., Try renaming this to be an identifier that isn't a keyword., {lexeme: for}], for, for)
          listener: handleIdentifier(for, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, null, null, null, null, null, null, for)
        parseClass(for, class, class, null, for)
          parsePrimaryConstructorOpt(for, null, false)
            listener: handleNoPrimaryConstructor(for, null, false)
          parseClassHeaderOpt(for, class, class)
            parseClassExtendsOpt(for, DeclarationHeaderKind.Class)
              listener: handleNoType(for)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(for)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(for)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(for, DeclarationKind.Class, for)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrType(CLOSE_CURLY_BRACKET, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(})
  parseTopLevelDeclarationImpl(}, DirectiveContext(DirectiveState.Declarations))
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(class, }, class, null, null, null, null, DirectiveContext(DirectiveState.Declarations))
      parseClassOrNamedMixinApplication(class, null, null, null, null, null, null, null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          reportRecoverableErrorWithToken(Function, Template(BuiltInIdentifierInDeclaration))
            listener: handleRecoverableError(Message[Template(BuiltInIdentifierInDeclaration), Can't use 'Function' as a name here., null, {lexeme: Function}], Function, Function)
          listener: handleIdentifier(Function, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, null, null, null, null, null, null, Function)
        parseClass(Function, class, class, null, Function)
          parsePrimaryConstructorOpt(Function, null, false)
            listener: handleNoPrimaryConstructor(Function, null, false)
          parseClassHeaderOpt(Function, class, class)
            parseClassExtendsOpt(Function, DeclarationHeaderKind.Class)
              listener: handleNoType(Function)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(Function)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(Function)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(Function, DeclarationKind.Class, Function)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrType(CLOSE_CURLY_BRACKET, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(})
  parseTopLevelDeclarationImpl(}, DirectiveContext(DirectiveState.Declarations))
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(class, }, class, null, null, null, null, DirectiveContext(DirectiveState.Declarations))
      parseClassOrNamedMixinApplication(class, null, null, null, null, null, null, null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          reportRecoverableErrorWithToken(get, Template(BuiltInIdentifierInDeclaration))
            listener: handleRecoverableError(Message[Template(BuiltInIdentifierInDeclaration), Can't use 'get' as a name here., null, {lexeme: get}], get, get)
          listener: handleIdentifier(get, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, null, null, null, null, null, null, get)
        parseClass(get, class, class, null, get)
          parsePrimaryConstructorOpt(get, null, false)
            listener: handleNoPrimaryConstructor(get, null, false)
          parseClassHeaderOpt(get, class, class)
            parseClassExtendsOpt(get, DeclarationHeaderKind.Class)
              listener: handleNoType(get)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(get)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(get)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(get, DeclarationKind.Class, get)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrType(CLOSE_CURLY_BRACKET, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(})
  parseTopLevelDeclarationImpl(}, DirectiveContext(DirectiveState.Declarations))
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(class, }, class, null, null, null, null, DirectiveContext(DirectiveState.Declarations))
      parseClassOrNamedMixinApplication(class, null, null, null, null, null, null, null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          listener: handleIdentifier(hide, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, null, null, null, null, null, null, hide)
        parseClass(hide, class, class, null, hide)
          parsePrimaryConstructorOpt(hide, null, false)
            listener: handleNoPrimaryConstructor(hide, null, false)
          parseClassHeaderOpt(hide, class, class)
            parseClassExtendsOpt(hide, DeclarationHeaderKind.Class)
              listener: handleNoType(hide)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(hide)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(hide)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(hide, DeclarationKind.Class, hide)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrType(CLOSE_CURLY_BRACKET, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(})
  parseTopLevelDeclarationImpl(}, DirectiveContext(DirectiveState.Declarations))
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(class, }, class, null, null, null, null, DirectiveContext(DirectiveState.Declarations))
      parseClassOrNamedMixinApplication(class, null, null, null, null, null, null, null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          reportRecoverableErrorWithToken(if, Template(ExpectedIdentifierButGotKeyword))
            listener: handleRecoverableError(Message[Template(ExpectedIdentifierButGotKeyword), 'if' can't be used as an identifier because it's a keyword., Try renaming this to be an identifier that isn't a keyword., {lexeme: if}], if, if)
          listener: handleIdentifier(if, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, null, null, null, null, null, null, if)
        parseClass(if, class, class, null, if)
          parsePrimaryConstructorOpt(if, null, false)
            listener: handleNoPrimaryConstructor(if, null, false)
          parseClassHeaderOpt(if, class, class)
            parseClassExtendsOpt(if, DeclarationHeaderKind.Class)
              listener: handleNoType(if)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(if)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(if)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(if, DeclarationKind.Class, if)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrType(CLOSE_CURLY_BRACKET, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(})
  parseTopLevelDeclarationImpl(}, DirectiveContext(DirectiveState.Declarations))
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(class, }, class, null, null, null, null, DirectiveContext(DirectiveState.Declarations))
      parseClassOrNamedMixinApplication(class, null, null, null, null, null, null, null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          reportRecoverableErrorWithToken(implements, Template(BuiltInIdentifierInDeclaration))
            listener: handleRecoverableError(Message[Template(BuiltInIdentifierInDeclaration), Can't use 'implements' as a name here., null, {lexeme: implements}], implements, implements)
          listener: handleIdentifier(implements, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, null, null, null, null, null, null, implements)
        parseClass(implements, class, class, null, implements)
          parsePrimaryConstructorOpt(implements, null, false)
            listener: handleNoPrimaryConstructor(implements, null, false)
          parseClassHeaderOpt(implements, class, class)
            parseClassExtendsOpt(implements, DeclarationHeaderKind.Class)
              listener: handleNoType(implements)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(implements)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(implements)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(implements, DeclarationKind.Class, implements)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrType(CLOSE_CURLY_BRACKET, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(})
  parseTopLevelDeclarationImpl(}, DirectiveContext(DirectiveState.Declarations))
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(class, }, class, null, null, null, null, DirectiveContext(DirectiveState.Declarations))
      parseClassOrNamedMixinApplication(class, null, null, null, null, null, null, null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          reportRecoverableErrorWithToken(import, Template(BuiltInIdentifierInDeclaration))
            listener: handleRecoverableError(Message[Template(BuiltInIdentifierInDeclaration), Can't use 'import' as a name here., null, {lexeme: import}], import, import)
          listener: handleIdentifier(import, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, null, null, null, null, null, null, import)
        parseClass(import, class, class, null, import)
          parsePrimaryConstructorOpt(import, null, false)
            listener: handleNoPrimaryConstructor(import, null, false)
          parseClassHeaderOpt(import, class, class)
            parseClassExtendsOpt(import, DeclarationHeaderKind.Class)
              listener: handleNoType(import)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(import)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(import)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(import, DeclarationKind.Class, import)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrType(CLOSE_CURLY_BRACKET, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(})
  parseTopLevelDeclarationImpl(}, DirectiveContext(DirectiveState.Declarations))
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(class, }, class, null, null, null, null, DirectiveContext(DirectiveState.Declarations))
      parseClassOrNamedMixinApplication(class, null, null, null, null, null, null, null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          reportRecoverableErrorWithToken(in, Template(ExpectedIdentifierButGotKeyword))
            listener: handleRecoverableError(Message[Template(ExpectedIdentifierButGotKeyword), 'in' can't be used as an identifier because it's a keyword., Try renaming this to be an identifier that isn't a keyword., {lexeme: in}], in, in)
          listener: handleIdentifier(in, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, null, null, null, null, null, null, in)
        parseClass(in, class, class, null, in)
          parsePrimaryConstructorOpt(in, null, false)
            listener: handleNoPrimaryConstructor(in, null, false)
          parseClassHeaderOpt(in, class, class)
            parseClassExtendsOpt(in, DeclarationHeaderKind.Class)
              listener: handleNoType(in)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(in)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(in)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(in, DeclarationKind.Class, in)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrType(CLOSE_CURLY_BRACKET, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(})
  parseTopLevelDeclarationImpl(}, DirectiveContext(DirectiveState.Declarations))
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(class, }, class, null, null, null, null, DirectiveContext(DirectiveState.Declarations))
      parseClassOrNamedMixinApplication(class, null, null, null, null, null, null, null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          listener: handleIdentifier(inout, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, null, null, null, null, null, null, inout)
        parseClass(inout, class, class, null, inout)
          parsePrimaryConstructorOpt(inout, null, false)
            listener: handleNoPrimaryConstructor(inout, null, false)
          parseClassHeaderOpt(inout, class, class)
            parseClassExtendsOpt(inout, DeclarationHeaderKind.Class)
              listener: handleNoType(inout)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(inout)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(inout)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(inout, DeclarationKind.Class, inout)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrType(CLOSE_CURLY_BRACKET, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(})
  parseTopLevelDeclarationImpl(}, DirectiveContext(DirectiveState.Declarations))
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(class, }, class, null, null, null, null, DirectiveContext(DirectiveState.Declarations))
      parseClassOrNamedMixinApplication(class, null, null, null, null, null, null, null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          reportRecoverableErrorWithToken(interface, Template(BuiltInIdentifierInDeclaration))
            listener: handleRecoverableError(Message[Template(BuiltInIdentifierInDeclaration), Can't use 'interface' as a name here., null, {lexeme: interface}], interface, interface)
          listener: handleIdentifier(interface, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, null, null, null, null, null, null, interface)
        parseClass(interface, class, class, null, interface)
          parsePrimaryConstructorOpt(interface, null, false)
            listener: handleNoPrimaryConstructor(interface, null, false)
          parseClassHeaderOpt(interface, class, class)
            parseClassExtendsOpt(interface, DeclarationHeaderKind.Class)
              listener: handleNoType(interface)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(interface)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(interface)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(interface, DeclarationKind.Class, interface)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrType(CLOSE_CURLY_BRACKET, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(})
  parseTopLevelDeclarationImpl(}, DirectiveContext(DirectiveState.Declarations))
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(class, }, class, null, null, null, null, DirectiveContext(DirectiveState.Declarations))
      parseClassOrNamedMixinApplication(class, null, null, null, null, null, null, null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          reportRecoverableErrorWithToken(is, Template(ExpectedIdentifierButGotKeyword))
            listener: handleRecoverableError(Message[Template(ExpectedIdentifierButGotKeyword), 'is' can't be used as an identifier because it's a keyword., Try renaming this to be an identifier that isn't a keyword., {lexeme: is}], is, is)
          listener: handleIdentifier(is, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, null, null, null, null, null, null, is)
        parseClass(is, class, class, null, is)
          parsePrimaryConstructorOpt(is, null, false)
            listener: handleNoPrimaryConstructor(is, null, false)
          parseClassHeaderOpt(is, class, class)
            parseClassExtendsOpt(is, DeclarationHeaderKind.Class)
              listener: handleNoType(is)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(is)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(is)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(is, DeclarationKind.Class, is)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrType(CLOSE_CURLY_BRACKET, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(})
  parseTopLevelDeclarationImpl(}, DirectiveContext(DirectiveState.Declarations))
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(class, }, class, null, null, null, null, DirectiveContext(DirectiveState.Declarations))
      parseClassOrNamedMixinApplication(class, null, null, null, null, null, null, null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          reportRecoverableErrorWithToken(late, Template(BuiltInIdentifierInDeclaration))
            listener: handleRecoverableError(Message[Template(BuiltInIdentifierInDeclaration), Can't use 'late' as a name here., null, {lexeme: late}], late, late)
          listener: handleIdentifier(late, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, null, null, null, null, null, null, late)
        parseClass(late, class, class, null, late)
          parsePrimaryConstructorOpt(late, null, false)
            listener: handleNoPrimaryConstructor(late, null, false)
          parseClassHeaderOpt(late, class, class)
            parseClassExtendsOpt(late, DeclarationHeaderKind.Class)
              listener: handleNoType(late)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(late)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(late)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(late, DeclarationKind.Class, late)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrType(CLOSE_CURLY_BRACKET, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(})
  parseTopLevelDeclarationImpl(}, DirectiveContext(DirectiveState.Declarations))
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(class, }, class, null, null, null, null, DirectiveContext(DirectiveState.Declarations))
      parseClassOrNamedMixinApplication(class, null, null, null, null, null, null, null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          reportRecoverableErrorWithToken(library, Template(BuiltInIdentifierInDeclaration))
            listener: handleRecoverableError(Message[Template(BuiltInIdentifierInDeclaration), Can't use 'library' as a name here., null, {lexeme: library}], library, library)
          listener: handleIdentifier(library, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, null, null, null, null, null, null, library)
        parseClass(library, class, class, null, library)
          parsePrimaryConstructorOpt(library, null, false)
            listener: handleNoPrimaryConstructor(library, null, false)
          parseClassHeaderOpt(library, class, class)
            parseClassExtendsOpt(library, DeclarationHeaderKind.Class)
              listener: handleNoType(library)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(library)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(library)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(library, DeclarationKind.Class, library)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrType(CLOSE_CURLY_BRACKET, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(})
  parseTopLevelDeclarationImpl(}, DirectiveContext(DirectiveState.Declarations))
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(class, }, class, null, null, null, null, DirectiveContext(DirectiveState.Declarations))
      parseClassOrNamedMixinApplication(class, null, null, null, null, null, null, null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          reportRecoverableErrorWithToken(mixin, Template(BuiltInIdentifierInDeclaration))
            listener: handleRecoverableError(Message[Template(BuiltInIdentifierInDeclaration), Can't use 'mixin' as a name here., null, {lexeme: mixin}], mixin, mixin)
          listener: handleIdentifier(mixin, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, null, null, null, null, null, null, mixin)
        parseClass(mixin, class, class, null, mixin)
          parsePrimaryConstructorOpt(mixin, null, false)
            listener: handleNoPrimaryConstructor(mixin, null, false)
          parseClassHeaderOpt(mixin, class, class)
            parseClassExtendsOpt(mixin, DeclarationHeaderKind.Class)
              listener: handleNoType(mixin)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(mixin)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(mixin)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(mixin, DeclarationKind.Class, mixin)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrType(CLOSE_CURLY_BRACKET, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(})
  parseTopLevelDeclarationImpl(}, DirectiveContext(DirectiveState.Declarations))
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(class, }, class, null, null, null, null, DirectiveContext(DirectiveState.Declarations))
      parseClassOrNamedMixinApplication(class, null, null, null, null, null, null, null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          listener: handleIdentifier(native, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, null, null, null, null, null, null, native)
        parseClass(native, class, class, null, native)
          parsePrimaryConstructorOpt(native, null, false)
            listener: handleNoPrimaryConstructor(native, null, false)
          parseClassHeaderOpt(native, class, class)
            parseClassExtendsOpt(native, DeclarationHeaderKind.Class)
              listener: handleNoType(native)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(native)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(native)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(native, DeclarationKind.Class, native)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrType(CLOSE_CURLY_BRACKET, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(})
  parseTopLevelDeclarationImpl(}, DirectiveContext(DirectiveState.Declarations))
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(class, }, class, null, null, null, null, DirectiveContext(DirectiveState.Declarations))
      parseClassOrNamedMixinApplication(class, null, null, null, null, null, null, null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          reportRecoverableErrorWithToken(new, Template(ExpectedIdentifierButGotKeyword))
            listener: handleRecoverableError(Message[Template(ExpectedIdentifierButGotKeyword), 'new' can't be used as an identifier because it's a keyword., Try renaming this to be an identifier that isn't a keyword., {lexeme: new}], new, new)
          listener: handleIdentifier(new, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, null, null, null, null, null, null, new)
        parseClass(new, class, class, null, new)
          parsePrimaryConstructorOpt(new, null, false)
            listener: handleNoPrimaryConstructor(new, null, false)
          parseClassHeaderOpt(new, class, class)
            parseClassExtendsOpt(new, DeclarationHeaderKind.Class)
              listener: handleNoType(new)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(new)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(new)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(new, DeclarationKind.Class, new)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrType(CLOSE_CURLY_BRACKET, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(})
  parseTopLevelDeclarationImpl(}, DirectiveContext(DirectiveState.Declarations))
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(class, }, class, null, null, null, null, DirectiveContext(DirectiveState.Declarations))
      parseClassOrNamedMixinApplication(class, null, null, null, null, null, null, null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          reportRecoverableErrorWithToken(null, Template(ExpectedIdentifierButGotKeyword))
            listener: handleRecoverableError(Message[Template(ExpectedIdentifierButGotKeyword), 'null' can't be used as an identifier because it's a keyword., Try renaming this to be an identifier that isn't a keyword., {lexeme: null}], null, null)
          listener: handleIdentifier(null, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, null, null, null, null, null, null, null)
        parseClass(null, class, class, null, null)
          parsePrimaryConstructorOpt(null, null, false)
            listener: handleNoPrimaryConstructor(null, null, false)
          parseClassHeaderOpt(null, class, class)
            parseClassExtendsOpt(null, DeclarationHeaderKind.Class)
              listener: handleNoType(null)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(null)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(null)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(null, DeclarationKind.Class, null)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrType(CLOSE_CURLY_BRACKET, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(})
  parseTopLevelDeclarationImpl(}, DirectiveContext(DirectiveState.Declarations))
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(class, }, class, null, null, null, null, DirectiveContext(DirectiveState.Declarations))
      parseClassOrNamedMixinApplication(class, null, null, null, null, null, null, null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          listener: handleIdentifier(of, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, null, null, null, null, null, null, of)
        parseClass(of, class, class, null, of)
          parsePrimaryConstructorOpt(of, null, false)
            listener: handleNoPrimaryConstructor(of, null, false)
          parseClassHeaderOpt(of, class, class)
            parseClassExtendsOpt(of, DeclarationHeaderKind.Class)
              listener: handleNoType(of)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(of)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(of)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(of, DeclarationKind.Class, of)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrType(CLOSE_CURLY_BRACKET, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(})
  parseTopLevelDeclarationImpl(}, DirectiveContext(DirectiveState.Declarations))
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(class, }, class, null, null, null, null, DirectiveContext(DirectiveState.Declarations))
      parseClassOrNamedMixinApplication(class, null, null, null, null, null, null, null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          listener: handleIdentifier(on, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, null, null, null, null, null, null, on)
        parseClass(on, class, class, null, on)
          parsePrimaryConstructorOpt(on, null, false)
            listener: handleNoPrimaryConstructor(on, null, false)
          parseClassHeaderOpt(on, class, class)
            parseClassExtendsOpt(on, DeclarationHeaderKind.Class)
              listener: handleNoType(on)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(on)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(on)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(on, DeclarationKind.Class, on)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrType(CLOSE_CURLY_BRACKET, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(})
  parseTopLevelDeclarationImpl(}, DirectiveContext(DirectiveState.Declarations))
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(class, }, class, null, null, null, null, DirectiveContext(DirectiveState.Declarations))
      parseClassOrNamedMixinApplication(class, null, null, null, null, null, null, null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          reportRecoverableErrorWithToken(operator, Template(BuiltInIdentifierInDeclaration))
            listener: handleRecoverableError(Message[Template(BuiltInIdentifierInDeclaration), Can't use 'operator' as a name here., null, {lexeme: operator}], operator, operator)
          listener: handleIdentifier(operator, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, null, null, null, null, null, null, operator)
        parseClass(operator, class, class, null, operator)
          parsePrimaryConstructorOpt(operator, null, false)
            listener: handleNoPrimaryConstructor(operator, null, false)
          parseClassHeaderOpt(operator, class, class)
            parseClassExtendsOpt(operator, DeclarationHeaderKind.Class)
              listener: handleNoType(operator)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(operator)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(operator)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(operator, DeclarationKind.Class, operator)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrType(CLOSE_CURLY_BRACKET, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(})
  parseTopLevelDeclarationImpl(}, DirectiveContext(DirectiveState.Declarations))
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(class, }, class, null, null, null, null, DirectiveContext(DirectiveState.Declarations))
      parseClassOrNamedMixinApplication(class, null, null, null, null, null, null, null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          listener: handleIdentifier(out, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, null, null, null, null, null, null, out)
        parseClass(out, class, class, null, out)
          parsePrimaryConstructorOpt(out, null, false)
            listener: handleNoPrimaryConstructor(out, null, false)
          parseClassHeaderOpt(out, class, class)
            parseClassExtendsOpt(out, DeclarationHeaderKind.Class)
              listener: handleNoType(out)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(out)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(out)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(out, DeclarationKind.Class, out)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrType(CLOSE_CURLY_BRACKET, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(})
  parseTopLevelDeclarationImpl(}, DirectiveContext(DirectiveState.Declarations))
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(class, }, class, null, null, null, null, DirectiveContext(DirectiveState.Declarations))
      parseClassOrNamedMixinApplication(class, null, null, null, null, null, null, null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          reportRecoverableErrorWithToken(part, Template(BuiltInIdentifierInDeclaration))
            listener: handleRecoverableError(Message[Template(BuiltInIdentifierInDeclaration), Can't use 'part' as a name here., null, {lexeme: part}], part, part)
          listener: handleIdentifier(part, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, null, null, null, null, null, null, part)
        parseClass(part, class, class, null, part)
          parsePrimaryConstructorOpt(part, null, false)
            listener: handleNoPrimaryConstructor(part, null, false)
          parseClassHeaderOpt(part, class, class)
            parseClassExtendsOpt(part, DeclarationHeaderKind.Class)
              listener: handleNoType(part)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(part)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(part)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(part, DeclarationKind.Class, part)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrType(CLOSE_CURLY_BRACKET, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(})
  parseTopLevelDeclarationImpl(}, DirectiveContext(DirectiveState.Declarations))
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(class, }, class, null, null, null, null, DirectiveContext(DirectiveState.Declarations))
      parseClassOrNamedMixinApplication(class, null, null, null, null, null, null, null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          listener: handleIdentifier(patch, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, null, null, null, null, null, null, patch)
        parseClass(patch, class, class, null, patch)
          parsePrimaryConstructorOpt(patch, null, false)
            listener: handleNoPrimaryConstructor(patch, null, false)
          parseClassHeaderOpt(patch, class, class)
            parseClassExtendsOpt(patch, DeclarationHeaderKind.Class)
              listener: handleNoType(patch)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(patch)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(patch)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(patch, DeclarationKind.Class, patch)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrType(CLOSE_CURLY_BRACKET, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(})
  parseTopLevelDeclarationImpl(}, DirectiveContext(DirectiveState.Declarations))
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(class, }, class, null, null, null, null, DirectiveContext(DirectiveState.Declarations))
      parseClassOrNamedMixinApplication(class, null, null, null, null, null, null, null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          reportRecoverableErrorWithToken(required, Template(BuiltInIdentifierInDeclaration))
            listener: handleRecoverableError(Message[Template(BuiltInIdentifierInDeclaration), Can't use 'required' as a name here., null, {lexeme: required}], required, required)
          listener: handleIdentifier(required, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, null, null, null, null, null, null, required)
        parseClass(required, class, class, null, required)
          parsePrimaryConstructorOpt(required, null, false)
            listener: handleNoPrimaryConstructor(required, null, false)
          parseClassHeaderOpt(required, class, class)
            parseClassExtendsOpt(required, DeclarationHeaderKind.Class)
              listener: handleNoType(required)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(required)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(required)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(required, DeclarationKind.Class, required)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrType(CLOSE_CURLY_BRACKET, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(})
  parseTopLevelDeclarationImpl(}, DirectiveContext(DirectiveState.Declarations))
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(class, }, class, null, null, null, null, DirectiveContext(DirectiveState.Declarations))
      parseClassOrNamedMixinApplication(class, null, null, null, null, null, null, null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          reportRecoverableErrorWithToken(rethrow, Template(ExpectedIdentifierButGotKeyword))
            listener: handleRecoverableError(Message[Template(ExpectedIdentifierButGotKeyword), 'rethrow' can't be used as an identifier because it's a keyword., Try renaming this to be an identifier that isn't a keyword., {lexeme: rethrow}], rethrow, rethrow)
          listener: handleIdentifier(rethrow, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, null, null, null, null, null, null, rethrow)
        parseClass(rethrow, class, class, null, rethrow)
          parsePrimaryConstructorOpt(rethrow, null, false)
            listener: handleNoPrimaryConstructor(rethrow, null, false)
          parseClassHeaderOpt(rethrow, class, class)
            parseClassExtendsOpt(rethrow, DeclarationHeaderKind.Class)
              listener: handleNoType(rethrow)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(rethrow)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(rethrow)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(rethrow, DeclarationKind.Class, rethrow)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrType(CLOSE_CURLY_BRACKET, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(})
  parseTopLevelDeclarationImpl(}, DirectiveContext(DirectiveState.Declarations))
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(class, }, class, null, null, null, null, DirectiveContext(DirectiveState.Declarations))
      parseClassOrNamedMixinApplication(class, null, null, null, null, null, null, null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          reportRecoverableErrorWithToken(return, Template(ExpectedIdentifierButGotKeyword))
            listener: handleRecoverableError(Message[Template(ExpectedIdentifierButGotKeyword), 'return' can't be used as an identifier because it's a keyword., Try renaming this to be an identifier that isn't a keyword., {lexeme: return}], return, return)
          listener: handleIdentifier(return, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, null, null, null, null, null, null, return)
        parseClass(return, class, class, null, return)
          parsePrimaryConstructorOpt(return, null, false)
            listener: handleNoPrimaryConstructor(return, null, false)
          parseClassHeaderOpt(return, class, class)
            parseClassExtendsOpt(return, DeclarationHeaderKind.Class)
              listener: handleNoType(return)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(return)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(return)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(return, DeclarationKind.Class, return)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrType(CLOSE_CURLY_BRACKET, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(})
  parseTopLevelDeclarationImpl(}, DirectiveContext(DirectiveState.Declarations))
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(class, }, class, null, null, null, null, DirectiveContext(DirectiveState.Declarations))
      parseClassOrNamedMixinApplication(class, null, null, null, null, null, null, null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          reportRecoverableErrorWithToken(set, Template(BuiltInIdentifierInDeclaration))
            listener: handleRecoverableError(Message[Template(BuiltInIdentifierInDeclaration), Can't use 'set' as a name here., null, {lexeme: set}], set, set)
          listener: handleIdentifier(set, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, null, null, null, null, null, null, set)
        parseClass(set, class, class, null, set)
          parsePrimaryConstructorOpt(set, null, false)
            listener: handleNoPrimaryConstructor(set, null, false)
          parseClassHeaderOpt(set, class, class)
            parseClassExtendsOpt(set, DeclarationHeaderKind.Class)
              listener: handleNoType(set)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(set)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(set)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(set, DeclarationKind.Class, set)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrType(CLOSE_CURLY_BRACKET, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(})
  parseTopLevelDeclarationImpl(}, DirectiveContext(DirectiveState.Declarations))
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(class, }, class, null, null, null, null, DirectiveContext(DirectiveState.Declarations))
      parseClassOrNamedMixinApplication(class, null, null, null, null, null, null, null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          listener: handleIdentifier(show, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, null, null, null, null, null, null, show)
        parseClass(show, class, class, null, show)
          parsePrimaryConstructorOpt(show, null, false)
            listener: handleNoPrimaryConstructor(show, null, false)
          parseClassHeaderOpt(show, class, class)
            parseClassExtendsOpt(show, DeclarationHeaderKind.Class)
              listener: handleNoType(show)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(show)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(show)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(show, DeclarationKind.Class, show)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrType(CLOSE_CURLY_BRACKET, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(})
  parseTopLevelDeclarationImpl(}, DirectiveContext(DirectiveState.Declarations))
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(class, }, class, null, null, null, null, DirectiveContext(DirectiveState.Declarations))
      parseClassOrNamedMixinApplication(class, null, null, null, null, null, null, null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          listener: handleIdentifier(source, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, null, null, null, null, null, null, source)
        parseClass(source, class, class, null, source)
          parsePrimaryConstructorOpt(source, null, false)
            listener: handleNoPrimaryConstructor(source, null, false)
          parseClassHeaderOpt(source, class, class)
            parseClassExtendsOpt(source, DeclarationHeaderKind.Class)
              listener: handleNoType(source)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(source)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(source)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(source, DeclarationKind.Class, source)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrType(CLOSE_CURLY_BRACKET, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(})
  parseTopLevelDeclarationImpl(}, DirectiveContext(DirectiveState.Declarations))
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(class, }, class, null, null, null, null, DirectiveContext(DirectiveState.Declarations))
      parseClassOrNamedMixinApplication(class, null, null, null, null, null, null, null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          reportRecoverableErrorWithToken(static, Template(BuiltInIdentifierInDeclaration))
            listener: handleRecoverableError(Message[Template(BuiltInIdentifierInDeclaration), Can't use 'static' as a name here., null, {lexeme: static}], static, static)
          listener: handleIdentifier(static, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, null, null, null, null, null, null, static)
        parseClass(static, class, class, null, static)
          parsePrimaryConstructorOpt(static, null, false)
            listener: handleNoPrimaryConstructor(static, null, false)
          parseClassHeaderOpt(static, class, class)
            parseClassExtendsOpt(static, DeclarationHeaderKind.Class)
              listener: handleNoType(static)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(static)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(static)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(static, DeclarationKind.Class, static)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrType(CLOSE_CURLY_BRACKET, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(})
  parseTopLevelDeclarationImpl(}, DirectiveContext(DirectiveState.Declarations))
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(class, }, class, null, null, null, null, DirectiveContext(DirectiveState.Declarations))
      parseClassOrNamedMixinApplication(class, null, null, null, null, null, null, null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          reportRecoverableErrorWithToken(super, Template(ExpectedIdentifierButGotKeyword))
            listener: handleRecoverableError(Message[Template(ExpectedIdentifierButGotKeyword), 'super' can't be used as an identifier because it's a keyword., Try renaming this to be an identifier that isn't a keyword., {lexeme: super}], super, super)
          listener: handleIdentifier(super, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, null, null, null, null, null, null, super)
        parseClass(super, class, class, null, super)
          parsePrimaryConstructorOpt(super, null, false)
            listener: handleNoPrimaryConstructor(super, null, false)
          parseClassHeaderOpt(super, class, class)
            parseClassExtendsOpt(super, DeclarationHeaderKind.Class)
              listener: handleNoType(super)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(super)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(super)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(super, DeclarationKind.Class, super)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrType(CLOSE_CURLY_BRACKET, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(})
  parseTopLevelDeclarationImpl(}, DirectiveContext(DirectiveState.Declarations))
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(class, }, class, null, null, null, null, DirectiveContext(DirectiveState.Declarations))
      parseClassOrNamedMixinApplication(class, null, null, null, null, null, null, null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          reportRecoverableErrorWithToken(switch, Template(ExpectedIdentifierButGotKeyword))
            listener: handleRecoverableError(Message[Template(ExpectedIdentifierButGotKeyword), 'switch' can't be used as an identifier because it's a keyword., Try renaming this to be an identifier that isn't a keyword., {lexeme: switch}], switch, switch)
          listener: handleIdentifier(switch, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, null, null, null, null, null, null, switch)
        parseClass(switch, class, class, null, switch)
          parsePrimaryConstructorOpt(switch, null, false)
            listener: handleNoPrimaryConstructor(switch, null, false)
          parseClassHeaderOpt(switch, class, class)
            parseClassExtendsOpt(switch, DeclarationHeaderKind.Class)
              listener: handleNoType(switch)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(switch)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(switch)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(switch, DeclarationKind.Class, switch)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrType(CLOSE_CURLY_BRACKET, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(})
  parseTopLevelDeclarationImpl(}, DirectiveContext(DirectiveState.Declarations))
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(class, }, class, null, null, null, null, DirectiveContext(DirectiveState.Declarations))
      parseClassOrNamedMixinApplication(class, null, null, null, null, null, null, null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          listener: handleIdentifier(sync, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, null, null, null, null, null, null, sync)
        parseClass(sync, class, class, null, sync)
          parsePrimaryConstructorOpt(sync, null, false)
            listener: handleNoPrimaryConstructor(sync, null, false)
          parseClassHeaderOpt(sync, class, class)
            parseClassExtendsOpt(sync, DeclarationHeaderKind.Class)
              listener: handleNoType(sync)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(sync)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(sync)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(sync, DeclarationKind.Class, sync)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrType(CLOSE_CURLY_BRACKET, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(})
  parseTopLevelDeclarationImpl(}, DirectiveContext(DirectiveState.Declarations))
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(class, }, class, null, null, null, null, DirectiveContext(DirectiveState.Declarations))
      parseClassOrNamedMixinApplication(class, null, null, null, null, null, null, null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          reportRecoverableErrorWithToken(this, Template(ExpectedIdentifierButGotKeyword))
            listener: handleRecoverableError(Message[Template(ExpectedIdentifierButGotKeyword), 'this' can't be used as an identifier because it's a keyword., Try renaming this to be an identifier that isn't a keyword., {lexeme: this}], this, this)
          listener: handleIdentifier(this, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, null, null, null, null, null, null, this)
        parseClass(this, class, class, null, this)
          parsePrimaryConstructorOpt(this, null, false)
            listener: handleNoPrimaryConstructor(this, null, false)
          parseClassHeaderOpt(this, class, class)
            parseClassExtendsOpt(this, DeclarationHeaderKind.Class)
              listener: handleNoType(this)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(this)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(this)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(this, DeclarationKind.Class, this)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrType(CLOSE_CURLY_BRACKET, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(})
  parseTopLevelDeclarationImpl(}, DirectiveContext(DirectiveState.Declarations))
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(class, }, class, null, null, null, null, DirectiveContext(DirectiveState.Declarations))
      parseClassOrNamedMixinApplication(class, null, null, null, null, null, null, null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          reportRecoverableErrorWithToken(throw, Template(ExpectedIdentifierButGotKeyword))
            listener: handleRecoverableError(Message[Template(ExpectedIdentifierButGotKeyword), 'throw' can't be used as an identifier because it's a keyword., Try renaming this to be an identifier that isn't a keyword., {lexeme: throw}], throw, throw)
          listener: handleIdentifier(throw, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, null, null, null, null, null, null, throw)
        parseClass(throw, class, class, null, throw)
          parsePrimaryConstructorOpt(throw, null, false)
            listener: handleNoPrimaryConstructor(throw, null, false)
          parseClassHeaderOpt(throw, class, class)
            parseClassExtendsOpt(throw, DeclarationHeaderKind.Class)
              listener: handleNoType(throw)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(throw)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(throw)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(throw, DeclarationKind.Class, throw)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrType(CLOSE_CURLY_BRACKET, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(})
  parseTopLevelDeclarationImpl(}, DirectiveContext(DirectiveState.Declarations))
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(class, }, class, null, null, null, null, DirectiveContext(DirectiveState.Declarations))
      parseClassOrNamedMixinApplication(class, null, null, null, null, null, null, null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          reportRecoverableErrorWithToken(true, Template(ExpectedIdentifierButGotKeyword))
            listener: handleRecoverableError(Message[Template(ExpectedIdentifierButGotKeyword), 'true' can't be used as an identifier because it's a keyword., Try renaming this to be an identifier that isn't a keyword., {lexeme: true}], true, true)
          listener: handleIdentifier(true, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, null, null, null, null, null, null, true)
        parseClass(true, class, class, null, true)
          parsePrimaryConstructorOpt(true, null, false)
            listener: handleNoPrimaryConstructor(true, null, false)
          parseClassHeaderOpt(true, class, class)
            parseClassExtendsOpt(true, DeclarationHeaderKind.Class)
              listener: handleNoType(true)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(true)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(true)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(true, DeclarationKind.Class, true)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrType(CLOSE_CURLY_BRACKET, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(})
  parseTopLevelDeclarationImpl(}, DirectiveContext(DirectiveState.Declarations))
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(class, }, class, null, null, null, null, DirectiveContext(DirectiveState.Declarations))
      parseClassOrNamedMixinApplication(class, null, null, null, null, null, null, null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          reportRecoverableErrorWithToken(try, Template(ExpectedIdentifierButGotKeyword))
            listener: handleRecoverableError(Message[Template(ExpectedIdentifierButGotKeyword), 'try' can't be used as an identifier because it's a keyword., Try renaming this to be an identifier that isn't a keyword., {lexeme: try}], try, try)
          listener: handleIdentifier(try, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, null, null, null, null, null, null, try)
        parseClass(try, class, class, null, try)
          parsePrimaryConstructorOpt(try, null, false)
            listener: handleNoPrimaryConstructor(try, null, false)
          parseClassHeaderOpt(try, class, class)
            parseClassExtendsOpt(try, DeclarationHeaderKind.Class)
              listener: handleNoType(try)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(try)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(try)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(try, DeclarationKind.Class, try)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrType(CLOSE_CURLY_BRACKET, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(})
  parseTopLevelDeclarationImpl(}, DirectiveContext(DirectiveState.Declarations))
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(class, }, class, null, null, null, null, DirectiveContext(DirectiveState.Declarations))
      parseClassOrNamedMixinApplication(class, null, null, null, null, null, null, null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          reportRecoverableErrorWithToken(typedef, Template(BuiltInIdentifierInDeclaration))
            listener: handleRecoverableError(Message[Template(BuiltInIdentifierInDeclaration), Can't use 'typedef' as a name here., null, {lexeme: typedef}], typedef, typedef)
          listener: handleIdentifier(typedef, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, null, null, null, null, null, null, typedef)
        parseClass(typedef, class, class, null, typedef)
          parsePrimaryConstructorOpt(typedef, null, false)
            listener: handleNoPrimaryConstructor(typedef, null, false)
          parseClassHeaderOpt(typedef, class, class)
            parseClassExtendsOpt(typedef, DeclarationHeaderKind.Class)
              listener: handleNoType(typedef)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(typedef)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(typedef)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(typedef, DeclarationKind.Class, typedef)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrType(CLOSE_CURLY_BRACKET, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(})
  parseTopLevelDeclarationImpl(}, DirectiveContext(DirectiveState.Declarations))
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(class, }, class, null, null, null, null, DirectiveContext(DirectiveState.Declarations))
      parseClassOrNamedMixinApplication(class, null, null, null, null, null, null, null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          reportRecoverableErrorWithToken(var, Template(ExpectedIdentifierButGotKeyword))
            listener: handleRecoverableError(Message[Template(ExpectedIdentifierButGotKeyword), 'var' can't be used as an identifier because it's a keyword., Try renaming this to be an identifier that isn't a keyword., {lexeme: var}], var, var)
          listener: handleIdentifier(var, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, null, null, null, null, null, null, var)
        parseClass(var, class, class, null, var)
          parsePrimaryConstructorOpt(var, null, false)
            listener: handleNoPrimaryConstructor(var, null, false)
          parseClassHeaderOpt(var, class, class)
            parseClassExtendsOpt(var, DeclarationHeaderKind.Class)
              listener: handleNoType(var)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(var)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(var)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(var, DeclarationKind.Class, var)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrType(CLOSE_CURLY_BRACKET, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(})
  parseTopLevelDeclarationImpl(}, DirectiveContext(DirectiveState.Declarations))
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(class, }, class, null, null, null, null, DirectiveContext(DirectiveState.Declarations))
      parseClassOrNamedMixinApplication(class, null, null, null, null, null, null, null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          reportRecoverableErrorWithToken(void, Template(ExpectedIdentifierButGotKeyword))
            listener: handleRecoverableError(Message[Template(ExpectedIdentifierButGotKeyword), 'void' can't be used as an identifier because it's a keyword., Try renaming this to be an identifier that isn't a keyword., {lexeme: void}], void, void)
          listener: handleIdentifier(void, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, null, null, null, null, null, null, void)
        parseClass(void, class, class, null, void)
          parsePrimaryConstructorOpt(void, null, false)
            listener: handleNoPrimaryConstructor(void, null, false)
          parseClassHeaderOpt(void, class, class)
            parseClassExtendsOpt(void, DeclarationHeaderKind.Class)
              listener: handleNoType(void)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(void)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(void)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(void, DeclarationKind.Class, void)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrType(CLOSE_CURLY_BRACKET, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(})
  parseTopLevelDeclarationImpl(}, DirectiveContext(DirectiveState.Declarations))
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(class, }, class, null, null, null, null, DirectiveContext(DirectiveState.Declarations))
      parseClassOrNamedMixinApplication(class, null, null, null, null, null, null, null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          reportRecoverableErrorWithToken(while, Template(ExpectedIdentifierButGotKeyword))
            listener: handleRecoverableError(Message[Template(ExpectedIdentifierButGotKeyword), 'while' can't be used as an identifier because it's a keyword., Try renaming this to be an identifier that isn't a keyword., {lexeme: while}], while, while)
          listener: handleIdentifier(while, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, null, null, null, null, null, null, while)
        parseClass(while, class, class, null, while)
          parsePrimaryConstructorOpt(while, null, false)
            listener: handleNoPrimaryConstructor(while, null, false)
          parseClassHeaderOpt(while, class, class)
            parseClassExtendsOpt(while, DeclarationHeaderKind.Class)
              listener: handleNoType(while)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(while)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(while)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(while, DeclarationKind.Class, while)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrType(CLOSE_CURLY_BRACKET, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(})
  parseTopLevelDeclarationImpl(}, DirectiveContext(DirectiveState.Declarations))
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(class, }, class, null, null, null, null, DirectiveContext(DirectiveState.Declarations))
      parseClassOrNamedMixinApplication(class, null, null, null, null, null, null, null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          reportRecoverableErrorWithToken(with, Template(ExpectedIdentifierButGotKeyword))
            listener: handleRecoverableError(Message[Template(ExpectedIdentifierButGotKeyword), 'with' can't be used as an identifier because it's a keyword., Try renaming this to be an identifier that isn't a keyword., {lexeme: with}], with, with)
          listener: handleIdentifier(with, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, null, null, null, null, null, null, with)
        parseClass(with, class, class, null, with)
          parsePrimaryConstructorOpt(with, null, false)
            listener: handleNoPrimaryConstructor(with, null, false)
          parseClassHeaderOpt(with, class, class)
            parseClassExtendsOpt(with, DeclarationHeaderKind.Class)
              listener: handleNoType(with)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(with)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(with)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(with, DeclarationKind.Class, with)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrType(CLOSE_CURLY_BRACKET, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(})
  parseTopLevelDeclarationImpl(}, DirectiveContext(DirectiveState.Declarations))
    parseMetadataStar(})
      listener: beginMetadataStar(class)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(class, }, class, null, null, null, null, DirectiveContext(DirectiveState.Declarations))
      parseClassOrNamedMixinApplication(class, null, null, null, null, null, null, null, null, class)
        listener: beginClassOrMixinOrNamedMixinApplicationPrelude(class)
        ensureIdentifier(class, classOrMixinDeclaration)
          listener: handleIdentifier(yield, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(class, null, null, null, null, null, null, null, null, yield)
        parseClass(yield, class, class, null, yield)
          parsePrimaryConstructorOpt(yield, null, false)
            listener: handleNoPrimaryConstructor(yield, null, false)
          parseClassHeaderOpt(yield, class, class)
            parseClassExtendsOpt(yield, DeclarationHeaderKind.Class)
              listener: handleNoType(yield)
              listener: handleClassExtends(null, 1)
            parseClassWithClauseOpt(yield)
              listener: handleClassNoWithClause()
            parseClassOrMixinOrEnumImplementsOpt(yield)
              listener: handleImplements(null, 0)
            listener: handleClassHeader(class, class, null)
          parseClassOrMixinOrExtensionBody(yield, DeclarationKind.Class, yield)
            listener: beginClassOrMixinOrExtensionBody(DeclarationKind.Class, {)
            notEofOrType(CLOSE_CURLY_BRACKET, })
            listener: endClassOrMixinOrExtensionBody(DeclarationKind.Class, 0, {, })
          listener: endClassDeclaration(class, })
  listener: endTopLevelDeclaration(})
  reportAllErrorTokens(class)
  listener: endCompilationUnit(69, )
