parseUnit(abstract)
  skipErrorTokens(abstract)
  listener: beginCompilationUnit(abstract)
  syntheticPreviousToken(abstract)
  parseTopLevelDeclarationImpl(, Instance of 'DirectiveContext')
    parseMetadataStar()
      listener: beginMetadataStar(abstract)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(, class, Instance of 'DirectiveContext')
      parseClassDeclarationModifiers(, class)
        parseTopLevelKeywordModifiers(abstract, class)
      parseClassOrNamedMixinApplication(abstract, class)
        listener: beginClassOrNamedMixinApplicationPrelude(abstract)
        ensureIdentifier(class, classOrMixinDeclaration)
          listener: handleIdentifier(C, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(abstract, abstract, C)
        parseClass(C, abstract, class, C)
          parseClassHeaderOpt(C, abstract, class)
            parseClassExtendsOpt(C)
              listener: handleNoType(C)
              listener: handleClassExtends(null, 1)
            parseWithClauseOpt(C)
              listener: handleClassNoWithClause()
            parseClassOrMixinImplementsOpt(C)
              listener: handleClassOrMixinImplements(null, 0)
            listener: handleClassHeader(abstract, class, null)
          parseClassOrMixinOrExtensionBody(C, DeclarationKind.Class, C)
            listener: beginClassOrMixinBody(DeclarationKind.Class, {)
            notEofOrValue(}, final)
            parseClassOrMixinOrExtensionMemberImpl({, DeclarationKind.Class, C)
              parseMetadataStar({)
                listener: beginMetadataStar(final)
                listener: endMetadataStar(0)
              reportRecoverableError(abstract, Message[ModifierOutOfOrder, The modifier 'abstract' should be before the modifier 'final'., Try re-ordering the modifiers., {string: abstract, string2: final}])
                listener: handleRecoverableError(Message[ModifierOutOfOrder, The modifier 'abstract' should be before the modifier 'final'., Try re-ordering the modifiers., {string: abstract, string2: final}], abstract, abstract)
              listener: beginMember()
              parseFields({, abstract, null, null, null, null, final, abstract, Instance of 'SimpleType', i1, DeclarationKind.Class, C, false)
                listener: beginFields({)
                listener: handleIdentifier(int, typeReference)
                listener: handleNoTypeArguments(i1)
                listener: handleType(int, null)
                ensureIdentifierPotentiallyRecovered(int, fieldDeclaration, false)
                  listener: handleIdentifier(i1, fieldDeclaration)
                parseFieldInitializerOpt(i1, i1, null, abstract, null, final, DeclarationKind.Class, C)
                  listener: handleNoFieldInitializer(;)
                listener: endClassFields(abstract, null, null, null, null, final, 1, final, ;)
              listener: endMember()
            notEofOrValue(}, final)
            parseClassOrMixinOrExtensionMemberImpl(;, DeclarationKind.Class, C)
              parseMetadataStar(;)
                listener: beginMetadataStar(final)
                listener: endMetadataStar(0)
              reportRecoverableError(abstract, Message[ModifierOutOfOrder, The modifier 'abstract' should be before the modifier 'final'., Try re-ordering the modifiers., {string: abstract, string2: final}])
                listener: handleRecoverableError(Message[ModifierOutOfOrder, The modifier 'abstract' should be before the modifier 'final'., Try re-ordering the modifiers., {string: abstract, string2: final}], abstract, abstract)
              listener: beginMember()
              parseFields(;, abstract, null, null, null, null, final, abstract, Instance of 'NoType', i2, DeclarationKind.Class, C, false)
                listener: beginFields(;)
                listener: handleNoType(abstract)
                ensureIdentifierPotentiallyRecovered(abstract, fieldDeclaration, false)
                  listener: handleIdentifier(i2, fieldDeclaration)
                parseFieldInitializerOpt(i2, i2, null, abstract, null, final, DeclarationKind.Class, C)
                  listener: handleNoFieldInitializer(;)
                listener: endClassFields(abstract, null, null, null, null, final, 1, final, ;)
              listener: endMember()
            notEofOrValue(}, covariant)
            parseClassOrMixinOrExtensionMemberImpl(;, DeclarationKind.Class, C)
              parseMetadataStar(;)
                listener: beginMetadataStar(covariant)
                listener: endMetadataStar(0)
              reportRecoverableError(abstract, Message[ModifierOutOfOrder, The modifier 'abstract' should be before the modifier 'covariant'., Try re-ordering the modifiers., {string: abstract, string2: covariant}])
                listener: handleRecoverableError(Message[ModifierOutOfOrder, The modifier 'abstract' should be before the modifier 'covariant'., Try re-ordering the modifiers., {string: abstract, string2: covariant}], abstract, abstract)
              listener: beginMember()
              parseFields(;, abstract, null, null, covariant, null, null, abstract, Instance of 'SimpleType', i3, DeclarationKind.Class, C, false)
                listener: beginFields(;)
                listener: handleIdentifier(num, typeReference)
                listener: handleNoTypeArguments(i3)
                listener: handleType(num, null)
                ensureIdentifierPotentiallyRecovered(num, fieldDeclaration, false)
                  listener: handleIdentifier(i3, fieldDeclaration)
                parseFieldInitializerOpt(i3, i3, null, abstract, null, null, DeclarationKind.Class, C)
                  listener: handleNoFieldInitializer(;)
                listener: endClassFields(abstract, null, null, covariant, null, null, 1, covariant, ;)
              listener: endMember()
            notEofOrValue(}, covariant)
            parseClassOrMixinOrExtensionMemberImpl(;, DeclarationKind.Class, C)
              parseMetadataStar(;)
                listener: beginMetadataStar(covariant)
                listener: endMetadataStar(0)
              reportRecoverableError(abstract, Message[ModifierOutOfOrder, The modifier 'abstract' should be before the modifier 'covariant'., Try re-ordering the modifiers., {string: abstract, string2: covariant}])
                listener: handleRecoverableError(Message[ModifierOutOfOrder, The modifier 'abstract' should be before the modifier 'covariant'., Try re-ordering the modifiers., {string: abstract, string2: covariant}], abstract, abstract)
              listener: beginMember()
              parseFields(;, abstract, null, null, covariant, null, var, var, Instance of 'NoType', i4, DeclarationKind.Class, C, false)
                listener: beginFields(;)
                listener: handleNoType(var)
                ensureIdentifierPotentiallyRecovered(var, fieldDeclaration, false)
                  listener: handleIdentifier(i4, fieldDeclaration)
                parseFieldInitializerOpt(i4, i4, null, abstract, null, var, DeclarationKind.Class, C)
                  listener: handleNoFieldInitializer(;)
                listener: endClassFields(abstract, null, null, covariant, null, var, 1, covariant, ;)
              listener: endMember()
            notEofOrValue(}, final)
            parseClassOrMixinOrExtensionMemberImpl(;, DeclarationKind.Class, C)
              parseMetadataStar(;)
                listener: beginMetadataStar(final)
                listener: endMetadataStar(0)
              reportRecoverableError(abstract, Message[ModifierOutOfOrder, The modifier 'abstract' should be before the modifier 'final'., Try re-ordering the modifiers., {string: abstract, string2: final}])
                listener: handleRecoverableError(Message[ModifierOutOfOrder, The modifier 'abstract' should be before the modifier 'final'., Try re-ordering the modifiers., {string: abstract, string2: final}], abstract, abstract)
              listener: beginMember()
              parseFields(;, abstract, null, null, null, null, final, abstract, Instance of 'NoType', i5, DeclarationKind.Class, C, false)
                listener: beginFields(;)
                listener: handleNoType(abstract)
                ensureIdentifierPotentiallyRecovered(abstract, fieldDeclaration, false)
                  listener: handleIdentifier(i5, fieldDeclaration)
                parseFieldInitializerOpt(i5, i5, null, abstract, null, final, DeclarationKind.Class, C)
                  listener: handleNoFieldInitializer(;)
                listener: endClassFields(abstract, null, null, null, null, final, 1, final, ;)
              listener: endMember()
            notEofOrValue(}, var)
            parseClassOrMixinOrExtensionMemberImpl(;, DeclarationKind.Class, C)
              parseMetadataStar(;)
                listener: beginMetadataStar(var)
                listener: endMetadataStar(0)
              reportRecoverableError(abstract, Message[ModifierOutOfOrder, The modifier 'abstract' should be before the modifier 'var'., Try re-ordering the modifiers., {string: abstract, string2: var}])
                listener: handleRecoverableError(Message[ModifierOutOfOrder, The modifier 'abstract' should be before the modifier 'var'., Try re-ordering the modifiers., {string: abstract, string2: var}], abstract, abstract)
              listener: beginMember()
              parseFields(;, abstract, null, null, null, null, var, abstract, Instance of 'NoType', i6, DeclarationKind.Class, C, false)
                listener: beginFields(;)
                listener: handleNoType(abstract)
                ensureIdentifierPotentiallyRecovered(abstract, fieldDeclaration, false)
                  listener: handleIdentifier(i6, fieldDeclaration)
                parseFieldInitializerOpt(i6, i6, null, abstract, null, var, DeclarationKind.Class, C)
                  listener: handleNoFieldInitializer(;)
                listener: endClassFields(abstract, null, null, null, null, var, 1, var, ;)
              listener: endMember()
            notEofOrValue(}, C)
            parseClassOrMixinOrExtensionMemberImpl(;, DeclarationKind.Class, C)
              parseMetadataStar(;)
                listener: beginMetadataStar(C)
                listener: endMetadataStar(0)
              listener: beginMember()
              parseFields(;, null, null, null, null, null, null, ;, Instance of 'SimpleType', abstract, DeclarationKind.Class, C, false)
                listener: beginFields(;)
                listener: handleIdentifier(C, typeReference)
                listener: handleNoTypeArguments(abstract)
                listener: handleType(C, null)
                ensureIdentifierPotentiallyRecovered(C, fieldDeclaration, false)
                  listener: handleIdentifier(abstract, fieldDeclaration)
                parseFieldInitializerOpt(abstract, abstract, null, null, null, null, DeclarationKind.Class, C)
                  listener: handleNoFieldInitializer(i7)
                ensureSemicolon(abstract)
                  reportRecoverableError(abstract, Message[ExpectedAfterButGot, Expected ';' after this., null, {string: ;}])
                    listener: handleRecoverableError(Message[ExpectedAfterButGot, Expected ';' after this., null, {string: ;}], abstract, abstract)
                  rewriter()
                listener: endClassFields(null, null, null, null, null, null, 1, C, ;)
              listener: endMember()
            notEofOrValue(}, i7)
            parseClassOrMixinOrExtensionMemberImpl(;, DeclarationKind.Class, C)
              parseMetadataStar(;)
                listener: beginMetadataStar(i7)
                listener: endMetadataStar(0)
              listener: beginMember()
              isReservedKeyword(;)
              parseFields(;, null, null, null, null, null, null, ;, Instance of 'NoType', i7, DeclarationKind.Class, C, false)
                listener: beginFields(;)
                reportRecoverableError(i7, MissingConstFinalVarOrType)
                  listener: handleRecoverableError(MissingConstFinalVarOrType, i7, i7)
                listener: handleNoType(;)
                ensureIdentifierPotentiallyRecovered(;, fieldDeclaration, false)
                  listener: handleIdentifier(i7, fieldDeclaration)
                parseFieldInitializerOpt(i7, i7, null, null, null, null, DeclarationKind.Class, C)
                  listener: handleNoFieldInitializer(;)
                listener: endClassFields(null, null, null, null, null, null, 1, i7, ;)
              listener: endMember()
            notEofOrValue(}, })
            listener: endClassOrMixinBody(DeclarationKind.Class, 8, {, })
          listener: endClassDeclaration(abstract, })
  listener: endTopLevelDeclaration(var)
  parseTopLevelDeclarationImpl(}, Instance of 'DirectiveContext')
    parseMetadataStar(})
      listener: beginMetadataStar(var)
      listener: endMetadataStar(0)
    parseTopLevelMemberImpl(})
      listener: beginTopLevelMember(var)
      reportRecoverableError(abstract, Message[ModifierOutOfOrder, The modifier 'abstract' should be before the modifier 'var'., Try re-ordering the modifiers., {string: abstract, string2: var}])
        listener: handleRecoverableError(Message[ModifierOutOfOrder, The modifier 'abstract' should be before the modifier 'var'., Try re-ordering the modifiers., {string: abstract, string2: var}], abstract, abstract)
      reportRecoverableErrorWithToken(abstract, Instance of 'Template<(Token) => Message>')
        listener: handleRecoverableError(Message[ExtraneousModifier, Can't have modifier 'abstract' here., Try removing 'abstract'., {token: abstract}], abstract, abstract)
      parseFields(}, null, null, null, null, null, var, abstract, Instance of 'NoType', foo, DeclarationKind.TopLevel, null, false)
        listener: beginFields(})
        listener: handleNoType(abstract)
        ensureIdentifierPotentiallyRecovered(abstract, topLevelVariableDeclaration, false)
          listener: handleIdentifier(foo, topLevelVariableDeclaration)
        parseFieldInitializerOpt(foo, foo, null, null, null, var, DeclarationKind.TopLevel, null)
          listener: handleNoFieldInitializer(;)
        listener: endTopLevelFields(null, null, null, null, var, 1, var, ;)
  listener: endTopLevelDeclaration(abstract)
  parseTopLevelDeclarationImpl(;, Instance of 'DirectiveContext')
    parseMetadataStar(;)
      listener: beginMetadataStar(abstract)
      listener: endMetadataStar(0)
    parseTopLevelKeywordDeclaration(;, class, Instance of 'DirectiveContext')
      parseClassDeclarationModifiers(;, class)
        parseTopLevelKeywordModifiers(abstract, class)
      parseClassOrNamedMixinApplication(abstract, class)
        listener: beginClassOrNamedMixinApplicationPrelude(abstract)
        ensureIdentifier(class, classOrMixinDeclaration)
          listener: handleIdentifier(Bar, classOrMixinDeclaration)
        listener: handleNoTypeVariables({)
        listener: beginClassDeclaration(abstract, abstract, Bar)
        parseClass(Bar, abstract, class, Bar)
          parseClassHeaderOpt(Bar, abstract, class)
            parseClassExtendsOpt(Bar)
              listener: handleNoType(Bar)
              listener: handleClassExtends(null, 1)
            parseWithClauseOpt(Bar)
              listener: handleClassNoWithClause()
            parseClassOrMixinImplementsOpt(Bar)
              listener: handleClassOrMixinImplements(null, 0)
            listener: handleClassHeader(abstract, class, null)
          parseClassOrMixinOrExtensionBody(Bar, DeclarationKind.Class, Bar)
            listener: beginClassOrMixinBody(DeclarationKind.Class, {)
            notEofOrValue(}, covariant)
            parseClassOrMixinOrExtensionMemberImpl({, DeclarationKind.Class, Bar)
              parseMetadataStar({)
                listener: beginMetadataStar(covariant)
                listener: endMetadataStar(0)
              reportRecoverableError(required, Message[ModifierOutOfOrder, The modifier 'required' should be before the modifier 'covariant'., Try re-ordering the modifiers., {string: required, string2: covariant}])
                listener: handleRecoverableError(Message[ModifierOutOfOrder, The modifier 'required' should be before the modifier 'covariant'., Try re-ordering the modifiers., {string: required, string2: covariant}], required, required)
              reportRecoverableErrorWithToken(required, Instance of 'Template<(Token) => Message>')
                listener: handleRecoverableError(Message[ExtraneousModifier, Can't have modifier 'required' here., Try removing 'required'., {token: required}], required, required)
              listener: beginMember()
              isReservedKeyword(;)
              parseFields({, null, null, null, covariant, null, null, required, Instance of 'NoType', x, DeclarationKind.Class, Bar, false)
                listener: beginFields({)
                reportRecoverableError(x, MissingConstFinalVarOrType)
                  listener: handleRecoverableError(MissingConstFinalVarOrType, x, x)
                listener: handleNoType(required)
                ensureIdentifierPotentiallyRecovered(required, fieldDeclaration, false)
                  listener: handleIdentifier(x, fieldDeclaration)
                parseFieldInitializerOpt(x, x, null, null, null, null, DeclarationKind.Class, Bar)
                  listener: handleNoFieldInitializer(;)
                listener: endClassFields(null, null, null, covariant, null, null, 1, covariant, ;)
              listener: endMember()
            notEofOrValue(}, })
            listener: endClassOrMixinBody(DeclarationKind.Class, 1, {, })
          listener: endClassDeclaration(abstract, })
  listener: endTopLevelDeclaration()
  reportAllErrorTokens(abstract)
  listener: endCompilationUnit(3, )
