// Copyright (c) 2016, the Dart project authors. Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

import 'dart:async';

import 'package:analyzer/analysis_rule/rule_context.dart';
import 'package:analyzer/analysis_rule/rule_visitor_registry.dart';
import 'package:analyzer/dart/analysis/results.dart';
import 'package:analyzer/dart/ast/visitor.dart';
import 'package:analyzer/dart/element/element.dart';
import 'package:analyzer/diagnostic/diagnostic.dart';
import 'package:analyzer/error/error.dart';
import 'package:analyzer/file_system/file_system.dart';
import 'package:analyzer/src/dart/analysis/analysis_context_collection.dart';
import 'package:analyzer/src/dart/analysis/driver.dart';
import 'package:analyzer/src/dart/analysis/driver_event.dart' as driver_events;
import 'package:analyzer/src/dart/analysis/file_state.dart';
import 'package:analyzer/src/dart/analysis/status.dart';
import 'package:analyzer/src/dart/ast/ast.dart';
import 'package:analyzer/src/dart/element/element.dart';
import 'package:analyzer/src/error/codes.dart';
import 'package:analyzer/src/lint/linter.dart';
import 'package:analyzer/src/test_utilities/lint_registration_mixin.dart';
import 'package:analyzer/src/utilities/extensions/async.dart';
import 'package:analyzer/utilities/package_config_file_builder.dart';
import 'package:analyzer_testing/utilities/utilities.dart';
import 'package:analyzer_utilities/testing/tree_string_sink.dart';
import 'package:linter/src/rules.dart';
import 'package:test/test.dart';
import 'package:test_reflective_loader/test_reflective_loader.dart';

import '../../../util/diff.dart';
import '../../../util/element_printer.dart';
import '../resolution/context_collection_resolution.dart';
import '../resolution/node_text_expectations.dart';
import '../resolution/resolution.dart';
import 'result_printer.dart';

main() {
  defineReflectiveSuite(() {
    defineReflectiveTests(AnalysisDriver_PubPackageTest);
    defineReflectiveTests(AnalysisDriver_BlazeWorkspaceTest);
    defineReflectiveTests(AnalysisDriver_LintTest);
    defineReflectiveTests(FineAnalysisDriverTest);
    defineReflectiveTests(UpdateNodeTextExpectations);
  });
}

@reflectiveTest
class AnalysisDriver_BlazeWorkspaceTest extends BlazeWorkspaceResolutionTest {
  void test_nestedLib_notCanonicalUri() async {
    var outerLibPath = '$workspaceRootPath/my/outer/lib';

    var innerFile = newFile('$outerLibPath/inner/lib/b.dart', 'class B {}');
    var innerUri = Uri.parse('package:my.outer.lib.inner/b.dart');

    var analysisSession = contextFor(innerFile).currentSession;

    void assertInnerUri(ResolvedUnitResult result) {
      var innerSource = result.libraryFragment.libraryImports
          .map((import) => import.importedLibrary?.firstFragment.source)
          .nonNulls
          .where((importedSource) => importedSource.fullName == innerFile.path)
          .single;
      expect(innerSource.uri, innerUri);
    }

    // Reference "inner" using a non-canonical URI.
    {
      var a = newFile(convertPath('$outerLibPath/a.dart'), r'''
import 'inner/lib/b.dart';
''');
      var result = await analysisSession.getResolvedUnit(a.path);
      result as ResolvedUnitResult;
      assertInnerUri(result);
    }

    // Reference "inner" using the canonical URI, via relative.
    {
      var c = newFile('$outerLibPath/inner/lib/c.dart', r'''
import 'b.dart';
''');
      var result = await analysisSession.getResolvedUnit(c.path);
      result as ResolvedUnitResult;
      assertInnerUri(result);
    }

    // Reference "inner" using the canonical URI, via absolute.
    {
      var d = newFile('$outerLibPath/inner/lib/d.dart', '''
import '$innerUri';
''');
      var result = await analysisSession.getResolvedUnit(d.path);
      result as ResolvedUnitResult;
      assertInnerUri(result);
    }
  }
}

@reflectiveTest
class AnalysisDriver_LintTest extends PubPackageResolutionTest
    with LintRegistrationMixin {
  @override
  void setUp() {
    super.setUp();

    useEmptyByteStore();
    registerLintRule(_AlwaysReportedLint.instance);
    writeTestPackageAnalysisOptionsFile(
      analysisOptionsContent(rules: [_AlwaysReportedLint.code.name]),
    );
  }

  @override
  Future<void> tearDown() {
    unregisterLintRules();
    return super.tearDown();
  }

  test_getResolvedUnit_lint_existingFile() async {
    addTestFile('');
    await resolveTestFile();

    // Existing/empty file triggers the lint.
    _assertHasLintReported(result.diagnostics, _AlwaysReportedLint.code.name);
  }

  test_getResolvedUnit_lint_notExistingFile() async {
    await resolveTestFile();

    // No errors for a file that doesn't exist.
    assertErrorsInResult([]);
  }

  void _assertHasLintReported(List<Diagnostic> diagnostics, String name) {
    var matching = diagnostics.where((element) {
      var diagnosticCode = element.diagnosticCode;
      return diagnosticCode is LintCode && diagnosticCode.name == name;
    }).toList();
    expect(matching, hasLength(1));
  }
}

@reflectiveTest
class AnalysisDriver_PubPackageTest extends PubPackageResolutionTest
    with _EventsMixin {
  @override
  bool get retainDataForTesting => true;

  @override
  void setUp() {
    super.setUp();
    registerLintRules();
    useEmptyByteStore();
  }

  test_addedFiles() async {
    var a = newFile('$testPackageLibPath/a.dart', '');
    var b = newFile('$testPackageLibPath/b.dart', '');

    var driver = driverFor(testFile);

    driver.addFile2(a);
    driver.addFile2(b);
    await driver.applyPendingFileChanges();
    expect(driver.addedFiles2, unorderedEquals([a, b]));

    driver.removeFile2(a);
    await driver.applyPendingFileChanges();
    expect(driver.addedFiles2, unorderedEquals([b]));
  }

  test_addFile() async {
    var a = newFile('$testPackageLibPath/a.dart', '');
    var b = newFile('$testPackageLibPath/b.dart', '');

    var driver = driverFor(testFile);
    var collector = DriverEventCollector(driver);

    driver.addFile2(b);
    driver.addFile2(a);

    // The files are analyzed in the order of adding.
    await assertEventsText(collector, r'''
[status] working
[operation] analyzeFile
  file: /home/test/lib/b.dart
  library: /home/test/lib/b.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/b.dart
    uri: package:test/b.dart
    flags: exists isLibrary
[operation] analyzeFile
  file: /home/test/lib/a.dart
  library: /home/test/lib/a.dart
[stream]
  ResolvedUnitResult #1
    path: /home/test/lib/a.dart
    uri: package:test/a.dart
    flags: exists isLibrary
[status] idle
''');
  }

  test_addFile_afterRemove() async {
    var a = newFile('$testPackageLibPath/a.dart', r'''
class A {}''');

    var b = newFile('$testPackageLibPath/b.dart', r'''
import 'a.dart';
''');

    var driver = driverFor(testFile);
    var collector = DriverEventCollector(driver);
    driver.addFile2(a);
    driver.addFile2(b);

    // Initial analysis, `b` does not use `a`, so there is a hint.
    await assertEventsText(collector, r'''
[status] working
[operation] analyzeFile
  file: /home/test/lib/a.dart
  library: /home/test/lib/a.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/a.dart
    uri: package:test/a.dart
    flags: exists isLibrary
[operation] analyzeFile
  file: /home/test/lib/b.dart
  library: /home/test/lib/b.dart
[stream]
  ResolvedUnitResult #1
    path: /home/test/lib/b.dart
    uri: package:test/b.dart
    flags: exists isLibrary
    errors
      7 +8 UNUSED_IMPORT
[status] idle
''');

    // Update `b` to use `a`, no more hints.
    modifyFile2(b, r'''
import 'a.dart';
void f() {
  A;
}
''');

    // Remove and add `b`.
    driver.removeFile2(b);
    driver.addFile2(b);

    // `b` was analyzed, no more hints.
    await assertEventsText(collector, r'''
[status] working
[operation] reuseLinkedBundle SDK
[operation] reuseLinkedBundle
  package:test/a.dart
[operation] analyzeFile
  file: /home/test/lib/b.dart
  library: /home/test/lib/b.dart
[stream]
  ResolvedUnitResult #2
    path: /home/test/lib/b.dart
    uri: package:test/b.dart
    flags: exists isLibrary
[status] idle
''');
  }

  test_addFile_missingDartLibrary_async() async {
    var driver = driverFor(testFile);
    var collector = DriverEventCollector(driver);

    sdkRoot.getChildAssumingFile('lib/async/async.dart').delete();

    var a = newFile('$testPackageLibPath/a.dart', '');
    driver.addFile2(a);

    await assertEventsText(collector, r'''
[status] working
[status] idle
''');
  }

  test_addFile_missingDartLibrary_core() async {
    var driver = driverFor(testFile);
    var collector = DriverEventCollector(driver);

    sdkRoot.getChildAssumingFile('lib/core/core.dart').delete();

    var a = newFile('$testPackageLibPath/a.dart', '');
    driver.addFile2(a);

    await assertEventsText(collector, r'''
[status] working
[status] idle
''');
  }

  test_addFile_notAbsolutePath() async {
    var driver = driverFor(testFile);
    expect(() {
      driver.addFile('not_absolute.dart');
    }, throwsArgumentError);
  }

  test_addFile_priorityFiles() async {
    var a = newFile('$testPackageLibPath/a.dart', '');
    var b = newFile('$testPackageLibPath/b.dart', '');
    var c = newFile('$testPackageLibPath/c.dart', '');

    var driver = driverFor(testFile);
    var collector = DriverEventCollector(driver);

    driver.addFile2(a);
    driver.addFile2(b);
    driver.addFile2(c);
    driver.priorityFiles2 = [b];

    // 1. The priority file is produced first.
    // 2. Each analyzed file produces `ResolvedUnitResult`.
    await assertEventsText(collector, r'''
[status] working
[operation] analyzeFile
  file: /home/test/lib/b.dart
  library: /home/test/lib/b.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/b.dart
    uri: package:test/b.dart
    flags: exists isLibrary
[operation] analyzeFile
  file: /home/test/lib/a.dart
  library: /home/test/lib/a.dart
[stream]
  ResolvedUnitResult #1
    path: /home/test/lib/a.dart
    uri: package:test/a.dart
    flags: exists isLibrary
[operation] analyzeFile
  file: /home/test/lib/c.dart
  library: /home/test/lib/c.dart
[stream]
  ResolvedUnitResult #2
    path: /home/test/lib/c.dart
    uri: package:test/c.dart
    flags: exists isLibrary
[status] idle
''');
  }

  test_addFile_removeFile() async {
    var a = newFile('$testPackageLibPath/a.dart', '');

    var driver = driverFor(testFile);
    var collector = DriverEventCollector(driver);

    // Add, and immediately remove.
    driver.addFile2(a);
    driver.removeFile2(a);

    // No files to analyze.
    await assertEventsText(collector, r'''
[status] working
[status] idle
''');
  }

  test_addFile_thenRemove() async {
    var a = newFile('$testPackageLibPath/a.dart', '');
    var b = newFile('$testPackageLibPath/b.dart', '');

    var driver = driverFor(testFile);
    var collector = DriverEventCollector(driver);

    driver.addFile2(a);
    driver.addFile2(b);

    // Now remove `a`.
    driver.removeFile2(a);

    // We remove `a` before analysis started.
    // So, only `b` was analyzed.
    await assertEventsText(collector, r'''
[status] working
[operation] analyzeFile
  file: /home/test/lib/b.dart
  library: /home/test/lib/b.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/b.dart
    uri: package:test/b.dart
    flags: exists isLibrary
[status] idle
''');
  }

  test_cachedPriorityResults() async {
    var a = newFile('$testPackageLibPath/a.dart', '');

    var driver = driverFor(testFile);
    var collector = DriverEventCollector(driver);

    driver.priorityFiles2 = [a];

    // Get the result, not cached.
    collector.getResolvedUnit('A1', a);
    await assertEventsText(collector, r'''
[status] working
[operation] analyzeFile
  file: /home/test/lib/a.dart
  library: /home/test/lib/a.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/a.dart
    uri: package:test/a.dart
    flags: exists isLibrary
[status] idle
[future] getResolvedUnit A1
  ResolvedUnitResult #0
''');

    // Get the (cached) result, not reported to the stream.
    collector.getResolvedUnit('A2', a);
    await assertEventsText(collector, r'''
[future] getResolvedUnit A2
  ResolvedUnitResult #0
''');

    // Get the (cached) result, reported to the stream.
    collector.getResolvedUnit('A3', a, sendCachedToStream: true);
    await assertEventsText(collector, r'''
[stream]
  ResolvedUnitResult #0
[future] getResolvedUnit A3
  ResolvedUnitResult #0
''');
  }

  test_cachedPriorityResults_flush_onAnyFileChange() async {
    var a = newFile('$testPackageLibPath/a.dart', '');
    var b = newFile('$testPackageLibPath/b.dart', '');

    var driver = driverFor(testFile);
    var collector = DriverEventCollector(driver);

    driver.priorityFiles2 = [a];

    collector.getResolvedUnit('A1', a);
    await assertEventsText(collector, r'''
[status] working
[operation] analyzeFile
  file: /home/test/lib/a.dart
  library: /home/test/lib/a.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/a.dart
    uri: package:test/a.dart
    flags: exists isLibrary
[status] idle
[future] getResolvedUnit A1
  ResolvedUnitResult #0
''');

    // Change a file.
    // The cache is flushed, so we get a new result.
    driver.changeFile2(a);
    collector.getResolvedUnit('A2', a);
    await assertEventsText(collector, r'''
[status] working
[operation] analyzeFile
  file: /home/test/lib/a.dart
  library: /home/test/lib/a.dart
[operation] reuseLinkedBundle
  package:test/a.dart
[stream]
  ResolvedUnitResult #1
    path: /home/test/lib/a.dart
    uri: package:test/a.dart
    flags: exists isLibrary
[status] idle
[future] getResolvedUnit A2
  ResolvedUnitResult #1
''');

    // Add `b`.
    // The cache is flushed, so we get a new result.
    driver.addFile2(b);
    collector.getResolvedUnit('A3', a);
    await assertEventsText(collector, r'''
[status] working
[operation] analyzeFile
  file: /home/test/lib/a.dart
  library: /home/test/lib/a.dart
[stream]
  ResolvedUnitResult #2
    path: /home/test/lib/a.dart
    uri: package:test/a.dart
    flags: exists isLibrary
[operation] analyzeFile
  file: /home/test/lib/b.dart
  library: /home/test/lib/b.dart
[stream]
  ResolvedUnitResult #3
    path: /home/test/lib/b.dart
    uri: package:test/b.dart
    flags: exists isLibrary
[status] idle
[future] getResolvedUnit A3
  ResolvedUnitResult #2
''');

    // Remove `b`.
    // The cache is flushed, so we get a new result.
    driver.removeFile2(b);
    collector.getResolvedUnit('A4', a);
    await assertEventsText(collector, r'''
[status] working
[operation] analyzeFile
  file: /home/test/lib/a.dart
  library: /home/test/lib/a.dart
[operation] reuseLinkedBundle SDK
[operation] reuseLinkedBundle
  package:test/a.dart
[stream]
  ResolvedUnitResult #4
    path: /home/test/lib/a.dart
    uri: package:test/a.dart
    flags: exists isLibrary
[status] idle
[future] getResolvedUnit A4
  ResolvedUnitResult #4
''');
  }

  test_cachedPriorityResults_flush_onPrioritySetChange() async {
    var a = newFile('$testPackageLibPath/a.dart', '');
    var b = newFile('$testPackageLibPath/b.dart', '');

    var driver = driverFor(testFile);
    var collector = DriverEventCollector(driver);

    driver.priorityFiles2 = [a];

    // Get the result for `a`, new.
    collector.getResolvedUnit('A1', a);
    await assertEventsText(collector, r'''
[status] working
[operation] analyzeFile
  file: /home/test/lib/a.dart
  library: /home/test/lib/a.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/a.dart
    uri: package:test/a.dart
    flags: exists isLibrary
[status] idle
[future] getResolvedUnit A1
  ResolvedUnitResult #0
''');

    // Make `a` and `b` priority.
    // We still have the result for `a` cached.
    driver.priorityFiles2 = [a, b];
    collector.getResolvedUnit('A2', a);
    await assertEventsText(collector, r'''
[status] working
[status] idle
[future] getResolvedUnit A2
  ResolvedUnitResult #0
''');

    // Get the result for `b`, new.
    collector.getResolvedUnit('B1', b);
    await assertEventsText(collector, r'''
[status] working
[operation] analyzeFile
  file: /home/test/lib/b.dart
  library: /home/test/lib/b.dart
[stream]
  ResolvedUnitResult #1
    path: /home/test/lib/b.dart
    uri: package:test/b.dart
    flags: exists isLibrary
[status] idle
[future] getResolvedUnit B1
  ResolvedUnitResult #1
''');

    // Get the result for `b`, cached.
    collector.getResolvedUnit('B2', b);
    await assertEventsText(collector, r'''
[future] getResolvedUnit B2
  ResolvedUnitResult #1
''');

    // Only `b` is priority.
    // The result for `a` is flushed, so analyzed when asked.
    driver.priorityFiles2 = [b];
    collector.getResolvedUnit('A3', a);
    await assertEventsText(collector, r'''
[status] working
[operation] analyzeFile
  file: /home/test/lib/a.dart
  library: /home/test/lib/a.dart
[stream]
  ResolvedUnitResult #2
    path: /home/test/lib/a.dart
    uri: package:test/a.dart
    flags: exists isLibrary
[status] idle
[future] getResolvedUnit A3
  ResolvedUnitResult #2
''');
  }

  test_cachedPriorityResults_notPriority() async {
    var a = newFile('$testPackageLibPath/a.dart', '');

    var driver = driverFor(testFile);
    var collector = DriverEventCollector(driver);

    // Always analyzed the first time.
    collector.getResolvedUnit('A1', a);
    await assertEventsText(collector, r'''
[status] working
[operation] analyzeFile
  file: /home/test/lib/a.dart
  library: /home/test/lib/a.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/a.dart
    uri: package:test/a.dart
    flags: exists isLibrary
[status] idle
[future] getResolvedUnit A1
  ResolvedUnitResult #0
''');

    // Analyzed again, because `a` is not priority.
    collector.getResolvedUnit('A2', a);
    await assertEventsText(collector, r'''
[status] working
[operation] analyzeFile
  file: /home/test/lib/a.dart
  library: /home/test/lib/a.dart
[stream]
  ResolvedUnitResult #1
    path: /home/test/lib/a.dart
    uri: package:test/a.dart
    flags: exists isLibrary
[status] idle
[future] getResolvedUnit A2
  ResolvedUnitResult #1
''');
  }

  test_cachedPriorityResults_wholeLibrary_priorityLibrary_askLibrary() async {
    var a = newFile('$testPackageLibPath/a.dart', r'''
part 'b.dart';
''');

    var b = newFile('$testPackageLibPath/b.dart', r'''
part of 'a.dart';
''');

    var driver = driverFor(testFile);
    var collector = DriverEventCollector(driver);

    driver.priorityFiles2 = [a];

    // Ask the result for `a`, should cache for both `a` and `b`.
    collector.getResolvedUnit('A1', a);
    await assertEventsText(collector, r'''
[status] working
[operation] analyzeFile
  file: /home/test/lib/a.dart
  library: /home/test/lib/a.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/a.dart
    uri: package:test/a.dart
    flags: exists isLibrary
[stream]
  ResolvedUnitResult #1
    path: /home/test/lib/b.dart
    uri: package:test/b.dart
    flags: exists isPart
[status] idle
[future] getResolvedUnit A1
  ResolvedUnitResult #0
''');

    // Verify that the results for `a` and `b` are cached.
    // Note, no analysis.
    collector.getResolvedUnit('A2', a);
    collector.getResolvedUnit('B1', b);
    await assertEventsText(collector, r'''
[future] getResolvedUnit A2
  ResolvedUnitResult #0
[future] getResolvedUnit B1
  ResolvedUnitResult #1
''');

    // Ask for resolved library.
    // Note, no analysis.
    // Note, the units are cached.
    collector.getResolvedLibrary('L1', a);
    await assertEventsText(collector, r'''
[future] getResolvedLibrary L1
  ResolvedLibraryResult #2
    element: package:test/a.dart
    units
      ResolvedUnitResult #0
      ResolvedUnitResult #1
''');
  }

  test_cachedPriorityResults_wholeLibrary_priorityLibrary_askPart() async {
    var a = newFile('$testPackageLibPath/a.dart', r'''
part 'b.dart';
''');

    var b = newFile('$testPackageLibPath/b.dart', r'''
part of 'a.dart';
''');

    var driver = driverFor(testFile);
    var collector = DriverEventCollector(driver);

    driver.priorityFiles2 = [a];

    // Ask the result for `b`, should cache for both `a` and `b`.
    collector.getResolvedUnit('B1', b);
    await assertEventsText(collector, r'''
[status] working
[operation] analyzeFile
  file: /home/test/lib/b.dart
  library: /home/test/lib/a.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/a.dart
    uri: package:test/a.dart
    flags: exists isLibrary
[stream]
  ResolvedUnitResult #1
    path: /home/test/lib/b.dart
    uri: package:test/b.dart
    flags: exists isPart
[status] idle
[future] getResolvedUnit B1
  ResolvedUnitResult #1
''');

    // Verify that the results for `a` and `b` are cached.
    // Note, no analysis.
    collector.getResolvedUnit('A1', a);
    collector.getResolvedUnit('B2', b);
    await assertEventsText(collector, r'''
[future] getResolvedUnit A1
  ResolvedUnitResult #0
[future] getResolvedUnit B2
  ResolvedUnitResult #1
''');

    // Ask for resolved library.
    // Note, no analysis.
    // Note, the units are cached.
    collector.getResolvedLibrary('L1', a);
    await assertEventsText(collector, r'''
[future] getResolvedLibrary L1
  ResolvedLibraryResult #2
    element: package:test/a.dart
    units
      ResolvedUnitResult #0
      ResolvedUnitResult #1
''');
  }

  test_cachedPriorityResults_wholeLibrary_priorityPart_askPart() async {
    var a = newFile('$testPackageLibPath/a.dart', r'''
part 'b.dart';
''');

    var b = newFile('$testPackageLibPath/b.dart', r'''
part of 'a.dart';
''');

    var driver = driverFor(testFile);
    var collector = DriverEventCollector(driver);

    driver.priorityFiles2 = [b];

    // Ask the result for `b`, should cache for both `a` and `b`.
    collector.getResolvedUnit('B1', b);
    await assertEventsText(collector, r'''
[status] working
[operation] analyzeFile
  file: /home/test/lib/b.dart
  library: /home/test/lib/a.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/a.dart
    uri: package:test/a.dart
    flags: exists isLibrary
[stream]
  ResolvedUnitResult #1
    path: /home/test/lib/b.dart
    uri: package:test/b.dart
    flags: exists isPart
[status] idle
[future] getResolvedUnit B1
  ResolvedUnitResult #1
''');

    // Verify that the results for `a` and `b` are cached.
    // Note, no analysis.
    collector.getResolvedUnit('A1', a);
    collector.getResolvedUnit('B2', b);
    await assertEventsText(collector, r'''
[future] getResolvedUnit A1
  ResolvedUnitResult #0
[future] getResolvedUnit B2
  ResolvedUnitResult #1
''');

    // Ask for resolved library.
    // Note, no analysis.
    // Note, the units are cached.
    collector.getResolvedLibrary('L1', a);
    await assertEventsText(collector, r'''
[future] getResolvedLibrary L1
  ResolvedLibraryResult #2
    element: package:test/a.dart
    units
      ResolvedUnitResult #0
      ResolvedUnitResult #1
''');
  }

  test_changeFile_implicitlyAnalyzed() async {
    var a = newFile('$testPackageLibPath/a.dart', r'''
import 'b.dart';
var A = B;
''');

    var b = newFile('$testPackageLibPath/b.dart', r'''
var B = 0;
''');

    var driver = driverFor(testFile);
    var collector = DriverEventCollector(driver);

    driver.priorityFiles2 = [a];
    driver.addFile2(a);

    configuration.libraryConfiguration.unitConfiguration.nodeSelector =
        (result) {
          return result.findNode.simple('B;');
        };

    // We have a result only for "a".
    // The type of `B` is `int`.
    await assertEventsText(collector, r'''
[status] working
[operation] analyzeFile
  file: /home/test/lib/a.dart
  library: /home/test/lib/a.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/a.dart
    uri: package:test/a.dart
    flags: exists isLibrary
    selectedNode: SimpleIdentifier
      token: B
      element: package:test/b.dart::@getter::B
      staticType: int
[status] idle
''');

    // Change "b" and notify.
    modifyFile2(b, r'''
var B = 1.2;
''');
    driver.changeFile2(b);

    // While "b" is not analyzed explicitly, it is analyzed implicitly.
    // The change causes "a" to be reanalyzed.
    // The type of `B` is now `double`.
    await assertEventsText(collector, r'''
[status] working
[operation] analyzeFile
  file: /home/test/lib/a.dart
  library: /home/test/lib/a.dart
[stream]
  ResolvedUnitResult #1
    path: /home/test/lib/a.dart
    uri: package:test/a.dart
    flags: exists isLibrary
    selectedNode: SimpleIdentifier
      token: B
      element: package:test/b.dart::@getter::B
      staticType: double
[status] idle
''');
  }

  test_changeFile_notAbsolutePath() async {
    var driver = driverFor(testFile);
    expect(() {
      driver.changeFile('not_absolute.dart');
    }, throwsArgumentError);
  }

  test_changeFile_notExisting_toEmpty() async {
    var b = newFile('$testPackageLibPath/b.dart', '''
// ignore:unused_import
import 'a.dart';
''');

    var driver = driverFor(testFile);
    var collector = DriverEventCollector(driver);

    driver.addFile2(b);

    // `b` is analyzed, has an error.
    await assertEventsText(collector, r'''
[status] working
[operation] analyzeFile
  file: /home/test/lib/b.dart
  library: /home/test/lib/b.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/b.dart
    uri: package:test/b.dart
    flags: exists isLibrary
    errors
      31 +8 URI_DOES_NOT_EXIST
[status] idle
''');

    // Create `a`, empty.
    var a = newFile('$testPackageLibPath/a.dart', '');
    driver.addFile2(a);

    // Both `a` and `b` are analyzed.
    // No errors anymore.
    await assertEventsText(collector, r'''
[status] working
[operation] analyzeFile
  file: /home/test/lib/a.dart
  library: /home/test/lib/a.dart
[stream]
  ResolvedUnitResult #1
    path: /home/test/lib/a.dart
    uri: package:test/a.dart
    flags: exists isLibrary
[operation] analyzeFile
  file: /home/test/lib/b.dart
  library: /home/test/lib/b.dart
[stream]
  ResolvedUnitResult #2
    path: /home/test/lib/b.dart
    uri: package:test/b.dart
    flags: exists isLibrary
[status] idle
''');
  }

  test_changeFile_notPriority_errorsFromBytes() async {
    var a = newFile('$testPackageLibPath/a.dart', '');

    var driver = driverFor(a);
    var collector = DriverEventCollector(driver);

    driver.addFile2(a);

    // Initial analysis, no errors.
    await assertEventsText(collector, r'''
[status] working
[operation] analyzeFile
  file: /home/test/lib/a.dart
  library: /home/test/lib/a.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/a.dart
    uri: package:test/a.dart
    flags: exists isLibrary
[status] idle
''');

    // Update the file, has an error.
    // Note, we analyze the file.
    modifyFile2(a, ';');
    driver.changeFile2(a);
    await assertEventsText(collector, r'''
[status] working
[operation] reuseLinkedBundle
  package:test/a.dart
[operation] analyzeFile
  file: /home/test/lib/a.dart
  library: /home/test/lib/a.dart
[stream]
  ResolvedUnitResult #1
    path: /home/test/lib/a.dart
    uri: package:test/a.dart
    flags: exists isLibrary
    errors
      0 +1 UNEXPECTED_TOKEN
[status] idle
''');

    // Update the file, no errors.
    // Note, we return errors from bytes.
    // We must update latest signatures, not reflected in the text.
    // If we don't, the next assert will fail.
    modifyFile2(a, '');
    driver.changeFile2(a);
    await assertEventsText(collector, r'''
[status] working
[operation] reuseLinkedBundle
  package:test/a.dart
[operation] getErrorsFromBytes
  file: /home/test/lib/a.dart
  library: /home/test/lib/a.dart
[stream]
  ErrorsResult #2
    path: /home/test/lib/a.dart
    uri: package:test/a.dart
    flags: isLibrary
[status] idle
''');

    // Update the file, has an error.
    // Note, we return errors from bytes.
    modifyFile2(a, ';');
    driver.changeFile2(a);
    await assertEventsText(collector, r'''
[status] working
[operation] reuseLinkedBundle
  package:test/a.dart
[operation] getErrorsFromBytes
  file: /home/test/lib/a.dart
  library: /home/test/lib/a.dart
[stream]
  ErrorsResult #3
    path: /home/test/lib/a.dart
    uri: package:test/a.dart
    flags: isLibrary
    errors
      0 +1 UNEXPECTED_TOKEN
[status] idle
''');
  }

  test_changeFile_notUsed() async {
    var a = newFile('$testPackageLibPath/a.dart', '');
    var b = newFile('$testPackageLibPath/b.dart', 'class B1 {}');

    var driver = driverFor(testFile);
    var collector = DriverEventCollector(driver);

    driver.addFile2(a);

    // Nothing interesting, "a" is analyzed.
    await assertEventsText(collector, r'''
[status] working
[operation] analyzeFile
  file: /home/test/lib/a.dart
  library: /home/test/lib/a.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/a.dart
    uri: package:test/a.dart
    flags: exists isLibrary
[status] idle
''');

    // Change "b" and notify.
    modifyFile2(b, 'class B2 {}');
    driver.changeFile2(b);

    // Nothing depends on "b", so nothing is analyzed.
    await assertEventsText(collector, r'''
[status] working
[status] idle
''');
  }

  test_changeFile_potentiallyAffected_imported() async {
    newFile('$testPackageLibPath/a.dart', '');

    var b = newFile('$testPackageLibPath/b.dart', '''
import 'a.dart';
''');

    var c = newFile('$testPackageLibPath/c.dart', '''
import 'b.dart';
''');

    var d = newFile('$testPackageLibPath/d.dart', '''
import 'c.dart';
''');

    newFile('$testPackageLibPath/e.dart', '');

    var driver = driverFor(testFile);

    Future<LibraryElement> getLibrary(String shortName) async {
      var uriStr = 'package:test/$shortName';
      var result = await driver.getLibraryByUriValid(uriStr);
      return result.element;
    }

    var a_element = await getLibrary('a.dart');
    var b_element = await getLibrary('b.dart');
    var c_element = await getLibrary('c.dart');
    var d_element = await getLibrary('d.dart');
    var e_element = await getLibrary('e.dart');

    // We have all libraries loaded after analysis.
    driver.assertLoadedLibraryUriSet(
      included: [
        'package:test/a.dart',
        'package:test/b.dart',
        'package:test/c.dart',
        'package:test/d.dart',
        'package:test/e.dart',
      ],
    );

    // All libraries have the current session.
    var session1 = driver.currentSession;
    expect(a_element.session, session1);
    expect(b_element.session, session1);
    expect(c_element.session, session1);
    expect(d_element.session, session1);
    expect(e_element.session, session1);

    // Change `b.dart`, also removes `c.dart` and `d.dart` that import it.
    // But `a.dart` and `d.dart` is not affected.
    driver.changeFile2(b);
    var affectedPathList = await driver.applyPendingFileChanges();
    expect(affectedPathList, unorderedEquals([b.path, c.path, d.path]));

    // We have a new session.
    var session2 = driver.currentSession;
    expect(session2, isNot(session1));

    driver.assertLoadedLibraryUriSet(
      excluded: [
        'package:test/b.dart',
        'package:test/c.dart',
        'package:test/d.dart',
      ],
      included: ['package:test/a.dart', 'package:test/e.dart'],
    );

    // `a.dart` and `e.dart` moved to the new session.
    // Invalidated libraries stuck with the old session.
    expect(a_element.session, session2);
    expect(b_element.session, session1);
    expect(c_element.session, session1);
    expect(d_element.session, session1);
    expect(e_element.session, session2);
  }

  test_changeFile_potentiallyAffected_part() async {
    var a = newFile('$testPackageLibPath/a.dart', '''
part of 'b.dart';
''');

    var b = newFile('$testPackageLibPath/b.dart', '''
part 'a.dart';
''');

    var c = newFile('$testPackageLibPath/c.dart', '''
import 'b.dart';
''');

    newFile('$testPackageLibPath/d.dart', '');

    var driver = driverFor(testFile);

    Future<LibraryElement> getLibrary(String shortName) async {
      var uriStr = 'package:test/$shortName';
      var result = await driver.getLibraryByUriValid(uriStr);
      return result.element;
    }

    var b_element = await getLibrary('b.dart');
    var c_element = await getLibrary('c.dart');
    var d_element = await getLibrary('d.dart');

    // We have all libraries loaded after analysis.
    driver.assertLoadedLibraryUriSet(
      included: [
        'package:test/b.dart',
        'package:test/c.dart',
        'package:test/d.dart',
      ],
    );

    // All libraries have the current session.
    var session1 = driver.currentSession;
    expect(b_element.session, session1);
    expect(c_element.session, session1);
    expect(d_element.session, session1);

    // Change `a.dart`, remove `b.dart` that part it.
    // Removes `c.dart` that imports `b.dart`.
    // But `d.dart` is not affected.
    driver.changeFile2(a);
    var affectedPathList = await driver.applyPendingFileChanges();
    expect(affectedPathList, unorderedEquals([a.path, b.path, c.path]));

    // We have a new session.
    var session2 = driver.currentSession;
    expect(session2, isNot(session1));

    driver.assertLoadedLibraryUriSet(
      excluded: ['package:test/b.dart', 'package:test/c.dart'],
      included: ['package:test/d.dart'],
    );

    // `d.dart` moved to the new session.
    // Invalidated libraries stuck with the old session.
    expect(b_element.session, session1);
    expect(c_element.session, session1);
    expect(d_element.session, session2);
  }

  test_changeFile_selfConsistent() async {
    var a = newFile('$testPackageLibPath/a.dart', r'''
import 'b.dart';
final A1 = 1;
final A2 = B1;
''');

    var b = newFile('$testPackageLibPath/b.dart', r'''
import 'a.dart';
final B1 = A1;
''');

    var driver = driverFor(testFile);
    var collector = DriverEventCollector(driver);

    driver.priorityFiles2 = [a, b];
    driver.addFile2(a);
    driver.addFile2(b);

    configuration.libraryConfiguration.unitConfiguration.variableTypesSelector =
        (result) {
          return switch (result.uriStr) {
            'package:test/a.dart' => [
              result.findElement2.topVar('A1'),
              result.findElement2.topVar('A2'),
            ],
            'package:test/b.dart' => [result.findElement2.topVar('B1')],
            _ => [],
          };
        };

    // We have results for both "a" and "b".
    await assertEventsText(collector, r'''
[status] working
[operation] analyzeFile
  file: /home/test/lib/a.dart
  library: /home/test/lib/a.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/a.dart
    uri: package:test/a.dart
    flags: exists isLibrary
    selectedVariableTypes
      A1: int
      A2: int
[operation] analyzeFile
  file: /home/test/lib/b.dart
  library: /home/test/lib/b.dart
[stream]
  ResolvedUnitResult #1
    path: /home/test/lib/b.dart
    uri: package:test/b.dart
    flags: exists isLibrary
    selectedVariableTypes
      B1: int
[status] idle
''');

    // Update "a".
    modifyFile2(a, r'''
import 'b.dart';
final A1 = 1.2;
final A2 = B1;
''');
    driver.changeFile2(a);

    // We again get results for both "a" and "b".
    // The results are consistent.
    await assertEventsText(collector, r'''
[status] working
[operation] analyzeFile
  file: /home/test/lib/a.dart
  library: /home/test/lib/a.dart
[stream]
  ResolvedUnitResult #2
    path: /home/test/lib/a.dart
    uri: package:test/a.dart
    flags: exists isLibrary
    selectedVariableTypes
      A1: double
      A2: double
[operation] analyzeFile
  file: /home/test/lib/b.dart
  library: /home/test/lib/b.dart
[stream]
  ResolvedUnitResult #3
    path: /home/test/lib/b.dart
    uri: package:test/b.dart
    flags: exists isLibrary
    selectedVariableTypes
      B1: double
[status] idle
''');
  }

  test_changeFile_single() async {
    var a = newFile('$testPackageLibPath/a.dart', 'var V = 1;');

    var driver = driverFor(a);
    var collector = DriverEventCollector(driver);

    driver.addFile2(a);
    driver.priorityFiles2 = [a];

    configuration.libraryConfiguration.unitConfiguration.variableTypesSelector =
        (result) {
          switch (result.uriStr) {
            case 'package:test/a.dart':
              return [result.findElement2.topVar('V')];
            default:
              return [];
          }
        };

    // Initial analysis.
    await assertEventsText(collector, r'''
[status] working
[operation] analyzeFile
  file: /home/test/lib/a.dart
  library: /home/test/lib/a.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/a.dart
    uri: package:test/a.dart
    flags: exists isLibrary
    selectedVariableTypes
      V: int
[status] idle
''');

    // Update the file, but don't notify the driver.
    // No new results.
    modifyFile2(a, 'var V = 1.2;');
    await assertEventsText(collector, r'''
''');

    // Notify the driver about the change.
    // We get a new result.
    driver.changeFile2(a);
    await assertEventsText(collector, r'''
[status] working
[operation] analyzeFile
  file: /home/test/lib/a.dart
  library: /home/test/lib/a.dart
[stream]
  ResolvedUnitResult #1
    path: /home/test/lib/a.dart
    uri: package:test/a.dart
    flags: exists isLibrary
    selectedVariableTypes
      V: double
[status] idle
''');
  }

  test_currentSession() async {
    var a = newFile('$testPackageLibPath/a.dart', r'''
final v = 0;
''');

    var driver = driverFor(testFile);

    await driver.getResolvedUnit2(a);

    var session1 = driver.currentSession;
    expect(session1, isNotNull);

    modifyFile2(a, r'''
final v = 2;
''');
    driver.changeFile2(a);
    await driver.getResolvedUnit2(a);

    var session2 = driver.currentSession;
    expect(session2, isNotNull);

    // We get a new session.
    expect(session2, isNot(session1));
  }

  test_discoverAvailableFiles_packages() async {
    writeTestPackageConfig(
      PackageConfigFileBuilder()
        ..add(name: 'aaa', rootPath: '$packagesRootPath/aaa')
        ..add(name: 'bbb', rootPath: '$packagesRootPath/bbb'),
    );

    var t1 = newFile('$testPackageLibPath/t1.dart', '');
    var a1 = newFile('$packagesRootPath/aaa/lib/a1.dart', '');
    var a2 = newFile('$packagesRootPath/aaa/lib/src/a2.dart', '');
    var a3 = newFile('$packagesRootPath/aaa/lib/a3.txt', '');
    var b1 = newFile('$packagesRootPath/bbb/lib/b1.dart', '');
    var c1 = newFile('$packagesRootPath/ccc/lib/c1.dart', '');

    var driver = driverFor(testFile);
    driver.addFile2(t1);

    // Don't add `a1`, `a2`, or `b1` - they should be discovered.
    // And `c` is not in the package config, so should not be discovered.
    await driver.discoverAvailableFiles();

    var knownFiles = driver.knownFiles.resources;
    expect(knownFiles, contains(t1));
    expect(knownFiles, contains(a1));
    expect(knownFiles, contains(a2));
    expect(knownFiles, isNot(contains(a3)));
    expect(knownFiles, contains(b1));
    expect(knownFiles, isNot(contains(c1)));

    // We can wait for discovery more than once.
    await driver.discoverAvailableFiles();
  }

  test_discoverAvailableFiles_sdk() async {
    var driver = driverFor(testFile);
    await driver.discoverAvailableFiles();
    expect(
      driver.knownFiles.resources,
      containsAll([
        sdkRoot.getChildAssumingFile('lib/async/async.dart'),
        sdkRoot.getChildAssumingFile('lib/collection/collection.dart'),
        sdkRoot.getChildAssumingFile('lib/core/core.dart'),
        sdkRoot.getChildAssumingFile('lib/math/math.dart'),
      ]),
    );
  }

  test_getCachedResolvedUnit() async {
    var a = newFile('$testPackageLibPath/a.dart', '');

    var driver = driverFor(a);
    var collector = DriverEventCollector(driver);

    // Not cached.
    // Note, no analysis.
    collector.getCachedResolvedUnit('A1', a);
    await assertEventsText(collector, r'''
[future] getCachedResolvedUnit A1
  null
''');

    driver.priorityFiles2 = [a];
    collector.getResolvedUnit('A2', a);
    await assertEventsText(collector, r'''
[status] working
[operation] analyzeFile
  file: /home/test/lib/a.dart
  library: /home/test/lib/a.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/a.dart
    uri: package:test/a.dart
    flags: exists isLibrary
[status] idle
[future] getResolvedUnit A2
  ResolvedUnitResult #0
''');

    // Has cached.
    // Note, no analysis.
    collector.getCachedResolvedUnit('A3', a);
    await assertEventsText(collector, r'''
[future] getCachedResolvedUnit A3
  ResolvedUnitResult #0
''');
  }

  test_getErrors() async {
    var a = newFile('$testPackageLibPath/a.dart', '''
var v = 0
''');

    var driver = driverFor(a);
    var collector = DriverEventCollector(driver);

    collector.getErrors('A1', a);
    await assertEventsText(collector, r'''
[status] working
[operation] analyzeFile
  file: /home/test/lib/a.dart
  library: /home/test/lib/a.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/a.dart
    uri: package:test/a.dart
    flags: exists isLibrary
    errors
      8 +1 EXPECTED_TOKEN
[status] idle
[future] getErrors A1
  ErrorsResult #1
    path: /home/test/lib/a.dart
    uri: package:test/a.dart
    flags: isLibrary
    errors
      8 +1 EXPECTED_TOKEN
''');

    // The result is produced from bytes.
    collector.getErrors('A2', a);
    await assertEventsText(collector, r'''
[status] working
[operation] getErrorsFromBytes
  file: /home/test/lib/a.dart
  library: /home/test/lib/a.dart
[status] idle
[future] getErrors A2
  ErrorsResult #2
    path: /home/test/lib/a.dart
    uri: package:test/a.dart
    flags: isLibrary
    errors
      8 +1 EXPECTED_TOKEN
''');
  }

  test_getErrors_library_part() async {
    var a = newFile('$testPackageLibPath/a.dart', r'''
part 'b.dart';
''');

    var b = newFile('$testPackageLibPath/b.dart', r'''
part of 'a.dart';
''');

    var driver = driverFor(testFile);
    var collector = DriverEventCollector(driver);

    collector.getErrors('A1', a);
    collector.getErrors('B1', b);

    // Note, both `getErrors()` returned during the library analysis.
    await assertEventsText(collector, r'''
[status] working
[operation] analyzeFile
  file: /home/test/lib/a.dart
  library: /home/test/lib/a.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/a.dart
    uri: package:test/a.dart
    flags: exists isLibrary
[stream]
  ResolvedUnitResult #1
    path: /home/test/lib/b.dart
    uri: package:test/b.dart
    flags: exists isPart
[status] idle
[future] getErrors A1
  ErrorsResult #2
    path: /home/test/lib/a.dart
    uri: package:test/a.dart
    flags: isLibrary
[future] getErrors B1
  ErrorsResult #3
    path: /home/test/lib/b.dart
    uri: package:test/b.dart
    flags: isPart
''');
  }

  test_getErrors_missingDartLibrary_async() async {
    var driver = driverFor(testFile);
    var collector = DriverEventCollector(driver);

    sdkRoot.getChildAssumingFile('lib/async/async.dart').delete();

    var a = newFile('$testPackageLibPath/a.dart', '');
    collector.getErrors('A1', a);

    await assertEventsText(collector, r'''
[status] working
[status] idle
[future] getErrors A1
  MissingSdkLibraryResult #0
    missingUri: dart:async
''');
  }

  test_getErrors_missingDartLibrary_core() async {
    var driver = driverFor(testFile);
    var collector = DriverEventCollector(driver);

    sdkRoot.getChildAssumingFile('lib/core/core.dart').delete();

    var a = newFile('$testPackageLibPath/a.dart', '');
    collector.getErrors('A1', a);

    await assertEventsText(collector, r'''
[status] working
[status] idle
[future] getErrors A1
  MissingSdkLibraryResult #0
    missingUri: dart:core
''');
  }

  test_getErrors_notAbsolutePath() async {
    var driver = driverFor(testFile);
    var result = await driver.getErrors('not_absolute.dart');
    expect(result, isA<InvalidPathResult>());
  }

  test_getFilesDefiningClassMemberName_class() async {
    var a = newFile('$testPackageLibPath/a.dart', r'''
class A {
  void m1() {}
}
''');

    var b = newFile('$testPackageLibPath/b.dart', r'''
class B {
  void m2() {}
}
''');

    var c = newFile('$testPackageLibPath/c.dart', r'''
class C {
  void m2() {}
}
''');

    var d = newFile('$testPackageLibPath/d.dart', r'''
class D {
  void m3() {}
}
''');

    var driver = driverFor(testFile);
    driver.addFile2(a);
    driver.addFile2(b);
    driver.addFile2(c);
    driver.addFile2(d);

    await driver.assertFilesDefiningClassMemberName('m1', [a]);
    await driver.assertFilesDefiningClassMemberName('m2', [b, c]);
    await driver.assertFilesDefiningClassMemberName('m3', [d]);
  }

  test_getFilesDefiningClassMemberName_mixin() async {
    var a = newFile('$testPackageLibPath/a.dart', r'''
mixin A {
  void m1() {}
}
''');

    var b = newFile('$testPackageLibPath/b.dart', r'''
mixin B {
  void m2() {}
}
''');

    var c = newFile('$testPackageLibPath/c.dart', r'''
mixin C {
  void m2() {}
}
''');

    var d = newFile('$testPackageLibPath/d.dart', r'''
mixin D {
  void m3() {}
}
''');

    var driver = driverFor(testFile);
    driver.addFile2(a);
    driver.addFile2(b);
    driver.addFile2(c);
    driver.addFile2(d);

    await driver.assertFilesDefiningClassMemberName('m1', [a]);
    await driver.assertFilesDefiningClassMemberName('m2', [b, c]);
    await driver.assertFilesDefiningClassMemberName('m3', [d]);
  }

  test_getFilesReferencingName() async {
    var a = newFile('$testPackageLibPath/a.dart', r'''
class A {}
''');

    var b = newFile('$testPackageLibPath/b.dart', r'''
import 'a.dart';
void f(A a) {}
''');

    var c = newFile('$testPackageLibPath/c.dart', r'''
import 'a.dart';
void f(A a) {}
''');

    var d = newFile('$testPackageLibPath/d.dart', r'''
class A {}
void f(A a) {}
''');

    var e = newFile('$testPackageLibPath/e.dart', r'''
import 'a.dart';
void main() {}
''');

    var driver = driverFor(testFile);
    driver.addFile2(a);
    driver.addFile2(b);
    driver.addFile2(c);
    driver.addFile2(d);
    driver.addFile2(e);

    // `b` references an external `A`.
    // `c` references an external `A`.
    // `d` references the local `A`.
    // `e` does not reference `A` at all.
    await driver.assertFilesReferencingName(
      'A',
      includesAll: [b, c],
      excludesAll: [d, e],
    );

    // We get the same results second time.
    await driver.assertFilesReferencingName(
      'A',
      includesAll: [b, c],
      excludesAll: [d, e],
    );
  }

  test_getFilesReferencingName_discover() async {
    writeTestPackageConfig(
      PackageConfigFileBuilder()
        ..add(name: 'aaa', rootPath: '$packagesRootPath/aaa')
        ..add(name: 'bbb', rootPath: '$packagesRootPath/bbb'),
    );

    var t = newFile('$testPackageLibPath/t.dart', '''
int t = 0;
''');

    var a = newFile('$packagesRootPath/aaa/lib/a.dart', '''
int a = 0;
''');

    var b = newFile('$packagesRootPath/bbb/lib/b.dart', '''
int b = 0;
''');

    var c = newFile('$packagesRootPath/ccc/lib/c.dart', '''
int c = 0;
''');

    var driver = driverFor(testFile);
    driver.addFile2(t);

    await driver.assertFilesReferencingName(
      'int',
      includesAll: [t, a, b],
      excludesAll: [c],
    );
  }

  test_getFileSync_changedFile() async {
    var a = newFile('$testPackageLibPath/a.dart', '');

    var b = newFile('$testPackageLibPath/b.dart', r'''
import 'a.dart';

void f(A a) {}
''');

    var driver = driverFor(testFile);
    var collector = DriverEventCollector(driver);

    // Ensure that `a` library cycle is loaded.
    // So, `a` is in the library context.
    collector.getResolvedUnit('A1', a);
    await assertEventsText(collector, r'''
[status] working
[operation] analyzeFile
  file: /home/test/lib/a.dart
  library: /home/test/lib/a.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/a.dart
    uri: package:test/a.dart
    flags: exists isLibrary
[status] idle
[future] getResolvedUnit A1
  ResolvedUnitResult #0
''');

    // Update the file, changing its API signature.
    // Note that we don't call `changeFile`.
    modifyFile2(a, 'class A {}\n');

    // Get the file.
    // We have not called `changeFile(a)`, so we should not read the file.
    // Moreover, doing this will create a new library cycle [a.dart].
    // Library cycles are compared by their identity, so we would try to
    // reload linked summary for [a.dart], and crash.
    expect(driver.getFileSyncValid(a).lineInfo.lineCount, 1);

    // We have not read `a.dart`, so `A` is still not declared.
    collector.getResolvedUnit('B1', b);
    await assertEventsText(collector, r'''
[status] working
[operation] analyzeFile
  file: /home/test/lib/b.dart
  library: /home/test/lib/b.dart
[stream]
  ResolvedUnitResult #1
    path: /home/test/lib/b.dart
    uri: package:test/b.dart
    flags: exists isLibrary
    errors
      25 +1 UNDEFINED_CLASS
[status] idle
[future] getResolvedUnit B1
  ResolvedUnitResult #1
''');

    // Notify the driver that the file was changed.
    driver.changeFile2(a);

    // ...and apply this change.
    await driver.applyPendingFileChanges();
    await assertEventsText(collector, r'''
[status] working
[status] idle
''');

    // So, `class A {}` is declared now.
    expect(driver.getFileSyncValid(a).lineInfo.lineCount, 2);

    // ...and `b` has no errors.
    collector.getResolvedUnit('B2', b);
    await assertEventsText(collector, r'''
[status] working
[operation] analyzeFile
  file: /home/test/lib/b.dart
  library: /home/test/lib/b.dart
[stream]
  ResolvedUnitResult #2
    path: /home/test/lib/b.dart
    uri: package:test/b.dart
    flags: exists isLibrary
[status] idle
[future] getResolvedUnit B2
  ResolvedUnitResult #2
''');
  }

  test_getFileSync_library() async {
    var content = 'class A {}';
    var a = newFile('$testPackageLibPath/a.dart', content);
    var driver = driverFor(testFile);
    var result = driver.getFileSyncValid(a);
    expect(result.path, a.path);
    expect(result.uri.toString(), 'package:test/a.dart');
    expect(result.content, content);
    expect(result.isLibrary, isTrue);
    expect(result.isPart, isFalse);
  }

  test_getFileSync_notAbsolutePath() async {
    var driver = driverFor(testFile);
    var result = driver.getFileSync('not_absolute.dart');
    expect(result, isA<InvalidPathResult>());
  }

  test_getFileSync_part() async {
    var content = 'part of lib;';
    var a = newFile('$testPackageLibPath/a.dart', content);
    var driver = driverFor(testFile);
    var result = driver.getFileSyncValid(a);
    expect(result.path, a.path);
    expect(result.uri.toString(), 'package:test/a.dart');
    expect(result.content, content);
    expect(result.isLibrary, isFalse);
    expect(result.isPart, isTrue);
  }

  test_getIndex() async {
    var a = newFile('$testPackageLibPath/a.dart', r'''
void foo() {}

void f() {
  foo();
}
''');

    var driver = driverFor(testFile);
    var collector = DriverEventCollector(driver);

    collector.getIndex('A1', a);
    await assertEventsText(collector, r'''
[status] working
[operation] analyzeFile
  file: /home/test/lib/a.dart
  library: /home/test/lib/a.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/a.dart
    uri: package:test/a.dart
    flags: exists isLibrary
[status] idle
[future] getIndex A1
  strings
    --nullString--
    foo
    package:test/a.dart
''');
  }

  test_getIndex_missingDartLibrary_async() async {
    var driver = driverFor(testFile);
    var collector = DriverEventCollector(driver);

    sdkRoot.getChildAssumingFile('lib/async/async.dart').delete();

    var a = newFile('$testPackageLibPath/a.dart', '');
    collector.getIndex('A1', a);

    await assertEventsText(collector, r'''
[status] working
[status] idle
[future] getIndex A1
''');
  }

  test_getIndex_missingDartLibrary_core() async {
    var driver = driverFor(testFile);
    var collector = DriverEventCollector(driver);

    sdkRoot.getChildAssumingFile('lib/core/core.dart').delete();

    var a = newFile('$testPackageLibPath/a.dart', '');
    collector.getIndex('A1', a);

    await assertEventsText(collector, r'''
[status] working
[status] idle
[future] getIndex A1
''');
  }

  test_getIndex_notAbsolutePath() async {
    var driver = driverFor(testFile);
    expect(() async {
      await driver.getIndex('not_absolute.dart');
    }, throwsArgumentError);
  }

  test_getLibraryByUri() async {
    var aUriStr = 'package:test/a.dart';
    var bUriStr = 'package:test/b.dart';

    newFile('$testPackageLibPath/a.dart', r'''
part 'b.dart';

class A {}
''');

    newFile('$testPackageLibPath/b.dart', r'''
part of 'a.dart';

class B {}
''');

    var driver = driverFor(testFile);
    var collector = DriverEventCollector(driver);

    var result = await driver.getLibraryByUri(aUriStr);
    result as LibraryElementResult;
    expect(result.element.getClass('A'), isNotNull);
    expect(result.element.getClass('B'), isNotNull);

    // It is an error to ask for a library when we know that it is a part.
    expect(
      await driver.getLibraryByUri(bUriStr),
      isA<NotLibraryButPartResult>(),
    );

    // No analysis.
    await assertEventsText(collector, r'''
[status] working
[status] idle
''');
  }

  test_getLibraryByUri_cannotResolveUri() async {
    var driver = driverFor(testFile);
    var collector = DriverEventCollector(driver);

    collector.getLibraryByUri('X', 'foo:bar');

    await assertEventsText(collector, r'''
[future] getLibraryByUri X
  CannotResolveUriResult
''');
  }

  test_getLibraryByUri_missingDartLibrary_async() async {
    var driver = driverFor(testFile);
    var collector = DriverEventCollector(driver);

    sdkRoot.getChildAssumingFile('lib/async/async.dart').delete();

    newFile('$testPackageLibPath/a.dart', '');
    collector.getLibraryByUri('A1', 'package:test/a.dart');

    await assertEventsText(collector, r'''
[status] working
[status] idle
[future] getLibraryByUri A1
  MissingSdkLibraryResult #0
    missingUri: dart:async
''');
  }

  test_getLibraryByUri_missingDartLibrary_core() async {
    var driver = driverFor(testFile);
    var collector = DriverEventCollector(driver);

    sdkRoot.getChildAssumingFile('lib/core/core.dart').delete();

    newFile('$testPackageLibPath/a.dart', '');
    collector.getLibraryByUri('A1', 'package:test/a.dart');

    await assertEventsText(collector, r'''
[status] working
[status] idle
[future] getLibraryByUri A1
  MissingSdkLibraryResult #0
    missingUri: dart:core
''');
  }

  test_getLibraryByUri_notLibrary_part() async {
    var a = newFile('$testPackageLibPath/a.dart', r'''
part of 'b.dart';
''');

    var driver = driverFor(a);
    var collector = DriverEventCollector(driver);

    var uriStr = 'package:test/a.dart';
    collector.getLibraryByUri('X', uriStr);

    await assertEventsText(collector, r'''
[future] getLibraryByUri X
  NotLibraryButPartResult
''');
  }

  test_getLibraryByUri_subsequentCallsDoesNoWork() async {
    var aUriStr = 'package:test/a.dart';
    var bUriStr = 'package:test/b.dart';

    newFile('$testPackageLibPath/a.dart', r'''
part 'b.dart';

class A {}
''');

    newFile('$testPackageLibPath/b.dart', r'''
part of 'a.dart';

class B {}
''');

    for (var run = 0; run < 5; run++) {
      var driver = driverFor(testFile);
      var collector = DriverEventCollector(driver);

      var result = await driver.getLibraryByUri(aUriStr);
      result as LibraryElementResult;
      expect(result.element.getClass('A'), isNotNull);
      expect(result.element.getClass('B'), isNotNull);

      // It is an error to ask for a library when we know that it is a part.
      expect(
        await driver.getLibraryByUri(bUriStr),
        isA<NotLibraryButPartResult>(),
      );

      if (run == 0) {
        // First `getLibraryByUri` call does actual work.
        await assertEventsText(collector, r'''
[status] working
[status] idle
''');
      } else {
        // Subsequent `getLibraryByUri` just grabs the result via rootReference
        // and thus does no actual work.
        await assertEventsText(collector, '');
      }
    }
  }

  test_getLibraryByUri_unresolvedUri() async {
    var driver = driverFor(testFile);
    var collector = DriverEventCollector(driver);

    var result = await driver.getLibraryByUri('package:foo/foo.dart');
    expect(result, isA<CannotResolveUriResult>());

    // No analysis.
    await assertEventsText(collector, '');
  }

  test_getParsedLibrary() async {
    var content = 'class A {}';
    var a = newFile('$testPackageLibPath/a.dart', content);

    var driver = driverFor(testFile);
    var result = driver.getParsedLibrary2(a);
    result as ParsedLibraryResult;
    expect(result.units, hasLength(1));
    expect(result.units[0].path, a.path);
    expect(result.units[0].content, content);
    expect(result.units[0].unit, isNotNull);
    expect(result.units[0].diagnostics, isEmpty);
  }

  test_getParsedLibrary_invalidPath_notAbsolute() async {
    var driver = driverFor(testFile);
    var result = driver.getParsedLibrary('not_absolute.dart');
    expect(result, isA<InvalidPathResult>());
  }

  test_getParsedLibrary_notLibraryButPart() async {
    var driver = driverFor(testFile);
    var a = newFile('$testPackageLibPath/a.dart', 'part of my;');
    var result = driver.getParsedLibrary2(a);
    expect(result, isA<NotLibraryButPartResult>());
  }

  test_getParsedLibraryByUri() async {
    var content = 'class A {}';
    var a = newFile('$testPackageLibPath/a.dart', content);

    var driver = driverFor(testFile);

    var uri = Uri.parse('package:test/a.dart');
    var result = driver.getParsedLibraryByUri(uri);
    result as ParsedLibraryResult;
    expect(result.units, hasLength(1));
    expect(result.units[0].uri, uri);
    expect(result.units[0].path, a.path);
    expect(result.units[0].content, content);
  }

  test_getParsedLibraryByUri_cannotResolveUri() async {
    var driver = driverFor(testFile);
    var uri = Uri.parse('foo:bar');
    expect(driver.getParsedLibraryByUri(uri), isA<CannotResolveUriResult>());
  }

  test_getParsedLibraryByUri_notLibrary_part() async {
    var a = newFile('$testPackageLibPath/a.dart', r'''
part of 'b.dart';
''');

    var driver = driverFor(a);
    var uri = Uri.parse('package:test/a.dart');
    expect(driver.getParsedLibraryByUri(uri), isA<NotLibraryButPartResult>());
  }

  test_getParsedLibraryByUri_notLibraryButPart() async {
    newFile('$testPackageLibPath/a.dart', 'part of my;');
    var driver = driverFor(testFile);
    var uri = Uri.parse('package:test/a.dart');
    var result = driver.getParsedLibraryByUri(uri);
    expect(result, isA<NotLibraryButPartResult>());
  }

  test_getParsedLibraryByUri_unresolvedUri() async {
    var driver = driverFor(testFile);
    var uri = Uri.parse('package:unknown/a.dart');
    var result = driver.getParsedLibraryByUri(uri);
    expect(result, isA<CannotResolveUriResult>());
  }

  test_getResolvedLibrary() async {
    var a = newFile('$testPackageLibPath/a.dart', r'''
class A {}
''');

    var driver = driverFor(testFile);
    var collector = DriverEventCollector(driver);

    collector.getResolvedLibrary('A1', a);
    await assertEventsText(collector, r'''
[status] working
[operation] analyzeFile
  file: /home/test/lib/a.dart
  library: /home/test/lib/a.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/a.dart
    uri: package:test/a.dart
    flags: exists isLibrary
[status] idle
[future] getResolvedLibrary A1
  ResolvedLibraryResult #1
    element: package:test/a.dart
    units
      ResolvedUnitResult #0
''');
  }

  test_getResolvedLibrary_cachePriority() async {
    var a = newFile('$testPackageLibPath/a.dart', r'''
part 'b.dart';
''');

    var b = newFile('$testPackageLibPath/b.dart', r'''
part of 'a.dart';
''');

    var driver = driverFor(testFile);
    var collector = DriverEventCollector(driver);

    driver.priorityFiles2 = [a];

    collector.getResolvedLibrary('A1', a);
    await assertEventsText(collector, r'''
[status] working
[operation] analyzeFile
  file: /home/test/lib/a.dart
  library: /home/test/lib/a.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/a.dart
    uri: package:test/a.dart
    flags: exists isLibrary
[stream]
  ResolvedUnitResult #1
    path: /home/test/lib/b.dart
    uri: package:test/b.dart
    flags: exists isPart
[status] idle
[future] getResolvedLibrary A1
  ResolvedLibraryResult #2
    element: package:test/a.dart
    units
      ResolvedUnitResult #0
      ResolvedUnitResult #1
''');

    // Ask again, the same cached instance should be returned.
    // Note, no analysis.
    // Note, the result is cached.
    collector.getResolvedLibrary('A2', a);
    await assertEventsText(collector, r'''
[future] getResolvedLibrary A2
  ResolvedLibraryResult #2
''');

    // Ask `a`, returns cached.
    // Note, no analysis.
    collector.getResolvedUnit('A3', a);
    await assertEventsText(collector, r'''
[future] getResolvedUnit A3
  ResolvedUnitResult #0
''');

    // Ask `b`, returns cached.
    // Note, no analysis.
    collector.getResolvedUnit('B1', b);
    await assertEventsText(collector, r'''
[future] getResolvedUnit B1
  ResolvedUnitResult #1
''');
  }

  test_getResolvedLibrary_missingDartLibrary_async() async {
    var driver = driverFor(testFile);
    var collector = DriverEventCollector(driver);

    sdkRoot.getChildAssumingFile('lib/async/async.dart').delete();

    var a = newFile('$testPackageLibPath/a.dart', '');
    collector.getResolvedLibrary('A1', a);

    await assertEventsText(collector, r'''
[status] working
[operation] analyzeFile
  file: /home/test/lib/a.dart
  library: /home/test/lib/a.dart
[status] idle
[future] getResolvedLibrary A1
  MissingSdkLibraryResult #0
    missingUri: dart:async
''');
  }

  test_getResolvedLibrary_missingDartLibrary_core() async {
    var driver = driverFor(testFile);
    var collector = DriverEventCollector(driver);

    sdkRoot.getChildAssumingFile('lib/core/core.dart').delete();

    var a = newFile('$testPackageLibPath/a.dart', '');
    collector.getResolvedLibrary('A1', a);

    await assertEventsText(collector, r'''
[status] working
[operation] analyzeFile
  file: /home/test/lib/a.dart
  library: /home/test/lib/a.dart
[status] idle
[future] getResolvedLibrary A1
  MissingSdkLibraryResult #0
    missingUri: dart:core
''');
  }

  test_getResolvedLibrary_notAbsolutePath() async {
    var driver = driverFor(testFile);
    var result = await driver.getResolvedLibrary('not_absolute.dart');
    expect(result, isA<InvalidPathResult>());
  }

  test_getResolvedLibrary_notLibrary_part() async {
    var a = newFile('$testPackageLibPath/a.dart', r'''
part of 'b.dart';
''');

    var driver = driverFor(a);
    var collector = DriverEventCollector(driver);

    collector.getResolvedLibrary('X', a);

    await assertEventsText(collector, r'''
[status] working
[status] idle
[future] getResolvedLibrary X
  NotLibraryButPartResult
''');
  }

  test_getResolvedLibrary_pending_changeFile() async {
    var a = newFile('$testPackageLibPath/a.dart', r'''
class A {}
''');

    var driver = driverFor(testFile);
    var collector = DriverEventCollector(driver);

    // Ask the resolved library.
    // We used to record the request with the `LibraryFileKind`.
    collector.getResolvedLibrary('A1', a);

    // ...the request is pending, notify that the file changed.
    // This forces its reading, and rebuilding its `kind`.
    // So, the old `kind` is not valid anymore.
    // This used to cause infinite processing of the request.
    // https://github.com/dart-lang/sdk/issues/54708
    driver.changeFile2(a);

    await assertEventsText(collector, r'''
[status] working
[operation] analyzeFile
  file: /home/test/lib/a.dart
  library: /home/test/lib/a.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/a.dart
    uri: package:test/a.dart
    flags: exists isLibrary
[status] idle
[future] getResolvedLibrary A1
  ResolvedLibraryResult #1
    element: package:test/a.dart
    units
      ResolvedUnitResult #0
''');
  }

  test_getResolvedLibraryByUri() async {
    newFile('$testPackageLibPath/a.dart', '');

    var driver = driverFor(testFile);
    var collector = DriverEventCollector(driver);

    var uri = Uri.parse('package:test/a.dart');
    collector.getResolvedLibraryByUri('A1', uri);

    await assertEventsText(collector, r'''
[status] working
[operation] analyzeFile
  file: /home/test/lib/a.dart
  library: /home/test/lib/a.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/a.dart
    uri: package:test/a.dart
    flags: exists isLibrary
[status] idle
[future] getResolvedLibraryByUri A1
  ResolvedLibraryResult #1
    element: package:test/a.dart
    units
      ResolvedUnitResult #0
''');
  }

  test_getResolvedLibraryByUri_cannotResolveUri() async {
    var driver = driverFor(testFile);
    var collector = DriverEventCollector(driver);

    var uri = Uri.parse('foo:bar');
    collector.getResolvedLibraryByUri('X', uri);

    await assertEventsText(collector, r'''
[future] getResolvedLibraryByUri X
  CannotResolveUriResult
''');
  }

  test_getResolvedLibraryByUri_library_pending_getResolvedUnit() async {
    var a = newFile('$testPackageLibPath/a.dart', r'''
part 'b.dart';
''');

    var b = newFile('$testPackageLibPath/b.dart', r'''
part of 'a.dart';
''');

    var driver = driverFor(a);

    var collector = DriverEventCollector(driver);
    collector.getResolvedUnit('A1', a);
    collector.getResolvedUnit('B1', b);

    var uri = Uri.parse('package:test/a.dart');
    collector.getResolvedLibraryByUri('A2', uri);

    // Note, the library is resolved only once.
    await assertEventsText(collector, r'''
[status] working
[operation] analyzeFile
  file: /home/test/lib/a.dart
  library: /home/test/lib/a.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/a.dart
    uri: package:test/a.dart
    flags: exists isLibrary
[stream]
  ResolvedUnitResult #1
    path: /home/test/lib/b.dart
    uri: package:test/b.dart
    flags: exists isPart
[status] idle
[future] getResolvedUnit A1
  ResolvedUnitResult #0
[future] getResolvedUnit B1
  ResolvedUnitResult #1
[future] getResolvedLibraryByUri A2
  ResolvedLibraryResult #2
    element: package:test/a.dart
    units
      ResolvedUnitResult #0
      ResolvedUnitResult #1
''');
  }

  test_getResolvedLibraryByUri_missingDartLibrary_async() async {
    var driver = driverFor(testFile);
    var collector = DriverEventCollector(driver);

    sdkRoot.getChildAssumingFile('lib/async/async.dart').delete();

    newFile('$testPackageLibPath/a.dart', '');
    collector.getResolvedLibraryByUri('A1', Uri.parse('package:test/a.dart'));

    await assertEventsText(collector, r'''
[status] working
[operation] analyzeFile
  file: /home/test/lib/a.dart
  library: /home/test/lib/a.dart
[status] idle
[future] getResolvedLibraryByUri A1
  MissingSdkLibraryResult #0
    missingUri: dart:async
''');
  }

  test_getResolvedLibraryByUri_missingDartLibrary_core() async {
    var driver = driverFor(testFile);
    var collector = DriverEventCollector(driver);

    sdkRoot.getChildAssumingFile('lib/core/core.dart').delete();

    newFile('$testPackageLibPath/a.dart', '');
    collector.getResolvedLibraryByUri('A1', Uri.parse('package:test/a.dart'));

    await assertEventsText(collector, r'''
[status] working
[operation] analyzeFile
  file: /home/test/lib/a.dart
  library: /home/test/lib/a.dart
[status] idle
[future] getResolvedLibraryByUri A1
  MissingSdkLibraryResult #0
    missingUri: dart:core
''');
  }

  test_getResolvedLibraryByUri_notLibrary_part() async {
    var a = newFile('$testPackageLibPath/a.dart', r'''
part of 'b.dart';
''');

    var driver = driverFor(a);
    var collector = DriverEventCollector(driver);

    var uri = Uri.parse('package:test/a.dart');
    collector.getResolvedLibraryByUri('X', uri);

    await assertEventsText(collector, r'''
[status] working
[status] idle
[future] getResolvedLibraryByUri X
  NotLibraryButPartResult
''');
  }

  test_getResolvedLibraryByUri_notLibraryButPart() async {
    newFile('$testPackageLibPath/a.dart', 'part of my;');

    var driver = driverFor(testFile);
    var collector = DriverEventCollector(driver);

    var uri = Uri.parse('package:test/a.dart');
    collector.getResolvedLibraryByUri('A1', uri);

    await assertEventsText(collector, r'''
[status] working
[status] idle
[future] getResolvedLibraryByUri A1
  NotLibraryButPartResult
''');
  }

  test_getResolvedLibraryByUri_unresolvedUri() async {
    var driver = driverFor(testFile);
    var collector = DriverEventCollector(driver);

    var uri = Uri.parse('package:unknown/a.dart');
    collector.getResolvedLibraryByUri('A1', uri);

    await assertEventsText(collector, r'''
[future] getResolvedLibraryByUri A1
  CannotResolveUriResult
''');
  }

  test_getResolvedUnit() async {
    var a = newFile('$testPackageLibPath/a.dart', '');

    var driver = driverFor(testFile);
    var collector = DriverEventCollector(driver);

    collector.getResolvedUnit('A1', a);
    await assertEventsText(collector, r'''
[status] working
[operation] analyzeFile
  file: /home/test/lib/a.dart
  library: /home/test/lib/a.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/a.dart
    uri: package:test/a.dart
    flags: exists isLibrary
[status] idle
[future] getResolvedUnit A1
  ResolvedUnitResult #0
''');
  }

  test_getResolvedUnit_added() async {
    var a = newFile('$testPackageLibPath/a.dart', '');

    var driver = driverFor(testFile);
    var collector = DriverEventCollector(driver);

    driver.addFile2(a);
    collector.getResolvedUnit('A1', a);

    // Note, no separate `ErrorsResult`.
    await assertEventsText(collector, r'''
[status] working
[operation] analyzeFile
  file: /home/test/lib/a.dart
  library: /home/test/lib/a.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/a.dart
    uri: package:test/a.dart
    flags: exists isLibrary
[status] idle
[future] getResolvedUnit A1
  ResolvedUnitResult #0
''');
  }

  test_getResolvedUnit_importLibrary_thenRemoveIt() async {
    var a = newFile('$testPackageLibPath/a.dart', r'''
class A {}''');

    var b = newFile('$testPackageLibPath/b.dart', r'''
import 'a.dart';
class B extends A {}
''');

    var driver = driverFor(testFile);
    var collector = DriverEventCollector(driver);

    driver.addFile2(a);
    driver.addFile2(b);

    // No errors in `a` or `b`.
    collector.getResolvedUnit('B1', b);
    await assertEventsText(collector, r'''
[status] working
[operation] analyzeFile
  file: /home/test/lib/b.dart
  library: /home/test/lib/b.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/b.dart
    uri: package:test/b.dart
    flags: exists isLibrary
[operation] analyzeFile
  file: /home/test/lib/a.dart
  library: /home/test/lib/a.dart
[stream]
  ResolvedUnitResult #1
    path: /home/test/lib/a.dart
    uri: package:test/a.dart
    flags: exists isLibrary
[status] idle
[future] getResolvedUnit B1
  ResolvedUnitResult #0
''');

    // Remove `a` and reanalyze.
    deleteFile(a.path);
    driver.removeFile2(a);

    // The unresolved URI error must be reported.
    collector.getResolvedUnit('B2', b);
    await assertEventsText(collector, r'''
[status] working
[operation] analyzeFile
  file: /home/test/lib/b.dart
  library: /home/test/lib/b.dart
[operation] reuseLinkedBundle SDK
[stream]
  ResolvedUnitResult #2
    path: /home/test/lib/b.dart
    uri: package:test/b.dart
    flags: exists isLibrary
    errors
      7 +8 URI_DOES_NOT_EXIST
      33 +1 EXTENDS_NON_CLASS
[status] idle
[future] getResolvedUnit B2
  ResolvedUnitResult #2
''');

    // Restore `a`.
    newFile(a.path, 'class A {}');
    driver.addFile2(a);

    // No errors in `b` again.
    collector.getResolvedUnit('B2', b);
    await assertEventsText(collector, r'''
[status] working
[operation] analyzeFile
  file: /home/test/lib/b.dart
  library: /home/test/lib/b.dart
[operation] reuseLinkedBundle
  package:test/a.dart
[operation] reuseLinkedBundle
  package:test/b.dart
[stream]
  ResolvedUnitResult #3
    path: /home/test/lib/b.dart
    uri: package:test/b.dart
    flags: exists isLibrary
[operation] getErrorsFromBytes
  file: /home/test/lib/a.dart
  library: /home/test/lib/a.dart
[stream]
  ErrorsResult #4
    path: /home/test/lib/a.dart
    uri: package:test/a.dart
    flags: isLibrary
[status] idle
[future] getResolvedUnit B2
  ResolvedUnitResult #3
''');
  }

  test_getResolvedUnit_library_added_part() async {
    var a = newFile('$testPackageLibPath/a.dart', r'''
part 'b.dart';
''');

    var b = newFile('$testPackageLibPath/b.dart', r'''
part of 'a.dart';
''');

    var driver = driverFor(testFile);
    var collector = DriverEventCollector(driver);

    driver.addFile2(a);
    driver.addFile2(b);
    collector.getResolvedUnit('A1', a);

    // Note, the library is resolved only once.
    // Note, no separate `ErrorsResult` for `a` or `b`.
    await assertEventsText(collector, r'''
[status] working
[operation] analyzeFile
  file: /home/test/lib/a.dart
  library: /home/test/lib/a.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/a.dart
    uri: package:test/a.dart
    flags: exists isLibrary
[stream]
  ResolvedUnitResult #1
    path: /home/test/lib/b.dart
    uri: package:test/b.dart
    flags: exists isPart
[status] idle
[future] getResolvedUnit A1
  ResolvedUnitResult #0
''');
  }

  test_getResolvedUnit_library_part() async {
    var a = newFile('$testPackageLibPath/a.dart', r'''
part 'b.dart';
''');

    var b = newFile('$testPackageLibPath/b.dart', r'''
part of 'a.dart';
''');

    var driver = driverFor(testFile);
    var collector = DriverEventCollector(driver);

    collector.getResolvedUnit('A1', a);
    collector.getResolvedUnit('B1', b);

    // Note, the library is resolved only once.
    await assertEventsText(collector, r'''
[status] working
[operation] analyzeFile
  file: /home/test/lib/a.dart
  library: /home/test/lib/a.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/a.dart
    uri: package:test/a.dart
    flags: exists isLibrary
[stream]
  ResolvedUnitResult #1
    path: /home/test/lib/b.dart
    uri: package:test/b.dart
    flags: exists isPart
[status] idle
[future] getResolvedUnit A1
  ResolvedUnitResult #0
[future] getResolvedUnit B1
  ResolvedUnitResult #1
''');
  }

  test_getResolvedUnit_library_pending_getErrors_part() async {
    var a = newFile('$testPackageLibPath/a.dart', r'''
part 'b.dart';
''');

    var b = newFile('$testPackageLibPath/b.dart', r'''
part of 'a.dart';
''');

    var driver = driverFor(testFile);
    var collector = DriverEventCollector(driver);

    collector.getErrors('B1', b);
    collector.getResolvedUnit('A1', a);

    // Note, the library is resolved only once.
    await assertEventsText(collector, r'''
[status] working
[operation] analyzeFile
  file: /home/test/lib/a.dart
  library: /home/test/lib/a.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/a.dart
    uri: package:test/a.dart
    flags: exists isLibrary
[stream]
  ResolvedUnitResult #1
    path: /home/test/lib/b.dart
    uri: package:test/b.dart
    flags: exists isPart
[status] idle
[future] getErrors B1
  ErrorsResult #2
    path: /home/test/lib/b.dart
    uri: package:test/b.dart
    flags: isPart
[future] getResolvedUnit A1
  ResolvedUnitResult #0
''');
  }

  test_getResolvedUnit_missingDartLibrary_async() async {
    var driver = driverFor(testFile);
    var collector = DriverEventCollector(driver);

    sdkRoot.getChildAssumingFile('lib/async/async.dart').delete();

    var a = newFile('$testPackageLibPath/a.dart', '');
    collector.getResolvedUnit('A1', a);

    await assertEventsText(collector, r'''
[status] working
[operation] analyzeFile
  file: /home/test/lib/a.dart
  library: /home/test/lib/a.dart
[status] idle
[future] getResolvedUnit A1
  MissingSdkLibraryResult #0
    missingUri: dart:async
''');
  }

  test_getResolvedUnit_missingDartLibrary_core() async {
    var driver = driverFor(testFile);
    var collector = DriverEventCollector(driver);

    sdkRoot.getChildAssumingFile('lib/core/core.dart').delete();

    var a = newFile('$testPackageLibPath/a.dart', '');
    collector.getResolvedUnit('A1', a);

    await assertEventsText(collector, r'''
[status] working
[operation] analyzeFile
  file: /home/test/lib/a.dart
  library: /home/test/lib/a.dart
[status] idle
[future] getResolvedUnit A1
  MissingSdkLibraryResult #0
    missingUri: dart:core
''');
  }

  test_getResolvedUnit_notDartFile() async {
    var a = newFile('$testPackageLibPath/a.txt', r'''
final foo = 0;
''');

    var driver = driverFor(testFile);
    var collector = DriverEventCollector(driver);

    configuration.libraryConfiguration.unitConfiguration.variableTypesSelector =
        (result) {
          return [result.findElement2.topVar('foo')];
        };

    // The extension of the file does not matter.
    // If asked, we analyze it as Dart.
    collector.getResolvedUnit('A1', a);
    await assertEventsText(collector, r'''
[status] working
[operation] analyzeFile
  file: /home/test/lib/a.txt
  library: /home/test/lib/a.txt
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/a.txt
    uri: package:test/a.txt
    flags: exists isLibrary
    selectedVariableTypes
      foo: int
[status] idle
[future] getResolvedUnit A1
  ResolvedUnitResult #0
''');
  }

  test_getResolvedUnit_part_doesNotExist_lints() async {
    newFile('$testPackageRootPath/analysis_options.yaml', r'''
linter:
  rules:
    - omit_local_variable_types
''');

    await assertErrorsInCode(
      r'''
library my.lib;
part 'a.dart';
''',
      [error(CompileTimeErrorCode.uriDoesNotExist, 21, 8)],
    );
  }

  test_getResolvedUnit_part_empty_lints() async {
    newFile('$testPackageRootPath/analysis_options.yaml', r'''
linter:
  rules:
    - omit_local_variable_types
''');

    newFile('$testPackageLibPath/a.dart', '');

    await assertErrorsInCode(
      r'''
library my.lib;
part 'a.dart';
''',
      [error(CompileTimeErrorCode.partOfNonPart, 21, 8)],
    );
  }

  test_getResolvedUnit_part_hasPartOfName_notThisLibrary_lints() async {
    newFile('$testPackageRootPath/analysis_options.yaml', r'''
linter:
  rules:
    - omit_local_variable_types
''');

    newFile('$testPackageLibPath/a.dart', r'''
part of other.lib;
''');

    await assertErrorsInCode(
      r'''
library my.lib;
part 'a.dart';
''',
      [error(CompileTimeErrorCode.partOfDifferentLibrary, 21, 8)],
    );
  }

  test_getResolvedUnit_part_hasPartOfUri_notThisLibrary_lints() async {
    newFile('$testPackageRootPath/analysis_options.yaml', r'''
linter:
  rules:
    - omit_local_variable_types
''');

    newFile('$testPackageLibPath/a.dart', r'''
part of 'not_test.dart';
''');

    await assertErrorsInCode(
      r'''
library my.lib;
part 'a.dart';
''',
      [error(CompileTimeErrorCode.partOfDifferentLibrary, 21, 8)],
    );
  }

  test_getResolvedUnit_part_library() async {
    var a = newFile('$testPackageLibPath/a.dart', r'''
part 'b.dart';
''');

    var b = newFile('$testPackageLibPath/b.dart', r'''
part of 'a.dart';
''');

    var driver = driverFor(testFile);
    var collector = DriverEventCollector(driver);

    collector.getResolvedUnit('B1', b);
    collector.getResolvedUnit('A1', a);

    // Note, the library is resolved only once.
    await assertEventsText(collector, r'''
[status] working
[operation] analyzeFile
  file: /home/test/lib/b.dart
  library: /home/test/lib/a.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/a.dart
    uri: package:test/a.dart
    flags: exists isLibrary
[stream]
  ResolvedUnitResult #1
    path: /home/test/lib/b.dart
    uri: package:test/b.dart
    flags: exists isPart
[status] idle
[future] getResolvedUnit B1
  ResolvedUnitResult #1
[future] getResolvedUnit A1
  ResolvedUnitResult #0
''');
  }

  test_getResolvedUnit_part_pending_getErrors_library() async {
    var a = newFile('$testPackageLibPath/a.dart', r'''
part 'b.dart';
''');

    var b = newFile('$testPackageLibPath/b.dart', r'''
part of 'a.dart';
''');

    var driver = driverFor(testFile);
    var collector = DriverEventCollector(driver);

    collector.getErrors('A1', a);
    collector.getResolvedUnit('B1', b);

    // Note, the library is resolved only once.
    await assertEventsText(collector, r'''
[status] working
[operation] analyzeFile
  file: /home/test/lib/b.dart
  library: /home/test/lib/a.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/a.dart
    uri: package:test/a.dart
    flags: exists isLibrary
[stream]
  ResolvedUnitResult #1
    path: /home/test/lib/b.dart
    uri: package:test/b.dart
    flags: exists isPart
[status] idle
[future] getErrors A1
  ErrorsResult #2
    path: /home/test/lib/a.dart
    uri: package:test/a.dart
    flags: isLibrary
[future] getResolvedUnit B1
  ResolvedUnitResult #1
''');
  }

  test_getResolvedUnit_pending_getErrors() async {
    var a = newFile('$testPackageLibPath/a.dart', '');

    var driver = driverFor(testFile);
    var collector = DriverEventCollector(driver);

    collector.getResolvedUnit('A1', a);
    collector.getErrors('A2', a);

    // Note, the library is resolved only once.
    await assertEventsText(collector, r'''
[status] working
[operation] analyzeFile
  file: /home/test/lib/a.dart
  library: /home/test/lib/a.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/a.dart
    uri: package:test/a.dart
    flags: exists isLibrary
[status] idle
[future] getResolvedUnit A1
  ResolvedUnitResult #0
[future] getErrors A2
  ErrorsResult #1
    path: /home/test/lib/a.dart
    uri: package:test/a.dart
    flags: isLibrary
''');
  }

  test_getResolvedUnit_pending_getErrors2() async {
    var a = newFile('$testPackageLibPath/a.dart', '');

    var driver = driverFor(testFile);
    var collector = DriverEventCollector(driver);

    collector.getErrors('A1', a);
    collector.getResolvedUnit('A2', a);

    // Note, the library is resolved only once.
    await assertEventsText(collector, r'''
[status] working
[operation] analyzeFile
  file: /home/test/lib/a.dart
  library: /home/test/lib/a.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/a.dart
    uri: package:test/a.dart
    flags: exists isLibrary
[status] idle
[future] getErrors A1
  ErrorsResult #1
    path: /home/test/lib/a.dart
    uri: package:test/a.dart
    flags: isLibrary
[future] getResolvedUnit A2
  ResolvedUnitResult #0
''');
  }

  test_getResolvedUnit_pending_getIndex() async {
    var a = newFile('$testPackageLibPath/a.dart', '');

    var driver = driverFor(testFile);
    var collector = DriverEventCollector(driver);

    collector.getIndex('A1', a);
    collector.getResolvedUnit('A2', a);

    // Note, no separate `getIndex` result.
    await assertEventsText(collector, r'''
[status] working
[operation] analyzeFile
  file: /home/test/lib/a.dart
  library: /home/test/lib/a.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/a.dart
    uri: package:test/a.dart
    flags: exists isLibrary
[status] idle
[future] getIndex A1
  strings
    --nullString--
[future] getResolvedUnit A2
  ResolvedUnitResult #0
''');
  }

  test_getResolvedUnit_thenRemove() async {
    var a = newFile('$testPackageLibPath/a.dart', '');

    var driver = driverFor(testFile);
    var collector = DriverEventCollector(driver);

    // Schedule resolved unit computation.
    collector.getResolvedUnit('A1', a);

    // ...and remove the file.
    driver.removeFile2(a);

    // The future with the result still completes.
    await assertEventsText(collector, r'''
[status] working
[operation] analyzeFile
  file: /home/test/lib/a.dart
  library: /home/test/lib/a.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/a.dart
    uri: package:test/a.dart
    flags: exists isLibrary
[status] idle
[future] getResolvedUnit A1
  ResolvedUnitResult #0
''');
  }

  test_getResolvedUnit_twoPendingFutures() async {
    var a = newFile('$testPackageLibPath/a.dart', '');

    var driver = driverFor(testFile);
    var collector = DriverEventCollector(driver);

    // Ask the same file twice.
    collector.getResolvedUnit('A1', a);
    collector.getResolvedUnit('A2', a);

    // Both futures complete.
    await assertEventsText(collector, r'''
[status] working
[operation] analyzeFile
  file: /home/test/lib/a.dart
  library: /home/test/lib/a.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/a.dart
    uri: package:test/a.dart
    flags: exists isLibrary
[status] idle
[future] getResolvedUnit A1
  ResolvedUnitResult #0
[future] getResolvedUnit A2
  ResolvedUnitResult #0
''');
  }

  test_getUnitElement() async {
    var a = newFile('$testPackageLibPath/a.dart', r'''
void foo() {}
void bar() {}
''');

    var driver = driverFor(testFile);
    var collector = DriverEventCollector(driver);

    configuration.unitElementConfiguration.elementSelector = (unitFragment) {
      return unitFragment.functions
          .map((fragment) => fragment.element)
          .toList();
    };

    collector.getUnitElement('A1', a);
    await assertEventsText(collector, r'''
[status] working
[status] idle
[future] getUnitElement A1
  path: /home/test/lib/a.dart
  uri: package:test/a.dart
  flags: isLibrary
  enclosing: <null>
  selectedElements
    package:test/a.dart::@function::foo
    package:test/a.dart::@function::bar
''');
  }

  test_getUnitElement_doesNotExist_afterResynthesized() async {
    var a = newFile('$testPackageLibPath/a.dart', r'''
import 'package:test/b.dart';
''');

    var driver = driverFor(testFile);
    var collector = DriverEventCollector(driver);

    collector.getResolvedLibrary('A1', a);
    await assertEventsText(collector, r'''
[status] working
[operation] analyzeFile
  file: /home/test/lib/a.dart
  library: /home/test/lib/a.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/a.dart
    uri: package:test/a.dart
    flags: exists isLibrary
    errors
      7 +21 URI_DOES_NOT_EXIST
[status] idle
[future] getResolvedLibrary A1
  ResolvedLibraryResult #1
    element: package:test/a.dart
    units
      ResolvedUnitResult #0
''');

    collector.getUnitElement('A2', a);
    await assertEventsText(collector, r'''
[status] working
[status] idle
[future] getUnitElement A2
  path: /home/test/lib/a.dart
  uri: package:test/a.dart
  flags: isLibrary
  enclosing: <null>
''');
  }

  test_getUnitElement_invalidPath_notAbsolute() async {
    var driver = driverFor(testFile);
    var result = await driver.getUnitElement('not_absolute.dart');
    expect(result, isA<InvalidPathResult>());
  }

  test_getUnitElement_missingDartLibrary_async() async {
    var driver = driverFor(testFile);
    var collector = DriverEventCollector(driver);

    sdkRoot.getChildAssumingFile('lib/async/async.dart').delete();

    var a = newFile('$testPackageLibPath/a.dart', '');
    collector.getUnitElement('A1', a);

    await assertEventsText(collector, r'''
[status] working
[status] idle
[future] getUnitElement A1
  MissingSdkLibraryResult #0
    missingUri: dart:async
''');
  }

  test_getUnitElement_missingDartLibrary_core() async {
    var driver = driverFor(testFile);
    var collector = DriverEventCollector(driver);

    sdkRoot.getChildAssumingFile('lib/core/core.dart').delete();

    var a = newFile('$testPackageLibPath/a.dart', '');
    collector.getUnitElement('A1', a);

    await assertEventsText(collector, r'''
[status] working
[status] idle
[future] getUnitElement A1
  MissingSdkLibraryResult #0
    missingUri: dart:core
''');
  }

  test_hermetic_modifyLibraryFile_resolvePart() async {
    var a = newFile('$testPackageLibPath/a.dart', r'''
part 'b.dart';
final A = 0;
''');

    var b = newFile('$testPackageLibPath/b.dart', r'''
part of 'a.dart';
final B = A;
''');

    var driver = driverFor(testFile);
    var collector = DriverEventCollector(driver);

    configuration.libraryConfiguration.unitConfiguration.variableTypesSelector =
        (result) {
          switch (result.uriStr) {
            case 'package:test/b.dart':
              return [result.findElement2.topVar('B')];
            default:
              return [];
          }
        };

    collector.getResolvedUnit('B1', b);
    await assertEventsText(collector, r'''
[status] working
[operation] analyzeFile
  file: /home/test/lib/b.dart
  library: /home/test/lib/a.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/a.dart
    uri: package:test/a.dart
    flags: exists isLibrary
[stream]
  ResolvedUnitResult #1
    path: /home/test/lib/b.dart
    uri: package:test/b.dart
    flags: exists isPart
    selectedVariableTypes
      B: int
[status] idle
[future] getResolvedUnit B1
  ResolvedUnitResult #1
''');

    // Modify the library, but don't notify the driver.
    // The driver should use the previous library content and elements.
    modifyFile2(a, r'''
part 'b.dart';
final A = 1.2;
''');

    // Note, still `B: int`, not `B: double` yet.
    collector.getResolvedUnit('B2', b);
    await assertEventsText(collector, r'''
[status] working
[operation] analyzeFile
  file: /home/test/lib/b.dart
  library: /home/test/lib/a.dart
[stream]
  ResolvedUnitResult #2
    path: /home/test/lib/a.dart
    uri: package:test/a.dart
    flags: exists isLibrary
[stream]
  ResolvedUnitResult #3
    path: /home/test/lib/b.dart
    uri: package:test/b.dart
    flags: exists isPart
    selectedVariableTypes
      B: int
[status] idle
[future] getResolvedUnit B2
  ResolvedUnitResult #3
''');
  }

  test_importOfNonLibrary_part_afterLibrary() async {
    var a = newFile('$testPackageLibPath/a.dart', '''
part 'b.dart';
''');

    newFile('$testPackageLibPath/b.dart', '''
part of 'a.dart';
class B {}
''');

    var c = newFile('$testPackageLibPath/c.dart', '''
import 'b.dart';
''');

    var driver = driverFor(testFile);

    // This ensures that `a` linked library is cached.
    await driver.getResolvedUnit2(a);

    // Should not fail because of considering `b` part as `a` library.
    await driver.getResolvedUnit2(c);
  }

  test_knownFiles() async {
    var a = newFile('$testPackageLibPath/a.dart', r'''
// ignore:unused_import
import 'b.dart';
''');

    var b = newFile('$testPackageLibPath/b.dart', r'''
''');

    var c = newFile('$testPackageLibPath/c.dart', r'''
''');

    var driver = driverFor(testFile);

    driver.addFile2(a);
    driver.addFile2(c);
    await pumpEventQueue(times: 5000);
    expect(driver.knownFiles.resources, contains(a));
    expect(driver.knownFiles.resources, contains(b));
    expect(driver.knownFiles.resources, contains(c));

    // Remove `a` and analyze.
    // Both `a` and `b` are not known now.
    driver.removeFile2(a);
    await pumpEventQueue(times: 5000);
    expect(driver.knownFiles.resources, isNot(contains(a)));
    expect(driver.knownFiles.resources, isNot(contains(b)));
    expect(driver.knownFiles.resources, contains(c));
  }

  test_knownFiles_beforeAnalysis() async {
    var a = newFile('$testPackageLibPath/a.dart', '');
    var driver = driverFor(testFile);

    // `a` is added, but not processed yet.
    // So, the set of known files is empty yet.
    driver.addFile2(a);
    expect(driver.knownFiles, isEmpty);
  }

  test_linkedBundleProvider_changeFile() async {
    var a = newFile('$testPackageLibPath/a.dart', 'var V = 1;');

    var driver = driverFor(a);
    var collector = DriverEventCollector(driver);

    driver.addFile2(a);
    driver.priorityFiles2 = [a];

    configuration.libraryConfiguration.unitConfiguration.variableTypesSelector =
        (result) {
          switch (result.uriStr) {
            case 'package:test/a.dart':
              return [result.findElement2.topVar('V')];
            default:
              return [];
          }
        };

    // Initial analysis.
    await assertEventsText(collector, r'''
[status] working
[operation] analyzeFile
  file: /home/test/lib/a.dart
  library: /home/test/lib/a.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/a.dart
    uri: package:test/a.dart
    flags: exists isLibrary
    selectedVariableTypes
      V: int
[status] idle
''');

    // When no fine-grained dependencies, we don't cache bundles.
    // So, [LinkedBundleProvider] is empty, and not printed.
    assertDriverStateString(testFile, r'''
files
  /home/test/lib/a.dart
    uri: package:test/a.dart
    current
      id: file_0
      kind: library_0
        libraryImports
          library_1 dart:core synthetic
        fileKinds: library_0
        cycle_0
          dependencies: dart:core
          libraries: library_0
          apiSignature_0
      unlinkedKey: k00
libraryCycles
  /home/test/lib/a.dart
    current: cycle_0
      key: k01
    get: []
    put: [k01]
elementFactory
  hasElement
    package:test/a.dart
''');

    // Update the file, but don't notify the driver.
    // No new results.
    modifyFile2(a, 'var V = 1.2;');
    await assertEventsText(collector, r'''
''');

    // Notify the driver about the change.
    // We get a new result.
    driver.changeFile2(a);
    await assertEventsText(collector, r'''
[status] working
[operation] analyzeFile
  file: /home/test/lib/a.dart
  library: /home/test/lib/a.dart
[stream]
  ResolvedUnitResult #1
    path: /home/test/lib/a.dart
    uri: package:test/a.dart
    flags: exists isLibrary
    selectedVariableTypes
      V: double
[status] idle
''');

    assertDriverStateString(testFile, r'''
files
  /home/test/lib/a.dart
    uri: package:test/a.dart
    current
      id: file_0
      kind: library_6
        libraryImports
          library_1 dart:core synthetic
        fileKinds: library_6
        cycle_2
          dependencies: dart:core
          libraries: library_6
          apiSignature_1
      unlinkedKey: k02
libraryCycles
  /home/test/lib/a.dart
    current: cycle_2
      key: k03
    get: []
    put: [k01, k03]
elementFactory
  hasElement
    package:test/a.dart
''');
  }

  test_parseFileSync_appliesPendingFileChanges() async {
    var initialContent = 'initial content';
    var updatedContent = 'updated content';
    var a = newFile('$testPackageLibPath/a.dart', initialContent);

    // Check initial content.
    var driver = driverFor(testFile);
    var parsed = driver.parseFileSync(a.path) as ParsedUnitResult;
    expect(parsed.content, initialContent);

    // Update the file.
    newFile(a.path, updatedContent);
    driver.changeFile(a.path);

    // Expect parseFileSync to return the updated content.
    parsed = driver.parseFileSync(a.path) as ParsedUnitResult;
    expect(parsed.content, updatedContent);
  }

  test_parseFileSync_changedFile() async {
    var a = newFile('$testPackageLibPath/a.dart', r'''
''');

    var b = newFile('$testPackageLibPath/b.dart', r'''
// ignore:unused_import
import 'a.dart';
void f(A a) {}
''');

    var driver = driverFor(testFile);
    var collector = DriverEventCollector(driver);

    // Ensure that [a] library cycle is loaded.
    // So, `a` is in the library context.
    collector.getResolvedUnit('A1', a);
    await assertEventsText(collector, r'''
[status] working
[operation] analyzeFile
  file: /home/test/lib/a.dart
  library: /home/test/lib/a.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/a.dart
    uri: package:test/a.dart
    flags: exists isLibrary
[status] idle
[future] getResolvedUnit A1
  ResolvedUnitResult #0
''');

    // Update the file, changing its API signature.
    // Note that we don't call `changeFile`.
    modifyFile2(a, r'''
class A {}
''');

    // Parse the file.
    // We have not called `changeFile(a)`, so we should not read the file.
    // Moreover, doing this will create a new library cycle [a].
    // Library cycles are compared by their identity, so we would try to
    // reload linked summary for [a], and crash.
    {
      var parseResult = driver.parseFileSync2(a) as ParsedUnitResult;
      expect(parseResult.unit.declarations, isEmpty);
    }

    // We have not read `a`, so `A` is still not declared.
    collector.getResolvedUnit('B1', b);
    await assertEventsText(collector, r'''
[status] working
[operation] analyzeFile
  file: /home/test/lib/b.dart
  library: /home/test/lib/b.dart
[stream]
  ResolvedUnitResult #1
    path: /home/test/lib/b.dart
    uri: package:test/b.dart
    flags: exists isLibrary
    errors
      48 +1 UNDEFINED_CLASS
[status] idle
[future] getResolvedUnit B1
  ResolvedUnitResult #1
''');

    // Notify the driver that `a` was changed.
    driver.changeFile2(a);

    // The pending change to `a` declares `A`.
    // So, `b` does not have errors anymore.
    collector.getResolvedUnit('B2', b);
    await assertEventsText(collector, r'''
[status] working
[operation] analyzeFile
  file: /home/test/lib/b.dart
  library: /home/test/lib/b.dart
[stream]
  ResolvedUnitResult #2
    path: /home/test/lib/b.dart
    uri: package:test/b.dart
    flags: exists isLibrary
[status] idle
[future] getResolvedUnit B2
  ResolvedUnitResult #2
''');

    // We apply pending changes while handling request.
    // So, now `class A {}` is declared.
    {
      var result = driver.parseFileSync2(a) as ParsedUnitResult;
      assertParsedNodeText(result.unit, r'''
CompilationUnit
  declarations
    ClassDeclaration
      classKeyword: class
      name: A
      leftBracket: {
      rightBracket: }
''');
    }
  }

  test_parseFileSync_doesNotReadImportedFiles() async {
    newFile('$testPackageLibPath/a.dart', r'''
''');

    var b = newFile('$testPackageLibPath/b.dart', r'''
// ignore:unused_import
import 'a.dart';
''');

    var driver = driverFor(testFile);
    expect(driver.knownFiles, isEmpty);

    // Don't read `a` when parse.
    driver.parseFileSync2(b);
    expect(driver.knownFiles.resources, unorderedEquals([b]));

    // Still don't read `a.dart` when parse the second time.
    driver.parseFileSync2(b);
    expect(driver.knownFiles.resources, unorderedEquals([b]));
  }

  test_parseFileSync_notAbsolutePath() async {
    var driver = driverFor(testFile);
    var result = driver.parseFileSync('not_absolute.dart');
    expect(result, isA<InvalidPathResult>());
  }

  test_parseFileSync_notDart() async {
    var a = newFile('$testPackageLibPath/a.txt', r'''
class A {}
''');

    var driver = driverFor(testFile);

    var result = driver.parseFileSync2(a) as ParsedUnitResult;
    assertParsedNodeText(result.unit, r'''
CompilationUnit
  declarations
    ClassDeclaration
      classKeyword: class
      name: A
      leftBracket: {
      rightBracket: }
''');

    expect(driver.knownFiles.resources, unorderedEquals([a]));
  }

  test_partOfName_getErrors_afterLibrary() async {
    // Note, we put the library into a different directory.
    // Otherwise we will discover it.
    var a = newFile('$testPackageLibPath/hidden/a.dart', r'''
// @dart = 3.4
// preEnhancedParts
library a;
part '../b.dart';
class A {}
''');

    var b = newFile('$testPackageLibPath/b.dart', r'''
// @dart = 3.4
// preEnhancedParts
part of a;
final a = A();
''');

    var driver = driverFor(testFile);
    var collector = DriverEventCollector(driver);

    // Process `a` so that we know that it's a library for `b`.
    collector.getErrors('A1', a);
    await assertEventsText(collector, r'''
[status] working
[operation] analyzeFile
  file: /home/test/lib/hidden/a.dart
  library: /home/test/lib/hidden/a.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/hidden/a.dart
    uri: package:test/hidden/a.dart
    flags: exists isLibrary
[stream]
  ResolvedUnitResult #1
    path: /home/test/lib/b.dart
    uri: package:test/b.dart
    flags: exists isPart
[status] idle
[future] getErrors A1
  ErrorsResult #2
    path: /home/test/lib/hidden/a.dart
    uri: package:test/hidden/a.dart
    flags: isLibrary
''');

    // We return cached errors.
    // TODO(scheglov): don't switch to analysis?
    collector.getErrors('B1', b);
    await assertEventsText(collector, r'''
[status] working
[operation] getErrorsFromBytes
  file: /home/test/lib/b.dart
  library: /home/test/lib/hidden/a.dart
[status] idle
[future] getErrors B1
  ErrorsResult #3
    path: /home/test/lib/b.dart
    uri: package:test/b.dart
    flags: isPart
''');
  }

  test_partOfName_getErrors_beforeLibrary_addedFiles() async {
    var a = newFile('$testPackageLibPath/hidden/a.dart', r'''
// @dart = 3.4
// preEnhancedParts
library a;
part '../b.dart';
class A {}
''');

    var b = newFile('$testPackageLibPath/b.dart', r'''
// preEnhancedParts
// @dart = 3.4
part of a;
final a = A();
''');

    var driver = driverFor(testFile);
    var collector = DriverEventCollector(driver);

    // We discover all added files are maybe libraries.
    driver.addFile2(a);
    driver.addFile2(b);

    // Because `a` is added, we know how to analyze `b`.
    // So, it has no errors.
    collector.getErrors('B1', b);
    await assertEventsText(collector, r'''
[status] working
[operation] analyzeFile
  file: /home/test/lib/b.dart
  library: /home/test/lib/hidden/a.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/hidden/a.dart
    uri: package:test/hidden/a.dart
    flags: exists isLibrary
[stream]
  ResolvedUnitResult #1
    path: /home/test/lib/b.dart
    uri: package:test/b.dart
    flags: exists isPart
[status] idle
[future] getErrors B1
  ErrorsResult #2
    path: /home/test/lib/b.dart
    uri: package:test/b.dart
    flags: isPart
''');
  }

  test_partOfName_getErrors_beforeLibrary_discovered() async {
    newFile('$testPackageLibPath/a.dart', r'''
// @dart = 3.4
// preEnhancedParts
library a;
part 'b.dart';
class A {}
''');

    var b = newFile('$testPackageLibPath/b.dart', r'''
// @dart = 3.4
// preEnhancedParts
part of a;
final a = new A();
''');

    var driver = driverFor(testFile);
    var collector = DriverEventCollector(driver);

    // We discover sibling files as libraries.
    // So, we know that `a` is the library of `b`.
    // So, no errors.
    collector.getErrors('B1', b);
    await assertEventsText(collector, r'''
[status] working
[operation] analyzeFile
  file: /home/test/lib/b.dart
  library: /home/test/lib/a.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/a.dart
    uri: package:test/a.dart
    flags: exists isLibrary
[stream]
  ResolvedUnitResult #1
    path: /home/test/lib/b.dart
    uri: package:test/b.dart
    flags: exists isPart
[status] idle
[future] getErrors B1
  ErrorsResult #2
    path: /home/test/lib/b.dart
    uri: package:test/b.dart
    flags: isPart
''');
  }

  test_partOfName_getErrors_beforeLibrary_notDiscovered() async {
    newFile('$testPackageLibPath/hidden/a.dart', r'''
// @dart = 3.4
// preEnhancedParts
library a;
part '../b.dart';
class A {}
''');

    var b = newFile('$testPackageLibPath/b.dart', r'''
// @dart = 3.4
// preEnhancedParts
part of a;
final a = new A();
''');

    var driver = driverFor(testFile);
    var collector = DriverEventCollector(driver);

    // We don't know that `a` is the library of `b`.
    // So, we treat it as its own library, has errors.
    collector.getErrors('B1', b);
    await assertEventsText(collector, r'''
[status] working
[operation] analyzeFile
  file: /home/test/lib/b.dart
  library: /home/test/lib/b.dart
[operation] reuseLinkedBundle
  package:test/b.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/b.dart
    uri: package:test/b.dart
    flags: exists isPart
    errors
      60 +1 CREATION_WITH_NON_TYPE
[status] idle
[future] getErrors B1
  ErrorsResult #1
    path: /home/test/lib/b.dart
    uri: package:test/b.dart
    flags: isPart
    errors
      60 +1 CREATION_WITH_NON_TYPE
''');
  }

  test_partOfName_getResolvedUnit_afterLibrary() async {
    var a = newFile('$testPackageLibPath/hidden/a.dart', r'''
// @dart = 3.4
// preEnhancedParts
library a;
part '../b.dart';
class A {}
''');

    var b = newFile('$testPackageLibPath/b.dart', r'''
// @dart = 3.4
// preEnhancedParts
part of a;
final a = new A();
''');

    var driver = driverFor(testFile);
    var collector = DriverEventCollector(driver);

    // Process `a` so that we know that it's a library for `b`.
    collector.getResolvedUnit('A1', a);
    await assertEventsText(collector, r'''
[status] working
[operation] analyzeFile
  file: /home/test/lib/hidden/a.dart
  library: /home/test/lib/hidden/a.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/hidden/a.dart
    uri: package:test/hidden/a.dart
    flags: exists isLibrary
[stream]
  ResolvedUnitResult #1
    path: /home/test/lib/b.dart
    uri: package:test/b.dart
    flags: exists isPart
[status] idle
[future] getResolvedUnit A1
  ResolvedUnitResult #0
''');

    // We know that `b` is analyzed as part of `a`.
    collector.getResolvedUnit('B1', b);
    await assertEventsText(collector, r'''
[status] working
[operation] analyzeFile
  file: /home/test/lib/b.dart
  library: /home/test/lib/hidden/a.dart
[stream]
  ResolvedUnitResult #2
    path: /home/test/lib/hidden/a.dart
    uri: package:test/hidden/a.dart
    flags: exists isLibrary
[stream]
  ResolvedUnitResult #3
    path: /home/test/lib/b.dart
    uri: package:test/b.dart
    flags: exists isPart
[status] idle
[future] getResolvedUnit B1
  ResolvedUnitResult #3
''');
  }

  test_partOfName_getResolvedUnit_beforeLibrary_addedFiles() async {
    var a = newFile('$testPackageLibPath/hidden/a.dart', r'''
// @dart = 3.4
// preEnhancedParts
library a;
part '../b.dart';
class A {}
''');

    var b = newFile('$testPackageLibPath/b.dart', r'''
// @dart = 3.4
// preEnhancedParts
part of a;
final a = new A();
''');

    var driver = driverFor(testFile);
    var collector = DriverEventCollector(driver);

    // We discover all added files are maybe libraries.
    driver.addFile2(a);
    driver.addFile2(b);

    // Because `a` is added, we know how to analyze `b`.
    collector.getResolvedUnit('B1', b);
    await assertEventsText(collector, r'''
[status] working
[operation] analyzeFile
  file: /home/test/lib/b.dart
  library: /home/test/lib/hidden/a.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/hidden/a.dart
    uri: package:test/hidden/a.dart
    flags: exists isLibrary
[stream]
  ResolvedUnitResult #1
    path: /home/test/lib/b.dart
    uri: package:test/b.dart
    flags: exists isPart
[status] idle
[future] getResolvedUnit B1
  ResolvedUnitResult #1
''');
  }

  test_partOfName_getResolvedUnit_beforeLibrary_notDiscovered() async {
    newFile('$testPackageLibPath/hidden/a.dart', r'''
// @dart = 3.4
// preEnhancedParts
library a;
part '../b.dart';
class A {}
''');

    var b = newFile('$testPackageLibPath/b.dart', r'''
// @dart = 3.4
// preEnhancedParts
part of a;
final a = new A();
''');

    var driver = driverFor(testFile);
    var collector = DriverEventCollector(driver);

    // We don't know that `a` is the library of `b`.
    // So, we treat it as its own library.
    collector.getResolvedUnit('B1', b);
    await assertEventsText(collector, r'''
[status] working
[operation] analyzeFile
  file: /home/test/lib/b.dart
  library: /home/test/lib/b.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/b.dart
    uri: package:test/b.dart
    flags: exists isPart
    errors
      60 +1 CREATION_WITH_NON_TYPE
[status] idle
[future] getResolvedUnit B1
  ResolvedUnitResult #0
''');
  }

  test_partOfName_getResolvedUnit_changePart_invalidatesLibraryCycle() async {
    var a = newFile('$testPackageLibPath/a.dart', r'''
// @dart = 3.4
// preEnhancedParts
import 'dart:async';
part 'b.dart';
''');

    var driver = driverFor(testFile);
    var collector = DriverEventCollector(driver);

    driver.addFile2(a);

    // Analyze the library without the part.
    await assertEventsText(collector, r'''
[status] working
[operation] analyzeFile
  file: /home/test/lib/a.dart
  library: /home/test/lib/a.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/a.dart
    uri: package:test/a.dart
    flags: exists isLibrary
    errors
      61 +8 URI_DOES_NOT_EXIST
      42 +12 UNUSED_IMPORT
[status] idle
''');

    // Create the part file.
    // This should invalidate library file state (specifically the library
    // cycle), so that we can re-link the library, and get new dependencies.
    var b = newFile('$testPackageLibPath/b.dart', r'''
// @dart = 3.4
// preEnhancedParts
part of 'a.dart';
Future<int>? f;
''');
    driver.changeFile2(b);

    // This should not crash.
    collector.getResolvedUnit('B1', b);
    await assertEventsText(collector, r'''
[status] working
[operation] analyzeFile
  file: /home/test/lib/b.dart
  library: /home/test/lib/a.dart
[stream]
  ResolvedUnitResult #1
    path: /home/test/lib/a.dart
    uri: package:test/a.dart
    flags: exists isLibrary
[stream]
  ResolvedUnitResult #2
    path: /home/test/lib/b.dart
    uri: package:test/b.dart
    flags: exists isPart
[status] idle
[future] getResolvedUnit B1
  ResolvedUnitResult #2
''');
  }

  test_partOfName_getResolvedUnit_hasLibrary_noPart() async {
    var a = newFile('$testPackageLibPath/a.dart', r'''
// @dart = 3.4
// preEnhancedParts
library my.lib;
''');

    var b = newFile('$testPackageLibPath/b.dart', r'''
// @dart = 3.4
// preEnhancedParts
part of my.lib;
final a = new A();
''');

    var driver = driverFor(testFile);
    var collector = DriverEventCollector(driver);

    // Discover the library.
    driver.getFileSync2(a);

    // There is no library which `b` is a part of, so `A` is unresolved.
    collector.getResolvedUnit('B1', b);
    await assertEventsText(collector, r'''
[status] working
[operation] analyzeFile
  file: /home/test/lib/b.dart
  library: /home/test/lib/b.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/b.dart
    uri: package:test/b.dart
    flags: exists isPart
    errors
      65 +1 CREATION_WITH_NON_TYPE
[status] idle
[future] getResolvedUnit B1
  ResolvedUnitResult #0
''');
  }

  test_partOfName_getResolvedUnit_noLibrary() async {
    var b = newFile('$testPackageLibPath/b.dart', r'''
// @dart = 3.4
// preEnhancedParts
part of my.lib;
var a = new A();
''');

    var driver = driverFor(testFile);
    var collector = DriverEventCollector(driver);

    // There is no library which `b` is a part of, so `A` is unresolved.
    collector.getResolvedUnit('B1', b);
    await assertEventsText(collector, r'''
[status] working
[operation] analyzeFile
  file: /home/test/lib/b.dart
  library: /home/test/lib/b.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/b.dart
    uri: package:test/b.dart
    flags: exists isPart
    errors
      63 +1 CREATION_WITH_NON_TYPE
[status] idle
[future] getResolvedUnit B1
  ResolvedUnitResult #0
''');
  }

  test_partOfName_getUnitElement_afterLibrary() async {
    var a = newFile('$testPackageLibPath/hidden/a.dart', r'''
// @dart = 3.4
// preEnhancedParts
library a;
part '../b.dart';
class A {}
''');

    var b = newFile('$testPackageLibPath/b.dart', r'''
// @dart = 3.4
// preEnhancedParts
part of a;
final a = new A();
''');

    var driver = driverFor(testFile);
    var collector = DriverEventCollector(driver);

    // Process `a` so that we know that it's a library for `b`.
    collector.getResolvedUnit('A1', a);
    await assertEventsText(collector, r'''
[status] working
[operation] analyzeFile
  file: /home/test/lib/hidden/a.dart
  library: /home/test/lib/hidden/a.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/hidden/a.dart
    uri: package:test/hidden/a.dart
    flags: exists isLibrary
[stream]
  ResolvedUnitResult #1
    path: /home/test/lib/b.dart
    uri: package:test/b.dart
    flags: exists isPart
[status] idle
[future] getResolvedUnit A1
  ResolvedUnitResult #0
''');

    // We know that `a` is the library for `b`.
    collector.getUnitElement('B1', b);
    await assertEventsText(collector, r'''
[status] working
[status] idle
[future] getUnitElement B1
  path: /home/test/lib/b.dart
  uri: package:test/b.dart
  flags: isPart
  enclosing: #F0
''');
  }

  test_partOfName_getUnitElement_beforeLibrary_addedFiles() async {
    var a = newFile('$testPackageLibPath/hidden/a.dart', r'''
// @dart = 3.4
// preEnhancedParts
library a;
part '../b.dart';
class A {}
''');

    var b = newFile('$testPackageLibPath/b.dart', r'''
// @dart = 3.4
// preEnhancedParts
part of a;
final a = new A();
''');

    var driver = driverFor(testFile);
    var collector = DriverEventCollector(driver);

    // We discover all added files are maybe libraries.
    driver.addFile2(a);
    driver.addFile2(b);

    // Because `a` is added, we know how to analyze `b`.
    collector.getUnitElement('B1', b);
    await assertEventsText(collector, r'''
[status] working
[operation] analyzeFile
  file: /home/test/lib/hidden/a.dart
  library: /home/test/lib/hidden/a.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/hidden/a.dart
    uri: package:test/hidden/a.dart
    flags: exists isLibrary
[stream]
  ResolvedUnitResult #1
    path: /home/test/lib/b.dart
    uri: package:test/b.dart
    flags: exists isPart
[status] idle
[future] getUnitElement B1
  path: /home/test/lib/b.dart
  uri: package:test/b.dart
  flags: isPart
  enclosing: #F0
''');
  }

  test_partOfName_getUnitElement_noLibrary() async {
    var b = newFile('$testPackageLibPath/b.dart', r'''
// @dart = 3.4
// preEnhancedParts
part of a;
final a = new A();
''');

    var driver = driverFor(testFile);
    var collector = DriverEventCollector(driver);

    // We don't know the library for `b`.
    // So, we treat it as its own library.
    collector.getUnitElement('B1', b);
    await assertEventsText(collector, r'''
[status] working
[status] idle
[future] getUnitElement B1
  path: /home/test/lib/b.dart
  uri: package:test/b.dart
  flags: isPart
  enclosing: <null>
''');
  }

  test_partOfName_results_afterLibrary() async {
    // Note, we put the library into a different directory.
    // Otherwise we will discover it.
    var a = newFile('$testPackageLibPath/hidden/a.dart', r'''
// @dart = 3.4
// preEnhancedParts
library a;
part '../b.dart';
class A {}
''');

    var b = newFile('$testPackageLibPath/b.dart', r'''
// @dart = 3.4
// preEnhancedParts
part of a;
final a = new A();
''');

    var driver = driverFor(testFile);
    var collector = DriverEventCollector(driver);

    // The order does not matter.
    // It used to matter, but not anymore.
    driver.addFile2(a);
    driver.addFile2(b);

    // We discover all added libraries.
    // So, we know that `a` is the library of `b`.
    await assertEventsText(collector, r'''
[status] working
[operation] analyzeFile
  file: /home/test/lib/hidden/a.dart
  library: /home/test/lib/hidden/a.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/hidden/a.dart
    uri: package:test/hidden/a.dart
    flags: exists isLibrary
[stream]
  ResolvedUnitResult #1
    path: /home/test/lib/b.dart
    uri: package:test/b.dart
    flags: exists isPart
[status] idle
''');
  }

  test_partOfName_results_beforeLibrary() async {
    // Note, we put the library into a different directory.
    // Otherwise we will discover it.
    var a = newFile('$testPackageLibPath/hidden/a.dart', r'''
// @dart = 3.4
// preEnhancedParts
library a;
part '../b.dart';
class A {}
''');

    var b = newFile('$testPackageLibPath/b.dart', r'''
// @dart = 3.4
// preEnhancedParts
part of a;
final a = new A();
''');

    var driver = driverFor(testFile);
    var collector = DriverEventCollector(driver);

    // The order does not matter.
    // It used to matter, but not anymore.
    driver.addFile2(b);
    driver.addFile2(a);

    // We discover all added libraries.
    // So, we know that `a` is the library of `b`.
    await assertEventsText(collector, r'''
[status] working
[operation] analyzeFile
  file: /home/test/lib/b.dart
  library: /home/test/lib/hidden/a.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/hidden/a.dart
    uri: package:test/hidden/a.dart
    flags: exists isLibrary
[stream]
  ResolvedUnitResult #1
    path: /home/test/lib/b.dart
    uri: package:test/b.dart
    flags: exists isPart
[status] idle
''');
  }

  test_partOfName_results_beforeLibrary_priority() async {
    // Note, we put the library into a different directory.
    // Otherwise we will discover it.
    var a = newFile('$testPackageLibPath/hidden/a.dart', r'''
// @dart = 3.4
// preEnhancedParts
library a;
part '../b.dart';
class A {}
''');

    var b = newFile('$testPackageLibPath/b.dart', r'''
// @dart = 3.4
// preEnhancedParts
part of a;
final a = new A();
''');

    var driver = driverFor(testFile);
    var collector = DriverEventCollector(driver);

    // The order does not matter.
    // It used to matter, but not anymore.
    driver.addFile2(b);
    driver.addFile2(a);
    driver.priorityFiles2 = [b];

    // We discover all added libraries.
    // So, we know that `a` is the library of `b`.
    await assertEventsText(collector, r'''
[status] working
[operation] analyzeFile
  file: /home/test/lib/b.dart
  library: /home/test/lib/hidden/a.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/hidden/a.dart
    uri: package:test/hidden/a.dart
    flags: exists isLibrary
[stream]
  ResolvedUnitResult #1
    path: /home/test/lib/b.dart
    uri: package:test/b.dart
    flags: exists isPart
[status] idle
''');
  }

  test_partOfName_results_noLibrary() async {
    var b = newFile('$testPackageLibPath/b.dart', r'''
// @dart = 3.4
// preEnhancedParts
part of a;
final a = new A();
''');

    var driver = driverFor(testFile);
    var collector = DriverEventCollector(driver);

    driver.addFile2(b);

    // There is no library for `b`.
    // So, we analyze `b` as its own library.
    await assertEventsText(collector, r'''
[status] working
[operation] analyzeFile
  file: /home/test/lib/b.dart
  library: /home/test/lib/b.dart
[operation] reuseLinkedBundle
  package:test/b.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/b.dart
    uri: package:test/b.dart
    flags: exists isPart
    errors
      60 +1 CREATION_WITH_NON_TYPE
[status] idle
''');
  }

  test_partOfName_results_noLibrary_priority() async {
    var b = newFile('$testPackageLibPath/b.dart', r'''
// @dart = 3.4
// preEnhancedParts
part of a;
final a = new A();
''');

    var driver = driverFor(testFile);
    var collector = DriverEventCollector(driver);

    driver.addFile2(b);
    driver.priorityFiles2 = [b];

    // There is no library for `b`.
    // So, we analyze `b` as its own library.
    await assertEventsText(collector, r'''
[status] working
[operation] analyzeFile
  file: /home/test/lib/b.dart
  library: /home/test/lib/b.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/b.dart
    uri: package:test/b.dart
    flags: exists isPart
    errors
      60 +1 CREATION_WITH_NON_TYPE
[status] idle
''');
  }

  test_priorities_changed_importing_rest() async {
    var a = newFile('$testPackageLibPath/a.dart', r'''
import 'c.dart';
''');

    var b = newFile('$testPackageLibPath/b.dart', r'''
class B {}
''');

    var c = newFile('$testPackageLibPath/c.dart', r'''
import 'b.dart';
''');

    var driver = driverFor(a);
    var collector = DriverEventCollector(driver);

    driver.addFile2(a);
    driver.addFile2(b);
    driver.addFile2(c);

    // Discard results so far.
    await collector.nextStatusIdle();
    collector.take();

    modifyFile2(b, r'''
class B2 {}
''');
    driver.changeFile2(b);

    // We analyze `b` first, because it was changed.
    // Then we analyze `c`, because it imports `b`.
    // Then we analyze `a`, because it also affected.
    // Note, there is no specific rule that says when `a` is analyzed.
    configuration.withStreamResolvedUnitResults = false;
    await assertEventsText(collector, r'''
[status] working
[operation] analyzeFile
  file: /home/test/lib/b.dart
  library: /home/test/lib/b.dart
[operation] analyzeFile
  file: /home/test/lib/c.dart
  library: /home/test/lib/c.dart
[operation] analyzeFile
  file: /home/test/lib/a.dart
  library: /home/test/lib/a.dart
[status] idle
''');
  }

  test_priorities_changed_importing_withErrors_rest() async {
    // Note, is affected by `b`, but does not import it.
    var a = newFile('$testPackageLibPath/a.dart', r'''
export 'b.dart';
''');

    // We will change this file.
    var b = newFile('$testPackageLibPath/b.dart', r'''
class B {}
''');

    // Note, does not import `b` directly.
    var c = newFile('$testPackageLibPath/c.dart', r'''
import 'a.dart';
class C extends X {}
''');

    // Note, does import `b`.
    var d = newFile('$testPackageLibPath/d.dart', r'''
import 'b.dart';
''');

    var driver = driverFor(a);
    var collector = DriverEventCollector(driver);

    driver.addFile2(a);
    driver.addFile2(b);
    driver.addFile2(c);
    driver.addFile2(d);

    // Discard results so far.
    await collector.nextStatusIdle();
    collector.take();

    modifyFile2(b, r'''
class B2 {}
''');
    driver.changeFile2(b);

    // We analyze `b` first, because it was changed.
    // The we analyze `d` because it import `b`.
    // Then we analyze `c` because it has errors.
    // Then we analyze `a` because it is affected.
    // For `a` because it just exports, there are no special rules.
    configuration.withStreamResolvedUnitResults = false;
    await assertEventsText(collector, r'''
[status] working
[operation] analyzeFile
  file: /home/test/lib/b.dart
  library: /home/test/lib/b.dart
[operation] analyzeFile
  file: /home/test/lib/d.dart
  library: /home/test/lib/d.dart
[operation] analyzeFile
  file: /home/test/lib/c.dart
  library: /home/test/lib/c.dart
[operation] analyzeFile
  file: /home/test/lib/a.dart
  library: /home/test/lib/a.dart
[status] idle
''');
  }

  test_priorities_changedAll() async {
    // Make sure that `test2` is its own analysis context.
    var test1Path = '$workspaceRootPath/test1';
    writePackageConfig(
      test1Path,
      PackageConfigFileBuilder()..add(name: 'test1', rootPath: test1Path),
    );

    // Make sure that `test2` is its own analysis context.
    var test2Path = '$workspaceRootPath/test2';
    writePackageConfig(
      test2Path,
      PackageConfigFileBuilder()..add(name: 'test2', rootPath: test2Path),
    );

    // `b` imports `a`, so `b` is reanalyzed when `a` API changes.
    var a = newFile('$test1Path/lib/a.dart', 'class A {}');
    var b = newFile('$test1Path/lib/b.dart', "import 'a.dart';");

    // `d` imports `c`, so `d` is reanalyzed when `b` API changes.
    var c = newFile('$test2Path/lib/c.dart', 'class C {}');
    var d = newFile('$test2Path/lib/d.dart', "import 'c.dart';");

    var collector = DriverEventCollector.forCollection(
      analysisContextCollection,
    );

    var driver1 = driverFor(a);
    var driver2 = driverFor(c);

    // Ensure that we actually have two separate analysis contexts.
    expect(driver1, isNot(same(driver2)));

    // Subscribe for analysis.
    driver1.addFile2(a);
    driver1.addFile2(b);
    driver2.addFile2(c);
    driver2.addFile2(d);

    // Discard results so far.
    await collector.nextStatusIdle();
    collector.take();

    // Change `a` and `c` in a way that changed their API signatures.
    modifyFile2(a, 'class A2 {}');
    modifyFile2(c, 'class C2 {}');
    driver1.changeFile2(a);
    driver2.changeFile2(c);

    // Note, `a` and `c` analyzed first, because they were changed.
    // Even though they are in different drivers.
    configuration.withStreamResolvedUnitResults = false;
    await assertEventsText(collector, r'''
[status] working
[operation] analyzeFile
  file: /home/test1/lib/a.dart
  library: /home/test1/lib/a.dart
[operation] analyzeFile
  file: /home/test2/lib/c.dart
  library: /home/test2/lib/c.dart
[operation] analyzeFile
  file: /home/test1/lib/b.dart
  library: /home/test1/lib/b.dart
[operation] analyzeFile
  file: /home/test2/lib/d.dart
  library: /home/test2/lib/d.dart
[status] idle
''');
  }

  test_priorities_getResolvedUnit_beforePriority() async {
    // Make sure that `test1` is its own analysis context.
    var test1Path = '$workspaceRootPath/test1';
    writePackageConfig(
      test1Path,
      PackageConfigFileBuilder()..add(name: 'test1', rootPath: test1Path),
    );

    // Make sure that `test2` is its own analysis context.
    var test2Path = '$workspaceRootPath/test2';
    writePackageConfig(
      test2Path,
      PackageConfigFileBuilder()..add(name: 'test2', rootPath: test2Path),
    );

    var a = newFile('$test1Path/lib/a.dart', '');
    var b = newFile('$test2Path/lib/b.dart', '');
    var c = newFile('$test2Path/lib/c.dart', '');

    var collector = DriverEventCollector.forCollection(
      analysisContextCollection,
    );

    var driver1 = driverFor(a);
    var driver2 = driverFor(c);

    // Ensure that we actually have two separate analysis contexts.
    expect(driver1, isNot(same(driver2)));

    // Subscribe for analysis.
    driver1.addFile2(a);
    driver2.addFile2(b);
    driver2.addFile2(c);

    driver1.priorityFiles2 = [a];
    driver2.priorityFiles2 = [c];

    collector.driver = driver2;
    collector.getResolvedUnit('B1', b);

    // We asked for `b`, so it is analyzed.
    // Even if it is not a priority file.
    // Even if it is in the `driver2`.
    configuration.withStreamResolvedUnitResults = false;
    await assertEventsText(collector, r'''
[status] working
[operation] analyzeFile
  file: /home/test2/lib/b.dart
  library: /home/test2/lib/b.dart
[operation] analyzeFile
  file: /home/test1/lib/a.dart
  library: /home/test1/lib/a.dart
[operation] reuseLinkedBundle SDK
[operation] analyzeFile
  file: /home/test2/lib/c.dart
  library: /home/test2/lib/c.dart
[status] idle
[future] getResolvedUnit B1
  ResolvedUnitResult #0
    path: /home/test2/lib/b.dart
    uri: package:test2/b.dart
    flags: exists isLibrary
''');
  }

  test_priorities_priority_rest() async {
    // Make sure that `test1` is its own analysis context.
    var test1Path = '$workspaceRootPath/test1';
    writePackageConfig(
      test1Path,
      PackageConfigFileBuilder()..add(name: 'test1', rootPath: test1Path),
    );

    // Make sure that `test2` is its own analysis context.
    var test2Path = '$workspaceRootPath/test2';
    writePackageConfig(
      test2Path,
      PackageConfigFileBuilder()..add(name: 'test2', rootPath: test2Path),
    );

    var a = newFile('$test1Path/lib/a.dart', '');
    var b = newFile('$test1Path/lib/b.dart', '');
    var c = newFile('$test2Path/lib/c.dart', '');
    var d = newFile('$test2Path/lib/d.dart', '');

    var collector = DriverEventCollector.forCollection(
      analysisContextCollection,
    );

    var driver1 = driverFor(a);
    var driver2 = driverFor(c);

    // Ensure that we actually have two separate analysis contexts.
    expect(driver1, isNot(same(driver2)));

    driver1.addFile2(a);
    driver1.addFile2(b);
    driver1.priorityFiles2 = [a];

    driver2.addFile2(c);
    driver2.addFile2(d);
    driver2.priorityFiles2 = [c];

    configuration.withStreamResolvedUnitResults = false;
    await assertEventsText(collector, r'''
[status] working
[operation] analyzeFile
  file: /home/test1/lib/a.dart
  library: /home/test1/lib/a.dart
[operation] analyzeFile
  file: /home/test2/lib/c.dart
  library: /home/test2/lib/c.dart
[operation] reuseLinkedBundle SDK
[operation] analyzeFile
  file: /home/test1/lib/b.dart
  library: /home/test1/lib/b.dart
[operation] analyzeFile
  file: /home/test2/lib/d.dart
  library: /home/test2/lib/d.dart
[status] idle
''');
  }

  test_removeFile_addFile() async {
    var a = newFile('$testPackageLibPath/a.dart', '');

    var driver = driverFor(testFile);
    var collector = DriverEventCollector(driver);

    driver.addFile2(a);

    // Initial analysis.
    await assertEventsText(collector, r'''
[status] working
[operation] analyzeFile
  file: /home/test/lib/a.dart
  library: /home/test/lib/a.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/a.dart
    uri: package:test/a.dart
    flags: exists isLibrary
[status] idle
''');

    driver.removeFile2(a);
    driver.addFile2(a);

    // The cache key for `a` errors is the same, return from bytes.
    // Note, no analysis.
    await assertEventsText(collector, r'''
[status] working
[operation] reuseLinkedBundle SDK
[operation] reuseLinkedBundle
  package:test/a.dart
[operation] getErrorsFromBytes
  file: /home/test/lib/a.dart
  library: /home/test/lib/a.dart
[stream]
  ErrorsResult #1
    path: /home/test/lib/a.dart
    uri: package:test/a.dart
    flags: isLibrary
[status] idle
''');
  }

  test_removeFile_changeFile_implicitlyAnalyzed() async {
    var a = newFile('$testPackageLibPath/a.dart', r'''
import 'b.dart';
final A = B;
''');

    var b = newFile('$testPackageLibPath/b.dart', r'''
final B = 0;
''');

    var driver = driverFor(testFile);
    var collector = DriverEventCollector(driver);

    driver.priorityFiles2 = [a, b];
    driver.addFile2(a);
    driver.addFile2(b);

    configuration.libraryConfiguration.unitConfiguration.variableTypesSelector =
        (result) {
          switch (result.uriStr) {
            case 'package:test/a.dart':
              return [result.findElement2.topVar('A')];
            case 'package:test/b.dart':
              return [result.findElement2.topVar('B')];
            default:
              return [];
          }
        };

    // We have results for both `a` and `b`.
    await assertEventsText(collector, r'''
[status] working
[operation] analyzeFile
  file: /home/test/lib/a.dart
  library: /home/test/lib/a.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/a.dart
    uri: package:test/a.dart
    flags: exists isLibrary
    selectedVariableTypes
      A: int
[operation] analyzeFile
  file: /home/test/lib/b.dart
  library: /home/test/lib/b.dart
[stream]
  ResolvedUnitResult #1
    path: /home/test/lib/b.dart
    uri: package:test/b.dart
    flags: exists isLibrary
    selectedVariableTypes
      B: int
[status] idle
''');

    // Remove `b` and send the change notification.
    modifyFile2(b, r'''
final B = 1.2;
''');
    driver.removeFile2(b);
    driver.changeFile2(b);

    // While `b` is not analyzed explicitly, it is analyzed implicitly.
    // We don't get a result for `b`.
    // But the change causes `a` to be reanalyzed.
    await assertEventsText(collector, r'''
[status] working
[operation] analyzeFile
  file: /home/test/lib/a.dart
  library: /home/test/lib/a.dart
[operation] reuseLinkedBundle SDK
[stream]
  ResolvedUnitResult #2
    path: /home/test/lib/a.dart
    uri: package:test/a.dart
    flags: exists isLibrary
    selectedVariableTypes
      A: double
[status] idle
''');
  }

  test_removeFile_changeFile_notAnalyzed() async {
    var a = newFile('$testPackageLibPath/a.dart', r'''
class A {}
''');

    var driver = driverFor(testFile);
    var collector = DriverEventCollector(driver);

    // We don't analyze `a`, so we get nothing.
    await assertEventsText(collector, r'''
''');

    // Remove `a`, and also change it.
    // Still nothing, we still don't analyze `a`.
    driver.removeFile2(a);
    driver.changeFile2(a);
    await assertEventsText(collector, r'''
[status] working
[status] idle
''');
  }

  test_removeFile_invalidate_importers() async {
    var a = newFile('$testPackageLibPath/a.dart', r'''
class A {}
''');

    var b = newFile('$testPackageLibPath/b.dart', r'''
import 'a.dart';
final a = new A();
''');

    var driver = driverFor(testFile);
    var collector = DriverEventCollector(driver);

    driver.addFile2(a);
    driver.addFile2(b);

    // No errors in `b`.
    await assertEventsText(collector, r'''
[status] working
[operation] analyzeFile
  file: /home/test/lib/a.dart
  library: /home/test/lib/a.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/a.dart
    uri: package:test/a.dart
    flags: exists isLibrary
[operation] analyzeFile
  file: /home/test/lib/b.dart
  library: /home/test/lib/b.dart
[stream]
  ResolvedUnitResult #1
    path: /home/test/lib/b.dart
    uri: package:test/b.dart
    flags: exists isLibrary
[status] idle
''');

    // Remove `a`, so `b` is reanalyzed and has an error.
    deleteFile(a.path);
    driver.removeFile2(a);
    await assertEventsText(collector, r'''
[status] working
[operation] reuseLinkedBundle SDK
[operation] analyzeFile
  file: /home/test/lib/b.dart
  library: /home/test/lib/b.dart
[stream]
  ResolvedUnitResult #2
    path: /home/test/lib/b.dart
    uri: package:test/b.dart
    flags: exists isLibrary
    errors
      7 +8 URI_DOES_NOT_EXIST
      31 +1 CREATION_WITH_NON_TYPE
[status] idle
''');
  }

  test_removeFile_notAbsolutePath() async {
    var driver = driverFor(testFile);
    expect(() {
      driver.removeFile('not_absolute.dart');
    }, throwsArgumentError);
  }

  test_results_order() async {
    var a = newFile('$testPackageLibPath/a.dart', r'''
// ignore:unused_import
import 'd.dart';
''');

    var b = newFile('$testPackageLibPath/b.dart', '');

    var c = newFile('$testPackageLibPath/c.dart', r'''
// ignore:unused_import
import 'd.dart';
''');

    var d = newFile('$testPackageLibPath/d.dart', r'''
// ignore:unused_import
import 'b.dart';
''');

    var e = newFile('$testPackageLibPath/e.dart', r'''
// ignore:unused_import
export 'b.dart';
''');

    // This file intentionally has an error.
    var f = newFile('$testPackageLibPath/f.dart', r'''
// ignore:unused_import
import 'e.dart';
class F extends X {}
''');

    var driver = driverFor(testFile);
    var collector = DriverEventCollector(driver);

    driver.addFile2(a);
    driver.addFile2(b);
    driver.addFile2(c);
    driver.addFile2(d);
    driver.addFile2(e);
    driver.addFile2(f);

    // Initial analysis, all files analyzed in order of adding.
    // Note, `f` has an error.
    await assertEventsText(collector, r'''
[status] working
[operation] analyzeFile
  file: /home/test/lib/a.dart
  library: /home/test/lib/a.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/a.dart
    uri: package:test/a.dart
    flags: exists isLibrary
[operation] analyzeFile
  file: /home/test/lib/b.dart
  library: /home/test/lib/b.dart
[stream]
  ResolvedUnitResult #1
    path: /home/test/lib/b.dart
    uri: package:test/b.dart
    flags: exists isLibrary
[operation] analyzeFile
  file: /home/test/lib/c.dart
  library: /home/test/lib/c.dart
[stream]
  ResolvedUnitResult #2
    path: /home/test/lib/c.dart
    uri: package:test/c.dart
    flags: exists isLibrary
[operation] analyzeFile
  file: /home/test/lib/d.dart
  library: /home/test/lib/d.dart
[stream]
  ResolvedUnitResult #3
    path: /home/test/lib/d.dart
    uri: package:test/d.dart
    flags: exists isLibrary
[operation] analyzeFile
  file: /home/test/lib/e.dart
  library: /home/test/lib/e.dart
[stream]
  ResolvedUnitResult #4
    path: /home/test/lib/e.dart
    uri: package:test/e.dart
    flags: exists isLibrary
[operation] analyzeFile
  file: /home/test/lib/f.dart
  library: /home/test/lib/f.dart
[stream]
  ResolvedUnitResult #5
    path: /home/test/lib/f.dart
    uri: package:test/f.dart
    flags: exists isLibrary
    errors
      57 +1 EXTENDS_NON_CLASS
[status] idle
''');

    // Update `b` with changing its API signature.
    modifyFile2(b, r'''
class B {}
''');
    driver.changeFile2(b);

    // 1. The changed `b` is the first.
    // 2. Then `d` that imports the changed `b`.
    // 3. Then `f` that has an error (even if it is unrelated).
    // 4. Then the rest, in order of adding.
    await assertEventsText(collector, r'''
[status] working
[operation] analyzeFile
  file: /home/test/lib/b.dart
  library: /home/test/lib/b.dart
[stream]
  ResolvedUnitResult #6
    path: /home/test/lib/b.dart
    uri: package:test/b.dart
    flags: exists isLibrary
[operation] analyzeFile
  file: /home/test/lib/d.dart
  library: /home/test/lib/d.dart
[stream]
  ResolvedUnitResult #7
    path: /home/test/lib/d.dart
    uri: package:test/d.dart
    flags: exists isLibrary
[operation] analyzeFile
  file: /home/test/lib/f.dart
  library: /home/test/lib/f.dart
[stream]
  ResolvedUnitResult #8
    path: /home/test/lib/f.dart
    uri: package:test/f.dart
    flags: exists isLibrary
    errors
      57 +1 EXTENDS_NON_CLASS
[operation] analyzeFile
  file: /home/test/lib/a.dart
  library: /home/test/lib/a.dart
[stream]
  ResolvedUnitResult #9
    path: /home/test/lib/a.dart
    uri: package:test/a.dart
    flags: exists isLibrary
[operation] analyzeFile
  file: /home/test/lib/c.dart
  library: /home/test/lib/c.dart
[stream]
  ResolvedUnitResult #10
    path: /home/test/lib/c.dart
    uri: package:test/c.dart
    flags: exists isLibrary
[operation] analyzeFile
  file: /home/test/lib/e.dart
  library: /home/test/lib/e.dart
[stream]
  ResolvedUnitResult #11
    path: /home/test/lib/e.dart
    uri: package:test/e.dart
    flags: exists isLibrary
[status] idle
''');
  }

  test_results_order_allChangedFirst_thenImports() async {
    var a = newFile('$testPackageLibPath/a.dart', r'''
class A {}
''');

    var b = newFile('$testPackageLibPath/b.dart', r'''
class B {}
''');

    var c = newFile('$testPackageLibPath/c.dart', r'''
''');

    var d = newFile('$testPackageLibPath/d.dart', r'''
// ignore:unused_import
import 'a.dart';
''');

    var e = newFile('$testPackageLibPath/e.dart', r'''
// ignore:unused_import
import 'b.dart';
''');

    var driver = driverFor(testFile);
    var collector = DriverEventCollector(driver);

    driver.addFile2(a);
    driver.addFile2(b);
    driver.addFile2(c);
    driver.addFile2(d);
    driver.addFile2(e);

    // Initial analysis, all files analyzed in order of adding.
    await assertEventsText(collector, r'''
[status] working
[operation] analyzeFile
  file: /home/test/lib/a.dart
  library: /home/test/lib/a.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/a.dart
    uri: package:test/a.dart
    flags: exists isLibrary
[operation] analyzeFile
  file: /home/test/lib/b.dart
  library: /home/test/lib/b.dart
[stream]
  ResolvedUnitResult #1
    path: /home/test/lib/b.dart
    uri: package:test/b.dart
    flags: exists isLibrary
[operation] analyzeFile
  file: /home/test/lib/c.dart
  library: /home/test/lib/c.dart
[stream]
  ResolvedUnitResult #2
    path: /home/test/lib/c.dart
    uri: package:test/c.dart
    flags: exists isLibrary
[operation] analyzeFile
  file: /home/test/lib/d.dart
  library: /home/test/lib/d.dart
[stream]
  ResolvedUnitResult #3
    path: /home/test/lib/d.dart
    uri: package:test/d.dart
    flags: exists isLibrary
[operation] analyzeFile
  file: /home/test/lib/e.dart
  library: /home/test/lib/e.dart
[stream]
  ResolvedUnitResult #4
    path: /home/test/lib/e.dart
    uri: package:test/e.dart
    flags: exists isLibrary
[status] idle
''');

    // Change b.dart and then a.dart files.
    modifyFile2(a, r'''
class A2 {}
''');
    modifyFile2(b, r'''
class B2 {}
''');
    driver.changeFile2(b);
    driver.changeFile2(a);

    // First `a` and `b`.
    // Then `d` and `e` because they import `a` and `b`.
    await assertEventsText(collector, r'''
[status] working
[operation] analyzeFile
  file: /home/test/lib/a.dart
  library: /home/test/lib/a.dart
[stream]
  ResolvedUnitResult #5
    path: /home/test/lib/a.dart
    uri: package:test/a.dart
    flags: exists isLibrary
[operation] analyzeFile
  file: /home/test/lib/b.dart
  library: /home/test/lib/b.dart
[stream]
  ResolvedUnitResult #6
    path: /home/test/lib/b.dart
    uri: package:test/b.dart
    flags: exists isLibrary
[operation] analyzeFile
  file: /home/test/lib/d.dart
  library: /home/test/lib/d.dart
[stream]
  ResolvedUnitResult #7
    path: /home/test/lib/d.dart
    uri: package:test/d.dart
    flags: exists isLibrary
[operation] analyzeFile
  file: /home/test/lib/e.dart
  library: /home/test/lib/e.dart
[stream]
  ResolvedUnitResult #8
    path: /home/test/lib/e.dart
    uri: package:test/e.dart
    flags: exists isLibrary
[status] idle
''');
  }

  test_results_removeFile_changeFile() async {
    var a = newFile('$testPackageLibPath/a.dart', r'''
final v = 0;
''');

    var b = getFile('$testPackageLibPath/b.dart');

    var driver = driverFor(testFile);
    var collector = DriverEventCollector(driver);

    driver.addFile2(a);

    // Initial analysis.
    await assertEventsText(collector, r'''
[status] working
[operation] analyzeFile
  file: /home/test/lib/a.dart
  library: /home/test/lib/a.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/a.dart
    uri: package:test/a.dart
    flags: exists isLibrary
[status] idle
''');

    // Update `a` to have an error.
    modifyFile2(a, r'''
final v = 0
''');

    // It does not matter what we do with `b`, it is not analyzed anyway.
    // But we notify that `a` was changed, so it is analyzed.
    driver.removeFile2(b);
    driver.changeFile2(a);
    await assertEventsText(collector, r'''
[status] working
[operation] reuseLinkedBundle SDK
[operation] reuseLinkedBundle
  package:test/a.dart
[operation] analyzeFile
  file: /home/test/lib/a.dart
  library: /home/test/lib/a.dart
[stream]
  ResolvedUnitResult #1
    path: /home/test/lib/a.dart
    uri: package:test/a.dart
    flags: exists isLibrary
    errors
      10 +1 EXPECTED_TOKEN
[status] idle
''');
  }

  test_results_skipNotAffected() async {
    var a = newFile('$testPackageLibPath/a.dart', r'''
class A {}
''');

    var b = newFile('$testPackageLibPath/b.dart', r'''
class B {}
''');

    var driver = driverFor(testFile);
    var collector = DriverEventCollector(driver);

    driver.addFile2(a);
    driver.addFile2(b);

    // Initial analysis.
    await assertEventsText(collector, r'''
[status] working
[operation] analyzeFile
  file: /home/test/lib/a.dart
  library: /home/test/lib/a.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/a.dart
    uri: package:test/a.dart
    flags: exists isLibrary
[operation] analyzeFile
  file: /home/test/lib/b.dart
  library: /home/test/lib/b.dart
[stream]
  ResolvedUnitResult #1
    path: /home/test/lib/b.dart
    uri: package:test/b.dart
    flags: exists isLibrary
[status] idle
''');

    // Update `a` and notify.
    modifyFile2(a, r'''
class A2 {}
''');
    driver.changeFile2(a);

    // Only `a` is analyzed, `b` is not affected.
    await assertEventsText(collector, r'''
[status] working
[operation] analyzeFile
  file: /home/test/lib/a.dart
  library: /home/test/lib/a.dart
[stream]
  ResolvedUnitResult #2
    path: /home/test/lib/a.dart
    uri: package:test/a.dart
    flags: exists isLibrary
[status] idle
''');
  }

  test_schedulerStatus_hasAddedFile() async {
    var a = newFile('$testPackageLibPath/a.dart', '');

    var driver = driverFor(testFile);
    var collector = DriverEventCollector(driver);

    driver.addFile2(a);

    await assertEventsText(collector, r'''
[status] working
[operation] analyzeFile
  file: /home/test/lib/a.dart
  library: /home/test/lib/a.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/a.dart
    uri: package:test/a.dart
    flags: exists isLibrary
[status] idle
''');
  }

  test_schedulerStatus_noAddedFile() async {
    var driver = driverFor(testFile);
    var collector = DriverEventCollector(driver);

    // No files, so no status changes.
    await assertEventsText(collector, r'''
''');
  }

  test_status_anyWorkTransitionsToAnalyzing() async {
    var a = newFile('$testPackageLibPath/a.dart', '');
    var b = newFile('$testPackageLibPath/b.dart', '');

    var driver = driverFor(testFile);
    var collector = DriverEventCollector(driver);

    driver.addFile2(a);
    driver.addFile2(b);

    // Initial analysis.
    configuration.withStreamResolvedUnitResults = false;
    await assertEventsText(collector, r'''
[status] working
[operation] analyzeFile
  file: /home/test/lib/a.dart
  library: /home/test/lib/a.dart
[operation] analyzeFile
  file: /home/test/lib/b.dart
  library: /home/test/lib/b.dart
[status] idle
''');

    // Any work transitions to analyzing, and back to idle.
    await driver.getFilesReferencingName('X');
    await assertEventsText(collector, r'''
[status] working
[status] idle
''');
  }
}

/// Tracks events reported into the `results` stream, and results of `getXyz`
/// requests. We are interested in relative orders, identity of the objects,
/// absence of duplicate events, etc.
class DriverEventCollector {
  final IdProvider idProvider;
  late AnalysisDriver driver;
  final List<DriverEvent> _events = [];
  final List<_PendingFuture> _pendingFutures = [];
  final List<Completer<void>> _statusIdleCompleters = [];

  DriverEventCollector(this.driver, {IdProvider? idProvider})
    : idProvider = idProvider ?? IdProvider() {
    _listenSchedulerEvents(driver.scheduler);
  }

  DriverEventCollector.forCollection(
    AnalysisContextCollectionImpl collection, {
    IdProvider? idProvider,
  }) : idProvider = idProvider ?? IdProvider() {
    _listenSchedulerEvents(collection.scheduler);
  }

  Future<void> awaitPendingFutures() async {
    var futures = _pendingFutures.toList();
    _pendingFutures.clear();
    for (var future in futures) {
      await future.resolve();
    }
  }

  void getCachedResolvedUnit(String name, File file) {
    var value = driver.getCachedResolvedUnit2(file);
    _events.add(GetCachedResolvedUnitEvent(name: name, result: value));
  }

  void getErrors(String name, File file) {
    _addPending(
      driver.getErrors(file.path),
      (value) => GetErrorsEvent(name: name, result: value),
    );
  }

  void getIndex(String name, File file) {
    _addPending(
      driver.getIndex(file.path),
      (value) => GetIndexEvent(name: name, result: value),
    );
  }

  void getLibraryByUri(String name, String uriStr) {
    _addPending(
      driver.getLibraryByUri(uriStr),
      (value) => GetLibraryByUriEvent(name: name, result: value),
    );
  }

  void getResolvedLibrary(String name, File file) {
    _addPending(
      driver.getResolvedLibrary(file.path),
      (value) => GetResolvedLibraryEvent(name: name, result: value),
    );
  }

  void getResolvedLibraryByUri(String name, Uri uri) {
    _addPending(
      driver.getResolvedLibraryByUri(uri),
      (value) => GetResolvedLibraryByUriEvent(name: name, result: value),
    );
  }

  void getResolvedUnit(
    String name,
    File file, {
    bool sendCachedToStream = false,
  }) {
    _addPending(
      driver.getResolvedUnit(file.path, sendCachedToStream: sendCachedToStream),
      (value) => GetResolvedUnitEvent(name: name, result: value),
    );
  }

  void getUnitElement(String name, File file) {
    _addPending(
      driver.getUnitElement2(file),
      (value) => GetUnitElementEvent(name: name, result: value),
    );
  }

  Future<void> nextStatusIdle() {
    var completer = Completer<void>();
    _statusIdleCompleters.add(completer);
    return completer.future;
  }

  List<DriverEvent> take() {
    if (_pendingFutures.isNotEmpty) {
      throw StateError('Some futures are not complete.');
    }
    var result = _events.toList();
    _events.clear();
    return result;
  }

  void _addPending<T>(
    Future<T> future,
    DriverEvent Function(T value) createEvent,
  ) {
    _pendingFutures.add(
      _PendingFuture<T>(
        future: future,
        createEvent: createEvent,
        eventsList: _events,
      ),
    );
  }

  void _listenSchedulerEvents(AnalysisDriverScheduler scheduler) {
    scheduler.eventsBroadcast.listen((event) {
      switch (event) {
        case AnalysisStatus():
          _events.add(SchedulerStatusEvent(event));
          if (event.isIdle) {
            _statusIdleCompleters.completeAll();
            _statusIdleCompleters.clear();
          }
        case driver_events.AnalyzeFile():
        case driver_events.AnalyzedLibrary():
        case driver_events.GetErrorsFromBytes():
        case driver_events.LinkLibraryCycle():
        case driver_events.CheckLibraryDiagnosticsRequirements():
        case driver_events.CheckLinkedBundleRequirements():
        case driver_events.ReuseLinkedBundle():
        case ErrorsResult():
        case ResolvedUnitResult():
          _events.add(ResultStreamEvent(object: event));
      }
    });
  }
}

@reflectiveTest
class FineAnalysisDriverTest extends PubPackageResolutionTest
    with _EventsMixin {
  @override
  bool get retainDataForTesting => true;

  @override
  void setUp() {
    withFineDependencies = true;
    super.setUp();
    registerLintRules();
    useEmptyByteStore();
  }

  @override
  Future<void> tearDown() async {
    testFineAfterLibraryAnalyzerHook = null;
    return super.tearDown();
  }

  test_dependency_class_instanceField_add_hasNonFinalField() async {
    configuration
      ..withGetErrorsEvents = false
      ..withStreamResolvedUnitResults = false;

    _ManualRequirements.install((state) {
      var A = state.singleUnit.scopeInterfaceElement('A');
      A.hasNonFinalField;
    });

    await _runChangeScenarioTA(
      initialA: r'''
class A {}
''',
      testCode: r'''
import 'a.dart';
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        interface: #M1
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M2
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        interfaces
          A
            hasNonFinalField: false
[status] idle
''',
      updatedA: r'''
class A {
  var foo = 0;
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M3
        declaredGetters
          foo: #M4
        declaredSetters
          foo=: #M5
        interface: #M6
          map
            foo: #M4
            foo=: #M5
          implemented
            foo: #M4
            foo=: #M5
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  interfaceHasNonFinalFieldMismatch
    libraryUri: package:test/a.dart
    interfaceName: A
    expected: false
    actual: true
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M2
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        interfaces
          A
            hasNonFinalField: true
[status] idle
''',
    );
  }

  test_dependency_class_instanceField_add_hasNonFinalField_ofSuper() async {
    configuration
      ..withGetErrorsEvents = false
      ..withStreamResolvedUnitResults = false;

    await _runChangeScenarioTA(
      initialA: r'''
class A {}
''',
      testCode: r'''
import 'a.dart';
class B extends A {}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        interface: #M1
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      B: #M2
        interface: #M3
  requirements
    libraries
      package:test/a.dart
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        interfaces
          A
            interfaceId: #M1
            hasNonFinalField: false
            requestedConstructors
              new: #M4
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        featureSet: <not-null>
        libraryMetadataId: #M5
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            allDeclaredGetters: []
            allDeclaredSetters: []
            allDeclaredMethods: []
        interfaces
          A
            allConstructors: #M4
            requestedConstructors
              new: #M4
[status] idle
''',
      updatedA: r'''
class A {
  var foo = 0;
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M6
        declaredGetters
          foo: #M7
        declaredSetters
          foo=: #M8
        interface: #M9
          map
            foo: #M7
            foo=: #M8
          implemented
            foo: #M7
            foo=: #M8
  requirements
[operation] checkLinkedBundleRequirements
  package:test/test.dart
  interfaceIdMismatch
    libraryUri: package:test/a.dart
    interfaceName: A
    expectedId: #M1
    actualId: #M9
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      B: #M2
        interface: #M10
          map
            foo: #M7
            foo=: #M8
          implemented
            foo: #M7
            foo=: #M8
          superImplemented
            [0]
              foo: #M7
              foo=: #M8
          inherited
            foo: #M7
            foo=: #M8
  requirements
    libraries
      package:test/a.dart
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        interfaces
          A
            interfaceId: #M9
            hasNonFinalField: true
            requestedConstructors
              new: #M4
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  instanceChildrenIdsMismatch
    libraryUri: package:test/a.dart
    instanceName: A
    childrenPropertyName: getters
    expectedIds: []
    actualIds: #M7
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        featureSet: <not-null>
        libraryMetadataId: #M5
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredFields
              foo: #M6
            allDeclaredGetters: #M7
            allDeclaredSetters: #M8
            allDeclaredMethods: []
        interfaces
          A
            allConstructors: #M4
            requestedConstructors
              new: #M4
[status] idle
''',
    );
  }

  test_dependency_class_instanceField_add_hasNonFinalField_ofSuper_private() async {
    configuration
      ..withGetErrorsEvents = false
      ..withStreamResolvedUnitResults = false;

    await _runChangeScenarioTA(
      initialA: r'''
class A {}
''',
      testCode: r'''
import 'a.dart';
class B extends A {}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        interface: #M1
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      B: #M2
        interface: #M3
  requirements
    libraries
      package:test/a.dart
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        interfaces
          A
            interfaceId: #M1
            hasNonFinalField: false
            requestedConstructors
              new: #M4
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        featureSet: <not-null>
        libraryMetadataId: #M5
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            allDeclaredGetters: []
            allDeclaredSetters: []
            allDeclaredMethods: []
        interfaces
          A
            allConstructors: #M4
            requestedConstructors
              new: #M4
[status] idle
''',
      updatedA: r'''
class A {
  var _foo = 0;
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredFields
          _foo: #M6
        declaredGetters
          _foo: #M7
        declaredSetters
          _foo=: #M8
        interface: #M1
  requirements
[operation] checkLinkedBundleRequirements
  package:test/test.dart
  interfaceHasNonFinalFieldMismatch
    libraryUri: package:test/a.dart
    interfaceName: A
    expected: false
    actual: true
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      B: #M2
        interface: #M3
  requirements
    libraries
      package:test/a.dart
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        interfaces
          A
            interfaceId: #M1
            hasNonFinalField: true
            requestedConstructors
              new: #M4
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  instanceChildrenIdsMismatch
    libraryUri: package:test/a.dart
    instanceName: A
    childrenPropertyName: getters
    expectedIds: []
    actualIds: #M7
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        featureSet: <not-null>
        libraryMetadataId: #M5
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            allDeclaredGetters: #M7
            allDeclaredSetters: #M8
            allDeclaredMethods: []
        interfaces
          A
            allConstructors: #M4
            requestedConstructors
              new: #M4
[status] idle
''',
    );
  }

  test_dependency_class_instanceField_change_getField() async {
    _ManualRequirements.install((state) {
      var A = state.singleUnit.scopeInstanceElement('A');
      A.getField('foo');
    });

    await _runChangeScenarioTA(
      initialA: r'''
class A {
  final int foo = 0;
}
''',
      testCode: r'''
import 'a.dart';
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        interface: #M3
          map
            foo: #M2
          implemented
            foo: #M2
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
    errors
      7 +8 UNUSED_IMPORT
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M4
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredFields
              foo: #M1
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
    errors
      7 +8 UNUSED_IMPORT
''',
      updatedA: r'''
class A {
  final double foo = 0;
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M5
        declaredGetters
          foo: #M6
        interface: #M7
          map
            foo: #M6
          implemented
            foo: #M6
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  instanceFieldIdMismatch
    libraryUri: package:test/a.dart
    interfaceName: A
    fieldName: foo
    expectedId: #M1
    actualId: #M5
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
    errors
      7 +8 UNUSED_IMPORT
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M4
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredFields
              foo: #M5
[status] idle
[future] getErrors T2
  ErrorsResult #3
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
    errors
      7 +8 UNUSED_IMPORT
''',
    );
  }

  test_dependency_class_instanceField_change_getField_other() async {
    _ManualRequirements.install((state) {
      var A = state.singleUnit.scopeInstanceElement('A');
      A.getField('foo');
    });

    await _runChangeScenarioTA(
      initialA: r'''
class A {
  final int foo = 0;
  final int bar = 0;
}
''',
      testCode: r'''
import 'a.dart';
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredFields
          bar: #M1
          foo: #M2
        declaredGetters
          bar: #M3
          foo: #M4
        interface: #M5
          map
            bar: #M3
            foo: #M4
          implemented
            bar: #M3
            foo: #M4
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
    errors
      7 +8 UNUSED_IMPORT
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M6
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredFields
              foo: #M2
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
    errors
      7 +8 UNUSED_IMPORT
''',
      updatedA: r'''
class A {
  final int foo = 0;
  final double bar = 0;
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredFields
          bar: #M7
          foo: #M2
        declaredGetters
          bar: #M8
          foo: #M4
        interface: #M9
          map
            bar: #M8
            foo: #M4
          implemented
            bar: #M8
            foo: #M4
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] getErrorsFromBytes
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[status] idle
[future] getErrors T2
  ErrorsResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
    errors
      7 +8 UNUSED_IMPORT
''',
    );
  }

  test_dependency_class_instanceGetter_add_extended() async {
    configuration.withStreamResolvedUnitResults = false;
    await _runChangeScenarioTA(
      initialA: r'''
class A {
  int get foo => 0;
}
''',
      testCode: r'''
import 'a.dart';
class B extends A {}
''',
      operation: _FineOperationGetTestLibrary(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        interface: #M3
          map
            foo: #M2
          implemented
            foo: #M2
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      B: #M4
        interface: #M5
          map
            foo: #M2
          implemented
            foo: #M2
          superImplemented
            [0]
              foo: #M2
          inherited
            foo: #M2
  requirements
    libraries
      package:test/a.dart
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        interfaces
          A
            interfaceId: #M3
            hasNonFinalField: false
            requestedConstructors
              new: #M6
[status] idle
[future] getLibraryByUri T1
  library
    classes
      class B
        supertype: A
        constructors
          synthetic new
''',
      updatedA: r'''
class A {
  int get foo => 0;
  int get bar => 0;
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredFields
          bar: #M7
          foo: #M1
        declaredGetters
          bar: #M8
          foo: #M2
        interface: #M9
          map
            bar: #M8
            foo: #M2
          implemented
            bar: #M8
            foo: #M2
  requirements
[operation] checkLinkedBundleRequirements
  package:test/test.dart
  interfaceIdMismatch
    libraryUri: package:test/a.dart
    interfaceName: A
    expectedId: #M3
    actualId: #M9
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      B: #M4
        interface: #M10
          map
            bar: #M8
            foo: #M2
          implemented
            bar: #M8
            foo: #M2
          superImplemented
            [0]
              bar: #M8
              foo: #M2
          inherited
            bar: #M8
            foo: #M2
  requirements
    libraries
      package:test/a.dart
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        interfaces
          A
            interfaceId: #M9
            hasNonFinalField: false
            requestedConstructors
              new: #M6
[status] idle
[future] getLibraryByUri T2
  library
    classes
      class B
        supertype: A
        constructors
          synthetic new
''',
    );
  }

  test_dependency_class_instanceGetter_add_getGetters() async {
    _ManualRequirements.install((state) {
      var A = state.singleUnit.scopeInstanceElement('A');
      A.getters;
    });

    await _runChangeScenarioTA(
      initialA: r'''
class A {
  int get foo => 0;
}
''',
      testCode: r'''
import 'a.dart';
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        interface: #M3
          map
            foo: #M2
          implemented
            foo: #M2
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
    errors
      7 +8 UNUSED_IMPORT
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M4
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            allDeclaredGetters: #M2
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
    errors
      7 +8 UNUSED_IMPORT
''',
      updatedA: r'''
class A {
  int get foo => 0;
  int get bar => 0;
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredFields
          bar: #M5
          foo: #M1
        declaredGetters
          bar: #M6
          foo: #M2
        interface: #M7
          map
            bar: #M6
            foo: #M2
          implemented
            bar: #M6
            foo: #M2
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  instanceChildrenIdsMismatch
    libraryUri: package:test/a.dart
    instanceName: A
    childrenPropertyName: getters
    expectedIds: #M2
    actualIds: #M2 #M6
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
    errors
      7 +8 UNUSED_IMPORT
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M4
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            allDeclaredGetters: #M2 #M6
[status] idle
[future] getErrors T2
  ErrorsResult #3
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
    errors
      7 +8 UNUSED_IMPORT
''',
    );
  }

  test_dependency_class_instanceGetter_change_classExtends_hasSetter() async {
    configuration.withStreamResolvedUnitResults = false;
    await _runChangeScenarioTA(
      initialA: r'''
class A {
  int get foo {}
  set foo(int _) {}
}
''',
      testCode: r'''
import 'a.dart';

class B extends A {}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        declaredSetters
          foo=: #M3
        interface: #M4
          map
            foo: #M2
            foo=: #M3
          implemented
            foo: #M2
            foo=: #M3
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      B: #M5
        interface: #M6
          map
            foo: #M2
            foo=: #M3
          implemented
            foo: #M2
            foo=: #M3
          superImplemented
            [0]
              foo: #M2
              foo=: #M3
          inherited
            foo: #M2
            foo=: #M3
  requirements
    libraries
      package:test/a.dart
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        interfaces
          A
            interfaceId: #M4
            hasNonFinalField: false
            requestedConstructors
              new: #M7
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        featureSet: <not-null>
        libraryMetadataId: #M8
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredFields
              foo: #M1
            allDeclaredGetters: #M2
            allDeclaredSetters: #M3
            allDeclaredMethods: []
        interfaces
          A
            allConstructors: #M7
            requestedConstructors
              new: #M7
[status] idle
[future] getErrors T1
  ErrorsResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updatedA: r'''
class A {
  double get foo {}
  set foo(int _) {}
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M9
        declaredGetters
          foo: #M10
        declaredSetters
          foo=: #M3
        interface: #M11
          map
            foo: #M10
            foo=: #M3
          implemented
            foo: #M10
            foo=: #M3
  requirements
[operation] checkLinkedBundleRequirements
  package:test/test.dart
  interfaceIdMismatch
    libraryUri: package:test/a.dart
    interfaceName: A
    expectedId: #M4
    actualId: #M11
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      B: #M5
        interface: #M12
          map
            foo: #M10
            foo=: #M3
          implemented
            foo: #M10
            foo=: #M3
          superImplemented
            [0]
              foo: #M10
              foo=: #M3
          inherited
            foo: #M10
            foo=: #M3
  requirements
    libraries
      package:test/a.dart
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        interfaces
          A
            interfaceId: #M11
            hasNonFinalField: false
            requestedConstructors
              new: #M7
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  instanceFieldIdMismatch
    libraryUri: package:test/a.dart
    interfaceName: A
    fieldName: foo
    expectedId: #M1
    actualId: #M9
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        featureSet: <not-null>
        libraryMetadataId: #M8
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredFields
              foo: #M9
            allDeclaredGetters: #M10
            allDeclaredSetters: #M3
            allDeclaredMethods: []
        interfaces
          A
            allConstructors: #M7
            requestedConstructors
              new: #M7
[status] idle
[future] getErrors T2
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
    );
  }

  test_dependency_class_instanceGetter_change_getField_getter() async {
    _ManualRequirements.install((state) {
      var A = state.singleUnit.scopeInstanceElement('A');
      A.getField('foo')?.getter;
    });

    await _runChangeScenarioTA(
      initialA: r'''
class A {
  int get foo => 0;
}
''',
      testCode: r'''
import 'a.dart';
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        interface: #M3
          map
            foo: #M2
          implemented
            foo: #M2
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
    errors
      7 +8 UNUSED_IMPORT
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M4
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredFields
              foo: #M1
            requestedDeclaredGetters
              foo: #M2
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
    errors
      7 +8 UNUSED_IMPORT
''',
      updatedA: r'''
class A {
  double get foo => 0;
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M5
        declaredGetters
          foo: #M6
        interface: #M7
          map
            foo: #M6
          implemented
            foo: #M6
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  instanceFieldIdMismatch
    libraryUri: package:test/a.dart
    interfaceName: A
    fieldName: foo
    expectedId: #M1
    actualId: #M5
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
    errors
      7 +8 UNUSED_IMPORT
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M4
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredFields
              foo: #M5
            requestedDeclaredGetters
              foo: #M6
[status] idle
[future] getErrors T2
  ErrorsResult #3
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
    errors
      7 +8 UNUSED_IMPORT
''',
    );
  }

  test_dependency_class_instanceGetter_change_getGetter() async {
    _ManualRequirements.install((state) {
      var A = state.singleUnit.scopeInstanceElement('A');
      A.getGetter('foo');
    });

    await _runChangeScenarioTA(
      initialA: r'''
class A {
  int get foo => 0;
}
''',
      testCode: r'''
import 'a.dart';
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        interface: #M3
          map
            foo: #M2
          implemented
            foo: #M2
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
    errors
      7 +8 UNUSED_IMPORT
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M4
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredGetters
              foo: #M2
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
    errors
      7 +8 UNUSED_IMPORT
''',
      updatedA: r'''
class A {
  double get foo => 0;
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M5
        declaredGetters
          foo: #M6
        interface: #M7
          map
            foo: #M6
          implemented
            foo: #M6
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  instanceMethodIdMismatch
    libraryUri: package:test/a.dart
    interfaceName: A
    methodName: foo
    expectedId: #M2
    actualId: #M6
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
    errors
      7 +8 UNUSED_IMPORT
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M4
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredGetters
              foo: #M6
[status] idle
[future] getErrors T2
  ErrorsResult #3
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
    errors
      7 +8 UNUSED_IMPORT
''',
    );
  }

  test_dependency_class_instanceGetter_change_getGetter_other() async {
    _ManualRequirements.install((state) {
      var A = state.singleUnit.scopeInstanceElement('A');
      A.getGetter('foo');
    });

    await _runChangeScenarioTA(
      initialA: r'''
class A {
  int get foo => 0;
  int get bar => 0;
}
''',
      testCode: r'''
import 'a.dart';
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredFields
          bar: #M1
          foo: #M2
        declaredGetters
          bar: #M3
          foo: #M4
        interface: #M5
          map
            bar: #M3
            foo: #M4
          implemented
            bar: #M3
            foo: #M4
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
    errors
      7 +8 UNUSED_IMPORT
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M6
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredGetters
              foo: #M4
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
    errors
      7 +8 UNUSED_IMPORT
''',
      updatedA: r'''
class A {
  int get foo => 0;
  double get bar => 0;
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredFields
          bar: #M7
          foo: #M2
        declaredGetters
          bar: #M8
          foo: #M4
        interface: #M9
          map
            bar: #M8
            foo: #M4
          implemented
            bar: #M8
            foo: #M4
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] getErrorsFromBytes
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[status] idle
[future] getErrors T2
  ErrorsResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
    errors
      7 +8 UNUSED_IMPORT
''',
    );
  }

  test_dependency_class_instanceGetter_change_invoked() async {
    await _runChangeScenarioTA(
      initialA: r'''
class A {
  int get foo => 0;
}
''',
      testCode: r'''
import 'a.dart';
void f(A a) {
  a.foo;
}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        interface: #M3
          map
            foo: #M2
          implemented
            foo: #M2
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M4
  requirements
    libraries
      package:test/a.dart
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M5
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredFields
              foo: #M1
        interfaces
          A
            methods
              foo: #M2
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updatedA: r'''
class A {
  double get foo => 1.2;
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M6
        declaredGetters
          foo: #M7
        interface: #M8
          map
            foo: #M7
          implemented
            foo: #M7
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  instanceFieldIdMismatch
    libraryUri: package:test/a.dart
    interfaceName: A
    fieldName: foo
    expectedId: #M1
    actualId: #M6
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M5
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredFields
              foo: #M6
        interfaces
          A
            methods
              foo: #M7
[status] idle
[future] getErrors T2
  ErrorsResult #3
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
    );
  }

  test_dependency_class_instanceGetter_change_invoked_hasNamedConstructor_hasInstanceSetter() async {
    configuration.withStreamResolvedUnitResults = false;
    await _runChangeScenarioTA(
      initialA: r'''
class A {
  A.foo(int _);
  int get foo {}
  set foo(int _) {}
}
''',
      testCode: r'''
import 'a.dart';
void f() {
  var a = A.foo(0);
  a.foo;
  a.foo = 0;
}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        declaredSetters
          foo=: #M3
        declaredConstructors
          foo: #M4
        interface: #M5
          map
            foo: #M2
            foo=: #M3
          implemented
            foo: #M2
            foo=: #M3
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M6
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M7
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredFields
              foo: #M1
        interfaces
          A
            requestedConstructors
              foo: #M4
            methods
              foo: #M2
              foo=: #M3
[status] idle
[future] getErrors T1
  ErrorsResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updatedA: r'''
class A {
  A.foo(int _);
  double get foo {}
  set foo(int _) {}
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M8
        declaredGetters
          foo: #M9
        declaredSetters
          foo=: #M3
        declaredConstructors
          foo: #M4
        interface: #M10
          map
            foo: #M9
            foo=: #M3
          implemented
            foo: #M9
            foo=: #M3
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  instanceFieldIdMismatch
    libraryUri: package:test/a.dart
    interfaceName: A
    fieldName: foo
    expectedId: #M1
    actualId: #M8
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M7
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredFields
              foo: #M8
        interfaces
          A
            requestedConstructors
              foo: #M4
            methods
              foo: #M9
              foo=: #M3
[status] idle
[future] getErrors T2
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
    );
  }

  test_dependency_class_instanceGetter_change_notUsed() async {
    await _runChangeScenarioTA(
      initialA: r'''
class A {
  int get foo => 0;
  int get bar => 0;
}
''',
      testCode: r'''
import 'a.dart';
void f(A a) {
  a.foo;
}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredFields
          bar: #M1
          foo: #M2
        declaredGetters
          bar: #M3
          foo: #M4
        interface: #M5
          map
            bar: #M3
            foo: #M4
          implemented
            bar: #M3
            foo: #M4
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M6
  requirements
    libraries
      package:test/a.dart
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M7
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredFields
              foo: #M2
        interfaces
          A
            methods
              foo: #M4
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updatedA: r'''
class A {
  int get foo => 0;
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M2
        declaredGetters
          foo: #M4
        interface: #M8
          map
            foo: #M4
          implemented
            foo: #M4
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] getErrorsFromBytes
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[status] idle
[future] getErrors T2
  ErrorsResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
    );
  }

  test_dependency_class_instanceGetter_inherited_fromGeneric_extends_changeTypeArgument() async {
    configuration.withStreamResolvedUnitResults = false;
    await _runChangeScenarioTA(
      initialA: r'''
class A<T> {
  T get foo {}
}

class B extends A<int> {}
''',
      testCode: r'''
import 'a.dart';
void f(B b) {
  b.foo;
}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        interface: #M3
          map
            foo: #M2
          implemented
            foo: #M2
      B: #M4
        interface: #M5
          map
            foo: #M2
          implemented
            foo: #M2
          superImplemented
            [0]
              foo: #M2
          inherited
            foo: #M2
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M6
  requirements
    libraries
      package:test/a.dart
        exportedTopLevels
          B: #M4
          B=: <null>
        reExportDeprecatedOnly
          B: false
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M7
        exportedTopLevels
          B: #M4
          B=: <null>
        reExportDeprecatedOnly
          B: false
        instances
          A
            requestedDeclaredFields
              foo: #M1
        interfaces
          B
            methods
              foo: #M2
[status] idle
[future] getErrors T1
  ErrorsResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updatedA: r'''
class A<T> {
  T get foo {}
}

class B extends A<double> {}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        interface: #M3
          map
            foo: #M2
          implemented
            foo: #M2
      B: #M8
        interface: #M9
          map
            foo: #M2
          implemented
            foo: #M2
          superImplemented
            [0]
              foo: #M2
          inherited
            foo: #M2
  requirements
[operation] checkLinkedBundleRequirements
  package:test/test.dart
  topLevelIdMismatch
    libraryUri: package:test/a.dart
    name: B
    expectedId: #M4
    actualId: #M8
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M10
  requirements
    libraries
      package:test/a.dart
        exportedTopLevels
          B: #M8
          B=: <null>
        reExportDeprecatedOnly
          B: false
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  topLevelIdMismatch
    libraryUri: package:test/a.dart
    name: B
    expectedId: #M4
    actualId: #M8
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M7
        exportedTopLevels
          B: #M8
          B=: <null>
        reExportDeprecatedOnly
          B: false
        instances
          A
            requestedDeclaredFields
              foo: #M1
        interfaces
          B
            methods
              foo: #M2
[status] idle
[future] getErrors T2
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
    );
  }

  test_dependency_class_instanceGetter_inherited_fromGeneric_implements_changeTypeArgument() async {
    configuration.withStreamResolvedUnitResults = false;
    await _runChangeScenarioTA(
      initialA: r'''
class A<T> {
  T get foo {}
}

class B implements A<int> {}
''',
      testCode: r'''
import 'a.dart';
void f(B b) {
  b.foo;
}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        interface: #M3
          map
            foo: #M2
          implemented
            foo: #M2
      B: #M4
        interface: #M5
          map
            foo: #M2
          inherited
            foo: #M2
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M6
  requirements
    libraries
      package:test/a.dart
        exportedTopLevels
          B: #M4
          B=: <null>
        reExportDeprecatedOnly
          B: false
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M7
        exportedTopLevels
          B: #M4
          B=: <null>
        reExportDeprecatedOnly
          B: false
        instances
          A
            requestedDeclaredFields
              foo: #M1
        interfaces
          B
            methods
              foo: #M2
[status] idle
[future] getErrors T1
  ErrorsResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updatedA: r'''
class A<T> {
  T get foo {}
}

class B implements A<double> {}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        interface: #M3
          map
            foo: #M2
          implemented
            foo: #M2
      B: #M8
        interface: #M9
          map
            foo: #M2
          inherited
            foo: #M2
  requirements
[operation] checkLinkedBundleRequirements
  package:test/test.dart
  topLevelIdMismatch
    libraryUri: package:test/a.dart
    name: B
    expectedId: #M4
    actualId: #M8
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M10
  requirements
    libraries
      package:test/a.dart
        exportedTopLevels
          B: #M8
          B=: <null>
        reExportDeprecatedOnly
          B: false
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  topLevelIdMismatch
    libraryUri: package:test/a.dart
    name: B
    expectedId: #M4
    actualId: #M8
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M7
        exportedTopLevels
          B: #M8
          B=: <null>
        reExportDeprecatedOnly
          B: false
        instances
          A
            requestedDeclaredFields
              foo: #M1
        interfaces
          B
            methods
              foo: #M2
[status] idle
[future] getErrors T2
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
    );
  }

  test_dependency_class_instanceGetter_inherited_fromGeneric_with_changeTypeArgument() async {
    configuration.withStreamResolvedUnitResults = false;
    await _runChangeScenarioTA(
      initialA: r'''
class A<T> {
  T get foo {}
}

class B with A<int> {}
''',
      testCode: r'''
import 'a.dart';
void f(B b) {
  b.foo;
}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        interface: #M3
          map
            foo: #M2
          implemented
            foo: #M2
      B: #M4
        interface: #M5
          map
            foo: #M2
          implemented
            foo: #M2
          superImplemented
            [1]
              foo: #M2
          inherited
            foo: #M2
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M6
  requirements
    libraries
      package:test/a.dart
        exportedTopLevels
          B: #M4
          B=: <null>
        reExportDeprecatedOnly
          B: false
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M7
        exportedTopLevels
          B: #M4
          B=: <null>
        reExportDeprecatedOnly
          B: false
        instances
          A
            requestedDeclaredFields
              foo: #M1
        interfaces
          B
            methods
              foo: #M2
[status] idle
[future] getErrors T1
  ErrorsResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updatedA: r'''
class A<T> {
  T get foo {}
}

class B with A<double> {}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        interface: #M3
          map
            foo: #M2
          implemented
            foo: #M2
      B: #M8
        interface: #M9
          map
            foo: #M2
          implemented
            foo: #M2
          superImplemented
            [1]
              foo: #M2
          inherited
            foo: #M2
  requirements
[operation] checkLinkedBundleRequirements
  package:test/test.dart
  topLevelIdMismatch
    libraryUri: package:test/a.dart
    name: B
    expectedId: #M4
    actualId: #M8
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M10
  requirements
    libraries
      package:test/a.dart
        exportedTopLevels
          B: #M8
          B=: <null>
        reExportDeprecatedOnly
          B: false
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  topLevelIdMismatch
    libraryUri: package:test/a.dart
    name: B
    expectedId: #M4
    actualId: #M8
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M7
        exportedTopLevels
          B: #M8
          B=: <null>
        reExportDeprecatedOnly
          B: false
        instances
          A
            requestedDeclaredFields
              foo: #M1
        interfaces
          B
            methods
              foo: #M2
[status] idle
[future] getErrors T2
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
    );
  }

  test_dependency_class_instanceGetter_inherited_private() async {
    // Test that there is a dependency between `f()` and `A._foo`.
    // So, that we re-analyze `f()` body when `A._foo` changes.
    // Currently this dependency is implicit: we analyze the whole library
    // when any of its files changes.
    configuration.withStreamResolvedUnitResults = false;

    newFile(testFile.path, r'''
class A {
  int get _foo => 0;
}

class B extends A {}

void f (B b) {
  b._foo.isEven;
}
''');

    await _runChangeScenario(
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          _foo: #M1
        declaredGetters
          _foo: #M2
        interface: #M3
      B: #M4
        interface: #M5
    declaredFunctions
      f: #M6
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
[status] idle
[future] getErrors T1
  ErrorsResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updateFiles: () {
        modifyFile2(testFile, r'''
class A {
  String get _foo => '';
}

class B extends A {}

void f (B b) {
  b._foo.isEven;
}
''');
        return [testFile];
      },
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          _foo: #M7
        declaredGetters
          _foo: #M8
        interface: #M3
      B: #M4
        interface: #M5
    declaredFunctions
      f: #M6
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
[status] idle
[future] getErrors T2
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
    errors
      84 +6 UNDEFINED_GETTER
''',
    );
  }

  test_dependency_class_instanceMethod_add_classExtends() async {
    configuration.withStreamResolvedUnitResults = false;
    await _runChangeScenarioTA(
      initialA: r'''
class A {
  void foo() {}
}
''',
      testCode: r'''
import 'a.dart';
class B extends A {}
''',
      operation: _FineOperationGetTestLibrary(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      B: #M3
        interface: #M4
          map
            foo: #M1
          implemented
            foo: #M1
          superImplemented
            [0]
              foo: #M1
          inherited
            foo: #M1
  requirements
    libraries
      package:test/a.dart
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        interfaces
          A
            interfaceId: #M2
            hasNonFinalField: false
            requestedConstructors
              new: #M5
[status] idle
[future] getLibraryByUri T1
  library
    classes
      class B
        supertype: A
        constructors
          synthetic new
''',
      updatedA: r'''
class A {
  void foo() {}
  void bar() {}
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredMethods
          bar: #M6
          foo: #M1
        interface: #M7
          map
            bar: #M6
            foo: #M1
          implemented
            bar: #M6
            foo: #M1
  requirements
[operation] checkLinkedBundleRequirements
  package:test/test.dart
  interfaceIdMismatch
    libraryUri: package:test/a.dart
    interfaceName: A
    expectedId: #M2
    actualId: #M7
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      B: #M3
        interface: #M8
          map
            bar: #M6
            foo: #M1
          implemented
            bar: #M6
            foo: #M1
          superImplemented
            [0]
              bar: #M6
              foo: #M1
          inherited
            bar: #M6
            foo: #M1
  requirements
    libraries
      package:test/a.dart
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        interfaces
          A
            interfaceId: #M7
            hasNonFinalField: false
            requestedConstructors
              new: #M5
[status] idle
[future] getLibraryByUri T2
  library
    classes
      class B
        supertype: A
        constructors
          synthetic new
''',
    );
  }

  test_dependency_class_instanceMethod_add_getMethods() async {
    _ManualRequirements.install((state) {
      var A = state.singleUnit.scopeInstanceElement('A');
      A.methods;
    });

    await _runChangeScenarioTA(
      initialA: r'''
class A {
  void foo() {}
}
''',
      testCode: r'''
import 'a.dart';
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
    errors
      7 +8 UNUSED_IMPORT
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M3
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            allDeclaredMethods: #M1
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
    errors
      7 +8 UNUSED_IMPORT
''',
      updatedA: r'''
class A {
  void foo() {}
  void bar() {}
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredMethods
          bar: #M4
          foo: #M1
        interface: #M5
          map
            bar: #M4
            foo: #M1
          implemented
            bar: #M4
            foo: #M1
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  instanceChildrenIdsMismatch
    libraryUri: package:test/a.dart
    instanceName: A
    childrenPropertyName: methods
    expectedIds: #M1
    actualIds: #M1 #M4
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
    errors
      7 +8 UNUSED_IMPORT
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M3
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            allDeclaredMethods: #M1 #M4
[status] idle
[future] getErrors T2
  ErrorsResult #3
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
    errors
      7 +8 UNUSED_IMPORT
''',
    );
  }

  test_dependency_class_instanceMethod_add_invoked() async {
    configuration.withStreamResolvedUnitResults = false;
    await _runChangeScenarioTA(
      initialA: r'''
class A {}
''',
      testCode: r'''
import 'a.dart';
void f(A a) {
  a.foo();
}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        interface: #M1
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M2
  requirements
    libraries
      package:test/a.dart
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M3
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredGetters
              foo: <null>
            requestedDeclaredMethods
              foo: <null>
        interfaces
          A
            methods
              foo: <null>
              foo=: <null>
        exportedExtensions: []
[status] idle
[future] getErrors T1
  ErrorsResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
    errors
      35 +3 UNDEFINED_METHOD
''',
      updatedA: r'''
class A {
  int foo() {}
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M4
        interface: #M5
          map
            foo: #M4
          implemented
            foo: #M4
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  instanceMethodIdMismatch
    libraryUri: package:test/a.dart
    interfaceName: A
    methodName: foo
    expectedId: <null>
    actualId: #M4
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M3
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        interfaces
          A
            methods
              foo: #M4
[status] idle
[future] getErrors T2
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
    );
  }

  test_dependency_class_instanceMethod_change_classExtends() async {
    configuration.withStreamResolvedUnitResults = false;
    await _runChangeScenarioTA(
      initialA: r'''
class A {
  void foo() {}
  void bar() {}
}
''',
      testCode: r'''
import 'a.dart';

class B extends A {}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredMethods
          bar: #M1
          foo: #M2
        interface: #M3
          map
            bar: #M1
            foo: #M2
          implemented
            bar: #M1
            foo: #M2
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      B: #M4
        interface: #M5
          map
            bar: #M1
            foo: #M2
          implemented
            bar: #M1
            foo: #M2
          superImplemented
            [0]
              bar: #M1
              foo: #M2
          inherited
            bar: #M1
            foo: #M2
  requirements
    libraries
      package:test/a.dart
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        interfaces
          A
            interfaceId: #M3
            hasNonFinalField: false
            requestedConstructors
              new: #M6
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        featureSet: <not-null>
        libraryMetadataId: #M7
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            allDeclaredGetters: []
            allDeclaredSetters: []
            allDeclaredMethods: #M2 #M1
        interfaces
          A
            allConstructors: #M6
            requestedConstructors
              new: #M6
[status] idle
[future] getErrors T1
  ErrorsResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updatedA: r'''
class A {
  int foo() {}
  void bar() {}
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredMethods
          bar: #M1
          foo: #M8
        interface: #M9
          map
            bar: #M1
            foo: #M8
          implemented
            bar: #M1
            foo: #M8
  requirements
[operation] checkLinkedBundleRequirements
  package:test/test.dart
  interfaceIdMismatch
    libraryUri: package:test/a.dart
    interfaceName: A
    expectedId: #M3
    actualId: #M9
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      B: #M4
        interface: #M10
          map
            bar: #M1
            foo: #M8
          implemented
            bar: #M1
            foo: #M8
          superImplemented
            [0]
              bar: #M1
              foo: #M8
          inherited
            bar: #M1
            foo: #M8
  requirements
    libraries
      package:test/a.dart
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        interfaces
          A
            interfaceId: #M9
            hasNonFinalField: false
            requestedConstructors
              new: #M6
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  instanceChildrenIdsMismatch
    libraryUri: package:test/a.dart
    instanceName: A
    childrenPropertyName: methods
    expectedIds: #M2 #M1
    actualIds: #M8 #M1
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        featureSet: <not-null>
        libraryMetadataId: #M7
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            allDeclaredGetters: []
            allDeclaredSetters: []
            allDeclaredMethods: #M8 #M1
        interfaces
          A
            allConstructors: #M6
            requestedConstructors
              new: #M6
[status] idle
[future] getErrors T2
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
    );
  }

  test_dependency_class_instanceMethod_change_classExtends_topMerged() async {
    configuration.withStreamResolvedUnitResults = false;
    await _runChangeScenarioTA(
      initialA: r'''
class A {
  void foo() {}
}

class B {
  dynamic foo() {}
}

class C extends A implements B {}
''',
      testCode: r'''
import 'a.dart';

class X extends C {}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
      B: #M3
        declaredMethods
          foo: #M4
        interface: #M5
          map
            foo: #M4
          implemented
            foo: #M4
      C: #M6
        interface: #M7
          map
            foo: #M8
          combinedIds
            [#M1, #M4]: #M8
          implemented
            foo: #M1
          superImplemented
            [0]
              foo: #M1
          inherited
            foo: #M8
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      X: #M9
        interface: #M10
          map
            foo: #M8
          implemented
            foo: #M1
          superImplemented
            [0]
              foo: #M1
          inherited
            foo: #M8
  requirements
    libraries
      package:test/a.dart
        exportedTopLevels
          C: #M6
          C=: <null>
        reExportDeprecatedOnly
          C: false
        interfaces
          C
            interfaceId: #M7
            hasNonFinalField: false
            requestedConstructors
              new: #M11
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        featureSet: <not-null>
        libraryMetadataId: #M12
        exportedTopLevels
          C: #M6
          C=: <null>
        reExportDeprecatedOnly
          C: false
        instances
          A
            allDeclaredGetters: []
            allDeclaredSetters: []
            allDeclaredMethods: #M1
          B
            allDeclaredGetters: []
            allDeclaredSetters: []
            allDeclaredMethods: #M4
          C
            allDeclaredGetters: []
            allDeclaredSetters: []
            allDeclaredMethods: []
        interfaces
          C
            allConstructors: #M11
            requestedConstructors
              new: #M11
[status] idle
[future] getErrors T1
  ErrorsResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updatedA: r'''
class A {
  int foo() {}
}

class B {
  dynamic foo() {}
}

class C extends A implements B {}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M13
        interface: #M14
          map
            foo: #M13
          implemented
            foo: #M13
      B: #M3
        declaredMethods
          foo: #M4
        interface: #M5
          map
            foo: #M4
          implemented
            foo: #M4
      C: #M6
        interface: #M15
          map
            foo: #M16
          combinedIds
            [#M13, #M4]: #M16
          implemented
            foo: #M13
          superImplemented
            [0]
              foo: #M13
          inherited
            foo: #M13
  requirements
[operation] checkLinkedBundleRequirements
  package:test/test.dart
  interfaceIdMismatch
    libraryUri: package:test/a.dart
    interfaceName: C
    expectedId: #M7
    actualId: #M15
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      X: #M9
        interface: #M17
          map
            foo: #M13
          implemented
            foo: #M13
          superImplemented
            [0]
              foo: #M13
          inherited
            foo: #M13
  requirements
    libraries
      package:test/a.dart
        exportedTopLevels
          C: #M6
          C=: <null>
        reExportDeprecatedOnly
          C: false
        interfaces
          C
            interfaceId: #M15
            hasNonFinalField: false
            requestedConstructors
              new: #M11
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  instanceChildrenIdsMismatch
    libraryUri: package:test/a.dart
    instanceName: A
    childrenPropertyName: methods
    expectedIds: #M1
    actualIds: #M13
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        featureSet: <not-null>
        libraryMetadataId: #M12
        exportedTopLevels
          C: #M6
          C=: <null>
        reExportDeprecatedOnly
          C: false
        instances
          A
            allDeclaredGetters: []
            allDeclaredSetters: []
            allDeclaredMethods: #M13
          B
            allDeclaredGetters: []
            allDeclaredSetters: []
            allDeclaredMethods: #M4
          C
            allDeclaredGetters: []
            allDeclaredSetters: []
            allDeclaredMethods: []
        interfaces
          C
            allConstructors: #M11
            requestedConstructors
              new: #M11
[status] idle
[future] getErrors T2
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
    );
  }

  test_dependency_class_instanceMethod_change_getInterfaceMember() async {
    configuration
      ..withGetErrorsEvents = false
      ..withStreamResolvedUnitResults = false;

    _ManualRequirements.install((state) {
      var B = state.singleUnit.scopeClassElement('B');
      B.getInterfaceMember(Name(null, 'foo'));
    });

    await _runChangeScenarioTA(
      initialA: r'''
abstract class A {
  int foo();
}

abstract class B extends A {}
''',
      testCode: r'''
import 'a.dart';
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
      B: #M3
        interface: #M4
          map
            foo: #M1
          inherited
            foo: #M1
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M5
        exportedTopLevels
          B: #M3
          B=: <null>
        reExportDeprecatedOnly
          B: false
        interfaces
          B
            methods
              foo: #M1
[status] idle
''',
      updatedA: r'''
abstract class A {
  double foo();
}

abstract class B extends A {}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M6
        interface: #M7
          map
            foo: #M6
      B: #M3
        interface: #M8
          map
            foo: #M6
          inherited
            foo: #M6
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  instanceMethodIdMismatch
    libraryUri: package:test/a.dart
    interfaceName: B
    methodName: foo
    expectedId: #M1
    actualId: #M6
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M5
        exportedTopLevels
          B: #M3
          B=: <null>
        reExportDeprecatedOnly
          B: false
        interfaces
          B
            methods
              foo: #M6
[status] idle
''',
    );
  }

  test_dependency_class_instanceMethod_change_getMethod() async {
    _ManualRequirements.install((state) {
      var A = state.singleUnit.scopeInstanceElement('A');
      A.getMethod('foo');
    });

    await _runChangeScenarioTA(
      initialA: r'''
class A {
  int foo() {}
}
''',
      testCode: r'''
import 'a.dart';
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
    errors
      7 +8 UNUSED_IMPORT
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M3
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredMethods
              foo: #M1
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
    errors
      7 +8 UNUSED_IMPORT
''',
      updatedA: r'''
class A {
  double foo() {}
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M4
        interface: #M5
          map
            foo: #M4
          implemented
            foo: #M4
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  instanceMethodIdMismatch
    libraryUri: package:test/a.dart
    interfaceName: A
    methodName: foo
    expectedId: #M1
    actualId: #M4
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
    errors
      7 +8 UNUSED_IMPORT
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M3
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredMethods
              foo: #M4
[status] idle
[future] getErrors T2
  ErrorsResult #3
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
    errors
      7 +8 UNUSED_IMPORT
''',
    );
  }

  test_dependency_class_instanceMethod_change_getMethod_other() async {
    _ManualRequirements.install((state) {
      var A = state.singleUnit.scopeInstanceElement('A');
      A.getMethod('foo');
    });

    await _runChangeScenarioTA(
      initialA: r'''
class A {
  int foo() {}
  int bar() {}
}
''',
      testCode: r'''
import 'a.dart';
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredMethods
          bar: #M1
          foo: #M2
        interface: #M3
          map
            bar: #M1
            foo: #M2
          implemented
            bar: #M1
            foo: #M2
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
    errors
      7 +8 UNUSED_IMPORT
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M4
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredMethods
              foo: #M2
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
    errors
      7 +8 UNUSED_IMPORT
''',
      updatedA: r'''
class A {
  int foo() {}
  double bar() {}
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredMethods
          bar: #M5
          foo: #M2
        interface: #M6
          map
            bar: #M5
            foo: #M2
          implemented
            bar: #M5
            foo: #M2
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] getErrorsFromBytes
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[status] idle
[future] getErrors T2
  ErrorsResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
    errors
      7 +8 UNUSED_IMPORT
''',
    );
  }

  test_dependency_class_instanceMethod_change_inheritanceManager_getInheritedMap_shadowed() async {
    configuration
      ..withGetErrorsEvents = false
      ..withStreamResolvedUnitResults = false;

    _ManualRequirements.install((state) {
      var B = state.singleUnit.scopeClassElement('B');
      B.inheritanceManager.getInheritedMap(B);
    });

    await _runChangeScenarioTA(
      initialA: r'''
abstract class A {
  int foo();
}

abstract class B extends A {
  void foo();
}
''',
      testCode: r'''
import 'a.dart';
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
      B: #M3
        declaredMethods
          foo: #M4
        interface: #M5
          map
            foo: #M4
          inherited
            foo: #M1
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M6
        exportedTopLevels
          B: #M3
          B=: <null>
        reExportDeprecatedOnly
          B: false
        interfaces
          B
            interfaceId: #M5
[status] idle
''',
      updatedA: r'''
abstract class A {
  double foo();
}

abstract class B extends A {
  void foo();
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M7
        interface: #M8
          map
            foo: #M7
      B: #M3
        declaredMethods
          foo: #M4
        interface: #M9
          map
            foo: #M4
          inherited
            foo: #M7
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  interfaceIdMismatch
    libraryUri: package:test/a.dart
    interfaceName: B
    expectedId: #M5
    actualId: #M9
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M6
        exportedTopLevels
          B: #M3
          B=: <null>
        reExportDeprecatedOnly
          B: false
        interfaces
          B
            interfaceId: #M9
[status] idle
''',
    );
  }

  test_dependency_class_instanceMethod_change_inheritanceManager_getInheritedMap_shadowed2() async {
    configuration
      ..withGetErrorsEvents = false
      ..withStreamResolvedUnitResults = false;

    _ManualRequirements.install((state) {
      var C = state.singleUnit.scopeClassElement('C');
      C.inheritanceManager.getInheritedMap(C);
    });

    await _runChangeScenarioTA(
      initialA: r'''
abstract class A {
  int foo();
}

abstract class B extends A {
  void foo();
}

abstract class C extends B {}
''',
      testCode: r'''
import 'a.dart';
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
      B: #M3
        declaredMethods
          foo: #M4
        interface: #M5
          map
            foo: #M4
          inherited
            foo: #M1
      C: #M6
        interface: #M7
          map
            foo: #M4
          inherited
            foo: #M4
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M8
        exportedTopLevels
          C: #M6
          C=: <null>
        reExportDeprecatedOnly
          C: false
        interfaces
          C
            interfaceId: #M7
[status] idle
''',
      updatedA: r'''
abstract class A {
  double foo();
}

abstract class B extends A {
  void foo();
}

abstract class C extends B {}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M9
        interface: #M10
          map
            foo: #M9
      B: #M3
        declaredMethods
          foo: #M4
        interface: #M11
          map
            foo: #M4
          inherited
            foo: #M9
      C: #M6
        interface: #M7
          map
            foo: #M4
          inherited
            foo: #M4
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] getErrorsFromBytes
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[status] idle
''',
    );
  }

  test_dependency_class_instanceMethod_change_invoked() async {
    await _runChangeScenarioTA(
      initialA: r'''
class A {
  int foo() {}
}
''',
      testCode: r'''
import 'a.dart';
void f(A a) {
  a.foo();
}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M3
  requirements
    libraries
      package:test/a.dart
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M4
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        interfaces
          A
            methods
              foo: #M1
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updatedA: r'''
class A {
  double foo() {}
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M5
        interface: #M6
          map
            foo: #M5
          implemented
            foo: #M5
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  instanceMethodIdMismatch
    libraryUri: package:test/a.dart
    interfaceName: A
    methodName: foo
    expectedId: #M1
    actualId: #M5
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M4
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        interfaces
          A
            methods
              foo: #M5
[status] idle
[future] getErrors T2
  ErrorsResult #3
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
    );
  }

  test_dependency_class_instanceMethod_change_invoked_hasNamedConstructor() async {
    configuration.withStreamResolvedUnitResults = false;
    await _runChangeScenarioTA(
      initialA: r'''
class A {
  A.foo(int _);
  int foo() {}
}
''',
      testCode: r'''
import 'a.dart';
void f() {
  A.foo(0).foo();
}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        declaredConstructors
          foo: #M2
        interface: #M3
          map
            foo: #M1
          implemented
            foo: #M1
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M4
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M5
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        interfaces
          A
            requestedConstructors
              foo: #M2
            methods
              foo: #M1
[status] idle
[future] getErrors T1
  ErrorsResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updatedA: r'''
class A {
  A.foo(int _);
  double foo() {}
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M6
        declaredConstructors
          foo: #M2
        interface: #M7
          map
            foo: #M6
          implemented
            foo: #M6
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  instanceMethodIdMismatch
    libraryUri: package:test/a.dart
    interfaceName: A
    methodName: foo
    expectedId: #M1
    actualId: #M6
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M5
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        interfaces
          A
            requestedConstructors
              foo: #M2
            methods
              foo: #M6
[status] idle
[future] getErrors T2
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
    );
  }

  test_dependency_class_instanceMethod_change_invoked_private() async {
    configuration.withStreamResolvedUnitResults = false;

    newFile(testFile.path, r'''
class A {
  int _foo() => 0;
}

class B extends A {}

void f(B b) {
  b._foo();
}
''');

    // Note:
    // 1. No `_foo` in `B`, even though it is in the same library.
    // 2. No dependency of `test.dart` on `_foo` through `B`.
    // However: we reanalyze `test.dart` when we change it, because we
    // always analyze the whole library when one of its files changes.
    // So, we don't need a separate dependency on `_foo`.
    await _runChangeScenario(
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          _foo: #M1
        interface: #M2
      B: #M3
        interface: #M4
    declaredFunctions
      f: #M5
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
[status] idle
[future] getErrors T1
  ErrorsResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updateFiles: () {
        modifyFile2(testFile, r'''
class A {
  double _foo() => 0;
}

class B extends A {}

void f(B b) {
  b._foo();
}
''');
        return [testFile];
      },
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          _foo: #M6
        interface: #M2
      B: #M3
        interface: #M4
    declaredFunctions
      f: #M5
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
[status] idle
[future] getErrors T2
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
    );
  }

  test_dependency_class_instanceMethod_change_invoked_private2() async {
    configuration.withStreamResolvedUnitResults = false;

    newFile('$testPackageLibPath/a.dart', r'''
import 'test.dart';

class B extends A {}
''');

    newFile(testFile.path, r'''
import 'a.dart';

class A {
  void _foo() {}
}

void f(B b) {
  b._foo();
}
''');

    // Note:
    // 1. No `_foo` in `B`.
    // 2. No dependency of `test.dart` on `_foo` through `B`.
    // However: we reanalyze `test.dart` when we change it, because we
    // always analyze the whole library when one of its files changes.
    // So, we don't need a separate dependency on `_foo`.
    await _runChangeScenario(
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      B: #M0
        interface: #M1
  package:test/test.dart
    declaredClasses
      A: #M2
        declaredMethods
          _foo: #M3
        interface: #M4
    declaredFunctions
      f: #M5
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M6
        exportedTopLevels
          B: #M0
          B=: <null>
        reExportDeprecatedOnly
          B: false
[status] idle
[future] getErrors T1
  ErrorsResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updateFiles: () {
        modifyFile2(testFile, r'''
import 'a.dart';

class A {
  void _bar() {}
}

void f(B b) {
  b._foo();
}
''');
        return [testFile];
      },
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      B: #M0
        interface: #M1
  package:test/test.dart
    declaredClasses
      A: #M2
        declaredMethods
          _bar: #M7
        interface: #M4
    declaredFunctions
      f: #M5
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M6
        exportedTopLevels
          B: #M0
          B=: <null>
        reExportDeprecatedOnly
          B: false
        instances
          B
            requestedDeclaredGetters
              _foo: <null>
            requestedDeclaredMethods
              _foo: <null>
        exportedExtensions: []
[status] idle
[future] getErrors T2
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
    errors
      66 +4 UNDEFINED_METHOD
      35 +4 UNUSED_ELEMENT
''',
    );
  }

  test_dependency_class_instanceMethod_change_lookUpMethod() async {
    configuration
      ..withGetErrorsEvents = false
      ..withStreamResolvedUnitResults = false;

    _ManualRequirements.install((state) {
      var A = state.singleUnit.scopeClassElement('A');
      A.thisType.lookUpMethod('foo', A.library);
    });

    await _runChangeScenarioTA(
      initialA: r'''
abstract class A {
  int foo();
}
''',
      testCode: r'''
import 'a.dart';
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M3
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        interfaces
          A
            methods
              foo: #M1
[status] idle
''',
      updatedA: r'''
abstract class A {
  double foo();
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M4
        interface: #M5
          map
            foo: #M4
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  instanceMethodIdMismatch
    libraryUri: package:test/a.dart
    interfaceName: A
    methodName: foo
    expectedId: #M1
    actualId: #M4
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M3
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        interfaces
          A
            methods
              foo: #M4
[status] idle
''',
    );
  }

  test_dependency_class_instanceMethod_change_lookUpMethod_concrete() async {
    configuration
      ..withGetErrorsEvents = false
      ..withStreamResolvedUnitResults = false;

    _ManualRequirements.install((state) {
      var A = state.singleUnit.scopeClassElement('A');
      A.thisType.lookUpMethod('foo', A.library, concrete: true);
    });

    await _runChangeScenarioTA(
      initialA: r'''
class A {
  int foo() {}
}
''',
      testCode: r'''
import 'a.dart';
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M3
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        interfaces
          A
            implementedMethods
              foo: #M1
[status] idle
''',
      updatedA: r'''
class A {
  double foo() {}
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M4
        interface: #M5
          map
            foo: #M4
          implemented
            foo: #M4
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  implementedMethodIdMismatch
    libraryUri: package:test/a.dart
    interfaceName: A
    methodName: foo
    expectedId: #M1
    actualId: #M4
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M3
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        interfaces
          A
            implementedMethods
              foo: #M4
[status] idle
''',
    );
  }

  test_dependency_class_instanceMethod_change_lookUpMethod_concrete_makeAbstract() async {
    configuration
      ..withGetErrorsEvents = false
      ..withStreamResolvedUnitResults = false;

    _ManualRequirements.install((state) {
      var A = state.singleUnit.scopeClassElement('A');
      A.thisType.lookUpMethod('foo', A.library, concrete: true);
    });

    await _runChangeScenarioTA(
      initialA: r'''
abstract class A {
  void foo() {}
}
''',
      testCode: r'''
import 'a.dart';
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M3
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        interfaces
          A
            implementedMethods
              foo: #M1
[status] idle
''',
      updatedA: r'''
abstract class A {
  void foo();
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M4
        interface: #M5
          map
            foo: #M4
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  implementedMethodIdMismatch
    libraryUri: package:test/a.dart
    interfaceName: A
    methodName: foo
    expectedId: #M1
    actualId: <null>
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M3
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        interfaces
          A
            implementedMethods
              foo: <null>
[status] idle
''',
    );
  }

  test_dependency_class_instanceMethod_change_lookUpMethod_concrete_makeConcrete() async {
    configuration
      ..withGetErrorsEvents = false
      ..withStreamResolvedUnitResults = false;

    _ManualRequirements.install((state) {
      var A = state.singleUnit.scopeClassElement('A');
      A.thisType.lookUpMethod('foo', A.library, concrete: true);
    });

    await _runChangeScenarioTA(
      initialA: r'''
abstract class A {
  void foo();
}
''',
      testCode: r'''
import 'a.dart';
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M3
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        interfaces
          A
            implementedMethods
              foo: <null>
[status] idle
''',
      updatedA: r'''
abstract class A {
  void foo() {}
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M4
        interface: #M5
          map
            foo: #M4
          implemented
            foo: #M4
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  implementedMethodIdMismatch
    libraryUri: package:test/a.dart
    interfaceName: A
    methodName: foo
    expectedId: <null>
    actualId: #M4
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M3
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        interfaces
          A
            implementedMethods
              foo: #M4
[status] idle
''',
    );
  }

  test_dependency_class_instanceMethod_change_lookUpMethod_concrete_other() async {
    configuration
      ..withGetErrorsEvents = false
      ..withStreamResolvedUnitResults = false;

    _ManualRequirements.install((state) {
      var A = state.singleUnit.scopeClassElement('A');
      A.thisType.lookUpMethod('foo', A.library, concrete: true);
    });

    await _runChangeScenarioTA(
      initialA: r'''
class A {
  void foo() {}
}
''',
      testCode: r'''
import 'a.dart';
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M3
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        interfaces
          A
            implementedMethods
              foo: #M1
[status] idle
''',
      updatedA: r'''
class A {
  void foo() {}
  void bar() {}
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredMethods
          bar: #M4
          foo: #M1
        interface: #M5
          map
            bar: #M4
            foo: #M1
          implemented
            bar: #M4
            foo: #M1
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] getErrorsFromBytes
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[status] idle
''',
    );
  }

  test_dependency_class_instanceMethod_change_lookUpMethod_inherited() async {
    configuration
      ..withGetErrorsEvents = false
      ..withStreamResolvedUnitResults = false;

    _ManualRequirements.install((state) {
      var B = state.singleUnit.scopeClassElement('B');
      B.thisType.lookUpMethod(
        'foo',
        B.library,
        concrete: true,
        inherited: true,
      );
    });

    await _runChangeScenarioTA(
      initialA: r'''
class A {
  int foo() {}
}
class B extends A {}
''',
      testCode: r'''
import 'a.dart';
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
      B: #M3
        interface: #M4
          map
            foo: #M1
          implemented
            foo: #M1
          superImplemented
            [0]
              foo: #M1
          inherited
            foo: #M1
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M5
        exportedTopLevels
          B: #M3
          B=: <null>
        reExportDeprecatedOnly
          B: false
        interfaces
          B
            superMethods
              [0]
                foo: #M1
[status] idle
''',
      updatedA: r'''
class A {
  double foo() {}
}
class B extends A {}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M6
        interface: #M7
          map
            foo: #M6
          implemented
            foo: #M6
      B: #M3
        interface: #M8
          map
            foo: #M6
          implemented
            foo: #M6
          superImplemented
            [0]
              foo: #M6
          inherited
            foo: #M6
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  superImplementedMethodIdMismatch
    libraryUri: package:test/a.dart
    interfaceName: B
    superIndex: 0
    methodName: foo
    expectedId: #M1
    actualId: #M6
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M5
        exportedTopLevels
          B: #M3
          B=: <null>
        reExportDeprecatedOnly
          B: false
        interfaces
          B
            superMethods
              [0]
                foo: #M6
[status] idle
''',
    );
  }

  test_dependency_class_instanceMethod_change_lookUpMethod_inherited_other() async {
    configuration
      ..withGetErrorsEvents = false
      ..withStreamResolvedUnitResults = false;

    _ManualRequirements.install((state) {
      var B = state.singleUnit.scopeClassElement('B');
      B.thisType.lookUpMethod(
        'foo',
        B.library,
        concrete: true,
        inherited: true,
      );
    });

    await _runChangeScenarioTA(
      initialA: r'''
class A {
  void foo() {}
}
class B extends A {}
''',
      testCode: r'''
import 'a.dart';
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
      B: #M3
        interface: #M4
          map
            foo: #M1
          implemented
            foo: #M1
          superImplemented
            [0]
              foo: #M1
          inherited
            foo: #M1
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M5
        exportedTopLevels
          B: #M3
          B=: <null>
        reExportDeprecatedOnly
          B: false
        interfaces
          B
            superMethods
              [0]
                foo: #M1
[status] idle
''',
      updatedA: r'''
class A {
  void foo() {}
  void bar() {}
}
class B extends A {}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredMethods
          bar: #M6
          foo: #M1
        interface: #M7
          map
            bar: #M6
            foo: #M1
          implemented
            bar: #M6
            foo: #M1
      B: #M3
        interface: #M8
          map
            bar: #M6
            foo: #M1
          implemented
            bar: #M6
            foo: #M1
          superImplemented
            [0]
              bar: #M6
              foo: #M1
          inherited
            bar: #M6
            foo: #M1
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] getErrorsFromBytes
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[status] idle
''',
    );
  }

  test_dependency_class_instanceMethod_change_lookUpMethod_other() async {
    configuration
      ..withGetErrorsEvents = false
      ..withStreamResolvedUnitResults = false;

    _ManualRequirements.install((state) {
      var A = state.singleUnit.scopeClassElement('A');
      A.thisType.lookUpMethod('foo', A.library);
    });

    await _runChangeScenarioTA(
      initialA: r'''
abstract class A {
  void foo();
}
''',
      testCode: r'''
import 'a.dart';
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M3
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        interfaces
          A
            methods
              foo: #M1
[status] idle
''',
      updatedA: r'''
abstract class A {
  void foo();
  void bar();
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredMethods
          bar: #M4
          foo: #M1
        interface: #M5
          map
            bar: #M4
            foo: #M1
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] getErrorsFromBytes
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[status] idle
''',
    );
  }

  test_dependency_class_instanceMethod_change_notUsed() async {
    await _runChangeScenarioTA(
      initialA: r'''
class A {
  int foo() {}
  int bar() {}
}
''',
      testCode: r'''
import 'a.dart';
void f(A a) {
  a.foo();
}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredMethods
          bar: #M1
          foo: #M2
        interface: #M3
          map
            bar: #M1
            foo: #M2
          implemented
            bar: #M1
            foo: #M2
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M4
  requirements
    libraries
      package:test/a.dart
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M5
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        interfaces
          A
            methods
              foo: #M2
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updatedA: r'''
class A {
  int foo() {}
  double bar() {}
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredMethods
          bar: #M6
          foo: #M2
        interface: #M7
          map
            bar: #M6
            foo: #M2
          implemented
            bar: #M6
            foo: #M2
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] getErrorsFromBytes
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[status] idle
[future] getErrors T2
  ErrorsResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
    );
  }

  test_dependency_class_instanceMethod_inherited_fromGeneric_extends2_changeTypeArgument() async {
    configuration.withStreamResolvedUnitResults = false;
    await _runChangeScenarioTA(
      initialA: r'''
class A<T> {
  T foo() {}
}

class B extends A<int> {}

class C extends B {}
''',
      testCode: r'''
import 'a.dart';
void f(C c) {
  c.foo();
}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
      B: #M3
        interface: #M4
          map
            foo: #M1
          implemented
            foo: #M1
          superImplemented
            [0]
              foo: #M1
          inherited
            foo: #M1
      C: #M5
        interface: #M6
          map
            foo: #M1
          implemented
            foo: #M1
          superImplemented
            [0]
              foo: #M1
          inherited
            foo: #M1
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M7
  requirements
    libraries
      package:test/a.dart
        exportedTopLevels
          C: #M5
          C=: <null>
        reExportDeprecatedOnly
          C: false
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M8
        exportedTopLevels
          C: #M5
          C=: <null>
        reExportDeprecatedOnly
          C: false
        interfaces
          C
            methods
              foo: #M1
[status] idle
[future] getErrors T1
  ErrorsResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updatedA: r'''
class A<T> {
  T foo() {}
}

class B extends A<double> {}

class C extends B {}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
      B: #M9
        interface: #M10
          map
            foo: #M1
          implemented
            foo: #M1
          superImplemented
            [0]
              foo: #M1
          inherited
            foo: #M1
      C: #M11
        interface: #M12
          map
            foo: #M1
          implemented
            foo: #M1
          superImplemented
            [0]
              foo: #M1
          inherited
            foo: #M1
  requirements
[operation] checkLinkedBundleRequirements
  package:test/test.dart
  topLevelIdMismatch
    libraryUri: package:test/a.dart
    name: C
    expectedId: #M5
    actualId: #M11
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M13
  requirements
    libraries
      package:test/a.dart
        exportedTopLevels
          C: #M11
          C=: <null>
        reExportDeprecatedOnly
          C: false
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  topLevelIdMismatch
    libraryUri: package:test/a.dart
    name: C
    expectedId: #M5
    actualId: #M11
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M8
        exportedTopLevels
          C: #M11
          C=: <null>
        reExportDeprecatedOnly
          C: false
        interfaces
          C
            methods
              foo: #M1
[status] idle
[future] getErrors T2
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
    );
  }

  test_dependency_class_instanceMethod_inherited_fromGeneric_extends_changeTypeArgument() async {
    configuration.withStreamResolvedUnitResults = false;
    await _runChangeScenarioTA(
      initialA: r'''
class A<T> {
  T foo() {}
}

class B extends A<int> {}
''',
      testCode: r'''
import 'a.dart';
void f(B b) {
  b.foo();
}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
      B: #M3
        interface: #M4
          map
            foo: #M1
          implemented
            foo: #M1
          superImplemented
            [0]
              foo: #M1
          inherited
            foo: #M1
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M5
  requirements
    libraries
      package:test/a.dart
        exportedTopLevels
          B: #M3
          B=: <null>
        reExportDeprecatedOnly
          B: false
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M6
        exportedTopLevels
          B: #M3
          B=: <null>
        reExportDeprecatedOnly
          B: false
        interfaces
          B
            methods
              foo: #M1
[status] idle
[future] getErrors T1
  ErrorsResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updatedA: r'''
class A<T> {
  T foo() {}
}

class B extends A<double> {}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
      B: #M7
        interface: #M8
          map
            foo: #M1
          implemented
            foo: #M1
          superImplemented
            [0]
              foo: #M1
          inherited
            foo: #M1
  requirements
[operation] checkLinkedBundleRequirements
  package:test/test.dart
  topLevelIdMismatch
    libraryUri: package:test/a.dart
    name: B
    expectedId: #M3
    actualId: #M7
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M9
  requirements
    libraries
      package:test/a.dart
        exportedTopLevels
          B: #M7
          B=: <null>
        reExportDeprecatedOnly
          B: false
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  topLevelIdMismatch
    libraryUri: package:test/a.dart
    name: B
    expectedId: #M3
    actualId: #M7
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M6
        exportedTopLevels
          B: #M7
          B=: <null>
        reExportDeprecatedOnly
          B: false
        interfaces
          B
            methods
              foo: #M1
[status] idle
[future] getErrors T2
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
    );
  }

  test_dependency_class_instanceMethod_inherited_fromGeneric_implements_changeTypeArgument() async {
    configuration.withStreamResolvedUnitResults = false;
    await _runChangeScenarioTA(
      initialA: r'''
class A<T> {
  T foo() {}
}

class B implements A<int> {}
''',
      testCode: r'''
import 'a.dart';
void f(B b) {
  b.foo();
}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
      B: #M3
        interface: #M4
          map
            foo: #M1
          inherited
            foo: #M1
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M5
  requirements
    libraries
      package:test/a.dart
        exportedTopLevels
          B: #M3
          B=: <null>
        reExportDeprecatedOnly
          B: false
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M6
        exportedTopLevels
          B: #M3
          B=: <null>
        reExportDeprecatedOnly
          B: false
        interfaces
          B
            methods
              foo: #M1
[status] idle
[future] getErrors T1
  ErrorsResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updatedA: r'''
class A<T> {
  T foo() {}
}

class B implements A<double> {}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
      B: #M7
        interface: #M8
          map
            foo: #M1
          inherited
            foo: #M1
  requirements
[operation] checkLinkedBundleRequirements
  package:test/test.dart
  topLevelIdMismatch
    libraryUri: package:test/a.dart
    name: B
    expectedId: #M3
    actualId: #M7
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M9
  requirements
    libraries
      package:test/a.dart
        exportedTopLevels
          B: #M7
          B=: <null>
        reExportDeprecatedOnly
          B: false
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  topLevelIdMismatch
    libraryUri: package:test/a.dart
    name: B
    expectedId: #M3
    actualId: #M7
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M6
        exportedTopLevels
          B: #M7
          B=: <null>
        reExportDeprecatedOnly
          B: false
        interfaces
          B
            methods
              foo: #M1
[status] idle
[future] getErrors T2
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
    );
  }

  test_dependency_class_instanceMethod_inherited_fromGeneric_with_changeTypeArgument() async {
    configuration.withStreamResolvedUnitResults = false;
    await _runChangeScenarioTA(
      initialA: r'''
class A<T> {
  T foo() {}
}

class B with A<int> {}
''',
      testCode: r'''
import 'a.dart';
void f(B b) {
  b.foo();
}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
      B: #M3
        interface: #M4
          map
            foo: #M1
          implemented
            foo: #M1
          superImplemented
            [1]
              foo: #M1
          inherited
            foo: #M1
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M5
  requirements
    libraries
      package:test/a.dart
        exportedTopLevels
          B: #M3
          B=: <null>
        reExportDeprecatedOnly
          B: false
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M6
        exportedTopLevels
          B: #M3
          B=: <null>
        reExportDeprecatedOnly
          B: false
        interfaces
          B
            methods
              foo: #M1
[status] idle
[future] getErrors T1
  ErrorsResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updatedA: r'''
class A<T> {
  T foo() {}
}

class B with A<double> {}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
      B: #M7
        interface: #M8
          map
            foo: #M1
          implemented
            foo: #M1
          superImplemented
            [1]
              foo: #M1
          inherited
            foo: #M1
  requirements
[operation] checkLinkedBundleRequirements
  package:test/test.dart
  topLevelIdMismatch
    libraryUri: package:test/a.dart
    name: B
    expectedId: #M3
    actualId: #M7
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M9
  requirements
    libraries
      package:test/a.dart
        exportedTopLevels
          B: #M7
          B=: <null>
        reExportDeprecatedOnly
          B: false
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  topLevelIdMismatch
    libraryUri: package:test/a.dart
    name: B
    expectedId: #M3
    actualId: #M7
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M6
        exportedTopLevels
          B: #M7
          B=: <null>
        reExportDeprecatedOnly
          B: false
        interfaces
          B
            methods
              foo: #M1
[status] idle
[future] getErrors T2
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
    );
  }

  test_dependency_class_instanceMethod_inherited_private() async {
    // Test that there is a dependency between `f()` and `A._foo`.
    // So, that we re-analyze `f()` body when `A._foo` changes.
    // Currently this dependency is implicit: we analyze the whole library
    // when any of its files changes.
    configuration.withStreamResolvedUnitResults = false;

    newFile(testFile.path, r'''
class A {
  int _foo() => 0;
}

class B extends A {}

void f (B b) {
  b._foo().isEven;
}
''');

    await _runChangeScenario(
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          _foo: #M1
        interface: #M2
      B: #M3
        interface: #M4
    declaredFunctions
      f: #M5
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
[status] idle
[future] getErrors T1
  ErrorsResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updateFiles: () {
        modifyFile2(testFile, r'''
class A {
  String _foo() => '';
}

class B extends A {}

void f (B b) {
  b._foo().isEven;
}
''');
        return [testFile];
      },
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          _foo: #M6
        interface: #M2
      B: #M3
        interface: #M4
    declaredFunctions
      f: #M5
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
[status] idle
[future] getErrors T2
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
    errors
      84 +6 UNDEFINED_GETTER
''',
    );
  }

  test_dependency_class_instanceMethod_remove_invoked() async {
    configuration.withStreamResolvedUnitResults = false;
    await _runChangeScenarioTA(
      initialA: r'''
class A {
  void foo() {}
}
''',
      testCode: r'''
import 'a.dart';
void f(A a) {
  a.foo();
}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M3
  requirements
    libraries
      package:test/a.dart
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M4
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        interfaces
          A
            methods
              foo: #M1
[status] idle
[future] getErrors T1
  ErrorsResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updatedA: r'''
class A {}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        interface: #M5
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  instanceMethodIdMismatch
    libraryUri: package:test/a.dart
    interfaceName: A
    methodName: foo
    expectedId: #M1
    actualId: <null>
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M4
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredGetters
              foo: <null>
            requestedDeclaredMethods
              foo: <null>
        interfaces
          A
            methods
              foo: <null>
              foo=: <null>
        exportedExtensions: []
[status] idle
[future] getErrors T2
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
    errors
      35 +3 UNDEFINED_METHOD
''',
    );
  }

  test_dependency_class_instanceSetter_add_invoked() async {
    await _runChangeScenarioTA(
      initialA: r'''
class A {}
''',
      testCode: r'''
import 'a.dart';
void f(A a) {
  a.foo = 0;
}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        interface: #M1
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M2
  requirements
    libraries
      package:test/a.dart
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
    errors
      35 +3 UNDEFINED_SETTER
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M3
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredGetters
              foo: <null>
            requestedDeclaredSetters
              foo=: <null>
            requestedDeclaredMethods
              foo: <null>
        interfaces
          A
            methods
              foo: <null>
              foo=: <null>
        exportedExtensions: []
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
    errors
      35 +3 UNDEFINED_SETTER
''',
      updatedA: r'''
class A {
  set foo(int _) {}
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M4
        declaredSetters
          foo=: #M5
        interface: #M6
          map
            foo=: #M5
          implemented
            foo=: #M5
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  instanceMethodIdMismatch
    libraryUri: package:test/a.dart
    interfaceName: A
    methodName: foo=
    expectedId: <null>
    actualId: #M5
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M3
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredFields
              foo: #M4
        interfaces
          A
            methods
              foo=: #M5
[status] idle
[future] getErrors T2
  ErrorsResult #3
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
    );
  }

  test_dependency_class_instanceSetter_change_getField_setter() async {
    _ManualRequirements.install((state) {
      var A = state.singleUnit.scopeInstanceElement('A');
      A.getField('foo')?.setter;
    });

    await _runChangeScenarioTA(
      initialA: r'''
class A {
  int get foo => 0;
  set foo(int _) {}
}
''',
      testCode: r'''
import 'a.dart';
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        declaredSetters
          foo=: #M3
        interface: #M4
          map
            foo: #M2
            foo=: #M3
          implemented
            foo: #M2
            foo=: #M3
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
    errors
      7 +8 UNUSED_IMPORT
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M5
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredFields
              foo: #M1
            requestedDeclaredSetters
              foo=: #M3
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
    errors
      7 +8 UNUSED_IMPORT
''',
      updatedA: r'''
class A {
  int get foo => 0;
  set foo(double _) {}
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        declaredSetters
          foo=: #M6
        interface: #M7
          map
            foo: #M2
            foo=: #M6
          implemented
            foo: #M2
            foo=: #M6
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  instanceMethodIdMismatch
    libraryUri: package:test/a.dart
    interfaceName: A
    methodName: foo=
    expectedId: #M3
    actualId: #M6
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
    errors
      7 +8 UNUSED_IMPORT
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M5
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredFields
              foo: #M1
            requestedDeclaredSetters
              foo=: #M6
[status] idle
[future] getErrors T2
  ErrorsResult #3
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
    errors
      7 +8 UNUSED_IMPORT
''',
    );
  }

  test_dependency_class_instanceSetter_change_getSetter() async {
    _ManualRequirements.install((state) {
      var A = state.singleUnit.scopeInstanceElement('A');
      A.getSetter('foo');
    });

    await _runChangeScenarioTA(
      initialA: r'''
class A {
  set foo(int _) {}
}
''',
      testCode: r'''
import 'a.dart';
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredSetters
          foo=: #M2
        interface: #M3
          map
            foo=: #M2
          implemented
            foo=: #M2
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
    errors
      7 +8 UNUSED_IMPORT
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M4
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredSetters
              foo=: #M2
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
    errors
      7 +8 UNUSED_IMPORT
''',
      updatedA: r'''
class A {
  set foo(double _) {}
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M5
        declaredSetters
          foo=: #M6
        interface: #M7
          map
            foo=: #M6
          implemented
            foo=: #M6
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  instanceMethodIdMismatch
    libraryUri: package:test/a.dart
    interfaceName: A
    methodName: foo=
    expectedId: #M2
    actualId: #M6
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
    errors
      7 +8 UNUSED_IMPORT
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M4
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredSetters
              foo=: #M6
[status] idle
[future] getErrors T2
  ErrorsResult #3
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
    errors
      7 +8 UNUSED_IMPORT
''',
    );
  }

  test_dependency_class_instanceSetter_change_getSetter_other() async {
    _ManualRequirements.install((state) {
      var A = state.singleUnit.scopeInstanceElement('A');
      A.getSetter('foo');
    });

    await _runChangeScenarioTA(
      initialA: r'''
class A {
  set foo(int _) {}
  set bar(int _) {}
}
''',
      testCode: r'''
import 'a.dart';
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredFields
          bar: #M1
          foo: #M2
        declaredSetters
          bar=: #M3
          foo=: #M4
        interface: #M5
          map
            bar=: #M3
            foo=: #M4
          implemented
            bar=: #M3
            foo=: #M4
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
    errors
      7 +8 UNUSED_IMPORT
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M6
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredSetters
              foo=: #M4
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
    errors
      7 +8 UNUSED_IMPORT
''',
      updatedA: r'''
class A {
  set foo(int _) {}
  set bar(double _) {}
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredFields
          bar: #M7
          foo: #M2
        declaredSetters
          bar=: #M8
          foo=: #M4
        interface: #M9
          map
            bar=: #M8
            foo=: #M4
          implemented
            bar=: #M8
            foo=: #M4
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] getErrorsFromBytes
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[status] idle
[future] getErrors T2
  ErrorsResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
    errors
      7 +8 UNUSED_IMPORT
''',
    );
  }

  test_dependency_class_instanceSetter_change_invoked() async {
    await _runChangeScenarioTA(
      initialA: r'''
class A {
  set foo(int _) {}
}
''',
      testCode: r'''
import 'a.dart';
void f(A a) {
  a.foo = 0;
}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredSetters
          foo=: #M2
        interface: #M3
          map
            foo=: #M2
          implemented
            foo=: #M2
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M4
  requirements
    libraries
      package:test/a.dart
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M5
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredFields
              foo: #M1
        interfaces
          A
            methods
              foo=: #M2
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updatedA: r'''
class A {
  set foo(double _) {}
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M6
        declaredSetters
          foo=: #M7
        interface: #M8
          map
            foo=: #M7
          implemented
            foo=: #M7
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  instanceFieldIdMismatch
    libraryUri: package:test/a.dart
    interfaceName: A
    fieldName: foo
    expectedId: #M1
    actualId: #M6
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M5
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredFields
              foo: #M6
        interfaces
          A
            methods
              foo=: #M7
[status] idle
[future] getErrors T2
  ErrorsResult #3
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
    );
  }

  test_dependency_class_instanceSetter_change_invoked_hasNamedConstructor_hasInstanceGetter() async {
    configuration.withStreamResolvedUnitResults = false;
    await _runChangeScenarioTA(
      initialA: r'''
class A {
  A.foo(int _);
  int get foo {}
  set foo(int _) {}
}
''',
      testCode: r'''
import 'a.dart';
void f() {
  var a = A.foo(0);
  a.foo;
  a.foo = 0;
}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        declaredSetters
          foo=: #M3
        declaredConstructors
          foo: #M4
        interface: #M5
          map
            foo: #M2
            foo=: #M3
          implemented
            foo: #M2
            foo=: #M3
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M6
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M7
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredFields
              foo: #M1
        interfaces
          A
            requestedConstructors
              foo: #M4
            methods
              foo: #M2
              foo=: #M3
[status] idle
[future] getErrors T1
  ErrorsResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updatedA: r'''
class A {
  A.foo(int _);
  int get foo {}
  set foo(double _) {}
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        declaredSetters
          foo=: #M8
        declaredConstructors
          foo: #M4
        interface: #M9
          map
            foo: #M2
            foo=: #M8
          implemented
            foo: #M2
            foo=: #M8
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  instanceMethodIdMismatch
    libraryUri: package:test/a.dart
    interfaceName: A
    methodName: foo=
    expectedId: #M3
    actualId: #M8
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M7
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredFields
              foo: #M1
        interfaces
          A
            requestedConstructors
              foo: #M4
            methods
              foo: #M2
              foo=: #M8
[status] idle
[future] getErrors T2
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
    );
  }

  test_dependency_class_instanceSetter_change_notUsed() async {
    await _runChangeScenarioTA(
      initialA: r'''
class A {
  set foo(int _) {}
  set bar(int _) {}
}
''',
      testCode: r'''
import 'a.dart';
void f(A a) {
  a.foo = 0;
}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredFields
          bar: #M1
          foo: #M2
        declaredSetters
          bar=: #M3
          foo=: #M4
        interface: #M5
          map
            bar=: #M3
            foo=: #M4
          implemented
            bar=: #M3
            foo=: #M4
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M6
  requirements
    libraries
      package:test/a.dart
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M7
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredFields
              foo: #M2
        interfaces
          A
            methods
              foo=: #M4
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updatedA: r'''
class A {
  set foo(int _) {}
  set bar(double _) {}
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredFields
          bar: #M8
          foo: #M2
        declaredSetters
          bar=: #M9
          foo=: #M4
        interface: #M10
          map
            bar=: #M9
            foo=: #M4
          implemented
            bar=: #M9
            foo=: #M4
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] getErrorsFromBytes
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[status] idle
[future] getErrors T2
  ErrorsResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
    );
  }

  test_dependency_class_instanceSetter_inherited_fromGeneric_extends_changeTypeArgument() async {
    configuration.withStreamResolvedUnitResults = false;
    await _runChangeScenarioTA(
      initialA: r'''
class A<T> {
  set foo(T _) {}
}

class B extends A<int> {}
''',
      testCode: r'''
import 'a.dart';
void f(B b) {
  b.foo = 0;
}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredSetters
          foo=: #M2
        interface: #M3
          map
            foo=: #M2
          implemented
            foo=: #M2
      B: #M4
        interface: #M5
          map
            foo=: #M2
          implemented
            foo=: #M2
          superImplemented
            [0]
              foo=: #M2
          inherited
            foo=: #M2
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M6
  requirements
    libraries
      package:test/a.dart
        exportedTopLevels
          B: #M4
          B=: <null>
        reExportDeprecatedOnly
          B: false
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M7
        exportedTopLevels
          B: #M4
          B=: <null>
        reExportDeprecatedOnly
          B: false
        instances
          A
            requestedDeclaredFields
              foo: #M1
        interfaces
          B
            methods
              foo=: #M2
[status] idle
[future] getErrors T1
  ErrorsResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updatedA: r'''
class A<T> {
  set foo(T _) {}
}

class B extends A<double> {}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredSetters
          foo=: #M2
        interface: #M3
          map
            foo=: #M2
          implemented
            foo=: #M2
      B: #M8
        interface: #M9
          map
            foo=: #M2
          implemented
            foo=: #M2
          superImplemented
            [0]
              foo=: #M2
          inherited
            foo=: #M2
  requirements
[operation] checkLinkedBundleRequirements
  package:test/test.dart
  topLevelIdMismatch
    libraryUri: package:test/a.dart
    name: B
    expectedId: #M4
    actualId: #M8
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M10
  requirements
    libraries
      package:test/a.dart
        exportedTopLevels
          B: #M8
          B=: <null>
        reExportDeprecatedOnly
          B: false
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  topLevelIdMismatch
    libraryUri: package:test/a.dart
    name: B
    expectedId: #M4
    actualId: #M8
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M7
        exportedTopLevels
          B: #M8
          B=: <null>
        reExportDeprecatedOnly
          B: false
        instances
          A
            requestedDeclaredFields
              foo: #M1
        interfaces
          B
            methods
              foo=: #M2
[status] idle
[future] getErrors T2
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
    );
  }

  test_dependency_class_instanceSetter_inherited_fromGeneric_implements_changeTypeArgument() async {
    configuration.withStreamResolvedUnitResults = false;
    await _runChangeScenarioTA(
      initialA: r'''
class A<T> {
  set foo(T _) {}
}

class B implements A<int> {}
''',
      testCode: r'''
import 'a.dart';
void f(B b) {
  b.foo = 0;
}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredSetters
          foo=: #M2
        interface: #M3
          map
            foo=: #M2
          implemented
            foo=: #M2
      B: #M4
        interface: #M5
          map
            foo=: #M2
          inherited
            foo=: #M2
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M6
  requirements
    libraries
      package:test/a.dart
        exportedTopLevels
          B: #M4
          B=: <null>
        reExportDeprecatedOnly
          B: false
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M7
        exportedTopLevels
          B: #M4
          B=: <null>
        reExportDeprecatedOnly
          B: false
        instances
          A
            requestedDeclaredFields
              foo: #M1
        interfaces
          B
            methods
              foo=: #M2
[status] idle
[future] getErrors T1
  ErrorsResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updatedA: r'''
class A<T> {
  set foo(T _) {}
}

class B implements A<double> {}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredSetters
          foo=: #M2
        interface: #M3
          map
            foo=: #M2
          implemented
            foo=: #M2
      B: #M8
        interface: #M9
          map
            foo=: #M2
          inherited
            foo=: #M2
  requirements
[operation] checkLinkedBundleRequirements
  package:test/test.dart
  topLevelIdMismatch
    libraryUri: package:test/a.dart
    name: B
    expectedId: #M4
    actualId: #M8
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M10
  requirements
    libraries
      package:test/a.dart
        exportedTopLevels
          B: #M8
          B=: <null>
        reExportDeprecatedOnly
          B: false
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  topLevelIdMismatch
    libraryUri: package:test/a.dart
    name: B
    expectedId: #M4
    actualId: #M8
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M7
        exportedTopLevels
          B: #M8
          B=: <null>
        reExportDeprecatedOnly
          B: false
        instances
          A
            requestedDeclaredFields
              foo: #M1
        interfaces
          B
            methods
              foo=: #M2
[status] idle
[future] getErrors T2
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
    );
  }

  test_dependency_class_instanceSetter_inherited_fromGeneric_with_changeTypeArgument() async {
    configuration.withStreamResolvedUnitResults = false;
    await _runChangeScenarioTA(
      initialA: r'''
class A<T> {
  set foo(T _) {}
}

class B with A<int> {}
''',
      testCode: r'''
import 'a.dart';
void f(B b) {
  b.foo = 0;
}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredSetters
          foo=: #M2
        interface: #M3
          map
            foo=: #M2
          implemented
            foo=: #M2
      B: #M4
        interface: #M5
          map
            foo=: #M2
          implemented
            foo=: #M2
          superImplemented
            [1]
              foo=: #M2
          inherited
            foo=: #M2
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M6
  requirements
    libraries
      package:test/a.dart
        exportedTopLevels
          B: #M4
          B=: <null>
        reExportDeprecatedOnly
          B: false
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M7
        exportedTopLevels
          B: #M4
          B=: <null>
        reExportDeprecatedOnly
          B: false
        instances
          A
            requestedDeclaredFields
              foo: #M1
        interfaces
          B
            methods
              foo=: #M2
[status] idle
[future] getErrors T1
  ErrorsResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updatedA: r'''
class A<T> {
  set foo(T _) {}
}

class B with A<double> {}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredSetters
          foo=: #M2
        interface: #M3
          map
            foo=: #M2
          implemented
            foo=: #M2
      B: #M8
        interface: #M9
          map
            foo=: #M2
          implemented
            foo=: #M2
          superImplemented
            [1]
              foo=: #M2
          inherited
            foo=: #M2
  requirements
[operation] checkLinkedBundleRequirements
  package:test/test.dart
  topLevelIdMismatch
    libraryUri: package:test/a.dart
    name: B
    expectedId: #M4
    actualId: #M8
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M10
  requirements
    libraries
      package:test/a.dart
        exportedTopLevels
          B: #M8
          B=: <null>
        reExportDeprecatedOnly
          B: false
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  topLevelIdMismatch
    libraryUri: package:test/a.dart
    name: B
    expectedId: #M4
    actualId: #M8
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M7
        exportedTopLevels
          B: #M8
          B=: <null>
        reExportDeprecatedOnly
          B: false
        instances
          A
            requestedDeclaredFields
              foo: #M1
        interfaces
          B
            methods
              foo=: #M2
[status] idle
[future] getErrors T2
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
    );
  }

  test_dependency_class_instanceSetter_inherited_private() async {
    // Test that there is a dependency between `f()` and `A._foo`.
    // So, that we re-analyze `f()` body when `A._foo` changes.
    // Currently this dependency is implicit: we analyze the whole library
    // when any of its files changes.
    configuration.withStreamResolvedUnitResults = false;

    newFile(testFile.path, r'''
class A {
  set _foo(int _) {}
}

class B extends A {}

void f (B b) {
  b._foo = 0;
}
''');

    await _runChangeScenario(
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          _foo: #M1
        declaredSetters
          _foo=: #M2
        interface: #M3
      B: #M4
        interface: #M5
    declaredFunctions
      f: #M6
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
[status] idle
[future] getErrors T1
  ErrorsResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updateFiles: () {
        modifyFile2(testFile, r'''
class A {
  set _foo(String _) {}
}

class B extends A {}

void f (B b) {
  b._foo = 0;
}
''');
        return [testFile];
      },
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          _foo: #M7
        declaredSetters
          _foo=: #M8
        interface: #M3
      B: #M4
        interface: #M5
    declaredFunctions
      f: #M6
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
[status] idle
[future] getErrors T2
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
    errors
      85 +1 INVALID_ASSIGNMENT
''',
    );
  }

  test_dependency_class_instanceSetter_remove_invoked() async {
    await _runChangeScenarioTA(
      initialA: r'''
class A {
  set foo(int _) {}
}
''',
      testCode: r'''
import 'a.dart';
void f(A a) {
  a.foo = 0;
}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredSetters
          foo=: #M2
        interface: #M3
          map
            foo=: #M2
          implemented
            foo=: #M2
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M4
  requirements
    libraries
      package:test/a.dart
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M5
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredFields
              foo: #M1
        interfaces
          A
            methods
              foo=: #M2
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updatedA: r'''
class A {}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        interface: #M6
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  instanceFieldIdMismatch
    libraryUri: package:test/a.dart
    interfaceName: A
    fieldName: foo
    expectedId: #M1
    actualId: <null>
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
    errors
      35 +3 UNDEFINED_SETTER
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M5
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredGetters
              foo: <null>
            requestedDeclaredSetters
              foo=: <null>
            requestedDeclaredMethods
              foo: <null>
        interfaces
          A
            methods
              foo: <null>
              foo=: <null>
        exportedExtensions: []
[status] idle
[future] getErrors T2
  ErrorsResult #3
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
    errors
      35 +3 UNDEFINED_SETTER
''',
    );
  }

  test_dependency_class_instanceSetters_add_getSetters() async {
    _ManualRequirements.install((state) {
      var A = state.singleUnit.scopeInstanceElement('A');
      A.setters;
    });

    await _runChangeScenarioTA(
      initialA: r'''
class A {
  set foo(int _) {}
}
''',
      testCode: r'''
import 'a.dart';
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredSetters
          foo=: #M2
        interface: #M3
          map
            foo=: #M2
          implemented
            foo=: #M2
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
    errors
      7 +8 UNUSED_IMPORT
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M4
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            allDeclaredSetters: #M2
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
    errors
      7 +8 UNUSED_IMPORT
''',
      updatedA: r'''
class A {
  set foo(int _) {}
  set bar(int _) {}
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredFields
          bar: #M5
          foo: #M1
        declaredSetters
          bar=: #M6
          foo=: #M2
        interface: #M7
          map
            bar=: #M6
            foo=: #M2
          implemented
            bar=: #M6
            foo=: #M2
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  instanceChildrenIdsMismatch
    libraryUri: package:test/a.dart
    instanceName: A
    childrenPropertyName: setters
    expectedIds: #M2
    actualIds: #M2 #M6
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
    errors
      7 +8 UNUSED_IMPORT
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M4
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            allDeclaredSetters: #M2 #M6
[status] idle
[future] getErrors T2
  ErrorsResult #3
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
    errors
      7 +8 UNUSED_IMPORT
''',
    );
  }

  test_dependency_class_it_add() async {
    await _runChangeScenarioTA(
      initialA: '',
      testCode: r'''
import 'a.dart';
A foo() {}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      foo: #M0
  requirements
    libraries
      package:test/a.dart
        exportedTopLevels
          A: <null>
          A=: <null>
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
    errors
      17 +1 UNDEFINED_CLASS
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M1
        exportedTopLevels
          A: <null>
          A=: <null>
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
    errors
      17 +1 UNDEFINED_CLASS
''',
      updatedA: r'''
class A {}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M2
        interface: #M3
  requirements
[operation] checkLinkedBundleRequirements
  package:test/test.dart
  topLevelIdMismatch
    libraryUri: package:test/a.dart
    name: A
    expectedId: <null>
    actualId: #M2
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      foo: #M4
  requirements
    libraries
      package:test/a.dart
        exportedTopLevels
          A: #M2
          A=: <null>
        reExportDeprecatedOnly
          A: false
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  topLevelIdMismatch
    libraryUri: package:test/a.dart
    name: A
    expectedId: <null>
    actualId: #M2
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
    errors
      19 +3 BODY_MIGHT_COMPLETE_NORMALLY
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M1
        exportedTopLevels
          A: #M2
          A=: <null>
        reExportDeprecatedOnly
          A: false
[status] idle
[future] getErrors T2
  ErrorsResult #3
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
    errors
      19 +3 BODY_MIGHT_COMPLETE_NORMALLY
''',
    );
  }

  test_dependency_class_it_add_notUsed() async {
    await _runChangeScenarioTA(
      initialA: r'''
class A {}
''',
      testCode: r'''
import 'a.dart';
A foo() {}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        interface: #M1
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      foo: #M2
  requirements
    libraries
      package:test/a.dart
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
    errors
      19 +3 BODY_MIGHT_COMPLETE_NORMALLY
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M3
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
    errors
      19 +3 BODY_MIGHT_COMPLETE_NORMALLY
''',
      updatedA: r'''
class A {}
class B {}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        interface: #M1
      B: #M4
        interface: #M5
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] getErrorsFromBytes
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[status] idle
[future] getErrors T2
  ErrorsResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
    errors
      19 +3 BODY_MIGHT_COMPLETE_NORMALLY
''',
    );
  }

  test_dependency_class_it_change() async {
    await _runChangeScenarioTA(
      initialA: r'''
class A {}
class B {}
''',
      testCode: r'''
import 'a.dart';
A foo() {}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        interface: #M1
      B: #M2
        interface: #M3
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      foo: #M4
  requirements
    libraries
      package:test/a.dart
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
    errors
      19 +3 BODY_MIGHT_COMPLETE_NORMALLY
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M5
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
    errors
      19 +3 BODY_MIGHT_COMPLETE_NORMALLY
''',
      updatedA: r'''
class A extends B {}
class B {}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M6
        interface: #M7
      B: #M2
        interface: #M3
  requirements
[operation] checkLinkedBundleRequirements
  package:test/test.dart
  topLevelIdMismatch
    libraryUri: package:test/a.dart
    name: A
    expectedId: #M0
    actualId: #M6
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      foo: #M8
  requirements
    libraries
      package:test/a.dart
        exportedTopLevels
          A: #M6
          A=: <null>
        reExportDeprecatedOnly
          A: false
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  topLevelIdMismatch
    libraryUri: package:test/a.dart
    name: A
    expectedId: #M0
    actualId: #M6
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
    errors
      19 +3 BODY_MIGHT_COMPLETE_NORMALLY
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M5
        exportedTopLevels
          A: #M6
          A=: <null>
        reExportDeprecatedOnly
          A: false
[status] idle
[future] getErrors T2
  ErrorsResult #3
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
    errors
      19 +3 BODY_MIGHT_COMPLETE_NORMALLY
''',
    );
  }

  test_dependency_class_it_change_notUsed() async {
    await _runChangeScenarioTA(
      initialA: r'''
class A {}
class B {}
class C {}
''',
      testCode: r'''
import 'a.dart';
A foo() {}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        interface: #M1
      B: #M2
        interface: #M3
      C: #M4
        interface: #M5
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      foo: #M6
  requirements
    libraries
      package:test/a.dart
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
    errors
      19 +3 BODY_MIGHT_COMPLETE_NORMALLY
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M7
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
    errors
      19 +3 BODY_MIGHT_COMPLETE_NORMALLY
''',
      updatedA: r'''
class A {}
class B extends C {}
class C {}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        interface: #M1
      B: #M8
        interface: #M9
      C: #M4
        interface: #M5
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] getErrorsFromBytes
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[status] idle
[future] getErrors T2
  ErrorsResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
    errors
      19 +3 BODY_MIGHT_COMPLETE_NORMALLY
''',
    );
  }

  test_dependency_class_it_remove() async {
    await _runChangeScenarioTA(
      initialA: r'''
class A {}
''',
      testCode: r'''
import 'a.dart';
A foo() => throw 0;
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        interface: #M1
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      foo: #M2
  requirements
    libraries
      package:test/a.dart
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M3
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updatedA: '',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
  requirements
[operation] checkLinkedBundleRequirements
  package:test/test.dart
  topLevelIdMismatch
    libraryUri: package:test/a.dart
    name: A
    expectedId: #M0
    actualId: <null>
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      foo: #M4
  requirements
    libraries
      package:test/a.dart
        exportedTopLevels
          A: <null>
          A=: <null>
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  topLevelIdMismatch
    libraryUri: package:test/a.dart
    name: A
    expectedId: #M0
    actualId: <null>
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
    errors
      17 +1 UNDEFINED_CLASS
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M3
        exportedTopLevels
          A: <null>
          A=: <null>
[status] idle
[future] getErrors T2
  ErrorsResult #3
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
    errors
      17 +1 UNDEFINED_CLASS
''',
    );
  }

  test_dependency_class_it_remove_notUsed() async {
    await _runChangeScenarioTA(
      initialA: r'''
class A {}
class B {}
''',
      testCode: r'''
import 'a.dart';
A foo() => throw 0;
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        interface: #M1
      B: #M2
        interface: #M3
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      foo: #M4
  requirements
    libraries
      package:test/a.dart
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M5
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updatedA: r'''
class A {}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        interface: #M1
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] getErrorsFromBytes
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[status] idle
[future] getErrors T2
  ErrorsResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
    );
  }

  test_dependency_class_namedConstructor_add_invoked() async {
    configuration.withStreamResolvedUnitResults = false;
    await _runChangeScenarioTA(
      initialA: r'''
class A {
  A.c1();
}
''',
      testCode: r'''
import 'a.dart';
void f() {
  A.c2();
}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredConstructors
          c1: #M1
        interface: #M2
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M3
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M4
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredGetters
              c2: <null>
            requestedDeclaredMethods
              c2: <null>
        interfaces
          A
            requestedConstructors
              c2: <null>
[status] idle
[future] getErrors T1
  ErrorsResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
    errors
      32 +2 UNDEFINED_METHOD
''',
      updatedA: r'''
class A {
  A.c1();
  A.c2();
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredConstructors
          c1: #M1
          c2: #M5
        interface: #M2
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  interfaceConstructorIdMismatch
    libraryUri: package:test/a.dart
    interfaceName: A
    constructorName: c2
    expectedId: <null>
    actualId: #M5
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M4
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        interfaces
          A
            requestedConstructors
              c2: #M5
[status] idle
[future] getErrors T2
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
    );
  }

  test_dependency_class_namedConstructor_add_isValidMixin() async {
    configuration.withStreamResolvedUnitResults = false;

    _ManualRequirements.install((state) {
      state.singleUnit.scopeClassElement('A').isValidMixin;
    });

    await _runChangeScenarioTA(
      initialA: r'''
class A {}
''',
      testCode: r'''
import 'a.dart';
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        interface: #M1
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M2
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        interfaces
          A
            allConstructors: #M3
[status] idle
[future] getErrors T1
  ErrorsResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
    errors
      7 +8 UNUSED_IMPORT
''',
      updatedA: r'''
class A {
  A.named();
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredConstructors
          named: #M4
        interface: #M1
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  interfaceChildrenIdsMismatch
    libraryUri: package:test/a.dart
    interfaceName: A
    childrenPropertyName: constructors
    expectedIds: #M3
    actualIds: #M4
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M2
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        interfaces
          A
            allConstructors: #M4
[status] idle
[future] getErrors T2
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
    errors
      7 +8 UNUSED_IMPORT
''',
    );
  }

  test_dependency_class_namedConstructor_change_getConstructors() async {
    configuration.includeDefaultConstructors();

    _ManualRequirements.install((state) {
      var A = state.singleUnit.scopeInterfaceElement('A');
      A.constructors;
    });

    await _runChangeScenarioTA(
      initialA: r'''
class A {
  A(int _);
  A.named(int _);
}
''',
      testCode: r'''
import 'a.dart';
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredConstructors
          named: #M1
          new: #M2
        interface: #M3
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
    errors
      7 +8 UNUSED_IMPORT
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M4
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        interfaces
          A
            allConstructors: #M2 #M1
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
    errors
      7 +8 UNUSED_IMPORT
''',
      updatedA: r'''
class A {
  A(int _);
  A.named(double _);
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredConstructors
          named: #M5
          new: #M2
        interface: #M3
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  interfaceChildrenIdsMismatch
    libraryUri: package:test/a.dart
    interfaceName: A
    childrenPropertyName: constructors
    expectedIds: #M2 #M1
    actualIds: #M2 #M5
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
    errors
      7 +8 UNUSED_IMPORT
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M4
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        interfaces
          A
            allConstructors: #M2 #M5
[status] idle
[future] getErrors T2
  ErrorsResult #3
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
    errors
      7 +8 UNUSED_IMPORT
''',
    );
  }

  test_dependency_class_namedConstructor_change_getNamedConstructor() async {
    _ManualRequirements.install((state) {
      var A = state.singleUnit.scopeInterfaceElement('A');
      A.getNamedConstructor('foo');
    });

    await _runChangeScenarioTA(
      initialA: r'''
class A {
  A.foo(int _);
}
''',
      testCode: r'''
import 'a.dart';
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredConstructors
          foo: #M1
        interface: #M2
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
    errors
      7 +8 UNUSED_IMPORT
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M3
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        interfaces
          A
            requestedConstructors
              foo: #M1
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
    errors
      7 +8 UNUSED_IMPORT
''',
      updatedA: r'''
class A {
  A.foo(double _);
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredConstructors
          foo: #M4
        interface: #M2
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  interfaceConstructorIdMismatch
    libraryUri: package:test/a.dart
    interfaceName: A
    constructorName: foo
    expectedId: #M1
    actualId: #M4
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
    errors
      7 +8 UNUSED_IMPORT
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M3
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        interfaces
          A
            requestedConstructors
              foo: #M4
[status] idle
[future] getErrors T2
  ErrorsResult #3
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
    errors
      7 +8 UNUSED_IMPORT
''',
    );
  }

  test_dependency_class_namedConstructor_change_getNamedConstructor_other() async {
    _ManualRequirements.install((state) {
      var A = state.singleUnit.scopeInterfaceElement('A');
      A.getNamedConstructor('foo');
    });

    await _runChangeScenarioTA(
      initialA: r'''
class A {
  A.foo(int _);
  A.bar(int _);
}
''',
      testCode: r'''
import 'a.dart';
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredConstructors
          bar: #M1
          foo: #M2
        interface: #M3
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
    errors
      7 +8 UNUSED_IMPORT
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M4
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        interfaces
          A
            requestedConstructors
              foo: #M2
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
    errors
      7 +8 UNUSED_IMPORT
''',
      updatedA: r'''
class A {
  A.foo(int _);
  A.bar(double _);
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredConstructors
          bar: #M5
          foo: #M2
        interface: #M3
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] getErrorsFromBytes
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[status] idle
[future] getErrors T2
  ErrorsResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
    errors
      7 +8 UNUSED_IMPORT
''',
    );
  }

  test_dependency_class_namedConstructor_change_getUnnamedConstructor() async {
    configuration.includeDefaultConstructors();

    _ManualRequirements.install((state) {
      var A = state.singleUnit.scopeInterfaceElement('A');
      A.unnamedConstructor;
    });

    await _runChangeScenarioTA(
      initialA: r'''
class A {
  A();
  A.named(int _);
}
''',
      testCode: r'''
import 'a.dart';
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredConstructors
          named: #M1
          new: #M2
        interface: #M3
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
    errors
      7 +8 UNUSED_IMPORT
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M4
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        interfaces
          A
            requestedConstructors
              new: #M2
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
    errors
      7 +8 UNUSED_IMPORT
''',
      updatedA: r'''
class A {
  A();
  A.named(double _);
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredConstructors
          named: #M5
          new: #M2
        interface: #M3
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] getErrorsFromBytes
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[status] idle
[future] getErrors T2
  ErrorsResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
    errors
      7 +8 UNUSED_IMPORT
''',
    );
  }

  test_dependency_class_namedConstructor_change_invoked() async {
    configuration.withStreamResolvedUnitResults = false;
    await _runChangeScenarioTA(
      initialA: r'''
class A {
  A.named(int _);
}
''',
      testCode: r'''
import 'a.dart';
void f() {
  A.named(0);
}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredConstructors
          named: #M1
        interface: #M2
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M3
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M4
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        interfaces
          A
            requestedConstructors
              named: #M1
[status] idle
[future] getErrors T1
  ErrorsResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updatedA: r'''
class A {
  A.named(double _);
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredConstructors
          named: #M5
        interface: #M2
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  interfaceConstructorIdMismatch
    libraryUri: package:test/a.dart
    interfaceName: A
    constructorName: named
    expectedId: #M1
    actualId: #M5
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M4
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        interfaces
          A
            requestedConstructors
              named: #M5
[status] idle
[future] getErrors T2
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
    );
  }

  test_dependency_class_namedConstructor_change_invoked_hasInstanceGetterSetter() async {
    configuration.withStreamResolvedUnitResults = false;
    await _runChangeScenarioTA(
      initialA: r'''
class A {
  A.foo(int _);
  int get foo {}
  set foo(int _) {}
}
''',
      testCode: r'''
import 'a.dart';

void f() {
  var a = A.foo(0);
  a.foo;
  a.foo = 0;
}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        declaredSetters
          foo=: #M3
        declaredConstructors
          foo: #M4
        interface: #M5
          map
            foo: #M2
            foo=: #M3
          implemented
            foo: #M2
            foo=: #M3
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M6
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M7
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredFields
              foo: #M1
        interfaces
          A
            requestedConstructors
              foo: #M4
            methods
              foo: #M2
              foo=: #M3
[status] idle
[future] getErrors T1
  ErrorsResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updatedA: r'''
class A {
  A.foo(double _);
  int get foo {}
  set foo(int _) {}
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        declaredSetters
          foo=: #M3
        declaredConstructors
          foo: #M8
        interface: #M5
          map
            foo: #M2
            foo=: #M3
          implemented
            foo: #M2
            foo=: #M3
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  interfaceConstructorIdMismatch
    libraryUri: package:test/a.dart
    interfaceName: A
    constructorName: foo
    expectedId: #M4
    actualId: #M8
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M7
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredFields
              foo: #M1
        interfaces
          A
            requestedConstructors
              foo: #M8
            methods
              foo: #M2
              foo=: #M3
[status] idle
[future] getErrors T2
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
    );
  }

  test_dependency_class_namedConstructor_change_invoked_hasInstanceMethod() async {
    configuration.withStreamResolvedUnitResults = false;
    await _runChangeScenarioTA(
      initialA: r'''
class A {
  A.foo(int _);
  int foo() {}
}
''',
      testCode: r'''
import 'a.dart';
void f() {
  A.foo(0).foo();
}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        declaredConstructors
          foo: #M2
        interface: #M3
          map
            foo: #M1
          implemented
            foo: #M1
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M4
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M5
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        interfaces
          A
            requestedConstructors
              foo: #M2
            methods
              foo: #M1
[status] idle
[future] getErrors T1
  ErrorsResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updatedA: r'''
class A {
  A.foo(double _);
  int foo() {}
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        declaredConstructors
          foo: #M6
        interface: #M3
          map
            foo: #M1
          implemented
            foo: #M1
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  interfaceConstructorIdMismatch
    libraryUri: package:test/a.dart
    interfaceName: A
    constructorName: foo
    expectedId: #M2
    actualId: #M6
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M5
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        interfaces
          A
            requestedConstructors
              foo: #M6
            methods
              foo: #M1
[status] idle
[future] getErrors T2
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
    );
  }

  test_dependency_class_namedConstructor_change_invoked_superInvocation() async {
    configuration.withStreamResolvedUnitResults = false;
    await _runChangeScenarioTA(
      initialA: r'''
class A {
  A.named(int _);
}
''',
      testCode: r'''
import 'a.dart';
class B extends A {
  B.foo() : super.named(0);
}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredConstructors
          named: #M1
        interface: #M2
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      B: #M3
        declaredConstructors
          foo: #M4
        interface: #M5
  requirements
    libraries
      package:test/a.dart
        exportedTopLevels
          A: #M0
          A=: <null>
          named: <null>
          named=: <null>
        reExportDeprecatedOnly
          A: false
        interfaces
          A
            interfaceId: #M2
            hasNonFinalField: false
            requestedConstructors
              named: #M1
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        featureSet: <not-null>
        libraryMetadataId: #M6
        exportedTopLevels
          A: #M0
          A=: <null>
          named: <null>
          named=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            allDeclaredGetters: []
            allDeclaredSetters: []
            allDeclaredMethods: []
        interfaces
          A
            allConstructors: #M1
            requestedConstructors
              named: #M1
[status] idle
[future] getErrors T1
  ErrorsResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updatedA: r'''
class A {
  A.named(double _);
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredConstructors
          named: #M7
        interface: #M2
  requirements
[operation] checkLinkedBundleRequirements
  package:test/test.dart
  interfaceConstructorIdMismatch
    libraryUri: package:test/a.dart
    interfaceName: A
    constructorName: named
    expectedId: #M1
    actualId: #M7
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      B: #M3
        declaredConstructors
          foo: #M8
        interface: #M5
  requirements
    libraries
      package:test/a.dart
        exportedTopLevels
          A: #M0
          A=: <null>
          named: <null>
          named=: <null>
        reExportDeprecatedOnly
          A: false
        interfaces
          A
            interfaceId: #M2
            hasNonFinalField: false
            requestedConstructors
              named: #M7
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  interfaceChildrenIdsMismatch
    libraryUri: package:test/a.dart
    interfaceName: A
    childrenPropertyName: constructors
    expectedIds: #M1
    actualIds: #M7
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        featureSet: <not-null>
        libraryMetadataId: #M6
        exportedTopLevels
          A: #M0
          A=: <null>
          named: <null>
          named=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            allDeclaredGetters: []
            allDeclaredSetters: []
            allDeclaredMethods: []
        interfaces
          A
            allConstructors: #M7
            requestedConstructors
              named: #M7
[status] idle
[future] getErrors T2
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
    );
  }

  test_dependency_class_namedConstructor_change_notUsed() async {
    configuration.withStreamResolvedUnitResults = false;
    await _runChangeScenarioTA(
      initialA: r'''
class A {
  A.c1();
  A.c2(int _);
}
''',
      testCode: r'''
import 'a.dart';
void f() {
  A.c1();
}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredConstructors
          c1: #M1
          c2: #M2
        interface: #M3
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M4
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M5
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        interfaces
          A
            requestedConstructors
              c1: #M1
[status] idle
[future] getErrors T1
  ErrorsResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updatedA: r'''
class A {
  A.c1();
  A.c2(double _);
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredConstructors
          c1: #M1
          c2: #M6
        interface: #M3
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] getErrorsFromBytes
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[status] idle
[future] getErrors T2
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
    );
  }

  test_dependency_class_namedConstructor_remove_invoked() async {
    configuration.withStreamResolvedUnitResults = false;
    await _runChangeScenarioTA(
      initialA: r'''
class A {
  A.c1();
  A.c2();
}
''',
      testCode: r'''
import 'a.dart';
void f() {
  A.c2();
}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredConstructors
          c1: #M1
          c2: #M2
        interface: #M3
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M4
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M5
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        interfaces
          A
            requestedConstructors
              c2: #M2
[status] idle
[future] getErrors T1
  ErrorsResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updatedA: r'''
class A {
  A.c1();
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredConstructors
          c1: #M1
        interface: #M3
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  interfaceConstructorIdMismatch
    libraryUri: package:test/a.dart
    interfaceName: A
    constructorName: c2
    expectedId: #M2
    actualId: <null>
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M5
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredGetters
              c2: <null>
            requestedDeclaredMethods
              c2: <null>
        interfaces
          A
            requestedConstructors
              c2: <null>
[status] idle
[future] getErrors T2
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
    errors
      32 +2 UNDEFINED_METHOD
''',
    );
  }

  test_dependency_class_staticField_add_getFields() async {
    _ManualRequirements.install((state) {
      var A = state.singleUnit.scopeInstanceElement('A');
      A.fields;
    });

    await _runChangeScenarioTA(
      initialA: r'''
class A {
  static final int foo = 0;
}
''',
      testCode: r'''
import 'a.dart';
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        interface: #M3
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
    errors
      7 +8 UNUSED_IMPORT
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M4
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            allDeclaredFields: #M1
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
    errors
      7 +8 UNUSED_IMPORT
''',
      updatedA: r'''
class A {
  static final int foo = 0;
  static final int bar = 0;
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredFields
          bar: #M5
          foo: #M1
        declaredGetters
          bar: #M6
          foo: #M2
        interface: #M3
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  instanceChildrenIdsMismatch
    libraryUri: package:test/a.dart
    instanceName: A
    childrenPropertyName: fields
    expectedIds: #M1
    actualIds: #M1 #M5
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
    errors
      7 +8 UNUSED_IMPORT
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M4
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            allDeclaredFields: #M1 #M5
[status] idle
[future] getErrors T2
  ErrorsResult #3
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
    errors
      7 +8 UNUSED_IMPORT
''',
    );
  }

  test_dependency_class_staticGetter_change_invoked() async {
    await _runChangeScenarioTA(
      initialA: r'''
class A {
  static int get foo {}
}
''',
      testCode: r'''
import 'a.dart';
void f() {
  A.foo;
}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        interface: #M3
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M4
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M5
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredFields
              foo: #M1
            requestedDeclaredGetters
              foo: #M2
        interfaces
          A
            requestedConstructors
              foo: <null>
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updatedA: r'''
class A {
  static double get foo {}
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M6
        declaredGetters
          foo: #M7
        interface: #M3
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  instanceFieldIdMismatch
    libraryUri: package:test/a.dart
    interfaceName: A
    fieldName: foo
    expectedId: #M1
    actualId: #M6
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M5
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredFields
              foo: #M6
            requestedDeclaredGetters
              foo: #M7
        interfaces
          A
            requestedConstructors
              foo: <null>
[status] idle
[future] getErrors T2
  ErrorsResult #3
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
    );
  }

  test_dependency_class_staticGetter_change_notUsed() async {
    await _runChangeScenarioTA(
      initialA: r'''
class A {
  static int get foo {}
  static int get bar {}
}
''',
      testCode: r'''
import 'a.dart';
void f() {
  A.foo;
}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredFields
          bar: #M1
          foo: #M2
        declaredGetters
          bar: #M3
          foo: #M4
        interface: #M5
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M6
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M7
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredFields
              foo: #M2
            requestedDeclaredGetters
              foo: #M4
        interfaces
          A
            requestedConstructors
              foo: <null>
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updatedA: r'''
class A {
  static int get foo {}
  static double get bar {}
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredFields
          bar: #M8
          foo: #M2
        declaredGetters
          bar: #M9
          foo: #M4
        interface: #M5
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] getErrorsFromBytes
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[status] idle
[future] getErrors T2
  ErrorsResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
    );
  }

  test_dependency_class_staticMethod_change_invoked() async {
    await _runChangeScenarioTA(
      initialA: r'''
class A {
  static int foo() {}
}
''',
      testCode: r'''
import 'a.dart';
void f() {
  A.foo();
}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M3
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M4
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredGetters
              foo: <null>
            requestedDeclaredMethods
              foo: #M1
        interfaces
          A
            requestedConstructors
              foo: <null>
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updatedA: r'''
class A {
  static double foo() {}
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M5
        interface: #M2
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  instanceMethodIdMismatch
    libraryUri: package:test/a.dart
    interfaceName: A
    methodName: foo
    expectedId: #M1
    actualId: #M5
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M4
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredGetters
              foo: <null>
            requestedDeclaredMethods
              foo: #M5
        interfaces
          A
            requestedConstructors
              foo: <null>
[status] idle
[future] getErrors T2
  ErrorsResult #3
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
    );
  }

  test_dependency_class_staticMethod_change_notUsed() async {
    await _runChangeScenarioTA(
      initialA: r'''
class A {
  static int foo() {}
  static int bar() {}
}
''',
      testCode: r'''
import 'a.dart';
void f() {
  A.foo();
}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredMethods
          bar: #M1
          foo: #M2
        interface: #M3
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M4
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M5
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredGetters
              foo: <null>
            requestedDeclaredMethods
              foo: #M2
        interfaces
          A
            requestedConstructors
              foo: <null>
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updatedA: r'''
class A {
  static int foo() {}
  static double bar() {}
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredMethods
          bar: #M6
          foo: #M2
        interface: #M3
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] getErrorsFromBytes
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[status] idle
[future] getErrors T2
  ErrorsResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
    );
  }

  test_dependency_class_staticSetter_change_invoked() async {
    await _runChangeScenarioTA(
      initialA: r'''
class A {
  static set foo(int _) {}
}
''',
      testCode: r'''
import 'a.dart';
void f() {
  A.foo = 0;
}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredSetters
          foo=: #M2
        interface: #M3
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M4
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M5
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredFields
              foo: #M1
            requestedDeclaredSetters
              foo=: #M2
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updatedA: r'''
class A {
  static set foo(double _) {}
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M6
        declaredSetters
          foo=: #M7
        interface: #M3
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  instanceFieldIdMismatch
    libraryUri: package:test/a.dart
    interfaceName: A
    fieldName: foo
    expectedId: #M1
    actualId: #M6
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M5
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredFields
              foo: #M6
            requestedDeclaredSetters
              foo=: #M7
[status] idle
[future] getErrors T2
  ErrorsResult #3
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
    );
  }

  test_dependency_class_staticSetter_change_notUsed() async {
    await _runChangeScenarioTA(
      initialA: r'''
class A {
  static set foo(int _) {}
  static set bar(int _) {}
}
''',
      testCode: r'''
import 'a.dart';
void f() {
  A.foo = 0;
}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredFields
          bar: #M1
          foo: #M2
        declaredSetters
          bar=: #M3
          foo=: #M4
        interface: #M5
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M6
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M7
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredFields
              foo: #M2
            requestedDeclaredSetters
              foo=: #M4
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updatedA: r'''
class A {
  static set foo(int _) {}
  static set bar(double _) {}
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredFields
          bar: #M8
          foo: #M2
        declaredSetters
          bar=: #M9
          foo=: #M4
        interface: #M5
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] getErrorsFromBytes
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[status] idle
[future] getErrors T2
  ErrorsResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
    );
  }

  test_dependency_class_unnamedConstructor_change_getConstructors() async {
    configuration.includeDefaultConstructors();

    _ManualRequirements.install((state) {
      var A = state.singleUnit.scopeInterfaceElement('A');
      A.constructors;
    });

    await _runChangeScenarioTA(
      initialA: r'''
class A {
  A(int _);
  A.named(int _);
}
''',
      testCode: r'''
import 'a.dart';
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredConstructors
          named: #M1
          new: #M2
        interface: #M3
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
    errors
      7 +8 UNUSED_IMPORT
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M4
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        interfaces
          A
            allConstructors: #M2 #M1
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
    errors
      7 +8 UNUSED_IMPORT
''',
      updatedA: r'''
class A {
  A(double _);
  A.named(int _);
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredConstructors
          named: #M1
          new: #M5
        interface: #M3
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  interfaceChildrenIdsMismatch
    libraryUri: package:test/a.dart
    interfaceName: A
    childrenPropertyName: constructors
    expectedIds: #M2 #M1
    actualIds: #M5 #M1
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
    errors
      7 +8 UNUSED_IMPORT
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M4
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        interfaces
          A
            allConstructors: #M5 #M1
[status] idle
[future] getErrors T2
  ErrorsResult #3
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
    errors
      7 +8 UNUSED_IMPORT
''',
    );
  }

  test_dependency_class_unnamedConstructor_change_getUnnamedConstructor() async {
    configuration.includeDefaultConstructors();

    _ManualRequirements.install((state) {
      var A = state.singleUnit.scopeInterfaceElement('A');
      A.unnamedConstructor;
    });

    await _runChangeScenarioTA(
      initialA: r'''
class A {
  A(int _);
}
''',
      testCode: r'''
import 'a.dart';
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredConstructors
          new: #M1
        interface: #M2
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
    errors
      7 +8 UNUSED_IMPORT
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M3
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        interfaces
          A
            requestedConstructors
              new: #M1
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
    errors
      7 +8 UNUSED_IMPORT
''',
      updatedA: r'''
class A {
  A(int _);
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] reuseLinkedBundle
  package:test/a.dart
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] getErrorsFromBytes
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[status] idle
[future] getErrors T2
  ErrorsResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
    errors
      7 +8 UNUSED_IMPORT
''',
    );
  }

  test_dependency_class_unnamedConstructor_change_invoked() async {
    configuration
      ..includeDefaultConstructors()
      ..withStreamResolvedUnitResults = false;
    await _runChangeScenarioTA(
      initialA: r'''
class A {
  A(int _);
}
''',
      testCode: r'''
import 'a.dart';
void f() {
  A(0);
}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredConstructors
          new: #M1
        interface: #M2
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M3
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M4
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        interfaces
          A
            requestedConstructors
              new: #M1
[status] idle
[future] getErrors T1
  ErrorsResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updatedA: r'''
class A {
  A(double _);
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredConstructors
          new: #M5
        interface: #M2
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  interfaceConstructorIdMismatch
    libraryUri: package:test/a.dart
    interfaceName: A
    constructorName: new
    expectedId: #M1
    actualId: #M5
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M4
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        interfaces
          A
            requestedConstructors
              new: #M5
[status] idle
[future] getErrors T2
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
    );
  }

  test_dependency_class_unnamedConstructor_change_notUsed() async {
    configuration
      ..includeDefaultConstructors()
      ..withStreamResolvedUnitResults = false;
    await _runChangeScenarioTA(
      initialA: r'''
class A {
  A(int _);
  A.named(int _);
}
''',
      testCode: r'''
import 'a.dart';
void f() {
  A.named(0);
}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredConstructors
          named: #M1
          new: #M2
        interface: #M3
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M4
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M5
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        interfaces
          A
            requestedConstructors
              named: #M1
[status] idle
[future] getErrors T1
  ErrorsResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updatedA: r'''
class A {
  A(double _);
  A.named(int _);
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredConstructors
          named: #M1
          new: #M6
        interface: #M3
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] getErrorsFromBytes
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[status] idle
[future] getErrors T2
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
    );
  }

  test_dependency_classTypaAlias_namedConstructor_change_invoked() async {
    configuration.withStreamResolvedUnitResults = false;
    await _runChangeScenarioTA(
      initialA: r'''
class A {
  A.named(int _);
}
mixin M {}
class B = A with M;
''',
      testCode: r'''
import 'a.dart';
void f() {
  B.named(0);
}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredConstructors
          named: #M1
        interface: #M2
      B: #M3
        inheritedConstructors
          named: #M1
        interface: #M4
    declaredMixins
      M: #M5
        interface: #M6
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M7
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M8
        exportedTopLevels
          B: #M3
          B=: <null>
        reExportDeprecatedOnly
          B: false
        interfaces
          B
            requestedConstructors
              named: #M1
[status] idle
[future] getErrors T1
  ErrorsResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updatedA: r'''
class A {
  A.named(double _);
}
mixin M {}
class B = A with M;
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredConstructors
          named: #M9
        interface: #M2
      B: #M3
        inheritedConstructors
          named: #M9
        interface: #M4
    declaredMixins
      M: #M5
        interface: #M6
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  interfaceConstructorIdMismatch
    libraryUri: package:test/a.dart
    interfaceName: B
    constructorName: named
    expectedId: #M1
    actualId: #M9
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M8
        exportedTopLevels
          B: #M3
          B=: <null>
        reExportDeprecatedOnly
          B: false
        interfaces
          B
            requestedConstructors
              named: #M9
[status] idle
[future] getErrors T2
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
    );
  }

  test_dependency_enum_constant_change_invoked() async {
    await _runChangeScenarioTA(
      initialA: r'''
enum A {
  foo(0);
  const A(int _)
}
''',
      testCode: r'''
import 'a.dart';
void f() {
  A.foo;
}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredEnums
      A: #M0
        declaredFields
          foo: #M1
          values: #M2
        declaredGetters
          foo: #M3
          values: #M4
        interface: #M5
          map
            index: #M6
          implemented
            index: #M6
          superImplemented
            [0]
              index: #M6
          inherited
            index: #M6
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M7
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M8
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredFields
              foo: #M1
            requestedDeclaredGetters
              foo: #M3
        interfaces
          A
            requestedConstructors
              foo: <null>
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updatedA: r'''
enum A {
  foo(1);
  const A(int _)
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredEnums
      A: #M0
        declaredFields
          foo: #M9
          values: #M10
        declaredGetters
          foo: #M3
          values: #M4
        interface: #M5
          map
            index: #M6
          implemented
            index: #M6
          superImplemented
            [0]
              index: #M6
          inherited
            index: #M6
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  instanceFieldIdMismatch
    libraryUri: package:test/a.dart
    interfaceName: A
    fieldName: foo
    expectedId: #M1
    actualId: #M9
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M8
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredFields
              foo: #M9
            requestedDeclaredGetters
              foo: #M3
        interfaces
          A
            requestedConstructors
              foo: <null>
[status] idle
[future] getErrors T2
  ErrorsResult #3
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
    );
  }

  test_dependency_enum_instanceGetter_change_invoked() async {
    await _runChangeScenarioTA(
      initialA: r'''
enum A {
  v;
  int get foo => 0;
}
''',
      testCode: r'''
import 'a.dart';
void f(A a) {
  a.foo;
}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredEnums
      A: #M0
        declaredFields
          foo: #M1
          v: #M2
          values: #M3
        declaredGetters
          foo: #M4
          v: #M5
          values: #M6
        interface: #M7
          map
            foo: #M4
            index: #M8
          implemented
            foo: #M4
            index: #M8
          superImplemented
            [0]
              index: #M8
          inherited
            index: #M8
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M9
  requirements
    libraries
      package:test/a.dart
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M10
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredFields
              foo: #M1
        interfaces
          A
            methods
              foo: #M4
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updatedA: r'''
enum A {
  v;
  double get foo => 1.2;
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredEnums
      A: #M0
        declaredFields
          foo: #M11
          v: #M2
          values: #M3
        declaredGetters
          foo: #M12
          v: #M5
          values: #M6
        interface: #M13
          map
            foo: #M12
            index: #M8
          implemented
            foo: #M12
            index: #M8
          superImplemented
            [0]
              index: #M8
          inherited
            index: #M8
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  instanceFieldIdMismatch
    libraryUri: package:test/a.dart
    interfaceName: A
    fieldName: foo
    expectedId: #M1
    actualId: #M11
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M10
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredFields
              foo: #M11
        interfaces
          A
            methods
              foo: #M12
[status] idle
[future] getErrors T2
  ErrorsResult #3
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
    );
  }

  test_dependency_enum_instanceGetter_change_notUsed() async {
    await _runChangeScenarioTA(
      initialA: r'''
enum A {
  v;
  int get foo => 0;
  int get bar => 0;
}
''',
      testCode: r'''
import 'a.dart';
void f(A a) {
  a.foo;
}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredEnums
      A: #M0
        declaredFields
          bar: #M1
          foo: #M2
          v: #M3
          values: #M4
        declaredGetters
          bar: #M5
          foo: #M6
          v: #M7
          values: #M8
        interface: #M9
          map
            bar: #M5
            foo: #M6
            index: #M10
          implemented
            bar: #M5
            foo: #M6
            index: #M10
          superImplemented
            [0]
              index: #M10
          inherited
            index: #M10
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M11
  requirements
    libraries
      package:test/a.dart
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M12
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredFields
              foo: #M2
        interfaces
          A
            methods
              foo: #M6
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updatedA: r'''
enum A {
  v;
  int get foo => 0;
  double get bar => 0;
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredEnums
      A: #M0
        declaredFields
          bar: #M13
          foo: #M2
          v: #M3
          values: #M4
        declaredGetters
          bar: #M14
          foo: #M6
          v: #M7
          values: #M8
        interface: #M15
          map
            bar: #M14
            foo: #M6
            index: #M10
          implemented
            bar: #M14
            foo: #M6
            index: #M10
          superImplemented
            [0]
              index: #M10
          inherited
            index: #M10
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] getErrorsFromBytes
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[status] idle
[future] getErrors T2
  ErrorsResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
    );
  }

  test_dependency_enum_instanceMethod_change_invoked() async {
    await _runChangeScenarioTA(
      initialA: r'''
enum A {
  v;
  int foo() {}
}
''',
      testCode: r'''
import 'a.dart';
void f(A a) {
  a.foo();
}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredEnums
      A: #M0
        declaredFields
          v: #M1
          values: #M2
        declaredGetters
          v: #M3
          values: #M4
        declaredMethods
          foo: #M5
        interface: #M6
          map
            foo: #M5
            index: #M7
          implemented
            foo: #M5
            index: #M7
          superImplemented
            [0]
              index: #M7
          inherited
            index: #M7
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M8
  requirements
    libraries
      package:test/a.dart
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M9
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        interfaces
          A
            methods
              foo: #M5
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updatedA: r'''
enum A {
  v;
  double foo() {}
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredEnums
      A: #M0
        declaredFields
          v: #M1
          values: #M2
        declaredGetters
          v: #M3
          values: #M4
        declaredMethods
          foo: #M10
        interface: #M11
          map
            foo: #M10
            index: #M7
          implemented
            foo: #M10
            index: #M7
          superImplemented
            [0]
              index: #M7
          inherited
            index: #M7
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  instanceMethodIdMismatch
    libraryUri: package:test/a.dart
    interfaceName: A
    methodName: foo
    expectedId: #M5
    actualId: #M10
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M9
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        interfaces
          A
            methods
              foo: #M10
[status] idle
[future] getErrors T2
  ErrorsResult #3
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
    );
  }

  test_dependency_enum_instanceMethod_change_notUsed() async {
    await _runChangeScenarioTA(
      initialA: r'''
enum A {
  v;
  int foo() {}
  int bar() {}
}
''',
      testCode: r'''
import 'a.dart';
void f(A a) {
  a.foo();
}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredEnums
      A: #M0
        declaredFields
          v: #M1
          values: #M2
        declaredGetters
          v: #M3
          values: #M4
        declaredMethods
          bar: #M5
          foo: #M6
        interface: #M7
          map
            bar: #M5
            foo: #M6
            index: #M8
          implemented
            bar: #M5
            foo: #M6
            index: #M8
          superImplemented
            [0]
              index: #M8
          inherited
            index: #M8
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M9
  requirements
    libraries
      package:test/a.dart
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M10
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        interfaces
          A
            methods
              foo: #M6
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updatedA: r'''
enum A {
  v;
  int foo() {}
  double bar() {}
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredEnums
      A: #M0
        declaredFields
          v: #M1
          values: #M2
        declaredGetters
          v: #M3
          values: #M4
        declaredMethods
          bar: #M11
          foo: #M6
        interface: #M12
          map
            bar: #M11
            foo: #M6
            index: #M8
          implemented
            bar: #M11
            foo: #M6
            index: #M8
          superImplemented
            [0]
              index: #M8
          inherited
            index: #M8
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] getErrorsFromBytes
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[status] idle
[future] getErrors T2
  ErrorsResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
    );
  }

  test_dependency_enum_instanceSetter_change_invoked() async {
    await _runChangeScenarioTA(
      initialA: r'''
enum A {
  v;
  set foo(int _) {}
}
''',
      testCode: r'''
import 'a.dart';
void f(A a) {
  a.foo = 0;
}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredEnums
      A: #M0
        declaredFields
          foo: #M1
          v: #M2
          values: #M3
        declaredGetters
          v: #M4
          values: #M5
        declaredSetters
          foo=: #M6
        interface: #M7
          map
            foo=: #M6
            index: #M8
          implemented
            foo=: #M6
            index: #M8
          superImplemented
            [0]
              index: #M8
          inherited
            index: #M8
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M9
  requirements
    libraries
      package:test/a.dart
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M10
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredFields
              foo: #M1
        interfaces
          A
            methods
              foo=: #M6
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updatedA: r'''
enum A {
  v;
  set foo(double _) {}
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredEnums
      A: #M0
        declaredFields
          foo: #M11
          v: #M2
          values: #M3
        declaredGetters
          v: #M4
          values: #M5
        declaredSetters
          foo=: #M12
        interface: #M13
          map
            foo=: #M12
            index: #M8
          implemented
            foo=: #M12
            index: #M8
          superImplemented
            [0]
              index: #M8
          inherited
            index: #M8
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  instanceFieldIdMismatch
    libraryUri: package:test/a.dart
    interfaceName: A
    fieldName: foo
    expectedId: #M1
    actualId: #M11
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M10
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredFields
              foo: #M11
        interfaces
          A
            methods
              foo=: #M12
[status] idle
[future] getErrors T2
  ErrorsResult #3
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
    );
  }

  test_dependency_enum_instanceSetter_change_notUsed() async {
    await _runChangeScenarioTA(
      initialA: r'''
enum A {
  v;
  set foo(int _) {}
  set bar(int _) {}
}
''',
      testCode: r'''
import 'a.dart';
void f(A a) {
  a.foo = 0;
}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredEnums
      A: #M0
        declaredFields
          bar: #M1
          foo: #M2
          v: #M3
          values: #M4
        declaredGetters
          v: #M5
          values: #M6
        declaredSetters
          bar=: #M7
          foo=: #M8
        interface: #M9
          map
            bar=: #M7
            foo=: #M8
            index: #M10
          implemented
            bar=: #M7
            foo=: #M8
            index: #M10
          superImplemented
            [0]
              index: #M10
          inherited
            index: #M10
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M11
  requirements
    libraries
      package:test/a.dart
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M12
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredFields
              foo: #M2
        interfaces
          A
            methods
              foo=: #M8
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updatedA: r'''
enum A {
  v;
  set foo(int _) {}
  set bar(double _) {}
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredEnums
      A: #M0
        declaredFields
          bar: #M13
          foo: #M2
          v: #M3
          values: #M4
        declaredGetters
          v: #M5
          values: #M6
        declaredSetters
          bar=: #M14
          foo=: #M8
        interface: #M15
          map
            bar=: #M14
            foo=: #M8
            index: #M10
          implemented
            bar=: #M14
            foo=: #M8
            index: #M10
          superImplemented
            [0]
              index: #M10
          inherited
            index: #M10
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] getErrorsFromBytes
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[status] idle
[future] getErrors T2
  ErrorsResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
    );
  }

  test_dependency_enum_staticGetter_change_invoked() async {
    await _runChangeScenarioTA(
      initialA: r'''
enum A {
  v;
  static int get foo {}
}
''',
      testCode: r'''
import 'a.dart';
void f() {
  A.foo;
}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredEnums
      A: #M0
        declaredFields
          foo: #M1
          v: #M2
          values: #M3
        declaredGetters
          foo: #M4
          v: #M5
          values: #M6
        interface: #M7
          map
            index: #M8
          implemented
            index: #M8
          superImplemented
            [0]
              index: #M8
          inherited
            index: #M8
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M9
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M10
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredFields
              foo: #M1
            requestedDeclaredGetters
              foo: #M4
        interfaces
          A
            requestedConstructors
              foo: <null>
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updatedA: r'''
enum A {
  v;
  static double get foo {}
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredEnums
      A: #M0
        declaredFields
          foo: #M11
          v: #M2
          values: #M3
        declaredGetters
          foo: #M12
          v: #M5
          values: #M6
        interface: #M7
          map
            index: #M8
          implemented
            index: #M8
          superImplemented
            [0]
              index: #M8
          inherited
            index: #M8
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  instanceFieldIdMismatch
    libraryUri: package:test/a.dart
    interfaceName: A
    fieldName: foo
    expectedId: #M1
    actualId: #M11
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M10
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredFields
              foo: #M11
            requestedDeclaredGetters
              foo: #M12
        interfaces
          A
            requestedConstructors
              foo: <null>
[status] idle
[future] getErrors T2
  ErrorsResult #3
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
    );
  }

  test_dependency_enum_staticGetter_change_notUsed() async {
    await _runChangeScenarioTA(
      initialA: r'''
enum A {
  v;
  static int get foo {}
  static int get bar {}
}
''',
      testCode: r'''
import 'a.dart';
void f() {
  A.foo;
}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredEnums
      A: #M0
        declaredFields
          bar: #M1
          foo: #M2
          v: #M3
          values: #M4
        declaredGetters
          bar: #M5
          foo: #M6
          v: #M7
          values: #M8
        interface: #M9
          map
            index: #M10
          implemented
            index: #M10
          superImplemented
            [0]
              index: #M10
          inherited
            index: #M10
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M11
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M12
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredFields
              foo: #M2
            requestedDeclaredGetters
              foo: #M6
        interfaces
          A
            requestedConstructors
              foo: <null>
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updatedA: r'''
enum A {
  v;
  static int get foo {}
  static double get bar {}
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredEnums
      A: #M0
        declaredFields
          bar: #M13
          foo: #M2
          v: #M3
          values: #M4
        declaredGetters
          bar: #M14
          foo: #M6
          v: #M7
          values: #M8
        interface: #M9
          map
            index: #M10
          implemented
            index: #M10
          superImplemented
            [0]
              index: #M10
          inherited
            index: #M10
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] getErrorsFromBytes
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[status] idle
[future] getErrors T2
  ErrorsResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
    );
  }

  test_dependency_enum_staticMethod_change_invoked() async {
    await _runChangeScenarioTA(
      initialA: r'''
enum A {
  v;
  static int foo() {}
}
''',
      testCode: r'''
import 'a.dart';
void f() {
  A.foo();
}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredEnums
      A: #M0
        declaredFields
          v: #M1
          values: #M2
        declaredGetters
          v: #M3
          values: #M4
        declaredMethods
          foo: #M5
        interface: #M6
          map
            index: #M7
          implemented
            index: #M7
          superImplemented
            [0]
              index: #M7
          inherited
            index: #M7
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M8
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M9
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredGetters
              foo: <null>
            requestedDeclaredMethods
              foo: #M5
        interfaces
          A
            requestedConstructors
              foo: <null>
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updatedA: r'''
enum A {
  v;
  static double foo() {}
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredEnums
      A: #M0
        declaredFields
          v: #M1
          values: #M2
        declaredGetters
          v: #M3
          values: #M4
        declaredMethods
          foo: #M10
        interface: #M6
          map
            index: #M7
          implemented
            index: #M7
          superImplemented
            [0]
              index: #M7
          inherited
            index: #M7
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  instanceMethodIdMismatch
    libraryUri: package:test/a.dart
    interfaceName: A
    methodName: foo
    expectedId: #M5
    actualId: #M10
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M9
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredGetters
              foo: <null>
            requestedDeclaredMethods
              foo: #M10
        interfaces
          A
            requestedConstructors
              foo: <null>
[status] idle
[future] getErrors T2
  ErrorsResult #3
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
    );
  }

  test_dependency_enum_staticMethod_change_notUsed() async {
    await _runChangeScenarioTA(
      initialA: r'''
enum A {
  v;
  static int foo() {}
  static int bar() {}
}
''',
      testCode: r'''
import 'a.dart';
void f() {
  A.foo();
}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredEnums
      A: #M0
        declaredFields
          v: #M1
          values: #M2
        declaredGetters
          v: #M3
          values: #M4
        declaredMethods
          bar: #M5
          foo: #M6
        interface: #M7
          map
            index: #M8
          implemented
            index: #M8
          superImplemented
            [0]
              index: #M8
          inherited
            index: #M8
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M9
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M10
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredGetters
              foo: <null>
            requestedDeclaredMethods
              foo: #M6
        interfaces
          A
            requestedConstructors
              foo: <null>
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updatedA: r'''
enum A {
  v;
  static int foo() {}
  static double bar() {}
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredEnums
      A: #M0
        declaredFields
          v: #M1
          values: #M2
        declaredGetters
          v: #M3
          values: #M4
        declaredMethods
          bar: #M11
          foo: #M6
        interface: #M7
          map
            index: #M8
          implemented
            index: #M8
          superImplemented
            [0]
              index: #M8
          inherited
            index: #M8
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] getErrorsFromBytes
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[status] idle
[future] getErrors T2
  ErrorsResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
    );
  }

  test_dependency_enum_staticSetter_change_invoked() async {
    await _runChangeScenarioTA(
      initialA: r'''
enum A {
  v;
  static set foo(int _) {}
}
''',
      testCode: r'''
import 'a.dart';
void f() {
  A.foo = 0;
}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredEnums
      A: #M0
        declaredFields
          foo: #M1
          v: #M2
          values: #M3
        declaredGetters
          v: #M4
          values: #M5
        declaredSetters
          foo=: #M6
        interface: #M7
          map
            index: #M8
          implemented
            index: #M8
          superImplemented
            [0]
              index: #M8
          inherited
            index: #M8
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M9
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M10
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredFields
              foo: #M1
            requestedDeclaredSetters
              foo=: #M6
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updatedA: r'''
enum A {
  v;
  static set foo(double _) {}
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredEnums
      A: #M0
        declaredFields
          foo: #M11
          v: #M2
          values: #M3
        declaredGetters
          v: #M4
          values: #M5
        declaredSetters
          foo=: #M12
        interface: #M7
          map
            index: #M8
          implemented
            index: #M8
          superImplemented
            [0]
              index: #M8
          inherited
            index: #M8
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  instanceFieldIdMismatch
    libraryUri: package:test/a.dart
    interfaceName: A
    fieldName: foo
    expectedId: #M1
    actualId: #M11
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M10
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredFields
              foo: #M11
            requestedDeclaredSetters
              foo=: #M12
[status] idle
[future] getErrors T2
  ErrorsResult #3
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
    );
  }

  test_dependency_enum_staticSetter_change_notUsed() async {
    await _runChangeScenarioTA(
      initialA: r'''
enum A {
  v;
  static set foo(int _) {}
  static set bar(int _) {}
}
''',
      testCode: r'''
import 'a.dart';
void f() {
  A.foo = 0;
}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredEnums
      A: #M0
        declaredFields
          bar: #M1
          foo: #M2
          v: #M3
          values: #M4
        declaredGetters
          v: #M5
          values: #M6
        declaredSetters
          bar=: #M7
          foo=: #M8
        interface: #M9
          map
            index: #M10
          implemented
            index: #M10
          superImplemented
            [0]
              index: #M10
          inherited
            index: #M10
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M11
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M12
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredFields
              foo: #M2
            requestedDeclaredSetters
              foo=: #M8
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updatedA: r'''
enum A {
  v;
  static set foo(int _) {}
  static set bar(double _) {}
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredEnums
      A: #M0
        declaredFields
          bar: #M13
          foo: #M2
          v: #M3
          values: #M4
        declaredGetters
          v: #M5
          values: #M6
        declaredSetters
          bar=: #M14
          foo=: #M8
        interface: #M9
          map
            index: #M10
          implemented
            index: #M10
          superImplemented
            [0]
              index: #M10
          inherited
            index: #M10
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] getErrorsFromBytes
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[status] idle
[future] getErrors T2
  ErrorsResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
    );
  }

  test_dependency_export_class_excludePrivate() async {
    var a = newFile('$testPackageLibPath/a.dart', r'''
class A {}
class _B {}
''');

    newFile('$testPackageLibPath/test.dart', r'''
export 'a.dart';
''');

    configuration.elementTextConfiguration.withExportScope = true;
    await _runChangeScenario(
      operation: _FineOperationGetTestLibrary(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        interface: #M1
      _B: #M2
        interface: #M3
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    reExportMap
      A: #M0
    exportedLibraryUris: package:test/a.dart
  requirements
    exportRequirements
      package:test/test.dart
        exports
          package:test/a.dart
            A: #M0
[status] idle
[future] getLibraryByUri T1
  library
    exportedReferences
      exported[(0, 0)] package:test/a.dart::@class::A
    exportNamespace
      A: package:test/a.dart::@class::A
''',
      updateFiles: () {
        modifyFile2(a, r'''
class A {}
class _B2 {}
''');
        return [a];
      },
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        interface: #M1
      _B2: #M4
        interface: #M5
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[status] idle
[future] getLibraryByUri T2
  library
    exportedReferences
      exported[(0, 0)] package:test/a.dart::@class::A
    exportNamespace
      A: package:test/a.dart::@class::A
''',
    );
  }

  test_dependency_export_class_localHidesExport_addHidden() async {
    var a = newFile('$testPackageLibPath/a.dart', r'''
class A {}
class B {}
''');

    newFile('$testPackageLibPath/test.dart', r'''
export 'a.dart';
class B {}
class C {}
''');

    configuration.elementTextConfiguration.withExportScope = true;
    await _runChangeScenario(
      operation: _FineOperationGetTestLibrary(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        interface: #M1
      B: #M2
        interface: #M3
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      B: #M4
        interface: #M5
      C: #M6
        interface: #M7
    reExportMap
      A: #M0
    exportedLibraryUris: package:test/a.dart
  requirements
    exportRequirements
      package:test/test.dart
        declaredTopNames: B C
        exports
          package:test/a.dart
            A: #M0
[status] idle
[future] getLibraryByUri T1
  library
    classes
      class B
        constructors
          synthetic new
      class C
        constructors
          synthetic new
    exportedReferences
      exported[(0, 0)] package:test/a.dart::@class::A
      declared <testLibrary>::@class::B
      declared <testLibrary>::@class::C
    exportNamespace
      A: package:test/a.dart::@class::A
      B: <testLibrary>::@class::B
      C: <testLibrary>::@class::C
''',
      updateFiles: () {
        modifyFile2(a, r'''
class A {}
class B {}
class C {}
''');
        return [a];
      },
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        interface: #M1
      B: #M2
        interface: #M3
      C: #M8
        interface: #M9
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[status] idle
[future] getLibraryByUri T2
  library
    classes
      class B
        constructors
          synthetic new
      class C
        constructors
          synthetic new
    exportedReferences
      exported[(0, 0)] package:test/a.dart::@class::A
      declared <testLibrary>::@class::B
      declared <testLibrary>::@class::C
    exportNamespace
      A: package:test/a.dart::@class::A
      B: <testLibrary>::@class::B
      C: <testLibrary>::@class::C
''',
    );
  }

  test_dependency_export_class_localHidesExport_addNotHidden() async {
    var a = newFile('$testPackageLibPath/a.dart', r'''
class A {}
class B {}
''');

    newFile('$testPackageLibPath/test.dart', r'''
export 'a.dart';
class B {}
''');

    configuration.elementTextConfiguration.withExportScope = true;
    await _runChangeScenario(
      operation: _FineOperationGetTestLibrary(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        interface: #M1
      B: #M2
        interface: #M3
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      B: #M4
        interface: #M5
    reExportMap
      A: #M0
    exportedLibraryUris: package:test/a.dart
  requirements
    exportRequirements
      package:test/test.dart
        declaredTopNames: B
        exports
          package:test/a.dart
            A: #M0
[status] idle
[future] getLibraryByUri T1
  library
    classes
      class B
        constructors
          synthetic new
    exportedReferences
      exported[(0, 0)] package:test/a.dart::@class::A
      declared <testLibrary>::@class::B
    exportNamespace
      A: package:test/a.dart::@class::A
      B: <testLibrary>::@class::B
''',
      updateFiles: () {
        modifyFile2(a, r'''
class A {}
class B {}
class C {}
''');
        return [a];
      },
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        interface: #M1
      B: #M2
        interface: #M3
      C: #M6
        interface: #M7
  requirements
[operation] checkLinkedBundleRequirements
  package:test/test.dart
  exportIdMismatch
    fragmentUri: package:test/test.dart
    exportedUri: package:test/a.dart
    name: C
    expectedId: <null>
    actualId: #M6
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      B: #M4
        interface: #M5
    reExportMap
      A: #M0
      C: #M6
    exportedLibraryUris: package:test/a.dart
  requirements
    exportRequirements
      package:test/test.dart
        declaredTopNames: B
        exports
          package:test/a.dart
            A: #M0
            C: #M6
[status] idle
[future] getLibraryByUri T2
  library
    classes
      class B
        constructors
          synthetic new
    exportedReferences
      exported[(0, 0)] package:test/a.dart::@class::A
      exported[(0, 0)] package:test/a.dart::@class::C
      declared <testLibrary>::@class::B
    exportNamespace
      A: package:test/a.dart::@class::A
      B: <testLibrary>::@class::B
      C: package:test/a.dart::@class::C
''',
    );
  }

  test_dependency_export_class_reExport_chain_external() async {
    var a = newFile('$testPackageLibPath/a.dart', r'''
class A1 {}
class A2 {}
class A3 {}
''');

    newFile('$testPackageLibPath/b.dart', r'''
export 'a.dart';
class B {}
''');

    newFile('$testPackageLibPath/test.dart', r'''
export 'b.dart';
''');

    configuration.elementTextConfiguration.withExportScope = true;
    await _runChangeScenario(
      operation: _FineOperationGetTestLibrary(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A1: #M0
        interface: #M1
      A2: #M2
        interface: #M3
      A3: #M4
        interface: #M5
  requirements
[operation] linkLibraryCycle
  package:test/b.dart
    declaredClasses
      B: #M6
        interface: #M7
    reExportMap
      A1: #M0
      A2: #M2
      A3: #M4
    exportedLibraryUris: package:test/a.dart
  requirements
    exportRequirements
      package:test/b.dart
        declaredTopNames: B
        exports
          package:test/a.dart
            A1: #M0
            A2: #M2
            A3: #M4
[operation] linkLibraryCycle
  package:test/test.dart
    reExportMap
      A1: #M0
      A2: #M2
      A3: #M4
      B: #M6
    exportedLibraryUris: package:test/b.dart
  requirements
    exportRequirements
      package:test/test.dart
        exports
          package:test/b.dart
            A1: #M0
            A2: #M2
            A3: #M4
            B: #M6
[status] idle
[future] getLibraryByUri T1
  library
    exportedReferences
      exported[(0, 0)] package:test/a.dart::@class::A1
      exported[(0, 0)] package:test/a.dart::@class::A2
      exported[(0, 0)] package:test/a.dart::@class::A3
      exported[(0, 0)] package:test/b.dart::@class::B
    exportNamespace
      A1: package:test/a.dart::@class::A1
      A2: package:test/a.dart::@class::A2
      A3: package:test/a.dart::@class::A3
      B: package:test/b.dart::@class::B
''',
      updateFiles: () {
        modifyFile2(a, r'''
abstract class A2 {}
class A3 {}
''');
        return [a];
      },
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A2: #M8
        interface: #M9
      A3: #M4
        interface: #M5
  requirements
[operation] checkLinkedBundleRequirements
  package:test/b.dart
  exportIdMismatch
    fragmentUri: package:test/b.dart
    exportedUri: package:test/a.dart
    name: A2
    expectedId: #M2
    actualId: #M8
[operation] linkLibraryCycle
  package:test/b.dart
    declaredClasses
      B: #M6
        interface: #M7
    reExportMap
      A2: #M8
      A3: #M4
    exportedLibraryUris: package:test/a.dart
  requirements
    exportRequirements
      package:test/b.dart
        declaredTopNames: B
        exports
          package:test/a.dart
            A2: #M8
            A3: #M4
[operation] checkLinkedBundleRequirements
  package:test/test.dart
  exportIdMismatch
    fragmentUri: package:test/test.dart
    exportedUri: package:test/b.dart
    name: A2
    expectedId: #M2
    actualId: #M8
[operation] linkLibraryCycle
  package:test/test.dart
    reExportMap
      A2: #M8
      A3: #M4
      B: #M6
    exportedLibraryUris: package:test/b.dart
  requirements
    exportRequirements
      package:test/test.dart
        exports
          package:test/b.dart
            A2: #M8
            A3: #M4
            B: #M6
[status] idle
[future] getLibraryByUri T2
  library
    exportedReferences
      exported[(0, 0)] package:test/a.dart::@class::A2
      exported[(0, 0)] package:test/a.dart::@class::A3
      exported[(0, 0)] package:test/b.dart::@class::B
    exportNamespace
      A2: package:test/a.dart::@class::A2
      A3: package:test/a.dart::@class::A3
      B: package:test/b.dart::@class::B
''',
    );
  }

  test_dependency_export_class_reExport_chain_thisCycle() async {
    var a = newFile('$testPackageLibPath/a.dart', r'''
import 'test.dart';
class A1 {}
class A2 {}
class A3 {}
''');

    newFile('$testPackageLibPath/b.dart', r'''
export 'a.dart';
class B {}
''');

    newFile('$testPackageLibPath/test.dart', r'''
export 'b.dart';
''');

    await _runChangeScenario(
      operation: _FineOperationGetTestLibrary(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A1: #M0
        interface: #M1
      A2: #M2
        interface: #M3
      A3: #M4
        interface: #M5
  package:test/b.dart
    declaredClasses
      B: #M6
        interface: #M7
    reExportMap
      A1: #M0
      A2: #M2
      A3: #M4
    exportedLibraryUris: package:test/a.dart
  package:test/test.dart
    reExportMap
      A1: #M0
      A2: #M2
      A3: #M4
      B: #M6
    exportedLibraryUris: package:test/b.dart
  requirements
[status] idle
[future] getLibraryByUri T1
  library
''',
      updateFiles: () {
        modifyFile2(a, r'''
import 'test.dart';
abstract class A2 {}
class A3 {}
''');
        return [a];
      },
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A2: #M8
        interface: #M9
      A3: #M4
        interface: #M5
  package:test/b.dart
    declaredClasses
      B: #M6
        interface: #M7
    reExportMap
      A2: #M8
      A3: #M4
    exportedLibraryUris: package:test/a.dart
  package:test/test.dart
    reExportMap
      A2: #M8
      A3: #M4
      B: #M6
    exportedLibraryUris: package:test/b.dart
  requirements
[status] idle
[future] getLibraryByUri T2
  library
''',
    );
  }

  test_dependency_export_class_reExport_combinatorShow() async {
    var a = newFile('$testPackageLibPath/a.dart', r'''
class A {}
''');

    newFile('$testPackageLibPath/b.dart', r'''
export 'a.dart' show A;
class B {}
''');

    newFile('$testPackageLibPath/test.dart', r'''
export 'b.dart';
''');

    configuration.elementTextConfiguration.withExportScope = true;
    await _runChangeScenario(
      operation: _FineOperationGetTestLibrary(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        interface: #M1
  requirements
[operation] linkLibraryCycle
  package:test/b.dart
    declaredClasses
      B: #M2
        interface: #M3
    reExportMap
      A: #M0
    exportedLibraryUris: package:test/a.dart
  requirements
    exportRequirements
      package:test/b.dart
        declaredTopNames: B
        exports
          package:test/a.dart
            combinators
              show A
            A: #M0
[operation] linkLibraryCycle
  package:test/test.dart
    reExportMap
      A: #M0
      B: #M2
    exportedLibraryUris: package:test/b.dart
  requirements
    exportRequirements
      package:test/test.dart
        exports
          package:test/b.dart
            A: #M0
            B: #M2
[status] idle
[future] getLibraryByUri T1
  library
    exportedReferences
      exported[(0, 0)] package:test/a.dart::@class::A
      exported[(0, 0)] package:test/b.dart::@class::B
    exportNamespace
      A: package:test/a.dart::@class::A
      B: package:test/b.dart::@class::B
''',
      updateFiles: () {
        modifyFile2(a, r'''
class A {}
class A2 {}
''');
        return [a];
      },
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        interface: #M1
      A2: #M4
        interface: #M5
  requirements
[operation] reuseLinkedBundle
  package:test/b.dart
[operation] reuseLinkedBundle
  package:test/test.dart
[status] idle
[future] getLibraryByUri T2
  library
    exportedReferences
      exported[(0, 0)] package:test/a.dart::@class::A
      exported[(0, 0)] package:test/b.dart::@class::B
    exportNamespace
      A: package:test/a.dart::@class::A
      B: package:test/b.dart::@class::B
''',
    );
  }

  test_dependency_export_enum() async {
    var a = newFile('$testPackageLibPath/a.dart', r'''
enum E {v}
enum _E {v}
''');

    newFile('$testPackageLibPath/test.dart', r'''
export 'a.dart';
''');

    configuration.elementTextConfiguration.withExportScope = true;
    await _runChangeScenario(
      operation: _FineOperationGetTestLibrary(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredEnums
      E: #M0
        declaredFields
          v: #M1
          values: #M2
        declaredGetters
          v: #M3
          values: #M4
        interface: #M5
          map
            index: #M6
          implemented
            index: #M6
          superImplemented
            [0]
              index: #M6
          inherited
            index: #M6
      _E: #M7
        declaredFields
          v: #M8
          values: #M9
        declaredGetters
          v: #M10
          values: #M11
        interface: #M12
          map
            index: #M6
          implemented
            index: #M6
          superImplemented
            [0]
              index: #M6
          inherited
            index: #M6
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    reExportMap
      E: #M0
    exportedLibraryUris: package:test/a.dart
  requirements
    exportRequirements
      package:test/test.dart
        exports
          package:test/a.dart
            E: #M0
[status] idle
[future] getLibraryByUri T1
  library
    exportedReferences
      exported[(0, 0)] package:test/a.dart::@enum::E
    exportNamespace
      E: package:test/a.dart::@enum::E
''',
      updateFiles: () {
        modifyFile2(a, r'''
enum E {v}
enum _E2 {v}
''');
        return [a];
      },
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredEnums
      E: #M0
        declaredFields
          v: #M1
          values: #M2
        declaredGetters
          v: #M3
          values: #M4
        interface: #M5
          map
            index: #M6
          implemented
            index: #M6
          superImplemented
            [0]
              index: #M6
          inherited
            index: #M6
      _E2: #M13
        declaredFields
          v: #M14
          values: #M15
        declaredGetters
          v: #M16
          values: #M17
        interface: #M18
          map
            index: #M6
          implemented
            index: #M6
          superImplemented
            [0]
              index: #M6
          inherited
            index: #M6
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[status] idle
[future] getLibraryByUri T2
  library
    exportedReferences
      exported[(0, 0)] package:test/a.dart::@enum::E
    exportNamespace
      E: package:test/a.dart::@enum::E
''',
    );
  }

  test_dependency_export_extension() async {
    var a = newFile('$testPackageLibPath/a.dart', r'''
extension E on int {}
extension _E on int {}
''');

    newFile('$testPackageLibPath/test.dart', r'''
export 'a.dart';
''');

    configuration.elementTextConfiguration.withExportScope = true;
    await _runChangeScenario(
      operation: _FineOperationGetTestLibrary(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensions
      E: #M0
      _E: #M1
    exportedExtensions: #M0
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    reExportMap
      E: #M0
    exportedExtensions: #M0
    exportedLibraryUris: package:test/a.dart
  requirements
    exportRequirements
      package:test/test.dart
        exports
          package:test/a.dart
            E: #M0
[status] idle
[future] getLibraryByUri T1
  library
    exportedReferences
      exported[(0, 0)] package:test/a.dart::@extension::E
    exportNamespace
      E: package:test/a.dart::@extension::E
''',
      updateFiles: () {
        modifyFile2(a, r'''
extension E on int {}
extension _E2 on int {}
''');
        return [a];
      },
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensions
      E: #M0
      _E2: #M2
    exportedExtensions: #M0
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[status] idle
[future] getLibraryByUri T2
  library
    exportedReferences
      exported[(0, 0)] package:test/a.dart::@extension::E
    exportNamespace
      E: package:test/a.dart::@extension::E
''',
    );
  }

  test_dependency_export_extension_getter_add() async {
    var a = newFile('$testPackageLibPath/a.dart', r'''
extension E on int {
  int get foo => 0;
}
''');

    newFile('$testPackageLibPath/test.dart', r'''
export 'a.dart';
''');

    configuration
      ..withElementManifests = true
      ..elementTextConfiguration.withExportScope = true;
    await _runChangeScenario(
      operation: _FineOperationGetTestLibrary(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensions
      E: #M0
        extendedType: int @ dart:core
        declaredFields
          foo: #M1
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
        declaredGetters
          foo: #M2
            flags: isSimplyBounded
            returnType: int @ dart:core
    exportedExtensions: #M0
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    reExportMap
      E: #M0
    exportedExtensions: #M0
    exportedLibraryUris: package:test/a.dart
  requirements
    exportRequirements
      package:test/test.dart
        exports
          package:test/a.dart
            E: #M0
[status] idle
[future] getLibraryByUri T1
  library
    exportedReferences
      exported[(0, 0)] package:test/a.dart::@extension::E
    exportNamespace
      E: package:test/a.dart::@extension::E
''',
      updateFiles: () {
        modifyFile2(a, r'''
extension E on int {
  int get foo => 0;
  int get bar => 0;
}
''');
        return [a];
      },
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensions
      E: #M0
        extendedType: int @ dart:core
        declaredFields
          bar: #M3
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo: #M1
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
        declaredGetters
          bar: #M4
            flags: isSimplyBounded
            returnType: int @ dart:core
          foo: #M2
            flags: isSimplyBounded
            returnType: int @ dart:core
    exportedExtensions: #M0
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[status] idle
[future] getLibraryByUri T2
  library
    exportedReferences
      exported[(0, 0)] package:test/a.dart::@extension::E
    exportNamespace
      E: package:test/a.dart::@extension::E
''',
    );
  }

  test_dependency_export_extension_getter_change() async {
    var a = newFile('$testPackageLibPath/a.dart', r'''
extension E on int {
  int get foo => 0;
  int get bar => 0;
}
''');

    newFile('$testPackageLibPath/test.dart', r'''
export 'a.dart';
''');

    configuration
      ..withElementManifests = true
      ..elementTextConfiguration.withExportScope = true;
    await _runChangeScenario(
      operation: _FineOperationGetTestLibrary(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensions
      E: #M0
        extendedType: int @ dart:core
        declaredFields
          bar: #M1
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo: #M2
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
        declaredGetters
          bar: #M3
            flags: isSimplyBounded
            returnType: int @ dart:core
          foo: #M4
            flags: isSimplyBounded
            returnType: int @ dart:core
    exportedExtensions: #M0
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    reExportMap
      E: #M0
    exportedExtensions: #M0
    exportedLibraryUris: package:test/a.dart
  requirements
    exportRequirements
      package:test/test.dart
        exports
          package:test/a.dart
            E: #M0
[status] idle
[future] getLibraryByUri T1
  library
    exportedReferences
      exported[(0, 0)] package:test/a.dart::@extension::E
    exportNamespace
      E: package:test/a.dart::@extension::E
''',
      updateFiles: () {
        modifyFile2(a, r'''
extension E on int {
  int get foo => 0;
  double get bar => 0;
}
''');
        return [a];
      },
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensions
      E: #M0
        extendedType: int @ dart:core
        declaredFields
          bar: #M5
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: double @ dart:core
          foo: #M2
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
        declaredGetters
          bar: #M6
            flags: isSimplyBounded
            returnType: double @ dart:core
          foo: #M4
            flags: isSimplyBounded
            returnType: int @ dart:core
    exportedExtensions: #M0
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[status] idle
[future] getLibraryByUri T2
  library
    exportedReferences
      exported[(0, 0)] package:test/a.dart::@extension::E
    exportNamespace
      E: package:test/a.dart::@extension::E
''',
    );
  }

  test_dependency_export_extension_getter_remove() async {
    var a = newFile('$testPackageLibPath/a.dart', r'''
extension E on int {
  int get foo => 0;
  int get bar => 0;
}
''');

    newFile('$testPackageLibPath/test.dart', r'''
export 'a.dart';
''');

    configuration
      ..withElementManifests = true
      ..elementTextConfiguration.withExportScope = true;
    await _runChangeScenario(
      operation: _FineOperationGetTestLibrary(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensions
      E: #M0
        extendedType: int @ dart:core
        declaredFields
          bar: #M1
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo: #M2
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
        declaredGetters
          bar: #M3
            flags: isSimplyBounded
            returnType: int @ dart:core
          foo: #M4
            flags: isSimplyBounded
            returnType: int @ dart:core
    exportedExtensions: #M0
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    reExportMap
      E: #M0
    exportedExtensions: #M0
    exportedLibraryUris: package:test/a.dart
  requirements
    exportRequirements
      package:test/test.dart
        exports
          package:test/a.dart
            E: #M0
[status] idle
[future] getLibraryByUri T1
  library
    exportedReferences
      exported[(0, 0)] package:test/a.dart::@extension::E
    exportNamespace
      E: package:test/a.dart::@extension::E
''',
      updateFiles: () {
        modifyFile2(a, r'''
extension E on int {
  int get foo => 0;
}
''');
        return [a];
      },
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensions
      E: #M0
        extendedType: int @ dart:core
        declaredFields
          foo: #M2
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
        declaredGetters
          foo: #M4
            flags: isSimplyBounded
            returnType: int @ dart:core
    exportedExtensions: #M0
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[status] idle
[future] getLibraryByUri T2
  library
    exportedReferences
      exported[(0, 0)] package:test/a.dart::@extension::E
    exportNamespace
      E: package:test/a.dart::@extension::E
''',
    );
  }

  test_dependency_export_extension_it_add() async {
    var a = newFile('$testPackageLibPath/a.dart', r'''
extension E1 on int {}
''');

    newFile('$testPackageLibPath/test.dart', r'''
export 'a.dart';
''');

    configuration
      ..withElementManifests = true
      ..elementTextConfiguration.withExportScope = true;
    await _runChangeScenario(
      operation: _FineOperationGetTestLibrary(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensions
      E1: #M0
        extendedType: int @ dart:core
    exportedExtensions: #M0
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    reExportMap
      E1: #M0
    exportedExtensions: #M0
    exportedLibraryUris: package:test/a.dart
  requirements
    exportRequirements
      package:test/test.dart
        exports
          package:test/a.dart
            E1: #M0
[status] idle
[future] getLibraryByUri T1
  library
    exportedReferences
      exported[(0, 0)] package:test/a.dart::@extension::E1
    exportNamespace
      E1: package:test/a.dart::@extension::E1
''',
      updateFiles: () {
        modifyFile2(a, r'''
extension E1 on int {}
extension E2 on int {}
''');
        return [a];
      },
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensions
      E1: #M0
        extendedType: int @ dart:core
      E2: #M1
        extendedType: int @ dart:core
    exportedExtensions: #M0 #M1
  requirements
[operation] checkLinkedBundleRequirements
  package:test/test.dart
  exportIdMismatch
    fragmentUri: package:test/test.dart
    exportedUri: package:test/a.dart
    name: E2
    expectedId: <null>
    actualId: #M1
[operation] linkLibraryCycle
  package:test/test.dart
    reExportMap
      E1: #M0
      E2: #M1
    exportedExtensions: #M0 #M1
    exportedLibraryUris: package:test/a.dart
  requirements
    exportRequirements
      package:test/test.dart
        exports
          package:test/a.dart
            E1: #M0
            E2: #M1
[status] idle
[future] getLibraryByUri T2
  library
    exportedReferences
      exported[(0, 0)] package:test/a.dart::@extension::E1
      exported[(0, 0)] package:test/a.dart::@extension::E2
    exportNamespace
      E1: package:test/a.dart::@extension::E1
      E2: package:test/a.dart::@extension::E2
''',
    );
  }

  test_dependency_export_extension_it_remove() async {
    var a = newFile('$testPackageLibPath/a.dart', r'''
extension E1 on int {}
extension E2 on int {}
''');

    newFile('$testPackageLibPath/test.dart', r'''
export 'a.dart';
''');

    configuration
      ..withElementManifests = true
      ..elementTextConfiguration.withExportScope = true;
    await _runChangeScenario(
      operation: _FineOperationGetTestLibrary(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensions
      E1: #M0
        extendedType: int @ dart:core
      E2: #M1
        extendedType: int @ dart:core
    exportedExtensions: #M0 #M1
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    reExportMap
      E1: #M0
      E2: #M1
    exportedExtensions: #M0 #M1
    exportedLibraryUris: package:test/a.dart
  requirements
    exportRequirements
      package:test/test.dart
        exports
          package:test/a.dart
            E1: #M0
            E2: #M1
[status] idle
[future] getLibraryByUri T1
  library
    exportedReferences
      exported[(0, 0)] package:test/a.dart::@extension::E1
      exported[(0, 0)] package:test/a.dart::@extension::E2
    exportNamespace
      E1: package:test/a.dart::@extension::E1
      E2: package:test/a.dart::@extension::E2
''',
      updateFiles: () {
        modifyFile2(a, r'''
extension E1 on int {}
''');
        return [a];
      },
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensions
      E1: #M0
        extendedType: int @ dart:core
    exportedExtensions: #M0
  requirements
[operation] checkLinkedBundleRequirements
  package:test/test.dart
  exportCountMismatch
    fragmentUri: package:test/test.dart
    exportedUri: package:test/a.dart
    expected: 2
    actual: 1
[operation] linkLibraryCycle
  package:test/test.dart
    reExportMap
      E1: #M0
    exportedExtensions: #M0
    exportedLibraryUris: package:test/a.dart
  requirements
    exportRequirements
      package:test/test.dart
        exports
          package:test/a.dart
            E1: #M0
[status] idle
[future] getLibraryByUri T2
  library
    exportedReferences
      exported[(0, 0)] package:test/a.dart::@extension::E1
    exportNamespace
      E1: package:test/a.dart::@extension::E1
''',
    );
  }

  test_dependency_export_extension_method_add() async {
    var a = newFile('$testPackageLibPath/a.dart', r'''
extension E on int {
  void foo() {}
}
''');

    newFile('$testPackageLibPath/test.dart', r'''
export 'a.dart';
''');

    configuration
      ..withElementManifests = true
      ..elementTextConfiguration.withExportScope = true;
    await _runChangeScenario(
      operation: _FineOperationGetTestLibrary(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensions
      E: #M0
        extendedType: int @ dart:core
        declaredMethods
          foo: #M1
            flags: isSimplyBounded
            functionType: FunctionType
              returnType: void
    exportedExtensions: #M0
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    reExportMap
      E: #M0
    exportedExtensions: #M0
    exportedLibraryUris: package:test/a.dart
  requirements
    exportRequirements
      package:test/test.dart
        exports
          package:test/a.dart
            E: #M0
[status] idle
[future] getLibraryByUri T1
  library
    exportedReferences
      exported[(0, 0)] package:test/a.dart::@extension::E
    exportNamespace
      E: package:test/a.dart::@extension::E
''',
      updateFiles: () {
        modifyFile2(a, r'''
extension E on int {
  void foo() {}
  void bar() {}
}
''');
        return [a];
      },
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensions
      E: #M0
        extendedType: int @ dart:core
        declaredMethods
          bar: #M2
            flags: isSimplyBounded
            functionType: FunctionType
              returnType: void
          foo: #M1
            flags: isSimplyBounded
            functionType: FunctionType
              returnType: void
    exportedExtensions: #M0
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[status] idle
[future] getLibraryByUri T2
  library
    exportedReferences
      exported[(0, 0)] package:test/a.dart::@extension::E
    exportNamespace
      E: package:test/a.dart::@extension::E
''',
    );
  }

  test_dependency_export_extension_method_change() async {
    var a = newFile('$testPackageLibPath/a.dart', r'''
extension E on int {
  void foo() {}
  void bar() {}
}
''');

    newFile('$testPackageLibPath/test.dart', r'''
export 'a.dart';
''');

    configuration
      ..withElementManifests = true
      ..elementTextConfiguration.withExportScope = true;
    await _runChangeScenario(
      operation: _FineOperationGetTestLibrary(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensions
      E: #M0
        extendedType: int @ dart:core
        declaredMethods
          bar: #M1
            flags: isSimplyBounded
            functionType: FunctionType
              returnType: void
          foo: #M2
            flags: isSimplyBounded
            functionType: FunctionType
              returnType: void
    exportedExtensions: #M0
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    reExportMap
      E: #M0
    exportedExtensions: #M0
    exportedLibraryUris: package:test/a.dart
  requirements
    exportRequirements
      package:test/test.dart
        exports
          package:test/a.dart
            E: #M0
[status] idle
[future] getLibraryByUri T1
  library
    exportedReferences
      exported[(0, 0)] package:test/a.dart::@extension::E
    exportNamespace
      E: package:test/a.dart::@extension::E
''',
      updateFiles: () {
        modifyFile2(a, r'''
extension E on int {
  void foo() {}
  void bar(int _) {}
}
''');
        return [a];
      },
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensions
      E: #M0
        extendedType: int @ dart:core
        declaredMethods
          bar: #M3
            flags: isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
          foo: #M2
            flags: isSimplyBounded
            functionType: FunctionType
              returnType: void
    exportedExtensions: #M0
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[status] idle
[future] getLibraryByUri T2
  library
    exportedReferences
      exported[(0, 0)] package:test/a.dart::@extension::E
    exportNamespace
      E: package:test/a.dart::@extension::E
''',
    );
  }

  test_dependency_export_extension_method_remove() async {
    var a = newFile('$testPackageLibPath/a.dart', r'''
extension E on int {
  void foo() {}
  void bar() {}
}
''');

    newFile('$testPackageLibPath/test.dart', r'''
export 'a.dart';
''');

    configuration
      ..withElementManifests = true
      ..elementTextConfiguration.withExportScope = true;
    await _runChangeScenario(
      operation: _FineOperationGetTestLibrary(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensions
      E: #M0
        extendedType: int @ dart:core
        declaredMethods
          bar: #M1
            flags: isSimplyBounded
            functionType: FunctionType
              returnType: void
          foo: #M2
            flags: isSimplyBounded
            functionType: FunctionType
              returnType: void
    exportedExtensions: #M0
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    reExportMap
      E: #M0
    exportedExtensions: #M0
    exportedLibraryUris: package:test/a.dart
  requirements
    exportRequirements
      package:test/test.dart
        exports
          package:test/a.dart
            E: #M0
[status] idle
[future] getLibraryByUri T1
  library
    exportedReferences
      exported[(0, 0)] package:test/a.dart::@extension::E
    exportNamespace
      E: package:test/a.dart::@extension::E
''',
      updateFiles: () {
        modifyFile2(a, r'''
extension E on int {
  void foo() {}
}
''');
        return [a];
      },
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensions
      E: #M0
        extendedType: int @ dart:core
        declaredMethods
          foo: #M2
            flags: isSimplyBounded
            functionType: FunctionType
              returnType: void
    exportedExtensions: #M0
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[status] idle
[future] getLibraryByUri T2
  library
    exportedReferences
      exported[(0, 0)] package:test/a.dart::@extension::E
    exportNamespace
      E: package:test/a.dart::@extension::E
''',
    );
  }

  test_dependency_export_extension_setter_add() async {
    var a = newFile('$testPackageLibPath/a.dart', r'''
extension E on int {
  set foo(int _) {}
}
''');

    newFile('$testPackageLibPath/test.dart', r'''
export 'a.dart';
''');

    configuration
      ..withElementManifests = true
      ..elementTextConfiguration.withExportScope = true;
    await _runChangeScenario(
      operation: _FineOperationGetTestLibrary(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensions
      E: #M0
        extendedType: int @ dart:core
        declaredFields
          foo: #M1
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
        declaredSetters
          foo=: #M2
            flags: hasImplicitReturnType isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
    exportedExtensions: #M0
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    reExportMap
      E: #M0
    exportedExtensions: #M0
    exportedLibraryUris: package:test/a.dart
  requirements
    exportRequirements
      package:test/test.dart
        exports
          package:test/a.dart
            E: #M0
[status] idle
[future] getLibraryByUri T1
  library
    exportedReferences
      exported[(0, 0)] package:test/a.dart::@extension::E
    exportNamespace
      E: package:test/a.dart::@extension::E
''',
      updateFiles: () {
        modifyFile2(a, r'''
extension E on int {
  set foo(int _) {}
  set bar(int _) {}
}
''');
        return [a];
      },
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensions
      E: #M0
        extendedType: int @ dart:core
        declaredFields
          bar: #M3
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo: #M1
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
        declaredSetters
          bar=: #M4
            flags: hasImplicitReturnType isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
          foo=: #M2
            flags: hasImplicitReturnType isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
    exportedExtensions: #M0
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[status] idle
[future] getLibraryByUri T2
  library
    exportedReferences
      exported[(0, 0)] package:test/a.dart::@extension::E
    exportNamespace
      E: package:test/a.dart::@extension::E
''',
    );
  }

  test_dependency_export_extension_setter_change() async {
    var a = newFile('$testPackageLibPath/a.dart', r'''
extension E on int {
  set foo(int _) {}
  set bar(int _) {}
}
''');

    newFile('$testPackageLibPath/test.dart', r'''
export 'a.dart';
''');

    configuration
      ..withElementManifests = true
      ..elementTextConfiguration.withExportScope = true;
    await _runChangeScenario(
      operation: _FineOperationGetTestLibrary(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensions
      E: #M0
        extendedType: int @ dart:core
        declaredFields
          bar: #M1
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo: #M2
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
        declaredSetters
          bar=: #M3
            flags: hasImplicitReturnType isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
          foo=: #M4
            flags: hasImplicitReturnType isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
    exportedExtensions: #M0
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    reExportMap
      E: #M0
    exportedExtensions: #M0
    exportedLibraryUris: package:test/a.dart
  requirements
    exportRequirements
      package:test/test.dart
        exports
          package:test/a.dart
            E: #M0
[status] idle
[future] getLibraryByUri T1
  library
    exportedReferences
      exported[(0, 0)] package:test/a.dart::@extension::E
    exportNamespace
      E: package:test/a.dart::@extension::E
''',
      updateFiles: () {
        modifyFile2(a, r'''
extension E on int {
  set foo(int _) {}
  set bar(double _) {}
}
''');
        return [a];
      },
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensions
      E: #M0
        extendedType: int @ dart:core
        declaredFields
          bar: #M5
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: double @ dart:core
          foo: #M2
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
        declaredSetters
          bar=: #M6
            flags: hasImplicitReturnType isSimplyBounded
            functionType: FunctionType
              positional
                required double @ dart:core
              returnType: void
          foo=: #M4
            flags: hasImplicitReturnType isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
    exportedExtensions: #M0
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[status] idle
[future] getLibraryByUri T2
  library
    exportedReferences
      exported[(0, 0)] package:test/a.dart::@extension::E
    exportNamespace
      E: package:test/a.dart::@extension::E
''',
    );
  }

  test_dependency_export_extension_setter_remove() async {
    var a = newFile('$testPackageLibPath/a.dart', r'''
extension E on int {
  set foo(int _) {}
  set bar(int _) {}
}
''');

    newFile('$testPackageLibPath/test.dart', r'''
export 'a.dart';
''');

    configuration
      ..withElementManifests = true
      ..elementTextConfiguration.withExportScope = true;
    await _runChangeScenario(
      operation: _FineOperationGetTestLibrary(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensions
      E: #M0
        extendedType: int @ dart:core
        declaredFields
          bar: #M1
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo: #M2
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
        declaredSetters
          bar=: #M3
            flags: hasImplicitReturnType isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
          foo=: #M4
            flags: hasImplicitReturnType isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
    exportedExtensions: #M0
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    reExportMap
      E: #M0
    exportedExtensions: #M0
    exportedLibraryUris: package:test/a.dart
  requirements
    exportRequirements
      package:test/test.dart
        exports
          package:test/a.dart
            E: #M0
[status] idle
[future] getLibraryByUri T1
  library
    exportedReferences
      exported[(0, 0)] package:test/a.dart::@extension::E
    exportNamespace
      E: package:test/a.dart::@extension::E
''',
      updateFiles: () {
        modifyFile2(a, r'''
extension E on int {
  set foo(int _) {}
}
''');
        return [a];
      },
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensions
      E: #M0
        extendedType: int @ dart:core
        declaredFields
          foo: #M2
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
        declaredSetters
          foo=: #M4
            flags: hasImplicitReturnType isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
    exportedExtensions: #M0
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[status] idle
[future] getLibraryByUri T2
  library
    exportedReferences
      exported[(0, 0)] package:test/a.dart::@extension::E
    exportNamespace
      E: package:test/a.dart::@extension::E
''',
    );
  }

  test_dependency_export_extensionType() async {
    var a = newFile('$testPackageLibPath/a.dart', r'''
extension type E(int it) {}
extension type _E(int it) {}
''');

    newFile('$testPackageLibPath/test.dart', r'''
export 'a.dart';
''');

    configuration.elementTextConfiguration.withExportScope = true;
    await _runChangeScenario(
      operation: _FineOperationGetTestLibrary(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensionTypes
      E: #M0
        declaredFields
          it: #M1
        declaredGetters
          it: #M2
        interface: #M3
          map
            it: #M2
          implemented
            it: #M2
      _E: #M4
        declaredFields
          it: #M5
        declaredGetters
          it: #M6
        interface: #M7
          map
            it: #M6
          implemented
            it: #M6
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    reExportMap
      E: #M0
    exportedLibraryUris: package:test/a.dart
  requirements
    exportRequirements
      package:test/test.dart
        exports
          package:test/a.dart
            E: #M0
[status] idle
[future] getLibraryByUri T1
  library
    exportedReferences
      exported[(0, 0)] package:test/a.dart::@extensionType::E
    exportNamespace
      E: package:test/a.dart::@extensionType::E
''',
      updateFiles: () {
        modifyFile2(a, r'''
extension type E(int it) {}
extension type _E2(int it) {}
''');
        return [a];
      },
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensionTypes
      E: #M0
        declaredFields
          it: #M1
        declaredGetters
          it: #M2
        interface: #M3
          map
            it: #M2
          implemented
            it: #M2
      _E2: #M8
        declaredFields
          it: #M9
        declaredGetters
          it: #M10
        interface: #M11
          map
            it: #M10
          implemented
            it: #M10
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[status] idle
[future] getLibraryByUri T2
  library
    exportedReferences
      exported[(0, 0)] package:test/a.dart::@extensionType::E
    exportNamespace
      E: package:test/a.dart::@extensionType::E
''',
    );
  }

  test_dependency_export_mixin() async {
    var a = newFile('$testPackageLibPath/a.dart', r'''
mixin M {}
mixin _M {}
''');

    newFile('$testPackageLibPath/test.dart', r'''
export 'a.dart';
''');

    configuration.elementTextConfiguration.withExportScope = true;
    await _runChangeScenario(
      operation: _FineOperationGetTestLibrary(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredMixins
      M: #M0
        interface: #M1
      _M: #M2
        interface: #M3
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    reExportMap
      M: #M0
    exportedLibraryUris: package:test/a.dart
  requirements
    exportRequirements
      package:test/test.dart
        exports
          package:test/a.dart
            M: #M0
[status] idle
[future] getLibraryByUri T1
  library
    exportedReferences
      exported[(0, 0)] package:test/a.dart::@mixin::M
    exportNamespace
      M: package:test/a.dart::@mixin::M
''',
      updateFiles: () {
        modifyFile2(a, r'''
mixin M {}
mixin _M2 {}
''');
        return [a];
      },
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredMixins
      M: #M0
        interface: #M1
      _M2: #M4
        interface: #M5
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[status] idle
[future] getLibraryByUri T2
  library
    exportedReferences
      exported[(0, 0)] package:test/a.dart::@mixin::M
    exportNamespace
      M: package:test/a.dart::@mixin::M
''',
    );
  }

  test_dependency_export_noLibrary() async {
    var a = newFile('$testPackageLibPath/a.dart', r'''
final a = 0;
''');

    newFile('$testPackageLibPath/test.dart', r'''
export 'a.dart';
export ':';
''');

    configuration.elementTextConfiguration.withExportScope = true;
    await _runChangeScenario(
      operation: _FineOperationGetTestLibrary(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredGetters
      a: #M0
    declaredVariables
      a: #M1
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    reExportMap
      a: #M0
    exportedLibraryUris: package:test/a.dart
  requirements
    exportRequirements
      package:test/test.dart
        exports
          package:test/a.dart
            a: #M0
[status] idle
[future] getLibraryByUri T1
  library
    exportedReferences
      exported[(0, 0)] package:test/a.dart::@getter::a
    exportNamespace
      a: package:test/a.dart::@getter::a
''',
      updateFiles: () {
        modifyFile2(a, r'''
final a = 1;
''');
        return [a];
      },
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredGetters
      a: #M0
    declaredVariables
      a: #M1
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[status] idle
[future] getLibraryByUri T2
  library
    exportedReferences
      exported[(0, 0)] package:test/a.dart::@getter::a
    exportNamespace
      a: package:test/a.dart::@getter::a
''',
    );
  }

  test_dependency_export_topLevelVariable_add() async {
    var a = newFile('$testPackageLibPath/a.dart', r'''
final a = 0;
''');

    newFile('$testPackageLibPath/test.dart', r'''
export 'a.dart';
''');

    configuration.elementTextConfiguration.withExportScope = true;
    await _runChangeScenario(
      operation: _FineOperationGetTestLibrary(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredGetters
      a: #M0
    declaredVariables
      a: #M1
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    reExportMap
      a: #M0
    exportedLibraryUris: package:test/a.dart
  requirements
    exportRequirements
      package:test/test.dart
        exports
          package:test/a.dart
            a: #M0
[status] idle
[future] getLibraryByUri T1
  library
    exportedReferences
      exported[(0, 0)] package:test/a.dart::@getter::a
    exportNamespace
      a: package:test/a.dart::@getter::a
''',
      updateFiles: () {
        modifyFile2(a, r'''
final a = 0;
final b = 0;
''');
        return [a];
      },
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredGetters
      a: #M0
      b: #M2
    declaredVariables
      a: #M1
      b: #M3
  requirements
[operation] checkLinkedBundleRequirements
  package:test/test.dart
  exportIdMismatch
    fragmentUri: package:test/test.dart
    exportedUri: package:test/a.dart
    name: b
    expectedId: <null>
    actualId: #M2
[operation] linkLibraryCycle
  package:test/test.dart
    reExportMap
      a: #M0
      b: #M2
    exportedLibraryUris: package:test/a.dart
  requirements
    exportRequirements
      package:test/test.dart
        exports
          package:test/a.dart
            a: #M0
            b: #M2
[status] idle
[future] getLibraryByUri T2
  library
    exportedReferences
      exported[(0, 0)] package:test/a.dart::@getter::a
      exported[(0, 0)] package:test/a.dart::@getter::b
    exportNamespace
      a: package:test/a.dart::@getter::a
      b: package:test/a.dart::@getter::b
''',
    );
  }

  test_dependency_export_topLevelVariable_add_combinators_hide_false() async {
    var a = newFile('$testPackageLibPath/a.dart', r'''
final a = 0;
''');

    newFile('$testPackageLibPath/test.dart', r'''
export 'a.dart' hide b;
''');

    configuration.elementTextConfiguration.withExportScope = true;
    await _runChangeScenario(
      operation: _FineOperationGetTestLibrary(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredGetters
      a: #M0
    declaredVariables
      a: #M1
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    reExportMap
      a: #M0
    exportedLibraryUris: package:test/a.dart
  requirements
    exportRequirements
      package:test/test.dart
        exports
          package:test/a.dart
            combinators
              hide b
            a: #M0
[status] idle
[future] getLibraryByUri T1
  library
    exportedReferences
      exported[(0, 0)] package:test/a.dart::@getter::a
    exportNamespace
      a: package:test/a.dart::@getter::a
''',
      updateFiles: () {
        modifyFile2(a, r'''
final a = 0;
final b = 0;
''');
        return [a];
      },
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredGetters
      a: #M0
      b: #M2
    declaredVariables
      a: #M1
      b: #M3
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[status] idle
[future] getLibraryByUri T2
  library
    exportedReferences
      exported[(0, 0)] package:test/a.dart::@getter::a
    exportNamespace
      a: package:test/a.dart::@getter::a
''',
    );
  }

  test_dependency_export_topLevelVariable_add_combinators_hide_true() async {
    var a = newFile('$testPackageLibPath/a.dart', r'''
final a = 0;
''');

    newFile('$testPackageLibPath/test.dart', r'''
export 'a.dart' hide c;
''');

    configuration.elementTextConfiguration.withExportScope = true;
    await _runChangeScenario(
      operation: _FineOperationGetTestLibrary(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredGetters
      a: #M0
    declaredVariables
      a: #M1
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    reExportMap
      a: #M0
    exportedLibraryUris: package:test/a.dart
  requirements
    exportRequirements
      package:test/test.dart
        exports
          package:test/a.dart
            combinators
              hide c
            a: #M0
[status] idle
[future] getLibraryByUri T1
  library
    exportedReferences
      exported[(0, 0)] package:test/a.dart::@getter::a
    exportNamespace
      a: package:test/a.dart::@getter::a
''',
      updateFiles: () {
        modifyFile2(a, r'''
final a = 0;
final b = 0;
''');
        return [a];
      },
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredGetters
      a: #M0
      b: #M2
    declaredVariables
      a: #M1
      b: #M3
  requirements
[operation] checkLinkedBundleRequirements
  package:test/test.dart
  exportIdMismatch
    fragmentUri: package:test/test.dart
    exportedUri: package:test/a.dart
    name: b
    expectedId: <null>
    actualId: #M2
[operation] linkLibraryCycle
  package:test/test.dart
    reExportMap
      a: #M0
      b: #M2
    exportedLibraryUris: package:test/a.dart
  requirements
    exportRequirements
      package:test/test.dart
        exports
          package:test/a.dart
            combinators
              hide c
            a: #M0
            b: #M2
[status] idle
[future] getLibraryByUri T2
  library
    exportedReferences
      exported[(0, 0)] package:test/a.dart::@getter::a
      exported[(0, 0)] package:test/a.dart::@getter::b
    exportNamespace
      a: package:test/a.dart::@getter::a
      b: package:test/a.dart::@getter::b
''',
    );
  }

  test_dependency_export_topLevelVariable_add_combinators_show_false() async {
    var a = newFile('$testPackageLibPath/a.dart', r'''
final a = 0;
''');

    newFile('$testPackageLibPath/test.dart', r'''
export 'a.dart' show a;
''');

    configuration.elementTextConfiguration.withExportScope = true;
    await _runChangeScenario(
      operation: _FineOperationGetTestLibrary(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredGetters
      a: #M0
    declaredVariables
      a: #M1
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    reExportMap
      a: #M0
    exportedLibraryUris: package:test/a.dart
  requirements
    exportRequirements
      package:test/test.dart
        exports
          package:test/a.dart
            combinators
              show a
            a: #M0
[status] idle
[future] getLibraryByUri T1
  library
    exportedReferences
      exported[(0, 0)] package:test/a.dart::@getter::a
    exportNamespace
      a: package:test/a.dart::@getter::a
''',
      updateFiles: () {
        modifyFile2(a, r'''
final a = 0;
final b = 0;
''');
        return [a];
      },
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredGetters
      a: #M0
      b: #M2
    declaredVariables
      a: #M1
      b: #M3
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[status] idle
[future] getLibraryByUri T2
  library
    exportedReferences
      exported[(0, 0)] package:test/a.dart::@getter::a
    exportNamespace
      a: package:test/a.dart::@getter::a
''',
    );
  }

  test_dependency_export_topLevelVariable_add_combinators_show_true() async {
    var a = newFile('$testPackageLibPath/a.dart', r'''
final a = 0;
''');

    newFile('$testPackageLibPath/test.dart', r'''
export 'a.dart' show a, b;
''');

    configuration.elementTextConfiguration.withExportScope = true;
    await _runChangeScenario(
      operation: _FineOperationGetTestLibrary(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredGetters
      a: #M0
    declaredVariables
      a: #M1
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    reExportMap
      a: #M0
    exportedLibraryUris: package:test/a.dart
  requirements
    exportRequirements
      package:test/test.dart
        exports
          package:test/a.dart
            combinators
              show a, b
            a: #M0
[status] idle
[future] getLibraryByUri T1
  library
    exportedReferences
      exported[(0, 0)] package:test/a.dart::@getter::a
    exportNamespace
      a: package:test/a.dart::@getter::a
''',
      updateFiles: () {
        modifyFile2(a, r'''
final a = 0;
final b = 0;
''');
        return [a];
      },
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredGetters
      a: #M0
      b: #M2
    declaredVariables
      a: #M1
      b: #M3
  requirements
[operation] checkLinkedBundleRequirements
  package:test/test.dart
  exportIdMismatch
    fragmentUri: package:test/test.dart
    exportedUri: package:test/a.dart
    name: b
    expectedId: <null>
    actualId: #M2
[operation] linkLibraryCycle
  package:test/test.dart
    reExportMap
      a: #M0
      b: #M2
    exportedLibraryUris: package:test/a.dart
  requirements
    exportRequirements
      package:test/test.dart
        exports
          package:test/a.dart
            combinators
              show a, b
            a: #M0
            b: #M2
[status] idle
[future] getLibraryByUri T2
  library
    exportedReferences
      exported[(0, 0)] package:test/a.dart::@getter::a
      exported[(0, 0)] package:test/a.dart::@getter::b
    exportNamespace
      a: package:test/a.dart::@getter::a
      b: package:test/a.dart::@getter::b
''',
    );
  }

  test_dependency_export_topLevelVariable_add_combinators_showHide_true() async {
    var a = newFile('$testPackageLibPath/a.dart', r'''
final a = 0;
''');

    newFile('$testPackageLibPath/test.dart', r'''
export 'a.dart' show a, b hide c;
''');

    configuration.elementTextConfiguration.withExportScope = true;
    await _runChangeScenario(
      operation: _FineOperationGetTestLibrary(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredGetters
      a: #M0
    declaredVariables
      a: #M1
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    reExportMap
      a: #M0
    exportedLibraryUris: package:test/a.dart
  requirements
    exportRequirements
      package:test/test.dart
        exports
          package:test/a.dart
            combinators
              show a, b
              hide c
            a: #M0
[status] idle
[future] getLibraryByUri T1
  library
    exportedReferences
      exported[(0, 0)] package:test/a.dart::@getter::a
    exportNamespace
      a: package:test/a.dart::@getter::a
''',
      updateFiles: () {
        modifyFile2(a, r'''
final a = 0;
final b = 0;
''');
        return [a];
      },
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredGetters
      a: #M0
      b: #M2
    declaredVariables
      a: #M1
      b: #M3
  requirements
[operation] checkLinkedBundleRequirements
  package:test/test.dart
  exportIdMismatch
    fragmentUri: package:test/test.dart
    exportedUri: package:test/a.dart
    name: b
    expectedId: <null>
    actualId: #M2
[operation] linkLibraryCycle
  package:test/test.dart
    reExportMap
      a: #M0
      b: #M2
    exportedLibraryUris: package:test/a.dart
  requirements
    exportRequirements
      package:test/test.dart
        exports
          package:test/a.dart
            combinators
              show a, b
              hide c
            a: #M0
            b: #M2
[status] idle
[future] getLibraryByUri T2
  library
    exportedReferences
      exported[(0, 0)] package:test/a.dart::@getter::a
      exported[(0, 0)] package:test/a.dart::@getter::b
    exportNamespace
      a: package:test/a.dart::@getter::a
      b: package:test/a.dart::@getter::b
''',
    );
  }

  test_dependency_export_topLevelVariable_add_private() async {
    var a = newFile('$testPackageLibPath/a.dart', r'''
final a = 0;
''');

    newFile('$testPackageLibPath/test.dart', r'''
export 'a.dart';
''');

    configuration.elementTextConfiguration.withExportScope = true;
    await _runChangeScenario(
      operation: _FineOperationGetTestLibrary(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredGetters
      a: #M0
    declaredVariables
      a: #M1
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    reExportMap
      a: #M0
    exportedLibraryUris: package:test/a.dart
  requirements
    exportRequirements
      package:test/test.dart
        exports
          package:test/a.dart
            a: #M0
[status] idle
[future] getLibraryByUri T1
  library
    exportedReferences
      exported[(0, 0)] package:test/a.dart::@getter::a
    exportNamespace
      a: package:test/a.dart::@getter::a
''',
      updateFiles: () {
        modifyFile2(a, r'''
final a = 0;
final _b = 0;
''');
        return [a];
      },
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredGetters
      _b: #M2
      a: #M0
    declaredVariables
      _b: #M3
      a: #M1
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[status] idle
[future] getLibraryByUri T2
  library
    exportedReferences
      exported[(0, 0)] package:test/a.dart::@getter::a
    exportNamespace
      a: package:test/a.dart::@getter::a
''',
    );
  }

  test_dependency_export_topLevelVariable_remove() async {
    var a = newFile('$testPackageLibPath/a.dart', r'''
final a = 0;
final b = 0;
''');

    newFile('$testPackageLibPath/test.dart', r'''
export 'a.dart';
''');

    configuration.elementTextConfiguration.withExportScope = true;
    await _runChangeScenario(
      operation: _FineOperationGetTestLibrary(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredGetters
      a: #M0
      b: #M1
    declaredVariables
      a: #M2
      b: #M3
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    reExportMap
      a: #M0
      b: #M1
    exportedLibraryUris: package:test/a.dart
  requirements
    exportRequirements
      package:test/test.dart
        exports
          package:test/a.dart
            a: #M0
            b: #M1
[status] idle
[future] getLibraryByUri T1
  library
    exportedReferences
      exported[(0, 0)] package:test/a.dart::@getter::a
      exported[(0, 0)] package:test/a.dart::@getter::b
    exportNamespace
      a: package:test/a.dart::@getter::a
      b: package:test/a.dart::@getter::b
''',
      updateFiles: () {
        modifyFile2(a, r'''
final a = 0;
''');
        return [a];
      },
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredGetters
      a: #M0
    declaredVariables
      a: #M2
  requirements
[operation] checkLinkedBundleRequirements
  package:test/test.dart
  exportCountMismatch
    fragmentUri: package:test/test.dart
    exportedUri: package:test/a.dart
    expected: 2
    actual: 1
[operation] linkLibraryCycle
  package:test/test.dart
    reExportMap
      a: #M0
    exportedLibraryUris: package:test/a.dart
  requirements
    exportRequirements
      package:test/test.dart
        exports
          package:test/a.dart
            a: #M0
[status] idle
[future] getLibraryByUri T2
  library
    exportedReferences
      exported[(0, 0)] package:test/a.dart::@getter::a
    exportNamespace
      a: package:test/a.dart::@getter::a
''',
    );
  }

  test_dependency_export_topLevelVariable_remove_show_false() async {
    var a = newFile('$testPackageLibPath/a.dart', r'''
final a = 0;
final b = 0;
''');

    newFile('$testPackageLibPath/test.dart', r'''
export 'a.dart' show a;
''');

    configuration.elementTextConfiguration.withExportScope = true;
    await _runChangeScenario(
      operation: _FineOperationGetTestLibrary(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredGetters
      a: #M0
      b: #M1
    declaredVariables
      a: #M2
      b: #M3
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    reExportMap
      a: #M0
    exportedLibraryUris: package:test/a.dart
  requirements
    exportRequirements
      package:test/test.dart
        exports
          package:test/a.dart
            combinators
              show a
            a: #M0
[status] idle
[future] getLibraryByUri T1
  library
    exportedReferences
      exported[(0, 0)] package:test/a.dart::@getter::a
    exportNamespace
      a: package:test/a.dart::@getter::a
''',
      updateFiles: () {
        modifyFile2(a, r'''
final a = 0;
''');
        return [a];
      },
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredGetters
      a: #M0
    declaredVariables
      a: #M2
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[status] idle
[future] getLibraryByUri T2
  library
    exportedReferences
      exported[(0, 0)] package:test/a.dart::@getter::a
    exportNamespace
      a: package:test/a.dart::@getter::a
''',
    );
  }

  test_dependency_export_topLevelVariable_replace() async {
    var a = newFile('$testPackageLibPath/a.dart', r'''
final a = 0;
final b = 0;
''');

    newFile('$testPackageLibPath/test.dart', r'''
export 'a.dart';
''');

    configuration.elementTextConfiguration.withExportScope = true;
    await _runChangeScenario(
      operation: _FineOperationGetTestLibrary(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredGetters
      a: #M0
      b: #M1
    declaredVariables
      a: #M2
      b: #M3
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    reExportMap
      a: #M0
      b: #M1
    exportedLibraryUris: package:test/a.dart
  requirements
    exportRequirements
      package:test/test.dart
        exports
          package:test/a.dart
            a: #M0
            b: #M1
[status] idle
[future] getLibraryByUri T1
  library
    exportedReferences
      exported[(0, 0)] package:test/a.dart::@getter::a
      exported[(0, 0)] package:test/a.dart::@getter::b
    exportNamespace
      a: package:test/a.dart::@getter::a
      b: package:test/a.dart::@getter::b
''',
      updateFiles: () {
        modifyFile2(a, r'''
final a = 0;
final c = 0;
''');
        return [a];
      },
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredGetters
      a: #M0
      c: #M4
    declaredVariables
      a: #M2
      c: #M5
  requirements
[operation] checkLinkedBundleRequirements
  package:test/test.dart
  exportIdMismatch
    fragmentUri: package:test/test.dart
    exportedUri: package:test/a.dart
    name: c
    expectedId: <null>
    actualId: #M4
[operation] linkLibraryCycle
  package:test/test.dart
    reExportMap
      a: #M0
      c: #M4
    exportedLibraryUris: package:test/a.dart
  requirements
    exportRequirements
      package:test/test.dart
        exports
          package:test/a.dart
            a: #M0
            c: #M4
[status] idle
[future] getLibraryByUri T2
  library
    exportedReferences
      exported[(0, 0)] package:test/a.dart::@getter::a
      exported[(0, 0)] package:test/a.dart::@getter::c
    exportNamespace
      a: package:test/a.dart::@getter::a
      c: package:test/a.dart::@getter::c
''',
    );
  }

  test_dependency_export_topLevelVariable_type() async {
    var a = newFile('$testPackageLibPath/a.dart', r'''
final a = 0;
''');

    newFile('$testPackageLibPath/b.dart', r'''
export 'a.dart';
''');

    // Uses exported `a`.
    newFile('$testPackageLibPath/test.dart', r'''
import 'b.dart';
final x = a;
''');

    configuration.elementTextConfiguration.withExportScope = true;
    await _runChangeScenario(
      operation: _FineOperationGetTestLibrary(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredGetters
      a: #M0
    declaredVariables
      a: #M1
  requirements
[operation] linkLibraryCycle
  package:test/b.dart
    reExportMap
      a: #M0
    exportedLibraryUris: package:test/a.dart
  requirements
    exportRequirements
      package:test/b.dart
        exports
          package:test/a.dart
            a: #M0
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      x: #M2
    declaredVariables
      x: #M3
  requirements
    libraries
      package:test/b.dart
        exportedTopLevels
          a: #M0
          a=: <null>
        reExportDeprecatedOnly
          a: false
[status] idle
[future] getLibraryByUri T1
  library
    topLevelVariables
      final hasInitializer x
        type: int
    exportedReferences
      declared <testLibrary>::@getter::x
    exportNamespace
      x: <testLibrary>::@getter::x
''',
      // Change the initializer, now `double`.
      updateFiles: () {
        modifyFile2(a, r'''
final a = 1.2;
''');
        return [a];
      },
      // Linked, `x` has type `double`.
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredGetters
      a: #M4
    declaredVariables
      a: #M5
  requirements
[operation] checkLinkedBundleRequirements
  package:test/b.dart
  exportIdMismatch
    fragmentUri: package:test/b.dart
    exportedUri: package:test/a.dart
    name: a
    expectedId: #M0
    actualId: #M4
[operation] linkLibraryCycle
  package:test/b.dart
    reExportMap
      a: #M4
    exportedLibraryUris: package:test/a.dart
  requirements
    exportRequirements
      package:test/b.dart
        exports
          package:test/a.dart
            a: #M4
[operation] checkLinkedBundleRequirements
  package:test/test.dart
  topLevelIdMismatch
    libraryUri: package:test/b.dart
    name: a
    expectedId: #M0
    actualId: #M4
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      x: #M6
    declaredVariables
      x: #M7
  requirements
    libraries
      package:test/b.dart
        exportedTopLevels
          a: #M4
          a=: <null>
        reExportDeprecatedOnly
          a: false
[status] idle
[future] getLibraryByUri T2
  library
    topLevelVariables
      final hasInitializer x
        type: double
    exportedReferences
      declared <testLibrary>::@getter::x
    exportNamespace
      x: <testLibrary>::@getter::x
''',
    );
  }

  test_dependency_export_typeAlias() async {
    var a = newFile('$testPackageLibPath/a.dart', r'''
typedef A = int;
typedef _A = int;
''');

    newFile('$testPackageLibPath/test.dart', r'''
export 'a.dart';
''');

    configuration.elementTextConfiguration.withExportScope = true;
    await _runChangeScenario(
      operation: _FineOperationGetTestLibrary(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredTypeAliases
      A: #M0
      _A: #M1
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    reExportMap
      A: #M0
    exportedLibraryUris: package:test/a.dart
  requirements
    exportRequirements
      package:test/test.dart
        exports
          package:test/a.dart
            A: #M0
[status] idle
[future] getLibraryByUri T1
  library
    exportedReferences
      exported[(0, 0)] package:test/a.dart::@typeAlias::A
    exportNamespace
      A: package:test/a.dart::@typeAlias::A
''',
      updateFiles: () {
        modifyFile2(a, r'''
typedef A = int;
typedef _A2 = int;
''');
        return [a];
      },
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredTypeAliases
      A: #M0
      _A2: #M2
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[status] idle
[future] getLibraryByUri T2
  library
    exportedReferences
      exported[(0, 0)] package:test/a.dart::@typeAlias::A
    exportNamespace
      A: package:test/a.dart::@typeAlias::A
''',
    );
  }

  test_dependency_exportedExtensions_add_accessibleExtensions() async {
    _ManualRequirements.install((state) {
      state.singleUnit.libraryFragment.accessibleExtensions;
    });

    await _runChangeScenarioTA(
      initialA: r'''
extension E1 on Object {}
''',
      testCode: r'''
import 'a.dart';
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensions
      E1: #M0
    exportedExtensions: #M0
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
    errors
      7 +8 UNUSED_IMPORT
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M1
        exportedExtensions: #M0
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
    errors
      7 +8 UNUSED_IMPORT
''',
      updatedA: r'''
extension E1 on Object {}
extension E2 on Object {}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensions
      E1: #M0
      E2: #M2
    exportedExtensions: #M0 #M2
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  exportedExtensionsMismatch
    libraryUri: package:test/a.dart
    expectedIds: #M0
    actualIds: #M0 #M2
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
    errors
      7 +8 UNUSED_IMPORT
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M1
        exportedExtensions: #M0 #M2
[status] idle
[future] getErrors T2
  ErrorsResult #3
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
    errors
      7 +8 UNUSED_IMPORT
''',
    );
  }

  test_dependency_exportedExtensions_add_accessibleExtensions_private() async {
    _ManualRequirements.install((state) {
      state.singleUnit.libraryFragment.accessibleExtensions;
    });

    await _runChangeScenarioTA(
      initialA: r'''
extension E on Object {}
''',
      testCode: r'''
import 'a.dart';
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensions
      E: #M0
    exportedExtensions: #M0
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
    errors
      7 +8 UNUSED_IMPORT
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M1
        exportedExtensions: #M0
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
    errors
      7 +8 UNUSED_IMPORT
''',
      updatedA: r'''
extension E on Object {}
extension _E on Object {}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensions
      E: #M0
      _E: #M2
    exportedExtensions: #M0
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] getErrorsFromBytes
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[status] idle
[future] getErrors T2
  ErrorsResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
    errors
      7 +8 UNUSED_IMPORT
''',
    );
  }

  test_dependency_exportedExtensions_remove_accessibleExtensions() async {
    _ManualRequirements.install((state) {
      state.singleUnit.libraryFragment.accessibleExtensions;
    });

    await _runChangeScenarioTA(
      initialA: r'''
extension E1 on Object {}
extension E2 on Object {}
''',
      testCode: r'''
import 'a.dart';
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensions
      E1: #M0
      E2: #M1
    exportedExtensions: #M0 #M1
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
    errors
      7 +8 UNUSED_IMPORT
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M2
        exportedExtensions: #M0 #M1
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
    errors
      7 +8 UNUSED_IMPORT
''',
      updatedA: r'''
extension E1 on Object {}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensions
      E1: #M0
    exportedExtensions: #M0
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  exportedExtensionsMismatch
    libraryUri: package:test/a.dart
    expectedIds: #M0 #M1
    actualIds: #M0
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
    errors
      7 +8 UNUSED_IMPORT
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M2
        exportedExtensions: #M0
[status] idle
[future] getErrors T2
  ErrorsResult #3
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
    errors
      7 +8 UNUSED_IMPORT
''',
    );
  }

  test_dependency_extension_instanceGetter_change_notUsed() async {
    await _runChangeScenarioTA(
      initialA: r'''
extension E on Object {
  int get foo => 0;
  set foo(int _) {}
  int get bar => 0;
}
''',
      testCode: r'''
import 'a.dart';
void f() {
  0.foo;
}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensions
      E: #M0
        declaredFields
          bar: #M1
          foo: #M2
        declaredGetters
          bar: #M3
          foo: #M4
        declaredSetters
          foo=: #M5
    exportedExtensions: #M0
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M6
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M7
        instances
          E
            requestedDeclaredFields
              foo: #M2
            requestedDeclaredGetters
              foo: #M4
            requestedDeclaredSetters
              foo=: #M5
            requestedDeclaredMethods
              foo: <null>
        exportedExtensions: #M0
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updatedA: r'''
extension E on Object {
  int get foo => 0;
  set foo(int _) {}
  double get bar => 0;
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensions
      E: #M0
        declaredFields
          bar: #M8
          foo: #M2
        declaredGetters
          bar: #M9
          foo: #M4
        declaredSetters
          foo=: #M5
    exportedExtensions: #M0
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] getErrorsFromBytes
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[status] idle
[future] getErrors T2
  ErrorsResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
    );
  }

  test_dependency_extension_instanceGetter_change_usedGetter() async {
    await _runChangeScenarioTA(
      initialA: r'''
extension E on Object {
  int get foo => 0;
  set foo(int _) {}
}
''',
      testCode: r'''
import 'a.dart';
void f() {
  0.foo;
}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensions
      E: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        declaredSetters
          foo=: #M3
    exportedExtensions: #M0
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M4
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M5
        instances
          E
            requestedDeclaredFields
              foo: #M1
            requestedDeclaredGetters
              foo: #M2
            requestedDeclaredSetters
              foo=: #M3
            requestedDeclaredMethods
              foo: <null>
        exportedExtensions: #M0
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updatedA: r'''
extension E on Object {
  double get foo => 0;
  set foo(int _) {}
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensions
      E: #M0
        declaredFields
          foo: #M6
        declaredGetters
          foo: #M7
        declaredSetters
          foo=: #M3
    exportedExtensions: #M0
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  instanceFieldIdMismatch
    libraryUri: package:test/a.dart
    interfaceName: E
    fieldName: foo
    expectedId: #M1
    actualId: #M6
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M5
        instances
          E
            requestedDeclaredFields
              foo: #M6
            requestedDeclaredGetters
              foo: #M7
            requestedDeclaredSetters
              foo=: #M3
            requestedDeclaredMethods
              foo: <null>
        exportedExtensions: #M0
[status] idle
[future] getErrors T2
  ErrorsResult #3
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
    );
  }

  test_dependency_extension_instanceGetter_change_usedGetter_private() async {
    await _runChangeScenarioTA(
      initialA: r'''
extension A on Object {
  int get _foo => 0;
}
''',
      testCode: r'''
import 'a.dart';

extension B on Object {
  int get _foo => 0;
}

void f() {
  0._foo;
}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensions
      A: #M0
        declaredFields
          _foo: #M1
        declaredGetters
          _foo: #M2
    exportedExtensions: #M0
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredExtensions
      B: #M3
        declaredFields
          _foo: #M4
        declaredGetters
          _foo: #M5
    declaredFunctions
      f: #M6
    exportedExtensions: #M3
  requirements
    libraries
      package:test/a.dart
        exportedTopLevels
          Object: <null>
          Object=: <null>
          int: <null>
          int=: <null>
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
    errors
      7 +8 UNUSED_IMPORT
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M7
        exportedTopLevels
          Object: <null>
          Object=: <null>
          int: <null>
          int=: <null>
        exportedExtensions: #M0
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
    errors
      7 +8 UNUSED_IMPORT
''',
      updatedA: r'''
extension A on Object {
  double get _foo => 0;
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensions
      A: #M0
        declaredFields
          _foo: #M8
        declaredGetters
          _foo: #M9
    exportedExtensions: #M0
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] getErrorsFromBytes
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[status] idle
[future] getErrors T2
  ErrorsResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
    errors
      7 +8 UNUSED_IMPORT
''',
    );
  }

  test_dependency_extension_instanceMethod_change_notUsedMemberName() async {
    await _runChangeScenarioTA(
      initialA: r'''
extension E1 on Object {
  int foo() {}
}
extension E2 on Object {
  int bar() {}
}
''',
      testCode: r'''
import 'a.dart';
void f() {
  0.foo();
}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensions
      E1: #M0
        declaredMethods
          foo: #M1
      E2: #M2
        declaredMethods
          bar: #M3
    exportedExtensions: #M0 #M2
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M4
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M5
        instances
          E1
            requestedDeclaredFields
              foo: <null>
            requestedDeclaredMethods
              foo: #M1
          E2
            requestedDeclaredFields
              foo: <null>
            requestedDeclaredMethods
              foo: <null>
        exportedExtensions: #M0 #M2
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updatedA: r'''
extension E1 on Object {
  int foo() {}
}
extension E2 on Object {
  double bar() {}
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensions
      E1: #M0
        declaredMethods
          foo: #M1
      E2: #M2
        declaredMethods
          bar: #M6
    exportedExtensions: #M0 #M2
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] getErrorsFromBytes
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[status] idle
[future] getErrors T2
  ErrorsResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
    );
  }

  test_dependency_extension_instanceMethod_change_usedMemberName() async {
    await _runChangeScenarioTA(
      initialA: r'''
extension E1 on Object {
  int foo() {}
}
extension E2 on Object {
  int bar() {}
}
''',
      testCode: r'''
import 'a.dart';
void f() {
  0.foo();
}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensions
      E1: #M0
        declaredMethods
          foo: #M1
      E2: #M2
        declaredMethods
          bar: #M3
    exportedExtensions: #M0 #M2
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M4
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M5
        instances
          E1
            requestedDeclaredFields
              foo: <null>
            requestedDeclaredMethods
              foo: #M1
          E2
            requestedDeclaredFields
              foo: <null>
            requestedDeclaredMethods
              foo: <null>
        exportedExtensions: #M0 #M2
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updatedA: r'''
extension E1 on Object {
  double foo() {}
}
extension E2 on Object {
  int bar() {}
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensions
      E1: #M0
        declaredMethods
          foo: #M6
      E2: #M2
        declaredMethods
          bar: #M3
    exportedExtensions: #M0 #M2
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  instanceMethodIdMismatch
    libraryUri: package:test/a.dart
    interfaceName: E1
    methodName: foo
    expectedId: #M1
    actualId: #M6
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M5
        instances
          E1
            requestedDeclaredFields
              foo: <null>
            requestedDeclaredMethods
              foo: #M6
          E2
            requestedDeclaredFields
              foo: <null>
            requestedDeclaredMethods
              foo: <null>
        exportedExtensions: #M0 #M2
[status] idle
[future] getErrors T2
  ErrorsResult #3
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
    );
  }

  test_dependency_extension_instanceMethod_change_usedMemberName_multiImport() async {
    await _runChangeScenarioTA(
      initialA: r'''
extension E on Object {
  int foo() {}
}
''',
      testCode: r'''
import 'a.dart';
import 'a.dart' as prefix;
void f() {
  0.foo();
}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensions
      E: #M0
        declaredMethods
          foo: #M1
    exportedExtensions: #M0
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M2
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M3
        instances
          E
            requestedDeclaredFields
              foo: <null>
            requestedDeclaredMethods
              foo: #M1
        exportedExtensions: #M0
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updatedA: r'''
extension E on Object {
  double foo() {}
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensions
      E: #M0
        declaredMethods
          foo: #M4
    exportedExtensions: #M0
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  instanceMethodIdMismatch
    libraryUri: package:test/a.dart
    interfaceName: E
    methodName: foo
    expectedId: #M1
    actualId: #M4
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M3
        instances
          E
            requestedDeclaredFields
              foo: <null>
            requestedDeclaredMethods
              foo: #M4
        exportedExtensions: #M0
[status] idle
[future] getErrors T2
  ErrorsResult #3
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
    );
  }

  test_dependency_extension_instanceSetter_change_usedGetter() async {
    await _runChangeScenarioTA(
      initialA: r'''
extension E on Object {
  int get foo => 0;
  set foo(int _) {}
}
''',
      testCode: r'''
import 'a.dart';
void f() {
  0.foo;
}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensions
      E: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        declaredSetters
          foo=: #M3
    exportedExtensions: #M0
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M4
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M5
        instances
          E
            requestedDeclaredFields
              foo: #M1
            requestedDeclaredGetters
              foo: #M2
            requestedDeclaredSetters
              foo=: #M3
            requestedDeclaredMethods
              foo: <null>
        exportedExtensions: #M0
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updatedA: r'''
extension E on Object {
  int get foo => 0;
  set foo(double _) {}
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensions
      E: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        declaredSetters
          foo=: #M6
    exportedExtensions: #M0
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  instanceMethodIdMismatch
    libraryUri: package:test/a.dart
    interfaceName: E
    methodName: foo=
    expectedId: #M3
    actualId: #M6
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M5
        instances
          E
            requestedDeclaredFields
              foo: #M1
            requestedDeclaredGetters
              foo: #M2
            requestedDeclaredSetters
              foo=: #M6
            requestedDeclaredMethods
              foo: <null>
        exportedExtensions: #M0
[status] idle
[future] getErrors T2
  ErrorsResult #3
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
    );
  }

  test_dependency_extension_it_add_notUsedMemberName() async {
    await _runChangeScenarioTA(
      initialA: r'''
extension E1 on Object {
  void foo() {}
}
''',
      testCode: r'''
import 'a.dart';
void f() {
  0.foo();
}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensions
      E1: #M0
        declaredMethods
          foo: #M1
    exportedExtensions: #M0
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M2
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M3
        instances
          E1
            requestedDeclaredFields
              foo: <null>
            requestedDeclaredMethods
              foo: #M1
        exportedExtensions: #M0
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updatedA: r'''
extension E1 on Object {
  void foo() {}
}
extension E2 on int {
  void bar() {}
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensions
      E1: #M0
        declaredMethods
          foo: #M1
      E2: #M4
        declaredMethods
          bar: #M5
    exportedExtensions: #M0 #M4
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  exportedExtensionsMismatch
    libraryUri: package:test/a.dart
    expectedIds: #M0
    actualIds: #M0 #M4
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M3
        instances
          E1
            requestedDeclaredFields
              foo: <null>
            requestedDeclaredMethods
              foo: #M1
          E2
            requestedDeclaredFields
              foo: <null>
            requestedDeclaredMethods
              foo: <null>
        exportedExtensions: #M0 #M4
[status] idle
[future] getErrors T2
  ErrorsResult #3
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
    );
  }

  test_dependency_extension_it_add_private() async {
    await _runChangeScenarioTA(
      initialA: r'''
extension E1 on Object {
  void foo() {}
}
''',
      testCode: r'''
import 'a.dart';
void f() {
  0.foo();
}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensions
      E1: #M0
        declaredMethods
          foo: #M1
    exportedExtensions: #M0
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M2
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M3
        instances
          E1
            requestedDeclaredFields
              foo: <null>
            requestedDeclaredMethods
              foo: #M1
        exportedExtensions: #M0
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updatedA: r'''
extension E1 on Object {
  void foo() {}
  void _bar() {}
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensions
      E1: #M0
        declaredMethods
          _bar: #M4
          foo: #M1
    exportedExtensions: #M0
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] getErrorsFromBytes
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[status] idle
[future] getErrors T2
  ErrorsResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
    );
  }

  test_dependency_extension_it_add_usedMemberName() async {
    await _runChangeScenarioTA(
      initialA: r'''
extension E1 on Object {
  void foo() {}
}
''',
      testCode: r'''
import 'a.dart';
void f() {
  0.foo();
}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensions
      E1: #M0
        declaredMethods
          foo: #M1
    exportedExtensions: #M0
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M2
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M3
        instances
          E1
            requestedDeclaredFields
              foo: <null>
            requestedDeclaredMethods
              foo: #M1
        exportedExtensions: #M0
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updatedA: r'''
extension E1 on Object {
  void foo() {}
}
extension E2 on int {
  void foo() {}
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensions
      E1: #M0
        declaredMethods
          foo: #M1
      E2: #M4
        declaredMethods
          foo: #M5
    exportedExtensions: #M0 #M4
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  exportedExtensionsMismatch
    libraryUri: package:test/a.dart
    expectedIds: #M0
    actualIds: #M0 #M4
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M3
        instances
          E1
            requestedDeclaredFields
              foo: <null>
            requestedDeclaredMethods
              foo: #M1
          E2
            requestedDeclaredFields
              foo: <null>
            requestedDeclaredMethods
              foo: #M5
        exportedExtensions: #M0 #M4
[status] idle
[future] getErrors T2
  ErrorsResult #3
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
    );
  }

  test_dependency_extension_it_add_usedMemberName2() async {
    await _runChangeScenarioTA(
      initialA: r'''
extension E on Object {}
''',
      testCode: r'''
import 'a.dart';
void f() {
  0.foo();
}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensions
      E: #M0
    exportedExtensions: #M0
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M1
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
    errors
      32 +3 UNDEFINED_METHOD
      7 +8 UNUSED_IMPORT
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M2
        instances
          E
            requestedDeclaredFields
              foo: <null>
            requestedDeclaredMethods
              foo: <null>
        exportedExtensions: #M0
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
    errors
      32 +3 UNDEFINED_METHOD
      7 +8 UNUSED_IMPORT
''',
      updatedA: r'''
extension E on Object {
  void foo() {}
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensions
      E: #M0
        declaredMethods
          foo: #M3
    exportedExtensions: #M0
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  instanceMethodIdMismatch
    libraryUri: package:test/a.dart
    interfaceName: E
    methodName: foo
    expectedId: <null>
    actualId: #M3
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M2
        instances
          E
            requestedDeclaredFields
              foo: <null>
            requestedDeclaredMethods
              foo: #M3
        exportedExtensions: #M0
[status] idle
[future] getErrors T2
  ErrorsResult #3
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
    );
  }

  test_dependency_extension_it_remove_notUsedMemberName() async {
    await _runChangeScenarioTA(
      initialA: r'''
extension E1 on Object {
  void foo() {}
}
extension E2 on int {
  void bar() {}
}
''',
      testCode: r'''
import 'a.dart';
void f() {
  0.foo();
}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensions
      E1: #M0
        declaredMethods
          foo: #M1
      E2: #M2
        declaredMethods
          bar: #M3
    exportedExtensions: #M0 #M2
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M4
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M5
        instances
          E1
            requestedDeclaredFields
              foo: <null>
            requestedDeclaredMethods
              foo: #M1
          E2
            requestedDeclaredFields
              foo: <null>
            requestedDeclaredMethods
              foo: <null>
        exportedExtensions: #M0 #M2
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updatedA: r'''
extension E1 on Object {
  void foo() {}
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensions
      E1: #M0
        declaredMethods
          foo: #M1
    exportedExtensions: #M0
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  topLevelNotInstance
    libraryUri: package:test/a.dart
    name: E2
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M5
        instances
          E1
            requestedDeclaredFields
              foo: <null>
            requestedDeclaredMethods
              foo: #M1
        exportedExtensions: #M0
[status] idle
[future] getErrors T2
  ErrorsResult #3
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
    );
  }

  test_dependency_extension_it_remove_usedMemberName() async {
    await _runChangeScenarioTA(
      initialA: r'''
extension E1 on Object {
  void foo() {}
}
extension E2 on int {
  void foo() {}
}
''',
      testCode: r'''
import 'a.dart';
void f() {
  0.foo();
}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensions
      E1: #M0
        declaredMethods
          foo: #M1
      E2: #M2
        declaredMethods
          foo: #M3
    exportedExtensions: #M0 #M2
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M4
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M5
        instances
          E1
            requestedDeclaredFields
              foo: <null>
            requestedDeclaredMethods
              foo: #M1
          E2
            requestedDeclaredFields
              foo: <null>
            requestedDeclaredMethods
              foo: #M3
        exportedExtensions: #M0 #M2
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updatedA: r'''
extension E1 on Object {
  void foo() {}
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensions
      E1: #M0
        declaredMethods
          foo: #M1
    exportedExtensions: #M0
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  topLevelNotInstance
    libraryUri: package:test/a.dart
    name: E2
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M5
        instances
          E1
            requestedDeclaredFields
              foo: <null>
            requestedDeclaredMethods
              foo: #M1
        exportedExtensions: #M0
[status] idle
[future] getErrors T2
  ErrorsResult #3
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
    );
  }

  test_dependency_extension_it_remove_usedMemberName_importWithPrefix() async {
    await _runChangeScenarioTA(
      initialA: r'''
extension E1 on Object {
  void foo() {}
}
extension E2 on int {
  void foo() {}
}
''',
      testCode: r'''
import 'a.dart' as prefix;
void f() {
  0.foo();
}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensions
      E1: #M0
        declaredMethods
          foo: #M1
      E2: #M2
        declaredMethods
          foo: #M3
    exportedExtensions: #M0 #M2
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M4
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M5
        instances
          E1
            requestedDeclaredFields
              foo: <null>
            requestedDeclaredMethods
              foo: #M1
          E2
            requestedDeclaredFields
              foo: <null>
            requestedDeclaredMethods
              foo: #M3
        exportedExtensions: #M0 #M2
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updatedA: r'''
extension E1 on Object {
  void foo() {}
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensions
      E1: #M0
        declaredMethods
          foo: #M1
    exportedExtensions: #M0
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  topLevelNotInstance
    libraryUri: package:test/a.dart
    name: E2
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M5
        instances
          E1
            requestedDeclaredFields
              foo: <null>
            requestedDeclaredMethods
              foo: #M1
        exportedExtensions: #M0
[status] idle
[future] getErrors T2
  ErrorsResult #3
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
    );
  }

  test_dependency_extension_operatorIndex_change_usedIndex() async {
    await _runChangeScenarioTA(
      initialA: r'''
extension E1 on Object {
  int operator[](int index) {}
  operator[]=(int index, int value) {}
}
''',
      testCode: r'''
import 'a.dart';
void f() {
  0[0];
}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensions
      E1: #M0
        declaredMethods
          []: #M1
          []=: #M2
    exportedExtensions: #M0
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M3
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M4
        instances
          E1
            requestedDeclaredMethods
              []: #M1
              []=: #M2
        exportedExtensions: #M0
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updatedA: r'''
extension E1 on Object {
  double operator[](int index) {}
  operator[]=(int index, int value) {}
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensions
      E1: #M0
        declaredMethods
          []: #M5
          []=: #M2
    exportedExtensions: #M0
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  instanceMethodIdMismatch
    libraryUri: package:test/a.dart
    interfaceName: E1
    methodName: []
    expectedId: #M1
    actualId: #M5
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M4
        instances
          E1
            requestedDeclaredMethods
              []: #M5
              []=: #M2
        exportedExtensions: #M0
[status] idle
[future] getErrors T2
  ErrorsResult #3
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
    );
  }

  test_dependency_extension_operatorIndex_change_usedIndexEq() async {
    await _runChangeScenarioTA(
      initialA: r'''
extension E1 on Object {
  int operator[](int index) {}
  operator[]=(int index, int value) {}
}
''',
      testCode: r'''
import 'a.dart';
void f() {
  0[0] = 0;
}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensions
      E1: #M0
        declaredMethods
          []: #M1
          []=: #M2
    exportedExtensions: #M0
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M3
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M4
        instances
          E1
            requestedDeclaredMethods
              []: #M1
              []=: #M2
        exportedExtensions: #M0
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updatedA: r'''
extension E1 on Object {
  double operator[](int index) {}
  operator[]=(int index, int value) {}
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensions
      E1: #M0
        declaredMethods
          []: #M5
          []=: #M2
    exportedExtensions: #M0
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  instanceMethodIdMismatch
    libraryUri: package:test/a.dart
    interfaceName: E1
    methodName: []
    expectedId: #M1
    actualId: #M5
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M4
        instances
          E1
            requestedDeclaredMethods
              []: #M5
              []=: #M2
        exportedExtensions: #M0
[status] idle
[future] getErrors T2
  ErrorsResult #3
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
    );
  }

  test_dependency_extension_operatorIndexEq_change_usedIndex() async {
    await _runChangeScenarioTA(
      initialA: r'''
extension E1 on Object {
  int operator[](int index) {}
  operator[]=(int index, int value) {}
}
''',
      testCode: r'''
import 'a.dart';
void f() {
  0[0];
}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensions
      E1: #M0
        declaredMethods
          []: #M1
          []=: #M2
    exportedExtensions: #M0
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M3
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M4
        instances
          E1
            requestedDeclaredMethods
              []: #M1
              []=: #M2
        exportedExtensions: #M0
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updatedA: r'''
extension E1 on Object {
  int operator[](int index) {}
  operator[]=(int index, double value) {}
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensions
      E1: #M0
        declaredMethods
          []: #M1
          []=: #M5
    exportedExtensions: #M0
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  instanceMethodIdMismatch
    libraryUri: package:test/a.dart
    interfaceName: E1
    methodName: []=
    expectedId: #M2
    actualId: #M5
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M4
        instances
          E1
            requestedDeclaredMethods
              []: #M1
              []=: #M5
        exportedExtensions: #M0
[status] idle
[future] getErrors T2
  ErrorsResult #3
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
    );
  }

  test_dependency_extension_operatorIndexEq_change_usedIndexEq() async {
    await _runChangeScenarioTA(
      initialA: r'''
extension E1 on Object {
  int operator[](int index) {}
  operator[]=(int index, int value) {}
}
''',
      testCode: r'''
import 'a.dart';
void f() {
  0[0] = 0;
}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensions
      E1: #M0
        declaredMethods
          []: #M1
          []=: #M2
    exportedExtensions: #M0
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M3
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M4
        instances
          E1
            requestedDeclaredMethods
              []: #M1
              []=: #M2
        exportedExtensions: #M0
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updatedA: r'''
extension E1 on Object {
  int operator[](int index) {}
  operator[]=(int index, double value) {}
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensions
      E1: #M0
        declaredMethods
          []: #M1
          []=: #M5
    exportedExtensions: #M0
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  instanceMethodIdMismatch
    libraryUri: package:test/a.dart
    interfaceName: E1
    methodName: []=
    expectedId: #M2
    actualId: #M5
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M4
        instances
          E1
            requestedDeclaredMethods
              []: #M1
              []=: #M5
        exportedExtensions: #M0
[status] idle
[future] getErrors T2
  ErrorsResult #3
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
    );
  }

  test_dependency_extension_staticGetter_change_invoked() async {
    await _runChangeScenarioTA(
      initialA: r'''
extension A on int {
  static int get foo => 0;
}
''',
      testCode: r'''
import 'a.dart';
void f() {
  A.foo;
}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensions
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
    exportedExtensions: #M0
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M3
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M4
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredFields
              foo: #M1
            requestedDeclaredGetters
              foo: #M2
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updatedA: r'''
extension A on int {
  static double get foo => 0;
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensions
      A: #M0
        declaredFields
          foo: #M5
        declaredGetters
          foo: #M6
    exportedExtensions: #M0
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  instanceFieldIdMismatch
    libraryUri: package:test/a.dart
    interfaceName: A
    fieldName: foo
    expectedId: #M1
    actualId: #M5
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M4
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredFields
              foo: #M5
            requestedDeclaredGetters
              foo: #M6
[status] idle
[future] getErrors T2
  ErrorsResult #3
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
    );
  }

  test_dependency_extension_staticGetter_change_notUsed() async {
    await _runChangeScenarioTA(
      initialA: r'''
extension A on int {
  static int get foo => 0;
  static int get bar => 0;
}
''',
      testCode: r'''
import 'a.dart';
void f() {
  A.foo;
}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensions
      A: #M0
        declaredFields
          bar: #M1
          foo: #M2
        declaredGetters
          bar: #M3
          foo: #M4
    exportedExtensions: #M0
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M5
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M6
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredFields
              foo: #M2
            requestedDeclaredGetters
              foo: #M4
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updatedA: r'''
extension A on int {
  static int get foo => 0;
  static double get bar => 0;
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensions
      A: #M0
        declaredFields
          bar: #M7
          foo: #M2
        declaredGetters
          bar: #M8
          foo: #M4
    exportedExtensions: #M0
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] getErrorsFromBytes
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[status] idle
[future] getErrors T2
  ErrorsResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
    );
  }

  test_dependency_extension_staticMethod_change_invoked() async {
    await _runChangeScenarioTA(
      initialA: r'''
extension A on int {
  static int foo() {}
}
''',
      testCode: r'''
import 'a.dart';
void f() {
  A.foo();
}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensions
      A: #M0
        declaredMethods
          foo: #M1
    exportedExtensions: #M0
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M2
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M3
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredGetters
              foo: <null>
            requestedDeclaredMethods
              foo: #M1
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updatedA: r'''
extension A on int {
  static double foo() {}
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensions
      A: #M0
        declaredMethods
          foo: #M4
    exportedExtensions: #M0
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  instanceMethodIdMismatch
    libraryUri: package:test/a.dart
    interfaceName: A
    methodName: foo
    expectedId: #M1
    actualId: #M4
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M3
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredGetters
              foo: <null>
            requestedDeclaredMethods
              foo: #M4
[status] idle
[future] getErrors T2
  ErrorsResult #3
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
    );
  }

  test_dependency_extension_staticMethod_change_notUsed() async {
    await _runChangeScenarioTA(
      initialA: r'''
extension A on int {
  static int foo() {}
  static int bar() {}
}
''',
      testCode: r'''
import 'a.dart';
void f() {
  A.foo();
}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensions
      A: #M0
        declaredMethods
          bar: #M1
          foo: #M2
    exportedExtensions: #M0
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M3
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M4
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredGetters
              foo: <null>
            requestedDeclaredMethods
              foo: #M2
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updatedA: r'''
extension A on int {
  static int foo() {}
  static double bar() {}
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensions
      A: #M0
        declaredMethods
          bar: #M5
          foo: #M2
    exportedExtensions: #M0
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] getErrorsFromBytes
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[status] idle
[future] getErrors T2
  ErrorsResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
    );
  }

  test_dependency_extension_staticSetter_change_invoked() async {
    await _runChangeScenarioTA(
      initialA: r'''
extension A on int {
  static set foo(int _) {}
}
''',
      testCode: r'''
import 'a.dart';
void f() {
  A.foo = 0;
}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensions
      A: #M0
        declaredFields
          foo: #M1
        declaredSetters
          foo=: #M2
    exportedExtensions: #M0
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M3
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M4
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredFields
              foo: #M1
            requestedDeclaredSetters
              foo=: #M2
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updatedA: r'''
extension A on int {
  static set foo(double _) {}
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensions
      A: #M0
        declaredFields
          foo: #M5
        declaredSetters
          foo=: #M6
    exportedExtensions: #M0
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  instanceFieldIdMismatch
    libraryUri: package:test/a.dart
    interfaceName: A
    fieldName: foo
    expectedId: #M1
    actualId: #M5
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M4
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredFields
              foo: #M5
            requestedDeclaredSetters
              foo=: #M6
[status] idle
[future] getErrors T2
  ErrorsResult #3
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
    );
  }

  test_dependency_extension_staticSetter_change_notUsed() async {
    await _runChangeScenarioTA(
      initialA: r'''
extension A on int {
  static set foo(int _) {}
  static set bar(int _) {}
}
''',
      testCode: r'''
import 'a.dart';
void f() {
  A.foo = 0;
}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensions
      A: #M0
        declaredFields
          bar: #M1
          foo: #M2
        declaredSetters
          bar=: #M3
          foo=: #M4
    exportedExtensions: #M0
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M5
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M6
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredFields
              foo: #M2
            requestedDeclaredSetters
              foo=: #M4
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updatedA: r'''
extension A on int {
  static set foo(int _) {}
  static set bar(double _) {}
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensions
      A: #M0
        declaredFields
          bar: #M7
          foo: #M2
        declaredSetters
          bar=: #M8
          foo=: #M4
    exportedExtensions: #M0
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] getErrorsFromBytes
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[status] idle
[future] getErrors T2
  ErrorsResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
    );
  }

  test_dependency_extensionType_instanceGetter_change_invoked() async {
    await _runChangeScenarioTA(
      initialA: r'''
extension type A(int it) {
  int get foo => 0;
}
''',
      testCode: r'''
import 'a.dart';
void f(A a) {
  a.foo;
}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensionTypes
      A: #M0
        declaredFields
          foo: #M1
          it: #M2
        declaredGetters
          foo: #M3
          it: #M4
        interface: #M5
          map
            foo: #M3
            it: #M4
          implemented
            foo: #M3
            it: #M4
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M6
  requirements
    libraries
      package:test/a.dart
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M7
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredFields
              foo: #M1
        interfaces
          A
            methods
              foo: #M3
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updatedA: r'''
extension type A(int it) {
  double get foo => 0;
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensionTypes
      A: #M0
        declaredFields
          foo: #M8
          it: #M2
        declaredGetters
          foo: #M9
          it: #M4
        interface: #M10
          map
            foo: #M9
            it: #M4
          implemented
            foo: #M9
            it: #M4
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  instanceFieldIdMismatch
    libraryUri: package:test/a.dart
    interfaceName: A
    fieldName: foo
    expectedId: #M1
    actualId: #M8
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M7
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredFields
              foo: #M8
        interfaces
          A
            methods
              foo: #M9
[status] idle
[future] getErrors T2
  ErrorsResult #3
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
    );
  }

  test_dependency_extensionType_instanceGetter_change_notUsed() async {
    await _runChangeScenarioTA(
      initialA: r'''
extension type A(int it) {
  int get foo => 0;
  int get bar => 0;
}
''',
      testCode: r'''
import 'a.dart';
void f(A a) {
  a.foo;
}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensionTypes
      A: #M0
        declaredFields
          bar: #M1
          foo: #M2
          it: #M3
        declaredGetters
          bar: #M4
          foo: #M5
          it: #M6
        interface: #M7
          map
            bar: #M4
            foo: #M5
            it: #M6
          implemented
            bar: #M4
            foo: #M5
            it: #M6
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M8
  requirements
    libraries
      package:test/a.dart
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M9
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredFields
              foo: #M2
        interfaces
          A
            methods
              foo: #M5
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updatedA: r'''
extension type A(int it) {
  int get foo => 0;
  double get bar => 0;
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensionTypes
      A: #M0
        declaredFields
          bar: #M10
          foo: #M2
          it: #M3
        declaredGetters
          bar: #M11
          foo: #M5
          it: #M6
        interface: #M12
          map
            bar: #M11
            foo: #M5
            it: #M6
          implemented
            bar: #M11
            foo: #M5
            it: #M6
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] getErrorsFromBytes
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[status] idle
[future] getErrors T2
  ErrorsResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
    );
  }

  test_dependency_extensionType_instanceMethod_change_invoked() async {
    await _runChangeScenarioTA(
      initialA: r'''
extension type A(int it) {
  int foo() {}
}
''',
      testCode: r'''
import 'a.dart';
void f(A a) {
  a.foo();
}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensionTypes
      A: #M0
        declaredFields
          it: #M1
        declaredGetters
          it: #M2
        declaredMethods
          foo: #M3
        interface: #M4
          map
            foo: #M3
            it: #M2
          implemented
            foo: #M3
            it: #M2
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M5
  requirements
    libraries
      package:test/a.dart
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M6
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        interfaces
          A
            methods
              foo: #M3
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updatedA: r'''
extension type A(int it) {
  double foo() {}
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensionTypes
      A: #M0
        declaredFields
          it: #M1
        declaredGetters
          it: #M2
        declaredMethods
          foo: #M7
        interface: #M8
          map
            foo: #M7
            it: #M2
          implemented
            foo: #M7
            it: #M2
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  instanceMethodIdMismatch
    libraryUri: package:test/a.dart
    interfaceName: A
    methodName: foo
    expectedId: #M3
    actualId: #M7
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M6
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        interfaces
          A
            methods
              foo: #M7
[status] idle
[future] getErrors T2
  ErrorsResult #3
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
    );
  }

  test_dependency_extensionType_instanceMethod_change_notUsed() async {
    await _runChangeScenarioTA(
      initialA: r'''
extension type A(int it) {
  int foo() {}
  int bar() {}
}
''',
      testCode: r'''
import 'a.dart';
void f(A a) {
  a.foo();
}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensionTypes
      A: #M0
        declaredFields
          it: #M1
        declaredGetters
          it: #M2
        declaredMethods
          bar: #M3
          foo: #M4
        interface: #M5
          map
            bar: #M3
            foo: #M4
            it: #M2
          implemented
            bar: #M3
            foo: #M4
            it: #M2
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M6
  requirements
    libraries
      package:test/a.dart
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M7
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        interfaces
          A
            methods
              foo: #M4
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updatedA: r'''
extension type A(int it) {
  int foo() {}
  double bar() {}
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensionTypes
      A: #M0
        declaredFields
          it: #M1
        declaredGetters
          it: #M2
        declaredMethods
          bar: #M8
          foo: #M4
        interface: #M9
          map
            bar: #M8
            foo: #M4
            it: #M2
          implemented
            bar: #M8
            foo: #M4
            it: #M2
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] getErrorsFromBytes
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[status] idle
[future] getErrors T2
  ErrorsResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
    );
  }

  test_dependency_extensionType_instanceSetter_change_invoked() async {
    await _runChangeScenarioTA(
      initialA: r'''
extension type A(int it) {
  set foo(int _) {}
}
''',
      testCode: r'''
import 'a.dart';
void f(A a) {
  a.foo = 0;
}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensionTypes
      A: #M0
        declaredFields
          foo: #M1
          it: #M2
        declaredGetters
          it: #M3
        declaredSetters
          foo=: #M4
        interface: #M5
          map
            foo=: #M4
            it: #M3
          implemented
            foo=: #M4
            it: #M3
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M6
  requirements
    libraries
      package:test/a.dart
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M7
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredFields
              foo: #M1
        interfaces
          A
            methods
              foo=: #M4
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updatedA: r'''
extension type A(int it) {
  set foo(double _) {}
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensionTypes
      A: #M0
        declaredFields
          foo: #M8
          it: #M2
        declaredGetters
          it: #M3
        declaredSetters
          foo=: #M9
        interface: #M10
          map
            foo=: #M9
            it: #M3
          implemented
            foo=: #M9
            it: #M3
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  instanceFieldIdMismatch
    libraryUri: package:test/a.dart
    interfaceName: A
    fieldName: foo
    expectedId: #M1
    actualId: #M8
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M7
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredFields
              foo: #M8
        interfaces
          A
            methods
              foo=: #M9
[status] idle
[future] getErrors T2
  ErrorsResult #3
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
    );
  }

  test_dependency_extensionType_instanceSetter_change_notUsed() async {
    await _runChangeScenarioTA(
      initialA: r'''
extension type A(int it) {
  set foo(int _) {}
  set bar(int _) {}
}
''',
      testCode: r'''
import 'a.dart';
void f(A a) {
  a.foo = 0;
}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensionTypes
      A: #M0
        declaredFields
          bar: #M1
          foo: #M2
          it: #M3
        declaredGetters
          it: #M4
        declaredSetters
          bar=: #M5
          foo=: #M6
        interface: #M7
          map
            bar=: #M5
            foo=: #M6
            it: #M4
          implemented
            bar=: #M5
            foo=: #M6
            it: #M4
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M8
  requirements
    libraries
      package:test/a.dart
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M9
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredFields
              foo: #M2
        interfaces
          A
            methods
              foo=: #M6
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updatedA: r'''
extension type A(int it) {
  set foo(int _) {}
  set bar(double _) {}
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensionTypes
      A: #M0
        declaredFields
          bar: #M10
          foo: #M2
          it: #M3
        declaredGetters
          it: #M4
        declaredSetters
          bar=: #M11
          foo=: #M6
        interface: #M12
          map
            bar=: #M11
            foo=: #M6
            it: #M4
          implemented
            bar=: #M11
            foo=: #M6
            it: #M4
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] getErrorsFromBytes
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[status] idle
[future] getErrors T2
  ErrorsResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
    );
  }

  test_dependency_extensionType_namedConstructor_change_getConstructors() async {
    configuration.includeDefaultConstructors();

    _ManualRequirements.install((state) {
      var A = state.singleUnit.scopeInterfaceElement('A');
      A.constructors;
    });

    await _runChangeScenarioTA(
      initialA: r'''
extension type A(int it) {
  factory A.named(int _) {}
}
''',
      testCode: r'''
import 'a.dart';
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensionTypes
      A: #M0
        declaredFields
          it: #M1
        declaredGetters
          it: #M2
        declaredConstructors
          named: #M3
          new: #M4
        interface: #M5
          map
            it: #M2
          implemented
            it: #M2
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
    errors
      7 +8 UNUSED_IMPORT
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M6
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        interfaces
          A
            allConstructors: #M4 #M3
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
    errors
      7 +8 UNUSED_IMPORT
''',
      updatedA: r'''
extension type A(int it) {
  factory A.named(double _) {}
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensionTypes
      A: #M0
        declaredFields
          it: #M1
        declaredGetters
          it: #M2
        declaredConstructors
          named: #M7
          new: #M4
        interface: #M5
          map
            it: #M2
          implemented
            it: #M2
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  interfaceChildrenIdsMismatch
    libraryUri: package:test/a.dart
    interfaceName: A
    childrenPropertyName: constructors
    expectedIds: #M4 #M3
    actualIds: #M4 #M7
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
    errors
      7 +8 UNUSED_IMPORT
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M6
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        interfaces
          A
            allConstructors: #M4 #M7
[status] idle
[future] getErrors T2
  ErrorsResult #3
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
    errors
      7 +8 UNUSED_IMPORT
''',
    );
  }

  test_dependency_extensionType_namedConstructor_change_invoked() async {
    configuration.includeDefaultConstructors();
    await _runChangeScenarioTA(
      initialA: r'''
extension type A(int it) {
  factory A.named(int _) {}
}
''',
      testCode: r'''
import 'a.dart';
void f() {
  A.named(0);
}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensionTypes
      A: #M0
        declaredFields
          it: #M1
        declaredGetters
          it: #M2
        declaredConstructors
          named: #M3
          new: #M4
        interface: #M5
          map
            it: #M2
          implemented
            it: #M2
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M6
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M7
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        interfaces
          A
            requestedConstructors
              named: #M3
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updatedA: r'''
extension type A(int it) {
  factory A.named(double _) {}
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensionTypes
      A: #M0
        declaredFields
          it: #M1
        declaredGetters
          it: #M2
        declaredConstructors
          named: #M8
          new: #M4
        interface: #M5
          map
            it: #M2
          implemented
            it: #M2
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  interfaceConstructorIdMismatch
    libraryUri: package:test/a.dart
    interfaceName: A
    constructorName: named
    expectedId: #M3
    actualId: #M8
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M7
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        interfaces
          A
            requestedConstructors
              named: #M8
[status] idle
[future] getErrors T2
  ErrorsResult #3
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
    );
  }

  test_dependency_extensionType_namedConstructor_change_notUsed() async {
    configuration.includeDefaultConstructors();
    await _runChangeScenarioTA(
      initialA: r'''
extension type A(int it) {
  factory A.named(int _) {}
}
''',
      testCode: r'''
import 'a.dart';
void f() {
  A(0);
}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensionTypes
      A: #M0
        declaredFields
          it: #M1
        declaredGetters
          it: #M2
        declaredConstructors
          named: #M3
          new: #M4
        interface: #M5
          map
            it: #M2
          implemented
            it: #M2
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M6
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M7
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        interfaces
          A
            requestedConstructors
              new: #M4
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updatedA: r'''
extension type A(int it) {
  factory A.named(double _) {}
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensionTypes
      A: #M0
        declaredFields
          it: #M1
        declaredGetters
          it: #M2
        declaredConstructors
          named: #M8
          new: #M4
        interface: #M5
          map
            it: #M2
          implemented
            it: #M2
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] getErrorsFromBytes
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[status] idle
[future] getErrors T2
  ErrorsResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
    );
  }

  test_dependency_extensionType_staticGetter_change_invoked() async {
    await _runChangeScenarioTA(
      initialA: r'''
extension type A(int it) {
  static int get foo => 0;
}
''',
      testCode: r'''
import 'a.dart';
void f() {
  A.foo;
}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensionTypes
      A: #M0
        declaredFields
          foo: #M1
          it: #M2
        declaredGetters
          foo: #M3
          it: #M4
        interface: #M5
          map
            it: #M4
          implemented
            it: #M4
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M6
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M7
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredFields
              foo: #M1
            requestedDeclaredGetters
              foo: #M3
        interfaces
          A
            requestedConstructors
              foo: <null>
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updatedA: r'''
extension type A(int it) {
  static double get foo => 0;
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensionTypes
      A: #M0
        declaredFields
          foo: #M8
          it: #M2
        declaredGetters
          foo: #M9
          it: #M4
        interface: #M5
          map
            it: #M4
          implemented
            it: #M4
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  instanceFieldIdMismatch
    libraryUri: package:test/a.dart
    interfaceName: A
    fieldName: foo
    expectedId: #M1
    actualId: #M8
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M7
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredFields
              foo: #M8
            requestedDeclaredGetters
              foo: #M9
        interfaces
          A
            requestedConstructors
              foo: <null>
[status] idle
[future] getErrors T2
  ErrorsResult #3
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
    );
  }

  test_dependency_extensionType_staticGetter_change_notUsed() async {
    await _runChangeScenarioTA(
      initialA: r'''
extension type A(int it) {
  static int get foo => 0;
  static int get bar => 0;
}
''',
      testCode: r'''
import 'a.dart';
void f() {
  A.foo;
}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensionTypes
      A: #M0
        declaredFields
          bar: #M1
          foo: #M2
          it: #M3
        declaredGetters
          bar: #M4
          foo: #M5
          it: #M6
        interface: #M7
          map
            it: #M6
          implemented
            it: #M6
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M8
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M9
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredFields
              foo: #M2
            requestedDeclaredGetters
              foo: #M5
        interfaces
          A
            requestedConstructors
              foo: <null>
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updatedA: r'''
extension type A(int it) {
  static int get foo => 0;
  static double get bar => 0;
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensionTypes
      A: #M0
        declaredFields
          bar: #M10
          foo: #M2
          it: #M3
        declaredGetters
          bar: #M11
          foo: #M5
          it: #M6
        interface: #M7
          map
            it: #M6
          implemented
            it: #M6
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] getErrorsFromBytes
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[status] idle
[future] getErrors T2
  ErrorsResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
    );
  }

  test_dependency_extensionType_staticMethod_change_invoked() async {
    await _runChangeScenarioTA(
      initialA: r'''
extension type A(int it) {
  static int foo() {}
}
''',
      testCode: r'''
import 'a.dart';
void f() {
  A.foo();
}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensionTypes
      A: #M0
        declaredFields
          it: #M1
        declaredGetters
          it: #M2
        declaredMethods
          foo: #M3
        interface: #M4
          map
            it: #M2
          implemented
            it: #M2
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M5
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M6
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredGetters
              foo: <null>
            requestedDeclaredMethods
              foo: #M3
        interfaces
          A
            requestedConstructors
              foo: <null>
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updatedA: r'''
extension type A(int it) {
  static double foo() {}
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensionTypes
      A: #M0
        declaredFields
          it: #M1
        declaredGetters
          it: #M2
        declaredMethods
          foo: #M7
        interface: #M4
          map
            it: #M2
          implemented
            it: #M2
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  instanceMethodIdMismatch
    libraryUri: package:test/a.dart
    interfaceName: A
    methodName: foo
    expectedId: #M3
    actualId: #M7
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M6
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredGetters
              foo: <null>
            requestedDeclaredMethods
              foo: #M7
        interfaces
          A
            requestedConstructors
              foo: <null>
[status] idle
[future] getErrors T2
  ErrorsResult #3
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
    );
  }

  test_dependency_extensionType_staticMethod_change_notUsed() async {
    await _runChangeScenarioTA(
      initialA: r'''
extension type A(int it) {
  static int foo() {}
  static int bar() {}
}
''',
      testCode: r'''
import 'a.dart';
void f() {
  A.foo();
}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensionTypes
      A: #M0
        declaredFields
          it: #M1
        declaredGetters
          it: #M2
        declaredMethods
          bar: #M3
          foo: #M4
        interface: #M5
          map
            it: #M2
          implemented
            it: #M2
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M6
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M7
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredGetters
              foo: <null>
            requestedDeclaredMethods
              foo: #M4
        interfaces
          A
            requestedConstructors
              foo: <null>
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updatedA: r'''
extension type A(int it) {
  static int foo() {}
  static double bar() {}
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensionTypes
      A: #M0
        declaredFields
          it: #M1
        declaredGetters
          it: #M2
        declaredMethods
          bar: #M8
          foo: #M4
        interface: #M5
          map
            it: #M2
          implemented
            it: #M2
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] getErrorsFromBytes
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[status] idle
[future] getErrors T2
  ErrorsResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
    );
  }

  test_dependency_extensionType_staticSetter_change_invoked() async {
    await _runChangeScenarioTA(
      initialA: r'''
extension type A(int it) {
  static set foo(int _) {}
}
''',
      testCode: r'''
import 'a.dart';
void f() {
  A.foo = 0;
}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensionTypes
      A: #M0
        declaredFields
          foo: #M1
          it: #M2
        declaredGetters
          it: #M3
        declaredSetters
          foo=: #M4
        interface: #M5
          map
            it: #M3
          implemented
            it: #M3
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M6
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M7
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredFields
              foo: #M1
            requestedDeclaredSetters
              foo=: #M4
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updatedA: r'''
extension type A(int it) {
  static set foo(double _) {}
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensionTypes
      A: #M0
        declaredFields
          foo: #M8
          it: #M2
        declaredGetters
          it: #M3
        declaredSetters
          foo=: #M9
        interface: #M5
          map
            it: #M3
          implemented
            it: #M3
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  instanceFieldIdMismatch
    libraryUri: package:test/a.dart
    interfaceName: A
    fieldName: foo
    expectedId: #M1
    actualId: #M8
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M7
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredFields
              foo: #M8
            requestedDeclaredSetters
              foo=: #M9
[status] idle
[future] getErrors T2
  ErrorsResult #3
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
    );
  }

  test_dependency_extensionType_staticSetter_change_notUsed() async {
    await _runChangeScenarioTA(
      initialA: r'''
extension type A(int it) {
  static set foo(int _) {}
  static set bar(int _) {}
}
''',
      testCode: r'''
import 'a.dart';
void f() {
  A.foo = 0;
}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensionTypes
      A: #M0
        declaredFields
          bar: #M1
          foo: #M2
          it: #M3
        declaredGetters
          it: #M4
        declaredSetters
          bar=: #M5
          foo=: #M6
        interface: #M7
          map
            it: #M4
          implemented
            it: #M4
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M8
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M9
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredFields
              foo: #M2
            requestedDeclaredSetters
              foo=: #M6
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updatedA: r'''
extension type A(int it) {
  static set foo(int _) {}
  static set bar(double _) {}
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensionTypes
      A: #M0
        declaredFields
          bar: #M10
          foo: #M2
          it: #M3
        declaredGetters
          it: #M4
        declaredSetters
          bar=: #M11
          foo=: #M6
        interface: #M7
          map
            it: #M4
          implemented
            it: #M4
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] getErrorsFromBytes
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[status] idle
[future] getErrors T2
  ErrorsResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
    );
  }

  test_dependency_extensionType_unnamedConstructor_change_getConstructors() async {
    configuration.includeDefaultConstructors();

    _ManualRequirements.install((state) {
      var A = state.singleUnit.scopeInterfaceElement('A');
      A.constructors;
    });

    await _runChangeScenarioTA(
      initialA: r'''
extension type A(int it) {
  factory A.named(int _) {}
}
''',
      testCode: r'''
import 'a.dart';
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensionTypes
      A: #M0
        declaredFields
          it: #M1
        declaredGetters
          it: #M2
        declaredConstructors
          named: #M3
          new: #M4
        interface: #M5
          map
            it: #M2
          implemented
            it: #M2
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
    errors
      7 +8 UNUSED_IMPORT
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M6
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        interfaces
          A
            allConstructors: #M4 #M3
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
    errors
      7 +8 UNUSED_IMPORT
''',
      updatedA: r'''
extension type A(double it) {
  factory A.named(int _) {}
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensionTypes
      A: #M7
        declaredFields
          it: #M8
        declaredGetters
          it: #M9
        declaredConstructors
          named: #M10
          new: #M11
        interface: #M12
          map
            it: #M9
          implemented
            it: #M9
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  topLevelIdMismatch
    libraryUri: package:test/a.dart
    name: A
    expectedId: #M0
    actualId: #M7
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
    errors
      7 +8 UNUSED_IMPORT
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M6
        exportedTopLevels
          A: #M7
          A=: <null>
        reExportDeprecatedOnly
          A: false
        interfaces
          A
            allConstructors: #M11 #M10
[status] idle
[future] getErrors T2
  ErrorsResult #3
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
    errors
      7 +8 UNUSED_IMPORT
''',
    );
  }

  test_dependency_extensionType_unnamedConstructor_change_invoked() async {
    configuration.includeDefaultConstructors();
    await _runChangeScenarioTA(
      initialA: r'''
extension type A(int it) {}
''',
      testCode: r'''
import 'a.dart';
void f() {
  A(0);
}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensionTypes
      A: #M0
        declaredFields
          it: #M1
        declaredGetters
          it: #M2
        declaredConstructors
          new: #M3
        interface: #M4
          map
            it: #M2
          implemented
            it: #M2
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M5
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M6
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        interfaces
          A
            requestedConstructors
              new: #M3
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updatedA: r'''
extension type A(double it) {}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensionTypes
      A: #M7
        declaredFields
          it: #M8
        declaredGetters
          it: #M9
        declaredConstructors
          new: #M10
        interface: #M11
          map
            it: #M9
          implemented
            it: #M9
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  topLevelIdMismatch
    libraryUri: package:test/a.dart
    name: A
    expectedId: #M0
    actualId: #M7
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M6
        exportedTopLevels
          A: #M7
          A=: <null>
        reExportDeprecatedOnly
          A: false
        interfaces
          A
            requestedConstructors
              new: #M10
[status] idle
[future] getErrors T2
  ErrorsResult #3
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
    );
  }

  test_dependency_extensionType_unnamedConstructor_change_notUsed() async {
    configuration.includeDefaultConstructors();
    await _runChangeScenarioTA(
      initialA: r'''
extension type A(int it) {
  factory A.named(int _) {}
}
''',
      testCode: r'''
import 'a.dart';
void f() {
  A.named(0);
}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensionTypes
      A: #M0
        declaredFields
          it: #M1
        declaredGetters
          it: #M2
        declaredConstructors
          named: #M3
          new: #M4
        interface: #M5
          map
            it: #M2
          implemented
            it: #M2
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M6
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M7
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        interfaces
          A
            requestedConstructors
              named: #M3
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updatedA: r'''
extension type A(double it) {
  factory A.named(int _) {}
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensionTypes
      A: #M8
        declaredFields
          it: #M9
        declaredGetters
          it: #M10
        declaredConstructors
          named: #M11
          new: #M12
        interface: #M13
          map
            it: #M10
          implemented
            it: #M10
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  topLevelIdMismatch
    libraryUri: package:test/a.dart
    name: A
    expectedId: #M0
    actualId: #M8
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M7
        exportedTopLevels
          A: #M8
          A=: <null>
        reExportDeprecatedOnly
          A: false
        interfaces
          A
            requestedConstructors
              named: #M11
[status] idle
[future] getErrors T2
  ErrorsResult #3
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
    );
  }

  test_dependency_library_exportedDeprecated_class_falseToTrue() async {
    configuration
      ..withStreamResolvedUnitResults = false
      ..withElementManifests = true;

    newFile('$testPackageLibPath/x.dart', r'''
class A {}
''');

    await _runChangeScenarioTA(
      initialA: r'''
library;
export 'x.dart';
''',
      testCode: r'''
import 'a.dart';
void f() {
  A;
}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/x.dart
    declaredClasses
      A: #M0
        supertype: Object @ dart:core
        interface: #M1
  requirements
[operation] linkLibraryCycle
  package:test/a.dart
    reExportMap
      A: #M0
    exportedLibraryUris: package:test/x.dart
  requirements
    exportRequirements
      package:test/a.dart
        exports
          package:test/x.dart
            A: #M0
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M2
        flags: hasEnclosingTypeParameterReference isSimplyBounded isStatic
        functionType: FunctionType
          returnType: void
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M3
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
[status] idle
[future] getErrors T1
  ErrorsResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updatedA: r'''
library;
@deprecated
export 'x.dart';
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    reExportMap
      A: #M0
    reExportDeprecatedOnly: A
    exportedLibraryUris: package:test/x.dart
  requirements
    exportRequirements
      package:test/a.dart
        exports
          package:test/x.dart
            A: #M0
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  reExportDeprecatedOnlyMismatch
    libraryUri: package:test/a.dart
    name: A
    expected: false
    actual: true
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M3
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: true
[status] idle
[future] getErrors T2
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
    errors
      30 +1 DEPRECATED_EXPORT_USE
''',
    );
  }

  test_dependency_library_exportedDeprecated_class_trueToFalse() async {
    configuration
      ..withStreamResolvedUnitResults = false
      ..withElementManifests = true;

    newFile('$testPackageLibPath/x.dart', r'''
class A {}
''');

    await _runChangeScenarioTA(
      initialA: r'''
library;
@deprecated
export 'x.dart';
''',
      testCode: r'''
import 'a.dart';
void f() {
  A;
}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/x.dart
    declaredClasses
      A: #M0
        supertype: Object @ dart:core
        interface: #M1
  requirements
[operation] linkLibraryCycle
  package:test/a.dart
    reExportMap
      A: #M0
    reExportDeprecatedOnly: A
    exportedLibraryUris: package:test/x.dart
  requirements
    exportRequirements
      package:test/a.dart
        exports
          package:test/x.dart
            A: #M0
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M2
        flags: hasEnclosingTypeParameterReference isSimplyBounded isStatic
        functionType: FunctionType
          returnType: void
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M3
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: true
[status] idle
[future] getErrors T1
  ErrorsResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
    errors
      30 +1 DEPRECATED_EXPORT_USE
''',
      updatedA: r'''
library;
@deprecated
export 'x.dart';
export 'x.dart';
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    reExportMap
      A: #M0
    exportedLibraryUris: package:test/x.dart
  requirements
    exportRequirements
      package:test/a.dart
        exports
          package:test/x.dart
            A: #M0
          package:test/x.dart
            A: #M0
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  reExportDeprecatedOnlyMismatch
    libraryUri: package:test/a.dart
    name: A
    expected: true
    actual: false
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M3
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
[status] idle
[future] getErrors T2
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
    );
  }

  test_dependency_library_exportedDeprecated_setter_falseToTrue() async {
    configuration
      ..withStreamResolvedUnitResults = false
      ..withElementManifests = true;

    newFile('$testPackageLibPath/x.dart', r'''
set foo(int _) {}
''');

    await _runChangeScenarioTA(
      initialA: r'''
library;
export 'x.dart';
''',
      testCode: r'''
import 'a.dart';
void f() {
  foo = 0;
}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/x.dart
    declaredSetters
      foo=: #M0
        flags: hasImplicitReturnType isSimplyBounded isStatic
        functionType: FunctionType
          positional
            required int @ dart:core
          returnType: void
    declaredVariables
      foo: #M1
        flags: isStatic isSynthetic shouldUseTypeForInitializerInference
        type: int @ dart:core
  requirements
[operation] linkLibraryCycle
  package:test/a.dart
    reExportMap
      foo=: #M0
    exportedLibraryUris: package:test/x.dart
  requirements
    exportRequirements
      package:test/a.dart
        exports
          package:test/x.dart
            foo=: #M0
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M2
        flags: hasEnclosingTypeParameterReference isSimplyBounded isStatic
        functionType: FunctionType
          returnType: void
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M3
        exportedTopLevels
          foo: <null>
          foo=: #M0
        reExportDeprecatedOnly
          foo=: false
      package:test/x.dart
        libraryMetadataId: #M4
[status] idle
[future] getErrors T1
  ErrorsResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updatedA: r'''
library;
@deprecated
export 'x.dart';
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    reExportMap
      foo=: #M0
    reExportDeprecatedOnly: foo=
    exportedLibraryUris: package:test/x.dart
  requirements
    exportRequirements
      package:test/a.dart
        exports
          package:test/x.dart
            foo=: #M0
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  reExportDeprecatedOnlyMismatch
    libraryUri: package:test/a.dart
    name: foo=
    expected: false
    actual: true
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M3
        exportedTopLevels
          foo: <null>
          foo=: #M0
        reExportDeprecatedOnly
          foo=: true
      package:test/x.dart
        libraryMetadataId: #M4
[status] idle
[future] getErrors T2
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
    errors
      30 +3 DEPRECATED_EXPORT_USE
''',
    );
  }

  test_dependency_library_exportedDeprecated_setter_trueToFalse() async {
    configuration
      ..withStreamResolvedUnitResults = false
      ..withElementManifests = true;

    newFile('$testPackageLibPath/x.dart', r'''
set foo(int _) {}
''');

    await _runChangeScenarioTA(
      initialA: r'''
library;
@deprecated
export 'x.dart';
''',
      testCode: r'''
import 'a.dart';
void f() {
  foo = 0;
}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/x.dart
    declaredSetters
      foo=: #M0
        flags: hasImplicitReturnType isSimplyBounded isStatic
        functionType: FunctionType
          positional
            required int @ dart:core
          returnType: void
    declaredVariables
      foo: #M1
        flags: isStatic isSynthetic shouldUseTypeForInitializerInference
        type: int @ dart:core
  requirements
[operation] linkLibraryCycle
  package:test/a.dart
    reExportMap
      foo=: #M0
    reExportDeprecatedOnly: foo=
    exportedLibraryUris: package:test/x.dart
  requirements
    exportRequirements
      package:test/a.dart
        exports
          package:test/x.dart
            foo=: #M0
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M2
        flags: hasEnclosingTypeParameterReference isSimplyBounded isStatic
        functionType: FunctionType
          returnType: void
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M3
        exportedTopLevels
          foo: <null>
          foo=: #M0
        reExportDeprecatedOnly
          foo=: true
      package:test/x.dart
        libraryMetadataId: #M4
[status] idle
[future] getErrors T1
  ErrorsResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
    errors
      30 +3 DEPRECATED_EXPORT_USE
''',
      updatedA: r'''
library;
@deprecated
export 'x.dart';
export 'x.dart';
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    reExportMap
      foo=: #M0
    exportedLibraryUris: package:test/x.dart
  requirements
    exportRequirements
      package:test/a.dart
        exports
          package:test/x.dart
            foo=: #M0
          package:test/x.dart
            foo=: #M0
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  reExportDeprecatedOnlyMismatch
    libraryUri: package:test/a.dart
    name: foo=
    expected: true
    actual: false
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M3
        exportedTopLevels
          foo: <null>
          foo=: #M0
        reExportDeprecatedOnly
          foo=: false
      package:test/x.dart
        libraryMetadataId: #M4
[status] idle
[future] getErrors T2
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
    );
  }

  test_dependency_library_exportedTopLevels_class_remove() async {
    configuration
      ..withStreamResolvedUnitResults = false
      ..withElementManifests = true;

    newFile('$testPackageLibPath/x.dart', r'''
class A {}
''');

    await _runChangeScenarioTA(
      initialA: r'''
library;
export 'x.dart';
''',
      testCode: r'''
import 'a.dart';
void f() {
  A;
}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/x.dart
    declaredClasses
      A: #M0
        supertype: Object @ dart:core
        interface: #M1
  requirements
[operation] linkLibraryCycle
  package:test/a.dart
    reExportMap
      A: #M0
    exportedLibraryUris: package:test/x.dart
  requirements
    exportRequirements
      package:test/a.dart
        exports
          package:test/x.dart
            A: #M0
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M2
        flags: hasEnclosingTypeParameterReference isSimplyBounded isStatic
        functionType: FunctionType
          returnType: void
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M3
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
[status] idle
[future] getErrors T1
  ErrorsResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updatedA: r'''
library;
// export 'x.dart';
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  topLevelIdMismatch
    libraryUri: package:test/a.dart
    name: A
    expectedId: #M0
    actualId: <null>
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M3
        exportedTopLevels
          A: <null>
          A=: <null>
[status] idle
[future] getErrors T2
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
    errors
      30 +1 UNDEFINED_IDENTIFIER
''',
    );
  }

  test_dependency_libraryElement_allClasses_change() async {
    configuration
      ..withGetErrorsEvents = false
      ..withStreamResolvedUnitResults = false;

    _ManualRequirements.install((state) {
      var library = state.singleUnit.importedLibraries.first;
      library.classes;
    });

    await _runChangeScenarioTA(
      initialA: r'''
class A {}
class B {}
''',
      testCode: r'''
import 'a.dart';
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        interface: #M1
      B: #M2
        interface: #M3
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M4
        allDeclaredClasses: #M0 #M2
[status] idle
''',
      updatedA: r'''
class A {}
class C {}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        interface: #M1
      C: #M5
        interface: #M6
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  libraryChildrenIdsMismatch
    libraryUri: package:test/a.dart
    childrenPropertyName: classes
    expectedIds: #M0 #M2
    actualIds: #M0 #M5
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M4
        allDeclaredClasses: #M0 #M5
[status] idle
''',
    );
  }

  test_dependency_libraryElement_allEnums_change() async {
    configuration
      ..withGetErrorsEvents = false
      ..withStreamResolvedUnitResults = false;

    _ManualRequirements.install((state) {
      var library = state.singleUnit.importedLibraries.first;
      library.enums;
    });

    await _runChangeScenarioTA(
      initialA: r'''
enum A { a }
enum B { b }
''',
      testCode: r'''
import 'a.dart';
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredEnums
      A: #M0
        declaredFields
          a: #M1
          values: #M2
        declaredGetters
          a: #M3
          values: #M4
        interface: #M5
          map
            index: #M6
          implemented
            index: #M6
          superImplemented
            [0]
              index: #M6
          inherited
            index: #M6
      B: #M7
        declaredFields
          b: #M8
          values: #M9
        declaredGetters
          b: #M10
          values: #M11
        interface: #M12
          map
            index: #M6
          implemented
            index: #M6
          superImplemented
            [0]
              index: #M6
          inherited
            index: #M6
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M13
        allDeclaredEnums: #M0 #M7
[status] idle
''',
      updatedA: r'''
enum A { a }
enum C { c }
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredEnums
      A: #M0
        declaredFields
          a: #M1
          values: #M2
        declaredGetters
          a: #M3
          values: #M4
        interface: #M5
          map
            index: #M6
          implemented
            index: #M6
          superImplemented
            [0]
              index: #M6
          inherited
            index: #M6
      C: #M14
        declaredFields
          c: #M15
          values: #M16
        declaredGetters
          c: #M17
          values: #M18
        interface: #M19
          map
            index: #M6
          implemented
            index: #M6
          superImplemented
            [0]
              index: #M6
          inherited
            index: #M6
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  libraryChildrenIdsMismatch
    libraryUri: package:test/a.dart
    childrenPropertyName: enums
    expectedIds: #M0 #M7
    actualIds: #M0 #M14
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M13
        allDeclaredEnums: #M0 #M14
[status] idle
''',
    );
  }

  test_dependency_libraryElement_allExtensions_change() async {
    configuration
      ..withGetErrorsEvents = false
      ..withStreamResolvedUnitResults = false;

    _ManualRequirements.install((state) {
      var library = state.singleUnit.importedLibraries.first;
      library.extensions;
    });

    await _runChangeScenarioTA(
      initialA: r'''
extension A on int {}
extension B on int {}
''',
      testCode: r'''
import 'a.dart';
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensions
      A: #M0
      B: #M1
    exportedExtensions: #M0 #M1
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M2
        allDeclaredExtensions: #M0 #M1
[status] idle
''',
      updatedA: r'''
extension A on int {}
extension C on int {}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensions
      A: #M0
      C: #M3
    exportedExtensions: #M0 #M3
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  libraryChildrenIdsMismatch
    libraryUri: package:test/a.dart
    childrenPropertyName: extensions
    expectedIds: #M0 #M1
    actualIds: #M0 #M3
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M2
        allDeclaredExtensions: #M0 #M3
[status] idle
''',
    );
  }

  test_dependency_libraryElement_allExtensionTypes_change() async {
    configuration
      ..withGetErrorsEvents = false
      ..withStreamResolvedUnitResults = false;

    _ManualRequirements.install((state) {
      var library = state.singleUnit.importedLibraries.first;
      library.extensionTypes;
    });

    await _runChangeScenarioTA(
      initialA: r'''
extension type A(int it) {}
extension type B(int it) {}
''',
      testCode: r'''
import 'a.dart';
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensionTypes
      A: #M0
        declaredFields
          it: #M1
        declaredGetters
          it: #M2
        interface: #M3
          map
            it: #M2
          implemented
            it: #M2
      B: #M4
        declaredFields
          it: #M5
        declaredGetters
          it: #M6
        interface: #M7
          map
            it: #M6
          implemented
            it: #M6
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M8
        allDeclaredExtensionTypes: #M0 #M4
[status] idle
''',
      updatedA: r'''
extension type A(int it) {}
extension type C(int it) {}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensionTypes
      A: #M0
        declaredFields
          it: #M1
        declaredGetters
          it: #M2
        interface: #M3
          map
            it: #M2
          implemented
            it: #M2
      C: #M9
        declaredFields
          it: #M10
        declaredGetters
          it: #M11
        interface: #M12
          map
            it: #M11
          implemented
            it: #M11
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  libraryChildrenIdsMismatch
    libraryUri: package:test/a.dart
    childrenPropertyName: extensionTypes
    expectedIds: #M0 #M4
    actualIds: #M0 #M9
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M8
        allDeclaredExtensionTypes: #M0 #M9
[status] idle
''',
    );
  }

  test_dependency_libraryElement_allGetters_change() async {
    configuration
      ..withGetErrorsEvents = false
      ..withStreamResolvedUnitResults = false;

    _ManualRequirements.install((state) {
      var library = state.singleUnit.importedLibraries.first;
      library.getters;
    });

    await _runChangeScenarioTA(
      initialA: r'''
int get foo => 0;
int get bar => 1;
''',
      testCode: r'''
import 'a.dart';
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredGetters
      bar: #M0
      foo: #M1
    declaredVariables
      bar: #M2
      foo: #M3
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M4
        allDeclaredGetters: #M1 #M0
[status] idle
''',
      updatedA: r'''
int get foo => 0;
int get baz => 1;
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredGetters
      baz: #M5
      foo: #M1
    declaredVariables
      baz: #M6
      foo: #M3
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  libraryChildrenIdsMismatch
    libraryUri: package:test/a.dart
    childrenPropertyName: getters
    expectedIds: #M1 #M0
    actualIds: #M1 #M5
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M4
        allDeclaredGetters: #M1 #M5
[status] idle
''',
    );
  }

  test_dependency_libraryElement_allMixins_change() async {
    configuration
      ..withGetErrorsEvents = false
      ..withStreamResolvedUnitResults = false;

    _ManualRequirements.install((state) {
      var library = state.singleUnit.importedLibraries.first;
      library.mixins;
    });

    await _runChangeScenarioTA(
      initialA: r'''
mixin A {}
mixin B {}
''',
      testCode: r'''
import 'a.dart';
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredMixins
      A: #M0
        interface: #M1
      B: #M2
        interface: #M3
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M4
        allDeclaredMixins: #M0 #M2
[status] idle
''',
      updatedA: r'''
mixin A {}
mixin C {}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredMixins
      A: #M0
        interface: #M1
      C: #M5
        interface: #M6
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  libraryChildrenIdsMismatch
    libraryUri: package:test/a.dart
    childrenPropertyName: mixins
    expectedIds: #M0 #M2
    actualIds: #M0 #M5
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M4
        allDeclaredMixins: #M0 #M5
[status] idle
''',
    );
  }

  test_dependency_libraryElement_allSetters_change() async {
    configuration
      ..withGetErrorsEvents = false
      ..withStreamResolvedUnitResults = false;

    _ManualRequirements.install((state) {
      var library = state.singleUnit.importedLibraries.first;
      library.setters;
    });

    await _runChangeScenarioTA(
      initialA: r'''
set foo(int _) {}
set bar(int _) {}
''',
      testCode: r'''
import 'a.dart';
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredSetters
      bar=: #M0
      foo=: #M1
    declaredVariables
      bar: #M2
      foo: #M3
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M4
        allDeclaredSetters: #M1 #M0
[status] idle
''',
      updatedA: r'''
set foo(int _) {}
set baz(int _) {}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredSetters
      baz=: #M5
      foo=: #M1
    declaredVariables
      baz: #M6
      foo: #M3
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  libraryChildrenIdsMismatch
    libraryUri: package:test/a.dart
    childrenPropertyName: setters
    expectedIds: #M1 #M0
    actualIds: #M1 #M5
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M4
        allDeclaredSetters: #M1 #M5
[status] idle
''',
    );
  }

  test_dependency_libraryElement_allTopLevelFunctions_change() async {
    configuration
      ..withGetErrorsEvents = false
      ..withStreamResolvedUnitResults = false;

    _ManualRequirements.install((state) {
      var library = state.singleUnit.importedLibraries.first;
      library.topLevelFunctions;
    });

    await _runChangeScenarioTA(
      initialA: r'''
void foo() {}
void bar() {}
''',
      testCode: r'''
import 'a.dart';
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredFunctions
      bar: #M0
      foo: #M1
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M2
        allDeclaredFunctions: #M1 #M0
[status] idle
''',
      updatedA: r'''
void foo() {}
void baz() {}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredFunctions
      baz: #M3
      foo: #M1
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  libraryChildrenIdsMismatch
    libraryUri: package:test/a.dart
    childrenPropertyName: topLevelFunctions
    expectedIds: #M1 #M0
    actualIds: #M1 #M3
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M2
        allDeclaredFunctions: #M1 #M3
[status] idle
''',
    );
  }

  test_dependency_libraryElement_allTopLevelVariables_change() async {
    configuration
      ..withGetErrorsEvents = false
      ..withStreamResolvedUnitResults = false;

    _ManualRequirements.install((state) {
      var library = state.singleUnit.importedLibraries.first;
      library.topLevelVariables;
    });

    await _runChangeScenarioTA(
      initialA: r'''
var foo = 0;
var bar = 1;
''',
      testCode: r'''
import 'a.dart';
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredGetters
      bar: #M0
      foo: #M1
    declaredSetters
      bar=: #M2
      foo=: #M3
    declaredVariables
      bar: #M4
      foo: #M5
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M6
        allDeclaredVariables: #M5 #M4
[status] idle
''',
      updatedA: r'''
var foo = 0;
var baz = 1;
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredGetters
      baz: #M7
      foo: #M1
    declaredSetters
      baz=: #M8
      foo=: #M3
    declaredVariables
      baz: #M9
      foo: #M5
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  libraryChildrenIdsMismatch
    libraryUri: package:test/a.dart
    childrenPropertyName: topLevelVariables
    expectedIds: #M5 #M4
    actualIds: #M5 #M9
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M6
        allDeclaredVariables: #M5 #M9
[status] idle
''',
    );
  }

  test_dependency_libraryElement_allTypeAliases_change() async {
    configuration
      ..withGetErrorsEvents = false
      ..withStreamResolvedUnitResults = false;

    _ManualRequirements.install((state) {
      var library = state.singleUnit.importedLibraries.first;
      library.typeAliases;
    });

    await _runChangeScenarioTA(
      initialA: r'''
typedef A = int;
typedef B = int;
''',
      testCode: r'''
import 'a.dart';
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredTypeAliases
      A: #M0
      B: #M1
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M2
        allDeclaredTypeAliases: #M0 #M1
[status] idle
''',
      updatedA: r'''
typedef A = int;
typedef C = int;
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredTypeAliases
      A: #M0
      C: #M3
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  libraryChildrenIdsMismatch
    libraryUri: package:test/a.dart
    childrenPropertyName: typeAliases
    expectedIds: #M0 #M1
    actualIds: #M0 #M3
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M2
        allDeclaredTypeAliases: #M0 #M3
[status] idle
''',
    );
  }

  test_dependency_libraryElement_entryPoint() async {
    configuration
      ..withGetErrorsEvents = false
      ..withStreamResolvedUnitResults = false;

    _ManualRequirements.install((state) {
      var library = state.singleUnit.importedLibraries.first;
      library.entryPoint;
    });

    await _runChangeScenarioTA(
      initialA: r'''
void main() {}
''',
      testCode: r'''
import 'a.dart';
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredFunctions
      main: #M0
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M1
        exportedTopLevels
          main: #M0
[status] idle
''',
      updatedA: r'''
@deprecated
void main() {}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredFunctions
      main: #M2
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  topLevelIdMismatch
    libraryUri: package:test/a.dart
    name: main
    expectedId: #M0
    actualId: #M2
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M1
        exportedTopLevels
          main: #M2
[status] idle
''',
    );
  }

  test_dependency_libraryElement_exportedLibraries() async {
    configuration
      ..withGetErrorsEvents = false
      ..withStreamResolvedUnitResults = false;

    _ManualRequirements.install((state) {
      var library = state.singleUnit.importedLibraries.first;
      library.exportedLibraries;
    });

    await _runChangeScenarioTA(
      initialA: r'''
export 'dart:math' show min;
''',
      testCode: r'''
import 'a.dart';
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    reExportMap
      min: #M0
    exportedLibraryUris: dart:math
  requirements
    exportRequirements
      package:test/a.dart
        exports
          dart:math
            combinators
              show min
            min: #M0
[operation] linkLibraryCycle
  package:test/test.dart
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M1
        exportedLibraryUris: dart:math
[status] idle
''',
      updatedA: r'''
export 'dart:io' show exit;
export 'dart:math' show min;
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    reExportMap
      exit: #M2
      min: #M0
    exportedLibraryUris: dart:io dart:math
  requirements
    exportRequirements
      package:test/a.dart
        exports
          dart:io
            combinators
              show exit
            exit: #M2
          dart:math
            combinators
              show min
            min: #M0
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  libraryExportedUrisMismatch
    libraryUri: package:test/a.dart
    expected: dart:math
    actual: dart:io dart:math
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M1
        exportedLibraryUris: dart:io dart:math
[status] idle
''',
    );
  }

  test_dependency_libraryElement_exportNamespace_ambiguousExport_add() async {
    configuration.withStreamResolvedUnitResults = false;

    newFile('$testPackageLibPath/b.dart', r'''
class B {}
''');

    await _runChangeScenarioTA(
      initialA: r'''
class A {}
''',
      testCode: r'''
export 'a.dart';
export 'b.dart';
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        interface: #M1
  requirements
[operation] linkLibraryCycle
  package:test/b.dart
    declaredClasses
      B: #M2
        interface: #M3
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    reExportMap
      A: #M0
      B: #M2
    exportedLibraryUris: package:test/a.dart package:test/b.dart
  requirements
    exportRequirements
      package:test/test.dart
        exports
          package:test/a.dart
            A: #M0
          package:test/b.dart
            B: #M2
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M4
        exportedTopLevels
          A: #M0
      package:test/b.dart
        libraryMetadataId: #M5
        exportedTopLevels
          B: #M2
[status] idle
[future] getErrors T1
  ErrorsResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updatedA: r'''
class B {}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      B: #M6
        interface: #M7
  requirements
[operation] checkLinkedBundleRequirements
  package:test/test.dart
  exportIdMismatch
    fragmentUri: package:test/test.dart
    exportedUri: package:test/a.dart
    name: B
    expectedId: <null>
    actualId: #M6
[operation] linkLibraryCycle
  package:test/test.dart
    reExportMap
      B: #M6
    exportedLibraryUris: package:test/a.dart package:test/b.dart
  requirements
    exportRequirements
      package:test/test.dart
        exports
          package:test/a.dart
            B: #M6
          package:test/b.dart
            B: #M2
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  topLevelIdMismatch
    libraryUri: package:test/a.dart
    name: A
    expectedId: #M0
    actualId: <null>
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M4
        exportedTopLevels
          B: #M6
      package:test/b.dart
        libraryMetadataId: #M5
        exportedTopLevels
          B: #M2
[status] idle
[future] getErrors T2
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
    errors
      24 +8 AMBIGUOUS_EXPORT
''',
    );
  }

  test_dependency_libraryElement_exportNamespace_ambiguousExport_remove() async {
    configuration.withStreamResolvedUnitResults = false;

    newFile('$testPackageLibPath/b.dart', r'''
class B {}
''');

    await _runChangeScenarioTA(
      initialA: r'''
class B {}
''',
      testCode: r'''
export 'a.dart';
export 'b.dart';
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      B: #M0
        interface: #M1
  requirements
[operation] linkLibraryCycle
  package:test/b.dart
    declaredClasses
      B: #M2
        interface: #M3
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    reExportMap
      B: #M0
    exportedLibraryUris: package:test/a.dart package:test/b.dart
  requirements
    exportRequirements
      package:test/test.dart
        exports
          package:test/a.dart
            B: #M0
          package:test/b.dart
            B: #M2
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M4
        exportedTopLevels
          B: #M0
      package:test/b.dart
        libraryMetadataId: #M5
        exportedTopLevels
          B: #M2
[status] idle
[future] getErrors T1
  ErrorsResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
    errors
      24 +8 AMBIGUOUS_EXPORT
''',
      updatedA: r'''
class A {}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M6
        interface: #M7
  requirements
[operation] checkLinkedBundleRequirements
  package:test/test.dart
  exportIdMismatch
    fragmentUri: package:test/test.dart
    exportedUri: package:test/a.dart
    name: A
    expectedId: <null>
    actualId: #M6
[operation] linkLibraryCycle
  package:test/test.dart
    reExportMap
      A: #M6
      B: #M2
    exportedLibraryUris: package:test/a.dart package:test/b.dart
  requirements
    exportRequirements
      package:test/test.dart
        exports
          package:test/a.dart
            A: #M6
          package:test/b.dart
            B: #M2
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  topLevelIdMismatch
    libraryUri: package:test/a.dart
    name: B
    expectedId: #M0
    actualId: <null>
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M4
        exportedTopLevels
          A: #M6
      package:test/b.dart
        libraryMetadataId: #M5
        exportedTopLevels
          B: #M2
[status] idle
[future] getErrors T2
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
    );
  }

  test_dependency_libraryElement_exportNamespace_definedNames() async {
    configuration
      ..withGetErrorsEvents = false
      ..withStreamResolvedUnitResults = false;

    _ManualRequirements.install((state) {
      var library = state.singleUnit.importedLibraries.first;
      library.exportNamespace.definedNames2;
    });

    await _runChangeScenarioTA(
      initialA: r'''
class A {}
class B {}
''',
      testCode: r'''
import 'a.dart';
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        interface: #M1
      B: #M2
        interface: #M3
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M4
        exportedTopLevels
          A: #M0
          B: #M2
[status] idle
''',
      updatedA: r'''
class A {}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        interface: #M1
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  topLevelIdMismatch
    libraryUri: package:test/a.dart
    name: B
    expectedId: #M2
    actualId: <null>
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M4
        exportedTopLevels
          A: #M0
[status] idle
''',
    );
  }

  test_dependency_libraryElement_exportNamespace_get_class() async {
    configuration
      ..withGetErrorsEvents = false
      ..withStreamResolvedUnitResults = false;

    _ManualRequirements.install((state) {
      var library = state.singleUnit.importedLibraries.first;
      library.exportNamespace.get2('A');
    });

    await _runChangeScenarioTA(
      initialA: r'''
class A {}
class B {}
''',
      testCode: r'''
import 'a.dart';
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        interface: #M1
      B: #M2
        interface: #M3
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M4
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
[status] idle
''',
      updatedA: r'''
class A {}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        interface: #M1
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] getErrorsFromBytes
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[status] idle
''',
    );
  }

  test_dependency_libraryElement_exportNamespace_get_setter() async {
    configuration
      ..withGetErrorsEvents = false
      ..withStreamResolvedUnitResults = false;

    _ManualRequirements.install((state) {
      var library = state.singleUnit.importedLibraries.first;
      library.exportNamespace.get2('foo=');
    });

    await _runChangeScenarioTA(
      initialA: r'''
void set foo(int _) {}
void set bar(int _) {}
''',
      testCode: r'''
import 'a.dart';
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredSetters
      bar=: #M0
      foo=: #M1
    declaredVariables
      bar: #M2
      foo: #M3
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M4
        exportedTopLevels
          foo: <null>
          foo=: #M1
        reExportDeprecatedOnly
          foo=: false
[status] idle
''',
      updatedA: r'''
void set foo(int _) {}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredSetters
      foo=: #M1
    declaredVariables
      foo: #M3
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] getErrorsFromBytes
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[status] idle
''',
    );
  }

  test_dependency_libraryElement_featureSet() async {
    configuration
      ..withGetErrorsEvents = false
      ..withStreamResolvedUnitResults = false;

    _ManualRequirements.install((state) {
      var library = state.singleUnit.importedLibraries.first;
      library.featureSet;
    });

    await _runChangeScenarioTA(
      initialA: r'''
class A {}
''',
      testCode: r'''
import 'a.dart';
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        interface: #M1
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        featureSet: <not-null>
        libraryMetadataId: #M2
[status] idle
''',
      updatedA: r'''
// @dart = 2.19
class A {}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        interface: #M1
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  libraryFeatureSetMismatch
    libraryUri: package:test/a.dart
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        featureSet: <not-null>
        libraryMetadataId: #M2
[status] idle
''',
    );
  }

  test_dependency_libraryElement_getClass_change() async {
    configuration
      ..withGetErrorsEvents = false
      ..withStreamResolvedUnitResults = false;

    _ManualRequirements.install((state) {
      var library = state.singleUnit.importedLibraries.first;
      library.getClass('A');
    });

    await _runChangeScenarioTA(
      initialA: r'''
class A {}
''',
      testCode: r'''
import 'a.dart';
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        interface: #M1
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M2
        requestedDeclaredClasses
          A: #M0
[status] idle
''',
      updatedA: r'''
class B {}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      B: #M3
        interface: #M4
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  topLevelIdMismatch
    libraryUri: package:test/a.dart
    name: A
    expectedId: #M0
    actualId: <null>
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M2
        requestedDeclaredClasses
          A: <null>
[status] idle
''',
    );
  }

  test_dependency_libraryElement_getClass_change_other() async {
    configuration
      ..withGetErrorsEvents = false
      ..withStreamResolvedUnitResults = false;

    _ManualRequirements.install((state) {
      var library = state.singleUnit.importedLibraries.first;
      library.getClass('A');
    });

    await _runChangeScenarioTA(
      initialA: r'''
class A {}
class B {}
''',
      testCode: r'''
import 'a.dart';
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        interface: #M1
      B: #M2
        interface: #M3
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M4
        requestedDeclaredClasses
          A: #M0
[status] idle
''',
      updatedA: r'''
class A {}
class C {}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        interface: #M1
      C: #M5
        interface: #M6
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] getErrorsFromBytes
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[status] idle
''',
    );
  }

  test_dependency_libraryElement_getEnum_change() async {
    configuration
      ..withGetErrorsEvents = false
      ..withStreamResolvedUnitResults = false;

    _ManualRequirements.install((state) {
      var library = state.singleUnit.importedLibraries.first;
      library.getEnum('A');
    });

    await _runChangeScenarioTA(
      initialA: r'''
enum A { a }
''',
      testCode: r'''
import 'a.dart';
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredEnums
      A: #M0
        declaredFields
          a: #M1
          values: #M2
        declaredGetters
          a: #M3
          values: #M4
        interface: #M5
          map
            index: #M6
          implemented
            index: #M6
          superImplemented
            [0]
              index: #M6
          inherited
            index: #M6
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M7
        requestedDeclaredEnums
          A: #M0
[status] idle
''',
      updatedA: r'''
enum B { b }
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredEnums
      B: #M8
        declaredFields
          b: #M9
          values: #M10
        declaredGetters
          b: #M11
          values: #M12
        interface: #M13
          map
            index: #M6
          implemented
            index: #M6
          superImplemented
            [0]
              index: #M6
          inherited
            index: #M6
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  topLevelIdMismatch
    libraryUri: package:test/a.dart
    name: A
    expectedId: #M0
    actualId: <null>
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M7
        requestedDeclaredEnums
          A: <null>
[status] idle
''',
    );
  }

  test_dependency_libraryElement_getEnum_change_other() async {
    configuration
      ..withGetErrorsEvents = false
      ..withStreamResolvedUnitResults = false;

    _ManualRequirements.install((state) {
      var library = state.singleUnit.importedLibraries.first;
      library.getEnum('A');
    });

    await _runChangeScenarioTA(
      initialA: r'''
enum A { a }
enum B { b }
''',
      testCode: r'''
import 'a.dart';
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredEnums
      A: #M0
        declaredFields
          a: #M1
          values: #M2
        declaredGetters
          a: #M3
          values: #M4
        interface: #M5
          map
            index: #M6
          implemented
            index: #M6
          superImplemented
            [0]
              index: #M6
          inherited
            index: #M6
      B: #M7
        declaredFields
          b: #M8
          values: #M9
        declaredGetters
          b: #M10
          values: #M11
        interface: #M12
          map
            index: #M6
          implemented
            index: #M6
          superImplemented
            [0]
              index: #M6
          inherited
            index: #M6
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M13
        requestedDeclaredEnums
          A: #M0
[status] idle
''',
      updatedA: r'''
enum A { a }
enum C { c }
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredEnums
      A: #M0
        declaredFields
          a: #M1
          values: #M2
        declaredGetters
          a: #M3
          values: #M4
        interface: #M5
          map
            index: #M6
          implemented
            index: #M6
          superImplemented
            [0]
              index: #M6
          inherited
            index: #M6
      C: #M14
        declaredFields
          c: #M15
          values: #M16
        declaredGetters
          c: #M17
          values: #M18
        interface: #M19
          map
            index: #M6
          implemented
            index: #M6
          superImplemented
            [0]
              index: #M6
          inherited
            index: #M6
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] getErrorsFromBytes
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[status] idle
''',
    );
  }

  test_dependency_libraryElement_getExtension_change() async {
    configuration
      ..withGetErrorsEvents = false
      ..withStreamResolvedUnitResults = false;

    _ManualRequirements.install((state) {
      var library = state.singleUnit.importedLibraries.first;
      library.getExtension('A');
    });

    await _runChangeScenarioTA(
      initialA: r'''
extension A on int {}
''',
      testCode: r'''
import 'a.dart';
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensions
      A: #M0
    exportedExtensions: #M0
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M1
        requestedDeclaredExtensions
          A: #M0
[status] idle
''',
      updatedA: r'''
extension B on int {}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensions
      B: #M2
    exportedExtensions: #M2
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  topLevelIdMismatch
    libraryUri: package:test/a.dart
    name: A
    expectedId: #M0
    actualId: <null>
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M1
        requestedDeclaredExtensions
          A: <null>
[status] idle
''',
    );
  }

  test_dependency_libraryElement_getExtension_change_other() async {
    configuration
      ..withGetErrorsEvents = false
      ..withStreamResolvedUnitResults = false;

    _ManualRequirements.install((state) {
      var library = state.singleUnit.importedLibraries.first;
      library.getExtension('A');
    });

    await _runChangeScenarioTA(
      initialA: r'''
extension A on int {}
extension B on int {}
''',
      testCode: r'''
import 'a.dart';
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensions
      A: #M0
      B: #M1
    exportedExtensions: #M0 #M1
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M2
        requestedDeclaredExtensions
          A: #M0
[status] idle
''',
      updatedA: r'''
extension A on int {}
extension C on int {}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensions
      A: #M0
      C: #M3
    exportedExtensions: #M0 #M3
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] getErrorsFromBytes
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[status] idle
''',
    );
  }

  test_dependency_libraryElement_getExtensionType_change() async {
    configuration
      ..withGetErrorsEvents = false
      ..withStreamResolvedUnitResults = false;

    _ManualRequirements.install((state) {
      var library = state.singleUnit.importedLibraries.first;
      library.getExtensionType('A');
    });

    await _runChangeScenarioTA(
      initialA: r'''
extension type A(int it) {}
''',
      testCode: r'''
import 'a.dart';
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensionTypes
      A: #M0
        declaredFields
          it: #M1
        declaredGetters
          it: #M2
        interface: #M3
          map
            it: #M2
          implemented
            it: #M2
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M4
        requestedDeclaredExtensionTypes
          A: #M0
[status] idle
''',
      updatedA: r'''
extension type B(int it) {}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensionTypes
      B: #M5
        declaredFields
          it: #M6
        declaredGetters
          it: #M7
        interface: #M8
          map
            it: #M7
          implemented
            it: #M7
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  topLevelIdMismatch
    libraryUri: package:test/a.dart
    name: A
    expectedId: #M0
    actualId: <null>
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M4
        requestedDeclaredExtensionTypes
          A: <null>
[status] idle
''',
    );
  }

  test_dependency_libraryElement_getExtensionType_change_other() async {
    configuration
      ..withGetErrorsEvents = false
      ..withStreamResolvedUnitResults = false;

    _ManualRequirements.install((state) {
      var library = state.singleUnit.importedLibraries.first;
      library.getExtensionType('A');
    });

    await _runChangeScenarioTA(
      initialA: r'''
extension type A(int it) {}
extension type B(int it) {}
''',
      testCode: r'''
import 'a.dart';
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensionTypes
      A: #M0
        declaredFields
          it: #M1
        declaredGetters
          it: #M2
        interface: #M3
          map
            it: #M2
          implemented
            it: #M2
      B: #M4
        declaredFields
          it: #M5
        declaredGetters
          it: #M6
        interface: #M7
          map
            it: #M6
          implemented
            it: #M6
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M8
        requestedDeclaredExtensionTypes
          A: #M0
[status] idle
''',
      updatedA: r'''
extension type A(int it) {}
extension type C(int it) {}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensionTypes
      A: #M0
        declaredFields
          it: #M1
        declaredGetters
          it: #M2
        interface: #M3
          map
            it: #M2
          implemented
            it: #M2
      C: #M9
        declaredFields
          it: #M10
        declaredGetters
          it: #M11
        interface: #M12
          map
            it: #M11
          implemented
            it: #M11
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] getErrorsFromBytes
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[status] idle
''',
    );
  }

  test_dependency_libraryElement_getGetter_change() async {
    configuration
      ..withGetErrorsEvents = false
      ..withStreamResolvedUnitResults = false;

    _ManualRequirements.install((state) {
      var library = state.singleUnit.importedLibraries.first;
      library.getGetter('foo');
    });

    await _runChangeScenarioTA(
      initialA: r'''
int get foo => 0;
''',
      testCode: r'''
import 'a.dart';
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredGetters
      foo: #M0
    declaredVariables
      foo: #M1
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M2
        requestedDeclaredGetters
          foo: #M0
[status] idle
''',
      updatedA: r'''
int get bar => 0;
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredGetters
      bar: #M3
    declaredVariables
      bar: #M4
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  topLevelIdMismatch
    libraryUri: package:test/a.dart
    name: foo
    expectedId: #M0
    actualId: <null>
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M2
        requestedDeclaredGetters
          foo: <null>
[status] idle
''',
    );
  }

  test_dependency_libraryElement_getGetter_change_other() async {
    configuration
      ..withGetErrorsEvents = false
      ..withStreamResolvedUnitResults = false;

    _ManualRequirements.install((state) {
      var library = state.singleUnit.importedLibraries.first;
      library.getGetter('foo');
    });

    await _runChangeScenarioTA(
      initialA: r'''
int get foo => 0;
int get bar => 1;
''',
      testCode: r'''
import 'a.dart';
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredGetters
      bar: #M0
      foo: #M1
    declaredVariables
      bar: #M2
      foo: #M3
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M4
        requestedDeclaredGetters
          foo: #M1
[status] idle
''',
      updatedA: r'''
int get foo => 0;
int get baz => 1;
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredGetters
      baz: #M5
      foo: #M1
    declaredVariables
      baz: #M6
      foo: #M3
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] getErrorsFromBytes
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[status] idle
''',
    );
  }

  test_dependency_libraryElement_getMixin_change() async {
    configuration
      ..withGetErrorsEvents = false
      ..withStreamResolvedUnitResults = false;

    _ManualRequirements.install((state) {
      var library = state.singleUnit.importedLibraries.first;
      library.getMixin('A');
    });

    await _runChangeScenarioTA(
      initialA: r'''
mixin A {}
''',
      testCode: r'''
import 'a.dart';
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredMixins
      A: #M0
        interface: #M1
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M2
        requestedDeclaredMixins
          A: #M0
[status] idle
''',
      updatedA: r'''
mixin B {}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredMixins
      B: #M3
        interface: #M4
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  topLevelIdMismatch
    libraryUri: package:test/a.dart
    name: A
    expectedId: #M0
    actualId: <null>
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M2
        requestedDeclaredMixins
          A: <null>
[status] idle
''',
    );
  }

  test_dependency_libraryElement_getMixin_change_other() async {
    configuration
      ..withGetErrorsEvents = false
      ..withStreamResolvedUnitResults = false;

    _ManualRequirements.install((state) {
      var library = state.singleUnit.importedLibraries.first;
      library.getMixin('A');
    });

    await _runChangeScenarioTA(
      initialA: r'''
mixin A {}
mixin B {}
''',
      testCode: r'''
import 'a.dart';
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredMixins
      A: #M0
        interface: #M1
      B: #M2
        interface: #M3
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M4
        requestedDeclaredMixins
          A: #M0
[status] idle
''',
      updatedA: r'''
mixin A {}
mixin C {}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredMixins
      A: #M0
        interface: #M1
      C: #M5
        interface: #M6
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] getErrorsFromBytes
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[status] idle
''',
    );
  }

  test_dependency_libraryElement_getName_change() async {
    configuration
      ..withGetErrorsEvents = false
      ..withStreamResolvedUnitResults = false;

    _ManualRequirements.install((state) {
      var library = state.singleUnit.importedLibraries.first;
      library.name;
    });

    await _runChangeScenarioTA(
      initialA: r'''
library foo;
class A {}
''',
      testCode: r'''
import 'a.dart';
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    name: foo
    declaredClasses
      A: #M0
        interface: #M1
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        name: foo
        libraryMetadataId: #M2
[status] idle
''',
      updatedA: r'''
library bar;
class A {}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    name: bar
    declaredClasses
      A: #M0
        interface: #M1
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  libraryNameMismatch
    libraryUri: package:test/a.dart
    expected: foo
    actual: bar
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        name: bar
        libraryMetadataId: #M2
[status] idle
''',
    );
  }

  test_dependency_libraryElement_getName_noChange() async {
    configuration
      ..withGetErrorsEvents = false
      ..withStreamResolvedUnitResults = false;

    _ManualRequirements.install((state) {
      var library = state.singleUnit.importedLibraries.first;
      library.name;
    });

    await _runChangeScenarioTA(
      initialA: r'''
library foo;
class A {}
''',
      testCode: r'''
import 'a.dart';
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    name: foo
    declaredClasses
      A: #M0
        interface: #M1
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        name: foo
        libraryMetadataId: #M2
[status] idle
''',
      updatedA: r'''
library foo;
class B {}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    name: foo
    declaredClasses
      B: #M3
        interface: #M4
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] getErrorsFromBytes
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[status] idle
''',
    );
  }

  test_dependency_libraryElement_getSetter_change() async {
    configuration
      ..withGetErrorsEvents = false
      ..withStreamResolvedUnitResults = false;

    _ManualRequirements.install((state) {
      var library = state.singleUnit.importedLibraries.first;
      library.getSetter('foo');
    });

    await _runChangeScenarioTA(
      initialA: r'''
set foo(int _) {}
''',
      testCode: r'''
import 'a.dart';
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredSetters
      foo=: #M0
    declaredVariables
      foo: #M1
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M2
        requestedDeclaredSetters
          foo=: #M0
[status] idle
''',
      updatedA: r'''
set bar(int _) {}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredSetters
      bar=: #M3
    declaredVariables
      bar: #M4
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  topLevelIdMismatch
    libraryUri: package:test/a.dart
    name: foo=
    expectedId: #M0
    actualId: <null>
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M2
        requestedDeclaredSetters
          foo=: <null>
[status] idle
''',
    );
  }

  test_dependency_libraryElement_getSetter_change_other() async {
    configuration
      ..withGetErrorsEvents = false
      ..withStreamResolvedUnitResults = false;

    _ManualRequirements.install((state) {
      var library = state.singleUnit.importedLibraries.first;
      library.getSetter('foo');
    });

    await _runChangeScenarioTA(
      initialA: r'''
set foo(int _) {}
set bar(int _) {}
''',
      testCode: r'''
import 'a.dart';
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredSetters
      bar=: #M0
      foo=: #M1
    declaredVariables
      bar: #M2
      foo: #M3
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M4
        requestedDeclaredSetters
          foo=: #M1
[status] idle
''',
      updatedA: r'''
set foo(int _) {}
set baz(int _) {}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredSetters
      baz=: #M5
      foo=: #M1
    declaredVariables
      baz: #M6
      foo: #M3
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] getErrorsFromBytes
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[status] idle
''',
    );
  }

  test_dependency_libraryElement_getTopLevelFunction_change() async {
    configuration
      ..withGetErrorsEvents = false
      ..withStreamResolvedUnitResults = false;

    _ManualRequirements.install((state) {
      var library = state.singleUnit.importedLibraries.first;
      library.getTopLevelFunction('foo');
    });

    await _runChangeScenarioTA(
      initialA: r'''
void foo() {}
''',
      testCode: r'''
import 'a.dart';
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredFunctions
      foo: #M0
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M1
        requestedDeclaredFunctions
          foo: #M0
[status] idle
''',
      updatedA: r'''
void bar() {}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredFunctions
      bar: #M2
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  topLevelIdMismatch
    libraryUri: package:test/a.dart
    name: foo
    expectedId: #M0
    actualId: <null>
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M1
        requestedDeclaredFunctions
          foo: <null>
[status] idle
''',
    );
  }

  test_dependency_libraryElement_getTopLevelFunction_change_other() async {
    configuration
      ..withGetErrorsEvents = false
      ..withStreamResolvedUnitResults = false;

    _ManualRequirements.install((state) {
      var library = state.singleUnit.importedLibraries.first;
      library.getTopLevelFunction('foo');
    });

    await _runChangeScenarioTA(
      initialA: r'''
void foo() {}
void bar() {}
''',
      testCode: r'''
import 'a.dart';
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredFunctions
      bar: #M0
      foo: #M1
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M2
        requestedDeclaredFunctions
          foo: #M1
[status] idle
''',
      updatedA: r'''
void foo() {}
void baz() {}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredFunctions
      baz: #M3
      foo: #M1
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] getErrorsFromBytes
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[status] idle
''',
    );
  }

  test_dependency_libraryElement_getTopLevelVariable_change() async {
    configuration
      ..withGetErrorsEvents = false
      ..withStreamResolvedUnitResults = false;

    _ManualRequirements.install((state) {
      var library = state.singleUnit.importedLibraries.first;
      library.getTopLevelVariable('foo');
    });

    await _runChangeScenarioTA(
      initialA: r'''
var foo = 0;
''',
      testCode: r'''
import 'a.dart';
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredGetters
      foo: #M0
    declaredSetters
      foo=: #M1
    declaredVariables
      foo: #M2
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M3
        requestedDeclaredVariables
          foo: #M2
[status] idle
''',
      updatedA: r'''
var bar = 0;
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredGetters
      bar: #M4
    declaredSetters
      bar=: #M5
    declaredVariables
      bar: #M6
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  topLevelIdMismatch
    libraryUri: package:test/a.dart
    name: foo
    expectedId: #M2
    actualId: <null>
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M3
        requestedDeclaredVariables
          foo: <null>
[status] idle
''',
    );
  }

  test_dependency_libraryElement_getTopLevelVariable_change_other() async {
    configuration
      ..withGetErrorsEvents = false
      ..withStreamResolvedUnitResults = false;

    _ManualRequirements.install((state) {
      var library = state.singleUnit.importedLibraries.first;
      library.getTopLevelVariable('foo');
    });

    await _runChangeScenarioTA(
      initialA: r'''
var foo = 0;
var bar = 1;
''',
      testCode: r'''
import 'a.dart';
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredGetters
      bar: #M0
      foo: #M1
    declaredSetters
      bar=: #M2
      foo=: #M3
    declaredVariables
      bar: #M4
      foo: #M5
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M6
        requestedDeclaredVariables
          foo: #M5
[status] idle
''',
      updatedA: r'''
var foo = 0;
var baz = 1;
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredGetters
      baz: #M7
      foo: #M1
    declaredSetters
      baz=: #M8
      foo=: #M3
    declaredVariables
      baz: #M9
      foo: #M5
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] getErrorsFromBytes
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[status] idle
''',
    );
  }

  test_dependency_libraryElement_getTypeAlias_change() async {
    configuration
      ..withGetErrorsEvents = false
      ..withStreamResolvedUnitResults = false;

    _ManualRequirements.install((state) {
      var library = state.singleUnit.importedLibraries.first;
      library.getTypeAlias('A');
    });

    await _runChangeScenarioTA(
      initialA: r'''
typedef A = int;
''',
      testCode: r'''
import 'a.dart';
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredTypeAliases
      A: #M0
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M1
        requestedDeclaredTypeAliases
          A: #M0
[status] idle
''',
      updatedA: r'''
typedef B = int;
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredTypeAliases
      B: #M2
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  topLevelIdMismatch
    libraryUri: package:test/a.dart
    name: A
    expectedId: #M0
    actualId: <null>
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M1
        requestedDeclaredTypeAliases
          A: <null>
[status] idle
''',
    );
  }

  test_dependency_libraryElement_getTypeAlias_change_other() async {
    configuration
      ..withGetErrorsEvents = false
      ..withStreamResolvedUnitResults = false;

    _ManualRequirements.install((state) {
      var library = state.singleUnit.importedLibraries.first;
      library.getTypeAlias('A');
    });

    await _runChangeScenarioTA(
      initialA: r'''
typedef A = int;
typedef B = int;
''',
      testCode: r'''
import 'a.dart';
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredTypeAliases
      A: #M0
      B: #M1
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M2
        requestedDeclaredTypeAliases
          A: #M0
[status] idle
''',
      updatedA: r'''
typedef A = int;
typedef C = int;
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredTypeAliases
      A: #M0
      C: #M3
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] getErrorsFromBytes
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[status] idle
''',
    );
  }

  test_dependency_libraryElement_isSynthetic() async {
    configuration
      ..withGetErrorsEvents = false
      ..withStreamResolvedUnitResults = false;

    _ManualRequirements.install((state) {
      var library = state.singleUnit.importedLibraries.first;
      library.isSynthetic;
    });

    newFile('$testPackageLibPath/test.dart', r'''
import 'a.dart';
''');

    await _runChangeScenario(
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    flags: isSynthetic
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        isSynthetic: true
        libraryMetadataId: #M0
[status] idle
''',
      updateFiles: () {
        var a = newFile('$testPackageLibPath/a.dart', '');
        return [a];
      },
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  libraryIsSyntheticMismatch
    libraryUri: package:test/a.dart
    expected: true
    actual: false
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M0
[status] idle
''',
    );
  }

  test_dependency_libraryElement_languageVersion() async {
    configuration
      ..withGetErrorsEvents = false
      ..withStreamResolvedUnitResults = false;

    _ManualRequirements.install((state) {
      var library = state.singleUnit.importedLibraries.first;
      library.languageVersion;
    });

    await _runChangeScenarioTA(
      initialA: r'''
// @dart = 3.8
class A {}
''',
      testCode: r'''
import 'a.dart';
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        interface: #M1
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        languageVersion: <not-null>
        libraryMetadataId: #M2
[status] idle
''',
      updatedA: r'''
// @dart = 3.9
class A {}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        interface: #M1
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  libraryLanguageVersionMismatch
    libraryUri: package:test/a.dart
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        languageVersion: <not-null>
        libraryMetadataId: #M2
[status] idle
''',
    );
  }

  test_dependency_libraryElement_metadata() async {
    configuration
      ..withGetErrorsEvents = false
      ..withStreamResolvedUnitResults = false;

    _ManualRequirements.install((state) {
      var library = state.singleUnit.importedLibraries.first;
      library.metadata;
    });

    await _runChangeScenarioTA(
      initialA: r'''
@Deprecated('0')
library;
''',
      testCode: r'''
import 'a.dart';
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    libraryMetadata: #M0
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        featureSet: <not-null>
        libraryMetadataId: #M0
[status] idle
''',
      updatedA: r'''
@Deprecated('1')
library;
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    libraryMetadata: #M1
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  libraryMetadataMismatch
    libraryUri: package:test/a.dart
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        featureSet: <not-null>
        libraryMetadataId: #M1
[status] idle
''',
    );
  }

  test_dependency_libraryElement_typeProvider_changeDartCore() async {
    configuration
      ..withGetErrorsEvents = false
      ..withStreamResolvedUnitResults = false;

    _ManualRequirements.install((state) {
      var library = state.singleUnit.libraryElement;
      library.typeProvider.intElement;
    });

    await _runChangeScenario(
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    flags: isSynthetic
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
[status] idle
''',
      updateFiles: () {
        var core = sdkRoot.getChildAssumingFile('lib/core/core.dart');
        var newCode = core.readAsStringSync().replaceFirst(
          'abstract final class int extends num {',
          '@deprecated abstract final class int extends num {',
        );
        modifyFile2(core, newCode);
        return [core];
      },
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  topLevelIdMismatch
    libraryUri: dart:core
    name: int
    expectedId: #M0
    actualId: #M1
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
[status] idle
''',
    );
  }

  test_dependency_mixin_instanceField_add_hasNonFinalField() async {
    configuration
      ..withGetErrorsEvents = false
      ..withStreamResolvedUnitResults = false;

    _ManualRequirements.install((state) {
      var A = state.singleUnit.scopeInterfaceElement('A');
      A.hasNonFinalField;
    });

    await _runChangeScenarioTA(
      initialA: r'''
mixin A {}
''',
      testCode: r'''
import 'a.dart';
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredMixins
      A: #M0
        interface: #M1
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M2
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        interfaces
          A
            hasNonFinalField: false
[status] idle
''',
      updatedA: r'''
mixin A {
  var foo = 0;
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredMixins
      A: #M0
        declaredFields
          foo: #M3
        declaredGetters
          foo: #M4
        declaredSetters
          foo=: #M5
        interface: #M6
          map
            foo: #M4
            foo=: #M5
          implemented
            foo: #M4
            foo=: #M5
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  interfaceHasNonFinalFieldMismatch
    libraryUri: package:test/a.dart
    interfaceName: A
    expected: false
    actual: true
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M2
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        interfaces
          A
            hasNonFinalField: true
[status] idle
''',
    );
  }

  test_dependency_mixin_instanceGetter_change_invoked() async {
    await _runChangeScenarioTA(
      initialA: r'''
mixin A {
  int get foo => 0;
}
''',
      testCode: r'''
import 'a.dart';
void f(A a) {
  a.foo;
}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredMixins
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        interface: #M3
          map
            foo: #M2
          implemented
            foo: #M2
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M4
  requirements
    libraries
      package:test/a.dart
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M5
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredFields
              foo: #M1
        interfaces
          A
            methods
              foo: #M2
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updatedA: r'''
mixin A {
  double get foo => 1.2;
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredMixins
      A: #M0
        declaredFields
          foo: #M6
        declaredGetters
          foo: #M7
        interface: #M8
          map
            foo: #M7
          implemented
            foo: #M7
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  instanceFieldIdMismatch
    libraryUri: package:test/a.dart
    interfaceName: A
    fieldName: foo
    expectedId: #M1
    actualId: #M6
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M5
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredFields
              foo: #M6
        interfaces
          A
            methods
              foo: #M7
[status] idle
[future] getErrors T2
  ErrorsResult #3
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
    );
  }

  test_dependency_mixin_instanceGetter_change_notUsed() async {
    await _runChangeScenarioTA(
      initialA: r'''
mixin A {
  int get foo => 0;
  int get bar => 0;
}
''',
      testCode: r'''
import 'a.dart';
void f(A a) {
  a.foo;
}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredMixins
      A: #M0
        declaredFields
          bar: #M1
          foo: #M2
        declaredGetters
          bar: #M3
          foo: #M4
        interface: #M5
          map
            bar: #M3
            foo: #M4
          implemented
            bar: #M3
            foo: #M4
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M6
  requirements
    libraries
      package:test/a.dart
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M7
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredFields
              foo: #M2
        interfaces
          A
            methods
              foo: #M4
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updatedA: r'''
mixin A {
  int get foo => 0;
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredMixins
      A: #M0
        declaredFields
          foo: #M2
        declaredGetters
          foo: #M4
        interface: #M8
          map
            foo: #M4
          implemented
            foo: #M4
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] getErrorsFromBytes
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[status] idle
[future] getErrors T2
  ErrorsResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
    );
  }

  test_dependency_mixin_instanceGetter_inherited_fromGeneric_on_changeTypeArgument() async {
    configuration.withStreamResolvedUnitResults = false;
    await _runChangeScenarioTA(
      initialA: r'''
mixin A<T> {
  T get foo {}
}

mixin B on A<int> {}
''',
      testCode: r'''
import 'a.dart';
void f(B b) {
  b.foo;
}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredMixins
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        interface: #M3
          map
            foo: #M2
          implemented
            foo: #M2
      B: #M4
        interface: #M5
          map
            foo: #M2
          superImplemented
            [0]
              foo: #M2
          inherited
            foo: #M2
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M6
  requirements
    libraries
      package:test/a.dart
        exportedTopLevels
          B: #M4
          B=: <null>
        reExportDeprecatedOnly
          B: false
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M7
        exportedTopLevels
          B: #M4
          B=: <null>
        reExportDeprecatedOnly
          B: false
        instances
          A
            requestedDeclaredFields
              foo: #M1
        interfaces
          B
            methods
              foo: #M2
[status] idle
[future] getErrors T1
  ErrorsResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updatedA: r'''
mixin A<T> {
  T get foo {}
}

mixin B on A<double> {}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredMixins
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        interface: #M3
          map
            foo: #M2
          implemented
            foo: #M2
      B: #M8
        interface: #M9
          map
            foo: #M2
          superImplemented
            [0]
              foo: #M2
          inherited
            foo: #M2
  requirements
[operation] checkLinkedBundleRequirements
  package:test/test.dart
  topLevelIdMismatch
    libraryUri: package:test/a.dart
    name: B
    expectedId: #M4
    actualId: #M8
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M10
  requirements
    libraries
      package:test/a.dart
        exportedTopLevels
          B: #M8
          B=: <null>
        reExportDeprecatedOnly
          B: false
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  topLevelIdMismatch
    libraryUri: package:test/a.dart
    name: B
    expectedId: #M4
    actualId: #M8
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M7
        exportedTopLevels
          B: #M8
          B=: <null>
        reExportDeprecatedOnly
          B: false
        instances
          A
            requestedDeclaredFields
              foo: #M1
        interfaces
          B
            methods
              foo: #M2
[status] idle
[future] getErrors T2
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
    );
  }

  test_dependency_mixin_instanceMethod_add_invoked() async {
    configuration.withStreamResolvedUnitResults = false;
    await _runChangeScenarioTA(
      initialA: r'''
mixin A {}
''',
      testCode: r'''
import 'a.dart';
void f(A a) {
  a.foo();
}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredMixins
      A: #M0
        interface: #M1
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M2
  requirements
    libraries
      package:test/a.dart
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M3
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredGetters
              foo: <null>
            requestedDeclaredMethods
              foo: <null>
        interfaces
          A
            methods
              foo: <null>
              foo=: <null>
        exportedExtensions: []
[status] idle
[future] getErrors T1
  ErrorsResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
    errors
      35 +3 UNDEFINED_METHOD
''',
      updatedA: r'''
mixin A {
  int foo() {}
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredMixins
      A: #M0
        declaredMethods
          foo: #M4
        interface: #M5
          map
            foo: #M4
          implemented
            foo: #M4
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  instanceMethodIdMismatch
    libraryUri: package:test/a.dart
    interfaceName: A
    methodName: foo
    expectedId: <null>
    actualId: #M4
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M3
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        interfaces
          A
            methods
              foo: #M4
[status] idle
[future] getErrors T2
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
    );
  }

  test_dependency_mixin_instanceMethod_change_invoked() async {
    await _runChangeScenarioTA(
      initialA: r'''
mixin A {
  int foo() {}
}
''',
      testCode: r'''
import 'a.dart';
void f(A a) {
  a.foo();
}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredMixins
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M3
  requirements
    libraries
      package:test/a.dart
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M4
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        interfaces
          A
            methods
              foo: #M1
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updatedA: r'''
mixin A {
  double foo() {}
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredMixins
      A: #M0
        declaredMethods
          foo: #M5
        interface: #M6
          map
            foo: #M5
          implemented
            foo: #M5
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  instanceMethodIdMismatch
    libraryUri: package:test/a.dart
    interfaceName: A
    methodName: foo
    expectedId: #M1
    actualId: #M5
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M4
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        interfaces
          A
            methods
              foo: #M5
[status] idle
[future] getErrors T2
  ErrorsResult #3
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
    );
  }

  test_dependency_mixin_instanceMethod_change_notUsed() async {
    await _runChangeScenarioTA(
      initialA: r'''
mixin A {
  int foo() {}
  int bar() {}
}
''',
      testCode: r'''
import 'a.dart';
void f(A a) {
  a.foo();
}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredMixins
      A: #M0
        declaredMethods
          bar: #M1
          foo: #M2
        interface: #M3
          map
            bar: #M1
            foo: #M2
          implemented
            bar: #M1
            foo: #M2
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M4
  requirements
    libraries
      package:test/a.dart
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M5
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        interfaces
          A
            methods
              foo: #M2
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updatedA: r'''
mixin A {
  int foo() {}
  double bar() {}
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredMixins
      A: #M0
        declaredMethods
          bar: #M6
          foo: #M2
        interface: #M7
          map
            bar: #M6
            foo: #M2
          implemented
            bar: #M6
            foo: #M2
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] getErrorsFromBytes
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[status] idle
[future] getErrors T2
  ErrorsResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
    );
  }

  test_dependency_mixin_instanceMethod_inherited_fromGeneric_implements_changeTypeArgument() async {
    configuration.withStreamResolvedUnitResults = false;
    await _runChangeScenarioTA(
      initialA: r'''
mixin A<T> {
  T foo() {}
}

mixin B implements A<int> {}
''',
      testCode: r'''
import 'a.dart';
void f(B b) {
  b.foo();
}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredMixins
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
      B: #M3
        interface: #M4
          map
            foo: #M1
          inherited
            foo: #M1
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M5
  requirements
    libraries
      package:test/a.dart
        exportedTopLevels
          B: #M3
          B=: <null>
        reExportDeprecatedOnly
          B: false
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M6
        exportedTopLevels
          B: #M3
          B=: <null>
        reExportDeprecatedOnly
          B: false
        interfaces
          B
            methods
              foo: #M1
[status] idle
[future] getErrors T1
  ErrorsResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updatedA: r'''
mixin A<T> {
  T foo() {}
}

mixin B implements A<double> {}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredMixins
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
      B: #M7
        interface: #M8
          map
            foo: #M1
          inherited
            foo: #M1
  requirements
[operation] checkLinkedBundleRequirements
  package:test/test.dart
  topLevelIdMismatch
    libraryUri: package:test/a.dart
    name: B
    expectedId: #M3
    actualId: #M7
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M9
  requirements
    libraries
      package:test/a.dart
        exportedTopLevels
          B: #M7
          B=: <null>
        reExportDeprecatedOnly
          B: false
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  topLevelIdMismatch
    libraryUri: package:test/a.dart
    name: B
    expectedId: #M3
    actualId: #M7
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M6
        exportedTopLevels
          B: #M7
          B=: <null>
        reExportDeprecatedOnly
          B: false
        interfaces
          B
            methods
              foo: #M1
[status] idle
[future] getErrors T2
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
    );
  }

  test_dependency_mixin_instanceMethod_inherited_fromGeneric_on_changeTypeArgument() async {
    configuration.withStreamResolvedUnitResults = false;
    await _runChangeScenarioTA(
      initialA: r'''
mixin A<T> {
  T foo() {}
}

mixin B on A<int> {}
''',
      testCode: r'''
import 'a.dart';
void f(B b) {
  b.foo();
}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredMixins
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
      B: #M3
        interface: #M4
          map
            foo: #M1
          superImplemented
            [0]
              foo: #M1
          inherited
            foo: #M1
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M5
  requirements
    libraries
      package:test/a.dart
        exportedTopLevels
          B: #M3
          B=: <null>
        reExportDeprecatedOnly
          B: false
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M6
        exportedTopLevels
          B: #M3
          B=: <null>
        reExportDeprecatedOnly
          B: false
        interfaces
          B
            methods
              foo: #M1
[status] idle
[future] getErrors T1
  ErrorsResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updatedA: r'''
mixin A<T> {
  T foo() {}
}

mixin B on A<double> {}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredMixins
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
      B: #M7
        interface: #M8
          map
            foo: #M1
          superImplemented
            [0]
              foo: #M1
          inherited
            foo: #M1
  requirements
[operation] checkLinkedBundleRequirements
  package:test/test.dart
  topLevelIdMismatch
    libraryUri: package:test/a.dart
    name: B
    expectedId: #M3
    actualId: #M7
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M9
  requirements
    libraries
      package:test/a.dart
        exportedTopLevels
          B: #M7
          B=: <null>
        reExportDeprecatedOnly
          B: false
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  topLevelIdMismatch
    libraryUri: package:test/a.dart
    name: B
    expectedId: #M3
    actualId: #M7
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M6
        exportedTopLevels
          B: #M7
          B=: <null>
        reExportDeprecatedOnly
          B: false
        interfaces
          B
            methods
              foo: #M1
[status] idle
[future] getErrors T2
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
    );
  }

  test_dependency_mixin_instanceMethod_remove_invoked() async {
    configuration.withStreamResolvedUnitResults = false;
    await _runChangeScenarioTA(
      initialA: r'''
mixin A {
  void foo() {}
}
''',
      testCode: r'''
import 'a.dart';
void f(A a) {
  a.foo();
}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredMixins
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M3
  requirements
    libraries
      package:test/a.dart
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M4
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        interfaces
          A
            methods
              foo: #M1
[status] idle
[future] getErrors T1
  ErrorsResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updatedA: r'''
mixin A {}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredMixins
      A: #M0
        interface: #M5
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  instanceMethodIdMismatch
    libraryUri: package:test/a.dart
    interfaceName: A
    methodName: foo
    expectedId: #M1
    actualId: <null>
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M4
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredGetters
              foo: <null>
            requestedDeclaredMethods
              foo: <null>
        interfaces
          A
            methods
              foo: <null>
              foo=: <null>
        exportedExtensions: []
[status] idle
[future] getErrors T2
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
    errors
      35 +3 UNDEFINED_METHOD
''',
    );
  }

  test_dependency_mixin_instanceSetter_add_invoked() async {
    await _runChangeScenarioTA(
      initialA: r'''
mixin A {}
''',
      testCode: r'''
import 'a.dart';
void f(A a) {
  a.foo = 0;
}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredMixins
      A: #M0
        interface: #M1
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M2
  requirements
    libraries
      package:test/a.dart
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
    errors
      35 +3 UNDEFINED_SETTER
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M3
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredGetters
              foo: <null>
            requestedDeclaredSetters
              foo=: <null>
            requestedDeclaredMethods
              foo: <null>
        interfaces
          A
            methods
              foo: <null>
              foo=: <null>
        exportedExtensions: []
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
    errors
      35 +3 UNDEFINED_SETTER
''',
      updatedA: r'''
mixin A {
  set foo(int _) {}
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredMixins
      A: #M0
        declaredFields
          foo: #M4
        declaredSetters
          foo=: #M5
        interface: #M6
          map
            foo=: #M5
          implemented
            foo=: #M5
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  instanceMethodIdMismatch
    libraryUri: package:test/a.dart
    interfaceName: A
    methodName: foo=
    expectedId: <null>
    actualId: #M5
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M3
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredFields
              foo: #M4
        interfaces
          A
            methods
              foo=: #M5
[status] idle
[future] getErrors T2
  ErrorsResult #3
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
    );
  }

  test_dependency_mixin_instanceSetter_change_invoked() async {
    await _runChangeScenarioTA(
      initialA: r'''
mixin A {
  set foo(int _) {}
}
''',
      testCode: r'''
import 'a.dart';
void f(A a) {
  a.foo = 0;
}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredMixins
      A: #M0
        declaredFields
          foo: #M1
        declaredSetters
          foo=: #M2
        interface: #M3
          map
            foo=: #M2
          implemented
            foo=: #M2
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M4
  requirements
    libraries
      package:test/a.dart
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M5
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredFields
              foo: #M1
        interfaces
          A
            methods
              foo=: #M2
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updatedA: r'''
mixin A {
  set foo(double _) {}
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredMixins
      A: #M0
        declaredFields
          foo: #M6
        declaredSetters
          foo=: #M7
        interface: #M8
          map
            foo=: #M7
          implemented
            foo=: #M7
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  instanceFieldIdMismatch
    libraryUri: package:test/a.dart
    interfaceName: A
    fieldName: foo
    expectedId: #M1
    actualId: #M6
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M5
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredFields
              foo: #M6
        interfaces
          A
            methods
              foo=: #M7
[status] idle
[future] getErrors T2
  ErrorsResult #3
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
    );
  }

  test_dependency_mixin_instanceSetter_change_notUsed() async {
    await _runChangeScenarioTA(
      initialA: r'''
mixin A {
  set foo(int _) {}
  set bar(int _) {}
}
''',
      testCode: r'''
import 'a.dart';
void f(A a) {
  a.foo = 0;
}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredMixins
      A: #M0
        declaredFields
          bar: #M1
          foo: #M2
        declaredSetters
          bar=: #M3
          foo=: #M4
        interface: #M5
          map
            bar=: #M3
            foo=: #M4
          implemented
            bar=: #M3
            foo=: #M4
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M6
  requirements
    libraries
      package:test/a.dart
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M7
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredFields
              foo: #M2
        interfaces
          A
            methods
              foo=: #M4
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updatedA: r'''
mixin A {
  set foo(int _) {}
  set bar(double _) {}
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredMixins
      A: #M0
        declaredFields
          bar: #M8
          foo: #M2
        declaredSetters
          bar=: #M9
          foo=: #M4
        interface: #M10
          map
            bar=: #M9
            foo=: #M4
          implemented
            bar=: #M9
            foo=: #M4
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] getErrorsFromBytes
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[status] idle
[future] getErrors T2
  ErrorsResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
    );
  }

  test_dependency_mixin_instanceSetter_inherited_fromGeneric_on_changeTypeArgument() async {
    configuration.withStreamResolvedUnitResults = false;
    await _runChangeScenarioTA(
      initialA: r'''
mixin A<T> {
  set foo(T _) {}
}

mixin B on A<int> {}
''',
      testCode: r'''
import 'a.dart';
void f(B b) {
  b.foo = 0;
}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredMixins
      A: #M0
        declaredFields
          foo: #M1
        declaredSetters
          foo=: #M2
        interface: #M3
          map
            foo=: #M2
          implemented
            foo=: #M2
      B: #M4
        interface: #M5
          map
            foo=: #M2
          superImplemented
            [0]
              foo=: #M2
          inherited
            foo=: #M2
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M6
  requirements
    libraries
      package:test/a.dart
        exportedTopLevels
          B: #M4
          B=: <null>
        reExportDeprecatedOnly
          B: false
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M7
        exportedTopLevels
          B: #M4
          B=: <null>
        reExportDeprecatedOnly
          B: false
        instances
          A
            requestedDeclaredFields
              foo: #M1
        interfaces
          B
            methods
              foo=: #M2
[status] idle
[future] getErrors T1
  ErrorsResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updatedA: r'''
mixin A<T> {
  set foo(T _) {}
}

mixin B on A<double> {}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredMixins
      A: #M0
        declaredFields
          foo: #M1
        declaredSetters
          foo=: #M2
        interface: #M3
          map
            foo=: #M2
          implemented
            foo=: #M2
      B: #M8
        interface: #M9
          map
            foo=: #M2
          superImplemented
            [0]
              foo=: #M2
          inherited
            foo=: #M2
  requirements
[operation] checkLinkedBundleRequirements
  package:test/test.dart
  topLevelIdMismatch
    libraryUri: package:test/a.dart
    name: B
    expectedId: #M4
    actualId: #M8
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M10
  requirements
    libraries
      package:test/a.dart
        exportedTopLevels
          B: #M8
          B=: <null>
        reExportDeprecatedOnly
          B: false
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  topLevelIdMismatch
    libraryUri: package:test/a.dart
    name: B
    expectedId: #M4
    actualId: #M8
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M7
        exportedTopLevels
          B: #M8
          B=: <null>
        reExportDeprecatedOnly
          B: false
        instances
          A
            requestedDeclaredFields
              foo: #M1
        interfaces
          B
            methods
              foo=: #M2
[status] idle
[future] getErrors T2
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
    );
  }

  test_dependency_mixin_instanceSetter_remove_invoked() async {
    await _runChangeScenarioTA(
      initialA: r'''
mixin A {
  set foo(int _) {}
}
''',
      testCode: r'''
import 'a.dart';
void f(A a) {
  a.foo = 0;
}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredMixins
      A: #M0
        declaredFields
          foo: #M1
        declaredSetters
          foo=: #M2
        interface: #M3
          map
            foo=: #M2
          implemented
            foo=: #M2
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M4
  requirements
    libraries
      package:test/a.dart
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M5
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredFields
              foo: #M1
        interfaces
          A
            methods
              foo=: #M2
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updatedA: r'''
mixin A {}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredMixins
      A: #M0
        interface: #M6
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  instanceFieldIdMismatch
    libraryUri: package:test/a.dart
    interfaceName: A
    fieldName: foo
    expectedId: #M1
    actualId: <null>
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
    errors
      35 +3 UNDEFINED_SETTER
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M5
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredGetters
              foo: <null>
            requestedDeclaredSetters
              foo=: <null>
            requestedDeclaredMethods
              foo: <null>
        interfaces
          A
            methods
              foo: <null>
              foo=: <null>
        exportedExtensions: []
[status] idle
[future] getErrors T2
  ErrorsResult #3
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
    errors
      35 +3 UNDEFINED_SETTER
''',
    );
  }

  test_dependency_mixin_it_add() async {
    await _runChangeScenarioTA(
      initialA: '',
      testCode: r'''
import 'a.dart';
A foo() {}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      foo: #M0
  requirements
    libraries
      package:test/a.dart
        exportedTopLevels
          A: <null>
          A=: <null>
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
    errors
      17 +1 UNDEFINED_CLASS
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M1
        exportedTopLevels
          A: <null>
          A=: <null>
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
    errors
      17 +1 UNDEFINED_CLASS
''',
      updatedA: r'''
mixin A {}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredMixins
      A: #M2
        interface: #M3
  requirements
[operation] checkLinkedBundleRequirements
  package:test/test.dart
  topLevelIdMismatch
    libraryUri: package:test/a.dart
    name: A
    expectedId: <null>
    actualId: #M2
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      foo: #M4
  requirements
    libraries
      package:test/a.dart
        exportedTopLevels
          A: #M2
          A=: <null>
        reExportDeprecatedOnly
          A: false
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  topLevelIdMismatch
    libraryUri: package:test/a.dart
    name: A
    expectedId: <null>
    actualId: #M2
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
    errors
      19 +3 BODY_MIGHT_COMPLETE_NORMALLY
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M1
        exportedTopLevels
          A: #M2
          A=: <null>
        reExportDeprecatedOnly
          A: false
[status] idle
[future] getErrors T2
  ErrorsResult #3
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
    errors
      19 +3 BODY_MIGHT_COMPLETE_NORMALLY
''',
    );
  }

  test_dependency_mixin_it_add_notUsed() async {
    await _runChangeScenarioTA(
      initialA: r'''
mixin A {}
''',
      testCode: r'''
import 'a.dart';
A foo() {}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredMixins
      A: #M0
        interface: #M1
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      foo: #M2
  requirements
    libraries
      package:test/a.dart
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
    errors
      19 +3 BODY_MIGHT_COMPLETE_NORMALLY
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M3
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
    errors
      19 +3 BODY_MIGHT_COMPLETE_NORMALLY
''',
      updatedA: r'''
mixin A {}
mixin B {}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredMixins
      A: #M0
        interface: #M1
      B: #M4
        interface: #M5
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] getErrorsFromBytes
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[status] idle
[future] getErrors T2
  ErrorsResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
    errors
      19 +3 BODY_MIGHT_COMPLETE_NORMALLY
''',
    );
  }

  test_dependency_mixin_it_change() async {
    await _runChangeScenarioTA(
      initialA: r'''
mixin A {}
mixin B {}
''',
      testCode: r'''
import 'a.dart';
A foo() {}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredMixins
      A: #M0
        interface: #M1
      B: #M2
        interface: #M3
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      foo: #M4
  requirements
    libraries
      package:test/a.dart
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
    errors
      19 +3 BODY_MIGHT_COMPLETE_NORMALLY
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M5
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
    errors
      19 +3 BODY_MIGHT_COMPLETE_NORMALLY
''',
      updatedA: r'''
mixin A on B {}
mixin B {}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredMixins
      A: #M6
        interface: #M7
      B: #M2
        interface: #M3
  requirements
[operation] checkLinkedBundleRequirements
  package:test/test.dart
  topLevelIdMismatch
    libraryUri: package:test/a.dart
    name: A
    expectedId: #M0
    actualId: #M6
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      foo: #M8
  requirements
    libraries
      package:test/a.dart
        exportedTopLevels
          A: #M6
          A=: <null>
        reExportDeprecatedOnly
          A: false
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  topLevelIdMismatch
    libraryUri: package:test/a.dart
    name: A
    expectedId: #M0
    actualId: #M6
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
    errors
      19 +3 BODY_MIGHT_COMPLETE_NORMALLY
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M5
        exportedTopLevels
          A: #M6
          A=: <null>
        reExportDeprecatedOnly
          A: false
[status] idle
[future] getErrors T2
  ErrorsResult #3
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
    errors
      19 +3 BODY_MIGHT_COMPLETE_NORMALLY
''',
    );
  }

  test_dependency_mixin_it_change_notUsed() async {
    await _runChangeScenarioTA(
      initialA: r'''
mixin A {}
mixin B {}
mixin C {}
''',
      testCode: r'''
import 'a.dart';
A foo() {}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredMixins
      A: #M0
        interface: #M1
      B: #M2
        interface: #M3
      C: #M4
        interface: #M5
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      foo: #M6
  requirements
    libraries
      package:test/a.dart
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
    errors
      19 +3 BODY_MIGHT_COMPLETE_NORMALLY
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M7
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
    errors
      19 +3 BODY_MIGHT_COMPLETE_NORMALLY
''',
      updatedA: r'''
mixin A {}
mixin B on C {}
mixin C {}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredMixins
      A: #M0
        interface: #M1
      B: #M8
        interface: #M9
      C: #M4
        interface: #M5
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] getErrorsFromBytes
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[status] idle
[future] getErrors T2
  ErrorsResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
    errors
      19 +3 BODY_MIGHT_COMPLETE_NORMALLY
''',
    );
  }

  test_dependency_mixin_it_remove() async {
    await _runChangeScenarioTA(
      initialA: r'''
mixin A {}
''',
      testCode: r'''
import 'a.dart';
A foo() => throw 0;
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredMixins
      A: #M0
        interface: #M1
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      foo: #M2
  requirements
    libraries
      package:test/a.dart
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M3
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updatedA: '',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
  requirements
[operation] checkLinkedBundleRequirements
  package:test/test.dart
  topLevelIdMismatch
    libraryUri: package:test/a.dart
    name: A
    expectedId: #M0
    actualId: <null>
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      foo: #M4
  requirements
    libraries
      package:test/a.dart
        exportedTopLevels
          A: <null>
          A=: <null>
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  topLevelIdMismatch
    libraryUri: package:test/a.dart
    name: A
    expectedId: #M0
    actualId: <null>
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
    errors
      17 +1 UNDEFINED_CLASS
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M3
        exportedTopLevels
          A: <null>
          A=: <null>
[status] idle
[future] getErrors T2
  ErrorsResult #3
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
    errors
      17 +1 UNDEFINED_CLASS
''',
    );
  }

  test_dependency_mixin_it_remove_notUsed() async {
    await _runChangeScenarioTA(
      initialA: r'''
mixin A {}
mixin B {}
''',
      testCode: r'''
import 'a.dart';
A foo() => throw 0;
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredMixins
      A: #M0
        interface: #M1
      B: #M2
        interface: #M3
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      foo: #M4
  requirements
    libraries
      package:test/a.dart
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M5
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updatedA: r'''
mixin A {}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredMixins
      A: #M0
        interface: #M1
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] getErrorsFromBytes
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[status] idle
[future] getErrors T2
  ErrorsResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
    );
  }

  test_dependency_mixin_staticGetter_change_invoked() async {
    await _runChangeScenarioTA(
      initialA: r'''
mixin A {
  static int get foo {}
}
''',
      testCode: r'''
import 'a.dart';
void f() {
  A.foo;
}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredMixins
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        interface: #M3
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M4
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M5
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredFields
              foo: #M1
            requestedDeclaredGetters
              foo: #M2
        interfaces
          A
            requestedConstructors
              foo: <null>
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updatedA: r'''
mixin A {
  static double get foo {}
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredMixins
      A: #M0
        declaredFields
          foo: #M6
        declaredGetters
          foo: #M7
        interface: #M3
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  instanceFieldIdMismatch
    libraryUri: package:test/a.dart
    interfaceName: A
    fieldName: foo
    expectedId: #M1
    actualId: #M6
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M5
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredFields
              foo: #M6
            requestedDeclaredGetters
              foo: #M7
        interfaces
          A
            requestedConstructors
              foo: <null>
[status] idle
[future] getErrors T2
  ErrorsResult #3
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
    );
  }

  test_dependency_mixin_staticGetter_change_notUsed() async {
    await _runChangeScenarioTA(
      initialA: r'''
mixin A {
  static int get foo {}
  static int get bar {}
}
''',
      testCode: r'''
import 'a.dart';
void f() {
  A.foo;
}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredMixins
      A: #M0
        declaredFields
          bar: #M1
          foo: #M2
        declaredGetters
          bar: #M3
          foo: #M4
        interface: #M5
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M6
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M7
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredFields
              foo: #M2
            requestedDeclaredGetters
              foo: #M4
        interfaces
          A
            requestedConstructors
              foo: <null>
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updatedA: r'''
mixin A {
  static int get foo {}
  static double get bar {}
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredMixins
      A: #M0
        declaredFields
          bar: #M8
          foo: #M2
        declaredGetters
          bar: #M9
          foo: #M4
        interface: #M5
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] getErrorsFromBytes
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[status] idle
[future] getErrors T2
  ErrorsResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
    );
  }

  test_dependency_mixin_staticMethod_change_invoked() async {
    await _runChangeScenarioTA(
      initialA: r'''
mixin A {
  static int foo() {}
}
''',
      testCode: r'''
import 'a.dart';
void f() {
  A.foo();
}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredMixins
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M3
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M4
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredGetters
              foo: <null>
            requestedDeclaredMethods
              foo: #M1
        interfaces
          A
            requestedConstructors
              foo: <null>
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updatedA: r'''
mixin A {
  static double foo() {}
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredMixins
      A: #M0
        declaredMethods
          foo: #M5
        interface: #M2
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  instanceMethodIdMismatch
    libraryUri: package:test/a.dart
    interfaceName: A
    methodName: foo
    expectedId: #M1
    actualId: #M5
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M4
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredGetters
              foo: <null>
            requestedDeclaredMethods
              foo: #M5
        interfaces
          A
            requestedConstructors
              foo: <null>
[status] idle
[future] getErrors T2
  ErrorsResult #3
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
    );
  }

  test_dependency_mixin_staticMethod_change_notUsed() async {
    await _runChangeScenarioTA(
      initialA: r'''
mixin A {
  static int foo() {}
  static int bar() {}
}
''',
      testCode: r'''
import 'a.dart';
void f() {
  A.foo();
}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredMixins
      A: #M0
        declaredMethods
          bar: #M1
          foo: #M2
        interface: #M3
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M4
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M5
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredGetters
              foo: <null>
            requestedDeclaredMethods
              foo: #M2
        interfaces
          A
            requestedConstructors
              foo: <null>
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updatedA: r'''
mixin A {
  static int foo() {}
  static double bar() {}
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredMixins
      A: #M0
        declaredMethods
          bar: #M6
          foo: #M2
        interface: #M3
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] getErrorsFromBytes
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[status] idle
[future] getErrors T2
  ErrorsResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
    );
  }

  test_dependency_mixin_staticSetter_change_invoked() async {
    await _runChangeScenarioTA(
      initialA: r'''
mixin A {
  static set foo(int _) {}
}
''',
      testCode: r'''
import 'a.dart';
void f() {
  A.foo = 0;
}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredMixins
      A: #M0
        declaredFields
          foo: #M1
        declaredSetters
          foo=: #M2
        interface: #M3
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M4
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M5
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredFields
              foo: #M1
            requestedDeclaredSetters
              foo=: #M2
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updatedA: r'''
mixin A {
  static set foo(double _) {}
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredMixins
      A: #M0
        declaredFields
          foo: #M6
        declaredSetters
          foo=: #M7
        interface: #M3
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  instanceFieldIdMismatch
    libraryUri: package:test/a.dart
    interfaceName: A
    fieldName: foo
    expectedId: #M1
    actualId: #M6
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M5
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredFields
              foo: #M6
            requestedDeclaredSetters
              foo=: #M7
[status] idle
[future] getErrors T2
  ErrorsResult #3
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
    );
  }

  test_dependency_mixin_staticSetter_change_notUsed() async {
    await _runChangeScenarioTA(
      initialA: r'''
mixin A {
  static set foo(int _) {}
  static set bar(int _) {}
}
''',
      testCode: r'''
import 'a.dart';
void f() {
  A.foo = 0;
}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredMixins
      A: #M0
        declaredFields
          bar: #M1
          foo: #M2
        declaredSetters
          bar=: #M3
          foo=: #M4
        interface: #M5
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      f: #M6
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M7
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredFields
              foo: #M2
            requestedDeclaredSetters
              foo=: #M4
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updatedA: r'''
mixin A {
  static set foo(int _) {}
  static set bar(double _) {}
}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredMixins
      A: #M0
        declaredFields
          bar: #M8
          foo: #M2
        declaredSetters
          bar=: #M9
          foo=: #M4
        interface: #M5
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] getErrorsFromBytes
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[status] idle
[future] getErrors T2
  ErrorsResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
    );
  }

  test_dependency_notOpaque_baseClassImplementedOutsideOfLibrary() async {
    configuration.withStreamResolvedUnitResults = false;
    await _runChangeScenarioTA(
      initialA: r'''
base class A {}
''',
      testCode: r'''
import 'a.dart';
base class X implements A {}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        interface: #M1
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      X: #M2
        interface: #M3
  requirements
    libraries
      package:test/a.dart
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        interfaces
          A
            interfaceId: #M1
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M4
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            allDeclaredGetters: []
            allDeclaredSetters: []
            allDeclaredMethods: []
[status] idle
[future] getErrors T1
  ErrorsResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
    errors
      41 +1 INVALID_USE_OF_TYPE_OUTSIDE_LIBRARY
''',
      updatedA: r'''
base class A {}
class B {}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        interface: #M1
      B: #M5
        interface: #M6
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] getErrorsFromBytes
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[status] idle
[future] getErrors T2
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
    errors
      41 +1 INVALID_USE_OF_TYPE_OUTSIDE_LIBRARY
''',
    );
  }

  test_dependency_opaqueApiUse_firstFragment() async {
    _ManualRequirements.install((state) {
      var A = state.singleUnit.scopeInterfaceElement('A');
      A.firstFragment;
    });

    await _runChangeScenarioTA(
      initialA: r'''
class A {}
''',
      testCode: r'''
import 'a.dart';
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        interface: #M1
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
    errors
      7 +8 UNUSED_IMPORT
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M2
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
    opaqueApiUses
      ClassElementImpl.firstFragment
        targetElementLibraryUri: package:test/a.dart
        targetElementName: A
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
    errors
      7 +8 UNUSED_IMPORT
''',
      updatedA: r'''
class A {}
class B {}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        interface: #M1
      B: #M3
        interface: #M4
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  opaqueApiUseFailure
    ClassElementImpl.firstFragment
      targetElementLibraryUri: package:test/a.dart
      targetElementName: A
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
    errors
      7 +8 UNUSED_IMPORT
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M2
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
    opaqueApiUses
      ClassElementImpl.firstFragment
        targetElementLibraryUri: package:test/a.dart
        targetElementName: A
[status] idle
[future] getErrors T2
  ErrorsResult #3
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
    errors
      7 +8 UNUSED_IMPORT
''',
    );
  }

  test_dependency_topLevelFunction_change_invoked() async {
    await _runChangeScenarioTA(
      initialA: r'''
int foo() {}
''',
      testCode: r'''
import 'a.dart';
final x = foo();
''',
      operation: _FineOperationGetTestLibrary(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredFunctions
      foo: #M0
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      x: #M1
    declaredVariables
      x: #M2
  requirements
    libraries
      package:test/a.dart
        exportedTopLevels
          foo: #M0
          foo=: <null>
        reExportDeprecatedOnly
          foo: false
[status] idle
[future] getLibraryByUri T1
  library
    topLevelVariables
      final hasInitializer x
        type: int
''',
      updatedA: r'''
double foo() {}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredFunctions
      foo: #M3
  requirements
[operation] checkLinkedBundleRequirements
  package:test/test.dart
  topLevelIdMismatch
    libraryUri: package:test/a.dart
    name: foo
    expectedId: #M0
    actualId: #M3
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      x: #M4
    declaredVariables
      x: #M5
  requirements
    libraries
      package:test/a.dart
        exportedTopLevels
          foo: #M3
          foo=: <null>
        reExportDeprecatedOnly
          foo: false
[status] idle
[future] getLibraryByUri T2
  library
    topLevelVariables
      final hasInitializer x
        type: double
''',
    );
  }

  test_dependency_topLevelFunction_change_notUsed() async {
    await _runChangeScenarioTA(
      initialA: r'''
int foo() {}
int bar() {}
''',
      testCode: r'''
import 'a.dart';
final x = foo();
''',
      operation: _FineOperationGetTestLibrary(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredFunctions
      bar: #M0
      foo: #M1
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      x: #M2
    declaredVariables
      x: #M3
  requirements
    libraries
      package:test/a.dart
        exportedTopLevels
          foo: #M1
          foo=: <null>
        reExportDeprecatedOnly
          foo: false
[status] idle
[future] getLibraryByUri T1
  library
    topLevelVariables
      final hasInitializer x
        type: int
''',
      updatedA: r'''
int foo() {}
double bar() {}
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredFunctions
      bar: #M4
      foo: #M1
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[status] idle
[future] getLibraryByUri T2
  library
    topLevelVariables
      final hasInitializer x
        type: int
''',
    );
  }

  test_dependency_topLevelGetter_change_invoked() async {
    await _runChangeScenarioTA(
      initialA: r'''
int get a => 0;
''',
      testCode: r'''
import 'a.dart';
final x = a;
''',
      operation: _FineOperationGetTestLibrary(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredGetters
      a: #M0
    declaredVariables
      a: #M1
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      x: #M2
    declaredVariables
      x: #M3
  requirements
    libraries
      package:test/a.dart
        exportedTopLevels
          a: #M0
          a=: <null>
        reExportDeprecatedOnly
          a: false
[status] idle
[future] getLibraryByUri T1
  library
    topLevelVariables
      final hasInitializer x
        type: int
''',
      updatedA: r'''
double get a => 1.2;
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredGetters
      a: #M4
    declaredVariables
      a: #M5
  requirements
[operation] checkLinkedBundleRequirements
  package:test/test.dart
  topLevelIdMismatch
    libraryUri: package:test/a.dart
    name: a
    expectedId: #M0
    actualId: #M4
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      x: #M6
    declaredVariables
      x: #M7
  requirements
    libraries
      package:test/a.dart
        exportedTopLevels
          a: #M4
          a=: <null>
        reExportDeprecatedOnly
          a: false
[status] idle
[future] getLibraryByUri T2
  library
    topLevelVariables
      final hasInitializer x
        type: double
''',
    );
  }

  test_dependency_topLevelGetter_change_notUsed() async {
    await _runChangeScenarioTA(
      initialA: r'''
int get a => 0;
int get b => 0;
''',
      testCode: r'''
import 'a.dart';
final x = a;
''',
      operation: _FineOperationGetTestLibrary(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredGetters
      a: #M0
      b: #M1
    declaredVariables
      a: #M2
      b: #M3
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      x: #M4
    declaredVariables
      x: #M5
  requirements
    libraries
      package:test/a.dart
        exportedTopLevels
          a: #M0
          a=: <null>
        reExportDeprecatedOnly
          a: false
[status] idle
[future] getLibraryByUri T1
  library
    topLevelVariables
      final hasInitializer x
        type: int
''',
      updatedA: r'''
int get a => 0;
double get b => 1.2;
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredGetters
      a: #M0
      b: #M6
    declaredVariables
      a: #M2
      b: #M7
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[status] idle
[future] getLibraryByUri T2
  library
    topLevelVariables
      final hasInitializer x
        type: int
''',
    );
  }

  test_dependency_topLevelVariable_change_exported() async {
    var a = newFile('$testPackageLibPath/a.dart', r'''
final a = 0;
''');

    newFile('$testPackageLibPath/b.dart', r'''
export 'a.dart';
''');

    // Uses exported `a`.
    newFile('$testPackageLibPath/test.dart', r'''
import 'b.dart';
final x = a;
''');

    await _runChangeScenario(
      operation: _FineOperationGetTestLibrary(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredGetters
      a: #M0
    declaredVariables
      a: #M1
  requirements
[operation] linkLibraryCycle
  package:test/b.dart
    reExportMap
      a: #M0
    exportedLibraryUris: package:test/a.dart
  requirements
    exportRequirements
      package:test/b.dart
        exports
          package:test/a.dart
            a: #M0
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      x: #M2
    declaredVariables
      x: #M3
  requirements
    libraries
      package:test/b.dart
        exportedTopLevels
          a: #M0
          a=: <null>
        reExportDeprecatedOnly
          a: false
[status] idle
[future] getLibraryByUri T1
  library
    topLevelVariables
      final hasInitializer x
        type: int
''',
      // Change the initializer, now `double`.
      updateFiles: () {
        modifyFile2(a, r'''
final a = 1.2;
''');
        return [a];
      },
      // Linked, `x` has type `double`.
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredGetters
      a: #M4
    declaredVariables
      a: #M5
  requirements
[operation] checkLinkedBundleRequirements
  package:test/b.dart
  exportIdMismatch
    fragmentUri: package:test/b.dart
    exportedUri: package:test/a.dart
    name: a
    expectedId: #M0
    actualId: #M4
[operation] linkLibraryCycle
  package:test/b.dart
    reExportMap
      a: #M4
    exportedLibraryUris: package:test/a.dart
  requirements
    exportRequirements
      package:test/b.dart
        exports
          package:test/a.dart
            a: #M4
[operation] checkLinkedBundleRequirements
  package:test/test.dart
  topLevelIdMismatch
    libraryUri: package:test/b.dart
    name: a
    expectedId: #M0
    actualId: #M4
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      x: #M6
    declaredVariables
      x: #M7
  requirements
    libraries
      package:test/b.dart
        exportedTopLevels
          a: #M4
          a=: <null>
        reExportDeprecatedOnly
          a: false
[status] idle
[future] getLibraryByUri T2
  library
    topLevelVariables
      final hasInitializer x
        type: double
''',
    );
  }

  test_dependency_topLevelVariable_change_invoked() async {
    await _runChangeScenarioTA(
      initialA: r'''
final a = 0;
''',
      testCode: r'''
import 'a.dart';
final x = a;
''',
      operation: _FineOperationGetTestLibrary(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredGetters
      a: #M0
    declaredVariables
      a: #M1
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      x: #M2
    declaredVariables
      x: #M3
  requirements
    libraries
      package:test/a.dart
        exportedTopLevels
          a: #M0
          a=: <null>
        reExportDeprecatedOnly
          a: false
[status] idle
[future] getLibraryByUri T1
  library
    topLevelVariables
      final hasInitializer x
        type: int
''',
      // Change the initializer, now `double`.
      updatedA: r'''
final a = 1.2;
''',
      // Linked, `x` has type `double`.
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredGetters
      a: #M4
    declaredVariables
      a: #M5
  requirements
[operation] checkLinkedBundleRequirements
  package:test/test.dart
  topLevelIdMismatch
    libraryUri: package:test/a.dart
    name: a
    expectedId: #M0
    actualId: #M4
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      x: #M6
    declaredVariables
      x: #M7
  requirements
    libraries
      package:test/a.dart
        exportedTopLevels
          a: #M4
          a=: <null>
        reExportDeprecatedOnly
          a: false
[status] idle
[future] getLibraryByUri T2
  library
    topLevelVariables
      final hasInitializer x
        type: double
''',
    );
  }

  test_dependency_typeAlias_change_notUsed() async {
    await _runChangeScenarioTA(
      initialA: r'''
typedef A = int;
typedef B = int;
''',
      testCode: r'''
import 'a.dart';
void foo(A _) {}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredTypeAliases
      A: #M0
      B: #M1
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      foo: #M2
  requirements
    libraries
      package:test/a.dart
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M3
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updatedA: r'''
typedef A = int;
typedef B = double;
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredTypeAliases
      A: #M0
      B: #M4
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] getErrorsFromBytes
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[status] idle
[future] getErrors T2
  ErrorsResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
    );
  }

  test_dependency_typeAlias_change_referenced() async {
    await _runChangeScenarioTA(
      initialA: r'''
typedef A = int;
''',
      testCode: r'''
import 'a.dart';
void foo(A _) {}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredTypeAliases
      A: #M0
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      foo: #M1
  requirements
    libraries
      package:test/a.dart
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M2
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updatedA: r'''
typedef A = double;
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredTypeAliases
      A: #M3
  requirements
[operation] checkLinkedBundleRequirements
  package:test/test.dart
  topLevelIdMismatch
    libraryUri: package:test/a.dart
    name: A
    expectedId: #M0
    actualId: #M3
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      foo: #M4
  requirements
    libraries
      package:test/a.dart
        exportedTopLevels
          A: #M3
          A=: <null>
        reExportDeprecatedOnly
          A: false
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  topLevelIdMismatch
    libraryUri: package:test/a.dart
    name: A
    expectedId: #M0
    actualId: #M3
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M2
        exportedTopLevels
          A: #M3
          A=: <null>
        reExportDeprecatedOnly
          A: false
[status] idle
[future] getErrors T2
  ErrorsResult #3
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
    );
  }

  test_dependency_typeAlias_ofClass_constructor_change_invoked() async {
    await _runChangeScenarioTA(
      initialA: r'''
class A {
  A.named(int _);
}
typedef B = A;
''',
      testCode: r'''
import 'a.dart';
void foo() {
  B.named(0);
}
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredConstructors
          named: #M1
        interface: #M2
    declaredTypeAliases
      B: #M3
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      foo: #M4
  requirements
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M5
        exportedTopLevels
          B: #M3
          B=: <null>
        reExportDeprecatedOnly
          B: false
        interfaces
          A
            requestedConstructors
              named: #M1
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updatedA: r'''
class A {
  A.named(double _);
}
typedef B = A;
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredConstructors
          named: #M6
        interface: #M2
    declaredTypeAliases
      B: #M3
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  interfaceConstructorIdMismatch
    libraryUri: package:test/a.dart
    interfaceName: A
    constructorName: named
    expectedId: #M1
    actualId: #M6
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M5
        exportedTopLevels
          B: #M3
          B=: <null>
        reExportDeprecatedOnly
          B: false
        interfaces
          A
            requestedConstructors
              named: #M6
[status] idle
[future] getErrors T2
  ErrorsResult #3
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
    );
  }

  test_linkedBundleProvider_newBundleKey() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
final a = 0;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
    declaredVariables
      a: #M1
''',
      // Here `k02` is for `dart:core`.
      expectedInitialDriverState: r'''
files
  /home/test/lib/test.dart
    uri: package:test/test.dart
    current
      id: file_0
      kind: library_0
        libraryImports
          library_1 dart:core synthetic
        fileKinds: library_0
        cycle_0
          dependencies: dart:core
          libraries: library_0
          apiSignature_0
      unlinkedKey: k00
libraryCycles
  /home/test/lib/test.dart
    current: cycle_0
      key: k01
    get: []
    put: [k01]
linkedBundleProvider: [k01, k02]
elementFactory
  hasElement
    package:test/test.dart
''',
      // Add a part, this changes the linked bundle key.
      updateFiles: () {
        var a = newFile('$testPackageLibPath/a.dart', r'''
part of 'test.dart';
final b = 0;
''');
        return [a];
      },
      updatedCode: r'''
part 'a.dart';
final a = 0;
''',
      // So, we cannot find the existing library manifest.
      // So, we relink the library, and give new IDs.
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M2
      b: #M3
    declaredVariables
      a: #M4
      b: #M5
''',
      // Note a new bundle key is generated: k05
      // TODO(scheglov): Here is a memory leak: k01 is still present.
      expectedUpdatedDriverState: r'''
files
  /home/test/lib/a.dart
    uri: package:test/a.dart
    current
      id: file_6
      kind: partOfUriKnown_6
        uriFile: file_0
        library: library_7
      referencingFiles: file_0
      unlinkedKey: k03
  /home/test/lib/test.dart
    uri: package:test/test.dart
    current
      id: file_0
      kind: library_7
        libraryImports
          library_1 dart:core synthetic
        partIncludes
          partOfUriKnown_6
        fileKinds: library_7 partOfUriKnown_6
        cycle_2
          dependencies: dart:core
          libraries: library_7
          apiSignature_1
      unlinkedKey: k04
libraryCycles
  /home/test/lib/test.dart
    current: cycle_2
      key: k05
    get: []
    put: [k01, k05]
linkedBundleProvider: [k01, k02, k05]
elementFactory
  hasElement
    package:test/test.dart
''',
    );
  }

  test_linkedBundleProvider_sameBundleKey() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
final a = 0;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
    declaredVariables
      a: #M1
''',
      expectedInitialDriverState: r'''
files
  /home/test/lib/test.dart
    uri: package:test/test.dart
    current
      id: file_0
      kind: library_0
        libraryImports
          library_1 dart:core synthetic
        fileKinds: library_0
        cycle_0
          dependencies: dart:core
          libraries: library_0
          apiSignature_0
      unlinkedKey: k00
libraryCycles
  /home/test/lib/test.dart
    current: cycle_0
      key: k01
    get: []
    put: [k01]
linkedBundleProvider: [k01, k02]
elementFactory
  hasElement
    package:test/test.dart
''',
      updatedCode: r'''
final a = 0;
final b = 0;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
      b: #M2
    declaredVariables
      a: #M1
      b: #M3
''',
      expectedUpdatedDriverState: r'''
files
  /home/test/lib/test.dart
    uri: package:test/test.dart
    current
      id: file_0
      kind: library_6
        libraryImports
          library_1 dart:core synthetic
        fileKinds: library_6
        cycle_2
          dependencies: dart:core
          libraries: library_6
          apiSignature_1
      unlinkedKey: k03
libraryCycles
  /home/test/lib/test.dart
    current: cycle_2
      key: k01
    get: []
    put: [k01, k01]
linkedBundleProvider: [k01, k02]
elementFactory
  hasElement
    package:test/test.dart
''',
    );
  }

  test_manifest_baseName2_private2() async {
    newFile('$testPackageLibPath/a.dart', r'''
class A {
  void _foo() {}
}
''');

    await _runLibraryManifestScenario(
      initialCode: r'''
import 'a.dart';

class B extends A {
  int get _foo {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredMethods
          _foo: #M1
        interface: #M2
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      B: #M3
        declaredFields
          _foo: #M4
        declaredGetters
          _foo: #M5
        interface: #M6
''',
      updatedCode: r'''
import 'a.dart';

class B extends A {
  int get _foo {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      B: #M3
        declaredFields
          _foo: #M4
        declaredGetters
          _foo: #M5
        declaredMethods
          zzz: #M7
        interface: #M8
          map
            zzz: #M7
          implemented
            zzz: #M7
''',
    );
  }

  test_manifest_baseName2_private3() async {
    newFile('$testPackageLibPath/a.dart', r'''
import 'test.dart';

class B extends A {
  void _foo() {}
}
''');

    await _runLibraryManifestScenario(
      initialCode: r'''
import 'a.dart';

class A {
  int get _foo {}
}

class C extends B {
  set _foo(int _) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      B: #M0
        declaredMethods
          _foo: #M1
        interface: #M2
  package:test/test.dart
    declaredClasses
      A: #M3
        declaredFields
          _foo: #M4
        declaredGetters
          _foo: #M5
        interface: #M6
      C: #M7
        declaredFields
          _foo: #M8
        declaredSetters
          _foo=: #M9
        interface: #M10
''',
      updatedCode: r'''
import 'a.dart';

class A {
  int get _foo {}
}

class C extends B {
  set _foo(int _) {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      B: #M0
        declaredMethods
          _foo: #M1
        interface: #M2
  package:test/test.dart
    declaredClasses
      A: #M3
        declaredFields
          _foo: #M4
        declaredGetters
          _foo: #M5
        interface: #M6
      C: #M7
        declaredFields
          _foo: #M8
        declaredSetters
          _foo=: #M9
        declaredMethods
          zzz: #M11
        interface: #M12
          map
            zzz: #M11
          implemented
            zzz: #M11
''',
    );
  }

  test_manifest_baseName_declaredConstructor() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  A.foo();
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConstructors
          foo: #M1
        interface: #M2
''',
      updatedCode: r'''
class A {
  A.foo();
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          zzz: #M3
        declaredConstructors
          foo: #M1
        interface: #M4
          map
            zzz: #M3
          implemented
            zzz: #M3
''',
    );
  }

  test_manifest_baseName_declaredConstructor_declaredConstructor() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  A.foo();
  A.foo();
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConflicts
          foo: #M1
          foo=: #M1
        interface: #M2
''',
      updatedCode: r'''
class A {
  A.foo();
  A.foo();
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConflicts
          foo: #M3
          foo=: #M3
        declaredMethods
          zzz: #M4
        interface: #M5
          map
            zzz: #M4
          implemented
            zzz: #M4
''',
    );
  }

  test_manifest_baseName_declaredConstructor_declaredInstanceGetter() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  A.foo();
  int get foo {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        declaredConstructors
          foo: #M3
        interface: #M4
          map
            foo: #M2
          implemented
            foo: #M2
''',
      updatedCode: r'''
class A {
  A.foo();
  int get foo {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        declaredMethods
          zzz: #M5
        declaredConstructors
          foo: #M3
        interface: #M6
          map
            foo: #M2
            zzz: #M5
          implemented
            foo: #M2
            zzz: #M5
''',
    );
  }

  test_manifest_baseName_declaredConstructor_declaredInstanceGetter_declaredInstanceGetter() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  A.foo();
  int get foo {}
  int get foo {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConflicts
          foo: #M1
          foo=: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
''',
      updatedCode: r'''
class A {
  A.foo();
  int get foo {}
  int get foo {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConflicts
          foo: #M3
          foo=: #M3
        declaredMethods
          zzz: #M4
        interface: #M5
          map
            foo: #M3
            zzz: #M4
          implemented
            foo: #M3
            zzz: #M4
''',
    );
  }

  test_manifest_baseName_declaredConstructor_declaredInstanceGetter_declaredInstanceSetter() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  A.foo();
  int get foo {}
  set foo(int _) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        declaredSetters
          foo=: #M3
        declaredConstructors
          foo: #M4
        interface: #M5
          map
            foo: #M2
            foo=: #M3
          implemented
            foo: #M2
            foo=: #M3
''',
      updatedCode: r'''
class A {
  A.foo();
  int get foo {}
  set foo(int _) {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        declaredSetters
          foo=: #M3
        declaredMethods
          zzz: #M6
        declaredConstructors
          foo: #M4
        interface: #M7
          map
            foo: #M2
            foo=: #M3
            zzz: #M6
          implemented
            foo: #M2
            foo=: #M3
            zzz: #M6
''',
    );
  }

  test_manifest_baseName_declaredConstructor_declaredInstanceGetter_declaredInstanceSetter_declaredInstanceSetter() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  A.foo();
  int get foo {}
  set foo(int _) {}
  set foo(int _) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConflicts
          foo: #M1
          foo=: #M1
        interface: #M2
          map
            foo: #M1
            foo=: #M1
          implemented
            foo: #M1
            foo=: #M1
''',
      updatedCode: r'''
class A {
  A.foo();
  int get foo {}
  set foo(int _) {}
  set foo(int _) {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConflicts
          foo: #M3
          foo=: #M3
        declaredMethods
          zzz: #M4
        interface: #M5
          map
            foo: #M3
            foo=: #M3
            zzz: #M4
          implemented
            foo: #M3
            foo=: #M3
            zzz: #M4
''',
    );
  }

  test_manifest_baseName_declaredConstructor_declaredInstanceGetter_declaredInstanceSetter_inheritedInstanceGetter() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  int get foo {}
}

class B extends A {
  B.foo();
  int get foo {}
  set foo(int _) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        interface: #M3
          map
            foo: #M2
          implemented
            foo: #M2
      B: #M4
        declaredFields
          foo: #M5
        declaredGetters
          foo: #M6
        declaredSetters
          foo=: #M7
        declaredConstructors
          foo: #M8
        interface: #M9
          map
            foo: #M6
            foo=: #M7
          implemented
            foo: #M6
            foo=: #M7
          superImplemented
            [0]
              foo: #M2
          inherited
            foo: #M2
''',
      updatedCode: r'''
class A {
  int get foo {}
}

class B extends A {
  B.foo();
  int get foo {}
  set foo(int _) {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        interface: #M3
          map
            foo: #M2
          implemented
            foo: #M2
      B: #M4
        declaredFields
          foo: #M5
        declaredGetters
          foo: #M6
        declaredSetters
          foo=: #M7
        declaredMethods
          zzz: #M10
        declaredConstructors
          foo: #M8
        interface: #M11
          map
            foo: #M6
            foo=: #M7
            zzz: #M10
          implemented
            foo: #M6
            foo=: #M7
            zzz: #M10
          superImplemented
            [0]
              foo: #M2
          inherited
            foo: #M2
''',
    );
  }

  test_manifest_baseName_declaredConstructor_declaredInstanceGetter_declaredInstanceSetter_inheritedInstanceGetter_inheritedInstanceSetter() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  int get foo {}
  set foo(int _) {}
}

class B extends A {
  B.foo();
  int get foo {}
  set foo(int _) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        declaredSetters
          foo=: #M3
        interface: #M4
          map
            foo: #M2
            foo=: #M3
          implemented
            foo: #M2
            foo=: #M3
      B: #M5
        declaredFields
          foo: #M6
        declaredGetters
          foo: #M7
        declaredSetters
          foo=: #M8
        declaredConstructors
          foo: #M9
        interface: #M10
          map
            foo: #M7
            foo=: #M8
          implemented
            foo: #M7
            foo=: #M8
          superImplemented
            [0]
              foo: #M2
              foo=: #M3
          inherited
            foo: #M2
            foo=: #M3
''',
      updatedCode: r'''
class A {
  int get foo {}
  set foo(int _) {}
}

class B extends A {
  B.foo();
  int get foo {}
  set foo(int _) {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        declaredSetters
          foo=: #M3
        interface: #M4
          map
            foo: #M2
            foo=: #M3
          implemented
            foo: #M2
            foo=: #M3
      B: #M5
        declaredFields
          foo: #M6
        declaredGetters
          foo: #M7
        declaredSetters
          foo=: #M8
        declaredMethods
          zzz: #M11
        declaredConstructors
          foo: #M9
        interface: #M12
          map
            foo: #M7
            foo=: #M8
            zzz: #M11
          implemented
            foo: #M7
            foo=: #M8
            zzz: #M11
          superImplemented
            [0]
              foo: #M2
              foo=: #M3
          inherited
            foo: #M2
            foo=: #M3
''',
    );
  }

  test_manifest_baseName_declaredConstructor_declaredInstanceGetter_declaredInstanceSetter_inheritedInstanceMethod() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  void foo() {}
}

class B extends A {
  B.foo();
  int get foo {}
  set foo(int _) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
      B: #M3
        declaredFields
          foo: #M4
        declaredGetters
          foo: #M5
        declaredSetters
          foo=: #M6
        declaredConstructors
          foo: #M7
        interface: #M8
          map
            foo: #M5
            foo=: #M6
          implemented
            foo: #M5
            foo=: #M6
          superImplemented
            [0]
              foo: #M1
          inherited
            foo: #M1
''',
      updatedCode: r'''
class A {
  void foo() {}
}

class B extends A {
  B.foo();
  int get foo {}
  set foo(int _) {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
      B: #M3
        declaredFields
          foo: #M4
        declaredGetters
          foo: #M5
        declaredSetters
          foo=: #M6
        declaredMethods
          zzz: #M9
        declaredConstructors
          foo: #M7
        interface: #M10
          map
            foo: #M5
            foo=: #M6
            zzz: #M9
          implemented
            foo: #M5
            foo=: #M6
            zzz: #M9
          superImplemented
            [0]
              foo: #M1
          inherited
            foo: #M1
''',
    );
  }

  test_manifest_baseName_declaredConstructor_declaredInstanceGetter_declaredInstanceSetter_inheritedInstanceSetter() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  set foo(int _) {}
}

class B extends A {
  B.foo();
  int get foo {}
  set foo(int _) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredSetters
          foo=: #M2
        interface: #M3
          map
            foo=: #M2
          implemented
            foo=: #M2
      B: #M4
        declaredFields
          foo: #M5
        declaredGetters
          foo: #M6
        declaredSetters
          foo=: #M7
        declaredConstructors
          foo: #M8
        interface: #M9
          map
            foo: #M6
            foo=: #M7
          implemented
            foo: #M6
            foo=: #M7
          superImplemented
            [0]
              foo=: #M2
          inherited
            foo=: #M2
''',
      updatedCode: r'''
class A {
  set foo(int _) {}
}

class B extends A {
  B.foo();
  int get foo {}
  set foo(int _) {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredSetters
          foo=: #M2
        interface: #M3
          map
            foo=: #M2
          implemented
            foo=: #M2
      B: #M4
        declaredFields
          foo: #M5
        declaredGetters
          foo: #M6
        declaredSetters
          foo=: #M7
        declaredMethods
          zzz: #M10
        declaredConstructors
          foo: #M8
        interface: #M11
          map
            foo: #M6
            foo=: #M7
            zzz: #M10
          implemented
            foo: #M6
            foo=: #M7
            zzz: #M10
          superImplemented
            [0]
              foo=: #M2
          inherited
            foo=: #M2
''',
    );
  }

  test_manifest_baseName_declaredConstructor_declaredInstanceGetter_declaredStaticSetter() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  A.foo();
  int get foo {}
  static set foo(int _) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConflicts
          foo: #M1
          foo=: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
''',
      updatedCode: r'''
class A {
  A.foo();
  int get foo {}
  static set foo(int _) {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConflicts
          foo: #M3
          foo=: #M3
        declaredMethods
          zzz: #M4
        interface: #M5
          map
            foo: #M3
            zzz: #M4
          implemented
            foo: #M3
            zzz: #M4
''',
    );
  }

  test_manifest_baseName_declaredConstructor_declaredInstanceGetter_declaredStaticSetter_inheritedInstanceGetter() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  int get foo {}
}

class B extends A {
  B.foo();
  int get foo {}
  static set foo(int _) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        interface: #M3
          map
            foo: #M2
          implemented
            foo: #M2
      B: #M4
        declaredConflicts
          foo: #M5
          foo=: #M5
        interface: #M6
          map
            foo: #M5
          implemented
            foo: #M5
          superImplemented
            [0]
              foo: #M2
          inherited
            foo: #M2
''',
      updatedCode: r'''
class A {
  int get foo {}
}

class B extends A {
  B.foo();
  int get foo {}
  static set foo(int _) {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        interface: #M3
          map
            foo: #M2
          implemented
            foo: #M2
      B: #M4
        declaredConflicts
          foo: #M7
          foo=: #M7
        declaredMethods
          zzz: #M8
        interface: #M9
          map
            foo: #M7
            zzz: #M8
          implemented
            foo: #M7
            zzz: #M8
          superImplemented
            [0]
              foo: #M2
          inherited
            foo: #M2
''',
    );
  }

  test_manifest_baseName_declaredConstructor_declaredInstanceGetter_declaredStaticSetter_inheritedInstanceGetter_inheritedInstanceSetter() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  int get foo {}
  set foo(int _) {}
}

class B extends A {
  B.foo();
  int get foo {}
  static set foo(int _) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        declaredSetters
          foo=: #M3
        interface: #M4
          map
            foo: #M2
            foo=: #M3
          implemented
            foo: #M2
            foo=: #M3
      B: #M5
        declaredConflicts
          foo: #M6
          foo=: #M6
        interface: #M7
          map
            foo: #M6
            foo=: #M3
          implemented
            foo: #M6
            foo=: #M3
          superImplemented
            [0]
              foo: #M2
              foo=: #M3
          inherited
            foo: #M2
            foo=: #M3
''',
      updatedCode: r'''
class A {
  int get foo {}
  set foo(int _) {}
}

class B extends A {
  B.foo();
  int get foo {}
  static set foo(int _) {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        declaredSetters
          foo=: #M3
        interface: #M4
          map
            foo: #M2
            foo=: #M3
          implemented
            foo: #M2
            foo=: #M3
      B: #M5
        declaredConflicts
          foo: #M8
          foo=: #M8
        declaredMethods
          zzz: #M9
        interface: #M10
          map
            foo: #M8
            foo=: #M3
            zzz: #M9
          implemented
            foo: #M8
            foo=: #M3
            zzz: #M9
          superImplemented
            [0]
              foo: #M2
              foo=: #M3
          inherited
            foo: #M2
            foo=: #M3
''',
    );
  }

  test_manifest_baseName_declaredConstructor_declaredInstanceGetter_declaredStaticSetter_inheritedInstanceMethod() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  void foo() {}
}

class B extends A {
  B.foo();
  int get foo {}
  static set foo(int _) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
      B: #M3
        declaredConflicts
          foo: #M4
          foo=: #M4
        interface: #M5
          map
            foo: #M4
          implemented
            foo: #M4
          superImplemented
            [0]
              foo: #M1
          inherited
            foo: #M1
''',
      updatedCode: r'''
class A {
  void foo() {}
}

class B extends A {
  B.foo();
  int get foo {}
  static set foo(int _) {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
      B: #M3
        declaredConflicts
          foo: #M6
          foo=: #M6
        declaredMethods
          zzz: #M7
        interface: #M8
          map
            foo: #M6
            zzz: #M7
          implemented
            foo: #M6
            zzz: #M7
          superImplemented
            [0]
              foo: #M1
          inherited
            foo: #M1
''',
    );
  }

  test_manifest_baseName_declaredConstructor_declaredInstanceGetter_declaredStaticSetter_inheritedInstanceSetter() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  set foo(int _) {}
}

class B extends A {
  B.foo();
  int get foo {}
  static set foo(int _) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredSetters
          foo=: #M2
        interface: #M3
          map
            foo=: #M2
          implemented
            foo=: #M2
      B: #M4
        declaredConflicts
          foo: #M5
          foo=: #M5
        interface: #M6
          map
            foo: #M5
            foo=: #M2
          implemented
            foo: #M5
            foo=: #M2
          superImplemented
            [0]
              foo=: #M2
          inherited
            foo=: #M2
''',
      updatedCode: r'''
class A {
  set foo(int _) {}
}

class B extends A {
  B.foo();
  int get foo {}
  static set foo(int _) {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredSetters
          foo=: #M2
        interface: #M3
          map
            foo=: #M2
          implemented
            foo=: #M2
      B: #M4
        declaredConflicts
          foo: #M7
          foo=: #M7
        declaredMethods
          zzz: #M8
        interface: #M9
          map
            foo: #M7
            foo=: #M2
            zzz: #M8
          implemented
            foo: #M7
            foo=: #M2
            zzz: #M8
          superImplemented
            [0]
              foo=: #M2
          inherited
            foo=: #M2
''',
    );
  }

  test_manifest_baseName_declaredConstructor_declaredInstanceGetter_inheritedInstanceGetter() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  int get foo {}
}

class B extends A {
  B.foo();
  int get foo {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        interface: #M3
          map
            foo: #M2
          implemented
            foo: #M2
      B: #M4
        declaredFields
          foo: #M5
        declaredGetters
          foo: #M6
        declaredConstructors
          foo: #M7
        interface: #M8
          map
            foo: #M6
          implemented
            foo: #M6
          superImplemented
            [0]
              foo: #M2
          inherited
            foo: #M2
''',
      updatedCode: r'''
class A {
  int get foo {}
}

class B extends A {
  B.foo();
  int get foo {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        interface: #M3
          map
            foo: #M2
          implemented
            foo: #M2
      B: #M4
        declaredFields
          foo: #M5
        declaredGetters
          foo: #M6
        declaredMethods
          zzz: #M9
        declaredConstructors
          foo: #M7
        interface: #M10
          map
            foo: #M6
            zzz: #M9
          implemented
            foo: #M6
            zzz: #M9
          superImplemented
            [0]
              foo: #M2
          inherited
            foo: #M2
''',
    );
  }

  test_manifest_baseName_declaredConstructor_declaredInstanceGetter_inheritedInstanceGetter_inheritedInstanceSetter() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  int get foo {}
  set foo(int _) {}
}

class B extends A {
  B.foo();
  int get foo {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        declaredSetters
          foo=: #M3
        interface: #M4
          map
            foo: #M2
            foo=: #M3
          implemented
            foo: #M2
            foo=: #M3
      B: #M5
        declaredFields
          foo: #M6
        declaredGetters
          foo: #M7
        declaredConstructors
          foo: #M8
        interface: #M9
          map
            foo: #M7
            foo=: #M3
          implemented
            foo: #M7
            foo=: #M3
          superImplemented
            [0]
              foo: #M2
              foo=: #M3
          inherited
            foo: #M2
            foo=: #M3
''',
      updatedCode: r'''
class A {
  int get foo {}
  set foo(int _) {}
}

class B extends A {
  B.foo();
  int get foo {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        declaredSetters
          foo=: #M3
        interface: #M4
          map
            foo: #M2
            foo=: #M3
          implemented
            foo: #M2
            foo=: #M3
      B: #M5
        declaredFields
          foo: #M6
        declaredGetters
          foo: #M7
        declaredMethods
          zzz: #M10
        declaredConstructors
          foo: #M8
        interface: #M11
          map
            foo: #M7
            foo=: #M3
            zzz: #M10
          implemented
            foo: #M7
            foo=: #M3
            zzz: #M10
          superImplemented
            [0]
              foo: #M2
              foo=: #M3
          inherited
            foo: #M2
            foo=: #M3
''',
    );
  }

  test_manifest_baseName_declaredConstructor_declaredInstanceGetter_inheritedInstanceMethod() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  void foo() {}
}

class B extends A {
  B.foo();
  int get foo {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
      B: #M3
        declaredFields
          foo: #M4
        declaredGetters
          foo: #M5
        declaredConstructors
          foo: #M6
        interface: #M7
          map
            foo: #M5
          implemented
            foo: #M5
          superImplemented
            [0]
              foo: #M1
          inherited
            foo: #M1
''',
      updatedCode: r'''
class A {
  void foo() {}
}

class B extends A {
  B.foo();
  int get foo {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
      B: #M3
        declaredFields
          foo: #M4
        declaredGetters
          foo: #M5
        declaredMethods
          zzz: #M8
        declaredConstructors
          foo: #M6
        interface: #M9
          map
            foo: #M5
            zzz: #M8
          implemented
            foo: #M5
            zzz: #M8
          superImplemented
            [0]
              foo: #M1
          inherited
            foo: #M1
''',
    );
  }

  test_manifest_baseName_declaredConstructor_declaredInstanceGetter_inheritedInstanceSetter() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  set foo(int _) {}
}

class B extends A {
  B.foo();
  int get foo {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredSetters
          foo=: #M2
        interface: #M3
          map
            foo=: #M2
          implemented
            foo=: #M2
      B: #M4
        declaredFields
          foo: #M5
        declaredGetters
          foo: #M6
        declaredConstructors
          foo: #M7
        interface: #M8
          map
            foo: #M6
            foo=: #M2
          implemented
            foo: #M6
            foo=: #M2
          superImplemented
            [0]
              foo=: #M2
          inherited
            foo=: #M2
''',
      updatedCode: r'''
class A {
  set foo(int _) {}
}

class B extends A {
  B.foo();
  int get foo {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredSetters
          foo=: #M2
        interface: #M3
          map
            foo=: #M2
          implemented
            foo=: #M2
      B: #M4
        declaredFields
          foo: #M5
        declaredGetters
          foo: #M6
        declaredMethods
          zzz: #M9
        declaredConstructors
          foo: #M7
        interface: #M10
          map
            foo: #M6
            foo=: #M2
            zzz: #M9
          implemented
            foo: #M6
            foo=: #M2
            zzz: #M9
          superImplemented
            [0]
              foo=: #M2
          inherited
            foo=: #M2
''',
    );
  }

  test_manifest_baseName_declaredConstructor_declaredInstanceMethod() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  A.foo();
  void foo() {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        declaredConstructors
          foo: #M2
        interface: #M3
          map
            foo: #M1
          implemented
            foo: #M1
''',
      updatedCode: r'''
class A {
  A.foo();
  void foo() {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
          zzz: #M4
        declaredConstructors
          foo: #M2
        interface: #M5
          map
            foo: #M1
            zzz: #M4
          implemented
            foo: #M1
            zzz: #M4
''',
    );
  }

  test_manifest_baseName_declaredConstructor_declaredInstanceMethod_declaredInstanceGetter() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  A.foo();
  void foo() {}
  int get foo {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConflicts
          foo: #M1
          foo=: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
''',
      updatedCode: r'''
class A {
  A.foo();
  void foo() {}
  int get foo {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConflicts
          foo: #M3
          foo=: #M3
        declaredMethods
          zzz: #M4
        interface: #M5
          map
            foo: #M3
            zzz: #M4
          implemented
            foo: #M3
            zzz: #M4
''',
    );
  }

  test_manifest_baseName_declaredConstructor_declaredInstanceMethod_declaredInstanceGetter_declaredInstanceGetter() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  A.foo();
  void foo() {}
  int get foo {}
  int get foo {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConflicts
          foo: #M1
          foo=: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
''',
      updatedCode: r'''
class A {
  A.foo();
  void foo() {}
  int get foo {}
  int get foo {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConflicts
          foo: #M3
          foo=: #M3
        declaredMethods
          zzz: #M4
        interface: #M5
          map
            foo: #M3
            zzz: #M4
          implemented
            foo: #M3
            zzz: #M4
''',
    );
  }

  test_manifest_baseName_declaredConstructor_declaredInstanceMethod_declaredInstanceGetter_declaredInstanceSetter() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  A.foo();
  void foo() {}
  int get foo {}
  set foo(int _) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConflicts
          foo: #M1
          foo=: #M1
        interface: #M2
          map
            foo: #M1
            foo=: #M1
          implemented
            foo: #M1
            foo=: #M1
''',
      updatedCode: r'''
class A {
  A.foo();
  void foo() {}
  int get foo {}
  set foo(int _) {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConflicts
          foo: #M3
          foo=: #M3
        declaredMethods
          zzz: #M4
        interface: #M5
          map
            foo: #M3
            foo=: #M3
            zzz: #M4
          implemented
            foo: #M3
            foo=: #M3
            zzz: #M4
''',
    );
  }

  test_manifest_baseName_declaredConstructor_declaredInstanceMethod_declaredInstanceMethod() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  A.foo();
  void foo() {}
  void foo() {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConflicts
          foo: #M1
          foo=: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
''',
      updatedCode: r'''
class A {
  A.foo();
  void foo() {}
  void foo() {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConflicts
          foo: #M3
          foo=: #M3
        declaredMethods
          zzz: #M4
        interface: #M5
          map
            foo: #M3
            zzz: #M4
          implemented
            foo: #M3
            zzz: #M4
''',
    );
  }

  test_manifest_baseName_declaredConstructor_declaredInstanceMethod_declaredInstanceSetter() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  A.foo();
  void foo() {}
  set foo(int _) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConflicts
          foo: #M1
          foo=: #M1
        interface: #M2
          map
            foo: #M1
            foo=: #M1
          implemented
            foo: #M1
            foo=: #M1
''',
      updatedCode: r'''
class A {
  A.foo();
  void foo() {}
  set foo(int _) {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConflicts
          foo: #M3
          foo=: #M3
        declaredMethods
          zzz: #M4
        interface: #M5
          map
            foo: #M3
            foo=: #M3
            zzz: #M4
          implemented
            foo: #M3
            foo=: #M3
            zzz: #M4
''',
    );
  }

  test_manifest_baseName_declaredConstructor_declaredInstanceMethod_declaredInstanceSetter_declaredInstanceSetter() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  A.foo();
  void foo() {}
  set foo(int _) {}
  set foo(int _) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConflicts
          foo: #M1
          foo=: #M1
        interface: #M2
          map
            foo: #M1
            foo=: #M1
          implemented
            foo: #M1
            foo=: #M1
''',
      updatedCode: r'''
class A {
  A.foo();
  void foo() {}
  set foo(int _) {}
  set foo(int _) {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConflicts
          foo: #M3
          foo=: #M3
        declaredMethods
          zzz: #M4
        interface: #M5
          map
            foo: #M3
            foo=: #M3
            zzz: #M4
          implemented
            foo: #M3
            foo=: #M3
            zzz: #M4
''',
    );
  }

  test_manifest_baseName_declaredConstructor_declaredInstanceMethod_inheritedInstanceGetter() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  int get foo {}
}

class B extends A {
  B.foo();
  void foo() {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        interface: #M3
          map
            foo: #M2
          implemented
            foo: #M2
      B: #M4
        declaredMethods
          foo: #M5
        declaredConstructors
          foo: #M6
        interface: #M7
          map
            foo: #M5
          implemented
            foo: #M5
          superImplemented
            [0]
              foo: #M2
          inherited
            foo: #M2
''',
      updatedCode: r'''
class A {
  int get foo {}
}

class B extends A {
  B.foo();
  void foo() {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        interface: #M3
          map
            foo: #M2
          implemented
            foo: #M2
      B: #M4
        declaredMethods
          foo: #M5
          zzz: #M8
        declaredConstructors
          foo: #M6
        interface: #M9
          map
            foo: #M5
            zzz: #M8
          implemented
            foo: #M5
            zzz: #M8
          superImplemented
            [0]
              foo: #M2
          inherited
            foo: #M2
''',
    );
  }

  test_manifest_baseName_declaredConstructor_declaredInstanceMethod_inheritedInstanceGetter_inheritedInstanceSetter() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  int get foo {}
  set foo(int _) {}
}

class B extends A {
  B.foo();
  void foo() {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        declaredSetters
          foo=: #M3
        interface: #M4
          map
            foo: #M2
            foo=: #M3
          implemented
            foo: #M2
            foo=: #M3
      B: #M5
        declaredMethods
          foo: #M6
        declaredConstructors
          foo: #M7
        interface: #M8
          map
            foo: #M6
            foo=: #M3
          implemented
            foo: #M6
            foo=: #M3
          superImplemented
            [0]
              foo: #M2
              foo=: #M3
          inherited
            foo: #M2
            foo=: #M3
''',
      updatedCode: r'''
class A {
  int get foo {}
  set foo(int _) {}
}

class B extends A {
  B.foo();
  void foo() {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        declaredSetters
          foo=: #M3
        interface: #M4
          map
            foo: #M2
            foo=: #M3
          implemented
            foo: #M2
            foo=: #M3
      B: #M5
        declaredMethods
          foo: #M6
          zzz: #M9
        declaredConstructors
          foo: #M7
        interface: #M10
          map
            foo: #M6
            foo=: #M3
            zzz: #M9
          implemented
            foo: #M6
            foo=: #M3
            zzz: #M9
          superImplemented
            [0]
              foo: #M2
              foo=: #M3
          inherited
            foo: #M2
            foo=: #M3
''',
    );
  }

  test_manifest_baseName_declaredConstructor_declaredInstanceMethod_inheritedInstanceMethod() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  void foo() {}
}

class B extends A {
  B.foo();
  void foo() {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
      B: #M3
        declaredMethods
          foo: #M4
        declaredConstructors
          foo: #M5
        interface: #M6
          map
            foo: #M4
          implemented
            foo: #M4
          superImplemented
            [0]
              foo: #M1
          inherited
            foo: #M1
''',
      updatedCode: r'''
class A {
  void foo() {}
}

class B extends A {
  B.foo();
  void foo() {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
      B: #M3
        declaredMethods
          foo: #M4
          zzz: #M7
        declaredConstructors
          foo: #M5
        interface: #M8
          map
            foo: #M4
            zzz: #M7
          implemented
            foo: #M4
            zzz: #M7
          superImplemented
            [0]
              foo: #M1
          inherited
            foo: #M1
''',
    );
  }

  test_manifest_baseName_declaredConstructor_declaredInstanceMethod_inheritedInstanceSetter() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  set foo(int _) {}
}

class B extends A {
  B.foo();
  void foo() {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredSetters
          foo=: #M2
        interface: #M3
          map
            foo=: #M2
          implemented
            foo=: #M2
      B: #M4
        declaredMethods
          foo: #M5
        declaredConstructors
          foo: #M6
        interface: #M7
          map
            foo: #M5
            foo=: #M2
          implemented
            foo: #M5
            foo=: #M2
          superImplemented
            [0]
              foo=: #M2
          inherited
            foo=: #M2
''',
      updatedCode: r'''
class A {
  set foo(int _) {}
}

class B extends A {
  B.foo();
  void foo() {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredSetters
          foo=: #M2
        interface: #M3
          map
            foo=: #M2
          implemented
            foo=: #M2
      B: #M4
        declaredMethods
          foo: #M5
          zzz: #M8
        declaredConstructors
          foo: #M6
        interface: #M9
          map
            foo: #M5
            foo=: #M2
            zzz: #M8
          implemented
            foo: #M5
            foo=: #M2
            zzz: #M8
          superImplemented
            [0]
              foo=: #M2
          inherited
            foo=: #M2
''',
    );
  }

  test_manifest_baseName_declaredConstructor_declaredInstanceSetter() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  A.foo();
  set foo(int _) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredSetters
          foo=: #M2
        declaredConstructors
          foo: #M3
        interface: #M4
          map
            foo=: #M2
          implemented
            foo=: #M2
''',
      updatedCode: r'''
class A {
  A.foo();
  set foo(int _) {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredSetters
          foo=: #M2
        declaredMethods
          zzz: #M5
        declaredConstructors
          foo: #M3
        interface: #M6
          map
            foo=: #M2
            zzz: #M5
          implemented
            foo=: #M2
            zzz: #M5
''',
    );
  }

  test_manifest_baseName_declaredConstructor_declaredInstanceSetter_declaredInstanceSetter() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  A.foo();
  set foo(int _) {}
  set foo(int _) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConflicts
          foo: #M1
          foo=: #M1
        interface: #M2
          map
            foo=: #M1
          implemented
            foo=: #M1
''',
      updatedCode: r'''
class A {
  A.foo();
  set foo(int _) {}
  set foo(int _) {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConflicts
          foo: #M3
          foo=: #M3
        declaredMethods
          zzz: #M4
        interface: #M5
          map
            foo=: #M3
            zzz: #M4
          implemented
            foo=: #M3
            zzz: #M4
''',
    );
  }

  test_manifest_baseName_declaredConstructor_declaredInstanceSetter_inheritedInstanceGetter() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  int get foo {}
}

class B extends A {
  B.foo();
  set foo(int _) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        interface: #M3
          map
            foo: #M2
          implemented
            foo: #M2
      B: #M4
        declaredFields
          foo: #M5
        declaredSetters
          foo=: #M6
        declaredConstructors
          foo: #M7
        interface: #M8
          map
            foo: #M2
            foo=: #M6
          implemented
            foo: #M2
            foo=: #M6
          superImplemented
            [0]
              foo: #M2
          inherited
            foo: #M2
''',
      updatedCode: r'''
class A {
  int get foo {}
}

class B extends A {
  B.foo();
  set foo(int _) {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        interface: #M3
          map
            foo: #M2
          implemented
            foo: #M2
      B: #M4
        declaredFields
          foo: #M5
        declaredSetters
          foo=: #M6
        declaredMethods
          zzz: #M9
        declaredConstructors
          foo: #M7
        interface: #M10
          map
            foo: #M2
            foo=: #M6
            zzz: #M9
          implemented
            foo: #M2
            foo=: #M6
            zzz: #M9
          superImplemented
            [0]
              foo: #M2
          inherited
            foo: #M2
''',
    );
  }

  test_manifest_baseName_declaredConstructor_declaredInstanceSetter_inheritedInstanceGetter_inheritedInstanceSetter() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  int get foo {}
  set foo(int _) {}
}

class B extends A {
  B.foo();
  set foo(int _) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        declaredSetters
          foo=: #M3
        interface: #M4
          map
            foo: #M2
            foo=: #M3
          implemented
            foo: #M2
            foo=: #M3
      B: #M5
        declaredFields
          foo: #M6
        declaredSetters
          foo=: #M7
        declaredConstructors
          foo: #M8
        interface: #M9
          map
            foo: #M2
            foo=: #M7
          implemented
            foo: #M2
            foo=: #M7
          superImplemented
            [0]
              foo: #M2
              foo=: #M3
          inherited
            foo: #M2
            foo=: #M3
''',
      updatedCode: r'''
class A {
  int get foo {}
  set foo(int _) {}
}

class B extends A {
  B.foo();
  set foo(int _) {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        declaredSetters
          foo=: #M3
        interface: #M4
          map
            foo: #M2
            foo=: #M3
          implemented
            foo: #M2
            foo=: #M3
      B: #M5
        declaredFields
          foo: #M6
        declaredSetters
          foo=: #M7
        declaredMethods
          zzz: #M10
        declaredConstructors
          foo: #M8
        interface: #M11
          map
            foo: #M2
            foo=: #M7
            zzz: #M10
          implemented
            foo: #M2
            foo=: #M7
            zzz: #M10
          superImplemented
            [0]
              foo: #M2
              foo=: #M3
          inherited
            foo: #M2
            foo=: #M3
''',
    );
  }

  test_manifest_baseName_declaredConstructor_declaredInstanceSetter_inheritedInstanceMethod() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  void foo() {}
}

class B extends A {
  B.foo();
  set foo(int _) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
      B: #M3
        declaredFields
          foo: #M4
        declaredSetters
          foo=: #M5
        declaredConstructors
          foo: #M6
        interface: #M7
          map
            foo: #M1
            foo=: #M5
          implemented
            foo: #M1
            foo=: #M5
          superImplemented
            [0]
              foo: #M1
          inherited
            foo: #M1
''',
      updatedCode: r'''
class A {
  void foo() {}
}

class B extends A {
  B.foo();
  set foo(int _) {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
      B: #M3
        declaredFields
          foo: #M4
        declaredSetters
          foo=: #M5
        declaredMethods
          zzz: #M8
        declaredConstructors
          foo: #M6
        interface: #M9
          map
            foo: #M1
            foo=: #M5
            zzz: #M8
          implemented
            foo: #M1
            foo=: #M5
            zzz: #M8
          superImplemented
            [0]
              foo: #M1
          inherited
            foo: #M1
''',
    );
  }

  test_manifest_baseName_declaredConstructor_declaredInstanceSetter_inheritedInstanceSetter() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  set foo(int _) {}
}

class B extends A {
  B.foo();
  set foo(int _) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredSetters
          foo=: #M2
        interface: #M3
          map
            foo=: #M2
          implemented
            foo=: #M2
      B: #M4
        declaredFields
          foo: #M5
        declaredSetters
          foo=: #M6
        declaredConstructors
          foo: #M7
        interface: #M8
          map
            foo=: #M6
          implemented
            foo=: #M6
          superImplemented
            [0]
              foo=: #M2
          inherited
            foo=: #M2
''',
      updatedCode: r'''
class A {
  set foo(int _) {}
}

class B extends A {
  B.foo();
  set foo(int _) {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredSetters
          foo=: #M2
        interface: #M3
          map
            foo=: #M2
          implemented
            foo=: #M2
      B: #M4
        declaredFields
          foo: #M5
        declaredSetters
          foo=: #M6
        declaredMethods
          zzz: #M9
        declaredConstructors
          foo: #M7
        interface: #M10
          map
            foo=: #M6
            zzz: #M9
          implemented
            foo=: #M6
            zzz: #M9
          superImplemented
            [0]
              foo=: #M2
          inherited
            foo=: #M2
''',
    );
  }

  test_manifest_baseName_declaredConstructor_declaredStaticGetter() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  A.foo();
  static int get foo {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConflicts
          foo: #M1
          foo=: #M1
        interface: #M2
''',
      updatedCode: r'''
class A {
  A.foo();
  static int get foo {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConflicts
          foo: #M3
          foo=: #M3
        declaredMethods
          zzz: #M4
        interface: #M5
          map
            zzz: #M4
          implemented
            zzz: #M4
''',
    );
  }

  test_manifest_baseName_declaredConstructor_declaredStaticGetter_declaredInstanceSetter() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  A.foo();
  static int get foo {}
  set foo(int _) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConflicts
          foo: #M1
          foo=: #M1
        interface: #M2
          map
            foo=: #M1
          implemented
            foo=: #M1
''',
      updatedCode: r'''
class A {
  A.foo();
  static int get foo {}
  set foo(int _) {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConflicts
          foo: #M3
          foo=: #M3
        declaredMethods
          zzz: #M4
        interface: #M5
          map
            foo=: #M3
            zzz: #M4
          implemented
            foo=: #M3
            zzz: #M4
''',
    );
  }

  test_manifest_baseName_declaredConstructor_declaredStaticGetter_declaredInstanceSetter_inheritedInstanceGetter() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  int get foo {}
}

class B extends A {
  B.foo();
  static int get foo {}
  set foo(int _) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        interface: #M3
          map
            foo: #M2
          implemented
            foo: #M2
      B: #M4
        declaredConflicts
          foo: #M5
          foo=: #M5
        interface: #M6
          map
            foo: #M2
            foo=: #M5
          implemented
            foo: #M2
            foo=: #M5
          superImplemented
            [0]
              foo: #M2
          inherited
            foo: #M2
''',
      updatedCode: r'''
class A {
  int get foo {}
}

class B extends A {
  B.foo();
  static int get foo {}
  set foo(int _) {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        interface: #M3
          map
            foo: #M2
          implemented
            foo: #M2
      B: #M4
        declaredConflicts
          foo: #M7
          foo=: #M7
        declaredMethods
          zzz: #M8
        interface: #M9
          map
            foo: #M2
            foo=: #M7
            zzz: #M8
          implemented
            foo: #M2
            foo=: #M7
            zzz: #M8
          superImplemented
            [0]
              foo: #M2
          inherited
            foo: #M2
''',
    );
  }

  test_manifest_baseName_declaredConstructor_declaredStaticGetter_declaredInstanceSetter_inheritedInstanceGetter_inheritedInstanceSetter() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  int get foo {}
  set foo(int _) {}
}

class B extends A {
  B.foo();
  static int get foo {}
  set foo(int _) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        declaredSetters
          foo=: #M3
        interface: #M4
          map
            foo: #M2
            foo=: #M3
          implemented
            foo: #M2
            foo=: #M3
      B: #M5
        declaredConflicts
          foo: #M6
          foo=: #M6
        interface: #M7
          map
            foo: #M2
            foo=: #M6
          implemented
            foo: #M2
            foo=: #M6
          superImplemented
            [0]
              foo: #M2
              foo=: #M3
          inherited
            foo: #M2
            foo=: #M3
''',
      updatedCode: r'''
class A {
  int get foo {}
  set foo(int _) {}
}

class B extends A {
  B.foo();
  static int get foo {}
  set foo(int _) {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        declaredSetters
          foo=: #M3
        interface: #M4
          map
            foo: #M2
            foo=: #M3
          implemented
            foo: #M2
            foo=: #M3
      B: #M5
        declaredConflicts
          foo: #M8
          foo=: #M8
        declaredMethods
          zzz: #M9
        interface: #M10
          map
            foo: #M2
            foo=: #M8
            zzz: #M9
          implemented
            foo: #M2
            foo=: #M8
            zzz: #M9
          superImplemented
            [0]
              foo: #M2
              foo=: #M3
          inherited
            foo: #M2
            foo=: #M3
''',
    );
  }

  test_manifest_baseName_declaredConstructor_declaredStaticGetter_declaredInstanceSetter_inheritedInstanceMethod() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  void foo() {}
}

class B extends A {
  B.foo();
  static int get foo {}
  set foo(int _) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
      B: #M3
        declaredConflicts
          foo: #M4
          foo=: #M4
        interface: #M5
          map
            foo: #M1
            foo=: #M4
          implemented
            foo: #M1
            foo=: #M4
          superImplemented
            [0]
              foo: #M1
          inherited
            foo: #M1
''',
      updatedCode: r'''
class A {
  void foo() {}
}

class B extends A {
  B.foo();
  static int get foo {}
  set foo(int _) {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
      B: #M3
        declaredConflicts
          foo: #M6
          foo=: #M6
        declaredMethods
          zzz: #M7
        interface: #M8
          map
            foo: #M1
            foo=: #M6
            zzz: #M7
          implemented
            foo: #M1
            foo=: #M6
            zzz: #M7
          superImplemented
            [0]
              foo: #M1
          inherited
            foo: #M1
''',
    );
  }

  test_manifest_baseName_declaredConstructor_declaredStaticGetter_declaredInstanceSetter_inheritedInstanceSetter() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  set foo(int _) {}
}

class B extends A {
  B.foo();
  static int get foo {}
  set foo(int _) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredSetters
          foo=: #M2
        interface: #M3
          map
            foo=: #M2
          implemented
            foo=: #M2
      B: #M4
        declaredConflicts
          foo: #M5
          foo=: #M5
        interface: #M6
          map
            foo=: #M5
          implemented
            foo=: #M5
          superImplemented
            [0]
              foo=: #M2
          inherited
            foo=: #M2
''',
      updatedCode: r'''
class A {
  set foo(int _) {}
}

class B extends A {
  B.foo();
  static int get foo {}
  set foo(int _) {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredSetters
          foo=: #M2
        interface: #M3
          map
            foo=: #M2
          implemented
            foo=: #M2
      B: #M4
        declaredConflicts
          foo: #M7
          foo=: #M7
        declaredMethods
          zzz: #M8
        interface: #M9
          map
            foo=: #M7
            zzz: #M8
          implemented
            foo=: #M7
            zzz: #M8
          superImplemented
            [0]
              foo=: #M2
          inherited
            foo=: #M2
''',
    );
  }

  test_manifest_baseName_declaredConstructor_declaredStaticGetter_declaredStaticSetter() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  A.foo();
  static int get foo {}
  static set foo(int _) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConflicts
          foo: #M1
          foo=: #M1
        interface: #M2
''',
      updatedCode: r'''
class A {
  A.foo();
  static int get foo {}
  static set foo(int _) {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConflicts
          foo: #M3
          foo=: #M3
        declaredMethods
          zzz: #M4
        interface: #M5
          map
            zzz: #M4
          implemented
            zzz: #M4
''',
    );
  }

  test_manifest_baseName_declaredConstructor_declaredStaticGetter_declaredStaticSetter_inheritedInstanceGetter() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  int get foo {}
}

class B extends A {
  B.foo();
  static int get foo {}
  static set foo(int _) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        interface: #M3
          map
            foo: #M2
          implemented
            foo: #M2
      B: #M4
        declaredConflicts
          foo: #M5
          foo=: #M5
        interface: #M6
          map
            foo: #M2
          implemented
            foo: #M2
          superImplemented
            [0]
              foo: #M2
          inherited
            foo: #M2
''',
      updatedCode: r'''
class A {
  int get foo {}
}

class B extends A {
  B.foo();
  static int get foo {}
  static set foo(int _) {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        interface: #M3
          map
            foo: #M2
          implemented
            foo: #M2
      B: #M4
        declaredConflicts
          foo: #M7
          foo=: #M7
        declaredMethods
          zzz: #M8
        interface: #M9
          map
            foo: #M2
            zzz: #M8
          implemented
            foo: #M2
            zzz: #M8
          superImplemented
            [0]
              foo: #M2
          inherited
            foo: #M2
''',
    );
  }

  test_manifest_baseName_declaredConstructor_declaredStaticGetter_declaredStaticSetter_inheritedInstanceGetter_inheritedInstanceSetter() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  int get foo {}
  set foo(int _) {}
}

class B extends A {
  B.foo();
  static int get foo {}
  static set foo(int _) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        declaredSetters
          foo=: #M3
        interface: #M4
          map
            foo: #M2
            foo=: #M3
          implemented
            foo: #M2
            foo=: #M3
      B: #M5
        declaredConflicts
          foo: #M6
          foo=: #M6
        interface: #M7
          map
            foo: #M2
            foo=: #M3
          implemented
            foo: #M2
            foo=: #M3
          superImplemented
            [0]
              foo: #M2
              foo=: #M3
          inherited
            foo: #M2
            foo=: #M3
''',
      updatedCode: r'''
class A {
  int get foo {}
  set foo(int _) {}
}

class B extends A {
  B.foo();
  static int get foo {}
  static set foo(int _) {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        declaredSetters
          foo=: #M3
        interface: #M4
          map
            foo: #M2
            foo=: #M3
          implemented
            foo: #M2
            foo=: #M3
      B: #M5
        declaredConflicts
          foo: #M8
          foo=: #M8
        declaredMethods
          zzz: #M9
        interface: #M10
          map
            foo: #M2
            foo=: #M3
            zzz: #M9
          implemented
            foo: #M2
            foo=: #M3
            zzz: #M9
          superImplemented
            [0]
              foo: #M2
              foo=: #M3
          inherited
            foo: #M2
            foo=: #M3
''',
    );
  }

  test_manifest_baseName_declaredConstructor_declaredStaticGetter_declaredStaticSetter_inheritedInstanceMethod() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  void foo() {}
}

class B extends A {
  B.foo();
  static int get foo {}
  static set foo(int _) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
      B: #M3
        declaredConflicts
          foo: #M4
          foo=: #M4
        interface: #M5
          map
            foo: #M1
          implemented
            foo: #M1
          superImplemented
            [0]
              foo: #M1
          inherited
            foo: #M1
''',
      updatedCode: r'''
class A {
  void foo() {}
}

class B extends A {
  B.foo();
  static int get foo {}
  static set foo(int _) {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
      B: #M3
        declaredConflicts
          foo: #M6
          foo=: #M6
        declaredMethods
          zzz: #M7
        interface: #M8
          map
            foo: #M1
            zzz: #M7
          implemented
            foo: #M1
            zzz: #M7
          superImplemented
            [0]
              foo: #M1
          inherited
            foo: #M1
''',
    );
  }

  test_manifest_baseName_declaredConstructor_declaredStaticGetter_declaredStaticSetter_inheritedInstanceSetter() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  set foo(int _) {}
}

class B extends A {
  B.foo();
  static int get foo {}
  static set foo(int _) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredSetters
          foo=: #M2
        interface: #M3
          map
            foo=: #M2
          implemented
            foo=: #M2
      B: #M4
        declaredConflicts
          foo: #M5
          foo=: #M5
        interface: #M6
          map
            foo=: #M2
          implemented
            foo=: #M2
          superImplemented
            [0]
              foo=: #M2
          inherited
            foo=: #M2
''',
      updatedCode: r'''
class A {
  set foo(int _) {}
}

class B extends A {
  B.foo();
  static int get foo {}
  static set foo(int _) {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredSetters
          foo=: #M2
        interface: #M3
          map
            foo=: #M2
          implemented
            foo=: #M2
      B: #M4
        declaredConflicts
          foo: #M7
          foo=: #M7
        declaredMethods
          zzz: #M8
        interface: #M9
          map
            foo=: #M2
            zzz: #M8
          implemented
            foo=: #M2
            zzz: #M8
          superImplemented
            [0]
              foo=: #M2
          inherited
            foo=: #M2
''',
    );
  }

  test_manifest_baseName_declaredConstructor_declaredStaticGetter_inheritedInstanceGetter() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  int get foo {}
}

class B extends A {
  B.foo();
  static int get foo {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        interface: #M3
          map
            foo: #M2
          implemented
            foo: #M2
      B: #M4
        declaredConflicts
          foo: #M5
          foo=: #M5
        interface: #M6
          map
            foo: #M2
          implemented
            foo: #M2
          superImplemented
            [0]
              foo: #M2
          inherited
            foo: #M2
''',
      updatedCode: r'''
class A {
  int get foo {}
}

class B extends A {
  B.foo();
  static int get foo {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        interface: #M3
          map
            foo: #M2
          implemented
            foo: #M2
      B: #M4
        declaredConflicts
          foo: #M7
          foo=: #M7
        declaredMethods
          zzz: #M8
        interface: #M9
          map
            foo: #M2
            zzz: #M8
          implemented
            foo: #M2
            zzz: #M8
          superImplemented
            [0]
              foo: #M2
          inherited
            foo: #M2
''',
    );
  }

  test_manifest_baseName_declaredConstructor_declaredStaticGetter_inheritedInstanceGetter_inheritedInstanceSetter() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  int get foo {}
  set foo(int _) {}
}

class B extends A {
  B.foo();
  static int get foo {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        declaredSetters
          foo=: #M3
        interface: #M4
          map
            foo: #M2
            foo=: #M3
          implemented
            foo: #M2
            foo=: #M3
      B: #M5
        declaredConflicts
          foo: #M6
          foo=: #M6
        interface: #M7
          map
            foo: #M2
            foo=: #M3
          implemented
            foo: #M2
            foo=: #M3
          superImplemented
            [0]
              foo: #M2
              foo=: #M3
          inherited
            foo: #M2
            foo=: #M3
''',
      updatedCode: r'''
class A {
  int get foo {}
  set foo(int _) {}
}

class B extends A {
  B.foo();
  static int get foo {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        declaredSetters
          foo=: #M3
        interface: #M4
          map
            foo: #M2
            foo=: #M3
          implemented
            foo: #M2
            foo=: #M3
      B: #M5
        declaredConflicts
          foo: #M8
          foo=: #M8
        declaredMethods
          zzz: #M9
        interface: #M10
          map
            foo: #M2
            foo=: #M3
            zzz: #M9
          implemented
            foo: #M2
            foo=: #M3
            zzz: #M9
          superImplemented
            [0]
              foo: #M2
              foo=: #M3
          inherited
            foo: #M2
            foo=: #M3
''',
    );
  }

  test_manifest_baseName_declaredConstructor_declaredStaticGetter_inheritedInstanceMethod() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  void foo() {}
}

class B extends A {
  B.foo();
  static int get foo {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
      B: #M3
        declaredConflicts
          foo: #M4
          foo=: #M4
        interface: #M5
          map
            foo: #M1
          implemented
            foo: #M1
          superImplemented
            [0]
              foo: #M1
          inherited
            foo: #M1
''',
      updatedCode: r'''
class A {
  void foo() {}
}

class B extends A {
  B.foo();
  static int get foo {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
      B: #M3
        declaredConflicts
          foo: #M6
          foo=: #M6
        declaredMethods
          zzz: #M7
        interface: #M8
          map
            foo: #M1
            zzz: #M7
          implemented
            foo: #M1
            zzz: #M7
          superImplemented
            [0]
              foo: #M1
          inherited
            foo: #M1
''',
    );
  }

  test_manifest_baseName_declaredConstructor_declaredStaticGetter_inheritedInstanceSetter() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  set foo(int _) {}
}

class B extends A {
  B.foo();
  static int get foo {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredSetters
          foo=: #M2
        interface: #M3
          map
            foo=: #M2
          implemented
            foo=: #M2
      B: #M4
        declaredConflicts
          foo: #M5
          foo=: #M5
        interface: #M6
          map
            foo=: #M2
          implemented
            foo=: #M2
          superImplemented
            [0]
              foo=: #M2
          inherited
            foo=: #M2
''',
      updatedCode: r'''
class A {
  set foo(int _) {}
}

class B extends A {
  B.foo();
  static int get foo {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredSetters
          foo=: #M2
        interface: #M3
          map
            foo=: #M2
          implemented
            foo=: #M2
      B: #M4
        declaredConflicts
          foo: #M7
          foo=: #M7
        declaredMethods
          zzz: #M8
        interface: #M9
          map
            foo=: #M2
            zzz: #M8
          implemented
            foo=: #M2
            zzz: #M8
          superImplemented
            [0]
              foo=: #M2
          inherited
            foo=: #M2
''',
    );
  }

  test_manifest_baseName_declaredConstructor_declaredStaticMethod() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  A.foo();
  static void foo() {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConflicts
          foo: #M1
          foo=: #M1
        interface: #M2
''',
      updatedCode: r'''
class A {
  A.foo();
  static void foo() {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConflicts
          foo: #M3
          foo=: #M3
        declaredMethods
          zzz: #M4
        interface: #M5
          map
            zzz: #M4
          implemented
            zzz: #M4
''',
    );
  }

  test_manifest_baseName_declaredConstructor_declaredStaticMethod_inheritedInstanceGetter() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  int get foo {}
}

class B extends A {
  B.foo();
  static void foo() {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        interface: #M3
          map
            foo: #M2
          implemented
            foo: #M2
      B: #M4
        declaredConflicts
          foo: #M5
          foo=: #M5
        interface: #M6
          map
            foo: #M2
          implemented
            foo: #M2
          superImplemented
            [0]
              foo: #M2
          inherited
            foo: #M2
''',
      updatedCode: r'''
class A {
  int get foo {}
}

class B extends A {
  B.foo();
  static void foo() {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        interface: #M3
          map
            foo: #M2
          implemented
            foo: #M2
      B: #M4
        declaredConflicts
          foo: #M7
          foo=: #M7
        declaredMethods
          zzz: #M8
        interface: #M9
          map
            foo: #M2
            zzz: #M8
          implemented
            foo: #M2
            zzz: #M8
          superImplemented
            [0]
              foo: #M2
          inherited
            foo: #M2
''',
    );
  }

  test_manifest_baseName_declaredConstructor_declaredStaticMethod_inheritedInstanceGetter_inheritedInstanceSetter() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  int get foo {}
  set foo(int _) {}
}

class B extends A {
  B.foo();
  static void foo() {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        declaredSetters
          foo=: #M3
        interface: #M4
          map
            foo: #M2
            foo=: #M3
          implemented
            foo: #M2
            foo=: #M3
      B: #M5
        declaredConflicts
          foo: #M6
          foo=: #M6
        interface: #M7
          map
            foo: #M2
            foo=: #M3
          implemented
            foo: #M2
            foo=: #M3
          superImplemented
            [0]
              foo: #M2
              foo=: #M3
          inherited
            foo: #M2
            foo=: #M3
''',
      updatedCode: r'''
class A {
  int get foo {}
  set foo(int _) {}
}

class B extends A {
  B.foo();
  static void foo() {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        declaredSetters
          foo=: #M3
        interface: #M4
          map
            foo: #M2
            foo=: #M3
          implemented
            foo: #M2
            foo=: #M3
      B: #M5
        declaredConflicts
          foo: #M8
          foo=: #M8
        declaredMethods
          zzz: #M9
        interface: #M10
          map
            foo: #M2
            foo=: #M3
            zzz: #M9
          implemented
            foo: #M2
            foo=: #M3
            zzz: #M9
          superImplemented
            [0]
              foo: #M2
              foo=: #M3
          inherited
            foo: #M2
            foo=: #M3
''',
    );
  }

  test_manifest_baseName_declaredConstructor_declaredStaticMethod_inheritedInstanceMethod() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  void foo() {}
}

class B extends A {
  B.foo();
  static void foo() {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
      B: #M3
        declaredConflicts
          foo: #M4
          foo=: #M4
        interface: #M5
          map
            foo: #M1
          implemented
            foo: #M1
          superImplemented
            [0]
              foo: #M1
          inherited
            foo: #M1
''',
      updatedCode: r'''
class A {
  void foo() {}
}

class B extends A {
  B.foo();
  static void foo() {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
      B: #M3
        declaredConflicts
          foo: #M6
          foo=: #M6
        declaredMethods
          zzz: #M7
        interface: #M8
          map
            foo: #M1
            zzz: #M7
          implemented
            foo: #M1
            zzz: #M7
          superImplemented
            [0]
              foo: #M1
          inherited
            foo: #M1
''',
    );
  }

  test_manifest_baseName_declaredConstructor_declaredStaticMethod_inheritedInstanceSetter() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  set foo(int _) {}
}

class B extends A {
  B.foo();
  static void foo() {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredSetters
          foo=: #M2
        interface: #M3
          map
            foo=: #M2
          implemented
            foo=: #M2
      B: #M4
        declaredConflicts
          foo: #M5
          foo=: #M5
        interface: #M6
          map
            foo=: #M2
          implemented
            foo=: #M2
          superImplemented
            [0]
              foo=: #M2
          inherited
            foo=: #M2
''',
      updatedCode: r'''
class A {
  set foo(int _) {}
}

class B extends A {
  B.foo();
  static void foo() {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredSetters
          foo=: #M2
        interface: #M3
          map
            foo=: #M2
          implemented
            foo=: #M2
      B: #M4
        declaredConflicts
          foo: #M7
          foo=: #M7
        declaredMethods
          zzz: #M8
        interface: #M9
          map
            foo=: #M2
            zzz: #M8
          implemented
            foo=: #M2
            zzz: #M8
          superImplemented
            [0]
              foo=: #M2
          inherited
            foo=: #M2
''',
    );
  }

  test_manifest_baseName_declaredConstructor_declaredStaticSetter() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  A.foo();
  static set foo(int _) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConflicts
          foo: #M1
          foo=: #M1
        interface: #M2
''',
      updatedCode: r'''
class A {
  A.foo();
  static set foo(int _) {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConflicts
          foo: #M3
          foo=: #M3
        declaredMethods
          zzz: #M4
        interface: #M5
          map
            zzz: #M4
          implemented
            zzz: #M4
''',
    );
  }

  test_manifest_baseName_declaredConstructor_declaredStaticSetter_inheritedInstanceGetter() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  int get foo {}
}

class B extends A {
  B.foo();
  static set foo(int _) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        interface: #M3
          map
            foo: #M2
          implemented
            foo: #M2
      B: #M4
        declaredConflicts
          foo: #M5
          foo=: #M5
        interface: #M6
          map
            foo: #M2
          implemented
            foo: #M2
          superImplemented
            [0]
              foo: #M2
          inherited
            foo: #M2
''',
      updatedCode: r'''
class A {
  int get foo {}
}

class B extends A {
  B.foo();
  static set foo(int _) {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        interface: #M3
          map
            foo: #M2
          implemented
            foo: #M2
      B: #M4
        declaredConflicts
          foo: #M7
          foo=: #M7
        declaredMethods
          zzz: #M8
        interface: #M9
          map
            foo: #M2
            zzz: #M8
          implemented
            foo: #M2
            zzz: #M8
          superImplemented
            [0]
              foo: #M2
          inherited
            foo: #M2
''',
    );
  }

  test_manifest_baseName_declaredConstructor_declaredStaticSetter_inheritedInstanceGetter_inheritedInstanceSetter() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  int get foo {}
  set foo(int _) {}
}

class B extends A {
  B.foo();
  static set foo(int _) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        declaredSetters
          foo=: #M3
        interface: #M4
          map
            foo: #M2
            foo=: #M3
          implemented
            foo: #M2
            foo=: #M3
      B: #M5
        declaredConflicts
          foo: #M6
          foo=: #M6
        interface: #M7
          map
            foo: #M2
            foo=: #M3
          implemented
            foo: #M2
            foo=: #M3
          superImplemented
            [0]
              foo: #M2
              foo=: #M3
          inherited
            foo: #M2
            foo=: #M3
''',
      updatedCode: r'''
class A {
  int get foo {}
  set foo(int _) {}
}

class B extends A {
  B.foo();
  static set foo(int _) {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        declaredSetters
          foo=: #M3
        interface: #M4
          map
            foo: #M2
            foo=: #M3
          implemented
            foo: #M2
            foo=: #M3
      B: #M5
        declaredConflicts
          foo: #M8
          foo=: #M8
        declaredMethods
          zzz: #M9
        interface: #M10
          map
            foo: #M2
            foo=: #M3
            zzz: #M9
          implemented
            foo: #M2
            foo=: #M3
            zzz: #M9
          superImplemented
            [0]
              foo: #M2
              foo=: #M3
          inherited
            foo: #M2
            foo=: #M3
''',
    );
  }

  test_manifest_baseName_declaredConstructor_declaredStaticSetter_inheritedInstanceMethod() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  void foo() {}
}

class B extends A {
  B.foo();
  static set foo(int _) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
      B: #M3
        declaredConflicts
          foo: #M4
          foo=: #M4
        interface: #M5
          map
            foo: #M1
          implemented
            foo: #M1
          superImplemented
            [0]
              foo: #M1
          inherited
            foo: #M1
''',
      updatedCode: r'''
class A {
  void foo() {}
}

class B extends A {
  B.foo();
  static set foo(int _) {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
      B: #M3
        declaredConflicts
          foo: #M6
          foo=: #M6
        declaredMethods
          zzz: #M7
        interface: #M8
          map
            foo: #M1
            zzz: #M7
          implemented
            foo: #M1
            zzz: #M7
          superImplemented
            [0]
              foo: #M1
          inherited
            foo: #M1
''',
    );
  }

  test_manifest_baseName_declaredConstructor_declaredStaticSetter_inheritedInstanceSetter() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  set foo(int _) {}
}

class B extends A {
  B.foo();
  static set foo(int _) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredSetters
          foo=: #M2
        interface: #M3
          map
            foo=: #M2
          implemented
            foo=: #M2
      B: #M4
        declaredConflicts
          foo: #M5
          foo=: #M5
        interface: #M6
          map
            foo=: #M2
          implemented
            foo=: #M2
          superImplemented
            [0]
              foo=: #M2
          inherited
            foo=: #M2
''',
      updatedCode: r'''
class A {
  set foo(int _) {}
}

class B extends A {
  B.foo();
  static set foo(int _) {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredSetters
          foo=: #M2
        interface: #M3
          map
            foo=: #M2
          implemented
            foo=: #M2
      B: #M4
        declaredConflicts
          foo: #M7
          foo=: #M7
        declaredMethods
          zzz: #M8
        interface: #M9
          map
            foo=: #M2
            zzz: #M8
          implemented
            foo=: #M2
            zzz: #M8
          superImplemented
            [0]
              foo=: #M2
          inherited
            foo=: #M2
''',
    );
  }

  test_manifest_baseName_declaredConstructor_inheritedInstanceGetter() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  int get foo {}
}

class B extends A {
  B.foo();
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        interface: #M3
          map
            foo: #M2
          implemented
            foo: #M2
      B: #M4
        declaredConstructors
          foo: #M5
        interface: #M6
          map
            foo: #M2
          implemented
            foo: #M2
          superImplemented
            [0]
              foo: #M2
          inherited
            foo: #M2
''',
      updatedCode: r'''
class A {
  int get foo {}
}

class B extends A {
  B.foo();
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        interface: #M3
          map
            foo: #M2
          implemented
            foo: #M2
      B: #M4
        declaredMethods
          zzz: #M7
        declaredConstructors
          foo: #M5
        interface: #M8
          map
            foo: #M2
            zzz: #M7
          implemented
            foo: #M2
            zzz: #M7
          superImplemented
            [0]
              foo: #M2
          inherited
            foo: #M2
''',
    );
  }

  test_manifest_baseName_declaredConstructor_inheritedInstanceGetter_inheritedInstanceSetter() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  int get foo {}
  set foo(int _) {}
}

class B extends A {
  B.foo();
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        declaredSetters
          foo=: #M3
        interface: #M4
          map
            foo: #M2
            foo=: #M3
          implemented
            foo: #M2
            foo=: #M3
      B: #M5
        declaredConstructors
          foo: #M6
        interface: #M7
          map
            foo: #M2
            foo=: #M3
          implemented
            foo: #M2
            foo=: #M3
          superImplemented
            [0]
              foo: #M2
              foo=: #M3
          inherited
            foo: #M2
            foo=: #M3
''',
      updatedCode: r'''
class A {
  int get foo {}
  set foo(int _) {}
}

class B extends A {
  B.foo();
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        declaredSetters
          foo=: #M3
        interface: #M4
          map
            foo: #M2
            foo=: #M3
          implemented
            foo: #M2
            foo=: #M3
      B: #M5
        declaredMethods
          zzz: #M8
        declaredConstructors
          foo: #M6
        interface: #M9
          map
            foo: #M2
            foo=: #M3
            zzz: #M8
          implemented
            foo: #M2
            foo=: #M3
            zzz: #M8
          superImplemented
            [0]
              foo: #M2
              foo=: #M3
          inherited
            foo: #M2
            foo=: #M3
''',
    );
  }

  test_manifest_baseName_declaredConstructor_inheritedInstanceMethod() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  void foo() {}
}

class B extends A {
  B.foo();
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
      B: #M3
        declaredConstructors
          foo: #M4
        interface: #M5
          map
            foo: #M1
          implemented
            foo: #M1
          superImplemented
            [0]
              foo: #M1
          inherited
            foo: #M1
''',
      updatedCode: r'''
class A {
  void foo() {}
}

class B extends A {
  B.foo();
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
      B: #M3
        declaredMethods
          zzz: #M6
        declaredConstructors
          foo: #M4
        interface: #M7
          map
            foo: #M1
            zzz: #M6
          implemented
            foo: #M1
            zzz: #M6
          superImplemented
            [0]
              foo: #M1
          inherited
            foo: #M1
''',
    );
  }

  test_manifest_baseName_declaredConstructor_inheritedInstanceSetter() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  set foo(int _) {}
}

class B extends A {
  B.foo();
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredSetters
          foo=: #M2
        interface: #M3
          map
            foo=: #M2
          implemented
            foo=: #M2
      B: #M4
        declaredConstructors
          foo: #M5
        interface: #M6
          map
            foo=: #M2
          implemented
            foo=: #M2
          superImplemented
            [0]
              foo=: #M2
          inherited
            foo=: #M2
''',
      updatedCode: r'''
class A {
  set foo(int _) {}
}

class B extends A {
  B.foo();
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredSetters
          foo=: #M2
        interface: #M3
          map
            foo=: #M2
          implemented
            foo=: #M2
      B: #M4
        declaredMethods
          zzz: #M7
        declaredConstructors
          foo: #M5
        interface: #M8
          map
            foo=: #M2
            zzz: #M7
          implemented
            foo=: #M2
            zzz: #M7
          superImplemented
            [0]
              foo=: #M2
          inherited
            foo=: #M2
''',
    );
  }

  test_manifest_baseName_declaredIndex() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  int operator[](_) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          []: #M1
        interface: #M2
          map
            []: #M1
          implemented
            []: #M1
''',
      updatedCode: r'''
class A {
  int operator[](_) {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          []: #M1
          zzz: #M3
        interface: #M4
          map
            []: #M1
            zzz: #M3
          implemented
            []: #M1
            zzz: #M3
''',
    );
  }

  test_manifest_baseName_declaredIndex_declaredIndex() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  int operator[](_) {}
  int operator[](_) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConflicts
          []: #M1
          []=: #M1
        interface: #M2
          map
            []: #M1
          implemented
            []: #M1
''',
      updatedCode: r'''
class A {
  int operator[](_) {}
  int operator[](_) {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConflicts
          []: #M3
          []=: #M3
        declaredMethods
          zzz: #M4
        interface: #M5
          map
            []: #M3
            zzz: #M4
          implemented
            []: #M3
            zzz: #M4
''',
    );
  }

  test_manifest_baseName_declaredIndex_declaredIndexEq() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  int operator[](_) {}
  operator[]=(_, _) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          []: #M1
          []=: #M2
        interface: #M3
          map
            []: #M1
            []=: #M2
          implemented
            []: #M1
            []=: #M2
''',
      updatedCode: r'''
class A {
  int operator[](_) {}
  operator[]=(_, _) {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          []: #M1
          []=: #M2
          zzz: #M4
        interface: #M5
          map
            []: #M1
            []=: #M2
            zzz: #M4
          implemented
            []: #M1
            []=: #M2
            zzz: #M4
''',
    );
  }

  test_manifest_baseName_declaredIndex_declaredIndexEq_declaredIndexEq() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  int operator[](_) {}
  operator[]=(_, _) {}
  operator[]=(_, _) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConflicts
          []: #M1
          []=: #M1
        interface: #M2
          map
            []: #M1
            []=: #M1
          implemented
            []: #M1
            []=: #M1
''',
      updatedCode: r'''
class A {
  int operator[](_) {}
  operator[]=(_, _) {}
  operator[]=(_, _) {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConflicts
          []: #M3
          []=: #M3
        declaredMethods
          zzz: #M4
        interface: #M5
          map
            []: #M3
            []=: #M3
            zzz: #M4
          implemented
            []: #M3
            []=: #M3
            zzz: #M4
''',
    );
  }

  test_manifest_baseName_declaredIndex_declaredIndexEq_inheritedIndex() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  int operator[](_) {}
}

class B extends A {
  int operator[](_) {}
  operator[]=(_, _) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          []: #M1
        interface: #M2
          map
            []: #M1
          implemented
            []: #M1
      B: #M3
        declaredMethods
          []: #M4
          []=: #M5
        interface: #M6
          map
            []: #M4
            []=: #M5
          implemented
            []: #M4
            []=: #M5
          superImplemented
            [0]
              []: #M1
          inherited
            []: #M1
''',
      updatedCode: r'''
class A {
  int operator[](_) {}
}

class B extends A {
  int operator[](_) {}
  operator[]=(_, _) {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          []: #M1
        interface: #M2
          map
            []: #M1
          implemented
            []: #M1
      B: #M3
        declaredMethods
          []: #M4
          []=: #M5
          zzz: #M7
        interface: #M8
          map
            []: #M4
            []=: #M5
            zzz: #M7
          implemented
            []: #M4
            []=: #M5
            zzz: #M7
          superImplemented
            [0]
              []: #M1
          inherited
            []: #M1
''',
    );
  }

  test_manifest_baseName_declaredIndex_declaredIndexEq_inheritedIndexEq() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  operator[]=(_, _) {}
}

class B extends A {
  int operator[](_) {}
  operator[]=(_, _) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          []=: #M1
        interface: #M2
          map
            []=: #M1
          implemented
            []=: #M1
      B: #M3
        declaredMethods
          []: #M4
          []=: #M5
        interface: #M6
          map
            []: #M4
            []=: #M5
          implemented
            []: #M4
            []=: #M5
          superImplemented
            [0]
              []=: #M1
          inherited
            []=: #M1
''',
      updatedCode: r'''
class A {
  operator[]=(_, _) {}
}

class B extends A {
  int operator[](_) {}
  operator[]=(_, _) {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          []=: #M1
        interface: #M2
          map
            []=: #M1
          implemented
            []=: #M1
      B: #M3
        declaredMethods
          []: #M4
          []=: #M5
          zzz: #M7
        interface: #M8
          map
            []: #M4
            []=: #M5
            zzz: #M7
          implemented
            []: #M4
            []=: #M5
            zzz: #M7
          superImplemented
            [0]
              []=: #M1
          inherited
            []=: #M1
''',
    );
  }

  test_manifest_baseName_declaredIndex_inheritedIndex() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  int operator[](_) {}
}

class B extends A {
  int operator[](_) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          []: #M1
        interface: #M2
          map
            []: #M1
          implemented
            []: #M1
      B: #M3
        declaredMethods
          []: #M4
        interface: #M5
          map
            []: #M4
          implemented
            []: #M4
          superImplemented
            [0]
              []: #M1
          inherited
            []: #M1
''',
      updatedCode: r'''
class A {
  int operator[](_) {}
}

class B extends A {
  int operator[](_) {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          []: #M1
        interface: #M2
          map
            []: #M1
          implemented
            []: #M1
      B: #M3
        declaredMethods
          []: #M4
          zzz: #M6
        interface: #M7
          map
            []: #M4
            zzz: #M6
          implemented
            []: #M4
            zzz: #M6
          superImplemented
            [0]
              []: #M1
          inherited
            []: #M1
''',
    );
  }

  test_manifest_baseName_declaredIndex_inheritedIndexEq() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  operator[]=(_, _) {}
}

class B extends A {
  int operator[](_) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          []=: #M1
        interface: #M2
          map
            []=: #M1
          implemented
            []=: #M1
      B: #M3
        declaredMethods
          []: #M4
        interface: #M5
          map
            []: #M4
            []=: #M1
          implemented
            []: #M4
            []=: #M1
          superImplemented
            [0]
              []=: #M1
          inherited
            []=: #M1
''',
      updatedCode: r'''
class A {
  operator[]=(_, _) {}
}

class B extends A {
  int operator[](_) {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          []=: #M1
        interface: #M2
          map
            []=: #M1
          implemented
            []=: #M1
      B: #M3
        declaredMethods
          []: #M4
          zzz: #M6
        interface: #M7
          map
            []: #M4
            []=: #M1
            zzz: #M6
          implemented
            []: #M4
            []=: #M1
            zzz: #M6
          superImplemented
            [0]
              []=: #M1
          inherited
            []=: #M1
''',
    );
  }

  test_manifest_baseName_declaredIndexEq() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  operator[]=(_, _) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          []=: #M1
        interface: #M2
          map
            []=: #M1
          implemented
            []=: #M1
''',
      updatedCode: r'''
class A {
  operator[]=(_, _) {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          []=: #M1
          zzz: #M3
        interface: #M4
          map
            []=: #M1
            zzz: #M3
          implemented
            []=: #M1
            zzz: #M3
''',
    );
  }

  test_manifest_baseName_declaredIndexEq_declaredIndex() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
}

class B extends A {
  operator[]=(_, _) {}
  int operator[](_) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        interface: #M1
      B: #M2
        declaredMethods
          []: #M3
          []=: #M4
        interface: #M5
          map
            []: #M3
            []=: #M4
          implemented
            []: #M3
            []=: #M4
''',
      updatedCode: r'''
class A {
}

class B extends A {
  operator[]=(_, _) {}
  int operator[](_) {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        interface: #M1
      B: #M2
        declaredMethods
          []: #M3
          []=: #M4
          zzz: #M6
        interface: #M7
          map
            []: #M3
            []=: #M4
            zzz: #M6
          implemented
            []: #M3
            []=: #M4
            zzz: #M6
''',
    );
  }

  test_manifest_baseName_declaredIndexEq_declaredIndexEq() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  operator[]=(_, _) {}
  operator[]=(_, _) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConflicts
          []: #M1
          []=: #M1
        interface: #M2
          map
            []=: #M1
          implemented
            []=: #M1
''',
      updatedCode: r'''
class A {
  operator[]=(_, _) {}
  operator[]=(_, _) {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConflicts
          []: #M3
          []=: #M3
        declaredMethods
          zzz: #M4
        interface: #M5
          map
            []=: #M3
            zzz: #M4
          implemented
            []=: #M3
            zzz: #M4
''',
    );
  }

  test_manifest_baseName_declaredIndexEq_inheritedIndex() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  int operator[](_) {}
}

class B extends A {
  operator[]=(_, _) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          []: #M1
        interface: #M2
          map
            []: #M1
          implemented
            []: #M1
      B: #M3
        declaredMethods
          []=: #M4
        interface: #M5
          map
            []: #M1
            []=: #M4
          implemented
            []: #M1
            []=: #M4
          superImplemented
            [0]
              []: #M1
          inherited
            []: #M1
''',
      updatedCode: r'''
class A {
  int operator[](_) {}
}

class B extends A {
  operator[]=(_, _) {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          []: #M1
        interface: #M2
          map
            []: #M1
          implemented
            []: #M1
      B: #M3
        declaredMethods
          []=: #M4
          zzz: #M6
        interface: #M7
          map
            []: #M1
            []=: #M4
            zzz: #M6
          implemented
            []: #M1
            []=: #M4
            zzz: #M6
          superImplemented
            [0]
              []: #M1
          inherited
            []: #M1
''',
    );
  }

  test_manifest_baseName_declaredIndexEq_inheritedIndexEq() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  operator[]=(_, _) {}
}

class B extends A {
  operator[]=(_, _) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          []=: #M1
        interface: #M2
          map
            []=: #M1
          implemented
            []=: #M1
      B: #M3
        declaredMethods
          []=: #M4
        interface: #M5
          map
            []=: #M4
          implemented
            []=: #M4
          superImplemented
            [0]
              []=: #M1
          inherited
            []=: #M1
''',
      updatedCode: r'''
class A {
  operator[]=(_, _) {}
}

class B extends A {
  operator[]=(_, _) {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          []=: #M1
        interface: #M2
          map
            []=: #M1
          implemented
            []=: #M1
      B: #M3
        declaredMethods
          []=: #M4
          zzz: #M6
        interface: #M7
          map
            []=: #M4
            zzz: #M6
          implemented
            []=: #M4
            zzz: #M6
          superImplemented
            [0]
              []=: #M1
          inherited
            []=: #M1
''',
    );
  }

  test_manifest_baseName_declaredInstanceGetter() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  int get foo {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        interface: #M3
          map
            foo: #M2
          implemented
            foo: #M2
''',
      updatedCode: r'''
class A {
  int get foo {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        declaredMethods
          zzz: #M4
        interface: #M5
          map
            foo: #M2
            zzz: #M4
          implemented
            foo: #M2
            zzz: #M4
''',
    );
  }

  test_manifest_baseName_declaredInstanceGetter_declaredInstanceGetter() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  int get foo {}
  int get foo {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConflicts
          foo: #M1
          foo=: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
''',
      updatedCode: r'''
class A {
  int get foo {}
  int get foo {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConflicts
          foo: #M3
          foo=: #M3
        declaredMethods
          zzz: #M4
        interface: #M5
          map
            foo: #M3
            zzz: #M4
          implemented
            foo: #M3
            zzz: #M4
''',
    );
  }

  test_manifest_baseName_declaredInstanceGetter_declaredInstanceSetter() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  int get foo {}
  set foo(int _) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        declaredSetters
          foo=: #M3
        interface: #M4
          map
            foo: #M2
            foo=: #M3
          implemented
            foo: #M2
            foo=: #M3
''',
      updatedCode: r'''
class A {
  int get foo {}
  set foo(int _) {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        declaredSetters
          foo=: #M3
        declaredMethods
          zzz: #M5
        interface: #M6
          map
            foo: #M2
            foo=: #M3
            zzz: #M5
          implemented
            foo: #M2
            foo=: #M3
            zzz: #M5
''',
    );
  }

  test_manifest_baseName_declaredInstanceGetter_declaredInstanceSetter_declaredInstanceSetter() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  int get foo {}
  set foo(int _) {}
  set foo(int _) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConflicts
          foo: #M1
          foo=: #M1
        interface: #M2
          map
            foo: #M1
            foo=: #M1
          implemented
            foo: #M1
            foo=: #M1
''',
      updatedCode: r'''
class A {
  int get foo {}
  set foo(int _) {}
  set foo(int _) {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConflicts
          foo: #M3
          foo=: #M3
        declaredMethods
          zzz: #M4
        interface: #M5
          map
            foo: #M3
            foo=: #M3
            zzz: #M4
          implemented
            foo: #M3
            foo=: #M3
            zzz: #M4
''',
    );
  }

  test_manifest_baseName_declaredInstanceGetter_declaredInstanceSetter_inheritedInstanceGetter() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  int get foo {}
}

class B extends A {
  int get foo {}
  set foo(int _) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        interface: #M3
          map
            foo: #M2
          implemented
            foo: #M2
      B: #M4
        declaredFields
          foo: #M5
        declaredGetters
          foo: #M6
        declaredSetters
          foo=: #M7
        interface: #M8
          map
            foo: #M6
            foo=: #M7
          implemented
            foo: #M6
            foo=: #M7
          superImplemented
            [0]
              foo: #M2
          inherited
            foo: #M2
''',
      updatedCode: r'''
class A {
  int get foo {}
}

class B extends A {
  int get foo {}
  set foo(int _) {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        interface: #M3
          map
            foo: #M2
          implemented
            foo: #M2
      B: #M4
        declaredFields
          foo: #M5
        declaredGetters
          foo: #M6
        declaredSetters
          foo=: #M7
        declaredMethods
          zzz: #M9
        interface: #M10
          map
            foo: #M6
            foo=: #M7
            zzz: #M9
          implemented
            foo: #M6
            foo=: #M7
            zzz: #M9
          superImplemented
            [0]
              foo: #M2
          inherited
            foo: #M2
''',
    );
  }

  test_manifest_baseName_declaredInstanceGetter_declaredInstanceSetter_inheritedInstanceGetter_inheritedInstanceSetter() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  int get foo {}
  set foo(int _) {}
}

class B extends A {
  int get foo {}
  set foo(int _) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        declaredSetters
          foo=: #M3
        interface: #M4
          map
            foo: #M2
            foo=: #M3
          implemented
            foo: #M2
            foo=: #M3
      B: #M5
        declaredFields
          foo: #M6
        declaredGetters
          foo: #M7
        declaredSetters
          foo=: #M8
        interface: #M9
          map
            foo: #M7
            foo=: #M8
          implemented
            foo: #M7
            foo=: #M8
          superImplemented
            [0]
              foo: #M2
              foo=: #M3
          inherited
            foo: #M2
            foo=: #M3
''',
      updatedCode: r'''
class A {
  int get foo {}
  set foo(int _) {}
}

class B extends A {
  int get foo {}
  set foo(int _) {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        declaredSetters
          foo=: #M3
        interface: #M4
          map
            foo: #M2
            foo=: #M3
          implemented
            foo: #M2
            foo=: #M3
      B: #M5
        declaredFields
          foo: #M6
        declaredGetters
          foo: #M7
        declaredSetters
          foo=: #M8
        declaredMethods
          zzz: #M10
        interface: #M11
          map
            foo: #M7
            foo=: #M8
            zzz: #M10
          implemented
            foo: #M7
            foo=: #M8
            zzz: #M10
          superImplemented
            [0]
              foo: #M2
              foo=: #M3
          inherited
            foo: #M2
            foo=: #M3
''',
    );
  }

  test_manifest_baseName_declaredInstanceGetter_declaredInstanceSetter_inheritedInstanceMethod() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  void foo() {}
}

class B extends A {
  int get foo {}
  set foo(int _) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
      B: #M3
        declaredFields
          foo: #M4
        declaredGetters
          foo: #M5
        declaredSetters
          foo=: #M6
        interface: #M7
          map
            foo: #M5
            foo=: #M6
          implemented
            foo: #M5
            foo=: #M6
          superImplemented
            [0]
              foo: #M1
          inherited
            foo: #M1
''',
      updatedCode: r'''
class A {
  void foo() {}
}

class B extends A {
  int get foo {}
  set foo(int _) {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
      B: #M3
        declaredFields
          foo: #M4
        declaredGetters
          foo: #M5
        declaredSetters
          foo=: #M6
        declaredMethods
          zzz: #M8
        interface: #M9
          map
            foo: #M5
            foo=: #M6
            zzz: #M8
          implemented
            foo: #M5
            foo=: #M6
            zzz: #M8
          superImplemented
            [0]
              foo: #M1
          inherited
            foo: #M1
''',
    );
  }

  test_manifest_baseName_declaredInstanceGetter_declaredInstanceSetter_inheritedInstanceSetter() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  set foo(int _) {}
}

class B extends A {
  int get foo {}
  set foo(int _) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredSetters
          foo=: #M2
        interface: #M3
          map
            foo=: #M2
          implemented
            foo=: #M2
      B: #M4
        declaredFields
          foo: #M5
        declaredGetters
          foo: #M6
        declaredSetters
          foo=: #M7
        interface: #M8
          map
            foo: #M6
            foo=: #M7
          implemented
            foo: #M6
            foo=: #M7
          superImplemented
            [0]
              foo=: #M2
          inherited
            foo=: #M2
''',
      updatedCode: r'''
class A {
  set foo(int _) {}
}

class B extends A {
  int get foo {}
  set foo(int _) {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredSetters
          foo=: #M2
        interface: #M3
          map
            foo=: #M2
          implemented
            foo=: #M2
      B: #M4
        declaredFields
          foo: #M5
        declaredGetters
          foo: #M6
        declaredSetters
          foo=: #M7
        declaredMethods
          zzz: #M9
        interface: #M10
          map
            foo: #M6
            foo=: #M7
            zzz: #M9
          implemented
            foo: #M6
            foo=: #M7
            zzz: #M9
          superImplemented
            [0]
              foo=: #M2
          inherited
            foo=: #M2
''',
    );
  }

  test_manifest_baseName_declaredInstanceGetter_declaredStaticSetter() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  int get foo {}
  static set foo(int _) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConflicts
          foo: #M1
          foo=: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
''',
      updatedCode: r'''
class A {
  int get foo {}
  static set foo(int _) {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConflicts
          foo: #M3
          foo=: #M3
        declaredMethods
          zzz: #M4
        interface: #M5
          map
            foo: #M3
            zzz: #M4
          implemented
            foo: #M3
            zzz: #M4
''',
    );
  }

  test_manifest_baseName_declaredInstanceGetter_declaredStaticSetter_inheritedInstanceGetter() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  int get foo {}
}

class B extends A {
  int get foo {}
  static set foo(int _) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        interface: #M3
          map
            foo: #M2
          implemented
            foo: #M2
      B: #M4
        declaredConflicts
          foo: #M5
          foo=: #M5
        interface: #M6
          map
            foo: #M5
          implemented
            foo: #M5
          superImplemented
            [0]
              foo: #M2
          inherited
            foo: #M2
''',
      updatedCode: r'''
class A {
  int get foo {}
}

class B extends A {
  int get foo {}
  static set foo(int _) {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        interface: #M3
          map
            foo: #M2
          implemented
            foo: #M2
      B: #M4
        declaredConflicts
          foo: #M7
          foo=: #M7
        declaredMethods
          zzz: #M8
        interface: #M9
          map
            foo: #M7
            zzz: #M8
          implemented
            foo: #M7
            zzz: #M8
          superImplemented
            [0]
              foo: #M2
          inherited
            foo: #M2
''',
    );
  }

  test_manifest_baseName_declaredInstanceGetter_declaredStaticSetter_inheritedInstanceGetter_inheritedInstanceSetter() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  int get foo {}
  set foo(int _) {}
}

class B extends A {
  int get foo {}
  static set foo(int _) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        declaredSetters
          foo=: #M3
        interface: #M4
          map
            foo: #M2
            foo=: #M3
          implemented
            foo: #M2
            foo=: #M3
      B: #M5
        declaredConflicts
          foo: #M6
          foo=: #M6
        interface: #M7
          map
            foo: #M6
            foo=: #M3
          implemented
            foo: #M6
            foo=: #M3
          superImplemented
            [0]
              foo: #M2
              foo=: #M3
          inherited
            foo: #M2
            foo=: #M3
''',
      updatedCode: r'''
class A {
  int get foo {}
  set foo(int _) {}
}

class B extends A {
  int get foo {}
  static set foo(int _) {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        declaredSetters
          foo=: #M3
        interface: #M4
          map
            foo: #M2
            foo=: #M3
          implemented
            foo: #M2
            foo=: #M3
      B: #M5
        declaredConflicts
          foo: #M8
          foo=: #M8
        declaredMethods
          zzz: #M9
        interface: #M10
          map
            foo: #M8
            foo=: #M3
            zzz: #M9
          implemented
            foo: #M8
            foo=: #M3
            zzz: #M9
          superImplemented
            [0]
              foo: #M2
              foo=: #M3
          inherited
            foo: #M2
            foo=: #M3
''',
    );
  }

  test_manifest_baseName_declaredInstanceGetter_declaredStaticSetter_inheritedInstanceMethod() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  void foo() {}
}

class B extends A {
  int get foo {}
  static set foo(int _) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
      B: #M3
        declaredConflicts
          foo: #M4
          foo=: #M4
        interface: #M5
          map
            foo: #M4
          implemented
            foo: #M4
          superImplemented
            [0]
              foo: #M1
          inherited
            foo: #M1
''',
      updatedCode: r'''
class A {
  void foo() {}
}

class B extends A {
  int get foo {}
  static set foo(int _) {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
      B: #M3
        declaredConflicts
          foo: #M6
          foo=: #M6
        declaredMethods
          zzz: #M7
        interface: #M8
          map
            foo: #M6
            zzz: #M7
          implemented
            foo: #M6
            zzz: #M7
          superImplemented
            [0]
              foo: #M1
          inherited
            foo: #M1
''',
    );
  }

  test_manifest_baseName_declaredInstanceGetter_declaredStaticSetter_inheritedInstanceSetter() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  set foo(int _) {}
}

class B extends A {
  int get foo {}
  static set foo(int _) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredSetters
          foo=: #M2
        interface: #M3
          map
            foo=: #M2
          implemented
            foo=: #M2
      B: #M4
        declaredConflicts
          foo: #M5
          foo=: #M5
        interface: #M6
          map
            foo: #M5
            foo=: #M2
          implemented
            foo: #M5
            foo=: #M2
          superImplemented
            [0]
              foo=: #M2
          inherited
            foo=: #M2
''',
      updatedCode: r'''
class A {
  set foo(int _) {}
}

class B extends A {
  int get foo {}
  static set foo(int _) {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredSetters
          foo=: #M2
        interface: #M3
          map
            foo=: #M2
          implemented
            foo=: #M2
      B: #M4
        declaredConflicts
          foo: #M7
          foo=: #M7
        declaredMethods
          zzz: #M8
        interface: #M9
          map
            foo: #M7
            foo=: #M2
            zzz: #M8
          implemented
            foo: #M7
            foo=: #M2
            zzz: #M8
          superImplemented
            [0]
              foo=: #M2
          inherited
            foo=: #M2
''',
    );
  }

  test_manifest_baseName_declaredInstanceGetter_inheritedInstanceGetter() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  int get foo {}
}

class B extends A {
  int get foo {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        interface: #M3
          map
            foo: #M2
          implemented
            foo: #M2
      B: #M4
        declaredFields
          foo: #M5
        declaredGetters
          foo: #M6
        interface: #M7
          map
            foo: #M6
          implemented
            foo: #M6
          superImplemented
            [0]
              foo: #M2
          inherited
            foo: #M2
''',
      updatedCode: r'''
class A {
  int get foo {}
}

class B extends A {
  int get foo {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        interface: #M3
          map
            foo: #M2
          implemented
            foo: #M2
      B: #M4
        declaredFields
          foo: #M5
        declaredGetters
          foo: #M6
        declaredMethods
          zzz: #M8
        interface: #M9
          map
            foo: #M6
            zzz: #M8
          implemented
            foo: #M6
            zzz: #M8
          superImplemented
            [0]
              foo: #M2
          inherited
            foo: #M2
''',
    );
  }

  test_manifest_baseName_declaredInstanceGetter_inheritedInstanceGetter_inheritedInstanceSetter() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  int get foo {}
  set foo(int _) {}
}

class B extends A {
  int get foo {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        declaredSetters
          foo=: #M3
        interface: #M4
          map
            foo: #M2
            foo=: #M3
          implemented
            foo: #M2
            foo=: #M3
      B: #M5
        declaredFields
          foo: #M6
        declaredGetters
          foo: #M7
        interface: #M8
          map
            foo: #M7
            foo=: #M3
          implemented
            foo: #M7
            foo=: #M3
          superImplemented
            [0]
              foo: #M2
              foo=: #M3
          inherited
            foo: #M2
            foo=: #M3
''',
      updatedCode: r'''
class A {
  int get foo {}
  set foo(int _) {}
}

class B extends A {
  int get foo {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        declaredSetters
          foo=: #M3
        interface: #M4
          map
            foo: #M2
            foo=: #M3
          implemented
            foo: #M2
            foo=: #M3
      B: #M5
        declaredFields
          foo: #M6
        declaredGetters
          foo: #M7
        declaredMethods
          zzz: #M9
        interface: #M10
          map
            foo: #M7
            foo=: #M3
            zzz: #M9
          implemented
            foo: #M7
            foo=: #M3
            zzz: #M9
          superImplemented
            [0]
              foo: #M2
              foo=: #M3
          inherited
            foo: #M2
            foo=: #M3
''',
    );
  }

  test_manifest_baseName_declaredInstanceGetter_inheritedInstanceMethod() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  void foo() {}
}

class B extends A {
  int get foo {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
      B: #M3
        declaredFields
          foo: #M4
        declaredGetters
          foo: #M5
        interface: #M6
          map
            foo: #M5
          implemented
            foo: #M5
          superImplemented
            [0]
              foo: #M1
          inherited
            foo: #M1
''',
      updatedCode: r'''
class A {
  void foo() {}
}

class B extends A {
  int get foo {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
      B: #M3
        declaredFields
          foo: #M4
        declaredGetters
          foo: #M5
        declaredMethods
          zzz: #M7
        interface: #M8
          map
            foo: #M5
            zzz: #M7
          implemented
            foo: #M5
            zzz: #M7
          superImplemented
            [0]
              foo: #M1
          inherited
            foo: #M1
''',
    );
  }

  test_manifest_baseName_declaredInstanceGetter_inheritedInstanceSetter() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  set foo(int _) {}
}

class B extends A {
  int get foo {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredSetters
          foo=: #M2
        interface: #M3
          map
            foo=: #M2
          implemented
            foo=: #M2
      B: #M4
        declaredFields
          foo: #M5
        declaredGetters
          foo: #M6
        interface: #M7
          map
            foo: #M6
            foo=: #M2
          implemented
            foo: #M6
            foo=: #M2
          superImplemented
            [0]
              foo=: #M2
          inherited
            foo=: #M2
''',
      updatedCode: r'''
class A {
  set foo(int _) {}
}

class B extends A {
  int get foo {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredSetters
          foo=: #M2
        interface: #M3
          map
            foo=: #M2
          implemented
            foo=: #M2
      B: #M4
        declaredFields
          foo: #M5
        declaredGetters
          foo: #M6
        declaredMethods
          zzz: #M8
        interface: #M9
          map
            foo: #M6
            foo=: #M2
            zzz: #M8
          implemented
            foo: #M6
            foo=: #M2
            zzz: #M8
          superImplemented
            [0]
              foo=: #M2
          inherited
            foo=: #M2
''',
    );
  }

  test_manifest_baseName_declaredInstanceMethod() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  void foo() {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
''',
      updatedCode: r'''
class A {
  void foo() {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
          zzz: #M3
        interface: #M4
          map
            foo: #M1
            zzz: #M3
          implemented
            foo: #M1
            zzz: #M3
''',
    );
  }

  test_manifest_baseName_declaredInstanceMethod_declaredInstanceGetter() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  void foo() {}
  int get foo {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConflicts
          foo: #M1
          foo=: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
''',
      updatedCode: r'''
class A {
  void foo() {}
  int get foo {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConflicts
          foo: #M3
          foo=: #M3
        declaredMethods
          zzz: #M4
        interface: #M5
          map
            foo: #M3
            zzz: #M4
          implemented
            foo: #M3
            zzz: #M4
''',
    );
  }

  test_manifest_baseName_declaredInstanceMethod_declaredInstanceGetter_declaredInstanceGetter() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  void foo() {}
  int get foo {}
  int get foo {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConflicts
          foo: #M1
          foo=: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
''',
      updatedCode: r'''
class A {
  void foo() {}
  int get foo {}
  int get foo {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConflicts
          foo: #M3
          foo=: #M3
        declaredMethods
          zzz: #M4
        interface: #M5
          map
            foo: #M3
            zzz: #M4
          implemented
            foo: #M3
            zzz: #M4
''',
    );
  }

  test_manifest_baseName_declaredInstanceMethod_declaredInstanceGetter_declaredInstanceSetter() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  void foo() {}
  int get foo {}
  set foo(int _) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConflicts
          foo: #M1
          foo=: #M1
        interface: #M2
          map
            foo: #M1
            foo=: #M1
          implemented
            foo: #M1
            foo=: #M1
''',
      updatedCode: r'''
class A {
  void foo() {}
  int get foo {}
  set foo(int _) {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConflicts
          foo: #M3
          foo=: #M3
        declaredMethods
          zzz: #M4
        interface: #M5
          map
            foo: #M3
            foo=: #M3
            zzz: #M4
          implemented
            foo: #M3
            foo=: #M3
            zzz: #M4
''',
    );
  }

  test_manifest_baseName_declaredInstanceMethod_declaredInstanceGetter_declaredInstanceSetter_declaredInstanceSetter() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  void foo() {}
  int get foo {}
  set foo(int _) {}
  set foo(int _) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConflicts
          foo: #M1
          foo=: #M1
        interface: #M2
          map
            foo: #M1
            foo=: #M1
          implemented
            foo: #M1
            foo=: #M1
''',
      updatedCode: r'''
class A {
  void foo() {}
  int get foo {}
  set foo(int _) {}
  set foo(int _) {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConflicts
          foo: #M3
          foo=: #M3
        declaredMethods
          zzz: #M4
        interface: #M5
          map
            foo: #M3
            foo=: #M3
            zzz: #M4
          implemented
            foo: #M3
            foo=: #M3
            zzz: #M4
''',
    );
  }

  test_manifest_baseName_declaredInstanceMethod_declaredInstanceMethod() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  void foo() {}
  void foo() {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConflicts
          foo: #M1
          foo=: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
''',
      updatedCode: r'''
class A {
  void foo() {}
  void foo() {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConflicts
          foo: #M3
          foo=: #M3
        declaredMethods
          zzz: #M4
        interface: #M5
          map
            foo: #M3
            zzz: #M4
          implemented
            foo: #M3
            zzz: #M4
''',
    );
  }

  test_manifest_baseName_declaredInstanceMethod_declaredInstanceSetter() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  void foo() {}
  set foo(int _) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConflicts
          foo: #M1
          foo=: #M1
        interface: #M2
          map
            foo: #M1
            foo=: #M1
          implemented
            foo: #M1
            foo=: #M1
''',
      updatedCode: r'''
class A {
  void foo() {}
  set foo(int _) {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConflicts
          foo: #M3
          foo=: #M3
        declaredMethods
          zzz: #M4
        interface: #M5
          map
            foo: #M3
            foo=: #M3
            zzz: #M4
          implemented
            foo: #M3
            foo=: #M3
            zzz: #M4
''',
    );
  }

  test_manifest_baseName_declaredInstanceMethod_declaredInstanceSetter_declaredInstanceSetter() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  void foo() {}
  set foo(int _) {}
  set foo(int _) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConflicts
          foo: #M1
          foo=: #M1
        interface: #M2
          map
            foo: #M1
            foo=: #M1
          implemented
            foo: #M1
            foo=: #M1
''',
      updatedCode: r'''
class A {
  void foo() {}
  set foo(int _) {}
  set foo(int _) {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConflicts
          foo: #M3
          foo=: #M3
        declaredMethods
          zzz: #M4
        interface: #M5
          map
            foo: #M3
            foo=: #M3
            zzz: #M4
          implemented
            foo: #M3
            foo=: #M3
            zzz: #M4
''',
    );
  }

  test_manifest_baseName_declaredInstanceMethod_inheritedInstanceGetter() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  int get foo {}
}

class B extends A {
  void foo() {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        interface: #M3
          map
            foo: #M2
          implemented
            foo: #M2
      B: #M4
        declaredMethods
          foo: #M5
        interface: #M6
          map
            foo: #M5
          implemented
            foo: #M5
          superImplemented
            [0]
              foo: #M2
          inherited
            foo: #M2
''',
      updatedCode: r'''
class A {
  int get foo {}
}

class B extends A {
  void foo() {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        interface: #M3
          map
            foo: #M2
          implemented
            foo: #M2
      B: #M4
        declaredMethods
          foo: #M5
          zzz: #M7
        interface: #M8
          map
            foo: #M5
            zzz: #M7
          implemented
            foo: #M5
            zzz: #M7
          superImplemented
            [0]
              foo: #M2
          inherited
            foo: #M2
''',
    );
  }

  test_manifest_baseName_declaredInstanceMethod_inheritedInstanceGetter_inheritedInstanceSetter() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  int get foo {}
  set foo(int _) {}
}

class B extends A {
  void foo() {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        declaredSetters
          foo=: #M3
        interface: #M4
          map
            foo: #M2
            foo=: #M3
          implemented
            foo: #M2
            foo=: #M3
      B: #M5
        declaredMethods
          foo: #M6
        interface: #M7
          map
            foo: #M6
            foo=: #M3
          implemented
            foo: #M6
            foo=: #M3
          superImplemented
            [0]
              foo: #M2
              foo=: #M3
          inherited
            foo: #M2
            foo=: #M3
''',
      updatedCode: r'''
class A {
  int get foo {}
  set foo(int _) {}
}

class B extends A {
  void foo() {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        declaredSetters
          foo=: #M3
        interface: #M4
          map
            foo: #M2
            foo=: #M3
          implemented
            foo: #M2
            foo=: #M3
      B: #M5
        declaredMethods
          foo: #M6
          zzz: #M8
        interface: #M9
          map
            foo: #M6
            foo=: #M3
            zzz: #M8
          implemented
            foo: #M6
            foo=: #M3
            zzz: #M8
          superImplemented
            [0]
              foo: #M2
              foo=: #M3
          inherited
            foo: #M2
            foo=: #M3
''',
    );
  }

  test_manifest_baseName_declaredInstanceMethod_inheritedInstanceMethod() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  void foo() {}
}

class B extends A {
  void foo() {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
      B: #M3
        declaredMethods
          foo: #M4
        interface: #M5
          map
            foo: #M4
          implemented
            foo: #M4
          superImplemented
            [0]
              foo: #M1
          inherited
            foo: #M1
''',
      updatedCode: r'''
class A {
  void foo() {}
}

class B extends A {
  void foo() {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
      B: #M3
        declaredMethods
          foo: #M4
          zzz: #M6
        interface: #M7
          map
            foo: #M4
            zzz: #M6
          implemented
            foo: #M4
            zzz: #M6
          superImplemented
            [0]
              foo: #M1
          inherited
            foo: #M1
''',
    );
  }

  test_manifest_baseName_declaredInstanceMethod_inheritedInstanceSetter() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  set foo(int _) {}
}

class B extends A {
  void foo() {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredSetters
          foo=: #M2
        interface: #M3
          map
            foo=: #M2
          implemented
            foo=: #M2
      B: #M4
        declaredMethods
          foo: #M5
        interface: #M6
          map
            foo: #M5
            foo=: #M2
          implemented
            foo: #M5
            foo=: #M2
          superImplemented
            [0]
              foo=: #M2
          inherited
            foo=: #M2
''',
      updatedCode: r'''
class A {
  set foo(int _) {}
}

class B extends A {
  void foo() {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredSetters
          foo=: #M2
        interface: #M3
          map
            foo=: #M2
          implemented
            foo=: #M2
      B: #M4
        declaredMethods
          foo: #M5
          zzz: #M7
        interface: #M8
          map
            foo: #M5
            foo=: #M2
            zzz: #M7
          implemented
            foo: #M5
            foo=: #M2
            zzz: #M7
          superImplemented
            [0]
              foo=: #M2
          inherited
            foo=: #M2
''',
    );
  }

  test_manifest_baseName_declaredInstanceSetter() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  set foo(int _) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredSetters
          foo=: #M2
        interface: #M3
          map
            foo=: #M2
          implemented
            foo=: #M2
''',
      updatedCode: r'''
class A {
  set foo(int _) {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredSetters
          foo=: #M2
        declaredMethods
          zzz: #M4
        interface: #M5
          map
            foo=: #M2
            zzz: #M4
          implemented
            foo=: #M2
            zzz: #M4
''',
    );
  }

  test_manifest_baseName_declaredInstanceSetter_declaredInstanceSetter() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  set foo(int _) {}
  set foo(int _) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConflicts
          foo: #M1
          foo=: #M1
        interface: #M2
          map
            foo=: #M1
          implemented
            foo=: #M1
''',
      updatedCode: r'''
class A {
  set foo(int _) {}
  set foo(int _) {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConflicts
          foo: #M3
          foo=: #M3
        declaredMethods
          zzz: #M4
        interface: #M5
          map
            foo=: #M3
            zzz: #M4
          implemented
            foo=: #M3
            zzz: #M4
''',
    );
  }

  test_manifest_baseName_declaredInstanceSetter_inheritedInstanceGetter() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  int get foo {}
}

class B extends A {
  set foo(int _) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        interface: #M3
          map
            foo: #M2
          implemented
            foo: #M2
      B: #M4
        declaredFields
          foo: #M5
        declaredSetters
          foo=: #M6
        interface: #M7
          map
            foo: #M2
            foo=: #M6
          implemented
            foo: #M2
            foo=: #M6
          superImplemented
            [0]
              foo: #M2
          inherited
            foo: #M2
''',
      updatedCode: r'''
class A {
  int get foo {}
}

class B extends A {
  set foo(int _) {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        interface: #M3
          map
            foo: #M2
          implemented
            foo: #M2
      B: #M4
        declaredFields
          foo: #M5
        declaredSetters
          foo=: #M6
        declaredMethods
          zzz: #M8
        interface: #M9
          map
            foo: #M2
            foo=: #M6
            zzz: #M8
          implemented
            foo: #M2
            foo=: #M6
            zzz: #M8
          superImplemented
            [0]
              foo: #M2
          inherited
            foo: #M2
''',
    );
  }

  test_manifest_baseName_declaredInstanceSetter_inheritedInstanceGetter_inheritedInstanceSetter() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  int get foo {}
  set foo(int _) {}
}

class B extends A {
  set foo(int _) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        declaredSetters
          foo=: #M3
        interface: #M4
          map
            foo: #M2
            foo=: #M3
          implemented
            foo: #M2
            foo=: #M3
      B: #M5
        declaredFields
          foo: #M6
        declaredSetters
          foo=: #M7
        interface: #M8
          map
            foo: #M2
            foo=: #M7
          implemented
            foo: #M2
            foo=: #M7
          superImplemented
            [0]
              foo: #M2
              foo=: #M3
          inherited
            foo: #M2
            foo=: #M3
''',
      updatedCode: r'''
class A {
  int get foo {}
  set foo(int _) {}
}

class B extends A {
  set foo(int _) {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        declaredSetters
          foo=: #M3
        interface: #M4
          map
            foo: #M2
            foo=: #M3
          implemented
            foo: #M2
            foo=: #M3
      B: #M5
        declaredFields
          foo: #M6
        declaredSetters
          foo=: #M7
        declaredMethods
          zzz: #M9
        interface: #M10
          map
            foo: #M2
            foo=: #M7
            zzz: #M9
          implemented
            foo: #M2
            foo=: #M7
            zzz: #M9
          superImplemented
            [0]
              foo: #M2
              foo=: #M3
          inherited
            foo: #M2
            foo=: #M3
''',
    );
  }

  test_manifest_baseName_declaredInstanceSetter_inheritedInstanceMethod() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  void foo() {}
}

class B extends A {
  set foo(int _) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
      B: #M3
        declaredFields
          foo: #M4
        declaredSetters
          foo=: #M5
        interface: #M6
          map
            foo: #M1
            foo=: #M5
          implemented
            foo: #M1
            foo=: #M5
          superImplemented
            [0]
              foo: #M1
          inherited
            foo: #M1
''',
      updatedCode: r'''
class A {
  void foo() {}
}

class B extends A {
  set foo(int _) {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
      B: #M3
        declaredFields
          foo: #M4
        declaredSetters
          foo=: #M5
        declaredMethods
          zzz: #M7
        interface: #M8
          map
            foo: #M1
            foo=: #M5
            zzz: #M7
          implemented
            foo: #M1
            foo=: #M5
            zzz: #M7
          superImplemented
            [0]
              foo: #M1
          inherited
            foo: #M1
''',
    );
  }

  test_manifest_baseName_declaredInstanceSetter_inheritedInstanceSetter() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  set foo(int _) {}
}

class B extends A {
  set foo(int _) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredSetters
          foo=: #M2
        interface: #M3
          map
            foo=: #M2
          implemented
            foo=: #M2
      B: #M4
        declaredFields
          foo: #M5
        declaredSetters
          foo=: #M6
        interface: #M7
          map
            foo=: #M6
          implemented
            foo=: #M6
          superImplemented
            [0]
              foo=: #M2
          inherited
            foo=: #M2
''',
      updatedCode: r'''
class A {
  set foo(int _) {}
}

class B extends A {
  set foo(int _) {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredSetters
          foo=: #M2
        interface: #M3
          map
            foo=: #M2
          implemented
            foo=: #M2
      B: #M4
        declaredFields
          foo: #M5
        declaredSetters
          foo=: #M6
        declaredMethods
          zzz: #M8
        interface: #M9
          map
            foo=: #M6
            zzz: #M8
          implemented
            foo=: #M6
            zzz: #M8
          superImplemented
            [0]
              foo=: #M2
          inherited
            foo=: #M2
''',
    );
  }

  test_manifest_baseName_declaredStaticGetter() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  static int get foo {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        interface: #M3
''',
      updatedCode: r'''
class A {
  static int get foo {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        declaredMethods
          zzz: #M4
        interface: #M5
          map
            zzz: #M4
          implemented
            zzz: #M4
''',
    );
  }

  test_manifest_baseName_declaredStaticGetter_declaredInstanceSetter() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  static int get foo {}
  set foo(int _) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConflicts
          foo: #M1
          foo=: #M1
        interface: #M2
          map
            foo=: #M1
          implemented
            foo=: #M1
''',
      updatedCode: r'''
class A {
  static int get foo {}
  set foo(int _) {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConflicts
          foo: #M3
          foo=: #M3
        declaredMethods
          zzz: #M4
        interface: #M5
          map
            foo=: #M3
            zzz: #M4
          implemented
            foo=: #M3
            zzz: #M4
''',
    );
  }

  test_manifest_baseName_declaredStaticGetter_declaredInstanceSetter_inheritedInstanceGetter() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  int get foo {}
}

class B extends A {
  static int get foo {}
  set foo(int _) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        interface: #M3
          map
            foo: #M2
          implemented
            foo: #M2
      B: #M4
        declaredConflicts
          foo: #M5
          foo=: #M5
        interface: #M6
          map
            foo: #M2
            foo=: #M5
          implemented
            foo: #M2
            foo=: #M5
          superImplemented
            [0]
              foo: #M2
          inherited
            foo: #M2
''',
      updatedCode: r'''
class A {
  int get foo {}
}

class B extends A {
  static int get foo {}
  set foo(int _) {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        interface: #M3
          map
            foo: #M2
          implemented
            foo: #M2
      B: #M4
        declaredConflicts
          foo: #M7
          foo=: #M7
        declaredMethods
          zzz: #M8
        interface: #M9
          map
            foo: #M2
            foo=: #M7
            zzz: #M8
          implemented
            foo: #M2
            foo=: #M7
            zzz: #M8
          superImplemented
            [0]
              foo: #M2
          inherited
            foo: #M2
''',
    );
  }

  test_manifest_baseName_declaredStaticGetter_declaredInstanceSetter_inheritedInstanceGetter_inheritedInstanceSetter() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  int get foo {}
  set foo(int _) {}
}

class B extends A {
  static int get foo {}
  set foo(int _) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        declaredSetters
          foo=: #M3
        interface: #M4
          map
            foo: #M2
            foo=: #M3
          implemented
            foo: #M2
            foo=: #M3
      B: #M5
        declaredConflicts
          foo: #M6
          foo=: #M6
        interface: #M7
          map
            foo: #M2
            foo=: #M6
          implemented
            foo: #M2
            foo=: #M6
          superImplemented
            [0]
              foo: #M2
              foo=: #M3
          inherited
            foo: #M2
            foo=: #M3
''',
      updatedCode: r'''
class A {
  int get foo {}
  set foo(int _) {}
}

class B extends A {
  static int get foo {}
  set foo(int _) {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        declaredSetters
          foo=: #M3
        interface: #M4
          map
            foo: #M2
            foo=: #M3
          implemented
            foo: #M2
            foo=: #M3
      B: #M5
        declaredConflicts
          foo: #M8
          foo=: #M8
        declaredMethods
          zzz: #M9
        interface: #M10
          map
            foo: #M2
            foo=: #M8
            zzz: #M9
          implemented
            foo: #M2
            foo=: #M8
            zzz: #M9
          superImplemented
            [0]
              foo: #M2
              foo=: #M3
          inherited
            foo: #M2
            foo=: #M3
''',
    );
  }

  test_manifest_baseName_declaredStaticGetter_declaredInstanceSetter_inheritedInstanceMethod() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  void foo() {}
}

class B extends A {
  static int get foo {}
  set foo(int _) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
      B: #M3
        declaredConflicts
          foo: #M4
          foo=: #M4
        interface: #M5
          map
            foo: #M1
            foo=: #M4
          implemented
            foo: #M1
            foo=: #M4
          superImplemented
            [0]
              foo: #M1
          inherited
            foo: #M1
''',
      updatedCode: r'''
class A {
  void foo() {}
}

class B extends A {
  static int get foo {}
  set foo(int _) {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
      B: #M3
        declaredConflicts
          foo: #M6
          foo=: #M6
        declaredMethods
          zzz: #M7
        interface: #M8
          map
            foo: #M1
            foo=: #M6
            zzz: #M7
          implemented
            foo: #M1
            foo=: #M6
            zzz: #M7
          superImplemented
            [0]
              foo: #M1
          inherited
            foo: #M1
''',
    );
  }

  test_manifest_baseName_declaredStaticGetter_declaredInstanceSetter_inheritedInstanceSetter() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  set foo(int _) {}
}

class B extends A {
  static int get foo {}
  set foo(int _) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredSetters
          foo=: #M2
        interface: #M3
          map
            foo=: #M2
          implemented
            foo=: #M2
      B: #M4
        declaredConflicts
          foo: #M5
          foo=: #M5
        interface: #M6
          map
            foo=: #M5
          implemented
            foo=: #M5
          superImplemented
            [0]
              foo=: #M2
          inherited
            foo=: #M2
''',
      updatedCode: r'''
class A {
  set foo(int _) {}
}

class B extends A {
  static int get foo {}
  set foo(int _) {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredSetters
          foo=: #M2
        interface: #M3
          map
            foo=: #M2
          implemented
            foo=: #M2
      B: #M4
        declaredConflicts
          foo: #M7
          foo=: #M7
        declaredMethods
          zzz: #M8
        interface: #M9
          map
            foo=: #M7
            zzz: #M8
          implemented
            foo=: #M7
            zzz: #M8
          superImplemented
            [0]
              foo=: #M2
          inherited
            foo=: #M2
''',
    );
  }

  test_manifest_baseName_declaredStaticGetter_declaredStaticSetter() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  static int get foo {}
  static set foo(int _) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        declaredSetters
          foo=: #M3
        interface: #M4
''',
      updatedCode: r'''
class A {
  static int get foo {}
  static set foo(int _) {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        declaredSetters
          foo=: #M3
        declaredMethods
          zzz: #M5
        interface: #M6
          map
            zzz: #M5
          implemented
            zzz: #M5
''',
    );
  }

  test_manifest_baseName_declaredStaticGetter_declaredStaticSetter_inheritedInstanceGetter() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  int get foo {}
}

class B extends A {
  static int get foo {}
  static set foo(int _) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        interface: #M3
          map
            foo: #M2
          implemented
            foo: #M2
      B: #M4
        declaredFields
          foo: #M5
        declaredGetters
          foo: #M6
        declaredSetters
          foo=: #M7
        interface: #M8
          map
            foo: #M2
          implemented
            foo: #M2
          superImplemented
            [0]
              foo: #M2
          inherited
            foo: #M2
''',
      updatedCode: r'''
class A {
  int get foo {}
}

class B extends A {
  static int get foo {}
  static set foo(int _) {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        interface: #M3
          map
            foo: #M2
          implemented
            foo: #M2
      B: #M4
        declaredFields
          foo: #M5
        declaredGetters
          foo: #M6
        declaredSetters
          foo=: #M7
        declaredMethods
          zzz: #M9
        interface: #M10
          map
            foo: #M2
            zzz: #M9
          implemented
            foo: #M2
            zzz: #M9
          superImplemented
            [0]
              foo: #M2
          inherited
            foo: #M2
''',
    );
  }

  test_manifest_baseName_declaredStaticGetter_declaredStaticSetter_inheritedInstanceGetter_inheritedInstanceSetter() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  int get foo {}
  set foo(int _) {}
}

class B extends A {
  static int get foo {}
  static set foo(int _) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        declaredSetters
          foo=: #M3
        interface: #M4
          map
            foo: #M2
            foo=: #M3
          implemented
            foo: #M2
            foo=: #M3
      B: #M5
        declaredFields
          foo: #M6
        declaredGetters
          foo: #M7
        declaredSetters
          foo=: #M8
        interface: #M9
          map
            foo: #M2
            foo=: #M3
          implemented
            foo: #M2
            foo=: #M3
          superImplemented
            [0]
              foo: #M2
              foo=: #M3
          inherited
            foo: #M2
            foo=: #M3
''',
      updatedCode: r'''
class A {
  int get foo {}
  set foo(int _) {}
}

class B extends A {
  static int get foo {}
  static set foo(int _) {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        declaredSetters
          foo=: #M3
        interface: #M4
          map
            foo: #M2
            foo=: #M3
          implemented
            foo: #M2
            foo=: #M3
      B: #M5
        declaredFields
          foo: #M6
        declaredGetters
          foo: #M7
        declaredSetters
          foo=: #M8
        declaredMethods
          zzz: #M10
        interface: #M11
          map
            foo: #M2
            foo=: #M3
            zzz: #M10
          implemented
            foo: #M2
            foo=: #M3
            zzz: #M10
          superImplemented
            [0]
              foo: #M2
              foo=: #M3
          inherited
            foo: #M2
            foo=: #M3
''',
    );
  }

  test_manifest_baseName_declaredStaticGetter_declaredStaticSetter_inheritedInstanceMethod() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  void foo() {}
}

class B extends A {
  static int get foo {}
  static set foo(int _) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
      B: #M3
        declaredFields
          foo: #M4
        declaredGetters
          foo: #M5
        declaredSetters
          foo=: #M6
        interface: #M7
          map
            foo: #M1
          implemented
            foo: #M1
          superImplemented
            [0]
              foo: #M1
          inherited
            foo: #M1
''',
      updatedCode: r'''
class A {
  void foo() {}
}

class B extends A {
  static int get foo {}
  static set foo(int _) {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
      B: #M3
        declaredFields
          foo: #M4
        declaredGetters
          foo: #M5
        declaredSetters
          foo=: #M6
        declaredMethods
          zzz: #M8
        interface: #M9
          map
            foo: #M1
            zzz: #M8
          implemented
            foo: #M1
            zzz: #M8
          superImplemented
            [0]
              foo: #M1
          inherited
            foo: #M1
''',
    );
  }

  test_manifest_baseName_declaredStaticGetter_declaredStaticSetter_inheritedInstanceSetter() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  set foo(int _) {}
}

class B extends A {
  static int get foo {}
  static set foo(int _) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredSetters
          foo=: #M2
        interface: #M3
          map
            foo=: #M2
          implemented
            foo=: #M2
      B: #M4
        declaredFields
          foo: #M5
        declaredGetters
          foo: #M6
        declaredSetters
          foo=: #M7
        interface: #M8
          map
            foo=: #M2
          implemented
            foo=: #M2
          superImplemented
            [0]
              foo=: #M2
          inherited
            foo=: #M2
''',
      updatedCode: r'''
class A {
  set foo(int _) {}
}

class B extends A {
  static int get foo {}
  static set foo(int _) {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredSetters
          foo=: #M2
        interface: #M3
          map
            foo=: #M2
          implemented
            foo=: #M2
      B: #M4
        declaredFields
          foo: #M5
        declaredGetters
          foo: #M6
        declaredSetters
          foo=: #M7
        declaredMethods
          zzz: #M9
        interface: #M10
          map
            foo=: #M2
            zzz: #M9
          implemented
            foo=: #M2
            zzz: #M9
          superImplemented
            [0]
              foo=: #M2
          inherited
            foo=: #M2
''',
    );
  }

  test_manifest_baseName_declaredStaticGetter_inheritedInstanceGetter() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  int get foo {}
}

class B extends A {
  static int get foo {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        interface: #M3
          map
            foo: #M2
          implemented
            foo: #M2
      B: #M4
        declaredFields
          foo: #M5
        declaredGetters
          foo: #M6
        interface: #M7
          map
            foo: #M2
          implemented
            foo: #M2
          superImplemented
            [0]
              foo: #M2
          inherited
            foo: #M2
''',
      updatedCode: r'''
class A {
  int get foo {}
}

class B extends A {
  static int get foo {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        interface: #M3
          map
            foo: #M2
          implemented
            foo: #M2
      B: #M4
        declaredFields
          foo: #M5
        declaredGetters
          foo: #M6
        declaredMethods
          zzz: #M8
        interface: #M9
          map
            foo: #M2
            zzz: #M8
          implemented
            foo: #M2
            zzz: #M8
          superImplemented
            [0]
              foo: #M2
          inherited
            foo: #M2
''',
    );
  }

  test_manifest_baseName_declaredStaticGetter_inheritedInstanceGetter_inheritedInstanceSetter() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  int get foo {}
  set foo(int _) {}
}

class B extends A {
  static int get foo {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        declaredSetters
          foo=: #M3
        interface: #M4
          map
            foo: #M2
            foo=: #M3
          implemented
            foo: #M2
            foo=: #M3
      B: #M5
        declaredFields
          foo: #M6
        declaredGetters
          foo: #M7
        interface: #M8
          map
            foo: #M2
            foo=: #M3
          implemented
            foo: #M2
            foo=: #M3
          superImplemented
            [0]
              foo: #M2
              foo=: #M3
          inherited
            foo: #M2
            foo=: #M3
''',
      updatedCode: r'''
class A {
  int get foo {}
  set foo(int _) {}
}

class B extends A {
  static int get foo {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        declaredSetters
          foo=: #M3
        interface: #M4
          map
            foo: #M2
            foo=: #M3
          implemented
            foo: #M2
            foo=: #M3
      B: #M5
        declaredFields
          foo: #M6
        declaredGetters
          foo: #M7
        declaredMethods
          zzz: #M9
        interface: #M10
          map
            foo: #M2
            foo=: #M3
            zzz: #M9
          implemented
            foo: #M2
            foo=: #M3
            zzz: #M9
          superImplemented
            [0]
              foo: #M2
              foo=: #M3
          inherited
            foo: #M2
            foo=: #M3
''',
    );
  }

  test_manifest_baseName_declaredStaticGetter_inheritedInstanceMethod() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  void foo() {}
}

class B extends A {
  static int get foo {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
      B: #M3
        declaredFields
          foo: #M4
        declaredGetters
          foo: #M5
        interface: #M6
          map
            foo: #M1
          implemented
            foo: #M1
          superImplemented
            [0]
              foo: #M1
          inherited
            foo: #M1
''',
      updatedCode: r'''
class A {
  void foo() {}
}

class B extends A {
  static int get foo {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
      B: #M3
        declaredFields
          foo: #M4
        declaredGetters
          foo: #M5
        declaredMethods
          zzz: #M7
        interface: #M8
          map
            foo: #M1
            zzz: #M7
          implemented
            foo: #M1
            zzz: #M7
          superImplemented
            [0]
              foo: #M1
          inherited
            foo: #M1
''',
    );
  }

  test_manifest_baseName_declaredStaticGetter_inheritedInstanceSetter() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  set foo(int _) {}
}

class B extends A {
  static int get foo {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredSetters
          foo=: #M2
        interface: #M3
          map
            foo=: #M2
          implemented
            foo=: #M2
      B: #M4
        declaredFields
          foo: #M5
        declaredGetters
          foo: #M6
        interface: #M7
          map
            foo=: #M2
          implemented
            foo=: #M2
          superImplemented
            [0]
              foo=: #M2
          inherited
            foo=: #M2
''',
      updatedCode: r'''
class A {
  set foo(int _) {}
}

class B extends A {
  static int get foo {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredSetters
          foo=: #M2
        interface: #M3
          map
            foo=: #M2
          implemented
            foo=: #M2
      B: #M4
        declaredFields
          foo: #M5
        declaredGetters
          foo: #M6
        declaredMethods
          zzz: #M8
        interface: #M9
          map
            foo=: #M2
            zzz: #M8
          implemented
            foo=: #M2
            zzz: #M8
          superImplemented
            [0]
              foo=: #M2
          inherited
            foo=: #M2
''',
    );
  }

  test_manifest_baseName_declaredStaticMethod() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  static void foo() {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
''',
      updatedCode: r'''
class A {
  static void foo() {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
          zzz: #M3
        interface: #M4
          map
            zzz: #M3
          implemented
            zzz: #M3
''',
    );
  }

  test_manifest_baseName_declaredStaticMethod_inheritedInstanceGetter() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  int get foo {}
}

class B extends A {
  static void foo() {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        interface: #M3
          map
            foo: #M2
          implemented
            foo: #M2
      B: #M4
        declaredMethods
          foo: #M5
        interface: #M6
          map
            foo: #M2
          implemented
            foo: #M2
          superImplemented
            [0]
              foo: #M2
          inherited
            foo: #M2
''',
      updatedCode: r'''
class A {
  int get foo {}
}

class B extends A {
  static void foo() {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        interface: #M3
          map
            foo: #M2
          implemented
            foo: #M2
      B: #M4
        declaredMethods
          foo: #M5
          zzz: #M7
        interface: #M8
          map
            foo: #M2
            zzz: #M7
          implemented
            foo: #M2
            zzz: #M7
          superImplemented
            [0]
              foo: #M2
          inherited
            foo: #M2
''',
    );
  }

  test_manifest_baseName_declaredStaticMethod_inheritedInstanceGetter_inheritedInstanceSetter() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  int get foo {}
  set foo(int _) {}
}

class B extends A {
  static void foo() {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        declaredSetters
          foo=: #M3
        interface: #M4
          map
            foo: #M2
            foo=: #M3
          implemented
            foo: #M2
            foo=: #M3
      B: #M5
        declaredMethods
          foo: #M6
        interface: #M7
          map
            foo: #M2
            foo=: #M3
          implemented
            foo: #M2
            foo=: #M3
          superImplemented
            [0]
              foo: #M2
              foo=: #M3
          inherited
            foo: #M2
            foo=: #M3
''',
      updatedCode: r'''
class A {
  int get foo {}
  set foo(int _) {}
}

class B extends A {
  static void foo() {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        declaredSetters
          foo=: #M3
        interface: #M4
          map
            foo: #M2
            foo=: #M3
          implemented
            foo: #M2
            foo=: #M3
      B: #M5
        declaredMethods
          foo: #M6
          zzz: #M8
        interface: #M9
          map
            foo: #M2
            foo=: #M3
            zzz: #M8
          implemented
            foo: #M2
            foo=: #M3
            zzz: #M8
          superImplemented
            [0]
              foo: #M2
              foo=: #M3
          inherited
            foo: #M2
            foo=: #M3
''',
    );
  }

  test_manifest_baseName_declaredStaticMethod_inheritedInstanceMethod() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  void foo() {}
}

class B extends A {
  static void foo() {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
      B: #M3
        declaredMethods
          foo: #M4
        interface: #M5
          map
            foo: #M1
          implemented
            foo: #M1
          superImplemented
            [0]
              foo: #M1
          inherited
            foo: #M1
''',
      updatedCode: r'''
class A {
  void foo() {}
}

class B extends A {
  static void foo() {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
      B: #M3
        declaredMethods
          foo: #M4
          zzz: #M6
        interface: #M7
          map
            foo: #M1
            zzz: #M6
          implemented
            foo: #M1
            zzz: #M6
          superImplemented
            [0]
              foo: #M1
          inherited
            foo: #M1
''',
    );
  }

  test_manifest_baseName_declaredStaticMethod_inheritedInstanceSetter() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  set foo(int _) {}
}

class B extends A {
  static void foo() {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredSetters
          foo=: #M2
        interface: #M3
          map
            foo=: #M2
          implemented
            foo=: #M2
      B: #M4
        declaredMethods
          foo: #M5
        interface: #M6
          map
            foo=: #M2
          implemented
            foo=: #M2
          superImplemented
            [0]
              foo=: #M2
          inherited
            foo=: #M2
''',
      updatedCode: r'''
class A {
  set foo(int _) {}
}

class B extends A {
  static void foo() {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredSetters
          foo=: #M2
        interface: #M3
          map
            foo=: #M2
          implemented
            foo=: #M2
      B: #M4
        declaredMethods
          foo: #M5
          zzz: #M7
        interface: #M8
          map
            foo=: #M2
            zzz: #M7
          implemented
            foo=: #M2
            zzz: #M7
          superImplemented
            [0]
              foo=: #M2
          inherited
            foo=: #M2
''',
    );
  }

  test_manifest_baseName_declaredStaticSetter() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  static set foo(int _) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredSetters
          foo=: #M2
        interface: #M3
''',
      updatedCode: r'''
class A {
  static set foo(int _) {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredSetters
          foo=: #M2
        declaredMethods
          zzz: #M4
        interface: #M5
          map
            zzz: #M4
          implemented
            zzz: #M4
''',
    );
  }

  test_manifest_baseName_declaredStaticSetter_inheritedInstanceGetter() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  int get foo {}
}

class B extends A {
  static set foo(int _) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        interface: #M3
          map
            foo: #M2
          implemented
            foo: #M2
      B: #M4
        declaredFields
          foo: #M5
        declaredSetters
          foo=: #M6
        interface: #M7
          map
            foo: #M2
          implemented
            foo: #M2
          superImplemented
            [0]
              foo: #M2
          inherited
            foo: #M2
''',
      updatedCode: r'''
class A {
  int get foo {}
}

class B extends A {
  static set foo(int _) {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        interface: #M3
          map
            foo: #M2
          implemented
            foo: #M2
      B: #M4
        declaredFields
          foo: #M5
        declaredSetters
          foo=: #M6
        declaredMethods
          zzz: #M8
        interface: #M9
          map
            foo: #M2
            zzz: #M8
          implemented
            foo: #M2
            zzz: #M8
          superImplemented
            [0]
              foo: #M2
          inherited
            foo: #M2
''',
    );
  }

  test_manifest_baseName_declaredStaticSetter_inheritedInstanceGetter_inheritedInstanceSetter() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  int get foo {}
  set foo(int _) {}
}

class B extends A {
  static set foo(int _) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        declaredSetters
          foo=: #M3
        interface: #M4
          map
            foo: #M2
            foo=: #M3
          implemented
            foo: #M2
            foo=: #M3
      B: #M5
        declaredFields
          foo: #M6
        declaredSetters
          foo=: #M7
        interface: #M8
          map
            foo: #M2
            foo=: #M3
          implemented
            foo: #M2
            foo=: #M3
          superImplemented
            [0]
              foo: #M2
              foo=: #M3
          inherited
            foo: #M2
            foo=: #M3
''',
      updatedCode: r'''
class A {
  int get foo {}
  set foo(int _) {}
}

class B extends A {
  static set foo(int _) {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        declaredSetters
          foo=: #M3
        interface: #M4
          map
            foo: #M2
            foo=: #M3
          implemented
            foo: #M2
            foo=: #M3
      B: #M5
        declaredFields
          foo: #M6
        declaredSetters
          foo=: #M7
        declaredMethods
          zzz: #M9
        interface: #M10
          map
            foo: #M2
            foo=: #M3
            zzz: #M9
          implemented
            foo: #M2
            foo=: #M3
            zzz: #M9
          superImplemented
            [0]
              foo: #M2
              foo=: #M3
          inherited
            foo: #M2
            foo=: #M3
''',
    );
  }

  test_manifest_baseName_declaredStaticSetter_inheritedInstanceMethod() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  void foo() {}
}

class B extends A {
  static set foo(int _) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
      B: #M3
        declaredFields
          foo: #M4
        declaredSetters
          foo=: #M5
        interface: #M6
          map
            foo: #M1
          implemented
            foo: #M1
          superImplemented
            [0]
              foo: #M1
          inherited
            foo: #M1
''',
      updatedCode: r'''
class A {
  void foo() {}
}

class B extends A {
  static set foo(int _) {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
      B: #M3
        declaredFields
          foo: #M4
        declaredSetters
          foo=: #M5
        declaredMethods
          zzz: #M7
        interface: #M8
          map
            foo: #M1
            zzz: #M7
          implemented
            foo: #M1
            zzz: #M7
          superImplemented
            [0]
              foo: #M1
          inherited
            foo: #M1
''',
    );
  }

  test_manifest_baseName_declaredStaticSetter_inheritedInstanceSetter() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  set foo(int _) {}
}

class B extends A {
  static set foo(int _) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredSetters
          foo=: #M2
        interface: #M3
          map
            foo=: #M2
          implemented
            foo=: #M2
      B: #M4
        declaredFields
          foo: #M5
        declaredSetters
          foo=: #M6
        interface: #M7
          map
            foo=: #M2
          implemented
            foo=: #M2
          superImplemented
            [0]
              foo=: #M2
          inherited
            foo=: #M2
''',
      updatedCode: r'''
class A {
  set foo(int _) {}
}

class B extends A {
  static set foo(int _) {}
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredSetters
          foo=: #M2
        interface: #M3
          map
            foo=: #M2
          implemented
            foo=: #M2
      B: #M4
        declaredFields
          foo: #M5
        declaredSetters
          foo=: #M6
        declaredMethods
          zzz: #M8
        interface: #M9
          map
            foo=: #M2
            zzz: #M8
          implemented
            foo=: #M2
            zzz: #M8
          superImplemented
            [0]
              foo=: #M2
          inherited
            foo=: #M2
''',
    );
  }

  test_manifest_baseName_inheritedConstructor() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
mixin M {}

class A {
  A.foo();
}

class B = A with M;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConstructors
          foo: #M1
        interface: #M2
      B: #M3
        inheritedConstructors
          foo: #M1
        interface: #M4
    declaredMixins
      M: #M5
        interface: #M6
''',
      updatedCode: r'''
mixin M {}

class A {
  A.foo();
}

class B = A with M;
class Z {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConstructors
          foo: #M1
        interface: #M2
      B: #M3
        inheritedConstructors
          foo: #M1
        interface: #M4
      Z: #M7
        interface: #M8
    declaredMixins
      M: #M5
        interface: #M6
''',
    );
  }

  test_manifest_baseName_inheritedConstructor_inheritedConstructor() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
mixin M {}

class A {
  A.foo();
  A.foo();
}

class B = A with M;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConflicts
          foo: #M1
          foo=: #M1
        interface: #M2
      B: #M3
        inheritedConstructors
          foo: #M1
        interface: #M4
    declaredMixins
      M: #M5
        interface: #M6
''',
      updatedCode: r'''
mixin M {}

class A {
  A.foo();
  A.foo();
}

class B = A with M;
class Z {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConflicts
          foo: #M7
          foo=: #M7
        interface: #M2
      B: #M3
        inheritedConstructors
          foo: #M7
        interface: #M4
      Z: #M8
        interface: #M9
    declaredMixins
      M: #M5
        interface: #M6
''',
    );
  }

  test_manifest_baseName_inheritedConstructor_inheritedInstanceGetter() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
mixin M {}

class A {
  A.foo();
  int get foo {}
}

class B = A with M;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        declaredConstructors
          foo: #M3
        interface: #M4
          map
            foo: #M2
          implemented
            foo: #M2
      B: #M5
        inheritedConstructors
          foo: #M3
        interface: #M6
          map
            foo: #M2
          implemented
            foo: #M2
          superImplemented
            [0]
              foo: #M2
            [1]
              foo: #M2
          inherited
            foo: #M2
    declaredMixins
      M: #M7
        interface: #M8
''',
      updatedCode: r'''
mixin M {}

class A {
  A.foo();
  int get foo {}
}

class B = A with M;
class Z {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        declaredConstructors
          foo: #M3
        interface: #M4
          map
            foo: #M2
          implemented
            foo: #M2
      B: #M5
        inheritedConstructors
          foo: #M3
        interface: #M6
          map
            foo: #M2
          implemented
            foo: #M2
          superImplemented
            [0]
              foo: #M2
            [1]
              foo: #M2
          inherited
            foo: #M2
      Z: #M9
        interface: #M10
    declaredMixins
      M: #M7
        interface: #M8
''',
    );
  }

  test_manifest_baseName_inheritedConstructor_inheritedInstanceGetter_inheritedInstanceSetter() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
mixin M {}

class A {
  A.foo();
  int get foo {}
  set foo(int _) {}
}

class B = A with M;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        declaredSetters
          foo=: #M3
        declaredConstructors
          foo: #M4
        interface: #M5
          map
            foo: #M2
            foo=: #M3
          implemented
            foo: #M2
            foo=: #M3
      B: #M6
        inheritedConstructors
          foo: #M4
        interface: #M7
          map
            foo: #M2
            foo=: #M3
          implemented
            foo: #M2
            foo=: #M3
          superImplemented
            [0]
              foo: #M2
              foo=: #M3
            [1]
              foo: #M2
              foo=: #M3
          inherited
            foo: #M2
            foo=: #M3
    declaredMixins
      M: #M8
        interface: #M9
''',
      updatedCode: r'''
mixin M {}

class A {
  A.foo();
  int get foo {}
  set foo(int _) {}
}

class B = A with M;
class Z {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        declaredSetters
          foo=: #M3
        declaredConstructors
          foo: #M4
        interface: #M5
          map
            foo: #M2
            foo=: #M3
          implemented
            foo: #M2
            foo=: #M3
      B: #M6
        inheritedConstructors
          foo: #M4
        interface: #M7
          map
            foo: #M2
            foo=: #M3
          implemented
            foo: #M2
            foo=: #M3
          superImplemented
            [0]
              foo: #M2
              foo=: #M3
            [1]
              foo: #M2
              foo=: #M3
          inherited
            foo: #M2
            foo=: #M3
      Z: #M10
        interface: #M11
    declaredMixins
      M: #M8
        interface: #M9
''',
    );
  }

  test_manifest_baseName_inheritedConstructor_inheritedInstanceMethod() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
mixin M {}

class A {
  A.foo();
  void foo() {}
}

class B = A with M;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        declaredConstructors
          foo: #M2
        interface: #M3
          map
            foo: #M1
          implemented
            foo: #M1
      B: #M4
        inheritedConstructors
          foo: #M2
        interface: #M5
          map
            foo: #M1
          implemented
            foo: #M1
          superImplemented
            [0]
              foo: #M1
            [1]
              foo: #M1
          inherited
            foo: #M1
    declaredMixins
      M: #M6
        interface: #M7
''',
      updatedCode: r'''
mixin M {}

class A {
  A.foo();
  void foo() {}
}

class B = A with M;
class Z {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        declaredConstructors
          foo: #M2
        interface: #M3
          map
            foo: #M1
          implemented
            foo: #M1
      B: #M4
        inheritedConstructors
          foo: #M2
        interface: #M5
          map
            foo: #M1
          implemented
            foo: #M1
          superImplemented
            [0]
              foo: #M1
            [1]
              foo: #M1
          inherited
            foo: #M1
      Z: #M8
        interface: #M9
    declaredMixins
      M: #M6
        interface: #M7
''',
    );
  }

  test_manifest_baseName_inheritedConstructor_inheritedInstanceSetter() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
mixin M {}

class A {
  A.foo();
  set foo(int _) {}
}

class B = A with M;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredSetters
          foo=: #M2
        declaredConstructors
          foo: #M3
        interface: #M4
          map
            foo=: #M2
          implemented
            foo=: #M2
      B: #M5
        inheritedConstructors
          foo: #M3
        interface: #M6
          map
            foo=: #M2
          implemented
            foo=: #M2
          superImplemented
            [0]
              foo=: #M2
            [1]
              foo=: #M2
          inherited
            foo=: #M2
    declaredMixins
      M: #M7
        interface: #M8
''',
      updatedCode: r'''
mixin M {}

class A {
  A.foo();
  set foo(int _) {}
}

class B = A with M;
class Z {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredSetters
          foo=: #M2
        declaredConstructors
          foo: #M3
        interface: #M4
          map
            foo=: #M2
          implemented
            foo=: #M2
      B: #M5
        inheritedConstructors
          foo: #M3
        interface: #M6
          map
            foo=: #M2
          implemented
            foo=: #M2
          superImplemented
            [0]
              foo=: #M2
            [1]
              foo=: #M2
          inherited
            foo=: #M2
      Z: #M9
        interface: #M10
    declaredMixins
      M: #M7
        interface: #M8
''',
    );
  }

  test_manifest_baseName_inheritedIndex() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  int operator[](_) {}
}

class B extends A {
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          []: #M1
        interface: #M2
          map
            []: #M1
          implemented
            []: #M1
      B: #M3
        interface: #M4
          map
            []: #M1
          implemented
            []: #M1
          superImplemented
            [0]
              []: #M1
          inherited
            []: #M1
''',
      updatedCode: r'''
class A {
  int operator[](_) {}
}

class B extends A {
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          []: #M1
        interface: #M2
          map
            []: #M1
          implemented
            []: #M1
      B: #M3
        declaredMethods
          zzz: #M5
        interface: #M6
          map
            []: #M1
            zzz: #M5
          implemented
            []: #M1
            zzz: #M5
          superImplemented
            [0]
              []: #M1
          inherited
            []: #M1
''',
    );
  }

  test_manifest_baseName_inheritedIndex_inheritedIndexEq() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  int operator[](_) {}
  operator[]=(_, _) {}
}

class B extends A {
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          []: #M1
          []=: #M2
        interface: #M3
          map
            []: #M1
            []=: #M2
          implemented
            []: #M1
            []=: #M2
      B: #M4
        interface: #M5
          map
            []: #M1
            []=: #M2
          implemented
            []: #M1
            []=: #M2
          superImplemented
            [0]
              []: #M1
              []=: #M2
          inherited
            []: #M1
            []=: #M2
''',
      updatedCode: r'''
class A {
  int operator[](_) {}
  operator[]=(_, _) {}
}

class B extends A {
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          []: #M1
          []=: #M2
        interface: #M3
          map
            []: #M1
            []=: #M2
          implemented
            []: #M1
            []=: #M2
      B: #M4
        declaredMethods
          zzz: #M6
        interface: #M7
          map
            []: #M1
            []=: #M2
            zzz: #M6
          implemented
            []: #M1
            []=: #M2
            zzz: #M6
          superImplemented
            [0]
              []: #M1
              []=: #M2
          inherited
            []: #M1
            []=: #M2
''',
    );
  }

  test_manifest_baseName_inheritedIndexEq() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  operator[]=(_, _) {}
}

class B extends A {
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          []=: #M1
        interface: #M2
          map
            []=: #M1
          implemented
            []=: #M1
      B: #M3
        interface: #M4
          map
            []=: #M1
          implemented
            []=: #M1
          superImplemented
            [0]
              []=: #M1
          inherited
            []=: #M1
''',
      updatedCode: r'''
class A {
  operator[]=(_, _) {}
}

class B extends A {
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          []=: #M1
        interface: #M2
          map
            []=: #M1
          implemented
            []=: #M1
      B: #M3
        declaredMethods
          zzz: #M5
        interface: #M6
          map
            []=: #M1
            zzz: #M5
          implemented
            []=: #M1
            zzz: #M5
          superImplemented
            [0]
              []=: #M1
          inherited
            []=: #M1
''',
    );
  }

  test_manifest_baseName_inheritedIndexEq_inheritedIndex() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  operator[]=(_, _) {}
  int operator[](_) {}
}

class B extends A {
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          []: #M1
          []=: #M2
        interface: #M3
          map
            []: #M1
            []=: #M2
          implemented
            []: #M1
            []=: #M2
      B: #M4
        interface: #M5
          map
            []: #M1
            []=: #M2
          implemented
            []: #M1
            []=: #M2
          superImplemented
            [0]
              []: #M1
              []=: #M2
          inherited
            []: #M1
            []=: #M2
''',
      updatedCode: r'''
class A {
  operator[]=(_, _) {}
  int operator[](_) {}
}

class B extends A {
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          []: #M1
          []=: #M2
        interface: #M3
          map
            []: #M1
            []=: #M2
          implemented
            []: #M1
            []=: #M2
      B: #M4
        declaredMethods
          zzz: #M6
        interface: #M7
          map
            []: #M1
            []=: #M2
            zzz: #M6
          implemented
            []: #M1
            []=: #M2
            zzz: #M6
          superImplemented
            [0]
              []: #M1
              []=: #M2
          inherited
            []: #M1
            []=: #M2
''',
    );
  }

  test_manifest_baseName_inheritedInstanceGetter() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  int get foo {}
}

class B extends A {
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        interface: #M3
          map
            foo: #M2
          implemented
            foo: #M2
      B: #M4
        interface: #M5
          map
            foo: #M2
          implemented
            foo: #M2
          superImplemented
            [0]
              foo: #M2
          inherited
            foo: #M2
''',
      updatedCode: r'''
class A {
  int get foo {}
}

class B extends A {
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        interface: #M3
          map
            foo: #M2
          implemented
            foo: #M2
      B: #M4
        declaredMethods
          zzz: #M6
        interface: #M7
          map
            foo: #M2
            zzz: #M6
          implemented
            foo: #M2
            zzz: #M6
          superImplemented
            [0]
              foo: #M2
          inherited
            foo: #M2
''',
    );
  }

  test_manifest_baseName_inheritedInstanceGetter_inheritedInstanceSetter() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  int get foo {}
  set foo(int _) {}
}

class B extends A {
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        declaredSetters
          foo=: #M3
        interface: #M4
          map
            foo: #M2
            foo=: #M3
          implemented
            foo: #M2
            foo=: #M3
      B: #M5
        interface: #M6
          map
            foo: #M2
            foo=: #M3
          implemented
            foo: #M2
            foo=: #M3
          superImplemented
            [0]
              foo: #M2
              foo=: #M3
          inherited
            foo: #M2
            foo=: #M3
''',
      updatedCode: r'''
class A {
  int get foo {}
  set foo(int _) {}
}

class B extends A {
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        declaredSetters
          foo=: #M3
        interface: #M4
          map
            foo: #M2
            foo=: #M3
          implemented
            foo: #M2
            foo=: #M3
      B: #M5
        declaredMethods
          zzz: #M7
        interface: #M8
          map
            foo: #M2
            foo=: #M3
            zzz: #M7
          implemented
            foo: #M2
            foo=: #M3
            zzz: #M7
          superImplemented
            [0]
              foo: #M2
              foo=: #M3
          inherited
            foo: #M2
            foo=: #M3
''',
    );
  }

  test_manifest_baseName_inheritedInstanceMethod() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  void foo() {}
}

class B extends A {
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
      B: #M3
        interface: #M4
          map
            foo: #M1
          implemented
            foo: #M1
          superImplemented
            [0]
              foo: #M1
          inherited
            foo: #M1
''',
      updatedCode: r'''
class A {
  void foo() {}
}

class B extends A {
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
      B: #M3
        declaredMethods
          zzz: #M5
        interface: #M6
          map
            foo: #M1
            zzz: #M5
          implemented
            foo: #M1
            zzz: #M5
          superImplemented
            [0]
              foo: #M1
          inherited
            foo: #M1
''',
    );
  }

  test_manifest_baseName_inheritedInstanceSetter() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  set foo(int _) {}
}

class B extends A {
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredSetters
          foo=: #M2
        interface: #M3
          map
            foo=: #M2
          implemented
            foo=: #M2
      B: #M4
        interface: #M5
          map
            foo=: #M2
          implemented
            foo=: #M2
          superImplemented
            [0]
              foo=: #M2
          inherited
            foo=: #M2
''',
      updatedCode: r'''
class A {
  set foo(int _) {}
}

class B extends A {
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredSetters
          foo=: #M2
        interface: #M3
          map
            foo=: #M2
          implemented
            foo=: #M2
      B: #M4
        declaredMethods
          zzz: #M6
        interface: #M7
          map
            foo=: #M2
            zzz: #M6
          implemented
            foo=: #M2
            zzz: #M6
          superImplemented
            [0]
              foo=: #M2
          inherited
            foo=: #M2
''',
    );
  }

  test_manifest_class_add() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        interface: #M1
''',
      updatedCode: r'''
class A {}
class B {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        interface: #M1
      B: #M2
        interface: #M3
''',
    );
  }

  test_manifest_class_constructor_add() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  A.foo();
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConstructors
          foo: #M1
        interface: #M2
''',
      updatedCode: r'''
class A {
  A.foo();
  A.bar();
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConstructors
          bar: #M3
          foo: #M1
        interface: #M2
''',
    );
  }

  test_manifest_class_constructor_formalParameter_isInitializingFormal() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  final int x;
  A.foo1(this.x);
  A.foo2(int x): this.x = x;
  A.foo3(this.x);
  A.foo4(int x): this.x = x;
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          x: #M1
        declaredGetters
          x: #M2
        declaredConstructors
          foo1: #M3
          foo2: #M4
          foo3: #M5
          foo4: #M6
        interface: #M7
          map
            x: #M2
          implemented
            x: #M2
''',
      updatedCode: r'''
class A {
  final int x;
  A.foo1(this.x);
  A.foo2(int x): this.x = x;
  A.foo3(int x): this.x = x;
  A.foo4(this.x);
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          x: #M1
        declaredGetters
          x: #M2
        declaredConstructors
          foo1: #M3
          foo2: #M4
          foo3: #M8
          foo4: #M9
        interface: #M7
          map
            x: #M2
          implemented
            x: #M2
''',
    );
  }

  test_manifest_class_constructor_formalParameter_isSuperFormal() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  A(int x);
}

class B extends A {
  B.foo1(super.x);
  B.foo2(int x) : super(x);
  B.foo3(super.x);
  B.foo4(int x) : super(x);
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        interface: #M1
      B: #M2
        declaredConstructors
          foo1: #M3
          foo2: #M4
          foo3: #M5
          foo4: #M6
        interface: #M7
''',
      updatedCode: r'''
class A {
  A(int x);
}

class B extends A {
  B.foo1(super.x);
  B.foo2(int x) : super(x);
  B.foo3(int x) : super(x);
  B.foo4(super.x);
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        interface: #M1
      B: #M2
        declaredConstructors
          foo1: #M3
          foo2: #M4
          foo3: #M8
          foo4: #M9
        interface: #M7
''',
    );
  }

  test_manifest_class_constructor_formalParameter_optionalNamed_defaultValue() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  A.foo({int a = 0});
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConstructors
          foo: #M1
        interface: #M2
''',
      updatedCode: r'''
class A {
  A.foo({int a = 0});
  A.bar();
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConstructors
          bar: #M3
          foo: #M1
        interface: #M2
''',
    );
  }

  test_manifest_class_constructor_formalParameter_optionalNamed_defaultValue_change() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  A.foo({int a = 0});
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConstructors
          foo: #M1
        interface: #M2
''',
      updatedCode: r'''
class A {
  A.foo({int a = 1});
  A.bar();
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConstructors
          bar: #M3
          foo: #M4
        interface: #M2
''',
    );
  }

  test_manifest_class_constructor_formalParameter_optionalPositional_defaultValue() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  A.foo([int a = 0]);
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConstructors
          foo: #M1
        interface: #M2
''',
      updatedCode: r'''
class A {
  A.foo([int a = 0]);
  A.bar();
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConstructors
          bar: #M3
          foo: #M1
        interface: #M2
''',
    );
  }

  test_manifest_class_constructor_formalParameter_optionalPositional_defaultValue_change() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  A.foo([int a = 0]);
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConstructors
          foo: #M1
        interface: #M2
''',
      updatedCode: r'''
class A {
  A.foo([int a = 1]);
  A.bar();
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConstructors
          bar: #M3
          foo: #M4
        interface: #M2
''',
    );
  }

  test_manifest_class_constructor_formalParameter_requiredPositional() async {
    configuration.includeDefaultConstructors();
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  A.foo(int a);
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConstructors
          foo: #M1
        interface: #M2
''',
      updatedCode: r'''
class A {
  A.foo(int a);
  A.bar();
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConstructors
          bar: #M3
          foo: #M1
        interface: #M2
''',
    );
  }

  test_manifest_class_constructor_formalParameter_requiredPositional_add() async {
    configuration.includeDefaultConstructors();
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  A(int a);
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConstructors
          new: #M1
        interface: #M2
''',
      updatedCode: r'''
class A {
  A(int a, int b);
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConstructors
          new: #M3
        interface: #M2
''',
    );
  }

  test_manifest_class_constructor_idChangesWithContainer() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {}
class B {}
class C extends B {
  C.named();
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        interface: #M1
      B: #M2
        interface: #M3
      C: #M4
        declaredConstructors
          named: #M5
        interface: #M6
''',
      updatedCode: r'''
class A {}
class B extends A {}
class C extends B {
  C.named();
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        interface: #M1
      B: #M7
        interface: #M8
      C: #M9
        declaredConstructors
          named: #M10
        interface: #M11
''',
    );
  }

  test_manifest_class_constructor_initializers_isConst_add() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  const A.named(int x);
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConstructors
          named: #M1
        interface: #M2
''',
      updatedCode: r'''
class A {
  const A.named(int x) : assert(x > 0);
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConstructors
          named: #M3
        interface: #M2
''',
    );
  }

  test_manifest_class_constructor_initializers_isConst_assert() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  const A.c1(int x) : assert(x > 0);
  const A.c2(int x) : assert(x > 0);
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConstructors
          c1: #M1
          c2: #M2
        interface: #M3
''',
      updatedCode: r'''
class A {
  const A.c1(int x) : assert(x > 0);
  const A.c2(int x) : assert(x > 1);
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConstructors
          c1: #M1
          c2: #M4
        interface: #M3
''',
    );
  }

  test_manifest_class_constructor_initializers_isConst_fieldInitializer_name() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  final int foo;
  const A.named() : bar = 0;
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        declaredConstructors
          named: #M3
        interface: #M4
          map
            foo: #M2
          implemented
            foo: #M2
''',
      updatedCode: r'''
class A {
  final int foo;
  const A.named() : foo = 0;
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        declaredConstructors
          named: #M5
        interface: #M4
          map
            foo: #M2
          implemented
            foo: #M2
''',
    );
  }

  test_manifest_class_constructor_initializers_isConst_fieldInitializer_value() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  final int foo;
  const A.named() : foo = 0;
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        declaredConstructors
          named: #M3
        interface: #M4
          map
            foo: #M2
          implemented
            foo: #M2
''',
      updatedCode: r'''
class A {
  final int foo;
  const A.named() : foo = 1;
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        declaredConstructors
          named: #M5
        interface: #M4
          map
            foo: #M2
          implemented
            foo: #M2
''',
    );
  }

  test_manifest_class_constructor_initializers_isConst_formalParameter_exchange() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  const A.named(int x, int y) : assert(x > 0);
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConstructors
          named: #M1
        interface: #M2
''',
      updatedCode: r'''
class A {
  const A.named(int y, int x) : assert(x > 0);
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConstructors
          named: #M3
        interface: #M2
''',
    );
  }

  test_manifest_class_constructor_initializers_isConst_redirect_argument() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  final int f;
  const A.c1(int a) : f = a;
  const A.c2() : this.c1(0);
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          f: #M1
        declaredGetters
          f: #M2
        declaredConstructors
          c1: #M3
          c2: #M4
        interface: #M5
          map
            f: #M2
          implemented
            f: #M2
''',
      updatedCode: r'''
class A {
  final int f;
  const A.c1(int a) : f = a;
  const A.c2() : this.c1(1);
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          f: #M1
        declaredGetters
          f: #M2
        declaredConstructors
          c1: #M3
          c2: #M6
        interface: #M5
          map
            f: #M2
          implemented
            f: #M2
''',
    );
  }

  test_manifest_class_constructor_initializers_isConst_redirect_name() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  final int f;
  const A.c1() : f = 0;
  const A.c2() : f = 1;
  const A.c3() : this.c1();
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          f: #M1
        declaredGetters
          f: #M2
        declaredConstructors
          c1: #M3
          c2: #M4
          c3: #M5
        interface: #M6
          map
            f: #M2
          implemented
            f: #M2
''',
      updatedCode: r'''
class A {
  final int f;
  const A.c1() : f = 0;
  const A.c2() : f = 1;
  const A.c3() : this.c2();
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          f: #M1
        declaredGetters
          f: #M2
        declaredConstructors
          c1: #M3
          c2: #M4
          c3: #M7
        interface: #M6
          map
            f: #M2
          implemented
            f: #M2
''',
    );
  }

  test_manifest_class_constructor_initializers_isConst_remove() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  const A.named(int x) : assert(x > 0);
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConstructors
          named: #M1
        interface: #M2
''',
      updatedCode: r'''
class A {
  const A.named(int x);
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConstructors
          named: #M3
        interface: #M2
''',
    );
  }

  test_manifest_class_constructor_initializers_isConst_super_argument() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  const A.named(int _);
}

class B extends A {
  const A.named() : super.named(0);
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConstructors
          named: #M1
        interface: #M2
      B: #M3
        declaredConstructors
          named: #M4
        interface: #M5
''',
      updatedCode: r'''
class A {
  const A.named(int _);
}

class B extends A {
  const A.named() : super.named(1);
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConstructors
          named: #M1
        interface: #M2
      B: #M3
        declaredConstructors
          named: #M6
        interface: #M5
''',
    );
  }

  test_manifest_class_constructor_initializers_isConst_super_name() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  final int f;
  const A.c1() : f = 0;
  const A.c2() : f = 1;
}

class B extends A {
  const A.named() : super.c1(0);
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          f: #M1
        declaredGetters
          f: #M2
        declaredConstructors
          c1: #M3
          c2: #M4
        interface: #M5
          map
            f: #M2
          implemented
            f: #M2
      B: #M6
        declaredConstructors
          named: #M7
        interface: #M8
          map
            f: #M2
          implemented
            f: #M2
          superImplemented
            [0]
              f: #M2
          inherited
            f: #M2
''',
      updatedCode: r'''
class A {
  final int f;
  const A.c1() : f = 0;
  const A.c2() : f = 1;
}

class B extends A {
  const A.named() : super.c2(0);
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          f: #M1
        declaredGetters
          f: #M2
        declaredConstructors
          c1: #M3
          c2: #M4
        interface: #M5
          map
            f: #M2
          implemented
            f: #M2
      B: #M6
        declaredConstructors
          named: #M9
        interface: #M8
          map
            f: #M2
          implemented
            f: #M2
          superImplemented
            [0]
              f: #M2
          inherited
            f: #M2
''',
    );
  }

  test_manifest_class_constructor_initializers_isConst_super_transitive() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  final int f;
  const A.named() : f = 0;
}

class B extends A {
  const A.named() : super.named();
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          f: #M1
        declaredGetters
          f: #M2
        declaredConstructors
          named: #M3
        interface: #M4
          map
            f: #M2
          implemented
            f: #M2
      B: #M5
        declaredConstructors
          named: #M6
        interface: #M7
          map
            f: #M2
          implemented
            f: #M2
          superImplemented
            [0]
              f: #M2
          inherited
            f: #M2
''',
      updatedCode: r'''
class A {
  final int f;
  const A.named() : f = 1;
}

class B extends A {
  const A.named() : super.named();
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          f: #M1
        declaredGetters
          f: #M2
        declaredConstructors
          named: #M8
        interface: #M4
          map
            f: #M2
          implemented
            f: #M2
      B: #M5
        declaredConstructors
          named: #M9
        interface: #M7
          map
            f: #M2
          implemented
            f: #M2
          superImplemented
            [0]
              f: #M2
          inherited
            f: #M2
''',
    );
  }

  test_manifest_class_constructor_initializers_notConst_assert() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  A.named(int x) : assert(x > 0);
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConstructors
          named: #M1
        interface: #M2
''',
      updatedCode: r'''
class A {
  A.named(int x) : assert(x > 1);
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConstructors
          named: #M1
        interface: #M2
''',
    );
  }

  test_manifest_class_constructor_initializers_notConst_fieldInitializer_value() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  final int foo;
  A.named() : foo = 0;
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        declaredConstructors
          named: #M3
        interface: #M4
          map
            foo: #M2
          implemented
            foo: #M2
''',
      updatedCode: r'''
class A {
  final int foo;
  A.named() : foo = 1;
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        declaredConstructors
          named: #M3
        interface: #M4
          map
            foo: #M2
          implemented
            foo: #M2
''',
    );
  }

  test_manifest_class_constructor_initializers_notConst_redirect_argument() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  final int f;
  A.c1(int a) : f = a;
  A.c2() : this.c1(0);
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          f: #M1
        declaredGetters
          f: #M2
        declaredConstructors
          c1: #M3
          c2: #M4
        interface: #M5
          map
            f: #M2
          implemented
            f: #M2
''',
      updatedCode: r'''
class A {
  final int f;
  A.c1(int a) : f = a;
  A.c2() : this.c1(1);
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          f: #M1
        declaredGetters
          f: #M2
        declaredConstructors
          c1: #M3
          c2: #M4
        interface: #M5
          map
            f: #M2
          implemented
            f: #M2
''',
    );
  }

  test_manifest_class_constructor_initializers_notConst_super_argument() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  const A.named(int _);
}

class B extends A {
  A.named() : super.named(0);
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConstructors
          named: #M1
        interface: #M2
      B: #M3
        declaredConstructors
          named: #M4
        interface: #M5
''',
      updatedCode: r'''
class A {
  const A.named(int _);
}

class B extends A {
  A.named() : super.named(1);
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConstructors
          named: #M1
        interface: #M2
      B: #M3
        declaredConstructors
          named: #M4
        interface: #M5
''',
    );
  }

  test_manifest_class_constructor_isSynthetic() async {
    configuration.includeDefaultConstructors();
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {}
class B {
  B();
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConstructors
          new: #M1
        interface: #M2
      B: #M3
        declaredConstructors
          new: #M4
        interface: #M5
''',
      updatedCode: r'''
class A {
  A();
}
class B {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConstructors
          new: #M6
        interface: #M2
      B: #M3
        declaredConstructors
          new: #M7
        interface: #M5
''',
    );
  }

  test_manifest_class_constructor_metadata() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  @Deprected('0')
  A.foo();
  @Deprected('0')
  A.bar();
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConstructors
          bar: #M1
          foo: #M2
        interface: #M3
''',
      updatedCode: r'''
class A {
  @Deprected('1')
  A.foo();
  @Deprected('0')
  A.bar();
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConstructors
          bar: #M1
          foo: #M4
        interface: #M3
''',
    );
  }

  test_manifest_class_constructor_modifier_isConst() async {
    configuration.withElementManifests = true;
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  A.foo1();
  const A.foo2();
  A.foo3();
  const A.foo4();
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        supertype: Object @ dart:core
        declaredConstructors
          foo1: #M1
              flags: hasEnclosingTypeParameterReference isSimplyBounded
              functionType: FunctionType
                returnType: A @ package:test/test.dart
              superConstructor: (dart:core, interfaceConstructor, Object, new) #M2
          foo2: #M3
              flags: hasEnclosingTypeParameterReference isConst isSimplyBounded
              functionType: FunctionType
                returnType: A @ package:test/test.dart
              superConstructor: (dart:core, interfaceConstructor, Object, new) #M2
          foo3: #M4
              flags: hasEnclosingTypeParameterReference isSimplyBounded
              functionType: FunctionType
                returnType: A @ package:test/test.dart
              superConstructor: (dart:core, interfaceConstructor, Object, new) #M2
          foo4: #M5
              flags: hasEnclosingTypeParameterReference isConst isSimplyBounded
              functionType: FunctionType
                returnType: A @ package:test/test.dart
              superConstructor: (dart:core, interfaceConstructor, Object, new) #M2
        interface: #M6
''',
      updatedCode: r'''
class A {
  A.foo1();
  const A.foo2();
  const A.foo3();
  A.foo4();
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        supertype: Object @ dart:core
        declaredConstructors
          foo1: #M1
              flags: hasEnclosingTypeParameterReference isSimplyBounded
              functionType: FunctionType
                returnType: A @ package:test/test.dart
              superConstructor: (dart:core, interfaceConstructor, Object, new) #M2
          foo2: #M3
              flags: hasEnclosingTypeParameterReference isConst isSimplyBounded
              functionType: FunctionType
                returnType: A @ package:test/test.dart
              superConstructor: (dart:core, interfaceConstructor, Object, new) #M2
          foo3: #M7
              flags: hasEnclosingTypeParameterReference isConst isSimplyBounded
              functionType: FunctionType
                returnType: A @ package:test/test.dart
              superConstructor: (dart:core, interfaceConstructor, Object, new) #M2
          foo4: #M8
              flags: hasEnclosingTypeParameterReference isSimplyBounded
              functionType: FunctionType
                returnType: A @ package:test/test.dart
              superConstructor: (dart:core, interfaceConstructor, Object, new) #M2
        interface: #M6
''',
    );
  }

  test_manifest_class_constructor_modifier_isExternal() async {
    configuration.withElementManifests = true;
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  A.foo1() {}
  external A.foo2();
  A.foo3() {}
  external A.foo4();
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        supertype: Object @ dart:core
        declaredConstructors
          foo1: #M1
              flags: hasEnclosingTypeParameterReference isSimplyBounded
              functionType: FunctionType
                returnType: A @ package:test/test.dart
              superConstructor: (dart:core, interfaceConstructor, Object, new) #M2
          foo2: #M3
              flags: hasEnclosingTypeParameterReference isExternal isSimplyBounded
              functionType: FunctionType
                returnType: A @ package:test/test.dart
              superConstructor: (dart:core, interfaceConstructor, Object, new) #M2
          foo3: #M4
              flags: hasEnclosingTypeParameterReference isSimplyBounded
              functionType: FunctionType
                returnType: A @ package:test/test.dart
              superConstructor: (dart:core, interfaceConstructor, Object, new) #M2
          foo4: #M5
              flags: hasEnclosingTypeParameterReference isExternal isSimplyBounded
              functionType: FunctionType
                returnType: A @ package:test/test.dart
              superConstructor: (dart:core, interfaceConstructor, Object, new) #M2
        interface: #M6
''',
      updatedCode: r'''
class A {
  A.foo1() {}
  external A.foo2();
  external A.foo3();
  A.foo4() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        supertype: Object @ dart:core
        declaredConstructors
          foo1: #M1
              flags: hasEnclosingTypeParameterReference isSimplyBounded
              functionType: FunctionType
                returnType: A @ package:test/test.dart
              superConstructor: (dart:core, interfaceConstructor, Object, new) #M2
          foo2: #M3
              flags: hasEnclosingTypeParameterReference isExternal isSimplyBounded
              functionType: FunctionType
                returnType: A @ package:test/test.dart
              superConstructor: (dart:core, interfaceConstructor, Object, new) #M2
          foo3: #M7
              flags: hasEnclosingTypeParameterReference isExternal isSimplyBounded
              functionType: FunctionType
                returnType: A @ package:test/test.dart
              superConstructor: (dart:core, interfaceConstructor, Object, new) #M2
          foo4: #M8
              flags: hasEnclosingTypeParameterReference isSimplyBounded
              functionType: FunctionType
                returnType: A @ package:test/test.dart
              superConstructor: (dart:core, interfaceConstructor, Object, new) #M2
        interface: #M6
''',
    );
  }

  test_manifest_class_constructor_modifier_isFactory() async {
    configuration.withElementManifests = true;
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  A.foo1();
  factory A.foo2();
  A.foo3();
  factory A.foo4();
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        supertype: Object @ dart:core
        declaredConstructors
          foo1: #M1
              flags: hasEnclosingTypeParameterReference isSimplyBounded
              functionType: FunctionType
                returnType: A @ package:test/test.dart
              superConstructor: (dart:core, interfaceConstructor, Object, new) #M2
          foo2: #M3
              flags: hasEnclosingTypeParameterReference isFactory isSimplyBounded
              functionType: FunctionType
                returnType: A @ package:test/test.dart
          foo3: #M4
              flags: hasEnclosingTypeParameterReference isSimplyBounded
              functionType: FunctionType
                returnType: A @ package:test/test.dart
              superConstructor: (dart:core, interfaceConstructor, Object, new) #M2
          foo4: #M5
              flags: hasEnclosingTypeParameterReference isFactory isSimplyBounded
              functionType: FunctionType
                returnType: A @ package:test/test.dart
        interface: #M6
''',
      updatedCode: r'''
class A {
  A.foo1();
  factory A.foo2();
  factory A.foo3();
  A.foo4();
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        supertype: Object @ dart:core
        declaredConstructors
          foo1: #M1
              flags: hasEnclosingTypeParameterReference isSimplyBounded
              functionType: FunctionType
                returnType: A @ package:test/test.dart
              superConstructor: (dart:core, interfaceConstructor, Object, new) #M2
          foo2: #M3
              flags: hasEnclosingTypeParameterReference isFactory isSimplyBounded
              functionType: FunctionType
                returnType: A @ package:test/test.dart
          foo3: #M7
              flags: hasEnclosingTypeParameterReference isFactory isSimplyBounded
              functionType: FunctionType
                returnType: A @ package:test/test.dart
          foo4: #M8
              flags: hasEnclosingTypeParameterReference isSimplyBounded
              functionType: FunctionType
                returnType: A @ package:test/test.dart
              superConstructor: (dart:core, interfaceConstructor, Object, new) #M2
        interface: #M6
''',
    );
  }

  test_manifest_class_constructor_private() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  A._foo();
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConstructors
          _foo: #M1
        interface: #M2
''',
      updatedCode: r'''
class A {
  A._foo();
  A.bar();
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConstructors
          _foo: #M1
          bar: #M3
        interface: #M2
''',
    );
  }

  test_manifest_class_constructor_private_const() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  const A._foo();
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConstructors
          _foo: #M1
        interface: #M2
''',
      updatedCode: r'''
class A {
  const A._foo();
  A.bar();
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConstructors
          _foo: #M1
          bar: #M3
        interface: #M2
''',
    );
  }

  test_manifest_class_constructor_redirectedConstructor() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  A.foo1(int _);
  A.foo2(int _);
  A.foo3(int _) : this.foo1(0);
  A.foo4(int _) : this.foo2(0);
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConstructors
          foo1: #M1
          foo2: #M2
          foo3: #M3
          foo4: #M4
        interface: #M5
''',
      updatedCode: r'''
class A {
  A.foo1(int _);
  A.foo2(double _);
  A.foo3(int _) : this.foo1(0);
  A.foo4(int _) : this.foo2(0);
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConstructors
          foo1: #M1
          foo2: #M6
          foo3: #M3
          foo4: #M7
        interface: #M5
''',
    );
  }

  test_manifest_class_constructor_redirectedConstructor_factory() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  factory A.foo1(int _) = B.bar1;
  factory A.foo2(int _) = B.bar2;
}

class B implements A {
  B.bar1(int _);
  B.bar2(int _);
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConstructors
          foo1: #M1
          foo2: #M2
        interface: #M3
      B: #M4
        declaredConstructors
          bar1: #M5
          bar2: #M6
        interface: #M7
''',
      updatedCode: r'''
class A {
  factory A.foo1(int _) = B.bar1;
  factory A.foo2(int _) = B.bar2;
}

class B implements A {
  B.bar1(int _);
  B.bar2(double _);
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConstructors
          foo1: #M1
          foo2: #M8
        interface: #M3
      B: #M4
        declaredConstructors
          bar1: #M5
          bar2: #M9
        interface: #M7
''',
    );
  }

  test_manifest_class_constructor_superConstructor() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  A.foo1(int _);
  A.foo2(int _);
}

class B extends A {
  B.bar1(int _) : super.foo1();
  B.bar2(int _) : super.foo2();
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConstructors
          foo1: #M1
          foo2: #M2
        interface: #M3
      B: #M4
        declaredConstructors
          bar1: #M5
          bar2: #M6
        interface: #M7
''',
      updatedCode: r'''
class A {
  A.foo1(int _);
  A.foo2(double _);
}

class B extends A {
  B.bar1(int _) : super.foo1();
  B.bar2(int _) : super.foo2();
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConstructors
          foo1: #M1
          foo2: #M8
        interface: #M3
      B: #M4
        declaredConstructors
          bar1: #M5
          bar2: #M9
        interface: #M7
''',
    );
  }

  test_manifest_class_extendsAdd_direct() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {}
class B {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        interface: #M1
      B: #M2
        interface: #M3
''',
      updatedCode: r'''
class A extends B {}
class B {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M4
        interface: #M5
      B: #M2
        interface: #M3
''',
    );
  }

  test_manifest_class_extendsAdd_indirect() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A extends B {}
class B {}
class C {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        interface: #M1
      B: #M2
        interface: #M3
      C: #M4
        interface: #M5
''',
      updatedCode: r'''
class A extends B {}
class B extends C {}
class C {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M6
        interface: #M7
      B: #M8
        interface: #M9
      C: #M4
        interface: #M5
''',
    );
  }

  test_manifest_class_extendsChange() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A extends B {}
class B {}
class C {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        interface: #M1
      B: #M2
        interface: #M3
      C: #M4
        interface: #M5
''',
      updatedCode: r'''
class A extends C {}
class B {}
class C {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M6
        interface: #M7
      B: #M2
        interface: #M3
      C: #M4
        interface: #M5
''',
    );
  }

  test_manifest_class_field_add() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  final a = 0;
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          a: #M1
        declaredGetters
          a: #M2
        interface: #M3
          map
            a: #M2
          implemented
            a: #M2
''',
      updatedCode: r'''
class A {
  final a = 0;
  final b = 1;
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          a: #M1
          b: #M4
        declaredGetters
          a: #M2
          b: #M5
        interface: #M6
          map
            a: #M2
            b: #M5
          implemented
            a: #M2
            b: #M5
''',
    );
  }

  test_manifest_class_field_const_initializer() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  static const a = 0;
  static const b = 0;
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          a: #M1
          b: #M2
        declaredGetters
          a: #M3
          b: #M4
        interface: #M5
''',
      updatedCode: r'''
class A {
  static const a = 1;
  static const b = 0;
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          a: #M6
          b: #M2
        declaredGetters
          a: #M3
          b: #M4
        interface: #M5
''',
    );
  }

  test_manifest_class_field_idChangesWithContainer() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {}
class B {}
class C extends B {
  var foo = 0;
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        interface: #M1
      B: #M2
        interface: #M3
      C: #M4
        declaredFields
          foo: #M5
        declaredGetters
          foo: #M6
        declaredSetters
          foo=: #M7
        interface: #M8
          map
            foo: #M6
            foo=: #M7
          implemented
            foo: #M6
            foo=: #M7
''',
      updatedCode: r'''
class A {}
class B extends A {}
class C extends B {
  var foo = 0;
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        interface: #M1
      B: #M9
        interface: #M10
      C: #M11
        declaredFields
          foo: #M12
        declaredGetters
          foo: #M13
        declaredSetters
          foo=: #M14
        interface: #M15
          map
            foo: #M13
            foo=: #M14
          implemented
            foo: #M13
            foo=: #M14
''',
    );
  }

  test_manifest_class_field_initializer_type() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  final a = 0;
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          a: #M1
        declaredGetters
          a: #M2
        interface: #M3
          map
            a: #M2
          implemented
            a: #M2
''',
      updatedCode: r'''
class A {
  final a = 1.2;
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          a: #M4
        declaredGetters
          a: #M5
        interface: #M6
          map
            a: #M5
          implemented
            a: #M5
''',
    );
  }

  test_manifest_class_field_initializer_value_final() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  final a = 0;
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          a: #M1
        declaredGetters
          a: #M2
        interface: #M3
          map
            a: #M2
          implemented
            a: #M2
''',
      updatedCode: r'''
class A {
  final a = 1;
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          a: #M1
        declaredGetters
          a: #M2
        interface: #M3
          map
            a: #M2
          implemented
            a: #M2
''',
    );
  }

  test_manifest_class_field_initializer_value_static_const() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  static const a = 0;
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          a: #M1
        declaredGetters
          a: #M2
        interface: #M3
''',
      updatedCode: r'''
class A {
  static const a = 1;
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          a: #M4
        declaredGetters
          a: #M2
        interface: #M3
''',
    );
  }

  test_manifest_class_field_initializer_value_static_final() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  static final a = 0;
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          a: #M1
        declaredGetters
          a: #M2
        interface: #M3
''',
      updatedCode: r'''
class A {
  static final a = 1;
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          a: #M1
        declaredGetters
          a: #M2
        interface: #M3
''',
    );
  }

  test_manifest_class_field_metadata() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  @Deprecated('0')
  var a = 0;
  @Deprecated('0')
  var b = 0;
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          a: #M1
          b: #M2
        declaredGetters
          a: #M3
          b: #M4
        declaredSetters
          a=: #M5
          b=: #M6
        interface: #M7
          map
            a: #M3
            a=: #M5
            b: #M4
            b=: #M6
          implemented
            a: #M3
            a=: #M5
            b: #M4
            b=: #M6
''',
      updatedCode: r'''
class A {
  @Deprecated('1')
  var a = 0;
  @Deprecated('0')
  var b = 0;
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          a: #M8
          b: #M2
        declaredGetters
          a: #M9
          b: #M4
        declaredSetters
          a=: #M10
          b=: #M6
        interface: #M11
          map
            a: #M9
            a=: #M10
            b: #M4
            b=: #M6
          implemented
            a: #M9
            a=: #M10
            b: #M4
            b=: #M6
''',
    );
  }

  test_manifest_class_field_modifier_hasEnclosingTypeParameterReference() async {
    configuration.withElementManifests = true;

    await _runLibraryManifestScenario(
      initialCode: r'''
class A<T> {
  final T? foo1;
  final int? foo2;
  final T? foo3;
  final int? foo4;
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        typeParameters
          #0 covariant
            bound: <null>
        supertype: Object @ dart:core
        declaredFields
          foo1: #M1
            flags: hasEnclosingTypeParameterReference isFinal shouldUseTypeForInitializerInference
            type: typeParameter#0?
          foo2: #M2
            flags: isFinal shouldUseTypeForInitializerInference
            type: int? @ dart:core
          foo3: #M3
            flags: hasEnclosingTypeParameterReference isFinal shouldUseTypeForInitializerInference
            type: typeParameter#0?
          foo4: #M4
            flags: isFinal shouldUseTypeForInitializerInference
            type: int? @ dart:core
        declaredGetters
          foo1: #M5
            flags: hasEnclosingTypeParameterReference isSimplyBounded isSynthetic
            returnType: typeParameter#0?
          foo2: #M6
            flags: isSimplyBounded isSynthetic
            returnType: int? @ dart:core
          foo3: #M7
            flags: hasEnclosingTypeParameterReference isSimplyBounded isSynthetic
            returnType: typeParameter#0?
          foo4: #M8
            flags: isSimplyBounded isSynthetic
            returnType: int? @ dart:core
        interface: #M9
          map
            foo1: #M5
            foo2: #M6
            foo3: #M7
            foo4: #M8
          implemented
            foo1: #M5
            foo2: #M6
            foo3: #M7
            foo4: #M8
''',
      updatedCode: r'''
class A<T> {
  final T? foo1;
  final int? foo2;
  final int? foo3;
  final T? foo4;
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        typeParameters
          #0 covariant
            bound: <null>
        supertype: Object @ dart:core
        declaredFields
          foo1: #M1
            flags: hasEnclosingTypeParameterReference isFinal shouldUseTypeForInitializerInference
            type: typeParameter#0?
          foo2: #M2
            flags: isFinal shouldUseTypeForInitializerInference
            type: int? @ dart:core
          foo3: #M10
            flags: isFinal shouldUseTypeForInitializerInference
            type: int? @ dart:core
          foo4: #M11
            flags: hasEnclosingTypeParameterReference isFinal shouldUseTypeForInitializerInference
            type: typeParameter#0?
        declaredGetters
          foo1: #M5
            flags: hasEnclosingTypeParameterReference isSimplyBounded isSynthetic
            returnType: typeParameter#0?
          foo2: #M6
            flags: isSimplyBounded isSynthetic
            returnType: int? @ dart:core
          foo3: #M12
            flags: isSimplyBounded isSynthetic
            returnType: int? @ dart:core
          foo4: #M13
            flags: hasEnclosingTypeParameterReference isSimplyBounded isSynthetic
            returnType: typeParameter#0?
        interface: #M14
          map
            foo1: #M5
            foo2: #M6
            foo3: #M12
            foo4: #M13
          implemented
            foo1: #M5
            foo2: #M6
            foo3: #M12
            foo4: #M13
''',
    );
  }

  test_manifest_class_field_modifier_hasImplicitType() async {
    configuration.withElementManifests = true;

    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  final foo1 = 0;
  final int foo2 = 0;
  final foo3 = 0;
  final int foo4 = 0;
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        supertype: Object @ dart:core
        declaredFields
          foo1: #M1
            flags: hasImplicitType hasInitializer isFinal
            type: int @ dart:core
          foo2: #M2
            flags: hasInitializer isFinal shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo3: #M3
            flags: hasImplicitType hasInitializer isFinal
            type: int @ dart:core
          foo4: #M4
            flags: hasInitializer isFinal shouldUseTypeForInitializerInference
            type: int @ dart:core
        declaredGetters
          foo1: #M5
            flags: isSimplyBounded isSynthetic
            returnType: int @ dart:core
          foo2: #M6
            flags: isSimplyBounded isSynthetic
            returnType: int @ dart:core
          foo3: #M7
            flags: isSimplyBounded isSynthetic
            returnType: int @ dart:core
          foo4: #M8
            flags: isSimplyBounded isSynthetic
            returnType: int @ dart:core
        interface: #M9
          map
            foo1: #M5
            foo2: #M6
            foo3: #M7
            foo4: #M8
          implemented
            foo1: #M5
            foo2: #M6
            foo3: #M7
            foo4: #M8
''',
      updatedCode: r'''
class A {
  final foo1 = 0;
  final int foo2 = 0;
  final int foo3 = 0;
  final foo4 = 0;
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        supertype: Object @ dart:core
        declaredFields
          foo1: #M1
            flags: hasImplicitType hasInitializer isFinal
            type: int @ dart:core
          foo2: #M2
            flags: hasInitializer isFinal shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo3: #M10
            flags: hasInitializer isFinal shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo4: #M11
            flags: hasImplicitType hasInitializer isFinal
            type: int @ dart:core
        declaredGetters
          foo1: #M5
            flags: isSimplyBounded isSynthetic
            returnType: int @ dart:core
          foo2: #M6
            flags: isSimplyBounded isSynthetic
            returnType: int @ dart:core
          foo3: #M7
            flags: isSimplyBounded isSynthetic
            returnType: int @ dart:core
          foo4: #M8
            flags: isSimplyBounded isSynthetic
            returnType: int @ dart:core
        interface: #M9
          map
            foo1: #M5
            foo2: #M6
            foo3: #M7
            foo4: #M8
          implemented
            foo1: #M5
            foo2: #M6
            foo3: #M7
            foo4: #M8
''',
    );
  }

  test_manifest_class_field_modifier_hasInitializer() async {
    configuration.withElementManifests = true;

    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  final int? foo1 = 0;
  final int? foo2;
  final int? foo3 = 0;
  final int? foo4;
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        supertype: Object @ dart:core
        declaredFields
          foo1: #M1
            flags: hasInitializer isFinal shouldUseTypeForInitializerInference
            type: int? @ dart:core
          foo2: #M2
            flags: isFinal shouldUseTypeForInitializerInference
            type: int? @ dart:core
          foo3: #M3
            flags: hasInitializer isFinal shouldUseTypeForInitializerInference
            type: int? @ dart:core
          foo4: #M4
            flags: isFinal shouldUseTypeForInitializerInference
            type: int? @ dart:core
        declaredGetters
          foo1: #M5
            flags: isSimplyBounded isSynthetic
            returnType: int? @ dart:core
          foo2: #M6
            flags: isSimplyBounded isSynthetic
            returnType: int? @ dart:core
          foo3: #M7
            flags: isSimplyBounded isSynthetic
            returnType: int? @ dart:core
          foo4: #M8
            flags: isSimplyBounded isSynthetic
            returnType: int? @ dart:core
        interface: #M9
          map
            foo1: #M5
            foo2: #M6
            foo3: #M7
            foo4: #M8
          implemented
            foo1: #M5
            foo2: #M6
            foo3: #M7
            foo4: #M8
''',
      updatedCode: r'''
class A {
  final int? foo1 = 0;
  final int? foo2;
  final int? foo3;
  final int? foo4 = 0;
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        supertype: Object @ dart:core
        declaredFields
          foo1: #M1
            flags: hasInitializer isFinal shouldUseTypeForInitializerInference
            type: int? @ dart:core
          foo2: #M2
            flags: isFinal shouldUseTypeForInitializerInference
            type: int? @ dart:core
          foo3: #M10
            flags: isFinal shouldUseTypeForInitializerInference
            type: int? @ dart:core
          foo4: #M11
            flags: hasInitializer isFinal shouldUseTypeForInitializerInference
            type: int? @ dart:core
        declaredGetters
          foo1: #M5
            flags: isSimplyBounded isSynthetic
            returnType: int? @ dart:core
          foo2: #M6
            flags: isSimplyBounded isSynthetic
            returnType: int? @ dart:core
          foo3: #M7
            flags: isSimplyBounded isSynthetic
            returnType: int? @ dart:core
          foo4: #M8
            flags: isSimplyBounded isSynthetic
            returnType: int? @ dart:core
        interface: #M9
          map
            foo1: #M5
            foo2: #M6
            foo3: #M7
            foo4: #M8
          implemented
            foo1: #M5
            foo2: #M6
            foo3: #M7
            foo4: #M8
''',
    );
  }

  test_manifest_class_field_modifier_isAbstract() async {
    configuration.withElementManifests = true;

    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  abstract int? foo1;
  int? foo2;
  abstract int? foo3;
  int? foo4;
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        flags: hasNonFinalField
        supertype: Object @ dart:core
        declaredFields
          foo1: #M1
            flags: isAbstract shouldUseTypeForInitializerInference
            type: int? @ dart:core
          foo2: #M2
            flags: shouldUseTypeForInitializerInference
            type: int? @ dart:core
          foo3: #M3
            flags: isAbstract shouldUseTypeForInitializerInference
            type: int? @ dart:core
          foo4: #M4
            flags: shouldUseTypeForInitializerInference
            type: int? @ dart:core
        declaredGetters
          foo1: #M5
            flags: isAbstract isSimplyBounded isSynthetic
            returnType: int? @ dart:core
          foo2: #M6
            flags: isSimplyBounded isSynthetic
            returnType: int? @ dart:core
          foo3: #M7
            flags: isAbstract isSimplyBounded isSynthetic
            returnType: int? @ dart:core
          foo4: #M8
            flags: isSimplyBounded isSynthetic
            returnType: int? @ dart:core
        declaredSetters
          foo1=: #M9
            flags: isAbstract isSimplyBounded isSynthetic
            functionType: FunctionType
              positional
                required int? @ dart:core
              returnType: void
          foo2=: #M10
            flags: isSimplyBounded isSynthetic
            functionType: FunctionType
              positional
                required int? @ dart:core
              returnType: void
          foo3=: #M11
            flags: isAbstract isSimplyBounded isSynthetic
            functionType: FunctionType
              positional
                required int? @ dart:core
              returnType: void
          foo4=: #M12
            flags: isSimplyBounded isSynthetic
            functionType: FunctionType
              positional
                required int? @ dart:core
              returnType: void
        interface: #M13
          map
            foo1: #M5
            foo1=: #M9
            foo2: #M6
            foo2=: #M10
            foo3: #M7
            foo3=: #M11
            foo4: #M8
            foo4=: #M12
          implemented
            foo2: #M6
            foo2=: #M10
            foo4: #M8
            foo4=: #M12
''',
      updatedCode: r'''
class A {
  abstract int? foo1;
  int? foo2;
  int? foo3;
  abstract int? foo4;
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        flags: hasNonFinalField
        supertype: Object @ dart:core
        declaredFields
          foo1: #M1
            flags: isAbstract shouldUseTypeForInitializerInference
            type: int? @ dart:core
          foo2: #M2
            flags: shouldUseTypeForInitializerInference
            type: int? @ dart:core
          foo3: #M14
            flags: shouldUseTypeForInitializerInference
            type: int? @ dart:core
          foo4: #M15
            flags: isAbstract shouldUseTypeForInitializerInference
            type: int? @ dart:core
        declaredGetters
          foo1: #M5
            flags: isAbstract isSimplyBounded isSynthetic
            returnType: int? @ dart:core
          foo2: #M6
            flags: isSimplyBounded isSynthetic
            returnType: int? @ dart:core
          foo3: #M16
            flags: isSimplyBounded isSynthetic
            returnType: int? @ dart:core
          foo4: #M17
            flags: isAbstract isSimplyBounded isSynthetic
            returnType: int? @ dart:core
        declaredSetters
          foo1=: #M9
            flags: isAbstract isSimplyBounded isSynthetic
            functionType: FunctionType
              positional
                required int? @ dart:core
              returnType: void
          foo2=: #M10
            flags: isSimplyBounded isSynthetic
            functionType: FunctionType
              positional
                required int? @ dart:core
              returnType: void
          foo3=: #M18
            flags: isSimplyBounded isSynthetic
            functionType: FunctionType
              positional
                required int? @ dart:core
              returnType: void
          foo4=: #M19
            flags: isAbstract isSimplyBounded isSynthetic
            functionType: FunctionType
              positional
                required int? @ dart:core
              returnType: void
        interface: #M20
          map
            foo1: #M5
            foo1=: #M9
            foo2: #M6
            foo2=: #M10
            foo3: #M16
            foo3=: #M18
            foo4: #M17
            foo4=: #M19
          implemented
            foo2: #M6
            foo2=: #M10
            foo3: #M16
            foo3=: #M18
''',
    );
  }

  test_manifest_class_field_modifier_isConst() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class C {
  static const a = 0;
  static const b = 0;
  static final c = 0;
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      C: #M0
        declaredFields
          a: #M1
          b: #M2
          c: #M3
        declaredGetters
          a: #M4
          b: #M5
          c: #M6
        interface: #M7
''',
      updatedCode: r'''
class C {
  static const a = 0;
  static final b = 0;
  static const c = 0;
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      C: #M0
        declaredFields
          a: #M1
          b: #M8
          c: #M9
        declaredGetters
          a: #M4
          b: #M5
          c: #M6
        interface: #M7
''',
    );
  }

  test_manifest_class_field_modifier_isCovariant() async {
    configuration.withElementManifests = true;

    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  covariant int? foo1;
  int? foo2;
  covariant int? foo3;
  int? foo4;
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        flags: hasNonFinalField
        supertype: Object @ dart:core
        declaredFields
          foo1: #M1
            flags: isCovariant shouldUseTypeForInitializerInference
            type: int? @ dart:core
          foo2: #M2
            flags: shouldUseTypeForInitializerInference
            type: int? @ dart:core
          foo3: #M3
            flags: isCovariant shouldUseTypeForInitializerInference
            type: int? @ dart:core
          foo4: #M4
            flags: shouldUseTypeForInitializerInference
            type: int? @ dart:core
        declaredGetters
          foo1: #M5
            flags: isSimplyBounded isSynthetic
            returnType: int? @ dart:core
          foo2: #M6
            flags: isSimplyBounded isSynthetic
            returnType: int? @ dart:core
          foo3: #M7
            flags: isSimplyBounded isSynthetic
            returnType: int? @ dart:core
          foo4: #M8
            flags: isSimplyBounded isSynthetic
            returnType: int? @ dart:core
        declaredSetters
          foo1=: #M9
            flags: isSimplyBounded isSynthetic
            functionType: FunctionType
              positional
                required int? @ dart:core
              returnType: void
          foo2=: #M10
            flags: isSimplyBounded isSynthetic
            functionType: FunctionType
              positional
                required int? @ dart:core
              returnType: void
          foo3=: #M11
            flags: isSimplyBounded isSynthetic
            functionType: FunctionType
              positional
                required int? @ dart:core
              returnType: void
          foo4=: #M12
            flags: isSimplyBounded isSynthetic
            functionType: FunctionType
              positional
                required int? @ dart:core
              returnType: void
        interface: #M13
          map
            foo1: #M5
            foo1=: #M9
            foo2: #M6
            foo2=: #M10
            foo3: #M7
            foo3=: #M11
            foo4: #M8
            foo4=: #M12
          implemented
            foo1: #M5
            foo1=: #M9
            foo2: #M6
            foo2=: #M10
            foo3: #M7
            foo3=: #M11
            foo4: #M8
            foo4=: #M12
''',
      updatedCode: r'''
class A {
  covariant int? foo1;
  int? foo2;
  int? foo3;
  covariant int? foo4;
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        flags: hasNonFinalField
        supertype: Object @ dart:core
        declaredFields
          foo1: #M1
            flags: isCovariant shouldUseTypeForInitializerInference
            type: int? @ dart:core
          foo2: #M2
            flags: shouldUseTypeForInitializerInference
            type: int? @ dart:core
          foo3: #M14
            flags: shouldUseTypeForInitializerInference
            type: int? @ dart:core
          foo4: #M15
            flags: isCovariant shouldUseTypeForInitializerInference
            type: int? @ dart:core
        declaredGetters
          foo1: #M5
            flags: isSimplyBounded isSynthetic
            returnType: int? @ dart:core
          foo2: #M6
            flags: isSimplyBounded isSynthetic
            returnType: int? @ dart:core
          foo3: #M7
            flags: isSimplyBounded isSynthetic
            returnType: int? @ dart:core
          foo4: #M8
            flags: isSimplyBounded isSynthetic
            returnType: int? @ dart:core
        declaredSetters
          foo1=: #M9
            flags: isSimplyBounded isSynthetic
            functionType: FunctionType
              positional
                required int? @ dart:core
              returnType: void
          foo2=: #M10
            flags: isSimplyBounded isSynthetic
            functionType: FunctionType
              positional
                required int? @ dart:core
              returnType: void
          foo3=: #M16
            flags: isSimplyBounded isSynthetic
            functionType: FunctionType
              positional
                required int? @ dart:core
              returnType: void
          foo4=: #M17
            flags: isSimplyBounded isSynthetic
            functionType: FunctionType
              positional
                required int? @ dart:core
              returnType: void
        interface: #M18
          map
            foo1: #M5
            foo1=: #M9
            foo2: #M6
            foo2=: #M10
            foo3: #M7
            foo3=: #M16
            foo4: #M8
            foo4=: #M17
          implemented
            foo1: #M5
            foo1=: #M9
            foo2: #M6
            foo2=: #M10
            foo3: #M7
            foo3=: #M16
            foo4: #M8
            foo4=: #M17
''',
    );
  }

  test_manifest_class_field_modifier_isExternal() async {
    configuration.withElementManifests = true;

    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  external final int? foo1;
  final int? foo2;
  external final int? foo3;
  final int? foo4;
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        supertype: Object @ dart:core
        declaredFields
          foo1: #M1
            flags: isExternal isFinal shouldUseTypeForInitializerInference
            type: int? @ dart:core
          foo2: #M2
            flags: isFinal shouldUseTypeForInitializerInference
            type: int? @ dart:core
          foo3: #M3
            flags: isExternal isFinal shouldUseTypeForInitializerInference
            type: int? @ dart:core
          foo4: #M4
            flags: isFinal shouldUseTypeForInitializerInference
            type: int? @ dart:core
        declaredGetters
          foo1: #M5
            flags: isSimplyBounded isSynthetic
            returnType: int? @ dart:core
          foo2: #M6
            flags: isSimplyBounded isSynthetic
            returnType: int? @ dart:core
          foo3: #M7
            flags: isSimplyBounded isSynthetic
            returnType: int? @ dart:core
          foo4: #M8
            flags: isSimplyBounded isSynthetic
            returnType: int? @ dart:core
        interface: #M9
          map
            foo1: #M5
            foo2: #M6
            foo3: #M7
            foo4: #M8
          implemented
            foo1: #M5
            foo2: #M6
            foo3: #M7
            foo4: #M8
''',
      updatedCode: r'''
class A {
  external final int? foo1;
  final int? foo2;
  final int? foo3;
  external final int? foo4;
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        supertype: Object @ dart:core
        declaredFields
          foo1: #M1
            flags: isExternal isFinal shouldUseTypeForInitializerInference
            type: int? @ dart:core
          foo2: #M2
            flags: isFinal shouldUseTypeForInitializerInference
            type: int? @ dart:core
          foo3: #M10
            flags: isFinal shouldUseTypeForInitializerInference
            type: int? @ dart:core
          foo4: #M11
            flags: isExternal isFinal shouldUseTypeForInitializerInference
            type: int? @ dart:core
        declaredGetters
          foo1: #M5
            flags: isSimplyBounded isSynthetic
            returnType: int? @ dart:core
          foo2: #M6
            flags: isSimplyBounded isSynthetic
            returnType: int? @ dart:core
          foo3: #M7
            flags: isSimplyBounded isSynthetic
            returnType: int? @ dart:core
          foo4: #M8
            flags: isSimplyBounded isSynthetic
            returnType: int? @ dart:core
        interface: #M9
          map
            foo1: #M5
            foo2: #M6
            foo3: #M7
            foo4: #M8
          implemented
            foo1: #M5
            foo2: #M6
            foo3: #M7
            foo4: #M8
''',
    );
  }

  test_manifest_class_field_modifier_isFinal() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class C {
  final a = 0;
  final b = 0;
  var c = 0;
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      C: #M0
        declaredFields
          a: #M1
          b: #M2
          c: #M3
        declaredGetters
          a: #M4
          b: #M5
          c: #M6
        declaredSetters
          c=: #M7
        interface: #M8
          map
            a: #M4
            b: #M5
            c: #M6
            c=: #M7
          implemented
            a: #M4
            b: #M5
            c: #M6
            c=: #M7
''',
      updatedCode: r'''
class C {
  final a = 0;
  var b = 0;
  final c = 0;
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      C: #M0
        declaredFields
          a: #M1
          b: #M9
          c: #M10
        declaredGetters
          a: #M4
          b: #M5
          c: #M6
        declaredSetters
          b=: #M11
        interface: #M12
          map
            a: #M4
            b: #M5
            b=: #M11
            c: #M6
          implemented
            a: #M4
            b: #M5
            b=: #M11
            c: #M6
''',
    );
  }

  test_manifest_class_field_modifier_isLate() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class C {
  late final a = 0;
  late final b = 0;
  final c = 0;
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      C: #M0
        declaredFields
          a: #M1
          b: #M2
          c: #M3
        declaredGetters
          a: #M4
          b: #M5
          c: #M6
        interface: #M7
          map
            a: #M4
            b: #M5
            c: #M6
          implemented
            a: #M4
            b: #M5
            c: #M6
''',
      updatedCode: r'''
class C {
  late final a = 0;
  final b = 0;
  late final c = 0;
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      C: #M0
        declaredFields
          a: #M1
          b: #M8
          c: #M9
        declaredGetters
          a: #M4
          b: #M5
          c: #M6
        interface: #M7
          map
            a: #M4
            b: #M5
            c: #M6
          implemented
            a: #M4
            b: #M5
            c: #M6
''',
    );
  }

  test_manifest_class_field_modifier_isPromotable() async {
    configuration.withElementManifests = true;

    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  final int? _foo1;
  final int? _foo2;
  final int? _foo3;
  final int? _foo4;
}

class B {
  int? get _foo2;
  int? get _foo4;
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        supertype: Object @ dart:core
        declaredFields
          _foo1: #M1
            flags: isFinal isPromotable shouldUseTypeForInitializerInference
            type: int? @ dart:core
          _foo2: #M2
            flags: isFinal shouldUseTypeForInitializerInference
            type: int? @ dart:core
          _foo3: #M3
            flags: isFinal isPromotable shouldUseTypeForInitializerInference
            type: int? @ dart:core
          _foo4: #M4
            flags: isFinal shouldUseTypeForInitializerInference
            type: int? @ dart:core
        declaredGetters
          _foo1: #M5
            flags: isSimplyBounded isSynthetic
            returnType: int? @ dart:core
          _foo2: #M6
            flags: isSimplyBounded isSynthetic
            returnType: int? @ dart:core
          _foo3: #M7
            flags: isSimplyBounded isSynthetic
            returnType: int? @ dart:core
          _foo4: #M8
            flags: isSimplyBounded isSynthetic
            returnType: int? @ dart:core
        interface: #M9
      B: #M10
        supertype: Object @ dart:core
        declaredFields
          _foo2: #M11
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int? @ dart:core
          _foo4: #M12
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int? @ dart:core
        declaredGetters
          _foo2: #M13
            flags: isAbstract isSimplyBounded
            returnType: int? @ dart:core
          _foo4: #M14
            flags: isAbstract isSimplyBounded
            returnType: int? @ dart:core
        interface: #M15
''',
      updatedCode: r'''
class A {
  final int? _foo1;
  final int? _foo2;
  final int? _foo3;
  final int? _foo4;
}

class B {
  int? get _foo2;
  int? get _foo3;
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        supertype: Object @ dart:core
        declaredFields
          _foo1: #M1
            flags: isFinal isPromotable shouldUseTypeForInitializerInference
            type: int? @ dart:core
          _foo2: #M2
            flags: isFinal shouldUseTypeForInitializerInference
            type: int? @ dart:core
          _foo3: #M16
            flags: isFinal shouldUseTypeForInitializerInference
            type: int? @ dart:core
          _foo4: #M17
            flags: isFinal isPromotable shouldUseTypeForInitializerInference
            type: int? @ dart:core
        declaredGetters
          _foo1: #M5
            flags: isSimplyBounded isSynthetic
            returnType: int? @ dart:core
          _foo2: #M6
            flags: isSimplyBounded isSynthetic
            returnType: int? @ dart:core
          _foo3: #M7
            flags: isSimplyBounded isSynthetic
            returnType: int? @ dart:core
          _foo4: #M8
            flags: isSimplyBounded isSynthetic
            returnType: int? @ dart:core
        interface: #M9
      B: #M10
        supertype: Object @ dart:core
        declaredFields
          _foo2: #M11
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int? @ dart:core
          _foo3: #M18
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int? @ dart:core
        declaredGetters
          _foo2: #M13
            flags: isAbstract isSimplyBounded
            returnType: int? @ dart:core
          _foo3: #M19
            flags: isAbstract isSimplyBounded
            returnType: int? @ dart:core
        interface: #M15
''',
    );
  }

  test_manifest_class_field_modifier_isStatic() async {
    configuration.withElementManifests = true;

    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  static final int? foo1;
  final int? foo2;
  static final int? foo3;
  final int? foo4;
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        supertype: Object @ dart:core
        declaredFields
          foo1: #M1
            flags: isFinal isStatic shouldUseTypeForInitializerInference
            type: int? @ dart:core
          foo2: #M2
            flags: isFinal shouldUseTypeForInitializerInference
            type: int? @ dart:core
          foo3: #M3
            flags: isFinal isStatic shouldUseTypeForInitializerInference
            type: int? @ dart:core
          foo4: #M4
            flags: isFinal shouldUseTypeForInitializerInference
            type: int? @ dart:core
        declaredGetters
          foo1: #M5
            flags: isSimplyBounded isStatic isSynthetic
            returnType: int? @ dart:core
          foo2: #M6
            flags: isSimplyBounded isSynthetic
            returnType: int? @ dart:core
          foo3: #M7
            flags: isSimplyBounded isStatic isSynthetic
            returnType: int? @ dart:core
          foo4: #M8
            flags: isSimplyBounded isSynthetic
            returnType: int? @ dart:core
        interface: #M9
          map
            foo2: #M6
            foo4: #M8
          implemented
            foo2: #M6
            foo4: #M8
''',
      updatedCode: r'''
class A {
  static final int? foo1;
  final int? foo2;
  final int? foo3;
  static final int? foo4;
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        supertype: Object @ dart:core
        declaredFields
          foo1: #M1
            flags: isFinal isStatic shouldUseTypeForInitializerInference
            type: int? @ dart:core
          foo2: #M2
            flags: isFinal shouldUseTypeForInitializerInference
            type: int? @ dart:core
          foo3: #M10
            flags: isFinal shouldUseTypeForInitializerInference
            type: int? @ dart:core
          foo4: #M11
            flags: isFinal isStatic shouldUseTypeForInitializerInference
            type: int? @ dart:core
        declaredGetters
          foo1: #M5
            flags: isSimplyBounded isStatic isSynthetic
            returnType: int? @ dart:core
          foo2: #M6
            flags: isSimplyBounded isSynthetic
            returnType: int? @ dart:core
          foo3: #M12
            flags: isSimplyBounded isSynthetic
            returnType: int? @ dart:core
          foo4: #M13
            flags: isSimplyBounded isStatic isSynthetic
            returnType: int? @ dart:core
        interface: #M14
          map
            foo2: #M6
            foo3: #M12
          implemented
            foo2: #M6
            foo3: #M12
''',
    );
  }

  test_manifest_class_field_modifier_isSynthetic() async {
    configuration.withElementManifests = true;

    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  int? get foo1 => 0;
  final int? foo2;
  int? get foo3 => 0;
  final int? foo4;
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        supertype: Object @ dart:core
        declaredFields
          foo1: #M1
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int? @ dart:core
          foo2: #M2
            flags: isFinal shouldUseTypeForInitializerInference
            type: int? @ dart:core
          foo3: #M3
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int? @ dart:core
          foo4: #M4
            flags: isFinal shouldUseTypeForInitializerInference
            type: int? @ dart:core
        declaredGetters
          foo1: #M5
            flags: isSimplyBounded
            returnType: int? @ dart:core
          foo2: #M6
            flags: isSimplyBounded isSynthetic
            returnType: int? @ dart:core
          foo3: #M7
            flags: isSimplyBounded
            returnType: int? @ dart:core
          foo4: #M8
            flags: isSimplyBounded isSynthetic
            returnType: int? @ dart:core
        interface: #M9
          map
            foo1: #M5
            foo2: #M6
            foo3: #M7
            foo4: #M8
          implemented
            foo1: #M5
            foo2: #M6
            foo3: #M7
            foo4: #M8
''',
      updatedCode: r'''
class A {
  int? get foo1 => 0;
  final int? foo2;
  final int? foo3;
  int? get foo4 => 0;
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        supertype: Object @ dart:core
        declaredFields
          foo1: #M1
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int? @ dart:core
          foo2: #M2
            flags: isFinal shouldUseTypeForInitializerInference
            type: int? @ dart:core
          foo3: #M10
            flags: isFinal shouldUseTypeForInitializerInference
            type: int? @ dart:core
          foo4: #M11
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int? @ dart:core
        declaredGetters
          foo1: #M5
            flags: isSimplyBounded
            returnType: int? @ dart:core
          foo2: #M6
            flags: isSimplyBounded isSynthetic
            returnType: int? @ dart:core
          foo3: #M12
            flags: isSimplyBounded isSynthetic
            returnType: int? @ dart:core
          foo4: #M13
            flags: isSimplyBounded
            returnType: int? @ dart:core
        interface: #M14
          map
            foo1: #M5
            foo2: #M6
            foo3: #M12
            foo4: #M13
          implemented
            foo1: #M5
            foo2: #M6
            foo3: #M12
            foo4: #M13
''',
    );
  }

  test_manifest_class_field_private_final() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  final _a = 0;
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          _a: #M1
        declaredGetters
          _a: #M2
        interface: #M3
''',
      updatedCode: r'''
class A {
  final _a = 0;
  final b = 0;
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          _a: #M1
          b: #M4
        declaredGetters
          _a: #M2
          b: #M5
        interface: #M6
          map
            b: #M5
          implemented
            b: #M5
''',
    );
  }

  test_manifest_class_field_private_static_const() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  static const _a = 0;
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          _a: #M1
        declaredGetters
          _a: #M2
        interface: #M3
''',
      updatedCode: r'''
class A {
  static const _a = 0;
  static const b = 0;
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          _a: #M1
          b: #M4
        declaredGetters
          _a: #M2
          b: #M5
        interface: #M3
''',
    );
  }

  test_manifest_class_field_private_var() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  var _a = 0;
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          _a: #M1
        declaredGetters
          _a: #M2
        declaredSetters
          _a=: #M3
        interface: #M4
''',
      updatedCode: r'''
class A {
  var _a = 0;
  var b = 0;
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          _a: #M1
          b: #M5
        declaredGetters
          _a: #M2
          b: #M6
        declaredSetters
          _a=: #M3
          b=: #M7
        interface: #M8
          map
            b: #M6
            b=: #M7
          implemented
            b: #M6
            b=: #M7
''',
    );
  }

  test_manifest_class_field_type() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  int? a;
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          a: #M1
        declaredGetters
          a: #M2
        declaredSetters
          a=: #M3
        interface: #M4
          map
            a: #M2
            a=: #M3
          implemented
            a: #M2
            a=: #M3
''',
      updatedCode: r'''
class A {
  double? a;
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          a: #M5
        declaredGetters
          a: #M6
        declaredSetters
          a=: #M7
        interface: #M8
          map
            a: #M6
            a=: #M7
          implemented
            a: #M6
            a=: #M7
''',
    );
  }

  test_manifest_class_getter_add_extends() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  int get foo => 0;
}

class B extends A {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        interface: #M3
          map
            foo: #M2
          implemented
            foo: #M2
      B: #M4
        interface: #M5
          map
            foo: #M2
          implemented
            foo: #M2
          superImplemented
            [0]
              foo: #M2
          inherited
            foo: #M2
''',
      updatedCode: r'''
class A {
  int get foo => 0;
  int get bar => 0;
}

class B extends A {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          bar: #M6
          foo: #M1
        declaredGetters
          bar: #M7
          foo: #M2
        interface: #M8
          map
            bar: #M7
            foo: #M2
          implemented
            bar: #M7
            foo: #M2
      B: #M4
        interface: #M9
          map
            bar: #M7
            foo: #M2
          implemented
            bar: #M7
            foo: #M2
          superImplemented
            [0]
              bar: #M7
              foo: #M2
          inherited
            bar: #M7
            foo: #M2
''',
    );
  }

  test_manifest_class_getter_add_extends_generic() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A<T> {
  T get foo => 0;
}

class B extends A<int> {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        interface: #M3
          map
            foo: #M2
          implemented
            foo: #M2
      B: #M4
        interface: #M5
          map
            foo: #M2
          implemented
            foo: #M2
          superImplemented
            [0]
              foo: #M2
          inherited
            foo: #M2
''',
      updatedCode: r'''
class A<T> {
  T get foo => 0;
  T get bar => 0;
}

class B extends A<int> {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          bar: #M6
          foo: #M1
        declaredGetters
          bar: #M7
          foo: #M2
        interface: #M8
          map
            bar: #M7
            foo: #M2
          implemented
            bar: #M7
            foo: #M2
      B: #M4
        interface: #M9
          map
            bar: #M7
            foo: #M2
          implemented
            bar: #M7
            foo: #M2
          superImplemented
            [0]
              bar: #M7
              foo: #M2
          inherited
            bar: #M7
            foo: #M2
''',
    );
  }

  test_manifest_class_getter_add_implements() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  int get foo => 0;
}

class B implements A {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        interface: #M3
          map
            foo: #M2
          implemented
            foo: #M2
      B: #M4
        interface: #M5
          map
            foo: #M2
          inherited
            foo: #M2
''',
      updatedCode: r'''
class A {
  int get foo => 0;
  int get bar => 0;
}

class B implements A {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          bar: #M6
          foo: #M1
        declaredGetters
          bar: #M7
          foo: #M2
        interface: #M8
          map
            bar: #M7
            foo: #M2
          implemented
            bar: #M7
            foo: #M2
      B: #M4
        interface: #M9
          map
            bar: #M7
            foo: #M2
          inherited
            bar: #M7
            foo: #M2
''',
    );
  }

  test_manifest_class_getter_add_implements_generic() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A<T> {
  T get foo => 0;
}

class B implements A<int> {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        interface: #M3
          map
            foo: #M2
          implemented
            foo: #M2
      B: #M4
        interface: #M5
          map
            foo: #M2
          inherited
            foo: #M2
''',
      updatedCode: r'''
class A<T> {
  T get foo => 0;
  T get bar => 0;
}

class B implements A<int> {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          bar: #M6
          foo: #M1
        declaredGetters
          bar: #M7
          foo: #M2
        interface: #M8
          map
            bar: #M7
            foo: #M2
          implemented
            bar: #M7
            foo: #M2
      B: #M4
        interface: #M9
          map
            bar: #M7
            foo: #M2
          inherited
            bar: #M7
            foo: #M2
''',
    );
  }

  test_manifest_class_getter_add_with() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  int get foo => 0;
}

class B with A {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        interface: #M3
          map
            foo: #M2
          implemented
            foo: #M2
      B: #M4
        interface: #M5
          map
            foo: #M2
          implemented
            foo: #M2
          superImplemented
            [1]
              foo: #M2
          inherited
            foo: #M2
''',
      updatedCode: r'''
class A {
  int get foo => 0;
  int get bar => 0;
}

class B with A {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          bar: #M6
          foo: #M1
        declaredGetters
          bar: #M7
          foo: #M2
        interface: #M8
          map
            bar: #M7
            foo: #M2
          implemented
            bar: #M7
            foo: #M2
      B: #M4
        interface: #M9
          map
            bar: #M7
            foo: #M2
          implemented
            bar: #M7
            foo: #M2
          superImplemented
            [1]
              bar: #M7
              foo: #M2
          inherited
            bar: #M7
            foo: #M2
''',
    );
  }

  test_manifest_class_getter_add_with_generic() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A<T> {
  T get foo => 0;
}

class B with A<int> {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        interface: #M3
          map
            foo: #M2
          implemented
            foo: #M2
      B: #M4
        interface: #M5
          map
            foo: #M2
          implemented
            foo: #M2
          superImplemented
            [1]
              foo: #M2
          inherited
            foo: #M2
''',
      updatedCode: r'''
class A<T> {
  T get foo => 0;
  T get bar => 0;
}

class B with A<int> {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          bar: #M6
          foo: #M1
        declaredGetters
          bar: #M7
          foo: #M2
        interface: #M8
          map
            bar: #M7
            foo: #M2
          implemented
            bar: #M7
            foo: #M2
      B: #M4
        interface: #M9
          map
            bar: #M7
            foo: #M2
          implemented
            bar: #M7
            foo: #M2
          superImplemented
            [1]
              bar: #M7
              foo: #M2
          inherited
            bar: #M7
            foo: #M2
''',
    );
  }

  test_manifest_class_getter_combinedSignatures_merged_addUnrelated() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
abstract class A {
  num get foo;
}

abstract class B {
  int get foo;
}

abstract class C implements A, B {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        interface: #M3
          map
            foo: #M2
      B: #M4
        declaredFields
          foo: #M5
        declaredGetters
          foo: #M6
        interface: #M7
          map
            foo: #M6
      C: #M8
        interface: #M9
          map
            foo: #M10
          combinedIds
            [#M2, #M6]: #M10
          inherited
            foo: #M6
''',
      updatedCode: r'''
abstract class A {
  num get foo;
}

abstract class B {
  int get foo;
}

abstract class C implements A, B {
  void zzz();
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        interface: #M3
          map
            foo: #M2
      B: #M4
        declaredFields
          foo: #M5
        declaredGetters
          foo: #M6
        interface: #M7
          map
            foo: #M6
      C: #M8
        declaredMethods
          zzz: #M11
        interface: #M12
          map
            foo: #M10
            zzz: #M11
          combinedIds
            [#M2, #M6]: #M10
          inherited
            foo: #M6
''',
    );
  }

  test_manifest_class_getter_combinedSignatures_merged_inherit() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  dynamic get foo;
}

class B {
  void get foo;
}

abstract class C implements A, B {}

abstract class D implements C {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        interface: #M3
          map
            foo: #M2
      B: #M4
        declaredFields
          foo: #M5
        declaredGetters
          foo: #M6
        interface: #M7
          map
            foo: #M6
      C: #M8
        interface: #M9
          map
            foo: #M10
          combinedIds
            [#M2, #M6]: #M10
          inherited
            foo: #M10
      D: #M11
        interface: #M12
          map
            foo: #M10
          inherited
            foo: #M10
''',
      updatedCode: r'''
class A {
  dynamic get foo;
}

class B {
  void get foo;
}

abstract class C implements A, B {
  void xxx() {}
}

abstract class D implements C {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        interface: #M3
          map
            foo: #M2
      B: #M4
        declaredFields
          foo: #M5
        declaredGetters
          foo: #M6
        interface: #M7
          map
            foo: #M6
      C: #M8
        declaredMethods
          xxx: #M13
        interface: #M14
          map
            foo: #M10
            xxx: #M13
          combinedIds
            [#M2, #M6]: #M10
          implemented
            xxx: #M13
          inherited
            foo: #M10
      D: #M11
        interface: #M15
          map
            foo: #M10
            xxx: #M13
          inherited
            foo: #M10
            xxx: #M13
''',
    );
  }

  test_manifest_class_getter_idChangesWithContainer() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {}
class B {}
class C extends B {
  int get foo => 0;
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        interface: #M1
      B: #M2
        interface: #M3
      C: #M4
        declaredFields
          foo: #M5
        declaredGetters
          foo: #M6
        interface: #M7
          map
            foo: #M6
          implemented
            foo: #M6
''',
      updatedCode: r'''
class A {}
class B extends A {}
class C extends B {
  int get foo => 0;
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        interface: #M1
      B: #M8
        interface: #M9
      C: #M10
        declaredFields
          foo: #M11
        declaredGetters
          foo: #M12
        interface: #M13
          map
            foo: #M12
          implemented
            foo: #M12
''',
    );
  }

  test_manifest_class_getter_isSynthetic() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  final int foo1 = 0;
  int get foo2 => 0;
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo1: #M1
          foo2: #M2
        declaredGetters
          foo1: #M3
          foo2: #M4
        interface: #M5
          map
            foo1: #M3
            foo2: #M4
          implemented
            foo1: #M3
            foo2: #M4
''',
      updatedCode: r'''
class A {
  int get foo1 => 0;
  final int foo2 = 0;
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo1: #M6
          foo2: #M7
        declaredGetters
          foo1: #M8
          foo2: #M9
        interface: #M10
          map
            foo1: #M8
            foo2: #M9
          implemented
            foo1: #M8
            foo2: #M9
''',
    );
  }

  test_manifest_class_getter_metadata() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  @Deprecated('0')
  int get foo => 0;
  @Deprecated('0')
  int get bar => 0;
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          bar: #M1
          foo: #M2
        declaredGetters
          bar: #M3
          foo: #M4
        interface: #M5
          map
            bar: #M3
            foo: #M4
          implemented
            bar: #M3
            foo: #M4
''',
      updatedCode: r'''
class A {
  @Deprecated('1')
  int get foo => 0;
  @Deprecated('0')
  int get bar => 0;
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          bar: #M1
          foo: #M2
        declaredGetters
          bar: #M3
          foo: #M6
        interface: #M7
          map
            bar: #M3
            foo: #M6
          implemented
            bar: #M3
            foo: #M6
''',
    );
  }

  test_manifest_class_getter_modifier_hasEnclosingTypeParameterReference() async {
    configuration.withElementManifests = true;
    await _runLibraryManifestScenario(
      initialCode: r'''
abstract class A<T> {
  T get foo1;
  int get foo2;
  T get foo3;
  int get foo4;
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        flags: isAbstract
        typeParameters
          #0 covariant
            bound: <null>
        supertype: Object @ dart:core
        declaredFields
          foo1: #M1
            flags: hasEnclosingTypeParameterReference isSynthetic shouldUseTypeForInitializerInference
            type: typeParameter#0
          foo2: #M2
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo3: #M3
            flags: hasEnclosingTypeParameterReference isSynthetic shouldUseTypeForInitializerInference
            type: typeParameter#0
          foo4: #M4
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
        declaredGetters
          foo1: #M5
            flags: hasEnclosingTypeParameterReference isAbstract isSimplyBounded
            returnType: typeParameter#0
          foo2: #M6
            flags: isAbstract isSimplyBounded
            returnType: int @ dart:core
          foo3: #M7
            flags: hasEnclosingTypeParameterReference isAbstract isSimplyBounded
            returnType: typeParameter#0
          foo4: #M8
            flags: isAbstract isSimplyBounded
            returnType: int @ dart:core
        interface: #M9
          map
            foo1: #M5
            foo2: #M6
            foo3: #M7
            foo4: #M8
''',
      updatedCode: r'''
abstract class A<T> {
  T get foo1;
  int get foo2;
  int get foo3;
  T get foo4;
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        flags: isAbstract
        typeParameters
          #0 covariant
            bound: <null>
        supertype: Object @ dart:core
        declaredFields
          foo1: #M1
            flags: hasEnclosingTypeParameterReference isSynthetic shouldUseTypeForInitializerInference
            type: typeParameter#0
          foo2: #M2
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo3: #M10
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo4: #M11
            flags: hasEnclosingTypeParameterReference isSynthetic shouldUseTypeForInitializerInference
            type: typeParameter#0
        declaredGetters
          foo1: #M5
            flags: hasEnclosingTypeParameterReference isAbstract isSimplyBounded
            returnType: typeParameter#0
          foo2: #M6
            flags: isAbstract isSimplyBounded
            returnType: int @ dart:core
          foo3: #M12
            flags: isAbstract isSimplyBounded
            returnType: int @ dart:core
          foo4: #M13
            flags: hasEnclosingTypeParameterReference isAbstract isSimplyBounded
            returnType: typeParameter#0
        interface: #M14
          map
            foo1: #M5
            foo2: #M6
            foo3: #M12
            foo4: #M13
''',
    );
  }

  test_manifest_class_getter_modifier_hasImplicitReturnType() async {
    configuration.withElementManifests = true;
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  get foo1 => 0;
  int get foo2 => 0;
  get foo3 => 0;
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        supertype: Object @ dart:core
        declaredFields
          foo1: #M1
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: dynamic
          foo2: #M2
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo3: #M3
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: dynamic
        declaredGetters
          foo1: #M4
            flags: hasImplicitReturnType isSimplyBounded
            returnType: dynamic
          foo2: #M5
            flags: isSimplyBounded
            returnType: int @ dart:core
          foo3: #M6
            flags: hasImplicitReturnType isSimplyBounded
            returnType: dynamic
        interface: #M7
          map
            foo1: #M4
            foo2: #M5
            foo3: #M6
          implemented
            foo1: #M4
            foo2: #M5
            foo3: #M6
''',
      updatedCode: r'''
class A {
  get foo1 => 0;
  get foo2 => 0;
  int get foo3 => 0;
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        supertype: Object @ dart:core
        declaredFields
          foo1: #M1
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: dynamic
          foo2: #M8
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: dynamic
          foo3: #M9
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
        declaredGetters
          foo1: #M4
            flags: hasImplicitReturnType isSimplyBounded
            returnType: dynamic
          foo2: #M10
            flags: hasImplicitReturnType isSimplyBounded
            returnType: dynamic
          foo3: #M11
            flags: isSimplyBounded
            returnType: int @ dart:core
        interface: #M12
          map
            foo1: #M4
            foo2: #M10
            foo3: #M11
          implemented
            foo1: #M4
            foo2: #M10
            foo3: #M11
''',
    );
  }

  test_manifest_class_getter_modifier_invokesSuperSelf() async {
    configuration.withElementManifests = true;
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  int get foo1 => 0;
  int get foo2 => 0;
  int get foo3 => 0;
  int get foo4 => 0;
}
class B extends A {
  int get foo1 => 1;
  int get foo2 { return super.foo2; }
  int get foo3 => 3;
  int get foo4 { return super.foo4; }
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        supertype: Object @ dart:core
        declaredFields
          foo1: #M1
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo2: #M2
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo3: #M3
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo4: #M4
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
        declaredGetters
          foo1: #M5
            flags: isSimplyBounded
            returnType: int @ dart:core
          foo2: #M6
            flags: isSimplyBounded
            returnType: int @ dart:core
          foo3: #M7
            flags: isSimplyBounded
            returnType: int @ dart:core
          foo4: #M8
            flags: isSimplyBounded
            returnType: int @ dart:core
        interface: #M9
          map
            foo1: #M5
            foo2: #M6
            foo3: #M7
            foo4: #M8
          implemented
            foo1: #M5
            foo2: #M6
            foo3: #M7
            foo4: #M8
      B: #M10
        supertype: A @ package:test/test.dart
        declaredFields
          foo1: #M11
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo2: #M12
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo3: #M13
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo4: #M14
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
        declaredGetters
          foo1: #M15
            flags: isSimplyBounded
            returnType: int @ dart:core
          foo2: #M16
            flags: invokesSuperSelf isSimplyBounded
            returnType: int @ dart:core
          foo3: #M17
            flags: isSimplyBounded
            returnType: int @ dart:core
          foo4: #M18
            flags: invokesSuperSelf isSimplyBounded
            returnType: int @ dart:core
        interface: #M19
          map
            foo1: #M15
            foo2: #M16
            foo3: #M17
            foo4: #M18
          implemented
            foo1: #M15
            foo2: #M16
            foo3: #M17
            foo4: #M18
          superImplemented
            [0]
              foo1: #M5
              foo2: #M6
              foo3: #M7
              foo4: #M8
          inherited
            foo1: #M5
            foo2: #M6
            foo3: #M7
            foo4: #M8
''',
      updatedCode: r'''
class A {
  int get foo1 => 0;
  int get foo2 => 0;
  int get foo3 => 0;
  int get foo4 => 0;
}
class B extends A {
  int get foo1 => 1;
  int get foo2 { return super.foo2; }
  int get foo3 { return super.foo3; }
  int get foo4 => 4;
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        supertype: Object @ dart:core
        declaredFields
          foo1: #M1
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo2: #M2
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo3: #M3
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo4: #M4
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
        declaredGetters
          foo1: #M5
            flags: isSimplyBounded
            returnType: int @ dart:core
          foo2: #M6
            flags: isSimplyBounded
            returnType: int @ dart:core
          foo3: #M7
            flags: isSimplyBounded
            returnType: int @ dart:core
          foo4: #M8
            flags: isSimplyBounded
            returnType: int @ dart:core
        interface: #M9
          map
            foo1: #M5
            foo2: #M6
            foo3: #M7
            foo4: #M8
          implemented
            foo1: #M5
            foo2: #M6
            foo3: #M7
            foo4: #M8
      B: #M10
        supertype: A @ package:test/test.dart
        declaredFields
          foo1: #M11
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo2: #M12
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo3: #M13
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo4: #M14
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
        declaredGetters
          foo1: #M15
            flags: isSimplyBounded
            returnType: int @ dart:core
          foo2: #M16
            flags: invokesSuperSelf isSimplyBounded
            returnType: int @ dart:core
          foo3: #M20
            flags: invokesSuperSelf isSimplyBounded
            returnType: int @ dart:core
          foo4: #M21
            flags: isSimplyBounded
            returnType: int @ dart:core
        interface: #M22
          map
            foo1: #M15
            foo2: #M16
            foo3: #M20
            foo4: #M21
          implemented
            foo1: #M15
            foo2: #M16
            foo3: #M20
            foo4: #M21
          superImplemented
            [0]
              foo1: #M5
              foo2: #M6
              foo3: #M7
              foo4: #M8
          inherited
            foo1: #M5
            foo2: #M6
            foo3: #M7
            foo4: #M8
''',
    );
  }

  test_manifest_class_getter_modifier_isAbstract() async {
    configuration.withElementManifests = true;
    await _runLibraryManifestScenario(
      initialCode: r'''
abstract class A {
  int get foo1 => 1;
  int get foo2;
  int get foo3 => 3;
  int get foo4;
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        flags: isAbstract
        supertype: Object @ dart:core
        declaredFields
          foo1: #M1
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo2: #M2
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo3: #M3
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo4: #M4
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
        declaredGetters
          foo1: #M5
            flags: isSimplyBounded
            returnType: int @ dart:core
          foo2: #M6
            flags: isAbstract isSimplyBounded
            returnType: int @ dart:core
          foo3: #M7
            flags: isSimplyBounded
            returnType: int @ dart:core
          foo4: #M8
            flags: isAbstract isSimplyBounded
            returnType: int @ dart:core
        interface: #M9
          map
            foo1: #M5
            foo2: #M6
            foo3: #M7
            foo4: #M8
          implemented
            foo1: #M5
            foo3: #M7
''',
      updatedCode: r'''
abstract class A {
  int get foo1 => 1;
  int get foo2;
  int get foo3;
  int get foo4 => 4;
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        flags: isAbstract
        supertype: Object @ dart:core
        declaredFields
          foo1: #M1
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo2: #M2
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo3: #M3
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo4: #M4
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
        declaredGetters
          foo1: #M5
            flags: isSimplyBounded
            returnType: int @ dart:core
          foo2: #M6
            flags: isAbstract isSimplyBounded
            returnType: int @ dart:core
          foo3: #M10
            flags: isAbstract isSimplyBounded
            returnType: int @ dart:core
          foo4: #M11
            flags: isSimplyBounded
            returnType: int @ dart:core
        interface: #M12
          map
            foo1: #M5
            foo2: #M6
            foo3: #M10
            foo4: #M11
          implemented
            foo1: #M5
            foo4: #M11
''',
    );
  }

  test_manifest_class_getter_modifier_isExternal() async {
    configuration.withElementManifests = true;
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  int get foo1 => 1;
  external int get foo2;
  int get foo3 => 3;
  external int get foo4;
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        supertype: Object @ dart:core
        declaredFields
          foo1: #M1
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo2: #M2
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo3: #M3
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo4: #M4
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
        declaredGetters
          foo1: #M5
            flags: isSimplyBounded
            returnType: int @ dart:core
          foo2: #M6
            flags: isExternal isSimplyBounded
            returnType: int @ dart:core
          foo3: #M7
            flags: isSimplyBounded
            returnType: int @ dart:core
          foo4: #M8
            flags: isExternal isSimplyBounded
            returnType: int @ dart:core
        interface: #M9
          map
            foo1: #M5
            foo2: #M6
            foo3: #M7
            foo4: #M8
          implemented
            foo1: #M5
            foo2: #M6
            foo3: #M7
            foo4: #M8
''',
      updatedCode: r'''
class A {
  int get foo1 => 1;
  external int get foo2;
  external int get foo3;
  int get foo4 => 4;
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        supertype: Object @ dart:core
        declaredFields
          foo1: #M1
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo2: #M2
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo3: #M3
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo4: #M4
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
        declaredGetters
          foo1: #M5
            flags: isSimplyBounded
            returnType: int @ dart:core
          foo2: #M6
            flags: isExternal isSimplyBounded
            returnType: int @ dart:core
          foo3: #M10
            flags: isExternal isSimplyBounded
            returnType: int @ dart:core
          foo4: #M11
            flags: isSimplyBounded
            returnType: int @ dart:core
        interface: #M12
          map
            foo1: #M5
            foo2: #M6
            foo3: #M10
            foo4: #M11
          implemented
            foo1: #M5
            foo2: #M6
            foo3: #M10
            foo4: #M11
''',
    );
  }

  test_manifest_class_getter_modifier_isStatic() async {
    configuration.withElementManifests = true;
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  int get foo1 => 1;
  static int get foo2 => 2;
  int get foo3 => 3;
  static int get foo4 => 4;
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        supertype: Object @ dart:core
        declaredFields
          foo1: #M1
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo2: #M2
            flags: isStatic isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo3: #M3
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo4: #M4
            flags: isStatic isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
        declaredGetters
          foo1: #M5
            flags: isSimplyBounded
            returnType: int @ dart:core
          foo2: #M6
            flags: isSimplyBounded isStatic
            returnType: int @ dart:core
          foo3: #M7
            flags: isSimplyBounded
            returnType: int @ dart:core
          foo4: #M8
            flags: isSimplyBounded isStatic
            returnType: int @ dart:core
        interface: #M9
          map
            foo1: #M5
            foo3: #M7
          implemented
            foo1: #M5
            foo3: #M7
''',
      updatedCode: r'''
class A {
  int get foo1 => 1;
  static int get foo2 => 2;
  static int get foo3 => 3;
  int get foo4 => 4;
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        supertype: Object @ dart:core
        declaredFields
          foo1: #M1
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo2: #M2
            flags: isStatic isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo3: #M10
            flags: isStatic isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo4: #M11
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
        declaredGetters
          foo1: #M5
            flags: isSimplyBounded
            returnType: int @ dart:core
          foo2: #M6
            flags: isSimplyBounded isStatic
            returnType: int @ dart:core
          foo3: #M12
            flags: isSimplyBounded isStatic
            returnType: int @ dart:core
          foo4: #M13
            flags: isSimplyBounded
            returnType: int @ dart:core
        interface: #M14
          map
            foo1: #M5
            foo4: #M13
          implemented
            foo1: #M5
            foo4: #M13
''',
    );
  }

  test_manifest_class_getter_private_instance() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  int get _foo => 0;
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          _foo: #M1
        declaredGetters
          _foo: #M2
        interface: #M3
''',
      updatedCode: r'''
class A {
  int get _foo => 0;
  int get bar => 0;
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          _foo: #M1
          bar: #M4
        declaredGetters
          _foo: #M2
          bar: #M5
        interface: #M6
          map
            bar: #M5
          implemented
            bar: #M5
''',
    );
  }

  test_manifest_class_getter_private_static() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  static int get _foo => 0;
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          _foo: #M1
        declaredGetters
          _foo: #M2
        interface: #M3
''',
      updatedCode: r'''
class A {
  static int get _foo => 0;
  int get bar => 0;
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          _foo: #M1
          bar: #M4
        declaredGetters
          _foo: #M2
          bar: #M5
        interface: #M6
          map
            bar: #M5
          implemented
            bar: #M5
''',
    );
  }

  test_manifest_class_getter_returnType() async {
    configuration.withElementManifests = true;
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  int get foo => 0;
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        supertype: Object @ dart:core
        declaredFields
          foo: #M1
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
        declaredGetters
          foo: #M2
            flags: isSimplyBounded
            returnType: int @ dart:core
        interface: #M3
          map
            foo: #M2
          implemented
            foo: #M2
''',
      updatedCode: r'''
class A {
  double get foo => 1.2;
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        supertype: Object @ dart:core
        declaredFields
          foo: #M4
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: double @ dart:core
        declaredGetters
          foo: #M5
            flags: isSimplyBounded
            returnType: double @ dart:core
        interface: #M6
          map
            foo: #M5
          implemented
            foo: #M5
''',
    );
  }

  test_manifest_class_getter_static() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  static int get foo => 0;
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        interface: #M3
''',
      updatedCode: r'''
class A {
  static int get foo => 0;
  static int get bar => 0;
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          bar: #M4
          foo: #M1
        declaredGetters
          bar: #M5
          foo: #M2
        interface: #M3
''',
    );
  }

  test_manifest_class_getter_static_falseToTrue() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  int get foo => 0;
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        interface: #M3
          map
            foo: #M2
          implemented
            foo: #M2
''',
      updatedCode: r'''
class A {
  static int get foo => 0;
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M4
        declaredGetters
          foo: #M5
        interface: #M6
''',
    );
  }

  test_manifest_class_getter_static_returnType() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  static int get foo => 0;
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        interface: #M3
''',
      updatedCode: r'''
class A {
  static double get foo => 0;
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M4
        declaredGetters
          foo: #M5
        interface: #M3
''',
    );
  }

  test_manifest_class_getter_static_trueToFalse() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  static int get foo => 0;
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        interface: #M3
''',
      updatedCode: r'''
class A {
  int get foo => 0;
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M4
        declaredGetters
          foo: #M5
        interface: #M6
          map
            foo: #M5
          implemented
            foo: #M5
''',
    );
  }

  test_manifest_class_getter_toDuplicate_hasInstance_addInstance_after() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  int get foo {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        interface: #M3
          map
            foo: #M2
          implemented
            foo: #M2
''',
      updatedCode: r'''
class A {
  int get foo {}
  double get foo {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConflicts
          foo: #M4
          foo=: #M4
        interface: #M5
          map
            foo: #M4
          implemented
            foo: #M4
''',
    );
  }

  test_manifest_class_getter_toDuplicate_hasInstance_addInstance_before() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  int get foo {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        interface: #M3
          map
            foo: #M2
          implemented
            foo: #M2
''',
      updatedCode: r'''
class A {
  double get foo {}
  int get foo {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConflicts
          foo: #M4
          foo=: #M4
        interface: #M5
          map
            foo: #M4
          implemented
            foo: #M4
''',
    );
  }

  test_manifest_class_getter_toDuplicate_hasInstance_addStatic_after() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  int get foo {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        interface: #M3
          map
            foo: #M2
          implemented
            foo: #M2
''',
      updatedCode: r'''
class A {
  int get foo {}
  static double get foo {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConflicts
          foo: #M4
          foo=: #M4
        interface: #M5
          map
            foo: #M4
          implemented
            foo: #M4
''',
    );
  }

  test_manifest_class_getter_toDuplicate_hasInstance_addStatic_before() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  int get foo {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        interface: #M3
          map
            foo: #M2
          implemented
            foo: #M2
''',
      updatedCode: r'''
class A {
  static double get foo {}
  int get foo {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConflicts
          foo: #M4
          foo=: #M4
        interface: #M5
          map
            foo: #M4
          implemented
            foo: #M4
''',
    );
  }

  test_manifest_class_getter_toDuplicate_hasStatic_addStatic_after() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  static int get foo {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        interface: #M3
''',
      updatedCode: r'''
class A {
  static int get foo {}
  static double get foo {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConflicts
          foo: #M4
          foo=: #M4
        interface: #M3
''',
    );
  }

  test_manifest_class_getter_toDuplicate_hasStatic_addStatic_before() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  static int get foo {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        interface: #M3
''',
      updatedCode: r'''
class A {
  static double get foo {}
  static int get foo {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConflicts
          foo: #M4
          foo=: #M4
        interface: #M3
''',
    );
  }

  test_manifest_class_hasNonFinalField() async {
    configuration.withElementManifests = true;

    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  final int? a;
}
class B {
  int? a;
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        supertype: Object @ dart:core
        declaredFields
          a: #M1
            flags: isFinal shouldUseTypeForInitializerInference
            type: int? @ dart:core
        declaredGetters
          a: #M2
            flags: isSimplyBounded isSynthetic
            returnType: int? @ dart:core
        interface: #M3
          map
            a: #M2
          implemented
            a: #M2
      B: #M4
        flags: hasNonFinalField
        supertype: Object @ dart:core
        declaredFields
          a: #M5
            flags: shouldUseTypeForInitializerInference
            type: int? @ dart:core
        declaredGetters
          a: #M6
            flags: isSimplyBounded isSynthetic
            returnType: int? @ dart:core
        declaredSetters
          a=: #M7
            flags: isSimplyBounded isSynthetic
            functionType: FunctionType
              positional
                required int? @ dart:core
              returnType: void
        interface: #M8
          map
            a: #M6
            a=: #M7
          implemented
            a: #M6
            a=: #M7
''',
      updatedCode: r'''
class A {
  int? a;
}
class B {
  final int? a;
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        flags: hasNonFinalField
        supertype: Object @ dart:core
        declaredFields
          a: #M9
            flags: shouldUseTypeForInitializerInference
            type: int? @ dart:core
        declaredGetters
          a: #M2
            flags: isSimplyBounded isSynthetic
            returnType: int? @ dart:core
        declaredSetters
          a=: #M10
            flags: isSimplyBounded isSynthetic
            functionType: FunctionType
              positional
                required int? @ dart:core
              returnType: void
        interface: #M11
          map
            a: #M2
            a=: #M10
          implemented
            a: #M2
            a=: #M10
      B: #M4
        supertype: Object @ dart:core
        declaredFields
          a: #M12
            flags: isFinal shouldUseTypeForInitializerInference
            type: int? @ dart:core
        declaredGetters
          a: #M6
            flags: isSimplyBounded isSynthetic
            returnType: int? @ dart:core
        interface: #M13
          map
            a: #M6
          implemented
            a: #M6
''',
    );
  }

  test_manifest_class_interface_implemented_inherited_abstract() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
abstract class A {
  void foo();
}
abstract class B extends A {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
      B: #M3
        interface: #M4
          map
            foo: #M1
          inherited
            foo: #M1
''',
      updatedCode: r'''
abstract class A {
  void foo();
  void bar() {}
}
abstract class B extends A {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          bar: #M5
          foo: #M1
        interface: #M6
          map
            bar: #M5
            foo: #M1
          implemented
            bar: #M5
      B: #M3
        interface: #M7
          map
            bar: #M5
            foo: #M1
          implemented
            bar: #M5
          superImplemented
            [0]
              bar: #M5
          inherited
            bar: #M5
            foo: #M1
''',
    );
  }

  test_manifest_class_interface_implemented_inherited_fromMixin_thenSuper() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class S {
  void foo() {}
}
mixin M {
  void foo() {}
}
class X extends S with M {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      S: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
      X: #M3
        interface: #M4
          map
            foo: #M5
          implemented
            foo: #M5
          superImplemented
            [0]
              foo: #M1
            [1]
              foo: #M5
          inherited
            foo: #M5
    declaredMixins
      M: #M6
        declaredMethods
          foo: #M5
        interface: #M7
          map
            foo: #M5
          implemented
            foo: #M5
''',
      updatedCode: r'''
class S {
  void foo() {}
}
mixin M {}
class X extends S with M {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      S: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
      X: #M3
        interface: #M8
          map
            foo: #M1
          implemented
            foo: #M1
          superImplemented
            [0]
              foo: #M1
            [1]
              foo: #M1
          inherited
            foo: #M1
    declaredMixins
      M: #M6
        interface: #M9
''',
    );
  }

  test_manifest_class_interface_implemented_inherited_fromMixins() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class S {
  void foo() {}
}
mixin M1 {
  void foo() {}
}
mixin M2 {}
class X extends S with M1, M2 {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      S: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
      X: #M3
        interface: #M4
          map
            foo: #M5
          implemented
            foo: #M5
          superImplemented
            [0]
              foo: #M1
            [1]
              foo: #M5
            [2]
              foo: #M5
          inherited
            foo: #M5
    declaredMixins
      M1: #M6
        declaredMethods
          foo: #M5
        interface: #M7
          map
            foo: #M5
          implemented
            foo: #M5
      M2: #M8
        interface: #M9
''',
      updatedCode: r'''
class S {
  void foo() {}
}
mixin M1 {
  void foo() {}
}
mixin M2 {
  void bar() {}
}
class X extends S with M1, M2 {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      S: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
      X: #M3
        interface: #M10
          map
            bar: #M11
            foo: #M5
          implemented
            bar: #M11
            foo: #M5
          superImplemented
            [0]
              foo: #M1
            [1]
              foo: #M5
            [2]
              bar: #M11
              foo: #M5
          inherited
            bar: #M11
            foo: #M5
    declaredMixins
      M1: #M6
        declaredMethods
          foo: #M5
        interface: #M7
          map
            foo: #M5
          implemented
            foo: #M5
      M2: #M8
        declaredMethods
          bar: #M11
        interface: #M12
          map
            bar: #M11
          implemented
            bar: #M11
''',
    );
  }

  test_manifest_class_interface_implemented_inherited_fromSuperclass() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  void foo() {}
}
class B extends A {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
      B: #M3
        interface: #M4
          map
            foo: #M1
          implemented
            foo: #M1
          superImplemented
            [0]
              foo: #M1
          inherited
            foo: #M1
''',
      updatedCode: r'''
class A {
  void foo() {}
  void bar() {}
}
class B extends A {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          bar: #M5
          foo: #M1
        interface: #M6
          map
            bar: #M5
            foo: #M1
          implemented
            bar: #M5
            foo: #M1
      B: #M3
        interface: #M7
          map
            bar: #M5
            foo: #M1
          implemented
            bar: #M5
            foo: #M1
          superImplemented
            [0]
              bar: #M5
              foo: #M1
          inherited
            bar: #M5
            foo: #M1
''',
    );
  }

  test_manifest_class_interface_implemented_inherited_fromSuperclass_overridden() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  void foo() {}
}
class B extends A {
  void foo() {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
      B: #M3
        declaredMethods
          foo: #M4
        interface: #M5
          map
            foo: #M4
          implemented
            foo: #M4
          superImplemented
            [0]
              foo: #M1
          inherited
            foo: #M1
''',
      updatedCode: r'''
class A {
  void foo() {}
  void bar() {}
}
class B extends A {
  void foo() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          bar: #M6
          foo: #M1
        interface: #M7
          map
            bar: #M6
            foo: #M1
          implemented
            bar: #M6
            foo: #M1
      B: #M3
        declaredMethods
          foo: #M4
        interface: #M8
          map
            bar: #M6
            foo: #M4
          implemented
            bar: #M6
            foo: #M4
          superImplemented
            [0]
              bar: #M6
              foo: #M1
          inherited
            bar: #M6
            foo: #M1
''',
    );
  }

  test_manifest_class_interface_implemented_inherited_private() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  void _foo() {}
}
class B extends A {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          _foo: #M1
        interface: #M2
      B: #M3
        interface: #M4
''',
      updatedCode: r'''
class A {
  void _foo() {}
  void _bar() {}
}
class B extends A {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          _bar: #M5
          _foo: #M1
        interface: #M2
      B: #M3
        interface: #M4
''',
    );
  }

  test_manifest_class_interfacesAdd() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {}
class B {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        interface: #M1
      B: #M2
        interface: #M3
''',
      updatedCode: r'''
class A implements B {}
class B {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M4
        interface: #M5
      B: #M2
        interface: #M3
''',
    );
  }

  test_manifest_class_interfacesRemove() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A implements B {}
class B {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        interface: #M1
      B: #M2
        interface: #M3
''',
      updatedCode: r'''
class A {}
class B {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M4
        interface: #M5
      B: #M2
        interface: #M3
''',
    );
  }

  test_manifest_class_interfacesReplace() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A implements B {}
class B {}
class C {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        interface: #M1
      B: #M2
        interface: #M3
      C: #M4
        interface: #M5
''',
      updatedCode: r'''
class A implements C {}
class B {}
class C {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M6
        interface: #M7
      B: #M2
        interface: #M3
      C: #M4
        interface: #M5
''',
    );
  }

  test_manifest_class_metadata() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
@Deprecated('0')
class A {}
@Deprecated('0')
class B {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        interface: #M1
      B: #M2
        interface: #M3
''',
      updatedCode: r'''
@Deprecated('0')
class A {}
@Deprecated('1')
class B {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        interface: #M1
      B: #M4
        interface: #M5
''',
    );
  }

  test_manifest_class_method_add() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  void foo() {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
''',
      updatedCode: r'''
class A {
  void foo() {}
  void bar() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          bar: #M3
          foo: #M1
        interface: #M4
          map
            bar: #M3
            foo: #M1
          implemented
            bar: #M3
            foo: #M1
''',
    );
  }

  test_manifest_class_method_add_extends() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  void foo() {}
}

class B extends A {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
      B: #M3
        interface: #M4
          map
            foo: #M1
          implemented
            foo: #M1
          superImplemented
            [0]
              foo: #M1
          inherited
            foo: #M1
''',
      updatedCode: r'''
class A {
  void foo() {}
  void bar() {}
}

class B extends A {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          bar: #M5
          foo: #M1
        interface: #M6
          map
            bar: #M5
            foo: #M1
          implemented
            bar: #M5
            foo: #M1
      B: #M3
        interface: #M7
          map
            bar: #M5
            foo: #M1
          implemented
            bar: #M5
            foo: #M1
          superImplemented
            [0]
              bar: #M5
              foo: #M1
          inherited
            bar: #M5
            foo: #M1
''',
    );
  }

  test_manifest_class_method_add_extends_generic() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A<T> {
  T foo() {}
}

class B extends A<int> {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
      B: #M3
        interface: #M4
          map
            foo: #M1
          implemented
            foo: #M1
          superImplemented
            [0]
              foo: #M1
          inherited
            foo: #M1
''',
      updatedCode: r'''
class A<T> {
  T foo() {}
  void bar() {}
}

class B extends A<int> {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          bar: #M5
          foo: #M1
        interface: #M6
          map
            bar: #M5
            foo: #M1
          implemented
            bar: #M5
            foo: #M1
      B: #M3
        interface: #M7
          map
            bar: #M5
            foo: #M1
          implemented
            bar: #M5
            foo: #M1
          superImplemented
            [0]
              bar: #M5
              foo: #M1
          inherited
            bar: #M5
            foo: #M1
''',
    );
  }

  test_manifest_class_method_add_extends_generic2() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A<T> {
  T foo() {}
}

class B extends A<int> {}

class C extends B {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
      B: #M3
        interface: #M4
          map
            foo: #M1
          implemented
            foo: #M1
          superImplemented
            [0]
              foo: #M1
          inherited
            foo: #M1
      C: #M5
        interface: #M6
          map
            foo: #M1
          implemented
            foo: #M1
          superImplemented
            [0]
              foo: #M1
          inherited
            foo: #M1
''',
      updatedCode: r'''
class A<T> {
  T foo() {}
  void bar() {}
}

class B extends A<int> {}

class C extends B {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          bar: #M7
          foo: #M1
        interface: #M8
          map
            bar: #M7
            foo: #M1
          implemented
            bar: #M7
            foo: #M1
      B: #M3
        interface: #M9
          map
            bar: #M7
            foo: #M1
          implemented
            bar: #M7
            foo: #M1
          superImplemented
            [0]
              bar: #M7
              foo: #M1
          inherited
            bar: #M7
            foo: #M1
      C: #M5
        interface: #M10
          map
            bar: #M7
            foo: #M1
          implemented
            bar: #M7
            foo: #M1
          superImplemented
            [0]
              bar: #M7
              foo: #M1
          inherited
            bar: #M7
            foo: #M1
''',
    );
  }

  test_manifest_class_method_add_implements() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  void foo() {}
}

class B implements A {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
      B: #M3
        interface: #M4
          map
            foo: #M1
          inherited
            foo: #M1
''',
      updatedCode: r'''
class A {
  void foo() {}
  void bar() {}
}

class B implements A {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          bar: #M5
          foo: #M1
        interface: #M6
          map
            bar: #M5
            foo: #M1
          implemented
            bar: #M5
            foo: #M1
      B: #M3
        interface: #M7
          map
            bar: #M5
            foo: #M1
          inherited
            bar: #M5
            foo: #M1
''',
    );
  }

  test_manifest_class_method_add_implements_generic() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A<T> {
  T foo() {}
}

class B implements A<int> {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
      B: #M3
        interface: #M4
          map
            foo: #M1
          inherited
            foo: #M1
''',
      updatedCode: r'''
class A<T> {
  T foo() {}
  void bar() {}
}

class B implements A<int> {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          bar: #M5
          foo: #M1
        interface: #M6
          map
            bar: #M5
            foo: #M1
          implemented
            bar: #M5
            foo: #M1
      B: #M3
        interface: #M7
          map
            bar: #M5
            foo: #M1
          inherited
            bar: #M5
            foo: #M1
''',
    );
  }

  test_manifest_class_method_add_with() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  void foo() {}
}

class B with A {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
      B: #M3
        interface: #M4
          map
            foo: #M1
          implemented
            foo: #M1
          superImplemented
            [1]
              foo: #M1
          inherited
            foo: #M1
''',
      updatedCode: r'''
class A {
  void foo() {}
  void bar() {}
}

class B with A {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          bar: #M5
          foo: #M1
        interface: #M6
          map
            bar: #M5
            foo: #M1
          implemented
            bar: #M5
            foo: #M1
      B: #M3
        interface: #M7
          map
            bar: #M5
            foo: #M1
          implemented
            bar: #M5
            foo: #M1
          superImplemented
            [1]
              bar: #M5
              foo: #M1
          inherited
            bar: #M5
            foo: #M1
''',
    );
  }

  test_manifest_class_method_add_with_generic() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A<T> {
  T foo() {}
}

class B with A<int> {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
      B: #M3
        interface: #M4
          map
            foo: #M1
          implemented
            foo: #M1
          superImplemented
            [1]
              foo: #M1
          inherited
            foo: #M1
''',
      updatedCode: r'''
class A<T> {
  T foo() {}
  void bar() {}
}

class B with A<int> {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          bar: #M5
          foo: #M1
        interface: #M6
          map
            bar: #M5
            foo: #M1
          implemented
            bar: #M5
            foo: #M1
      B: #M3
        interface: #M7
          map
            bar: #M5
            foo: #M1
          implemented
            bar: #M5
            foo: #M1
          superImplemented
            [1]
              bar: #M5
              foo: #M1
          inherited
            bar: #M5
            foo: #M1
''',
    );
  }

  test_manifest_class_method_combinedSignatures_conflict_removeOne() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
abstract class A {
  int foo();
}

abstract class B {
  double foo();
}

abstract class C implements A, B {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
      B: #M3
        declaredMethods
          foo: #M4
        interface: #M5
          map
            foo: #M4
      C: #M6
        interface: #M7
''',
      updatedCode: r'''
abstract class A {
  int foo();
}

abstract class B {}

abstract class C implements A, B {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
      B: #M3
        interface: #M8
      C: #M6
        interface: #M9
          map
            foo: #M1
          inherited
            foo: #M1
''',
    );
  }

  test_manifest_class_method_combinedSignatures_merged_addUnrelated() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
abstract class A {
  dynamic foo();
}

abstract class B {
  void foo();
}

abstract class C implements A, B {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
      B: #M3
        declaredMethods
          foo: #M4
        interface: #M5
          map
            foo: #M4
      C: #M6
        interface: #M7
          map
            foo: #M8
          combinedIds
            [#M1, #M4]: #M8
          inherited
            foo: #M8
''',
      updatedCode: r'''
abstract class A {
  dynamic foo();
}

abstract class B {
  void foo();
  void zzz();
}

abstract class C implements A, B {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
      B: #M3
        declaredMethods
          foo: #M4
          zzz: #M9
        interface: #M10
          map
            foo: #M4
            zzz: #M9
      C: #M6
        interface: #M11
          map
            foo: #M8
            zzz: #M9
          combinedIds
            [#M1, #M4]: #M8
          inherited
            foo: #M8
            zzz: #M9
''',
    );
  }

  test_manifest_class_method_combinedSignatures_merged_inherit_backward() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  dynamic foo();
}

class B {
  void foo();
}

abstract class C implements D {}

abstract class D implements A, B {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
      B: #M3
        declaredMethods
          foo: #M4
        interface: #M5
          map
            foo: #M4
      C: #M6
        interface: #M7
          map
            foo: #M8
          inherited
            foo: #M8
      D: #M9
        interface: #M10
          map
            foo: #M8
          combinedIds
            [#M1, #M4]: #M8
          inherited
            foo: #M8
''',
      updatedCode: r'''
class A {
  dynamic foo();
}

class B {
  void foo();
}

abstract class C implements D {}

abstract class D implements A, B {
  void xxx() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
      B: #M3
        declaredMethods
          foo: #M4
        interface: #M5
          map
            foo: #M4
      C: #M6
        interface: #M11
          map
            foo: #M8
            xxx: #M12
          inherited
            foo: #M8
            xxx: #M12
      D: #M9
        declaredMethods
          xxx: #M12
        interface: #M13
          map
            foo: #M8
            xxx: #M12
          combinedIds
            [#M1, #M4]: #M8
          implemented
            xxx: #M12
          inherited
            foo: #M8
''',
    );
  }

  test_manifest_class_method_combinedSignatures_merged_inherit_forward() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  dynamic foo();
}

class B {
  void foo();
}

abstract class C implements A, B {}

abstract class D implements C {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
      B: #M3
        declaredMethods
          foo: #M4
        interface: #M5
          map
            foo: #M4
      C: #M6
        interface: #M7
          map
            foo: #M8
          combinedIds
            [#M1, #M4]: #M8
          inherited
            foo: #M8
      D: #M9
        interface: #M10
          map
            foo: #M8
          inherited
            foo: #M8
''',
      updatedCode: r'''
class A {
  dynamic foo();
}

class B {
  void foo();
}

abstract class C implements A, B {
  void xxx() {}
}

abstract class D implements C {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
      B: #M3
        declaredMethods
          foo: #M4
        interface: #M5
          map
            foo: #M4
      C: #M6
        declaredMethods
          xxx: #M11
        interface: #M12
          map
            foo: #M8
            xxx: #M11
          combinedIds
            [#M1, #M4]: #M8
          implemented
            xxx: #M11
          inherited
            foo: #M8
      D: #M9
        interface: #M13
          map
            foo: #M8
            xxx: #M11
          inherited
            foo: #M8
            xxx: #M11
''',
    );
  }

  test_manifest_class_method_combinedSignatures_merged_removeOne() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
abstract class A {
  dynamic foo();
}

abstract class B {
  void foo();
}

abstract class C implements A, B {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
      B: #M3
        declaredMethods
          foo: #M4
        interface: #M5
          map
            foo: #M4
      C: #M6
        interface: #M7
          map
            foo: #M8
          combinedIds
            [#M1, #M4]: #M8
          inherited
            foo: #M8
''',
      updatedCode: r'''
abstract class A {}

abstract class B {
  void foo();
}

abstract class C implements A, B {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        interface: #M9
      B: #M3
        declaredMethods
          foo: #M4
        interface: #M5
          map
            foo: #M4
      C: #M6
        interface: #M10
          map
            foo: #M4
          inherited
            foo: #M4
''',
    );
  }

  test_manifest_class_method_combinedSignatures_merged_sameBase() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
abstract class A<T> {
  T foo();
}

abstract class B implements A<dynamic> {}

abstract class C implements A<void> {}

abstract class D implements B, C {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
      B: #M3
        interface: #M4
          map
            foo: #M1
          inherited
            foo: #M1
      C: #M5
        interface: #M6
          map
            foo: #M1
          inherited
            foo: #M1
      D: #M7
        interface: #M8
          map
            foo: #M1
          inherited
            foo: #M1
''',
      updatedCode: r'''
abstract class A<T> {
  T foo();
}

abstract class B implements A<dynamic> {}

abstract class C implements A<void> {}

abstract class D implements B, C {
  void zzz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
      B: #M3
        interface: #M4
          map
            foo: #M1
          inherited
            foo: #M1
      C: #M5
        interface: #M6
          map
            foo: #M1
          inherited
            foo: #M1
      D: #M7
        declaredMethods
          zzz: #M9
        interface: #M10
          map
            foo: #M1
            zzz: #M9
          implemented
            zzz: #M9
          inherited
            foo: #M1
''',
    );
  }

  test_manifest_class_method_combinedSignatures_merged_updateOne() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
abstract class A {
  dynamic foo();
}

abstract class B {
  void foo();
}

abstract class C implements A, B {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
      B: #M3
        declaredMethods
          foo: #M4
        interface: #M5
          map
            foo: #M4
      C: #M6
        interface: #M7
          map
            foo: #M8
          combinedIds
            [#M1, #M4]: #M8
          inherited
            foo: #M8
''',
      updatedCode: r'''
abstract class A {
  dynamic foo();
}

abstract class B {
  int foo();
}

abstract class C implements A, B {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
      B: #M3
        declaredMethods
          foo: #M9
        interface: #M10
          map
            foo: #M9
      C: #M6
        interface: #M11
          map
            foo: #M12
          combinedIds
            [#M1, #M9]: #M12
          inherited
            foo: #M9
''',
    );
  }

  test_manifest_class_method_formalParameter_optionalNamed() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  void foo({int a}) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
''',
      updatedCode: r'''
class A {
  void foo({int a}) {}
  void bar() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          bar: #M3
          foo: #M1
        interface: #M4
          map
            bar: #M3
            foo: #M1
          implemented
            bar: #M3
            foo: #M1
''',
    );
  }

  test_manifest_class_method_formalParameter_optionalNamed_reorder() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  void foo({int a, int b}) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
''',
      updatedCode: r'''
class A {
  void foo({int b, int a}) {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
''',
    );
  }

  test_manifest_class_method_formalParameter_optionalPositional() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  void foo([int a]) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
''',
      updatedCode: r'''
class A {
  void foo([int a]) {}
  void bar() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          bar: #M3
          foo: #M1
        interface: #M4
          map
            bar: #M3
            foo: #M1
          implemented
            bar: #M3
            foo: #M1
''',
    );
  }

  test_manifest_class_method_formalParameter_requiredNamed() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  void foo({required int a}) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
''',
      updatedCode: r'''
class A {
  void foo({required int a}) {}
  void bar() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          bar: #M3
          foo: #M1
        interface: #M4
          map
            bar: #M3
            foo: #M1
          implemented
            bar: #M3
            foo: #M1
''',
    );
  }

  test_manifest_class_method_formalParameter_requiredNamed_name() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  void foo({required int a}) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
''',
      updatedCode: r'''
class A {
  void foo({required int b}) {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M3
        interface: #M4
          map
            foo: #M3
          implemented
            foo: #M3
''',
    );
  }

  test_manifest_class_method_formalParameter_requiredNamed_reorder() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  void foo({required int a, required int b}) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
''',
      updatedCode: r'''
class A {
  void foo({required int b, required int a}) {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
''',
    );
  }

  test_manifest_class_method_formalParameter_requiredNamed_type() async {
    configuration.withElementManifests = true;
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  void foo({required int a}) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        supertype: Object @ dart:core
        declaredMethods
          foo: #M1
            flags: isSimplyBounded
            functionType: FunctionType
              named
                a: required int @ dart:core
              returnType: void
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
''',
      updatedCode: r'''
class A {
  void foo({required double a}) {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        supertype: Object @ dart:core
        declaredMethods
          foo: #M3
            flags: isSimplyBounded
            functionType: FunctionType
              named
                a: required double @ dart:core
              returnType: void
        interface: #M4
          map
            foo: #M3
          implemented
            foo: #M3
''',
    );
  }

  test_manifest_class_method_formalParameter_requiredPositional() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  void foo(int a) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
''',
      updatedCode: r'''
class A {
  void foo(int a) {}
  void bar() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          bar: #M3
          foo: #M1
        interface: #M4
          map
            bar: #M3
            foo: #M1
          implemented
            bar: #M3
            foo: #M1
''',
    );
  }

  test_manifest_class_method_formalParameter_requiredPositional_covariant() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  void foo1(int a) {}
  void foo2(covariant int a) {}
  void foo3(int a) {}
  void foo4(covariant int a) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo1: #M1
          foo2: #M2
          foo3: #M3
          foo4: #M4
        interface: #M5
          map
            foo1: #M1
            foo2: #M2
            foo3: #M3
            foo4: #M4
          implemented
            foo1: #M1
            foo2: #M2
            foo3: #M3
            foo4: #M4
''',
      updatedCode: r'''
class A {
  void foo1(int a) {}
  void foo2(covariant int a) {}
  void foo3(covariant int a) {}
  void foo4(int a) {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo1: #M1
          foo2: #M2
          foo3: #M6
          foo4: #M7
        interface: #M8
          map
            foo1: #M1
            foo2: #M2
            foo3: #M6
            foo4: #M7
          implemented
            foo1: #M1
            foo2: #M2
            foo3: #M6
            foo4: #M7
''',
    );
  }

  test_manifest_class_method_formalParameter_requiredPositional_metadata() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  void foo1(int a) {}
  void foo2(@deprecated int a) {}
  void foo3(int a) {}
  void foo4(@deprecated int a) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo1: #M1
          foo2: #M2
          foo3: #M3
          foo4: #M4
        interface: #M5
          map
            foo1: #M1
            foo2: #M2
            foo3: #M3
            foo4: #M4
          implemented
            foo1: #M1
            foo2: #M2
            foo3: #M3
            foo4: #M4
''',
      updatedCode: r'''
class A {
  void foo1(int a) {}
  void foo2(@deprecated int a) {}
  void foo3(@deprecated int a) {}
  void foo4(int a) {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo1: #M1
          foo2: #M2
          foo3: #M6
          foo4: #M7
        interface: #M8
          map
            foo1: #M1
            foo2: #M2
            foo3: #M6
            foo4: #M7
          implemented
            foo1: #M1
            foo2: #M2
            foo3: #M6
            foo4: #M7
''',
    );
  }

  test_manifest_class_method_formalParameter_requiredPositional_name() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  void foo(int a) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
''',
      updatedCode: r'''
class A {
  void foo(int b) {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
''',
    );
  }

  test_manifest_class_method_formalParameter_requiredPositional_type() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  void foo(int a) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
''',
      updatedCode: r'''
class A {
  void foo(double a) {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M3
        interface: #M4
          map
            foo: #M3
          implemented
            foo: #M3
''',
    );
  }

  test_manifest_class_method_fromDuplicate_hasInstanceInstance_removeFirst() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  int foo() {}
  double foo() {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConflicts
          foo: #M1
          foo=: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
''',
      updatedCode: r'''
class A {
  double foo() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M3
        interface: #M4
          map
            foo: #M3
          implemented
            foo: #M3
''',
    );
  }

  test_manifest_class_method_fromDuplicate_hasInstanceInstance_removeSecond() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  int foo() {}
  double foo() {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConflicts
          foo: #M1
          foo=: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
''',
      updatedCode: r'''
class A {
  int foo() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M3
        interface: #M4
          map
            foo: #M3
          implemented
            foo: #M3
''',
    );
  }

  test_manifest_class_method_fromDuplicate_hasInstanceStatic_removeFirst() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  int foo() {}
  static double foo() {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConflicts
          foo: #M1
          foo=: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
''',
      updatedCode: r'''
class A {
  static double foo() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M3
        interface: #M4
''',
    );
  }

  test_manifest_class_method_fromDuplicate_hasInstanceStatic_removeSecond() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  int foo() {}
  static double foo() {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConflicts
          foo: #M1
          foo=: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
''',
      updatedCode: r'''
class A {
  int foo() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M3
        interface: #M4
          map
            foo: #M3
          implemented
            foo: #M3
''',
    );
  }

  test_manifest_class_method_fromDuplicate_hasStaticInstance_removeFirst() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  static int foo() {}
  double foo() {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConflicts
          foo: #M1
          foo=: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
''',
      updatedCode: r'''
class A {
  double foo() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M3
        interface: #M4
          map
            foo: #M3
          implemented
            foo: #M3
''',
    );
  }

  test_manifest_class_method_fromDuplicate_hasStaticInstance_removeSecond() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  static int foo() {}
  double foo() {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConflicts
          foo: #M1
          foo=: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
''',
      updatedCode: r'''
class A {
  static int foo() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M3
        interface: #M4
''',
    );
  }

  test_manifest_class_method_fromDuplicate_hasStaticStatic_removeFirst() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  static int foo() {}
  static double foo() {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConflicts
          foo: #M1
          foo=: #M1
        interface: #M2
''',
      updatedCode: r'''
class A {
  static double foo() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M3
        interface: #M2
''',
    );
  }

  test_manifest_class_method_fromDuplicate_hasStaticStatic_removeSecond() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  static int foo() {}
  static double foo() {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConflicts
          foo: #M1
          foo=: #M1
        interface: #M2
''',
      updatedCode: r'''
class A {
  static int foo() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M3
        interface: #M2
''',
    );
  }

  test_manifest_class_method_idChangesWithContainer() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {}
class B {}
class C extends B {
  void foo() {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        interface: #M1
      B: #M2
        interface: #M3
      C: #M4
        declaredMethods
          foo: #M5
        interface: #M6
          map
            foo: #M5
          implemented
            foo: #M5
''',
      updatedCode: r'''
class A {}
class B extends A {}
class C extends B {
  void foo() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        interface: #M1
      B: #M7
        interface: #M8
      C: #M9
        declaredMethods
          foo: #M10
        interface: #M11
          map
            foo: #M10
          implemented
            foo: #M10
''',
    );
  }

  test_manifest_class_method_metadata() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  @Deprecated('0')
  void foo() {}
  @Deprecated('0')
  void bar() {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          bar: #M1
          foo: #M2
        interface: #M3
          map
            bar: #M1
            foo: #M2
          implemented
            bar: #M1
            foo: #M2
''',
      updatedCode: r'''
class A {
  @Deprecated('1')
  void foo() {}
  @Deprecated('0')
  void bar() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          bar: #M1
          foo: #M4
        interface: #M5
          map
            bar: #M1
            foo: #M4
          implemented
            bar: #M1
            foo: #M4
''',
    );
  }

  test_manifest_class_method_modifier_hasEnclosingTypeParameterReference() async {
    configuration.withElementManifests = true;
    await _runLibraryManifestScenario(
      initialCode: r'''
abstract class A<T> {
  T foo1();
  void foo2();
  T foo3();
  void foo4();
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        flags: isAbstract
        typeParameters
          #0 covariant
            bound: <null>
        supertype: Object @ dart:core
        declaredMethods
          foo1: #M1
            flags: hasEnclosingTypeParameterReference isAbstract isSimplyBounded
            functionType: FunctionType
              returnType: typeParameter#0
          foo2: #M2
            flags: isAbstract isSimplyBounded
            functionType: FunctionType
              returnType: void
          foo3: #M3
            flags: hasEnclosingTypeParameterReference isAbstract isSimplyBounded
            functionType: FunctionType
              returnType: typeParameter#0
          foo4: #M4
            flags: isAbstract isSimplyBounded
            functionType: FunctionType
              returnType: void
        interface: #M5
          map
            foo1: #M1
            foo2: #M2
            foo3: #M3
            foo4: #M4
''',
      updatedCode: r'''
abstract class A<T> {
  T foo1();
  void foo2();
  void foo3();
  T foo4();
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        flags: isAbstract
        typeParameters
          #0 covariant
            bound: <null>
        supertype: Object @ dart:core
        declaredMethods
          foo1: #M1
            flags: hasEnclosingTypeParameterReference isAbstract isSimplyBounded
            functionType: FunctionType
              returnType: typeParameter#0
          foo2: #M2
            flags: isAbstract isSimplyBounded
            functionType: FunctionType
              returnType: void
          foo3: #M6
            flags: isAbstract isSimplyBounded
            functionType: FunctionType
              returnType: void
          foo4: #M7
            flags: hasEnclosingTypeParameterReference isAbstract isSimplyBounded
            functionType: FunctionType
              returnType: typeParameter#0
        interface: #M8
          map
            foo1: #M1
            foo2: #M2
            foo3: #M6
            foo4: #M7
''',
    );
  }

  test_manifest_class_method_modifier_hasImplicitReturnType() async {
    configuration.withElementManifests = true;
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  foo1() {}
  void foo2() {}
  foo3() {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        supertype: Object @ dart:core
        declaredMethods
          foo1: #M1
            flags: hasImplicitReturnType isSimplyBounded
            functionType: FunctionType
              returnType: dynamic
          foo2: #M2
            flags: isSimplyBounded
            functionType: FunctionType
              returnType: void
          foo3: #M3
            flags: hasImplicitReturnType isSimplyBounded
            functionType: FunctionType
              returnType: dynamic
        interface: #M4
          map
            foo1: #M1
            foo2: #M2
            foo3: #M3
          implemented
            foo1: #M1
            foo2: #M2
            foo3: #M3
''',
      updatedCode: r'''
class A {
  foo1() {}
  foo2() {}
  void foo3() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        supertype: Object @ dart:core
        declaredMethods
          foo1: #M1
            flags: hasImplicitReturnType isSimplyBounded
            functionType: FunctionType
              returnType: dynamic
          foo2: #M5
            flags: hasImplicitReturnType isSimplyBounded
            functionType: FunctionType
              returnType: dynamic
          foo3: #M6
            flags: isSimplyBounded
            functionType: FunctionType
              returnType: void
        interface: #M7
          map
            foo1: #M1
            foo2: #M5
            foo3: #M6
          implemented
            foo1: #M1
            foo2: #M5
            foo3: #M6
''',
    );
  }

  test_manifest_class_method_modifier_invokesSuperSelf() async {
    configuration.withElementManifests = true;
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  void foo1() {}
  void foo2() {}
  void foo3() {}
  void foo4() {}
}
class B extends A {
  void foo1() {}
  void foo2() {
    super.foo2();
  }
  void foo3() {}
  void foo4() {
    super.foo4();
  }
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        supertype: Object @ dart:core
        declaredMethods
          foo1: #M1
            flags: isSimplyBounded
            functionType: FunctionType
              returnType: void
          foo2: #M2
            flags: isSimplyBounded
            functionType: FunctionType
              returnType: void
          foo3: #M3
            flags: isSimplyBounded
            functionType: FunctionType
              returnType: void
          foo4: #M4
            flags: isSimplyBounded
            functionType: FunctionType
              returnType: void
        interface: #M5
          map
            foo1: #M1
            foo2: #M2
            foo3: #M3
            foo4: #M4
          implemented
            foo1: #M1
            foo2: #M2
            foo3: #M3
            foo4: #M4
      B: #M6
        supertype: A @ package:test/test.dart
        declaredMethods
          foo1: #M7
            flags: isSimplyBounded
            functionType: FunctionType
              returnType: void
          foo2: #M8
            flags: invokesSuperSelf isSimplyBounded
            functionType: FunctionType
              returnType: void
          foo3: #M9
            flags: isSimplyBounded
            functionType: FunctionType
              returnType: void
          foo4: #M10
            flags: invokesSuperSelf isSimplyBounded
            functionType: FunctionType
              returnType: void
        interface: #M11
          map
            foo1: #M7
            foo2: #M8
            foo3: #M9
            foo4: #M10
          implemented
            foo1: #M7
            foo2: #M8
            foo3: #M9
            foo4: #M10
          superImplemented
            [0]
              foo1: #M1
              foo2: #M2
              foo3: #M3
              foo4: #M4
          inherited
            foo1: #M1
            foo2: #M2
            foo3: #M3
            foo4: #M4
''',
      updatedCode: r'''
class A {
  void foo1() {}
  void foo2() {}
  void foo3() {}
  void foo4() {}
}
class B extends A {
  void foo1() {}
  void foo2() {
    super.foo2();
  }
  void foo3() {
    super.foo3();
  }
  void foo4() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        supertype: Object @ dart:core
        declaredMethods
          foo1: #M1
            flags: isSimplyBounded
            functionType: FunctionType
              returnType: void
          foo2: #M2
            flags: isSimplyBounded
            functionType: FunctionType
              returnType: void
          foo3: #M3
            flags: isSimplyBounded
            functionType: FunctionType
              returnType: void
          foo4: #M4
            flags: isSimplyBounded
            functionType: FunctionType
              returnType: void
        interface: #M5
          map
            foo1: #M1
            foo2: #M2
            foo3: #M3
            foo4: #M4
          implemented
            foo1: #M1
            foo2: #M2
            foo3: #M3
            foo4: #M4
      B: #M6
        supertype: A @ package:test/test.dart
        declaredMethods
          foo1: #M7
            flags: isSimplyBounded
            functionType: FunctionType
              returnType: void
          foo2: #M8
            flags: invokesSuperSelf isSimplyBounded
            functionType: FunctionType
              returnType: void
          foo3: #M12
            flags: invokesSuperSelf isSimplyBounded
            functionType: FunctionType
              returnType: void
          foo4: #M13
            flags: isSimplyBounded
            functionType: FunctionType
              returnType: void
        interface: #M14
          map
            foo1: #M7
            foo2: #M8
            foo3: #M12
            foo4: #M13
          implemented
            foo1: #M7
            foo2: #M8
            foo3: #M12
            foo4: #M13
          superImplemented
            [0]
              foo1: #M1
              foo2: #M2
              foo3: #M3
              foo4: #M4
          inherited
            foo1: #M1
            foo2: #M2
            foo3: #M3
            foo4: #M4
''',
    );
  }

  test_manifest_class_method_modifier_isAbstract() async {
    configuration.withElementManifests = true;
    await _runLibraryManifestScenario(
      initialCode: r'''
abstract class A {
  void foo1() {}
  void foo2();
  void foo3() {}
  void foo4();
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        flags: isAbstract
        supertype: Object @ dart:core
        declaredMethods
          foo1: #M1
            flags: isSimplyBounded
            functionType: FunctionType
              returnType: void
          foo2: #M2
            flags: isAbstract isSimplyBounded
            functionType: FunctionType
              returnType: void
          foo3: #M3
            flags: isSimplyBounded
            functionType: FunctionType
              returnType: void
          foo4: #M4
            flags: isAbstract isSimplyBounded
            functionType: FunctionType
              returnType: void
        interface: #M5
          map
            foo1: #M1
            foo2: #M2
            foo3: #M3
            foo4: #M4
          implemented
            foo1: #M1
            foo3: #M3
''',
      updatedCode: r'''
abstract class A {
  void foo1() {}
  void foo2();
  void foo3();
  void foo4() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        flags: isAbstract
        supertype: Object @ dart:core
        declaredMethods
          foo1: #M1
            flags: isSimplyBounded
            functionType: FunctionType
              returnType: void
          foo2: #M2
            flags: isAbstract isSimplyBounded
            functionType: FunctionType
              returnType: void
          foo3: #M6
            flags: isAbstract isSimplyBounded
            functionType: FunctionType
              returnType: void
          foo4: #M7
            flags: isSimplyBounded
            functionType: FunctionType
              returnType: void
        interface: #M8
          map
            foo1: #M1
            foo2: #M2
            foo3: #M6
            foo4: #M7
          implemented
            foo1: #M1
            foo4: #M7
''',
    );
  }

  test_manifest_class_method_modifier_isExternal() async {
    configuration.withElementManifests = true;
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  void foo1() {}
  external void foo2();
  void foo3() {}
  external void foo4();
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        supertype: Object @ dart:core
        declaredMethods
          foo1: #M1
            flags: isSimplyBounded
            functionType: FunctionType
              returnType: void
          foo2: #M2
            flags: isExternal isSimplyBounded
            functionType: FunctionType
              returnType: void
          foo3: #M3
            flags: isSimplyBounded
            functionType: FunctionType
              returnType: void
          foo4: #M4
            flags: isExternal isSimplyBounded
            functionType: FunctionType
              returnType: void
        interface: #M5
          map
            foo1: #M1
            foo2: #M2
            foo3: #M3
            foo4: #M4
          implemented
            foo1: #M1
            foo2: #M2
            foo3: #M3
            foo4: #M4
''',
      updatedCode: r'''
class A {
  void foo1() {}
  external void foo2();
  external void foo3();
  void foo4() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        supertype: Object @ dart:core
        declaredMethods
          foo1: #M1
            flags: isSimplyBounded
            functionType: FunctionType
              returnType: void
          foo2: #M2
            flags: isExternal isSimplyBounded
            functionType: FunctionType
              returnType: void
          foo3: #M6
            flags: isExternal isSimplyBounded
            functionType: FunctionType
              returnType: void
          foo4: #M7
            flags: isSimplyBounded
            functionType: FunctionType
              returnType: void
        interface: #M8
          map
            foo1: #M1
            foo2: #M2
            foo3: #M6
            foo4: #M7
          implemented
            foo1: #M1
            foo2: #M2
            foo3: #M6
            foo4: #M7
''',
    );
  }

  test_manifest_class_method_modifier_isOperatorEqualWithParameterTypeFromObject() async {
    configuration
      ..withElementManifests = true
      ..ignoredManifestInstanceMemberNames.remove('==');

    await _runLibraryManifestScenario(
      initialCode: r'''
abstract class A {
  bool operator ==(other);
}
abstract class B {
  bool operator ==(Object? other);
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        flags: isAbstract
        supertype: Object @ dart:core
        declaredMethods
          ==: #M1
            flags: isAbstract isOperatorEqualWithParameterTypeFromObject isSimplyBounded
            functionType: FunctionType
              positional
                required Object @ dart:core
              returnType: bool @ dart:core
        interface: #M2
          map
            ==: #M1
          implemented
            ==: #M3
          superImplemented
            [0]
              ==: #M3
          inherited
            ==: #M3
      B: #M4
        flags: isAbstract
        supertype: Object @ dart:core
        declaredMethods
          ==: #M5
            flags: isAbstract isSimplyBounded
            functionType: FunctionType
              positional
                required Object? @ dart:core
              returnType: bool @ dart:core
        interface: #M6
          map
            ==: #M5
          implemented
            ==: #M3
          superImplemented
            [0]
              ==: #M3
          inherited
            ==: #M3
''',
      updatedCode: r'''
abstract class A {
  bool operator ==(Object? other);
}
abstract class B {
  bool operator ==(other);
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        flags: isAbstract
        supertype: Object @ dart:core
        declaredMethods
          ==: #M7
            flags: isAbstract isSimplyBounded
            functionType: FunctionType
              positional
                required Object? @ dart:core
              returnType: bool @ dart:core
        interface: #M8
          map
            ==: #M7
          implemented
            ==: #M3
          superImplemented
            [0]
              ==: #M3
          inherited
            ==: #M3
      B: #M4
        flags: isAbstract
        supertype: Object @ dart:core
        declaredMethods
          ==: #M9
            flags: isAbstract isOperatorEqualWithParameterTypeFromObject isSimplyBounded
            functionType: FunctionType
              positional
                required Object @ dart:core
              returnType: bool @ dart:core
        interface: #M10
          map
            ==: #M9
          implemented
            ==: #M3
          superImplemented
            [0]
              ==: #M3
          inherited
            ==: #M3
''',
    );
  }

  test_manifest_class_method_modifier_isStatic() async {
    configuration.withElementManifests = true;
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  void foo1() {}
  static void foo2() {}
  void foo3() {}
  static void foo4() {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        supertype: Object @ dart:core
        declaredMethods
          foo1: #M1
            flags: isSimplyBounded
            functionType: FunctionType
              returnType: void
          foo2: #M2
            flags: isSimplyBounded isStatic
            functionType: FunctionType
              returnType: void
          foo3: #M3
            flags: isSimplyBounded
            functionType: FunctionType
              returnType: void
          foo4: #M4
            flags: isSimplyBounded isStatic
            functionType: FunctionType
              returnType: void
        interface: #M5
          map
            foo1: #M1
            foo3: #M3
          implemented
            foo1: #M1
            foo3: #M3
''',
      updatedCode: r'''
class A {
  void foo1() {}
  static void foo2() {}
  static void foo3() {}
  void foo4() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        supertype: Object @ dart:core
        declaredMethods
          foo1: #M1
            flags: isSimplyBounded
            functionType: FunctionType
              returnType: void
          foo2: #M2
            flags: isSimplyBounded isStatic
            functionType: FunctionType
              returnType: void
          foo3: #M6
            flags: isSimplyBounded isStatic
            functionType: FunctionType
              returnType: void
          foo4: #M7
            flags: isSimplyBounded
            functionType: FunctionType
              returnType: void
        interface: #M8
          map
            foo1: #M1
            foo4: #M7
          implemented
            foo1: #M1
            foo4: #M7
''',
    );
  }

  test_manifest_class_method_modifier_typeInferenceError() async {
    configuration.withElementManifests = true;

    await _runLibraryManifestScenario(
      initialCode: r'''
abstract class A {
  void foo(double x);
}
abstract class B {
  void foo(int x);
}
class C implements A, B {
  void foo(x) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        flags: isAbstract
        supertype: Object @ dart:core
        declaredMethods
          foo: #M1
            flags: isAbstract isSimplyBounded
            functionType: FunctionType
              positional
                required double @ dart:core
              returnType: void
        interface: #M2
          map
            foo: #M1
      B: #M3
        flags: isAbstract
        supertype: Object @ dart:core
        declaredMethods
          foo: #M4
            flags: isAbstract isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
        interface: #M5
          map
            foo: #M4
      C: #M6
        supertype: Object @ dart:core
        interfaces
          A @ package:test/test.dart
          B @ package:test/test.dart
        declaredMethods
          foo: #M7
            flags: isSimplyBounded
            functionType: FunctionType
              positional
                required dynamic
              returnType: void
            inferenceError: overrideNoCombinedSuperSignature(A.foo (void Function(double)), B.foo (void Function(int)))
        interface: #M8
          map
            foo: #M7
          implemented
            foo: #M7
''',
      updatedCode: r'''
abstract class A {
  void foo(String x);
}
abstract class B {
  void foo(int x);
}
class C implements A, B {
  void foo(x) {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        flags: isAbstract
        supertype: Object @ dart:core
        declaredMethods
          foo: #M9
            flags: isAbstract isSimplyBounded
            functionType: FunctionType
              positional
                required String @ dart:core
              returnType: void
        interface: #M10
          map
            foo: #M9
      B: #M3
        flags: isAbstract
        supertype: Object @ dart:core
        declaredMethods
          foo: #M4
            flags: isAbstract isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
        interface: #M5
          map
            foo: #M4
      C: #M6
        supertype: Object @ dart:core
        interfaces
          A @ package:test/test.dart
          B @ package:test/test.dart
        declaredMethods
          foo: #M11
            flags: isSimplyBounded
            functionType: FunctionType
              positional
                required dynamic
              returnType: void
            inferenceError: overrideNoCombinedSuperSignature(A.foo (void Function(String)), B.foo (void Function(int)))
        interface: #M12
          map
            foo: #M11
          implemented
            foo: #M11
''',
    );
  }

  test_manifest_class_method_private_instance() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  void _foo() {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          _foo: #M1
        interface: #M2
''',
      updatedCode: r'''
class A {
  void _foo() {}
  void bar() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          _foo: #M1
          bar: #M3
        interface: #M4
          map
            bar: #M3
          implemented
            bar: #M3
''',
    );
  }

  test_manifest_class_method_private_static() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  static void _foo() {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          _foo: #M1
        interface: #M2
''',
      updatedCode: r'''
class A {
  static void _foo() {}
  void bar() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          _foo: #M1
          bar: #M3
        interface: #M4
          map
            bar: #M3
          implemented
            bar: #M3
''',
    );
  }

  test_manifest_class_method_remove() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  void foo() {}
  void bar() {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          bar: #M1
          foo: #M2
        interface: #M3
          map
            bar: #M1
            foo: #M2
          implemented
            bar: #M1
            foo: #M2
''',
      updatedCode: r'''
class A {
  void foo() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M2
        interface: #M4
          map
            foo: #M2
          implemented
            foo: #M2
''',
    );
  }

  test_manifest_class_method_returnType() async {
    configuration.withElementManifests = true;
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  int foo() {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        supertype: Object @ dart:core
        declaredMethods
          foo: #M1
            flags: isSimplyBounded
            functionType: FunctionType
              returnType: int @ dart:core
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
''',
      updatedCode: r'''
class A {
  double foo() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        supertype: Object @ dart:core
        declaredMethods
          foo: #M3
            flags: isSimplyBounded
            functionType: FunctionType
              returnType: double @ dart:core
        interface: #M4
          map
            foo: #M3
          implemented
            foo: #M3
''',
    );
  }

  test_manifest_class_method_toDuplicate_hasInstance_addInstance_after() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  int foo() {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
''',
      updatedCode: r'''
class A {
  int foo() {}
  double foo() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConflicts
          foo: #M3
          foo=: #M3
        interface: #M4
          map
            foo: #M3
          implemented
            foo: #M3
''',
    );
  }

  test_manifest_class_method_toDuplicate_hasInstance_addInstance_before() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  int foo() {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
''',
      updatedCode: r'''
class A {
  double foo() {}
  int foo() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConflicts
          foo: #M3
          foo=: #M3
        interface: #M4
          map
            foo: #M3
          implemented
            foo: #M3
''',
    );
  }

  test_manifest_class_method_toDuplicate_hasInstance_addStatic_after() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  int foo() {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
''',
      updatedCode: r'''
class A {
  int foo() {}
  static double foo() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConflicts
          foo: #M3
          foo=: #M3
        interface: #M4
          map
            foo: #M3
          implemented
            foo: #M3
''',
    );
  }

  test_manifest_class_method_toDuplicate_hasInstance_addStatic_before() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  int foo() {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
''',
      updatedCode: r'''
class A {
  static double foo() {}
  int foo() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConflicts
          foo: #M3
          foo=: #M3
        interface: #M4
          map
            foo: #M3
          implemented
            foo: #M3
''',
    );
  }

  test_manifest_class_method_toDuplicate_hasStatic_addInstance_after() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  static int foo() {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
''',
      updatedCode: r'''
class A {
  static int foo() {}
  double foo() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConflicts
          foo: #M3
          foo=: #M3
        interface: #M4
          map
            foo: #M3
          implemented
            foo: #M3
''',
    );
  }

  test_manifest_class_method_toDuplicate_hasStatic_addInstance_before() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  static int foo() {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
''',
      updatedCode: r'''
class A {
  double foo() {}
  static int foo() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConflicts
          foo: #M3
          foo=: #M3
        interface: #M4
          map
            foo: #M3
          implemented
            foo: #M3
''',
    );
  }

  test_manifest_class_method_toDuplicate_hasStatic_addStatic_after() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  static int foo() {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
''',
      updatedCode: r'''
class A {
  static int foo() {}
  static double foo() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConflicts
          foo: #M3
          foo=: #M3
        interface: #M2
''',
    );
  }

  test_manifest_class_method_toDuplicate_hasStatic_addStatic_before() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  static int foo() {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
''',
      updatedCode: r'''
class A {
  static double foo() {}
  static int foo() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConflicts
          foo: #M3
          foo=: #M3
        interface: #M2
''',
    );
  }

  test_manifest_class_method_typeParameter() async {
    configuration.withElementManifests = true;
    await _runLibraryManifestScenario(
      initialCode: r'''
class A<T> {
  Map<T, U> foo<U>() {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        typeParameters
          #0 covariant
            bound: <null>
        supertype: Object @ dart:core
        declaredMethods
          foo: #M1
            flags: hasEnclosingTypeParameterReference isSimplyBounded
            functionType: FunctionType
              typeParameters
                #0 covariant
                  bound: <null>
              returnType: Map @ dart:core
                typeParameter#1
                typeParameter#0
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
''',
      updatedCode: r'''
class A<T> {
  Map<T, U> foo<U>() {}
  void bar() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        typeParameters
          #0 covariant
            bound: <null>
        supertype: Object @ dart:core
        declaredMethods
          bar: #M3
            flags: isSimplyBounded
            functionType: FunctionType
              returnType: void
          foo: #M1
            flags: hasEnclosingTypeParameterReference isSimplyBounded
            functionType: FunctionType
              typeParameters
                #0 covariant
                  bound: <null>
              returnType: Map @ dart:core
                typeParameter#1
                typeParameter#0
        interface: #M4
          map
            bar: #M3
            foo: #M1
          implemented
            bar: #M3
            foo: #M1
''',
    );
  }

  test_manifest_class_method_typeParameter_add() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  void foo<T>() {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
''',
      updatedCode: r'''
class A {
  void foo<T, U>() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M3
        interface: #M4
          map
            foo: #M3
          implemented
            foo: #M3
''',
    );
  }

  test_manifest_class_method_typeParameter_remove() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  void foo<T, U>() {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
''',
      updatedCode: r'''
class A {
  void foo<T>() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M3
        interface: #M4
          map
            foo: #M3
          implemented
            foo: #M3
''',
    );
  }

  test_manifest_class_modifier_isAbstract() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {}
abstract class B {}
class C {}
abstract class D {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        interface: #M1
      B: #M2
        interface: #M3
      C: #M4
        interface: #M5
      D: #M6
        interface: #M7
''',
      updatedCode: r'''
class A {}
abstract class B {}
abstract class C {}
class D {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        interface: #M1
      B: #M2
        interface: #M3
      C: #M8
        interface: #M9
      D: #M10
        interface: #M11
''',
    );
  }

  test_manifest_class_modifier_isBase() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {}
base class B {}
class C {}
base class D {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        interface: #M1
      B: #M2
        interface: #M3
      C: #M4
        interface: #M5
      D: #M6
        interface: #M7
''',
      updatedCode: r'''
class A {}
base class B {}
base class C {}
class D {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        interface: #M1
      B: #M2
        interface: #M3
      C: #M8
        interface: #M9
      D: #M10
        interface: #M11
''',
    );
  }

  test_manifest_class_modifier_isFinal() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {}
final class B {}
class C {}
final class D {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        interface: #M1
      B: #M2
        interface: #M3
      C: #M4
        interface: #M5
      D: #M6
        interface: #M7
''',
      updatedCode: r'''
class A {}
final class B {}
final class C {}
class D {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        interface: #M1
      B: #M2
        interface: #M3
      C: #M8
        interface: #M9
      D: #M10
        interface: #M11
''',
    );
  }

  test_manifest_class_modifier_isInterface() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {}
interface class B {}
class C {}
interface class D {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        interface: #M1
      B: #M2
        interface: #M3
      C: #M4
        interface: #M5
      D: #M6
        interface: #M7
''',
      updatedCode: r'''
class A {}
interface class B {}
interface class C {}
class D {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        interface: #M1
      B: #M2
        interface: #M3
      C: #M8
        interface: #M9
      D: #M10
        interface: #M11
''',
    );
  }

  test_manifest_class_modifier_isMixinApplication() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {}
class B = Object with M;
class C {}
class D = Object with M;
mixin M {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        interface: #M1
      B: #M2
        interface: #M3
      C: #M4
        interface: #M5
      D: #M6
        interface: #M7
    declaredMixins
      M: #M8
        interface: #M9
''',
      updatedCode: r'''
class A {}
class B = Object with M;
class C = Object with M;
class D {}
mixin M {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        interface: #M1
      B: #M2
        interface: #M3
      C: #M10
        interface: #M11
      D: #M12
        interface: #M13
    declaredMixins
      M: #M8
        interface: #M9
''',
    );
  }

  test_manifest_class_modifier_isMixinClass() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {}
mixin class B {}
class C {}
mixin class D {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        interface: #M1
      B: #M2
        interface: #M3
      C: #M4
        interface: #M5
      D: #M6
        interface: #M7
''',
      updatedCode: r'''
class A {}
mixin class B {}
mixin class C {}
class D {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        interface: #M1
      B: #M2
        interface: #M3
      C: #M8
        interface: #M9
      D: #M10
        interface: #M11
''',
    );
  }

  test_manifest_class_modifier_isSealed() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {}
sealed class B {}
class C {}
sealed class D {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        interface: #M1
      B: #M2
        interface: #M3
      C: #M4
        interface: #M5
      D: #M6
        interface: #M7
''',
      updatedCode: r'''
class A {}
sealed class B {}
sealed class C {}
class D {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        interface: #M1
      B: #M2
        interface: #M3
      C: #M8
        interface: #M9
      D: #M10
        interface: #M11
''',
    );
  }

  test_manifest_class_modifier_isSimplyBounded() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A<T> {}
class B<T extends List<T>> {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        interface: #M1
      B: #M2
        interface: #M3
''',
      updatedCode: r'''
class A<T extends List<T>> {}
class B<T> {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M4
        interface: #M5
      B: #M6
        interface: #M7
''',
    );
  }

  test_manifest_class_private() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class _A {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      _A: #M0
        interface: #M1
''',
      updatedCode: r'''
class _A {}
class B {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      B: #M2
        interface: #M3
      _A: #M0
        interface: #M1
''',
    );
  }

  test_manifest_class_remove() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        interface: #M1
''',
      updatedCode: '',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
''',
    );
  }

  test_manifest_class_setter_add_extends() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  set foo(int _) {}
}

class B extends A {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredSetters
          foo=: #M2
        interface: #M3
          map
            foo=: #M2
          implemented
            foo=: #M2
      B: #M4
        interface: #M5
          map
            foo=: #M2
          implemented
            foo=: #M2
          superImplemented
            [0]
              foo=: #M2
          inherited
            foo=: #M2
''',
      updatedCode: r'''
class A {
  set foo(int _) {}
  set bar(int _) {}
}

class B extends A {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          bar: #M6
          foo: #M1
        declaredSetters
          bar=: #M7
          foo=: #M2
        interface: #M8
          map
            bar=: #M7
            foo=: #M2
          implemented
            bar=: #M7
            foo=: #M2
      B: #M4
        interface: #M9
          map
            bar=: #M7
            foo=: #M2
          implemented
            bar=: #M7
            foo=: #M2
          superImplemented
            [0]
              bar=: #M7
              foo=: #M2
          inherited
            bar=: #M7
            foo=: #M2
''',
    );
  }

  test_manifest_class_setter_add_extends_generic() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A<T> {
  set foo(T _) {}
}

class B extends A<int> {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredSetters
          foo=: #M2
        interface: #M3
          map
            foo=: #M2
          implemented
            foo=: #M2
      B: #M4
        interface: #M5
          map
            foo=: #M2
          implemented
            foo=: #M2
          superImplemented
            [0]
              foo=: #M2
          inherited
            foo=: #M2
''',
      updatedCode: r'''
class A<T> {
  set foo(T _) {}
  set bar(T _) {}
}

class B extends A<int> {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          bar: #M6
          foo: #M1
        declaredSetters
          bar=: #M7
          foo=: #M2
        interface: #M8
          map
            bar=: #M7
            foo=: #M2
          implemented
            bar=: #M7
            foo=: #M2
      B: #M4
        interface: #M9
          map
            bar=: #M7
            foo=: #M2
          implemented
            bar=: #M7
            foo=: #M2
          superImplemented
            [0]
              bar=: #M7
              foo=: #M2
          inherited
            bar=: #M7
            foo=: #M2
''',
    );
  }

  test_manifest_class_setter_add_implements() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  set foo(int _) {}
}

class B implements A {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredSetters
          foo=: #M2
        interface: #M3
          map
            foo=: #M2
          implemented
            foo=: #M2
      B: #M4
        interface: #M5
          map
            foo=: #M2
          inherited
            foo=: #M2
''',
      updatedCode: r'''
class A {
  set foo(int _) {}
  set bar(int _) {}
}

class B implements A {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          bar: #M6
          foo: #M1
        declaredSetters
          bar=: #M7
          foo=: #M2
        interface: #M8
          map
            bar=: #M7
            foo=: #M2
          implemented
            bar=: #M7
            foo=: #M2
      B: #M4
        interface: #M9
          map
            bar=: #M7
            foo=: #M2
          inherited
            bar=: #M7
            foo=: #M2
''',
    );
  }

  test_manifest_class_setter_add_implements_generic() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A<T> {
  set foo(T _) {}
}

class B implements A<int> {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredSetters
          foo=: #M2
        interface: #M3
          map
            foo=: #M2
          implemented
            foo=: #M2
      B: #M4
        interface: #M5
          map
            foo=: #M2
          inherited
            foo=: #M2
''',
      updatedCode: r'''
class A<T> {
  set foo(T _) {}
  set bar(T _) {}
}

class B implements A<int> {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          bar: #M6
          foo: #M1
        declaredSetters
          bar=: #M7
          foo=: #M2
        interface: #M8
          map
            bar=: #M7
            foo=: #M2
          implemented
            bar=: #M7
            foo=: #M2
      B: #M4
        interface: #M9
          map
            bar=: #M7
            foo=: #M2
          inherited
            bar=: #M7
            foo=: #M2
''',
    );
  }

  test_manifest_class_setter_add_with() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  set foo(int _) {}
}

class B with A {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredSetters
          foo=: #M2
        interface: #M3
          map
            foo=: #M2
          implemented
            foo=: #M2
      B: #M4
        interface: #M5
          map
            foo=: #M2
          implemented
            foo=: #M2
          superImplemented
            [1]
              foo=: #M2
          inherited
            foo=: #M2
''',
      updatedCode: r'''
class A {
  set foo(int _) {}
  set bar(int _) {}
}

class B with A {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          bar: #M6
          foo: #M1
        declaredSetters
          bar=: #M7
          foo=: #M2
        interface: #M8
          map
            bar=: #M7
            foo=: #M2
          implemented
            bar=: #M7
            foo=: #M2
      B: #M4
        interface: #M9
          map
            bar=: #M7
            foo=: #M2
          implemented
            bar=: #M7
            foo=: #M2
          superImplemented
            [1]
              bar=: #M7
              foo=: #M2
          inherited
            bar=: #M7
            foo=: #M2
''',
    );
  }

  test_manifest_class_setter_add_with_generic() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A<T> {
  set foo(T _) {}
}

class B with A<int> {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredSetters
          foo=: #M2
        interface: #M3
          map
            foo=: #M2
          implemented
            foo=: #M2
      B: #M4
        interface: #M5
          map
            foo=: #M2
          implemented
            foo=: #M2
          superImplemented
            [1]
              foo=: #M2
          inherited
            foo=: #M2
''',
      updatedCode: r'''
class A<T> {
  set foo(T _) {}
  set bar(T _) {}
}

class B with A<int> {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          bar: #M6
          foo: #M1
        declaredSetters
          bar=: #M7
          foo=: #M2
        interface: #M8
          map
            bar=: #M7
            foo=: #M2
          implemented
            bar=: #M7
            foo=: #M2
      B: #M4
        interface: #M9
          map
            bar=: #M7
            foo=: #M2
          implemented
            bar=: #M7
            foo=: #M2
          superImplemented
            [1]
              bar=: #M7
              foo=: #M2
          inherited
            bar=: #M7
            foo=: #M2
''',
    );
  }

  test_manifest_class_setter_combinedSignatures_merged_addUnrelated() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
abstract class A {
  set foo(num _);
}

abstract class B {
  set foo(int _);
}

abstract class C implements A, B {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredSetters
          foo=: #M2
        interface: #M3
          map
            foo=: #M2
      B: #M4
        declaredFields
          foo: #M5
        declaredSetters
          foo=: #M6
        interface: #M7
          map
            foo=: #M6
      C: #M8
        interface: #M9
          map
            foo=: #M10
          combinedIds
            [#M2, #M6]: #M10
          inherited
            foo=: #M2
''',
      updatedCode: r'''
abstract class A {
  set foo(num _);
}

abstract class B {
  set foo(int _);
}

abstract class C implements A, B {
  void zzz();
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredSetters
          foo=: #M2
        interface: #M3
          map
            foo=: #M2
      B: #M4
        declaredFields
          foo: #M5
        declaredSetters
          foo=: #M6
        interface: #M7
          map
            foo=: #M6
      C: #M8
        declaredMethods
          zzz: #M11
        interface: #M12
          map
            foo=: #M10
            zzz: #M11
          combinedIds
            [#M2, #M6]: #M10
          inherited
            foo=: #M2
''',
    );
  }

  test_manifest_class_setter_combinedSignatures_merged_inherit() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
abstract class A {
  set foo(dynamic _);
}

abstract class B {
  set foo(void _);
}

abstract class C implements A, B {}

abstract class D implements C {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredSetters
          foo=: #M2
        interface: #M3
          map
            foo=: #M2
      B: #M4
        declaredFields
          foo: #M5
        declaredSetters
          foo=: #M6
        interface: #M7
          map
            foo=: #M6
      C: #M8
        interface: #M9
          map
            foo=: #M10
          combinedIds
            [#M2, #M6]: #M10
          inherited
            foo=: #M10
      D: #M11
        interface: #M12
          map
            foo=: #M10
          inherited
            foo=: #M10
''',
      updatedCode: r'''
abstract class A {
  set foo(dynamic _);
}

abstract class B {
  set foo(void _);
}

abstract class C implements A, B {
  void xxx() {}
}

abstract class D implements C {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredSetters
          foo=: #M2
        interface: #M3
          map
            foo=: #M2
      B: #M4
        declaredFields
          foo: #M5
        declaredSetters
          foo=: #M6
        interface: #M7
          map
            foo=: #M6
      C: #M8
        declaredMethods
          xxx: #M13
        interface: #M14
          map
            foo=: #M10
            xxx: #M13
          combinedIds
            [#M2, #M6]: #M10
          implemented
            xxx: #M13
          inherited
            foo=: #M10
      D: #M11
        interface: #M15
          map
            foo=: #M10
            xxx: #M13
          inherited
            foo=: #M10
            xxx: #M13
''',
    );
  }

  test_manifest_class_setter_formalParameter_covariant() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  set foo1(int a) {}
  set foo2(covariant int a) {}
  set foo3(int a) {}
  set foo4(covariant int a) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo1: #M1
          foo2: #M2
          foo3: #M3
          foo4: #M4
        declaredSetters
          foo1=: #M5
          foo2=: #M6
          foo3=: #M7
          foo4=: #M8
        interface: #M9
          map
            foo1=: #M5
            foo2=: #M6
            foo3=: #M7
            foo4=: #M8
          implemented
            foo1=: #M5
            foo2=: #M6
            foo3=: #M7
            foo4=: #M8
''',
      updatedCode: r'''
class A {
  set foo1(int a) {}
  set foo2(covariant int a) {}
  set foo3(covariant int a) {}
  set foo4(int a) {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo1: #M1
          foo2: #M2
          foo3: #M3
          foo4: #M4
        declaredSetters
          foo1=: #M5
          foo2=: #M6
          foo3=: #M10
          foo4=: #M11
        interface: #M12
          map
            foo1=: #M5
            foo2=: #M6
            foo3=: #M10
            foo4=: #M11
          implemented
            foo1=: #M5
            foo2=: #M6
            foo3=: #M10
            foo4=: #M11
''',
    );
  }

  test_manifest_class_setter_formalParameter_metadata() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  set foo1(int a) {}
  set foo2(@deprecated int a) {}
  set foo3(int a) {}
  set foo4(@deprecated int a) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo1: #M1
          foo2: #M2
          foo3: #M3
          foo4: #M4
        declaredSetters
          foo1=: #M5
          foo2=: #M6
          foo3=: #M7
          foo4=: #M8
        interface: #M9
          map
            foo1=: #M5
            foo2=: #M6
            foo3=: #M7
            foo4=: #M8
          implemented
            foo1=: #M5
            foo2=: #M6
            foo3=: #M7
            foo4=: #M8
''',
      updatedCode: r'''
class A {
  set foo1(int a) {}
  set foo2(@deprecated int a) {}
  set foo3(@deprecated int a) {}
  set foo4(int a) {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo1: #M1
          foo2: #M2
          foo3: #M3
          foo4: #M4
        declaredSetters
          foo1=: #M5
          foo2=: #M6
          foo3=: #M10
          foo4=: #M11
        interface: #M12
          map
            foo1=: #M5
            foo2=: #M6
            foo3=: #M10
            foo4=: #M11
          implemented
            foo1=: #M5
            foo2=: #M6
            foo3=: #M10
            foo4=: #M11
''',
    );
  }

  test_manifest_class_setter_idChangesWithContainer() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {}
class B {}
class C extends B {
  void set foo(int value) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        interface: #M1
      B: #M2
        interface: #M3
      C: #M4
        declaredFields
          foo: #M5
        declaredSetters
          foo=: #M6
        interface: #M7
          map
            foo=: #M6
          implemented
            foo=: #M6
''',
      updatedCode: r'''
class A {}
class B extends A {}
class C extends B {
  void set foo(int value) {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        interface: #M1
      B: #M8
        interface: #M9
      C: #M10
        declaredFields
          foo: #M11
        declaredSetters
          foo=: #M12
        interface: #M13
          map
            foo=: #M12
          implemented
            foo=: #M12
''',
    );
  }

  test_manifest_class_setter_isSynthetic() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  int foo = 0;
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        declaredSetters
          foo=: #M3
        interface: #M4
          map
            foo: #M2
            foo=: #M3
          implemented
            foo: #M2
            foo=: #M3
''',
      updatedCode: r'''
class A {
  int get foo => 0;
  set foo(int _) {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M5
        declaredGetters
          foo: #M6
        declaredSetters
          foo=: #M7
        interface: #M8
          map
            foo: #M6
            foo=: #M7
          implemented
            foo: #M6
            foo=: #M7
''',
    );
  }

  test_manifest_class_setter_metadata() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  @Deprecated('0')
  set foo(int _) {}
  @Deprecated('0')
  set bar(int _) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          bar: #M1
          foo: #M2
        declaredSetters
          bar=: #M3
          foo=: #M4
        interface: #M5
          map
            bar=: #M3
            foo=: #M4
          implemented
            bar=: #M3
            foo=: #M4
''',
      updatedCode: r'''
class A {
  @Deprecated('1')
  set foo(int _) {}
  @Deprecated('0')
  set bar(int _) {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          bar: #M1
          foo: #M2
        declaredSetters
          bar=: #M3
          foo=: #M6
        interface: #M7
          map
            bar=: #M3
            foo=: #M6
          implemented
            bar=: #M3
            foo=: #M6
''',
    );
  }

  test_manifest_class_setter_modifier_hasEnclosingTypeParameterReference() async {
    configuration.withElementManifests = true;
    await _runLibraryManifestScenario(
      initialCode: r'''
abstract class A<T> {
  set foo1(T value);
  set foo2(int value);
  set foo3(T value);
  set foo4(int value);
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        flags: isAbstract
        typeParameters
          #0 covariant
            bound: <null>
        supertype: Object @ dart:core
        declaredFields
          foo1: #M1
            flags: hasEnclosingTypeParameterReference isSynthetic shouldUseTypeForInitializerInference
            type: typeParameter#0
          foo2: #M2
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo3: #M3
            flags: hasEnclosingTypeParameterReference isSynthetic shouldUseTypeForInitializerInference
            type: typeParameter#0
          foo4: #M4
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
        declaredSetters
          foo1=: #M5
            flags: hasEnclosingTypeParameterReference hasImplicitReturnType isAbstract isSimplyBounded
            functionType: FunctionType
              positional
                required typeParameter#0
              returnType: void
          foo2=: #M6
            flags: hasImplicitReturnType isAbstract isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
          foo3=: #M7
            flags: hasEnclosingTypeParameterReference hasImplicitReturnType isAbstract isSimplyBounded
            functionType: FunctionType
              positional
                required typeParameter#0
              returnType: void
          foo4=: #M8
            flags: hasImplicitReturnType isAbstract isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
        interface: #M9
          map
            foo1=: #M5
            foo2=: #M6
            foo3=: #M7
            foo4=: #M8
''',
      updatedCode: r'''
abstract class A<T> {
  set foo1(T value);
  set foo2(int value);
  set foo3(int value);
  set foo4(T value);
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        flags: isAbstract
        typeParameters
          #0 covariant
            bound: <null>
        supertype: Object @ dart:core
        declaredFields
          foo1: #M1
            flags: hasEnclosingTypeParameterReference isSynthetic shouldUseTypeForInitializerInference
            type: typeParameter#0
          foo2: #M2
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo3: #M10
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo4: #M11
            flags: hasEnclosingTypeParameterReference isSynthetic shouldUseTypeForInitializerInference
            type: typeParameter#0
        declaredSetters
          foo1=: #M5
            flags: hasEnclosingTypeParameterReference hasImplicitReturnType isAbstract isSimplyBounded
            functionType: FunctionType
              positional
                required typeParameter#0
              returnType: void
          foo2=: #M6
            flags: hasImplicitReturnType isAbstract isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
          foo3=: #M12
            flags: hasImplicitReturnType isAbstract isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
          foo4=: #M13
            flags: hasEnclosingTypeParameterReference hasImplicitReturnType isAbstract isSimplyBounded
            functionType: FunctionType
              positional
                required typeParameter#0
              returnType: void
        interface: #M14
          map
            foo1=: #M5
            foo2=: #M6
            foo3=: #M12
            foo4=: #M13
''',
    );
  }

  test_manifest_class_setter_modifier_invokesSuperSelf() async {
    configuration.withElementManifests = true;
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  set foo1(int value) {}
  set foo2(int value) {}
  set foo3(int value) {}
  set foo4(int value) {}
}
class B extends A {
  set foo1(int value) {}
  set foo2(int value) { super.foo2 = value; }
  set foo3(int value) {}
  set foo4(int value) { super.foo4 = value; }
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        supertype: Object @ dart:core
        declaredFields
          foo1: #M1
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo2: #M2
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo3: #M3
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo4: #M4
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
        declaredSetters
          foo1=: #M5
            flags: hasImplicitReturnType isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
          foo2=: #M6
            flags: hasImplicitReturnType isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
          foo3=: #M7
            flags: hasImplicitReturnType isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
          foo4=: #M8
            flags: hasImplicitReturnType isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
        interface: #M9
          map
            foo1=: #M5
            foo2=: #M6
            foo3=: #M7
            foo4=: #M8
          implemented
            foo1=: #M5
            foo2=: #M6
            foo3=: #M7
            foo4=: #M8
      B: #M10
        supertype: A @ package:test/test.dart
        declaredFields
          foo1: #M11
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo2: #M12
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo3: #M13
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo4: #M14
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
        declaredSetters
          foo1=: #M15
            flags: hasImplicitReturnType isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
          foo2=: #M16
            flags: hasImplicitReturnType invokesSuperSelf isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
          foo3=: #M17
            flags: hasImplicitReturnType isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
          foo4=: #M18
            flags: hasImplicitReturnType invokesSuperSelf isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
        interface: #M19
          map
            foo1=: #M15
            foo2=: #M16
            foo3=: #M17
            foo4=: #M18
          implemented
            foo1=: #M15
            foo2=: #M16
            foo3=: #M17
            foo4=: #M18
          superImplemented
            [0]
              foo1=: #M5
              foo2=: #M6
              foo3=: #M7
              foo4=: #M8
          inherited
            foo1=: #M5
            foo2=: #M6
            foo3=: #M7
            foo4=: #M8
''',
      updatedCode: r'''
class A {
  set foo1(int value) {}
  set foo2(int value) {}
  set foo3(int value) {}
  set foo4(int value) {}
}
class B extends A {
  set foo1(int value) {}
  set foo2(int value) { super.foo2 = value; }
  set foo3(int value) { super.foo3 = value; }
  set foo4(int value) {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        supertype: Object @ dart:core
        declaredFields
          foo1: #M1
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo2: #M2
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo3: #M3
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo4: #M4
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
        declaredSetters
          foo1=: #M5
            flags: hasImplicitReturnType isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
          foo2=: #M6
            flags: hasImplicitReturnType isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
          foo3=: #M7
            flags: hasImplicitReturnType isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
          foo4=: #M8
            flags: hasImplicitReturnType isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
        interface: #M9
          map
            foo1=: #M5
            foo2=: #M6
            foo3=: #M7
            foo4=: #M8
          implemented
            foo1=: #M5
            foo2=: #M6
            foo3=: #M7
            foo4=: #M8
      B: #M10
        supertype: A @ package:test/test.dart
        declaredFields
          foo1: #M11
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo2: #M12
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo3: #M13
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo4: #M14
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
        declaredSetters
          foo1=: #M15
            flags: hasImplicitReturnType isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
          foo2=: #M16
            flags: hasImplicitReturnType invokesSuperSelf isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
          foo3=: #M20
            flags: hasImplicitReturnType invokesSuperSelf isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
          foo4=: #M21
            flags: hasImplicitReturnType isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
        interface: #M22
          map
            foo1=: #M15
            foo2=: #M16
            foo3=: #M20
            foo4=: #M21
          implemented
            foo1=: #M15
            foo2=: #M16
            foo3=: #M20
            foo4=: #M21
          superImplemented
            [0]
              foo1=: #M5
              foo2=: #M6
              foo3=: #M7
              foo4=: #M8
          inherited
            foo1=: #M5
            foo2=: #M6
            foo3=: #M7
            foo4=: #M8
''',
    );
  }

  test_manifest_class_setter_modifier_isAbstract() async {
    configuration.withElementManifests = true;
    await _runLibraryManifestScenario(
      initialCode: r'''
abstract class A {
  set foo1(int value) {}
  set foo2(int value);
  set foo3(int value) {}
  set foo4(int value);
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        flags: isAbstract
        supertype: Object @ dart:core
        declaredFields
          foo1: #M1
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo2: #M2
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo3: #M3
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo4: #M4
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
        declaredSetters
          foo1=: #M5
            flags: hasImplicitReturnType isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
          foo2=: #M6
            flags: hasImplicitReturnType isAbstract isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
          foo3=: #M7
            flags: hasImplicitReturnType isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
          foo4=: #M8
            flags: hasImplicitReturnType isAbstract isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
        interface: #M9
          map
            foo1=: #M5
            foo2=: #M6
            foo3=: #M7
            foo4=: #M8
          implemented
            foo1=: #M5
            foo3=: #M7
''',
      updatedCode: r'''
abstract class A {
  set foo1(int value) {}
  set foo2(int value);
  set foo3(int value);
  set foo4(int value) {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        flags: isAbstract
        supertype: Object @ dart:core
        declaredFields
          foo1: #M1
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo2: #M2
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo3: #M3
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo4: #M4
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
        declaredSetters
          foo1=: #M5
            flags: hasImplicitReturnType isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
          foo2=: #M6
            flags: hasImplicitReturnType isAbstract isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
          foo3=: #M10
            flags: hasImplicitReturnType isAbstract isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
          foo4=: #M11
            flags: hasImplicitReturnType isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
        interface: #M12
          map
            foo1=: #M5
            foo2=: #M6
            foo3=: #M10
            foo4=: #M11
          implemented
            foo1=: #M5
            foo4=: #M11
''',
    );
  }

  test_manifest_class_setter_modifier_isExternal() async {
    configuration.withElementManifests = true;
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  set foo1(int value) {}
  external set foo2(int value);
  set foo3(int value) {}
  external set foo4(int value);
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        supertype: Object @ dart:core
        declaredFields
          foo1: #M1
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo2: #M2
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo3: #M3
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo4: #M4
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
        declaredSetters
          foo1=: #M5
            flags: hasImplicitReturnType isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
          foo2=: #M6
            flags: hasImplicitReturnType isExternal isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
          foo3=: #M7
            flags: hasImplicitReturnType isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
          foo4=: #M8
            flags: hasImplicitReturnType isExternal isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
        interface: #M9
          map
            foo1=: #M5
            foo2=: #M6
            foo3=: #M7
            foo4=: #M8
          implemented
            foo1=: #M5
            foo2=: #M6
            foo3=: #M7
            foo4=: #M8
''',
      updatedCode: r'''
class A {
  set foo1(int value) {}
  external set foo2(int value);
  external set foo3(int value);
  set foo4(int value) {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        supertype: Object @ dart:core
        declaredFields
          foo1: #M1
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo2: #M2
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo3: #M3
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo4: #M4
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
        declaredSetters
          foo1=: #M5
            flags: hasImplicitReturnType isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
          foo2=: #M6
            flags: hasImplicitReturnType isExternal isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
          foo3=: #M10
            flags: hasImplicitReturnType isExternal isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
          foo4=: #M11
            flags: hasImplicitReturnType isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
        interface: #M12
          map
            foo1=: #M5
            foo2=: #M6
            foo3=: #M10
            foo4=: #M11
          implemented
            foo1=: #M5
            foo2=: #M6
            foo3=: #M10
            foo4=: #M11
''',
    );
  }

  test_manifest_class_setter_modifier_isStatic() async {
    configuration.withElementManifests = true;
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  set foo1(int value) {}
  static set foo2(int value) {}
  set foo3(int value) {}
  static set foo4(int value) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        supertype: Object @ dart:core
        declaredFields
          foo1: #M1
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo2: #M2
            flags: isStatic isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo3: #M3
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo4: #M4
            flags: isStatic isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
        declaredSetters
          foo1=: #M5
            flags: hasImplicitReturnType isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
          foo2=: #M6
            flags: hasImplicitReturnType isSimplyBounded isStatic
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
          foo3=: #M7
            flags: hasImplicitReturnType isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
          foo4=: #M8
            flags: hasImplicitReturnType isSimplyBounded isStatic
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
        interface: #M9
          map
            foo1=: #M5
            foo3=: #M7
          implemented
            foo1=: #M5
            foo3=: #M7
''',
      updatedCode: r'''
class A {
  set foo1(int value) {}
  static set foo2(int value) {}
  static set foo3(int value) {}
  set foo4(int value) {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        supertype: Object @ dart:core
        declaredFields
          foo1: #M1
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo2: #M2
            flags: isStatic isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo3: #M10
            flags: isStatic isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo4: #M11
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
        declaredSetters
          foo1=: #M5
            flags: hasImplicitReturnType isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
          foo2=: #M6
            flags: hasImplicitReturnType isSimplyBounded isStatic
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
          foo3=: #M12
            flags: hasImplicitReturnType isSimplyBounded isStatic
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
          foo4=: #M13
            flags: hasImplicitReturnType isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
        interface: #M14
          map
            foo1=: #M5
            foo4=: #M13
          implemented
            foo1=: #M5
            foo4=: #M13
''',
    );
  }

  test_manifest_class_setter_private_instance() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  set _foo(int _) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          _foo: #M1
        declaredSetters
          _foo=: #M2
        interface: #M3
''',
      updatedCode: r'''
class A {
  set _foo(int _) {}
  set bar(int _) {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          _foo: #M1
          bar: #M4
        declaredSetters
          _foo=: #M2
          bar=: #M5
        interface: #M6
          map
            bar=: #M5
          implemented
            bar=: #M5
''',
    );
  }

  test_manifest_class_setter_private_static() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  static set _foo(int _) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          _foo: #M1
        declaredSetters
          _foo=: #M2
        interface: #M3
''',
      updatedCode: r'''
class A {
  static set _foo(int _) {}
  set bar(int _) {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          _foo: #M1
          bar: #M4
        declaredSetters
          _foo=: #M2
          bar=: #M5
        interface: #M6
          map
            bar=: #M5
          implemented
            bar=: #M5
''',
    );
  }

  test_manifest_class_setter_static() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  static set foo(int _) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredSetters
          foo=: #M2
        interface: #M3
''',
      updatedCode: r'''
class A {
  static set foo(int _) {}
  static set bar(int _) {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          bar: #M4
          foo: #M1
        declaredSetters
          bar=: #M5
          foo=: #M2
        interface: #M3
''',
    );
  }

  test_manifest_class_setter_static_falseToTrue() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  set foo(int _) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredSetters
          foo=: #M2
        interface: #M3
          map
            foo=: #M2
          implemented
            foo=: #M2
''',
      updatedCode: r'''
class A {
  static set foo(int _) {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M4
        declaredSetters
          foo=: #M5
        interface: #M6
''',
    );
  }

  test_manifest_class_setter_static_trueToFalse() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  static set foo(int _) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredSetters
          foo=: #M2
        interface: #M3
''',
      updatedCode: r'''
class A {
  set foo(int _) {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M4
        declaredSetters
          foo=: #M5
        interface: #M6
          map
            foo=: #M5
          implemented
            foo=: #M5
''',
    );
  }

  test_manifest_class_setter_static_valueType() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  static set foo(int _) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredSetters
          foo=: #M2
        interface: #M3
''',
      updatedCode: r'''
class A {
  static set foo(double _) {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M4
        declaredSetters
          foo=: #M5
        interface: #M3
''',
    );
  }

  test_manifest_class_setter_toDuplicate_hasInstance_addInstance_after() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  set foo(int _) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredSetters
          foo=: #M2
        interface: #M3
          map
            foo=: #M2
          implemented
            foo=: #M2
''',
      updatedCode: r'''
class A {
  set foo(int _) {}
  set foo(double _) {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConflicts
          foo: #M4
          foo=: #M4
        interface: #M5
          map
            foo=: #M4
          implemented
            foo=: #M4
''',
    );
  }

  test_manifest_class_setter_toDuplicate_hasInstance_addInstance_before() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  set foo(int _) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredSetters
          foo=: #M2
        interface: #M3
          map
            foo=: #M2
          implemented
            foo=: #M2
''',
      updatedCode: r'''
class A {
  set foo(double _) {}
  set foo(int _) {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConflicts
          foo: #M4
          foo=: #M4
        interface: #M5
          map
            foo=: #M4
          implemented
            foo=: #M4
''',
    );
  }

  test_manifest_class_setter_toDuplicate_hasInstance_addStatic_after() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  set foo(int _) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredSetters
          foo=: #M2
        interface: #M3
          map
            foo=: #M2
          implemented
            foo=: #M2
''',
      updatedCode: r'''
class A {
  set foo(int _) {}
  static set foo(double _) {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConflicts
          foo: #M4
          foo=: #M4
        interface: #M5
          map
            foo=: #M4
          implemented
            foo=: #M4
''',
    );
  }

  test_manifest_class_setter_toDuplicate_hasInstance_addStatic_before() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  set foo(int _) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredSetters
          foo=: #M2
        interface: #M3
          map
            foo=: #M2
          implemented
            foo=: #M2
''',
      updatedCode: r'''
class A {
  static set foo(double _) {}
  set foo(int _) {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConflicts
          foo: #M4
          foo=: #M4
        interface: #M5
          map
            foo=: #M4
          implemented
            foo=: #M4
''',
    );
  }

  test_manifest_class_setter_toDuplicate_hasStatic_addStatic_after() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  static set foo(int _) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredSetters
          foo=: #M2
        interface: #M3
''',
      updatedCode: r'''
class A {
  static set foo(int _) {}
  static set foo(double _) {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConflicts
          foo: #M4
          foo=: #M4
        interface: #M3
''',
    );
  }

  test_manifest_class_setter_toDuplicate_hasStatic_addStatic_before() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  static set foo(int _) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredSetters
          foo=: #M2
        interface: #M3
''',
      updatedCode: r'''
class A {
  static set foo(double _) {}
  static set foo(int _) {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConflicts
          foo: #M4
          foo=: #M4
        interface: #M3
''',
    );
  }

  test_manifest_class_setter_topMerge() async {
    configuration.withElementManifests = true;
    await _runLibraryManifestScenario(
      initialCode: r'''
abstract class A {
  set foo(List _);
}

abstract class B {
  set foo(List<void> _);
}

abstract class C implements A, B {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        flags: isAbstract
        supertype: Object @ dart:core
        declaredFields
          foo: #M1
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: List @ dart:core
              dynamic
        declaredSetters
          foo=: #M2
            flags: hasImplicitReturnType isAbstract isSimplyBounded
            functionType: FunctionType
              positional
                required List @ dart:core
                  dynamic
              returnType: void
        interface: #M3
          map
            foo=: #M2
      B: #M4
        flags: isAbstract
        supertype: Object @ dart:core
        declaredFields
          foo: #M5
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: List @ dart:core
              void
        declaredSetters
          foo=: #M6
            flags: hasImplicitReturnType isAbstract isSimplyBounded
            functionType: FunctionType
              positional
                required List @ dart:core
                  void
              returnType: void
        interface: #M7
          map
            foo=: #M6
      C: #M8
        flags: isAbstract
        supertype: Object @ dart:core
        interfaces
          A @ package:test/test.dart
          B @ package:test/test.dart
        interface: #M9
          map
            foo=: #M10
          combinedIds
            [#M2, #M6]: #M10
          inherited
            foo=: #M10
''',
      updatedCode: r'''
abstract class A {
  set foo(List _);
}

abstract class B {
  set foo(List<int> _);
}

abstract class C implements A, B {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        flags: isAbstract
        supertype: Object @ dart:core
        declaredFields
          foo: #M1
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: List @ dart:core
              dynamic
        declaredSetters
          foo=: #M2
            flags: hasImplicitReturnType isAbstract isSimplyBounded
            functionType: FunctionType
              positional
                required List @ dart:core
                  dynamic
              returnType: void
        interface: #M3
          map
            foo=: #M2
      B: #M4
        flags: isAbstract
        supertype: Object @ dart:core
        declaredFields
          foo: #M11
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: List @ dart:core
              int @ dart:core
        declaredSetters
          foo=: #M12
            flags: hasImplicitReturnType isAbstract isSimplyBounded
            functionType: FunctionType
              positional
                required List @ dart:core
                  int @ dart:core
              returnType: void
        interface: #M13
          map
            foo=: #M12
      C: #M8
        flags: isAbstract
        supertype: Object @ dart:core
        interfaces
          A @ package:test/test.dart
          B @ package:test/test.dart
        interface: #M14
          map
            foo=: #M15
          combinedIds
            [#M2, #M12]: #M15
          inherited
            foo=: #M2
''',
    );
  }

  test_manifest_class_setter_valueType() async {
    configuration.withElementManifests = true;
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  set foo(int _) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        supertype: Object @ dart:core
        declaredFields
          foo: #M1
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
        declaredSetters
          foo=: #M2
            flags: hasImplicitReturnType isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
        interface: #M3
          map
            foo=: #M2
          implemented
            foo=: #M2
''',
      updatedCode: r'''
class A {
  set foo(double _) {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        supertype: Object @ dart:core
        declaredFields
          foo: #M4
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: double @ dart:core
        declaredSetters
          foo=: #M5
            flags: hasImplicitReturnType isSimplyBounded
            functionType: FunctionType
              positional
                required double @ dart:core
              returnType: void
        interface: #M6
          map
            foo=: #M5
          implemented
            foo=: #M5
''',
    );
  }

  test_manifest_class_typeParameters() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A<T> {
  void foo(T _) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
''',
      updatedCode: r'''
class A<T> {
  void foo(T _) {}
  void bar(T _) {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          bar: #M3
          foo: #M1
        interface: #M4
          map
            bar: #M3
            foo: #M1
          implemented
            bar: #M3
            foo: #M1
''',
    );
  }

  test_manifest_class_typeParameters_add() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A<T> {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        interface: #M1
''',
      updatedCode: r'''
class A<T, U> {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M2
        interface: #M3
''',
    );
  }

  test_manifest_class_typeParameters_bound() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A<T extends num> {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        interface: #M1
''',
      updatedCode: r'''
class A<T extends int> {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M2
        interface: #M3
''',
    );
  }

  test_manifest_class_typeParameters_remove() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A<T, U> {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        interface: #M1
''',
      updatedCode: r'''
class A<T> {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M2
        interface: #M3
''',
    );
  }

  test_manifest_class_typeParameters_variance() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A<in T> {}
class B<out T> {}
class C<in T> {}
class D<out T> {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        interface: #M1
      B: #M2
        interface: #M3
      C: #M4
        interface: #M5
      D: #M6
        interface: #M7
''',
      updatedCode: r'''
class A<in T> {}
class B<out T> {}
class C<out T> {}
class D<in T> {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        interface: #M1
      B: #M2
        interface: #M3
      C: #M8
        interface: #M9
      D: #M10
        interface: #M11
''',
    );
  }

  test_manifest_class_typeParameters_variance_legacyCovariant() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A<T> {}
class B<out T> {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        interface: #M1
      B: #M2
        interface: #M3
''',
      updatedCode: r'''
class A<out T> {}
class B<T> {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        interface: #M1
      B: #M2
        interface: #M3
''',
    );
  }

  test_manifest_classTypeAlias_constructors_add() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  A.c1();
}
mixin M {}
class X = A with M;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConstructors
          c1: #M1
        interface: #M2
      X: #M3
        inheritedConstructors
          c1: #M1
        interface: #M4
    declaredMixins
      M: #M5
        interface: #M6
''',
      updatedCode: r'''
class A {
  A.c1();
  A.c2();
}
mixin M {}
class X = A with M;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConstructors
          c1: #M1
          c2: #M7
        interface: #M2
      X: #M3
        inheritedConstructors
          c1: #M1
          c2: #M7
        interface: #M4
    declaredMixins
      M: #M5
        interface: #M6
''',
    );
  }

  test_manifest_classTypeAlias_constructors_add_chain_backward() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  A.c1();
}
mixin M {}
class X1 = X2 with M;
class X2 = A with M;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConstructors
          c1: #M1
        interface: #M2
      X1: #M3
        inheritedConstructors
          c1: #M1
        interface: #M4
      X2: #M5
        inheritedConstructors
          c1: #M1
        interface: #M6
    declaredMixins
      M: #M7
        interface: #M8
''',
      updatedCode: r'''
class A {
  A.c1();
  A.c2();
}
mixin M {}
class X1 = X2 with M;
class X2 = A with M;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConstructors
          c1: #M1
          c2: #M9
        interface: #M2
      X1: #M3
        inheritedConstructors
          c1: #M1
          c2: #M9
        interface: #M4
      X2: #M5
        inheritedConstructors
          c1: #M1
          c2: #M9
        interface: #M6
    declaredMixins
      M: #M7
        interface: #M8
''',
    );
  }

  test_manifest_classTypeAlias_constructors_add_chain_forward() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  A.c1();
}
mixin M {}
class X1 = A with M;
class X2 = X1 with M;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConstructors
          c1: #M1
        interface: #M2
      X1: #M3
        inheritedConstructors
          c1: #M1
        interface: #M4
      X2: #M5
        inheritedConstructors
          c1: #M1
        interface: #M6
    declaredMixins
      M: #M7
        interface: #M8
''',
      updatedCode: r'''
class A {
  A.c1();
  A.c2();
}
mixin M {}
class X1 = A with M;
class X2 = X1 with M;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConstructors
          c1: #M1
          c2: #M9
        interface: #M2
      X1: #M3
        inheritedConstructors
          c1: #M1
          c2: #M9
        interface: #M4
      X2: #M5
        inheritedConstructors
          c1: #M1
          c2: #M9
        interface: #M6
    declaredMixins
      M: #M7
        interface: #M8
''',
    );
  }

  test_manifest_classTypeAlias_constructors_change() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  A.c1();
  A.c2(int _);
}
mixin M {}
class X = A with M;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConstructors
          c1: #M1
          c2: #M2
        interface: #M3
      X: #M4
        inheritedConstructors
          c1: #M1
          c2: #M2
        interface: #M5
    declaredMixins
      M: #M6
        interface: #M7
''',
      updatedCode: r'''
class A {
  A.c1();
  A.c2(double _);
}
mixin M {}
class X = A with M;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConstructors
          c1: #M1
          c2: #M8
        interface: #M3
      X: #M4
        inheritedConstructors
          c1: #M1
          c2: #M8
        interface: #M5
    declaredMixins
      M: #M6
        interface: #M7
''',
    );
  }

  test_manifest_classTypeAlias_constructors_remove() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  A.c1();
  A.c2();
}
mixin M {}
class X = A with M;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConstructors
          c1: #M1
          c2: #M2
        interface: #M3
      X: #M4
        inheritedConstructors
          c1: #M1
          c2: #M2
        interface: #M5
    declaredMixins
      M: #M6
        interface: #M7
''',
      updatedCode: r'''
class A {
  A.c1();
}
mixin M {}
class X = A with M;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConstructors
          c1: #M1
        interface: #M3
      X: #M4
        inheritedConstructors
          c1: #M1
        interface: #M5
    declaredMixins
      M: #M6
        interface: #M7
''',
    );
  }

  test_manifest_classTypeAlias_extends() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {}
class B {}
mixin M {}
class X = A with M;
class Y = A with M;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        interface: #M1
      B: #M2
        interface: #M3
      X: #M4
        interface: #M5
      Y: #M6
        interface: #M7
    declaredMixins
      M: #M8
        interface: #M9
''',
      updatedCode: r'''
class A {}
class B {}
mixin M {}
class X = A with M;
class Y = B with M;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        interface: #M1
      B: #M2
        interface: #M3
      X: #M4
        interface: #M5
      Y: #M10
        interface: #M11
    declaredMixins
      M: #M8
        interface: #M9
''',
    );
  }

  test_manifest_classTypeAlias_getter() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  int get foo1 => 0;
  int get foo2 => 0;
}

mixin M {
  int get foo3 => 0;
  int get foo4 => 0;
}

class X = A with M;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo1: #M1
          foo2: #M2
        declaredGetters
          foo1: #M3
          foo2: #M4
        interface: #M5
          map
            foo1: #M3
            foo2: #M4
          implemented
            foo1: #M3
            foo2: #M4
      X: #M6
        interface: #M7
          map
            foo1: #M3
            foo2: #M4
            foo3: #M8
            foo4: #M9
          implemented
            foo1: #M3
            foo2: #M4
            foo3: #M8
            foo4: #M9
          superImplemented
            [0]
              foo1: #M3
              foo2: #M4
            [1]
              foo1: #M3
              foo2: #M4
              foo3: #M8
              foo4: #M9
          inherited
            foo1: #M3
            foo2: #M4
            foo3: #M8
            foo4: #M9
    declaredMixins
      M: #M10
        declaredFields
          foo3: #M11
          foo4: #M12
        declaredGetters
          foo3: #M8
          foo4: #M9
        interface: #M13
          map
            foo3: #M8
            foo4: #M9
          implemented
            foo3: #M8
            foo4: #M9
''',
      updatedCode: r'''
class A {
  int get foo1 => 0;
  double get foo2 => 0;
}

mixin M {
  int get foo3 => 0;
  double get foo4 => 0;
}

class X = A with M;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo1: #M1
          foo2: #M14
        declaredGetters
          foo1: #M3
          foo2: #M15
        interface: #M16
          map
            foo1: #M3
            foo2: #M15
          implemented
            foo1: #M3
            foo2: #M15
      X: #M6
        interface: #M17
          map
            foo1: #M3
            foo2: #M15
            foo3: #M8
            foo4: #M18
          implemented
            foo1: #M3
            foo2: #M15
            foo3: #M8
            foo4: #M18
          superImplemented
            [0]
              foo1: #M3
              foo2: #M15
            [1]
              foo1: #M3
              foo2: #M15
              foo3: #M8
              foo4: #M18
          inherited
            foo1: #M3
            foo2: #M15
            foo3: #M8
            foo4: #M18
    declaredMixins
      M: #M10
        declaredFields
          foo3: #M11
          foo4: #M19
        declaredGetters
          foo3: #M8
          foo4: #M18
        interface: #M20
          map
            foo3: #M8
            foo4: #M18
          implemented
            foo3: #M8
            foo4: #M18
''',
    );
  }

  test_manifest_classTypeAlias_interfaces() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {}
mixin M {}
class X1 = Object with M;
class X2 = Object with M implements A;
class X3 = Object with M;
class X4 = Object with M implements A;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        interface: #M1
      X1: #M2
        interface: #M3
      X2: #M4
        interface: #M5
      X3: #M6
        interface: #M7
      X4: #M8
        interface: #M9
    declaredMixins
      M: #M10
        interface: #M11
''',
      updatedCode: r'''
class A {}
mixin M {}
class X1 = Object with M;
class X2 = Object with M implements A;
class X3 = Object with M implements A;
class X4 = Object with M;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        interface: #M1
      X1: #M2
        interface: #M3
      X2: #M4
        interface: #M5
      X3: #M12
        interface: #M13
      X4: #M14
        interface: #M15
    declaredMixins
      M: #M10
        interface: #M11
''',
    );
  }

  test_manifest_classTypeAlias_metadata() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
mixin M {}
@Deprecated('0')
class X = Object with M;
@Deprecated('0')
class Y = Object with M;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      X: #M0
        interface: #M1
      Y: #M2
        interface: #M3
    declaredMixins
      M: #M4
        interface: #M5
''',
      updatedCode: r'''
mixin M {}
@Deprecated('0')
class X = Object with M;
@Deprecated('1')
class Y = Object with M;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      X: #M0
        interface: #M1
      Y: #M6
        interface: #M7
    declaredMixins
      M: #M4
        interface: #M5
''',
    );
  }

  test_manifest_classTypeAlias_method() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  void foo1(int _) {}
  void foo2(int _) {}
}

mixin M {
  void foo3(int _) {}
  void foo4(int _) {}
}

class X = A with M;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo1: #M1
          foo2: #M2
        interface: #M3
          map
            foo1: #M1
            foo2: #M2
          implemented
            foo1: #M1
            foo2: #M2
      X: #M4
        interface: #M5
          map
            foo1: #M1
            foo2: #M2
            foo3: #M6
            foo4: #M7
          implemented
            foo1: #M1
            foo2: #M2
            foo3: #M6
            foo4: #M7
          superImplemented
            [0]
              foo1: #M1
              foo2: #M2
            [1]
              foo1: #M1
              foo2: #M2
              foo3: #M6
              foo4: #M7
          inherited
            foo1: #M1
            foo2: #M2
            foo3: #M6
            foo4: #M7
    declaredMixins
      M: #M8
        declaredMethods
          foo3: #M6
          foo4: #M7
        interface: #M9
          map
            foo3: #M6
            foo4: #M7
          implemented
            foo3: #M6
            foo4: #M7
''',
      updatedCode: r'''
class A {
  void foo1(int _) {}
  void foo2(double _) {}
}

mixin M {
  void foo3(int _) {}
  void foo4(double _) {}
}

class X = A with M;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo1: #M1
          foo2: #M10
        interface: #M11
          map
            foo1: #M1
            foo2: #M10
          implemented
            foo1: #M1
            foo2: #M10
      X: #M4
        interface: #M12
          map
            foo1: #M1
            foo2: #M10
            foo3: #M6
            foo4: #M13
          implemented
            foo1: #M1
            foo2: #M10
            foo3: #M6
            foo4: #M13
          superImplemented
            [0]
              foo1: #M1
              foo2: #M10
            [1]
              foo1: #M1
              foo2: #M10
              foo3: #M6
              foo4: #M13
          inherited
            foo1: #M1
            foo2: #M10
            foo3: #M6
            foo4: #M13
    declaredMixins
      M: #M8
        declaredMethods
          foo3: #M6
          foo4: #M13
        interface: #M14
          map
            foo3: #M6
            foo4: #M13
          implemented
            foo3: #M6
            foo4: #M13
''',
    );
  }

  test_manifest_classTypeAlias_setter() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  set foo1(int _) {}
  set foo2(int _) {}
}

mixin M {
  set foo3(int _) {}
  set foo4(int _) {}
}

class X = A with M;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo1: #M1
          foo2: #M2
        declaredSetters
          foo1=: #M3
          foo2=: #M4
        interface: #M5
          map
            foo1=: #M3
            foo2=: #M4
          implemented
            foo1=: #M3
            foo2=: #M4
      X: #M6
        interface: #M7
          map
            foo1=: #M3
            foo2=: #M4
            foo3=: #M8
            foo4=: #M9
          implemented
            foo1=: #M3
            foo2=: #M4
            foo3=: #M8
            foo4=: #M9
          superImplemented
            [0]
              foo1=: #M3
              foo2=: #M4
            [1]
              foo1=: #M3
              foo2=: #M4
              foo3=: #M8
              foo4=: #M9
          inherited
            foo1=: #M3
            foo2=: #M4
            foo3=: #M8
            foo4=: #M9
    declaredMixins
      M: #M10
        declaredFields
          foo3: #M11
          foo4: #M12
        declaredSetters
          foo3=: #M8
          foo4=: #M9
        interface: #M13
          map
            foo3=: #M8
            foo4=: #M9
          implemented
            foo3=: #M8
            foo4=: #M9
''',
      updatedCode: r'''
class A {
  set foo1(int _) {}
  set foo2(double _) {}
}

mixin M {
  set foo3(int _) {}
  set foo4(double _) {}
}

class X = A with M;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo1: #M1
          foo2: #M14
        declaredSetters
          foo1=: #M3
          foo2=: #M15
        interface: #M16
          map
            foo1=: #M3
            foo2=: #M15
          implemented
            foo1=: #M3
            foo2=: #M15
      X: #M6
        interface: #M17
          map
            foo1=: #M3
            foo2=: #M15
            foo3=: #M8
            foo4=: #M18
          implemented
            foo1=: #M3
            foo2=: #M15
            foo3=: #M8
            foo4=: #M18
          superImplemented
            [0]
              foo1=: #M3
              foo2=: #M15
            [1]
              foo1=: #M3
              foo2=: #M15
              foo3=: #M8
              foo4=: #M18
          inherited
            foo1=: #M3
            foo2=: #M15
            foo3=: #M8
            foo4=: #M18
    declaredMixins
      M: #M10
        declaredFields
          foo3: #M11
          foo4: #M19
        declaredSetters
          foo3=: #M8
          foo4=: #M18
        interface: #M20
          map
            foo3=: #M8
            foo4=: #M18
          implemented
            foo3=: #M8
            foo4=: #M18
''',
    );
  }

  test_manifest_constInitializer_adjacentStrings() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
const a = 0;
const b = 0;
const c = '$a' 'x';
const d = 'x' '$a';
const e = '$b' 'x';
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
      b: #M1
      c: #M2
      d: #M3
      e: #M4
    declaredVariables
      a: #M5
      b: #M6
      c: #M7
      d: #M8
      e: #M9
''',
      updatedCode: r'''
const a = 1;
const b = 0;
const c = '$a' 'x';
const d = 'x' '$a';
const e = '$b' 'x';
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
      b: #M1
      c: #M2
      d: #M3
      e: #M4
    declaredVariables
      a: #M10
      b: #M6
      c: #M11
      d: #M12
      e: #M9
''',
    );
  }

  test_manifest_constInitializer_asExpression() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
const a = 0;
const b = 0;
const c = a as int;
const d = b as int;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
      b: #M1
      c: #M2
      d: #M3
    declaredVariables
      a: #M4
      b: #M5
      c: #M6
      d: #M7
''',
      updatedCode: r'''
const a = 0;
const b = 1;
const c = a as int;
const d = b as int;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
      b: #M1
      c: #M2
      d: #M3
    declaredVariables
      a: #M4
      b: #M8
      c: #M6
      d: #M9
''',
    );
  }

  test_manifest_constInitializer_binaryExpression() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
const a = 0 + 1;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
    declaredVariables
      a: #M1
''',
      updatedCode: r'''
const a = 0 + 1;
const b = 0;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
      b: #M2
    declaredVariables
      a: #M1
      b: #M3
''',
    );
  }

  test_manifest_constInitializer_binaryExpression_left_change() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
const a = 0;
const b = a + 2;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
      b: #M1
    declaredVariables
      a: #M2
      b: #M3
''',
      updatedCode: r'''
const a = 1;
const b = a + 2;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
      b: #M1
    declaredVariables
      a: #M4
      b: #M5
''',
    );
  }

  test_manifest_constInitializer_binaryExpression_left_token() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
const a = 0 + 1;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
    declaredVariables
      a: #M1
''',
      updatedCode: r'''
const a = 2 + 1;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
    declaredVariables
      a: #M2
''',
    );
  }

  test_manifest_constInitializer_binaryExpression_operator() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  const A();
  int operator+(_) {}
}
const a = A();
const x = a + 1;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          +: #M1
        interface: #M2
          map
            +: #M1
          implemented
            +: #M1
    declaredGetters
      a: #M3
      x: #M4
    declaredVariables
      a: #M5
      x: #M6
''',
      updatedCode: r'''
class A {
  const A();
  double operator+(_) {}
}
const a = A();
const x = a + 1;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          +: #M7
        interface: #M8
          map
            +: #M7
          implemented
            +: #M7
    declaredGetters
      a: #M3
      x: #M9
    declaredVariables
      a: #M5
      x: #M10
''',
    );
  }

  test_manifest_constInitializer_binaryExpression_operator_token() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
const a = 0 + 1;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
    declaredVariables
      a: #M1
''',
      updatedCode: r'''
const a = 0 - 1;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
    declaredVariables
      a: #M2
''',
    );
  }

  test_manifest_constInitializer_binaryExpression_right() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
const a = 0;
const b = 2 + a;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
      b: #M1
    declaredVariables
      a: #M2
      b: #M3
''',
      updatedCode: r'''
const a = 1;
const b = 2 + a;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
      b: #M1
    declaredVariables
      a: #M4
      b: #M5
''',
    );
  }

  test_manifest_constInitializer_binaryExpression_right_add() async {
    configuration.withElementManifests = true;
    await _runLibraryManifestScenario(
      initialCode: r'''
const b = 0 + a;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      b: #M0
        flags: isSimplyBounded isStatic isSynthetic
        returnType: double @ dart:core
    declaredVariables
      b: #M1
        flags: hasImplicitType hasInitializer isConst isStatic
        type: double @ dart:core
        constInitializer
          tokenBuffer: 0+a
          tokenLengthList: [1, 1, 1]
          elements
            [0] (dart:core, instanceMethod, num, +) #M2
          elementIndexList
            0 = null
            6 = element 0
''',
      updatedCode: r'''
const a = 1;
const b = 0 + a;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M3
        flags: isSimplyBounded isStatic isSynthetic
        returnType: int @ dart:core
      b: #M4
        flags: isSimplyBounded isStatic isSynthetic
        returnType: int @ dart:core
    declaredVariables
      a: #M5
        flags: hasImplicitType hasInitializer isConst isStatic
        type: int @ dart:core
        constInitializer
          tokenBuffer: 1
          tokenLengthList: [1]
      b: #M6
        flags: hasImplicitType hasInitializer isConst isStatic
        type: int @ dart:core
        constInitializer
          tokenBuffer: 0+a
          tokenLengthList: [1, 1, 1]
          elements
            [0] (package:test/test.dart, topLevelGetter, a) <null>
            [1] (package:test/test.dart, topLevelVariable, a) <null>
            [2] (dart:core, instanceMethod, num, +) #M2
          elementIndexList
            6 = element 0
            22 = element 1
            38 = element 2
''',
    );
  }

  test_manifest_constInitializer_binaryExpression_right_remove() async {
    configuration.withElementManifests = true;
    await _runLibraryManifestScenario(
      initialCode: r'''
const a = 0;
const b = 1 + a;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
        flags: isSimplyBounded isStatic isSynthetic
        returnType: int @ dart:core
      b: #M1
        flags: isSimplyBounded isStatic isSynthetic
        returnType: int @ dart:core
    declaredVariables
      a: #M2
        flags: hasImplicitType hasInitializer isConst isStatic
        type: int @ dart:core
        constInitializer
          tokenBuffer: 0
          tokenLengthList: [1]
      b: #M3
        flags: hasImplicitType hasInitializer isConst isStatic
        type: int @ dart:core
        constInitializer
          tokenBuffer: 1+a
          tokenLengthList: [1, 1, 1]
          elements
            [0] (package:test/test.dart, topLevelGetter, a) <null>
            [1] (package:test/test.dart, topLevelVariable, a) <null>
            [2] (dart:core, instanceMethod, num, +) #M4
          elementIndexList
            6 = element 0
            22 = element 1
            38 = element 2
''',
      updatedCode: r'''
const b = 1 + a;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      b: #M5
        flags: isSimplyBounded isStatic isSynthetic
        returnType: double @ dart:core
    declaredVariables
      b: #M6
        flags: hasImplicitType hasInitializer isConst isStatic
        type: double @ dart:core
        constInitializer
          tokenBuffer: 1+a
          tokenLengthList: [1, 1, 1]
          elements
            [0] (dart:core, instanceMethod, num, +) #M4
          elementIndexList
            0 = null
            6 = element 0
''',
    );
  }

  test_manifest_constInitializer_boolLiteral() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
const a = true;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
    declaredVariables
      a: #M1
''',
      updatedCode: r'''
const a = true;
const b = false;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
      b: #M2
    declaredVariables
      a: #M1
      b: #M3
''',
    );
  }

  test_manifest_constInitializer_cascadeExpression() async {
    configuration.withElementManifests = true;
    await _runLibraryManifestScenario(
      initialCode: r'''
const a = 0..abs();
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
        flags: isSimplyBounded isStatic isSynthetic
        returnType: int @ dart:core
    declaredVariables
      a: #M1
        flags: hasImplicitType hasInitializer isConst isStatic
        type: int @ dart:core
        constInitializer
          isValid: false
''',
      updatedCode: r'''
const a = 0..abs();
const b = 0;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
        flags: isSimplyBounded isStatic isSynthetic
        returnType: int @ dart:core
      b: #M2
        flags: isSimplyBounded isStatic isSynthetic
        returnType: int @ dart:core
    declaredVariables
      a: #M3
        flags: hasImplicitType hasInitializer isConst isStatic
        type: int @ dart:core
        constInitializer
          isValid: false
      b: #M4
        flags: hasImplicitType hasInitializer isConst isStatic
        type: int @ dart:core
        constInitializer
          tokenBuffer: 0
          tokenLengthList: [1]
''',
    );
  }

  test_manifest_constInitializer_conditionalExpression() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
const a = true;
const b = true;
const c = a ? 0 : 1;
const d = b ? 0 : 1;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
      b: #M1
      c: #M2
      d: #M3
    declaredVariables
      a: #M4
      b: #M5
      c: #M6
      d: #M7
''',
      updatedCode: r'''
const a = true;
const b = false;
const c = a ? 0 : 1;
const d = b ? 0 : 1;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
      b: #M1
      c: #M2
      d: #M3
    declaredVariables
      a: #M4
      b: #M8
      c: #M6
      d: #M9
''',
    );
  }

  test_manifest_constInitializer_constructorName_named() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  A.named();
}
const a = A.named();
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConstructors
          named: #M1
        interface: #M2
    declaredGetters
      a: #M3
    declaredVariables
      a: #M4
''',
      updatedCode: r'''
class A {
  A.named(int _);
}
const a = A.named();
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConstructors
          named: #M5
        interface: #M2
    declaredGetters
      a: #M3
    declaredVariables
      a: #M6
''',
    );
  }

  test_manifest_constInitializer_constructorName_unnamed() async {
    configuration.includeDefaultConstructors();
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  A();
}
const a = A();
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConstructors
          new: #M1
        interface: #M2
    declaredGetters
      a: #M3
    declaredVariables
      a: #M4
''',
      updatedCode: r'''
class A {
  A(int _);
}
const a = A();
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConstructors
          new: #M5
        interface: #M2
    declaredGetters
      a: #M3
    declaredVariables
      a: #M6
''',
    );
  }

  test_manifest_constInitializer_constructorName_unnamed_notAffected() async {
    configuration.includeDefaultConstructors();
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  A();
}
const a = A();
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredConstructors
          new: #M1
        interface: #M2
    declaredGetters
      a: #M3
    declaredVariables
      a: #M4
''',
      updatedCode: r'''
class A {
  A();
  void foo() {}
}
const a = A();
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M5
        declaredConstructors
          new: #M1
        interface: #M6
          map
            foo: #M5
          implemented
            foo: #M5
    declaredGetters
      a: #M3
    declaredVariables
      a: #M4
''',
    );
  }

  test_manifest_constInitializer_dynamicElement() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
const a = 0 as dynamic;
const b = 0 as dynamic;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
      b: #M1
    declaredVariables
      a: #M2
      b: #M3
''',
      updatedCode: r'''
const a = 0 as dynamic;
const b = 0 as int;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
      b: #M4
    declaredVariables
      a: #M2
      b: #M5
''',
    );
  }

  test_manifest_constInitializer_identifier_addIdentifier() async {
    configuration.withElementManifests = true;
    await _runLibraryManifestScenario(
      initialCode: r'''
@foo
class A {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        metadata
          [0]
            tokenBuffer: @foo
            tokenLengthList: [1, 3]
            elementIndexList
              0 = null
              0 = null
        supertype: Object @ dart:core
        interface: #M1
''',
      updatedCode: r'''
@foo.bar
class A {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M2
        metadata
          [0]
            tokenBuffer: @foo.bar
            tokenLengthList: [1, 3, 1, 3]
            elementIndexList
              0 = null
              0 = null
              0 = null
        supertype: Object @ dart:core
        interface: #M3
''',
    );
  }

  test_manifest_constInitializer_identifierIdentifier_removeIdentifier() async {
    configuration.withElementManifests = true;
    await _runLibraryManifestScenario(
      initialCode: r'''
@foo.bar
class A {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        metadata
          [0]
            tokenBuffer: @foo.bar
            tokenLengthList: [1, 3, 1, 3]
            elementIndexList
              0 = null
              0 = null
              0 = null
        supertype: Object @ dart:core
        interface: #M1
''',
      updatedCode: r'''
@foo
class A {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M2
        metadata
          [0]
            tokenBuffer: @foo
            tokenLengthList: [1, 3]
            elementIndexList
              0 = null
              0 = null
        supertype: Object @ dart:core
        interface: #M3
''',
    );
  }

  test_manifest_constInitializer_importPrefixReference() async {
    configuration.withElementManifests = true;
    await _runLibraryManifestScenario(
      initialCode: r'''
import 'dart:core' as core;
const a = 0 as core.int;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
        flags: isSimplyBounded isStatic isSynthetic
        returnType: int @ dart:core
    declaredVariables
      a: #M1
        flags: hasImplicitType hasInitializer isConst isStatic
        type: int @ dart:core
        constInitializer
          tokenBuffer: 0ascore.int
          tokenLengthList: [1, 2, 4, 1, 3]
          elements
            [0] (dart:core, class_, int) #M2
          elementIndexList
            3 = importPrefix
            6 = element 0
''',
      updatedCode: r'''
import 'dart:core' as core;
const a = 0 as core.int;
const b = 0;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
        flags: isSimplyBounded isStatic isSynthetic
        returnType: int @ dart:core
      b: #M3
        flags: isSimplyBounded isStatic isSynthetic
        returnType: int @ dart:core
    declaredVariables
      a: #M1
        flags: hasImplicitType hasInitializer isConst isStatic
        type: int @ dart:core
        constInitializer
          tokenBuffer: 0ascore.int
          tokenLengthList: [1, 2, 4, 1, 3]
          elements
            [0] (dart:core, class_, int) #M2
          elementIndexList
            3 = importPrefix
            6 = element 0
      b: #M4
        flags: hasImplicitType hasInitializer isConst isStatic
        type: int @ dart:core
        constInitializer
          tokenBuffer: 0
          tokenLengthList: [1]
''',
    );
  }

  test_manifest_constInitializer_indexExpression() async {
    configuration.withElementManifests = true;
    await _runLibraryManifestScenario(
      initialCode: r'''
const a = [0][0];
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
        flags: isSimplyBounded isStatic isSynthetic
        returnType: int @ dart:core
    declaredVariables
      a: #M1
        flags: hasImplicitType hasInitializer isConst isStatic
        type: int @ dart:core
        constInitializer
          isValid: false
''',
      updatedCode: r'''
const a = [0][0];
const b = 0;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
        flags: isSimplyBounded isStatic isSynthetic
        returnType: int @ dart:core
      b: #M2
        flags: isSimplyBounded isStatic isSynthetic
        returnType: int @ dart:core
    declaredVariables
      a: #M3
        flags: hasImplicitType hasInitializer isConst isStatic
        type: int @ dart:core
        constInitializer
          isValid: false
      b: #M4
        flags: hasImplicitType hasInitializer isConst isStatic
        type: int @ dart:core
        constInitializer
          tokenBuffer: 0
          tokenLengthList: [1]
''',
    );
  }

  test_manifest_constInitializer_instanceCreation_argument() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  A(_);
}
const a = 0;
const b = 0;
const c = A(a);
const d = A(b);
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        interface: #M1
    declaredGetters
      a: #M2
      b: #M3
      c: #M4
      d: #M5
    declaredVariables
      a: #M6
      b: #M7
      c: #M8
      d: #M9
''',
      updatedCode: r'''
class A {
  A(_);
}
const a = 1;
const b = 0;
const c = A(a);
const d = A(b);
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        interface: #M1
    declaredGetters
      a: #M2
      b: #M3
      c: #M4
      d: #M5
    declaredVariables
      a: #M10
      b: #M7
      c: #M11
      d: #M9
''',
    );
  }

  test_manifest_constInitializer_integerLiteral() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
const a = 0;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
    declaredVariables
      a: #M1
''',
      updatedCode: r'''
const a = 0;
const b = 1;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
      b: #M2
    declaredVariables
      a: #M1
      b: #M3
''',
    );
  }

  test_manifest_constInitializer_integerLiteral_value() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
const a = 0;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
    declaredVariables
      a: #M1
''',
      updatedCode: r'''
const a = 1;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
    declaredVariables
      a: #M2
''',
    );
  }

  test_manifest_constInitializer_listLiteral() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
const a = 0;
const b = 0;
const c = [a];
const d = [b];
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
      b: #M1
      c: #M2
      d: #M3
    declaredVariables
      a: #M4
      b: #M5
      c: #M6
      d: #M7
''',
      updatedCode: r'''
const a = 1;
const b = 0;
const c = [a];
const d = [b];
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
      b: #M1
      c: #M2
      d: #M3
    declaredVariables
      a: #M8
      b: #M5
      c: #M9
      d: #M7
''',
    );
  }

  test_manifest_constInitializer_mapLiteral_key() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
const a = 0;
const b = 0;
const c = {a: 0};
const d = {b: 0};
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
      b: #M1
      c: #M2
      d: #M3
    declaredVariables
      a: #M4
      b: #M5
      c: #M6
      d: #M7
''',
      updatedCode: r'''
const a = 1;
const b = 0;
const c = {a: 0};
const d = {b: 0};
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
      b: #M1
      c: #M2
      d: #M3
    declaredVariables
      a: #M8
      b: #M5
      c: #M9
      d: #M7
''',
    );
  }

  test_manifest_constInitializer_mapLiteral_value() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
const a = 0;
const b = 0;
const c = {0: a};
const d = {0: b};
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
      b: #M1
      c: #M2
      d: #M3
    declaredVariables
      a: #M4
      b: #M5
      c: #M6
      d: #M7
''',
      updatedCode: r'''
const a = 1;
const b = 0;
const c = {0: a};
const d = {0: b};
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
      b: #M1
      c: #M2
      d: #M3
    declaredVariables
      a: #M8
      b: #M5
      c: #M9
      d: #M7
''',
    );
  }

  test_manifest_constInitializer_methodInvocation_custom() async {
    configuration.withElementManifests = true;
    await _runLibraryManifestScenario(
      initialCode: r'''
const a = 0.abs();
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
        flags: isSimplyBounded isStatic isSynthetic
        returnType: int @ dart:core
    declaredVariables
      a: #M1
        flags: hasImplicitType hasInitializer isConst isStatic
        type: int @ dart:core
        constInitializer
          isValid: false
''',
      updatedCode: r'''
const a = 0.abs();
const b = 0;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
        flags: isSimplyBounded isStatic isSynthetic
        returnType: int @ dart:core
      b: #M2
        flags: isSimplyBounded isStatic isSynthetic
        returnType: int @ dart:core
    declaredVariables
      a: #M3
        flags: hasImplicitType hasInitializer isConst isStatic
        type: int @ dart:core
        constInitializer
          isValid: false
      b: #M4
        flags: hasImplicitType hasInitializer isConst isStatic
        type: int @ dart:core
        constInitializer
          tokenBuffer: 0
          tokenLengthList: [1]
''',
    );
  }

  test_manifest_constInitializer_methodInvocation_identical() async {
    configuration.withElementManifests = true;
    await _runLibraryManifestScenario(
      initialCode: r'''
const a = identical(0, 1);
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
        flags: isSimplyBounded isStatic isSynthetic
        returnType: bool @ dart:core
    declaredVariables
      a: #M1
        flags: hasImplicitType hasInitializer isConst isStatic
        type: bool @ dart:core
        constInitializer
          tokenBuffer: identical(0,1)
          tokenLengthList: [9, 1, 1, 1, 1, 1]
          elements
            [0] (dart:core, topLevelFunction, identical) #M2
          elementIndexList
            6 = element 0
''',
      updatedCode: r'''
const a = identical(0, 1);
const b = 0;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
        flags: isSimplyBounded isStatic isSynthetic
        returnType: bool @ dart:core
      b: #M3
        flags: isSimplyBounded isStatic isSynthetic
        returnType: int @ dart:core
    declaredVariables
      a: #M1
        flags: hasImplicitType hasInitializer isConst isStatic
        type: bool @ dart:core
        constInitializer
          tokenBuffer: identical(0,1)
          tokenLengthList: [9, 1, 1, 1, 1, 1]
          elements
            [0] (dart:core, topLevelFunction, identical) #M2
          elementIndexList
            6 = element 0
      b: #M4
        flags: hasImplicitType hasInitializer isConst isStatic
        type: int @ dart:core
        constInitializer
          tokenBuffer: 0
          tokenLengthList: [1]
''',
    );
  }

  test_manifest_constInitializer_multiplyDefinedElement() async {
    newFile('$testPackageLibPath/a.dart', r'''
const foo = 0;
''');

    newFile('$testPackageLibPath/b.dart', r'''
const foo = 0;
''');

    configuration.withElementManifests = true;
    await _runLibraryManifestScenario(
      initialCode: r'''
import 'a.dart';
import 'b.dart';
const x = foo;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredGetters
      foo: #M0
        flags: isSimplyBounded isStatic isSynthetic
        returnType: int @ dart:core
    declaredVariables
      foo: #M1
        flags: hasImplicitType hasInitializer isConst isStatic
        type: int @ dart:core
        constInitializer
          tokenBuffer: 0
          tokenLengthList: [1]
[operation] linkLibraryCycle
  package:test/b.dart
    declaredGetters
      foo: #M2
        flags: isSimplyBounded isStatic isSynthetic
        returnType: int @ dart:core
    declaredVariables
      foo: #M3
        flags: hasImplicitType hasInitializer isConst isStatic
        type: int @ dart:core
        constInitializer
          tokenBuffer: 0
          tokenLengthList: [1]
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      x: #M4
        flags: isSimplyBounded isStatic isSynthetic
        returnType: InvalidType
    declaredVariables
      x: #M5
        flags: hasImplicitType hasInitializer isConst isStatic
        type: InvalidType
        constInitializer
          tokenBuffer: foo
          tokenLengthList: [3]
          elementIndexList
            7 = multiplyDefined
''',
      updatedCode: r'''
import 'a.dart';
import 'b.dart';
const x = foo;
class A {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M6
        supertype: Object @ dart:core
        interface: #M7
    declaredGetters
      x: #M4
        flags: isSimplyBounded isStatic isSynthetic
        returnType: InvalidType
    declaredVariables
      x: #M5
        flags: hasImplicitType hasInitializer isConst isStatic
        type: InvalidType
        constInitializer
          tokenBuffer: foo
          tokenLengthList: [3]
          elementIndexList
            7 = multiplyDefined
''',
    );
  }

  test_manifest_constInitializer_namedType() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {}
class B {}
const a = A;
const b = B;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        interface: #M1
      B: #M2
        interface: #M3
    declaredGetters
      a: #M4
      b: #M5
    declaredVariables
      a: #M6
      b: #M7
''',
      updatedCode: r'''
class A {}
class B extends A {}
const a = A;
const b = B;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        interface: #M1
      B: #M8
        interface: #M9
    declaredGetters
      a: #M4
      b: #M5
    declaredVariables
      a: #M6
      b: #M10
''',
    );
  }

  test_manifest_constInitializer_neverType() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
const a = <Never>[];
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
    declaredVariables
      a: #M1
''',
      updatedCode: r'''
const a = <Never>[];
const b = 0;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
      b: #M2
    declaredVariables
      a: #M1
      b: #M3
''',
    );
  }

  test_manifest_constInitializer_postfixExpression_increment() async {
    configuration.withElementManifests = true;
    await _runLibraryManifestScenario(
      initialCode: r'''
const a = 0;
const b = a++;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
        flags: isSimplyBounded isStatic isSynthetic
        returnType: int @ dart:core
      b: #M1
        flags: isSimplyBounded isStatic isSynthetic
        returnType: int @ dart:core
    declaredVariables
      a: #M2
        flags: hasImplicitType hasInitializer isConst isStatic
        type: int @ dart:core
        constInitializer
          tokenBuffer: 0
          tokenLengthList: [1]
      b: #M3
        flags: hasImplicitType hasInitializer isConst isStatic
        type: int @ dart:core
        constInitializer
          isValid: false
''',
      updatedCode: r'''
const a = 0;
const b = a++;
const c = 0;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
        flags: isSimplyBounded isStatic isSynthetic
        returnType: int @ dart:core
      b: #M1
        flags: isSimplyBounded isStatic isSynthetic
        returnType: int @ dart:core
      c: #M4
        flags: isSimplyBounded isStatic isSynthetic
        returnType: int @ dart:core
    declaredVariables
      a: #M2
        flags: hasImplicitType hasInitializer isConst isStatic
        type: int @ dart:core
        constInitializer
          tokenBuffer: 0
          tokenLengthList: [1]
      b: #M5
        flags: hasImplicitType hasInitializer isConst isStatic
        type: int @ dart:core
        constInitializer
          isValid: false
      c: #M6
        flags: hasImplicitType hasInitializer isConst isStatic
        type: int @ dart:core
        constInitializer
          tokenBuffer: 0
          tokenLengthList: [1]
''',
    );
  }

  test_manifest_constInitializer_postfixExpression_nullAssert() async {
    configuration.withElementManifests = true;
    await _runLibraryManifestScenario(
      initialCode: r'''
const a = 0!;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
        flags: isSimplyBounded isStatic isSynthetic
        returnType: int @ dart:core
    declaredVariables
      a: #M1
        flags: hasImplicitType hasInitializer isConst isStatic
        type: int @ dart:core
        constInitializer
          isValid: false
''',
      updatedCode: r'''
const a = 0!;
const b = 0;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
        flags: isSimplyBounded isStatic isSynthetic
        returnType: int @ dart:core
      b: #M2
        flags: isSimplyBounded isStatic isSynthetic
        returnType: int @ dart:core
    declaredVariables
      a: #M3
        flags: hasImplicitType hasInitializer isConst isStatic
        type: int @ dart:core
        constInitializer
          isValid: false
      b: #M4
        flags: hasImplicitType hasInitializer isConst isStatic
        type: int @ dart:core
        constInitializer
          tokenBuffer: 0
          tokenLengthList: [1]
''',
    );
  }

  test_manifest_constInitializer_prefixedIdentifier_className_fieldName() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  static const a = 0;
  static const b = 0;
}

const c = A.a;
const d = A.b;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          a: #M1
          b: #M2
        declaredGetters
          a: #M3
          b: #M4
        interface: #M5
    declaredGetters
      c: #M6
      d: #M7
    declaredVariables
      c: #M8
      d: #M9
''',
      updatedCode: r'''
class A {
  static const a = 0;
  static const b = 1;
}

const c = A.a;
const d = A.b;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          a: #M1
          b: #M10
        declaredGetters
          a: #M3
          b: #M4
        interface: #M5
    declaredGetters
      c: #M6
      d: #M7
    declaredVariables
      c: #M8
      d: #M11
''',
    );
  }

  test_manifest_constInitializer_prefixedIdentifier_extensionName_fieldName() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
extension A on Object {
  static const a = 0;
  static const b = 0;
}

const c = A.a;
const d = A.b;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredExtensions
      A: #M0
        declaredFields
          a: #M1
          b: #M2
        declaredGetters
          a: #M3
          b: #M4
    declaredGetters
      c: #M5
      d: #M6
    declaredVariables
      c: #M7
      d: #M8
    exportedExtensions: #M0
''',
      updatedCode: r'''
extension A on Object {
  static const a = 0;
  static const b = 1;
}

const c = A.a;
const d = A.b;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredExtensions
      A: #M0
        declaredFields
          a: #M1
          b: #M9
        declaredGetters
          a: #M3
          b: #M4
    declaredGetters
      c: #M5
      d: #M6
    declaredVariables
      c: #M7
      d: #M10
    exportedExtensions: #M0
''',
    );
  }

  test_manifest_constInitializer_prefixedIdentifier_importPrefix_className_fieldName() async {
    var a = newFile('$testPackageLibPath/a.dart', r'''
class A {
  static const a = 0;
  static const b = 0;
}
''');

    configuration.withElementManifests = true;
    await _runLibraryManifestScenario(
      initialCode: r'''
import 'a.dart' as prefix;

const c = prefix.A.a;
const d = prefix.A.b;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        supertype: Object @ dart:core
        declaredFields
          a: #M1
            flags: hasImplicitType hasInitializer isConst isStatic
            type: int @ dart:core
            constInitializer
              tokenBuffer: 0
              tokenLengthList: [1]
          b: #M2
            flags: hasImplicitType hasInitializer isConst isStatic
            type: int @ dart:core
            constInitializer
              tokenBuffer: 0
              tokenLengthList: [1]
        declaredGetters
          a: #M3
            flags: isSimplyBounded isStatic isSynthetic
            returnType: int @ dart:core
          b: #M4
            flags: isSimplyBounded isStatic isSynthetic
            returnType: int @ dart:core
        interface: #M5
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      c: #M6
        flags: isSimplyBounded isStatic isSynthetic
        returnType: int @ dart:core
      d: #M7
        flags: isSimplyBounded isStatic isSynthetic
        returnType: int @ dart:core
    declaredVariables
      c: #M8
        flags: hasImplicitType hasInitializer isConst isStatic
        type: int @ dart:core
        constInitializer
          tokenBuffer: prefix.A.a
          tokenLengthList: [6, 1, 1, 1, 1]
          elements
            [0] (package:test/a.dart, class_, A) #M0
            [1] (package:test/a.dart, instanceGetter, A, a) #M3
            [2] (package:test/a.dart, instanceField, A, a) #M1
          elementIndexList
            3 = importPrefix
            6 = element 0
            22 = element 1
            38 = element 2
      d: #M9
        flags: hasImplicitType hasInitializer isConst isStatic
        type: int @ dart:core
        constInitializer
          tokenBuffer: prefix.A.b
          tokenLengthList: [6, 1, 1, 1, 1]
          elements
            [0] (package:test/a.dart, class_, A) #M0
            [1] (package:test/a.dart, instanceGetter, A, b) #M4
            [2] (package:test/a.dart, instanceField, A, b) #M2
          elementIndexList
            3 = importPrefix
            6 = element 0
            22 = element 1
            38 = element 2
''',
      updatedCodeFile: a,
      updatedCode: r'''
class A {
  static const a = 0;
  static const b = 1;
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        supertype: Object @ dart:core
        declaredFields
          a: #M1
            flags: hasImplicitType hasInitializer isConst isStatic
            type: int @ dart:core
            constInitializer
              tokenBuffer: 0
              tokenLengthList: [1]
          b: #M10
            flags: hasImplicitType hasInitializer isConst isStatic
            type: int @ dart:core
            constInitializer
              tokenBuffer: 1
              tokenLengthList: [1]
        declaredGetters
          a: #M3
            flags: isSimplyBounded isStatic isSynthetic
            returnType: int @ dart:core
          b: #M4
            flags: isSimplyBounded isStatic isSynthetic
            returnType: int @ dart:core
        interface: #M5
[operation] checkLinkedBundleRequirements
  package:test/test.dart
  instanceFieldIdMismatch
    libraryUri: package:test/a.dart
    interfaceName: A
    fieldName: b
    expectedId: #M2
    actualId: #M10
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      c: #M6
        flags: isSimplyBounded isStatic isSynthetic
        returnType: int @ dart:core
      d: #M7
        flags: isSimplyBounded isStatic isSynthetic
        returnType: int @ dart:core
    declaredVariables
      c: #M8
        flags: hasImplicitType hasInitializer isConst isStatic
        type: int @ dart:core
        constInitializer
          tokenBuffer: prefix.A.a
          tokenLengthList: [6, 1, 1, 1, 1]
          elements
            [0] (package:test/a.dart, class_, A) #M0
            [1] (package:test/a.dart, instanceGetter, A, a) #M3
            [2] (package:test/a.dart, instanceField, A, a) #M1
          elementIndexList
            3 = importPrefix
            6 = element 0
            22 = element 1
            38 = element 2
      d: #M11
        flags: hasImplicitType hasInitializer isConst isStatic
        type: int @ dart:core
        constInitializer
          tokenBuffer: prefix.A.b
          tokenLengthList: [6, 1, 1, 1, 1]
          elements
            [0] (package:test/a.dart, class_, A) #M0
            [1] (package:test/a.dart, instanceGetter, A, b) #M4
            [2] (package:test/a.dart, instanceField, A, b) #M10
          elementIndexList
            3 = importPrefix
            6 = element 0
            22 = element 1
            38 = element 2
''',
    );
  }

  test_manifest_constInitializer_prefixedIdentifier_importPrefix_topVariable() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
import '' as self;
const a = 0;
const b = 0;
const c = self.a;
const d = self.b;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
      b: #M1
      c: #M2
      d: #M3
    declaredVariables
      a: #M4
      b: #M5
      c: #M6
      d: #M7
''',
      updatedCode: r'''
import '' as self;
const a = 0;
const b = 1;
const c = self.a;
const d = self.b;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
      b: #M1
      c: #M2
      d: #M3
    declaredVariables
      a: #M4
      b: #M8
      c: #M6
      d: #M9
''',
    );
  }

  test_manifest_constInitializer_prefixedIdentifier_importPrefix_topVariable_changePrefix() async {
    newFile('$testPackageLibPath/a.dart', '');

    await _runLibraryManifestScenario(
      initialCode: r'''
import 'a.dart' as x;
const z = x.x + y.y;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      z: #M0
    declaredVariables
      z: #M1
''',
      updatedCode: r'''
import 'a.dart' as y;
const z = x.x + y.y;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      z: #M0
    declaredVariables
      z: #M2
''',
    );
  }

  test_manifest_constInitializer_prefixedIdentifier_importPrefix_topVariable_changeUri() async {
    newFile('$testPackageLibPath/a.dart', r'''
const x = 0;
''');

    newFile('$testPackageLibPath/b.dart', r'''
const x = 0;
''');

    await _runLibraryManifestScenario(
      initialCode: r'''
import 'a.dart' as p;
const z = p.x;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredGetters
      x: #M0
    declaredVariables
      x: #M1
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      z: #M2
    declaredVariables
      z: #M3
''',
      updatedCode: r'''
import 'b.dart' as p;
const z = p.x;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/b.dart
    declaredGetters
      x: #M4
    declaredVariables
      x: #M5
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      z: #M2
    declaredVariables
      z: #M6
''',
    );
  }

  test_manifest_constInitializer_prefixExpression() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  int operator-() {}
}
const a = A();
const b = -a;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          unary-: #M1
        interface: #M2
          map
            unary-: #M1
          implemented
            unary-: #M1
    declaredGetters
      a: #M3
      b: #M4
    declaredVariables
      a: #M5
      b: #M6
''',
      updatedCode: r'''
class A {
  double operator-() {}
}
const a = A();
const b = -a;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          unary-: #M7
        interface: #M8
          map
            unary-: #M7
          implemented
            unary-: #M7
    declaredGetters
      a: #M3
      b: #M9
    declaredVariables
      a: #M5
      b: #M10
''',
    );
  }

  test_manifest_constInitializer_prefixExpression_notAffected() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  int operator-() {}
}
const a = A();
const b = -a;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          unary-: #M1
        interface: #M2
          map
            unary-: #M1
          implemented
            unary-: #M1
    declaredGetters
      a: #M3
      b: #M4
    declaredVariables
      a: #M5
      b: #M6
''',
      updatedCode: r'''
class A {
  int operator-() {}
  void foo() {}
}
const a = A();
const b = -a;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M7
          unary-: #M1
        interface: #M8
          map
            foo: #M7
            unary-: #M1
          implemented
            foo: #M7
            unary-: #M1
    declaredGetters
      a: #M3
      b: #M4
    declaredVariables
      a: #M5
      b: #M6
''',
    );
  }

  test_manifest_constInitializer_propertyAccess_stringLength() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
const a = '0'.length;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
    declaredVariables
      a: #M1
''',
      updatedCode: r'''
const a = '1'.length;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
    declaredVariables
      a: #M2
''',
    );
  }

  test_manifest_constInitializer_setLiteral() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
const a = 0;
const b = 0;
const c = {a};
const d = {b};
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
      b: #M1
      c: #M2
      d: #M3
    declaredVariables
      a: #M4
      b: #M5
      c: #M6
      d: #M7
''',
      updatedCode: r'''
const a = 1;
const b = 0;
const c = {a};
const d = {b};
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
      b: #M1
      c: #M2
      d: #M3
    declaredVariables
      a: #M8
      b: #M5
      c: #M9
      d: #M7
''',
    );
  }

  test_manifest_constInitializer_simpleIdentifier_field() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  static const a = 0;
  static const b = 0;
  static const c = a;
  static const d = b;
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          a: #M1
          b: #M2
          c: #M3
          d: #M4
        declaredGetters
          a: #M5
          b: #M6
          c: #M7
          d: #M8
        interface: #M9
''',
      updatedCode: r'''
class A {
  static const a = 0;
  static const b = 1;
  static const c = a;
  static const d = b;
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          a: #M1
          b: #M10
          c: #M3
          d: #M11
        declaredGetters
          a: #M5
          b: #M6
          c: #M7
          d: #M8
        interface: #M9
''',
    );
  }

  test_manifest_constInitializer_simpleIdentifier_topVariable() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
const a = 0;
const b = 0;
const c = a;
const d = b;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
      b: #M1
      c: #M2
      d: #M3
    declaredVariables
      a: #M4
      b: #M5
      c: #M6
      d: #M7
''',
      updatedCode: r'''
const a = 0;
const b = 1;
const c = a;
const d = b;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
      b: #M1
      c: #M2
      d: #M3
    declaredVariables
      a: #M4
      b: #M8
      c: #M6
      d: #M9
''',
    );
  }

  test_manifest_constInitializer_symbolLiteral() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
const a = #foo.bar;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
    declaredVariables
      a: #M1
''',
      updatedCode: r'''
const a = #foo.bar;
const b = 1;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
      b: #M2
    declaredVariables
      a: #M1
      b: #M3
''',
    );
  }

  test_manifest_constInitializer_typeAlias() async {
    newFile('$testPackageLibPath/a.dart', r'''
typedef A = int;
''');

    configuration.withElementManifests = true;
    await _runLibraryManifestScenario(
      initialCode: r'''
import 'a.dart';
const x = A;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredTypeAliases
      A: #M0
        flags: isProperRename isSimplyBounded
        aliasedType: int @ dart:core
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      x: #M1
        flags: isSimplyBounded isStatic isSynthetic
        returnType: Type @ dart:core
    declaredVariables
      x: #M2
        flags: hasImplicitType hasInitializer isConst isStatic
        type: Type @ dart:core
        constInitializer
          tokenBuffer: A
          tokenLengthList: [1]
          elements
            [0] (package:test/a.dart, typeAlias, A) #M0
          elementIndexList
            6 = element 0
''',
      updatedCode: r'''
import 'a.dart';
const x = A;
const y = double;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      x: #M1
        flags: isSimplyBounded isStatic isSynthetic
        returnType: Type @ dart:core
      y: #M3
        flags: isSimplyBounded isStatic isSynthetic
        returnType: Type @ dart:core
    declaredVariables
      x: #M2
        flags: hasImplicitType hasInitializer isConst isStatic
        type: Type @ dart:core
        constInitializer
          tokenBuffer: A
          tokenLengthList: [1]
          elements
            [0] (package:test/a.dart, typeAlias, A) #M0
          elementIndexList
            6 = element 0
      y: #M4
        flags: hasImplicitType hasInitializer isConst isStatic
        type: Type @ dart:core
        constInitializer
          tokenBuffer: double
          tokenLengthList: [6]
          elements
            [0] (dart:core, class_, double) #M5
          elementIndexList
            6 = element 0
''',
    );
  }

  test_manifest_constInitializer_typeLiteral() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
const a = List<int>;
const b = List<int>;
const c = a;
const d = b;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
      b: #M1
      c: #M2
      d: #M3
    declaredVariables
      a: #M4
      b: #M5
      c: #M6
      d: #M7
''',
      updatedCode: r'''
const a = List<int>;
const b = List<double>;
const c = a;
const d = b;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
      b: #M1
      c: #M2
      d: #M3
    declaredVariables
      a: #M4
      b: #M8
      c: #M6
      d: #M9
''',
    );
  }

  test_manifest_enum_constants_reorder() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
enum A {
  c1, c2
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredEnums
      A: #M0
        declaredFields
          c1: #M1
          c2: #M2
          values: #M3
        declaredGetters
          c1: #M4
          c2: #M5
          values: #M6
        interface: #M7
          map
            index: #M8
          implemented
            index: #M8
          superImplemented
            [0]
              index: #M8
          inherited
            index: #M8
''',
      updatedCode: r'''
enum A {
  c2, c1
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredEnums
      A: #M0
        declaredFields
          c1: #M1
          c2: #M2
          values: #M9
        declaredGetters
          c1: #M4
          c2: #M5
          values: #M6
        interface: #M7
          map
            index: #M8
          implemented
            index: #M8
          superImplemented
            [0]
              index: #M8
          inherited
            index: #M8
''',
    );
  }

  test_manifest_enum_constants_replace() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
enum A {
  c1, c2
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredEnums
      A: #M0
        declaredFields
          c1: #M1
          c2: #M2
          values: #M3
        declaredGetters
          c1: #M4
          c2: #M5
          values: #M6
        interface: #M7
          map
            index: #M8
          implemented
            index: #M8
          superImplemented
            [0]
              index: #M8
          inherited
            index: #M8
''',
      updatedCode: r'''
enum A {
  c1, c3
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredEnums
      A: #M0
        declaredFields
          c1: #M1
          c3: #M9
          values: #M10
        declaredGetters
          c1: #M4
          c3: #M11
          values: #M6
        interface: #M7
          map
            index: #M8
          implemented
            index: #M8
          superImplemented
            [0]
              index: #M8
          inherited
            index: #M8
''',
    );
  }

  test_manifest_enum_constants_update_argument() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
enum A {
  c1(1),
  c2(2),
  c3(3);
  const A(int _);
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredEnums
      A: #M0
        declaredFields
          c1: #M1
          c2: #M2
          c3: #M3
          values: #M4
        declaredGetters
          c1: #M5
          c2: #M6
          c3: #M7
          values: #M8
        interface: #M9
          map
            index: #M10
          implemented
            index: #M10
          superImplemented
            [0]
              index: #M10
          inherited
            index: #M10
''',
      updatedCode: r'''
enum A {
  c1(1),
  c2(20),
  c3(3);
  const A(int _);
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredEnums
      A: #M0
        declaredFields
          c1: #M1
          c2: #M11
          c3: #M3
          values: #M12
        declaredGetters
          c1: #M5
          c2: #M6
          c3: #M7
          values: #M8
        interface: #M9
          map
            index: #M10
          implemented
            index: #M10
          superImplemented
            [0]
              index: #M10
          inherited
            index: #M10
''',
    );
  }

  test_manifest_enum_constants_update_typeArgument() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
enum A<T> {
  c1<int>(),
  c2<int>(),
  c3<int>();
  const A();
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredEnums
      A: #M0
        declaredFields
          c1: #M1
          c2: #M2
          c3: #M3
          values: #M4
        declaredGetters
          c1: #M5
          c2: #M6
          c3: #M7
          values: #M8
        interface: #M9
          map
            index: #M10
          implemented
            index: #M10
          superImplemented
            [0]
              index: #M10
          inherited
            index: #M10
''',
      updatedCode: r'''
enum A<T> {
  c1<int>(),
  c2<double>(),
  c3<int>();
  const A();
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredEnums
      A: #M0
        declaredFields
          c1: #M1
          c2: #M11
          c3: #M3
          values: #M12
        declaredGetters
          c1: #M5
          c2: #M13
          c3: #M7
          values: #M8
        interface: #M9
          map
            index: #M10
          implemented
            index: #M10
          superImplemented
            [0]
              index: #M10
          inherited
            index: #M10
''',
    );
  }

  test_manifest_enum_field_type() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
enum A {
  v;
  final int foo = 0;
  final int bar = 0;
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredEnums
      A: #M0
        declaredFields
          bar: #M1
          foo: #M2
          v: #M3
          values: #M4
        declaredGetters
          bar: #M5
          foo: #M6
          v: #M7
          values: #M8
        interface: #M9
          map
            bar: #M5
            foo: #M6
            index: #M10
          implemented
            bar: #M5
            foo: #M6
            index: #M10
          superImplemented
            [0]
              index: #M10
          inherited
            index: #M10
''',
      updatedCode: r'''
enum A {
  v;
  final int foo = 0;
  final double bar = 0;
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredEnums
      A: #M0
        declaredFields
          bar: #M11
          foo: #M2
          v: #M3
          values: #M4
        declaredGetters
          bar: #M12
          foo: #M6
          v: #M7
          values: #M8
        interface: #M13
          map
            bar: #M12
            foo: #M6
            index: #M10
          implemented
            bar: #M12
            foo: #M6
            index: #M10
          superImplemented
            [0]
              index: #M10
          inherited
            index: #M10
''',
    );
  }

  test_manifest_enum_getter() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
enum A {
  v;
  int get foo {}
  int get bar {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredEnums
      A: #M0
        declaredFields
          bar: #M1
          foo: #M2
          v: #M3
          values: #M4
        declaredGetters
          bar: #M5
          foo: #M6
          v: #M7
          values: #M8
        interface: #M9
          map
            bar: #M5
            foo: #M6
            index: #M10
          implemented
            bar: #M5
            foo: #M6
            index: #M10
          superImplemented
            [0]
              index: #M10
          inherited
            index: #M10
''',
      updatedCode: r'''
enum A {
  v;
  int get foo {}
  double get bar {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredEnums
      A: #M0
        declaredFields
          bar: #M11
          foo: #M2
          v: #M3
          values: #M4
        declaredGetters
          bar: #M12
          foo: #M6
          v: #M7
          values: #M8
        interface: #M13
          map
            bar: #M12
            foo: #M6
            index: #M10
          implemented
            bar: #M12
            foo: #M6
            index: #M10
          superImplemented
            [0]
              index: #M10
          inherited
            index: #M10
''',
    );
  }

  test_manifest_enum_implements_add() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
enum A { v }
class B {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      B: #M0
        interface: #M1
    declaredEnums
      A: #M2
        declaredFields
          v: #M3
          values: #M4
        declaredGetters
          v: #M5
          values: #M6
        interface: #M7
          map
            index: #M8
          implemented
            index: #M8
          superImplemented
            [0]
              index: #M8
          inherited
            index: #M8
''',
      updatedCode: r'''
enum A implements B { v }
class B {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      B: #M0
        interface: #M1
    declaredEnums
      A: #M9
        declaredFields
          v: #M10
          values: #M11
        declaredGetters
          v: #M12
          values: #M13
        interface: #M14
          map
            index: #M8
          implemented
            index: #M8
          superImplemented
            [0]
              index: #M8
          inherited
            index: #M8
''',
    );
  }

  test_manifest_enum_implements_remove() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
enum A implements B { v }
class B {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      B: #M0
        interface: #M1
    declaredEnums
      A: #M2
        declaredFields
          v: #M3
          values: #M4
        declaredGetters
          v: #M5
          values: #M6
        interface: #M7
          map
            index: #M8
          implemented
            index: #M8
          superImplemented
            [0]
              index: #M8
          inherited
            index: #M8
''',
      updatedCode: r'''
enum A { v }
class B {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      B: #M0
        interface: #M1
    declaredEnums
      A: #M9
        declaredFields
          v: #M10
          values: #M11
        declaredGetters
          v: #M12
          values: #M13
        interface: #M14
          map
            index: #M8
          implemented
            index: #M8
          superImplemented
            [0]
              index: #M8
          inherited
            index: #M8
''',
    );
  }

  test_manifest_enum_it_add() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
enum A { v }
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredEnums
      A: #M0
        declaredFields
          v: #M1
          values: #M2
        declaredGetters
          v: #M3
          values: #M4
        interface: #M5
          map
            index: #M6
          implemented
            index: #M6
          superImplemented
            [0]
              index: #M6
          inherited
            index: #M6
''',
      updatedCode: r'''
enum A { v }
enum B { v }
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredEnums
      A: #M0
        declaredFields
          v: #M1
          values: #M2
        declaredGetters
          v: #M3
          values: #M4
        interface: #M5
          map
            index: #M6
          implemented
            index: #M6
          superImplemented
            [0]
              index: #M6
          inherited
            index: #M6
      B: #M7
        declaredFields
          v: #M8
          values: #M9
        declaredGetters
          v: #M10
          values: #M11
        interface: #M12
          map
            index: #M6
          implemented
            index: #M6
          superImplemented
            [0]
              index: #M6
          inherited
            index: #M6
''',
    );
  }

  test_manifest_enum_it_remove() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
enum A { v }
enum B { v }
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredEnums
      A: #M0
        declaredFields
          v: #M1
          values: #M2
        declaredGetters
          v: #M3
          values: #M4
        interface: #M5
          map
            index: #M6
          implemented
            index: #M6
          superImplemented
            [0]
              index: #M6
          inherited
            index: #M6
      B: #M7
        declaredFields
          v: #M8
          values: #M9
        declaredGetters
          v: #M10
          values: #M11
        interface: #M12
          map
            index: #M6
          implemented
            index: #M6
          superImplemented
            [0]
              index: #M6
          inherited
            index: #M6
''',
      updatedCode: r'''
enum A { v }
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredEnums
      A: #M0
        declaredFields
          v: #M1
          values: #M2
        declaredGetters
          v: #M3
          values: #M4
        interface: #M5
          map
            index: #M6
          implemented
            index: #M6
          superImplemented
            [0]
              index: #M6
          inherited
            index: #M6
''',
    );
  }

  test_manifest_enum_method() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
enum A {
  v;
  int foo() {}
  int bar() {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredEnums
      A: #M0
        declaredFields
          v: #M1
          values: #M2
        declaredGetters
          v: #M3
          values: #M4
        declaredMethods
          bar: #M5
          foo: #M6
        interface: #M7
          map
            bar: #M5
            foo: #M6
            index: #M8
          implemented
            bar: #M5
            foo: #M6
            index: #M8
          superImplemented
            [0]
              index: #M8
          inherited
            index: #M8
''',
      updatedCode: r'''
enum A {
  v;
  int foo() {}
  double bar() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredEnums
      A: #M0
        declaredFields
          v: #M1
          values: #M2
        declaredGetters
          v: #M3
          values: #M4
        declaredMethods
          bar: #M9
          foo: #M6
        interface: #M10
          map
            bar: #M9
            foo: #M6
            index: #M8
          implemented
            bar: #M9
            foo: #M6
            index: #M8
          superImplemented
            [0]
              index: #M8
          inherited
            index: #M8
''',
    );
  }

  test_manifest_enum_setter() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
enum A {
  v;
  set foo(int _) {}
  set bar(int _) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredEnums
      A: #M0
        declaredFields
          bar: #M1
          foo: #M2
          v: #M3
          values: #M4
        declaredGetters
          v: #M5
          values: #M6
        declaredSetters
          bar=: #M7
          foo=: #M8
        interface: #M9
          map
            bar=: #M7
            foo=: #M8
            index: #M10
          implemented
            bar=: #M7
            foo=: #M8
            index: #M10
          superImplemented
            [0]
              index: #M10
          inherited
            index: #M10
''',
      updatedCode: r'''
enum A {
  v;
  set foo(int _) {}
  set bar(double _) {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredEnums
      A: #M0
        declaredFields
          bar: #M11
          foo: #M2
          v: #M3
          values: #M4
        declaredGetters
          v: #M5
          values: #M6
        declaredSetters
          bar=: #M12
          foo=: #M8
        interface: #M13
          map
            bar=: #M12
            foo=: #M8
            index: #M10
          implemented
            bar=: #M12
            foo=: #M8
            index: #M10
          superImplemented
            [0]
              index: #M10
          inherited
            index: #M10
''',
    );
  }

  test_manifest_enum_typeParameters() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
enum A<T> {
  v;
  void foo(T _) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredEnums
      A: #M0
        declaredFields
          v: #M1
          values: #M2
        declaredGetters
          v: #M3
          values: #M4
        declaredMethods
          foo: #M5
        interface: #M6
          map
            foo: #M5
            index: #M7
          implemented
            foo: #M5
            index: #M7
          superImplemented
            [0]
              index: #M7
          inherited
            index: #M7
''',
      updatedCode: r'''
enum A<T> {
  v;
  void foo(T _) {}
  void bar(T _) {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredEnums
      A: #M0
        declaredFields
          v: #M1
          values: #M2
        declaredGetters
          v: #M3
          values: #M4
        declaredMethods
          bar: #M8
          foo: #M5
        interface: #M9
          map
            bar: #M8
            foo: #M5
            index: #M7
          implemented
            bar: #M8
            foo: #M5
            index: #M7
          superImplemented
            [0]
              index: #M7
          inherited
            index: #M7
''',
    );
  }

  test_manifest_enum_typeParameters_add() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
enum A<T> { v }
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredEnums
      A: #M0
        declaredFields
          v: #M1
          values: #M2
        declaredGetters
          v: #M3
          values: #M4
        interface: #M5
          map
            index: #M6
          implemented
            index: #M6
          superImplemented
            [0]
              index: #M6
          inherited
            index: #M6
''',
      updatedCode: r'''
enum A<T, U> { v }
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredEnums
      A: #M7
        declaredFields
          v: #M8
          values: #M9
        declaredGetters
          v: #M10
          values: #M11
        interface: #M12
          map
            index: #M6
          implemented
            index: #M6
          superImplemented
            [0]
              index: #M6
          inherited
            index: #M6
''',
    );
  }

  test_manifest_enum_with_add() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
enum A { v }

mixin M {
  void foo() {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredEnums
      A: #M0
        declaredFields
          v: #M1
          values: #M2
        declaredGetters
          v: #M3
          values: #M4
        interface: #M5
          map
            index: #M6
          implemented
            index: #M6
          superImplemented
            [0]
              index: #M6
          inherited
            index: #M6
    declaredMixins
      M: #M7
        declaredMethods
          foo: #M8
        interface: #M9
          map
            foo: #M8
          implemented
            foo: #M8
''',
      updatedCode: r'''
enum A with M { v }

mixin M {
  void foo() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredEnums
      A: #M10
        declaredFields
          v: #M11
          values: #M12
        declaredGetters
          v: #M13
          values: #M14
        interface: #M15
          map
            foo: #M8
            index: #M6
          implemented
            foo: #M8
            index: #M6
          superImplemented
            [0]
              index: #M6
            [1]
              foo: #M8
              index: #M6
          inherited
            foo: #M8
            index: #M6
    declaredMixins
      M: #M7
        declaredMethods
          foo: #M8
        interface: #M9
          map
            foo: #M8
          implemented
            foo: #M8
''',
    );
  }

  test_manifest_enum_with_remove() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
enum A with M { v }

mixin M {
  void foo() {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredEnums
      A: #M0
        declaredFields
          v: #M1
          values: #M2
        declaredGetters
          v: #M3
          values: #M4
        interface: #M5
          map
            foo: #M6
            index: #M7
          implemented
            foo: #M6
            index: #M7
          superImplemented
            [0]
              index: #M7
            [1]
              foo: #M6
              index: #M7
          inherited
            foo: #M6
            index: #M7
    declaredMixins
      M: #M8
        declaredMethods
          foo: #M6
        interface: #M9
          map
            foo: #M6
          implemented
            foo: #M6
''',
      updatedCode: r'''
enum A { v }

mixin M {
  void foo() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredEnums
      A: #M10
        declaredFields
          v: #M11
          values: #M12
        declaredGetters
          v: #M13
          values: #M14
        interface: #M15
          map
            index: #M7
          implemented
            index: #M7
          superImplemented
            [0]
              index: #M7
          inherited
            index: #M7
    declaredMixins
      M: #M8
        declaredMethods
          foo: #M6
        interface: #M9
          map
            foo: #M6
          implemented
            foo: #M6
''',
    );
  }

  test_manifest_extension_exportedExtensionMethods() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
extension A on int {
  int foo() {}
  int bar() {}
}

extension B on int {
  int foo() {}
  int baz() {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredExtensions
      A: #M0
        declaredMethods
          bar: #M1
          foo: #M2
      B: #M3
        declaredMethods
          baz: #M4
          foo: #M5
    exportedExtensions: #M0 #M3
''',
      updatedCode: r'''
extension A on int {
  int foo() {}
  double bar() {}
}

extension B on int {
  int foo() {}
  int baz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredExtensions
      A: #M0
        declaredMethods
          bar: #M6
          foo: #M2
      B: #M3
        declaredMethods
          baz: #M4
          foo: #M5
    exportedExtensions: #M0 #M3
''',
    );
  }

  test_manifest_extension_exportedExtensionMethods_exported() async {
    var a = newFile('$testPackageLibPath/a.dart', r'''
extension A on int {
  int foo() {}
  int bar() {}
}
''');

    await _runLibraryManifestScenario(
      initialCode: r'''
export 'a.dart';

extension B on int {
  int foo() {}
  int baz() {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensions
      A: #M0
        declaredMethods
          bar: #M1
          foo: #M2
    exportedExtensions: #M0
[operation] linkLibraryCycle
  package:test/test.dart
    declaredExtensions
      B: #M3
        declaredMethods
          baz: #M4
          foo: #M5
    reExportMap
      A: #M0
    exportedExtensions: #M0 #M3
    exportedLibraryUris: package:test/a.dart
''',
      updatedCodeFile: a,
      updatedCode: r'''
extension A on int {
  int foo() {}
  double bar() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensions
      A: #M0
        declaredMethods
          bar: #M6
          foo: #M2
    exportedExtensions: #M0
[operation] reuseLinkedBundle
  package:test/test.dart
''',
    );
  }

  test_manifest_extension_exportedExtensionMethods_exported_hideCombinator() async {
    var a = newFile('$testPackageLibPath/a.dart', r'''
extension A on int {
  int foo() {}
}
extension B on int {
  int bar() {}
}
''');

    await _runLibraryManifestScenario(
      initialCode: r'''
export 'a.dart' hide B;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensions
      A: #M0
        declaredMethods
          foo: #M1
      B: #M2
        declaredMethods
          bar: #M3
    exportedExtensions: #M0 #M2
[operation] linkLibraryCycle
  package:test/test.dart
    reExportMap
      A: #M0
    exportedExtensions: #M0
    exportedLibraryUris: package:test/a.dart
''',
      updatedCodeFile: a,
      updatedCode: r'''
extension A on int {
  int foo() {}
}
extension B on int {
  double bar() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensions
      A: #M0
        declaredMethods
          foo: #M1
      B: #M2
        declaredMethods
          bar: #M4
    exportedExtensions: #M0 #M2
[operation] reuseLinkedBundle
  package:test/test.dart
''',
    );
  }

  test_manifest_extension_exportedExtensionMethods_exported_showCombinator() async {
    var a = newFile('$testPackageLibPath/a.dart', r'''
extension A on int {
  int foo() {}
}
extension B on int {
  int bar() {}
}
''');

    await _runLibraryManifestScenario(
      initialCode: r'''
export 'a.dart' show A;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensions
      A: #M0
        declaredMethods
          foo: #M1
      B: #M2
        declaredMethods
          bar: #M3
    exportedExtensions: #M0 #M2
[operation] linkLibraryCycle
  package:test/test.dart
    reExportMap
      A: #M0
    exportedExtensions: #M0
    exportedLibraryUris: package:test/a.dart
''',
      updatedCodeFile: a,
      updatedCode: r'''
extension A on int {
  int foo() {}
}
extension B on int {
  double bar() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensions
      A: #M0
        declaredMethods
          foo: #M1
      B: #M2
        declaredMethods
          bar: #M4
    exportedExtensions: #M0 #M2
[operation] reuseLinkedBundle
  package:test/test.dart
''',
    );
  }

  test_manifest_extension_exportedExtensionMethods_exportedChain() async {
    var a = newFile('$testPackageLibPath/a.dart', r'''
extension A on int {
  int foo() {}
  int bar() {}
}
''');

    newFile('$testPackageLibPath/b.dart', r'''
export 'a.dart';
''');

    await _runLibraryManifestScenario(
      initialCode: r'''
export 'b.dart';

extension B on int {
  int foo() {}
  int baz() {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensions
      A: #M0
        declaredMethods
          bar: #M1
          foo: #M2
    exportedExtensions: #M0
[operation] linkLibraryCycle
  package:test/b.dart
    reExportMap
      A: #M0
    exportedExtensions: #M0
    exportedLibraryUris: package:test/a.dart
[operation] linkLibraryCycle
  package:test/test.dart
    declaredExtensions
      B: #M3
        declaredMethods
          baz: #M4
          foo: #M5
    reExportMap
      A: #M0
    exportedExtensions: #M0 #M3
    exportedLibraryUris: package:test/b.dart
''',
      updatedCodeFile: a,
      updatedCode: r'''
extension A on int {
  int foo() {}
  double bar() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensions
      A: #M0
        declaredMethods
          bar: #M6
          foo: #M2
    exportedExtensions: #M0
[operation] reuseLinkedBundle
  package:test/b.dart
[operation] reuseLinkedBundle
  package:test/test.dart
''',
    );
  }

  test_manifest_extension_exportedExtensionMethods_exportedShadow() async {
    var a = newFile('$testPackageLibPath/a.dart', r'''
extension A on int {
  int foo() {}
}
extension B on int {
  int bar() {}
}
''');

    await _runLibraryManifestScenario(
      initialCode: r'''
export 'a.dart';
extension A on int {
  int baz() {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensions
      A: #M0
        declaredMethods
          foo: #M1
      B: #M2
        declaredMethods
          bar: #M3
    exportedExtensions: #M0 #M2
[operation] linkLibraryCycle
  package:test/test.dart
    declaredExtensions
      A: #M4
        declaredMethods
          baz: #M5
    reExportMap
      B: #M2
    exportedExtensions: #M2 #M4
    exportedLibraryUris: package:test/a.dart
''',
      updatedCodeFile: a,
      updatedCode: r'''
extension A on int {
  double foo() {}
}
extension B on int {
  int bar() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/a.dart
    declaredExtensions
      A: #M0
        declaredMethods
          foo: #M6
      B: #M2
        declaredMethods
          bar: #M3
    exportedExtensions: #M0 #M2
[operation] reuseLinkedBundle
  package:test/test.dart
''',
    );
  }

  test_manifest_extension_exportedExtensionMethods_private() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
extension A on int {
  int foo() {}
  int _bar() {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredExtensions
      A: #M0
        declaredMethods
          _bar: #M1
          foo: #M2
    exportedExtensions: #M0
''',
      updatedCode: r'''
extension A on int {
  int foo() {}
  double _bar() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredExtensions
      A: #M0
        declaredMethods
          _bar: #M3
          foo: #M2
    exportedExtensions: #M0
''',
    );
  }

  test_manifest_extension_exportedExtensionMethods_reorderExtensions() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
extension A on int {
  int foo() {}
}
extension B on int {
  int foo() {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredExtensions
      A: #M0
        declaredMethods
          foo: #M1
      B: #M2
        declaredMethods
          foo: #M3
    exportedExtensions: #M0 #M2
''',
      updatedCode: r'''
extension B on int {
  int foo() {}
}
extension A on int {
  int foo() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredExtensions
      A: #M0
        declaredMethods
          foo: #M1
      B: #M2
        declaredMethods
          foo: #M3
    exportedExtensions: #M0 #M2
''',
    );
  }

  test_manifest_extension_exportedExtensionMethods_static() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
extension A on int {
  int foo() {}
  static int bar() {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredExtensions
      A: #M0
        declaredMethods
          bar: #M1
          foo: #M2
    exportedExtensions: #M0
''',
      updatedCode: r'''
extension A on int {
  int foo() {}
  static double bar() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredExtensions
      A: #M0
        declaredMethods
          bar: #M3
          foo: #M2
    exportedExtensions: #M0
''',
    );
  }

  test_manifest_extension_extendedType() async {
    configuration.withElementManifests = true;
    await _runLibraryManifestScenario(
      initialCode: r'''
extension A on int {
  void foo() {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredExtensions
      A: #M0
        extendedType: int @ dart:core
        declaredMethods
          foo: #M1
            flags: isSimplyBounded
            functionType: FunctionType
              returnType: void
    exportedExtensions: #M0
''',
      updatedCode: r'''
extension A on double {
  void foo() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredExtensions
      A: #M2
        extendedType: double @ dart:core
        declaredMethods
          foo: #M3
            flags: isSimplyBounded
            functionType: FunctionType
              returnType: void
    exportedExtensions: #M2
''',
    );
  }

  test_manifest_extension_getter() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
extension A on int {
  int get foo {}
  int get bar {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredExtensions
      A: #M0
        declaredFields
          bar: #M1
          foo: #M2
        declaredGetters
          bar: #M3
          foo: #M4
    exportedExtensions: #M0
''',
      updatedCode: r'''
extension A on int {
  int get foo {}
  double get bar {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredExtensions
      A: #M0
        declaredFields
          bar: #M5
          foo: #M2
        declaredGetters
          bar: #M6
          foo: #M4
    exportedExtensions: #M0
''',
    );
  }

  test_manifest_extension_getter_idChangesWithContainer() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {}
class B {}
extension E on B {
  int get foo => 0;
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        interface: #M1
      B: #M2
        interface: #M3
    declaredExtensions
      E: #M4
        declaredFields
          foo: #M5
        declaredGetters
          foo: #M6
    exportedExtensions: #M4
''',
      updatedCode: r'''
class A {}
class B extends A {}
extension E on B {
  int get foo => 0;
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        interface: #M1
      B: #M7
        interface: #M8
    declaredExtensions
      E: #M9
        declaredFields
          foo: #M10
        declaredGetters
          foo: #M11
    exportedExtensions: #M9
''',
    );
  }

  test_manifest_extension_getter_modifier_hasEnclosingTypeParameterReference() async {
    configuration.withElementManifests = true;
    await _runLibraryManifestScenario(
      initialCode: r'''
extension E<T> on int {
  T get foo1 => throw 0;
  int get foo2 => 0;
  T get foo3 => throw 0;
  int get foo4 => 0;
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredExtensions
      E: #M0
        typeParameters
          #0 covariant
            bound: <null>
        extendedType: int @ dart:core
        declaredFields
          foo1: #M1
            flags: hasEnclosingTypeParameterReference isSynthetic shouldUseTypeForInitializerInference
            type: typeParameter#0
          foo2: #M2
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo3: #M3
            flags: hasEnclosingTypeParameterReference isSynthetic shouldUseTypeForInitializerInference
            type: typeParameter#0
          foo4: #M4
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
        declaredGetters
          foo1: #M5
            flags: hasEnclosingTypeParameterReference isSimplyBounded
            returnType: typeParameter#0
          foo2: #M6
            flags: isSimplyBounded
            returnType: int @ dart:core
          foo3: #M7
            flags: hasEnclosingTypeParameterReference isSimplyBounded
            returnType: typeParameter#0
          foo4: #M8
            flags: isSimplyBounded
            returnType: int @ dart:core
    exportedExtensions: #M0
''',
      updatedCode: r'''
extension E<T> on int {
  T get foo1 => throw 0;
  int get foo2 => 0;
  int get foo3 => 0;
  T get foo4 => throw 0;
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredExtensions
      E: #M0
        typeParameters
          #0 covariant
            bound: <null>
        extendedType: int @ dart:core
        declaredFields
          foo1: #M1
            flags: hasEnclosingTypeParameterReference isSynthetic shouldUseTypeForInitializerInference
            type: typeParameter#0
          foo2: #M2
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo3: #M9
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo4: #M10
            flags: hasEnclosingTypeParameterReference isSynthetic shouldUseTypeForInitializerInference
            type: typeParameter#0
        declaredGetters
          foo1: #M5
            flags: hasEnclosingTypeParameterReference isSimplyBounded
            returnType: typeParameter#0
          foo2: #M6
            flags: isSimplyBounded
            returnType: int @ dart:core
          foo3: #M11
            flags: isSimplyBounded
            returnType: int @ dart:core
          foo4: #M12
            flags: hasEnclosingTypeParameterReference isSimplyBounded
            returnType: typeParameter#0
    exportedExtensions: #M0
''',
    );
  }

  test_manifest_extension_getter_modifier_hasImplicitReturnType() async {
    configuration.withElementManifests = true;
    await _runLibraryManifestScenario(
      initialCode: r'''
extension E on int {
  get foo1 => 0;
  int get foo2 => 0;
  get foo3 => 0;
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredExtensions
      E: #M0
        extendedType: int @ dart:core
        declaredFields
          foo1: #M1
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: dynamic
          foo2: #M2
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo3: #M3
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: dynamic
        declaredGetters
          foo1: #M4
            flags: hasImplicitReturnType isSimplyBounded
            returnType: dynamic
          foo2: #M5
            flags: isSimplyBounded
            returnType: int @ dart:core
          foo3: #M6
            flags: hasImplicitReturnType isSimplyBounded
            returnType: dynamic
    exportedExtensions: #M0
''',
      updatedCode: r'''
extension E on int {
  get foo1 => 0;
  get foo2 => 0;
  int get foo3 => 0;
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredExtensions
      E: #M0
        extendedType: int @ dart:core
        declaredFields
          foo1: #M1
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: dynamic
          foo2: #M7
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: dynamic
          foo3: #M8
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
        declaredGetters
          foo1: #M4
            flags: hasImplicitReturnType isSimplyBounded
            returnType: dynamic
          foo2: #M9
            flags: hasImplicitReturnType isSimplyBounded
            returnType: dynamic
          foo3: #M10
            flags: isSimplyBounded
            returnType: int @ dart:core
    exportedExtensions: #M0
''',
    );
  }

  test_manifest_extension_getter_modifier_isExternal() async {
    configuration.withElementManifests = true;
    await _runLibraryManifestScenario(
      initialCode: r'''
extension E on int {
  int get foo1 => 1;
  external int get foo2;
  int get foo3 => 3;
  external int get foo4;
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredExtensions
      E: #M0
        extendedType: int @ dart:core
        declaredFields
          foo1: #M1
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo2: #M2
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo3: #M3
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo4: #M4
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
        declaredGetters
          foo1: #M5
            flags: isSimplyBounded
            returnType: int @ dart:core
          foo2: #M6
            flags: isExternal isSimplyBounded
            returnType: int @ dart:core
          foo3: #M7
            flags: isSimplyBounded
            returnType: int @ dart:core
          foo4: #M8
            flags: isExternal isSimplyBounded
            returnType: int @ dart:core
    exportedExtensions: #M0
''',
      updatedCode: r'''
extension E on int {
  int get foo1 => 1;
  external int get foo2;
  external int get foo3;
  int get foo4 => 4;
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredExtensions
      E: #M0
        extendedType: int @ dart:core
        declaredFields
          foo1: #M1
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo2: #M2
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo3: #M3
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo4: #M4
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
        declaredGetters
          foo1: #M5
            flags: isSimplyBounded
            returnType: int @ dart:core
          foo2: #M6
            flags: isExternal isSimplyBounded
            returnType: int @ dart:core
          foo3: #M9
            flags: isExternal isSimplyBounded
            returnType: int @ dart:core
          foo4: #M10
            flags: isSimplyBounded
            returnType: int @ dart:core
    exportedExtensions: #M0
''',
    );
  }

  test_manifest_extension_getter_modifier_isStatic() async {
    configuration.withElementManifests = true;
    await _runLibraryManifestScenario(
      initialCode: r'''
extension E on int {
  int get foo1 => 1;
  static int get foo2 => 2;
  int get foo3 => 3;
  static int get foo4 => 4;
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredExtensions
      E: #M0
        extendedType: int @ dart:core
        declaredFields
          foo1: #M1
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo2: #M2
            flags: isStatic isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo3: #M3
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo4: #M4
            flags: isStatic isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
        declaredGetters
          foo1: #M5
            flags: isSimplyBounded
            returnType: int @ dart:core
          foo2: #M6
            flags: isSimplyBounded isStatic
            returnType: int @ dart:core
          foo3: #M7
            flags: isSimplyBounded
            returnType: int @ dart:core
          foo4: #M8
            flags: isSimplyBounded isStatic
            returnType: int @ dart:core
    exportedExtensions: #M0
''',
      updatedCode: r'''
extension E on int {
  int get foo1 => 1;
  static int get foo2 => 2;
  static int get foo3 => 3;
  int get foo4 => 4;
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredExtensions
      E: #M0
        extendedType: int @ dart:core
        declaredFields
          foo1: #M1
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo2: #M2
            flags: isStatic isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo3: #M9
            flags: isStatic isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo4: #M10
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
        declaredGetters
          foo1: #M5
            flags: isSimplyBounded
            returnType: int @ dart:core
          foo2: #M6
            flags: isSimplyBounded isStatic
            returnType: int @ dart:core
          foo3: #M11
            flags: isSimplyBounded isStatic
            returnType: int @ dart:core
          foo4: #M12
            flags: isSimplyBounded
            returnType: int @ dart:core
    exportedExtensions: #M0
''',
    );
  }

  test_manifest_extension_metadata() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
@Deprecated('0')
extension A on int {}

@Deprecated('0')
extension B on int {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredExtensions
      A: #M0
      B: #M1
    exportedExtensions: #M0 #M1
''',
      updatedCode: r'''
@Deprecated('0')
extension A on int {}

@Deprecated('1')
extension B on int {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredExtensions
      A: #M0
      B: #M2
    exportedExtensions: #M0 #M2
''',
    );
  }

  test_manifest_extension_method() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
extension A on int {
  int foo() {}
  int bar() {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredExtensions
      A: #M0
        declaredMethods
          bar: #M1
          foo: #M2
    exportedExtensions: #M0
''',
      updatedCode: r'''
extension A on int {
  int foo() {}
  double bar() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredExtensions
      A: #M0
        declaredMethods
          bar: #M3
          foo: #M2
    exportedExtensions: #M0
''',
    );
  }

  test_manifest_extension_method_idChangesWithContainer() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {}
class B {}
extension E on B {
  void foo() {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        interface: #M1
      B: #M2
        interface: #M3
    declaredExtensions
      E: #M4
        declaredMethods
          foo: #M5
    exportedExtensions: #M4
''',
      updatedCode: r'''
class A {}
class B extends A {}
extension E on B {
  void foo() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        interface: #M1
      B: #M6
        interface: #M7
    declaredExtensions
      E: #M8
        declaredMethods
          foo: #M9
    exportedExtensions: #M8
''',
    );
  }

  test_manifest_extension_method_modifier_hasEnclosingTypeParameterReference() async {
    configuration.withElementManifests = true;
    await _runLibraryManifestScenario(
      initialCode: r'''
extension E<T> on int {
  T foo1() => throw 0;
  void foo2() {}
  T foo3() => throw 0;
  void foo4() {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredExtensions
      E: #M0
        typeParameters
          #0 covariant
            bound: <null>
        extendedType: int @ dart:core
        declaredMethods
          foo1: #M1
            flags: hasEnclosingTypeParameterReference isSimplyBounded
            functionType: FunctionType
              returnType: typeParameter#0
          foo2: #M2
            flags: isSimplyBounded
            functionType: FunctionType
              returnType: void
          foo3: #M3
            flags: hasEnclosingTypeParameterReference isSimplyBounded
            functionType: FunctionType
              returnType: typeParameter#0
          foo4: #M4
            flags: isSimplyBounded
            functionType: FunctionType
              returnType: void
    exportedExtensions: #M0
''',
      updatedCode: r'''
extension E<T> on int {
  T foo1() => throw 0;
  void foo2() {}
  void foo3() {}
  T foo4() => throw 0;
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredExtensions
      E: #M0
        typeParameters
          #0 covariant
            bound: <null>
        extendedType: int @ dart:core
        declaredMethods
          foo1: #M1
            flags: hasEnclosingTypeParameterReference isSimplyBounded
            functionType: FunctionType
              returnType: typeParameter#0
          foo2: #M2
            flags: isSimplyBounded
            functionType: FunctionType
              returnType: void
          foo3: #M5
            flags: isSimplyBounded
            functionType: FunctionType
              returnType: void
          foo4: #M6
            flags: hasEnclosingTypeParameterReference isSimplyBounded
            functionType: FunctionType
              returnType: typeParameter#0
    exportedExtensions: #M0
''',
    );
  }

  test_manifest_extension_method_modifier_hasImplicitReturnType() async {
    configuration.withElementManifests = true;
    await _runLibraryManifestScenario(
      initialCode: r'''
extension E on int {
  foo1() {}
  void foo2() {}
  foo3() {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredExtensions
      E: #M0
        extendedType: int @ dart:core
        declaredMethods
          foo1: #M1
            flags: hasImplicitReturnType isSimplyBounded
            functionType: FunctionType
              returnType: dynamic
          foo2: #M2
            flags: isSimplyBounded
            functionType: FunctionType
              returnType: void
          foo3: #M3
            flags: hasImplicitReturnType isSimplyBounded
            functionType: FunctionType
              returnType: dynamic
    exportedExtensions: #M0
''',
      updatedCode: r'''
extension E on int {
  foo1() {}
  foo2() {}
  void foo3() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredExtensions
      E: #M0
        extendedType: int @ dart:core
        declaredMethods
          foo1: #M1
            flags: hasImplicitReturnType isSimplyBounded
            functionType: FunctionType
              returnType: dynamic
          foo2: #M4
            flags: hasImplicitReturnType isSimplyBounded
            functionType: FunctionType
              returnType: dynamic
          foo3: #M5
            flags: isSimplyBounded
            functionType: FunctionType
              returnType: void
    exportedExtensions: #M0
''',
    );
  }

  test_manifest_extension_method_modifier_isExternal() async {
    configuration.withElementManifests = true;
    await _runLibraryManifestScenario(
      initialCode: r'''
extension E on int {
  void foo1() {}
  external void foo2();
  void foo3() {}
  external void foo4();
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredExtensions
      E: #M0
        extendedType: int @ dart:core
        declaredMethods
          foo1: #M1
            flags: isSimplyBounded
            functionType: FunctionType
              returnType: void
          foo2: #M2
            flags: isExternal isSimplyBounded
            functionType: FunctionType
              returnType: void
          foo3: #M3
            flags: isSimplyBounded
            functionType: FunctionType
              returnType: void
          foo4: #M4
            flags: isExternal isSimplyBounded
            functionType: FunctionType
              returnType: void
    exportedExtensions: #M0
''',
      updatedCode: r'''
extension E on int {
  void foo1() {}
  external void foo2();
  external void foo3();
  void foo4() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredExtensions
      E: #M0
        extendedType: int @ dart:core
        declaredMethods
          foo1: #M1
            flags: isSimplyBounded
            functionType: FunctionType
              returnType: void
          foo2: #M2
            flags: isExternal isSimplyBounded
            functionType: FunctionType
              returnType: void
          foo3: #M5
            flags: isExternal isSimplyBounded
            functionType: FunctionType
              returnType: void
          foo4: #M6
            flags: isSimplyBounded
            functionType: FunctionType
              returnType: void
    exportedExtensions: #M0
''',
    );
  }

  test_manifest_extension_method_modifier_isStatic() async {
    configuration.withElementManifests = true;
    await _runLibraryManifestScenario(
      initialCode: r'''
extension E on int {
  void foo1() {}
  static void foo2() {}
  void foo3() {}
  static void foo4() {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredExtensions
      E: #M0
        extendedType: int @ dart:core
        declaredMethods
          foo1: #M1
            flags: isSimplyBounded
            functionType: FunctionType
              returnType: void
          foo2: #M2
            flags: isSimplyBounded isStatic
            functionType: FunctionType
              returnType: void
          foo3: #M3
            flags: isSimplyBounded
            functionType: FunctionType
              returnType: void
          foo4: #M4
            flags: isSimplyBounded isStatic
            functionType: FunctionType
              returnType: void
    exportedExtensions: #M0
''',
      updatedCode: r'''
extension E on int {
  void foo1() {}
  static void foo2() {}
  static void foo3() {}
  void foo4() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredExtensions
      E: #M0
        extendedType: int @ dart:core
        declaredMethods
          foo1: #M1
            flags: isSimplyBounded
            functionType: FunctionType
              returnType: void
          foo2: #M2
            flags: isSimplyBounded isStatic
            functionType: FunctionType
              returnType: void
          foo3: #M5
            flags: isSimplyBounded isStatic
            functionType: FunctionType
              returnType: void
          foo4: #M6
            flags: isSimplyBounded
            functionType: FunctionType
              returnType: void
    exportedExtensions: #M0
''',
    );
  }

  test_manifest_extension_noName() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
extension on int {
  void foo() {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
''',
      updatedCode: r'''
extension on int {
  void foo() {}
  void bar() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
''',
    );
  }

  test_manifest_extension_setter() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
extension A on int {
  set foo(int _) {}
  set bar(int _) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredExtensions
      A: #M0
        declaredFields
          bar: #M1
          foo: #M2
        declaredSetters
          bar=: #M3
          foo=: #M4
    exportedExtensions: #M0
''',
      updatedCode: r'''
extension A on int {
  set foo(int _) {}
  set bar(double _) {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredExtensions
      A: #M0
        declaredFields
          bar: #M5
          foo: #M2
        declaredSetters
          bar=: #M6
          foo=: #M4
    exportedExtensions: #M0
''',
    );
  }

  test_manifest_extension_setter_idChangesWithContainer() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {}
class B {}
extension E on B {
  void set foo(int _) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        interface: #M1
      B: #M2
        interface: #M3
    declaredExtensions
      E: #M4
        declaredFields
          foo: #M5
        declaredSetters
          foo=: #M6
    exportedExtensions: #M4
''',
      updatedCode: r'''
class A {}
class B extends A {}
extension E on B {
  void set foo(int _) {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        interface: #M1
      B: #M7
        interface: #M8
    declaredExtensions
      E: #M9
        declaredFields
          foo: #M10
        declaredSetters
          foo=: #M11
    exportedExtensions: #M9
''',
    );
  }

  test_manifest_extension_setter_modifier_hasEnclosingTypeParameterReference() async {
    configuration.withElementManifests = true;
    await _runLibraryManifestScenario(
      initialCode: r'''
extension E<T> on int {
  set foo1(T value) {}
  set foo2(int value) {}
  set foo3(T value) {}
  set foo4(int value) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredExtensions
      E: #M0
        typeParameters
          #0 covariant
            bound: <null>
        extendedType: int @ dart:core
        declaredFields
          foo1: #M1
            flags: hasEnclosingTypeParameterReference isSynthetic shouldUseTypeForInitializerInference
            type: typeParameter#0
          foo2: #M2
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo3: #M3
            flags: hasEnclosingTypeParameterReference isSynthetic shouldUseTypeForInitializerInference
            type: typeParameter#0
          foo4: #M4
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
        declaredSetters
          foo1=: #M5
            flags: hasEnclosingTypeParameterReference hasImplicitReturnType isSimplyBounded
            functionType: FunctionType
              positional
                required typeParameter#0
              returnType: void
          foo2=: #M6
            flags: hasImplicitReturnType isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
          foo3=: #M7
            flags: hasEnclosingTypeParameterReference hasImplicitReturnType isSimplyBounded
            functionType: FunctionType
              positional
                required typeParameter#0
              returnType: void
          foo4=: #M8
            flags: hasImplicitReturnType isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
    exportedExtensions: #M0
''',
      updatedCode: r'''
extension E<T> on int {
  set foo1(T value) {}
  set foo2(int value) {}
  set foo3(int value) {}
  set foo4(T value) {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredExtensions
      E: #M0
        typeParameters
          #0 covariant
            bound: <null>
        extendedType: int @ dart:core
        declaredFields
          foo1: #M1
            flags: hasEnclosingTypeParameterReference isSynthetic shouldUseTypeForInitializerInference
            type: typeParameter#0
          foo2: #M2
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo3: #M9
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo4: #M10
            flags: hasEnclosingTypeParameterReference isSynthetic shouldUseTypeForInitializerInference
            type: typeParameter#0
        declaredSetters
          foo1=: #M5
            flags: hasEnclosingTypeParameterReference hasImplicitReturnType isSimplyBounded
            functionType: FunctionType
              positional
                required typeParameter#0
              returnType: void
          foo2=: #M6
            flags: hasImplicitReturnType isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
          foo3=: #M11
            flags: hasImplicitReturnType isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
          foo4=: #M12
            flags: hasEnclosingTypeParameterReference hasImplicitReturnType isSimplyBounded
            functionType: FunctionType
              positional
                required typeParameter#0
              returnType: void
    exportedExtensions: #M0
''',
    );
  }

  test_manifest_extension_setter_modifier_isExternal() async {
    configuration.withElementManifests = true;
    await _runLibraryManifestScenario(
      initialCode: r'''
extension E on int {
  set foo1(int value) {}
  external set foo2(int value);
  set foo3(int value) {}
  external set foo4(int value);
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredExtensions
      E: #M0
        extendedType: int @ dart:core
        declaredFields
          foo1: #M1
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo2: #M2
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo3: #M3
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo4: #M4
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
        declaredSetters
          foo1=: #M5
            flags: hasImplicitReturnType isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
          foo2=: #M6
            flags: hasImplicitReturnType isExternal isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
          foo3=: #M7
            flags: hasImplicitReturnType isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
          foo4=: #M8
            flags: hasImplicitReturnType isExternal isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
    exportedExtensions: #M0
''',
      updatedCode: r'''
extension E on int {
  set foo1(int value) {}
  external set foo2(int value);
  external set foo3(int value);
  set foo4(int value) {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredExtensions
      E: #M0
        extendedType: int @ dart:core
        declaredFields
          foo1: #M1
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo2: #M2
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo3: #M3
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo4: #M4
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
        declaredSetters
          foo1=: #M5
            flags: hasImplicitReturnType isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
          foo2=: #M6
            flags: hasImplicitReturnType isExternal isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
          foo3=: #M9
            flags: hasImplicitReturnType isExternal isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
          foo4=: #M10
            flags: hasImplicitReturnType isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
    exportedExtensions: #M0
''',
    );
  }

  test_manifest_extension_setter_modifier_isStatic() async {
    configuration.withElementManifests = true;
    await _runLibraryManifestScenario(
      initialCode: r'''
extension E on int {
  set foo1(int value) {}
  static set foo2(int value) {}
  set foo3(int value) {}
  static set foo4(int value) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredExtensions
      E: #M0
        extendedType: int @ dart:core
        declaredFields
          foo1: #M1
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo2: #M2
            flags: isStatic isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo3: #M3
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo4: #M4
            flags: isStatic isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
        declaredSetters
          foo1=: #M5
            flags: hasImplicitReturnType isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
          foo2=: #M6
            flags: hasImplicitReturnType isSimplyBounded isStatic
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
          foo3=: #M7
            flags: hasImplicitReturnType isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
          foo4=: #M8
            flags: hasImplicitReturnType isSimplyBounded isStatic
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
    exportedExtensions: #M0
''',
      updatedCode: r'''
extension E on int {
  set foo1(int value) {}
  static set foo2(int value) {}
  static set foo3(int value) {}
  set foo4(int value) {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredExtensions
      E: #M0
        extendedType: int @ dart:core
        declaredFields
          foo1: #M1
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo2: #M2
            flags: isStatic isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo3: #M9
            flags: isStatic isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo4: #M10
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
        declaredSetters
          foo1=: #M5
            flags: hasImplicitReturnType isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
          foo2=: #M6
            flags: hasImplicitReturnType isSimplyBounded isStatic
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
          foo3=: #M11
            flags: hasImplicitReturnType isSimplyBounded isStatic
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
          foo4=: #M12
            flags: hasImplicitReturnType isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
    exportedExtensions: #M0
''',
    );
  }

  test_manifest_extension_typeParameters() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
extension A<T> on int {
  void foo(T _) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredExtensions
      A: #M0
        declaredMethods
          foo: #M1
    exportedExtensions: #M0
''',
      updatedCode: r'''
extension A<T> on int {
  void foo(T _) {}
  void bar(T _) {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredExtensions
      A: #M0
        declaredMethods
          bar: #M2
          foo: #M1
    exportedExtensions: #M0
''',
    );
  }

  test_manifest_extension_typeParameters_add() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
extension A<T> on int {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredExtensions
      A: #M0
    exportedExtensions: #M0
''',
      updatedCode: r'''
extension A<T, U> on int {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredExtensions
      A: #M1
    exportedExtensions: #M1
''',
    );
  }

  test_manifest_extensionType_constructor_idChangesWithContainer() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {}
class B {}
extension type ET(B it) {
  ET.named();
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        interface: #M1
      B: #M2
        interface: #M3
    declaredExtensionTypes
      ET: #M4
        declaredFields
          it: #M5
        declaredGetters
          it: #M6
        declaredConstructors
          named: #M7
        interface: #M8
          map
            it: #M6
          implemented
            it: #M6
''',
      updatedCode: r'''
class A {}
class B extends A {}
extension type ET(B it) {
  ET.named();
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        interface: #M1
      B: #M9
        interface: #M10
    declaredExtensionTypes
      ET: #M11
        declaredFields
          it: #M12
        declaredGetters
          it: #M13
        declaredConstructors
          named: #M14
        interface: #M15
          map
            it: #M13
          implemented
            it: #M13
''',
    );
  }

  test_manifest_extensionType_constructor_modifier_isConst() async {
    configuration.withElementManifests = true;
    await _runLibraryManifestScenario(
      initialCode: r'''
extension type E(int it) {
  E.foo1(this.it);
  const E.foo2(this.it);
  E.foo3(this.it);
  const E.foo4(this.it);
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredExtensionTypes
      E: #M0
        representationType: int @ dart:core
        typeErasure: int @ dart:core
        declaredFields
          it: #M1
            flags: isFinal shouldUseTypeForInitializerInference
            type: int @ dart:core
        declaredGetters
          it: #M2
            flags: isExtensionTypeMember isSimplyBounded isSynthetic
            returnType: int @ dart:core
        declaredConstructors
          foo1: #M3
              flags: hasEnclosingTypeParameterReference isExtensionTypeMember isSimplyBounded
              functionType: FunctionType
                positional
                  required this int @ dart:core
                returnType: E @ package:test/test.dart
          foo2: #M4
              flags: hasEnclosingTypeParameterReference isConst isExtensionTypeMember isSimplyBounded
              functionType: FunctionType
                positional
                  required this int @ dart:core
                returnType: E @ package:test/test.dart
          foo3: #M5
              flags: hasEnclosingTypeParameterReference isExtensionTypeMember isSimplyBounded
              functionType: FunctionType
                positional
                  required this int @ dart:core
                returnType: E @ package:test/test.dart
          foo4: #M6
              flags: hasEnclosingTypeParameterReference isConst isExtensionTypeMember isSimplyBounded
              functionType: FunctionType
                positional
                  required this int @ dart:core
                returnType: E @ package:test/test.dart
        interface: #M7
          map
            it: #M2
          implemented
            it: #M2
''',
      updatedCode: r'''
extension type E(int it) {
  E.foo1(this.it);
  const E.foo2(this.it);
  const E.foo3(this.it);
  E.foo4(this.it);
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredExtensionTypes
      E: #M0
        representationType: int @ dart:core
        typeErasure: int @ dart:core
        declaredFields
          it: #M1
            flags: isFinal shouldUseTypeForInitializerInference
            type: int @ dart:core
        declaredGetters
          it: #M2
            flags: isExtensionTypeMember isSimplyBounded isSynthetic
            returnType: int @ dart:core
        declaredConstructors
          foo1: #M3
              flags: hasEnclosingTypeParameterReference isExtensionTypeMember isSimplyBounded
              functionType: FunctionType
                positional
                  required this int @ dart:core
                returnType: E @ package:test/test.dart
          foo2: #M4
              flags: hasEnclosingTypeParameterReference isConst isExtensionTypeMember isSimplyBounded
              functionType: FunctionType
                positional
                  required this int @ dart:core
                returnType: E @ package:test/test.dart
          foo3: #M8
              flags: hasEnclosingTypeParameterReference isConst isExtensionTypeMember isSimplyBounded
              functionType: FunctionType
                positional
                  required this int @ dart:core
                returnType: E @ package:test/test.dart
          foo4: #M9
              flags: hasEnclosingTypeParameterReference isExtensionTypeMember isSimplyBounded
              functionType: FunctionType
                positional
                  required this int @ dart:core
                returnType: E @ package:test/test.dart
        interface: #M7
          map
            it: #M2
          implemented
            it: #M2
''',
    );
  }

  test_manifest_extensionType_constructor_modifier_isExternal() async {
    configuration.withElementManifests = true;
    await _runLibraryManifestScenario(
      initialCode: r'''
extension type E(int it) {
  E.foo1(this.it);
  external E.foo2(int it);
  E.foo3(this.it);
  external E.foo4(int it);
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredExtensionTypes
      E: #M0
        representationType: int @ dart:core
        typeErasure: int @ dart:core
        declaredFields
          it: #M1
            flags: isFinal shouldUseTypeForInitializerInference
            type: int @ dart:core
        declaredGetters
          it: #M2
            flags: isExtensionTypeMember isSimplyBounded isSynthetic
            returnType: int @ dart:core
        declaredConstructors
          foo1: #M3
              flags: hasEnclosingTypeParameterReference isExtensionTypeMember isSimplyBounded
              functionType: FunctionType
                positional
                  required this int @ dart:core
                returnType: E @ package:test/test.dart
          foo2: #M4
              flags: hasEnclosingTypeParameterReference isExtensionTypeMember isExternal isSimplyBounded
              functionType: FunctionType
                positional
                  required int @ dart:core
                returnType: E @ package:test/test.dart
          foo3: #M5
              flags: hasEnclosingTypeParameterReference isExtensionTypeMember isSimplyBounded
              functionType: FunctionType
                positional
                  required this int @ dart:core
                returnType: E @ package:test/test.dart
          foo4: #M6
              flags: hasEnclosingTypeParameterReference isExtensionTypeMember isExternal isSimplyBounded
              functionType: FunctionType
                positional
                  required int @ dart:core
                returnType: E @ package:test/test.dart
        interface: #M7
          map
            it: #M2
          implemented
            it: #M2
''',
      updatedCode: r'''
extension type E(int it) {
  E.foo1(this.it);
  external E.foo2(int it);
  external E.foo3(int it);
  E.foo4(this.it);
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredExtensionTypes
      E: #M0
        representationType: int @ dart:core
        typeErasure: int @ dart:core
        declaredFields
          it: #M1
            flags: isFinal shouldUseTypeForInitializerInference
            type: int @ dart:core
        declaredGetters
          it: #M2
            flags: isExtensionTypeMember isSimplyBounded isSynthetic
            returnType: int @ dart:core
        declaredConstructors
          foo1: #M3
              flags: hasEnclosingTypeParameterReference isExtensionTypeMember isSimplyBounded
              functionType: FunctionType
                positional
                  required this int @ dart:core
                returnType: E @ package:test/test.dart
          foo2: #M4
              flags: hasEnclosingTypeParameterReference isExtensionTypeMember isExternal isSimplyBounded
              functionType: FunctionType
                positional
                  required int @ dart:core
                returnType: E @ package:test/test.dart
          foo3: #M8
              flags: hasEnclosingTypeParameterReference isExtensionTypeMember isExternal isSimplyBounded
              functionType: FunctionType
                positional
                  required int @ dart:core
                returnType: E @ package:test/test.dart
          foo4: #M9
              flags: hasEnclosingTypeParameterReference isExtensionTypeMember isSimplyBounded
              functionType: FunctionType
                positional
                  required this int @ dart:core
                returnType: E @ package:test/test.dart
        interface: #M7
          map
            it: #M2
          implemented
            it: #M2
''',
    );
  }

  test_manifest_extensionType_constructor_modifier_isFactory() async {
    configuration.withElementManifests = true;
    await _runLibraryManifestScenario(
      initialCode: r'''
extension type E(int it) {
  E.foo1(this.it);
  factory E.foo2(int it) => E(it);
  E.foo3(this.it);
  factory E.foo4(int it) => E(it);
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredExtensionTypes
      E: #M0
        representationType: int @ dart:core
        typeErasure: int @ dart:core
        declaredFields
          it: #M1
            flags: isFinal shouldUseTypeForInitializerInference
            type: int @ dart:core
        declaredGetters
          it: #M2
            flags: isExtensionTypeMember isSimplyBounded isSynthetic
            returnType: int @ dart:core
        declaredConstructors
          foo1: #M3
              flags: hasEnclosingTypeParameterReference isExtensionTypeMember isSimplyBounded
              functionType: FunctionType
                positional
                  required this int @ dart:core
                returnType: E @ package:test/test.dart
          foo2: #M4
              flags: hasEnclosingTypeParameterReference isExtensionTypeMember isFactory isSimplyBounded
              functionType: FunctionType
                positional
                  required int @ dart:core
                returnType: E @ package:test/test.dart
          foo3: #M5
              flags: hasEnclosingTypeParameterReference isExtensionTypeMember isSimplyBounded
              functionType: FunctionType
                positional
                  required this int @ dart:core
                returnType: E @ package:test/test.dart
          foo4: #M6
              flags: hasEnclosingTypeParameterReference isExtensionTypeMember isFactory isSimplyBounded
              functionType: FunctionType
                positional
                  required int @ dart:core
                returnType: E @ package:test/test.dart
        interface: #M7
          map
            it: #M2
          implemented
            it: #M2
''',
      updatedCode: r'''
extension type E(int it) {
  E.foo1(this.it);
  factory E.foo2(int it) => E(it);
  factory E.foo3(int it) => E(it);
  E.foo4(this.it);
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredExtensionTypes
      E: #M0
        representationType: int @ dart:core
        typeErasure: int @ dart:core
        declaredFields
          it: #M1
            flags: isFinal shouldUseTypeForInitializerInference
            type: int @ dart:core
        declaredGetters
          it: #M2
            flags: isExtensionTypeMember isSimplyBounded isSynthetic
            returnType: int @ dart:core
        declaredConstructors
          foo1: #M3
              flags: hasEnclosingTypeParameterReference isExtensionTypeMember isSimplyBounded
              functionType: FunctionType
                positional
                  required this int @ dart:core
                returnType: E @ package:test/test.dart
          foo2: #M4
              flags: hasEnclosingTypeParameterReference isExtensionTypeMember isFactory isSimplyBounded
              functionType: FunctionType
                positional
                  required int @ dart:core
                returnType: E @ package:test/test.dart
          foo3: #M8
              flags: hasEnclosingTypeParameterReference isExtensionTypeMember isFactory isSimplyBounded
              functionType: FunctionType
                positional
                  required int @ dart:core
                returnType: E @ package:test/test.dart
          foo4: #M9
              flags: hasEnclosingTypeParameterReference isExtensionTypeMember isSimplyBounded
              functionType: FunctionType
                positional
                  required this int @ dart:core
                returnType: E @ package:test/test.dart
        interface: #M7
          map
            it: #M2
          implemented
            it: #M2
''',
    );
  }

  test_manifest_extensionType_getter() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
extension type A(int it) {
  int get foo {}
  int get bar {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredExtensionTypes
      A: #M0
        declaredFields
          bar: #M1
          foo: #M2
          it: #M3
        declaredGetters
          bar: #M4
          foo: #M5
          it: #M6
        interface: #M7
          map
            bar: #M4
            foo: #M5
            it: #M6
          implemented
            bar: #M4
            foo: #M5
            it: #M6
''',
      updatedCode: r'''
extension type A(int it) {
  int get foo {}
  double get bar {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredExtensionTypes
      A: #M0
        declaredFields
          bar: #M8
          foo: #M2
          it: #M3
        declaredGetters
          bar: #M9
          foo: #M5
          it: #M6
        interface: #M10
          map
            bar: #M9
            foo: #M5
            it: #M6
          implemented
            bar: #M9
            foo: #M5
            it: #M6
''',
    );
  }

  test_manifest_extensionType_getter_idChangesWithContainer() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {}
class B {}
extension type ET(B it) {
  int get foo => 0;
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        interface: #M1
      B: #M2
        interface: #M3
    declaredExtensionTypes
      ET: #M4
        declaredFields
          foo: #M5
          it: #M6
        declaredGetters
          foo: #M7
          it: #M8
        interface: #M9
          map
            foo: #M7
            it: #M8
          implemented
            foo: #M7
            it: #M8
''',
      updatedCode: r'''
class A {}
class B extends A {}
extension type ET(B it) {
  int get foo => 0;
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        interface: #M1
      B: #M10
        interface: #M11
    declaredExtensionTypes
      ET: #M12
        declaredFields
          foo: #M13
          it: #M14
        declaredGetters
          foo: #M15
          it: #M16
        interface: #M17
          map
            foo: #M15
            it: #M16
          implemented
            foo: #M15
            it: #M16
''',
    );
  }

  test_manifest_extensionType_getter_modifier_hasEnclosingTypeParameterReference() async {
    configuration.withElementManifests = true;
    await _runLibraryManifestScenario(
      initialCode: r'''
extension type E<T>(T it) {
  T get foo1 => throw 0;
  int get foo2 => 0;
  T get foo3 => throw 0;
  int get foo4 => 0;
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredExtensionTypes
      E: #M0
        typeParameters
          #0 covariant
            bound: <null>
        representationType: typeParameter#0
        typeErasure: typeParameter#0
        declaredFields
          foo1: #M1
            flags: hasEnclosingTypeParameterReference isSynthetic shouldUseTypeForInitializerInference
            type: typeParameter#0
          foo2: #M2
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo3: #M3
            flags: hasEnclosingTypeParameterReference isSynthetic shouldUseTypeForInitializerInference
            type: typeParameter#0
          foo4: #M4
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          it: #M5
            flags: hasEnclosingTypeParameterReference isFinal shouldUseTypeForInitializerInference
            type: typeParameter#0
        declaredGetters
          foo1: #M6
            flags: hasEnclosingTypeParameterReference isExtensionTypeMember isSimplyBounded
            returnType: typeParameter#0
          foo2: #M7
            flags: isExtensionTypeMember isSimplyBounded
            returnType: int @ dart:core
          foo3: #M8
            flags: hasEnclosingTypeParameterReference isExtensionTypeMember isSimplyBounded
            returnType: typeParameter#0
          foo4: #M9
            flags: isExtensionTypeMember isSimplyBounded
            returnType: int @ dart:core
          it: #M10
            flags: hasEnclosingTypeParameterReference isExtensionTypeMember isSimplyBounded isSynthetic
            returnType: typeParameter#0
        interface: #M11
          map
            foo1: #M6
            foo2: #M7
            foo3: #M8
            foo4: #M9
            it: #M10
          implemented
            foo1: #M6
            foo2: #M7
            foo3: #M8
            foo4: #M9
            it: #M10
''',
      updatedCode: r'''
extension type E<T>(T it) {
  T get foo1 => throw 0;
  int get foo2 => 0;
  int get foo3 => 0;
  T get foo4 => throw 0;
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredExtensionTypes
      E: #M0
        typeParameters
          #0 covariant
            bound: <null>
        representationType: typeParameter#0
        typeErasure: typeParameter#0
        declaredFields
          foo1: #M1
            flags: hasEnclosingTypeParameterReference isSynthetic shouldUseTypeForInitializerInference
            type: typeParameter#0
          foo2: #M2
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo3: #M12
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo4: #M13
            flags: hasEnclosingTypeParameterReference isSynthetic shouldUseTypeForInitializerInference
            type: typeParameter#0
          it: #M5
            flags: hasEnclosingTypeParameterReference isFinal shouldUseTypeForInitializerInference
            type: typeParameter#0
        declaredGetters
          foo1: #M6
            flags: hasEnclosingTypeParameterReference isExtensionTypeMember isSimplyBounded
            returnType: typeParameter#0
          foo2: #M7
            flags: isExtensionTypeMember isSimplyBounded
            returnType: int @ dart:core
          foo3: #M14
            flags: isExtensionTypeMember isSimplyBounded
            returnType: int @ dart:core
          foo4: #M15
            flags: hasEnclosingTypeParameterReference isExtensionTypeMember isSimplyBounded
            returnType: typeParameter#0
          it: #M10
            flags: hasEnclosingTypeParameterReference isExtensionTypeMember isSimplyBounded isSynthetic
            returnType: typeParameter#0
        interface: #M16
          map
            foo1: #M6
            foo2: #M7
            foo3: #M14
            foo4: #M15
            it: #M10
          implemented
            foo1: #M6
            foo2: #M7
            foo3: #M14
            foo4: #M15
            it: #M10
''',
    );
  }

  test_manifest_extensionType_getter_modifier_hasImplicitReturnType() async {
    configuration.withElementManifests = true;
    await _runLibraryManifestScenario(
      initialCode: r'''
extension type E(int it) {
  get foo1 => 0;
  int get foo2 => 0;
  get foo3 => 0;
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredExtensionTypes
      E: #M0
        representationType: int @ dart:core
        typeErasure: int @ dart:core
        declaredFields
          foo1: #M1
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: dynamic
          foo2: #M2
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo3: #M3
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: dynamic
          it: #M4
            flags: isFinal shouldUseTypeForInitializerInference
            type: int @ dart:core
        declaredGetters
          foo1: #M5
            flags: hasImplicitReturnType isExtensionTypeMember isSimplyBounded
            returnType: dynamic
          foo2: #M6
            flags: isExtensionTypeMember isSimplyBounded
            returnType: int @ dart:core
          foo3: #M7
            flags: hasImplicitReturnType isExtensionTypeMember isSimplyBounded
            returnType: dynamic
          it: #M8
            flags: isExtensionTypeMember isSimplyBounded isSynthetic
            returnType: int @ dart:core
        interface: #M9
          map
            foo1: #M5
            foo2: #M6
            foo3: #M7
            it: #M8
          implemented
            foo1: #M5
            foo2: #M6
            foo3: #M7
            it: #M8
''',
      updatedCode: r'''
extension type E(int it) {
  get foo1 => 0;
  get foo2 => 0;
  int get foo3 => 0;
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredExtensionTypes
      E: #M0
        representationType: int @ dart:core
        typeErasure: int @ dart:core
        declaredFields
          foo1: #M1
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: dynamic
          foo2: #M10
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: dynamic
          foo3: #M11
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          it: #M4
            flags: isFinal shouldUseTypeForInitializerInference
            type: int @ dart:core
        declaredGetters
          foo1: #M5
            flags: hasImplicitReturnType isExtensionTypeMember isSimplyBounded
            returnType: dynamic
          foo2: #M12
            flags: hasImplicitReturnType isExtensionTypeMember isSimplyBounded
            returnType: dynamic
          foo3: #M13
            flags: isExtensionTypeMember isSimplyBounded
            returnType: int @ dart:core
          it: #M8
            flags: isExtensionTypeMember isSimplyBounded isSynthetic
            returnType: int @ dart:core
        interface: #M14
          map
            foo1: #M5
            foo2: #M12
            foo3: #M13
            it: #M8
          implemented
            foo1: #M5
            foo2: #M12
            foo3: #M13
            it: #M8
''',
    );
  }

  test_manifest_extensionType_getter_modifier_isExternal() async {
    configuration.withElementManifests = true;
    await _runLibraryManifestScenario(
      initialCode: r'''
extension type E(int it) {
  int get foo1 => 1;
  external int get foo2;
  int get foo3 => 3;
  external int get foo4;
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredExtensionTypes
      E: #M0
        representationType: int @ dart:core
        typeErasure: int @ dart:core
        declaredFields
          foo1: #M1
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo2: #M2
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo3: #M3
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo4: #M4
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          it: #M5
            flags: isFinal shouldUseTypeForInitializerInference
            type: int @ dart:core
        declaredGetters
          foo1: #M6
            flags: isExtensionTypeMember isSimplyBounded
            returnType: int @ dart:core
          foo2: #M7
            flags: isExtensionTypeMember isExternal isSimplyBounded
            returnType: int @ dart:core
          foo3: #M8
            flags: isExtensionTypeMember isSimplyBounded
            returnType: int @ dart:core
          foo4: #M9
            flags: isExtensionTypeMember isExternal isSimplyBounded
            returnType: int @ dart:core
          it: #M10
            flags: isExtensionTypeMember isSimplyBounded isSynthetic
            returnType: int @ dart:core
        interface: #M11
          map
            foo1: #M6
            foo2: #M7
            foo3: #M8
            foo4: #M9
            it: #M10
          implemented
            foo1: #M6
            foo2: #M7
            foo3: #M8
            foo4: #M9
            it: #M10
''',
      updatedCode: r'''
extension type E(int it) {
  int get foo1 => 1;
  external int get foo2;
  external int get foo3;
  int get foo4 => 4;
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredExtensionTypes
      E: #M0
        representationType: int @ dart:core
        typeErasure: int @ dart:core
        declaredFields
          foo1: #M1
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo2: #M2
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo3: #M3
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo4: #M4
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          it: #M5
            flags: isFinal shouldUseTypeForInitializerInference
            type: int @ dart:core
        declaredGetters
          foo1: #M6
            flags: isExtensionTypeMember isSimplyBounded
            returnType: int @ dart:core
          foo2: #M7
            flags: isExtensionTypeMember isExternal isSimplyBounded
            returnType: int @ dart:core
          foo3: #M12
            flags: isExtensionTypeMember isExternal isSimplyBounded
            returnType: int @ dart:core
          foo4: #M13
            flags: isExtensionTypeMember isSimplyBounded
            returnType: int @ dart:core
          it: #M10
            flags: isExtensionTypeMember isSimplyBounded isSynthetic
            returnType: int @ dart:core
        interface: #M14
          map
            foo1: #M6
            foo2: #M7
            foo3: #M12
            foo4: #M13
            it: #M10
          implemented
            foo1: #M6
            foo2: #M7
            foo3: #M12
            foo4: #M13
            it: #M10
''',
    );
  }

  test_manifest_extensionType_getter_modifier_isStatic() async {
    configuration.withElementManifests = true;
    await _runLibraryManifestScenario(
      initialCode: r'''
extension type E(int it) {
  int get foo1 => 1;
  static int get foo2 => 2;
  int get foo3 => 3;
  static int get foo4 => 4;
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredExtensionTypes
      E: #M0
        representationType: int @ dart:core
        typeErasure: int @ dart:core
        declaredFields
          foo1: #M1
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo2: #M2
            flags: isStatic isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo3: #M3
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo4: #M4
            flags: isStatic isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          it: #M5
            flags: isFinal shouldUseTypeForInitializerInference
            type: int @ dart:core
        declaredGetters
          foo1: #M6
            flags: isExtensionTypeMember isSimplyBounded
            returnType: int @ dart:core
          foo2: #M7
            flags: isExtensionTypeMember isSimplyBounded isStatic
            returnType: int @ dart:core
          foo3: #M8
            flags: isExtensionTypeMember isSimplyBounded
            returnType: int @ dart:core
          foo4: #M9
            flags: isExtensionTypeMember isSimplyBounded isStatic
            returnType: int @ dart:core
          it: #M10
            flags: isExtensionTypeMember isSimplyBounded isSynthetic
            returnType: int @ dart:core
        interface: #M11
          map
            foo1: #M6
            foo3: #M8
            it: #M10
          implemented
            foo1: #M6
            foo3: #M8
            it: #M10
''',
      updatedCode: r'''
extension type E(int it) {
  int get foo1 => 1;
  static int get foo2 => 2;
  static int get foo3 => 3;
  int get foo4 => 4;
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredExtensionTypes
      E: #M0
        representationType: int @ dart:core
        typeErasure: int @ dart:core
        declaredFields
          foo1: #M1
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo2: #M2
            flags: isStatic isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo3: #M12
            flags: isStatic isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo4: #M13
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          it: #M5
            flags: isFinal shouldUseTypeForInitializerInference
            type: int @ dart:core
        declaredGetters
          foo1: #M6
            flags: isExtensionTypeMember isSimplyBounded
            returnType: int @ dart:core
          foo2: #M7
            flags: isExtensionTypeMember isSimplyBounded isStatic
            returnType: int @ dart:core
          foo3: #M14
            flags: isExtensionTypeMember isSimplyBounded isStatic
            returnType: int @ dart:core
          foo4: #M15
            flags: isExtensionTypeMember isSimplyBounded
            returnType: int @ dart:core
          it: #M10
            flags: isExtensionTypeMember isSimplyBounded isSynthetic
            returnType: int @ dart:core
        interface: #M16
          map
            foo1: #M6
            foo4: #M15
            it: #M10
          implemented
            foo1: #M6
            foo4: #M15
            it: #M10
''',
    );
  }

  test_manifest_extensionType_hasImplementsSelfReference() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
extension type A(int it) implements Object {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredExtensionTypes
      A: #M0
        declaredFields
          it: #M1
        declaredGetters
          it: #M2
        interface: #M3
          map
            it: #M2
          implemented
            it: #M2
''',
      updatedCode: r'''
extension type A(int it) implements A {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredExtensionTypes
      A: #M4
        declaredFields
          it: #M5
        declaredGetters
          it: #M6
        interface: #M7
          map
            it: #M6
          implemented
            it: #M6
''',
    );
  }

  test_manifest_extensionType_hasRepresentationSelfReference() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
extension type A(NoSuchType it) {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredExtensionTypes
      A: #M0
        declaredFields
          it: #M1
        declaredGetters
          it: #M2
        interface: #M3
          map
            it: #M2
          implemented
            it: #M2
''',
      updatedCode: r'''
extension type A(A it) {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredExtensionTypes
      A: #M4
        declaredFields
          it: #M5
        declaredGetters
          it: #M6
        interface: #M7
          map
            it: #M6
          implemented
            it: #M6
''',
    );
  }

  test_manifest_extensionType_implements_add() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
extension type A(int it) {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredExtensionTypes
      A: #M0
        declaredFields
          it: #M1
        declaredGetters
          it: #M2
        interface: #M3
          map
            it: #M2
          implemented
            it: #M2
''',
      updatedCode: r'''
extension type A(int it) implements Object {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredExtensionTypes
      A: #M4
        declaredFields
          it: #M5
        declaredGetters
          it: #M6
        interface: #M7
          map
            it: #M6
          implemented
            it: #M6
''',
    );
  }

  test_manifest_extensionType_implements_remove() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
extension type A(int it) implements Object {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredExtensionTypes
      A: #M0
        declaredFields
          it: #M1
        declaredGetters
          it: #M2
        interface: #M3
          map
            it: #M2
          implemented
            it: #M2
''',
      updatedCode: r'''
extension type A(int it) {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredExtensionTypes
      A: #M4
        declaredFields
          it: #M5
        declaredGetters
          it: #M6
        interface: #M7
          map
            it: #M6
          implemented
            it: #M6
''',
    );
  }

  test_manifest_extensionType_metadata() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
@Deprecated('0')
extension type A(int it) {}

@Deprecated('0')
extension type B(int it) {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredExtensionTypes
      A: #M0
        declaredFields
          it: #M1
        declaredGetters
          it: #M2
        interface: #M3
          map
            it: #M2
          implemented
            it: #M2
      B: #M4
        declaredFields
          it: #M5
        declaredGetters
          it: #M6
        interface: #M7
          map
            it: #M6
          implemented
            it: #M6
''',
      updatedCode: r'''
@Deprecated('0')
extension type A(int it) {}

@Deprecated('1')
extension type B(int it) {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredExtensionTypes
      A: #M0
        declaredFields
          it: #M1
        declaredGetters
          it: #M2
        interface: #M3
          map
            it: #M2
          implemented
            it: #M2
      B: #M8
        declaredFields
          it: #M9
        declaredGetters
          it: #M10
        interface: #M11
          map
            it: #M10
          implemented
            it: #M10
''',
    );
  }

  test_manifest_extensionType_method() async {
    configuration.withElementManifests = true;
    await _runLibraryManifestScenario(
      initialCode: r'''
extension type A(int it) {
  int foo() {}
  int bar() {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredExtensionTypes
      A: #M0
        representationType: int @ dart:core
        typeErasure: int @ dart:core
        declaredFields
          it: #M1
            flags: isFinal shouldUseTypeForInitializerInference
            type: int @ dart:core
        declaredGetters
          it: #M2
            flags: isExtensionTypeMember isSimplyBounded isSynthetic
            returnType: int @ dart:core
        declaredMethods
          bar: #M3
            flags: isExtensionTypeMember isSimplyBounded
            functionType: FunctionType
              returnType: int @ dart:core
          foo: #M4
            flags: isExtensionTypeMember isSimplyBounded
            functionType: FunctionType
              returnType: int @ dart:core
        interface: #M5
          map
            bar: #M3
            foo: #M4
            it: #M2
          implemented
            bar: #M3
            foo: #M4
            it: #M2
''',
      updatedCode: r'''
extension type A(int it) {
  int foo() {}
  double bar() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredExtensionTypes
      A: #M0
        representationType: int @ dart:core
        typeErasure: int @ dart:core
        declaredFields
          it: #M1
            flags: isFinal shouldUseTypeForInitializerInference
            type: int @ dart:core
        declaredGetters
          it: #M2
            flags: isExtensionTypeMember isSimplyBounded isSynthetic
            returnType: int @ dart:core
        declaredMethods
          bar: #M6
            flags: isExtensionTypeMember isSimplyBounded
            functionType: FunctionType
              returnType: double @ dart:core
          foo: #M4
            flags: isExtensionTypeMember isSimplyBounded
            functionType: FunctionType
              returnType: int @ dart:core
        interface: #M7
          map
            bar: #M6
            foo: #M4
            it: #M2
          implemented
            bar: #M6
            foo: #M4
            it: #M2
''',
    );
  }

  test_manifest_extensionType_method_idChangesWithContainer() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {}
class B {}
extension type ET(B it) {
  void foo() {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        interface: #M1
      B: #M2
        interface: #M3
    declaredExtensionTypes
      ET: #M4
        declaredFields
          it: #M5
        declaredGetters
          it: #M6
        declaredMethods
          foo: #M7
        interface: #M8
          map
            foo: #M7
            it: #M6
          implemented
            foo: #M7
            it: #M6
''',
      updatedCode: r'''
class A {}
class B extends A {}
extension type ET(B it) {
  void foo() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        interface: #M1
      B: #M9
        interface: #M10
    declaredExtensionTypes
      ET: #M11
        declaredFields
          it: #M12
        declaredGetters
          it: #M13
        declaredMethods
          foo: #M14
        interface: #M15
          map
            foo: #M14
            it: #M13
          implemented
            foo: #M14
            it: #M13
''',
    );
  }

  test_manifest_extensionType_method_modifier_hasEnclosingTypeParameterReference() async {
    configuration.withElementManifests = true;
    await _runLibraryManifestScenario(
      initialCode: r'''
extension type E<T>(T it) {
  T foo1() => throw 0;
  void foo2() {}
  T foo3() => throw 0;
  void foo4() {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredExtensionTypes
      E: #M0
        typeParameters
          #0 covariant
            bound: <null>
        representationType: typeParameter#0
        typeErasure: typeParameter#0
        declaredFields
          it: #M1
            flags: hasEnclosingTypeParameterReference isFinal shouldUseTypeForInitializerInference
            type: typeParameter#0
        declaredGetters
          it: #M2
            flags: hasEnclosingTypeParameterReference isExtensionTypeMember isSimplyBounded isSynthetic
            returnType: typeParameter#0
        declaredMethods
          foo1: #M3
            flags: hasEnclosingTypeParameterReference isExtensionTypeMember isSimplyBounded
            functionType: FunctionType
              returnType: typeParameter#0
          foo2: #M4
            flags: isExtensionTypeMember isSimplyBounded
            functionType: FunctionType
              returnType: void
          foo3: #M5
            flags: hasEnclosingTypeParameterReference isExtensionTypeMember isSimplyBounded
            functionType: FunctionType
              returnType: typeParameter#0
          foo4: #M6
            flags: isExtensionTypeMember isSimplyBounded
            functionType: FunctionType
              returnType: void
        interface: #M7
          map
            foo1: #M3
            foo2: #M4
            foo3: #M5
            foo4: #M6
            it: #M2
          implemented
            foo1: #M3
            foo2: #M4
            foo3: #M5
            foo4: #M6
            it: #M2
''',
      updatedCode: r'''
extension type E<T>(T it) {
  T foo1() => throw 0;
  void foo2() {}
  void foo3() {}
  T foo4() => throw 0;
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredExtensionTypes
      E: #M0
        typeParameters
          #0 covariant
            bound: <null>
        representationType: typeParameter#0
        typeErasure: typeParameter#0
        declaredFields
          it: #M1
            flags: hasEnclosingTypeParameterReference isFinal shouldUseTypeForInitializerInference
            type: typeParameter#0
        declaredGetters
          it: #M2
            flags: hasEnclosingTypeParameterReference isExtensionTypeMember isSimplyBounded isSynthetic
            returnType: typeParameter#0
        declaredMethods
          foo1: #M3
            flags: hasEnclosingTypeParameterReference isExtensionTypeMember isSimplyBounded
            functionType: FunctionType
              returnType: typeParameter#0
          foo2: #M4
            flags: isExtensionTypeMember isSimplyBounded
            functionType: FunctionType
              returnType: void
          foo3: #M8
            flags: isExtensionTypeMember isSimplyBounded
            functionType: FunctionType
              returnType: void
          foo4: #M9
            flags: hasEnclosingTypeParameterReference isExtensionTypeMember isSimplyBounded
            functionType: FunctionType
              returnType: typeParameter#0
        interface: #M10
          map
            foo1: #M3
            foo2: #M4
            foo3: #M8
            foo4: #M9
            it: #M2
          implemented
            foo1: #M3
            foo2: #M4
            foo3: #M8
            foo4: #M9
            it: #M2
''',
    );
  }

  test_manifest_extensionType_method_modifier_hasImplicitReturnType() async {
    configuration.withElementManifests = true;
    await _runLibraryManifestScenario(
      initialCode: r'''
extension type E(int it) {
  foo1() {}
  void foo2() {}
  foo3() {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredExtensionTypes
      E: #M0
        representationType: int @ dart:core
        typeErasure: int @ dart:core
        declaredFields
          it: #M1
            flags: isFinal shouldUseTypeForInitializerInference
            type: int @ dart:core
        declaredGetters
          it: #M2
            flags: isExtensionTypeMember isSimplyBounded isSynthetic
            returnType: int @ dart:core
        declaredMethods
          foo1: #M3
            flags: hasImplicitReturnType isExtensionTypeMember isSimplyBounded
            functionType: FunctionType
              returnType: dynamic
          foo2: #M4
            flags: isExtensionTypeMember isSimplyBounded
            functionType: FunctionType
              returnType: void
          foo3: #M5
            flags: hasImplicitReturnType isExtensionTypeMember isSimplyBounded
            functionType: FunctionType
              returnType: dynamic
        interface: #M6
          map
            foo1: #M3
            foo2: #M4
            foo3: #M5
            it: #M2
          implemented
            foo1: #M3
            foo2: #M4
            foo3: #M5
            it: #M2
''',
      updatedCode: r'''
extension type E(int it) {
  foo1() {}
  foo2() {}
  void foo3() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredExtensionTypes
      E: #M0
        representationType: int @ dart:core
        typeErasure: int @ dart:core
        declaredFields
          it: #M1
            flags: isFinal shouldUseTypeForInitializerInference
            type: int @ dart:core
        declaredGetters
          it: #M2
            flags: isExtensionTypeMember isSimplyBounded isSynthetic
            returnType: int @ dart:core
        declaredMethods
          foo1: #M3
            flags: hasImplicitReturnType isExtensionTypeMember isSimplyBounded
            functionType: FunctionType
              returnType: dynamic
          foo2: #M7
            flags: hasImplicitReturnType isExtensionTypeMember isSimplyBounded
            functionType: FunctionType
              returnType: dynamic
          foo3: #M8
            flags: isExtensionTypeMember isSimplyBounded
            functionType: FunctionType
              returnType: void
        interface: #M9
          map
            foo1: #M3
            foo2: #M7
            foo3: #M8
            it: #M2
          implemented
            foo1: #M3
            foo2: #M7
            foo3: #M8
            it: #M2
''',
    );
  }

  test_manifest_extensionType_method_modifier_isExternal() async {
    configuration.withElementManifests = true;
    await _runLibraryManifestScenario(
      initialCode: r'''
extension type E(int it) {
  void foo1() {}
  external void foo2();
  void foo3() {}
  external void foo4();
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredExtensionTypes
      E: #M0
        representationType: int @ dart:core
        typeErasure: int @ dart:core
        declaredFields
          it: #M1
            flags: isFinal shouldUseTypeForInitializerInference
            type: int @ dart:core
        declaredGetters
          it: #M2
            flags: isExtensionTypeMember isSimplyBounded isSynthetic
            returnType: int @ dart:core
        declaredMethods
          foo1: #M3
            flags: isExtensionTypeMember isSimplyBounded
            functionType: FunctionType
              returnType: void
          foo2: #M4
            flags: isExtensionTypeMember isExternal isSimplyBounded
            functionType: FunctionType
              returnType: void
          foo3: #M5
            flags: isExtensionTypeMember isSimplyBounded
            functionType: FunctionType
              returnType: void
          foo4: #M6
            flags: isExtensionTypeMember isExternal isSimplyBounded
            functionType: FunctionType
              returnType: void
        interface: #M7
          map
            foo1: #M3
            foo2: #M4
            foo3: #M5
            foo4: #M6
            it: #M2
          implemented
            foo1: #M3
            foo2: #M4
            foo3: #M5
            foo4: #M6
            it: #M2
''',
      updatedCode: r'''
extension type E(int it) {
  void foo1() {}
  external void foo2();
  external void foo3();
  void foo4() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredExtensionTypes
      E: #M0
        representationType: int @ dart:core
        typeErasure: int @ dart:core
        declaredFields
          it: #M1
            flags: isFinal shouldUseTypeForInitializerInference
            type: int @ dart:core
        declaredGetters
          it: #M2
            flags: isExtensionTypeMember isSimplyBounded isSynthetic
            returnType: int @ dart:core
        declaredMethods
          foo1: #M3
            flags: isExtensionTypeMember isSimplyBounded
            functionType: FunctionType
              returnType: void
          foo2: #M4
            flags: isExtensionTypeMember isExternal isSimplyBounded
            functionType: FunctionType
              returnType: void
          foo3: #M8
            flags: isExtensionTypeMember isExternal isSimplyBounded
            functionType: FunctionType
              returnType: void
          foo4: #M9
            flags: isExtensionTypeMember isSimplyBounded
            functionType: FunctionType
              returnType: void
        interface: #M10
          map
            foo1: #M3
            foo2: #M4
            foo3: #M8
            foo4: #M9
            it: #M2
          implemented
            foo1: #M3
            foo2: #M4
            foo3: #M8
            foo4: #M9
            it: #M2
''',
    );
  }

  test_manifest_extensionType_method_modifier_isStatic() async {
    configuration.withElementManifests = true;
    await _runLibraryManifestScenario(
      initialCode: r'''
extension type E(int it) {
  void foo1() {}
  static void foo2() {}
  void foo3() {}
  static void foo4() {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredExtensionTypes
      E: #M0
        representationType: int @ dart:core
        typeErasure: int @ dart:core
        declaredFields
          it: #M1
            flags: isFinal shouldUseTypeForInitializerInference
            type: int @ dart:core
        declaredGetters
          it: #M2
            flags: isExtensionTypeMember isSimplyBounded isSynthetic
            returnType: int @ dart:core
        declaredMethods
          foo1: #M3
            flags: isExtensionTypeMember isSimplyBounded
            functionType: FunctionType
              returnType: void
          foo2: #M4
            flags: isExtensionTypeMember isSimplyBounded isStatic
            functionType: FunctionType
              returnType: void
          foo3: #M5
            flags: isExtensionTypeMember isSimplyBounded
            functionType: FunctionType
              returnType: void
          foo4: #M6
            flags: isExtensionTypeMember isSimplyBounded isStatic
            functionType: FunctionType
              returnType: void
        interface: #M7
          map
            foo1: #M3
            foo3: #M5
            it: #M2
          implemented
            foo1: #M3
            foo3: #M5
            it: #M2
''',
      updatedCode: r'''
extension type E(int it) {
  void foo1() {}
  static void foo2() {}
  static void foo3() {}
  void foo4() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredExtensionTypes
      E: #M0
        representationType: int @ dart:core
        typeErasure: int @ dart:core
        declaredFields
          it: #M1
            flags: isFinal shouldUseTypeForInitializerInference
            type: int @ dart:core
        declaredGetters
          it: #M2
            flags: isExtensionTypeMember isSimplyBounded isSynthetic
            returnType: int @ dart:core
        declaredMethods
          foo1: #M3
            flags: isExtensionTypeMember isSimplyBounded
            functionType: FunctionType
              returnType: void
          foo2: #M4
            flags: isExtensionTypeMember isSimplyBounded isStatic
            functionType: FunctionType
              returnType: void
          foo3: #M8
            flags: isExtensionTypeMember isSimplyBounded isStatic
            functionType: FunctionType
              returnType: void
          foo4: #M9
            flags: isExtensionTypeMember isSimplyBounded
            functionType: FunctionType
              returnType: void
        interface: #M10
          map
            foo1: #M3
            foo4: #M9
            it: #M2
          implemented
            foo1: #M3
            foo4: #M9
            it: #M2
''',
    );
  }

  test_manifest_extensionType_representation_constructorName() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
extension type A.foo(int it) {
  void baz() {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredExtensionTypes
      A: #M0
        declaredFields
          it: #M1
        declaredGetters
          it: #M2
        declaredMethods
          baz: #M3
        declaredConstructors
          foo: #M4
        interface: #M5
          map
            baz: #M3
            it: #M2
          implemented
            baz: #M3
            it: #M2
''',
      updatedCode: r'''
extension type A.bar(int it) {
  void baz() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredExtensionTypes
      A: #M0
        declaredFields
          it: #M1
        declaredGetters
          it: #M2
        declaredMethods
          baz: #M3
        declaredConstructors
          bar: #M6
        interface: #M5
          map
            baz: #M3
            it: #M2
          implemented
            baz: #M3
            it: #M2
''',
    );
  }

  test_manifest_extensionType_representation_field_name() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
extension type A(int it) {
  void foo() {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredExtensionTypes
      A: #M0
        declaredFields
          it: #M1
        declaredGetters
          it: #M2
        declaredMethods
          foo: #M3
        interface: #M4
          map
            foo: #M3
            it: #M2
          implemented
            foo: #M3
            it: #M2
''',
      updatedCode: r'''
extension type A(int _it) {
  void foo() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredExtensionTypes
      A: #M0
        declaredFields
          _it: #M5
        declaredGetters
          _it: #M6
        declaredMethods
          foo: #M3
        interface: #M7
          map
            foo: #M3
          implemented
            foo: #M3
''',
    );
  }

  test_manifest_extensionType_representation_field_type() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
extension type A(int it) {
  void foo() {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredExtensionTypes
      A: #M0
        declaredFields
          it: #M1
        declaredGetters
          it: #M2
        declaredMethods
          foo: #M3
        interface: #M4
          map
            foo: #M3
            it: #M2
          implemented
            foo: #M3
            it: #M2
''',
      updatedCode: r'''
extension type A(double it) {
  void foo() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredExtensionTypes
      A: #M5
        declaredFields
          it: #M6
        declaredGetters
          it: #M7
        declaredMethods
          foo: #M8
        interface: #M9
          map
            foo: #M8
            it: #M7
          implemented
            foo: #M8
            it: #M7
''',
    );
  }

  test_manifest_extensionType_setter() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
extension type A(int it) {
  set foo(int _) {}
  set bar(int _) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredExtensionTypes
      A: #M0
        declaredFields
          bar: #M1
          foo: #M2
          it: #M3
        declaredGetters
          it: #M4
        declaredSetters
          bar=: #M5
          foo=: #M6
        interface: #M7
          map
            bar=: #M5
            foo=: #M6
            it: #M4
          implemented
            bar=: #M5
            foo=: #M6
            it: #M4
''',
      updatedCode: r'''
extension type A(int it) {
  set foo(int _) {}
  set bar(double _) {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredExtensionTypes
      A: #M0
        declaredFields
          bar: #M8
          foo: #M2
          it: #M3
        declaredGetters
          it: #M4
        declaredSetters
          bar=: #M9
          foo=: #M6
        interface: #M10
          map
            bar=: #M9
            foo=: #M6
            it: #M4
          implemented
            bar=: #M9
            foo=: #M6
            it: #M4
''',
    );
  }

  test_manifest_extensionType_setter_idChangesWithContainer() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {}
class B {}
extension type ET(B it) {
  void set foo(int _) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        interface: #M1
      B: #M2
        interface: #M3
    declaredExtensionTypes
      ET: #M4
        declaredFields
          foo: #M5
          it: #M6
        declaredGetters
          it: #M7
        declaredSetters
          foo=: #M8
        interface: #M9
          map
            foo=: #M8
            it: #M7
          implemented
            foo=: #M8
            it: #M7
''',
      updatedCode: r'''
class A {}
class B extends A {}
extension type ET(B it) {
  void set foo(int _) {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        interface: #M1
      B: #M10
        interface: #M11
    declaredExtensionTypes
      ET: #M12
        declaredFields
          foo: #M13
          it: #M14
        declaredGetters
          it: #M15
        declaredSetters
          foo=: #M16
        interface: #M17
          map
            foo=: #M16
            it: #M15
          implemented
            foo=: #M16
            it: #M15
''',
    );
  }

  test_manifest_extensionType_setter_modifier_hasEnclosingTypeParameterReference() async {
    configuration.withElementManifests = true;
    await _runLibraryManifestScenario(
      initialCode: r'''
extension type E<T>(T it) {
  set foo1(T value) {}
  set foo2(int value) {}
  set foo3(T value) {}
  set foo4(int value) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredExtensionTypes
      E: #M0
        typeParameters
          #0 covariant
            bound: <null>
        representationType: typeParameter#0
        typeErasure: typeParameter#0
        declaredFields
          foo1: #M1
            flags: hasEnclosingTypeParameterReference isSynthetic shouldUseTypeForInitializerInference
            type: typeParameter#0
          foo2: #M2
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo3: #M3
            flags: hasEnclosingTypeParameterReference isSynthetic shouldUseTypeForInitializerInference
            type: typeParameter#0
          foo4: #M4
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          it: #M5
            flags: hasEnclosingTypeParameterReference isFinal shouldUseTypeForInitializerInference
            type: typeParameter#0
        declaredGetters
          it: #M6
            flags: hasEnclosingTypeParameterReference isExtensionTypeMember isSimplyBounded isSynthetic
            returnType: typeParameter#0
        declaredSetters
          foo1=: #M7
            flags: hasEnclosingTypeParameterReference hasImplicitReturnType isExtensionTypeMember isSimplyBounded
            functionType: FunctionType
              positional
                required typeParameter#0
              returnType: void
          foo2=: #M8
            flags: hasImplicitReturnType isExtensionTypeMember isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
          foo3=: #M9
            flags: hasEnclosingTypeParameterReference hasImplicitReturnType isExtensionTypeMember isSimplyBounded
            functionType: FunctionType
              positional
                required typeParameter#0
              returnType: void
          foo4=: #M10
            flags: hasImplicitReturnType isExtensionTypeMember isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
        interface: #M11
          map
            foo1=: #M7
            foo2=: #M8
            foo3=: #M9
            foo4=: #M10
            it: #M6
          implemented
            foo1=: #M7
            foo2=: #M8
            foo3=: #M9
            foo4=: #M10
            it: #M6
''',
      updatedCode: r'''
extension type E<T>(T it) {
  set foo1(T value) {}
  set foo2(int value) {}
  set foo3(int value) {}
  set foo4(T value) {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredExtensionTypes
      E: #M0
        typeParameters
          #0 covariant
            bound: <null>
        representationType: typeParameter#0
        typeErasure: typeParameter#0
        declaredFields
          foo1: #M1
            flags: hasEnclosingTypeParameterReference isSynthetic shouldUseTypeForInitializerInference
            type: typeParameter#0
          foo2: #M2
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo3: #M12
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo4: #M13
            flags: hasEnclosingTypeParameterReference isSynthetic shouldUseTypeForInitializerInference
            type: typeParameter#0
          it: #M5
            flags: hasEnclosingTypeParameterReference isFinal shouldUseTypeForInitializerInference
            type: typeParameter#0
        declaredGetters
          it: #M6
            flags: hasEnclosingTypeParameterReference isExtensionTypeMember isSimplyBounded isSynthetic
            returnType: typeParameter#0
        declaredSetters
          foo1=: #M7
            flags: hasEnclosingTypeParameterReference hasImplicitReturnType isExtensionTypeMember isSimplyBounded
            functionType: FunctionType
              positional
                required typeParameter#0
              returnType: void
          foo2=: #M8
            flags: hasImplicitReturnType isExtensionTypeMember isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
          foo3=: #M14
            flags: hasImplicitReturnType isExtensionTypeMember isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
          foo4=: #M15
            flags: hasEnclosingTypeParameterReference hasImplicitReturnType isExtensionTypeMember isSimplyBounded
            functionType: FunctionType
              positional
                required typeParameter#0
              returnType: void
        interface: #M16
          map
            foo1=: #M7
            foo2=: #M8
            foo3=: #M14
            foo4=: #M15
            it: #M6
          implemented
            foo1=: #M7
            foo2=: #M8
            foo3=: #M14
            foo4=: #M15
            it: #M6
''',
    );
  }

  test_manifest_extensionType_setter_modifier_isExternal() async {
    configuration.withElementManifests = true;
    await _runLibraryManifestScenario(
      initialCode: r'''
extension type E(int it) {
  set foo1(int value) {}
  external set foo2(int value);
  set foo3(int value) {}
  external set foo4(int value);
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredExtensionTypes
      E: #M0
        representationType: int @ dart:core
        typeErasure: int @ dart:core
        declaredFields
          foo1: #M1
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo2: #M2
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo3: #M3
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo4: #M4
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          it: #M5
            flags: isFinal shouldUseTypeForInitializerInference
            type: int @ dart:core
        declaredGetters
          it: #M6
            flags: isExtensionTypeMember isSimplyBounded isSynthetic
            returnType: int @ dart:core
        declaredSetters
          foo1=: #M7
            flags: hasImplicitReturnType isExtensionTypeMember isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
          foo2=: #M8
            flags: hasImplicitReturnType isExtensionTypeMember isExternal isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
          foo3=: #M9
            flags: hasImplicitReturnType isExtensionTypeMember isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
          foo4=: #M10
            flags: hasImplicitReturnType isExtensionTypeMember isExternal isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
        interface: #M11
          map
            foo1=: #M7
            foo2=: #M8
            foo3=: #M9
            foo4=: #M10
            it: #M6
          implemented
            foo1=: #M7
            foo2=: #M8
            foo3=: #M9
            foo4=: #M10
            it: #M6
''',
      updatedCode: r'''
extension type E(int it) {
  set foo1(int value) {}
  external set foo2(int value);
  external set foo3(int value);
  set foo4(int value) {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredExtensionTypes
      E: #M0
        representationType: int @ dart:core
        typeErasure: int @ dart:core
        declaredFields
          foo1: #M1
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo2: #M2
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo3: #M3
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo4: #M4
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          it: #M5
            flags: isFinal shouldUseTypeForInitializerInference
            type: int @ dart:core
        declaredGetters
          it: #M6
            flags: isExtensionTypeMember isSimplyBounded isSynthetic
            returnType: int @ dart:core
        declaredSetters
          foo1=: #M7
            flags: hasImplicitReturnType isExtensionTypeMember isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
          foo2=: #M8
            flags: hasImplicitReturnType isExtensionTypeMember isExternal isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
          foo3=: #M12
            flags: hasImplicitReturnType isExtensionTypeMember isExternal isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
          foo4=: #M13
            flags: hasImplicitReturnType isExtensionTypeMember isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
        interface: #M14
          map
            foo1=: #M7
            foo2=: #M8
            foo3=: #M12
            foo4=: #M13
            it: #M6
          implemented
            foo1=: #M7
            foo2=: #M8
            foo3=: #M12
            foo4=: #M13
            it: #M6
''',
    );
  }

  test_manifest_extensionType_setter_modifier_isStatic() async {
    configuration.withElementManifests = true;
    await _runLibraryManifestScenario(
      initialCode: r'''
extension type E(int it) {
  set foo1(int value) {}
  static set foo2(int value) {}
  set foo3(int value) {}
  static set foo4(int value) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredExtensionTypes
      E: #M0
        representationType: int @ dart:core
        typeErasure: int @ dart:core
        declaredFields
          foo1: #M1
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo2: #M2
            flags: isStatic isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo3: #M3
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo4: #M4
            flags: isStatic isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          it: #M5
            flags: isFinal shouldUseTypeForInitializerInference
            type: int @ dart:core
        declaredGetters
          it: #M6
            flags: isExtensionTypeMember isSimplyBounded isSynthetic
            returnType: int @ dart:core
        declaredSetters
          foo1=: #M7
            flags: hasImplicitReturnType isExtensionTypeMember isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
          foo2=: #M8
            flags: hasImplicitReturnType isExtensionTypeMember isSimplyBounded isStatic
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
          foo3=: #M9
            flags: hasImplicitReturnType isExtensionTypeMember isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
          foo4=: #M10
            flags: hasImplicitReturnType isExtensionTypeMember isSimplyBounded isStatic
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
        interface: #M11
          map
            foo1=: #M7
            foo3=: #M9
            it: #M6
          implemented
            foo1=: #M7
            foo3=: #M9
            it: #M6
''',
      updatedCode: r'''
extension type E(int it) {
  set foo1(int value) {}
  static set foo2(int value) {}
  static set foo3(int value) {}
  set foo4(int value) {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredExtensionTypes
      E: #M0
        representationType: int @ dart:core
        typeErasure: int @ dart:core
        declaredFields
          foo1: #M1
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo2: #M2
            flags: isStatic isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo3: #M12
            flags: isStatic isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo4: #M13
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          it: #M5
            flags: isFinal shouldUseTypeForInitializerInference
            type: int @ dart:core
        declaredGetters
          it: #M6
            flags: isExtensionTypeMember isSimplyBounded isSynthetic
            returnType: int @ dart:core
        declaredSetters
          foo1=: #M7
            flags: hasImplicitReturnType isExtensionTypeMember isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
          foo2=: #M8
            flags: hasImplicitReturnType isExtensionTypeMember isSimplyBounded isStatic
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
          foo3=: #M14
            flags: hasImplicitReturnType isExtensionTypeMember isSimplyBounded isStatic
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
          foo4=: #M15
            flags: hasImplicitReturnType isExtensionTypeMember isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
        interface: #M16
          map
            foo1=: #M7
            foo4=: #M15
            it: #M6
          implemented
            foo1=: #M7
            foo4=: #M15
            it: #M6
''',
    );
  }

  test_manifest_extensionType_typeErasure() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
extension type A(num it) {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredExtensionTypes
      A: #M0
        declaredFields
          it: #M1
        declaredGetters
          it: #M2
        interface: #M3
          map
            it: #M2
          implemented
            it: #M2
''',
      updatedCode: r'''
extension type A(int it) {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredExtensionTypes
      A: #M4
        declaredFields
          it: #M5
        declaredGetters
          it: #M6
        interface: #M7
          map
            it: #M6
          implemented
            it: #M6
''',
    );
  }

  test_manifest_extensionType_typeParameters() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
extension type A<T>(int it) {
  void foo(T _) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredExtensionTypes
      A: #M0
        declaredFields
          it: #M1
        declaredGetters
          it: #M2
        declaredMethods
          foo: #M3
        interface: #M4
          map
            foo: #M3
            it: #M2
          implemented
            foo: #M3
            it: #M2
''',
      updatedCode: r'''
extension type A<T>(int it) {
  void foo(T _) {}
  void bar(T _) {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredExtensionTypes
      A: #M0
        declaredFields
          it: #M1
        declaredGetters
          it: #M2
        declaredMethods
          bar: #M5
          foo: #M3
        interface: #M6
          map
            bar: #M5
            foo: #M3
            it: #M2
          implemented
            bar: #M5
            foo: #M3
            it: #M2
''',
    );
  }

  test_manifest_extensionType_typeParameters_add() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
extension type A<T>(int it) {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredExtensionTypes
      A: #M0
        declaredFields
          it: #M1
        declaredGetters
          it: #M2
        interface: #M3
          map
            it: #M2
          implemented
            it: #M2
''',
      updatedCode: r'''
extension type A<T, U>(int it) {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredExtensionTypes
      A: #M4
        declaredFields
          it: #M5
        declaredGetters
          it: #M6
        interface: #M7
          map
            it: #M6
          implemented
            it: #M6
''',
    );
  }

  test_manifest_library_metadata_add() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
library;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
''',
      updatedCode: r'''
@deprecated
library;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    libraryMetadata: #M0
''',
    );
  }

  test_manifest_library_metadata_changeArgument() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
@Deprecated('0')
library;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    libraryMetadata: #M0
''',
      updatedCode: r'''
@Deprecated('1')
library;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    libraryMetadata: #M1
''',
    );
  }

  test_manifest_library_metadata_match() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
@deprecated
library;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    libraryMetadata: #M0
''',
      updatedCode: r'''
@deprecated
library;
void foo() {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    libraryMetadata: #M0
    declaredFunctions
      foo: #M1
''',
    );
  }

  test_manifest_library_metadata_remove() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
@deprecated
library;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    libraryMetadata: #M0
''',
      updatedCode: r'''
library;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
''',
    );
  }

  test_manifest_metadata() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
@deprecated
int get a => 0;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
    declaredVariables
      a: #M1
''',
      updatedCode: r'''
@deprecated
int get a => 0;
int get b => 0;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
      b: #M2
    declaredVariables
      a: #M1
      b: #M3
''',
    );
  }

  test_manifest_metadata_add() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
int get a => 0;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
    declaredVariables
      a: #M1
''',
      updatedCode: r'''
@deprecated
int get a => 0;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M2
    declaredVariables
      a: #M1
''',
    );
  }

  test_manifest_metadata_remove() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
@deprecated
int get a => 0;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
    declaredVariables
      a: #M1
''',
      updatedCode: r'''
int get a => 0;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M2
    declaredVariables
      a: #M1
''',
    );
  }

  test_manifest_metadata_simpleIdentifier_change() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
const a = 0;
@a
int get foo => 0;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
      foo: #M1
    declaredVariables
      a: #M2
      foo: #M3
''',
      updatedCode: r'''
const a = 1;
@a
int get foo => 0;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
      foo: #M4
    declaredVariables
      a: #M5
      foo: #M3
''',
    );
  }

  test_manifest_metadata_simpleIdentifier_replace() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
@deprecated
int get a => 0;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
    declaredVariables
      a: #M1
''',
      updatedCode: r'''
@override
int get a => 0;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M2
    declaredVariables
      a: #M1
''',
    );
  }

  test_manifest_mixin_add() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
mixin A {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        interface: #M1
''',
      updatedCode: r'''
mixin A {}
mixin B {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        interface: #M1
      B: #M2
        interface: #M3
''',
    );
  }

  test_manifest_mixin_field_add() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
mixin A {
  final a = 0;
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        declaredFields
          a: #M1
        declaredGetters
          a: #M2
        interface: #M3
          map
            a: #M2
          implemented
            a: #M2
''',
      updatedCode: r'''
mixin A {
  final a = 0;
  final b = 1;
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        declaredFields
          a: #M1
          b: #M4
        declaredGetters
          a: #M2
          b: #M5
        interface: #M6
          map
            a: #M2
            b: #M5
          implemented
            a: #M2
            b: #M5
''',
    );
  }

  test_manifest_mixin_field_idChangesWithContainer() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
mixin A {}
mixin B {}
mixin C on B {
  var foo = 0;
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        interface: #M1
      B: #M2
        interface: #M3
      C: #M4
        declaredFields
          foo: #M5
        declaredGetters
          foo: #M6
        declaredSetters
          foo=: #M7
        interface: #M8
          map
            foo: #M6
            foo=: #M7
          implemented
            foo: #M6
            foo=: #M7
''',
      updatedCode: r'''
mixin A {}
mixin B on A {}
mixin C on B {
  var foo = 0;
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        interface: #M1
      B: #M9
        interface: #M10
      C: #M11
        declaredFields
          foo: #M12
        declaredGetters
          foo: #M13
        declaredSetters
          foo=: #M14
        interface: #M15
          map
            foo: #M13
            foo=: #M14
          implemented
            foo: #M13
            foo=: #M14
''',
    );
  }

  test_manifest_mixin_field_initializer_type() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
mixin A {
  final a = 0;
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        declaredFields
          a: #M1
        declaredGetters
          a: #M2
        interface: #M3
          map
            a: #M2
          implemented
            a: #M2
''',
      updatedCode: r'''
mixin A {
  final a = 1.2;
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        declaredFields
          a: #M4
        declaredGetters
          a: #M5
        interface: #M6
          map
            a: #M5
          implemented
            a: #M5
''',
    );
  }

  test_manifest_mixin_field_initializer_value_final() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
mixin A {
  final a = 0;
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        declaredFields
          a: #M1
        declaredGetters
          a: #M2
        interface: #M3
          map
            a: #M2
          implemented
            a: #M2
''',
      updatedCode: r'''
mixin A {
  final a = 1;
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        declaredFields
          a: #M1
        declaredGetters
          a: #M2
        interface: #M3
          map
            a: #M2
          implemented
            a: #M2
''',
    );
  }

  test_manifest_mixin_field_initializer_value_static_const() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
mixin A {
  static const a = 0;
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        declaredFields
          a: #M1
        declaredGetters
          a: #M2
        interface: #M3
''',
      updatedCode: r'''
mixin A {
  static const a = 1;
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        declaredFields
          a: #M4
        declaredGetters
          a: #M2
        interface: #M3
''',
    );
  }

  test_manifest_mixin_field_initializer_value_static_final() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
mixin A {
  static final a = 0;
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        declaredFields
          a: #M1
        declaredGetters
          a: #M2
        interface: #M3
''',
      updatedCode: r'''
mixin A {
  static final a = 1;
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        declaredFields
          a: #M1
        declaredGetters
          a: #M2
        interface: #M3
''',
    );
  }

  test_manifest_mixin_field_metadata() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
mixin A {
  @Deprecated('0')
  var a = 0;
  @Deprecated('0')
  var b = 0;
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        declaredFields
          a: #M1
          b: #M2
        declaredGetters
          a: #M3
          b: #M4
        declaredSetters
          a=: #M5
          b=: #M6
        interface: #M7
          map
            a: #M3
            a=: #M5
            b: #M4
            b=: #M6
          implemented
            a: #M3
            a=: #M5
            b: #M4
            b=: #M6
''',
      updatedCode: r'''
mixin A {
  @Deprecated('0')
  var a = 0;
  @Deprecated('1')
  var b = 0;
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        declaredFields
          a: #M1
          b: #M8
        declaredGetters
          a: #M3
          b: #M9
        declaredSetters
          a=: #M5
          b=: #M10
        interface: #M11
          map
            a: #M3
            a=: #M5
            b: #M9
            b=: #M10
          implemented
            a: #M3
            a=: #M5
            b: #M9
            b=: #M10
''',
    );
  }

  test_manifest_mixin_field_private_final() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
mixin A {
  final _a = 0;
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        declaredFields
          _a: #M1
        declaredGetters
          _a: #M2
        interface: #M3
''',
      updatedCode: r'''
mixin A {
  final _a = 0;
  final b = 0;
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        declaredFields
          _a: #M1
          b: #M4
        declaredGetters
          _a: #M2
          b: #M5
        interface: #M6
          map
            b: #M5
          implemented
            b: #M5
''',
    );
  }

  test_manifest_mixin_field_private_static_const() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
mixin A {
  static const _a = 0;
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        declaredFields
          _a: #M1
        declaredGetters
          _a: #M2
        interface: #M3
''',
      updatedCode: r'''
mixin A {
  static const _a = 0;
  static const b = 0;
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        declaredFields
          _a: #M1
          b: #M4
        declaredGetters
          _a: #M2
          b: #M5
        interface: #M3
''',
    );
  }

  test_manifest_mixin_field_private_var() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
mixin A {
  var _a = 0;
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        declaredFields
          _a: #M1
        declaredGetters
          _a: #M2
        declaredSetters
          _a=: #M3
        interface: #M4
''',
      updatedCode: r'''
mixin A {
  var _a = 0;
  var b = 0;
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        declaredFields
          _a: #M1
          b: #M5
        declaredGetters
          _a: #M2
          b: #M6
        declaredSetters
          _a=: #M3
          b=: #M7
        interface: #M8
          map
            b: #M6
            b=: #M7
          implemented
            b: #M6
            b=: #M7
''',
    );
  }

  test_manifest_mixin_field_type() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
mixin A {
  int? a;
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        declaredFields
          a: #M1
        declaredGetters
          a: #M2
        declaredSetters
          a=: #M3
        interface: #M4
          map
            a: #M2
            a=: #M3
          implemented
            a: #M2
            a=: #M3
''',
      updatedCode: r'''
mixin A {
  double? a;
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        declaredFields
          a: #M5
        declaredGetters
          a: #M6
        declaredSetters
          a=: #M7
        interface: #M8
          map
            a: #M6
            a=: #M7
          implemented
            a: #M6
            a=: #M7
''',
    );
  }

  test_manifest_mixin_getter_add_implements() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
mixin A {
  int get foo => 0;
}

mixin B implements A {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        interface: #M3
          map
            foo: #M2
          implemented
            foo: #M2
      B: #M4
        interface: #M5
          map
            foo: #M2
          inherited
            foo: #M2
''',
      updatedCode: r'''
mixin A {
  int get foo => 0;
  int get bar => 0;
}

mixin B implements A {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        declaredFields
          bar: #M6
          foo: #M1
        declaredGetters
          bar: #M7
          foo: #M2
        interface: #M8
          map
            bar: #M7
            foo: #M2
          implemented
            bar: #M7
            foo: #M2
      B: #M4
        interface: #M9
          map
            bar: #M7
            foo: #M2
          inherited
            bar: #M7
            foo: #M2
''',
    );
  }

  test_manifest_mixin_getter_add_implements_generic() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
mixin A<T> {
  T get foo => 0;
}

mixin B implements A<int> {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        interface: #M3
          map
            foo: #M2
          implemented
            foo: #M2
      B: #M4
        interface: #M5
          map
            foo: #M2
          inherited
            foo: #M2
''',
      updatedCode: r'''
mixin A<T> {
  T get foo => 0;
  T get bar => 0;
}

mixin B implements A<int> {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        declaredFields
          bar: #M6
          foo: #M1
        declaredGetters
          bar: #M7
          foo: #M2
        interface: #M8
          map
            bar: #M7
            foo: #M2
          implemented
            bar: #M7
            foo: #M2
      B: #M4
        interface: #M9
          map
            bar: #M7
            foo: #M2
          inherited
            bar: #M7
            foo: #M2
''',
    );
  }

  test_manifest_mixin_getter_add_on() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
mixin A {
  int get foo => 0;
}

mixin B on A {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        interface: #M3
          map
            foo: #M2
          implemented
            foo: #M2
      B: #M4
        interface: #M5
          map
            foo: #M2
          superImplemented
            [0]
              foo: #M2
          inherited
            foo: #M2
''',
      updatedCode: r'''
mixin A {
  int get foo => 0;
  int get bar => 0;
}

mixin B on A {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        declaredFields
          bar: #M6
          foo: #M1
        declaredGetters
          bar: #M7
          foo: #M2
        interface: #M8
          map
            bar: #M7
            foo: #M2
          implemented
            bar: #M7
            foo: #M2
      B: #M4
        interface: #M9
          map
            bar: #M7
            foo: #M2
          superImplemented
            [0]
              bar: #M7
              foo: #M2
          inherited
            bar: #M7
            foo: #M2
''',
    );
  }

  test_manifest_mixin_getter_add_on_generic() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
mixin A<T> {
  T get foo => 0;
}

mixin B on A<int> {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        interface: #M3
          map
            foo: #M2
          implemented
            foo: #M2
      B: #M4
        interface: #M5
          map
            foo: #M2
          superImplemented
            [0]
              foo: #M2
          inherited
            foo: #M2
''',
      updatedCode: r'''
mixin A<T> {
  T get foo => 0;
  T get bar => 0;
}

mixin B on A<int> {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        declaredFields
          bar: #M6
          foo: #M1
        declaredGetters
          bar: #M7
          foo: #M2
        interface: #M8
          map
            bar: #M7
            foo: #M2
          implemented
            bar: #M7
            foo: #M2
      B: #M4
        interface: #M9
          map
            bar: #M7
            foo: #M2
          superImplemented
            [0]
              bar: #M7
              foo: #M2
          inherited
            bar: #M7
            foo: #M2
''',
    );
  }

  test_manifest_mixin_getter_idChangesWithContainer() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
mixin A {}
mixin B {}
mixin C on B {
  int get foo => 0;
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        interface: #M1
      B: #M2
        interface: #M3
      C: #M4
        declaredFields
          foo: #M5
        declaredGetters
          foo: #M6
        interface: #M7
          map
            foo: #M6
          implemented
            foo: #M6
''',
      updatedCode: r'''
mixin A {}
mixin B on A {}
mixin C on B {
  int get foo => 0;
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        interface: #M1
      B: #M8
        interface: #M9
      C: #M10
        declaredFields
          foo: #M11
        declaredGetters
          foo: #M12
        interface: #M13
          map
            foo: #M12
          implemented
            foo: #M12
''',
    );
  }

  test_manifest_mixin_getter_metadata() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
mixin A {
  @Deprecated('0')
  int get foo => 0;
  @Deprecated('0')
  int get bar => 0;
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        declaredFields
          bar: #M1
          foo: #M2
        declaredGetters
          bar: #M3
          foo: #M4
        interface: #M5
          map
            bar: #M3
            foo: #M4
          implemented
            bar: #M3
            foo: #M4
''',
      updatedCode: r'''
mixin A {
  @Deprecated('1')
  int get foo => 0;
  @Deprecated('0')
  int get bar => 0;
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        declaredFields
          bar: #M1
          foo: #M2
        declaredGetters
          bar: #M3
          foo: #M6
        interface: #M7
          map
            bar: #M3
            foo: #M6
          implemented
            bar: #M3
            foo: #M6
''',
    );
  }

  test_manifest_mixin_getter_modifier_hasEnclosingTypeParameterReference() async {
    configuration.withElementManifests = true;
    await _runLibraryManifestScenario(
      initialCode: r'''
mixin M<T> {
  T get foo1;
  int get foo2;
  T get foo3;
  int get foo4;
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      M: #M0
        typeParameters
          #0 covariant
            bound: <null>
        superclassConstraints
          Object @ dart:core
        declaredFields
          foo1: #M1
            flags: hasEnclosingTypeParameterReference isSynthetic shouldUseTypeForInitializerInference
            type: typeParameter#0
          foo2: #M2
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo3: #M3
            flags: hasEnclosingTypeParameterReference isSynthetic shouldUseTypeForInitializerInference
            type: typeParameter#0
          foo4: #M4
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
        declaredGetters
          foo1: #M5
            flags: hasEnclosingTypeParameterReference isAbstract isSimplyBounded
            returnType: typeParameter#0
          foo2: #M6
            flags: isAbstract isSimplyBounded
            returnType: int @ dart:core
          foo3: #M7
            flags: hasEnclosingTypeParameterReference isAbstract isSimplyBounded
            returnType: typeParameter#0
          foo4: #M8
            flags: isAbstract isSimplyBounded
            returnType: int @ dart:core
        interface: #M9
          map
            foo1: #M5
            foo2: #M6
            foo3: #M7
            foo4: #M8
''',
      updatedCode: r'''
mixin M<T> {
  T get foo1;
  int get foo2;
  int get foo3;
  T get foo4;
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      M: #M0
        typeParameters
          #0 covariant
            bound: <null>
        superclassConstraints
          Object @ dart:core
        declaredFields
          foo1: #M1
            flags: hasEnclosingTypeParameterReference isSynthetic shouldUseTypeForInitializerInference
            type: typeParameter#0
          foo2: #M2
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo3: #M10
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo4: #M11
            flags: hasEnclosingTypeParameterReference isSynthetic shouldUseTypeForInitializerInference
            type: typeParameter#0
        declaredGetters
          foo1: #M5
            flags: hasEnclosingTypeParameterReference isAbstract isSimplyBounded
            returnType: typeParameter#0
          foo2: #M6
            flags: isAbstract isSimplyBounded
            returnType: int @ dart:core
          foo3: #M12
            flags: isAbstract isSimplyBounded
            returnType: int @ dart:core
          foo4: #M13
            flags: hasEnclosingTypeParameterReference isAbstract isSimplyBounded
            returnType: typeParameter#0
        interface: #M14
          map
            foo1: #M5
            foo2: #M6
            foo3: #M12
            foo4: #M13
''',
    );
  }

  test_manifest_mixin_getter_modifier_hasImplicitReturnType() async {
    configuration.withElementManifests = true;
    await _runLibraryManifestScenario(
      initialCode: r'''
mixin M {
  get foo1 => 0;
  int get foo2 => 0;
  get foo3 => 0;
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      M: #M0
        superclassConstraints
          Object @ dart:core
        declaredFields
          foo1: #M1
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: dynamic
          foo2: #M2
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo3: #M3
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: dynamic
        declaredGetters
          foo1: #M4
            flags: hasImplicitReturnType isSimplyBounded
            returnType: dynamic
          foo2: #M5
            flags: isSimplyBounded
            returnType: int @ dart:core
          foo3: #M6
            flags: hasImplicitReturnType isSimplyBounded
            returnType: dynamic
        interface: #M7
          map
            foo1: #M4
            foo2: #M5
            foo3: #M6
          implemented
            foo1: #M4
            foo2: #M5
            foo3: #M6
''',
      updatedCode: r'''
mixin M {
  get foo1 => 0;
  get foo2 => 0;
  int get foo3 => 0;
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      M: #M0
        superclassConstraints
          Object @ dart:core
        declaredFields
          foo1: #M1
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: dynamic
          foo2: #M8
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: dynamic
          foo3: #M9
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
        declaredGetters
          foo1: #M4
            flags: hasImplicitReturnType isSimplyBounded
            returnType: dynamic
          foo2: #M10
            flags: hasImplicitReturnType isSimplyBounded
            returnType: dynamic
          foo3: #M11
            flags: isSimplyBounded
            returnType: int @ dart:core
        interface: #M12
          map
            foo1: #M4
            foo2: #M10
            foo3: #M11
          implemented
            foo1: #M4
            foo2: #M10
            foo3: #M11
''',
    );
  }

  test_manifest_mixin_getter_modifier_invokesSuperSelf() async {
    configuration.withElementManifests = true;
    await _runLibraryManifestScenario(
      initialCode: r'''
class S {
  int get foo1 => 1;
  int get foo2 => 2;
  int get foo3 => 3;
  int get foo4 => 4;
}
mixin M on S {
  int get foo1 => 11;
  int get foo2 { return super.foo2; }
  int get foo3 => 33;
  int get foo4 { return super.foo4; }
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      S: #M0
        supertype: Object @ dart:core
        declaredFields
          foo1: #M1
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo2: #M2
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo3: #M3
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo4: #M4
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
        declaredGetters
          foo1: #M5
            flags: isSimplyBounded
            returnType: int @ dart:core
          foo2: #M6
            flags: isSimplyBounded
            returnType: int @ dart:core
          foo3: #M7
            flags: isSimplyBounded
            returnType: int @ dart:core
          foo4: #M8
            flags: isSimplyBounded
            returnType: int @ dart:core
        interface: #M9
          map
            foo1: #M5
            foo2: #M6
            foo3: #M7
            foo4: #M8
          implemented
            foo1: #M5
            foo2: #M6
            foo3: #M7
            foo4: #M8
    declaredMixins
      M: #M10
        superclassConstraints
          S @ package:test/test.dart
        declaredFields
          foo1: #M11
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo2: #M12
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo3: #M13
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo4: #M14
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
        declaredGetters
          foo1: #M15
            flags: isSimplyBounded
            returnType: int @ dart:core
          foo2: #M16
            flags: invokesSuperSelf isSimplyBounded
            returnType: int @ dart:core
          foo3: #M17
            flags: isSimplyBounded
            returnType: int @ dart:core
          foo4: #M18
            flags: invokesSuperSelf isSimplyBounded
            returnType: int @ dart:core
        interface: #M19
          map
            foo1: #M15
            foo2: #M16
            foo3: #M17
            foo4: #M18
          implemented
            foo1: #M15
            foo2: #M16
            foo3: #M17
            foo4: #M18
          superImplemented
            [0]
              foo1: #M5
              foo2: #M6
              foo3: #M7
              foo4: #M8
          inherited
            foo1: #M5
            foo2: #M6
            foo3: #M7
            foo4: #M8
''',
      updatedCode: r'''
class S {
  int get foo1 => 1;
  int get foo2 => 2;
  int get foo3 => 3;
  int get foo4 => 4;
}
mixin M on S {
  int get foo1 => 11;
  int get foo2 { return super.foo2; }
  int get foo3 { return super.foo3; }
  int get foo4 => 44;
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      S: #M0
        supertype: Object @ dart:core
        declaredFields
          foo1: #M1
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo2: #M2
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo3: #M3
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo4: #M4
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
        declaredGetters
          foo1: #M5
            flags: isSimplyBounded
            returnType: int @ dart:core
          foo2: #M6
            flags: isSimplyBounded
            returnType: int @ dart:core
          foo3: #M7
            flags: isSimplyBounded
            returnType: int @ dart:core
          foo4: #M8
            flags: isSimplyBounded
            returnType: int @ dart:core
        interface: #M9
          map
            foo1: #M5
            foo2: #M6
            foo3: #M7
            foo4: #M8
          implemented
            foo1: #M5
            foo2: #M6
            foo3: #M7
            foo4: #M8
    declaredMixins
      M: #M20
        superclassConstraints
          S @ package:test/test.dart
        declaredFields
          foo1: #M21
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo2: #M22
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo3: #M23
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo4: #M24
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
        declaredGetters
          foo1: #M25
            flags: isSimplyBounded
            returnType: int @ dart:core
          foo2: #M26
            flags: invokesSuperSelf isSimplyBounded
            returnType: int @ dart:core
          foo3: #M27
            flags: invokesSuperSelf isSimplyBounded
            returnType: int @ dart:core
          foo4: #M28
            flags: isSimplyBounded
            returnType: int @ dart:core
        interface: #M29
          map
            foo1: #M25
            foo2: #M26
            foo3: #M27
            foo4: #M28
          implemented
            foo1: #M25
            foo2: #M26
            foo3: #M27
            foo4: #M28
          superImplemented
            [0]
              foo1: #M5
              foo2: #M6
              foo3: #M7
              foo4: #M8
          inherited
            foo1: #M5
            foo2: #M6
            foo3: #M7
            foo4: #M8
''',
    );
  }

  test_manifest_mixin_getter_modifier_isAbstract() async {
    configuration.withElementManifests = true;
    await _runLibraryManifestScenario(
      initialCode: r'''
mixin M {
  int get foo1 => 1;
  int get foo2;
  int get foo3 => 3;
  int get foo4;
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      M: #M0
        superclassConstraints
          Object @ dart:core
        declaredFields
          foo1: #M1
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo2: #M2
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo3: #M3
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo4: #M4
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
        declaredGetters
          foo1: #M5
            flags: isSimplyBounded
            returnType: int @ dart:core
          foo2: #M6
            flags: isAbstract isSimplyBounded
            returnType: int @ dart:core
          foo3: #M7
            flags: isSimplyBounded
            returnType: int @ dart:core
          foo4: #M8
            flags: isAbstract isSimplyBounded
            returnType: int @ dart:core
        interface: #M9
          map
            foo1: #M5
            foo2: #M6
            foo3: #M7
            foo4: #M8
          implemented
            foo1: #M5
            foo3: #M7
''',
      updatedCode: r'''
mixin M {
  int get foo1 => 1;
  int get foo2;
  int get foo3;
  int get foo4 => 4;
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      M: #M0
        superclassConstraints
          Object @ dart:core
        declaredFields
          foo1: #M1
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo2: #M2
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo3: #M3
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo4: #M4
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
        declaredGetters
          foo1: #M5
            flags: isSimplyBounded
            returnType: int @ dart:core
          foo2: #M6
            flags: isAbstract isSimplyBounded
            returnType: int @ dart:core
          foo3: #M10
            flags: isAbstract isSimplyBounded
            returnType: int @ dart:core
          foo4: #M11
            flags: isSimplyBounded
            returnType: int @ dart:core
        interface: #M12
          map
            foo1: #M5
            foo2: #M6
            foo3: #M10
            foo4: #M11
          implemented
            foo1: #M5
            foo4: #M11
''',
    );
  }

  test_manifest_mixin_getter_modifier_isExternal() async {
    configuration.withElementManifests = true;
    await _runLibraryManifestScenario(
      initialCode: r'''
mixin M {
  int get foo1 => 1;
  external int get foo2;
  int get foo3 => 3;
  external int get foo4;
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      M: #M0
        superclassConstraints
          Object @ dart:core
        declaredFields
          foo1: #M1
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo2: #M2
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo3: #M3
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo4: #M4
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
        declaredGetters
          foo1: #M5
            flags: isSimplyBounded
            returnType: int @ dart:core
          foo2: #M6
            flags: isExternal isSimplyBounded
            returnType: int @ dart:core
          foo3: #M7
            flags: isSimplyBounded
            returnType: int @ dart:core
          foo4: #M8
            flags: isExternal isSimplyBounded
            returnType: int @ dart:core
        interface: #M9
          map
            foo1: #M5
            foo2: #M6
            foo3: #M7
            foo4: #M8
          implemented
            foo1: #M5
            foo2: #M6
            foo3: #M7
            foo4: #M8
''',
      updatedCode: r'''
mixin M {
  int get foo1 => 1;
  external int get foo2;
  external int get foo3;
  int get foo4 => 4;
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      M: #M0
        superclassConstraints
          Object @ dart:core
        declaredFields
          foo1: #M1
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo2: #M2
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo3: #M3
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo4: #M4
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
        declaredGetters
          foo1: #M5
            flags: isSimplyBounded
            returnType: int @ dart:core
          foo2: #M6
            flags: isExternal isSimplyBounded
            returnType: int @ dart:core
          foo3: #M10
            flags: isExternal isSimplyBounded
            returnType: int @ dart:core
          foo4: #M11
            flags: isSimplyBounded
            returnType: int @ dart:core
        interface: #M12
          map
            foo1: #M5
            foo2: #M6
            foo3: #M10
            foo4: #M11
          implemented
            foo1: #M5
            foo2: #M6
            foo3: #M10
            foo4: #M11
''',
    );
  }

  test_manifest_mixin_getter_modifier_isStatic() async {
    configuration.withElementManifests = true;
    await _runLibraryManifestScenario(
      initialCode: r'''
mixin M {
  int get foo1 => 1;
  static int get foo2 => 2;
  int get foo3 => 3;
  static int get foo4 => 4;
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      M: #M0
        superclassConstraints
          Object @ dart:core
        declaredFields
          foo1: #M1
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo2: #M2
            flags: isStatic isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo3: #M3
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo4: #M4
            flags: isStatic isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
        declaredGetters
          foo1: #M5
            flags: isSimplyBounded
            returnType: int @ dart:core
          foo2: #M6
            flags: isSimplyBounded isStatic
            returnType: int @ dart:core
          foo3: #M7
            flags: isSimplyBounded
            returnType: int @ dart:core
          foo4: #M8
            flags: isSimplyBounded isStatic
            returnType: int @ dart:core
        interface: #M9
          map
            foo1: #M5
            foo3: #M7
          implemented
            foo1: #M5
            foo3: #M7
''',
      updatedCode: r'''
mixin M {
  int get foo1 => 1;
  static int get foo2 => 2;
  static int get foo3 => 3;
  int get foo4 => 4;
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      M: #M0
        superclassConstraints
          Object @ dart:core
        declaredFields
          foo1: #M1
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo2: #M2
            flags: isStatic isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo3: #M10
            flags: isStatic isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo4: #M11
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
        declaredGetters
          foo1: #M5
            flags: isSimplyBounded
            returnType: int @ dart:core
          foo2: #M6
            flags: isSimplyBounded isStatic
            returnType: int @ dart:core
          foo3: #M12
            flags: isSimplyBounded isStatic
            returnType: int @ dart:core
          foo4: #M13
            flags: isSimplyBounded
            returnType: int @ dart:core
        interface: #M14
          map
            foo1: #M5
            foo4: #M13
          implemented
            foo1: #M5
            foo4: #M13
''',
    );
  }

  test_manifest_mixin_getter_private_instance() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
mixin A {
  int get _foo => 0;
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        declaredFields
          _foo: #M1
        declaredGetters
          _foo: #M2
        interface: #M3
''',
      updatedCode: r'''
mixin A {
  int get _foo => 0;
  int get bar => 0;
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        declaredFields
          _foo: #M1
          bar: #M4
        declaredGetters
          _foo: #M2
          bar: #M5
        interface: #M6
          map
            bar: #M5
          implemented
            bar: #M5
''',
    );
  }

  test_manifest_mixin_getter_private_static() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
mixin A {
  static int get _foo => 0;
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        declaredFields
          _foo: #M1
        declaredGetters
          _foo: #M2
        interface: #M3
''',
      updatedCode: r'''
mixin A {
  static int get _foo => 0;
  int get bar => 0;
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        declaredFields
          _foo: #M1
          bar: #M4
        declaredGetters
          _foo: #M2
          bar: #M5
        interface: #M6
          map
            bar: #M5
          implemented
            bar: #M5
''',
    );
  }

  test_manifest_mixin_getter_returnType() async {
    configuration.withElementManifests = true;
    await _runLibraryManifestScenario(
      initialCode: r'''
mixin A {
  int get foo => 0;
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        superclassConstraints
          Object @ dart:core
        declaredFields
          foo: #M1
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
        declaredGetters
          foo: #M2
            flags: isSimplyBounded
            returnType: int @ dart:core
        interface: #M3
          map
            foo: #M2
          implemented
            foo: #M2
''',
      updatedCode: r'''
mixin A {
  double get foo => 1.2;
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        superclassConstraints
          Object @ dart:core
        declaredFields
          foo: #M4
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: double @ dart:core
        declaredGetters
          foo: #M5
            flags: isSimplyBounded
            returnType: double @ dart:core
        interface: #M6
          map
            foo: #M5
          implemented
            foo: #M5
''',
    );
  }

  test_manifest_mixin_getter_static() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
mixin A {
  static int get foo => 0;
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        interface: #M3
''',
      updatedCode: r'''
mixin A {
  static int get foo => 0;
  static int get bar => 0;
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        declaredFields
          bar: #M4
          foo: #M1
        declaredGetters
          bar: #M5
          foo: #M2
        interface: #M3
''',
    );
  }

  test_manifest_mixin_getter_static_falseToTrue() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
mixin A {
  int get foo => 0;
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        interface: #M3
          map
            foo: #M2
          implemented
            foo: #M2
''',
      updatedCode: r'''
mixin A {
  static int get foo => 0;
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        declaredFields
          foo: #M4
        declaredGetters
          foo: #M5
        interface: #M6
''',
    );
  }

  test_manifest_mixin_getter_static_returnType() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
mixin A {
  static int get foo => 0;
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        interface: #M3
''',
      updatedCode: r'''
mixin A {
  static double get foo => 0;
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        declaredFields
          foo: #M4
        declaredGetters
          foo: #M5
        interface: #M3
''',
    );
  }

  test_manifest_mixin_getter_static_trueToFalse() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
mixin A {
  static int get foo => 0;
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        interface: #M3
''',
      updatedCode: r'''
mixin A {
  int get foo => 0;
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        declaredFields
          foo: #M4
        declaredGetters
          foo: #M5
        interface: #M6
          map
            foo: #M5
          implemented
            foo: #M5
''',
    );
  }

  test_manifest_mixin_interfacesAdd() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
mixin A {}
mixin B {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        interface: #M1
      B: #M2
        interface: #M3
''',
      updatedCode: r'''
mixin A implements B {}
mixin B {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M4
        interface: #M5
      B: #M2
        interface: #M3
''',
    );
  }

  test_manifest_mixin_interfacesRemove() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
mixin A implements B {}
mixin B {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        interface: #M1
      B: #M2
        interface: #M3
''',
      updatedCode: r'''
mixin A {}
mixin B {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M4
        interface: #M5
      B: #M2
        interface: #M3
''',
    );
  }

  test_manifest_mixin_interfacesReplace() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
mixin A implements B {}
mixin B {}
mixin C {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        interface: #M1
      B: #M2
        interface: #M3
      C: #M4
        interface: #M5
''',
      updatedCode: r'''
mixin A implements C {}
mixin B {}
mixin C {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M6
        interface: #M7
      B: #M2
        interface: #M3
      C: #M4
        interface: #M5
''',
    );
  }

  test_manifest_mixin_metadata() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
@Deprecated('0')
mixin A {}
@Deprecated('0')
mixin B {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        interface: #M1
      B: #M2
        interface: #M3
''',
      updatedCode: r'''
@Deprecated('0')
mixin A {}
@Deprecated('1')
mixin B {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        interface: #M1
      B: #M4
        interface: #M5
''',
    );
  }

  test_manifest_mixin_method_add() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
mixin A {
  void foo() {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
''',
      updatedCode: r'''
mixin A {
  void foo() {}
  void bar() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        declaredMethods
          bar: #M3
          foo: #M1
        interface: #M4
          map
            bar: #M3
            foo: #M1
          implemented
            bar: #M3
            foo: #M1
''',
    );
  }

  test_manifest_mixin_method_add_implements() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
mixin A {
  void foo() {}
}

mixin B implements A {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
      B: #M3
        interface: #M4
          map
            foo: #M1
          inherited
            foo: #M1
''',
      updatedCode: r'''
mixin A {
  void foo() {}
  void bar() {}
}

mixin B implements A {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        declaredMethods
          bar: #M5
          foo: #M1
        interface: #M6
          map
            bar: #M5
            foo: #M1
          implemented
            bar: #M5
            foo: #M1
      B: #M3
        interface: #M7
          map
            bar: #M5
            foo: #M1
          inherited
            bar: #M5
            foo: #M1
''',
    );
  }

  test_manifest_mixin_method_add_implements_generic() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
mixin A<T> {
  T foo() {}
}

mixin B implements A<int> {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
      B: #M3
        interface: #M4
          map
            foo: #M1
          inherited
            foo: #M1
''',
      updatedCode: r'''
mixin A<T> {
  T foo() {}
  void bar() {}
}

mixin B implements A<int> {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        declaredMethods
          bar: #M5
          foo: #M1
        interface: #M6
          map
            bar: #M5
            foo: #M1
          implemented
            bar: #M5
            foo: #M1
      B: #M3
        interface: #M7
          map
            bar: #M5
            foo: #M1
          inherited
            bar: #M5
            foo: #M1
''',
    );
  }

  test_manifest_mixin_method_add_on() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
mixin A {
  void foo() {}
}

mixin B on A {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
      B: #M3
        interface: #M4
          map
            foo: #M1
          superImplemented
            [0]
              foo: #M1
          inherited
            foo: #M1
''',
      updatedCode: r'''
mixin A {
  void foo() {}
  void bar() {}
}

mixin B extends A {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        declaredMethods
          bar: #M5
          foo: #M1
        interface: #M6
          map
            bar: #M5
            foo: #M1
          implemented
            bar: #M5
            foo: #M1
      B: #M3
        interface: #M7
          map
            bar: #M5
            foo: #M1
          superImplemented
            [0]
              bar: #M5
              foo: #M1
          inherited
            bar: #M5
            foo: #M1
''',
    );
  }

  test_manifest_mixin_method_add_on_generic() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
mixin A<T> {
  T foo() {}
}

mixin B extends A<int> {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
      B: #M3
        interface: #M4
          map
            foo: #M1
          superImplemented
            [0]
              foo: #M1
          inherited
            foo: #M1
''',
      updatedCode: r'''
mixin A<T> {
  T foo() {}
  void bar() {}
}

mixin B extends A<int> {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        declaredMethods
          bar: #M5
          foo: #M1
        interface: #M6
          map
            bar: #M5
            foo: #M1
          implemented
            bar: #M5
            foo: #M1
      B: #M3
        interface: #M7
          map
            bar: #M5
            foo: #M1
          superImplemented
            [0]
              bar: #M5
              foo: #M1
          inherited
            bar: #M5
            foo: #M1
''',
    );
  }

  test_manifest_mixin_method_idChangesWithContainer() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
mixin A {}
mixin B {}
mixin C on B {
  void foo() {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        interface: #M1
      B: #M2
        interface: #M3
      C: #M4
        declaredMethods
          foo: #M5
        interface: #M6
          map
            foo: #M5
          implemented
            foo: #M5
''',
      updatedCode: r'''
mixin A {}
mixin B on A {}
mixin C on B {
  void foo() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        interface: #M1
      B: #M7
        interface: #M8
      C: #M9
        declaredMethods
          foo: #M10
        interface: #M11
          map
            foo: #M10
          implemented
            foo: #M10
''',
    );
  }

  test_manifest_mixin_method_metadata() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
mixin A {
  @Deprecated('0')
  void foo() {}
  @Deprecated('0')
  void bar() {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        declaredMethods
          bar: #M1
          foo: #M2
        interface: #M3
          map
            bar: #M1
            foo: #M2
          implemented
            bar: #M1
            foo: #M2
''',
      updatedCode: r'''
mixin A {
  @Deprecated('1')
  void foo() {}
  @Deprecated('0')
  void bar() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        declaredMethods
          bar: #M1
          foo: #M4
        interface: #M5
          map
            bar: #M1
            foo: #M4
          implemented
            bar: #M1
            foo: #M4
''',
    );
  }

  test_manifest_mixin_method_modifier_hasEnclosingTypeParameterReference() async {
    configuration.withElementManifests = true;
    await _runLibraryManifestScenario(
      initialCode: r'''
mixin M<T> {
  T foo1();
  void foo2();
  T foo3();
  void foo4();
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      M: #M0
        typeParameters
          #0 covariant
            bound: <null>
        superclassConstraints
          Object @ dart:core
        declaredMethods
          foo1: #M1
            flags: hasEnclosingTypeParameterReference isAbstract isSimplyBounded
            functionType: FunctionType
              returnType: typeParameter#0
          foo2: #M2
            flags: isAbstract isSimplyBounded
            functionType: FunctionType
              returnType: void
          foo3: #M3
            flags: hasEnclosingTypeParameterReference isAbstract isSimplyBounded
            functionType: FunctionType
              returnType: typeParameter#0
          foo4: #M4
            flags: isAbstract isSimplyBounded
            functionType: FunctionType
              returnType: void
        interface: #M5
          map
            foo1: #M1
            foo2: #M2
            foo3: #M3
            foo4: #M4
''',
      updatedCode: r'''
mixin M<T> {
  T foo1();
  void foo2();
  void foo3();
  T foo4();
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      M: #M0
        typeParameters
          #0 covariant
            bound: <null>
        superclassConstraints
          Object @ dart:core
        declaredMethods
          foo1: #M1
            flags: hasEnclosingTypeParameterReference isAbstract isSimplyBounded
            functionType: FunctionType
              returnType: typeParameter#0
          foo2: #M2
            flags: isAbstract isSimplyBounded
            functionType: FunctionType
              returnType: void
          foo3: #M6
            flags: isAbstract isSimplyBounded
            functionType: FunctionType
              returnType: void
          foo4: #M7
            flags: hasEnclosingTypeParameterReference isAbstract isSimplyBounded
            functionType: FunctionType
              returnType: typeParameter#0
        interface: #M8
          map
            foo1: #M1
            foo2: #M2
            foo3: #M6
            foo4: #M7
''',
    );
  }

  test_manifest_mixin_method_modifier_hasImplicitReturnType() async {
    configuration.withElementManifests = true;
    await _runLibraryManifestScenario(
      initialCode: r'''
mixin M {
  foo1() {}
  void foo2() {}
  foo3() {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      M: #M0
        superclassConstraints
          Object @ dart:core
        declaredMethods
          foo1: #M1
            flags: hasImplicitReturnType isSimplyBounded
            functionType: FunctionType
              returnType: dynamic
          foo2: #M2
            flags: isSimplyBounded
            functionType: FunctionType
              returnType: void
          foo3: #M3
            flags: hasImplicitReturnType isSimplyBounded
            functionType: FunctionType
              returnType: dynamic
        interface: #M4
          map
            foo1: #M1
            foo2: #M2
            foo3: #M3
          implemented
            foo1: #M1
            foo2: #M2
            foo3: #M3
''',
      updatedCode: r'''
mixin M {
  foo1() {}
  foo2() {}
  void foo3() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      M: #M0
        superclassConstraints
          Object @ dart:core
        declaredMethods
          foo1: #M1
            flags: hasImplicitReturnType isSimplyBounded
            functionType: FunctionType
              returnType: dynamic
          foo2: #M5
            flags: hasImplicitReturnType isSimplyBounded
            functionType: FunctionType
              returnType: dynamic
          foo3: #M6
            flags: isSimplyBounded
            functionType: FunctionType
              returnType: void
        interface: #M7
          map
            foo1: #M1
            foo2: #M5
            foo3: #M6
          implemented
            foo1: #M1
            foo2: #M5
            foo3: #M6
''',
    );
  }

  test_manifest_mixin_method_modifier_invokesSuperSelf() async {
    configuration.withElementManifests = true;
    await _runLibraryManifestScenario(
      initialCode: r'''
class S {
  void foo1() {}
  void foo2() {}
  void foo3() {}
  void foo4() {}
}
mixin M on S {
  void foo1() {}
  void foo2() { super.foo2(); }
  void foo3() {}
  void foo4() { super.foo4(); }
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      S: #M0
        supertype: Object @ dart:core
        declaredMethods
          foo1: #M1
            flags: isSimplyBounded
            functionType: FunctionType
              returnType: void
          foo2: #M2
            flags: isSimplyBounded
            functionType: FunctionType
              returnType: void
          foo3: #M3
            flags: isSimplyBounded
            functionType: FunctionType
              returnType: void
          foo4: #M4
            flags: isSimplyBounded
            functionType: FunctionType
              returnType: void
        interface: #M5
          map
            foo1: #M1
            foo2: #M2
            foo3: #M3
            foo4: #M4
          implemented
            foo1: #M1
            foo2: #M2
            foo3: #M3
            foo4: #M4
    declaredMixins
      M: #M6
        superclassConstraints
          S @ package:test/test.dart
        declaredMethods
          foo1: #M7
            flags: isSimplyBounded
            functionType: FunctionType
              returnType: void
          foo2: #M8
            flags: invokesSuperSelf isSimplyBounded
            functionType: FunctionType
              returnType: void
          foo3: #M9
            flags: isSimplyBounded
            functionType: FunctionType
              returnType: void
          foo4: #M10
            flags: invokesSuperSelf isSimplyBounded
            functionType: FunctionType
              returnType: void
        interface: #M11
          map
            foo1: #M7
            foo2: #M8
            foo3: #M9
            foo4: #M10
          implemented
            foo1: #M7
            foo2: #M8
            foo3: #M9
            foo4: #M10
          superImplemented
            [0]
              foo1: #M1
              foo2: #M2
              foo3: #M3
              foo4: #M4
          inherited
            foo1: #M1
            foo2: #M2
            foo3: #M3
            foo4: #M4
''',
      updatedCode: r'''
class S {
  void foo1() {}
  void foo2() {}
  void foo3() {}
  void foo4() {}
}
mixin M on S {
  void foo1() {}
  void foo2() { super.foo2(); }
  void foo3() { super.foo3(); }
  void foo4() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      S: #M0
        supertype: Object @ dart:core
        declaredMethods
          foo1: #M1
            flags: isSimplyBounded
            functionType: FunctionType
              returnType: void
          foo2: #M2
            flags: isSimplyBounded
            functionType: FunctionType
              returnType: void
          foo3: #M3
            flags: isSimplyBounded
            functionType: FunctionType
              returnType: void
          foo4: #M4
            flags: isSimplyBounded
            functionType: FunctionType
              returnType: void
        interface: #M5
          map
            foo1: #M1
            foo2: #M2
            foo3: #M3
            foo4: #M4
          implemented
            foo1: #M1
            foo2: #M2
            foo3: #M3
            foo4: #M4
    declaredMixins
      M: #M12
        superclassConstraints
          S @ package:test/test.dart
        declaredMethods
          foo1: #M13
            flags: isSimplyBounded
            functionType: FunctionType
              returnType: void
          foo2: #M14
            flags: invokesSuperSelf isSimplyBounded
            functionType: FunctionType
              returnType: void
          foo3: #M15
            flags: invokesSuperSelf isSimplyBounded
            functionType: FunctionType
              returnType: void
          foo4: #M16
            flags: isSimplyBounded
            functionType: FunctionType
              returnType: void
        interface: #M17
          map
            foo1: #M13
            foo2: #M14
            foo3: #M15
            foo4: #M16
          implemented
            foo1: #M13
            foo2: #M14
            foo3: #M15
            foo4: #M16
          superImplemented
            [0]
              foo1: #M1
              foo2: #M2
              foo3: #M3
              foo4: #M4
          inherited
            foo1: #M1
            foo2: #M2
            foo3: #M3
            foo4: #M4
''',
    );
  }

  test_manifest_mixin_method_modifier_isAbstract() async {
    configuration.withElementManifests = true;
    await _runLibraryManifestScenario(
      initialCode: r'''
mixin M {
  void foo1() {}
  void foo2();
  void foo3() {}
  void foo4();
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      M: #M0
        superclassConstraints
          Object @ dart:core
        declaredMethods
          foo1: #M1
            flags: isSimplyBounded
            functionType: FunctionType
              returnType: void
          foo2: #M2
            flags: isAbstract isSimplyBounded
            functionType: FunctionType
              returnType: void
          foo3: #M3
            flags: isSimplyBounded
            functionType: FunctionType
              returnType: void
          foo4: #M4
            flags: isAbstract isSimplyBounded
            functionType: FunctionType
              returnType: void
        interface: #M5
          map
            foo1: #M1
            foo2: #M2
            foo3: #M3
            foo4: #M4
          implemented
            foo1: #M1
            foo3: #M3
''',
      updatedCode: r'''
mixin M {
  void foo1() {}
  void foo2();
  void foo3();
  void foo4() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      M: #M0
        superclassConstraints
          Object @ dart:core
        declaredMethods
          foo1: #M1
            flags: isSimplyBounded
            functionType: FunctionType
              returnType: void
          foo2: #M2
            flags: isAbstract isSimplyBounded
            functionType: FunctionType
              returnType: void
          foo3: #M6
            flags: isAbstract isSimplyBounded
            functionType: FunctionType
              returnType: void
          foo4: #M7
            flags: isSimplyBounded
            functionType: FunctionType
              returnType: void
        interface: #M8
          map
            foo1: #M1
            foo2: #M2
            foo3: #M6
            foo4: #M7
          implemented
            foo1: #M1
            foo4: #M7
''',
    );
  }

  test_manifest_mixin_method_modifier_isExternal() async {
    configuration.withElementManifests = true;
    await _runLibraryManifestScenario(
      initialCode: r'''
mixin M {
  void foo1() {}
  external void foo2();
  void foo3() {}
  external void foo4();
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      M: #M0
        superclassConstraints
          Object @ dart:core
        declaredMethods
          foo1: #M1
            flags: isSimplyBounded
            functionType: FunctionType
              returnType: void
          foo2: #M2
            flags: isExternal isSimplyBounded
            functionType: FunctionType
              returnType: void
          foo3: #M3
            flags: isSimplyBounded
            functionType: FunctionType
              returnType: void
          foo4: #M4
            flags: isExternal isSimplyBounded
            functionType: FunctionType
              returnType: void
        interface: #M5
          map
            foo1: #M1
            foo2: #M2
            foo3: #M3
            foo4: #M4
          implemented
            foo1: #M1
            foo2: #M2
            foo3: #M3
            foo4: #M4
''',
      updatedCode: r'''
mixin M {
  void foo1() {}
  external void foo2();
  external void foo3();
  void foo4() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      M: #M0
        superclassConstraints
          Object @ dart:core
        declaredMethods
          foo1: #M1
            flags: isSimplyBounded
            functionType: FunctionType
              returnType: void
          foo2: #M2
            flags: isExternal isSimplyBounded
            functionType: FunctionType
              returnType: void
          foo3: #M6
            flags: isExternal isSimplyBounded
            functionType: FunctionType
              returnType: void
          foo4: #M7
            flags: isSimplyBounded
            functionType: FunctionType
              returnType: void
        interface: #M8
          map
            foo1: #M1
            foo2: #M2
            foo3: #M6
            foo4: #M7
          implemented
            foo1: #M1
            foo2: #M2
            foo3: #M6
            foo4: #M7
''',
    );
  }

  test_manifest_mixin_method_modifier_isStatic() async {
    configuration.withElementManifests = true;
    await _runLibraryManifestScenario(
      initialCode: r'''
mixin M {
  void foo1() {}
  static void foo2() {}
  void foo3() {}
  static void foo4() {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      M: #M0
        superclassConstraints
          Object @ dart:core
        declaredMethods
          foo1: #M1
            flags: isSimplyBounded
            functionType: FunctionType
              returnType: void
          foo2: #M2
            flags: isSimplyBounded isStatic
            functionType: FunctionType
              returnType: void
          foo3: #M3
            flags: isSimplyBounded
            functionType: FunctionType
              returnType: void
          foo4: #M4
            flags: isSimplyBounded isStatic
            functionType: FunctionType
              returnType: void
        interface: #M5
          map
            foo1: #M1
            foo3: #M3
          implemented
            foo1: #M1
            foo3: #M3
''',
      updatedCode: r'''
mixin M {
  void foo1() {}
  static void foo2() {}
  static void foo3() {}
  void foo4() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      M: #M0
        superclassConstraints
          Object @ dart:core
        declaredMethods
          foo1: #M1
            flags: isSimplyBounded
            functionType: FunctionType
              returnType: void
          foo2: #M2
            flags: isSimplyBounded isStatic
            functionType: FunctionType
              returnType: void
          foo3: #M6
            flags: isSimplyBounded isStatic
            functionType: FunctionType
              returnType: void
          foo4: #M7
            flags: isSimplyBounded
            functionType: FunctionType
              returnType: void
        interface: #M8
          map
            foo1: #M1
            foo4: #M7
          implemented
            foo1: #M1
            foo4: #M7
''',
    );
  }

  test_manifest_mixin_method_private_instance() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
mixin A {
  void _foo() {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        declaredMethods
          _foo: #M1
        interface: #M2
''',
      updatedCode: r'''
mixin A {
  void _foo() {}
  void bar() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        declaredMethods
          _foo: #M1
          bar: #M3
        interface: #M4
          map
            bar: #M3
          implemented
            bar: #M3
''',
    );
  }

  test_manifest_mixin_method_private_static() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
mixin A {
  static void _foo() {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        declaredMethods
          _foo: #M1
        interface: #M2
''',
      updatedCode: r'''
mixin A {
  static void _foo() {}
  void bar() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        declaredMethods
          _foo: #M1
          bar: #M3
        interface: #M4
          map
            bar: #M3
          implemented
            bar: #M3
''',
    );
  }

  test_manifest_mixin_method_remove() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
mixin A {
  void foo() {}
  void bar() {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        declaredMethods
          bar: #M1
          foo: #M2
        interface: #M3
          map
            bar: #M1
            foo: #M2
          implemented
            bar: #M1
            foo: #M2
''',
      updatedCode: r'''
mixin A {
  void foo() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        declaredMethods
          foo: #M2
        interface: #M4
          map
            foo: #M2
          implemented
            foo: #M2
''',
    );
  }

  test_manifest_mixin_method_returnType() async {
    configuration.withElementManifests = true;
    await _runLibraryManifestScenario(
      initialCode: r'''
mixin A {
  int foo() {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        superclassConstraints
          Object @ dart:core
        declaredMethods
          foo: #M1
            flags: isSimplyBounded
            functionType: FunctionType
              returnType: int @ dart:core
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
''',
      updatedCode: r'''
mixin A {
  double foo() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        superclassConstraints
          Object @ dart:core
        declaredMethods
          foo: #M3
            flags: isSimplyBounded
            functionType: FunctionType
              returnType: double @ dart:core
        interface: #M4
          map
            foo: #M3
          implemented
            foo: #M3
''',
    );
  }

  test_manifest_mixin_method_static_falseToTrue() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
mixin A {
  void foo() {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
''',
      updatedCode: r'''
mixin A {
  static void foo() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        declaredMethods
          foo: #M3
        interface: #M4
''',
    );
  }

  test_manifest_mixin_method_static_returnType() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
mixin A {
  static int foo() {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
''',
      updatedCode: r'''
mixin A {
  static double foo() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        declaredMethods
          foo: #M3
        interface: #M2
''',
    );
  }

  test_manifest_mixin_method_static_trueToFalse() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
mixin A {
  static void foo() {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
''',
      updatedCode: r'''
mixin A {
  void foo() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        declaredMethods
          foo: #M3
        interface: #M4
          map
            foo: #M3
          implemented
            foo: #M3
''',
    );
  }

  test_manifest_mixin_method_typeParameter() async {
    configuration.withElementManifests = true;
    await _runLibraryManifestScenario(
      initialCode: r'''
mixin A<T> {
  Map<T, U> foo<U>() {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        typeParameters
          #0 covariant
            bound: <null>
        superclassConstraints
          Object @ dart:core
        declaredMethods
          foo: #M1
            flags: hasEnclosingTypeParameterReference isSimplyBounded
            functionType: FunctionType
              typeParameters
                #0 covariant
                  bound: <null>
              returnType: Map @ dart:core
                typeParameter#1
                typeParameter#0
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
''',
      updatedCode: r'''
mixin A<T> {
  Map<T, U> foo<U>() {}
  void bar() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        typeParameters
          #0 covariant
            bound: <null>
        superclassConstraints
          Object @ dart:core
        declaredMethods
          bar: #M3
            flags: isSimplyBounded
            functionType: FunctionType
              returnType: void
          foo: #M1
            flags: hasEnclosingTypeParameterReference isSimplyBounded
            functionType: FunctionType
              typeParameters
                #0 covariant
                  bound: <null>
              returnType: Map @ dart:core
                typeParameter#1
                typeParameter#0
        interface: #M4
          map
            bar: #M3
            foo: #M1
          implemented
            bar: #M3
            foo: #M1
''',
    );
  }

  test_manifest_mixin_method_typeParameter_add() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
mixin A {
  void foo<T>() {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
''',
      updatedCode: r'''
mixin A {
  void foo<T, U>() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        declaredMethods
          foo: #M3
        interface: #M4
          map
            foo: #M3
          implemented
            foo: #M3
''',
    );
  }

  test_manifest_mixin_method_typeParameter_remove() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
mixin A {
  void foo<T, U>() {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
''',
      updatedCode: r'''
mixin A {
  void foo<T>() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        declaredMethods
          foo: #M3
        interface: #M4
          map
            foo: #M3
          implemented
            foo: #M3
''',
    );
  }

  test_manifest_mixin_modifier_isBase() async {
    configuration.withElementManifests = true;

    await _runLibraryManifestScenario(
      initialCode: r'''
mixin A {}
base mixin B {}
mixin C {}
base mixin D {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        superclassConstraints
          Object @ dart:core
        interface: #M1
      B: #M2
        flags: isBase
        superclassConstraints
          Object @ dart:core
        interface: #M3
      C: #M4
        superclassConstraints
          Object @ dart:core
        interface: #M5
      D: #M6
        flags: isBase
        superclassConstraints
          Object @ dart:core
        interface: #M7
''',
      updatedCode: r'''
mixin A {}
base mixin B {}
base mixin C {}
mixin D {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        superclassConstraints
          Object @ dart:core
        interface: #M1
      B: #M2
        flags: isBase
        superclassConstraints
          Object @ dart:core
        interface: #M3
      C: #M8
        flags: isBase
        superclassConstraints
          Object @ dart:core
        interface: #M9
      D: #M10
        superclassConstraints
          Object @ dart:core
        interface: #M11
''',
    );
  }

  test_manifest_mixin_onAdd_direct() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
mixin A {}
mixin B {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        interface: #M1
      B: #M2
        interface: #M3
''',
      updatedCode: r'''
mixin A on B {}
mixin B {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M4
        interface: #M5
      B: #M2
        interface: #M3
''',
    );
  }

  test_manifest_mixin_onAdd_indirect() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
mixin A on B {}
mixin B {}
mixin C {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        interface: #M1
      B: #M2
        interface: #M3
      C: #M4
        interface: #M5
''',
      updatedCode: r'''
mixin A on B {}
mixin B on C {}
mixin C {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M6
        interface: #M7
      B: #M8
        interface: #M9
      C: #M4
        interface: #M5
''',
    );
  }

  test_manifest_mixin_onChange() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
mixin A on B {}
mixin B {}
mixin C {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        interface: #M1
      B: #M2
        interface: #M3
      C: #M4
        interface: #M5
''',
      updatedCode: r'''
mixin A on C {}
mixin B {}
mixin C {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M6
        interface: #M7
      B: #M2
        interface: #M3
      C: #M4
        interface: #M5
''',
    );
  }

  test_manifest_mixin_private() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
mixin _A {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      _A: #M0
        interface: #M1
''',
      updatedCode: r'''
mixin _A {}
mixin B {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      B: #M2
        interface: #M3
      _A: #M0
        interface: #M1
''',
    );
  }

  test_manifest_mixin_remove() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
mixin A {}
mixin B {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        interface: #M1
      B: #M2
        interface: #M3
''',
      updatedCode: r'''
mixin B {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      B: #M2
        interface: #M3
''',
    );
  }

  test_manifest_mixin_setter_add_implements() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
mixin A {
  set foo(int _) {}
}

mixin B implements A {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        declaredFields
          foo: #M1
        declaredSetters
          foo=: #M2
        interface: #M3
          map
            foo=: #M2
          implemented
            foo=: #M2
      B: #M4
        interface: #M5
          map
            foo=: #M2
          inherited
            foo=: #M2
''',
      updatedCode: r'''
mixin A {
  set foo(int _) {}
  set bar(int _) {}
}

mixin B implements A {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        declaredFields
          bar: #M6
          foo: #M1
        declaredSetters
          bar=: #M7
          foo=: #M2
        interface: #M8
          map
            bar=: #M7
            foo=: #M2
          implemented
            bar=: #M7
            foo=: #M2
      B: #M4
        interface: #M9
          map
            bar=: #M7
            foo=: #M2
          inherited
            bar=: #M7
            foo=: #M2
''',
    );
  }

  test_manifest_mixin_setter_add_implements_generic() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
mixin A<T> {
  set foo(T _) {}
}

mixin B implements A<int> {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        declaredFields
          foo: #M1
        declaredSetters
          foo=: #M2
        interface: #M3
          map
            foo=: #M2
          implemented
            foo=: #M2
      B: #M4
        interface: #M5
          map
            foo=: #M2
          inherited
            foo=: #M2
''',
      updatedCode: r'''
mixin A<T> {
  set foo(T _) {}
  set bar(T _) {}
}

mixin B implements A<int> {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        declaredFields
          bar: #M6
          foo: #M1
        declaredSetters
          bar=: #M7
          foo=: #M2
        interface: #M8
          map
            bar=: #M7
            foo=: #M2
          implemented
            bar=: #M7
            foo=: #M2
      B: #M4
        interface: #M9
          map
            bar=: #M7
            foo=: #M2
          inherited
            bar=: #M7
            foo=: #M2
''',
    );
  }

  test_manifest_mixin_setter_add_on() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
mixin A {
  set foo(int _) {}
}

mixin B on A {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        declaredFields
          foo: #M1
        declaredSetters
          foo=: #M2
        interface: #M3
          map
            foo=: #M2
          implemented
            foo=: #M2
      B: #M4
        interface: #M5
          map
            foo=: #M2
          superImplemented
            [0]
              foo=: #M2
          inherited
            foo=: #M2
''',
      updatedCode: r'''
mixin A {
  set foo(int _) {}
  set bar(int _) {}
}

mixin B on A {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        declaredFields
          bar: #M6
          foo: #M1
        declaredSetters
          bar=: #M7
          foo=: #M2
        interface: #M8
          map
            bar=: #M7
            foo=: #M2
          implemented
            bar=: #M7
            foo=: #M2
      B: #M4
        interface: #M9
          map
            bar=: #M7
            foo=: #M2
          superImplemented
            [0]
              bar=: #M7
              foo=: #M2
          inherited
            bar=: #M7
            foo=: #M2
''',
    );
  }

  test_manifest_mixin_setter_add_on_generic() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
mixin A<T> {
  set foo(T _) {}
}

mixin B on A<int> {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        declaredFields
          foo: #M1
        declaredSetters
          foo=: #M2
        interface: #M3
          map
            foo=: #M2
          implemented
            foo=: #M2
      B: #M4
        interface: #M5
          map
            foo=: #M2
          superImplemented
            [0]
              foo=: #M2
          inherited
            foo=: #M2
''',
      updatedCode: r'''
mixin A<T> {
  set foo(T _) {}
  set bar(T _) {}
}

mixin B on A<int> {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        declaredFields
          bar: #M6
          foo: #M1
        declaredSetters
          bar=: #M7
          foo=: #M2
        interface: #M8
          map
            bar=: #M7
            foo=: #M2
          implemented
            bar=: #M7
            foo=: #M2
      B: #M4
        interface: #M9
          map
            bar=: #M7
            foo=: #M2
          superImplemented
            [0]
              bar=: #M7
              foo=: #M2
          inherited
            bar=: #M7
            foo=: #M2
''',
    );
  }

  test_manifest_mixin_setter_idChangesWithContainer() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
mixin A {}
mixin B {}
mixin C on B {
  void set foo(int _) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        interface: #M1
      B: #M2
        interface: #M3
      C: #M4
        declaredFields
          foo: #M5
        declaredSetters
          foo=: #M6
        interface: #M7
          map
            foo=: #M6
          implemented
            foo=: #M6
''',
      updatedCode: r'''
mixin A {}
mixin B on A {}
mixin C on B {
  void set foo(int _) {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        interface: #M1
      B: #M8
        interface: #M9
      C: #M10
        declaredFields
          foo: #M11
        declaredSetters
          foo=: #M12
        interface: #M13
          map
            foo=: #M12
          implemented
            foo=: #M12
''',
    );
  }

  test_manifest_mixin_setter_metadata() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
mixin A {
  @Deprecated('0')
  set foo(int _) {}
  @Deprecated('0')
  set bar(int _) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        declaredFields
          bar: #M1
          foo: #M2
        declaredSetters
          bar=: #M3
          foo=: #M4
        interface: #M5
          map
            bar=: #M3
            foo=: #M4
          implemented
            bar=: #M3
            foo=: #M4
''',
      updatedCode: r'''
mixin A {
  @Deprecated('1')
  set foo(int _) {}
  @Deprecated('0')
  set bar(int _) {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        declaredFields
          bar: #M1
          foo: #M2
        declaredSetters
          bar=: #M3
          foo=: #M6
        interface: #M7
          map
            bar=: #M3
            foo=: #M6
          implemented
            bar=: #M3
            foo=: #M6
''',
    );
  }

  test_manifest_mixin_setter_modifier_hasEnclosingTypeParameterReference() async {
    configuration.withElementManifests = true;
    await _runLibraryManifestScenario(
      initialCode: r'''
mixin M<T> {
  set foo1(T value);
  set foo2(int value);
  set foo3(T value);
  set foo4(int value);
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      M: #M0
        typeParameters
          #0 covariant
            bound: <null>
        superclassConstraints
          Object @ dart:core
        declaredFields
          foo1: #M1
            flags: hasEnclosingTypeParameterReference isSynthetic shouldUseTypeForInitializerInference
            type: typeParameter#0
          foo2: #M2
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo3: #M3
            flags: hasEnclosingTypeParameterReference isSynthetic shouldUseTypeForInitializerInference
            type: typeParameter#0
          foo4: #M4
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
        declaredSetters
          foo1=: #M5
            flags: hasEnclosingTypeParameterReference hasImplicitReturnType isAbstract isSimplyBounded
            functionType: FunctionType
              positional
                required typeParameter#0
              returnType: void
          foo2=: #M6
            flags: hasImplicitReturnType isAbstract isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
          foo3=: #M7
            flags: hasEnclosingTypeParameterReference hasImplicitReturnType isAbstract isSimplyBounded
            functionType: FunctionType
              positional
                required typeParameter#0
              returnType: void
          foo4=: #M8
            flags: hasImplicitReturnType isAbstract isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
        interface: #M9
          map
            foo1=: #M5
            foo2=: #M6
            foo3=: #M7
            foo4=: #M8
''',
      updatedCode: r'''
mixin M<T> {
  set foo1(T value);
  set foo2(int value);
  set foo3(int value);
  set foo4(T value);
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      M: #M0
        typeParameters
          #0 covariant
            bound: <null>
        superclassConstraints
          Object @ dart:core
        declaredFields
          foo1: #M1
            flags: hasEnclosingTypeParameterReference isSynthetic shouldUseTypeForInitializerInference
            type: typeParameter#0
          foo2: #M2
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo3: #M10
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo4: #M11
            flags: hasEnclosingTypeParameterReference isSynthetic shouldUseTypeForInitializerInference
            type: typeParameter#0
        declaredSetters
          foo1=: #M5
            flags: hasEnclosingTypeParameterReference hasImplicitReturnType isAbstract isSimplyBounded
            functionType: FunctionType
              positional
                required typeParameter#0
              returnType: void
          foo2=: #M6
            flags: hasImplicitReturnType isAbstract isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
          foo3=: #M12
            flags: hasImplicitReturnType isAbstract isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
          foo4=: #M13
            flags: hasEnclosingTypeParameterReference hasImplicitReturnType isAbstract isSimplyBounded
            functionType: FunctionType
              positional
                required typeParameter#0
              returnType: void
        interface: #M14
          map
            foo1=: #M5
            foo2=: #M6
            foo3=: #M12
            foo4=: #M13
''',
    );
  }

  test_manifest_mixin_setter_modifier_invokesSuperSelf() async {
    configuration.withElementManifests = true;
    await _runLibraryManifestScenario(
      initialCode: r'''
class S {
  set foo1(int value) {}
  set foo2(int value) {}
  set foo3(int value) {}
  set foo4(int value) {}
}
mixin M on S {
  set foo1(int value) {}
  set foo2(int value) { super.foo2 = value; }
  set foo3(int value) {}
  set foo4(int value) { super.foo4 = value; }
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      S: #M0
        supertype: Object @ dart:core
        declaredFields
          foo1: #M1
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo2: #M2
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo3: #M3
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo4: #M4
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
        declaredSetters
          foo1=: #M5
            flags: hasImplicitReturnType isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
          foo2=: #M6
            flags: hasImplicitReturnType isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
          foo3=: #M7
            flags: hasImplicitReturnType isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
          foo4=: #M8
            flags: hasImplicitReturnType isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
        interface: #M9
          map
            foo1=: #M5
            foo2=: #M6
            foo3=: #M7
            foo4=: #M8
          implemented
            foo1=: #M5
            foo2=: #M6
            foo3=: #M7
            foo4=: #M8
    declaredMixins
      M: #M10
        superclassConstraints
          S @ package:test/test.dart
        declaredFields
          foo1: #M11
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo2: #M12
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo3: #M13
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo4: #M14
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
        declaredSetters
          foo1=: #M15
            flags: hasImplicitReturnType isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
          foo2=: #M16
            flags: hasImplicitReturnType invokesSuperSelf isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
          foo3=: #M17
            flags: hasImplicitReturnType isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
          foo4=: #M18
            flags: hasImplicitReturnType invokesSuperSelf isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
        interface: #M19
          map
            foo1=: #M15
            foo2=: #M16
            foo3=: #M17
            foo4=: #M18
          implemented
            foo1=: #M15
            foo2=: #M16
            foo3=: #M17
            foo4=: #M18
          superImplemented
            [0]
              foo1=: #M5
              foo2=: #M6
              foo3=: #M7
              foo4=: #M8
          inherited
            foo1=: #M5
            foo2=: #M6
            foo3=: #M7
            foo4=: #M8
''',
      updatedCode: r'''
class S {
  set foo1(int value) {}
  set foo2(int value) {}
  set foo3(int value) {}
  set foo4(int value) {}
}
mixin M on S {
  set foo1(int value) {}
  set foo2(int value) { super.foo2 = value; }
  set foo3(int value) { super.foo3 = value; }
  set foo4(int value) {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      S: #M0
        supertype: Object @ dart:core
        declaredFields
          foo1: #M1
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo2: #M2
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo3: #M3
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo4: #M4
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
        declaredSetters
          foo1=: #M5
            flags: hasImplicitReturnType isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
          foo2=: #M6
            flags: hasImplicitReturnType isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
          foo3=: #M7
            flags: hasImplicitReturnType isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
          foo4=: #M8
            flags: hasImplicitReturnType isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
        interface: #M9
          map
            foo1=: #M5
            foo2=: #M6
            foo3=: #M7
            foo4=: #M8
          implemented
            foo1=: #M5
            foo2=: #M6
            foo3=: #M7
            foo4=: #M8
    declaredMixins
      M: #M20
        superclassConstraints
          S @ package:test/test.dart
        declaredFields
          foo1: #M21
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo2: #M22
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo3: #M23
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo4: #M24
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
        declaredSetters
          foo1=: #M25
            flags: hasImplicitReturnType isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
          foo2=: #M26
            flags: hasImplicitReturnType invokesSuperSelf isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
          foo3=: #M27
            flags: hasImplicitReturnType invokesSuperSelf isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
          foo4=: #M28
            flags: hasImplicitReturnType isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
        interface: #M29
          map
            foo1=: #M25
            foo2=: #M26
            foo3=: #M27
            foo4=: #M28
          implemented
            foo1=: #M25
            foo2=: #M26
            foo3=: #M27
            foo4=: #M28
          superImplemented
            [0]
              foo1=: #M5
              foo2=: #M6
              foo3=: #M7
              foo4=: #M8
          inherited
            foo1=: #M5
            foo2=: #M6
            foo3=: #M7
            foo4=: #M8
''',
    );
  }

  test_manifest_mixin_setter_modifier_isAbstract() async {
    configuration.withElementManifests = true;
    await _runLibraryManifestScenario(
      initialCode: r'''
mixin M {
  set foo1(int value) {}
  set foo2(int value);
  set foo3(int value) {}
  set foo4(int value);
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      M: #M0
        superclassConstraints
          Object @ dart:core
        declaredFields
          foo1: #M1
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo2: #M2
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo3: #M3
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo4: #M4
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
        declaredSetters
          foo1=: #M5
            flags: hasImplicitReturnType isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
          foo2=: #M6
            flags: hasImplicitReturnType isAbstract isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
          foo3=: #M7
            flags: hasImplicitReturnType isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
          foo4=: #M8
            flags: hasImplicitReturnType isAbstract isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
        interface: #M9
          map
            foo1=: #M5
            foo2=: #M6
            foo3=: #M7
            foo4=: #M8
          implemented
            foo1=: #M5
            foo3=: #M7
''',
      updatedCode: r'''
mixin M {
  set foo1(int value) {}
  set foo2(int value);
  set foo3(int value);
  set foo4(int value) {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      M: #M0
        superclassConstraints
          Object @ dart:core
        declaredFields
          foo1: #M1
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo2: #M2
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo3: #M3
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo4: #M4
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
        declaredSetters
          foo1=: #M5
            flags: hasImplicitReturnType isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
          foo2=: #M6
            flags: hasImplicitReturnType isAbstract isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
          foo3=: #M10
            flags: hasImplicitReturnType isAbstract isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
          foo4=: #M11
            flags: hasImplicitReturnType isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
        interface: #M12
          map
            foo1=: #M5
            foo2=: #M6
            foo3=: #M10
            foo4=: #M11
          implemented
            foo1=: #M5
            foo4=: #M11
''',
    );
  }

  test_manifest_mixin_setter_modifier_isExternal() async {
    configuration.withElementManifests = true;
    await _runLibraryManifestScenario(
      initialCode: r'''
mixin M {
  set foo1(int value) {}
  external set foo2(int value);
  set foo3(int value) {}
  external set foo4(int value);
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      M: #M0
        superclassConstraints
          Object @ dart:core
        declaredFields
          foo1: #M1
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo2: #M2
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo3: #M3
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo4: #M4
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
        declaredSetters
          foo1=: #M5
            flags: hasImplicitReturnType isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
          foo2=: #M6
            flags: hasImplicitReturnType isExternal isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
          foo3=: #M7
            flags: hasImplicitReturnType isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
          foo4=: #M8
            flags: hasImplicitReturnType isExternal isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
        interface: #M9
          map
            foo1=: #M5
            foo2=: #M6
            foo3=: #M7
            foo4=: #M8
          implemented
            foo1=: #M5
            foo2=: #M6
            foo3=: #M7
            foo4=: #M8
''',
      updatedCode: r'''
mixin M {
  set foo1(int value) {}
  external set foo2(int value);
  external set foo3(int value);
  set foo4(int value) {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      M: #M0
        superclassConstraints
          Object @ dart:core
        declaredFields
          foo1: #M1
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo2: #M2
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo3: #M3
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo4: #M4
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
        declaredSetters
          foo1=: #M5
            flags: hasImplicitReturnType isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
          foo2=: #M6
            flags: hasImplicitReturnType isExternal isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
          foo3=: #M10
            flags: hasImplicitReturnType isExternal isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
          foo4=: #M11
            flags: hasImplicitReturnType isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
        interface: #M12
          map
            foo1=: #M5
            foo2=: #M6
            foo3=: #M10
            foo4=: #M11
          implemented
            foo1=: #M5
            foo2=: #M6
            foo3=: #M10
            foo4=: #M11
''',
    );
  }

  test_manifest_mixin_setter_modifier_isStatic() async {
    configuration.withElementManifests = true;
    await _runLibraryManifestScenario(
      initialCode: r'''
mixin M {
  set foo1(int value) {}
  static set foo2(int value) {}
  set foo3(int value) {}
  static set foo4(int value) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      M: #M0
        superclassConstraints
          Object @ dart:core
        declaredFields
          foo1: #M1
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo2: #M2
            flags: isStatic isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo3: #M3
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo4: #M4
            flags: isStatic isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
        declaredSetters
          foo1=: #M5
            flags: hasImplicitReturnType isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
          foo2=: #M6
            flags: hasImplicitReturnType isSimplyBounded isStatic
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
          foo3=: #M7
            flags: hasImplicitReturnType isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
          foo4=: #M8
            flags: hasImplicitReturnType isSimplyBounded isStatic
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
        interface: #M9
          map
            foo1=: #M5
            foo3=: #M7
          implemented
            foo1=: #M5
            foo3=: #M7
''',
      updatedCode: r'''
mixin M {
  set foo1(int value) {}
  static set foo2(int value) {}
  static set foo3(int value) {}
  set foo4(int value) {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      M: #M0
        superclassConstraints
          Object @ dart:core
        declaredFields
          foo1: #M1
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo2: #M2
            flags: isStatic isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo3: #M10
            flags: isStatic isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
          foo4: #M11
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
        declaredSetters
          foo1=: #M5
            flags: hasImplicitReturnType isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
          foo2=: #M6
            flags: hasImplicitReturnType isSimplyBounded isStatic
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
          foo3=: #M12
            flags: hasImplicitReturnType isSimplyBounded isStatic
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
          foo4=: #M13
            flags: hasImplicitReturnType isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
        interface: #M14
          map
            foo1=: #M5
            foo4=: #M13
          implemented
            foo1=: #M5
            foo4=: #M13
''',
    );
  }

  test_manifest_mixin_setter_private_instance() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
mixin A {
  set _foo(int _) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        declaredFields
          _foo: #M1
        declaredSetters
          _foo=: #M2
        interface: #M3
''',
      updatedCode: r'''
mixin A {
  set _foo(int _) {}
  set bar(int _) {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        declaredFields
          _foo: #M1
          bar: #M4
        declaredSetters
          _foo=: #M2
          bar=: #M5
        interface: #M6
          map
            bar=: #M5
          implemented
            bar=: #M5
''',
    );
  }

  test_manifest_mixin_setter_private_static() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
mixin A {
  static set _foo(int _) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        declaredFields
          _foo: #M1
        declaredSetters
          _foo=: #M2
        interface: #M3
''',
      updatedCode: r'''
mixin A {
  static set _foo(int _) {}
  set bar(int _) {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        declaredFields
          _foo: #M1
          bar: #M4
        declaredSetters
          _foo=: #M2
          bar=: #M5
        interface: #M6
          map
            bar=: #M5
          implemented
            bar=: #M5
''',
    );
  }

  test_manifest_mixin_setter_static() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
mixin A {
  static set foo(int _) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        declaredFields
          foo: #M1
        declaredSetters
          foo=: #M2
        interface: #M3
''',
      updatedCode: r'''
mixin A {
  static set foo(int _) {}
  static set bar(int _) {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        declaredFields
          bar: #M4
          foo: #M1
        declaredSetters
          bar=: #M5
          foo=: #M2
        interface: #M3
''',
    );
  }

  test_manifest_mixin_setter_static_falseToTrue() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
mixin A {
  set foo(int _) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        declaredFields
          foo: #M1
        declaredSetters
          foo=: #M2
        interface: #M3
          map
            foo=: #M2
          implemented
            foo=: #M2
''',
      updatedCode: r'''
mixin A {
  static set foo(int _) {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        declaredFields
          foo: #M4
        declaredSetters
          foo=: #M5
        interface: #M6
''',
    );
  }

  test_manifest_mixin_setter_static_trueToFalse() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
mixin A {
  static set foo(int _) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        declaredFields
          foo: #M1
        declaredSetters
          foo=: #M2
        interface: #M3
''',
      updatedCode: r'''
mixin A {
  set foo(int _) {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        declaredFields
          foo: #M4
        declaredSetters
          foo=: #M5
        interface: #M6
          map
            foo=: #M5
          implemented
            foo=: #M5
''',
    );
  }

  test_manifest_mixin_setter_static_valueType() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
mixin A {
  static set foo(int _) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        declaredFields
          foo: #M1
        declaredSetters
          foo=: #M2
        interface: #M3
''',
      updatedCode: r'''
mixin A {
  static set foo(double _) {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        declaredFields
          foo: #M4
        declaredSetters
          foo=: #M5
        interface: #M3
''',
    );
  }

  test_manifest_mixin_setter_valueType() async {
    configuration.withElementManifests = true;
    await _runLibraryManifestScenario(
      initialCode: r'''
mixin A {
  set foo(int _) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        superclassConstraints
          Object @ dart:core
        declaredFields
          foo: #M1
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: int @ dart:core
        declaredSetters
          foo=: #M2
            flags: hasImplicitReturnType isSimplyBounded
            functionType: FunctionType
              positional
                required int @ dart:core
              returnType: void
        interface: #M3
          map
            foo=: #M2
          implemented
            foo=: #M2
''',
      updatedCode: r'''
mixin A {
  set foo(double _) {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        superclassConstraints
          Object @ dart:core
        declaredFields
          foo: #M4
            flags: isSynthetic shouldUseTypeForInitializerInference
            type: double @ dart:core
        declaredSetters
          foo=: #M5
            flags: hasImplicitReturnType isSimplyBounded
            functionType: FunctionType
              positional
                required double @ dart:core
              returnType: void
        interface: #M6
          map
            foo=: #M5
          implemented
            foo=: #M5
''',
    );
  }

  test_manifest_mixin_superInvokedNames_invokedToInvoked_reorder() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
mixin M {
  void f() {
    super.foo();
    super.bar;
    super.baz = 0;
  }
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      M: #M0
        declaredMethods
          f: #M1
        interface: #M2
          map
            f: #M1
          implemented
            f: #M1
''',
      updatedCode: r'''
class A {}
mixin M {
  void f() {
    super.baz = 0;
    super.bar;
    super.foo();
  }
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M3
        interface: #M4
    declaredMixins
      M: #M0
        declaredMethods
          f: #M1
        interface: #M2
          map
            f: #M1
          implemented
            f: #M1
''',
    );
  }

  test_manifest_mixin_superInvokedNames_invokedToNot_getter() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  int get foo => 0;
}

mixin M on A {
  void f() {
    super.foo;
  }
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        interface: #M3
          map
            foo: #M2
          implemented
            foo: #M2
    declaredMixins
      M: #M4
        declaredMethods
          f: #M5
        interface: #M6
          map
            f: #M5
            foo: #M2
          implemented
            f: #M5
          superImplemented
            [0]
              foo: #M2
          inherited
            foo: #M2
''',
      updatedCode: r'''
class A {
  int get foo => 0;
}

mixin M on A {
  void f() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        interface: #M3
          map
            foo: #M2
          implemented
            foo: #M2
    declaredMixins
      M: #M7
        declaredMethods
          f: #M8
        interface: #M9
          map
            f: #M8
            foo: #M2
          implemented
            f: #M8
          superImplemented
            [0]
              foo: #M2
          inherited
            foo: #M2
''',
    );
  }

  test_manifest_mixin_superInvokedNames_invokedToNot_method() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  void foo() {}
}

mixin M on A {
  void f() {
    super.foo();
  }
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
    declaredMixins
      M: #M3
        declaredMethods
          f: #M4
        interface: #M5
          map
            f: #M4
            foo: #M1
          implemented
            f: #M4
          superImplemented
            [0]
              foo: #M1
          inherited
            foo: #M1
''',
      updatedCode: r'''
class A {
  void foo() {}
}

mixin M on A {
  void f() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
    declaredMixins
      M: #M6
        declaredMethods
          f: #M7
        interface: #M8
          map
            f: #M7
            foo: #M1
          implemented
            f: #M7
          superImplemented
            [0]
              foo: #M1
          inherited
            foo: #M1
''',
    );
  }

  test_manifest_mixin_superInvokedNames_invokedToNot_setter() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  set foo(int _) {}
}

mixin M on A {
  void f() {
    super.foo = 0;
  }
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredSetters
          foo=: #M2
        interface: #M3
          map
            foo=: #M2
          implemented
            foo=: #M2
    declaredMixins
      M: #M4
        declaredMethods
          f: #M5
        interface: #M6
          map
            f: #M5
            foo=: #M2
          implemented
            f: #M5
          superImplemented
            [0]
              foo=: #M2
          inherited
            foo=: #M2
''',
      updatedCode: r'''
class A {
  set foo(int _) {}
}

mixin M on A {
  void f() {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredSetters
          foo=: #M2
        interface: #M3
          map
            foo=: #M2
          implemented
            foo=: #M2
    declaredMixins
      M: #M7
        declaredMethods
          f: #M8
        interface: #M9
          map
            f: #M8
            foo=: #M2
          implemented
            f: #M8
          superImplemented
            [0]
              foo=: #M2
          inherited
            foo=: #M2
''',
    );
  }

  test_manifest_mixin_superInvokedNames_notToInvoked_getter() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  int get foo => 0;
}

mixin M on A {
  void f() {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        interface: #M3
          map
            foo: #M2
          implemented
            foo: #M2
    declaredMixins
      M: #M4
        declaredMethods
          f: #M5
        interface: #M6
          map
            f: #M5
            foo: #M2
          implemented
            f: #M5
          superImplemented
            [0]
              foo: #M2
          inherited
            foo: #M2
''',
      updatedCode: r'''
class A {
  int get foo => 0;
}

mixin M on A {
  void f() {
    super.foo;
  }
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        interface: #M3
          map
            foo: #M2
          implemented
            foo: #M2
    declaredMixins
      M: #M7
        declaredMethods
          f: #M8
        interface: #M9
          map
            f: #M8
            foo: #M2
          implemented
            f: #M8
          superImplemented
            [0]
              foo: #M2
          inherited
            foo: #M2
''',
    );
  }

  test_manifest_mixin_superInvokedNames_notToInvoked_method() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  void foo() {}
}

mixin M on A {
  void f() {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
    declaredMixins
      M: #M3
        declaredMethods
          f: #M4
        interface: #M5
          map
            f: #M4
            foo: #M1
          implemented
            f: #M4
          superImplemented
            [0]
              foo: #M1
          inherited
            foo: #M1
''',
      updatedCode: r'''
class A {
  void foo() {}
}

mixin M on A {
  void f() {
    super.foo();
  }
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
    declaredMixins
      M: #M6
        declaredMethods
          f: #M7
        interface: #M8
          map
            f: #M7
            foo: #M1
          implemented
            f: #M7
          superImplemented
            [0]
              foo: #M1
          inherited
            foo: #M1
''',
    );
  }

  test_manifest_mixin_superInvokedNames_notToInvoked_setter() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
class A {
  set foo(int _) {}
}

mixin M on A {
  void f() {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredSetters
          foo=: #M2
        interface: #M3
          map
            foo=: #M2
          implemented
            foo=: #M2
    declaredMixins
      M: #M4
        declaredMethods
          f: #M5
        interface: #M6
          map
            f: #M5
            foo=: #M2
          implemented
            f: #M5
          superImplemented
            [0]
              foo=: #M2
          inherited
            foo=: #M2
''',
      updatedCode: r'''
class A {
  set foo(int _) {}
}

mixin M on A {
  void f() {
    super.foo = 0;
  }
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredSetters
          foo=: #M2
        interface: #M3
          map
            foo=: #M2
          implemented
            foo=: #M2
    declaredMixins
      M: #M7
        declaredMethods
          f: #M8
        interface: #M9
          map
            f: #M8
            foo=: #M2
          implemented
            f: #M8
          superImplemented
            [0]
              foo=: #M2
          inherited
            foo=: #M2
''',
    );
  }

  test_manifest_mixin_typeParameters() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
mixin A<T> {
  void foo(T _) {}
}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
          map
            foo: #M1
          implemented
            foo: #M1
''',
      updatedCode: r'''
mixin A<T> {
  void foo(T _) {}
  void bar(T _) {}
}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        declaredMethods
          bar: #M3
          foo: #M1
        interface: #M4
          map
            bar: #M3
            foo: #M1
          implemented
            bar: #M3
            foo: #M1
''',
    );
  }

  test_manifest_mixin_typeParameters_add() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
mixin A<T> {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        interface: #M1
''',
      updatedCode: r'''
mixin A<T, U> {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M2
        interface: #M3
''',
    );
  }

  test_manifest_mixin_typeParameters_variance() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
mixin A<in T> {}
mixin B<out T> {}
mixin C<in T> {}
mixin D<out T> {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        interface: #M1
      B: #M2
        interface: #M3
      C: #M4
        interface: #M5
      D: #M6
        interface: #M7
''',
      updatedCode: r'''
mixin A<in T> {}
mixin B<out T> {}
mixin C<out T> {}
mixin D<in T> {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredMixins
      A: #M0
        interface: #M1
      B: #M2
        interface: #M3
      C: #M8
        interface: #M9
      D: #M10
        interface: #M11
''',
    );
  }

  test_manifest_topLevelFunction_add() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
void foo() {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      foo: #M0
''',
      updatedCode: r'''
void foo() {}
void bar() {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      bar: #M1
      foo: #M0
''',
    );
  }

  test_manifest_topLevelFunction_formalParameter_optionalNamed() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
void foo({int a}) {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      foo: #M0
''',
      updatedCode: r'''
void foo({int a}) {}
void bar() {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      bar: #M1
      foo: #M0
''',
    );
  }

  test_manifest_topLevelFunction_formalParameter_optionalNamed_defaultValue() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
void foo({int a = 0}) {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      foo: #M0
''',
      updatedCode: r'''
void foo({int a = 0}) {}
void bar() {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      bar: #M1
      foo: #M0
''',
    );
  }

  test_manifest_topLevelFunction_formalParameter_optionalNamed_defaultValue_change() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
void foo({int a = 0}) {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      foo: #M0
''',
      updatedCode: r'''
void foo({int a = 1}) {}
void bar() {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      bar: #M1
      foo: #M2
''',
    );
  }

  test_manifest_topLevelFunction_formalParameter_optionalNamed_name() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
void foo({int a}) {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      foo: #M0
''',
      updatedCode: r'''
void foo({int b}) {}
void bar() {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      bar: #M1
      foo: #M2
''',
    );
  }

  test_manifest_topLevelFunction_formalParameter_optionalNamed_type() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
void foo({int a}) {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      foo: #M0
''',
      updatedCode: r'''
void foo({double a}) {}
void bar() {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      bar: #M1
      foo: #M2
''',
    );
  }

  test_manifest_topLevelFunction_formalParameter_optionalPositional() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
void foo([int a]) {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      foo: #M0
''',
      updatedCode: r'''
void foo([int a]) {}
void bar() {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      bar: #M1
      foo: #M0
''',
    );
  }

  test_manifest_topLevelFunction_formalParameter_optionalPositional_defaultValue() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
void foo([int a = 0]) {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      foo: #M0
''',
      updatedCode: r'''
void foo([int a = 0]) {}
void bar() {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      bar: #M1
      foo: #M0
''',
    );
  }

  test_manifest_topLevelFunction_formalParameter_optionalPositional_defaultValue_change() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
void foo([int a = 0]) {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      foo: #M0
''',
      updatedCode: r'''
void foo([int a = 1]) {}
void bar() {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      bar: #M1
      foo: #M2
''',
    );
  }

  test_manifest_topLevelFunction_formalParameter_optionalPositional_name() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
void foo([int a]) {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      foo: #M0
''',
      updatedCode: r'''
void foo([int b]) {}
void bar() {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      bar: #M1
      foo: #M0
''',
    );
  }

  test_manifest_topLevelFunction_formalParameter_optionalPositional_type() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
void foo([int a]) {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      foo: #M0
''',
      updatedCode: r'''
void foo([double a]) {}
void bar() {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      bar: #M1
      foo: #M2
''',
    );
  }

  test_manifest_topLevelFunction_formalParameter_requiredNamed() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
void foo({required int a}) {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      foo: #M0
''',
      updatedCode: r'''
void foo({required int a}) {}
void bar() {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      bar: #M1
      foo: #M0
''',
    );
  }

  test_manifest_topLevelFunction_formalParameter_requiredNamed_name() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
void foo({required int a}) {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      foo: #M0
''',
      updatedCode: r'''
void foo({required int b}) {}
void bar() {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      bar: #M1
      foo: #M2
''',
    );
  }

  test_manifest_topLevelFunction_formalParameter_requiredNamed_toRequiredPositional() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
void foo({required int a}) {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      foo: #M0
''',
      updatedCode: r'''
void foo(int a) {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      foo: #M1
''',
    );
  }

  test_manifest_topLevelFunction_formalParameter_requiredNamed_type() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
void foo({required int a}) {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      foo: #M0
''',
      updatedCode: r'''
void foo({required double a}) {}
void bar() {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      bar: #M1
      foo: #M2
''',
    );
  }

  test_manifest_topLevelFunction_formalParameter_requiredPositional() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
void foo(int a) {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      foo: #M0
''',
      updatedCode: r'''
void foo(int a) {}
void bar() {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      bar: #M1
      foo: #M0
''',
    );
  }

  test_manifest_topLevelFunction_formalParameter_requiredPositional_name() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
void foo(int a) {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      foo: #M0
''',
      updatedCode: r'''
void foo(int b) {}
void bar() {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      bar: #M1
      foo: #M0
''',
    );
  }

  test_manifest_topLevelFunction_formalParameter_requiredPositional_toRequiredNamed() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
void foo(int a) {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      foo: #M0
''',
      updatedCode: r'''
void foo({required int a}) {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      foo: #M1
''',
    );
  }

  test_manifest_topLevelFunction_formalParameter_requiredPositional_type() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
void foo(int a) {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      foo: #M0
''',
      updatedCode: r'''
void foo(double a) {}
void bar() {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      bar: #M1
      foo: #M2
''',
    );
  }

  test_manifest_topLevelFunction_metadata() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
@Deprected('0')
void a() {}
@Deprected('0')
void b() {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      a: #M0
      b: #M1
''',
      updatedCode: r'''
@Deprected('0')
void a() {}
@Deprected('1')
void b() {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      a: #M0
      b: #M2
''',
    );
  }

  test_manifest_topLevelFunction_modifier_hasImplicitReturnType() async {
    configuration.withElementManifests = true;
    await _runLibraryManifestScenario(
      initialCode: r'''
foo1() {}
void foo2() {}
foo3() {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      foo1: #M0
        flags: hasEnclosingTypeParameterReference hasImplicitReturnType isSimplyBounded isStatic
        functionType: FunctionType
          returnType: dynamic
      foo2: #M1
        flags: hasEnclosingTypeParameterReference isSimplyBounded isStatic
        functionType: FunctionType
          returnType: void
      foo3: #M2
        flags: hasEnclosingTypeParameterReference hasImplicitReturnType isSimplyBounded isStatic
        functionType: FunctionType
          returnType: dynamic
''',
      updatedCode: r'''
foo1() {}
foo2() {}
void foo3() {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      foo1: #M0
        flags: hasEnclosingTypeParameterReference hasImplicitReturnType isSimplyBounded isStatic
        functionType: FunctionType
          returnType: dynamic
      foo2: #M3
        flags: hasEnclosingTypeParameterReference hasImplicitReturnType isSimplyBounded isStatic
        functionType: FunctionType
          returnType: dynamic
      foo3: #M4
        flags: hasEnclosingTypeParameterReference isSimplyBounded isStatic
        functionType: FunctionType
          returnType: void
''',
    );
  }

  test_manifest_topLevelFunction_modifier_isExternal() async {
    configuration.withElementManifests = true;
    await _runLibraryManifestScenario(
      initialCode: r'''
void foo1() {}
external void foo2();
void foo3() {}
external void foo4();
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      foo1: #M0
        flags: hasEnclosingTypeParameterReference isSimplyBounded isStatic
        functionType: FunctionType
          returnType: void
      foo2: #M1
        flags: hasEnclosingTypeParameterReference isExternal isSimplyBounded isStatic
        functionType: FunctionType
          returnType: void
      foo3: #M2
        flags: hasEnclosingTypeParameterReference isSimplyBounded isStatic
        functionType: FunctionType
          returnType: void
      foo4: #M3
        flags: hasEnclosingTypeParameterReference isExternal isSimplyBounded isStatic
        functionType: FunctionType
          returnType: void
''',
      updatedCode: r'''
void foo1() {}
external void foo2();
external void foo3();
void foo4() {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      foo1: #M0
        flags: hasEnclosingTypeParameterReference isSimplyBounded isStatic
        functionType: FunctionType
          returnType: void
      foo2: #M1
        flags: hasEnclosingTypeParameterReference isExternal isSimplyBounded isStatic
        functionType: FunctionType
          returnType: void
      foo3: #M4
        flags: hasEnclosingTypeParameterReference isExternal isSimplyBounded isStatic
        functionType: FunctionType
          returnType: void
      foo4: #M5
        flags: hasEnclosingTypeParameterReference isSimplyBounded isStatic
        functionType: FunctionType
          returnType: void
''',
    );
  }

  test_manifest_topLevelFunction_private() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
void _foo() {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      _foo: #M0
''',
      updatedCode: r'''
void _foo() {}
void bar() {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      _foo: #M0
      bar: #M1
''',
    );
  }

  test_manifest_topLevelFunction_returnType() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
int foo() {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      foo: #M0
''',
      updatedCode: r'''
double foo() {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      foo: #M1
''',
    );
  }

  test_manifest_topLevelFunction_typeParameter() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
Map<T, U> foo<T extends num, U>() {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      foo: #M0
''',
      updatedCode: r'''
Map<T, U> foo<T, U>() {}
void bar() {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      bar: #M1
      foo: #M2
''',
    );
  }

  test_manifest_topLevelFunction_typeParameter_add() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
void foo<T>() {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      foo: #M0
''',
      updatedCode: r'''
void foo<T, U>() {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      foo: #M1
''',
    );
  }

  test_manifest_topLevelFunction_typeParameter_bound() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
void foo<T extends num>() {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      foo: #M0
''',
      updatedCode: r'''
void foo<T extends int>() {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      foo: #M1
''',
    );
  }

  test_manifest_topLevelFunction_typeParameter_remove() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
void foo<T, U>() {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      foo: #M0
''',
      updatedCode: r'''
void foo<T>() {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      foo: #M1
''',
    );
  }

  test_manifest_topLevelGetter_add() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
int get a => 0;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
    declaredVariables
      a: #M1
''',
      updatedCode: r'''
int get a => 0;
int get b => 0;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
      b: #M2
    declaredVariables
      a: #M1
      b: #M3
''',
    );
  }

  test_manifest_topLevelGetter_body() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
int get a => 0;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
    declaredVariables
      a: #M1
''',
      updatedCode: r'''
int get a => 1;
''',
      expectedUpdatedEvents: r'''
[operation] reuseLinkedBundle
  package:test/test.dart
''',
    );
  }

  test_manifest_topLevelGetter_isSynthetic() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
final int foo = 0;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      foo: #M0
    declaredVariables
      foo: #M1
''',
      updatedCode: r'''
int get foo => 0;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      foo: #M2
    declaredVariables
      foo: #M3
''',
    );
  }

  test_manifest_topLevelGetter_metadata() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
@Deprecated('0')
int get a => 0;
@Deprecated('0')
int get b => 0;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
      b: #M1
    declaredVariables
      a: #M2
      b: #M3
''',
      updatedCode: r'''
@Deprecated('0')
int get a => 0;
@Deprecated('1')
int get b => 0;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
      b: #M4
    declaredVariables
      a: #M2
      b: #M3
''',
    );
  }

  test_manifest_topLevelGetter_modifier_hasImplicitReturnType() async {
    configuration.withElementManifests = true;
    await _runLibraryManifestScenario(
      initialCode: r'''
get foo1 => 0;
int get foo2 => 0;
get foo3 => 0;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      foo1: #M0
        flags: hasImplicitReturnType isSimplyBounded isStatic
        returnType: dynamic
      foo2: #M1
        flags: isSimplyBounded isStatic
        returnType: int @ dart:core
      foo3: #M2
        flags: hasImplicitReturnType isSimplyBounded isStatic
        returnType: dynamic
    declaredVariables
      foo1: #M3
        flags: isStatic isSynthetic shouldUseTypeForInitializerInference
        type: dynamic
      foo2: #M4
        flags: isStatic isSynthetic shouldUseTypeForInitializerInference
        type: int @ dart:core
      foo3: #M5
        flags: isStatic isSynthetic shouldUseTypeForInitializerInference
        type: dynamic
''',
      updatedCode: r'''
get foo1 => 0;
get foo2 => 0;
int get foo3 => 0;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      foo1: #M0
        flags: hasImplicitReturnType isSimplyBounded isStatic
        returnType: dynamic
      foo2: #M6
        flags: hasImplicitReturnType isSimplyBounded isStatic
        returnType: dynamic
      foo3: #M7
        flags: isSimplyBounded isStatic
        returnType: int @ dart:core
    declaredVariables
      foo1: #M3
        flags: isStatic isSynthetic shouldUseTypeForInitializerInference
        type: dynamic
      foo2: #M8
        flags: isStatic isSynthetic shouldUseTypeForInitializerInference
        type: dynamic
      foo3: #M9
        flags: isStatic isSynthetic shouldUseTypeForInitializerInference
        type: int @ dart:core
''',
    );
  }

  test_manifest_topLevelGetter_modifier_isExternal() async {
    configuration.withElementManifests = true;
    await _runLibraryManifestScenario(
      initialCode: r'''
int get foo1 => 1;
external int get foo2;
int get foo3 => 3;
external int get foo4;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      foo1: #M0
        flags: isSimplyBounded isStatic
        returnType: int @ dart:core
      foo2: #M1
        flags: isExternal isSimplyBounded isStatic
        returnType: int @ dart:core
      foo3: #M2
        flags: isSimplyBounded isStatic
        returnType: int @ dart:core
      foo4: #M3
        flags: isExternal isSimplyBounded isStatic
        returnType: int @ dart:core
    declaredVariables
      foo1: #M4
        flags: isStatic isSynthetic shouldUseTypeForInitializerInference
        type: int @ dart:core
      foo2: #M5
        flags: isStatic isSynthetic shouldUseTypeForInitializerInference
        type: int @ dart:core
      foo3: #M6
        flags: isStatic isSynthetic shouldUseTypeForInitializerInference
        type: int @ dart:core
      foo4: #M7
        flags: isStatic isSynthetic shouldUseTypeForInitializerInference
        type: int @ dart:core
''',
      updatedCode: r'''
int get foo1 => 1;
external int get foo2;
external int get foo3;
int get foo4 => 4;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      foo1: #M0
        flags: isSimplyBounded isStatic
        returnType: int @ dart:core
      foo2: #M1
        flags: isExternal isSimplyBounded isStatic
        returnType: int @ dart:core
      foo3: #M8
        flags: isExternal isSimplyBounded isStatic
        returnType: int @ dart:core
      foo4: #M9
        flags: isSimplyBounded isStatic
        returnType: int @ dart:core
    declaredVariables
      foo1: #M4
        flags: isStatic isSynthetic shouldUseTypeForInitializerInference
        type: int @ dart:core
      foo2: #M5
        flags: isStatic isSynthetic shouldUseTypeForInitializerInference
        type: int @ dart:core
      foo3: #M6
        flags: isStatic isSynthetic shouldUseTypeForInitializerInference
        type: int @ dart:core
      foo4: #M7
        flags: isStatic isSynthetic shouldUseTypeForInitializerInference
        type: int @ dart:core
''',
    );
  }

  test_manifest_topLevelGetter_private() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
int get _a => 0;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      _a: #M0
    declaredVariables
      _a: #M1
''',
      updatedCode: r'''
int get _a => 0;
int get b => 0;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      _a: #M0
      b: #M2
    declaredVariables
      _a: #M1
      b: #M3
''',
    );
  }

  test_manifest_topLevelGetter_returnType() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
int get a => 0;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
    declaredVariables
      a: #M1
''',
      updatedCode: r'''
double get a => 0;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M2
    declaredVariables
      a: #M3
''',
    );
  }

  test_manifest_topLevelSetter_add() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
set a(int _) {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredSetters
      a=: #M0
    declaredVariables
      a: #M1
''',
      updatedCode: r'''
set a(int _) {}
set b(int _) {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredSetters
      a=: #M0
      b=: #M2
    declaredVariables
      a: #M1
      b: #M3
''',
    );
  }

  test_manifest_topLevelSetter_body() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
set a(int _) { 0; }
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredSetters
      a=: #M0
    declaredVariables
      a: #M1
''',
      updatedCode: r'''
set a(int _) { 1; }
''',
      expectedUpdatedEvents: r'''
[operation] reuseLinkedBundle
  package:test/test.dart
''',
    );
  }

  test_manifest_topLevelSetter_isSynthetic() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
int foo = 0;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      foo: #M0
    declaredSetters
      foo=: #M1
    declaredVariables
      foo: #M2
''',
      updatedCode: r'''
int get foo => 0;
set foo(int _) {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      foo: #M3
    declaredSetters
      foo=: #M4
    declaredVariables
      foo: #M5
''',
    );
  }

  test_manifest_topLevelSetter_metadata() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
@Deprecated('0')
set a(int _) {}
@Deprecated('0')
set b(int _) {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredSetters
      a=: #M0
      b=: #M1
    declaredVariables
      a: #M2
      b: #M3
''',
      updatedCode: r'''
@Deprecated('0')
set a(int _) {}
@Deprecated('1')
set b(int _) {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredSetters
      a=: #M0
      b=: #M4
    declaredVariables
      a: #M2
      b: #M3
''',
    );
  }

  test_manifest_topLevelSetter_modifier_hasImplicitReturnType() async {
    configuration.withElementManifests = true;
    await _runLibraryManifestScenario(
      initialCode: r'''
set foo1(int value) {}
void set foo2(int value) {}
set foo3(int value) {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredSetters
      foo1=: #M0
        flags: hasImplicitReturnType isSimplyBounded isStatic
        functionType: FunctionType
          positional
            required int @ dart:core
          returnType: void
      foo2=: #M1
        flags: isSimplyBounded isStatic
        functionType: FunctionType
          positional
            required int @ dart:core
          returnType: void
      foo3=: #M2
        flags: hasImplicitReturnType isSimplyBounded isStatic
        functionType: FunctionType
          positional
            required int @ dart:core
          returnType: void
    declaredVariables
      foo1: #M3
        flags: isStatic isSynthetic shouldUseTypeForInitializerInference
        type: int @ dart:core
      foo2: #M4
        flags: isStatic isSynthetic shouldUseTypeForInitializerInference
        type: int @ dart:core
      foo3: #M5
        flags: isStatic isSynthetic shouldUseTypeForInitializerInference
        type: int @ dart:core
''',
      updatedCode: r'''
set foo1(int value) {}
set foo2(int value) {}
void set foo3(int value) {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredSetters
      foo1=: #M0
        flags: hasImplicitReturnType isSimplyBounded isStatic
        functionType: FunctionType
          positional
            required int @ dart:core
          returnType: void
      foo2=: #M6
        flags: hasImplicitReturnType isSimplyBounded isStatic
        functionType: FunctionType
          positional
            required int @ dart:core
          returnType: void
      foo3=: #M7
        flags: isSimplyBounded isStatic
        functionType: FunctionType
          positional
            required int @ dart:core
          returnType: void
    declaredVariables
      foo1: #M3
        flags: isStatic isSynthetic shouldUseTypeForInitializerInference
        type: int @ dart:core
      foo2: #M4
        flags: isStatic isSynthetic shouldUseTypeForInitializerInference
        type: int @ dart:core
      foo3: #M5
        flags: isStatic isSynthetic shouldUseTypeForInitializerInference
        type: int @ dart:core
''',
    );
  }

  test_manifest_topLevelSetter_modifier_isExternal() async {
    configuration.withElementManifests = true;
    await _runLibraryManifestScenario(
      initialCode: r'''
set foo1(int value) {}
external set foo2(int value);
set foo3(int value) {}
external set foo4(int value);
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredSetters
      foo1=: #M0
        flags: hasImplicitReturnType isSimplyBounded isStatic
        functionType: FunctionType
          positional
            required int @ dart:core
          returnType: void
      foo2=: #M1
        flags: hasImplicitReturnType isExternal isSimplyBounded isStatic
        functionType: FunctionType
          positional
            required int @ dart:core
          returnType: void
      foo3=: #M2
        flags: hasImplicitReturnType isSimplyBounded isStatic
        functionType: FunctionType
          positional
            required int @ dart:core
          returnType: void
      foo4=: #M3
        flags: hasImplicitReturnType isExternal isSimplyBounded isStatic
        functionType: FunctionType
          positional
            required int @ dart:core
          returnType: void
    declaredVariables
      foo1: #M4
        flags: isStatic isSynthetic shouldUseTypeForInitializerInference
        type: int @ dart:core
      foo2: #M5
        flags: isStatic isSynthetic shouldUseTypeForInitializerInference
        type: int @ dart:core
      foo3: #M6
        flags: isStatic isSynthetic shouldUseTypeForInitializerInference
        type: int @ dart:core
      foo4: #M7
        flags: isStatic isSynthetic shouldUseTypeForInitializerInference
        type: int @ dart:core
''',
      updatedCode: r'''
set foo1(int value) {}
external set foo2(int value);
external set foo3(int value);
set foo4(int value) {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredSetters
      foo1=: #M0
        flags: hasImplicitReturnType isSimplyBounded isStatic
        functionType: FunctionType
          positional
            required int @ dart:core
          returnType: void
      foo2=: #M1
        flags: hasImplicitReturnType isExternal isSimplyBounded isStatic
        functionType: FunctionType
          positional
            required int @ dart:core
          returnType: void
      foo3=: #M8
        flags: hasImplicitReturnType isExternal isSimplyBounded isStatic
        functionType: FunctionType
          positional
            required int @ dart:core
          returnType: void
      foo4=: #M9
        flags: hasImplicitReturnType isSimplyBounded isStatic
        functionType: FunctionType
          positional
            required int @ dart:core
          returnType: void
    declaredVariables
      foo1: #M4
        flags: isStatic isSynthetic shouldUseTypeForInitializerInference
        type: int @ dart:core
      foo2: #M5
        flags: isStatic isSynthetic shouldUseTypeForInitializerInference
        type: int @ dart:core
      foo3: #M6
        flags: isStatic isSynthetic shouldUseTypeForInitializerInference
        type: int @ dart:core
      foo4: #M7
        flags: isStatic isSynthetic shouldUseTypeForInitializerInference
        type: int @ dart:core
''',
    );
  }

  test_manifest_topLevelSetter_valueType() async {
    configuration.withElementManifests = true;
    await _runLibraryManifestScenario(
      initialCode: r'''
set a(int _) {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredSetters
      a=: #M0
        flags: hasImplicitReturnType isSimplyBounded isStatic
        functionType: FunctionType
          positional
            required int @ dart:core
          returnType: void
    declaredVariables
      a: #M1
        flags: isStatic isSynthetic shouldUseTypeForInitializerInference
        type: int @ dart:core
''',
      updatedCode: r'''
set a(double _) {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredSetters
      a=: #M2
        flags: hasImplicitReturnType isSimplyBounded isStatic
        functionType: FunctionType
          positional
            required double @ dart:core
          returnType: void
    declaredVariables
      a: #M3
        flags: isStatic isSynthetic shouldUseTypeForInitializerInference
        type: double @ dart:core
''',
    );
  }

  test_manifest_topLevelVariable_add() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
final a = 0;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
    declaredVariables
      a: #M1
''',
      updatedCode: r'''
final a = 0;
final b = 1;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
      b: #M2
    declaredVariables
      a: #M1
      b: #M3
''',
    );
  }

  test_manifest_topLevelVariable_initializer_type() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
final a = 0;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
    declaredVariables
      a: #M1
''',
      updatedCode: r'''
final a = 1.2;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M2
    declaredVariables
      a: #M3
''',
    );
  }

  test_manifest_topLevelVariable_initializer_value_const() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
const a = 0;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
    declaredVariables
      a: #M1
''',
      updatedCode: r'''
const a = 1;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
    declaredVariables
      a: #M2
''',
    );
  }

  test_manifest_topLevelVariable_initializer_value_final() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
final a = 0;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
    declaredVariables
      a: #M1
''',
      updatedCode: r'''
final a = 1;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
    declaredVariables
      a: #M1
''',
    );
  }

  test_manifest_topLevelVariable_metadata() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
@Deprecated('0')
var a = 0;
@Deprecated('0')
var b = 0;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
      b: #M1
    declaredSetters
      a=: #M2
      b=: #M3
    declaredVariables
      a: #M4
      b: #M5
''',
      updatedCode: r'''
@Deprecated('0')
var a = 0;
@Deprecated('1')
var b = 0;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
      b: #M6
    declaredSetters
      a=: #M2
      b=: #M7
    declaredVariables
      a: #M4
      b: #M8
''',
    );
  }

  test_manifest_topLevelVariable_modifier_hasImplicitType() async {
    configuration.withElementManifests = true;

    await _runLibraryManifestScenario(
      initialCode: r'''
final foo1 = 0;
final int foo2 = 0;
final foo3 = 0;
final int foo4 = 0;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      foo1: #M0
        flags: isSimplyBounded isStatic isSynthetic
        returnType: int @ dart:core
      foo2: #M1
        flags: isSimplyBounded isStatic isSynthetic
        returnType: int @ dart:core
      foo3: #M2
        flags: isSimplyBounded isStatic isSynthetic
        returnType: int @ dart:core
      foo4: #M3
        flags: isSimplyBounded isStatic isSynthetic
        returnType: int @ dart:core
    declaredVariables
      foo1: #M4
        flags: hasImplicitType hasInitializer isFinal isStatic
        type: int @ dart:core
      foo2: #M5
        flags: hasInitializer isFinal isStatic shouldUseTypeForInitializerInference
        type: int @ dart:core
      foo3: #M6
        flags: hasImplicitType hasInitializer isFinal isStatic
        type: int @ dart:core
      foo4: #M7
        flags: hasInitializer isFinal isStatic shouldUseTypeForInitializerInference
        type: int @ dart:core
''',
      updatedCode: r'''
final foo1 = 0;
final int foo2 = 0;
final int foo3 = 0;
final foo4 = 0;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      foo1: #M0
        flags: isSimplyBounded isStatic isSynthetic
        returnType: int @ dart:core
      foo2: #M1
        flags: isSimplyBounded isStatic isSynthetic
        returnType: int @ dart:core
      foo3: #M2
        flags: isSimplyBounded isStatic isSynthetic
        returnType: int @ dart:core
      foo4: #M3
        flags: isSimplyBounded isStatic isSynthetic
        returnType: int @ dart:core
    declaredVariables
      foo1: #M4
        flags: hasImplicitType hasInitializer isFinal isStatic
        type: int @ dart:core
      foo2: #M5
        flags: hasInitializer isFinal isStatic shouldUseTypeForInitializerInference
        type: int @ dart:core
      foo3: #M8
        flags: hasInitializer isFinal isStatic shouldUseTypeForInitializerInference
        type: int @ dart:core
      foo4: #M9
        flags: hasImplicitType hasInitializer isFinal isStatic
        type: int @ dart:core
''',
    );
  }

  test_manifest_topLevelVariable_modifier_hasInitializer() async {
    configuration.withElementManifests = true;

    await _runLibraryManifestScenario(
      initialCode: r'''
final int? foo1 = 0;
final int? foo2;
final int? foo3 = 0;
final int? foo4;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      foo1: #M0
        flags: isSimplyBounded isStatic isSynthetic
        returnType: int? @ dart:core
      foo2: #M1
        flags: isSimplyBounded isStatic isSynthetic
        returnType: int? @ dart:core
      foo3: #M2
        flags: isSimplyBounded isStatic isSynthetic
        returnType: int? @ dart:core
      foo4: #M3
        flags: isSimplyBounded isStatic isSynthetic
        returnType: int? @ dart:core
    declaredVariables
      foo1: #M4
        flags: hasInitializer isFinal isStatic shouldUseTypeForInitializerInference
        type: int? @ dart:core
      foo2: #M5
        flags: isFinal isStatic shouldUseTypeForInitializerInference
        type: int? @ dart:core
      foo3: #M6
        flags: hasInitializer isFinal isStatic shouldUseTypeForInitializerInference
        type: int? @ dart:core
      foo4: #M7
        flags: isFinal isStatic shouldUseTypeForInitializerInference
        type: int? @ dart:core
''',
      updatedCode: r'''
final int? foo1 = 0;
final int? foo2;
final int? foo3;
final int? foo4 = 0;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      foo1: #M0
        flags: isSimplyBounded isStatic isSynthetic
        returnType: int? @ dart:core
      foo2: #M1
        flags: isSimplyBounded isStatic isSynthetic
        returnType: int? @ dart:core
      foo3: #M2
        flags: isSimplyBounded isStatic isSynthetic
        returnType: int? @ dart:core
      foo4: #M3
        flags: isSimplyBounded isStatic isSynthetic
        returnType: int? @ dart:core
    declaredVariables
      foo1: #M4
        flags: hasInitializer isFinal isStatic shouldUseTypeForInitializerInference
        type: int? @ dart:core
      foo2: #M5
        flags: isFinal isStatic shouldUseTypeForInitializerInference
        type: int? @ dart:core
      foo3: #M8
        flags: isFinal isStatic shouldUseTypeForInitializerInference
        type: int? @ dart:core
      foo4: #M9
        flags: hasInitializer isFinal isStatic shouldUseTypeForInitializerInference
        type: int? @ dart:core
''',
    );
  }

  test_manifest_topLevelVariable_modifier_isConst() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
const a = 0;
const b = 0;
final c = 0;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
      b: #M1
      c: #M2
    declaredVariables
      a: #M3
      b: #M4
      c: #M5
''',
      updatedCode: r'''
const a = 0;
final b = 0;
const c = 0;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
      b: #M1
      c: #M2
    declaredVariables
      a: #M3
      b: #M6
      c: #M7
''',
    );
  }

  test_manifest_topLevelVariable_modifier_isExternal() async {
    configuration.withElementManifests = true;

    await _runLibraryManifestScenario(
      initialCode: r'''
external final int? foo1;
final int? foo2;
external final int? foo3;
final int? foo4;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      foo1: #M0
        flags: isSimplyBounded isStatic isSynthetic
        returnType: int? @ dart:core
      foo2: #M1
        flags: isSimplyBounded isStatic isSynthetic
        returnType: int? @ dart:core
      foo3: #M2
        flags: isSimplyBounded isStatic isSynthetic
        returnType: int? @ dart:core
      foo4: #M3
        flags: isSimplyBounded isStatic isSynthetic
        returnType: int? @ dart:core
    declaredVariables
      foo1: #M4
        flags: isExternal isFinal isStatic shouldUseTypeForInitializerInference
        type: int? @ dart:core
      foo2: #M5
        flags: isFinal isStatic shouldUseTypeForInitializerInference
        type: int? @ dart:core
      foo3: #M6
        flags: isExternal isFinal isStatic shouldUseTypeForInitializerInference
        type: int? @ dart:core
      foo4: #M7
        flags: isFinal isStatic shouldUseTypeForInitializerInference
        type: int? @ dart:core
''',
      updatedCode: r'''
external final int? foo1;
final int? foo2;
final int? foo3;
external final int? foo4;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      foo1: #M0
        flags: isSimplyBounded isStatic isSynthetic
        returnType: int? @ dart:core
      foo2: #M1
        flags: isSimplyBounded isStatic isSynthetic
        returnType: int? @ dart:core
      foo3: #M2
        flags: isSimplyBounded isStatic isSynthetic
        returnType: int? @ dart:core
      foo4: #M3
        flags: isSimplyBounded isStatic isSynthetic
        returnType: int? @ dart:core
    declaredVariables
      foo1: #M4
        flags: isExternal isFinal isStatic shouldUseTypeForInitializerInference
        type: int? @ dart:core
      foo2: #M5
        flags: isFinal isStatic shouldUseTypeForInitializerInference
        type: int? @ dart:core
      foo3: #M8
        flags: isFinal isStatic shouldUseTypeForInitializerInference
        type: int? @ dart:core
      foo4: #M9
        flags: isExternal isFinal isStatic shouldUseTypeForInitializerInference
        type: int? @ dart:core
''',
    );
  }

  test_manifest_topLevelVariable_modifier_isFinal() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
final a = 0;
final b = 0;
var c = 0;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
      b: #M1
      c: #M2
    declaredSetters
      c=: #M3
    declaredVariables
      a: #M4
      b: #M5
      c: #M6
''',
      updatedCode: r'''
final a = 0;
var b = 0;
final c = 0;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
      b: #M1
      c: #M2
    declaredSetters
      b=: #M7
    declaredVariables
      a: #M4
      b: #M8
      c: #M9
''',
    );
  }

  test_manifest_topLevelVariable_modifier_isLate() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
late final a = 0;
late final b = 0;
final c = 0;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
      b: #M1
      c: #M2
    declaredVariables
      a: #M3
      b: #M4
      c: #M5
''',
      updatedCode: r'''
late final a = 0;
final b = 0;
late final c = 0;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
      b: #M1
      c: #M2
    declaredVariables
      a: #M3
      b: #M6
      c: #M7
''',
    );
  }

  test_manifest_topLevelVariable_modifier_isSynthetic() async {
    configuration.withElementManifests = true;

    await _runLibraryManifestScenario(
      initialCode: r'''
int? get foo1 => 0;
final int? foo2;
int? get foo3 => 0;
final int? foo4;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      foo1: #M0
        flags: isSimplyBounded isStatic
        returnType: int? @ dart:core
      foo2: #M1
        flags: isSimplyBounded isStatic isSynthetic
        returnType: int? @ dart:core
      foo3: #M2
        flags: isSimplyBounded isStatic
        returnType: int? @ dart:core
      foo4: #M3
        flags: isSimplyBounded isStatic isSynthetic
        returnType: int? @ dart:core
    declaredVariables
      foo1: #M4
        flags: isStatic isSynthetic shouldUseTypeForInitializerInference
        type: int? @ dart:core
      foo2: #M5
        flags: isFinal isStatic shouldUseTypeForInitializerInference
        type: int? @ dart:core
      foo3: #M6
        flags: isStatic isSynthetic shouldUseTypeForInitializerInference
        type: int? @ dart:core
      foo4: #M7
        flags: isFinal isStatic shouldUseTypeForInitializerInference
        type: int? @ dart:core
''',
      updatedCode: r'''
int? get foo1 => 0;
final int? foo2;
final int? foo3;
int? get foo4 => 0;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      foo1: #M0
        flags: isSimplyBounded isStatic
        returnType: int? @ dart:core
      foo2: #M1
        flags: isSimplyBounded isStatic isSynthetic
        returnType: int? @ dart:core
      foo3: #M8
        flags: isSimplyBounded isStatic isSynthetic
        returnType: int? @ dart:core
      foo4: #M9
        flags: isSimplyBounded isStatic
        returnType: int? @ dart:core
    declaredVariables
      foo1: #M4
        flags: isStatic isSynthetic shouldUseTypeForInitializerInference
        type: int? @ dart:core
      foo2: #M5
        flags: isFinal isStatic shouldUseTypeForInitializerInference
        type: int? @ dart:core
      foo3: #M10
        flags: isFinal isStatic shouldUseTypeForInitializerInference
        type: int? @ dart:core
      foo4: #M11
        flags: isStatic isSynthetic shouldUseTypeForInitializerInference
        type: int? @ dart:core
''',
    );
  }

  test_manifest_topLevelVariable_private_const() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
const _a = 0;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      _a: #M0
    declaredVariables
      _a: #M1
''',
      updatedCode: r'''
const _a = 0;
const b = 0;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      _a: #M0
      b: #M2
    declaredVariables
      _a: #M1
      b: #M3
''',
    );
  }

  test_manifest_topLevelVariable_private_final() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
final _a = 0;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      _a: #M0
    declaredVariables
      _a: #M1
''',
      updatedCode: r'''
final _a = 0;
final b = 0;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      _a: #M0
      b: #M2
    declaredVariables
      _a: #M1
      b: #M3
''',
    );
  }

  test_manifest_topLevelVariable_private_var() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
var _a = 0;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      _a: #M0
    declaredSetters
      _a=: #M1
    declaredVariables
      _a: #M2
''',
      updatedCode: r'''
var _a = 0;
var b = 0;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      _a: #M0
      b: #M3
    declaredSetters
      _a=: #M1
      b=: #M4
    declaredVariables
      _a: #M2
      b: #M5
''',
    );
  }

  test_manifest_topLevelVariable_type() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
int? a;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
    declaredSetters
      a=: #M1
    declaredVariables
      a: #M2
''',
      updatedCode: r'''
double? a;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M3
    declaredSetters
      a=: #M4
    declaredVariables
      a: #M5
''',
    );
  }

  test_manifest_type_dynamicType() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
final dynamic a = 0;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
    declaredVariables
      a: #M1
''',
      updatedCode: r'''
final dynamic a = 0;
final b = 0;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
      b: #M2
    declaredVariables
      a: #M1
      b: #M3
''',
    );
  }

  test_manifest_type_dynamicType_to_interfaceType() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
final dynamic a = 0;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
    declaredVariables
      a: #M1
''',
      updatedCode: r'''
final int a = 0;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M2
    declaredVariables
      a: #M3
''',
    );
  }

  test_manifest_type_functionType() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
final int Function() a;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
    declaredVariables
      a: #M1
''',
      updatedCode: r'''
final int Function() a;
final b = 0;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
      b: #M2
    declaredVariables
      a: #M1
      b: #M3
''',
    );
  }

  test_manifest_type_functionType_named() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
final void Function({int p1}) a;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
    declaredVariables
      a: #M1
''',
      updatedCode: r'''
final void Function({int p1}) a;
final b = 0;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
      b: #M2
    declaredVariables
      a: #M1
      b: #M3
''',
    );
  }

  test_manifest_type_functionType_named_add() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
final void Function({int p1}) a;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
    declaredVariables
      a: #M1
''',
      updatedCode: r'''
final void Function({int p1, double p2}) a;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M2
    declaredVariables
      a: #M3
''',
    );
  }

  test_manifest_type_functionType_named_metadata_add() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
void foo({int a}) {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      foo: #M0
''',
      updatedCode: r'''
void foo({@deprecated int a}) {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      foo: #M1
''',
    );
  }

  test_manifest_type_functionType_named_metadata_remove() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
void foo({@deprecated int a}) {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      foo: #M0
''',
      updatedCode: r'''
void foo({int a}) {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      foo: #M1
''',
    );
  }

  test_manifest_type_functionType_named_remove() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
final void Function({int p1, double p2}) a;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
    declaredVariables
      a: #M1
''',
      updatedCode: r'''
final void Function({int p1}) a;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M2
    declaredVariables
      a: #M3
''',
    );
  }

  test_manifest_type_functionType_named_remove_hasPositional() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
final void Function(int p1, {double p2}) a;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
    declaredVariables
      a: #M1
''',
      updatedCode: r'''
final void Function(int p1) a;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M2
    declaredVariables
      a: #M3
''',
    );
  }

  test_manifest_type_functionType_named_rename() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
final void Function({int p1}) a;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
    declaredVariables
      a: #M1
''',
      updatedCode: r'''
final void Function({int p2}) a;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M2
    declaredVariables
      a: #M3
''',
    );
  }

  test_manifest_type_functionType_named_reorder() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
final void Function({int p1, int p2}) a;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
    declaredVariables
      a: #M1
''',
      updatedCode: r'''
final void Function({int p2, int p1}) a;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
    declaredVariables
      a: #M1
''',
    );
  }

  test_manifest_type_functionType_named_toPositional() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
final void Function({int p}) a;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
    declaredVariables
      a: #M1
''',
      updatedCode: r'''
final void Function(int p) a;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M2
    declaredVariables
      a: #M3
''',
    );
  }

  test_manifest_type_functionType_named_toRequiredFalse() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
final void Function({required int p1}) a;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
    declaredVariables
      a: #M1
''',
      updatedCode: r'''
final void Function({int p1}) a;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M2
    declaredVariables
      a: #M3
''',
    );
  }

  test_manifest_type_functionType_named_toRequiredTrue() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
final void Function({int p1}) a;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
    declaredVariables
      a: #M1
''',
      updatedCode: r'''
final void Function({required int p1}) a;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M2
    declaredVariables
      a: #M3
''',
    );
  }

  test_manifest_type_functionType_named_type() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
final void Function({int p1}) a;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
    declaredVariables
      a: #M1
''',
      updatedCode: r'''
final void Function({double p1}) a;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M2
    declaredVariables
      a: #M3
''',
    );
  }

  test_manifest_type_functionType_nullabilitySuffix() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
final int Function() a;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
    declaredVariables
      a: #M1
''',
      updatedCode: r'''
final int Function()? a;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M2
    declaredVariables
      a: #M3
''',
    );
  }

  test_manifest_type_functionType_positional() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
final void Function(int p1) a;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
    declaredVariables
      a: #M1
''',
      updatedCode: r'''
final void Function(int p1) a;
final b = 0;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
      b: #M2
    declaredVariables
      a: #M1
      b: #M3
''',
    );
  }

  test_manifest_type_functionType_positional_add() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
final void Function(int p1) a;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
    declaredVariables
      a: #M1
''',
      updatedCode: r'''
final void Function(int p1, double p2) a;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M2
    declaredVariables
      a: #M3
''',
    );
  }

  test_manifest_type_functionType_positional_metadata_add() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
void foo([int a]) {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      foo: #M0
''',
      updatedCode: r'''
void foo([@deprecated int a]) {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      foo: #M1
''',
    );
  }

  test_manifest_type_functionType_positional_metadata_remove() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
void foo([@deprecated int a]) {}
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      foo: #M0
''',
      updatedCode: r'''
void foo([int a]) {}
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredFunctions
      foo: #M1
''',
    );
  }

  test_manifest_type_functionType_positional_name_add() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
final void Function(int) a;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
    declaredVariables
      a: #M1
''',
      updatedCode: r'''
final void Function(int p1) a;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
    declaredVariables
      a: #M1
''',
    );
  }

  test_manifest_type_functionType_positional_name_remove() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
final void Function(int p1) a;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
    declaredVariables
      a: #M1
''',
      updatedCode: r'''
final void Function(int) a;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
    declaredVariables
      a: #M1
''',
    );
  }

  test_manifest_type_functionType_positional_remove() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
final void Function(int p1, double p2) a;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
    declaredVariables
      a: #M1
''',
      updatedCode: r'''
final void Function(int p1) a;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M2
    declaredVariables
      a: #M3
''',
    );
  }

  test_manifest_type_functionType_positional_remove_hasNamed() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
final void Function(int p1, {double p2}) a;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
    declaredVariables
      a: #M1
''',
      updatedCode: r'''
final void Function({double p2}) a;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M2
    declaredVariables
      a: #M3
''',
    );
  }

  test_manifest_type_functionType_positional_rename_optional() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
final void Function([int p1]) a;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
    declaredVariables
      a: #M1
''',
      updatedCode: r'''
final void Function([int p2]) a;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
    declaredVariables
      a: #M1
''',
    );
  }

  test_manifest_type_functionType_positional_rename_required() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
final void Function(int p1) a;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
    declaredVariables
      a: #M1
''',
      updatedCode: r'''
final void Function(int p2) a;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
    declaredVariables
      a: #M1
''',
    );
  }

  test_manifest_type_functionType_positional_reorder_optional() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
final void Function([int p1, double p2]) a;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
    declaredVariables
      a: #M1
''',
      updatedCode: r'''
final void Function([double p2, int p1]) a;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M2
    declaredVariables
      a: #M3
''',
    );
  }

  test_manifest_type_functionType_positional_reorder_required() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
final void Function(int p1, double p2) a;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
    declaredVariables
      a: #M1
''',
      updatedCode: r'''
final void Function(double p2, int p1) a;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M2
    declaredVariables
      a: #M3
''',
    );
  }

  test_manifest_type_functionType_positional_toNamed() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
final void Function(int p) a;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
    declaredVariables
      a: #M1
''',
      updatedCode: r'''
final void Function({int p}) a;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M2
    declaredVariables
      a: #M3
''',
    );
  }

  test_manifest_type_functionType_positional_toRequiredFalse() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
final void Function(int p1) a;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
    declaredVariables
      a: #M1
''',
      updatedCode: r'''
final void Function([int p1]) a;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M2
    declaredVariables
      a: #M3
''',
    );
  }

  test_manifest_type_functionType_positional_toRequiredTrue() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
final void Function([int p1]) a;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
    declaredVariables
      a: #M1
''',
      updatedCode: r'''
final void Function(int p1) a;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M2
    declaredVariables
      a: #M3
''',
    );
  }

  test_manifest_type_functionType_positional_type() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
final void Function(int p1) a;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
    declaredVariables
      a: #M1
''',
      updatedCode: r'''
final void Function(double p1) a;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M2
    declaredVariables
      a: #M3
''',
    );
  }

  test_manifest_type_functionType_returnType() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
final int Function() a;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
    declaredVariables
      a: #M1
''',
      updatedCode: r'''
final double Function() a;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M2
    declaredVariables
      a: #M3
''',
    );
  }

  test_manifest_type_functionType_typeParameter() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
final T Function<T>() a;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
    declaredVariables
      a: #M1
''',
      updatedCode: r'''
final T Function<T>() a;
final b = 0;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
      b: #M2
    declaredVariables
      a: #M1
      b: #M3
''',
    );
  }

  test_manifest_type_functionType_typeParameter_add() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
final void Function<E1>() a;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
    declaredVariables
      a: #M1
''',
      updatedCode: r'''
final void Function<E1, E2>() a;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M2
    declaredVariables
      a: #M3
''',
    );
  }

  test_manifest_type_functionType_typeParameter_bound() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
final T Function<T extends int>() a;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
    declaredVariables
      a: #M1
''',
      updatedCode: r'''
final T Function<T extends double>() a;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M2
    declaredVariables
      a: #M3
''',
    );
  }

  test_manifest_type_functionType_typeParameter_remove() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
final void Function<E1, E2>() a;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
    declaredVariables
      a: #M1
''',
      updatedCode: r'''
final void Function<E1>() a;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M2
    declaredVariables
      a: #M3
''',
    );
  }

  test_manifest_type_functionType_typeParameter_rename() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
final T Function<T>() a;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
    declaredVariables
      a: #M1
''',
      updatedCode: r'''
final T2 Function<T2>() a;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
    declaredVariables
      a: #M1
''',
    );
  }

  test_manifest_type_functionType_typeParameter_reorder_andFormalParameters() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
typedef F = void Function<T, U>(T, U);
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredTypeAliases
      F: #M0
''',
      updatedCode: r'''
typedef F = void Function<U, T>(U, T);
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredTypeAliases
      F: #M0
''',
    );
  }

  test_manifest_type_functionType_typeParameter_reorder_notFormalParameters() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
typedef F = void Function<T, U>(T, U);
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredTypeAliases
      F: #M0
''',
      updatedCode: r'''
typedef F = void Function<U, T>(T, U);
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredTypeAliases
      F: #M1
''',
    );
  }

  test_manifest_type_functionType_typeParameter_reorder_withBounds() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
typedef F = void Function<T extends num, U extends int>(T, U);
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredTypeAliases
      F: #M0
''',
      updatedCode: r'''
typedef F = void Function<U extends int, T extends num>(U, T);
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredTypeAliases
      F: #M1
''',
    );
  }

  test_manifest_type_interfaceType_element() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
final int a = 0;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
    declaredVariables
      a: #M1
''',
      updatedCode: r'''
final double a = 0;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M2
    declaredVariables
      a: #M3
''',
    );
  }

  test_manifest_type_interfaceType_nullabilitySuffix() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
final int a = 0;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
    declaredVariables
      a: #M1
''',
      updatedCode: r'''
final int? a = 0;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M2
    declaredVariables
      a: #M3
''',
    );
  }

  test_manifest_type_interfaceType_typeArguments() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
final List<int> a = 0;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
    declaredVariables
      a: #M1
''',
      updatedCode: r'''
final List<double> a = 0;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M2
    declaredVariables
      a: #M3
''',
    );
  }

  test_manifest_type_invalidType() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
final NotType a = 0;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
    declaredVariables
      a: #M1
''',
      updatedCode: r'''
final NotType a = 0;
final b = 0;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
      b: #M2
    declaredVariables
      a: #M1
      b: #M3
''',
    );
  }

  test_manifest_type_neverType() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
final Never a;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
    declaredVariables
      a: #M1
''',
      updatedCode: r'''
final Never a;
final b = 0;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
      b: #M2
    declaredVariables
      a: #M1
      b: #M3
''',
    );
  }

  test_manifest_type_neverType_nullabilitySuffix() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
final Never a;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
    declaredVariables
      a: #M1
''',
      updatedCode: r'''
final Never? a;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M2
    declaredVariables
      a: #M3
''',
    );
  }

  test_manifest_type_recordType_namedFields() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
final ({int f1}) a = 0;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
    declaredVariables
      a: #M1
''',
      updatedCode: r'''
final ({int f1}) a = 0;
final b = 0;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
      b: #M2
    declaredVariables
      a: #M1
      b: #M3
''',
    );
  }

  test_manifest_type_recordType_namedFields_add() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
final ({int f1}) a = 0;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
    declaredVariables
      a: #M1
''',
      updatedCode: r'''
final ({int f1, double f2}) a = 0;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M2
    declaredVariables
      a: #M3
''',
    );
  }

  test_manifest_type_recordType_namedFields_name() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
final ({int f1}) a = 0;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
    declaredVariables
      a: #M1
''',
      updatedCode: r'''
final ({int f2}) a = 0;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M2
    declaredVariables
      a: #M3
''',
    );
  }

  test_manifest_type_recordType_namedFields_remove() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
final ({int f1, double f2}) a = 0;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
    declaredVariables
      a: #M1
''',
      updatedCode: r'''
final ({int f1}) a = 0;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M2
    declaredVariables
      a: #M3
''',
    );
  }

  test_manifest_type_recordType_namedFields_reorder() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
final ({int f1, double f2}) a = 0;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
    declaredVariables
      a: #M1
''',
      updatedCode: r'''
final ({double f2, int f1}) a = 0;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
    declaredVariables
      a: #M1
''',
    );
  }

  test_manifest_type_recordType_namedFields_type() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
final ({int f1}) a = 0;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
    declaredVariables
      a: #M1
''',
      updatedCode: r'''
final ({double f1}) a = 0;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M2
    declaredVariables
      a: #M3
''',
    );
  }

  test_manifest_type_recordType_nullabilitySuffix() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
final (int,) a = 0;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
    declaredVariables
      a: #M1
''',
      updatedCode: r'''
final (int,)? a = 0;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M2
    declaredVariables
      a: #M3
''',
    );
  }

  test_manifest_type_recordType_positionalFields() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
final (int,) a = 0;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
    declaredVariables
      a: #M1
''',
      updatedCode: r'''
final (int,) a = 0;
final b = 0;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
      b: #M2
    declaredVariables
      a: #M1
      b: #M3
''',
    );
  }

  test_manifest_type_recordType_positionalFields_add() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
final (int,) a = 0;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
    declaredVariables
      a: #M1
''',
      updatedCode: r'''
final (int, double) a = 0;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M2
    declaredVariables
      a: #M3
''',
    );
  }

  test_manifest_type_recordType_positionalFields_name() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
final (int x,) a = 0;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
    declaredVariables
      a: #M1
''',
      updatedCode: r'''
final (int y,) a = 0;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
    declaredVariables
      a: #M1
''',
    );
  }

  test_manifest_type_recordType_positionalFields_remove() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
final (int, double) a = 0;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
    declaredVariables
      a: #M1
''',
      updatedCode: r'''
final (int,) a = 0;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M2
    declaredVariables
      a: #M3
''',
    );
  }

  test_manifest_type_recordType_positionalFields_type() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
final (int,) a = 0;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
    declaredVariables
      a: #M1
''',
      updatedCode: r'''
final (double,) a = 0;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M2
    declaredVariables
      a: #M3
''',
    );
  }

  test_manifest_type_voidType() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
final void a = 0;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
    declaredVariables
      a: #M1
''',
      updatedCode: r'''
final void a = 0;
final b = 0;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      a: #M0
      b: #M2
    declaredVariables
      a: #M1
      b: #M3
''',
    );
  }

  test_manifest_typeAlias_aliasedType_functionType() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
typedef A = int Function();
typedef B = int Function();
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredTypeAliases
      A: #M0
      B: #M1
''',
      updatedCode: r'''
typedef A = int Function();
typedef B = double Function();
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredTypeAliases
      A: #M0
      B: #M2
''',
    );
  }

  test_manifest_typeAlias_aliasedType_interfaceType() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
typedef A = int;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredTypeAliases
      A: #M0
''',
      updatedCode: r'''
typedef A = double;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredTypeAliases
      A: #M1
''',
    );
  }

  test_manifest_typeAlias_aliasedType_metadata() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
@Deprecated('0')
typedef A = int;

@Deprecated('0')
typedef B = int;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredTypeAliases
      A: #M0
      B: #M1
''',
      updatedCode: r'''
@Deprecated('0')
typedef A = int;

@Deprecated('1')
typedef B = int;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredTypeAliases
      A: #M0
      B: #M2
''',
    );
  }

  test_manifest_typeAlias_modifier_isProperRename() async {
    configuration.withElementManifests = true;
    await _runLibraryManifestScenario(
      initialCode: r'''
typedef A<T> = List<T>;
typedef B<T extends num> = List<T>;
typedef C<T> = List<T>;
typedef D<T extends num> = List<T>;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredTypeAliases
      A: #M0
        flags: isProperRename isSimplyBounded
        typeParameters
          #0 covariant
            bound: <null>
        aliasedType: List @ dart:core
          typeParameter#0
      B: #M1
        flags: isSimplyBounded
        typeParameters
          #0 covariant
            bound: num @ dart:core
        aliasedType: List @ dart:core
          typeParameter#0
      C: #M2
        flags: isProperRename isSimplyBounded
        typeParameters
          #0 covariant
            bound: <null>
        aliasedType: List @ dart:core
          typeParameter#0
      D: #M3
        flags: isSimplyBounded
        typeParameters
          #0 covariant
            bound: num @ dart:core
        aliasedType: List @ dart:core
          typeParameter#0
''',
      updatedCode: r'''
typedef A<T> = List<T>;
typedef B<T extends num> = List<T>;
typedef C<T extends num> = List<T>;
typedef D<T> = List<T>;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredTypeAliases
      A: #M0
        flags: isProperRename isSimplyBounded
        typeParameters
          #0 covariant
            bound: <null>
        aliasedType: List @ dart:core
          typeParameter#0
      B: #M1
        flags: isSimplyBounded
        typeParameters
          #0 covariant
            bound: num @ dart:core
        aliasedType: List @ dart:core
          typeParameter#0
      C: #M4
        flags: isSimplyBounded
        typeParameters
          #0 covariant
            bound: num @ dart:core
        aliasedType: List @ dart:core
          typeParameter#0
      D: #M5
        flags: isProperRename isSimplyBounded
        typeParameters
          #0 covariant
            bound: <null>
        aliasedType: List @ dart:core
          typeParameter#0
''',
    );
  }

  test_manifest_typeAlias_modifier_isSimplyBounded() async {
    configuration.withElementManifests = true;
    await _runLibraryManifestScenario(
      initialCode: r'''
typedef A<T> = int;
typedef B<T extends List<T>> = int;
typedef C<T> = int;
typedef D<T extends List<T>> = int;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredTypeAliases
      A: #M0
        flags: isSimplyBounded
        typeParameters
          #0 unrelated
            bound: <null>
        aliasedType: int @ dart:core
      B: #M1
        typeParameters
          #0 unrelated
            bound: List @ dart:core
              typeParameter#0
        aliasedType: int @ dart:core
      C: #M2
        flags: isSimplyBounded
        typeParameters
          #0 unrelated
            bound: <null>
        aliasedType: int @ dart:core
      D: #M3
        typeParameters
          #0 unrelated
            bound: List @ dart:core
              typeParameter#0
        aliasedType: int @ dart:core
''',
      updatedCode: r'''
typedef A<T> = int;
typedef B<T extends List<T>> = int;
typedef C<T extends List<T>> = int;
typedef D<T> = int;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredTypeAliases
      A: #M0
        flags: isSimplyBounded
        typeParameters
          #0 unrelated
            bound: <null>
        aliasedType: int @ dart:core
      B: #M1
        typeParameters
          #0 unrelated
            bound: List @ dart:core
              typeParameter#0
        aliasedType: int @ dart:core
      C: #M4
        typeParameters
          #0 unrelated
            bound: List @ dart:core
              typeParameter#0
        aliasedType: int @ dart:core
      D: #M5
        flags: isSimplyBounded
        typeParameters
          #0 unrelated
            bound: <null>
        aliasedType: int @ dart:core
''',
    );
  }

  test_manifest_typeAlias_typeParameters_bound() async {
    configuration.withElementManifests = true;
    await _runLibraryManifestScenario(
      initialCode: r'''
typedef F<X extends num> = List<X>;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredTypeAliases
      F: #M0
        flags: isSimplyBounded
        typeParameters
          #0 covariant
            bound: num @ dart:core
        aliasedType: List @ dart:core
          typeParameter#0
''',
      updatedCode: r'''
typedef F<X extends int> = List<X>;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredTypeAliases
      F: #M1
        flags: isSimplyBounded
        typeParameters
          #0 covariant
            bound: int @ dart:core
        aliasedType: List @ dart:core
          typeParameter#0
''',
    );
  }

  test_manifest_typeAlias_typeParameters_name() async {
    await _runLibraryManifestScenario(
      initialCode: r'''
typedef F<X> = List<X>;
''',
      expectedInitialEvents: r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
    declaredTypeAliases
      F: #M0
''',
      updatedCode: r'''
typedef F<Y> = List<Y>;
''',
      expectedUpdatedEvents: r'''
[operation] linkLibraryCycle
  package:test/test.dart
    declaredTypeAliases
      F: #M0
''',
    );
  }

  test_operation_addFile_changeImported_affected() async {
    configuration.withCheckLibraryDiagnosticsRequirements = true;

    var driver = driverFor(testFile);
    var collector = DriverEventCollector(driver, idProvider: idProvider);

    var a = newFile('$testPackageLibPath/a.dart', r'''
int get a => 0;
''');

    newFile(testFile.path, r'''
import 'a.dart';
void f() {
  a;
}
''');

    driver.addFile2(testFile);

    await assertEventsText(collector, r'''
[status] working
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
[status] idle
''');

    modifyFile2(a, r'''
double get a => 0;
''');
    driver.changeFile2(a);

    await assertEventsText(collector, r'''
[status] working
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  topLevelIdMismatch
    libraryUri: package:test/a.dart
    name: a
    expectedId: #M0
    actualId: #M1
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
[status] idle
''');
  }

  test_operation_addFile_changeImported_notAffected() async {
    configuration.withCheckLibraryDiagnosticsRequirements = true;

    var driver = driverFor(testFile);
    var collector = DriverEventCollector(driver, idProvider: idProvider);

    var a = newFile('$testPackageLibPath/a.dart', r'''
int get a => 0;
''');

    newFile(testFile.path, r'''
import 'a.dart';
void f() {
  a;
}
''');

    driver.addFile2(testFile);

    await assertEventsText(collector, r'''
[status] working
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
[status] idle
''');

    modifyFile2(a, r'''
int get a => 0;
int get b => 0;
''');
    driver.changeFile2(a);

    await assertEventsText(collector, r'''
[status] working
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  failure: null
[operation] getErrorsFromBytes
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
[status] idle
''');
  }

  test_operation_addFile_changeLibraryFile() async {
    configuration.withCheckLibraryDiagnosticsRequirements = true;

    var driver = driverFor(testFile);
    var collector = DriverEventCollector(driver, idProvider: idProvider);

    newFile(testFile.path, r'''
final x = 0;
''');

    driver.addFile2(testFile);
    await assertEventsText(collector, r'''
[status] working
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
[status] idle
''');

    modifyFile2(testFile, r'''
final x = 0;
final y = 0;
''');
    driver.changeFile2(testFile);

    // The library file changed, so diagnostics bundle key is different.
    await assertEventsText(collector, r'''
[status] working
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
[status] idle
''');
  }

  test_operation_addFile_changePartFile() async {
    configuration.withCheckLibraryDiagnosticsRequirements = true;

    var driver = driverFor(testFile);
    var collector = DriverEventCollector(driver, idProvider: idProvider);

    var a = newFile('$testPackageLibPath/a.dart', r'''
part of 'test.dart';
''');

    newFile(testFile.path, r'''
part 'a.dart';
final x = 0;
''');

    driver.addFile2(testFile);
    driver.addFile2(a);

    await assertEventsText(collector, r'''
[status] working
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[stream]
  ResolvedUnitResult #1
    path: /home/test/lib/a.dart
    uri: package:test/a.dart
    flags: exists isPart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
[status] idle
''');

    modifyFile2(a, r'''
part of 'test.dart';
final y = 0;
''');
    driver.changeFile2(a);

    // The part file changed, so diagnostics bundle key is different.
    await assertEventsText(collector, r'''
[status] working
[operation] analyzeFile
  file: /home/test/lib/a.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[stream]
  ResolvedUnitResult #3
    path: /home/test/lib/a.dart
    uri: package:test/a.dart
    flags: exists isPart
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
[status] idle
''');
  }

  test_operation_getErrors_changeImported_affected() async {
    configuration.withCheckLibraryDiagnosticsRequirements = true;

    var driver = driverFor(testFile);
    var collector = DriverEventCollector(driver, idProvider: idProvider);

    var a = newFile('$testPackageLibPath/a.dart', r'''
int get a => 0;
''');

    newFile(testFile.path, r'''
import 'a.dart';
void f() {
  a;
}
''');

    collector.getErrors('T1', testFile);

    await assertEventsText(collector, r'''
[status] working
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''');

    modifyFile2(a, r'''
double get a => 0;
''');
    driver.changeFile2(a);
    collector.getErrors('T2', testFile);

    await assertEventsText(collector, r'''
[status] working
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  topLevelIdMismatch
    libraryUri: package:test/a.dart
    name: a
    expectedId: #M0
    actualId: #M1
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
[status] idle
[future] getErrors T2
  ErrorsResult #3
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''');
  }

  test_operation_getErrors_changeImported_notAffected() async {
    configuration.withCheckLibraryDiagnosticsRequirements = true;

    var driver = driverFor(testFile);
    var collector = DriverEventCollector(driver, idProvider: idProvider);

    var a = newFile('$testPackageLibPath/a.dart', r'''
int get a => 0;
''');

    newFile(testFile.path, r'''
import 'a.dart';
void f() {
  a;
}
''');

    collector.getErrors('T1', testFile);

    await assertEventsText(collector, r'''
[status] working
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''');

    modifyFile2(a, r'''
int get a => 0;
int get b => 0;
''');
    driver.changeFile2(a);
    collector.getErrors('T2', testFile);

    await assertEventsText(collector, r'''
[status] working
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  failure: null
[operation] getErrorsFromBytes
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[status] idle
[future] getErrors T2
  ErrorsResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''');
  }

  test_operation_getErrors_noChange() async {
    configuration.withCheckLibraryDiagnosticsRequirements = true;

    var driver = driverFor(testFile);
    var collector = DriverEventCollector(driver, idProvider: idProvider);

    newFile(testFile.path, r'''
void f() {}
''');

    collector.getErrors('T1', testFile);

    await assertEventsText(collector, r'''
[status] working
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''');

    // Note, no check for requirements operation.
    // The transitive API signature is the same, so we shortcut.
    collector.getErrors('T2', testFile);
    await assertEventsText(collector, r'''
[status] working
[operation] getErrorsFromBytes
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[status] idle
[future] getErrors T2
  ErrorsResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''');

    // Repeating requests still uses the shortcut.
    collector.getErrors('T3', testFile);
    await assertEventsText(collector, r'''
[status] working
[operation] getErrorsFromBytes
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[status] idle
[future] getErrors T3
  ErrorsResult #3
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''');
  }

  test_operation_getErrors_notAffected() async {
    configuration.withCheckLibraryDiagnosticsRequirements = true;

    await _runChangeScenarioTA(
      initialA: r'''
int get a => 0;
''',
      testCode: r'''
import 'a.dart';
final x = a;
''',
      operation: _FineOperationTestFileGetErrors(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredGetters
      a: #M0
    declaredVariables
      a: #M1
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      x: #M2
    declaredVariables
      x: #M3
  requirements
    libraries
      package:test/a.dart
        exportedTopLevels
          a: #M0
          a=: <null>
        reExportDeprecatedOnly
          a: false
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M4
        exportedTopLevels
          a: #M0
          a=: <null>
        reExportDeprecatedOnly
          a: false
[status] idle
[future] getErrors T1
  ErrorsResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
      updatedA: r'''
int get a => 0;
int get b => 0;
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredGetters
      a: #M0
      b: #M5
    declaredVariables
      a: #M1
      b: #M6
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  failure: null
[operation] getErrorsFromBytes
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[status] idle
[future] getErrors T2
  ErrorsResult #2
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: isLibrary
''',
    );
  }

  test_operation_getIndex_changeImported_affected() async {
    configuration.withCheckLibraryDiagnosticsRequirements = true;

    var driver = driverFor(testFile);
    var collector = DriverEventCollector(driver, idProvider: idProvider);

    var a = newFile('$testPackageLibPath/a.dart', r'''
int get a => 0;
''');

    newFile(testFile.path, r'''
import 'a.dart';
void f() {
  a;
}
''');

    collector.getIndex('T1', testFile);

    await assertEventsText(collector, r'''
[status] working
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
[status] idle
[future] getIndex T1
  strings
    --nullString--
    a
    package:test/a.dart
''');

    modifyFile2(a, r'''
double get a => 0;
''');
    driver.changeFile2(a);
    collector.getIndex('T2', testFile);

    await assertEventsText(collector, r'''
[status] working
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  topLevelIdMismatch
    libraryUri: package:test/a.dart
    name: a
    expectedId: #M0
    actualId: #M1
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #1
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
[status] idle
[future] getIndex T2
  strings
    --nullString--
    a
    package:test/a.dart
''');
  }

  test_operation_getIndex_changeImported_notAffected() async {
    configuration.withCheckLibraryDiagnosticsRequirements = true;

    var driver = driverFor(testFile);
    var collector = DriverEventCollector(driver, idProvider: idProvider);

    var a = newFile('$testPackageLibPath/a.dart', r'''
int get a => 0;
''');

    newFile(testFile.path, r'''
import 'a.dart';
void f() {
  a;
}
''');

    collector.getIndex('T1', testFile);

    await assertEventsText(collector, r'''
[status] working
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
[status] idle
[future] getIndex T1
  strings
    --nullString--
    a
    package:test/a.dart
''');

    modifyFile2(a, r'''
int get a => 0;
int get b => 0;
''');
    driver.changeFile2(a);
    collector.getIndex('T2', testFile);

    await assertEventsText(collector, r'''
[status] working
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  failure: null
[status] idle
[future] getIndex T2
  strings
    --nullString--
    a
    package:test/a.dart
''');
  }

  test_operation_getIndex_noChange() async {
    configuration.withCheckLibraryDiagnosticsRequirements = true;

    var driver = driverFor(testFile);
    var collector = DriverEventCollector(driver, idProvider: idProvider);

    newFile(testFile.path, r'''
void f() {}
''');

    collector.getIndex('T1', testFile);

    await assertEventsText(collector, r'''
[status] working
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
[status] idle
[future] getIndex T1
  strings
    --nullString--
''');

    // Note, no check for requirements operation.
    // The transitive API signature is the same, so we shortcut.
    collector.getIndex('T2', testFile);
    await assertEventsText(collector, r'''
[status] working
[status] idle
[future] getIndex T2
  strings
    --nullString--
''');

    // Repeating requests still uses the shortcut.
    collector.getIndex('T3', testFile);
    await assertEventsText(collector, r'''
[status] working
[status] idle
[future] getIndex T3
  strings
    --nullString--
''');
  }

  test_operation_getIndex_notAffected() async {
    configuration.withCheckLibraryDiagnosticsRequirements = true;

    await _runChangeScenarioTA(
      initialA: r'''
int get a => 0;
''',
      testCode: r'''
import 'a.dart';
final x = a;
''',
      operation: _FineOperationTestFileGetIndex(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredGetters
      a: #M0
    declaredVariables
      a: #M1
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      x: #M2
    declaredVariables
      x: #M3
  requirements
    libraries
      package:test/a.dart
        exportedTopLevels
          a: #M0
          a=: <null>
        reExportDeprecatedOnly
          a: false
[operation] analyzeFile
  file: /home/test/lib/test.dart
  library: /home/test/lib/test.dart
[stream]
  ResolvedUnitResult #0
    path: /home/test/lib/test.dart
    uri: package:test/test.dart
    flags: exists isLibrary
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M4
        exportedTopLevels
          a: #M0
          a=: <null>
        reExportDeprecatedOnly
          a: false
[status] idle
[future] getIndex T1
  strings
    --nullString--
    a
    package:test/a.dart
''',
      updatedA: r'''
int get a => 0;
int get b => 0;
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredGetters
      a: #M0
      b: #M5
    declaredVariables
      a: #M1
      b: #M6
  requirements
[operation] reuseLinkedBundle
  package:test/test.dart
[operation] checkLibraryDiagnosticsRequirements
  library: /home/test/lib/test.dart
  failure: null
[status] idle
[future] getIndex T2
  strings
    --nullString--
    a
    package:test/a.dart
''',
    );
  }

  test_operation_getLibraryByUri_affected() async {
    configuration.withCheckLinkedBundleRequirements = true;

    await _runChangeScenarioTA(
      initialA: r'''
int get a => 0;
''',
      testCode: r'''
import 'a.dart';
final x = a;
''',
      operation: _FineOperationGetTestLibrary(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredGetters
      a: #M0
    declaredVariables
      a: #M1
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      x: #M2
    declaredVariables
      x: #M3
  requirements
    libraries
      package:test/a.dart
        exportedTopLevels
          a: #M0
          a=: <null>
        reExportDeprecatedOnly
          a: false
[status] idle
[future] getLibraryByUri T1
  library
    topLevelVariables
      final hasInitializer x
        type: int
''',
      updatedA: r'''
double get a => 1.2;
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredGetters
      a: #M4
    declaredVariables
      a: #M5
  requirements
[operation] checkLinkedBundleRequirements
  package:test/test.dart
  topLevelIdMismatch
    libraryUri: package:test/a.dart
    name: a
    expectedId: #M0
    actualId: #M4
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      x: #M6
    declaredVariables
      x: #M7
  requirements
    libraries
      package:test/a.dart
        exportedTopLevels
          a: #M4
          a=: <null>
        reExportDeprecatedOnly
          a: false
[status] idle
[future] getLibraryByUri T2
  library
    topLevelVariables
      final hasInitializer x
        type: double
''',
    );
  }

  test_operation_getLibraryByUri_changeBody() async {
    configuration
      // We don't test specific elements here.
      ..withGetLibraryByUriElement = false
      // We want to see all checks of requirements.
      ..withCheckLinkedBundleRequirements = true;

    var driver = driverFor(testFile);
    var collector = DriverEventCollector(driver, idProvider: idProvider);

    newFile(testFile.path, r'''
void f() { 0; }
''');

    collector.getLibraryByUri('L1', 'package:test/test.dart');

    await assertEventsText(collector, r'''
[status] working
[status] idle
[future] getLibraryByUri L1
''');

    modifyFile2(testFile, r'''
void f() { 1; }
''');
    driver.changeFile2(testFile);

    // Note, no check for requirements operation.
    // The transitive API signature is the same, so we shortcut.
    collector.getLibraryByUri('L2', 'package:test/test.dart');
    await assertEventsText(collector, r'''
[status] working
[operation] reuseLinkedBundle
  package:test/test.dart
[status] idle
[future] getLibraryByUri L2
''');

    modifyFile2(testFile, r'''
void f() { 2; }
''');
    driver.changeFile2(testFile);

    // Repeating requests still uses the shortcut.
    collector.getLibraryByUri('L3', 'package:test/test.dart');
    await assertEventsText(collector, r'''
[status] working
[operation] reuseLinkedBundle
  package:test/test.dart
[status] idle
[future] getLibraryByUri L3
''');
  }

  test_operation_getLibraryByUri_notAffected() async {
    configuration.withCheckLinkedBundleRequirements = true;

    await _runChangeScenarioTA(
      initialA: r'''
int get a => 0;
''',
      testCode: r'''
import 'a.dart';
final x = a;
''',
      operation: _FineOperationGetTestLibrary(),
      expectedInitialEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredGetters
      a: #M0
    declaredVariables
      a: #M1
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      x: #M2
    declaredVariables
      x: #M3
  requirements
    libraries
      package:test/a.dart
        exportedTopLevels
          a: #M0
          a=: <null>
        reExportDeprecatedOnly
          a: false
[status] idle
[future] getLibraryByUri T1
  library
    topLevelVariables
      final hasInitializer x
        type: int
''',
      updatedA: r'''
int get a => 0;
int get b => 0;
''',
      expectedUpdatedEvents: r'''
[status] working
[operation] linkLibraryCycle
  package:test/a.dart
    declaredGetters
      a: #M0
      b: #M4
    declaredVariables
      a: #M1
      b: #M5
  requirements
[operation] checkLinkedBundleRequirements
  package:test/test.dart
  failure: null
[operation] reuseLinkedBundle
  package:test/test.dart
[status] idle
[future] getLibraryByUri T2
  library
    topLevelVariables
      final hasInitializer x
        type: int
''',
    );
  }

  test_precision_noOpaqueApiUse() async {
    // Lowest layer: `A` is used by `B`.
    var a = newFile('$testPackageLibPath/a.dart', r'''
class A {
  const A();
}
''');

    // Middle layer: `B` references `A` in a default value.
    newFile('$testPackageLibPath/b.dart', r'''
import 'a.dart';

class B {
  const B([Object? x = const A()]);
}
''');

    configuration
      ..withSchedulerStatus = false
      ..withGetLibraryByUri = false
      ..withLinkLibraryCycle = true
      ..withLibraryManifest = true
      ..withResultRequirements = true;

    var driver = driverFor(testFile);
    var collector = DriverEventCollector(driver, idProvider: idProvider);

    // 1) Link `a.dart` and `b.dart`.
    collector.getLibraryByUri('B1', 'package:test/b.dart');
    await assertEventsText(collector, r'''
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        interface: #M1
  requirements
[operation] linkLibraryCycle
  package:test/b.dart
    declaredClasses
      B: #M2
        interface: #M3
  requirements
    libraries
      package:test/a.dart
        exportedTopLevels
          A: #M0
          A=: <null>
          Object: <null>
          Object=: <null>
        reExportDeprecatedOnly
          A: false
        interfaces
          A
            requestedConstructors
              new: #M4
''');

    // 2) Touch the lowest layer: unload both `a.dart` and `b.dart`.
    modifyFile2(a, r'''
class A {
  const A(); // comment
}
''');
    driver.changeFile2(a);

    // 3) Top layer: `test.dart` depends on `B`, and so `A` transitively.
    newFile(testFile.path, r'''
import 'b.dart';
final v = B();
''');

    // Link `test.dart`. During linking, we will need formal parameters of the
    // constructor `B()`, which will trigger loading resolution data for its
    // formal parameter `x = const A()`. This will require loading members,
    // specifically constructors, of `A`.
    //
    // There was a bug when loading members of `A` and `B` caused recording
    // opaque API use (`firstFragment` and `fragments`).
    collector.getLibraryByUri('T1', 'package:test/test.dart');
    await assertEventsText(collector, r'''
[operation] reuseLinkedBundle
  package:test/a.dart
[operation] reuseLinkedBundle
  package:test/b.dart
[operation] linkLibraryCycle
  package:test/test.dart
    declaredGetters
      v: #M5
    declaredVariables
      v: #M6
  requirements
    libraries
      package:test/b.dart
        exportedTopLevels
          B: #M2
          B=: <null>
        reExportDeprecatedOnly
          B: false
        interfaces
          B
            requestedConstructors
              new: #M7
''');
  }

  test_req_classElement_noName() async {
    newFile(testFile.path, r'''
class {}
''');

    _ManualRequirements.install((state) {
      var e = state.singleUnit.libraryElement.classes.single;
      e.getNamedConstructor('foo');
    });

    await _runManualRequirementsRecording(
      expectedEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
  requirements
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
[status] idle
''',
    );
  }

  test_req_extensionElement_noName() async {
    newFile(testFile.path, r'''
extension on int {
  void foo() {}
}
''');

    _ManualRequirements.install((state) {
      var e = state.singleUnit.libraryElement.extensions.single;
      e.getMethod('foo');
    });

    await _runManualRequirementsRecording(
      expectedEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
  requirements
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
[status] idle
''',
    );
  }

  test_req_instanceElement_fieldElement_getter() async {
    newFile('$testPackageLibPath/a.dart', r'''
class A {
  int foo = 0;
}
''');

    newFile(testFile.path, r'''
import 'a.dart';
''');

    _ManualRequirements.install((state) {
      var A = state.singleUnit.scopeInstanceElement('A');
      A.getField('foo')!.getter;
    });

    await _runManualRequirementsRecording(
      expectedEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        declaredSetters
          foo=: #M3
        interface: #M4
          map
            foo: #M2
            foo=: #M3
          implemented
            foo: #M2
            foo=: #M3
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
  requirements
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M5
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredFields
              foo: #M1
            requestedDeclaredGetters
              foo: #M2
[status] idle
''',
    );
  }

  test_req_instanceElement_fieldElement_setter() async {
    newFile('$testPackageLibPath/a.dart', r'''
class A {
  int foo = 0;
}
''');

    newFile(testFile.path, r'''
import 'a.dart';
''');

    _ManualRequirements.install((state) {
      var A = state.singleUnit.scopeInstanceElement('A');
      A.getField('foo')!.setter;
    });

    await _runManualRequirementsRecording(
      expectedEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        declaredSetters
          foo=: #M3
        interface: #M4
          map
            foo: #M2
            foo=: #M3
          implemented
            foo: #M2
            foo=: #M3
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
  requirements
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M5
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredFields
              foo: #M1
            requestedDeclaredSetters
              foo=: #M3
[status] idle
''',
    );
  }

  test_req_instanceElement_fields() async {
    newFile('$testPackageLibPath/a.dart', r'''
class A {
  static final int foo = 0;
}
''');

    newFile(testFile.path, r'''
import 'a.dart';
''');

    _ManualRequirements.install((state) {
      var A = state.singleUnit.scopeInstanceElement('A');
      A.fields;
    });

    await _runManualRequirementsRecording(
      expectedEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        interface: #M3
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
  requirements
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M4
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            allDeclaredFields: #M1
[status] idle
''',
    );
  }

  test_req_instanceElement_getField() async {
    newFile('$testPackageLibPath/a.dart', r'''
class A {
  final int foo = 0;
}
''');

    newFile(testFile.path, r'''
import 'a.dart';
''');

    _ManualRequirements.install((state) {
      var A = state.singleUnit.scopeInstanceElement('A');
      A.getField('foo');
    });

    await _runManualRequirementsRecording(
      expectedEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        interface: #M3
          map
            foo: #M2
          implemented
            foo: #M2
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
  requirements
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M4
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredFields
              foo: #M1
[status] idle
''',
    );
  }

  test_req_instanceElement_getGetter() async {
    newFile('$testPackageLibPath/a.dart', r'''
class A {
  static int get foo {}
}
''');

    newFile(testFile.path, r'''
import 'a.dart';
''');

    _ManualRequirements.install((state) {
      var A = state.singleUnit.scopeInstanceElement('A');
      A.getGetter('foo');
    });

    await _runManualRequirementsRecording(
      expectedEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        interface: #M3
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
  requirements
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M4
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredGetters
              foo: #M2
[status] idle
''',
    );
  }

  test_req_instanceElement_getMethod() async {
    newFile('$testPackageLibPath/a.dart', r'''
class A {
  static int foo() {}
}
''');

    newFile(testFile.path, r'''
import 'a.dart';
''');

    _ManualRequirements.install((state) {
      var A = state.singleUnit.scopeInstanceElement('A');
      A.getMethod('foo');
    });

    await _runManualRequirementsRecording(
      expectedEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
  requirements
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M3
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredMethods
              foo: #M1
[status] idle
''',
    );
  }

  test_req_instanceElement_getMethod_doesNotExist() async {
    newFile('$testPackageLibPath/a.dart', r'''
class A {}
''');

    newFile(testFile.path, r'''
import 'a.dart';
''');

    _ManualRequirements.install((state) {
      var A = state.singleUnit.scopeInstanceElement('A');
      A.getMethod('foo');
    });

    await _runManualRequirementsRecording(
      expectedEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        interface: #M1
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
  requirements
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M2
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredMethods
              foo: <null>
[status] idle
''',
    );
  }

  test_req_instanceElement_getSetter() async {
    newFile('$testPackageLibPath/a.dart', r'''
class A {
  static set foo(int _) {}
}
''');

    newFile(testFile.path, r'''
import 'a.dart';
''');

    _ManualRequirements.install((state) {
      var A = state.singleUnit.scopeInstanceElement('A');
      A.getSetter('foo');
    });

    await _runManualRequirementsRecording(
      expectedEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredSetters
          foo=: #M2
        interface: #M3
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
  requirements
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M4
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredSetters
              foo=: #M2
[status] idle
''',
    );
  }

  test_req_instanceElement_getterElement_correspondingSetter() async {
    newFile('$testPackageLibPath/a.dart', r'''
class A {
  int foo = 0;
}
''');

    newFile(testFile.path, r'''
import 'a.dart';
''');

    _ManualRequirements.install((state) {
      var A = state.singleUnit.scopeInstanceElement('A');
      A.getGetter('foo')!.correspondingSetter;
    });

    await _runManualRequirementsRecording(
      expectedEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        declaredSetters
          foo=: #M3
        interface: #M4
          map
            foo: #M2
            foo=: #M3
          implemented
            foo: #M2
            foo=: #M3
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
  requirements
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M5
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredFields
              foo: #M1
            requestedDeclaredGetters
              foo: #M2
            requestedDeclaredSetters
              foo=: #M3
[status] idle
''',
    );
  }

  test_req_instanceElement_getterElement_nonSynthetic() async {
    newFile('$testPackageLibPath/a.dart', r'''
class A {
  int foo = 0;
}
''');

    newFile(testFile.path, r'''
import 'a.dart';
''');

    _ManualRequirements.install((state) {
      var A = state.singleUnit.scopeInstanceElement('A');
      A.getGetter('foo')!.nonSynthetic;
    });

    await _runManualRequirementsRecording(
      expectedEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        declaredSetters
          foo=: #M3
        interface: #M4
          map
            foo: #M2
            foo=: #M3
          implemented
            foo: #M2
            foo=: #M3
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
  requirements
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M5
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredFields
              foo: #M1
            requestedDeclaredGetters
              foo: #M2
[status] idle
''',
    );
  }

  test_req_instanceElement_getterElement_variable() async {
    newFile('$testPackageLibPath/a.dart', r'''
class A {
  int foo = 0;
}
''');

    newFile(testFile.path, r'''
import 'a.dart';
''');

    _ManualRequirements.install((state) {
      var A = state.singleUnit.scopeInstanceElement('A');
      A.getGetter('foo')!.variable;
    });

    await _runManualRequirementsRecording(
      expectedEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        declaredSetters
          foo=: #M3
        interface: #M4
          map
            foo: #M2
            foo=: #M3
          implemented
            foo: #M2
            foo=: #M3
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
  requirements
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M5
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredFields
              foo: #M1
            requestedDeclaredGetters
              foo: #M2
[status] idle
''',
    );
  }

  test_req_instanceElement_getterElement_variable_synthetic() async {
    newFile('$testPackageLibPath/a.dart', r'''
class A {
  int get foo => 0;
}
''');

    newFile(testFile.path, r'''
import 'a.dart';
''');

    _ManualRequirements.install((state) {
      var A = state.singleUnit.scopeInstanceElement('A');
      A.getGetter('foo')!.variable;
    });

    await _runManualRequirementsRecording(
      expectedEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        interface: #M3
          map
            foo: #M2
          implemented
            foo: #M2
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
  requirements
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M4
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredFields
              foo: #M1
            requestedDeclaredGetters
              foo: #M2
[status] idle
''',
    );
  }

  test_req_instanceElement_getters() async {
    newFile('$testPackageLibPath/a.dart', r'''
class A {
  int get foo => 0;
}
''');

    newFile(testFile.path, r'''
import 'a.dart';
''');

    _ManualRequirements.install((state) {
      var A = state.singleUnit.scopeInstanceElement('A');
      A.getters;
    });

    await _runManualRequirementsRecording(
      expectedEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        interface: #M3
          map
            foo: #M2
          implemented
            foo: #M2
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
  requirements
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M4
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            allDeclaredGetters: #M2
[status] idle
''',
    );
  }

  test_req_instanceElement_methods() async {
    newFile('$testPackageLibPath/a.dart', r'''
class A {
  static int foo() {}
}
''');

    newFile(testFile.path, r'''
import 'a.dart';
''');

    _ManualRequirements.install((state) {
      var A = state.singleUnit.scopeInstanceElement('A');
      A.methods;
    });

    await _runManualRequirementsRecording(
      expectedEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredMethods
          foo: #M1
        interface: #M2
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
  requirements
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M3
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            allDeclaredMethods: #M1
[status] idle
''',
    );
  }

  test_req_instanceElement_setterElement_correspondingGetter() async {
    newFile('$testPackageLibPath/a.dart', r'''
class A {
  int foo = 0;
}
''');

    newFile(testFile.path, r'''
import 'a.dart';
''');

    _ManualRequirements.install((state) {
      var A = state.singleUnit.scopeInstanceElement('A');
      A.getSetter('foo')!.correspondingGetter;
    });

    await _runManualRequirementsRecording(
      expectedEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        declaredSetters
          foo=: #M3
        interface: #M4
          map
            foo: #M2
            foo=: #M3
          implemented
            foo: #M2
            foo=: #M3
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
  requirements
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M5
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredFields
              foo: #M1
            requestedDeclaredGetters
              foo: #M2
            requestedDeclaredSetters
              foo=: #M3
[status] idle
''',
    );
  }

  test_req_instanceElement_setterElement_nonSynthetic() async {
    newFile('$testPackageLibPath/a.dart', r'''
class A {
  int foo = 0;
}
''');

    newFile(testFile.path, r'''
import 'a.dart';
''');

    _ManualRequirements.install((state) {
      var A = state.singleUnit.scopeInstanceElement('A');
      A.getSetter('foo')!.nonSynthetic;
    });

    await _runManualRequirementsRecording(
      expectedEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        declaredSetters
          foo=: #M3
        interface: #M4
          map
            foo: #M2
            foo=: #M3
          implemented
            foo: #M2
            foo=: #M3
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
  requirements
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M5
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredFields
              foo: #M1
            requestedDeclaredSetters
              foo=: #M3
[status] idle
''',
    );
  }

  test_req_instanceElement_setterElement_variable() async {
    newFile('$testPackageLibPath/a.dart', r'''
class A {
  int foo = 0;
}
''');

    newFile(testFile.path, r'''
import 'a.dart';
''');

    _ManualRequirements.install((state) {
      var A = state.singleUnit.scopeInstanceElement('A');
      A.getSetter('foo')!.variable;
    });

    await _runManualRequirementsRecording(
      expectedEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredGetters
          foo: #M2
        declaredSetters
          foo=: #M3
        interface: #M4
          map
            foo: #M2
            foo=: #M3
          implemented
            foo: #M2
            foo=: #M3
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
  requirements
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M5
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredFields
              foo: #M1
            requestedDeclaredSetters
              foo=: #M3
[status] idle
''',
    );
  }

  test_req_instanceElement_setterElement_variable_synthetic() async {
    newFile('$testPackageLibPath/a.dart', r'''
class A {
  set foo(int _) {}
}
''');

    newFile(testFile.path, r'''
import 'a.dart';
''');

    _ManualRequirements.install((state) {
      var A = state.singleUnit.scopeInstanceElement('A');
      A.getSetter('foo')!.variable;
    });

    await _runManualRequirementsRecording(
      expectedEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredSetters
          foo=: #M2
        interface: #M3
          map
            foo=: #M2
          implemented
            foo=: #M2
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
  requirements
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M4
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            requestedDeclaredFields
              foo: #M1
            requestedDeclaredSetters
              foo=: #M2
[status] idle
''',
    );
  }

  test_req_instanceElement_setters() async {
    newFile('$testPackageLibPath/a.dart', r'''
class A {
  set foo(int _) {}
}
''');

    newFile(testFile.path, r'''
import 'a.dart';
''');

    _ManualRequirements.install((state) {
      var A = state.singleUnit.scopeInstanceElement('A');
      A.setters;
    });

    await _runManualRequirementsRecording(
      expectedEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredFields
          foo: #M1
        declaredSetters
          foo=: #M2
        interface: #M3
          map
            foo=: #M2
          implemented
            foo=: #M2
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
  requirements
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M4
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        instances
          A
            allDeclaredSetters: #M2
[status] idle
''',
    );
  }

  test_req_interfaceElement_getConstructor_named() async {
    newFile('$testPackageLibPath/a.dart', r'''
class A {
  A.named();
}
''');

    newFile(testFile.path, r'''
import 'a.dart';
''');

    _ManualRequirements.install((state) {
      var A = state.singleUnit.scopeInterfaceElement('A');
      A.getNamedConstructor('named');
    });

    await _runManualRequirementsRecording(
      expectedEvents: r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/a.dart
    declaredClasses
      A: #M0
        declaredConstructors
          named: #M1
        interface: #M2
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
  requirements
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
    libraries
      package:test/a.dart
        libraryMetadataId: #M3
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
        interfaces
          A
            requestedConstructors
              named: #M1
[status] idle
''',
    );
  }

  test_requirements_declaredVariables_change_getErrors() async {
    newFile(testFile.path, '');

    configuration
      ..withAnalyzeFileEvents = false
      ..withGetErrorsEvents = false
      ..withLinkLibraryCycle = true
      ..withResultRequirements = true
      ..withStreamResolvedUnitResults = false;

    // Record the precise accessor use.
    _ManualRequirements.install((state) {
      state.singleUnit.libraryElement.declaredVariables.get('X');
    });

    {
      await disposeAnalysisContextCollection();
      declaredVariables = {'X': '1'};

      var driver = driverFor(testFile);
      var collector = DriverEventCollector(driver, idProvider: idProvider);

      collector.getErrors('E1', testFile);
      await assertEventsText(collector, r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
  requirements
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
[status] idle
''');
    }

    {
      await disposeAnalysisContextCollection();
      declaredVariables = {'X': '2'};

      var driver = driverFor(testFile);
      var collector = DriverEventCollector(driver, idProvider: idProvider);

      collector.getErrors('E2', testFile);
      await assertEventsText(collector, r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/test.dart
  requirements
[operation] analyzedLibrary
  file: /home/test/lib/test.dart
  requirements
[status] idle
''');
    }
  }

  test_requirements_declaredVariables_change_getLibrary() async {
    newFile('$testPackageLibPath/foo.dart', 'class A {}');
    newFile('$testPackageLibPath/bar.dart', 'class A {}');

    newFile(testFile.path, r'''
import 'foo.dart'
  if (X) 'bar.dart';
void f(A _) {}
''');

    configuration
      ..withAnalyzeFileEvents = false
      ..withGetErrorsEvents = false
      ..withLinkLibraryCycle = true
      ..withResultRequirements = true
      ..withStreamResolvedUnitResults = false
      ..withGetLibraryByUriElement = false;

    {
      await disposeAnalysisContextCollection();
      declaredVariables = {'X': 'false'};

      var driver = driverFor(testFile);
      var collector = DriverEventCollector(driver, idProvider: idProvider);

      collector.getLibraryByUri('E1', 'package:test/test.dart');
      await assertEventsText(collector, r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/foo.dart
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
  requirements
    libraries
      package:test/foo.dart
        exportedTopLevels
          A: #M0
          A=: <null>
        reExportDeprecatedOnly
          A: false
[status] idle
[future] getLibraryByUri E1
''');
    }

    {
      await disposeAnalysisContextCollection();
      declaredVariables = {'X': 'true'};

      var driver = driverFor(testFile);
      var collector = DriverEventCollector(driver, idProvider: idProvider);

      collector.getLibraryByUri('E2', 'package:test/foo.dart');
      collector.getLibraryByUri('E3', 'package:test/bar.dart');

      collector.getLibraryByUri('E4', 'package:test/test.dart');
      await assertEventsText(collector, r'''
[status] working
[operation] linkLibraryCycle SDK
[operation] linkLibraryCycle
  package:test/foo.dart
  requirements
[operation] linkLibraryCycle
  package:test/bar.dart
  requirements
[operation] linkLibraryCycle
  package:test/test.dart
  requirements
    libraries
      package:test/bar.dart
        exportedTopLevels
          A: #M1
          A=: <null>
        reExportDeprecatedOnly
          A: false
[status] idle
[future] getLibraryByUri E2
[future] getLibraryByUri E3
[future] getLibraryByUri E4
''');
    }
  }

  Future<void> _runChangeScenario({
    required _FineOperation operation,
    String? expectedInitialEvents,
    required List<File> Function() updateFiles,
    required String expectedUpdatedEvents,
  }) async {
    void setId(String id) {
      NodeTextExpectationsCollector.intraInvocationId = id;
    }

    configuration
      ..withResultRequirements = true
      ..withLibraryManifest = true
      ..withLinkLibraryCycle = true;

    var driver = driverFor(testFile);
    var collector = DriverEventCollector(driver, idProvider: idProvider);

    configuration.elementTextConfiguration
      ..withLibraryFragments = false
      ..withReferences = false
      ..withSyntheticGetters = false;

    switch (operation) {
      case _FineOperationAddTestFile():
        driver.addFile2(testFile);
      case _FineOperationTestFileGetErrors():
        collector.getErrors('T1', testFile);
      case _FineOperationTestFileGetIndex():
        collector.getIndex('T1', testFile);
      case _FineOperationGetTestLibrary():
        collector.getLibraryByUri('T1', 'package:test/test.dart');
    }

    if (expectedInitialEvents != null) {
      setId('expectedInitialEvents');
      await assertEventsText(collector, expectedInitialEvents);
    } else {
      await collector.nextStatusIdle();
      collector.take();
    }

    var updatedFiles = updateFiles();
    for (var updatedFile in updatedFiles) {
      driver.changeFile2(updatedFile);
    }

    switch (operation) {
      case _FineOperationAddTestFile():
        // Nothing to do here, wait for analysis of previous added files.
        break;
      case _FineOperationTestFileGetErrors():
        collector.getErrors('T2', testFile);
      case _FineOperationTestFileGetIndex():
        collector.getIndex('T2', testFile);
      case _FineOperationGetTestLibrary():
        collector.getLibraryByUri('T2', 'package:test/test.dart');
    }

    setId('expectedUpdatedEvents');
    await assertEventsText(collector, expectedUpdatedEvents);
  }

  Future<void> _runChangeScenarioTA({
    required String initialA,
    required String testCode,
    required _FineOperation operation,
    String? expectedInitialEvents,
    required String updatedA,
    required String expectedUpdatedEvents,
  }) async {
    var a = newFile('$testPackageLibPath/a.dart', initialA);
    newFile('$testPackageLibPath/test.dart', testCode);

    await _runChangeScenario(
      operation: operation,
      expectedInitialEvents: expectedInitialEvents,
      updateFiles: () {
        modifyFile2(a, updatedA);
        return [a];
      },
      expectedUpdatedEvents: expectedUpdatedEvents,
    );
  }

  Future<void> _runLibraryManifestScenario({
    required String initialCode,
    String? expectedInitialEvents,
    String? expectedInitialDriverState,
    List<File> Function()? updateFiles,
    File? updatedCodeFile,
    required String updatedCode,
    required String expectedUpdatedEvents,
    String? expectedUpdatedDriverState,
  }) async {
    void setId(String id) {
      NodeTextExpectationsCollector.intraInvocationId = id;
    }

    newFile(testFile.path, initialCode);

    configuration
      ..withGetLibraryByUri = false
      ..withLibraryManifest = true
      ..withLinkLibraryCycle = true
      ..withSchedulerStatus = false;

    var driver = driverFor(testFile);
    var collector = DriverEventCollector(driver, idProvider: idProvider);

    var libraryUri = Uri.parse('package:test/test.dart');
    collector.getLibraryByUri('T1', '$libraryUri');

    if (expectedInitialEvents != null) {
      setId('expectedInitialEvents');
      await assertEventsText(collector, expectedInitialEvents);
    } else {
      await collector.nextStatusIdle();
      collector.take();
    }

    if (expectedInitialDriverState != null) {
      assertDriverStateString(testFile, expectedInitialDriverState);
    }

    if (updateFiles != null) {
      var updatedFiles = updateFiles();
      for (var updatedFile in updatedFiles) {
        driver.changeFile2(updatedFile);
      }
    }

    updatedCodeFile ??= testFile;
    modifyFile2(updatedCodeFile, updatedCode);
    driver.changeFile2(updatedCodeFile);

    collector.getLibraryByUri('T2', '$libraryUri');

    setId('expectedUpdatedEvents');
    await assertEventsText(collector, expectedUpdatedEvents);

    if (expectedUpdatedDriverState != null) {
      assertDriverStateString(testFile, expectedUpdatedDriverState);
    }
  }

  /// Works together with [_ManualRequirements] to execute manual requests to
  /// the element model, and observe which requirements are recorded.
  Future<void> _runManualRequirementsRecording({
    required String expectedEvents,
  }) async {
    configuration
      ..withAnalyzeFileEvents = false
      ..withLibraryManifest = true
      ..withLinkLibraryCycle = true
      ..withGetErrorsEvents = false
      ..withResultRequirements = true
      ..withStreamResolvedUnitResults = false;

    var driver = driverFor(testFile);
    var collector = DriverEventCollector(driver, idProvider: idProvider);

    collector.getErrors('T1', testFile);
    await assertEventsText(collector, expectedEvents);
  }
}

/// A lint that is always reported for all linted files.
class _AlwaysReportedLint extends LintRule {
  static final instance = _AlwaysReportedLint();

  static const LintCode code = LintCode(
    'always_reported_lint',
    'This lint is reported for all files',
  );

  _AlwaysReportedLint() : super(name: 'always_reported_lint', description: '');

  @override
  DiagnosticCode get diagnosticCode => code;

  @override
  void registerNodeProcessors(
    RuleVisitorRegistry registry,
    RuleContext context,
  ) {
    var visitor = _AlwaysReportedLintVisitor(this);
    registry.addCompilationUnit(this, visitor);
  }
}

/// A visitor for [_AlwaysReportedLint] that reports the lint for all files.
class _AlwaysReportedLintVisitor extends SimpleAstVisitor<void> {
  final LintRule rule;

  _AlwaysReportedLintVisitor(this.rule);

  @override
  void visitCompilationUnit(CompilationUnit node) {
    rule.reportAtOffset(0, 0);
  }
}

mixin _EventsMixin {
  final IdProvider idProvider = IdProvider();
  final DriverEventsPrinterConfiguration configuration =
      DriverEventsPrinterConfiguration();

  Future<void> assertEventsText(
    DriverEventCollector collector,
    String expected,
  ) async {
    await pumpEventQueue(times: 5000);

    // The waiting above must be enough to complete all futures.
    await collector.awaitPendingFutures();

    var buffer = StringBuffer();
    var sink = TreeStringSink(sink: buffer, indent: '');

    var elementPrinter = ElementPrinter(
      sink: sink,
      configuration: ElementPrinterConfiguration(),
    );

    var events = collector.take();
    DriverEventsPrinter(
      configuration: configuration,
      sink: sink,
      elementPrinter: elementPrinter,
      idProvider: collector.idProvider,
    ).write(events);

    var actual = buffer.toString();
    if (actual != expected) {
      NodeTextExpectationsCollector.add(actual);
      printPrettyDiff(expected, actual);
      fail('See the difference above.');
    }
  }
}

sealed class _FineOperation {
  const _FineOperation();
}

final class _FineOperationAddTestFile extends _FineOperation {
  const _FineOperationAddTestFile();
}

final class _FineOperationGetTestLibrary extends _FineOperation {
  const _FineOperationGetTestLibrary();
}

final class _FineOperationTestFileGetErrors extends _FineOperation {
  const _FineOperationTestFileGetErrors();
}

final class _FineOperationTestFileGetIndex extends _FineOperation {
  const _FineOperationTestFileGetIndex();
}

/// Helper for triggering requirements manually.
///
/// Some [Element] APIs are not trivial, or maybe even impossible, to
/// trigger. For example because this API is not used during normal resolution
/// of Dart code, but can be used by a linter rule.
class _ManualRequirements {
  final List<CompilationUnitImpl> units;

  _ManualRequirements(this.units);

  _ManualRequirementsUnit get singleUnit {
    var unit = units.single;
    return _ManualRequirementsUnit(unit);
  }

  static void install(void Function(_ManualRequirements) operation) {
    testFineAfterLibraryAnalyzerHook = (units) {
      var self = _ManualRequirements(units);
      operation(self);
    };
  }
}

class _ManualRequirementsUnit {
  final CompilationUnitImpl unit;

  _ManualRequirementsUnit(this.unit);

  List<LibraryElementImpl> get importedLibraries {
    var result = <LibraryElementImpl>[];
    for (var import in libraryFragment.libraryImports) {
      var library = import.importedLibrary;
      if (library != null) {
        result.add(library);
      }
    }
    return result;
  }

  LibraryElementImpl get libraryElement {
    return libraryFragment.element;
  }

  LibraryFragmentImpl get libraryFragment {
    return unit.declaredFragment!;
  }

  ClassElementImpl scopeClassElement(String name) {
    return scopeInterfaceElement(name) as ClassElementImpl;
  }

  InstanceElementImpl scopeInstanceElement(String name) {
    var lookupResult = libraryFragment.scope.lookup(name);
    return lookupResult.getter as InstanceElementImpl;
  }

  InterfaceElementImpl scopeInterfaceElement(String name) {
    return scopeInstanceElement(name) as InterfaceElementImpl;
  }
}

class _PendingFuture<T> {
  final Future<T> future;
  final DriverEvent Function(T value) createEvent;
  final List<DriverEvent> eventsList;

  _PendingFuture({
    required this.future,
    required this.createEvent,
    required this.eventsList,
  });

  Future<void> resolve() async {
    var value = await future;
    eventsList.add(createEvent(value));
  }
}

extension on AnalysisDriver {
  Future<void> assertFilesDefiningClassMemberName(
    String name,
    List<File?> expected,
  ) async {
    var fileStateList = await getFilesDefiningClassMemberName(name);
    var files = fileStateList.resources;
    expect(files, unorderedEquals(expected));
  }

  Future<void> assertFilesReferencingName(
    String name, {
    required List<File?> includesAll,
    required List<File?> excludesAll,
  }) async {
    var fileStateList = await getFilesReferencingName(name);
    var files = fileStateList.resources;
    for (var expected in includesAll) {
      expect(files, contains(expected));
    }
    for (var expected in excludesAll) {
      expect(files, isNot(contains(expected)));
    }
  }

  void assertLoadedLibraryUriSet({
    Iterable<String>? included,
    Iterable<String>? excluded,
  }) {
    var uriSet = testView!.loadedLibraryUriSet;
    if (included != null) {
      expect(uriSet, containsAll(included));
    }
    if (excluded != null) {
      for (var excludedUri in excluded) {
        expect(uriSet, isNot(contains(excludedUri)));
      }
    }
  }

  FileResult getFileSyncValid(File file) {
    return getFileSync2(file) as FileResult;
  }

  Future<LibraryElementResult> getLibraryByUriValid(String uriStr) async {
    return await getLibraryByUri(uriStr) as LibraryElementResult;
  }
}
