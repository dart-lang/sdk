library dart.io; import 'dart:async';  import 'dart:collection' show HashMap, HashSet, Queue, ListQueue, LinkedList, LinkedListEntry, UnmodifiableMapView; import 'dart:convert'; import 'dart:isolate'; import 'dart:math'; import 'dart:typed_data';  abstract class BytesBuilder { factory BytesBuilder({bool copy : true}) { throw new UnsupportedError("new BytesBuilder() is unsupported on this platform."); }   void add(List<int> bytes);   void addByte(int byte);   List<int> takeBytes();   List<int> toBytes();   int get length;   bool get isEmpty;   bool get isNotEmpty;   void clear(); } class _CopyingBytesBuilder implements BytesBuilder { static const _INIT_SIZE = 1024;       void add(List<int> bytes) { throw new UnsupportedError("_CopyingBytesBuilder.add() is unsupported on this platform."); }   void addByte(int byte) { throw new UnsupportedError("_CopyingBytesBuilder.addByte() is unsupported on this platform."); }   List<int> takeBytes() { throw new UnsupportedError("_CopyingBytesBuilder.takeBytes() is unsupported on this platform."); }   List<int> toBytes() { throw new UnsupportedError("_CopyingBytesBuilder.toBytes() is unsupported on this platform."); }   int get length { throw new UnsupportedError("_CopyingBytesBuilder.length is unsupported on this platform."); }   bool get isEmpty { throw new UnsupportedError("_CopyingBytesBuilder.isEmpty is unsupported on this platform."); }   bool get isNotEmpty { throw new UnsupportedError("_CopyingBytesBuilder.isNotEmpty is unsupported on this platform."); }   void clear() { throw new UnsupportedError("_CopyingBytesBuilder.clear() is unsupported on this platform."); }  } class _BytesBuilder implements BytesBuilder {     void add(List<int> bytes) { throw new UnsupportedError("_BytesBuilder.add() is unsupported on this platform."); }   void addByte(int byte) { throw new UnsupportedError("_BytesBuilder.addByte() is unsupported on this platform."); }   List<int> takeBytes() { throw new UnsupportedError("_BytesBuilder.takeBytes() is unsupported on this platform."); }   List<int> toBytes() { throw new UnsupportedError("_BytesBuilder.toBytes() is unsupported on this platform."); }   int get length { throw new UnsupportedError("_BytesBuilder.length is unsupported on this platform."); }   bool get isEmpty { throw new UnsupportedError("_BytesBuilder.isEmpty is unsupported on this platform."); }   bool get isNotEmpty { throw new UnsupportedError("_BytesBuilder.isNotEmpty is unsupported on this platform."); }   void clear() { throw new UnsupportedError("_BytesBuilder.clear() is unsupported on this platform."); } }  const _SUCCESS_RESPONSE = 0;  const _ILLEGAL_ARGUMENT_RESPONSE = 1;  const _OSERROR_RESPONSE = 2;  const _FILE_CLOSED_RESPONSE = 3;  const _ERROR_RESPONSE_ERROR_TYPE = 0;  const _OSERROR_RESPONSE_ERROR_CODE = 1;  const _OSERROR_RESPONSE_MESSAGE = 2;  bool _isErrorResponse(response) { throw new UnsupportedError("_isErrorResponse() is unsupported on this platform."); }  _exceptionFromResponse(response, String message, String path) { throw new UnsupportedError("_exceptionFromResponse() is unsupported on this platform."); }  abstract class IOException implements Exception { String toString() { throw new UnsupportedError("IOException.toString() is unsupported on this platform."); } } class OSError { static const noErrorCode = -1;   String get message => throw new UnsupportedError("OSError.message is unsupported on this platform.");   int get errorCode => throw new UnsupportedError("OSError.errorCode is unsupported on this platform.");   const OSError([String message = "", int errorCode = noErrorCode]);   String toString() { throw new UnsupportedError("OSError.toString() is unsupported on this platform."); } } class _BufferAndStart { List buffer  int start  _BufferAndStart(List buffer, int start) { throw new UnsupportedError("new _BufferAndStart() is unsupported on this platform."); } } _BufferAndStart _ensureFastAndSerializableByteData(List buffer, int start, int end) { throw new UnsupportedError("_ensureFastAndSerializableByteData() is unsupported on this platform."); }  class _IOCrypto { static Uint8List getRandomBytes(int count) { throw new UnsupportedError("_IOCrypto.getRandomBytes() is unsupported on this platform."); } }   Console get console { throw new UnsupportedError("console is unsupported on this platform."); }  class Console {     Console._() { throw new UnsupportedError("new Console._() is unsupported on this platform."); }   ConsoleSink get log {}   ConsoleSink get error {} } class ConsoleSink implements Sink<List<int>>, StringSink {   ConsoleSink._(int fd) { throw new UnsupportedError("new ConsoleSink._() is unsupported on this platform."); }   void call([Object message = ""]) {}   void add(List<int> data) {}   void close() {}   void write(Object obj) {}   void writeAll(Iterable objects, [String separator = ""]) {}   void writeCharCode(int charCode) {}   void writeln([Object obj = ""]) {} } class _ConsoleConsumer implements StreamConsumer<List<int>> {   _ConsoleConsumer(int fd) { throw new UnsupportedError("new _ConsoleConsumer() is unsupported on this platform."); }   Future addStream(Stream<List<int>> stream) {}   Future close() {} }  class _CryptoUtils { static const PAD = 61;   static const CR = 13;   static const LF = 10;   static const LINE_LENGTH = 76;   static const _encodeTable = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";   static const _encodeTableUrlSafe = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";   static const _decodeTable = const [-2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -1, -2, -2, -1, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, 62, -2, 62, -2, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -2, -2, -2, 0, -2, -2, -2, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -2, -2, -2, -2, 63, -2, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2];   static String bytesToHex(List<int> bytes) { throw new UnsupportedError("_CryptoUtils.bytesToHex() is unsupported on this platform."); }   static String bytesToBase64(List<int> bytes, [bool urlSafe = false, bool addLineSeparator = false]) { throw new UnsupportedError("_CryptoUtils.bytesToBase64() is unsupported on this platform."); }   static List<int> base64StringToBytes(String input, [bool ignoreInvalidCharacters = true]) { throw new UnsupportedError("_CryptoUtils.base64StringToBytes() is unsupported on this platform."); } } const _MASK_8 = 0xff;  const _MASK_32 = 0xffffffff;  const _BITS_PER_BYTE = 8;  const _BYTES_PER_WORD = 4;  abstract class _HashBase {                 _HashBase(int _chunkSizeInWords, int _digestSizeInWords, bool _bigEndianWords) { throw new UnsupportedError("new _HashBase() is unsupported on this platform."); }   add(List<int> data) {}   List<int> close() {}   int get blockSize {}   newInstance();          } class _MD5 extends _HashBase { _MD5() : super(throw new UnsupportedError("new _MD5() is unsupported on this platform."), null, null) { throw new UnsupportedError("new _MD5() is unsupported on this platform."); }   _MD5 newInstance() {}   static const _k = const [0xd76aa478, 0xe8c7b756, 0x242070db, 0xc1bdceee, 0xf57c0faf, 0x4787c62a, 0xa8304613, 0xfd469501, 0x698098d8, 0x8b44f7af, 0xffff5bb1, 0x895cd7be, 0x6b901122, 0xfd987193, 0xa679438e, 0x49b40821, 0xf61e2562, 0xc040b340, 0x265e5a51, 0xe9b6c7aa, 0xd62f105d, 0x02441453, 0xd8a1e681, 0xe7d3fbc8, 0x21e1cde6, 0xc33707d6, 0xf4d50d87, 0x455a14ed, 0xa9e3e905, 0xfcefa3f8, 0x676f02d9, 0x8d2a4c8a, 0xfffa3942, 0x8771f681, 0x6d9d6122, 0xfde5380c, 0xa4beea44, 0x4bdecfa9, 0xf6bb4b60, 0xbebfbc70, 0x289b7ec6, 0xeaa127fa, 0xd4ef3085, 0x04881d05, 0xd9d4d039, 0xe6db99e5, 0x1fa27cf8, 0xc4ac5665, 0xf4292244, 0x432aff97, 0xab9423a7, 0xfc93a039, 0x655b59c3, 0x8f0ccc92, 0xffeff47d, 0x85845dd1, 0x6fa87e4f, 0xfe2ce6e0, 0xa3014314, 0x4e0811a1, 0xf7537e82, 0xbd3af235, 0x2ad7d2bb, 0xeb86d391];   static const _r = const [7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21];  } class _SHA1 extends _HashBase { _SHA1() : super(throw new UnsupportedError("new _SHA1() is unsupported on this platform."), null, null) { throw new UnsupportedError("new _SHA1() is unsupported on this platform."); }   _SHA1 newInstance() {}    }  abstract class ZLibOption { static const MIN_WINDOW_BITS = 8;   static const MAX_WINDOW_BITS = 15;   static const DEFAULT_WINDOW_BITS = 15;   static const MIN_LEVEL = -1;   static const MAX_LEVEL = 9;   static const DEFAULT_LEVEL = 6;   static const MIN_MEM_LEVEL = 1;   static const MAX_MEM_LEVEL = 9;   static const DEFAULT_MEM_LEVEL = 8;   static const STRATEGY_FILTERED = 1;   static const STRATEGY_HUFFMAN_ONLY = 2;   static const STRATEGY_RLE = 3;   static const STRATEGY_FIXED = 4;   static const STRATEGY_DEFAULT = 0; } const ZLIB = const ZLibCodec._default();  class ZLibCodec extends Codec<List<int>, List<int>> { bool get gzip => throw new UnsupportedError("ZLibCodec.gzip is unsupported on this platform.");   int get level => throw new UnsupportedError("ZLibCodec.level is unsupported on this platform.");   int get memLevel => throw new UnsupportedError("ZLibCodec.memLevel is unsupported on this platform.");   int get strategy => throw new UnsupportedError("ZLibCodec.strategy is unsupported on this platform.");   int get windowBits => throw new UnsupportedError("ZLibCodec.windowBits is unsupported on this platform.");   bool get raw => throw new UnsupportedError("ZLibCodec.raw is unsupported on this platform.");   List<int> get dictionary => throw new UnsupportedError("ZLibCodec.dictionary is unsupported on this platform.");   ZLibCodec({int level : ZLibOption.DEFAULT_LEVEL, int windowBits : ZLibOption.DEFAULT_WINDOW_BITS, int memLevel : ZLibOption.DEFAULT_MEM_LEVEL, int strategy : ZLibOption.STRATEGY_DEFAULT, List<int> dictionary : null, bool raw : false, bool gzip : false}) { throw new UnsupportedError("new ZLibCodec() is unsupported on this platform."); }   const ZLibCodec._default();   Converter<List<int>, List<int>> get encoder { throw new UnsupportedError("ZLibCodec.encoder is unsupported on this platform."); }   Converter<List<int>, List<int>> get decoder { throw new UnsupportedError("ZLibCodec.decoder is unsupported on this platform."); } } const GZIP = const GZipCodec._default();  class GZipCodec extends Codec<List<int>, List<int>> { bool get gzip => throw new UnsupportedError("GZipCodec.gzip is unsupported on this platform.");   int get level => throw new UnsupportedError("GZipCodec.level is unsupported on this platform.");   int get memLevel => throw new UnsupportedError("GZipCodec.memLevel is unsupported on this platform.");   int get strategy => throw new UnsupportedError("GZipCodec.strategy is unsupported on this platform.");   int get windowBits => throw new UnsupportedError("GZipCodec.windowBits is unsupported on this platform.");   List<int> get dictionary => throw new UnsupportedError("GZipCodec.dictionary is unsupported on this platform.");   bool get raw => throw new UnsupportedError("GZipCodec.raw is unsupported on this platform.");   GZipCodec({int level : ZLibOption.DEFAULT_LEVEL, int windowBits : ZLibOption.DEFAULT_WINDOW_BITS, int memLevel : ZLibOption.DEFAULT_MEM_LEVEL, int strategy : ZLibOption.STRATEGY_DEFAULT, List<int> dictionary : null, bool raw : false, bool gzip : true}) { throw new UnsupportedError("new GZipCodec() is unsupported on this platform."); }   const GZipCodec._default();   Converter<List<int>, List<int>> get encoder { throw new UnsupportedError("GZipCodec.encoder is unsupported on this platform."); }   Converter<List<int>, List<int>> get decoder { throw new UnsupportedError("GZipCodec.decoder is unsupported on this platform."); } } class ZLibEncoder extends Converter<List<int>, List<int>> { final bool gzip = null;   final int level = null;   final int memLevel = null;   final int strategy = null;   final int windowBits = null;   final List<int> dictionary = null;   final bool raw = null;   ZLibEncoder({bool gzip : false, int level : ZLibOption.DEFAULT_LEVEL, int windowBits : ZLibOption.DEFAULT_WINDOW_BITS, int memLevel : ZLibOption.DEFAULT_MEM_LEVEL, int strategy : ZLibOption.STRATEGY_DEFAULT, List<int> dictionary : null, bool raw : false}) { throw new UnsupportedError("new ZLibEncoder() is unsupported on this platform."); }   List<int> convert(List<int> bytes) {}   ByteConversionSink startChunkedConversion(Sink<List<int>> sink) {} } class ZLibDecoder extends Converter<List<int>, List<int>> { final int windowBits = null;   final List<int> dictionary = null;   final bool raw = null;   ZLibDecoder({int windowBits : ZLibOption.DEFAULT_WINDOW_BITS, List<int> dictionary : null, bool raw : false}) { throw new UnsupportedError("new ZLibDecoder() is unsupported on this platform."); }   List<int> convert(List<int> bytes) {}   ByteConversionSink startChunkedConversion(Sink<List<int>> sink) {} } class _BufferSink extends ByteConversionSink { BytesBuilder get builder => throw new UnsupportedError("_BufferSink.builder is unsupported on this platform.");   void add(List<int> chunk) { throw new UnsupportedError("_BufferSink.add() is unsupported on this platform."); }   void addSlice(List<int> chunk, int start, int end, bool isLast) { throw new UnsupportedError("_BufferSink.addSlice() is unsupported on this platform."); }   void close() { throw new UnsupportedError("_BufferSink.close() is unsupported on this platform."); } } class _ZLibEncoderSink extends _FilterSink { _ZLibEncoderSink(ByteConversionSink sink, bool gzip, int level, int windowBits, int memLevel, int strategy, List<int> dictionary, bool raw) : super(throw new UnsupportedError("new _ZLibEncoderSink() is unsupported on this platform."), null) { throw new UnsupportedError("new _ZLibEncoderSink() is unsupported on this platform."); } } class _ZLibDecoderSink extends _FilterSink { _ZLibDecoderSink(ByteConversionSink sink, int windowBits, List<int> dictionary, bool raw) : super(throw new UnsupportedError("new _ZLibDecoderSink() is unsupported on this platform."), null) { throw new UnsupportedError("new _ZLibDecoderSink() is unsupported on this platform."); } } class _FilterSink extends ByteConversionSink {         _FilterSink(ByteConversionSink _sink, _Filter _filter) { throw new UnsupportedError("new _FilterSink() is unsupported on this platform."); }   void add(List<int> data) {}   void addSlice(List<int> data, int start, int end, bool isLast) {}   void close() {} } abstract class _Filter { void process(List<int> data, int start, int end);   List<int> processed({bool flush : true, bool end : false});   void end();   static _Filter newZLibDeflateFilter(bool gzip, int level, int windowBits, int memLevel, int strategy, List<int> dictionary, bool raw) { throw new UnsupportedError("_Filter.newZLibDeflateFilter() is unsupported on this platform."); }   static _Filter newZLibInflateFilter(int windowBits, List<int> dictionary, bool raw) { throw new UnsupportedError("_Filter.newZLibInflateFilter() is unsupported on this platform."); } } void _validateZLibWindowBits(int windowBits) { throw new UnsupportedError("_validateZLibWindowBits() is unsupported on this platform."); }  void _validateZLibeLevel(int level) { throw new UnsupportedError("_validateZLibeLevel() is unsupported on this platform."); }  void _validateZLibMemLevel(int memLevel) { throw new UnsupportedError("_validateZLibMemLevel() is unsupported on this platform."); }  void _validateZLibStrategy(int strategy) { throw new UnsupportedError("_validateZLibStrategy() is unsupported on this platform."); }   abstract class Directory extends FileSystemEntity { final String path = null;   factory Directory(String path) { throw new UnsupportedError("new Directory() is unsupported on this platform."); }   factory Directory.fromUri(Uri uri) { throw new UnsupportedError("new Directory.fromUri() is unsupported on this platform."); }   static Directory get current { throw new UnsupportedError("Directory.current is unsupported on this platform."); }   static void set current(path) { throw new UnsupportedError("Directory.current= is unsupported on this platform."); }   Future<Directory> create({bool recursive : false});   void createSync({bool recursive : false});   static Directory get systemTemp { throw new UnsupportedError("Directory.systemTemp is unsupported on this platform."); }   Future<Directory> createTemp([String prefix]);   Directory createTempSync([String prefix]);   Future<String> resolveSymbolicLinks();   String resolveSymbolicLinksSync();   Future<Directory> rename(String newPath);   Directory renameSync(String newPath);   Directory get absolute;   Stream<FileSystemEntity> list({bool recursive : false, bool followLinks : true});   List<FileSystemEntity> listSync({bool recursive : false, bool followLinks : true});   String toString(); }  class _Directory extends FileSystemEntity implements Directory { final String path = null;   _Directory(String path) { throw new UnsupportedError("new _Directory() is unsupported on this platform."); }   static _current() { throw new UnsupportedError("_Directory._current() is unsupported on this platform."); }   static _setCurrent(path) { throw new UnsupportedError("_Directory._setCurrent() is unsupported on this platform."); }   static _createTemp(String path) { throw new UnsupportedError("_Directory._createTemp() is unsupported on this platform."); }   static String _systemTemp() { throw new UnsupportedError("_Directory._systemTemp() is unsupported on this platform."); }   static _exists(String path) { throw new UnsupportedError("_Directory._exists() is unsupported on this platform."); }   static _create(String path) { throw new UnsupportedError("_Directory._create() is unsupported on this platform."); }   static _deleteNative(String path, bool recursive) { throw new UnsupportedError("_Directory._deleteNative() is unsupported on this platform."); }   static _rename(String path, String newPath) { throw new UnsupportedError("_Directory._rename() is unsupported on this platform."); }   static List _list(String path, bool recursive, bool followLinks) { throw new UnsupportedError("_Directory._list() is unsupported on this platform."); }   static Directory get current { throw new UnsupportedError("_Directory.current is unsupported on this platform."); }   static void set current(path) { throw new UnsupportedError("_Directory.current= is unsupported on this platform."); }   Future<bool> exists() {}   bool existsSync() {}   Directory get absolute {}   Future<FileStat> stat() {}   FileStat statSync() {}    Future<Directory> create({bool recursive : false}) {}   void createSync({bool recursive : false}) {}   static Directory get systemTemp { throw new UnsupportedError("_Directory.systemTemp is unsupported on this platform."); }   Future<Directory> createTemp([String prefix]) {}   Directory createTempSync([String prefix]) {}     Future<Directory> rename(String newPath) {}   Directory renameSync(String newPath) {}   Stream<FileSystemEntity> list({bool recursive : false, bool followLinks : true}) {}   List listSync({bool recursive : false, bool followLinks : true}) {}   String toString() {}   } class _AsyncDirectoryLister { static const LIST_FILE = 0;   static const LIST_DIRECTORY = 1;   static const LIST_LINK = 2;   static const LIST_ERROR = 3;   static const LIST_DONE = 4;   static const RESPONSE_TYPE = 0;   static const RESPONSE_PATH = 1;   static const RESPONSE_COMPLETE = 1;   static const RESPONSE_ERROR = 2;   final String path = null;   final bool recursive = null;   final bool followLinks = null;   StreamController controller  int id  bool canceled  bool nextRunning  bool closed  Completer closeCompleter  _AsyncDirectoryLister(String path, bool recursive, bool followLinks) { throw new UnsupportedError("new _AsyncDirectoryLister() is unsupported on this platform."); }   Stream get stream {}   void onListen() {}   void onResume() {}   Future onCancel() {}   void next() {}   void close() {}   void error(message) {} }  class _EventHandler { static void _sendData(Object sender, SendPort sendPort, int data) { throw new UnsupportedError("_EventHandler._sendData() is unsupported on this platform."); } }  class FileMode { static const READ = const FileMode._internal(0);   static const WRITE = const FileMode._internal(1);   static const APPEND = const FileMode._internal(2);     const FileMode._internal(int _mode); } const READ = FileMode.READ;  const WRITE = FileMode.WRITE;  const APPEND = FileMode.APPEND;  class FileLock {   static const SHARED = const FileLock._internal(0);   static const EXCLUSIVE = const FileLock._internal(1);   const FileLock._internal(int _lock); } abstract class File extends FileSystemEntity { factory File(String path) { throw new UnsupportedError("new File() is unsupported on this platform."); }   factory File.fromUri(Uri uri) { throw new UnsupportedError("new File.fromUri() is unsupported on this platform."); }   Future<File> create({bool recursive : false});   void createSync({bool recursive : false});   Future<File> rename(String newPath);   File renameSync(String newPath);   Future<File> copy(String newPath);   File copySync(String newPath);   Future<int> length();   int lengthSync();   File get absolute;   Future<DateTime> lastModified();   DateTime lastModifiedSync();   Future<RandomAccessFile> open({FileMode mode : FileMode.READ});   RandomAccessFile openSync({FileMode mode : FileMode.READ});   Stream<List<int>> openRead([int start, int end]);   IOSink openWrite({FileMode mode : FileMode.WRITE, Encoding encoding : UTF8});   Future<List<int>> readAsBytes();   List<int> readAsBytesSync();   Future<String> readAsString({Encoding encoding : UTF8});   String readAsStringSync({Encoding encoding : UTF8});   Future<List<String>> readAsLines({Encoding encoding : UTF8});   List<String> readAsLinesSync({Encoding encoding : UTF8});   Future<File> writeAsBytes(List<int> bytes, {FileMode mode : FileMode.WRITE, bool flush : false});   void writeAsBytesSync(List<int> bytes, {FileMode mode : FileMode.WRITE, bool flush : false});   Future<File> writeAsString(String contents, {FileMode mode : FileMode.WRITE, Encoding encoding : UTF8, bool flush : false});   void writeAsStringSync(String contents, {FileMode mode : FileMode.WRITE, Encoding encoding : UTF8, bool flush : false});   String get path; } abstract class RandomAccessFile { Future<RandomAccessFile> close();   void closeSync();   Future<int> readByte();   int readByteSync();   Future<List<int>> read(int bytes);   List<int> readSync(int bytes);   Future<int> readInto(List<int> buffer, [int start, int end]);   int readIntoSync(List<int> buffer, [int start, int end]);   Future<RandomAccessFile> writeByte(int value);   int writeByteSync(int value);   Future<RandomAccessFile> writeFrom(List<int> buffer, [int start, int end]);   void writeFromSync(List<int> buffer, [int start, int end]);   Future<RandomAccessFile> writeString(String string, {Encoding encoding : UTF8});   void writeStringSync(String string, {Encoding encoding : UTF8});   Future<int> position();   int positionSync();   Future<RandomAccessFile> setPosition(int position);   void setPositionSync(int position);   Future<RandomAccessFile> truncate(int length);   void truncateSync(int length);   Future<int> length();   int lengthSync();   Future<RandomAccessFile> flush();   void flushSync();   Future<RandomAccessFile> lock([FileLock mode = FileLock.EXCLUSIVE, int start = 0, int end]);   void lockSync([FileLock mode = FileLock.EXCLUSIVE, int start = 0, int end]);   Future<RandomAccessFile> unlock([int start = 0, int end]);   void unlockSync([int start = 0, int end]);   String toString();   String get path; } class FileSystemException implements IOException { String get message => throw new UnsupportedError("FileSystemException.message is unsupported on this platform.");   String get path => throw new UnsupportedError("FileSystemException.path is unsupported on this platform.");   OSError get osError => throw new UnsupportedError("FileSystemException.osError is unsupported on this platform.");   const FileSystemException([String message = "", String path = "", OSError osError]);   String toString() { throw new UnsupportedError("FileSystemException.toString() is unsupported on this platform."); } }  const _BLOCK_SIZE = 64 * 1024;  class _FileStream extends Stream<List<int>> {                     _FileStream(String _path, int _position, int _end) { throw new UnsupportedError("new _FileStream() is unsupported on this platform."); }   _FileStream.forStdin() { throw new UnsupportedError("new _FileStream.forStdin() is unsupported on this platform."); }   StreamSubscription<List<int>> listen(void onData(List<int> event), {Function onError, void onDone(), bool cancelOnError}) {}     } class _FileStreamConsumer extends StreamConsumer<List<int>> {     _FileStreamConsumer(File _file, FileMode mode) { throw new UnsupportedError("new _FileStreamConsumer() is unsupported on this platform."); }   _FileStreamConsumer.fromStdio(int fd) { throw new UnsupportedError("new _FileStreamConsumer.fromStdio() is unsupported on this platform."); }   Future<File> addStream(Stream<List<int>> stream) {}   Future<File> close() {} } class _File extends FileSystemEntity implements File { final String path = null;   _File(String path) { throw new UnsupportedError("new _File() is unsupported on this platform."); }   Future<bool> exists() {}   static _exists(String path) { throw new UnsupportedError("_File._exists() is unsupported on this platform."); }   bool existsSync() {}   File get absolute {}   Future<FileStat> stat() {}   FileStat statSync() {}   Future<File> create({bool recursive : false}) {}   static _create(String path) { throw new UnsupportedError("_File._create() is unsupported on this platform."); }   static _createLink(String path, String target) { throw new UnsupportedError("_File._createLink() is unsupported on this platform."); }   static _linkTarget(String path) { throw new UnsupportedError("_File._linkTarget() is unsupported on this platform."); }   void createSync({bool recursive : false}) {}    static _deleteNative(String path) { throw new UnsupportedError("_File._deleteNative() is unsupported on this platform."); }   static _deleteLinkNative(String path) { throw new UnsupportedError("_File._deleteLinkNative() is unsupported on this platform."); }    Future<File> rename(String newPath) {}   static _rename(String oldPath, String newPath) { throw new UnsupportedError("_File._rename() is unsupported on this platform."); }   static _renameLink(String oldPath, String newPath) { throw new UnsupportedError("_File._renameLink() is unsupported on this platform."); }   File renameSync(String newPath) {}   Future<File> copy(String newPath) {}   static _copy(String oldPath, String newPath) { throw new UnsupportedError("_File._copy() is unsupported on this platform."); }   File copySync(String newPath) {}   Future<RandomAccessFile> open({FileMode mode : FileMode.READ}) {}   Future<int> length() {}   static _lengthFromPath(String path) { throw new UnsupportedError("_File._lengthFromPath() is unsupported on this platform."); }   int lengthSync() {}   Future<DateTime> lastModified() {}   static _lastModified(String path) { throw new UnsupportedError("_File._lastModified() is unsupported on this platform."); }   DateTime lastModifiedSync() {}   static _open(String path, int mode) { throw new UnsupportedError("_File._open() is unsupported on this platform."); }   RandomAccessFile openSync({FileMode mode : FileMode.READ}) {}   static int _openStdio(int fd) { throw new UnsupportedError("_File._openStdio() is unsupported on this platform."); }   static RandomAccessFile _openStdioSync(int fd) { throw new UnsupportedError("_File._openStdioSync() is unsupported on this platform."); }   Stream<List<int>> openRead([int start, int end]) {}   IOSink openWrite({FileMode mode : FileMode.WRITE, Encoding encoding : UTF8}) {}   Future<List<int>> readAsBytes() {}   List<int> readAsBytesSync() {}    Future<String> readAsString({Encoding encoding : UTF8}) {}   String readAsStringSync({Encoding encoding : UTF8}) {}   Future<List<String>> readAsLines({Encoding encoding : UTF8}) {}   List<String> readAsLinesSync({Encoding encoding : UTF8}) {}   Future<File> writeAsBytes(List<int> bytes, {FileMode mode : FileMode.WRITE, bool flush : false}) {}   void writeAsBytesSync(List<int> bytes, {FileMode mode : FileMode.WRITE, bool flush : false}) {}   Future<File> writeAsString(String contents, {FileMode mode : FileMode.WRITE, Encoding encoding : UTF8, bool flush : false}) {}   void writeAsStringSync(String contents, {FileMode mode : FileMode.WRITE, Encoding encoding : UTF8, bool flush : false}) {}   String toString() {}   static throwIfError(Object result, String msg, String path) { throw new UnsupportedError("_File.throwIfError() is unsupported on this platform."); } } class _RandomAccessFile extends Object with _ServiceObject implements RandomAccessFile {   final String path = null;                 _RandomAccessFile(int _id, String path) { throw new UnsupportedError("new _RandomAccessFile() is unsupported on this platform."); }       static int _getFD(int id) { throw new UnsupportedError("_RandomAccessFile._getFD() is unsupported on this platform."); }   Future<RandomAccessFile> close() {}   static int _close(int id) { throw new UnsupportedError("_RandomAccessFile._close() is unsupported on this platform."); }   void closeSync() {}   Future<int> readByte() {}   static _readByte(int id) { throw new UnsupportedError("_RandomAccessFile._readByte() is unsupported on this platform."); }   int readByteSync() {}   Future<List<int>> read(int bytes) {}   static _read(int id, int bytes) { throw new UnsupportedError("_RandomAccessFile._read() is unsupported on this platform."); }   List<int> readSync(int bytes) {}   Future<int> readInto(List<int> buffer, [int start, int end]) {}   static void _checkReadWriteListArguments(int length, int start, int end) { throw new UnsupportedError("_RandomAccessFile._checkReadWriteListArguments() is unsupported on this platform."); }   static _readInto(int id, List<int> buffer, int start, int end) { throw new UnsupportedError("_RandomAccessFile._readInto() is unsupported on this platform."); }   int readIntoSync(List<int> buffer, [int start, int end]) {}   Future<RandomAccessFile> writeByte(int value) {}   static _writeByte(int id, int value) { throw new UnsupportedError("_RandomAccessFile._writeByte() is unsupported on this platform."); }   int writeByteSync(int value) {}   Future<RandomAccessFile> writeFrom(List<int> buffer, [int start, int end]) {}   static _writeFrom(int id, List<int> buffer, int start, int end) { throw new UnsupportedError("_RandomAccessFile._writeFrom() is unsupported on this platform."); }   void writeFromSync(List<int> buffer, [int start, int end]) {}   Future<RandomAccessFile> writeString(String string, {Encoding encoding : UTF8}) {}   void writeStringSync(String string, {Encoding encoding : UTF8}) {}   Future<int> position() {}   static _position(int id) { throw new UnsupportedError("_RandomAccessFile._position() is unsupported on this platform."); }   int positionSync() {}   Future<RandomAccessFile> setPosition(int position) {}   static _setPosition(int id, int position) { throw new UnsupportedError("_RandomAccessFile._setPosition() is unsupported on this platform."); }   void setPositionSync(int position) {}   Future<RandomAccessFile> truncate(int length) {}   static _truncate(int id, int length) { throw new UnsupportedError("_RandomAccessFile._truncate() is unsupported on this platform."); }   void truncateSync(int length) {}   Future<int> length() {}   static _length(int id) { throw new UnsupportedError("_RandomAccessFile._length() is unsupported on this platform."); }   int lengthSync() {}   Future<RandomAccessFile> flush() {}   static _flush(int id) { throw new UnsupportedError("_RandomAccessFile._flush() is unsupported on this platform."); }   void flushSync() {}   static int get LOCK_UNLOCK => throw new UnsupportedError("_RandomAccessFile.LOCK_UNLOCK is unsupported on this platform.");   static int get LOCK_SHARED => throw new UnsupportedError("_RandomAccessFile.LOCK_SHARED is unsupported on this platform.");   static int get LOCK_EXCLUSIVE => throw new UnsupportedError("_RandomAccessFile.LOCK_EXCLUSIVE is unsupported on this platform.");   Future<RandomAccessFile> lock([FileLock mode = FileLock.EXCLUSIVE, int start = 0, int end]) {}   Future<RandomAccessFile> unlock([int start = 0, int end]) {}   static _lock(int id, int lock, int start, int end) { throw new UnsupportedError("_RandomAccessFile._lock() is unsupported on this platform."); }   void lockSync([FileLock mode = FileLock.EXCLUSIVE, int start = 0, int end]) {}   void unlockSync([int start = 0, int end]) {}   bool get closed {}   }  class FileSystemEntityType { static const FILE = const FileSystemEntityType._internal(0);   static const DIRECTORY = const FileSystemEntityType._internal(1);   static const LINK = const FileSystemEntityType._internal(2);   static const NOT_FOUND = const FileSystemEntityType._internal(3);   static const _typeList = const [FileSystemEntityType.FILE, FileSystemEntityType.DIRECTORY, FileSystemEntityType.LINK, FileSystemEntityType.NOT_FOUND];     const FileSystemEntityType._internal(int _type);   static FileSystemEntityType _lookup(int type) { throw new UnsupportedError("FileSystemEntityType._lookup() is unsupported on this platform."); }   String toString() { throw new UnsupportedError("FileSystemEntityType.toString() is unsupported on this platform."); } } class FileStat { static const _TYPE = 0;   static const _CHANGED_TIME = 1;   static const _MODIFIED_TIME = 2;   static const _ACCESSED_TIME = 3;   static const _MODE = 4;   static const _SIZE = 5;   static const _notFound = const FileStat._internalNotFound();   DateTime get changed => throw new UnsupportedError("FileStat.changed is unsupported on this platform.");   DateTime get modified => throw new UnsupportedError("FileStat.modified is unsupported on this platform.");   DateTime get accessed => throw new UnsupportedError("FileStat.accessed is unsupported on this platform.");   FileSystemEntityType get type => throw new UnsupportedError("FileStat.type is unsupported on this platform.");   int get mode => throw new UnsupportedError("FileStat.mode is unsupported on this platform.");   int get size => throw new UnsupportedError("FileStat.size is unsupported on this platform.");   FileStat._internal(DateTime changed, DateTime modified, DateTime accessed, FileSystemEntityType type, int mode, int size) { throw new UnsupportedError("new FileStat._internal() is unsupported on this platform."); }   const FileStat._internalNotFound();   static _statSync(String path) { throw new UnsupportedError("FileStat._statSync() is unsupported on this platform."); }   static FileStat statSync(String path) { throw new UnsupportedError("FileStat.statSync() is unsupported on this platform."); }   static Future<FileStat> stat(String path) { throw new UnsupportedError("FileStat.stat() is unsupported on this platform."); }   String toString() { throw new UnsupportedError("FileStat.toString() is unsupported on this platform."); }   String modeString() { throw new UnsupportedError("FileStat.modeString() is unsupported on this platform."); } } abstract class FileSystemEntity { String get path;   Future<bool> exists();   bool existsSync();   Future<FileSystemEntity> rename(String newPath);   FileSystemEntity renameSync(String newPath);   Future<String> resolveSymbolicLinks() { throw new UnsupportedError("FileSystemEntity.resolveSymbolicLinks() is unsupported on this platform."); }   String resolveSymbolicLinksSync() { throw new UnsupportedError("FileSystemEntity.resolveSymbolicLinksSync() is unsupported on this platform."); }   Future<FileStat> stat();   FileStat statSync();   Future<FileSystemEntity> delete({bool recursive : false}) { throw new UnsupportedError("FileSystemEntity.delete() is unsupported on this platform."); }   void deleteSync({bool recursive : false}) { throw new UnsupportedError("FileSystemEntity.deleteSync() is unsupported on this platform."); }   Stream<FileSystemEvent> watch({int events : FileSystemEvent.ALL, bool recursive : false}) { throw new UnsupportedError("FileSystemEntity.watch() is unsupported on this platform."); }     static Future<bool> identical(String path1, String path2) { throw new UnsupportedError("FileSystemEntity.identical() is unsupported on this platform."); }     bool get isAbsolute { throw new UnsupportedError("FileSystemEntity.isAbsolute is unsupported on this platform."); }   FileSystemEntity get absolute;    static bool identicalSync(String path1, String path2) { throw new UnsupportedError("FileSystemEntity.identicalSync() is unsupported on this platform."); }   static bool get isWatchSupported { throw new UnsupportedError("FileSystemEntity.isWatchSupported is unsupported on this platform."); }   static Future<FileSystemEntityType> type(String path, {bool followLinks : true}) { throw new UnsupportedError("FileSystemEntity.type() is unsupported on this platform."); }   static FileSystemEntityType typeSync(String path, {bool followLinks : true}) { throw new UnsupportedError("FileSystemEntity.typeSync() is unsupported on this platform."); }   static Future<bool> isLink(String path) { throw new UnsupportedError("FileSystemEntity.isLink() is unsupported on this platform."); }   static Future<bool> isFile(String path) { throw new UnsupportedError("FileSystemEntity.isFile() is unsupported on this platform."); }   static Future<bool> isDirectory(String path) { throw new UnsupportedError("FileSystemEntity.isDirectory() is unsupported on this platform."); }   static bool isLinkSync(String path) { throw new UnsupportedError("FileSystemEntity.isLinkSync() is unsupported on this platform."); }   static bool isFileSync(String path) { throw new UnsupportedError("FileSystemEntity.isFileSync() is unsupported on this platform."); }   static bool isDirectorySync(String path) { throw new UnsupportedError("FileSystemEntity.isDirectorySync() is unsupported on this platform."); }   static _getType(String path, bool followLinks) { throw new UnsupportedError("FileSystemEntity._getType() is unsupported on this platform."); }   static _identical(String path1, String path2) { throw new UnsupportedError("FileSystemEntity._identical() is unsupported on this platform."); }   static _resolveSymbolicLinks(String path) { throw new UnsupportedError("FileSystemEntity._resolveSymbolicLinks() is unsupported on this platform."); }     static String parentOf(String path) { throw new UnsupportedError("FileSystemEntity.parentOf() is unsupported on this platform."); }   Directory get parent { throw new UnsupportedError("FileSystemEntity.parent is unsupported on this platform."); }   static int _getTypeSync(String path, bool followLinks) { throw new UnsupportedError("FileSystemEntity._getTypeSync() is unsupported on this platform."); }   static Future<int> _getTypeAsync(String path, bool followLinks) { throw new UnsupportedError("FileSystemEntity._getTypeAsync() is unsupported on this platform."); }   static _throwIfError(Object result, String msg, [String path]) { throw new UnsupportedError("FileSystemEntity._throwIfError() is unsupported on this platform."); }   static String _trimTrailingPathSeparators(String path) { throw new UnsupportedError("FileSystemEntity._trimTrailingPathSeparators() is unsupported on this platform."); }   static String _ensureTrailingPathSeparators(String path) { throw new UnsupportedError("FileSystemEntity._ensureTrailingPathSeparators() is unsupported on this platform."); } } class FileSystemEvent { static const CREATE = 1 << 0;   static const MODIFY = 1 << 1;   static const DELETE = 1 << 2;   static const MOVE = 1 << 3;   static const ALL = CREATE | MODIFY | DELETE | MOVE;   static const _MODIFY_ATTRIBUTES = 1 << 4;   static const _DELETE_SELF = 1 << 5;   static const _IS_DIR = 1 << 6;   final int type = null;   final String path = null;   final bool isDirectory = null;   FileSystemEvent._(int type, String path, bool isDirectory) { throw new UnsupportedError("new FileSystemEvent._() is unsupported on this platform."); } } class FileSystemCreateEvent extends FileSystemEvent { FileSystemCreateEvent._(path, isDirectory) : super._(throw new UnsupportedError("new FileSystemCreateEvent._() is unsupported on this platform."), null, null) { throw new UnsupportedError("new FileSystemCreateEvent._() is unsupported on this platform."); }   String toString() {} } class FileSystemModifyEvent extends FileSystemEvent { final bool contentChanged = null;   FileSystemModifyEvent._(path, isDirectory, bool contentChanged) : super._(throw new UnsupportedError("new FileSystemModifyEvent._() is unsupported on this platform."), null, null) { throw new UnsupportedError("new FileSystemModifyEvent._() is unsupported on this platform."); }   String toString() {} } class FileSystemDeleteEvent extends FileSystemEvent { FileSystemDeleteEvent._(path, isDirectory) : super._(throw new UnsupportedError("new FileSystemDeleteEvent._() is unsupported on this platform."), null, null) { throw new UnsupportedError("new FileSystemDeleteEvent._() is unsupported on this platform."); }   String toString() {} } class FileSystemMoveEvent extends FileSystemEvent { final String destination = null;   FileSystemMoveEvent._(path, isDirectory, String destination) : super._(throw new UnsupportedError("new FileSystemMoveEvent._() is unsupported on this platform."), null, null) { throw new UnsupportedError("new FileSystemMoveEvent._() is unsupported on this platform."); }   String toString() {} } class _FileSystemWatcher { static Stream<FileSystemEvent> watch(String path, int events, bool recursive) { throw new UnsupportedError("_FileSystemWatcher.watch() is unsupported on this platform."); }   static bool get isSupported { throw new UnsupportedError("_FileSystemWatcher.isSupported is unsupported on this platform."); } }  abstract class HttpStatus { static const CONTINUE = 100;   static const SWITCHING_PROTOCOLS = 101;   static const OK = 200;   static const CREATED = 201;   static const ACCEPTED = 202;   static const NON_AUTHORITATIVE_INFORMATION = 203;   static const NO_CONTENT = 204;   static const RESET_CONTENT = 205;   static const PARTIAL_CONTENT = 206;   static const MULTIPLE_CHOICES = 300;   static const MOVED_PERMANENTLY = 301;   static const FOUND = 302;   static const MOVED_TEMPORARILY = 302;   static const SEE_OTHER = 303;   static const NOT_MODIFIED = 304;   static const USE_PROXY = 305;   static const TEMPORARY_REDIRECT = 307;   static const BAD_REQUEST = 400;   static const UNAUTHORIZED = 401;   static const PAYMENT_REQUIRED = 402;   static const FORBIDDEN = 403;   static const NOT_FOUND = 404;   static const METHOD_NOT_ALLOWED = 405;   static const NOT_ACCEPTABLE = 406;   static const PROXY_AUTHENTICATION_REQUIRED = 407;   static const REQUEST_TIMEOUT = 408;   static const CONFLICT = 409;   static const GONE = 410;   static const LENGTH_REQUIRED = 411;   static const PRECONDITION_FAILED = 412;   static const REQUEST_ENTITY_TOO_LARGE = 413;   static const REQUEST_URI_TOO_LONG = 414;   static const UNSUPPORTED_MEDIA_TYPE = 415;   static const REQUESTED_RANGE_NOT_SATISFIABLE = 416;   static const EXPECTATION_FAILED = 417;   static const INTERNAL_SERVER_ERROR = 500;   static const NOT_IMPLEMENTED = 501;   static const BAD_GATEWAY = 502;   static const SERVICE_UNAVAILABLE = 503;   static const GATEWAY_TIMEOUT = 504;   static const HTTP_VERSION_NOT_SUPPORTED = 505;   static const NETWORK_CONNECT_TIMEOUT_ERROR = 599; } abstract class HttpServer implements Stream<HttpRequest> { String serverHeader  HttpHeaders get defaultResponseHeaders;   bool autoCompress  Duration idleTimeout  static Future<HttpServer> bind(address, int port, {int backlog : 0}) { throw new UnsupportedError("HttpServer.bind() is unsupported on this platform."); }   static Future<HttpServer> bindSecure(address, int port, {int backlog : 0, String certificateName, bool requestClientCertificate : false}) { throw new UnsupportedError("HttpServer.bindSecure() is unsupported on this platform."); }   factory HttpServer.listenOn(ServerSocket serverSocket) { throw new UnsupportedError("new HttpServer.listenOn() is unsupported on this platform."); }   Future close({bool force : false});   int get port;   InternetAddress get address;   set sessionTimeout(int timeout);   HttpConnectionsInfo connectionsInfo(); } class HttpConnectionsInfo { int get total => throw new UnsupportedError("HttpConnectionsInfo.total is unsupported on this platform."); set total(int _) { throw new UnsupportedError("HttpConnectionsInfo.total= is unsupported on this platform."); }   int get active => throw new UnsupportedError("HttpConnectionsInfo.active is unsupported on this platform."); set active(int _) { throw new UnsupportedError("HttpConnectionsInfo.active= is unsupported on this platform."); }   int get idle => throw new UnsupportedError("HttpConnectionsInfo.idle is unsupported on this platform."); set idle(int _) { throw new UnsupportedError("HttpConnectionsInfo.idle= is unsupported on this platform."); }   int get closing => throw new UnsupportedError("HttpConnectionsInfo.closing is unsupported on this platform."); set closing(int _) { throw new UnsupportedError("HttpConnectionsInfo.closing= is unsupported on this platform."); } } abstract class HttpHeaders { static const ACCEPT = "accept";   static const ACCEPT_CHARSET = "accept-charset";   static const ACCEPT_ENCODING = "accept-encoding";   static const ACCEPT_LANGUAGE = "accept-language";   static const ACCEPT_RANGES = "accept-ranges";   static const AGE = "age";   static const ALLOW = "allow";   static const AUTHORIZATION = "authorization";   static const CACHE_CONTROL = "cache-control";   static const CONNECTION = "connection";   static const CONTENT_ENCODING = "content-encoding";   static const CONTENT_LANGUAGE = "content-language";   static const CONTENT_LENGTH = "content-length";   static const CONTENT_LOCATION = "content-location";   static const CONTENT_MD5 = "content-md5";   static const CONTENT_RANGE = "content-range";   static const CONTENT_TYPE = "content-type";   static const DATE = "date";   static const ETAG = "etag";   static const EXPECT = "expect";   static const EXPIRES = "expires";   static const FROM = "from";   static const HOST = "host";   static const IF_MATCH = "if-match";   static const IF_MODIFIED_SINCE = "if-modified-since";   static const IF_NONE_MATCH = "if-none-match";   static const IF_RANGE = "if-range";   static const IF_UNMODIFIED_SINCE = "if-unmodified-since";   static const LAST_MODIFIED = "last-modified";   static const LOCATION = "location";   static const MAX_FORWARDS = "max-forwards";   static const PRAGMA = "pragma";   static const PROXY_AUTHENTICATE = "proxy-authenticate";   static const PROXY_AUTHORIZATION = "proxy-authorization";   static const RANGE = "range";   static const REFERER = "referer";   static const RETRY_AFTER = "retry-after";   static const SERVER = "server";   static const TE = "te";   static const TRAILER = "trailer";   static const TRANSFER_ENCODING = "transfer-encoding";   static const UPGRADE = "upgrade";   static const USER_AGENT = "user-agent";   static const VARY = "vary";   static const VIA = "via";   static const WARNING = "warning";   static const WWW_AUTHENTICATE = "www-authenticate";   static const COOKIE = "cookie";   static const SET_COOKIE = "set-cookie";   static const GENERAL_HEADERS = const [CACHE_CONTROL, CONNECTION, DATE, PRAGMA, TRAILER, TRANSFER_ENCODING, UPGRADE, VIA, WARNING];   static const ENTITY_HEADERS = const [ALLOW, CONTENT_ENCODING, CONTENT_LANGUAGE, CONTENT_LENGTH, CONTENT_LOCATION, CONTENT_MD5, CONTENT_RANGE, CONTENT_TYPE, EXPIRES, LAST_MODIFIED];   static const RESPONSE_HEADERS = const [ACCEPT_RANGES, AGE, ETAG, LOCATION, PROXY_AUTHENTICATE, RETRY_AFTER, SERVER, VARY, WWW_AUTHENTICATE];   static const REQUEST_HEADERS = const [ACCEPT, ACCEPT_CHARSET, ACCEPT_ENCODING, ACCEPT_LANGUAGE, AUTHORIZATION, EXPECT, FROM, HOST, IF_MATCH, IF_MODIFIED_SINCE, IF_NONE_MATCH, IF_RANGE, IF_UNMODIFIED_SINCE, MAX_FORWARDS, PROXY_AUTHORIZATION, RANGE, REFERER, TE, USER_AGENT];   DateTime get date => throw new UnsupportedError("HttpHeaders.date is unsupported on this platform."); set date(DateTime _) { throw new UnsupportedError("HttpHeaders.date= is unsupported on this platform."); }   DateTime get expires => throw new UnsupportedError("HttpHeaders.expires is unsupported on this platform."); set expires(DateTime _) { throw new UnsupportedError("HttpHeaders.expires= is unsupported on this platform."); }   DateTime get ifModifiedSince => throw new UnsupportedError("HttpHeaders.ifModifiedSince is unsupported on this platform."); set ifModifiedSince(DateTime _) { throw new UnsupportedError("HttpHeaders.ifModifiedSince= is unsupported on this platform."); }   String get host => throw new UnsupportedError("HttpHeaders.host is unsupported on this platform."); set host(String _) { throw new UnsupportedError("HttpHeaders.host= is unsupported on this platform."); }   int get port => throw new UnsupportedError("HttpHeaders.port is unsupported on this platform."); set port(int _) { throw new UnsupportedError("HttpHeaders.port= is unsupported on this platform."); }   ContentType get contentType => throw new UnsupportedError("HttpHeaders.contentType is unsupported on this platform."); set contentType(ContentType _) { throw new UnsupportedError("HttpHeaders.contentType= is unsupported on this platform."); }   int get contentLength => throw new UnsupportedError("HttpHeaders.contentLength is unsupported on this platform."); set contentLength(int _) { throw new UnsupportedError("HttpHeaders.contentLength= is unsupported on this platform."); }   bool get persistentConnection => throw new UnsupportedError("HttpHeaders.persistentConnection is unsupported on this platform."); set persistentConnection(bool _) { throw new UnsupportedError("HttpHeaders.persistentConnection= is unsupported on this platform."); }   bool get chunkedTransferEncoding => throw new UnsupportedError("HttpHeaders.chunkedTransferEncoding is unsupported on this platform."); set chunkedTransferEncoding(bool _) { throw new UnsupportedError("HttpHeaders.chunkedTransferEncoding= is unsupported on this platform."); }   List<String> operator [](String name);   String value(String name);   void add(String name, Object value);   void set(String name, Object value);   void remove(String name, Object value);   void removeAll(String name);   void forEach(void f(String name, List<String> values));   void noFolding(String name);   void clear(); } abstract class HeaderValue { factory HeaderValue([String value = "", Map<String, String> parameters]) { throw new UnsupportedError("new HeaderValue() is unsupported on this platform."); }   static HeaderValue parse(String value, {String parameterSeparator : ";", bool preserveBackslash : false}) { throw new UnsupportedError("HeaderValue.parse() is unsupported on this platform."); }   String get value;   Map<String, String> get parameters;   String toString(); } abstract class HttpSession implements Map { String get id;   void destroy();   void set onTimeout(void callback());   bool get isNew; } abstract class ContentType implements HeaderValue { static get TEXT => throw new UnsupportedError("ContentType.TEXT is unsupported on this platform.");   static get HTML => throw new UnsupportedError("ContentType.HTML is unsupported on this platform.");   static get JSON => throw new UnsupportedError("ContentType.JSON is unsupported on this platform.");   static get BINARY => throw new UnsupportedError("ContentType.BINARY is unsupported on this platform.");   factory ContentType(String primaryType, String subType, {String charset, Map<String, String> parameters}) { throw new UnsupportedError("new ContentType() is unsupported on this platform."); }   static ContentType parse(String value) { throw new UnsupportedError("ContentType.parse() is unsupported on this platform."); }   String get mimeType;   String get primaryType;   String get subType;   String get charset; } abstract class Cookie { String name  String value  DateTime expires  int maxAge  String domain  String path  bool secure  bool httpOnly  factory Cookie([String name, String value]) { throw new UnsupportedError("new Cookie() is unsupported on this platform."); }   factory Cookie.fromSetCookieValue(String value) { throw new UnsupportedError("new Cookie.fromSetCookieValue() is unsupported on this platform."); }   String toString(); } abstract class HttpRequest implements Stream<List<int>> { int get contentLength;   String get method;   Uri get uri;   Uri get requestedUri;   HttpHeaders get headers;   List<Cookie> get cookies;   bool get persistentConnection;   X509Certificate get certificate;   HttpSession get session;   String get protocolVersion;   HttpConnectionInfo get connectionInfo;   HttpResponse get response; } abstract class HttpResponse implements IOSink { int get contentLength => throw new UnsupportedError("HttpResponse.contentLength is unsupported on this platform."); set contentLength(int _) { throw new UnsupportedError("HttpResponse.contentLength= is unsupported on this platform."); }   int get statusCode => throw new UnsupportedError("HttpResponse.statusCode is unsupported on this platform."); set statusCode(int _) { throw new UnsupportedError("HttpResponse.statusCode= is unsupported on this platform."); }   String get reasonPhrase => throw new UnsupportedError("HttpResponse.reasonPhrase is unsupported on this platform."); set reasonPhrase(String _) { throw new UnsupportedError("HttpResponse.reasonPhrase= is unsupported on this platform."); }   bool get persistentConnection => throw new UnsupportedError("HttpResponse.persistentConnection is unsupported on this platform."); set persistentConnection(bool _) { throw new UnsupportedError("HttpResponse.persistentConnection= is unsupported on this platform."); }   Duration get deadline => throw new UnsupportedError("HttpResponse.deadline is unsupported on this platform."); set deadline(Duration _) { throw new UnsupportedError("HttpResponse.deadline= is unsupported on this platform."); }   bool get bufferOutput => throw new UnsupportedError("HttpResponse.bufferOutput is unsupported on this platform."); set bufferOutput(bool _) { throw new UnsupportedError("HttpResponse.bufferOutput= is unsupported on this platform."); }   HttpHeaders get headers;   List<Cookie> get cookies;   Future redirect(Uri location, {int status : HttpStatus.MOVED_TEMPORARILY});   Future<Socket> detachSocket({bool writeHeaders : true});   HttpConnectionInfo get connectionInfo; } abstract class HttpClient { static const DEFAULT_HTTP_PORT = 80;   static const DEFAULT_HTTPS_PORT = 443;   Duration idleTimeout  int maxConnectionsPerHost  bool autoUncompress  String userAgent  factory HttpClient() { throw new UnsupportedError("new HttpClient() is unsupported on this platform."); }   Future<HttpClientRequest> open(String method, String host, int port, String path);   Future<HttpClientRequest> openUrl(String method, Uri url);   Future<HttpClientRequest> get(String host, int port, String path);   Future<HttpClientRequest> getUrl(Uri url);   Future<HttpClientRequest> post(String host, int port, String path);   Future<HttpClientRequest> postUrl(Uri url);   Future<HttpClientRequest> put(String host, int port, String path);   Future<HttpClientRequest> putUrl(Uri url);   Future<HttpClientRequest> delete(String host, int port, String path);   Future<HttpClientRequest> deleteUrl(Uri url);   Future<HttpClientRequest> patch(String host, int port, String path);   Future<HttpClientRequest> patchUrl(Uri url);   Future<HttpClientRequest> head(String host, int port, String path);   Future<HttpClientRequest> headUrl(Uri url);   set authenticate(Future<bool> f(Uri url, String scheme, String realm));   void addCredentials(Uri url, String realm, HttpClientCredentials credentials);   set findProxy(String f(Uri url));   static String findProxyFromEnvironment(Uri url, {Map<String, String> environment}) { throw new UnsupportedError("HttpClient.findProxyFromEnvironment() is unsupported on this platform."); }   set authenticateProxy(Future<bool> f(String host, int port, String scheme, String realm));   void addProxyCredentials(String host, int port, String realm, HttpClientCredentials credentials);   set badCertificateCallback(bool callback(X509Certificate cert, String host, int port));   void close({bool force : false}); } abstract class HttpClientRequest implements IOSink { bool get persistentConnection => throw new UnsupportedError("HttpClientRequest.persistentConnection is unsupported on this platform."); set persistentConnection(bool _) { throw new UnsupportedError("HttpClientRequest.persistentConnection= is unsupported on this platform."); }   bool get followRedirects => throw new UnsupportedError("HttpClientRequest.followRedirects is unsupported on this platform."); set followRedirects(bool _) { throw new UnsupportedError("HttpClientRequest.followRedirects= is unsupported on this platform."); }   int get maxRedirects => throw new UnsupportedError("HttpClientRequest.maxRedirects is unsupported on this platform."); set maxRedirects(int _) { throw new UnsupportedError("HttpClientRequest.maxRedirects= is unsupported on this platform."); }   String get method;   Uri get uri;   int get contentLength => throw new UnsupportedError("HttpClientRequest.contentLength is unsupported on this platform."); set contentLength(int _) { throw new UnsupportedError("HttpClientRequest.contentLength= is unsupported on this platform."); }   bool get bufferOutput => throw new UnsupportedError("HttpClientRequest.bufferOutput is unsupported on this platform."); set bufferOutput(bool _) { throw new UnsupportedError("HttpClientRequest.bufferOutput= is unsupported on this platform."); }   HttpHeaders get headers;   List<Cookie> get cookies;   Future<HttpClientResponse> get done;   Future<HttpClientResponse> close();   HttpConnectionInfo get connectionInfo; } abstract class HttpClientResponse implements Stream<List<int>> { int get statusCode;   String get reasonPhrase;   int get contentLength;   bool get persistentConnection;   bool get isRedirect;   List<RedirectInfo> get redirects;   Future<HttpClientResponse> redirect([String method, Uri url, bool followLoops]);   HttpHeaders get headers;   Future<Socket> detachSocket();   List<Cookie> get cookies;   X509Certificate get certificate;   HttpConnectionInfo get connectionInfo; } abstract class HttpClientCredentials {} abstract class HttpClientBasicCredentials extends HttpClientCredentials { factory HttpClientBasicCredentials(String username, String password) { throw new UnsupportedError("new HttpClientBasicCredentials() is unsupported on this platform."); } } abstract class HttpClientDigestCredentials extends HttpClientCredentials { factory HttpClientDigestCredentials(String username, String password) { throw new UnsupportedError("new HttpClientDigestCredentials() is unsupported on this platform."); } } abstract class HttpConnectionInfo { InternetAddress get remoteAddress;   int get remotePort;   int get localPort; } abstract class RedirectInfo { int get statusCode;   String get method;   Uri get location; } abstract class DetachedSocket { Socket get socket;   List<int> get unparsedData; } class HttpException implements IOException { String get message => throw new UnsupportedError("HttpException.message is unsupported on this platform.");   Uri get uri => throw new UnsupportedError("HttpException.uri is unsupported on this platform.");   const HttpException(String message, {Uri uri});   String toString() { throw new UnsupportedError("HttpException.toString() is unsupported on this platform."); } } class RedirectException implements HttpException { String get message => throw new UnsupportedError("RedirectException.message is unsupported on this platform.");   List<RedirectInfo> get redirects => throw new UnsupportedError("RedirectException.redirects is unsupported on this platform.");   const RedirectException(String message, List<RedirectInfo> redirects);   String toString() { throw new UnsupportedError("RedirectException.toString() is unsupported on this platform."); }   Uri get uri { throw new UnsupportedError("RedirectException.uri is unsupported on this platform."); } }  class HttpDate { static String format(DateTime date) { throw new UnsupportedError("HttpDate.format() is unsupported on this platform."); }   static DateTime parse(String date) { throw new UnsupportedError("HttpDate.parse() is unsupported on this platform."); }   static DateTime _parseCookieDate(String date) { throw new UnsupportedError("HttpDate._parseCookieDate() is unsupported on this platform."); } }  class _HttpHeaders implements HttpHeaders {   final String protocolVersion = null;                   _HttpHeaders(String protocolVersion, {int defaultPortForScheme : HttpClient.DEFAULT_HTTP_PORT, _HttpHeaders initialHeaders}) { throw new UnsupportedError("new _HttpHeaders() is unsupported on this platform."); }   List<String> operator [](String name) {}   String value(String name) {}   void add(String name, value) {}    void set(String name, Object value) {}   void remove(String name, Object value) {}   void removeAll(String name) {}   void forEach(void f(String name, List<String> values)) {}   void noFolding(String name) {}   bool get persistentConnection {}   void set persistentConnection(bool persistentConnection) {}   int get contentLength {}   void set contentLength(int contentLength) {}   bool get chunkedTransferEncoding {}   void set chunkedTransferEncoding(bool chunkedTransferEncoding) {}   String get host {}   void set host(String host) {}   int get port {}   void set port(int port) {}   DateTime get ifModifiedSince {}   void set ifModifiedSince(DateTime ifModifiedSince) {}   DateTime get date {}   void set date(DateTime date) {}   DateTime get expires {}   void set expires(DateTime expires) {}   ContentType get contentType {}   void set contentType(ContentType contentType) {}   void clear() {}                   String toString() {}    static String _validateField(String field) { throw new UnsupportedError("_HttpHeaders._validateField() is unsupported on this platform."); }   static _validateValue(value) { throw new UnsupportedError("_HttpHeaders._validateValue() is unsupported on this platform."); } } class _HeaderValue implements HeaderValue {       _HeaderValue([String _value = "", Map<String, String> parameters]) { throw new UnsupportedError("new _HeaderValue() is unsupported on this platform."); }   static _HeaderValue parse(String value, {parameterSeparator : ";", preserveBackslash : false}) { throw new UnsupportedError("_HeaderValue.parse() is unsupported on this platform."); }   String get value {}    Map<String, String> get parameters {}   String toString() {}  } class _ContentType extends _HeaderValue implements ContentType {     _ContentType(String primaryType, String subType, String charset, Map<String, String> parameters) : super(throw new UnsupportedError("new _ContentType() is unsupported on this platform.")) { throw new UnsupportedError("new _ContentType() is unsupported on this platform."); }   _ContentType._() { throw new UnsupportedError("new _ContentType._() is unsupported on this platform."); }   static _ContentType parse(String value) { throw new UnsupportedError("_ContentType.parse() is unsupported on this platform."); }   String get mimeType {}   String get primaryType {}   String get subType {}   String get charset {} } class _Cookie implements Cookie { String name  String value  DateTime expires  int maxAge  String domain  String path  bool httpOnly  bool secure  _Cookie([String name, String value]) { throw new UnsupportedError("new _Cookie() is unsupported on this platform."); }   _Cookie.fromSetCookieValue(String value) { throw new UnsupportedError("new _Cookie.fromSetCookieValue() is unsupported on this platform."); }    String toString() {}  }  const _OUTGOING_BUFFER_SIZE = 8 * 1024;  class _HttpIncoming extends Stream<List<int>> {       bool fullBodyRead  final _HttpHeaders headers = null;   bool upgraded  int statusCode  String reasonPhrase  String method  Uri uri  bool hasSubscriber  int get transferLength {}   _HttpIncoming(_HttpHeaders headers, int _transferLength, Stream<List<int>> _stream) { throw new UnsupportedError("new _HttpIncoming() is unsupported on this platform."); }   StreamSubscription<List<int>> listen(void onData(List<int> event), {Function onError, void onDone(), bool cancelOnError}) {}   Future get dataDone {}   void close(bool closing) {} } abstract class _HttpInboundMessage extends Stream<List<int>> {     _HttpInboundMessage(_HttpIncoming _incoming) { throw new UnsupportedError("new _HttpInboundMessage() is unsupported on this platform."); }   List<Cookie> get cookies {}   _HttpHeaders get headers {}   String get protocolVersion {}   int get contentLength {}   bool get persistentConnection {} } class _HttpRequest extends _HttpInboundMessage implements HttpRequest { final HttpResponse response = null;           _HttpRequest(HttpResponse response, _HttpIncoming _incoming, _HttpServer _httpServer, _HttpConnection _httpConnection) : super(throw new UnsupportedError("new _HttpRequest() is unsupported on this platform.")) { throw new UnsupportedError("new _HttpRequest() is unsupported on this platform."); }   StreamSubscription<List<int>> listen(void onData(List<int> event), {Function onError, void onDone(), bool cancelOnError}) {}   Uri get uri {}   Uri get requestedUri {}   String get method {}   HttpSession get session {}   HttpConnectionInfo get connectionInfo {}   X509Certificate get certificate {} } class _HttpClientResponse extends _HttpInboundMessage implements HttpClientResponse { List<RedirectInfo> get redirects {}         _HttpClientResponse(_HttpIncoming _incoming, _HttpClientRequest _httpRequest, _HttpClient _httpClient) : super(throw new UnsupportedError("new _HttpClientResponse() is unsupported on this platform.")) { throw new UnsupportedError("new _HttpClientResponse() is unsupported on this platform."); }   int get statusCode {}   String get reasonPhrase {}   X509Certificate get certificate {}   List<Cookie> get cookies {}   bool get isRedirect {}   Future<HttpClientResponse> redirect([String method, Uri url, bool followLoops]) {}   StreamSubscription<List<int>> listen(void onData(List<int> event), {Function onError, void onDone(), bool cancelOnError}) {}   Future<Socket> detachSocket() {}   HttpConnectionInfo get connectionInfo {}    } abstract class _HttpOutboundMessage<T> extends _IOSinkImpl {         final _HttpHeaders headers = null;   _HttpOutboundMessage(Uri uri, String protocolVersion, _HttpOutgoing outgoing, {_HttpHeaders initialHeaders}) : super(throw new UnsupportedError("new _HttpOutboundMessage() is unsupported on this platform."), null) { throw new UnsupportedError("new _HttpOutboundMessage() is unsupported on this platform."); }   int get contentLength {}   void set contentLength(int contentLength) {}   bool get persistentConnection {}   void set persistentConnection(bool p) {}   bool get bufferOutput {}   void set bufferOutput(bool bufferOutput) {}   Encoding get encoding {}   void add(List<int> data) {}   void write(Object obj) {}   } class _HttpResponse extends _HttpOutboundMessage<HttpResponse> implements HttpResponse {             _HttpResponse(Uri uri, String protocolVersion, _HttpOutgoing outgoing, HttpHeaders defaultHeaders, String serverHeader) : super(throw new UnsupportedError("new _HttpResponse() is unsupported on this platform."), null, null) { throw new UnsupportedError("new _HttpResponse() is unsupported on this platform."); }    List<Cookie> get cookies {}   int get statusCode {}   void set statusCode(int statusCode) {}   String get reasonPhrase {}   void set reasonPhrase(String reasonPhrase) {}   Future redirect(Uri location, {int status : HttpStatus.MOVED_TEMPORARILY}) {}   Future<Socket> detachSocket({bool writeHeaders : true}) {}   HttpConnectionInfo get connectionInfo {}   Duration get deadline {}   void set deadline(Duration d) {}   } class _HttpClientRequest extends _HttpOutboundMessage<HttpClientResponse> implements HttpClientRequest { final String method = null;   final Uri uri = null;   final List<Cookie> cookies = null;                   _HttpClientRequest(_HttpOutgoing outgoing, Uri uri, String method, _Proxy _proxy, _HttpClient _httpClient, _HttpClientConnection _httpClientConnection) : super(throw new UnsupportedError("new _HttpClientRequest() is unsupported on this platform."), null, null) { throw new UnsupportedError("new _HttpClientRequest() is unsupported on this platform."); }   Future<HttpClientResponse> get done {}   Future<HttpClientResponse> close() {}   int get maxRedirects {}   void set maxRedirects(int maxRedirects) {}   bool get followRedirects {}   void set followRedirects(bool followRedirects) {}   HttpConnectionInfo get connectionInfo {}     } class _HttpGZipSink extends ByteConversionSink {   _HttpGZipSink(Function _consume) { throw new UnsupportedError("new _HttpGZipSink() is unsupported on this platform."); }   void add(List<int> chunk) {}   void addSlice(Uint8List chunk, int start, int end, bool isLast) {}   void close() {} } class _HttpOutgoing implements StreamConsumer<List<int>> { static const _footerAndChunk0Length = const [_CharCode.CR, _CharCode.LF, 0x30, _CharCode.CR, _CharCode.LF, _CharCode.CR, _CharCode.LF];   static const _chunk0Length = const [0x30, _CharCode.CR, _CharCode.LF, _CharCode.CR, _CharCode.LF];     final Socket socket = null;   bool ignoreBody  bool headersWritten        bool chunked    int contentLength                _HttpOutboundMessage outbound  _HttpOutgoing(Socket socket) { throw new UnsupportedError("new _HttpOutgoing() is unsupported on this platform."); }   Future writeHeaders({bool drainRequest : true, bool setOutgoing : true}) {}   Future addStream(Stream<List<int>> stream) {}   Future close() {}   Future get done {}   void setHeader(List<int> data, int length) {}   void set gzip(bool value) {}     } class _HttpClientConnection { final String key = null;                 bool closed        _HttpClientConnection(String key, Socket _socket, _HttpClient _httpClient, [bool _proxyTunnel = false]) { throw new UnsupportedError("new _HttpClientConnection() is unsupported on this platform."); }   _HttpClientRequest send(Uri uri, int port, String method, _Proxy proxy) {}   Future<Socket> detachSocket() {}   void destroy() {}   void close() {}   Future<_HttpClientConnection> createProxyTunnel(host, port, proxy, callback) {}   HttpConnectionInfo get connectionInfo {}   static makeKey(bool isSecure, String host, int port) { throw new UnsupportedError("_HttpClientConnection.makeKey() is unsupported on this platform."); }   void stopTimer() {}   void startTimer() {} } class _ConnectionInfo { final _HttpClientConnection connection = null;   final _Proxy proxy = null;   _ConnectionInfo(_HttpClientConnection connection, _Proxy proxy) { throw new UnsupportedError("new _ConnectionInfo() is unsupported on this platform."); } } class _ConnectionTarget { final String key = null;   final String host = null;   final int port = null;   final bool isSecure = null;           _ConnectionTarget(String key, String host, int port, bool isSecure) { throw new UnsupportedError("new _ConnectionTarget() is unsupported on this platform."); }   bool get isEmpty {}   bool get hasIdle {}   bool get hasActive {}   _HttpClientConnection takeIdle() {}    void addNewActive(_HttpClientConnection connection) {}   void returnConnection(_HttpClientConnection connection) {}   void connectionClosed(_HttpClientConnection connection) {}   void close(bool force) {}   Future<_ConnectionInfo> connect(String uriHost, int uriPort, _Proxy proxy, _HttpClient client) {} } class _HttpClient implements HttpClient {                     Duration get idleTimeout { throw new UnsupportedError("_HttpClient.idleTimeout is unsupported on this platform."); }   int get maxConnectionsPerHost => throw new UnsupportedError("_HttpClient.maxConnectionsPerHost is unsupported on this platform."); set maxConnectionsPerHost(int _) { throw new UnsupportedError("_HttpClient.maxConnectionsPerHost= is unsupported on this platform."); }   bool get autoUncompress => throw new UnsupportedError("_HttpClient.autoUncompress is unsupported on this platform."); set autoUncompress(bool _) { throw new UnsupportedError("_HttpClient.autoUncompress= is unsupported on this platform."); }   String get userAgent => throw new UnsupportedError("_HttpClient.userAgent is unsupported on this platform."); set userAgent(String _) { throw new UnsupportedError("_HttpClient.userAgent= is unsupported on this platform."); }   void set idleTimeout(Duration timeout) { throw new UnsupportedError("_HttpClient.idleTimeout= is unsupported on this platform."); }   set badCertificateCallback(bool callback(X509Certificate cert, String host, int port)) { throw new UnsupportedError("_HttpClient.badCertificateCallback= is unsupported on this platform."); }   Future<HttpClientRequest> open(String method, String host, int port, String path) { throw new UnsupportedError("_HttpClient.open() is unsupported on this platform."); }   Future<HttpClientRequest> openUrl(String method, Uri url) { throw new UnsupportedError("_HttpClient.openUrl() is unsupported on this platform."); }   Future<HttpClientRequest> get(String host, int port, String path) { throw new UnsupportedError("_HttpClient.get() is unsupported on this platform."); }   Future<HttpClientRequest> getUrl(Uri url) { throw new UnsupportedError("_HttpClient.getUrl() is unsupported on this platform."); }   Future<HttpClientRequest> post(String host, int port, String path) { throw new UnsupportedError("_HttpClient.post() is unsupported on this platform."); }   Future<HttpClientRequest> postUrl(Uri url) { throw new UnsupportedError("_HttpClient.postUrl() is unsupported on this platform."); }   Future<HttpClientRequest> put(String host, int port, String path) { throw new UnsupportedError("_HttpClient.put() is unsupported on this platform."); }   Future<HttpClientRequest> putUrl(Uri url) { throw new UnsupportedError("_HttpClient.putUrl() is unsupported on this platform."); }   Future<HttpClientRequest> delete(String host, int port, String path) { throw new UnsupportedError("_HttpClient.delete() is unsupported on this platform."); }   Future<HttpClientRequest> deleteUrl(Uri url) { throw new UnsupportedError("_HttpClient.deleteUrl() is unsupported on this platform."); }   Future<HttpClientRequest> head(String host, int port, String path) { throw new UnsupportedError("_HttpClient.head() is unsupported on this platform."); }   Future<HttpClientRequest> headUrl(Uri url) { throw new UnsupportedError("_HttpClient.headUrl() is unsupported on this platform."); }   Future<HttpClientRequest> patch(String host, int port, String path) { throw new UnsupportedError("_HttpClient.patch() is unsupported on this platform."); }   Future<HttpClientRequest> patchUrl(Uri url) { throw new UnsupportedError("_HttpClient.patchUrl() is unsupported on this platform."); }   void close({bool force : false}) { throw new UnsupportedError("_HttpClient.close() is unsupported on this platform."); }   set authenticate(Future<bool> f(Uri url, String scheme, String realm)) { throw new UnsupportedError("_HttpClient.authenticate= is unsupported on this platform."); }   void addCredentials(Uri url, String realm, HttpClientCredentials cr) { throw new UnsupportedError("_HttpClient.addCredentials() is unsupported on this platform."); }   set authenticateProxy(Future<bool> f(String host, int port, String scheme, String realm)) { throw new UnsupportedError("_HttpClient.authenticateProxy= is unsupported on this platform."); }   void addProxyCredentials(String host, int port, String realm, HttpClientCredentials cr) { throw new UnsupportedError("_HttpClient.addProxyCredentials() is unsupported on this platform."); }   set findProxy(String f(Uri uri)) { throw new UnsupportedError("_HttpClient.findProxy= is unsupported on this platform."); }               static String _findProxyFromEnvironment(Uri url, Map<String, String> environment) { throw new UnsupportedError("_HttpClient._findProxyFromEnvironment() is unsupported on this platform."); }   } class _HttpConnection extends LinkedListEntry<_HttpConnection> with _ServiceObject { static const _ACTIVE = 0;   static const _IDLE = 1;   static const _CLOSING = 2;   static const _DETACHED = 3;                   _HttpConnection(_socket, _HttpServer _httpServer) { throw new UnsupportedError("new _HttpConnection() is unsupported on this platform."); }   void markIdle() {}   bool get isMarkedIdle {}   void destroy() {}   Future<Socket> detachSocket() {}   HttpConnectionInfo get connectionInfo {}        } class _HttpServer extends Stream<HttpRequest> with _ServiceObject implements HttpServer {   String serverHeader  final HttpHeaders defaultResponseHeaders = null;   bool autoCompress      static Future<HttpServer> bind(address, int port, int backlog) { throw new UnsupportedError("_HttpServer.bind() is unsupported on this platform."); }   static Future<HttpServer> bindSecure(address, int port, int backlog, String certificate_name, bool requestClientCertificate) { throw new UnsupportedError("_HttpServer.bindSecure() is unsupported on this platform."); }   _HttpServer._(_serverSocket, bool _closeServer) { throw new UnsupportedError("new _HttpServer._() is unsupported on this platform."); }   _HttpServer.listenOn(_serverSocket) { throw new UnsupportedError("new _HttpServer.listenOn() is unsupported on this platform."); }   static HttpHeaders _initDefaultResponseHeaders() { throw new UnsupportedError("_HttpServer._initDefaultResponseHeaders() is unsupported on this platform."); }   Duration get idleTimeout {}   void set idleTimeout(Duration duration) {}   StreamSubscription<HttpRequest> listen(void onData(HttpRequest event), {Function onError, void onDone(), bool cancelOnError}) {}   Future close({bool force : false}) {}    int get port {}   InternetAddress get address {}   set sessionTimeout(int timeout) {}         HttpConnectionsInfo connectionsInfo() {}        bool closed          } class _ProxyConfiguration { static const PROXY_PREFIX = "PROXY ";   static const DIRECT_PREFIX = "DIRECT";   _ProxyConfiguration(String configuration) { throw new UnsupportedError("new _ProxyConfiguration() is unsupported on this platform."); }   const _ProxyConfiguration.direct();   List<_Proxy> get proxies => throw new UnsupportedError("_ProxyConfiguration.proxies is unsupported on this platform."); } class _Proxy { String get host => throw new UnsupportedError("_Proxy.host is unsupported on this platform.");   int get port => throw new UnsupportedError("_Proxy.port is unsupported on this platform.");   String get username => throw new UnsupportedError("_Proxy.username is unsupported on this platform.");   String get password => throw new UnsupportedError("_Proxy.password is unsupported on this platform.");   bool get isDirect => throw new UnsupportedError("_Proxy.isDirect is unsupported on this platform.");   const _Proxy(String host, int port, String username, String password);   const _Proxy.direct();   bool get isAuthenticated { throw new UnsupportedError("_Proxy.isAuthenticated is unsupported on this platform."); } } class _HttpConnectionInfo implements HttpConnectionInfo { InternetAddress get remoteAddress => throw new UnsupportedError("_HttpConnectionInfo.remoteAddress is unsupported on this platform."); set remoteAddress(InternetAddress _) { throw new UnsupportedError("_HttpConnectionInfo.remoteAddress= is unsupported on this platform."); }   int get remotePort => throw new UnsupportedError("_HttpConnectionInfo.remotePort is unsupported on this platform."); set remotePort(int _) { throw new UnsupportedError("_HttpConnectionInfo.remotePort= is unsupported on this platform."); }   int get localPort => throw new UnsupportedError("_HttpConnectionInfo.localPort is unsupported on this platform."); set localPort(int _) { throw new UnsupportedError("_HttpConnectionInfo.localPort= is unsupported on this platform."); }   static _HttpConnectionInfo create(Socket socket) { throw new UnsupportedError("_HttpConnectionInfo.create() is unsupported on this platform."); } } class _DetachedSocket extends Stream<List<int>> implements Socket {     _DetachedSocket(_socket, Stream<List<int>> _incoming) { throw new UnsupportedError("new _DetachedSocket() is unsupported on this platform."); }   StreamSubscription<List<int>> listen(void onData(List<int> event), {Function onError, void onDone(), bool cancelOnError}) {}   Encoding get encoding {}   void set encoding(Encoding value) {}   void write(Object obj) {}   void writeln([Object obj = ""]) {}   void writeCharCode(int charCode) {}   void writeAll(Iterable objects, [String separator = ""]) {}   void add(List<int> bytes) {}   void addError(error, [StackTrace stackTrace]) {}   Future<Socket> addStream(Stream<List<int>> stream) {}   void destroy() {}   Future flush() {}   Future close() {}   Future<Socket> get done {}   int get port {}   InternetAddress get address {}   InternetAddress get remoteAddress {}   int get remotePort {}   bool setOption(SocketOption option, bool enabled) {}   } class _AuthenticationScheme {   static const UNKNOWN = const _AuthenticationScheme(-1);   static const BASIC = const _AuthenticationScheme(0);   static const DIGEST = const _AuthenticationScheme(1);   const _AuthenticationScheme(int _scheme);   factory _AuthenticationScheme.fromString(String scheme) { throw new UnsupportedError("new _AuthenticationScheme.fromString() is unsupported on this platform."); }   String toString() { throw new UnsupportedError("_AuthenticationScheme.toString() is unsupported on this platform."); } } abstract class _Credentials { _HttpClientCredentials credentials  String realm  bool used  String ha1  String nonce  String algorithm  String qop  int nonceCount  _Credentials(_HttpClientCredentials credentials, String realm) { throw new UnsupportedError("new _Credentials() is unsupported on this platform."); }   _AuthenticationScheme get scheme {}   void authorize(HttpClientRequest request); } class _SiteCredentials extends _Credentials { Uri uri  _SiteCredentials(Uri uri, realm, _HttpClientCredentials creds) : super(throw new UnsupportedError("new _SiteCredentials() is unsupported on this platform."), null) { throw new UnsupportedError("new _SiteCredentials() is unsupported on this platform."); }   bool applies(Uri uri, _AuthenticationScheme scheme) {}   void authorize(HttpClientRequest request) {} } class _ProxyCredentials extends _Credentials { String host  int port  _ProxyCredentials(String host, int port, realm, _HttpClientCredentials creds) : super(throw new UnsupportedError("new _ProxyCredentials() is unsupported on this platform."), null) { throw new UnsupportedError("new _ProxyCredentials() is unsupported on this platform."); }   bool applies(_Proxy proxy, _AuthenticationScheme scheme) {}   void authorize(HttpClientRequest request) {} } abstract class _HttpClientCredentials implements HttpClientCredentials { _AuthenticationScheme get scheme;   void authorize(_Credentials credentials, HttpClientRequest request);   void authorizeProxy(_ProxyCredentials credentials, HttpClientRequest request); } class _HttpClientBasicCredentials extends _HttpClientCredentials implements HttpClientBasicCredentials { String username  String password  _HttpClientBasicCredentials(String username, String password) { throw new UnsupportedError("new _HttpClientBasicCredentials() is unsupported on this platform."); }   _AuthenticationScheme get scheme {}   String authorization() {}   void authorize(_Credentials _, HttpClientRequest request) {}   void authorizeProxy(_ProxyCredentials _, HttpClientRequest request) {} } class _HttpClientDigestCredentials extends _HttpClientCredentials implements HttpClientDigestCredentials { String username  String password  _HttpClientDigestCredentials(String username, String password) { throw new UnsupportedError("new _HttpClientDigestCredentials() is unsupported on this platform."); }   _AuthenticationScheme get scheme {}   String authorization(_Credentials credentials, _HttpClientRequest request) {}   void authorize(_Credentials credentials, HttpClientRequest request) {}   void authorizeProxy(_ProxyCredentials credentials, HttpClientRequest request) {} } class _RedirectInfo implements RedirectInfo { int get statusCode => throw new UnsupportedError("_RedirectInfo.statusCode is unsupported on this platform.");   String get method => throw new UnsupportedError("_RedirectInfo.method is unsupported on this platform.");   Uri get location => throw new UnsupportedError("_RedirectInfo.location is unsupported on this platform.");   const _RedirectInfo(int statusCode, String method, Uri location); } String _getHttpVersion() { throw new UnsupportedError("_getHttpVersion() is unsupported on this platform."); }   class _Const { static const HTTP = const [72, 84, 84, 80];   static const HTTP1DOT = const [72, 84, 84, 80, 47, 49, 46];   static const HTTP10 = const [72, 84, 84, 80, 47, 49, 46, 48];   static const HTTP11 = const [72, 84, 84, 80, 47, 49, 46, 49];   static const T = true;   static const F = false;   static const SEPARATOR_MAP = const [F, F, F, F, F, F, F, F, F, T, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, T, F, T, F, F, F, F, F, T, T, F, F, T, F, F, T, F, F, F, F, F, F, F, F, F, F, T, T, T, T, T, T, T, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, T, T, T, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, T, F, T, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F]; } class _CharCode { static const HT = 9;   static const LF = 10;   static const CR = 13;   static const SP = 32;   static const AMPERSAND = 38;   static const COMMA = 44;   static const DASH = 45;   static const SLASH = 47;   static const ZERO = 48;   static const ONE = 49;   static const COLON = 58;   static const SEMI_COLON = 59;   static const EQUAL = 61; } class _State { static const START = 0;   static const METHOD_OR_RESPONSE_HTTP_VERSION = 1;   static const RESPONSE_HTTP_VERSION = 2;   static const REQUEST_LINE_METHOD = 3;   static const REQUEST_LINE_URI = 4;   static const REQUEST_LINE_HTTP_VERSION = 5;   static const REQUEST_LINE_ENDING = 6;   static const RESPONSE_LINE_STATUS_CODE = 7;   static const RESPONSE_LINE_REASON_PHRASE = 8;   static const RESPONSE_LINE_ENDING = 9;   static const HEADER_START = 10;   static const HEADER_FIELD = 11;   static const HEADER_VALUE_START = 12;   static const HEADER_VALUE = 13;   static const HEADER_VALUE_FOLDING_OR_ENDING = 14;   static const HEADER_VALUE_FOLD_OR_END = 15;   static const HEADER_ENDING = 16;   static const CHUNK_SIZE_STARTING_CR = 17;   static const CHUNK_SIZE_STARTING_LF = 18;   static const CHUNK_SIZE = 19;   static const CHUNK_SIZE_EXTENSION = 20;   static const CHUNK_SIZE_ENDING = 21;   static const CHUNKED_BODY_DONE_CR = 22;   static const CHUNKED_BODY_DONE_LF = 23;   static const BODY = 24;   static const CLOSED = 25;   static const UPGRADED = 26;   static const FAILURE = 27;   static const FIRST_BODY_STATE = CHUNK_SIZE_STARTING_CR; } class _HttpVersion { static const UNDETERMINED = 0;   static const HTTP10 = 1;   static const HTTP11 = 2; } class _MessageType { static const UNDETERMINED = 0;   static const REQUEST = 1;   static const RESPONSE = 0; } class _HttpDetachedStreamSubscription implements StreamSubscription<List<int>> {             _HttpDetachedStreamSubscription(StreamSubscription<List<int>> _subscription, List<int> _injectData, Function _userOnData) { throw new UnsupportedError("new _HttpDetachedStreamSubscription() is unsupported on this platform."); }   bool get isPaused {}   Future asFuture([futureValue]) {}   Future cancel() {}   void onData(void handleData(List<int> data)) {}   void onDone(void handleDone()) {}   void onError(Function handleError) {}   void pause([Future resumeSignal]) {}   void resume() {}  } class _HttpDetachedIncoming extends Stream<List<int>> { final StreamSubscription subscription = null;   final List<int> bufferedData = null;   _HttpDetachedIncoming(StreamSubscription subscription, List<int> bufferedData) { throw new UnsupportedError("new _HttpDetachedIncoming() is unsupported on this platform."); }   StreamSubscription<List<int>> listen(void onData(List<int> event), {Function onError, void onDone(), bool cancelOnError}) {} } class _HttpParser extends Stream<_HttpIncoming> {                                                       factory _HttpParser.requestParser() { throw new UnsupportedError("new _HttpParser.requestParser() is unsupported on this platform."); }   factory _HttpParser.responseParser() { throw new UnsupportedError("new _HttpParser.responseParser() is unsupported on this platform."); }   _HttpParser._(bool _requestParser) { throw new UnsupportedError("new _HttpParser._() is unsupported on this platform."); }   StreamSubscription<_HttpIncoming> listen(void onData(_HttpIncoming event), {Function onError, void onDone(), bool cancelOnError}) {}   void listenToStream(Stream<List<int>> stream) {}        String get version {}   int get messageType {}   int get transferLength {}   bool get upgrade {}   bool get persistentConnection {}   void set isHead(bool value) {}   _HttpDetachedIncoming detachIncoming() {}   List<int> readUnparsedData() {}     static bool _isTokenChar(int byte) { throw new UnsupportedError("_HttpParser._isTokenChar() is unsupported on this platform."); }   static bool _isValueChar(int byte) { throw new UnsupportedError("_HttpParser._isValueChar() is unsupported on this platform."); }   static List<String> _tokenizeFieldValue(String headerValue) { throw new UnsupportedError("_HttpParser._tokenizeFieldValue() is unsupported on this platform."); }   static int _toLowerCaseByte(int x) { throw new UnsupportedError("_HttpParser._toLowerCaseByte() is unsupported on this platform."); }        }  const _DART_SESSION_ID = "DARTSESSID";  class _HttpSession implements HttpSession {               final String id = null;     _HttpSession(_HttpSessionManager _sessionManager, String id) { throw new UnsupportedError("new _HttpSession() is unsupported on this platform."); }   void destroy() {}    DateTime get lastSeen {}   bool get isNew {}   void set onTimeout(void callback()) {}   bool containsValue(value) {}   bool containsKey(key) {}   operator [](key) {}   void operator []=(key, value) {}   putIfAbsent(key, ifAbsent) {}   addAll(Map other) {}   remove(key) {}   void clear() {}   void forEach(void f(key, value)) {}   Iterable get keys {}   Iterable get values {}   int get length {}   bool get isEmpty {}   bool get isNotEmpty {}   String toString() {} } class _HttpSessionManager {           _HttpSessionManager() { throw new UnsupportedError("new _HttpSessionManager() is unsupported on this platform."); }   String createSessionId() {}   _HttpSession getSession(String id) {}   _HttpSession createSession() {}   void set sessionTimeout(int timeout) {}   void close() {}       }  abstract class IOSink implements StreamSink<List<int>>, StringSink { factory IOSink(StreamConsumer<List<int>> target, {Encoding encoding : UTF8}) { throw new UnsupportedError("new IOSink() is unsupported on this platform."); }   Encoding encoding  void add(List<int> data);   void write(Object obj);   void writeAll(Iterable objects, [String separator = ""]);   void writeln([Object obj = ""]);   void writeCharCode(int charCode);   void addError(error, [StackTrace stackTrace]);   Future addStream(Stream<List<int>> stream);   Future flush();   Future close();   Future get done; } class _StreamSinkImpl<T> implements StreamSink<T> {                 _StreamSinkImpl(StreamConsumer<T> _target) { throw new UnsupportedError("new _StreamSinkImpl() is unsupported on this platform."); }   void add(T data) {}   void addError(error, [StackTrace stackTrace]) {}   Future addStream(Stream<T> stream) {}   Future flush() {}   Future close() {}    Future get done {}   } class _IOSinkImpl extends _StreamSinkImpl<List<int>> implements IOSink {     _IOSinkImpl(StreamConsumer<List<int>> target, Encoding _encoding) : super(throw new UnsupportedError("new _IOSinkImpl() is unsupported on this platform.")) { throw new UnsupportedError("new _IOSinkImpl() is unsupported on this platform."); }   Encoding get encoding {}   void set encoding(Encoding value) {}   void write(Object obj) {}   void writeAll(Iterable objects, [String separator = ""]) {}   void writeln([Object obj = ""]) {}   void writeCharCode(int charCode) {} }  const _FILE_EXISTS = 0;  const _FILE_CREATE = 1;  const _FILE_DELETE = 2;  const _FILE_RENAME = 3;  const _FILE_COPY = 4;  const _FILE_OPEN = 5;  const _FILE_RESOLVE_SYMBOLIC_LINKS = 6;  const _FILE_CLOSE = 7;  const _FILE_POSITION = 8;  const _FILE_SET_POSITION = 9;  const _FILE_TRUNCATE = 10;  const _FILE_LENGTH = 11;  const _FILE_LENGTH_FROM_PATH = 12;  const _FILE_LAST_MODIFIED = 13;  const _FILE_FLUSH = 14;  const _FILE_READ_BYTE = 15;  const _FILE_WRITE_BYTE = 16;  const _FILE_READ = 17;  const _FILE_READ_INTO = 18;  const _FILE_WRITE_FROM = 19;  const _FILE_CREATE_LINK = 20;  const _FILE_DELETE_LINK = 21;  const _FILE_RENAME_LINK = 22;  const _FILE_LINK_TARGET = 23;  const _FILE_TYPE = 24;  const _FILE_IDENTICAL = 25;  const _FILE_STAT = 26;  const _FILE_LOCK = 27;  const _SOCKET_LOOKUP = 28;  const _SOCKET_LIST_INTERFACES = 29;  const _SOCKET_REVERSE_LOOKUP = 30;  const _DIRECTORY_CREATE = 31;  const _DIRECTORY_DELETE = 32;  const _DIRECTORY_EXISTS = 33;  const _DIRECTORY_CREATE_TEMP = 34;  const _DIRECTORY_LIST_START = 35;  const _DIRECTORY_LIST_NEXT = 36;  const _DIRECTORY_LIST_STOP = 37;  const _DIRECTORY_RENAME = 38;  const _SSL_PROCESS_FILTER = 39;  class _IOService { static Future dispatch(int request, List data) { throw new UnsupportedError("_IOService.dispatch() is unsupported on this platform."); } }  abstract class Link extends FileSystemEntity { factory Link(String path) { throw new UnsupportedError("new Link() is unsupported on this platform."); }   factory Link.fromUri(Uri uri) { throw new UnsupportedError("new Link.fromUri() is unsupported on this platform."); }   Future<Link> create(String target, {bool recursive : false});   void createSync(String target, {bool recursive : false});   void updateSync(String target);   Future<Link> update(String target);   Future<String> resolveSymbolicLinks();   String resolveSymbolicLinksSync();   Future<Link> rename(String newPath);   Link renameSync(String newPath);   Link get absolute;   Future<String> target();   String targetSync(); } class _Link extends FileSystemEntity implements Link { final String path = null;   _Link(String path) { throw new UnsupportedError("new _Link() is unsupported on this platform."); }   String toString() {}   Future<bool> exists() {}   bool existsSync() {}   Link get absolute {}   Future<FileStat> stat() {}   FileStat statSync() {}   Future<Link> create(String target, {bool recursive : false}) {}   void createSync(String target, {bool recursive : false}) {}    void updateSync(String target) {}   Future<Link> update(String target) {}     Future<Link> rename(String newPath) {}   Link renameSync(String newPath) {}   Future<String> target() {}   String targetSync() {}   static throwIfError(Object result, String msg, [String path = ""]) { throw new UnsupportedError("_Link.throwIfError() is unsupported on this platform."); }   }  class Platform {           static int get numberOfProcessors { throw new UnsupportedError("Platform.numberOfProcessors is unsupported on this platform."); }   static String get pathSeparator { throw new UnsupportedError("Platform.pathSeparator is unsupported on this platform."); }   static String get operatingSystem { throw new UnsupportedError("Platform.operatingSystem is unsupported on this platform."); }   static String get localHostname { throw new UnsupportedError("Platform.localHostname is unsupported on this platform."); }   static bool get isLinux => throw new UnsupportedError("Platform.isLinux is unsupported on this platform.");   static bool get isMacOS => throw new UnsupportedError("Platform.isMacOS is unsupported on this platform.");   static bool get isWindows => throw new UnsupportedError("Platform.isWindows is unsupported on this platform.");   static bool get isAndroid => throw new UnsupportedError("Platform.isAndroid is unsupported on this platform.");   static Map<String, String> get environment { throw new UnsupportedError("Platform.environment is unsupported on this platform."); }   static String get executable { throw new UnsupportedError("Platform.executable is unsupported on this platform."); }   static Uri get script { throw new UnsupportedError("Platform.script is unsupported on this platform."); }   static List<String> get executableArguments { throw new UnsupportedError("Platform.executableArguments is unsupported on this platform."); }   static String get packageRoot { throw new UnsupportedError("Platform.packageRoot is unsupported on this platform."); }   static String get version { throw new UnsupportedError("Platform.version is unsupported on this platform."); } }  class _Platform { static int _numberOfProcessors() { throw new UnsupportedError("_Platform._numberOfProcessors() is unsupported on this platform."); }   static String _pathSeparator() { throw new UnsupportedError("_Platform._pathSeparator() is unsupported on this platform."); }   static String _operatingSystem() { throw new UnsupportedError("_Platform._operatingSystem() is unsupported on this platform."); }   static _localHostname() { throw new UnsupportedError("_Platform._localHostname() is unsupported on this platform."); }   static _executable() { throw new UnsupportedError("_Platform._executable() is unsupported on this platform."); }   static _environment() { throw new UnsupportedError("_Platform._environment() is unsupported on this platform."); }   static List<String> _executableArguments() { throw new UnsupportedError("_Platform._executableArguments() is unsupported on this platform."); }   static String _packageRoot() { throw new UnsupportedError("_Platform._packageRoot() is unsupported on this platform."); }   static String _version() { throw new UnsupportedError("_Platform._version() is unsupported on this platform."); }   static String get executable => throw new UnsupportedError("_Platform.executable is unsupported on this platform."); static set executable(String _) { throw new UnsupportedError("_Platform.executable= is unsupported on this platform."); }   static String get packageRoot => throw new UnsupportedError("_Platform.packageRoot is unsupported on this platform."); static set packageRoot(String _) { throw new UnsupportedError("_Platform.packageRoot= is unsupported on this platform."); }     static int get numberOfProcessors { throw new UnsupportedError("_Platform.numberOfProcessors is unsupported on this platform."); }   static String get pathSeparator { throw new UnsupportedError("_Platform.pathSeparator is unsupported on this platform."); }   static String get operatingSystem { throw new UnsupportedError("_Platform.operatingSystem is unsupported on this platform."); }   static Uri get script => throw new UnsupportedError("_Platform.script is unsupported on this platform."); static set script(Uri _) { throw new UnsupportedError("_Platform.script= is unsupported on this platform."); }   static void set _nativeScript(String path) { throw new UnsupportedError("_Platform._nativeScript= is unsupported on this platform."); }   static String get localHostname { throw new UnsupportedError("_Platform.localHostname is unsupported on this platform."); }   static List<String> get executableArguments { throw new UnsupportedError("_Platform.executableArguments is unsupported on this platform."); }   static Map<String, String> get environment { throw new UnsupportedError("_Platform.environment is unsupported on this platform."); }   static String get version { throw new UnsupportedError("_Platform.version is unsupported on this platform."); } } class _CaseInsensitiveStringMap<V> implements Map<String, V> {   bool containsKey(String key) { throw new UnsupportedError("_CaseInsensitiveStringMap.containsKey() is unsupported on this platform."); }   bool containsValue(Object value) { throw new UnsupportedError("_CaseInsensitiveStringMap.containsValue() is unsupported on this platform."); }   V operator [](String key) { throw new UnsupportedError("_CaseInsensitiveStringMap.[] is unsupported on this platform."); }   void operator []=(String key, V value) { throw new UnsupportedError("_CaseInsensitiveStringMap.[]= is unsupported on this platform."); }   V putIfAbsent(String key, V ifAbsent()) { throw new UnsupportedError("_CaseInsensitiveStringMap.putIfAbsent() is unsupported on this platform."); }   addAll(Map other) { throw new UnsupportedError("_CaseInsensitiveStringMap.addAll() is unsupported on this platform."); }   V remove(String key) { throw new UnsupportedError("_CaseInsensitiveStringMap.remove() is unsupported on this platform."); }   void clear() { throw new UnsupportedError("_CaseInsensitiveStringMap.clear() is unsupported on this platform."); }   void forEach(void f(String key, V value)) { throw new UnsupportedError("_CaseInsensitiveStringMap.forEach() is unsupported on this platform."); }   Iterable<String> get keys { throw new UnsupportedError("_CaseInsensitiveStringMap.keys is unsupported on this platform."); }   Iterable<V> get values { throw new UnsupportedError("_CaseInsensitiveStringMap.values is unsupported on this platform."); }   int get length { throw new UnsupportedError("_CaseInsensitiveStringMap.length is unsupported on this platform."); }   bool get isEmpty { throw new UnsupportedError("_CaseInsensitiveStringMap.isEmpty is unsupported on this platform."); }   bool get isNotEmpty { throw new UnsupportedError("_CaseInsensitiveStringMap.isNotEmpty is unsupported on this platform."); }   String toString() { throw new UnsupportedError("_CaseInsensitiveStringMap.toString() is unsupported on this platform."); } }  class _ProcessUtils { static void _exit(int status) { throw new UnsupportedError("_ProcessUtils._exit() is unsupported on this platform."); }   static void _setExitCode(int status) { throw new UnsupportedError("_ProcessUtils._setExitCode() is unsupported on this platform."); }   static int _getExitCode() { throw new UnsupportedError("_ProcessUtils._getExitCode() is unsupported on this platform."); }   static void _sleep(int millis) { throw new UnsupportedError("_ProcessUtils._sleep() is unsupported on this platform."); }   static int _pid(Process process) { throw new UnsupportedError("_ProcessUtils._pid() is unsupported on this platform."); }   static Stream<ProcessSignal> _watchSignal(ProcessSignal signal) { throw new UnsupportedError("_ProcessUtils._watchSignal() is unsupported on this platform."); } } void exit(int code) { throw new UnsupportedError("exit() is unsupported on this platform."); }  void set exitCode(int code) { throw new UnsupportedError("exitCode= is unsupported on this platform."); }  int get exitCode { throw new UnsupportedError("exitCode is unsupported on this platform."); }  void sleep(Duration duration) { throw new UnsupportedError("sleep() is unsupported on this platform."); }  int get pid { throw new UnsupportedError("pid is unsupported on this platform."); }  abstract class Process { Future<int> get exitCode => throw new UnsupportedError("Process.exitCode is unsupported on this platform."); set exitCode(Future<int> _) { throw new UnsupportedError("Process.exitCode= is unsupported on this platform."); }   static Future<Process> start(String executable, List<String> arguments, {String workingDirectory, Map<String, String> environment, bool includeParentEnvironment : true, bool runInShell : false}) { throw new UnsupportedError("Process.start() is unsupported on this platform."); }   static Future<ProcessResult> run(String executable, List<String> arguments, {String workingDirectory, Map<String, String> environment, bool includeParentEnvironment : true, bool runInShell : false, Encoding stdoutEncoding : SYSTEM_ENCODING, Encoding stderrEncoding : SYSTEM_ENCODING}) { throw new UnsupportedError("Process.run() is unsupported on this platform."); }   static ProcessResult runSync(String executable, List<String> arguments, {String workingDirectory, Map<String, String> environment, bool includeParentEnvironment : true, bool runInShell : false, Encoding stdoutEncoding : SYSTEM_ENCODING, Encoding stderrEncoding : SYSTEM_ENCODING}) { throw new UnsupportedError("Process.runSync() is unsupported on this platform."); }   Stream<List<int>> get stdout;   Stream<List<int>> get stderr;   IOSink get stdin;   int get pid;   bool kill([ProcessSignal signal = ProcessSignal.SIGTERM]); } abstract class ProcessResult { int get exitCode;   get stdout;   get stderr;   int get pid; } class ProcessSignal { static const SIGHUP = const ProcessSignal._(1, "SIGHUP");   static const SIGINT = const ProcessSignal._(2, "SIGINT");   static const SIGQUIT = const ProcessSignal._(3, "SIGQUIT");   static const SIGILL = const ProcessSignal._(4, "SIGILL");   static const SIGTRAP = const ProcessSignal._(5, "SIGTRAP");   static const SIGABRT = const ProcessSignal._(6, "SIGABRT");   static const SIGBUS = const ProcessSignal._(7, "SIGBUS");   static const SIGFPE = const ProcessSignal._(8, "SIGFPE");   static const SIGKILL = const ProcessSignal._(9, "SIGKILL");   static const SIGUSR1 = const ProcessSignal._(10, "SIGUSR1");   static const SIGSEGV = const ProcessSignal._(11, "SIGSEGV");   static const SIGUSR2 = const ProcessSignal._(12, "SIGUSR2");   static const SIGPIPE = const ProcessSignal._(13, "SIGPIPE");   static const SIGALRM = const ProcessSignal._(14, "SIGALRM");   static const SIGTERM = const ProcessSignal._(15, "SIGTERM");   static const SIGCHLD = const ProcessSignal._(17, "SIGCHLD");   static const SIGCONT = const ProcessSignal._(18, "SIGCONT");   static const SIGSTOP = const ProcessSignal._(19, "SIGSTOP");   static const SIGTSTP = const ProcessSignal._(20, "SIGTSTP");   static const SIGTTIN = const ProcessSignal._(21, "SIGTTIN");   static const SIGTTOU = const ProcessSignal._(22, "SIGTTOU");   static const SIGURG = const ProcessSignal._(23, "SIGURG");   static const SIGXCPU = const ProcessSignal._(24, "SIGXCPU");   static const SIGXFSZ = const ProcessSignal._(25, "SIGXFSZ");   static const SIGVTALRM = const ProcessSignal._(26, "SIGVTALRM");   static const SIGPROF = const ProcessSignal._(27, "SIGPROF");   static const SIGWINCH = const ProcessSignal._(28, "SIGWINCH");   static const SIGPOLL = const ProcessSignal._(29, "SIGPOLL");   static const SIGSYS = const ProcessSignal._(31, "SIGSYS");       const ProcessSignal._(int _signalNumber, String _name);   String toString() { throw new UnsupportedError("ProcessSignal.toString() is unsupported on this platform."); }   Stream<ProcessSignal> watch() { throw new UnsupportedError("ProcessSignal.watch() is unsupported on this platform."); } } class SignalException implements IOException { String get message => throw new UnsupportedError("SignalException.message is unsupported on this platform.");   get osError => throw new UnsupportedError("SignalException.osError is unsupported on this platform.");   const SignalException(String message, [osError = null]);   String toString() { throw new UnsupportedError("SignalException.toString() is unsupported on this platform."); } } class ProcessException implements IOException { String get executable => throw new UnsupportedError("ProcessException.executable is unsupported on this platform.");   List<String> get arguments => throw new UnsupportedError("ProcessException.arguments is unsupported on this platform.");   String get message => throw new UnsupportedError("ProcessException.message is unsupported on this platform.");   int get errorCode => throw new UnsupportedError("ProcessException.errorCode is unsupported on this platform.");   const ProcessException(String executable, List<String> arguments, [String message = "", int errorCode = 0]);   String toString() { throw new UnsupportedError("ProcessException.toString() is unsupported on this platform."); } }   abstract class _ServiceObject {       }  class InternetAddressType { static const IP_V4 = const InternetAddressType._(0);   static const IP_V6 = const InternetAddressType._(1);   static const ANY = const InternetAddressType._(-1);     const InternetAddressType._(int _value);   factory InternetAddressType._from(int value) { throw new UnsupportedError("new InternetAddressType._from() is unsupported on this platform."); }   String get name { throw new UnsupportedError("InternetAddressType.name is unsupported on this platform."); }   String toString() { throw new UnsupportedError("InternetAddressType.toString() is unsupported on this platform."); } } abstract class InternetAddress { static InternetAddress get LOOPBACK_IP_V4 { throw new UnsupportedError("InternetAddress.LOOPBACK_IP_V4 is unsupported on this platform."); }   static InternetAddress get LOOPBACK_IP_V6 { throw new UnsupportedError("InternetAddress.LOOPBACK_IP_V6 is unsupported on this platform."); }   static InternetAddress get ANY_IP_V4 { throw new UnsupportedError("InternetAddress.ANY_IP_V4 is unsupported on this platform."); }   static InternetAddress get ANY_IP_V6 { throw new UnsupportedError("InternetAddress.ANY_IP_V6 is unsupported on this platform."); }   InternetAddressType type  String get address;   String get host;   List<int> get rawAddress;   bool get isLoopback;   bool get isLinkLocal;   bool get isMulticast;   factory InternetAddress(String address) { throw new UnsupportedError("new InternetAddress() is unsupported on this platform."); }   Future<InternetAddress> reverse();   static Future<List<InternetAddress>> lookup(String host, {InternetAddressType type : InternetAddressType.ANY}) { throw new UnsupportedError("InternetAddress.lookup() is unsupported on this platform."); } } abstract class NetworkInterface { String get name;   String get index;   List<InternetAddress> get addresses;   static Future<List<NetworkInterface>> list({bool includeLoopback : false, bool includeLinkLocal : false, InternetAddressType type : InternetAddressType.ANY}) { throw new UnsupportedError("NetworkInterface.list() is unsupported on this platform."); } } abstract class RawServerSocket implements Stream<RawSocket> { static Future<RawServerSocket> bind(address, int port, {int backlog : 0, bool v6Only : false}) { throw new UnsupportedError("RawServerSocket.bind() is unsupported on this platform."); }   int get port;   InternetAddress get address;   Future<RawServerSocket> close();   RawServerSocketReference get reference; } abstract class RawServerSocketReference { Future<RawServerSocket> create(); } abstract class ServerSocket implements Stream<Socket> { static Future<ServerSocket> bind(address, int port, {int backlog : 0, bool v6Only : false}) { throw new UnsupportedError("ServerSocket.bind() is unsupported on this platform."); }   int get port;   InternetAddress get address;   Future<ServerSocket> close();   ServerSocketReference get reference; } abstract class ServerSocketReference { Future<ServerSocket> create(); } class SocketDirection { static const RECEIVE = const SocketDirection._(0);   static const SEND = const SocketDirection._(1);   static const BOTH = const SocketDirection._(2);     const SocketDirection._(_value); } class SocketOption { static const TCP_NODELAY = const SocketOption._(0);   static const _IP_MULTICAST_LOOP = const SocketOption._(1);   static const _IP_MULTICAST_HOPS = const SocketOption._(2);   static const _IP_MULTICAST_IF = const SocketOption._(3);   static const _IP_BROADCAST = const SocketOption._(4);     const SocketOption._(_value); } class RawSocketEvent { static const READ = const RawSocketEvent._(0);   static const WRITE = const RawSocketEvent._(1);   static const READ_CLOSED = const RawSocketEvent._(2);   static const CLOSED = const RawSocketEvent._(3);     const RawSocketEvent._(int _value);   String toString() { throw new UnsupportedError("RawSocketEvent.toString() is unsupported on this platform."); } } abstract class RawSocket implements Stream<RawSocketEvent> { bool get readEventsEnabled => throw new UnsupportedError("RawSocket.readEventsEnabled is unsupported on this platform."); set readEventsEnabled(bool _) { throw new UnsupportedError("RawSocket.readEventsEnabled= is unsupported on this platform."); }   bool get writeEventsEnabled => throw new UnsupportedError("RawSocket.writeEventsEnabled is unsupported on this platform."); set writeEventsEnabled(bool _) { throw new UnsupportedError("RawSocket.writeEventsEnabled= is unsupported on this platform."); }   static Future<RawSocket> connect(host, int port) { throw new UnsupportedError("RawSocket.connect() is unsupported on this platform."); }   int available();   List<int> read([int len]);   int write(List<int> buffer, [int offset, int count]);   int get port;   int get remotePort;   InternetAddress get address;   InternetAddress get remoteAddress;   Future<RawSocket> close();   void shutdown(SocketDirection direction);   bool setOption(SocketOption option, bool enabled); } abstract class Socket implements Stream<List<int>>, IOSink { static Future<Socket> connect(host, int port) { throw new UnsupportedError("Socket.connect() is unsupported on this platform."); }   void destroy();   bool setOption(SocketOption option, bool enabled);   int get port;   int get remotePort;   InternetAddress get address;   InternetAddress get remoteAddress; } class Datagram { List<int> data  InternetAddress address  int port  Datagram(List<int> data, InternetAddress address, int port) { throw new UnsupportedError("new Datagram() is unsupported on this platform."); } } abstract class RawDatagramSocket extends Stream<RawSocketEvent> { bool get readEventsEnabled => throw new UnsupportedError("RawDatagramSocket.readEventsEnabled is unsupported on this platform."); set readEventsEnabled(bool _) { throw new UnsupportedError("RawDatagramSocket.readEventsEnabled= is unsupported on this platform."); }   bool get writeEventsEnabled => throw new UnsupportedError("RawDatagramSocket.writeEventsEnabled is unsupported on this platform."); set writeEventsEnabled(bool _) { throw new UnsupportedError("RawDatagramSocket.writeEventsEnabled= is unsupported on this platform."); }   bool get multicastLoopback => throw new UnsupportedError("RawDatagramSocket.multicastLoopback is unsupported on this platform."); set multicastLoopback(bool _) { throw new UnsupportedError("RawDatagramSocket.multicastLoopback= is unsupported on this platform."); }   int get multicastHops => throw new UnsupportedError("RawDatagramSocket.multicastHops is unsupported on this platform."); set multicastHops(int _) { throw new UnsupportedError("RawDatagramSocket.multicastHops= is unsupported on this platform."); }   NetworkInterface get multicastInterface => throw new UnsupportedError("RawDatagramSocket.multicastInterface is unsupported on this platform."); set multicastInterface(NetworkInterface _) { throw new UnsupportedError("RawDatagramSocket.multicastInterface= is unsupported on this platform."); }   bool get broadcastEnabled => throw new UnsupportedError("RawDatagramSocket.broadcastEnabled is unsupported on this platform."); set broadcastEnabled(bool _) { throw new UnsupportedError("RawDatagramSocket.broadcastEnabled= is unsupported on this platform."); }   static Future<RawDatagramSocket> bind(host, int port, {bool reuseAddress : true}) { throw new UnsupportedError("RawDatagramSocket.bind() is unsupported on this platform."); }   int get port;   InternetAddress get address;   void close();   int send(List<int> buffer, InternetAddress address, int port);   Datagram receive();   void joinMulticast(InternetAddress group, {NetworkInterface interface});   void leaveMulticast(InternetAddress group, {NetworkInterface interface}); } class SocketException implements IOException { String get message => throw new UnsupportedError("SocketException.message is unsupported on this platform.");   OSError get osError => throw new UnsupportedError("SocketException.osError is unsupported on this platform.");   InternetAddress get address => throw new UnsupportedError("SocketException.address is unsupported on this platform.");   int get port => throw new UnsupportedError("SocketException.port is unsupported on this platform.");   const SocketException(String message, {OSError osError, InternetAddress address, int port});   String toString() { throw new UnsupportedError("SocketException.toString() is unsupported on this platform."); } }  const _STDIO_HANDLE_TYPE_TERMINAL = 0;  const _STDIO_HANDLE_TYPE_PIPE = 1;  const _STDIO_HANDLE_TYPE_FILE = 2;  const _STDIO_HANDLE_TYPE_SOCKET = 3;  const _STDIO_HANDLE_TYPE_OTHER = 4;  class _StdStream extends Stream<List<int>> {   _StdStream(Stream<List<int>> _stream) { throw new UnsupportedError("new _StdStream() is unsupported on this platform."); }   StreamSubscription<List<int>> listen(void onData(List<int> event), {Function onError, void onDone(), bool cancelOnError}) {} } class Stdin extends _StdStream implements Stream<List<int>> { Stdin._(Stream<List<int>> stream) : super(throw new UnsupportedError("new Stdin._() is unsupported on this platform.")) { throw new UnsupportedError("new Stdin._() is unsupported on this platform."); }   String readLineSync({Encoding encoding : SYSTEM_ENCODING, bool retainNewlines : false}) {}   bool get echoMode {}   void set echoMode(bool enabled) {}   bool get lineMode {}   void set lineMode(bool enabled) {}   int readByteSync() {} } class Stdout extends _StdSink implements IOSink { Stdout._(IOSink sink) : super(throw new UnsupportedError("new Stdout._() is unsupported on this platform.")) { throw new UnsupportedError("new Stdout._() is unsupported on this platform."); }   bool get hasTerminal {}   int get terminalColumns {}   int get terminalLines {} } class StdoutException implements IOException { String get message => throw new UnsupportedError("StdoutException.message is unsupported on this platform.");   OSError get osError => throw new UnsupportedError("StdoutException.osError is unsupported on this platform.");   const StdoutException(String message, [OSError osError]);   String toString() { throw new UnsupportedError("StdoutException.toString() is unsupported on this platform."); } } class _StdSink implements IOSink {   _StdSink(IOSink _sink) { throw new UnsupportedError("new _StdSink() is unsupported on this platform."); }   Encoding get encoding {}   void set encoding(Encoding encoding) {}   void write(object) {}   void writeln([object = ""]) {}   void writeAll(objects, [sep = ""]) {}   void add(List<int> data) {}   void addError(error, [StackTrace stackTrace]) {}   void writeCharCode(int charCode) {}   Future addStream(Stream<List<int>> stream) {}   Future flush() {}   Future close() {}   Future get done {} } class StdioType { static const TERMINAL = const StdioType._("terminal");   static const PIPE = const StdioType._("pipe");   static const FILE = const StdioType._("file");   static const OTHER = const StdioType._("other");   String get name => throw new UnsupportedError("StdioType.name is unsupported on this platform.");   const StdioType._(String name);   String toString() { throw new UnsupportedError("StdioType.toString() is unsupported on this platform."); } }    Stdin get stdin { throw new UnsupportedError("stdin is unsupported on this platform."); }  Stdout get stdout { throw new UnsupportedError("stdout is unsupported on this platform."); }  IOSink get stderr { throw new UnsupportedError("stderr is unsupported on this platform."); }  StdioType stdioType(object) { throw new UnsupportedError("stdioType() is unsupported on this platform."); }  class _StdIOUtils { static _getStdioOutputStream(int fd) { throw new UnsupportedError("_StdIOUtils._getStdioOutputStream() is unsupported on this platform."); }   static Stdin _getStdioInputStream() { throw new UnsupportedError("_StdIOUtils._getStdioInputStream() is unsupported on this platform."); }   static int _socketType(nativeSocket) { throw new UnsupportedError("_StdIOUtils._socketType() is unsupported on this platform."); }   static _getStdioHandleType(int fd) { throw new UnsupportedError("_StdIOUtils._getStdioHandleType() is unsupported on this platform."); } }  const SYSTEM_ENCODING = const SystemEncoding();  class SystemEncoding extends Encoding { const SystemEncoding();   String get name { throw new UnsupportedError("SystemEncoding.name is unsupported on this platform."); }   List<int> encode(String input) { throw new UnsupportedError("SystemEncoding.encode() is unsupported on this platform."); }   String decode(List<int> encoded) { throw new UnsupportedError("SystemEncoding.decode() is unsupported on this platform."); }   Converter<String, List<int>> get encoder { throw new UnsupportedError("SystemEncoding.encoder is unsupported on this platform."); }   Converter<List<int>, String> get decoder { throw new UnsupportedError("SystemEncoding.decoder is unsupported on this platform."); } } class _WindowsCodePageEncoder extends Converter<String, List<int>> { const _WindowsCodePageEncoder();   List<int> convert(String input) { throw new UnsupportedError("_WindowsCodePageEncoder.convert() is unsupported on this platform."); }   StringConversionSink startChunkedConversion(Sink<List<int>> sink) { throw new UnsupportedError("_WindowsCodePageEncoder.startChunkedConversion() is unsupported on this platform."); }   Stream<List<int>> bind(Stream<String> stream) { throw new UnsupportedError("_WindowsCodePageEncoder.bind() is unsupported on this platform."); }   static List<int> _encodeString(String string) { throw new UnsupportedError("_WindowsCodePageEncoder._encodeString() is unsupported on this platform."); } } class _WindowsCodePageEncoderSink extends StringConversionSinkBase {   _WindowsCodePageEncoderSink(Sink<List<int>> _sink) { throw new UnsupportedError("new _WindowsCodePageEncoderSink() is unsupported on this platform."); }   void close() {}   void add(String string) {}   void addSlice(String source, int start, int end, bool isLast) {} } class _WindowsCodePageDecoder extends Converter<List<int>, String> { const _WindowsCodePageDecoder();   String convert(List<int> input) { throw new UnsupportedError("_WindowsCodePageDecoder.convert() is unsupported on this platform."); }   ByteConversionSink startChunkedConversion(Sink<String> sink) { throw new UnsupportedError("_WindowsCodePageDecoder.startChunkedConversion() is unsupported on this platform."); }   Stream<String> bind(Stream<List<int>> stream) { throw new UnsupportedError("_WindowsCodePageDecoder.bind() is unsupported on this platform."); }   static String _decodeBytes(List<int> bytes) { throw new UnsupportedError("_WindowsCodePageDecoder._decodeBytes() is unsupported on this platform."); } } class _WindowsCodePageDecoderSink extends ByteConversionSinkBase {   _WindowsCodePageDecoderSink(Sink<String> _sink) { throw new UnsupportedError("new _WindowsCodePageDecoderSink() is unsupported on this platform."); }   void close() {}   void add(List<int> bytes) {} }  class _TimerHeap {     _TimerHeap([int initSize = 7]) { throw new UnsupportedError("new _TimerHeap() is unsupported on this platform."); }   bool get isEmpty {}   _Timer get first {}   bool isFirst(_Timer timer) {}   void add(_Timer timer) {}   _Timer removeFirst() {}   void remove(_Timer timer) {}          static int _parentIndex(int index) { throw new UnsupportedError("_TimerHeap._parentIndex() is unsupported on this platform."); }   static int _leftChildIndex(int index) { throw new UnsupportedError("_TimerHeap._leftChildIndex() is unsupported on this platform."); }   static int _rightChildIndex(int index) { throw new UnsupportedError("_TimerHeap._rightChildIndex() is unsupported on this platform."); } } class _Timer implements Timer { static const _NO_TIMER = -1;                                 static int _nextId() { throw new UnsupportedError("_Timer._nextId() is unsupported on this platform."); }   _Timer._internal(Function _callback, int _wakeupTime, int _milliSeconds, bool _repeating) { throw new UnsupportedError("new _Timer._internal() is unsupported on this platform."); }   static Timer _createTimer(void callback(Timer timer), int milliSeconds, bool repeating) { throw new UnsupportedError("_Timer._createTimer() is unsupported on this platform."); }   factory _Timer(int milliSeconds, void callback(Timer timer)) { throw new UnsupportedError("new _Timer() is unsupported on this platform."); }   factory _Timer.periodic(int milliSeconds, void callback(Timer timer)) { throw new UnsupportedError("new _Timer.periodic() is unsupported on this platform."); }      bool get isActive {}   void cancel() {}     static void _notifyEventHandler() { throw new UnsupportedError("_Timer._notifyEventHandler() is unsupported on this platform."); }   static void _handleTimeout(pendingImmediateCallback) { throw new UnsupportedError("_Timer._handleTimeout() is unsupported on this platform."); }   static _ignoreMessage(_) { throw new UnsupportedError("_Timer._ignoreMessage() is unsupported on this platform."); }   static void _createTimerHandler() { throw new UnsupportedError("_Timer._createTimerHandler() is unsupported on this platform."); }   static void _shutdownTimerHandler() { throw new UnsupportedError("_Timer._shutdownTimerHandler() is unsupported on this platform."); }   static Timer _factory(int milliSeconds, void callback(Timer timer), bool repeating) { throw new UnsupportedError("_Timer._factory() is unsupported on this platform."); } }  abstract class SecureSocket implements Socket { factory SecureSocket._(RawSecureSocket rawSocket) { throw new UnsupportedError("new SecureSocket._() is unsupported on this platform."); }   static Future<SecureSocket> connect(host, int port, {bool sendClientCertificate : false, String certificateName, bool onBadCertificate(X509Certificate certificate), List<String> supportedProtocols}) { throw new UnsupportedError("SecureSocket.connect() is unsupported on this platform."); }   static Future<SecureSocket> secure(Socket socket, {host, bool sendClientCertificate : false, String certificateName, bool onBadCertificate(X509Certificate certificate)}) { throw new UnsupportedError("SecureSocket.secure() is unsupported on this platform."); }   static Future<SecureSocket> secureServer(Socket socket, String certificateName, {List<int> bufferedData, bool requestClientCertificate : false, bool requireClientCertificate : false, List<String> supportedProtocols}) { throw new UnsupportedError("SecureSocket.secureServer() is unsupported on this platform."); }   X509Certificate get peerCertificate;   String get selectedProtocol;   void renegotiate({bool useSessionCache : true, bool requestClientCertificate : false, bool requireClientCertificate : false});   static void initialize({String database, String password, bool useBuiltinRoots : true}) { throw new UnsupportedError("SecureSocket.initialize() is unsupported on this platform."); } } abstract class RawSecureSocket implements RawSocket { static Future<RawSecureSocket> connect(host, int port, {bool sendClientCertificate : false, String certificateName, bool onBadCertificate(X509Certificate certificate), List<String> supportedProtocols}) { throw new UnsupportedError("RawSecureSocket.connect() is unsupported on this platform."); }   static Future<RawSecureSocket> secure(RawSocket socket, {StreamSubscription subscription, host, bool sendClientCertificate : false, String certificateName, bool onBadCertificate(X509Certificate certificate), List<String> supportedProtocols}) { throw new UnsupportedError("RawSecureSocket.secure() is unsupported on this platform."); }   static Future<RawSecureSocket> secureServer(RawSocket socket, String certificateName, {StreamSubscription subscription, List<int> bufferedData, bool requestClientCertificate : false, bool requireClientCertificate : false, List<String> supportedProtocols}) { throw new UnsupportedError("RawSecureSocket.secureServer() is unsupported on this platform."); }   void renegotiate({bool useSessionCache : true, bool requestClientCertificate : false, bool requireClientCertificate : false});   X509Certificate get peerCertificate;   String get selectedProtocol; } class X509Certificate { X509Certificate(String subject, String issuer, DateTime startValidity, DateTime endValidity) { throw new UnsupportedError("new X509Certificate() is unsupported on this platform."); }   final String subject = null;   final String issuer = null;   final DateTime startValidity = null;   final DateTime endValidity = null; } class _FilterStatus { bool progress  bool readEmpty  bool writeEmpty  bool readPlaintextNoLongerEmpty  bool writePlaintextNoLongerFull  bool readEncryptedNoLongerFull  bool writeEncryptedNoLongerEmpty  _FilterStatus() { throw new UnsupportedError("new _FilterStatus() is unsupported on this platform."); } } class _RawSecureSocket extends Stream<RawSocketEvent> implements RawSecureSocket { static int get HANDSHAKE => throw new UnsupportedError("_RawSecureSocket.HANDSHAKE is unsupported on this platform.");   static int get CONNECTED => throw new UnsupportedError("_RawSecureSocket.CONNECTED is unsupported on this platform.");   static int get CLOSED => throw new UnsupportedError("_RawSecureSocket.CLOSED is unsupported on this platform.");   static int get READ_PLAINTEXT => throw new UnsupportedError("_RawSecureSocket.READ_PLAINTEXT is unsupported on this platform.");   static int get WRITE_PLAINTEXT => throw new UnsupportedError("_RawSecureSocket.WRITE_PLAINTEXT is unsupported on this platform.");   static int get READ_ENCRYPTED => throw new UnsupportedError("_RawSecureSocket.READ_ENCRYPTED is unsupported on this platform.");   static int get WRITE_ENCRYPTED => throw new UnsupportedError("_RawSecureSocket.WRITE_ENCRYPTED is unsupported on this platform.");   static int get NUM_BUFFERS => throw new UnsupportedError("_RawSecureSocket.NUM_BUFFERS is unsupported on this platform.");   static bool _isBufferEncrypted(int identifier) { throw new UnsupportedError("_RawSecureSocket._isBufferEncrypted() is unsupported on this platform."); }                 final InternetAddress address = null;   final bool is_server = null;   final String certificateName = null;   final bool requestClientCertificate = null;   final bool requireClientCertificate = null;   final bool sendClientCertificate = null;   final Function onBadCertificate = null;                                     static Future<_RawSecureSocket> connect(host, int requestedPort, String certificateName, {bool is_server, RawSocket socket, StreamSubscription subscription, List<int> bufferedData, bool requestClientCertificate : false, bool requireClientCertificate : false, bool sendClientCertificate : false, bool onBadCertificate(X509Certificate certificate), List<String> supportedProtocols}) { throw new UnsupportedError("_RawSecureSocket.connect() is unsupported on this platform."); }   _RawSecureSocket(InternetAddress address, int requestedPort, String certificateName, bool is_server, RawSocket _socket, StreamSubscription<RawSocketEvent> _socketSubscription, List<int> _bufferedData, bool requestClientCertificate, bool requireClientCertificate, bool sendClientCertificate, Function onBadCertificate(X509Certificate certificate), List<String> supportedProtocols) { throw new UnsupportedError("new _RawSecureSocket() is unsupported on this platform."); }      StreamSubscription listen(void onData(RawSocketEvent data), {Function onError, void onDone(), bool cancelOnError}) {}   static void _verifyFields(host, int requestedPort, String certificateName, bool is_server, bool requestClientCertificate, bool requireClientCertificate, bool sendClientCertificate, Function onBadCertificate) { throw new UnsupportedError("_RawSecureSocket._verifyFields() is unsupported on this platform."); }   int get port {}   InternetAddress get remoteAddress {}   int get remotePort {}    int available() {}   Future<RawSecureSocket> close() {}     void shutdown(SocketDirection direction) {}   bool get writeEventsEnabled {}   void set writeEventsEnabled(bool value) {}   bool get readEventsEnabled {}   void set readEventsEnabled(bool value) {}   List<int> read([int length]) {}   int write(List<int> data, [int offset, int bytes]) {}   X509Certificate get peerCertificate {}   String get selectedProtocol {}    bool setOption(SocketOption option, bool enabled) {}          void renegotiate({bool useSessionCache : true, bool requestClientCertificate : false, bool requireClientCertificate : false}) {}             } class _ExternalBuffer { List data  int start  int end  final size = null;   _ExternalBuffer(size) { throw new UnsupportedError("new _ExternalBuffer() is unsupported on this platform."); }   void advanceStart(int bytes) {}   void advanceEnd(int bytes) {}   bool get isEmpty {}   int get length {}   int get linearLength {}   int get free {}   int get linearFree {}   List<int> read(int bytes) {}   int write(List<int> inputData, int offset, int bytes) {}   int writeFromSource(List<int> getData(int requested)) {}   bool readToSocket(RawSocket socket) {} } abstract class _SecureFilter { factory _SecureFilter() { throw new UnsupportedError("new _SecureFilter() is unsupported on this platform."); }   void connect(String hostName, Uint8List addr, int port, bool is_server, String certificateName, bool requestClientCertificate, bool requireClientCertificate, bool sendClientCertificate, Uint8List protocols);   void destroy();   void handshake();   String selectedProtocol();   void rehandshake();   void renegotiate(bool useSessionCache, bool requestClientCertificate, bool requireClientCertificate);   void init();   X509Certificate get peerCertificate;   int processBuffer(int bufferIndex);   void registerBadCertificateCallback(Function callback);   void registerHandshakeCompleteCallback(Function handshakeCompleteHandler);    List<_ExternalBuffer> get buffers; } class TlsException implements IOException { String get type => throw new UnsupportedError("TlsException.type is unsupported on this platform.");   String get message => throw new UnsupportedError("TlsException.message is unsupported on this platform.");   OSError get osError => throw new UnsupportedError("TlsException.osError is unsupported on this platform.");   const TlsException([String message = "", OSError osError = null]);   const TlsException._(String type, String message, OSError osError);   String toString() { throw new UnsupportedError("TlsException.toString() is unsupported on this platform."); } } class HandshakeException extends TlsException { const HandshakeException([String message = "", OSError osError = null]) : super._("HandshakeException", message, osError); } class CertificateException extends TlsException { const CertificateException([String message = "", OSError osError = null]) : super._("CertificateException", message, osError); }  class SecureServerSocket extends Stream<SecureSocket> {   SecureServerSocket._(RawSecureServerSocket _socket) { throw new UnsupportedError("new SecureServerSocket._() is unsupported on this platform."); }   static Future<SecureServerSocket> bind(address, int port, String certificateName, {int backlog : 0, bool v6Only : false, bool requestClientCertificate : false, bool requireClientCertificate : false, List<String> supportedProtocols}) { throw new UnsupportedError("SecureServerSocket.bind() is unsupported on this platform."); }   StreamSubscription<SecureSocket> listen(void onData(SecureSocket socket), {Function onError, void onDone(), bool cancelOnError}) {}   int get port {}   InternetAddress get address {}   Future<SecureServerSocket> close() {}  } class RawSecureServerSocket extends Stream<RawSecureSocket> {       final String certificateName = null;   final bool requestClientCertificate = null;   final bool requireClientCertificate = null;   final List<String> supportedProtocols = null;     RawSecureServerSocket._(RawServerSocket serverSocket, String certificateName, bool requestClientCertificate, bool requireClientCertificate, List<String> supportedProtocols) { throw new UnsupportedError("new RawSecureServerSocket._() is unsupported on this platform."); }   static Future<RawSecureServerSocket> bind(address, int port, String certificateName, {int backlog : 0, bool v6Only : false, bool requestClientCertificate : false, bool requireClientCertificate : false, List<String> supportedProtocols}) { throw new UnsupportedError("RawSecureServerSocket.bind() is unsupported on this platform."); }   StreamSubscription<RawSecureSocket> listen(void onData(RawSecureSocket s), {Function onError, void onDone(), bool cancelOnError}) {}   int get port {}   InternetAddress get address {}   Future<RawSecureServerSocket> close() {}       }  abstract class WebSocketStatus { static const NORMAL_CLOSURE = 1000;   static const GOING_AWAY = 1001;   static const PROTOCOL_ERROR = 1002;   static const UNSUPPORTED_DATA = 1003;   static const RESERVED_1004 = 1004;   static const NO_STATUS_RECEIVED = 1005;   static const ABNORMAL_CLOSURE = 1006;   static const INVALID_FRAME_PAYLOAD_DATA = 1007;   static const POLICY_VIOLATION = 1008;   static const MESSAGE_TOO_BIG = 1009;   static const MISSING_MANDATORY_EXTENSION = 1010;   static const INTERNAL_SERVER_ERROR = 1011;   static const RESERVED_1015 = 1015; } abstract class WebSocketTransformer implements StreamTransformer<HttpRequest, WebSocket> { factory WebSocketTransformer({protocolSelector(List<String> protocols)}) { throw new UnsupportedError("new WebSocketTransformer() is unsupported on this platform."); }   static Future<WebSocket> upgrade(HttpRequest request, {protocolSelector(List<String> protocols)}) { throw new UnsupportedError("WebSocketTransformer.upgrade() is unsupported on this platform."); }   static bool isUpgradeRequest(HttpRequest request) { throw new UnsupportedError("WebSocketTransformer.isUpgradeRequest() is unsupported on this platform."); } } abstract class WebSocket implements Stream, StreamSink { static const CONNECTING = 0;   static const OPEN = 1;   static const CLOSING = 2;   static const CLOSED = 3;   Duration pingInterval  static Future<WebSocket> connect(String url, {List<String> protocols : const []}) { throw new UnsupportedError("WebSocket.connect() is unsupported on this platform."); }   @Deprecated('This constructor will be removed in Dart 2.0. Use `implements`' ' instead of `extends` if implementing this abstract class.') WebSocket() { throw new UnsupportedError("new WebSocket() is unsupported on this platform."); }   factory WebSocket.fromUpgradedSocket(Socket socket, {String protocol, bool serverSide}) { throw new UnsupportedError("new WebSocket.fromUpgradedSocket() is unsupported on this platform."); }   int get readyState;   String get extensions;   String get protocol;   int get closeCode;   String get closeReason;   Future close([int code, String reason]);   void add(data);   Future addStream(Stream stream); } class WebSocketException implements IOException { String get message => throw new UnsupportedError("WebSocketException.message is unsupported on this platform.");   const WebSocketException([String message = ""]);   String toString() { throw new UnsupportedError("WebSocketException.toString() is unsupported on this platform."); } }  const _webSocketGUID = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";  class _WebSocketMessageType { static const NONE = 0;   static const TEXT = 1;   static const BINARY = 2; } class _WebSocketOpcode { static const CONTINUATION = 0;   static const TEXT = 1;   static const BINARY = 2;   static const RESERVED_3 = 3;   static const RESERVED_4 = 4;   static const RESERVED_5 = 5;   static const RESERVED_6 = 6;   static const RESERVED_7 = 7;   static const CLOSE = 8;   static const PING = 9;   static const PONG = 10;   static const RESERVED_B = 11;   static const RESERVED_C = 12;   static const RESERVED_D = 13;   static const RESERVED_E = 14;   static const RESERVED_F = 15; } class _WebSocketProtocolTransformer implements StreamTransformer, EventSink { static const START = 0;   static const LEN_FIRST = 1;   static const LEN_REST = 2;   static const MASK = 3;   static const PAYLOAD = 4;   static const CLOSED = 5;   static const FAILURE = 6;                       int closeCode  String closeReason          _WebSocketProtocolTransformer([bool _serverSide = false]) { throw new UnsupportedError("new _WebSocketProtocolTransformer() is unsupported on this platform."); }   Stream bind(Stream stream) {}   void addError(Object error, [StackTrace stackTrace]) {}   void close() {}   void add(Uint8List buffer) {}         } class _WebSocketPing { final List<int> payload = null;   _WebSocketPing([List<int> payload = null]) { throw new UnsupportedError("new _WebSocketPing() is unsupported on this platform."); } } class _WebSocketPong { final List<int> payload = null;   _WebSocketPong([List<int> payload = null]) { throw new UnsupportedError("new _WebSocketPong() is unsupported on this platform."); } } class _WebSocketTransformerImpl implements WebSocketTransformer {     _WebSocketTransformerImpl(Function _protocolSelector) { throw new UnsupportedError("new _WebSocketTransformerImpl() is unsupported on this platform."); }   Stream<WebSocket> bind(Stream<HttpRequest> stream) {}   static Future<WebSocket> _upgrade(HttpRequest request, _protocolSelector) { throw new UnsupportedError("_WebSocketTransformerImpl._upgrade() is unsupported on this platform."); }   static bool _isUpgradeRequest(HttpRequest request) { throw new UnsupportedError("_WebSocketTransformerImpl._isUpgradeRequest() is unsupported on this platform."); } } class _WebSocketOutgoingTransformer implements StreamTransformer, EventSink { final _WebSocketImpl webSocket = null;     _WebSocketOutgoingTransformer(_WebSocketImpl webSocket) { throw new UnsupportedError("new _WebSocketOutgoingTransformer() is unsupported on this platform."); }   Stream bind(Stream stream) {}   void add(message) {}   void addError(Object error, [StackTrace stackTrace]) {}   void close() {}   void addFrame(int opcode, List<int> data) {}   static Iterable createFrame(int opcode, List<int> data, bool serverSide) { throw new UnsupportedError("_WebSocketOutgoingTransformer.createFrame() is unsupported on this platform."); } } class _WebSocketConsumer implements StreamConsumer { final _WebSocketImpl webSocket = null;   final Socket socket = null;               _WebSocketConsumer(_WebSocketImpl webSocket, Socket socket) { throw new UnsupportedError("new _WebSocketConsumer() is unsupported on this platform."); }         Future addStream(var stream) {}   Future close() {}   void add(data) {}   void closeSocket() {} } class _WebSocketImpl extends Stream with _ServiceObject implements WebSocket {   final String protocol = null;                                   static Future<WebSocket> connect(String url, List<String> protocols) { throw new UnsupportedError("_WebSocketImpl.connect() is unsupported on this platform."); }   _WebSocketImpl._fromSocket(_socket, String protocol, [bool _serverSide = false]) { throw new UnsupportedError("new _WebSocketImpl._fromSocket() is unsupported on this platform."); }   StreamSubscription listen(void onData(message), {Function onError, void onDone(), bool cancelOnError}) {}   Duration get pingInterval {}   void set pingInterval(Duration interval) {}   int get readyState {}   String get extensions {}   int get closeCode {}   String get closeReason {}   void add(data) {}   void addError(error, [StackTrace stackTrace]) {}   Future addStream(Stream stream) {}   Future get done {}   Future close([int code, String reason]) {}       static bool _isReservedStatusCode(int code) { throw new UnsupportedError("_WebSocketImpl._isReservedStatusCode() is unsupported on this platform."); } }