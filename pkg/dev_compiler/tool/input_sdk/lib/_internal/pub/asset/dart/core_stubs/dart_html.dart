library dart.dom.html; import 'dart:async'; import 'dart:collection';  import "dart_html_common.dart"; import "dart_indexed_db.dart"; import "dart_indexed_db.dart" show indexed_dbBlinkMap; import 'dart:isolate'; import "dart_js.dart" as js; import "dart:convert"; import 'dart:math'; import 'dart:mirrors'; import 'dart:nativewrappers'; import 'dart:typed_data'; import "dart_web_gl.dart" as gl; import "dart_web_gl.dart" show web_glBlinkMap; import "dart_web_sql.dart"; import "dart_svg.dart" as svg; import "dart_svg.dart" show svgBlinkMap; import "dart_svg.dart" show Matrix; import "dart_svg.dart" show SvgSvgElement; import "dart_web_audio.dart" as web_audio; import "dart_web_audio.dart" show web_audioBlinkMap;  export 'dart:math' show Rectangle, Point;  Window get window { throw new UnsupportedError("window is unsupported on this platform."); }   HtmlDocument get document { throw new UnsupportedError("document is unsupported on this platform."); }  @Experimental() Future<Isolate> spawnDomUri(Uri uri, List<String> args, message) { throw new UnsupportedError("spawnDomUri() is unsupported on this platform."); }  get htmlBlinkMap => throw new UnsupportedError("htmlBlinkMap is unsupported on this platform.");  Type _getType(String key) { throw new UnsupportedError("_getType() is unsupported on this platform."); }  Type _getHtmlType(String key) { throw new UnsupportedError("_getHtmlType() is unsupported on this platform."); }  Type _getWebGlType(String key) { throw new UnsupportedError("_getWebGlType() is unsupported on this platform."); }  Type _getIndexDbType(String key) { throw new UnsupportedError("_getIndexDbType() is unsupported on this platform."); }  Type _getWebAudioType(String key) { throw new UnsupportedError("_getWebAudioType() is unsupported on this platform."); }  Type _getWebSqlType(String key) { throw new UnsupportedError("_getWebSqlType() is unsupported on this platform."); }  Type _getSvgType(String key) { throw new UnsupportedError("_getSvgType() is unsupported on this platform."); }  @DocsEditable() @DomName('AbstractWorker') abstract class AbstractWorker extends NativeFieldWrapperClass2 implements EventTarget { factory AbstractWorker._() { throw new UnsupportedError("new AbstractWorker._() is unsupported on this platform."); }   static const errorEvent = const EventStreamProvider<ErrorEvent>('error');   @DomName('AbstractWorker.onerror') @DocsEditable() Stream<ErrorEvent> get onError {} } @DocsEditable() @DomName('HTMLAnchorElement') class AnchorElement extends HtmlElement implements UrlUtils { factory AnchorElement._() { throw new UnsupportedError("new AnchorElement._() is unsupported on this platform."); }   @DomName('HTMLAnchorElement.HTMLAnchorElement') @DocsEditable() factory AnchorElement({String href}) { throw new UnsupportedError("new AnchorElement() is unsupported on this platform."); }   AnchorElement.created() : super.created() { throw new UnsupportedError("new AnchorElement.created() is unsupported on this platform."); }   @DomName('HTMLAnchorElement.download') @DocsEditable() String get download {}   @DomName('HTMLAnchorElement.download') @DocsEditable() void set download(String value) {}   @DomName('HTMLAnchorElement.hreflang') @DocsEditable() String get hreflang {}   @DomName('HTMLAnchorElement.hreflang') @DocsEditable() void set hreflang(String value) {}   @DomName('HTMLAnchorElement.integrity') @DocsEditable() @Experimental() String get integrity {}   @DomName('HTMLAnchorElement.integrity') @DocsEditable() @Experimental() void set integrity(String value) {}   @DomName('HTMLAnchorElement.rel') @DocsEditable() String get rel {}   @DomName('HTMLAnchorElement.rel') @DocsEditable() void set rel(String value) {}   @DomName('HTMLAnchorElement.target') @DocsEditable() String get target {}   @DomName('HTMLAnchorElement.target') @DocsEditable() void set target(String value) {}   @DomName('HTMLAnchorElement.type') @DocsEditable() String get type {}   @DomName('HTMLAnchorElement.type') @DocsEditable() void set type(String value) {}   @DomName('HTMLAnchorElement.hash') @DocsEditable() String get hash {}   @DomName('HTMLAnchorElement.hash') @DocsEditable() void set hash(String value) {}   @DomName('HTMLAnchorElement.host') @DocsEditable() String get host {}   @DomName('HTMLAnchorElement.host') @DocsEditable() void set host(String value) {}   @DomName('HTMLAnchorElement.hostname') @DocsEditable() String get hostname {}   @DomName('HTMLAnchorElement.hostname') @DocsEditable() void set hostname(String value) {}   @DomName('HTMLAnchorElement.href') @DocsEditable() String get href {}   @DomName('HTMLAnchorElement.href') @DocsEditable() void set href(String value) {}   @DomName('HTMLAnchorElement.origin') @DocsEditable() @Experimental() String get origin {}   @DomName('HTMLAnchorElement.password') @DocsEditable() @Experimental() String get password {}   @DomName('HTMLAnchorElement.password') @DocsEditable() @Experimental() void set password(String value) {}   @DomName('HTMLAnchorElement.pathname') @DocsEditable() String get pathname {}   @DomName('HTMLAnchorElement.pathname') @DocsEditable() void set pathname(String value) {}   @DomName('HTMLAnchorElement.port') @DocsEditable() String get port {}   @DomName('HTMLAnchorElement.port') @DocsEditable() void set port(String value) {}   @DomName('HTMLAnchorElement.protocol') @DocsEditable() String get protocol {}   @DomName('HTMLAnchorElement.protocol') @DocsEditable() void set protocol(String value) {}   @DomName('HTMLAnchorElement.search') @DocsEditable() String get search {}   @DomName('HTMLAnchorElement.search') @DocsEditable() void set search(String value) {}   @DomName('HTMLAnchorElement.username') @DocsEditable() @Experimental() String get username {}   @DomName('HTMLAnchorElement.username') @DocsEditable() @Experimental() void set username(String value) {}   @DomName('HTMLAnchorElement.toString') @DocsEditable() String toString() {} } @DocsEditable() @DomName('Animation') @Experimental() class Animation extends AnimationNode { factory Animation._() { throw new UnsupportedError("new Animation._() is unsupported on this platform."); }   @DomName('Animation.Animation') @DocsEditable() factory Animation(Element target, List<Map> keyframes, [timingInput]) { throw new UnsupportedError("new Animation() is unsupported on this platform."); } } @DocsEditable() @DomName('AnimationEffect') @Experimental() class AnimationEffect extends NativeFieldWrapperClass2 { factory AnimationEffect._() { throw new UnsupportedError("new AnimationEffect._() is unsupported on this platform."); } } @DocsEditable() @DomName('WebKitAnimationEvent') @SupportedBrowser(SupportedBrowser.CHROME) @SupportedBrowser(SupportedBrowser.SAFARI) @Experimental() class AnimationEvent extends Event { factory AnimationEvent._() { throw new UnsupportedError("new AnimationEvent._() is unsupported on this platform."); }   @DomName('WebKitAnimationEvent.animationName') @DocsEditable() String get animationName {}   @DomName('WebKitAnimationEvent.elapsedTime') @DocsEditable() double get elapsedTime {} } @DocsEditable() @DomName('AnimationNode') @Experimental() class AnimationNode extends NativeFieldWrapperClass2 { factory AnimationNode._() { throw new UnsupportedError("new AnimationNode._() is unsupported on this platform."); }   @DomName('AnimationNode.activeDuration') @DocsEditable() @Experimental() double get activeDuration {}   @DomName('AnimationNode.currentIteration') @DocsEditable() @Experimental() int get currentIteration {}   @DomName('AnimationNode.duration') @DocsEditable() @Experimental() double get duration {}   @DomName('AnimationNode.endTime') @DocsEditable() @Experimental() double get endTime {}   @DomName('AnimationNode.localTime') @DocsEditable() @Experimental() double get localTime {}   @DomName('AnimationNode.player') @DocsEditable() @Experimental() AnimationPlayer get player {}   @DomName('AnimationNode.startTime') @DocsEditable() @Experimental() double get startTime {}   @DomName('AnimationNode.timing') @DocsEditable() @Experimental() Timing get timing {} } @DocsEditable() @DomName('AnimationPlayer') @Experimental() class AnimationPlayer extends EventTarget { factory AnimationPlayer._() { throw new UnsupportedError("new AnimationPlayer._() is unsupported on this platform."); }   @DomName('AnimationPlayer.currentTime') @DocsEditable() @Experimental() num get currentTime {}   @DomName('AnimationPlayer.currentTime') @DocsEditable() @Experimental() void set currentTime(num value) {}   @DomName('AnimationPlayer.finished') @DocsEditable() @Experimental() bool get finished {}   @DomName('AnimationPlayer.paused') @DocsEditable() @Experimental() bool get paused {}   @DomName('AnimationPlayer.playbackRate') @DocsEditable() @Experimental() num get playbackRate {}   @DomName('AnimationPlayer.playbackRate') @DocsEditable() @Experimental() void set playbackRate(num value) {}   @DomName('AnimationPlayer.source') @DocsEditable() @Experimental() AnimationNode get source {}   @DomName('AnimationPlayer.source') @DocsEditable() @Experimental() void set source(AnimationNode value) {}   @DomName('AnimationPlayer.startTime') @DocsEditable() @Experimental() num get startTime {}   @DomName('AnimationPlayer.startTime') @DocsEditable() @Experimental() void set startTime(num value) {}   @DomName('AnimationPlayer.cancel') @DocsEditable() @Experimental() void cancel() {}   @DomName('AnimationPlayer.finish') @DocsEditable() @Experimental() void finish() {}   @DomName('AnimationPlayer.pause') @DocsEditable() @Experimental() void pause() {}   @DomName('AnimationPlayer.play') @DocsEditable() @Experimental() void play() {}   @DomName('AnimationPlayer.reverse') @DocsEditable() @Experimental() void reverse() {} } @DocsEditable() @DomName('AnimationPlayerEvent') @Experimental() class AnimationPlayerEvent extends Event { factory AnimationPlayerEvent._() { throw new UnsupportedError("new AnimationPlayerEvent._() is unsupported on this platform."); }   @DomName('AnimationPlayerEvent.currentTime') @DocsEditable() @Experimental() double get currentTime {}   @DomName('AnimationPlayerEvent.timelineTime') @DocsEditable() @Experimental() double get timelineTime {} } @DocsEditable() @DomName('AnimationTimeline') @Experimental() class AnimationTimeline extends NativeFieldWrapperClass2 { factory AnimationTimeline._() { throw new UnsupportedError("new AnimationTimeline._() is unsupported on this platform."); }   @DomName('AnimationTimeline.currentTime') @DocsEditable() @Experimental() double get currentTime {}   @DomName('AnimationTimeline.getAnimationPlayers') @DocsEditable() @Experimental() List<AnimationPlayer> getAnimationPlayers() {}   @DomName('AnimationTimeline.play') @DocsEditable() @Experimental() AnimationPlayer play(AnimationNode source) {} } @DocsEditable() @DomName('ApplicationCache') @SupportedBrowser(SupportedBrowser.CHROME) @SupportedBrowser(SupportedBrowser.FIREFOX) @SupportedBrowser(SupportedBrowser.IE, '10') @SupportedBrowser(SupportedBrowser.OPERA) @SupportedBrowser(SupportedBrowser.SAFARI) @Unstable() class ApplicationCache extends EventTarget { factory ApplicationCache._() { throw new UnsupportedError("new ApplicationCache._() is unsupported on this platform."); }   static const cachedEvent = const EventStreamProvider<Event>('cached');   static const checkingEvent = const EventStreamProvider<Event>('checking');   static const downloadingEvent = const EventStreamProvider<Event>('downloading');   static const errorEvent = const EventStreamProvider<Event>('error');   static const noUpdateEvent = const EventStreamProvider<Event>('noupdate');   static const obsoleteEvent = const EventStreamProvider<Event>('obsolete');   static const progressEvent = const EventStreamProvider<ProgressEvent>('progress');   static const updateReadyEvent = const EventStreamProvider<Event>('updateready');   static bool get supported { throw new UnsupportedError("ApplicationCache.supported is unsupported on this platform."); }   static const CHECKING = 2;   static const DOWNLOADING = 3;   static const IDLE = 1;   static const OBSOLETE = 5;   static const UNCACHED = 0;   static const UPDATEREADY = 4;   @DomName('ApplicationCache.status') @DocsEditable() int get status {}   @DomName('ApplicationCache.abort') @DocsEditable() void abort() {}   @DomName('ApplicationCache.swapCache') @DocsEditable() void swapCache() {}   @DomName('ApplicationCache.update') @DocsEditable() void update() {}   @DomName('ApplicationCache.oncached') @DocsEditable() Stream<Event> get onCached {}   @DomName('ApplicationCache.onchecking') @DocsEditable() Stream<Event> get onChecking {}   @DomName('ApplicationCache.ondownloading') @DocsEditable() Stream<Event> get onDownloading {}   @DomName('ApplicationCache.onerror') @DocsEditable() Stream<Event> get onError {}   @DomName('ApplicationCache.onnoupdate') @DocsEditable() Stream<Event> get onNoUpdate {}   @DomName('ApplicationCache.onobsolete') @DocsEditable() Stream<Event> get onObsolete {}   @DomName('ApplicationCache.onprogress') @DocsEditable() Stream<ProgressEvent> get onProgress {}   @DomName('ApplicationCache.onupdateready') @DocsEditable() Stream<Event> get onUpdateReady {} } @DocsEditable() @DomName('ApplicationCacheErrorEvent') @Experimental() class ApplicationCacheErrorEvent extends Event { factory ApplicationCacheErrorEvent._() { throw new UnsupportedError("new ApplicationCacheErrorEvent._() is unsupported on this platform."); }   @DomName('ApplicationCacheErrorEvent.message') @DocsEditable() @Experimental() String get message {}   @DomName('ApplicationCacheErrorEvent.reason') @DocsEditable() @Experimental() String get reason {}   @DomName('ApplicationCacheErrorEvent.status') @DocsEditable() @Experimental() int get status {}   @DomName('ApplicationCacheErrorEvent.url') @DocsEditable() @Experimental() String get url {} } @DocsEditable() @DomName('HTMLAreaElement') class AreaElement extends HtmlElement implements UrlUtils { factory AreaElement._() { throw new UnsupportedError("new AreaElement._() is unsupported on this platform."); }   @DomName('HTMLAreaElement.HTMLAreaElement') @DocsEditable() factory AreaElement() { throw new UnsupportedError("new AreaElement() is unsupported on this platform."); }   AreaElement.created() : super.created() { throw new UnsupportedError("new AreaElement.created() is unsupported on this platform."); }   @DomName('HTMLAreaElement.alt') @DocsEditable() String get alt {}   @DomName('HTMLAreaElement.alt') @DocsEditable() void set alt(String value) {}   @DomName('HTMLAreaElement.coords') @DocsEditable() String get coords {}   @DomName('HTMLAreaElement.coords') @DocsEditable() void set coords(String value) {}   @DomName('HTMLAreaElement.shape') @DocsEditable() String get shape {}   @DomName('HTMLAreaElement.shape') @DocsEditable() void set shape(String value) {}   @DomName('HTMLAreaElement.target') @DocsEditable() String get target {}   @DomName('HTMLAreaElement.target') @DocsEditable() void set target(String value) {}   @DomName('HTMLAreaElement.hash') @DocsEditable() String get hash {}   @DomName('HTMLAreaElement.hash') @DocsEditable() void set hash(String value) {}   @DomName('HTMLAreaElement.host') @DocsEditable() String get host {}   @DomName('HTMLAreaElement.host') @DocsEditable() void set host(String value) {}   @DomName('HTMLAreaElement.hostname') @DocsEditable() String get hostname {}   @DomName('HTMLAreaElement.hostname') @DocsEditable() void set hostname(String value) {}   @DomName('HTMLAreaElement.href') @DocsEditable() String get href {}   @DomName('HTMLAreaElement.href') @DocsEditable() void set href(String value) {}   @DomName('HTMLAreaElement.origin') @DocsEditable() @Experimental() String get origin {}   @DomName('HTMLAreaElement.password') @DocsEditable() @Experimental() String get password {}   @DomName('HTMLAreaElement.password') @DocsEditable() @Experimental() void set password(String value) {}   @DomName('HTMLAreaElement.pathname') @DocsEditable() String get pathname {}   @DomName('HTMLAreaElement.pathname') @DocsEditable() void set pathname(String value) {}   @DomName('HTMLAreaElement.port') @DocsEditable() String get port {}   @DomName('HTMLAreaElement.port') @DocsEditable() void set port(String value) {}   @DomName('HTMLAreaElement.protocol') @DocsEditable() String get protocol {}   @DomName('HTMLAreaElement.protocol') @DocsEditable() void set protocol(String value) {}   @DomName('HTMLAreaElement.search') @DocsEditable() String get search {}   @DomName('HTMLAreaElement.search') @DocsEditable() void set search(String value) {}   @DomName('HTMLAreaElement.username') @DocsEditable() @Experimental() String get username {}   @DomName('HTMLAreaElement.username') @DocsEditable() @Experimental() void set username(String value) {}   @DomName('HTMLAreaElement.toString') @DocsEditable() @Experimental() String toString() {} } @DocsEditable() @DomName('HTMLAudioElement') class AudioElement extends MediaElement { factory AudioElement._() { throw new UnsupportedError("new AudioElement._() is unsupported on this platform."); }   @DomName('HTMLAudioElement.HTMLAudioElement') @DocsEditable() factory AudioElement([String src]) { throw new UnsupportedError("new AudioElement() is unsupported on this platform."); }   AudioElement.created() : super.created() { throw new UnsupportedError("new AudioElement.created() is unsupported on this platform."); } } @DocsEditable() @DomName('AudioTrack') @Experimental() class AudioTrack extends NativeFieldWrapperClass2 { factory AudioTrack._() { throw new UnsupportedError("new AudioTrack._() is unsupported on this platform."); }   @DomName('AudioTrack.enabled') @DocsEditable() @Experimental() bool get enabled {}   @DomName('AudioTrack.enabled') @DocsEditable() @Experimental() void set enabled(bool value) {}   @DomName('AudioTrack.id') @DocsEditable() @Experimental() String get id {}   @DomName('AudioTrack.kind') @DocsEditable() @Experimental() String get kind {}   @DomName('AudioTrack.label') @DocsEditable() @Experimental() String get label {}   @DomName('AudioTrack.language') @DocsEditable() @Experimental() String get language {} } @DocsEditable() @DomName('AudioTrackList') @Experimental() class AudioTrackList extends EventTarget { factory AudioTrackList._() { throw new UnsupportedError("new AudioTrackList._() is unsupported on this platform."); }   static const changeEvent = const EventStreamProvider<Event>('change');   @DomName('AudioTrackList.length') @DocsEditable() @Experimental() int get length {}    @DomName('AudioTrackList.getTrackById') @DocsEditable() @Experimental() AudioTrack getTrackById(String id) {}   @DomName('AudioTrackList.onchange') @DocsEditable() @Experimental() Stream<Event> get onChange {} } @DocsEditable() @DomName('AutocompleteErrorEvent') @Experimental() class AutocompleteErrorEvent extends Event { factory AutocompleteErrorEvent._() { throw new UnsupportedError("new AutocompleteErrorEvent._() is unsupported on this platform."); }   @DomName('AutocompleteErrorEvent.reason') @DocsEditable() String get reason {} } @DocsEditable() @DomName('HTMLBRElement') class BRElement extends HtmlElement { factory BRElement._() { throw new UnsupportedError("new BRElement._() is unsupported on this platform."); }   @DomName('HTMLBRElement.HTMLBRElement') @DocsEditable() factory BRElement() { throw new UnsupportedError("new BRElement() is unsupported on this platform."); }   BRElement.created() : super.created() { throw new UnsupportedError("new BRElement.created() is unsupported on this platform."); } } @DocsEditable() @DomName('BarProp') @deprecated class BarProp extends NativeFieldWrapperClass2 { factory BarProp._() { throw new UnsupportedError("new BarProp._() is unsupported on this platform."); }   @DomName('BarProp.visible') @DocsEditable() bool get visible {} } @DocsEditable() @DomName('HTMLBaseElement') class BaseElement extends HtmlElement { factory BaseElement._() { throw new UnsupportedError("new BaseElement._() is unsupported on this platform."); }   @DomName('HTMLBaseElement.HTMLBaseElement') @DocsEditable() factory BaseElement() { throw new UnsupportedError("new BaseElement() is unsupported on this platform."); }   BaseElement.created() : super.created() { throw new UnsupportedError("new BaseElement.created() is unsupported on this platform."); }   @DomName('HTMLBaseElement.href') @DocsEditable() String get href {}   @DomName('HTMLBaseElement.href') @DocsEditable() void set href(String value) {}   @DomName('HTMLBaseElement.target') @DocsEditable() String get target {}   @DomName('HTMLBaseElement.target') @DocsEditable() void set target(String value) {} } @DocsEditable() @DomName('BatteryManager') @Experimental() class BatteryManager extends EventTarget { factory BatteryManager._() { throw new UnsupportedError("new BatteryManager._() is unsupported on this platform."); }   @DomName('BatteryManager.charging') @DocsEditable() bool get charging {}   @DomName('BatteryManager.chargingTime') @DocsEditable() double get chargingTime {}   @DomName('BatteryManager.dischargingTime') @DocsEditable() double get dischargingTime {}   @DomName('BatteryManager.level') @DocsEditable() double get level {} } @DocsEditable() @DomName('BeforeUnloadEvent') class BeforeUnloadEvent extends Event { factory BeforeUnloadEvent._() { throw new UnsupportedError("new BeforeUnloadEvent._() is unsupported on this platform."); }   @DomName('BeforeUnloadEvent.returnValue') @DocsEditable() String get returnValue {}   @DomName('BeforeUnloadEvent.returnValue') @DocsEditable() void set returnValue(String value) {} } @DomName('Blob') class Blob extends NativeFieldWrapperClass2 { factory Blob._() { throw new UnsupportedError("new Blob._() is unsupported on this platform."); }   @DomName('Blob.Blob') @DocsEditable() factory Blob(List blobParts, [String type, String endings]) { throw new UnsupportedError("new Blob() is unsupported on this platform."); }   @DocsEditable() static Blob _create(blobParts, type, endings) { throw new UnsupportedError("Blob._create() is unsupported on this platform."); }   @DomName('Blob.size') @DocsEditable() int get size {}   @DomName('Blob.type') @DocsEditable() String get type {}   @DomName('Blob.close') @DocsEditable() @Experimental() void close() {}   Blob slice([int start, int end, String contentType]) {} } @DocsEditable() @DomName('HTMLBodyElement') class BodyElement extends HtmlElement implements WindowEventHandlers { factory BodyElement._() { throw new UnsupportedError("new BodyElement._() is unsupported on this platform."); }   static const blurEvent = const EventStreamProvider<Event>('blur');   static const errorEvent = const EventStreamProvider<Event>('error');   static const focusEvent = const EventStreamProvider<Event>('focus');   static const hashChangeEvent = const EventStreamProvider<Event>('hashchange');   static const loadEvent = const EventStreamProvider<Event>('load');   static const messageEvent = const EventStreamProvider<MessageEvent>('message');   static const offlineEvent = const EventStreamProvider<Event>('offline');   static const onlineEvent = const EventStreamProvider<Event>('online');   static const popStateEvent = const EventStreamProvider<PopStateEvent>('popstate');   static const resizeEvent = const EventStreamProvider<Event>('resize');   static const scrollEvent = const EventStreamProvider<Event>('scroll');   static const storageEvent = const EventStreamProvider<StorageEvent>('storage');   static const unloadEvent = const EventStreamProvider<Event>('unload');   @DomName('HTMLBodyElement.HTMLBodyElement') @DocsEditable() factory BodyElement() { throw new UnsupportedError("new BodyElement() is unsupported on this platform."); }   BodyElement.created() : super.created() { throw new UnsupportedError("new BodyElement.created() is unsupported on this platform."); }   @DomName('HTMLBodyElement.onblur') @DocsEditable() ElementStream<Event> get onBlur {}   @DomName('HTMLBodyElement.onerror') @DocsEditable() ElementStream<Event> get onError {}   @DomName('HTMLBodyElement.onfocus') @DocsEditable() ElementStream<Event> get onFocus {}   @DomName('HTMLBodyElement.onhashchange') @DocsEditable() ElementStream<Event> get onHashChange {}   @DomName('HTMLBodyElement.onload') @DocsEditable() ElementStream<Event> get onLoad {}   @DomName('HTMLBodyElement.onmessage') @DocsEditable() ElementStream<MessageEvent> get onMessage {}   @DomName('HTMLBodyElement.onoffline') @DocsEditable() ElementStream<Event> get onOffline {}   @DomName('HTMLBodyElement.ononline') @DocsEditable() ElementStream<Event> get onOnline {}   @DomName('HTMLBodyElement.onpopstate') @DocsEditable() ElementStream<PopStateEvent> get onPopState {}   @DomName('HTMLBodyElement.onresize') @DocsEditable() ElementStream<Event> get onResize {}   @DomName('HTMLBodyElement.onscroll') @DocsEditable() @Experimental() ElementStream<Event> get onScroll {}   @DomName('HTMLBodyElement.onstorage') @DocsEditable() ElementStream<StorageEvent> get onStorage {}   @DomName('HTMLBodyElement.onunload') @DocsEditable() ElementStream<Event> get onUnload {} } @DocsEditable() @DomName('HTMLButtonElement') class ButtonElement extends HtmlElement { factory ButtonElement._() { throw new UnsupportedError("new ButtonElement._() is unsupported on this platform."); }   @DomName('HTMLButtonElement.HTMLButtonElement') @DocsEditable() factory ButtonElement() { throw new UnsupportedError("new ButtonElement() is unsupported on this platform."); }   ButtonElement.created() : super.created() { throw new UnsupportedError("new ButtonElement.created() is unsupported on this platform."); }   @DomName('HTMLButtonElement.autofocus') @DocsEditable() bool get autofocus {}   @DomName('HTMLButtonElement.autofocus') @DocsEditable() void set autofocus(bool value) {}   @DomName('HTMLButtonElement.disabled') @DocsEditable() bool get disabled {}   @DomName('HTMLButtonElement.disabled') @DocsEditable() void set disabled(bool value) {}   @DomName('HTMLButtonElement.form') @DocsEditable() FormElement get form {}   @DomName('HTMLButtonElement.formAction') @DocsEditable() String get formAction {}   @DomName('HTMLButtonElement.formAction') @DocsEditable() void set formAction(String value) {}   @DomName('HTMLButtonElement.formEnctype') @DocsEditable() String get formEnctype {}   @DomName('HTMLButtonElement.formEnctype') @DocsEditable() void set formEnctype(String value) {}   @DomName('HTMLButtonElement.formMethod') @DocsEditable() String get formMethod {}   @DomName('HTMLButtonElement.formMethod') @DocsEditable() void set formMethod(String value) {}   @DomName('HTMLButtonElement.formNoValidate') @DocsEditable() bool get formNoValidate {}   @DomName('HTMLButtonElement.formNoValidate') @DocsEditable() void set formNoValidate(bool value) {}   @DomName('HTMLButtonElement.formTarget') @DocsEditable() String get formTarget {}   @DomName('HTMLButtonElement.formTarget') @DocsEditable() void set formTarget(String value) {}   @DomName('HTMLButtonElement.labels') @DocsEditable() @Unstable() List<Node> get labels {}   @DomName('HTMLButtonElement.name') @DocsEditable() String get name {}   @DomName('HTMLButtonElement.name') @DocsEditable() void set name(String value) {}   @DomName('HTMLButtonElement.type') @DocsEditable() String get type {}   @DomName('HTMLButtonElement.type') @DocsEditable() void set type(String value) {}   @DomName('HTMLButtonElement.validationMessage') @DocsEditable() String get validationMessage {}   @DomName('HTMLButtonElement.validity') @DocsEditable() ValidityState get validity {}   @DomName('HTMLButtonElement.value') @DocsEditable() String get value {}   @DomName('HTMLButtonElement.value') @DocsEditable() void set value(String value) {}   @DomName('HTMLButtonElement.willValidate') @DocsEditable() bool get willValidate {}   @DomName('HTMLButtonElement.checkValidity') @DocsEditable() bool checkValidity() {}   @DomName('HTMLButtonElement.setCustomValidity') @DocsEditable() void setCustomValidity(String error) {} } @DocsEditable() @DomName('CDATASection') @deprecated class CDataSection extends Text { factory CDataSection._() { throw new UnsupportedError("new CDataSection._() is unsupported on this platform."); } } @DocsEditable() @DomName('CacheStorage') @Experimental() class CacheStorage extends NativeFieldWrapperClass2 { factory CacheStorage._() { throw new UnsupportedError("new CacheStorage._() is unsupported on this platform."); }   @DomName('CacheStorage.create') @DocsEditable() @Experimental() Future create(String cacheName) {}   @DomName('CacheStorage.delete') @DocsEditable() @Experimental() Future delete(String cacheName) {}   @DomName('CacheStorage.get') @DocsEditable() @Experimental() Future get(String cacheName) {}   @DomName('CacheStorage.has') @DocsEditable() @Experimental() Future has(String cacheName) {}   @DomName('CacheStorage.keys') @DocsEditable() @Experimental() Future keys() {} } @DocsEditable() @DomName('Canvas2DContextAttributes') @Experimental() class Canvas2DContextAttributes extends NativeFieldWrapperClass2 { factory Canvas2DContextAttributes._() { throw new UnsupportedError("new Canvas2DContextAttributes._() is unsupported on this platform."); }   @DomName('Canvas2DContextAttributes.alpha') @DocsEditable() bool get alpha {}   @DomName('Canvas2DContextAttributes.alpha') @DocsEditable() void set alpha(bool value) {}   @DomName('Canvas2DContextAttributes.storage') @DocsEditable() @Experimental() String get storage {}   @DomName('Canvas2DContextAttributes.storage') @DocsEditable() @Experimental() void set storage(String value) {} } @DomName('HTMLCanvasElement') class CanvasElement extends HtmlElement implements CanvasImageSource { factory CanvasElement._() { throw new UnsupportedError("new CanvasElement._() is unsupported on this platform."); }   static const webGlContextLostEvent = const EventStreamProvider<gl.ContextEvent>('webglcontextlost');   static const webGlContextRestoredEvent = const EventStreamProvider<gl.ContextEvent>('webglcontextrestored');   @DomName('HTMLCanvasElement.HTMLCanvasElement') @DocsEditable() factory CanvasElement({int width, int height}) { throw new UnsupportedError("new CanvasElement() is unsupported on this platform."); }   CanvasElement.created() : super.created() { throw new UnsupportedError("new CanvasElement.created() is unsupported on this platform."); }   @DomName('HTMLCanvasElement.height') @DocsEditable() int get height {}   @DomName('HTMLCanvasElement.height') @DocsEditable() void set height(int value) {}   @DomName('HTMLCanvasElement.width') @DocsEditable() int get width {}   @DomName('HTMLCanvasElement.width') @DocsEditable() void set width(int value) {}   @DomName('HTMLCanvasElement.getContext') @DocsEditable() Object getContext(String contextId, [Map attrs]) {}    @DomName('HTMLCanvasElement.onwebglcontextlost') @DocsEditable() ElementStream<gl.ContextEvent> get onWebGlContextLost {}   @DomName('HTMLCanvasElement.onwebglcontextrestored') @DocsEditable() ElementStream<gl.ContextEvent> get onWebGlContextRestored {}   CanvasRenderingContext2D get context2D {}   @SupportedBrowser(SupportedBrowser.CHROME) @SupportedBrowser(SupportedBrowser.FIREFOX) @Experimental() gl.RenderingContext getContext3d({alpha : true, depth : true, stencil : false, antialias : true, premultipliedAlpha : true, preserveDrawingBuffer : false}) {}   String toDataUrl([String type = 'image/png', num quality]) {} } @DocsEditable() @DomName('CanvasGradient') class CanvasGradient extends NativeFieldWrapperClass2 { factory CanvasGradient._() { throw new UnsupportedError("new CanvasGradient._() is unsupported on this platform."); }   @DomName('CanvasGradient.addColorStop') @DocsEditable() void addColorStop(num offset, String color) {} } @DocsEditable() @DomName('CanvasPattern') class CanvasPattern extends NativeFieldWrapperClass2 { factory CanvasPattern._() { throw new UnsupportedError("new CanvasPattern._() is unsupported on this platform."); } } abstract class CanvasRenderingContext { CanvasElement get canvas; } @DomName('CanvasRenderingContext2D') class CanvasRenderingContext2D extends NativeFieldWrapperClass2 implements CanvasRenderingContext { factory CanvasRenderingContext2D._() { throw new UnsupportedError("new CanvasRenderingContext2D._() is unsupported on this platform."); }   @DomName('CanvasRenderingContext2D.canvas') @DocsEditable() @Experimental() CanvasElement get canvas {}   @DomName('CanvasRenderingContext2D.currentTransform') @DocsEditable() @Experimental() Matrix get currentTransform {}   @DomName('CanvasRenderingContext2D.currentTransform') @DocsEditable() @Experimental() void set currentTransform(Matrix value) {}   @DomName('CanvasRenderingContext2D.fillStyle') @DocsEditable() Object get fillStyle {}   @DomName('CanvasRenderingContext2D.fillStyle') @DocsEditable() void set fillStyle(Object value) {}   @DomName('CanvasRenderingContext2D.font') @DocsEditable() String get font {}   @DomName('CanvasRenderingContext2D.font') @DocsEditable() void set font(String value) {}   @DomName('CanvasRenderingContext2D.globalAlpha') @DocsEditable() num get globalAlpha {}   @DomName('CanvasRenderingContext2D.globalAlpha') @DocsEditable() void set globalAlpha(num value) {}   @DomName('CanvasRenderingContext2D.globalCompositeOperation') @DocsEditable() String get globalCompositeOperation {}   @DomName('CanvasRenderingContext2D.globalCompositeOperation') @DocsEditable() void set globalCompositeOperation(String value) {}   @DomName('CanvasRenderingContext2D.imageSmoothingEnabled') @DocsEditable() @Experimental() bool get imageSmoothingEnabled {}   @DomName('CanvasRenderingContext2D.imageSmoothingEnabled') @DocsEditable() @Experimental() void set imageSmoothingEnabled(bool value) {}   @DomName('CanvasRenderingContext2D.lineCap') @DocsEditable() String get lineCap {}   @DomName('CanvasRenderingContext2D.lineCap') @DocsEditable() void set lineCap(String value) {}   @DomName('CanvasRenderingContext2D.lineDashOffset') @DocsEditable() num get lineDashOffset {}   @DomName('CanvasRenderingContext2D.lineDashOffset') @DocsEditable() void set lineDashOffset(num value) {}   @DomName('CanvasRenderingContext2D.lineJoin') @DocsEditable() String get lineJoin {}   @DomName('CanvasRenderingContext2D.lineJoin') @DocsEditable() void set lineJoin(String value) {}   @DomName('CanvasRenderingContext2D.lineWidth') @DocsEditable() num get lineWidth {}   @DomName('CanvasRenderingContext2D.lineWidth') @DocsEditable() void set lineWidth(num value) {}   @DomName('CanvasRenderingContext2D.miterLimit') @DocsEditable() num get miterLimit {}   @DomName('CanvasRenderingContext2D.miterLimit') @DocsEditable() void set miterLimit(num value) {}   @DomName('CanvasRenderingContext2D.shadowBlur') @DocsEditable() num get shadowBlur {}   @DomName('CanvasRenderingContext2D.shadowBlur') @DocsEditable() void set shadowBlur(num value) {}   @DomName('CanvasRenderingContext2D.shadowColor') @DocsEditable() String get shadowColor {}   @DomName('CanvasRenderingContext2D.shadowColor') @DocsEditable() void set shadowColor(String value) {}   @DomName('CanvasRenderingContext2D.shadowOffsetX') @DocsEditable() num get shadowOffsetX {}   @DomName('CanvasRenderingContext2D.shadowOffsetX') @DocsEditable() void set shadowOffsetX(num value) {}   @DomName('CanvasRenderingContext2D.shadowOffsetY') @DocsEditable() num get shadowOffsetY {}   @DomName('CanvasRenderingContext2D.shadowOffsetY') @DocsEditable() void set shadowOffsetY(num value) {}   @DomName('CanvasRenderingContext2D.strokeStyle') @DocsEditable() Object get strokeStyle {}   @DomName('CanvasRenderingContext2D.strokeStyle') @DocsEditable() void set strokeStyle(Object value) {}   @DomName('CanvasRenderingContext2D.textAlign') @DocsEditable() String get textAlign {}   @DomName('CanvasRenderingContext2D.textAlign') @DocsEditable() void set textAlign(String value) {}   @DomName('CanvasRenderingContext2D.textBaseline') @DocsEditable() String get textBaseline {}   @DomName('CanvasRenderingContext2D.textBaseline') @DocsEditable() void set textBaseline(String value) {}   void addHitRegion([Map options]) {}   @DomName('CanvasRenderingContext2D.beginPath') @DocsEditable() void beginPath() {}   @DomName('CanvasRenderingContext2D.clearHitRegions') @DocsEditable() @Experimental() void clearHitRegions() {}   @DomName('CanvasRenderingContext2D.clearRect') @DocsEditable() void clearRect(num x, num y, num width, num height) {}   void clip([path_OR_winding, String winding]) {}   @DomName('CanvasRenderingContext2D.createImageData') @DocsEditable() ImageData createImageData(num sw, num sh) {}   @DomName('CanvasRenderingContext2D.createImageDataFromImageData') @DocsEditable() ImageData createImageDataFromImageData(ImageData imagedata) {}   @DomName('CanvasRenderingContext2D.createLinearGradient') @DocsEditable() CanvasGradient createLinearGradient(num x0, num y0, num x1, num y1) {}   CanvasPattern createPattern(canvas_OR_image, String repetitionType) {}   @DomName('CanvasRenderingContext2D.createPatternFromImage') @DocsEditable() CanvasPattern createPatternFromImage(ImageElement image, String repetitionType) {}   @DomName('CanvasRenderingContext2D.createRadialGradient') @DocsEditable() CanvasGradient createRadialGradient(num x0, num y0, num r0, num x1, num y1, num r1) {}   void drawFocusIfNeeded(element_OR_path, [Element element]) {}    void fill([path_OR_winding, String winding]) {}   @DomName('CanvasRenderingContext2D.fillRect') @DocsEditable() void fillRect(num x, num y, num width, num height) {}   void fillText(String text, num x, num y, [num maxWidth]) {}   @DomName('CanvasRenderingContext2D.getContextAttributes') @DocsEditable() @Experimental() Canvas2DContextAttributes getContextAttributes() {}   @DomName('CanvasRenderingContext2D.getImageData') @DocsEditable() ImageData getImageData(num sx, num sy, num sw, num sh) {}    @DomName('CanvasRenderingContext2D.isContextLost') @DocsEditable() @Experimental() bool isContextLost() {}   bool isPointInPath(path_OR_x, num x_OR_y, [winding_OR_y, String winding]) {}   bool isPointInStroke(path_OR_x, num x_OR_y, [num y]) {}   @DomName('CanvasRenderingContext2D.measureText') @DocsEditable() TextMetrics measureText(String text) {}   void putImageData(ImageData imagedata, num dx, num dy, [num dirtyX, num dirtyY, num dirtyWidth, num dirtyHeight]) {}   @DomName('CanvasRenderingContext2D.removeHitRegion') @DocsEditable() @Experimental() void removeHitRegion(String id) {}   @DomName('CanvasRenderingContext2D.resetTransform') @DocsEditable() @Experimental() void resetTransform() {}   @DomName('CanvasRenderingContext2D.restore') @DocsEditable() void restore() {}   @DomName('CanvasRenderingContext2D.rotate') @DocsEditable() void rotate(num angle) {}   @DomName('CanvasRenderingContext2D.save') @DocsEditable() void save() {}   @DomName('CanvasRenderingContext2D.scale') @DocsEditable() void scale(num x, num y) {}   void scrollPathIntoView([Path2D path]) {}   @DomName('CanvasRenderingContext2D.setLineDash') @DocsEditable() void setLineDash(List<num> dash) {}   @DomName('CanvasRenderingContext2D.setTransform') @DocsEditable() void setTransform(num a, num b, num c, num d, num e, num f) {}   void stroke([Path2D path]) {}   @DomName('CanvasRenderingContext2D.strokeRect') @DocsEditable() void strokeRect(num x, num y, num width, num height) {}   void strokeText(String text, num x, num y, [num maxWidth]) {}   @DomName('CanvasRenderingContext2D.transform') @DocsEditable() void transform(num a, num b, num c, num d, num e, num f) {}   @DomName('CanvasRenderingContext2D.translate') @DocsEditable() void translate(num x, num y) {}    @DomName('CanvasRenderingContext2D.arcTo') @DocsEditable() void arcTo(num x1, num y1, num x2, num y2, num radius) {}   @DomName('CanvasRenderingContext2D.bezierCurveTo') @DocsEditable() void bezierCurveTo(num cp1x, num cp1y, num cp2x, num cp2y, num x, num y) {}   @DomName('CanvasRenderingContext2D.closePath') @DocsEditable() void closePath() {}   @DomName('CanvasRenderingContext2D.ellipse') @DocsEditable() @Experimental() void ellipse(num x, num y, num radiusX, num radiusY, num rotation, num startAngle, num endAngle, bool anticlockwise) {}   @DomName('CanvasRenderingContext2D.lineTo') @DocsEditable() void lineTo(num x, num y) {}   @DomName('CanvasRenderingContext2D.moveTo') @DocsEditable() void moveTo(num x, num y) {}   @DomName('CanvasRenderingContext2D.quadraticCurveTo') @DocsEditable() void quadraticCurveTo(num cpx, num cpy, num x, num y) {}   @DomName('CanvasRenderingContext2D.rect') @DocsEditable() void rect(num x, num y, num width, num height) {}   void setFillColorRgb(int r, int g, int b, [num a = 1]) {}   void setFillColorHsl(int h, num s, num l, [num a = 1]) {}   void setStrokeColorRgb(int r, int g, int b, [num a = 1]) {}   void setStrokeColorHsl(int h, num s, num l, [num a = 1]) {}   @DomName('CanvasRenderingContext2D.arc') void arc(num x, num y, num radius, num startAngle, num endAngle, [bool anticlockwise = false]) {}   @DomName('CanvasRenderingContext2D.drawImage') void drawImageToRect(CanvasImageSource source, Rectangle destRect, {Rectangle sourceRect}) {}   @DomName('CanvasRenderingContext2D.drawImage') void drawImage(CanvasImageSource source, num destX, num destY) {}   @DomName('CanvasRenderingContext2D.drawImage') void drawImageScaled(CanvasImageSource source, num destX, num destY, num destWidth, num destHeight) {}   @DomName('CanvasRenderingContext2D.drawImage') void drawImageScaledFromSource(CanvasImageSource source, num sourceX, num sourceY, num sourceWidth, num sourceHeight, num destX, num destY, num destWidth, num destHeight) {}   @SupportedBrowser(SupportedBrowser.CHROME) @SupportedBrowser(SupportedBrowser.SAFARI) @SupportedBrowser(SupportedBrowser.IE, '11') @Unstable() @DomName('CanvasRenderingContext2D.getLineDash') List<num> getLineDash() {}   @DomName('CanvasRenderingContext2D.webkitBackingStorePixelRation') @Experimental() @deprecated double get backingStorePixelRatio {} } @DocsEditable() @DomName('CharacterData') class CharacterData extends Node implements ChildNode { factory CharacterData._() { throw new UnsupportedError("new CharacterData._() is unsupported on this platform."); }   @DomName('CharacterData.data') @DocsEditable() String get data {}   @DomName('CharacterData.data') @DocsEditable() void set data(String value) {}   @DomName('CharacterData.length') @DocsEditable() int get length {}   @DomName('CharacterData.appendData') @DocsEditable() void appendData(String data) {}   @DomName('CharacterData.deleteData') @DocsEditable() void deleteData(int offset, int length) {}   @DomName('CharacterData.insertData') @DocsEditable() void insertData(int offset, String data) {}   @DomName('CharacterData.replaceData') @DocsEditable() void replaceData(int offset, int length, String data) {}   @DomName('CharacterData.substringData') @DocsEditable() String substringData(int offset, int length) {}   @DomName('CharacterData.nextElementSibling') @DocsEditable() Element get nextElementSibling {}   @DomName('CharacterData.previousElementSibling') @DocsEditable() Element get previousElementSibling {} } @DocsEditable() @DomName('ChildNode') @Experimental() abstract class ChildNode extends NativeFieldWrapperClass2 { factory ChildNode._() { throw new UnsupportedError("new ChildNode._() is unsupported on this platform."); }   @DomName('ChildNode.nextElementSibling') @DocsEditable() @Experimental() Element get nextElementSibling;   @DomName('ChildNode.previousElementSibling') @DocsEditable() @Experimental() Element get previousElementSibling;   @DomName('ChildNode.remove') @DocsEditable() @Experimental() void remove(); } @DocsEditable() @DomName('CircularRegion') @Experimental() class CircularRegion extends GeofencingRegion { factory CircularRegion._() { throw new UnsupportedError("new CircularRegion._() is unsupported on this platform."); }   @DomName('CircularRegion.CircularRegion') @DocsEditable() factory CircularRegion(Map init) { throw new UnsupportedError("new CircularRegion() is unsupported on this platform."); }   static const MAX_RADIUS = 100.0;   static const MIN_RADIUS = 1.0;   @DomName('CircularRegion.latitude') @DocsEditable() @Experimental() double get latitude {}   @DomName('CircularRegion.longitude') @DocsEditable() @Experimental() double get longitude {}   @DomName('CircularRegion.radius') @DocsEditable() @Experimental() double get radius {} } @DocsEditable() @DomName('CloseEvent') class CloseEvent extends Event { factory CloseEvent._() { throw new UnsupportedError("new CloseEvent._() is unsupported on this platform."); }   @DomName('CloseEvent.code') @DocsEditable() int get code {}   @DomName('CloseEvent.reason') @DocsEditable() String get reason {}   @DomName('CloseEvent.wasClean') @DocsEditable() bool get wasClean {} } @DocsEditable() @DomName('Comment') class Comment extends CharacterData { factory Comment._() { throw new UnsupportedError("new Comment._() is unsupported on this platform."); }   @DomName('Comment.Comment') @DocsEditable() factory Comment([String data]) { throw new UnsupportedError("new Comment() is unsupported on this platform."); } } @DomName('CompositionEvent') class CompositionEvent extends UIEvent { factory CompositionEvent(String type, {bool canBubble : false, bool cancelable : false, Window view, String data}) { throw new UnsupportedError("new CompositionEvent() is unsupported on this platform."); }   factory CompositionEvent._() { throw new UnsupportedError("new CompositionEvent._() is unsupported on this platform."); }   @DomName('CompositionEvent.activeSegmentEnd') @DocsEditable() @Experimental() int get activeSegmentEnd {}   @DomName('CompositionEvent.activeSegmentStart') @DocsEditable() @Experimental() int get activeSegmentStart {}   @DomName('CompositionEvent.data') @DocsEditable() String get data {}   @DomName('CompositionEvent.getSegments') @DocsEditable() @Experimental() List<int> getSegments() {}  } @DocsEditable() @DomName('Console') class Console extends ConsoleBase { factory Console._() { throw new UnsupportedError("new Console._() is unsupported on this platform."); }   @DomName('Console.memory') @DocsEditable() @Experimental() MemoryInfo get memory {} } @DocsEditable() @DomName('ConsoleBase') @Experimental() class ConsoleBase extends NativeFieldWrapperClass2 { factory ConsoleBase._() { throw new UnsupportedError("new ConsoleBase._() is unsupported on this platform."); }   @DomName('ConsoleBase.assertCondition') @DocsEditable() @Experimental() void assertCondition(bool condition, Object arg) {}   @DomName('ConsoleBase.clear') @DocsEditable() @Experimental() void clear(Object arg) {}   @DomName('ConsoleBase.count') @DocsEditable() @Experimental() void count(Object arg) {}   @DomName('ConsoleBase.debug') @DocsEditable() @Experimental() void debug(Object arg) {}   @DomName('ConsoleBase.dir') @DocsEditable() @Experimental() void dir(Object arg) {}   @DomName('ConsoleBase.dirxml') @DocsEditable() @Experimental() void dirxml(Object arg) {}   @DomName('ConsoleBase.error') @DocsEditable() @Experimental() void error(Object arg) {}   @DomName('ConsoleBase.group') @DocsEditable() @Experimental() void group(Object arg) {}   @DomName('ConsoleBase.groupCollapsed') @DocsEditable() @Experimental() void groupCollapsed(Object arg) {}   @DomName('ConsoleBase.groupEnd') @DocsEditable() @Experimental() void groupEnd() {}   @DomName('ConsoleBase.info') @DocsEditable() @Experimental() void info(Object arg) {}   @DomName('ConsoleBase.log') @DocsEditable() @Experimental() void log(Object arg) {}   @DomName('ConsoleBase.markTimeline') @DocsEditable() @Experimental() void markTimeline(String title) {}   @DomName('ConsoleBase.profile') @DocsEditable() @Experimental() void profile(String title) {}   @DomName('ConsoleBase.profileEnd') @DocsEditable() @Experimental() void profileEnd(String title) {}   @DomName('ConsoleBase.table') @DocsEditable() @Experimental() void table(Object arg) {}   @DomName('ConsoleBase.time') @DocsEditable() @Experimental() void time(String title) {}   @DomName('ConsoleBase.timeEnd') @DocsEditable() @Experimental() void timeEnd(String title) {}   @DomName('ConsoleBase.timeStamp') @DocsEditable() @Experimental() void timeStamp(String title) {}   @DomName('ConsoleBase.timeline') @DocsEditable() @Experimental() void timeline(String title) {}   @DomName('ConsoleBase.timelineEnd') @DocsEditable() @Experimental() void timelineEnd(String title) {}   @DomName('ConsoleBase.trace') @DocsEditable() @Experimental() void trace(Object arg) {}   @DomName('ConsoleBase.warn') @DocsEditable() @Experimental() void warn(Object arg) {} } @DocsEditable() @DomName('HTMLContentElement') @SupportedBrowser(SupportedBrowser.CHROME, '26') @Experimental() class ContentElement extends HtmlElement { factory ContentElement._() { throw new UnsupportedError("new ContentElement._() is unsupported on this platform."); }   @DomName('HTMLContentElement.HTMLContentElement') @DocsEditable() factory ContentElement() { throw new UnsupportedError("new ContentElement() is unsupported on this platform."); }   ContentElement.created() : super.created() { throw new UnsupportedError("new ContentElement.created() is unsupported on this platform."); }   static bool get supported { throw new UnsupportedError("ContentElement.supported is unsupported on this platform."); }   @DomName('HTMLContentElement.select') @DocsEditable() String get select {}   @DomName('HTMLContentElement.select') @DocsEditable() void set select(String value) {}   @DomName('HTMLContentElement.getDistributedNodes') @DocsEditable() List<Node> getDistributedNodes() {} } @DocsEditable() @DomName('Coordinates') class Coordinates extends NativeFieldWrapperClass2 { factory Coordinates._() { throw new UnsupportedError("new Coordinates._() is unsupported on this platform."); }   @DomName('Coordinates.accuracy') @DocsEditable() double get accuracy {}   @DomName('Coordinates.altitude') @DocsEditable() double get altitude {}   @DomName('Coordinates.altitudeAccuracy') @DocsEditable() double get altitudeAccuracy {}   @DomName('Coordinates.heading') @DocsEditable() double get heading {}   @DomName('Coordinates.latitude') @DocsEditable() double get latitude {}   @DomName('Coordinates.longitude') @DocsEditable() double get longitude {}   @DomName('Coordinates.speed') @DocsEditable() double get speed {} } @DocsEditable() @DomName('Credential') @Experimental() class Credential extends NativeFieldWrapperClass2 { factory Credential._() { throw new UnsupportedError("new Credential._() is unsupported on this platform."); }   @DomName('Credential.avatarURL') @DocsEditable() @Experimental() String get avatarUrl {}   @DomName('Credential.id') @DocsEditable() @Experimental() String get id {}   @DomName('Credential.name') @DocsEditable() @Experimental() String get name {} } @DocsEditable() @DomName('CredentialsContainer') @Experimental() class CredentialsContainer extends NativeFieldWrapperClass2 { factory CredentialsContainer._() { throw new UnsupportedError("new CredentialsContainer._() is unsupported on this platform."); }   Future notifyFailedSignIn([Credential credential]) {}   Future notifySignedIn([Credential credential]) {}   @DomName('CredentialsContainer.notifySignedOut') @DocsEditable() @Experimental() Future notifySignedOut() {}   Future request([Map options]) {} } @DocsEditable() @DomName('Crypto') @SupportedBrowser(SupportedBrowser.CHROME) @SupportedBrowser(SupportedBrowser.SAFARI) @Experimental() class Crypto extends NativeFieldWrapperClass2 { factory Crypto._() { throw new UnsupportedError("new Crypto._() is unsupported on this platform."); }   static bool get supported { throw new UnsupportedError("Crypto.supported is unsupported on this platform."); }   @DomName('Crypto.subtle') @DocsEditable() @Experimental() _SubtleCrypto get subtle {}   @DomName('Crypto.getRandomValues') @DocsEditable() TypedData getRandomValues(TypedData array) {} } @DocsEditable() @DomName('CryptoKey') @Experimental() class CryptoKey extends NativeFieldWrapperClass2 { factory CryptoKey._() { throw new UnsupportedError("new CryptoKey._() is unsupported on this platform."); }   @DomName('CryptoKey.algorithm') @DocsEditable() @Experimental() Object get algorithm {}   @DomName('CryptoKey.extractable') @DocsEditable() @Experimental() bool get extractable {}   @DomName('CryptoKey.type') @DocsEditable() @Experimental() String get type {}   @DomName('CryptoKey.usages') @DocsEditable() @Experimental() List<String> get usages {} } @DocsEditable() @DomName('CSS') @Experimental() class Css extends NativeFieldWrapperClass2 { factory Css._() { throw new UnsupportedError("new Css._() is unsupported on this platform."); }   @DomName('CSS.supports') @DocsEditable() bool supports(String property, String value) {}   @DomName('CSS.supportsCondition') @DocsEditable() bool supportsCondition(String conditionText) {} } @DocsEditable() @DomName('CSSCharsetRule') @Experimental() class CssCharsetRule extends CssRule { factory CssCharsetRule._() { throw new UnsupportedError("new CssCharsetRule._() is unsupported on this platform."); }   @DomName('CSSCharsetRule.encoding') @DocsEditable() String get encoding {}   @DomName('CSSCharsetRule.encoding') @DocsEditable() void set encoding(String value) {} } @DocsEditable() @DomName('WebKitCSSFilterRule') @SupportedBrowser(SupportedBrowser.CHROME) @SupportedBrowser(SupportedBrowser.SAFARI) @Experimental() class CssFilterRule extends CssRule { factory CssFilterRule._() { throw new UnsupportedError("new CssFilterRule._() is unsupported on this platform."); }   @DomName('WebKitCSSFilterRule.style') @DocsEditable() CssStyleDeclaration get style {} } @DocsEditable() @DomName('CSSFontFaceRule') class CssFontFaceRule extends CssRule { factory CssFontFaceRule._() { throw new UnsupportedError("new CssFontFaceRule._() is unsupported on this platform."); }   @DomName('CSSFontFaceRule.style') @DocsEditable() CssStyleDeclaration get style {} } @DocsEditable() @DomName('CSSImportRule') class CssImportRule extends CssRule { factory CssImportRule._() { throw new UnsupportedError("new CssImportRule._() is unsupported on this platform."); }   @DomName('CSSImportRule.href') @DocsEditable() String get href {}   @DomName('CSSImportRule.media') @DocsEditable() MediaList get media {}   @DomName('CSSImportRule.styleSheet') @DocsEditable() CssStyleSheet get styleSheet {} } @DocsEditable() @DomName('CSSKeyframeRule') @Experimental() class CssKeyframeRule extends CssRule { factory CssKeyframeRule._() { throw new UnsupportedError("new CssKeyframeRule._() is unsupported on this platform."); }   @DomName('CSSKeyframeRule.keyText') @DocsEditable() @Experimental() String get keyText {}   @DomName('CSSKeyframeRule.keyText') @DocsEditable() @Experimental() void set keyText(String value) {}   @DomName('CSSKeyframeRule.style') @DocsEditable() @Experimental() CssStyleDeclaration get style {} } @DocsEditable() @DomName('CSSKeyframesRule') @Experimental() class CssKeyframesRule extends CssRule { factory CssKeyframesRule._() { throw new UnsupportedError("new CssKeyframesRule._() is unsupported on this platform."); }   @DomName('CSSKeyframesRule.cssRules') @DocsEditable() @Experimental() List<CssRule> get cssRules {}   @DomName('CSSKeyframesRule.name') @DocsEditable() @Experimental() String get name {}   @DomName('CSSKeyframesRule.name') @DocsEditable() @Experimental() void set name(String value) {}    @DomName('CSSKeyframesRule.deleteRule') @DocsEditable() @Experimental() void deleteRule(String key) {}   @DomName('CSSKeyframesRule.findRule') @DocsEditable() @Experimental() CssKeyframeRule findRule(String key) {}   @DomName('CSSKeyframesRule.insertRule') @DocsEditable() @Experimental() void appendRule(String rule) {} } @DocsEditable() @DomName('CSSMediaRule') class CssMediaRule extends CssRule { factory CssMediaRule._() { throw new UnsupportedError("new CssMediaRule._() is unsupported on this platform."); }   @DomName('CSSMediaRule.cssRules') @DocsEditable() List<CssRule> get cssRules {}   @DomName('CSSMediaRule.media') @DocsEditable() MediaList get media {}   @DomName('CSSMediaRule.deleteRule') @DocsEditable() void deleteRule(int index) {}   @DomName('CSSMediaRule.insertRule') @DocsEditable() int insertRule(String rule, int index) {} } @DocsEditable() @DomName('CSSPageRule') class CssPageRule extends CssRule { factory CssPageRule._() { throw new UnsupportedError("new CssPageRule._() is unsupported on this platform."); }   @DomName('CSSPageRule.selectorText') @DocsEditable() String get selectorText {}   @DomName('CSSPageRule.selectorText') @DocsEditable() void set selectorText(String value) {}   @DomName('CSSPageRule.style') @DocsEditable() CssStyleDeclaration get style {} } @DocsEditable() @DomName('CSSRule') class CssRule extends NativeFieldWrapperClass2 { factory CssRule._() { throw new UnsupportedError("new CssRule._() is unsupported on this platform."); }   static const CHARSET_RULE = 2;   static const FONT_FACE_RULE = 5;   static const IMPORT_RULE = 3;   static const KEYFRAMES_RULE = 7;   static const KEYFRAME_RULE = 8;   static const MEDIA_RULE = 4;   static const PAGE_RULE = 6;   static const STYLE_RULE = 1;   static const SUPPORTS_RULE = 12;   static const VIEWPORT_RULE = 15;   static const WEBKIT_FILTER_RULE = 17;   static const WEBKIT_KEYFRAMES_RULE = 7;   static const WEBKIT_KEYFRAME_RULE = 8;   @DomName('CSSRule.cssText') @DocsEditable() String get cssText {}   @DomName('CSSRule.cssText') @DocsEditable() void set cssText(String value) {}   @DomName('CSSRule.parentRule') @DocsEditable() CssRule get parentRule {}   @DomName('CSSRule.parentStyleSheet') @DocsEditable() CssStyleSheet get parentStyleSheet {}   @DomName('CSSRule.type') @DocsEditable() int get type {} } @DomName('CSSStyleDeclaration') class CssStyleDeclaration extends NativeFieldWrapperClass2 with CssStyleDeclarationBase { factory CssStyleDeclaration() { throw new UnsupportedError("new CssStyleDeclaration() is unsupported on this platform."); }   factory CssStyleDeclaration.css(String css) { throw new UnsupportedError("new CssStyleDeclaration.css() is unsupported on this platform."); }   String getPropertyValue(String propertyName) {}    bool supportsProperty(String propertyName) {}     @DomName('CSSStyleDeclaration.setProperty') void setProperty(String propertyName, String value, [String priority]) {}   static String _camelCase(String hyphenated) { throw new UnsupportedError("CssStyleDeclaration._camelCase() is unsupported on this platform."); }    static bool get supportsTransitions { throw new UnsupportedError("CssStyleDeclaration.supportsTransitions is unsupported on this platform."); }   factory CssStyleDeclaration._() { throw new UnsupportedError("new CssStyleDeclaration._() is unsupported on this platform."); }   @DomName('CSSStyleDeclaration.cssText') @DocsEditable() String get cssText {}   @DomName('CSSStyleDeclaration.cssText') @DocsEditable() void set cssText(String value) {}   @DomName('CSSStyleDeclaration.length') @DocsEditable() int get length {}   @DomName('CSSStyleDeclaration.parentRule') @DocsEditable() CssRule get parentRule {}      @DomName('CSSStyleDeclaration.getPropertyPriority') @DocsEditable() String getPropertyPriority(String propertyName) {}    @DomName('CSSStyleDeclaration.item') @DocsEditable() String item(int index) {}   @DomName('CSSStyleDeclaration.removeProperty') @DocsEditable() String removeProperty(String propertyName) {}  } class _CssStyleDeclarationSet extends Object with CssStyleDeclarationBase {     _CssStyleDeclarationSet(Iterable<Element> _elementIterable) { throw new UnsupportedError("new _CssStyleDeclarationSet() is unsupported on this platform."); }   String getPropertyValue(String propertyName) {}   void setProperty(String propertyName, String value, [String priority]) {} } abstract class CssStyleDeclarationBase { String getPropertyValue(String propertyName);   void setProperty(String propertyName, String value, [String priority]);   String get alignContent { throw new UnsupportedError("CssStyleDeclarationBase.alignContent is unsupported on this platform."); }   void set alignContent(String value) { throw new UnsupportedError("CssStyleDeclarationBase.alignContent= is unsupported on this platform."); }   String get alignItems { throw new UnsupportedError("CssStyleDeclarationBase.alignItems is unsupported on this platform."); }   void set alignItems(String value) { throw new UnsupportedError("CssStyleDeclarationBase.alignItems= is unsupported on this platform."); }   String get alignSelf { throw new UnsupportedError("CssStyleDeclarationBase.alignSelf is unsupported on this platform."); }   void set alignSelf(String value) { throw new UnsupportedError("CssStyleDeclarationBase.alignSelf= is unsupported on this platform."); }   String get animation { throw new UnsupportedError("CssStyleDeclarationBase.animation is unsupported on this platform."); }   void set animation(String value) { throw new UnsupportedError("CssStyleDeclarationBase.animation= is unsupported on this platform."); }   String get animationDelay { throw new UnsupportedError("CssStyleDeclarationBase.animationDelay is unsupported on this platform."); }   void set animationDelay(String value) { throw new UnsupportedError("CssStyleDeclarationBase.animationDelay= is unsupported on this platform."); }   String get animationDirection { throw new UnsupportedError("CssStyleDeclarationBase.animationDirection is unsupported on this platform."); }   void set animationDirection(String value) { throw new UnsupportedError("CssStyleDeclarationBase.animationDirection= is unsupported on this platform."); }   String get animationDuration { throw new UnsupportedError("CssStyleDeclarationBase.animationDuration is unsupported on this platform."); }   void set animationDuration(String value) { throw new UnsupportedError("CssStyleDeclarationBase.animationDuration= is unsupported on this platform."); }   String get animationFillMode { throw new UnsupportedError("CssStyleDeclarationBase.animationFillMode is unsupported on this platform."); }   void set animationFillMode(String value) { throw new UnsupportedError("CssStyleDeclarationBase.animationFillMode= is unsupported on this platform."); }   String get animationIterationCount { throw new UnsupportedError("CssStyleDeclarationBase.animationIterationCount is unsupported on this platform."); }   void set animationIterationCount(String value) { throw new UnsupportedError("CssStyleDeclarationBase.animationIterationCount= is unsupported on this platform."); }   String get animationName { throw new UnsupportedError("CssStyleDeclarationBase.animationName is unsupported on this platform."); }   void set animationName(String value) { throw new UnsupportedError("CssStyleDeclarationBase.animationName= is unsupported on this platform."); }   String get animationPlayState { throw new UnsupportedError("CssStyleDeclarationBase.animationPlayState is unsupported on this platform."); }   void set animationPlayState(String value) { throw new UnsupportedError("CssStyleDeclarationBase.animationPlayState= is unsupported on this platform."); }   String get animationTimingFunction { throw new UnsupportedError("CssStyleDeclarationBase.animationTimingFunction is unsupported on this platform."); }   void set animationTimingFunction(String value) { throw new UnsupportedError("CssStyleDeclarationBase.animationTimingFunction= is unsupported on this platform."); }   String get appRegion { throw new UnsupportedError("CssStyleDeclarationBase.appRegion is unsupported on this platform."); }   void set appRegion(String value) { throw new UnsupportedError("CssStyleDeclarationBase.appRegion= is unsupported on this platform."); }   String get appearance { throw new UnsupportedError("CssStyleDeclarationBase.appearance is unsupported on this platform."); }   void set appearance(String value) { throw new UnsupportedError("CssStyleDeclarationBase.appearance= is unsupported on this platform."); }   String get aspectRatio { throw new UnsupportedError("CssStyleDeclarationBase.aspectRatio is unsupported on this platform."); }   void set aspectRatio(String value) { throw new UnsupportedError("CssStyleDeclarationBase.aspectRatio= is unsupported on this platform."); }   String get backfaceVisibility { throw new UnsupportedError("CssStyleDeclarationBase.backfaceVisibility is unsupported on this platform."); }   void set backfaceVisibility(String value) { throw new UnsupportedError("CssStyleDeclarationBase.backfaceVisibility= is unsupported on this platform."); }   String get background { throw new UnsupportedError("CssStyleDeclarationBase.background is unsupported on this platform."); }   void set background(String value) { throw new UnsupportedError("CssStyleDeclarationBase.background= is unsupported on this platform."); }   String get backgroundAttachment { throw new UnsupportedError("CssStyleDeclarationBase.backgroundAttachment is unsupported on this platform."); }   void set backgroundAttachment(String value) { throw new UnsupportedError("CssStyleDeclarationBase.backgroundAttachment= is unsupported on this platform."); }   String get backgroundBlendMode { throw new UnsupportedError("CssStyleDeclarationBase.backgroundBlendMode is unsupported on this platform."); }   void set backgroundBlendMode(String value) { throw new UnsupportedError("CssStyleDeclarationBase.backgroundBlendMode= is unsupported on this platform."); }   String get backgroundClip { throw new UnsupportedError("CssStyleDeclarationBase.backgroundClip is unsupported on this platform."); }   void set backgroundClip(String value) { throw new UnsupportedError("CssStyleDeclarationBase.backgroundClip= is unsupported on this platform."); }   String get backgroundColor { throw new UnsupportedError("CssStyleDeclarationBase.backgroundColor is unsupported on this platform."); }   void set backgroundColor(String value) { throw new UnsupportedError("CssStyleDeclarationBase.backgroundColor= is unsupported on this platform."); }   String get backgroundComposite { throw new UnsupportedError("CssStyleDeclarationBase.backgroundComposite is unsupported on this platform."); }   void set backgroundComposite(String value) { throw new UnsupportedError("CssStyleDeclarationBase.backgroundComposite= is unsupported on this platform."); }   String get backgroundImage { throw new UnsupportedError("CssStyleDeclarationBase.backgroundImage is unsupported on this platform."); }   void set backgroundImage(String value) { throw new UnsupportedError("CssStyleDeclarationBase.backgroundImage= is unsupported on this platform."); }   String get backgroundOrigin { throw new UnsupportedError("CssStyleDeclarationBase.backgroundOrigin is unsupported on this platform."); }   void set backgroundOrigin(String value) { throw new UnsupportedError("CssStyleDeclarationBase.backgroundOrigin= is unsupported on this platform."); }   String get backgroundPosition { throw new UnsupportedError("CssStyleDeclarationBase.backgroundPosition is unsupported on this platform."); }   void set backgroundPosition(String value) { throw new UnsupportedError("CssStyleDeclarationBase.backgroundPosition= is unsupported on this platform."); }   String get backgroundPositionX { throw new UnsupportedError("CssStyleDeclarationBase.backgroundPositionX is unsupported on this platform."); }   void set backgroundPositionX(String value) { throw new UnsupportedError("CssStyleDeclarationBase.backgroundPositionX= is unsupported on this platform."); }   String get backgroundPositionY { throw new UnsupportedError("CssStyleDeclarationBase.backgroundPositionY is unsupported on this platform."); }   void set backgroundPositionY(String value) { throw new UnsupportedError("CssStyleDeclarationBase.backgroundPositionY= is unsupported on this platform."); }   String get backgroundRepeat { throw new UnsupportedError("CssStyleDeclarationBase.backgroundRepeat is unsupported on this platform."); }   void set backgroundRepeat(String value) { throw new UnsupportedError("CssStyleDeclarationBase.backgroundRepeat= is unsupported on this platform."); }   String get backgroundRepeatX { throw new UnsupportedError("CssStyleDeclarationBase.backgroundRepeatX is unsupported on this platform."); }   void set backgroundRepeatX(String value) { throw new UnsupportedError("CssStyleDeclarationBase.backgroundRepeatX= is unsupported on this platform."); }   String get backgroundRepeatY { throw new UnsupportedError("CssStyleDeclarationBase.backgroundRepeatY is unsupported on this platform."); }   void set backgroundRepeatY(String value) { throw new UnsupportedError("CssStyleDeclarationBase.backgroundRepeatY= is unsupported on this platform."); }   String get backgroundSize { throw new UnsupportedError("CssStyleDeclarationBase.backgroundSize is unsupported on this platform."); }   void set backgroundSize(String value) { throw new UnsupportedError("CssStyleDeclarationBase.backgroundSize= is unsupported on this platform."); }   String get border { throw new UnsupportedError("CssStyleDeclarationBase.border is unsupported on this platform."); }   void set border(String value) { throw new UnsupportedError("CssStyleDeclarationBase.border= is unsupported on this platform."); }   String get borderAfter { throw new UnsupportedError("CssStyleDeclarationBase.borderAfter is unsupported on this platform."); }   void set borderAfter(String value) { throw new UnsupportedError("CssStyleDeclarationBase.borderAfter= is unsupported on this platform."); }   String get borderAfterColor { throw new UnsupportedError("CssStyleDeclarationBase.borderAfterColor is unsupported on this platform."); }   void set borderAfterColor(String value) { throw new UnsupportedError("CssStyleDeclarationBase.borderAfterColor= is unsupported on this platform."); }   String get borderAfterStyle { throw new UnsupportedError("CssStyleDeclarationBase.borderAfterStyle is unsupported on this platform."); }   void set borderAfterStyle(String value) { throw new UnsupportedError("CssStyleDeclarationBase.borderAfterStyle= is unsupported on this platform."); }   String get borderAfterWidth { throw new UnsupportedError("CssStyleDeclarationBase.borderAfterWidth is unsupported on this platform."); }   void set borderAfterWidth(String value) { throw new UnsupportedError("CssStyleDeclarationBase.borderAfterWidth= is unsupported on this platform."); }   String get borderBefore { throw new UnsupportedError("CssStyleDeclarationBase.borderBefore is unsupported on this platform."); }   void set borderBefore(String value) { throw new UnsupportedError("CssStyleDeclarationBase.borderBefore= is unsupported on this platform."); }   String get borderBeforeColor { throw new UnsupportedError("CssStyleDeclarationBase.borderBeforeColor is unsupported on this platform."); }   void set borderBeforeColor(String value) { throw new UnsupportedError("CssStyleDeclarationBase.borderBeforeColor= is unsupported on this platform."); }   String get borderBeforeStyle { throw new UnsupportedError("CssStyleDeclarationBase.borderBeforeStyle is unsupported on this platform."); }   void set borderBeforeStyle(String value) { throw new UnsupportedError("CssStyleDeclarationBase.borderBeforeStyle= is unsupported on this platform."); }   String get borderBeforeWidth { throw new UnsupportedError("CssStyleDeclarationBase.borderBeforeWidth is unsupported on this platform."); }   void set borderBeforeWidth(String value) { throw new UnsupportedError("CssStyleDeclarationBase.borderBeforeWidth= is unsupported on this platform."); }   String get borderBottom { throw new UnsupportedError("CssStyleDeclarationBase.borderBottom is unsupported on this platform."); }   void set borderBottom(String value) { throw new UnsupportedError("CssStyleDeclarationBase.borderBottom= is unsupported on this platform."); }   String get borderBottomColor { throw new UnsupportedError("CssStyleDeclarationBase.borderBottomColor is unsupported on this platform."); }   void set borderBottomColor(String value) { throw new UnsupportedError("CssStyleDeclarationBase.borderBottomColor= is unsupported on this platform."); }   String get borderBottomLeftRadius { throw new UnsupportedError("CssStyleDeclarationBase.borderBottomLeftRadius is unsupported on this platform."); }   void set borderBottomLeftRadius(String value) { throw new UnsupportedError("CssStyleDeclarationBase.borderBottomLeftRadius= is unsupported on this platform."); }   String get borderBottomRightRadius { throw new UnsupportedError("CssStyleDeclarationBase.borderBottomRightRadius is unsupported on this platform."); }   void set borderBottomRightRadius(String value) { throw new UnsupportedError("CssStyleDeclarationBase.borderBottomRightRadius= is unsupported on this platform."); }   String get borderBottomStyle { throw new UnsupportedError("CssStyleDeclarationBase.borderBottomStyle is unsupported on this platform."); }   void set borderBottomStyle(String value) { throw new UnsupportedError("CssStyleDeclarationBase.borderBottomStyle= is unsupported on this platform."); }   String get borderBottomWidth { throw new UnsupportedError("CssStyleDeclarationBase.borderBottomWidth is unsupported on this platform."); }   void set borderBottomWidth(String value) { throw new UnsupportedError("CssStyleDeclarationBase.borderBottomWidth= is unsupported on this platform."); }   String get borderCollapse { throw new UnsupportedError("CssStyleDeclarationBase.borderCollapse is unsupported on this platform."); }   void set borderCollapse(String value) { throw new UnsupportedError("CssStyleDeclarationBase.borderCollapse= is unsupported on this platform."); }   String get borderColor { throw new UnsupportedError("CssStyleDeclarationBase.borderColor is unsupported on this platform."); }   void set borderColor(String value) { throw new UnsupportedError("CssStyleDeclarationBase.borderColor= is unsupported on this platform."); }   String get borderEnd { throw new UnsupportedError("CssStyleDeclarationBase.borderEnd is unsupported on this platform."); }   void set borderEnd(String value) { throw new UnsupportedError("CssStyleDeclarationBase.borderEnd= is unsupported on this platform."); }   String get borderEndColor { throw new UnsupportedError("CssStyleDeclarationBase.borderEndColor is unsupported on this platform."); }   void set borderEndColor(String value) { throw new UnsupportedError("CssStyleDeclarationBase.borderEndColor= is unsupported on this platform."); }   String get borderEndStyle { throw new UnsupportedError("CssStyleDeclarationBase.borderEndStyle is unsupported on this platform."); }   void set borderEndStyle(String value) { throw new UnsupportedError("CssStyleDeclarationBase.borderEndStyle= is unsupported on this platform."); }   String get borderEndWidth { throw new UnsupportedError("CssStyleDeclarationBase.borderEndWidth is unsupported on this platform."); }   void set borderEndWidth(String value) { throw new UnsupportedError("CssStyleDeclarationBase.borderEndWidth= is unsupported on this platform."); }   String get borderFit { throw new UnsupportedError("CssStyleDeclarationBase.borderFit is unsupported on this platform."); }   void set borderFit(String value) { throw new UnsupportedError("CssStyleDeclarationBase.borderFit= is unsupported on this platform."); }   String get borderHorizontalSpacing { throw new UnsupportedError("CssStyleDeclarationBase.borderHorizontalSpacing is unsupported on this platform."); }   void set borderHorizontalSpacing(String value) { throw new UnsupportedError("CssStyleDeclarationBase.borderHorizontalSpacing= is unsupported on this platform."); }   String get borderImage { throw new UnsupportedError("CssStyleDeclarationBase.borderImage is unsupported on this platform."); }   void set borderImage(String value) { throw new UnsupportedError("CssStyleDeclarationBase.borderImage= is unsupported on this platform."); }   String get borderImageOutset { throw new UnsupportedError("CssStyleDeclarationBase.borderImageOutset is unsupported on this platform."); }   void set borderImageOutset(String value) { throw new UnsupportedError("CssStyleDeclarationBase.borderImageOutset= is unsupported on this platform."); }   String get borderImageRepeat { throw new UnsupportedError("CssStyleDeclarationBase.borderImageRepeat is unsupported on this platform."); }   void set borderImageRepeat(String value) { throw new UnsupportedError("CssStyleDeclarationBase.borderImageRepeat= is unsupported on this platform."); }   String get borderImageSlice { throw new UnsupportedError("CssStyleDeclarationBase.borderImageSlice is unsupported on this platform."); }   void set borderImageSlice(String value) { throw new UnsupportedError("CssStyleDeclarationBase.borderImageSlice= is unsupported on this platform."); }   String get borderImageSource { throw new UnsupportedError("CssStyleDeclarationBase.borderImageSource is unsupported on this platform."); }   void set borderImageSource(String value) { throw new UnsupportedError("CssStyleDeclarationBase.borderImageSource= is unsupported on this platform."); }   String get borderImageWidth { throw new UnsupportedError("CssStyleDeclarationBase.borderImageWidth is unsupported on this platform."); }   void set borderImageWidth(String value) { throw new UnsupportedError("CssStyleDeclarationBase.borderImageWidth= is unsupported on this platform."); }   String get borderLeft { throw new UnsupportedError("CssStyleDeclarationBase.borderLeft is unsupported on this platform."); }   void set borderLeft(String value) { throw new UnsupportedError("CssStyleDeclarationBase.borderLeft= is unsupported on this platform."); }   String get borderLeftColor { throw new UnsupportedError("CssStyleDeclarationBase.borderLeftColor is unsupported on this platform."); }   void set borderLeftColor(String value) { throw new UnsupportedError("CssStyleDeclarationBase.borderLeftColor= is unsupported on this platform."); }   String get borderLeftStyle { throw new UnsupportedError("CssStyleDeclarationBase.borderLeftStyle is unsupported on this platform."); }   void set borderLeftStyle(String value) { throw new UnsupportedError("CssStyleDeclarationBase.borderLeftStyle= is unsupported on this platform."); }   String get borderLeftWidth { throw new UnsupportedError("CssStyleDeclarationBase.borderLeftWidth is unsupported on this platform."); }   void set borderLeftWidth(String value) { throw new UnsupportedError("CssStyleDeclarationBase.borderLeftWidth= is unsupported on this platform."); }   String get borderRadius { throw new UnsupportedError("CssStyleDeclarationBase.borderRadius is unsupported on this platform."); }   void set borderRadius(String value) { throw new UnsupportedError("CssStyleDeclarationBase.borderRadius= is unsupported on this platform."); }   String get borderRight { throw new UnsupportedError("CssStyleDeclarationBase.borderRight is unsupported on this platform."); }   void set borderRight(String value) { throw new UnsupportedError("CssStyleDeclarationBase.borderRight= is unsupported on this platform."); }   String get borderRightColor { throw new UnsupportedError("CssStyleDeclarationBase.borderRightColor is unsupported on this platform."); }   void set borderRightColor(String value) { throw new UnsupportedError("CssStyleDeclarationBase.borderRightColor= is unsupported on this platform."); }   String get borderRightStyle { throw new UnsupportedError("CssStyleDeclarationBase.borderRightStyle is unsupported on this platform."); }   void set borderRightStyle(String value) { throw new UnsupportedError("CssStyleDeclarationBase.borderRightStyle= is unsupported on this platform."); }   String get borderRightWidth { throw new UnsupportedError("CssStyleDeclarationBase.borderRightWidth is unsupported on this platform."); }   void set borderRightWidth(String value) { throw new UnsupportedError("CssStyleDeclarationBase.borderRightWidth= is unsupported on this platform."); }   String get borderSpacing { throw new UnsupportedError("CssStyleDeclarationBase.borderSpacing is unsupported on this platform."); }   void set borderSpacing(String value) { throw new UnsupportedError("CssStyleDeclarationBase.borderSpacing= is unsupported on this platform."); }   String get borderStart { throw new UnsupportedError("CssStyleDeclarationBase.borderStart is unsupported on this platform."); }   void set borderStart(String value) { throw new UnsupportedError("CssStyleDeclarationBase.borderStart= is unsupported on this platform."); }   String get borderStartColor { throw new UnsupportedError("CssStyleDeclarationBase.borderStartColor is unsupported on this platform."); }   void set borderStartColor(String value) { throw new UnsupportedError("CssStyleDeclarationBase.borderStartColor= is unsupported on this platform."); }   String get borderStartStyle { throw new UnsupportedError("CssStyleDeclarationBase.borderStartStyle is unsupported on this platform."); }   void set borderStartStyle(String value) { throw new UnsupportedError("CssStyleDeclarationBase.borderStartStyle= is unsupported on this platform."); }   String get borderStartWidth { throw new UnsupportedError("CssStyleDeclarationBase.borderStartWidth is unsupported on this platform."); }   void set borderStartWidth(String value) { throw new UnsupportedError("CssStyleDeclarationBase.borderStartWidth= is unsupported on this platform."); }   String get borderStyle { throw new UnsupportedError("CssStyleDeclarationBase.borderStyle is unsupported on this platform."); }   void set borderStyle(String value) { throw new UnsupportedError("CssStyleDeclarationBase.borderStyle= is unsupported on this platform."); }   String get borderTop { throw new UnsupportedError("CssStyleDeclarationBase.borderTop is unsupported on this platform."); }   void set borderTop(String value) { throw new UnsupportedError("CssStyleDeclarationBase.borderTop= is unsupported on this platform."); }   String get borderTopColor { throw new UnsupportedError("CssStyleDeclarationBase.borderTopColor is unsupported on this platform."); }   void set borderTopColor(String value) { throw new UnsupportedError("CssStyleDeclarationBase.borderTopColor= is unsupported on this platform."); }   String get borderTopLeftRadius { throw new UnsupportedError("CssStyleDeclarationBase.borderTopLeftRadius is unsupported on this platform."); }   void set borderTopLeftRadius(String value) { throw new UnsupportedError("CssStyleDeclarationBase.borderTopLeftRadius= is unsupported on this platform."); }   String get borderTopRightRadius { throw new UnsupportedError("CssStyleDeclarationBase.borderTopRightRadius is unsupported on this platform."); }   void set borderTopRightRadius(String value) { throw new UnsupportedError("CssStyleDeclarationBase.borderTopRightRadius= is unsupported on this platform."); }   String get borderTopStyle { throw new UnsupportedError("CssStyleDeclarationBase.borderTopStyle is unsupported on this platform."); }   void set borderTopStyle(String value) { throw new UnsupportedError("CssStyleDeclarationBase.borderTopStyle= is unsupported on this platform."); }   String get borderTopWidth { throw new UnsupportedError("CssStyleDeclarationBase.borderTopWidth is unsupported on this platform."); }   void set borderTopWidth(String value) { throw new UnsupportedError("CssStyleDeclarationBase.borderTopWidth= is unsupported on this platform."); }   String get borderVerticalSpacing { throw new UnsupportedError("CssStyleDeclarationBase.borderVerticalSpacing is unsupported on this platform."); }   void set borderVerticalSpacing(String value) { throw new UnsupportedError("CssStyleDeclarationBase.borderVerticalSpacing= is unsupported on this platform."); }   String get borderWidth { throw new UnsupportedError("CssStyleDeclarationBase.borderWidth is unsupported on this platform."); }   void set borderWidth(String value) { throw new UnsupportedError("CssStyleDeclarationBase.borderWidth= is unsupported on this platform."); }   String get bottom { throw new UnsupportedError("CssStyleDeclarationBase.bottom is unsupported on this platform."); }   void set bottom(String value) { throw new UnsupportedError("CssStyleDeclarationBase.bottom= is unsupported on this platform."); }   String get boxAlign { throw new UnsupportedError("CssStyleDeclarationBase.boxAlign is unsupported on this platform."); }   void set boxAlign(String value) { throw new UnsupportedError("CssStyleDeclarationBase.boxAlign= is unsupported on this platform."); }   String get boxDecorationBreak { throw new UnsupportedError("CssStyleDeclarationBase.boxDecorationBreak is unsupported on this platform."); }   void set boxDecorationBreak(String value) { throw new UnsupportedError("CssStyleDeclarationBase.boxDecorationBreak= is unsupported on this platform."); }   String get boxDirection { throw new UnsupportedError("CssStyleDeclarationBase.boxDirection is unsupported on this platform."); }   void set boxDirection(String value) { throw new UnsupportedError("CssStyleDeclarationBase.boxDirection= is unsupported on this platform."); }   String get boxFlex { throw new UnsupportedError("CssStyleDeclarationBase.boxFlex is unsupported on this platform."); }   void set boxFlex(String value) { throw new UnsupportedError("CssStyleDeclarationBase.boxFlex= is unsupported on this platform."); }   String get boxFlexGroup { throw new UnsupportedError("CssStyleDeclarationBase.boxFlexGroup is unsupported on this platform."); }   void set boxFlexGroup(String value) { throw new UnsupportedError("CssStyleDeclarationBase.boxFlexGroup= is unsupported on this platform."); }   String get boxLines { throw new UnsupportedError("CssStyleDeclarationBase.boxLines is unsupported on this platform."); }   void set boxLines(String value) { throw new UnsupportedError("CssStyleDeclarationBase.boxLines= is unsupported on this platform."); }   String get boxOrdinalGroup { throw new UnsupportedError("CssStyleDeclarationBase.boxOrdinalGroup is unsupported on this platform."); }   void set boxOrdinalGroup(String value) { throw new UnsupportedError("CssStyleDeclarationBase.boxOrdinalGroup= is unsupported on this platform."); }   String get boxOrient { throw new UnsupportedError("CssStyleDeclarationBase.boxOrient is unsupported on this platform."); }   void set boxOrient(String value) { throw new UnsupportedError("CssStyleDeclarationBase.boxOrient= is unsupported on this platform."); }   String get boxPack { throw new UnsupportedError("CssStyleDeclarationBase.boxPack is unsupported on this platform."); }   void set boxPack(String value) { throw new UnsupportedError("CssStyleDeclarationBase.boxPack= is unsupported on this platform."); }   String get boxReflect { throw new UnsupportedError("CssStyleDeclarationBase.boxReflect is unsupported on this platform."); }   void set boxReflect(String value) { throw new UnsupportedError("CssStyleDeclarationBase.boxReflect= is unsupported on this platform."); }   String get boxShadow { throw new UnsupportedError("CssStyleDeclarationBase.boxShadow is unsupported on this platform."); }   void set boxShadow(String value) { throw new UnsupportedError("CssStyleDeclarationBase.boxShadow= is unsupported on this platform."); }   String get boxSizing { throw new UnsupportedError("CssStyleDeclarationBase.boxSizing is unsupported on this platform."); }   void set boxSizing(String value) { throw new UnsupportedError("CssStyleDeclarationBase.boxSizing= is unsupported on this platform."); }   String get captionSide { throw new UnsupportedError("CssStyleDeclarationBase.captionSide is unsupported on this platform."); }   void set captionSide(String value) { throw new UnsupportedError("CssStyleDeclarationBase.captionSide= is unsupported on this platform."); }   String get clear { throw new UnsupportedError("CssStyleDeclarationBase.clear is unsupported on this platform."); }   void set clear(String value) { throw new UnsupportedError("CssStyleDeclarationBase.clear= is unsupported on this platform."); }   String get clip { throw new UnsupportedError("CssStyleDeclarationBase.clip is unsupported on this platform."); }   void set clip(String value) { throw new UnsupportedError("CssStyleDeclarationBase.clip= is unsupported on this platform."); }   String get clipPath { throw new UnsupportedError("CssStyleDeclarationBase.clipPath is unsupported on this platform."); }   void set clipPath(String value) { throw new UnsupportedError("CssStyleDeclarationBase.clipPath= is unsupported on this platform."); }   String get color { throw new UnsupportedError("CssStyleDeclarationBase.color is unsupported on this platform."); }   void set color(String value) { throw new UnsupportedError("CssStyleDeclarationBase.color= is unsupported on this platform."); }   String get columnBreakAfter { throw new UnsupportedError("CssStyleDeclarationBase.columnBreakAfter is unsupported on this platform."); }   void set columnBreakAfter(String value) { throw new UnsupportedError("CssStyleDeclarationBase.columnBreakAfter= is unsupported on this platform."); }   String get columnBreakBefore { throw new UnsupportedError("CssStyleDeclarationBase.columnBreakBefore is unsupported on this platform."); }   void set columnBreakBefore(String value) { throw new UnsupportedError("CssStyleDeclarationBase.columnBreakBefore= is unsupported on this platform."); }   String get columnBreakInside { throw new UnsupportedError("CssStyleDeclarationBase.columnBreakInside is unsupported on this platform."); }   void set columnBreakInside(String value) { throw new UnsupportedError("CssStyleDeclarationBase.columnBreakInside= is unsupported on this platform."); }   String get columnCount { throw new UnsupportedError("CssStyleDeclarationBase.columnCount is unsupported on this platform."); }   void set columnCount(String value) { throw new UnsupportedError("CssStyleDeclarationBase.columnCount= is unsupported on this platform."); }   String get columnFill { throw new UnsupportedError("CssStyleDeclarationBase.columnFill is unsupported on this platform."); }   void set columnFill(String value) { throw new UnsupportedError("CssStyleDeclarationBase.columnFill= is unsupported on this platform."); }   String get columnGap { throw new UnsupportedError("CssStyleDeclarationBase.columnGap is unsupported on this platform."); }   void set columnGap(String value) { throw new UnsupportedError("CssStyleDeclarationBase.columnGap= is unsupported on this platform."); }   String get columnRule { throw new UnsupportedError("CssStyleDeclarationBase.columnRule is unsupported on this platform."); }   void set columnRule(String value) { throw new UnsupportedError("CssStyleDeclarationBase.columnRule= is unsupported on this platform."); }   String get columnRuleColor { throw new UnsupportedError("CssStyleDeclarationBase.columnRuleColor is unsupported on this platform."); }   void set columnRuleColor(String value) { throw new UnsupportedError("CssStyleDeclarationBase.columnRuleColor= is unsupported on this platform."); }   String get columnRuleStyle { throw new UnsupportedError("CssStyleDeclarationBase.columnRuleStyle is unsupported on this platform."); }   void set columnRuleStyle(String value) { throw new UnsupportedError("CssStyleDeclarationBase.columnRuleStyle= is unsupported on this platform."); }   String get columnRuleWidth { throw new UnsupportedError("CssStyleDeclarationBase.columnRuleWidth is unsupported on this platform."); }   void set columnRuleWidth(String value) { throw new UnsupportedError("CssStyleDeclarationBase.columnRuleWidth= is unsupported on this platform."); }   String get columnSpan { throw new UnsupportedError("CssStyleDeclarationBase.columnSpan is unsupported on this platform."); }   void set columnSpan(String value) { throw new UnsupportedError("CssStyleDeclarationBase.columnSpan= is unsupported on this platform."); }   String get columnWidth { throw new UnsupportedError("CssStyleDeclarationBase.columnWidth is unsupported on this platform."); }   void set columnWidth(String value) { throw new UnsupportedError("CssStyleDeclarationBase.columnWidth= is unsupported on this platform."); }   String get columns { throw new UnsupportedError("CssStyleDeclarationBase.columns is unsupported on this platform."); }   void set columns(String value) { throw new UnsupportedError("CssStyleDeclarationBase.columns= is unsupported on this platform."); }   String get content { throw new UnsupportedError("CssStyleDeclarationBase.content is unsupported on this platform."); }   void set content(String value) { throw new UnsupportedError("CssStyleDeclarationBase.content= is unsupported on this platform."); }   String get counterIncrement { throw new UnsupportedError("CssStyleDeclarationBase.counterIncrement is unsupported on this platform."); }   void set counterIncrement(String value) { throw new UnsupportedError("CssStyleDeclarationBase.counterIncrement= is unsupported on this platform."); }   String get counterReset { throw new UnsupportedError("CssStyleDeclarationBase.counterReset is unsupported on this platform."); }   void set counterReset(String value) { throw new UnsupportedError("CssStyleDeclarationBase.counterReset= is unsupported on this platform."); }   String get cursor { throw new UnsupportedError("CssStyleDeclarationBase.cursor is unsupported on this platform."); }   void set cursor(String value) { throw new UnsupportedError("CssStyleDeclarationBase.cursor= is unsupported on this platform."); }   String get direction { throw new UnsupportedError("CssStyleDeclarationBase.direction is unsupported on this platform."); }   void set direction(String value) { throw new UnsupportedError("CssStyleDeclarationBase.direction= is unsupported on this platform."); }   String get display { throw new UnsupportedError("CssStyleDeclarationBase.display is unsupported on this platform."); }   void set display(String value) { throw new UnsupportedError("CssStyleDeclarationBase.display= is unsupported on this platform."); }   String get emptyCells { throw new UnsupportedError("CssStyleDeclarationBase.emptyCells is unsupported on this platform."); }   void set emptyCells(String value) { throw new UnsupportedError("CssStyleDeclarationBase.emptyCells= is unsupported on this platform."); }   String get filter { throw new UnsupportedError("CssStyleDeclarationBase.filter is unsupported on this platform."); }   void set filter(String value) { throw new UnsupportedError("CssStyleDeclarationBase.filter= is unsupported on this platform."); }   String get flex { throw new UnsupportedError("CssStyleDeclarationBase.flex is unsupported on this platform."); }   void set flex(String value) { throw new UnsupportedError("CssStyleDeclarationBase.flex= is unsupported on this platform."); }   String get flexBasis { throw new UnsupportedError("CssStyleDeclarationBase.flexBasis is unsupported on this platform."); }   void set flexBasis(String value) { throw new UnsupportedError("CssStyleDeclarationBase.flexBasis= is unsupported on this platform."); }   String get flexDirection { throw new UnsupportedError("CssStyleDeclarationBase.flexDirection is unsupported on this platform."); }   void set flexDirection(String value) { throw new UnsupportedError("CssStyleDeclarationBase.flexDirection= is unsupported on this platform."); }   String get flexFlow { throw new UnsupportedError("CssStyleDeclarationBase.flexFlow is unsupported on this platform."); }   void set flexFlow(String value) { throw new UnsupportedError("CssStyleDeclarationBase.flexFlow= is unsupported on this platform."); }   String get flexGrow { throw new UnsupportedError("CssStyleDeclarationBase.flexGrow is unsupported on this platform."); }   void set flexGrow(String value) { throw new UnsupportedError("CssStyleDeclarationBase.flexGrow= is unsupported on this platform."); }   String get flexShrink { throw new UnsupportedError("CssStyleDeclarationBase.flexShrink is unsupported on this platform."); }   void set flexShrink(String value) { throw new UnsupportedError("CssStyleDeclarationBase.flexShrink= is unsupported on this platform."); }   String get flexWrap { throw new UnsupportedError("CssStyleDeclarationBase.flexWrap is unsupported on this platform."); }   void set flexWrap(String value) { throw new UnsupportedError("CssStyleDeclarationBase.flexWrap= is unsupported on this platform."); }   String get float { throw new UnsupportedError("CssStyleDeclarationBase.float is unsupported on this platform."); }   void set float(String value) { throw new UnsupportedError("CssStyleDeclarationBase.float= is unsupported on this platform."); }   String get font { throw new UnsupportedError("CssStyleDeclarationBase.font is unsupported on this platform."); }   void set font(String value) { throw new UnsupportedError("CssStyleDeclarationBase.font= is unsupported on this platform."); }   String get fontFamily { throw new UnsupportedError("CssStyleDeclarationBase.fontFamily is unsupported on this platform."); }   void set fontFamily(String value) { throw new UnsupportedError("CssStyleDeclarationBase.fontFamily= is unsupported on this platform."); }   String get fontFeatureSettings { throw new UnsupportedError("CssStyleDeclarationBase.fontFeatureSettings is unsupported on this platform."); }   void set fontFeatureSettings(String value) { throw new UnsupportedError("CssStyleDeclarationBase.fontFeatureSettings= is unsupported on this platform."); }   String get fontKerning { throw new UnsupportedError("CssStyleDeclarationBase.fontKerning is unsupported on this platform."); }   void set fontKerning(String value) { throw new UnsupportedError("CssStyleDeclarationBase.fontKerning= is unsupported on this platform."); }   String get fontSize { throw new UnsupportedError("CssStyleDeclarationBase.fontSize is unsupported on this platform."); }   void set fontSize(String value) { throw new UnsupportedError("CssStyleDeclarationBase.fontSize= is unsupported on this platform."); }   String get fontSizeDelta { throw new UnsupportedError("CssStyleDeclarationBase.fontSizeDelta is unsupported on this platform."); }   void set fontSizeDelta(String value) { throw new UnsupportedError("CssStyleDeclarationBase.fontSizeDelta= is unsupported on this platform."); }   String get fontSmoothing { throw new UnsupportedError("CssStyleDeclarationBase.fontSmoothing is unsupported on this platform."); }   void set fontSmoothing(String value) { throw new UnsupportedError("CssStyleDeclarationBase.fontSmoothing= is unsupported on this platform."); }   String get fontStretch { throw new UnsupportedError("CssStyleDeclarationBase.fontStretch is unsupported on this platform."); }   void set fontStretch(String value) { throw new UnsupportedError("CssStyleDeclarationBase.fontStretch= is unsupported on this platform."); }   String get fontStyle { throw new UnsupportedError("CssStyleDeclarationBase.fontStyle is unsupported on this platform."); }   void set fontStyle(String value) { throw new UnsupportedError("CssStyleDeclarationBase.fontStyle= is unsupported on this platform."); }   String get fontVariant { throw new UnsupportedError("CssStyleDeclarationBase.fontVariant is unsupported on this platform."); }   void set fontVariant(String value) { throw new UnsupportedError("CssStyleDeclarationBase.fontVariant= is unsupported on this platform."); }   String get fontVariantLigatures { throw new UnsupportedError("CssStyleDeclarationBase.fontVariantLigatures is unsupported on this platform."); }   void set fontVariantLigatures(String value) { throw new UnsupportedError("CssStyleDeclarationBase.fontVariantLigatures= is unsupported on this platform."); }   String get fontWeight { throw new UnsupportedError("CssStyleDeclarationBase.fontWeight is unsupported on this platform."); }   void set fontWeight(String value) { throw new UnsupportedError("CssStyleDeclarationBase.fontWeight= is unsupported on this platform."); }   String get grid { throw new UnsupportedError("CssStyleDeclarationBase.grid is unsupported on this platform."); }   void set grid(String value) { throw new UnsupportedError("CssStyleDeclarationBase.grid= is unsupported on this platform."); }   String get gridArea { throw new UnsupportedError("CssStyleDeclarationBase.gridArea is unsupported on this platform."); }   void set gridArea(String value) { throw new UnsupportedError("CssStyleDeclarationBase.gridArea= is unsupported on this platform."); }   String get gridAutoColumns { throw new UnsupportedError("CssStyleDeclarationBase.gridAutoColumns is unsupported on this platform."); }   void set gridAutoColumns(String value) { throw new UnsupportedError("CssStyleDeclarationBase.gridAutoColumns= is unsupported on this platform."); }   String get gridAutoFlow { throw new UnsupportedError("CssStyleDeclarationBase.gridAutoFlow is unsupported on this platform."); }   void set gridAutoFlow(String value) { throw new UnsupportedError("CssStyleDeclarationBase.gridAutoFlow= is unsupported on this platform."); }   String get gridAutoRows { throw new UnsupportedError("CssStyleDeclarationBase.gridAutoRows is unsupported on this platform."); }   void set gridAutoRows(String value) { throw new UnsupportedError("CssStyleDeclarationBase.gridAutoRows= is unsupported on this platform."); }   String get gridColumn { throw new UnsupportedError("CssStyleDeclarationBase.gridColumn is unsupported on this platform."); }   void set gridColumn(String value) { throw new UnsupportedError("CssStyleDeclarationBase.gridColumn= is unsupported on this platform."); }   String get gridColumnEnd { throw new UnsupportedError("CssStyleDeclarationBase.gridColumnEnd is unsupported on this platform."); }   void set gridColumnEnd(String value) { throw new UnsupportedError("CssStyleDeclarationBase.gridColumnEnd= is unsupported on this platform."); }   String get gridColumnStart { throw new UnsupportedError("CssStyleDeclarationBase.gridColumnStart is unsupported on this platform."); }   void set gridColumnStart(String value) { throw new UnsupportedError("CssStyleDeclarationBase.gridColumnStart= is unsupported on this platform."); }   String get gridRow { throw new UnsupportedError("CssStyleDeclarationBase.gridRow is unsupported on this platform."); }   void set gridRow(String value) { throw new UnsupportedError("CssStyleDeclarationBase.gridRow= is unsupported on this platform."); }   String get gridRowEnd { throw new UnsupportedError("CssStyleDeclarationBase.gridRowEnd is unsupported on this platform."); }   void set gridRowEnd(String value) { throw new UnsupportedError("CssStyleDeclarationBase.gridRowEnd= is unsupported on this platform."); }   String get gridRowStart { throw new UnsupportedError("CssStyleDeclarationBase.gridRowStart is unsupported on this platform."); }   void set gridRowStart(String value) { throw new UnsupportedError("CssStyleDeclarationBase.gridRowStart= is unsupported on this platform."); }   String get gridTemplate { throw new UnsupportedError("CssStyleDeclarationBase.gridTemplate is unsupported on this platform."); }   void set gridTemplate(String value) { throw new UnsupportedError("CssStyleDeclarationBase.gridTemplate= is unsupported on this platform."); }   String get gridTemplateAreas { throw new UnsupportedError("CssStyleDeclarationBase.gridTemplateAreas is unsupported on this platform."); }   void set gridTemplateAreas(String value) { throw new UnsupportedError("CssStyleDeclarationBase.gridTemplateAreas= is unsupported on this platform."); }   String get gridTemplateColumns { throw new UnsupportedError("CssStyleDeclarationBase.gridTemplateColumns is unsupported on this platform."); }   void set gridTemplateColumns(String value) { throw new UnsupportedError("CssStyleDeclarationBase.gridTemplateColumns= is unsupported on this platform."); }   String get gridTemplateRows { throw new UnsupportedError("CssStyleDeclarationBase.gridTemplateRows is unsupported on this platform."); }   void set gridTemplateRows(String value) { throw new UnsupportedError("CssStyleDeclarationBase.gridTemplateRows= is unsupported on this platform."); }   String get height { throw new UnsupportedError("CssStyleDeclarationBase.height is unsupported on this platform."); }   void set height(String value) { throw new UnsupportedError("CssStyleDeclarationBase.height= is unsupported on this platform."); }   String get highlight { throw new UnsupportedError("CssStyleDeclarationBase.highlight is unsupported on this platform."); }   void set highlight(String value) { throw new UnsupportedError("CssStyleDeclarationBase.highlight= is unsupported on this platform."); }   String get hyphenateCharacter { throw new UnsupportedError("CssStyleDeclarationBase.hyphenateCharacter is unsupported on this platform."); }   void set hyphenateCharacter(String value) { throw new UnsupportedError("CssStyleDeclarationBase.hyphenateCharacter= is unsupported on this platform."); }   String get imageRendering { throw new UnsupportedError("CssStyleDeclarationBase.imageRendering is unsupported on this platform."); }   void set imageRendering(String value) { throw new UnsupportedError("CssStyleDeclarationBase.imageRendering= is unsupported on this platform."); }   String get isolation { throw new UnsupportedError("CssStyleDeclarationBase.isolation is unsupported on this platform."); }   void set isolation(String value) { throw new UnsupportedError("CssStyleDeclarationBase.isolation= is unsupported on this platform."); }   String get justifyContent { throw new UnsupportedError("CssStyleDeclarationBase.justifyContent is unsupported on this platform."); }   void set justifyContent(String value) { throw new UnsupportedError("CssStyleDeclarationBase.justifyContent= is unsupported on this platform."); }   String get justifySelf { throw new UnsupportedError("CssStyleDeclarationBase.justifySelf is unsupported on this platform."); }   void set justifySelf(String value) { throw new UnsupportedError("CssStyleDeclarationBase.justifySelf= is unsupported on this platform."); }   String get left { throw new UnsupportedError("CssStyleDeclarationBase.left is unsupported on this platform."); }   void set left(String value) { throw new UnsupportedError("CssStyleDeclarationBase.left= is unsupported on this platform."); }   String get letterSpacing { throw new UnsupportedError("CssStyleDeclarationBase.letterSpacing is unsupported on this platform."); }   void set letterSpacing(String value) { throw new UnsupportedError("CssStyleDeclarationBase.letterSpacing= is unsupported on this platform."); }   String get lineBoxContain { throw new UnsupportedError("CssStyleDeclarationBase.lineBoxContain is unsupported on this platform."); }   void set lineBoxContain(String value) { throw new UnsupportedError("CssStyleDeclarationBase.lineBoxContain= is unsupported on this platform."); }   String get lineBreak { throw new UnsupportedError("CssStyleDeclarationBase.lineBreak is unsupported on this platform."); }   void set lineBreak(String value) { throw new UnsupportedError("CssStyleDeclarationBase.lineBreak= is unsupported on this platform."); }   String get lineClamp { throw new UnsupportedError("CssStyleDeclarationBase.lineClamp is unsupported on this platform."); }   void set lineClamp(String value) { throw new UnsupportedError("CssStyleDeclarationBase.lineClamp= is unsupported on this platform."); }   String get lineHeight { throw new UnsupportedError("CssStyleDeclarationBase.lineHeight is unsupported on this platform."); }   void set lineHeight(String value) { throw new UnsupportedError("CssStyleDeclarationBase.lineHeight= is unsupported on this platform."); }   String get listStyle { throw new UnsupportedError("CssStyleDeclarationBase.listStyle is unsupported on this platform."); }   void set listStyle(String value) { throw new UnsupportedError("CssStyleDeclarationBase.listStyle= is unsupported on this platform."); }   String get listStyleImage { throw new UnsupportedError("CssStyleDeclarationBase.listStyleImage is unsupported on this platform."); }   void set listStyleImage(String value) { throw new UnsupportedError("CssStyleDeclarationBase.listStyleImage= is unsupported on this platform."); }   String get listStylePosition { throw new UnsupportedError("CssStyleDeclarationBase.listStylePosition is unsupported on this platform."); }   void set listStylePosition(String value) { throw new UnsupportedError("CssStyleDeclarationBase.listStylePosition= is unsupported on this platform."); }   String get listStyleType { throw new UnsupportedError("CssStyleDeclarationBase.listStyleType is unsupported on this platform."); }   void set listStyleType(String value) { throw new UnsupportedError("CssStyleDeclarationBase.listStyleType= is unsupported on this platform."); }   String get locale { throw new UnsupportedError("CssStyleDeclarationBase.locale is unsupported on this platform."); }   void set locale(String value) { throw new UnsupportedError("CssStyleDeclarationBase.locale= is unsupported on this platform."); }   String get logicalHeight { throw new UnsupportedError("CssStyleDeclarationBase.logicalHeight is unsupported on this platform."); }   void set logicalHeight(String value) { throw new UnsupportedError("CssStyleDeclarationBase.logicalHeight= is unsupported on this platform."); }   String get logicalWidth { throw new UnsupportedError("CssStyleDeclarationBase.logicalWidth is unsupported on this platform."); }   void set logicalWidth(String value) { throw new UnsupportedError("CssStyleDeclarationBase.logicalWidth= is unsupported on this platform."); }   String get margin { throw new UnsupportedError("CssStyleDeclarationBase.margin is unsupported on this platform."); }   void set margin(String value) { throw new UnsupportedError("CssStyleDeclarationBase.margin= is unsupported on this platform."); }   String get marginAfter { throw new UnsupportedError("CssStyleDeclarationBase.marginAfter is unsupported on this platform."); }   void set marginAfter(String value) { throw new UnsupportedError("CssStyleDeclarationBase.marginAfter= is unsupported on this platform."); }   String get marginAfterCollapse { throw new UnsupportedError("CssStyleDeclarationBase.marginAfterCollapse is unsupported on this platform."); }   void set marginAfterCollapse(String value) { throw new UnsupportedError("CssStyleDeclarationBase.marginAfterCollapse= is unsupported on this platform."); }   String get marginBefore { throw new UnsupportedError("CssStyleDeclarationBase.marginBefore is unsupported on this platform."); }   void set marginBefore(String value) { throw new UnsupportedError("CssStyleDeclarationBase.marginBefore= is unsupported on this platform."); }   String get marginBeforeCollapse { throw new UnsupportedError("CssStyleDeclarationBase.marginBeforeCollapse is unsupported on this platform."); }   void set marginBeforeCollapse(String value) { throw new UnsupportedError("CssStyleDeclarationBase.marginBeforeCollapse= is unsupported on this platform."); }   String get marginBottom { throw new UnsupportedError("CssStyleDeclarationBase.marginBottom is unsupported on this platform."); }   void set marginBottom(String value) { throw new UnsupportedError("CssStyleDeclarationBase.marginBottom= is unsupported on this platform."); }   String get marginBottomCollapse { throw new UnsupportedError("CssStyleDeclarationBase.marginBottomCollapse is unsupported on this platform."); }   void set marginBottomCollapse(String value) { throw new UnsupportedError("CssStyleDeclarationBase.marginBottomCollapse= is unsupported on this platform."); }   String get marginCollapse { throw new UnsupportedError("CssStyleDeclarationBase.marginCollapse is unsupported on this platform."); }   void set marginCollapse(String value) { throw new UnsupportedError("CssStyleDeclarationBase.marginCollapse= is unsupported on this platform."); }   String get marginEnd { throw new UnsupportedError("CssStyleDeclarationBase.marginEnd is unsupported on this platform."); }   void set marginEnd(String value) { throw new UnsupportedError("CssStyleDeclarationBase.marginEnd= is unsupported on this platform."); }   String get marginLeft { throw new UnsupportedError("CssStyleDeclarationBase.marginLeft is unsupported on this platform."); }   void set marginLeft(String value) { throw new UnsupportedError("CssStyleDeclarationBase.marginLeft= is unsupported on this platform."); }   String get marginRight { throw new UnsupportedError("CssStyleDeclarationBase.marginRight is unsupported on this platform."); }   void set marginRight(String value) { throw new UnsupportedError("CssStyleDeclarationBase.marginRight= is unsupported on this platform."); }   String get marginStart { throw new UnsupportedError("CssStyleDeclarationBase.marginStart is unsupported on this platform."); }   void set marginStart(String value) { throw new UnsupportedError("CssStyleDeclarationBase.marginStart= is unsupported on this platform."); }   String get marginTop { throw new UnsupportedError("CssStyleDeclarationBase.marginTop is unsupported on this platform."); }   void set marginTop(String value) { throw new UnsupportedError("CssStyleDeclarationBase.marginTop= is unsupported on this platform."); }   String get marginTopCollapse { throw new UnsupportedError("CssStyleDeclarationBase.marginTopCollapse is unsupported on this platform."); }   void set marginTopCollapse(String value) { throw new UnsupportedError("CssStyleDeclarationBase.marginTopCollapse= is unsupported on this platform."); }   String get mask { throw new UnsupportedError("CssStyleDeclarationBase.mask is unsupported on this platform."); }   void set mask(String value) { throw new UnsupportedError("CssStyleDeclarationBase.mask= is unsupported on this platform."); }   String get maskBoxImage { throw new UnsupportedError("CssStyleDeclarationBase.maskBoxImage is unsupported on this platform."); }   void set maskBoxImage(String value) { throw new UnsupportedError("CssStyleDeclarationBase.maskBoxImage= is unsupported on this platform."); }   String get maskBoxImageOutset { throw new UnsupportedError("CssStyleDeclarationBase.maskBoxImageOutset is unsupported on this platform."); }   void set maskBoxImageOutset(String value) { throw new UnsupportedError("CssStyleDeclarationBase.maskBoxImageOutset= is unsupported on this platform."); }   String get maskBoxImageRepeat { throw new UnsupportedError("CssStyleDeclarationBase.maskBoxImageRepeat is unsupported on this platform."); }   void set maskBoxImageRepeat(String value) { throw new UnsupportedError("CssStyleDeclarationBase.maskBoxImageRepeat= is unsupported on this platform."); }   String get maskBoxImageSlice { throw new UnsupportedError("CssStyleDeclarationBase.maskBoxImageSlice is unsupported on this platform."); }   void set maskBoxImageSlice(String value) { throw new UnsupportedError("CssStyleDeclarationBase.maskBoxImageSlice= is unsupported on this platform."); }   String get maskBoxImageSource { throw new UnsupportedError("CssStyleDeclarationBase.maskBoxImageSource is unsupported on this platform."); }   void set maskBoxImageSource(String value) { throw new UnsupportedError("CssStyleDeclarationBase.maskBoxImageSource= is unsupported on this platform."); }   String get maskBoxImageWidth { throw new UnsupportedError("CssStyleDeclarationBase.maskBoxImageWidth is unsupported on this platform."); }   void set maskBoxImageWidth(String value) { throw new UnsupportedError("CssStyleDeclarationBase.maskBoxImageWidth= is unsupported on this platform."); }   String get maskClip { throw new UnsupportedError("CssStyleDeclarationBase.maskClip is unsupported on this platform."); }   void set maskClip(String value) { throw new UnsupportedError("CssStyleDeclarationBase.maskClip= is unsupported on this platform."); }   String get maskComposite { throw new UnsupportedError("CssStyleDeclarationBase.maskComposite is unsupported on this platform."); }   void set maskComposite(String value) { throw new UnsupportedError("CssStyleDeclarationBase.maskComposite= is unsupported on this platform."); }   String get maskImage { throw new UnsupportedError("CssStyleDeclarationBase.maskImage is unsupported on this platform."); }   void set maskImage(String value) { throw new UnsupportedError("CssStyleDeclarationBase.maskImage= is unsupported on this platform."); }   String get maskOrigin { throw new UnsupportedError("CssStyleDeclarationBase.maskOrigin is unsupported on this platform."); }   void set maskOrigin(String value) { throw new UnsupportedError("CssStyleDeclarationBase.maskOrigin= is unsupported on this platform."); }   String get maskPosition { throw new UnsupportedError("CssStyleDeclarationBase.maskPosition is unsupported on this platform."); }   void set maskPosition(String value) { throw new UnsupportedError("CssStyleDeclarationBase.maskPosition= is unsupported on this platform."); }   String get maskPositionX { throw new UnsupportedError("CssStyleDeclarationBase.maskPositionX is unsupported on this platform."); }   void set maskPositionX(String value) { throw new UnsupportedError("CssStyleDeclarationBase.maskPositionX= is unsupported on this platform."); }   String get maskPositionY { throw new UnsupportedError("CssStyleDeclarationBase.maskPositionY is unsupported on this platform."); }   void set maskPositionY(String value) { throw new UnsupportedError("CssStyleDeclarationBase.maskPositionY= is unsupported on this platform."); }   String get maskRepeat { throw new UnsupportedError("CssStyleDeclarationBase.maskRepeat is unsupported on this platform."); }   void set maskRepeat(String value) { throw new UnsupportedError("CssStyleDeclarationBase.maskRepeat= is unsupported on this platform."); }   String get maskRepeatX { throw new UnsupportedError("CssStyleDeclarationBase.maskRepeatX is unsupported on this platform."); }   void set maskRepeatX(String value) { throw new UnsupportedError("CssStyleDeclarationBase.maskRepeatX= is unsupported on this platform."); }   String get maskRepeatY { throw new UnsupportedError("CssStyleDeclarationBase.maskRepeatY is unsupported on this platform."); }   void set maskRepeatY(String value) { throw new UnsupportedError("CssStyleDeclarationBase.maskRepeatY= is unsupported on this platform."); }   String get maskSize { throw new UnsupportedError("CssStyleDeclarationBase.maskSize is unsupported on this platform."); }   void set maskSize(String value) { throw new UnsupportedError("CssStyleDeclarationBase.maskSize= is unsupported on this platform."); }   String get maskSourceType { throw new UnsupportedError("CssStyleDeclarationBase.maskSourceType is unsupported on this platform."); }   void set maskSourceType(String value) { throw new UnsupportedError("CssStyleDeclarationBase.maskSourceType= is unsupported on this platform."); }   String get maxHeight { throw new UnsupportedError("CssStyleDeclarationBase.maxHeight is unsupported on this platform."); }   void set maxHeight(String value) { throw new UnsupportedError("CssStyleDeclarationBase.maxHeight= is unsupported on this platform."); }   String get maxLogicalHeight { throw new UnsupportedError("CssStyleDeclarationBase.maxLogicalHeight is unsupported on this platform."); }   void set maxLogicalHeight(String value) { throw new UnsupportedError("CssStyleDeclarationBase.maxLogicalHeight= is unsupported on this platform."); }   String get maxLogicalWidth { throw new UnsupportedError("CssStyleDeclarationBase.maxLogicalWidth is unsupported on this platform."); }   void set maxLogicalWidth(String value) { throw new UnsupportedError("CssStyleDeclarationBase.maxLogicalWidth= is unsupported on this platform."); }   String get maxWidth { throw new UnsupportedError("CssStyleDeclarationBase.maxWidth is unsupported on this platform."); }   void set maxWidth(String value) { throw new UnsupportedError("CssStyleDeclarationBase.maxWidth= is unsupported on this platform."); }   String get maxZoom { throw new UnsupportedError("CssStyleDeclarationBase.maxZoom is unsupported on this platform."); }   void set maxZoom(String value) { throw new UnsupportedError("CssStyleDeclarationBase.maxZoom= is unsupported on this platform."); }   String get minHeight { throw new UnsupportedError("CssStyleDeclarationBase.minHeight is unsupported on this platform."); }   void set minHeight(String value) { throw new UnsupportedError("CssStyleDeclarationBase.minHeight= is unsupported on this platform."); }   String get minLogicalHeight { throw new UnsupportedError("CssStyleDeclarationBase.minLogicalHeight is unsupported on this platform."); }   void set minLogicalHeight(String value) { throw new UnsupportedError("CssStyleDeclarationBase.minLogicalHeight= is unsupported on this platform."); }   String get minLogicalWidth { throw new UnsupportedError("CssStyleDeclarationBase.minLogicalWidth is unsupported on this platform."); }   void set minLogicalWidth(String value) { throw new UnsupportedError("CssStyleDeclarationBase.minLogicalWidth= is unsupported on this platform."); }   String get minWidth { throw new UnsupportedError("CssStyleDeclarationBase.minWidth is unsupported on this platform."); }   void set minWidth(String value) { throw new UnsupportedError("CssStyleDeclarationBase.minWidth= is unsupported on this platform."); }   String get minZoom { throw new UnsupportedError("CssStyleDeclarationBase.minZoom is unsupported on this platform."); }   void set minZoom(String value) { throw new UnsupportedError("CssStyleDeclarationBase.minZoom= is unsupported on this platform."); }   String get mixBlendMode { throw new UnsupportedError("CssStyleDeclarationBase.mixBlendMode is unsupported on this platform."); }   void set mixBlendMode(String value) { throw new UnsupportedError("CssStyleDeclarationBase.mixBlendMode= is unsupported on this platform."); }   String get objectFit { throw new UnsupportedError("CssStyleDeclarationBase.objectFit is unsupported on this platform."); }   void set objectFit(String value) { throw new UnsupportedError("CssStyleDeclarationBase.objectFit= is unsupported on this platform."); }   String get objectPosition { throw new UnsupportedError("CssStyleDeclarationBase.objectPosition is unsupported on this platform."); }   void set objectPosition(String value) { throw new UnsupportedError("CssStyleDeclarationBase.objectPosition= is unsupported on this platform."); }   String get opacity { throw new UnsupportedError("CssStyleDeclarationBase.opacity is unsupported on this platform."); }   void set opacity(String value) { throw new UnsupportedError("CssStyleDeclarationBase.opacity= is unsupported on this platform."); }   String get order { throw new UnsupportedError("CssStyleDeclarationBase.order is unsupported on this platform."); }   void set order(String value) { throw new UnsupportedError("CssStyleDeclarationBase.order= is unsupported on this platform."); }   String get orientation { throw new UnsupportedError("CssStyleDeclarationBase.orientation is unsupported on this platform."); }   void set orientation(String value) { throw new UnsupportedError("CssStyleDeclarationBase.orientation= is unsupported on this platform."); }   String get orphans { throw new UnsupportedError("CssStyleDeclarationBase.orphans is unsupported on this platform."); }   void set orphans(String value) { throw new UnsupportedError("CssStyleDeclarationBase.orphans= is unsupported on this platform."); }   String get outline { throw new UnsupportedError("CssStyleDeclarationBase.outline is unsupported on this platform."); }   void set outline(String value) { throw new UnsupportedError("CssStyleDeclarationBase.outline= is unsupported on this platform."); }   String get outlineColor { throw new UnsupportedError("CssStyleDeclarationBase.outlineColor is unsupported on this platform."); }   void set outlineColor(String value) { throw new UnsupportedError("CssStyleDeclarationBase.outlineColor= is unsupported on this platform."); }   String get outlineOffset { throw new UnsupportedError("CssStyleDeclarationBase.outlineOffset is unsupported on this platform."); }   void set outlineOffset(String value) { throw new UnsupportedError("CssStyleDeclarationBase.outlineOffset= is unsupported on this platform."); }   String get outlineStyle { throw new UnsupportedError("CssStyleDeclarationBase.outlineStyle is unsupported on this platform."); }   void set outlineStyle(String value) { throw new UnsupportedError("CssStyleDeclarationBase.outlineStyle= is unsupported on this platform."); }   String get outlineWidth { throw new UnsupportedError("CssStyleDeclarationBase.outlineWidth is unsupported on this platform."); }   void set outlineWidth(String value) { throw new UnsupportedError("CssStyleDeclarationBase.outlineWidth= is unsupported on this platform."); }   String get overflow { throw new UnsupportedError("CssStyleDeclarationBase.overflow is unsupported on this platform."); }   void set overflow(String value) { throw new UnsupportedError("CssStyleDeclarationBase.overflow= is unsupported on this platform."); }   String get overflowWrap { throw new UnsupportedError("CssStyleDeclarationBase.overflowWrap is unsupported on this platform."); }   void set overflowWrap(String value) { throw new UnsupportedError("CssStyleDeclarationBase.overflowWrap= is unsupported on this platform."); }   String get overflowX { throw new UnsupportedError("CssStyleDeclarationBase.overflowX is unsupported on this platform."); }   void set overflowX(String value) { throw new UnsupportedError("CssStyleDeclarationBase.overflowX= is unsupported on this platform."); }   String get overflowY { throw new UnsupportedError("CssStyleDeclarationBase.overflowY is unsupported on this platform."); }   void set overflowY(String value) { throw new UnsupportedError("CssStyleDeclarationBase.overflowY= is unsupported on this platform."); }   String get padding { throw new UnsupportedError("CssStyleDeclarationBase.padding is unsupported on this platform."); }   void set padding(String value) { throw new UnsupportedError("CssStyleDeclarationBase.padding= is unsupported on this platform."); }   String get paddingAfter { throw new UnsupportedError("CssStyleDeclarationBase.paddingAfter is unsupported on this platform."); }   void set paddingAfter(String value) { throw new UnsupportedError("CssStyleDeclarationBase.paddingAfter= is unsupported on this platform."); }   String get paddingBefore { throw new UnsupportedError("CssStyleDeclarationBase.paddingBefore is unsupported on this platform."); }   void set paddingBefore(String value) { throw new UnsupportedError("CssStyleDeclarationBase.paddingBefore= is unsupported on this platform."); }   String get paddingBottom { throw new UnsupportedError("CssStyleDeclarationBase.paddingBottom is unsupported on this platform."); }   void set paddingBottom(String value) { throw new UnsupportedError("CssStyleDeclarationBase.paddingBottom= is unsupported on this platform."); }   String get paddingEnd { throw new UnsupportedError("CssStyleDeclarationBase.paddingEnd is unsupported on this platform."); }   void set paddingEnd(String value) { throw new UnsupportedError("CssStyleDeclarationBase.paddingEnd= is unsupported on this platform."); }   String get paddingLeft { throw new UnsupportedError("CssStyleDeclarationBase.paddingLeft is unsupported on this platform."); }   void set paddingLeft(String value) { throw new UnsupportedError("CssStyleDeclarationBase.paddingLeft= is unsupported on this platform."); }   String get paddingRight { throw new UnsupportedError("CssStyleDeclarationBase.paddingRight is unsupported on this platform."); }   void set paddingRight(String value) { throw new UnsupportedError("CssStyleDeclarationBase.paddingRight= is unsupported on this platform."); }   String get paddingStart { throw new UnsupportedError("CssStyleDeclarationBase.paddingStart is unsupported on this platform."); }   void set paddingStart(String value) { throw new UnsupportedError("CssStyleDeclarationBase.paddingStart= is unsupported on this platform."); }   String get paddingTop { throw new UnsupportedError("CssStyleDeclarationBase.paddingTop is unsupported on this platform."); }   void set paddingTop(String value) { throw new UnsupportedError("CssStyleDeclarationBase.paddingTop= is unsupported on this platform."); }   String get page { throw new UnsupportedError("CssStyleDeclarationBase.page is unsupported on this platform."); }   void set page(String value) { throw new UnsupportedError("CssStyleDeclarationBase.page= is unsupported on this platform."); }   String get pageBreakAfter { throw new UnsupportedError("CssStyleDeclarationBase.pageBreakAfter is unsupported on this platform."); }   void set pageBreakAfter(String value) { throw new UnsupportedError("CssStyleDeclarationBase.pageBreakAfter= is unsupported on this platform."); }   String get pageBreakBefore { throw new UnsupportedError("CssStyleDeclarationBase.pageBreakBefore is unsupported on this platform."); }   void set pageBreakBefore(String value) { throw new UnsupportedError("CssStyleDeclarationBase.pageBreakBefore= is unsupported on this platform."); }   String get pageBreakInside { throw new UnsupportedError("CssStyleDeclarationBase.pageBreakInside is unsupported on this platform."); }   void set pageBreakInside(String value) { throw new UnsupportedError("CssStyleDeclarationBase.pageBreakInside= is unsupported on this platform."); }   String get perspective { throw new UnsupportedError("CssStyleDeclarationBase.perspective is unsupported on this platform."); }   void set perspective(String value) { throw new UnsupportedError("CssStyleDeclarationBase.perspective= is unsupported on this platform."); }   String get perspectiveOrigin { throw new UnsupportedError("CssStyleDeclarationBase.perspectiveOrigin is unsupported on this platform."); }   void set perspectiveOrigin(String value) { throw new UnsupportedError("CssStyleDeclarationBase.perspectiveOrigin= is unsupported on this platform."); }   String get perspectiveOriginX { throw new UnsupportedError("CssStyleDeclarationBase.perspectiveOriginX is unsupported on this platform."); }   void set perspectiveOriginX(String value) { throw new UnsupportedError("CssStyleDeclarationBase.perspectiveOriginX= is unsupported on this platform."); }   String get perspectiveOriginY { throw new UnsupportedError("CssStyleDeclarationBase.perspectiveOriginY is unsupported on this platform."); }   void set perspectiveOriginY(String value) { throw new UnsupportedError("CssStyleDeclarationBase.perspectiveOriginY= is unsupported on this platform."); }   String get pointerEvents { throw new UnsupportedError("CssStyleDeclarationBase.pointerEvents is unsupported on this platform."); }   void set pointerEvents(String value) { throw new UnsupportedError("CssStyleDeclarationBase.pointerEvents= is unsupported on this platform."); }   String get position { throw new UnsupportedError("CssStyleDeclarationBase.position is unsupported on this platform."); }   void set position(String value) { throw new UnsupportedError("CssStyleDeclarationBase.position= is unsupported on this platform."); }   String get printColorAdjust { throw new UnsupportedError("CssStyleDeclarationBase.printColorAdjust is unsupported on this platform."); }   void set printColorAdjust(String value) { throw new UnsupportedError("CssStyleDeclarationBase.printColorAdjust= is unsupported on this platform."); }   String get quotes { throw new UnsupportedError("CssStyleDeclarationBase.quotes is unsupported on this platform."); }   void set quotes(String value) { throw new UnsupportedError("CssStyleDeclarationBase.quotes= is unsupported on this platform."); }   String get resize { throw new UnsupportedError("CssStyleDeclarationBase.resize is unsupported on this platform."); }   void set resize(String value) { throw new UnsupportedError("CssStyleDeclarationBase.resize= is unsupported on this platform."); }   String get right { throw new UnsupportedError("CssStyleDeclarationBase.right is unsupported on this platform."); }   void set right(String value) { throw new UnsupportedError("CssStyleDeclarationBase.right= is unsupported on this platform."); }   String get rtlOrdering { throw new UnsupportedError("CssStyleDeclarationBase.rtlOrdering is unsupported on this platform."); }   void set rtlOrdering(String value) { throw new UnsupportedError("CssStyleDeclarationBase.rtlOrdering= is unsupported on this platform."); }   String get rubyPosition { throw new UnsupportedError("CssStyleDeclarationBase.rubyPosition is unsupported on this platform."); }   void set rubyPosition(String value) { throw new UnsupportedError("CssStyleDeclarationBase.rubyPosition= is unsupported on this platform."); }   String get scrollBehavior { throw new UnsupportedError("CssStyleDeclarationBase.scrollBehavior is unsupported on this platform."); }   void set scrollBehavior(String value) { throw new UnsupportedError("CssStyleDeclarationBase.scrollBehavior= is unsupported on this platform."); }   String get shapeImageThreshold { throw new UnsupportedError("CssStyleDeclarationBase.shapeImageThreshold is unsupported on this platform."); }   void set shapeImageThreshold(String value) { throw new UnsupportedError("CssStyleDeclarationBase.shapeImageThreshold= is unsupported on this platform."); }   String get shapeMargin { throw new UnsupportedError("CssStyleDeclarationBase.shapeMargin is unsupported on this platform."); }   void set shapeMargin(String value) { throw new UnsupportedError("CssStyleDeclarationBase.shapeMargin= is unsupported on this platform."); }   String get shapeOutside { throw new UnsupportedError("CssStyleDeclarationBase.shapeOutside is unsupported on this platform."); }   void set shapeOutside(String value) { throw new UnsupportedError("CssStyleDeclarationBase.shapeOutside= is unsupported on this platform."); }   String get size { throw new UnsupportedError("CssStyleDeclarationBase.size is unsupported on this platform."); }   void set size(String value) { throw new UnsupportedError("CssStyleDeclarationBase.size= is unsupported on this platform."); }   String get speak { throw new UnsupportedError("CssStyleDeclarationBase.speak is unsupported on this platform."); }   void set speak(String value) { throw new UnsupportedError("CssStyleDeclarationBase.speak= is unsupported on this platform."); }   String get src { throw new UnsupportedError("CssStyleDeclarationBase.src is unsupported on this platform."); }   void set src(String value) { throw new UnsupportedError("CssStyleDeclarationBase.src= is unsupported on this platform."); }   String get tabSize { throw new UnsupportedError("CssStyleDeclarationBase.tabSize is unsupported on this platform."); }   void set tabSize(String value) { throw new UnsupportedError("CssStyleDeclarationBase.tabSize= is unsupported on this platform."); }   String get tableLayout { throw new UnsupportedError("CssStyleDeclarationBase.tableLayout is unsupported on this platform."); }   void set tableLayout(String value) { throw new UnsupportedError("CssStyleDeclarationBase.tableLayout= is unsupported on this platform."); }   String get tapHighlightColor { throw new UnsupportedError("CssStyleDeclarationBase.tapHighlightColor is unsupported on this platform."); }   void set tapHighlightColor(String value) { throw new UnsupportedError("CssStyleDeclarationBase.tapHighlightColor= is unsupported on this platform."); }   String get textAlign { throw new UnsupportedError("CssStyleDeclarationBase.textAlign is unsupported on this platform."); }   void set textAlign(String value) { throw new UnsupportedError("CssStyleDeclarationBase.textAlign= is unsupported on this platform."); }   String get textAlignLast { throw new UnsupportedError("CssStyleDeclarationBase.textAlignLast is unsupported on this platform."); }   void set textAlignLast(String value) { throw new UnsupportedError("CssStyleDeclarationBase.textAlignLast= is unsupported on this platform."); }   String get textCombine { throw new UnsupportedError("CssStyleDeclarationBase.textCombine is unsupported on this platform."); }   void set textCombine(String value) { throw new UnsupportedError("CssStyleDeclarationBase.textCombine= is unsupported on this platform."); }   String get textDecoration { throw new UnsupportedError("CssStyleDeclarationBase.textDecoration is unsupported on this platform."); }   void set textDecoration(String value) { throw new UnsupportedError("CssStyleDeclarationBase.textDecoration= is unsupported on this platform."); }   String get textDecorationColor { throw new UnsupportedError("CssStyleDeclarationBase.textDecorationColor is unsupported on this platform."); }   void set textDecorationColor(String value) { throw new UnsupportedError("CssStyleDeclarationBase.textDecorationColor= is unsupported on this platform."); }   String get textDecorationLine { throw new UnsupportedError("CssStyleDeclarationBase.textDecorationLine is unsupported on this platform."); }   void set textDecorationLine(String value) { throw new UnsupportedError("CssStyleDeclarationBase.textDecorationLine= is unsupported on this platform."); }   String get textDecorationStyle { throw new UnsupportedError("CssStyleDeclarationBase.textDecorationStyle is unsupported on this platform."); }   void set textDecorationStyle(String value) { throw new UnsupportedError("CssStyleDeclarationBase.textDecorationStyle= is unsupported on this platform."); }   String get textDecorationsInEffect { throw new UnsupportedError("CssStyleDeclarationBase.textDecorationsInEffect is unsupported on this platform."); }   void set textDecorationsInEffect(String value) { throw new UnsupportedError("CssStyleDeclarationBase.textDecorationsInEffect= is unsupported on this platform."); }   String get textEmphasis { throw new UnsupportedError("CssStyleDeclarationBase.textEmphasis is unsupported on this platform."); }   void set textEmphasis(String value) { throw new UnsupportedError("CssStyleDeclarationBase.textEmphasis= is unsupported on this platform."); }   String get textEmphasisColor { throw new UnsupportedError("CssStyleDeclarationBase.textEmphasisColor is unsupported on this platform."); }   void set textEmphasisColor(String value) { throw new UnsupportedError("CssStyleDeclarationBase.textEmphasisColor= is unsupported on this platform."); }   String get textEmphasisPosition { throw new UnsupportedError("CssStyleDeclarationBase.textEmphasisPosition is unsupported on this platform."); }   void set textEmphasisPosition(String value) { throw new UnsupportedError("CssStyleDeclarationBase.textEmphasisPosition= is unsupported on this platform."); }   String get textEmphasisStyle { throw new UnsupportedError("CssStyleDeclarationBase.textEmphasisStyle is unsupported on this platform."); }   void set textEmphasisStyle(String value) { throw new UnsupportedError("CssStyleDeclarationBase.textEmphasisStyle= is unsupported on this platform."); }   String get textFillColor { throw new UnsupportedError("CssStyleDeclarationBase.textFillColor is unsupported on this platform."); }   void set textFillColor(String value) { throw new UnsupportedError("CssStyleDeclarationBase.textFillColor= is unsupported on this platform."); }   String get textIndent { throw new UnsupportedError("CssStyleDeclarationBase.textIndent is unsupported on this platform."); }   void set textIndent(String value) { throw new UnsupportedError("CssStyleDeclarationBase.textIndent= is unsupported on this platform."); }   String get textJustify { throw new UnsupportedError("CssStyleDeclarationBase.textJustify is unsupported on this platform."); }   void set textJustify(String value) { throw new UnsupportedError("CssStyleDeclarationBase.textJustify= is unsupported on this platform."); }   String get textLineThroughColor { throw new UnsupportedError("CssStyleDeclarationBase.textLineThroughColor is unsupported on this platform."); }   void set textLineThroughColor(String value) { throw new UnsupportedError("CssStyleDeclarationBase.textLineThroughColor= is unsupported on this platform."); }   String get textLineThroughMode { throw new UnsupportedError("CssStyleDeclarationBase.textLineThroughMode is unsupported on this platform."); }   void set textLineThroughMode(String value) { throw new UnsupportedError("CssStyleDeclarationBase.textLineThroughMode= is unsupported on this platform."); }   String get textLineThroughStyle { throw new UnsupportedError("CssStyleDeclarationBase.textLineThroughStyle is unsupported on this platform."); }   void set textLineThroughStyle(String value) { throw new UnsupportedError("CssStyleDeclarationBase.textLineThroughStyle= is unsupported on this platform."); }   String get textLineThroughWidth { throw new UnsupportedError("CssStyleDeclarationBase.textLineThroughWidth is unsupported on this platform."); }   void set textLineThroughWidth(String value) { throw new UnsupportedError("CssStyleDeclarationBase.textLineThroughWidth= is unsupported on this platform."); }   String get textOrientation { throw new UnsupportedError("CssStyleDeclarationBase.textOrientation is unsupported on this platform."); }   void set textOrientation(String value) { throw new UnsupportedError("CssStyleDeclarationBase.textOrientation= is unsupported on this platform."); }   String get textOverflow { throw new UnsupportedError("CssStyleDeclarationBase.textOverflow is unsupported on this platform."); }   void set textOverflow(String value) { throw new UnsupportedError("CssStyleDeclarationBase.textOverflow= is unsupported on this platform."); }   String get textOverlineColor { throw new UnsupportedError("CssStyleDeclarationBase.textOverlineColor is unsupported on this platform."); }   void set textOverlineColor(String value) { throw new UnsupportedError("CssStyleDeclarationBase.textOverlineColor= is unsupported on this platform."); }   String get textOverlineMode { throw new UnsupportedError("CssStyleDeclarationBase.textOverlineMode is unsupported on this platform."); }   void set textOverlineMode(String value) { throw new UnsupportedError("CssStyleDeclarationBase.textOverlineMode= is unsupported on this platform."); }   String get textOverlineStyle { throw new UnsupportedError("CssStyleDeclarationBase.textOverlineStyle is unsupported on this platform."); }   void set textOverlineStyle(String value) { throw new UnsupportedError("CssStyleDeclarationBase.textOverlineStyle= is unsupported on this platform."); }   String get textOverlineWidth { throw new UnsupportedError("CssStyleDeclarationBase.textOverlineWidth is unsupported on this platform."); }   void set textOverlineWidth(String value) { throw new UnsupportedError("CssStyleDeclarationBase.textOverlineWidth= is unsupported on this platform."); }   String get textRendering { throw new UnsupportedError("CssStyleDeclarationBase.textRendering is unsupported on this platform."); }   void set textRendering(String value) { throw new UnsupportedError("CssStyleDeclarationBase.textRendering= is unsupported on this platform."); }   String get textSecurity { throw new UnsupportedError("CssStyleDeclarationBase.textSecurity is unsupported on this platform."); }   void set textSecurity(String value) { throw new UnsupportedError("CssStyleDeclarationBase.textSecurity= is unsupported on this platform."); }   String get textShadow { throw new UnsupportedError("CssStyleDeclarationBase.textShadow is unsupported on this platform."); }   void set textShadow(String value) { throw new UnsupportedError("CssStyleDeclarationBase.textShadow= is unsupported on this platform."); }   String get textStroke { throw new UnsupportedError("CssStyleDeclarationBase.textStroke is unsupported on this platform."); }   void set textStroke(String value) { throw new UnsupportedError("CssStyleDeclarationBase.textStroke= is unsupported on this platform."); }   String get textStrokeColor { throw new UnsupportedError("CssStyleDeclarationBase.textStrokeColor is unsupported on this platform."); }   void set textStrokeColor(String value) { throw new UnsupportedError("CssStyleDeclarationBase.textStrokeColor= is unsupported on this platform."); }   String get textStrokeWidth { throw new UnsupportedError("CssStyleDeclarationBase.textStrokeWidth is unsupported on this platform."); }   void set textStrokeWidth(String value) { throw new UnsupportedError("CssStyleDeclarationBase.textStrokeWidth= is unsupported on this platform."); }   String get textTransform { throw new UnsupportedError("CssStyleDeclarationBase.textTransform is unsupported on this platform."); }   void set textTransform(String value) { throw new UnsupportedError("CssStyleDeclarationBase.textTransform= is unsupported on this platform."); }   String get textUnderlineColor { throw new UnsupportedError("CssStyleDeclarationBase.textUnderlineColor is unsupported on this platform."); }   void set textUnderlineColor(String value) { throw new UnsupportedError("CssStyleDeclarationBase.textUnderlineColor= is unsupported on this platform."); }   String get textUnderlineMode { throw new UnsupportedError("CssStyleDeclarationBase.textUnderlineMode is unsupported on this platform."); }   void set textUnderlineMode(String value) { throw new UnsupportedError("CssStyleDeclarationBase.textUnderlineMode= is unsupported on this platform."); }   String get textUnderlinePosition { throw new UnsupportedError("CssStyleDeclarationBase.textUnderlinePosition is unsupported on this platform."); }   void set textUnderlinePosition(String value) { throw new UnsupportedError("CssStyleDeclarationBase.textUnderlinePosition= is unsupported on this platform."); }   String get textUnderlineStyle { throw new UnsupportedError("CssStyleDeclarationBase.textUnderlineStyle is unsupported on this platform."); }   void set textUnderlineStyle(String value) { throw new UnsupportedError("CssStyleDeclarationBase.textUnderlineStyle= is unsupported on this platform."); }   String get textUnderlineWidth { throw new UnsupportedError("CssStyleDeclarationBase.textUnderlineWidth is unsupported on this platform."); }   void set textUnderlineWidth(String value) { throw new UnsupportedError("CssStyleDeclarationBase.textUnderlineWidth= is unsupported on this platform."); }   String get top { throw new UnsupportedError("CssStyleDeclarationBase.top is unsupported on this platform."); }   void set top(String value) { throw new UnsupportedError("CssStyleDeclarationBase.top= is unsupported on this platform."); }   String get touchAction { throw new UnsupportedError("CssStyleDeclarationBase.touchAction is unsupported on this platform."); }   void set touchAction(String value) { throw new UnsupportedError("CssStyleDeclarationBase.touchAction= is unsupported on this platform."); }   String get touchActionDelay { throw new UnsupportedError("CssStyleDeclarationBase.touchActionDelay is unsupported on this platform."); }   void set touchActionDelay(String value) { throw new UnsupportedError("CssStyleDeclarationBase.touchActionDelay= is unsupported on this platform."); }   String get transform { throw new UnsupportedError("CssStyleDeclarationBase.transform is unsupported on this platform."); }   void set transform(String value) { throw new UnsupportedError("CssStyleDeclarationBase.transform= is unsupported on this platform."); }   String get transformOrigin { throw new UnsupportedError("CssStyleDeclarationBase.transformOrigin is unsupported on this platform."); }   void set transformOrigin(String value) { throw new UnsupportedError("CssStyleDeclarationBase.transformOrigin= is unsupported on this platform."); }   String get transformOriginX { throw new UnsupportedError("CssStyleDeclarationBase.transformOriginX is unsupported on this platform."); }   void set transformOriginX(String value) { throw new UnsupportedError("CssStyleDeclarationBase.transformOriginX= is unsupported on this platform."); }   String get transformOriginY { throw new UnsupportedError("CssStyleDeclarationBase.transformOriginY is unsupported on this platform."); }   void set transformOriginY(String value) { throw new UnsupportedError("CssStyleDeclarationBase.transformOriginY= is unsupported on this platform."); }   String get transformOriginZ { throw new UnsupportedError("CssStyleDeclarationBase.transformOriginZ is unsupported on this platform."); }   void set transformOriginZ(String value) { throw new UnsupportedError("CssStyleDeclarationBase.transformOriginZ= is unsupported on this platform."); }   String get transformStyle { throw new UnsupportedError("CssStyleDeclarationBase.transformStyle is unsupported on this platform."); }   void set transformStyle(String value) { throw new UnsupportedError("CssStyleDeclarationBase.transformStyle= is unsupported on this platform."); }   @SupportedBrowser(SupportedBrowser.CHROME) @SupportedBrowser(SupportedBrowser.FIREFOX) @SupportedBrowser(SupportedBrowser.IE, '10') @SupportedBrowser(SupportedBrowser.SAFARI) String get transition { throw new UnsupportedError("CssStyleDeclarationBase.transition is unsupported on this platform."); }   @SupportedBrowser(SupportedBrowser.CHROME) @SupportedBrowser(SupportedBrowser.FIREFOX) @SupportedBrowser(SupportedBrowser.IE, '10') @SupportedBrowser(SupportedBrowser.SAFARI) void set transition(String value) { throw new UnsupportedError("CssStyleDeclarationBase.transition= is unsupported on this platform."); }   String get transitionDelay { throw new UnsupportedError("CssStyleDeclarationBase.transitionDelay is unsupported on this platform."); }   void set transitionDelay(String value) { throw new UnsupportedError("CssStyleDeclarationBase.transitionDelay= is unsupported on this platform."); }   String get transitionDuration { throw new UnsupportedError("CssStyleDeclarationBase.transitionDuration is unsupported on this platform."); }   void set transitionDuration(String value) { throw new UnsupportedError("CssStyleDeclarationBase.transitionDuration= is unsupported on this platform."); }   String get transitionProperty { throw new UnsupportedError("CssStyleDeclarationBase.transitionProperty is unsupported on this platform."); }   void set transitionProperty(String value) { throw new UnsupportedError("CssStyleDeclarationBase.transitionProperty= is unsupported on this platform."); }   String get transitionTimingFunction { throw new UnsupportedError("CssStyleDeclarationBase.transitionTimingFunction is unsupported on this platform."); }   void set transitionTimingFunction(String value) { throw new UnsupportedError("CssStyleDeclarationBase.transitionTimingFunction= is unsupported on this platform."); }   String get unicodeBidi { throw new UnsupportedError("CssStyleDeclarationBase.unicodeBidi is unsupported on this platform."); }   void set unicodeBidi(String value) { throw new UnsupportedError("CssStyleDeclarationBase.unicodeBidi= is unsupported on this platform."); }   String get unicodeRange { throw new UnsupportedError("CssStyleDeclarationBase.unicodeRange is unsupported on this platform."); }   void set unicodeRange(String value) { throw new UnsupportedError("CssStyleDeclarationBase.unicodeRange= is unsupported on this platform."); }   String get userDrag { throw new UnsupportedError("CssStyleDeclarationBase.userDrag is unsupported on this platform."); }   void set userDrag(String value) { throw new UnsupportedError("CssStyleDeclarationBase.userDrag= is unsupported on this platform."); }   String get userModify { throw new UnsupportedError("CssStyleDeclarationBase.userModify is unsupported on this platform."); }   void set userModify(String value) { throw new UnsupportedError("CssStyleDeclarationBase.userModify= is unsupported on this platform."); }   String get userSelect { throw new UnsupportedError("CssStyleDeclarationBase.userSelect is unsupported on this platform."); }   void set userSelect(String value) { throw new UnsupportedError("CssStyleDeclarationBase.userSelect= is unsupported on this platform."); }   String get userZoom { throw new UnsupportedError("CssStyleDeclarationBase.userZoom is unsupported on this platform."); }   void set userZoom(String value) { throw new UnsupportedError("CssStyleDeclarationBase.userZoom= is unsupported on this platform."); }   String get verticalAlign { throw new UnsupportedError("CssStyleDeclarationBase.verticalAlign is unsupported on this platform."); }   void set verticalAlign(String value) { throw new UnsupportedError("CssStyleDeclarationBase.verticalAlign= is unsupported on this platform."); }   String get visibility { throw new UnsupportedError("CssStyleDeclarationBase.visibility is unsupported on this platform."); }   void set visibility(String value) { throw new UnsupportedError("CssStyleDeclarationBase.visibility= is unsupported on this platform."); }   String get whiteSpace { throw new UnsupportedError("CssStyleDeclarationBase.whiteSpace is unsupported on this platform."); }   void set whiteSpace(String value) { throw new UnsupportedError("CssStyleDeclarationBase.whiteSpace= is unsupported on this platform."); }   String get widows { throw new UnsupportedError("CssStyleDeclarationBase.widows is unsupported on this platform."); }   void set widows(String value) { throw new UnsupportedError("CssStyleDeclarationBase.widows= is unsupported on this platform."); }   String get width { throw new UnsupportedError("CssStyleDeclarationBase.width is unsupported on this platform."); }   void set width(String value) { throw new UnsupportedError("CssStyleDeclarationBase.width= is unsupported on this platform."); }   String get willChange { throw new UnsupportedError("CssStyleDeclarationBase.willChange is unsupported on this platform."); }   void set willChange(String value) { throw new UnsupportedError("CssStyleDeclarationBase.willChange= is unsupported on this platform."); }   String get wordBreak { throw new UnsupportedError("CssStyleDeclarationBase.wordBreak is unsupported on this platform."); }   void set wordBreak(String value) { throw new UnsupportedError("CssStyleDeclarationBase.wordBreak= is unsupported on this platform."); }   String get wordSpacing { throw new UnsupportedError("CssStyleDeclarationBase.wordSpacing is unsupported on this platform."); }   void set wordSpacing(String value) { throw new UnsupportedError("CssStyleDeclarationBase.wordSpacing= is unsupported on this platform."); }   String get wordWrap { throw new UnsupportedError("CssStyleDeclarationBase.wordWrap is unsupported on this platform."); }   void set wordWrap(String value) { throw new UnsupportedError("CssStyleDeclarationBase.wordWrap= is unsupported on this platform."); }   String get wrapFlow { throw new UnsupportedError("CssStyleDeclarationBase.wrapFlow is unsupported on this platform."); }   void set wrapFlow(String value) { throw new UnsupportedError("CssStyleDeclarationBase.wrapFlow= is unsupported on this platform."); }   String get wrapThrough { throw new UnsupportedError("CssStyleDeclarationBase.wrapThrough is unsupported on this platform."); }   void set wrapThrough(String value) { throw new UnsupportedError("CssStyleDeclarationBase.wrapThrough= is unsupported on this platform."); }   String get writingMode { throw new UnsupportedError("CssStyleDeclarationBase.writingMode is unsupported on this platform."); }   void set writingMode(String value) { throw new UnsupportedError("CssStyleDeclarationBase.writingMode= is unsupported on this platform."); }   String get zIndex { throw new UnsupportedError("CssStyleDeclarationBase.zIndex is unsupported on this platform."); }   void set zIndex(String value) { throw new UnsupportedError("CssStyleDeclarationBase.zIndex= is unsupported on this platform."); }   String get zoom { throw new UnsupportedError("CssStyleDeclarationBase.zoom is unsupported on this platform."); }   void set zoom(String value) { throw new UnsupportedError("CssStyleDeclarationBase.zoom= is unsupported on this platform."); } } @DocsEditable() @DomName('CSSStyleRule') class CssStyleRule extends CssRule { factory CssStyleRule._() { throw new UnsupportedError("new CssStyleRule._() is unsupported on this platform."); }   @DomName('CSSStyleRule.selectorText') @DocsEditable() String get selectorText {}   @DomName('CSSStyleRule.selectorText') @DocsEditable() void set selectorText(String value) {}   @DomName('CSSStyleRule.style') @DocsEditable() CssStyleDeclaration get style {} } @DocsEditable() @DomName('CSSStyleSheet') class CssStyleSheet extends StyleSheet { factory CssStyleSheet._() { throw new UnsupportedError("new CssStyleSheet._() is unsupported on this platform."); }   @DomName('CSSStyleSheet.cssRules') @DocsEditable() List<CssRule> get cssRules {}   @DomName('CSSStyleSheet.ownerRule') @DocsEditable() CssRule get ownerRule {}   @DomName('CSSStyleSheet.rules') @DocsEditable() @Experimental() List<CssRule> get rules {}   int addRule(String selector, String style, [int index]) {}   @DomName('CSSStyleSheet.deleteRule') @DocsEditable() void deleteRule(int index) {}   int insertRule(String rule, [int index]) {}   @DomName('CSSStyleSheet.removeRule') @DocsEditable() @Experimental() void removeRule(int index) {} } @DocsEditable() @DomName('CSSSupportsRule') class CssSupportsRule extends CssRule { factory CssSupportsRule._() { throw new UnsupportedError("new CssSupportsRule._() is unsupported on this platform."); }   @DomName('CSSSupportsRule.conditionText') @DocsEditable() String get conditionText {}   @DomName('CSSSupportsRule.cssRules') @DocsEditable() List<CssRule> get cssRules {}   @DomName('CSSSupportsRule.deleteRule') @DocsEditable() void deleteRule(int index) {}   @DomName('CSSSupportsRule.insertRule') @DocsEditable() int insertRule(String rule, int index) {} } @DocsEditable() @DomName('CSSViewportRule') @Experimental() class CssViewportRule extends CssRule { factory CssViewportRule._() { throw new UnsupportedError("new CssViewportRule._() is unsupported on this platform."); }   @DomName('CSSViewportRule.style') @DocsEditable() @Experimental() CssStyleDeclaration get style {} } @DomName('CustomEvent') class CustomEvent extends Event {   factory CustomEvent(String type, {bool canBubble : true, bool cancelable : true, Object detail}) { throw new UnsupportedError("new CustomEvent() is unsupported on this platform."); }   @DomName('CustomEvent.detail') get detail {}   factory CustomEvent._() { throw new UnsupportedError("new CustomEvent._() is unsupported on this platform."); }   } @DocsEditable() @DomName('HTMLDListElement') class DListElement extends HtmlElement { factory DListElement._() { throw new UnsupportedError("new DListElement._() is unsupported on this platform."); }   @DomName('HTMLDListElement.HTMLDListElement') @DocsEditable() factory DListElement() { throw new UnsupportedError("new DListElement() is unsupported on this platform."); }   DListElement.created() : super.created() { throw new UnsupportedError("new DListElement.created() is unsupported on this platform."); } } @DocsEditable() @DomName('HTMLDataListElement') @SupportedBrowser(SupportedBrowser.CHROME) @SupportedBrowser(SupportedBrowser.FIREFOX) @SupportedBrowser(SupportedBrowser.IE, '10') @SupportedBrowser(SupportedBrowser.SAFARI) class DataListElement extends HtmlElement { factory DataListElement._() { throw new UnsupportedError("new DataListElement._() is unsupported on this platform."); }   @DomName('HTMLDataListElement.HTMLDataListElement') @DocsEditable() factory DataListElement() { throw new UnsupportedError("new DataListElement() is unsupported on this platform."); }   DataListElement.created() : super.created() { throw new UnsupportedError("new DataListElement.created() is unsupported on this platform."); }   static bool get supported { throw new UnsupportedError("DataListElement.supported is unsupported on this platform."); }   @DomName('HTMLDataListElement.options') @DocsEditable() List<Node> get options {} } @DocsEditable() @DomName('DataTransfer') @Experimental() class DataTransfer extends NativeFieldWrapperClass2 { factory DataTransfer._() { throw new UnsupportedError("new DataTransfer._() is unsupported on this platform."); }   @DomName('DataTransfer.dropEffect') @DocsEditable() @Experimental() String get dropEffect {}   @DomName('DataTransfer.dropEffect') @DocsEditable() @Experimental() void set dropEffect(String value) {}   @DomName('DataTransfer.effectAllowed') @DocsEditable() @Experimental() String get effectAllowed {}   @DomName('DataTransfer.effectAllowed') @DocsEditable() @Experimental() void set effectAllowed(String value) {}   @DomName('DataTransfer.files') @DocsEditable() @Experimental() List<File> get files {}   @DomName('DataTransfer.items') @DocsEditable() @Experimental() DataTransferItemList get items {}   @DomName('DataTransfer.types') @DocsEditable() @Experimental() List<String> get types {}   void clearData([String type]) {}   @DomName('DataTransfer.getData') @DocsEditable() @Experimental() String getData(String type) {}   @DomName('DataTransfer.setData') @DocsEditable() @Experimental() void setData(String type, String data) {}   @DomName('DataTransfer.setDragImage') @DocsEditable() @Experimental() void setDragImage(Element image, int x, int y) {} } @DocsEditable() @DomName('DataTransferItem') @Experimental() class DataTransferItem extends NativeFieldWrapperClass2 { factory DataTransferItem._() { throw new UnsupportedError("new DataTransferItem._() is unsupported on this platform."); }   @DomName('DataTransferItem.kind') @DocsEditable() String get kind {}   @DomName('DataTransferItem.type') @DocsEditable() String get type {}   @DomName('DataTransferItem.getAsFile') @DocsEditable() Blob getAsFile() {}    Future<String> getAsString() {}   @DomName('DataTransferItem.webkitGetAsEntry') @DocsEditable() @SupportedBrowser(SupportedBrowser.CHROME) @SupportedBrowser(SupportedBrowser.SAFARI) @Experimental() Entry getAsEntry() {} } @DocsEditable() @DomName('DataTransferItemList') @Experimental() class DataTransferItemList extends NativeFieldWrapperClass2 { factory DataTransferItemList._() { throw new UnsupportedError("new DataTransferItemList._() is unsupported on this platform."); }   @DomName('DataTransferItemList.length') @DocsEditable() int get length {}    DataTransferItem add(data_OR_file, [String type]) {}   @DomName('DataTransferItemList.addData') @DocsEditable() DataTransferItem addData(String data, String type) {}   @DomName('DataTransferItemList.addFile') @DocsEditable() DataTransferItem addFile(File file) {}   @DomName('DataTransferItemList.clear') @DocsEditable() void clear() {}   @DomName('DataTransferItemList.remove') @DocsEditable() @Experimental() void remove(int index) {}   DataTransferItem operator [](int index) {} } @DomName('DatabaseCallback') @Experimental() typedef void DatabaseCallback(database); @DocsEditable() @DomName('DedicatedWorkerGlobalScope') @Experimental() class DedicatedWorkerGlobalScope extends WorkerGlobalScope { factory DedicatedWorkerGlobalScope._() { throw new UnsupportedError("new DedicatedWorkerGlobalScope._() is unsupported on this platform."); }   static const messageEvent = const EventStreamProvider<MessageEvent>('message');   @DomName('DedicatedWorkerGlobalScope.postMessage') @DocsEditable() @Experimental() void postMessage(Object message, [List<MessagePort> transfer]) {}   @DomName('DedicatedWorkerGlobalScope.onmessage') @DocsEditable() @Experimental() Stream<MessageEvent> get onMessage {} } @DocsEditable() @DomName('DeprecatedStorageInfo') @Experimental() class DeprecatedStorageInfo extends NativeFieldWrapperClass2 { factory DeprecatedStorageInfo._() { throw new UnsupportedError("new DeprecatedStorageInfo._() is unsupported on this platform."); }   static const PERSISTENT = 1;   static const TEMPORARY = 0;   void queryUsageAndQuota(int storageType, [StorageUsageCallback usageCallback, StorageErrorCallback errorCallback]) {}   void requestQuota(int storageType, int newQuotaInBytes, [StorageQuotaCallback quotaCallback, StorageErrorCallback errorCallback]) {} } @DocsEditable() @DomName('DeprecatedStorageQuota') @Experimental() class DeprecatedStorageQuota extends NativeFieldWrapperClass2 { factory DeprecatedStorageQuota._() { throw new UnsupportedError("new DeprecatedStorageQuota._() is unsupported on this platform."); }   void queryUsageAndQuota(StorageUsageCallback usageCallback, [StorageErrorCallback errorCallback]) {}   void requestQuota(int newQuotaInBytes, [StorageQuotaCallback quotaCallback, StorageErrorCallback errorCallback]) {} } @DocsEditable() @DomName('HTMLDetailsElement') @SupportedBrowser(SupportedBrowser.CHROME) @SupportedBrowser(SupportedBrowser.SAFARI) @Experimental() class DetailsElement extends HtmlElement { factory DetailsElement._() { throw new UnsupportedError("new DetailsElement._() is unsupported on this platform."); }   @DomName('HTMLDetailsElement.HTMLDetailsElement') @DocsEditable() factory DetailsElement() { throw new UnsupportedError("new DetailsElement() is unsupported on this platform."); }   DetailsElement.created() : super.created() { throw new UnsupportedError("new DetailsElement.created() is unsupported on this platform."); }   static bool get supported { throw new UnsupportedError("DetailsElement.supported is unsupported on this platform."); }   @DomName('HTMLDetailsElement.open') @DocsEditable() bool get open {}   @DomName('HTMLDetailsElement.open') @DocsEditable() void set open(bool value) {} } @DocsEditable() @DomName('DeviceAcceleration') @Experimental() class DeviceAcceleration extends NativeFieldWrapperClass2 { factory DeviceAcceleration._() { throw new UnsupportedError("new DeviceAcceleration._() is unsupported on this platform."); }   @DomName('DeviceAcceleration.x') @DocsEditable() double get x {}   @DomName('DeviceAcceleration.y') @DocsEditable() double get y {}   @DomName('DeviceAcceleration.z') @DocsEditable() double get z {} } @DocsEditable() @DomName('DeviceLightEvent') @Experimental() class DeviceLightEvent extends Event { factory DeviceLightEvent._() { throw new UnsupportedError("new DeviceLightEvent._() is unsupported on this platform."); }   @DomName('DeviceLightEvent.value') @DocsEditable() @Experimental() double get value {} } @DocsEditable() @DomName('DeviceMotionEvent') @Experimental() class DeviceMotionEvent extends Event { factory DeviceMotionEvent._() { throw new UnsupportedError("new DeviceMotionEvent._() is unsupported on this platform."); }   @DomName('DeviceMotionEvent.acceleration') @DocsEditable() DeviceAcceleration get acceleration {}   @DomName('DeviceMotionEvent.accelerationIncludingGravity') @DocsEditable() DeviceAcceleration get accelerationIncludingGravity {}   @DomName('DeviceMotionEvent.interval') @DocsEditable() double get interval {}   @DomName('DeviceMotionEvent.rotationRate') @DocsEditable() DeviceRotationRate get rotationRate {}   @DomName('DeviceMotionEvent.initDeviceMotionEvent') @DocsEditable() @Experimental() void initDeviceMotionEvent(String type, bool bubbles, bool cancelable, DeviceAcceleration acceleration, DeviceAcceleration accelerationIncludingGravity, DeviceRotationRate rotationRate, num interval) {} } @DomName('DeviceOrientationEvent') @Experimental() class DeviceOrientationEvent extends Event { factory DeviceOrientationEvent(String type, {bool canBubble : true, bool cancelable : true, num alpha : 0, num beta : 0, num gamma : 0, bool absolute : false}) { throw new UnsupportedError("new DeviceOrientationEvent() is unsupported on this platform."); }   factory DeviceOrientationEvent._() { throw new UnsupportedError("new DeviceOrientationEvent._() is unsupported on this platform."); }   @DomName('DeviceOrientationEvent.absolute') @DocsEditable() bool get absolute {}   @DomName('DeviceOrientationEvent.alpha') @DocsEditable() double get alpha {}   @DomName('DeviceOrientationEvent.beta') @DocsEditable() double get beta {}   @DomName('DeviceOrientationEvent.gamma') @DocsEditable() double get gamma {}  } @DocsEditable() @DomName('DeviceRotationRate') @Experimental() class DeviceRotationRate extends NativeFieldWrapperClass2 { factory DeviceRotationRate._() { throw new UnsupportedError("new DeviceRotationRate._() is unsupported on this platform."); }   @DomName('DeviceRotationRate.alpha') @DocsEditable() double get alpha {}   @DomName('DeviceRotationRate.beta') @DocsEditable() double get beta {}   @DomName('DeviceRotationRate.gamma') @DocsEditable() double get gamma {} } @DocsEditable() @DomName('HTMLDialogElement') @Unstable() class DialogElement extends HtmlElement { factory DialogElement._() { throw new UnsupportedError("new DialogElement._() is unsupported on this platform."); }   DialogElement.created() : super.created() { throw new UnsupportedError("new DialogElement.created() is unsupported on this platform."); }   @DomName('HTMLDialogElement.open') @DocsEditable() bool get open {}   @DomName('HTMLDialogElement.open') @DocsEditable() void set open(bool value) {}   @DomName('HTMLDialogElement.returnValue') @DocsEditable() @Experimental() String get returnValue {}   @DomName('HTMLDialogElement.returnValue') @DocsEditable() @Experimental() void set returnValue(String value) {}   @DomName('HTMLDialogElement.close') @DocsEditable() void close(String returnValue) {}   @DomName('HTMLDialogElement.show') @DocsEditable() void show() {}   @DomName('HTMLDialogElement.showModal') @DocsEditable() void showModal() {} } @DomName('DirectoryEntry') @Experimental() class DirectoryEntry extends Entry { Future<Entry> createDirectory(String path, {bool exclusive : false}) {}   Future<Entry> getDirectory(String path) {}   Future<Entry> createFile(String path, {bool exclusive : false}) {}   Future<Entry> getFile(String path) {}   factory DirectoryEntry._() { throw new UnsupportedError("new DirectoryEntry._() is unsupported on this platform."); }   @DomName('DirectoryEntry.createReader') @DocsEditable() DirectoryReader createReader() {}        Future removeRecursively() {} } @DocsEditable() @DomName('DirectoryReader') @Experimental() class DirectoryReader extends NativeFieldWrapperClass2 { factory DirectoryReader._() { throw new UnsupportedError("new DirectoryReader._() is unsupported on this platform."); }    Future<List<Entry>> readEntries() {} } @DocsEditable() @DomName('HTMLDivElement') class DivElement extends HtmlElement { factory DivElement._() { throw new UnsupportedError("new DivElement._() is unsupported on this platform."); }   @DomName('HTMLDivElement.HTMLDivElement') @DocsEditable() factory DivElement() { throw new UnsupportedError("new DivElement() is unsupported on this platform."); }   DivElement.created() : super.created() { throw new UnsupportedError("new DivElement.created() is unsupported on this platform."); } } @DocsEditable() @DomName('Document') class Document extends Node { factory Document._() { throw new UnsupportedError("new Document._() is unsupported on this platform."); }   static const pointerLockChangeEvent = const EventStreamProvider<Event>('pointerlockchange');   static const pointerLockErrorEvent = const EventStreamProvider<Event>('pointerlockerror');   static const readyStateChangeEvent = const EventStreamProvider<Event>('readystatechange');   static const securityPolicyViolationEvent = const EventStreamProvider<SecurityPolicyViolationEvent>('securitypolicyviolation');   static const selectionChangeEvent = const EventStreamProvider<Event>('selectionchange');   @DomName('Document.activeElement') @DocsEditable() @Experimental() Element get activeElement {}     @DomName('Document.contentType') @DocsEditable() @Experimental() String get contentType {}   @DomName('Document.cookie') @DocsEditable() String get cookie {}   @DomName('Document.cookie') @DocsEditable() void set cookie(String value) {}   @DomName('Document.currentScript') @DocsEditable() @Experimental() ScriptElement get currentScript {}   @DomName('Document.defaultView') @DocsEditable() WindowBase get window {}   @DomName('Document.documentElement') @DocsEditable() Element get documentElement {}   @DomName('Document.domain') @DocsEditable() String get domain {}   @DomName('Document.fonts') @DocsEditable() @Experimental() FontFaceSet get fonts {}   @DomName('Document.fullscreenElement') @DocsEditable() @Experimental() Element get fullscreenElement {}   @DomName('Document.fullscreenEnabled') @DocsEditable() @Experimental() bool get fullscreenEnabled {}    @DomName('Document.hidden') @DocsEditable() @Experimental() bool get hidden {}   @DomName('Document.implementation') @DocsEditable() DomImplementation get implementation {}    @DomName('Document.pointerLockElement') @DocsEditable() @Experimental() Element get pointerLockElement {}    @DomName('Document.readyState') @DocsEditable() String get readyState {}    @DomName('Document.rootElement') @DocsEditable() @Experimental() SvgSvgElement get rootElement {}      @DomName('Document.timeline') @DocsEditable() @Experimental() AnimationTimeline get timeline {}     @DomName('Document.visibilityState') @DocsEditable() @Experimental() String get visibilityState {}       @DomName('Document.adoptNode') @DocsEditable() Node adoptNode(Node node) {}    @DomName('Document.createDocumentFragment') @DocsEditable() DocumentFragment createDocumentFragment() {}    @DomName('Document.createElementNS') @DocsEditable() Element createElementNS(String namespaceURI, String qualifiedName, [String typeExtension]) {}     @DomName('Document.createRange') @DocsEditable() Range createRange() {}        @DomName('Document.execCommand') @DocsEditable() bool execCommand(String command, bool userInterface, String value) {}   @DomName('Document.exitFullscreen') @DocsEditable() @Experimental() void exitFullscreen() {}   @DomName('Document.exitPointerLock') @DocsEditable() @Experimental() void exitPointerLock() {}    @DomName('Document.getElementById') @DocsEditable() Element getElementById(String elementId) {}   @DomName('Document.getElementsByClassName') @DocsEditable() List<Node> getElementsByClassName(String classNames) {}   @DomName('Document.getElementsByName') @DocsEditable() List<Node> getElementsByName(String elementName) {}   @DomName('Document.getElementsByTagName') @DocsEditable() List<Node> getElementsByTagName(String localName) {}   Node importNode(Node node, [bool deep]) {}   @DomName('Document.queryCommandEnabled') @DocsEditable() bool queryCommandEnabled(String command) {}   @DomName('Document.queryCommandIndeterm') @DocsEditable() bool queryCommandIndeterm(String command) {}   @DomName('Document.queryCommandState') @DocsEditable() bool queryCommandState(String command) {}   @DomName('Document.queryCommandSupported') @DocsEditable() bool queryCommandSupported(String command) {}   @DomName('Document.queryCommandValue') @DocsEditable() String queryCommandValue(String command) {}        @DomName('Document.querySelector') @DocsEditable() Element querySelector(String selectors) {}    @DomName('Document.onabort') @DocsEditable() Stream<Event> get onAbort {}   @DomName('Document.onbeforecopy') @DocsEditable() Stream<Event> get onBeforeCopy {}   @DomName('Document.onbeforecut') @DocsEditable() Stream<Event> get onBeforeCut {}   @DomName('Document.onbeforepaste') @DocsEditable() Stream<Event> get onBeforePaste {}   @DomName('Document.onblur') @DocsEditable() Stream<Event> get onBlur {}   @DomName('Document.oncanplay') @DocsEditable() @Experimental() Stream<Event> get onCanPlay {}   @DomName('Document.oncanplaythrough') @DocsEditable() @Experimental() Stream<Event> get onCanPlayThrough {}   @DomName('Document.onchange') @DocsEditable() Stream<Event> get onChange {}   @DomName('Document.onclick') @DocsEditable() Stream<MouseEvent> get onClick {}   @DomName('Document.oncontextmenu') @DocsEditable() Stream<MouseEvent> get onContextMenu {}   @DomName('Document.oncopy') @DocsEditable() Stream<Event> get onCopy {}   @DomName('Document.oncut') @DocsEditable() Stream<Event> get onCut {}   @DomName('Document.ondblclick') @DocsEditable() Stream<Event> get onDoubleClick {}   @DomName('Document.ondrag') @DocsEditable() Stream<MouseEvent> get onDrag {}   @DomName('Document.ondragend') @DocsEditable() Stream<MouseEvent> get onDragEnd {}   @DomName('Document.ondragenter') @DocsEditable() Stream<MouseEvent> get onDragEnter {}   @DomName('Document.ondragleave') @DocsEditable() Stream<MouseEvent> get onDragLeave {}   @DomName('Document.ondragover') @DocsEditable() Stream<MouseEvent> get onDragOver {}   @DomName('Document.ondragstart') @DocsEditable() Stream<MouseEvent> get onDragStart {}   @DomName('Document.ondrop') @DocsEditable() Stream<MouseEvent> get onDrop {}   @DomName('Document.ondurationchange') @DocsEditable() @Experimental() Stream<Event> get onDurationChange {}   @DomName('Document.onemptied') @DocsEditable() @Experimental() Stream<Event> get onEmptied {}   @DomName('Document.onended') @DocsEditable() @Experimental() Stream<Event> get onEnded {}   @DomName('Document.onerror') @DocsEditable() Stream<Event> get onError {}   @DomName('Document.onfocus') @DocsEditable() Stream<Event> get onFocus {}   @DomName('Document.oninput') @DocsEditable() Stream<Event> get onInput {}   @DomName('Document.oninvalid') @DocsEditable() Stream<Event> get onInvalid {}   @DomName('Document.onkeydown') @DocsEditable() Stream<KeyboardEvent> get onKeyDown {}   @DomName('Document.onkeypress') @DocsEditable() Stream<KeyboardEvent> get onKeyPress {}   @DomName('Document.onkeyup') @DocsEditable() Stream<KeyboardEvent> get onKeyUp {}   @DomName('Document.onload') @DocsEditable() Stream<Event> get onLoad {}   @DomName('Document.onloadeddata') @DocsEditable() @Experimental() Stream<Event> get onLoadedData {}   @DomName('Document.onloadedmetadata') @DocsEditable() @Experimental() Stream<Event> get onLoadedMetadata {}   @DomName('Document.onmousedown') @DocsEditable() Stream<MouseEvent> get onMouseDown {}   @DomName('Document.onmouseenter') @DocsEditable() @Experimental() Stream<MouseEvent> get onMouseEnter {}   @DomName('Document.onmouseleave') @DocsEditable() @Experimental() Stream<MouseEvent> get onMouseLeave {}   @DomName('Document.onmousemove') @DocsEditable() Stream<MouseEvent> get onMouseMove {}   @DomName('Document.onmouseout') @DocsEditable() Stream<MouseEvent> get onMouseOut {}   @DomName('Document.onmouseover') @DocsEditable() Stream<MouseEvent> get onMouseOver {}   @DomName('Document.onmouseup') @DocsEditable() Stream<MouseEvent> get onMouseUp {}   @DomName('Document.onmousewheel') @DocsEditable() Stream<WheelEvent> get onMouseWheel {}   @DomName('Document.onpaste') @DocsEditable() Stream<Event> get onPaste {}   @DomName('Document.onpause') @DocsEditable() @Experimental() Stream<Event> get onPause {}   @DomName('Document.onplay') @DocsEditable() @Experimental() Stream<Event> get onPlay {}   @DomName('Document.onplaying') @DocsEditable() @Experimental() Stream<Event> get onPlaying {}   @DomName('Document.onpointerlockchange') @DocsEditable() @Experimental() Stream<Event> get onPointerLockChange {}   @DomName('Document.onpointerlockerror') @DocsEditable() @Experimental() Stream<Event> get onPointerLockError {}   @DomName('Document.onratechange') @DocsEditable() @Experimental() Stream<Event> get onRateChange {}   @DomName('Document.onreadystatechange') @DocsEditable() Stream<Event> get onReadyStateChange {}   @DomName('Document.onreset') @DocsEditable() Stream<Event> get onReset {}   @DomName('Document.onresize') @DocsEditable() @Experimental() Stream<Event> get onResize {}   @DomName('Document.onscroll') @DocsEditable() Stream<Event> get onScroll {}   @DomName('Document.onsearch') @DocsEditable() @Experimental() Stream<Event> get onSearch {}   @DomName('Document.onsecuritypolicyviolation') @DocsEditable() @Experimental() Stream<SecurityPolicyViolationEvent> get onSecurityPolicyViolation {}   @DomName('Document.onseeked') @DocsEditable() @Experimental() Stream<Event> get onSeeked {}   @DomName('Document.onseeking') @DocsEditable() @Experimental() Stream<Event> get onSeeking {}   @DomName('Document.onselect') @DocsEditable() Stream<Event> get onSelect {}   @DomName('Document.onselectionchange') @DocsEditable() Stream<Event> get onSelectionChange {}   @DomName('Document.onselectstart') @DocsEditable() Stream<Event> get onSelectStart {}   @DomName('Document.onstalled') @DocsEditable() @Experimental() Stream<Event> get onStalled {}   @DomName('Document.onsubmit') @DocsEditable() Stream<Event> get onSubmit {}   @DomName('Document.onsuspend') @DocsEditable() @Experimental() Stream<Event> get onSuspend {}   @DomName('Document.ontimeupdate') @DocsEditable() @Experimental() Stream<Event> get onTimeUpdate {}   @DomName('Document.ontouchcancel') @DocsEditable() @Experimental() Stream<TouchEvent> get onTouchCancel {}   @DomName('Document.ontouchend') @DocsEditable() @Experimental() Stream<TouchEvent> get onTouchEnd {}   @DomName('Document.ontouchmove') @DocsEditable() @Experimental() Stream<TouchEvent> get onTouchMove {}   @DomName('Document.ontouchstart') @DocsEditable() @Experimental() Stream<TouchEvent> get onTouchStart {}   @DomName('Document.onvolumechange') @DocsEditable() @Experimental() Stream<Event> get onVolumeChange {}   @DomName('Document.onwaiting') @DocsEditable() @Experimental() Stream<Event> get onWaiting {}   @DomName('Document.onwebkitfullscreenchange') @DocsEditable() @Experimental() Stream<Event> get onFullscreenChange {}   @DomName('Document.onwebkitfullscreenerror') @DocsEditable() @Experimental() Stream<Event> get onFullscreenError {}   ElementList querySelectorAll(String selectors) {}   @deprecated @Experimental() @DomName('Document.querySelector') Element query(String relativeSelectors) {}   @deprecated @Experimental() @DomName('Document.querySelectorAll') ElementList queryAll(String relativeSelectors) {}   bool get supportsRegisterElement {}   @deprecated bool get supportsRegister {}   @DomName('Document.createElement') Element createElement(String tagName, [String typeExtension]) {} } @DomName('DocumentFragment') class DocumentFragment extends Node implements ParentNode { factory DocumentFragment() { throw new UnsupportedError("new DocumentFragment() is unsupported on this platform."); }   factory DocumentFragment.html(String html, {NodeValidator validator, NodeTreeSanitizer treeSanitizer}) { throw new UnsupportedError("new DocumentFragment.html() is unsupported on this platform."); }   factory DocumentFragment.svg(String svgContent, {NodeValidator validator, NodeTreeSanitizer treeSanitizer}) { throw new UnsupportedError("new DocumentFragment.svg() is unsupported on this platform."); }      List<Element> get children {}   void set children(List<Element> value) {}   ElementList querySelectorAll(String selectors) {}   String get innerHtml {}   void set innerHtml(String value) {}   void setInnerHtml(String html, {NodeValidator validator, NodeTreeSanitizer treeSanitizer}) {}   void appendText(String text) {}   void appendHtml(String text) {}   @deprecated @Experimental() @DomName('DocumentFragment.querySelector') Element query(String relativeSelectors) {}   @deprecated @Experimental() @DomName('DocumentFragment.querySelectorAll') ElementList queryAll(String relativeSelectors) {}   factory DocumentFragment._() { throw new UnsupportedError("new DocumentFragment._() is unsupported on this platform."); }   @DomName('DocumentFragment.getElementById') @DocsEditable() @Experimental() Element getElementById(String elementId) {}      @DomName('DocumentFragment.querySelector') @DocsEditable() Element querySelector(String selectors) {}  } @DocsEditable() @DomName('DOMError') class DomError extends NativeFieldWrapperClass2 { factory DomError._() { throw new UnsupportedError("new DomError._() is unsupported on this platform."); }   @DomName('DOMError.DOMError') @DocsEditable() factory DomError(String name, [String message]) { throw new UnsupportedError("new DomError() is unsupported on this platform."); }   @DomName('DOMError.message') @DocsEditable() @Experimental() String get message {}   @DomName('DOMError.name') @DocsEditable() String get name {} } @DomName('DOMException') @Unstable() class DomException extends NativeFieldWrapperClass2 { static const INDEX_SIZE = 'IndexSizeError';   static const HIERARCHY_REQUEST = 'HierarchyRequestError';   static const WRONG_DOCUMENT = 'WrongDocumentError';   static const INVALID_CHARACTER = 'InvalidCharacterError';   static const NO_MODIFICATION_ALLOWED = 'NoModificationAllowedError';   static const NOT_FOUND = 'NotFoundError';   static const NOT_SUPPORTED = 'NotSupportedError';   static const INVALID_STATE = 'InvalidStateError';   static const SYNTAX = 'SyntaxError';   static const INVALID_MODIFICATION = 'InvalidModificationError';   static const NAMESPACE = 'NamespaceError';   static const INVALID_ACCESS = 'InvalidAccessError';   static const TYPE_MISMATCH = 'TypeMismatchError';   static const SECURITY = 'SecurityError';   static const NETWORK = 'NetworkError';   static const ABORT = 'AbortError';   static const URL_MISMATCH = 'URLMismatchError';   static const QUOTA_EXCEEDED = 'QuotaExceededError';   static const TIMEOUT = 'TimeoutError';   static const INVALID_NODE_TYPE = 'InvalidNodeTypeError';   static const DATA_CLONE = 'DataCloneError';   factory DomException._() { throw new UnsupportedError("new DomException._() is unsupported on this platform."); }   @DomName('DOMException.message') @DocsEditable() String get message {}   @DomName('DOMException.name') @DocsEditable() String get name {}   @DomName('DOMException.toString') @DocsEditable() String toString() {} } @DocsEditable() @DomName('DOMImplementation') class DomImplementation extends NativeFieldWrapperClass2 { factory DomImplementation._() { throw new UnsupportedError("new DomImplementation._() is unsupported on this platform."); }   @DomName('DOMImplementation.createDocument') @DocsEditable() XmlDocument createDocument(String namespaceURI, String qualifiedName, _DocumentType doctype) {}   @DomName('DOMImplementation.createDocumentType') @DocsEditable() _DocumentType createDocumentType(String qualifiedName, String publicId, String systemId) {}   @DomName('DOMImplementation.createHTMLDocument') @DocsEditable() HtmlDocument createHtmlDocument(String title) {}   @DomName('DOMImplementation.hasFeature') @DocsEditable() bool hasFeature(String feature, String version) {} } @DocsEditable() @DomName('DOMMatrix') @Experimental() class DomMatrix extends DomMatrixReadOnly { factory DomMatrix._() { throw new UnsupportedError("new DomMatrix._() is unsupported on this platform."); }   @DomName('DOMMatrix.DOMMatrix') @DocsEditable() factory DomMatrix([DomMatrixReadOnly other]) { throw new UnsupportedError("new DomMatrix() is unsupported on this platform."); }   @DomName('DOMMatrix.a') @DocsEditable() @Experimental() num get a {}   @DomName('DOMMatrix.a') @DocsEditable() @Experimental() void set a(num value) {}   @DomName('DOMMatrix.b') @DocsEditable() @Experimental() num get b {}   @DomName('DOMMatrix.b') @DocsEditable() @Experimental() void set b(num value) {}   @DomName('DOMMatrix.c') @DocsEditable() @Experimental() num get c {}   @DomName('DOMMatrix.c') @DocsEditable() @Experimental() void set c(num value) {}   @DomName('DOMMatrix.d') @DocsEditable() @Experimental() num get d {}   @DomName('DOMMatrix.d') @DocsEditable() @Experimental() void set d(num value) {}   @DomName('DOMMatrix.e') @DocsEditable() @Experimental() num get e {}   @DomName('DOMMatrix.e') @DocsEditable() @Experimental() void set e(num value) {}   @DomName('DOMMatrix.f') @DocsEditable() @Experimental() num get f {}   @DomName('DOMMatrix.f') @DocsEditable() @Experimental() void set f(num value) {}   @DomName('DOMMatrix.m11') @DocsEditable() @Experimental() num get m11 {}   @DomName('DOMMatrix.m11') @DocsEditable() @Experimental() void set m11(num value) {}   @DomName('DOMMatrix.m12') @DocsEditable() @Experimental() num get m12 {}   @DomName('DOMMatrix.m12') @DocsEditable() @Experimental() void set m12(num value) {}   @DomName('DOMMatrix.m13') @DocsEditable() @Experimental() num get m13 {}   @DomName('DOMMatrix.m13') @DocsEditable() @Experimental() void set m13(num value) {}   @DomName('DOMMatrix.m14') @DocsEditable() @Experimental() num get m14 {}   @DomName('DOMMatrix.m14') @DocsEditable() @Experimental() void set m14(num value) {}   @DomName('DOMMatrix.m21') @DocsEditable() @Experimental() num get m21 {}   @DomName('DOMMatrix.m21') @DocsEditable() @Experimental() void set m21(num value) {}   @DomName('DOMMatrix.m22') @DocsEditable() @Experimental() num get m22 {}   @DomName('DOMMatrix.m22') @DocsEditable() @Experimental() void set m22(num value) {}   @DomName('DOMMatrix.m23') @DocsEditable() @Experimental() num get m23 {}   @DomName('DOMMatrix.m23') @DocsEditable() @Experimental() void set m23(num value) {}   @DomName('DOMMatrix.m24') @DocsEditable() @Experimental() num get m24 {}   @DomName('DOMMatrix.m24') @DocsEditable() @Experimental() void set m24(num value) {}   @DomName('DOMMatrix.m31') @DocsEditable() @Experimental() num get m31 {}   @DomName('DOMMatrix.m31') @DocsEditable() @Experimental() void set m31(num value) {}   @DomName('DOMMatrix.m32') @DocsEditable() @Experimental() num get m32 {}   @DomName('DOMMatrix.m32') @DocsEditable() @Experimental() void set m32(num value) {}   @DomName('DOMMatrix.m33') @DocsEditable() @Experimental() num get m33 {}   @DomName('DOMMatrix.m33') @DocsEditable() @Experimental() void set m33(num value) {}   @DomName('DOMMatrix.m34') @DocsEditable() @Experimental() num get m34 {}   @DomName('DOMMatrix.m34') @DocsEditable() @Experimental() void set m34(num value) {}   @DomName('DOMMatrix.m41') @DocsEditable() @Experimental() num get m41 {}   @DomName('DOMMatrix.m41') @DocsEditable() @Experimental() void set m41(num value) {}   @DomName('DOMMatrix.m42') @DocsEditable() @Experimental() num get m42 {}   @DomName('DOMMatrix.m42') @DocsEditable() @Experimental() void set m42(num value) {}   @DomName('DOMMatrix.m43') @DocsEditable() @Experimental() num get m43 {}   @DomName('DOMMatrix.m43') @DocsEditable() @Experimental() void set m43(num value) {}   @DomName('DOMMatrix.m44') @DocsEditable() @Experimental() num get m44 {}   @DomName('DOMMatrix.m44') @DocsEditable() @Experimental() void set m44(num value) {} } @DocsEditable() @DomName('DOMMatrixReadOnly') @Experimental() class DomMatrixReadOnly extends NativeFieldWrapperClass2 { factory DomMatrixReadOnly._() { throw new UnsupportedError("new DomMatrixReadOnly._() is unsupported on this platform."); }   @DomName('DOMMatrixReadOnly.a') @DocsEditable() @Experimental() double get a {}   @DomName('DOMMatrixReadOnly.b') @DocsEditable() @Experimental() double get b {}   @DomName('DOMMatrixReadOnly.c') @DocsEditable() @Experimental() double get c {}   @DomName('DOMMatrixReadOnly.d') @DocsEditable() @Experimental() double get d {}   @DomName('DOMMatrixReadOnly.e') @DocsEditable() @Experimental() double get e {}   @DomName('DOMMatrixReadOnly.f') @DocsEditable() @Experimental() double get f {}   @DomName('DOMMatrixReadOnly.is2D') @DocsEditable() @Experimental() bool get is2D {}   @DomName('DOMMatrixReadOnly.isIdentity') @DocsEditable() @Experimental() bool get isIdentity {}   @DomName('DOMMatrixReadOnly.m11') @DocsEditable() @Experimental() double get m11 {}   @DomName('DOMMatrixReadOnly.m12') @DocsEditable() @Experimental() double get m12 {}   @DomName('DOMMatrixReadOnly.m13') @DocsEditable() @Experimental() double get m13 {}   @DomName('DOMMatrixReadOnly.m14') @DocsEditable() @Experimental() double get m14 {}   @DomName('DOMMatrixReadOnly.m21') @DocsEditable() @Experimental() double get m21 {}   @DomName('DOMMatrixReadOnly.m22') @DocsEditable() @Experimental() double get m22 {}   @DomName('DOMMatrixReadOnly.m23') @DocsEditable() @Experimental() double get m23 {}   @DomName('DOMMatrixReadOnly.m24') @DocsEditable() @Experimental() double get m24 {}   @DomName('DOMMatrixReadOnly.m31') @DocsEditable() @Experimental() double get m31 {}   @DomName('DOMMatrixReadOnly.m32') @DocsEditable() @Experimental() double get m32 {}   @DomName('DOMMatrixReadOnly.m33') @DocsEditable() @Experimental() double get m33 {}   @DomName('DOMMatrixReadOnly.m34') @DocsEditable() @Experimental() double get m34 {}   @DomName('DOMMatrixReadOnly.m41') @DocsEditable() @Experimental() double get m41 {}   @DomName('DOMMatrixReadOnly.m42') @DocsEditable() @Experimental() double get m42 {}   @DomName('DOMMatrixReadOnly.m43') @DocsEditable() @Experimental() double get m43 {}   @DomName('DOMMatrixReadOnly.m44') @DocsEditable() @Experimental() double get m44 {} } @DocsEditable() @DomName('DOMParser') class DomParser extends NativeFieldWrapperClass2 { factory DomParser._() { throw new UnsupportedError("new DomParser._() is unsupported on this platform."); }   @DomName('DOMParser.DOMParser') @DocsEditable() factory DomParser() { throw new UnsupportedError("new DomParser() is unsupported on this platform."); }   @DomName('DOMParser.parseFromString') @DocsEditable() Document parseFromString(String str, String contentType) {} } @DocsEditable() @DomName('DOMPoint') @Experimental() class DomPoint extends DomPointReadOnly { factory DomPoint._() { throw new UnsupportedError("new DomPoint._() is unsupported on this platform."); }   @DomName('DOMPoint.DOMPoint') @DocsEditable() factory DomPoint([point_OR_x, num y, num z, num w]) { throw new UnsupportedError("new DomPoint() is unsupported on this platform."); }   @DomName('DOMPoint.w') @DocsEditable() @Experimental() num get w {}   @DomName('DOMPoint.w') @DocsEditable() @Experimental() void set w(num value) {}   @DomName('DOMPoint.x') @DocsEditable() @Experimental() num get x {}   @DomName('DOMPoint.x') @DocsEditable() @Experimental() void set x(num value) {}   @DomName('DOMPoint.y') @DocsEditable() @Experimental() num get y {}   @DomName('DOMPoint.y') @DocsEditable() @Experimental() void set y(num value) {}   @DomName('DOMPoint.z') @DocsEditable() @Experimental() num get z {}   @DomName('DOMPoint.z') @DocsEditable() @Experimental() void set z(num value) {} } @DocsEditable() @DomName('DOMPointReadOnly') @Experimental() class DomPointReadOnly extends NativeFieldWrapperClass2 { factory DomPointReadOnly._() { throw new UnsupportedError("new DomPointReadOnly._() is unsupported on this platform."); }   @DomName('DOMPointReadOnly.DOMPointReadOnly') @DocsEditable() factory DomPointReadOnly(num x, num y, num z, num w) { throw new UnsupportedError("new DomPointReadOnly() is unsupported on this platform."); }   @DomName('DOMPointReadOnly.w') @DocsEditable() @Experimental() double get w {}   @DomName('DOMPointReadOnly.x') @DocsEditable() @Experimental() double get x {}   @DomName('DOMPointReadOnly.y') @DocsEditable() @Experimental() double get y {}   @DomName('DOMPointReadOnly.z') @DocsEditable() @Experimental() double get z {} } @DocsEditable() @DomName('DOMRectReadOnly') @Experimental() class DomRectReadOnly extends NativeFieldWrapperClass2 implements Rectangle { String toString() {}   bool operator ==(other) {}   int get hashCode {}   Rectangle intersection(Rectangle other) {}   bool intersects(Rectangle<num> other) {}   Rectangle boundingBox(Rectangle other) {}   bool containsRectangle(Rectangle<num> another) {}   bool containsPoint(Point<num> another) {}   Point get topLeft {}   Point get topRight {}   Point get bottomRight {}   Point get bottomLeft {}   factory DomRectReadOnly._() { throw new UnsupportedError("new DomRectReadOnly._() is unsupported on this platform."); }   @DomName('DOMRectReadOnly.DOMRectReadOnly') @DocsEditable() factory DomRectReadOnly(num x, num y, num width, num height) { throw new UnsupportedError("new DomRectReadOnly() is unsupported on this platform."); }   @DomName('DOMRectReadOnly.bottom') @DocsEditable() @Experimental() double get bottom {}   @DomName('DOMRectReadOnly.height') @DocsEditable() @Experimental() double get height {}   @DomName('DOMRectReadOnly.left') @DocsEditable() @Experimental() double get left {}   @DomName('DOMRectReadOnly.right') @DocsEditable() @Experimental() double get right {}   @DomName('DOMRectReadOnly.top') @DocsEditable() @Experimental() double get top {}   @DomName('DOMRectReadOnly.width') @DocsEditable() @Experimental() double get width {}   @DomName('DOMRectReadOnly.x') @DocsEditable() @Experimental() double get x {}   @DomName('DOMRectReadOnly.y') @DocsEditable() @Experimental() double get y {} } @DocsEditable() @DomName('DOMSettableTokenList') class DomSettableTokenList extends DomTokenList { factory DomSettableTokenList._() { throw new UnsupportedError("new DomSettableTokenList._() is unsupported on this platform."); }   @DomName('DOMSettableTokenList.value') @DocsEditable() String get value {}   @DomName('DOMSettableTokenList.value') @DocsEditable() void set value(String value) {}  } @DocsEditable() @DomName('DOMStringList') class DomStringList extends NativeFieldWrapperClass2 with ListMixin<String>, ImmutableListMixin<String> implements List<String> { factory DomStringList._() { throw new UnsupportedError("new DomStringList._() is unsupported on this platform."); }   @DomName('DOMStringList.length') @DocsEditable() int get length {}   String operator [](int index) {}    void operator []=(int index, String value) {}   void set length(int value) {}   String get first {}   String get last {}   String get single {}   String elementAt(int index) {}   @DomName('DOMStringList.contains') @DocsEditable() bool contains(String string) {}   @DomName('DOMStringList.item') @DocsEditable() String item(int index) {} } @DocsEditable() @DomName('DOMStringMap') abstract class DomStringMap extends NativeFieldWrapperClass2 { factory DomStringMap._() { throw new UnsupportedError("new DomStringMap._() is unsupported on this platform."); }    } @DocsEditable() @DomName('DOMTokenList') class DomTokenList extends NativeFieldWrapperClass2 { factory DomTokenList._() { throw new UnsupportedError("new DomTokenList._() is unsupported on this platform."); }   @DomName('DOMTokenList.length') @DocsEditable() int get length {}   @DomName('DOMTokenList.add') @DocsEditable() @Experimental() void add(String tokens) {}   @DomName('DOMTokenList.contains') @DocsEditable() bool contains(String token) {}   @DomName('DOMTokenList.item') @DocsEditable() String item(int index) {}   @DomName('DOMTokenList.remove') @DocsEditable() @Experimental() void remove(String tokens) {}   bool toggle(String token, [bool force]) {} } class _ChildrenElementList extends ListBase<Element> implements NodeListWrapper {     _ChildrenElementList._wrap(Element element) { throw new UnsupportedError("new _ChildrenElementList._wrap() is unsupported on this platform."); }   bool contains(Object element) {}   bool get isEmpty {}   int get length {}   Element operator [](int index) {}   void operator []=(int index, Element value) {}   void set length(int newLength) {}   Element add(Element value) {}   Iterator<Element> get iterator {}   void addAll(Iterable<Element> iterable) {}   void sort([int compare(Element a, Element b)]) {}   void shuffle([Random random]) {}   void removeWhere(bool test(Element element)) {}   void retainWhere(bool test(Element element)) {}    void setRange(int start, int end, Iterable<Element> iterable, [int skipCount = 0]) {}   void replaceRange(int start, int end, Iterable<Element> iterable) {}   void fillRange(int start, int end, [Element fillValue]) {}   bool remove(Object object) {}   void insert(int index, Element element) {}   void setAll(int index, Iterable<Element> iterable) {}   void clear() {}   Element removeAt(int index) {}   Element removeLast() {}   Element get first {}   Element get last {}   Element get single {}   List<Node> get rawList {} } abstract class ElementList<T extends Element> extends ListBase<T> { CssClassSet get classes;   set classes(Iterable<String> value);   CssStyleDeclarationBase get style;   @Experimental() CssRect get contentEdge;   @Experimental() CssRect get paddingEdge;   @Experimental() CssRect get borderEdge;   @Experimental() CssRect get marginEdge;   @DomName('Element.onabort') @DocsEditable() ElementStream<Event> get onAbort;   @DomName('Element.onbeforecopy') @DocsEditable() ElementStream<Event> get onBeforeCopy;   @DomName('Element.onbeforecut') @DocsEditable() ElementStream<Event> get onBeforeCut;   @DomName('Element.onbeforepaste') @DocsEditable() ElementStream<Event> get onBeforePaste;   @DomName('Element.onblur') @DocsEditable() ElementStream<Event> get onBlur;   @DomName('Element.oncanplay') @DocsEditable() @Experimental() ElementStream<Event> get onCanPlay;   @DomName('Element.oncanplaythrough') @DocsEditable() @Experimental() ElementStream<Event> get onCanPlayThrough;   @DomName('Element.onchange') @DocsEditable() ElementStream<Event> get onChange;   @DomName('Element.onclick') @DocsEditable() ElementStream<MouseEvent> get onClick;   @DomName('Element.oncontextmenu') @DocsEditable() ElementStream<MouseEvent> get onContextMenu;   @DomName('Element.oncopy') @DocsEditable() ElementStream<Event> get onCopy;   @DomName('Element.oncut') @DocsEditable() ElementStream<Event> get onCut;   @DomName('Element.ondblclick') @DocsEditable() ElementStream<Event> get onDoubleClick;   @DomName('Element.ondrag') @DocsEditable() ElementStream<MouseEvent> get onDrag;   @DomName('Element.ondragend') @DocsEditable() ElementStream<MouseEvent> get onDragEnd;   @DomName('Element.ondragenter') @DocsEditable() ElementStream<MouseEvent> get onDragEnter;   @DomName('Element.ondragleave') @DocsEditable() ElementStream<MouseEvent> get onDragLeave;   @DomName('Element.ondragover') @DocsEditable() ElementStream<MouseEvent> get onDragOver;   @DomName('Element.ondragstart') @DocsEditable() ElementStream<MouseEvent> get onDragStart;   @DomName('Element.ondrop') @DocsEditable() ElementStream<MouseEvent> get onDrop;   @DomName('Element.ondurationchange') @DocsEditable() @Experimental() ElementStream<Event> get onDurationChange;   @DomName('Element.onemptied') @DocsEditable() @Experimental() ElementStream<Event> get onEmptied;   @DomName('Element.onended') @DocsEditable() @Experimental() ElementStream<Event> get onEnded;   @DomName('Element.onerror') @DocsEditable() ElementStream<Event> get onError;   @DomName('Element.onfocus') @DocsEditable() ElementStream<Event> get onFocus;   @DomName('Element.oninput') @DocsEditable() ElementStream<Event> get onInput;   @DomName('Element.oninvalid') @DocsEditable() ElementStream<Event> get onInvalid;   @DomName('Element.onkeydown') @DocsEditable() ElementStream<KeyboardEvent> get onKeyDown;   @DomName('Element.onkeypress') @DocsEditable() ElementStream<KeyboardEvent> get onKeyPress;   @DomName('Element.onkeyup') @DocsEditable() ElementStream<KeyboardEvent> get onKeyUp;   @DomName('Element.onload') @DocsEditable() ElementStream<Event> get onLoad;   @DomName('Element.onloadeddata') @DocsEditable() @Experimental() ElementStream<Event> get onLoadedData;   @DomName('Element.onloadedmetadata') @DocsEditable() @Experimental() ElementStream<Event> get onLoadedMetadata;   @DomName('Element.onmousedown') @DocsEditable() ElementStream<MouseEvent> get onMouseDown;   @DomName('Element.onmouseenter') @DocsEditable() @Experimental() ElementStream<MouseEvent> get onMouseEnter;   @DomName('Element.onmouseleave') @DocsEditable() @Experimental() ElementStream<MouseEvent> get onMouseLeave;   @DomName('Element.onmousemove') @DocsEditable() ElementStream<MouseEvent> get onMouseMove;   @DomName('Element.onmouseout') @DocsEditable() ElementStream<MouseEvent> get onMouseOut;   @DomName('Element.onmouseover') @DocsEditable() ElementStream<MouseEvent> get onMouseOver;   @DomName('Element.onmouseup') @DocsEditable() ElementStream<MouseEvent> get onMouseUp;   @DomName('Element.onmousewheel') @DocsEditable() @Experimental() ElementStream<WheelEvent> get onMouseWheel;   @DomName('Element.onpaste') @DocsEditable() ElementStream<Event> get onPaste;   @DomName('Element.onpause') @DocsEditable() @Experimental() ElementStream<Event> get onPause;   @DomName('Element.onplay') @DocsEditable() @Experimental() ElementStream<Event> get onPlay;   @DomName('Element.onplaying') @DocsEditable() @Experimental() ElementStream<Event> get onPlaying;   @DomName('Element.onratechange') @DocsEditable() @Experimental() ElementStream<Event> get onRateChange;   @DomName('Element.onreset') @DocsEditable() ElementStream<Event> get onReset;   @DomName('Element.onresize') @DocsEditable() @Experimental() ElementStream<Event> get onResize;   @DomName('Element.onscroll') @DocsEditable() ElementStream<Event> get onScroll;   @DomName('Element.onsearch') @DocsEditable() @Experimental() ElementStream<Event> get onSearch;   @DomName('Element.onseeked') @DocsEditable() @Experimental() ElementStream<Event> get onSeeked;   @DomName('Element.onseeking') @DocsEditable() @Experimental() ElementStream<Event> get onSeeking;   @DomName('Element.onselect') @DocsEditable() ElementStream<Event> get onSelect;   @DomName('Element.onselectstart') @DocsEditable() @Experimental() ElementStream<Event> get onSelectStart;   @DomName('Element.onstalled') @DocsEditable() @Experimental() ElementStream<Event> get onStalled;   @DomName('Element.onsubmit') @DocsEditable() ElementStream<Event> get onSubmit;   @DomName('Element.onsuspend') @DocsEditable() @Experimental() ElementStream<Event> get onSuspend;   @DomName('Element.ontimeupdate') @DocsEditable() @Experimental() ElementStream<Event> get onTimeUpdate;   @DomName('Element.ontouchcancel') @DocsEditable() @Experimental() ElementStream<TouchEvent> get onTouchCancel;   @DomName('Element.ontouchend') @DocsEditable() @Experimental() ElementStream<TouchEvent> get onTouchEnd;   @DomName('Element.ontouchenter') @DocsEditable() @Experimental() ElementStream<TouchEvent> get onTouchEnter;   @DomName('Element.ontouchleave') @DocsEditable() @Experimental() ElementStream<TouchEvent> get onTouchLeave;   @DomName('Element.ontouchmove') @DocsEditable() @Experimental() ElementStream<TouchEvent> get onTouchMove;   @DomName('Element.ontouchstart') @DocsEditable() @Experimental() ElementStream<TouchEvent> get onTouchStart;   @DomName('Element.ontransitionend') @DocsEditable() @SupportedBrowser(SupportedBrowser.CHROME) @SupportedBrowser(SupportedBrowser.FIREFOX) @SupportedBrowser(SupportedBrowser.IE, '10') @SupportedBrowser(SupportedBrowser.SAFARI) ElementStream<TransitionEvent> get onTransitionEnd;   @DomName('Element.onvolumechange') @DocsEditable() @Experimental() ElementStream<Event> get onVolumeChange;   @DomName('Element.onwaiting') @DocsEditable() @Experimental() ElementStream<Event> get onWaiting;   @DomName('Element.onwebkitfullscreenchange') @DocsEditable() @Experimental() ElementStream<Event> get onFullscreenChange;   @DomName('Element.onwebkitfullscreenerror') @DocsEditable() @Experimental() ElementStream<Event> get onFullscreenError; } class _FrozenElementList extends ListBase implements ElementList, NodeListWrapper {   _FrozenElementList._wrap(List<Node> _nodeList) { throw new UnsupportedError("new _FrozenElementList._wrap() is unsupported on this platform."); }   int get length {}   Element operator [](int index) {}   void operator []=(int index, Element value) {}   void set length(int newLength) {}   void sort([Comparator<Element> compare]) {}   void shuffle([Random random]) {}   Element get first {}   Element get last {}   Element get single {}   CssClassSet get classes {}   CssStyleDeclarationBase get style {}   void set classes(Iterable<String> value) {}   CssRect get contentEdge {}   CssRect get paddingEdge {}   CssRect get borderEdge {}   CssRect get marginEdge {}   List<Node> get rawList {}   @DomName('Element.onabort') @DocsEditable() ElementStream<Event> get onAbort {}   @DomName('Element.onbeforecopy') @DocsEditable() ElementStream<Event> get onBeforeCopy {}   @DomName('Element.onbeforecut') @DocsEditable() ElementStream<Event> get onBeforeCut {}   @DomName('Element.onbeforepaste') @DocsEditable() ElementStream<Event> get onBeforePaste {}   @DomName('Element.onblur') @DocsEditable() ElementStream<Event> get onBlur {}   @DomName('Element.oncanplay') @DocsEditable() @Experimental() ElementStream<Event> get onCanPlay {}   @DomName('Element.oncanplaythrough') @DocsEditable() @Experimental() ElementStream<Event> get onCanPlayThrough {}   @DomName('Element.onchange') @DocsEditable() ElementStream<Event> get onChange {}   @DomName('Element.onclick') @DocsEditable() ElementStream<MouseEvent> get onClick {}   @DomName('Element.oncontextmenu') @DocsEditable() ElementStream<MouseEvent> get onContextMenu {}   @DomName('Element.oncopy') @DocsEditable() ElementStream<Event> get onCopy {}   @DomName('Element.oncut') @DocsEditable() ElementStream<Event> get onCut {}   @DomName('Element.ondblclick') @DocsEditable() ElementStream<Event> get onDoubleClick {}   @DomName('Element.ondrag') @DocsEditable() ElementStream<MouseEvent> get onDrag {}   @DomName('Element.ondragend') @DocsEditable() ElementStream<MouseEvent> get onDragEnd {}   @DomName('Element.ondragenter') @DocsEditable() ElementStream<MouseEvent> get onDragEnter {}   @DomName('Element.ondragleave') @DocsEditable() ElementStream<MouseEvent> get onDragLeave {}   @DomName('Element.ondragover') @DocsEditable() ElementStream<MouseEvent> get onDragOver {}   @DomName('Element.ondragstart') @DocsEditable() ElementStream<MouseEvent> get onDragStart {}   @DomName('Element.ondrop') @DocsEditable() ElementStream<MouseEvent> get onDrop {}   @DomName('Element.ondurationchange') @DocsEditable() @Experimental() ElementStream<Event> get onDurationChange {}   @DomName('Element.onemptied') @DocsEditable() @Experimental() ElementStream<Event> get onEmptied {}   @DomName('Element.onended') @DocsEditable() @Experimental() ElementStream<Event> get onEnded {}   @DomName('Element.onerror') @DocsEditable() ElementStream<Event> get onError {}   @DomName('Element.onfocus') @DocsEditable() ElementStream<Event> get onFocus {}   @DomName('Element.oninput') @DocsEditable() ElementStream<Event> get onInput {}   @DomName('Element.oninvalid') @DocsEditable() ElementStream<Event> get onInvalid {}   @DomName('Element.onkeydown') @DocsEditable() ElementStream<KeyboardEvent> get onKeyDown {}   @DomName('Element.onkeypress') @DocsEditable() ElementStream<KeyboardEvent> get onKeyPress {}   @DomName('Element.onkeyup') @DocsEditable() ElementStream<KeyboardEvent> get onKeyUp {}   @DomName('Element.onload') @DocsEditable() ElementStream<Event> get onLoad {}   @DomName('Element.onloadeddata') @DocsEditable() @Experimental() ElementStream<Event> get onLoadedData {}   @DomName('Element.onloadedmetadata') @DocsEditable() @Experimental() ElementStream<Event> get onLoadedMetadata {}   @DomName('Element.onmousedown') @DocsEditable() ElementStream<MouseEvent> get onMouseDown {}   @DomName('Element.onmouseenter') @DocsEditable() @Experimental() ElementStream<MouseEvent> get onMouseEnter {}   @DomName('Element.onmouseleave') @DocsEditable() @Experimental() ElementStream<MouseEvent> get onMouseLeave {}   @DomName('Element.onmousemove') @DocsEditable() ElementStream<MouseEvent> get onMouseMove {}   @DomName('Element.onmouseout') @DocsEditable() ElementStream<MouseEvent> get onMouseOut {}   @DomName('Element.onmouseover') @DocsEditable() ElementStream<MouseEvent> get onMouseOver {}   @DomName('Element.onmouseup') @DocsEditable() ElementStream<MouseEvent> get onMouseUp {}   @DomName('Element.onmousewheel') @DocsEditable() @Experimental() ElementStream<WheelEvent> get onMouseWheel {}   @DomName('Element.onpaste') @DocsEditable() ElementStream<Event> get onPaste {}   @DomName('Element.onpause') @DocsEditable() @Experimental() ElementStream<Event> get onPause {}   @DomName('Element.onplay') @DocsEditable() @Experimental() ElementStream<Event> get onPlay {}   @DomName('Element.onplaying') @DocsEditable() @Experimental() ElementStream<Event> get onPlaying {}   @DomName('Element.onratechange') @DocsEditable() @Experimental() ElementStream<Event> get onRateChange {}   @DomName('Element.onreset') @DocsEditable() ElementStream<Event> get onReset {}   @DomName('Element.onresize') @DocsEditable() @Experimental() ElementStream<Event> get onResize {}   @DomName('Element.onscroll') @DocsEditable() ElementStream<Event> get onScroll {}   @DomName('Element.onsearch') @DocsEditable() @Experimental() ElementStream<Event> get onSearch {}   @DomName('Element.onseeked') @DocsEditable() @Experimental() ElementStream<Event> get onSeeked {}   @DomName('Element.onseeking') @DocsEditable() @Experimental() ElementStream<Event> get onSeeking {}   @DomName('Element.onselect') @DocsEditable() ElementStream<Event> get onSelect {}   @DomName('Element.onselectstart') @DocsEditable() @Experimental() ElementStream<Event> get onSelectStart {}   @DomName('Element.onstalled') @DocsEditable() @Experimental() ElementStream<Event> get onStalled {}   @DomName('Element.onsubmit') @DocsEditable() ElementStream<Event> get onSubmit {}   @DomName('Element.onsuspend') @DocsEditable() @Experimental() ElementStream<Event> get onSuspend {}   @DomName('Element.ontimeupdate') @DocsEditable() @Experimental() ElementStream<Event> get onTimeUpdate {}   @DomName('Element.ontouchcancel') @DocsEditable() @Experimental() ElementStream<TouchEvent> get onTouchCancel {}   @DomName('Element.ontouchend') @DocsEditable() @Experimental() ElementStream<TouchEvent> get onTouchEnd {}   @DomName('Element.ontouchenter') @DocsEditable() @Experimental() ElementStream<TouchEvent> get onTouchEnter {}   @DomName('Element.ontouchleave') @DocsEditable() @Experimental() ElementStream<TouchEvent> get onTouchLeave {}   @DomName('Element.ontouchmove') @DocsEditable() @Experimental() ElementStream<TouchEvent> get onTouchMove {}   @DomName('Element.ontouchstart') @DocsEditable() @Experimental() ElementStream<TouchEvent> get onTouchStart {}   @DomName('Element.ontransitionend') @DocsEditable() @SupportedBrowser(SupportedBrowser.CHROME) @SupportedBrowser(SupportedBrowser.FIREFOX) @SupportedBrowser(SupportedBrowser.IE, '10') @SupportedBrowser(SupportedBrowser.SAFARI) ElementStream<TransitionEvent> get onTransitionEnd {}   @DomName('Element.onvolumechange') @DocsEditable() @Experimental() ElementStream<Event> get onVolumeChange {}   @DomName('Element.onwaiting') @DocsEditable() @Experimental() ElementStream<Event> get onWaiting {}   @DomName('Element.onwebkitfullscreenchange') @DocsEditable() @Experimental() ElementStream<Event> get onFullscreenChange {}   @DomName('Element.onwebkitfullscreenerror') @DocsEditable() @Experimental() ElementStream<Event> get onFullscreenError {} } @DocsEditable() @DomName('Element') abstract class Element extends Node implements GlobalEventHandlers, ParentNode, ChildNode { factory Element.html(String html, {NodeValidator validator, NodeTreeSanitizer treeSanitizer}) { throw new UnsupportedError("new Element.html() is unsupported on this platform."); }   Element.created() : super._created() { throw new UnsupportedError("new Element.created() is unsupported on this platform."); }   factory Element.tag(String tag, [String typeExtention]) { throw new UnsupportedError("new Element.tag() is unsupported on this platform."); }   factory Element.a() { throw new UnsupportedError("new Element.a() is unsupported on this platform."); }   factory Element.article() { throw new UnsupportedError("new Element.article() is unsupported on this platform."); }   factory Element.aside() { throw new UnsupportedError("new Element.aside() is unsupported on this platform."); }   factory Element.audio() { throw new UnsupportedError("new Element.audio() is unsupported on this platform."); }   factory Element.br() { throw new UnsupportedError("new Element.br() is unsupported on this platform."); }   factory Element.canvas() { throw new UnsupportedError("new Element.canvas() is unsupported on this platform."); }   factory Element.div() { throw new UnsupportedError("new Element.div() is unsupported on this platform."); }   factory Element.footer() { throw new UnsupportedError("new Element.footer() is unsupported on this platform."); }   factory Element.header() { throw new UnsupportedError("new Element.header() is unsupported on this platform."); }   factory Element.hr() { throw new UnsupportedError("new Element.hr() is unsupported on this platform."); }   factory Element.iframe() { throw new UnsupportedError("new Element.iframe() is unsupported on this platform."); }   factory Element.img() { throw new UnsupportedError("new Element.img() is unsupported on this platform."); }   factory Element.li() { throw new UnsupportedError("new Element.li() is unsupported on this platform."); }   factory Element.nav() { throw new UnsupportedError("new Element.nav() is unsupported on this platform."); }   factory Element.ol() { throw new UnsupportedError("new Element.ol() is unsupported on this platform."); }   factory Element.option() { throw new UnsupportedError("new Element.option() is unsupported on this platform."); }   factory Element.p() { throw new UnsupportedError("new Element.p() is unsupported on this platform."); }   factory Element.pre() { throw new UnsupportedError("new Element.pre() is unsupported on this platform."); }   factory Element.section() { throw new UnsupportedError("new Element.section() is unsupported on this platform."); }   factory Element.select() { throw new UnsupportedError("new Element.select() is unsupported on this platform."); }   factory Element.span() { throw new UnsupportedError("new Element.span() is unsupported on this platform."); }   factory Element.svg() { throw new UnsupportedError("new Element.svg() is unsupported on this platform."); }   factory Element.table() { throw new UnsupportedError("new Element.table() is unsupported on this platform."); }   factory Element.td() { throw new UnsupportedError("new Element.td() is unsupported on this platform."); }   factory Element.textarea() { throw new UnsupportedError("new Element.textarea() is unsupported on this platform."); }   factory Element.th() { throw new UnsupportedError("new Element.th() is unsupported on this platform."); }   factory Element.tr() { throw new UnsupportedError("new Element.tr() is unsupported on this platform."); }   factory Element.ul() { throw new UnsupportedError("new Element.ul() is unsupported on this platform."); }   factory Element.video() { throw new UnsupportedError("new Element.video() is unsupported on this platform."); }   Map<String, String> get attributes {}   void set attributes(Map<String, String> value) {}   List<Element> get children {}   void set children(List<Element> value) {}   @DomName('Element.querySelectorAll') ElementList querySelectorAll(String selectors) {}   @deprecated @DomName('Element.querySelector') @Experimental() Element query(String relativeSelectors) {}   @deprecated @DomName('Element.querySelectorAll') @Experimental() ElementList queryAll(String relativeSelectors) {}   CssClassSet get classes {}   void set classes(Iterable<String> value) {}   Map<String, String> get dataset {}   void set dataset(Map<String, String> value) {}   Map<String, String> getNamespacedAttributes(String namespace) {}   CssStyleDeclaration getComputedStyle([String pseudoElement]) {}   Rectangle get client {}   Rectangle get offset {}   void appendText(String text) {}   void appendHtml(String text) {}   static bool isTagSupported(String tag) { throw new UnsupportedError("Element.isTagSupported() is unsupported on this platform."); }   @Experimental() void attached() {}   @Experimental() void detached() {}   @Experimental() @deprecated void enteredView() {}   @Experimental() @deprecated void leftView() {}   void attributeChanged(String name, String oldValue, String newValue) {}     get xtag {}   void set xtag(Element value) {}   @DomName('Element.localName') @DocsEditable() String get localName {}   @DomName('Element.namespaceUri') String get namespaceUri {}   String toString() {}   void scrollIntoView([ScrollAlignment alignment]) {}   @Experimental() bool matchesWithAncestors(String selectors) {}   @Experimental() CssRect get contentEdge {}   @Experimental() CssRect get paddingEdge {}   @Experimental() CssRect get borderEdge {}   @Experimental() CssRect get marginEdge {}   @Experimental() Point get documentOffset {}   @Experimental() Point offsetTo(Element parent) {}   static Point _offsetToHelper(Element current, Element parent) { throw new UnsupportedError("Element._offsetToHelper() is unsupported on this platform."); }           DocumentFragment createFragment(String html, {NodeValidator validator, NodeTreeSanitizer treeSanitizer}) {}   void set innerHtml(String html) {}   void setInnerHtml(String html, {NodeValidator validator, NodeTreeSanitizer treeSanitizer}) {}   String get innerHtml {}   ElementEvents get on {}   @DomName('Element.offsetHeight') @DocsEditable() int get offsetHeight {}   @DomName('Element.offsetLeft') @DocsEditable() int get offsetLeft {}   @DomName('Element.offsetTop') @DocsEditable() int get offsetTop {}   @DomName('Element.offsetWidth') @DocsEditable() int get offsetWidth {}   @DomName('Element.clientHeight') @DocsEditable() int get clientHeight {}   @DomName('Element.clientLeft') @DocsEditable() int get clientLeft {}   @DomName('Element.clientTop') @DocsEditable() int get clientTop {}   @DomName('Element.clientWidth') @DocsEditable() int get clientWidth {}   @DomName('Element.scrollHeight') @DocsEditable() int get scrollHeight {}   @DomName('Element.scrollLeft') @DocsEditable() int get scrollLeft {}   @DomName('Element.scrollLeft') @DocsEditable() void set scrollLeft(int value) {}   @DomName('Element.scrollTop') @DocsEditable() int get scrollTop {}   @DomName('Element.scrollTop') @DocsEditable() void set scrollTop(int value) {}   @DomName('Element.scrollWidth') @DocsEditable() int get scrollWidth {}   factory Element._() { throw new UnsupportedError("new Element._() is unsupported on this platform."); }   static const abortEvent = const EventStreamProvider<Event>('abort');   static const beforeCopyEvent = const EventStreamProvider<Event>('beforecopy');   static const beforeCutEvent = const EventStreamProvider<Event>('beforecut');   static const beforePasteEvent = const EventStreamProvider<Event>('beforepaste');   static const blurEvent = const EventStreamProvider<Event>('blur');   static const canPlayEvent = const EventStreamProvider<Event>('canplay');   static const canPlayThroughEvent = const EventStreamProvider<Event>('canplaythrough');   static const changeEvent = const EventStreamProvider<Event>('change');   static const clickEvent = const EventStreamProvider<MouseEvent>('click');   static const contextMenuEvent = const EventStreamProvider<MouseEvent>('contextmenu');   static const copyEvent = const EventStreamProvider<Event>('copy');   static const cutEvent = const EventStreamProvider<Event>('cut');   static const doubleClickEvent = const EventStreamProvider<Event>('dblclick');   static const dragEvent = const EventStreamProvider<MouseEvent>('drag');   static const dragEndEvent = const EventStreamProvider<MouseEvent>('dragend');   static const dragEnterEvent = const EventStreamProvider<MouseEvent>('dragenter');   static const dragLeaveEvent = const EventStreamProvider<MouseEvent>('dragleave');   static const dragOverEvent = const EventStreamProvider<MouseEvent>('dragover');   static const dragStartEvent = const EventStreamProvider<MouseEvent>('dragstart');   static const dropEvent = const EventStreamProvider<MouseEvent>('drop');   static const durationChangeEvent = const EventStreamProvider<Event>('durationchange');   static const emptiedEvent = const EventStreamProvider<Event>('emptied');   static const endedEvent = const EventStreamProvider<Event>('ended');   static const errorEvent = const EventStreamProvider<Event>('error');   static const focusEvent = const EventStreamProvider<Event>('focus');   static const inputEvent = const EventStreamProvider<Event>('input');   static const invalidEvent = const EventStreamProvider<Event>('invalid');   static const keyDownEvent = const EventStreamProvider<KeyboardEvent>('keydown');   static const keyPressEvent = const EventStreamProvider<KeyboardEvent>('keypress');   static const keyUpEvent = const EventStreamProvider<KeyboardEvent>('keyup');   static const loadEvent = const EventStreamProvider<Event>('load');   static const loadedDataEvent = const EventStreamProvider<Event>('loadeddata');   static const loadedMetadataEvent = const EventStreamProvider<Event>('loadedmetadata');   static const mouseDownEvent = const EventStreamProvider<MouseEvent>('mousedown');   static const mouseEnterEvent = const EventStreamProvider<MouseEvent>('mouseenter');   static const mouseLeaveEvent = const EventStreamProvider<MouseEvent>('mouseleave');   static const mouseMoveEvent = const EventStreamProvider<MouseEvent>('mousemove');   static const mouseOutEvent = const EventStreamProvider<MouseEvent>('mouseout');   static const mouseOverEvent = const EventStreamProvider<MouseEvent>('mouseover');   static const mouseUpEvent = const EventStreamProvider<MouseEvent>('mouseup');   static const mouseWheelEvent = const EventStreamProvider<WheelEvent>('mousewheel');   static const pasteEvent = const EventStreamProvider<Event>('paste');   static const pauseEvent = const EventStreamProvider<Event>('pause');   static const playEvent = const EventStreamProvider<Event>('play');   static const playingEvent = const EventStreamProvider<Event>('playing');   static const rateChangeEvent = const EventStreamProvider<Event>('ratechange');   static const resetEvent = const EventStreamProvider<Event>('reset');   static const resizeEvent = const EventStreamProvider<Event>('resize');   static const scrollEvent = const EventStreamProvider<Event>('scroll');   static const searchEvent = const EventStreamProvider<Event>('search');   static const seekedEvent = const EventStreamProvider<Event>('seeked');   static const seekingEvent = const EventStreamProvider<Event>('seeking');   static const selectEvent = const EventStreamProvider<Event>('select');   static const selectStartEvent = const EventStreamProvider<Event>('selectstart');   static const stalledEvent = const EventStreamProvider<Event>('stalled');   static const submitEvent = const EventStreamProvider<Event>('submit');   static const suspendEvent = const EventStreamProvider<Event>('suspend');   static const timeUpdateEvent = const EventStreamProvider<Event>('timeupdate');   static const touchCancelEvent = const EventStreamProvider<TouchEvent>('touchcancel');   static const touchEndEvent = const EventStreamProvider<TouchEvent>('touchend');   static const touchEnterEvent = const EventStreamProvider<TouchEvent>('touchenter');   static const touchLeaveEvent = const EventStreamProvider<TouchEvent>('touchleave');   static const touchMoveEvent = const EventStreamProvider<TouchEvent>('touchmove');   static const touchStartEvent = const EventStreamProvider<TouchEvent>('touchstart');   static const transitionEndEvent = const EventStreamProvider<TransitionEvent>('transitionend');   static const volumeChangeEvent = const EventStreamProvider<Event>('volumechange');   static const waitingEvent = const EventStreamProvider<Event>('waiting');   static const fullscreenChangeEvent = const EventStreamProvider<Event>('webkitfullscreenchange');   static const fullscreenErrorEvent = const EventStreamProvider<Event>('webkitfullscreenerror');   String contentEditable  String dir  bool draggable  bool hidden  bool get isContentEditable;   String lang  bool spellcheck  int tabIndex  String title  bool translate  String dropzone  void click();    @DomName('Element.className') @DocsEditable() String get className {}   @DomName('Element.className') @DocsEditable() void set className(String value) {}       @DomName('Element.id') @DocsEditable() String get id {}   @DomName('Element.id') @DocsEditable() void set id(String value) {}         @DomName('Element.offsetParent') @DocsEditable() Element get offsetParent {}     @DomName('Element.outerHTML') @DocsEditable() String get outerHtml {}         @DomName('Element.shadowRoot') @DocsEditable() @Experimental() ShadowRoot get shadowRoot {}   @DomName('Element.style') @DocsEditable() CssStyleDeclaration get style {}   @DomName('Element.tagName') @DocsEditable() String get tagName {}   @DomName('Element.animate') @DocsEditable() @Experimental() AnimationPlayer animate(Object effect, [Object timing]) {}   @DomName('Element.blur') @DocsEditable() void blur() {}   @DomName('Element.createShadowRoot') @DocsEditable() @SupportedBrowser(SupportedBrowser.CHROME, '25') @Experimental() ShadowRoot createShadowRoot() {}   @DomName('Element.focus') @DocsEditable() void focus() {}   @DomName('Element.getAnimationPlayers') @DocsEditable() @Experimental() List<AnimationPlayer> getAnimationPlayers() {}   @DomName('Element.getAttribute') @DocsEditable() @Experimental() String getAttribute(String name) {}   @DomName('Element.getAttributeNS') @DocsEditable() @Experimental() String getAttributeNS(String namespaceURI, String localName) {}   @DomName('Element.getBoundingClientRect') @DocsEditable() Rectangle getBoundingClientRect() {}   @DomName('Element.getClientRects') @DocsEditable() List<Rectangle> getClientRects() {}   @DomName('Element.getDestinationInsertionPoints') @DocsEditable() @Experimental() List<Node> getDestinationInsertionPoints() {}   @DomName('Element.getElementsByClassName') @DocsEditable() List<Node> getElementsByClassName(String classNames) {}      @DomName('Element.insertAdjacentElement') @DocsEditable() @Experimental() Element insertAdjacentElement(String where, Element element) {}   @DomName('Element.insertAdjacentHTML') @DocsEditable() @Experimental() void insertAdjacentHtml(String where, String html) {}   @DomName('Element.insertAdjacentText') @DocsEditable() @Experimental() void insertAdjacentText(String where, String text) {}   @DomName('Element.matches') @DocsEditable() @Experimental() bool matches(String selectors) {}     @DomName('Element.requestFullscreen') @DocsEditable() @Experimental() void requestFullscreen() {}   @DomName('Element.requestPointerLock') @DocsEditable() @Experimental() void requestPointerLock() {}     @DomName('Element.setAttribute') @DocsEditable() void setAttribute(String name, String value) {}   @DomName('Element.setAttributeNS') @DocsEditable() void setAttributeNS(String namespaceURI, String qualifiedName, String value) {}   @DomName('Element.nextElementSibling') @DocsEditable() Element get nextElementSibling {}   @DomName('Element.previousElementSibling') @DocsEditable() Element get previousElementSibling {}   @DomName('Element.remove') @DocsEditable() void remove() {}       @DomName('Element.querySelector') @DocsEditable() Element querySelector(String selectors) {}    @DomName('Element.onabort') @DocsEditable() ElementStream<Event> get onAbort {}   @DomName('Element.onbeforecopy') @DocsEditable() ElementStream<Event> get onBeforeCopy {}   @DomName('Element.onbeforecut') @DocsEditable() ElementStream<Event> get onBeforeCut {}   @DomName('Element.onbeforepaste') @DocsEditable() ElementStream<Event> get onBeforePaste {}   @DomName('Element.onblur') @DocsEditable() ElementStream<Event> get onBlur {}   @DomName('Element.oncanplay') @DocsEditable() @Experimental() ElementStream<Event> get onCanPlay {}   @DomName('Element.oncanplaythrough') @DocsEditable() @Experimental() ElementStream<Event> get onCanPlayThrough {}   @DomName('Element.onchange') @DocsEditable() ElementStream<Event> get onChange {}   @DomName('Element.onclick') @DocsEditable() ElementStream<MouseEvent> get onClick {}   @DomName('Element.oncontextmenu') @DocsEditable() ElementStream<MouseEvent> get onContextMenu {}   @DomName('Element.oncopy') @DocsEditable() ElementStream<Event> get onCopy {}   @DomName('Element.oncut') @DocsEditable() ElementStream<Event> get onCut {}   @DomName('Element.ondblclick') @DocsEditable() ElementStream<Event> get onDoubleClick {}   @DomName('Element.ondrag') @DocsEditable() ElementStream<MouseEvent> get onDrag {}   @DomName('Element.ondragend') @DocsEditable() ElementStream<MouseEvent> get onDragEnd {}   @DomName('Element.ondragenter') @DocsEditable() ElementStream<MouseEvent> get onDragEnter {}   @DomName('Element.ondragleave') @DocsEditable() ElementStream<MouseEvent> get onDragLeave {}   @DomName('Element.ondragover') @DocsEditable() ElementStream<MouseEvent> get onDragOver {}   @DomName('Element.ondragstart') @DocsEditable() ElementStream<MouseEvent> get onDragStart {}   @DomName('Element.ondrop') @DocsEditable() ElementStream<MouseEvent> get onDrop {}   @DomName('Element.ondurationchange') @DocsEditable() @Experimental() ElementStream<Event> get onDurationChange {}   @DomName('Element.onemptied') @DocsEditable() @Experimental() ElementStream<Event> get onEmptied {}   @DomName('Element.onended') @DocsEditable() @Experimental() ElementStream<Event> get onEnded {}   @DomName('Element.onerror') @DocsEditable() ElementStream<Event> get onError {}   @DomName('Element.onfocus') @DocsEditable() ElementStream<Event> get onFocus {}   @DomName('Element.oninput') @DocsEditable() ElementStream<Event> get onInput {}   @DomName('Element.oninvalid') @DocsEditable() ElementStream<Event> get onInvalid {}   @DomName('Element.onkeydown') @DocsEditable() ElementStream<KeyboardEvent> get onKeyDown {}   @DomName('Element.onkeypress') @DocsEditable() ElementStream<KeyboardEvent> get onKeyPress {}   @DomName('Element.onkeyup') @DocsEditable() ElementStream<KeyboardEvent> get onKeyUp {}   @DomName('Element.onload') @DocsEditable() ElementStream<Event> get onLoad {}   @DomName('Element.onloadeddata') @DocsEditable() @Experimental() ElementStream<Event> get onLoadedData {}   @DomName('Element.onloadedmetadata') @DocsEditable() @Experimental() ElementStream<Event> get onLoadedMetadata {}   @DomName('Element.onmousedown') @DocsEditable() ElementStream<MouseEvent> get onMouseDown {}   @DomName('Element.onmouseenter') @DocsEditable() @Experimental() ElementStream<MouseEvent> get onMouseEnter {}   @DomName('Element.onmouseleave') @DocsEditable() @Experimental() ElementStream<MouseEvent> get onMouseLeave {}   @DomName('Element.onmousemove') @DocsEditable() ElementStream<MouseEvent> get onMouseMove {}   @DomName('Element.onmouseout') @DocsEditable() ElementStream<MouseEvent> get onMouseOut {}   @DomName('Element.onmouseover') @DocsEditable() ElementStream<MouseEvent> get onMouseOver {}   @DomName('Element.onmouseup') @DocsEditable() ElementStream<MouseEvent> get onMouseUp {}   @DomName('Element.onmousewheel') @DocsEditable() @Experimental() ElementStream<WheelEvent> get onMouseWheel {}   @DomName('Element.onpaste') @DocsEditable() ElementStream<Event> get onPaste {}   @DomName('Element.onpause') @DocsEditable() @Experimental() ElementStream<Event> get onPause {}   @DomName('Element.onplay') @DocsEditable() @Experimental() ElementStream<Event> get onPlay {}   @DomName('Element.onplaying') @DocsEditable() @Experimental() ElementStream<Event> get onPlaying {}   @DomName('Element.onratechange') @DocsEditable() @Experimental() ElementStream<Event> get onRateChange {}   @DomName('Element.onreset') @DocsEditable() ElementStream<Event> get onReset {}   @DomName('Element.onresize') @DocsEditable() @Experimental() ElementStream<Event> get onResize {}   @DomName('Element.onscroll') @DocsEditable() ElementStream<Event> get onScroll {}   @DomName('Element.onsearch') @DocsEditable() @Experimental() ElementStream<Event> get onSearch {}   @DomName('Element.onseeked') @DocsEditable() @Experimental() ElementStream<Event> get onSeeked {}   @DomName('Element.onseeking') @DocsEditable() @Experimental() ElementStream<Event> get onSeeking {}   @DomName('Element.onselect') @DocsEditable() ElementStream<Event> get onSelect {}   @DomName('Element.onselectstart') @DocsEditable() @Experimental() ElementStream<Event> get onSelectStart {}   @DomName('Element.onstalled') @DocsEditable() @Experimental() ElementStream<Event> get onStalled {}   @DomName('Element.onsubmit') @DocsEditable() ElementStream<Event> get onSubmit {}   @DomName('Element.onsuspend') @DocsEditable() @Experimental() ElementStream<Event> get onSuspend {}   @DomName('Element.ontimeupdate') @DocsEditable() @Experimental() ElementStream<Event> get onTimeUpdate {}   @DomName('Element.ontouchcancel') @DocsEditable() @Experimental() ElementStream<TouchEvent> get onTouchCancel {}   @DomName('Element.ontouchend') @DocsEditable() @Experimental() ElementStream<TouchEvent> get onTouchEnd {}   @DomName('Element.ontouchenter') @DocsEditable() @Experimental() ElementStream<TouchEvent> get onTouchEnter {}   @DomName('Element.ontouchleave') @DocsEditable() @Experimental() ElementStream<TouchEvent> get onTouchLeave {}   @DomName('Element.ontouchmove') @DocsEditable() @Experimental() ElementStream<TouchEvent> get onTouchMove {}   @DomName('Element.ontouchstart') @DocsEditable() @Experimental() ElementStream<TouchEvent> get onTouchStart {}   @DomName('Element.ontransitionend') @DocsEditable() @SupportedBrowser(SupportedBrowser.CHROME) @SupportedBrowser(SupportedBrowser.FIREFOX) @SupportedBrowser(SupportedBrowser.IE, '10') @SupportedBrowser(SupportedBrowser.SAFARI) ElementStream<TransitionEvent> get onTransitionEnd {}   @DomName('Element.onvolumechange') @DocsEditable() @Experimental() ElementStream<Event> get onVolumeChange {}   @DomName('Element.onwaiting') @DocsEditable() @Experimental() ElementStream<Event> get onWaiting {}   @DomName('Element.onwebkitfullscreenchange') @DocsEditable() @Experimental() ElementStream<Event> get onFullscreenChange {}   @DomName('Element.onwebkitfullscreenerror') @DocsEditable() @Experimental() ElementStream<Event> get onFullscreenError {} } class _ElementFactoryProvider { @DomName('Document.createElement') static Element createElement_tag(String tag, String typeExtension) { throw new UnsupportedError("_ElementFactoryProvider.createElement_tag() is unsupported on this platform."); } } class ScrollAlignment {   const ScrollAlignment._internal(_value);   toString() { throw new UnsupportedError("ScrollAlignment.toString() is unsupported on this platform."); }   static const TOP = const ScrollAlignment._internal('TOP');   static const CENTER = const ScrollAlignment._internal('CENTER');   static const BOTTOM = const ScrollAlignment._internal('BOTTOM'); } @DocsEditable() @DomName('HTMLEmbedElement') @SupportedBrowser(SupportedBrowser.CHROME) @SupportedBrowser(SupportedBrowser.IE) @SupportedBrowser(SupportedBrowser.SAFARI) @Unstable() class EmbedElement extends HtmlElement { factory EmbedElement._() { throw new UnsupportedError("new EmbedElement._() is unsupported on this platform."); }   @DomName('HTMLEmbedElement.HTMLEmbedElement') @DocsEditable() factory EmbedElement() { throw new UnsupportedError("new EmbedElement() is unsupported on this platform."); }   EmbedElement.created() : super.created() { throw new UnsupportedError("new EmbedElement.created() is unsupported on this platform."); }   static bool get supported { throw new UnsupportedError("EmbedElement.supported is unsupported on this platform."); }   @DomName('HTMLEmbedElement.height') @DocsEditable() String get height {}   @DomName('HTMLEmbedElement.height') @DocsEditable() void set height(String value) {}   @DomName('HTMLEmbedElement.integrity') @DocsEditable() @Experimental() String get integrity {}   @DomName('HTMLEmbedElement.integrity') @DocsEditable() @Experimental() void set integrity(String value) {}   @DomName('HTMLEmbedElement.name') @DocsEditable() String get name {}   @DomName('HTMLEmbedElement.name') @DocsEditable() void set name(String value) {}   @DomName('HTMLEmbedElement.src') @DocsEditable() String get src {}   @DomName('HTMLEmbedElement.src') @DocsEditable() void set src(String value) {}   @DomName('HTMLEmbedElement.type') @DocsEditable() String get type {}   @DomName('HTMLEmbedElement.type') @DocsEditable() void set type(String value) {}   @DomName('HTMLEmbedElement.width') @DocsEditable() String get width {}   @DomName('HTMLEmbedElement.width') @DocsEditable() void set width(String value) {}   } @DomName('EntriesCallback') @Experimental() typedef void _EntriesCallback(List<Entry> entries); @DocsEditable() @DomName('Entry') @Experimental() class Entry extends NativeFieldWrapperClass2 { factory Entry._() { throw new UnsupportedError("new Entry._() is unsupported on this platform."); }   @DomName('Entry.filesystem') @DocsEditable() FileSystem get filesystem {}   @DomName('Entry.fullPath') @DocsEditable() String get fullPath {}   @DomName('Entry.isDirectory') @DocsEditable() bool get isDirectory {}   @DomName('Entry.isFile') @DocsEditable() bool get isFile {}   @DomName('Entry.name') @DocsEditable() String get name {}    Future<Entry> copyTo(DirectoryEntry parent, {String name}) {}    Future<Metadata> getMetadata() {}    Future<Entry> getParent() {}    Future<Entry> moveTo(DirectoryEntry parent, {String name}) {}    Future remove() {}   @DomName('Entry.toURL') @DocsEditable() String toUrl() {} } @DomName('EntryCallback') @Experimental() typedef void _EntryCallback(Entry entry); @DomName('ErrorCallback') @Experimental() typedef void _ErrorCallback(FileError error); @DocsEditable() @DomName('ErrorEvent') @Unstable() class ErrorEvent extends Event { factory ErrorEvent._() { throw new UnsupportedError("new ErrorEvent._() is unsupported on this platform."); }   @DomName('ErrorEvent.colno') @DocsEditable() @Experimental() int get colno {}   @DomName('ErrorEvent.error') @DocsEditable() @Experimental() Object get error {}   @DomName('ErrorEvent.filename') @DocsEditable() String get filename {}   @DomName('ErrorEvent.lineno') @DocsEditable() int get lineno {}   @DomName('ErrorEvent.message') @DocsEditable() String get message {} } @DomName('Event') class Event extends NativeFieldWrapperClass2 { factory Event(String type, {bool canBubble : true, bool cancelable : true}) { throw new UnsupportedError("new Event() is unsupported on this platform."); }   factory Event.eventType(String type, String name, {bool canBubble : true, bool cancelable : true}) { throw new UnsupportedError("new Event.eventType() is unsupported on this platform."); }     Element get matchingTarget {}   factory Event._() { throw new UnsupportedError("new Event._() is unsupported on this platform."); }   static const AT_TARGET = 2;   static const BUBBLING_PHASE = 3;   static const CAPTURING_PHASE = 1;   @DomName('Event.bubbles') @DocsEditable() bool get bubbles {}   @DomName('Event.cancelable') @DocsEditable() bool get cancelable {}   @DomName('Event.clipboardData') @DocsEditable() @SupportedBrowser(SupportedBrowser.CHROME) @SupportedBrowser(SupportedBrowser.FIREFOX) @SupportedBrowser(SupportedBrowser.SAFARI) @Experimental() @Experimental() DataTransfer get clipboardData {}   @DomName('Event.currentTarget') @DocsEditable() EventTarget get currentTarget {}   @DomName('Event.defaultPrevented') @DocsEditable() bool get defaultPrevented {}   @DomName('Event.eventPhase') @DocsEditable() int get eventPhase {}   @DomName('Event.path') @DocsEditable() @Experimental() List<Node> get path {}   @DomName('Event.target') @DocsEditable() EventTarget get target {}   @DomName('Event.timeStamp') @DocsEditable() int get timeStamp {}   @DomName('Event.type') @DocsEditable() String get type {}    @DomName('Event.preventDefault') @DocsEditable() void preventDefault() {}   @DomName('Event.stopImmediatePropagation') @DocsEditable() void stopImmediatePropagation() {}   @DomName('Event.stopPropagation') @DocsEditable() void stopPropagation() {} } @DomName('EventSource') @Experimental() class EventSource extends EventTarget { factory EventSource(String title, {withCredentials : false}) { throw new UnsupportedError("new EventSource() is unsupported on this platform."); }   factory EventSource._() { throw new UnsupportedError("new EventSource._() is unsupported on this platform."); }   static const errorEvent = const EventStreamProvider<Event>('error');   static const messageEvent = const EventStreamProvider<MessageEvent>('message');   static const openEvent = const EventStreamProvider<Event>('open');   @DomName('EventSource.EventSource') @DocsEditable() static EventSource _factoryEventSource(String url, [Map eventSourceInit]) { throw new UnsupportedError("EventSource._factoryEventSource() is unsupported on this platform."); }   static const CLOSED = 2;   static const CONNECTING = 0;   static const OPEN = 1;   @DomName('EventSource.readyState') @DocsEditable() int get readyState {}   @DomName('EventSource.url') @DocsEditable() String get url {}   @DomName('EventSource.withCredentials') @DocsEditable() bool get withCredentials {}   @DomName('EventSource.close') @DocsEditable() void close() {}   @DomName('EventSource.onerror') @DocsEditable() Stream<Event> get onError {}   @DomName('EventSource.onmessage') @DocsEditable() Stream<MessageEvent> get onMessage {}   @DomName('EventSource.onopen') @DocsEditable() Stream<Event> get onOpen {} } class Events {   Events(EventTarget _ptr) { throw new UnsupportedError("new Events() is unsupported on this platform."); }   Stream operator [](String type) {} } class ElementEvents extends Events {   static get webkitEvents => throw new UnsupportedError("ElementEvents.webkitEvents is unsupported on this platform.");   ElementEvents(Element ptr) : super(throw new UnsupportedError("new ElementEvents() is unsupported on this platform.")) { throw new UnsupportedError("new ElementEvents() is unsupported on this platform."); }   Stream operator [](String type) {} } @DomName('EventTarget') class EventTarget extends NativeFieldWrapperClass2 { EventTarget._created() { throw new UnsupportedError("new EventTarget._created() is unsupported on this platform."); }   Events get on {}   void addEventListener(String type, EventListener listener, [bool useCapture]) {}   void removeEventListener(String type, EventListener listener, [bool useCapture]) {}   factory EventTarget._() { throw new UnsupportedError("new EventTarget._() is unsupported on this platform."); }    @DomName('EventTarget.dispatchEvent') @DocsEditable() bool dispatchEvent(Event event) {}  } @DocsEditable() @DomName('FederatedCredential') @Experimental() class FederatedCredential extends Credential { factory FederatedCredential._() { throw new UnsupportedError("new FederatedCredential._() is unsupported on this platform."); }   @DomName('FederatedCredential.FederatedCredential') @DocsEditable() factory FederatedCredential(String id, String name, String avatarURL, String federation) { throw new UnsupportedError("new FederatedCredential() is unsupported on this platform."); }   @DomName('FederatedCredential.federation') @DocsEditable() @Experimental() String get federation {} } @DocsEditable() @DomName('FetchBodyStream') @Experimental() class FetchBodyStream extends NativeFieldWrapperClass2 { factory FetchBodyStream._() { throw new UnsupportedError("new FetchBodyStream._() is unsupported on this platform."); }   @DomName('FetchBodyStream.asArrayBuffer') @DocsEditable() @Experimental() Future asArrayBuffer() {}   @DomName('FetchBodyStream.asBlob') @DocsEditable() @Experimental() Future asBlob() {}   @DomName('FetchBodyStream.asJSON') @DocsEditable() @Experimental() Future asJson() {}   @DomName('FetchBodyStream.asText') @DocsEditable() @Experimental() Future asText() {} } @DocsEditable() @DomName('FetchEvent') @Experimental() class FetchEvent extends Event { factory FetchEvent._() { throw new UnsupportedError("new FetchEvent._() is unsupported on this platform."); }   @DomName('FetchEvent.isReload') @DocsEditable() @Experimental() bool get isReload {}   @DomName('FetchEvent.request') @DocsEditable() @Experimental() _Request get request {}   @DomName('FetchEvent.respondWith') @DocsEditable() @Experimental() void respondWith(Object value) {} } @DocsEditable() @DomName('HTMLFieldSetElement') @Unstable() class FieldSetElement extends HtmlElement { factory FieldSetElement._() { throw new UnsupportedError("new FieldSetElement._() is unsupported on this platform."); }   @DomName('HTMLFieldSetElement.HTMLFieldSetElement') @DocsEditable() factory FieldSetElement() { throw new UnsupportedError("new FieldSetElement() is unsupported on this platform."); }   FieldSetElement.created() : super.created() { throw new UnsupportedError("new FieldSetElement.created() is unsupported on this platform."); }   @DomName('HTMLFieldSetElement.disabled') @DocsEditable() bool get disabled {}   @DomName('HTMLFieldSetElement.disabled') @DocsEditable() void set disabled(bool value) {}   @DomName('HTMLFieldSetElement.elements') @DocsEditable() List<Node> get elements {}   @DomName('HTMLFieldSetElement.form') @DocsEditable() FormElement get form {}   @DomName('HTMLFieldSetElement.name') @DocsEditable() String get name {}   @DomName('HTMLFieldSetElement.name') @DocsEditable() void set name(String value) {}   @DomName('HTMLFieldSetElement.type') @DocsEditable() String get type {}   @DomName('HTMLFieldSetElement.validationMessage') @DocsEditable() String get validationMessage {}   @DomName('HTMLFieldSetElement.validity') @DocsEditable() ValidityState get validity {}   @DomName('HTMLFieldSetElement.willValidate') @DocsEditable() bool get willValidate {}   @DomName('HTMLFieldSetElement.checkValidity') @DocsEditable() bool checkValidity() {}   @DomName('HTMLFieldSetElement.setCustomValidity') @DocsEditable() void setCustomValidity(String error) {} } @DocsEditable() @DomName('File') class File extends Blob { factory File._() { throw new UnsupportedError("new File._() is unsupported on this platform."); }   @DomName('File.lastModified') @DocsEditable() @Experimental() int get lastModified {}   @DomName('File.lastModifiedDate') @DocsEditable() DateTime get lastModifiedDate {}   @DomName('File.name') @DocsEditable() String get name {}   @DomName('File.webkitRelativePath') @DocsEditable() @SupportedBrowser(SupportedBrowser.CHROME) @SupportedBrowser(SupportedBrowser.SAFARI) @Experimental() String get relativePath {} } @DomName('FileCallback') @Experimental() typedef void _FileCallback(File file); @DocsEditable() @DomName('FileEntry') @Experimental() class FileEntry extends Entry { factory FileEntry._() { throw new UnsupportedError("new FileEntry._() is unsupported on this platform."); }    Future<FileWriter> createWriter() {}    Future<File> file() {} } @DocsEditable() @DomName('FileError') @Experimental() class FileError extends DomError { factory FileError._() { throw new UnsupportedError("new FileError._() is unsupported on this platform."); }   static const ABORT_ERR = 3;   static const ENCODING_ERR = 5;   static const INVALID_MODIFICATION_ERR = 9;   static const INVALID_STATE_ERR = 7;   static const NOT_FOUND_ERR = 1;   static const NOT_READABLE_ERR = 4;   static const NO_MODIFICATION_ALLOWED_ERR = 6;   static const PATH_EXISTS_ERR = 12;   static const QUOTA_EXCEEDED_ERR = 10;   static const SECURITY_ERR = 2;   static const SYNTAX_ERR = 8;   static const TYPE_MISMATCH_ERR = 11;   @DomName('FileError.code') @DocsEditable() int get code {} } @DocsEditable() @DomName('FileList') class FileList extends NativeFieldWrapperClass2 with ListMixin<File>, ImmutableListMixin<File> implements List<File> { factory FileList._() { throw new UnsupportedError("new FileList._() is unsupported on this platform."); }   @DomName('FileList.length') @DocsEditable() int get length {}   File operator [](int index) {}    void operator []=(int index, File value) {}   void set length(int value) {}   File get first {}   File get last {}   File get single {}   File elementAt(int index) {}   @DomName('FileList.item') @DocsEditable() File item(int index) {} } @DocsEditable() @DomName('FileReader') class FileReader extends EventTarget { @DomName('FileReader.result') @DocsEditable() Object get result {}   factory FileReader._() { throw new UnsupportedError("new FileReader._() is unsupported on this platform."); }   static const abortEvent = const EventStreamProvider<ProgressEvent>('abort');   static const errorEvent = const EventStreamProvider<Event>('error');   static const loadEvent = const EventStreamProvider<ProgressEvent>('load');   static const loadEndEvent = const EventStreamProvider<ProgressEvent>('loadend');   static const loadStartEvent = const EventStreamProvider<ProgressEvent>('loadstart');   static const progressEvent = const EventStreamProvider<ProgressEvent>('progress');   @DomName('FileReader.FileReader') @DocsEditable() factory FileReader() { throw new UnsupportedError("new FileReader() is unsupported on this platform."); }   static const DONE = 2;   static const EMPTY = 0;   static const LOADING = 1;   @DomName('FileReader.error') @DocsEditable() FileError get error {}   @DomName('FileReader.readyState') @DocsEditable() int get readyState {}    @DomName('FileReader.abort') @DocsEditable() void abort() {}   @DomName('FileReader.readAsArrayBuffer') @DocsEditable() void readAsArrayBuffer(Blob blob) {}   @DomName('FileReader.readAsDataURL') @DocsEditable() void readAsDataUrl(Blob blob) {}   void readAsText(Blob blob, [String encoding]) {}   @DomName('FileReader.onabort') @DocsEditable() Stream<ProgressEvent> get onAbort {}   @DomName('FileReader.onerror') @DocsEditable() Stream<Event> get onError {}   @DomName('FileReader.onload') @DocsEditable() Stream<ProgressEvent> get onLoad {}   @DomName('FileReader.onloadend') @DocsEditable() Stream<ProgressEvent> get onLoadEnd {}   @DomName('FileReader.onloadstart') @DocsEditable() Stream<ProgressEvent> get onLoadStart {}   @DomName('FileReader.onprogress') @DocsEditable() Stream<ProgressEvent> get onProgress {} } @DocsEditable() @DomName('Stream') @Experimental() class FileStream extends NativeFieldWrapperClass2 { factory FileStream._() { throw new UnsupportedError("new FileStream._() is unsupported on this platform."); }   @DomName('Stream.type') @DocsEditable() @Experimental() String get type {} } @DocsEditable() @DomName('DOMFileSystem') @SupportedBrowser(SupportedBrowser.CHROME) @Experimental() class FileSystem extends NativeFieldWrapperClass2 { factory FileSystem._() { throw new UnsupportedError("new FileSystem._() is unsupported on this platform."); }   static bool get supported { throw new UnsupportedError("FileSystem.supported is unsupported on this platform."); }   @DomName('DOMFileSystem.name') @DocsEditable() String get name {}   @DomName('DOMFileSystem.root') @DocsEditable() DirectoryEntry get root {} } @DomName('FileSystemCallback') @Experimental() typedef void _FileSystemCallback(FileSystem fileSystem); @DocsEditable() @DomName('FileWriter') @Experimental() class FileWriter extends EventTarget { factory FileWriter._() { throw new UnsupportedError("new FileWriter._() is unsupported on this platform."); }   static const abortEvent = const EventStreamProvider<ProgressEvent>('abort');   static const errorEvent = const EventStreamProvider<Event>('error');   static const progressEvent = const EventStreamProvider<ProgressEvent>('progress');   static const writeEvent = const EventStreamProvider<ProgressEvent>('write');   static const writeEndEvent = const EventStreamProvider<ProgressEvent>('writeend');   static const writeStartEvent = const EventStreamProvider<ProgressEvent>('writestart');   static const DONE = 2;   static const INIT = 0;   static const WRITING = 1;   @DomName('FileWriter.error') @DocsEditable() FileError get error {}   @DomName('FileWriter.length') @DocsEditable() int get length {}   @DomName('FileWriter.position') @DocsEditable() int get position {}   @DomName('FileWriter.readyState') @DocsEditable() int get readyState {}   @DomName('FileWriter.abort') @DocsEditable() void abort() {}   @DomName('FileWriter.seek') @DocsEditable() void seek(int position) {}   @DomName('FileWriter.truncate') @DocsEditable() void truncate(int size) {}   @DomName('FileWriter.write') @DocsEditable() void write(Blob data) {}   @DomName('FileWriter.onabort') @DocsEditable() Stream<ProgressEvent> get onAbort {}   @DomName('FileWriter.onerror') @DocsEditable() Stream<Event> get onError {}   @DomName('FileWriter.onprogress') @DocsEditable() Stream<ProgressEvent> get onProgress {}   @DomName('FileWriter.onwrite') @DocsEditable() Stream<ProgressEvent> get onWrite {}   @DomName('FileWriter.onwriteend') @DocsEditable() Stream<ProgressEvent> get onWriteEnd {}   @DomName('FileWriter.onwritestart') @DocsEditable() Stream<ProgressEvent> get onWriteStart {} } @DomName('FileWriterCallback') @Experimental() typedef void _FileWriterCallback(FileWriter fileWriter); @DocsEditable() @DomName('FocusEvent') class FocusEvent extends UIEvent { factory FocusEvent._() { throw new UnsupportedError("new FocusEvent._() is unsupported on this platform."); }   @DomName('FocusEvent.relatedTarget') @DocsEditable() EventTarget get relatedTarget {} } @DocsEditable() @DomName('FontFace') @Experimental() class FontFace extends NativeFieldWrapperClass2 { factory FontFace._() { throw new UnsupportedError("new FontFace._() is unsupported on this platform."); }   @DomName('FontFace.FontFace') @DocsEditable() factory FontFace(String family, source, [Map descriptors]) { throw new UnsupportedError("new FontFace() is unsupported on this platform."); }   @DomName('FontFace.family') @DocsEditable() @Experimental() String get family {}   @DomName('FontFace.family') @DocsEditable() @Experimental() void set family(String value) {}   @DomName('FontFace.featureSettings') @DocsEditable() @Experimental() String get featureSettings {}   @DomName('FontFace.featureSettings') @DocsEditable() @Experimental() void set featureSettings(String value) {}   @DomName('FontFace.loaded') @DocsEditable() @Experimental() Future get loaded {}   @DomName('FontFace.status') @DocsEditable() @Experimental() String get status {}   @DomName('FontFace.stretch') @DocsEditable() @Experimental() String get stretch {}   @DomName('FontFace.stretch') @DocsEditable() @Experimental() void set stretch(String value) {}   @DomName('FontFace.style') @DocsEditable() @Experimental() String get style {}   @DomName('FontFace.style') @DocsEditable() @Experimental() void set style(String value) {}   @DomName('FontFace.unicodeRange') @DocsEditable() @Experimental() String get unicodeRange {}   @DomName('FontFace.unicodeRange') @DocsEditable() @Experimental() void set unicodeRange(String value) {}   @DomName('FontFace.variant') @DocsEditable() @Experimental() String get variant {}   @DomName('FontFace.variant') @DocsEditable() @Experimental() void set variant(String value) {}   @DomName('FontFace.weight') @DocsEditable() @Experimental() String get weight {}   @DomName('FontFace.weight') @DocsEditable() @Experimental() void set weight(String value) {}   @DomName('FontFace.load') @DocsEditable() @Experimental() Future load() {} } @DocsEditable() @DomName('FontFaceSet') @Experimental() class FontFaceSet extends EventTarget { factory FontFaceSet._() { throw new UnsupportedError("new FontFaceSet._() is unsupported on this platform."); }   @DomName('FontFaceSet.size') @DocsEditable() @Experimental() int get size {}   @DomName('FontFaceSet.status') @DocsEditable() @Experimental() String get status {}   @DomName('FontFaceSet.add') @DocsEditable() @Experimental() void add(FontFace fontFace) {}   @DomName('FontFaceSet.check') @DocsEditable() @Experimental() bool check(String font, String text) {}   @DomName('FontFaceSet.clear') @DocsEditable() @Experimental() void clear() {}   @DomName('FontFaceSet.delete') @DocsEditable() @Experimental() bool delete(FontFace fontFace) {}   void forEach(FontFaceSetForEachCallback callback, [Object thisArg]) {}   @DomName('FontFaceSet.has') @DocsEditable() @Experimental() bool has(FontFace fontFace) {} } @DomName('FontFaceSetForEachCallback') @Experimental() typedef void FontFaceSetForEachCallback(FontFace fontFace, FontFace fontFaceAgain, FontFaceSet set); @DocsEditable() @DomName('FontFaceSetLoadEvent') @Experimental() class FontFaceSetLoadEvent extends Event { factory FontFaceSetLoadEvent._() { throw new UnsupportedError("new FontFaceSetLoadEvent._() is unsupported on this platform."); }   @DomName('FontFaceSetLoadEvent.fontfaces') @DocsEditable() @Experimental() List<FontFace> get fontfaces {} } @DocsEditable() @DomName('FormData') @SupportedBrowser(SupportedBrowser.CHROME) @SupportedBrowser(SupportedBrowser.FIREFOX) @SupportedBrowser(SupportedBrowser.IE, '10') @SupportedBrowser(SupportedBrowser.SAFARI) class FormData extends NativeFieldWrapperClass2 { factory FormData._() { throw new UnsupportedError("new FormData._() is unsupported on this platform."); }   @DomName('FormData.FormData') @DocsEditable() factory FormData([FormElement form]) { throw new UnsupportedError("new FormData() is unsupported on this platform."); }   @DocsEditable() static FormData _create(form) { throw new UnsupportedError("FormData._create() is unsupported on this platform."); }   static bool get supported { throw new UnsupportedError("FormData.supported is unsupported on this platform."); }   @DomName('FormData.append') @DocsEditable() void append(String name, String value) {}   @DomName('FormData.appendBlob') @DocsEditable() void appendBlob(String name, Blob value, [String filename]) {} } @DocsEditable() @DomName('HTMLFormElement') class FormElement extends HtmlElement { factory FormElement._() { throw new UnsupportedError("new FormElement._() is unsupported on this platform."); }   @DomName('HTMLFormElement.HTMLFormElement') @DocsEditable() factory FormElement() { throw new UnsupportedError("new FormElement() is unsupported on this platform."); }   FormElement.created() : super.created() { throw new UnsupportedError("new FormElement.created() is unsupported on this platform."); }   @DomName('HTMLFormElement.acceptCharset') @DocsEditable() String get acceptCharset {}   @DomName('HTMLFormElement.acceptCharset') @DocsEditable() void set acceptCharset(String value) {}   @DomName('HTMLFormElement.action') @DocsEditable() String get action {}   @DomName('HTMLFormElement.action') @DocsEditable() void set action(String value) {}   @DomName('HTMLFormElement.autocomplete') @DocsEditable() @Experimental() String get autocomplete {}   @DomName('HTMLFormElement.autocomplete') @DocsEditable() @Experimental() void set autocomplete(String value) {}   @DomName('HTMLFormElement.encoding') @DocsEditable() String get encoding {}   @DomName('HTMLFormElement.encoding') @DocsEditable() void set encoding(String value) {}   @DomName('HTMLFormElement.enctype') @DocsEditable() String get enctype {}   @DomName('HTMLFormElement.enctype') @DocsEditable() void set enctype(String value) {}   @DomName('HTMLFormElement.length') @DocsEditable() int get length {}   @DomName('HTMLFormElement.method') @DocsEditable() String get method {}   @DomName('HTMLFormElement.method') @DocsEditable() void set method(String value) {}   @DomName('HTMLFormElement.name') @DocsEditable() String get name {}   @DomName('HTMLFormElement.name') @DocsEditable() void set name(String value) {}   @DomName('HTMLFormElement.noValidate') @DocsEditable() bool get noValidate {}   @DomName('HTMLFormElement.noValidate') @DocsEditable() void set noValidate(bool value) {}   @DomName('HTMLFormElement.target') @DocsEditable() String get target {}   @DomName('HTMLFormElement.target') @DocsEditable() void set target(String value) {}    @DomName('HTMLFormElement.checkValidity') @DocsEditable() bool checkValidity() {}   @DomName('HTMLFormElement.requestAutocomplete') @DocsEditable() @Experimental() void requestAutocomplete(Map details) {}   @DomName('HTMLFormElement.reset') @DocsEditable() void reset() {}   @DomName('HTMLFormElement.submit') @DocsEditable() void submit() {} } @DocsEditable() @DomName('Gamepad') @Experimental() class Gamepad extends NativeFieldWrapperClass2 { factory Gamepad._() { throw new UnsupportedError("new Gamepad._() is unsupported on this platform."); }   @DomName('Gamepad.axes') @DocsEditable() List<num> get axes {}   @DomName('Gamepad.connected') @DocsEditable() @Experimental() bool get connected {}   @DomName('Gamepad.id') @DocsEditable() String get id {}   @DomName('Gamepad.index') @DocsEditable() int get index {}   @DomName('Gamepad.mapping') @DocsEditable() @Experimental() String get mapping {}   @DomName('Gamepad.timestamp') @DocsEditable() int get timestamp {} } @DocsEditable() @DomName('GamepadButton') @Experimental() class GamepadButton extends NativeFieldWrapperClass2 { factory GamepadButton._() { throw new UnsupportedError("new GamepadButton._() is unsupported on this platform."); }   @DomName('GamepadButton.pressed') @DocsEditable() @Experimental() bool get pressed {}   @DomName('GamepadButton.value') @DocsEditable() @Experimental() double get value {} } @DocsEditable() @DomName('GamepadEvent') @Experimental() class GamepadEvent extends Event { factory GamepadEvent._() { throw new UnsupportedError("new GamepadEvent._() is unsupported on this platform."); }   @DomName('GamepadEvent.gamepad') @DocsEditable() @Experimental() Gamepad get gamepad {} } @DocsEditable() @DomName('Geofencing') @Experimental() class Geofencing extends NativeFieldWrapperClass2 { factory Geofencing._() { throw new UnsupportedError("new Geofencing._() is unsupported on this platform."); }   @DomName('Geofencing.getRegisteredRegions') @DocsEditable() @Experimental() Future getRegisteredRegions() {}   @DomName('Geofencing.registerRegion') @DocsEditable() @Experimental() Future registerRegion(GeofencingRegion region) {}   @DomName('Geofencing.unregisterRegion') @DocsEditable() @Experimental() Future unregisterRegion(String regionId) {} } @DocsEditable() @DomName('GeofencingRegion') @Experimental() class GeofencingRegion extends NativeFieldWrapperClass2 { factory GeofencingRegion._() { throw new UnsupportedError("new GeofencingRegion._() is unsupported on this platform."); }   @DomName('GeofencingRegion.id') @DocsEditable() @Experimental() String get id {} } @DocsEditable() @DomName('Geolocation') @Unstable() class Geolocation extends NativeFieldWrapperClass2 { @DomName('Geolocation.getCurrentPosition') Future<Geoposition> getCurrentPosition({bool enableHighAccuracy, Duration timeout, Duration maximumAge}) {}   @DomName('Geolocation.watchPosition') Stream<Geoposition> watchPosition({bool enableHighAccuracy, Duration timeout, Duration maximumAge}) {}    factory Geolocation._() { throw new UnsupportedError("new Geolocation._() is unsupported on this platform."); }    } @DocsEditable() @DomName('Geoposition') @Unstable() class Geoposition extends NativeFieldWrapperClass2 { factory Geoposition._() { throw new UnsupportedError("new Geoposition._() is unsupported on this platform."); }   @DomName('Geoposition.coords') @DocsEditable() Coordinates get coords {}   @DomName('Geoposition.timestamp') @DocsEditable() int get timestamp {} } @DocsEditable() @DomName('GlobalEventHandlers') @Experimental() abstract class GlobalEventHandlers extends EventTarget { factory GlobalEventHandlers._() { throw new UnsupportedError("new GlobalEventHandlers._() is unsupported on this platform."); }   static const abortEvent = const EventStreamProvider<Event>('abort');   static const blurEvent = const EventStreamProvider<Event>('blur');   static const canPlayEvent = const EventStreamProvider<Event>('canplay');   static const canPlayThroughEvent = const EventStreamProvider<Event>('canplaythrough');   static const changeEvent = const EventStreamProvider<Event>('change');   static const clickEvent = const EventStreamProvider<MouseEvent>('click');   static const contextMenuEvent = const EventStreamProvider<MouseEvent>('contextmenu');   static const doubleClickEvent = const EventStreamProvider<Event>('dblclick');   static const dragEvent = const EventStreamProvider<MouseEvent>('drag');   static const dragEndEvent = const EventStreamProvider<MouseEvent>('dragend');   static const dragEnterEvent = const EventStreamProvider<MouseEvent>('dragenter');   static const dragLeaveEvent = const EventStreamProvider<MouseEvent>('dragleave');   static const dragOverEvent = const EventStreamProvider<MouseEvent>('dragover');   static const dragStartEvent = const EventStreamProvider<MouseEvent>('dragstart');   static const dropEvent = const EventStreamProvider<MouseEvent>('drop');   static const durationChangeEvent = const EventStreamProvider<Event>('durationchange');   static const emptiedEvent = const EventStreamProvider<Event>('emptied');   static const endedEvent = const EventStreamProvider<Event>('ended');   static const errorEvent = const EventStreamProvider<Event>('error');   static const focusEvent = const EventStreamProvider<Event>('focus');   static const inputEvent = const EventStreamProvider<Event>('input');   static const invalidEvent = const EventStreamProvider<Event>('invalid');   static const keyDownEvent = const EventStreamProvider<KeyboardEvent>('keydown');   static const keyPressEvent = const EventStreamProvider<KeyboardEvent>('keypress');   static const keyUpEvent = const EventStreamProvider<KeyboardEvent>('keyup');   static const loadEvent = const EventStreamProvider<Event>('load');   static const loadedDataEvent = const EventStreamProvider<Event>('loadeddata');   static const loadedMetadataEvent = const EventStreamProvider<Event>('loadedmetadata');   static const mouseDownEvent = const EventStreamProvider<MouseEvent>('mousedown');   static const mouseEnterEvent = const EventStreamProvider<MouseEvent>('mouseenter');   static const mouseLeaveEvent = const EventStreamProvider<MouseEvent>('mouseleave');   static const mouseMoveEvent = const EventStreamProvider<MouseEvent>('mousemove');   static const mouseOutEvent = const EventStreamProvider<MouseEvent>('mouseout');   static const mouseOverEvent = const EventStreamProvider<MouseEvent>('mouseover');   static const mouseUpEvent = const EventStreamProvider<MouseEvent>('mouseup');   static const mouseWheelEvent = const EventStreamProvider<WheelEvent>('mousewheel');   static const pauseEvent = const EventStreamProvider<Event>('pause');   static const playEvent = const EventStreamProvider<Event>('play');   static const playingEvent = const EventStreamProvider<Event>('playing');   static const rateChangeEvent = const EventStreamProvider<Event>('ratechange');   static const resetEvent = const EventStreamProvider<Event>('reset');   static const resizeEvent = const EventStreamProvider<Event>('resize');   static const scrollEvent = const EventStreamProvider<Event>('scroll');   static const seekedEvent = const EventStreamProvider<Event>('seeked');   static const seekingEvent = const EventStreamProvider<Event>('seeking');   static const selectEvent = const EventStreamProvider<Event>('select');   static const stalledEvent = const EventStreamProvider<Event>('stalled');   static const submitEvent = const EventStreamProvider<Event>('submit');   static const suspendEvent = const EventStreamProvider<Event>('suspend');   static const timeUpdateEvent = const EventStreamProvider<Event>('timeupdate');   static const volumeChangeEvent = const EventStreamProvider<Event>('volumechange');   static const waitingEvent = const EventStreamProvider<Event>('waiting');   @DomName('GlobalEventHandlers.onabort') @DocsEditable() @Experimental() Stream<Event> get onAbort {}   @DomName('GlobalEventHandlers.onblur') @DocsEditable() @Experimental() Stream<Event> get onBlur {}   @DomName('GlobalEventHandlers.oncanplay') @DocsEditable() @Experimental() Stream<Event> get onCanPlay {}   @DomName('GlobalEventHandlers.oncanplaythrough') @DocsEditable() @Experimental() Stream<Event> get onCanPlayThrough {}   @DomName('GlobalEventHandlers.onchange') @DocsEditable() @Experimental() Stream<Event> get onChange {}   @DomName('GlobalEventHandlers.onclick') @DocsEditable() @Experimental() Stream<MouseEvent> get onClick {}   @DomName('GlobalEventHandlers.oncontextmenu') @DocsEditable() @Experimental() Stream<MouseEvent> get onContextMenu {}   @DomName('GlobalEventHandlers.ondblclick') @DocsEditable() @Experimental() Stream<Event> get onDoubleClick {}   @DomName('GlobalEventHandlers.ondrag') @DocsEditable() @Experimental() Stream<MouseEvent> get onDrag {}   @DomName('GlobalEventHandlers.ondragend') @DocsEditable() @Experimental() Stream<MouseEvent> get onDragEnd {}   @DomName('GlobalEventHandlers.ondragenter') @DocsEditable() @Experimental() Stream<MouseEvent> get onDragEnter {}   @DomName('GlobalEventHandlers.ondragleave') @DocsEditable() @Experimental() Stream<MouseEvent> get onDragLeave {}   @DomName('GlobalEventHandlers.ondragover') @DocsEditable() @Experimental() Stream<MouseEvent> get onDragOver {}   @DomName('GlobalEventHandlers.ondragstart') @DocsEditable() @Experimental() Stream<MouseEvent> get onDragStart {}   @DomName('GlobalEventHandlers.ondrop') @DocsEditable() @Experimental() Stream<MouseEvent> get onDrop {}   @DomName('GlobalEventHandlers.ondurationchange') @DocsEditable() @Experimental() Stream<Event> get onDurationChange {}   @DomName('GlobalEventHandlers.onemptied') @DocsEditable() @Experimental() Stream<Event> get onEmptied {}   @DomName('GlobalEventHandlers.onended') @DocsEditable() @Experimental() Stream<Event> get onEnded {}   @DomName('GlobalEventHandlers.onerror') @DocsEditable() @Experimental() Stream<Event> get onError {}   @DomName('GlobalEventHandlers.onfocus') @DocsEditable() @Experimental() Stream<Event> get onFocus {}   @DomName('GlobalEventHandlers.oninput') @DocsEditable() @Experimental() Stream<Event> get onInput {}   @DomName('GlobalEventHandlers.oninvalid') @DocsEditable() @Experimental() Stream<Event> get onInvalid {}   @DomName('GlobalEventHandlers.onkeydown') @DocsEditable() @Experimental() Stream<KeyboardEvent> get onKeyDown {}   @DomName('GlobalEventHandlers.onkeypress') @DocsEditable() @Experimental() Stream<KeyboardEvent> get onKeyPress {}   @DomName('GlobalEventHandlers.onkeyup') @DocsEditable() @Experimental() Stream<KeyboardEvent> get onKeyUp {}   @DomName('GlobalEventHandlers.onload') @DocsEditable() @Experimental() Stream<Event> get onLoad {}   @DomName('GlobalEventHandlers.onloadeddata') @DocsEditable() @Experimental() Stream<Event> get onLoadedData {}   @DomName('GlobalEventHandlers.onloadedmetadata') @DocsEditable() @Experimental() Stream<Event> get onLoadedMetadata {}   @DomName('GlobalEventHandlers.onmousedown') @DocsEditable() @Experimental() Stream<MouseEvent> get onMouseDown {}   @DomName('GlobalEventHandlers.onmouseenter') @DocsEditable() @Experimental() Stream<MouseEvent> get onMouseEnter {}   @DomName('GlobalEventHandlers.onmouseleave') @DocsEditable() @Experimental() Stream<MouseEvent> get onMouseLeave {}   @DomName('GlobalEventHandlers.onmousemove') @DocsEditable() @Experimental() Stream<MouseEvent> get onMouseMove {}   @DomName('GlobalEventHandlers.onmouseout') @DocsEditable() @Experimental() Stream<MouseEvent> get onMouseOut {}   @DomName('GlobalEventHandlers.onmouseover') @DocsEditable() @Experimental() Stream<MouseEvent> get onMouseOver {}   @DomName('GlobalEventHandlers.onmouseup') @DocsEditable() @Experimental() Stream<MouseEvent> get onMouseUp {}   @DomName('GlobalEventHandlers.onmousewheel') @DocsEditable() @Experimental() Stream<WheelEvent> get onMouseWheel {}   @DomName('GlobalEventHandlers.onpause') @DocsEditable() @Experimental() Stream<Event> get onPause {}   @DomName('GlobalEventHandlers.onplay') @DocsEditable() @Experimental() Stream<Event> get onPlay {}   @DomName('GlobalEventHandlers.onplaying') @DocsEditable() @Experimental() Stream<Event> get onPlaying {}   @DomName('GlobalEventHandlers.onratechange') @DocsEditable() @Experimental() Stream<Event> get onRateChange {}   @DomName('GlobalEventHandlers.onreset') @DocsEditable() @Experimental() Stream<Event> get onReset {}   @DomName('GlobalEventHandlers.onresize') @DocsEditable() @Experimental() Stream<Event> get onResize {}   @DomName('GlobalEventHandlers.onscroll') @DocsEditable() @Experimental() Stream<Event> get onScroll {}   @DomName('GlobalEventHandlers.onseeked') @DocsEditable() @Experimental() Stream<Event> get onSeeked {}   @DomName('GlobalEventHandlers.onseeking') @DocsEditable() @Experimental() Stream<Event> get onSeeking {}   @DomName('GlobalEventHandlers.onselect') @DocsEditable() @Experimental() Stream<Event> get onSelect {}   @DomName('GlobalEventHandlers.onstalled') @DocsEditable() @Experimental() Stream<Event> get onStalled {}   @DomName('GlobalEventHandlers.onsubmit') @DocsEditable() @Experimental() Stream<Event> get onSubmit {}   @DomName('GlobalEventHandlers.onsuspend') @DocsEditable() @Experimental() Stream<Event> get onSuspend {}   @DomName('GlobalEventHandlers.ontimeupdate') @DocsEditable() @Experimental() Stream<Event> get onTimeUpdate {}   @DomName('GlobalEventHandlers.onvolumechange') @DocsEditable() @Experimental() Stream<Event> get onVolumeChange {}   @DomName('GlobalEventHandlers.onwaiting') @DocsEditable() @Experimental() Stream<Event> get onWaiting {} } @DocsEditable() @DomName('HTMLHRElement') class HRElement extends HtmlElement { factory HRElement._() { throw new UnsupportedError("new HRElement._() is unsupported on this platform."); }   @DomName('HTMLHRElement.HTMLHRElement') @DocsEditable() factory HRElement() { throw new UnsupportedError("new HRElement() is unsupported on this platform."); }   HRElement.created() : super.created() { throw new UnsupportedError("new HRElement.created() is unsupported on this platform."); }   @DomName('HTMLHRElement.color') @DocsEditable() @Experimental() String get color {}   @DomName('HTMLHRElement.color') @DocsEditable() @Experimental() void set color(String value) {} } @DomName('HashChangeEvent') @SupportedBrowser(SupportedBrowser.CHROME) @SupportedBrowser(SupportedBrowser.FIREFOX) @SupportedBrowser(SupportedBrowser.SAFARI) @Unstable() class HashChangeEvent extends Event { factory HashChangeEvent(String type, {bool canBubble : true, bool cancelable : true, String oldUrl, String newUrl}) { throw new UnsupportedError("new HashChangeEvent() is unsupported on this platform."); }   factory HashChangeEvent._() { throw new UnsupportedError("new HashChangeEvent._() is unsupported on this platform."); }   static bool get supported { throw new UnsupportedError("HashChangeEvent.supported is unsupported on this platform."); }   @DomName('HashChangeEvent.newURL') @DocsEditable() String get newUrl {}   @DomName('HashChangeEvent.oldURL') @DocsEditable() String get oldUrl {}  } @DocsEditable() @DomName('HTMLHeadElement') class HeadElement extends HtmlElement { factory HeadElement._() { throw new UnsupportedError("new HeadElement._() is unsupported on this platform."); }   @DomName('HTMLHeadElement.HTMLHeadElement') @DocsEditable() factory HeadElement() { throw new UnsupportedError("new HeadElement() is unsupported on this platform."); }   HeadElement.created() : super.created() { throw new UnsupportedError("new HeadElement.created() is unsupported on this platform."); } } @DocsEditable() @DomName('Headers') @Experimental() class Headers extends NativeFieldWrapperClass2 { factory Headers._() { throw new UnsupportedError("new Headers._() is unsupported on this platform."); }   @DomName('Headers.Headers') @DocsEditable() factory Headers([input]) { throw new UnsupportedError("new Headers() is unsupported on this platform."); }   @DomName('Headers.size') @DocsEditable() @Experimental() int get size {}   void forEach(HeadersForEachCallback callback, [Object thisArg]) {} } @DomName('HeadersForEachCallback') @Experimental() typedef void HeadersForEachCallback(String value, String key, Headers map); @DocsEditable() @DomName('HTMLHeadingElement') class HeadingElement extends HtmlElement { factory HeadingElement._() { throw new UnsupportedError("new HeadingElement._() is unsupported on this platform."); }   @DomName('HTMLHeadingElement.HTMLHeadingElement') @DocsEditable() factory HeadingElement.h1() { throw new UnsupportedError("new HeadingElement.h1() is unsupported on this platform."); }   @DomName('HTMLHeadingElement.HTMLHeadingElement') @DocsEditable() factory HeadingElement.h2() { throw new UnsupportedError("new HeadingElement.h2() is unsupported on this platform."); }   @DomName('HTMLHeadingElement.HTMLHeadingElement') @DocsEditable() factory HeadingElement.h3() { throw new UnsupportedError("new HeadingElement.h3() is unsupported on this platform."); }   @DomName('HTMLHeadingElement.HTMLHeadingElement') @DocsEditable() factory HeadingElement.h4() { throw new UnsupportedError("new HeadingElement.h4() is unsupported on this platform."); }   @DomName('HTMLHeadingElement.HTMLHeadingElement') @DocsEditable() factory HeadingElement.h5() { throw new UnsupportedError("new HeadingElement.h5() is unsupported on this platform."); }   @DomName('HTMLHeadingElement.HTMLHeadingElement') @DocsEditable() factory HeadingElement.h6() { throw new UnsupportedError("new HeadingElement.h6() is unsupported on this platform."); }   HeadingElement.created() : super.created() { throw new UnsupportedError("new HeadingElement.created() is unsupported on this platform."); } } @DomName('History') class History extends NativeFieldWrapperClass2 implements HistoryBase { static bool get supportsState { throw new UnsupportedError("History.supportsState is unsupported on this platform."); }   factory History._() { throw new UnsupportedError("new History._() is unsupported on this platform."); }   @DomName('History.length') @DocsEditable() int get length {}   @DomName('History.state') @DocsEditable() dynamic get state {}   @DomName('History.back') @DocsEditable() void back() {}   @DomName('History.forward') @DocsEditable() void forward() {}   @DomName('History.go') @DocsEditable() void go(int distance) {}   @DomName('History.pushState') @DocsEditable() @SupportedBrowser(SupportedBrowser.CHROME) @SupportedBrowser(SupportedBrowser.FIREFOX) @SupportedBrowser(SupportedBrowser.IE, '10') @SupportedBrowser(SupportedBrowser.SAFARI) void pushState(Object data, String title, [String url]) {}   @DomName('History.replaceState') @DocsEditable() @SupportedBrowser(SupportedBrowser.CHROME) @SupportedBrowser(SupportedBrowser.FIREFOX) @SupportedBrowser(SupportedBrowser.IE, '10') @SupportedBrowser(SupportedBrowser.SAFARI) void replaceState(Object data, String title, [String url]) {} } @DocsEditable() @DomName('HTMLCollection') class HtmlCollection extends NativeFieldWrapperClass2 with ListMixin<Node>, ImmutableListMixin<Node> implements List<Node> { factory HtmlCollection._() { throw new UnsupportedError("new HtmlCollection._() is unsupported on this platform."); }   @DomName('HTMLCollection.length') @DocsEditable() int get length {}   Node operator [](int index) {}    void operator []=(int index, Node value) {}   void set length(int value) {}   Node get first {}   Node get last {}   Node get single {}   Node elementAt(int index) {}   @DomName('HTMLCollection.item') @DocsEditable() Element item(int index) {}   @DomName('HTMLCollection.namedItem') @DocsEditable() Element namedItem(String name) {} } @DomName('HTMLDocument') class HtmlDocument extends Document { factory HtmlDocument._() { throw new UnsupportedError("new HtmlDocument._() is unsupported on this platform."); }   @DomName('Document.body') BodyElement get body {}   @DomName('Document.body') void set body(BodyElement value) {}   @DomName('Document.caretRangeFromPoint') Range caretRangeFromPoint(int x, int y) {}   @DomName('Document.elementFromPoint') Element elementFromPoint(int x, int y) {}   static bool get supportsCssCanvasContext { throw new UnsupportedError("HtmlDocument.supportsCssCanvasContext is unsupported on this platform."); }   @SupportedBrowser(SupportedBrowser.CHROME) @SupportedBrowser(SupportedBrowser.SAFARI) @Experimental() @DomName('Document.getCSSCanvasContext') CanvasRenderingContext getCssCanvasContext(String contextId, String name, int width, int height) {}   @DomName('Document.head') HeadElement get head {}   @DomName('Document.lastModified') String get lastModified {}   @DomName('Document.preferredStylesheetSet') String get preferredStylesheetSet {}   @DomName('Document.referrer') String get referrer {}   @DomName('Document.selectedStylesheetSet') String get selectedStylesheetSet {}   void set selectedStylesheetSet(String value) {}   @DomName('Document.styleSheets') List<StyleSheet> get styleSheets {}   @DomName('Document.title') String get title {}   @DomName('Document.title') void set title(String value) {}   @DomName('Document.webkitExitFullscreen') @SupportedBrowser(SupportedBrowser.CHROME) @SupportedBrowser(SupportedBrowser.SAFARI) @Experimental() void exitFullscreen() {}   @DomName('Document.webkitFullscreenElement') @SupportedBrowser(SupportedBrowser.CHROME) @SupportedBrowser(SupportedBrowser.SAFARI) @Experimental() Element get fullscreenElement {}   @DomName('Document.webkitFullscreenEnabled') @SupportedBrowser(SupportedBrowser.CHROME) @SupportedBrowser(SupportedBrowser.SAFARI) @Experimental() bool get fullscreenEnabled {}   @DomName('Document.webkitHidden') @SupportedBrowser(SupportedBrowser.CHROME) @SupportedBrowser(SupportedBrowser.SAFARI) @Experimental() bool get hidden {}   @DomName('Document.visibilityState') @SupportedBrowser(SupportedBrowser.CHROME) @SupportedBrowser(SupportedBrowser.FIREFOX) @SupportedBrowser(SupportedBrowser.IE, '10') @Experimental() String get visibilityState {}   @Experimental() void registerElement(String tag, Type customElementClass, {String extendsTag}) {}   @deprecated @Experimental() void register(String tag, Type customElementClass, {String extendsTag}) {}   static const visibilityChangeEvent = const _CustomEventStreamProvider<Event>(_determineVisibilityChangeEventType);   static String _determineVisibilityChangeEventType(EventTarget e) { throw new UnsupportedError("HtmlDocument._determineVisibilityChangeEventType() is unsupported on this platform."); }   @SupportedBrowser(SupportedBrowser.CHROME) @SupportedBrowser(SupportedBrowser.FIREFOX) @SupportedBrowser(SupportedBrowser.IE, '10') @Experimental() Stream<Event> get onVisibilityChange {}   @Experimental() ElementUpgrader createElementUpgrader(Type type, {String extendsTag}) {} } @DocsEditable() @DomName('HTMLElement') class HtmlElement extends Element implements GlobalEventHandlers { factory HtmlElement._() { throw new UnsupportedError("new HtmlElement._() is unsupported on this platform."); }   static const abortEvent = const EventStreamProvider<Event>('abort');   static const blurEvent = const EventStreamProvider<Event>('blur');   static const canPlayEvent = const EventStreamProvider<Event>('canplay');   static const canPlayThroughEvent = const EventStreamProvider<Event>('canplaythrough');   static const changeEvent = const EventStreamProvider<Event>('change');   static const clickEvent = const EventStreamProvider<MouseEvent>('click');   static const contextMenuEvent = const EventStreamProvider<MouseEvent>('contextmenu');   static const doubleClickEvent = const EventStreamProvider<Event>('dblclick');   static const dragEvent = const EventStreamProvider<MouseEvent>('drag');   static const dragEndEvent = const EventStreamProvider<MouseEvent>('dragend');   static const dragEnterEvent = const EventStreamProvider<MouseEvent>('dragenter');   static const dragLeaveEvent = const EventStreamProvider<MouseEvent>('dragleave');   static const dragOverEvent = const EventStreamProvider<MouseEvent>('dragover');   static const dragStartEvent = const EventStreamProvider<MouseEvent>('dragstart');   static const dropEvent = const EventStreamProvider<MouseEvent>('drop');   static const durationChangeEvent = const EventStreamProvider<Event>('durationchange');   static const emptiedEvent = const EventStreamProvider<Event>('emptied');   static const endedEvent = const EventStreamProvider<Event>('ended');   static const errorEvent = const EventStreamProvider<Event>('error');   static const focusEvent = const EventStreamProvider<Event>('focus');   static const inputEvent = const EventStreamProvider<Event>('input');   static const invalidEvent = const EventStreamProvider<Event>('invalid');   static const keyDownEvent = const EventStreamProvider<KeyboardEvent>('keydown');   static const keyPressEvent = const EventStreamProvider<KeyboardEvent>('keypress');   static const keyUpEvent = const EventStreamProvider<KeyboardEvent>('keyup');   static const loadEvent = const EventStreamProvider<Event>('load');   static const loadedDataEvent = const EventStreamProvider<Event>('loadeddata');   static const loadedMetadataEvent = const EventStreamProvider<Event>('loadedmetadata');   static const mouseDownEvent = const EventStreamProvider<MouseEvent>('mousedown');   static const mouseEnterEvent = const EventStreamProvider<MouseEvent>('mouseenter');   static const mouseLeaveEvent = const EventStreamProvider<MouseEvent>('mouseleave');   static const mouseMoveEvent = const EventStreamProvider<MouseEvent>('mousemove');   static const mouseOutEvent = const EventStreamProvider<MouseEvent>('mouseout');   static const mouseOverEvent = const EventStreamProvider<MouseEvent>('mouseover');   static const mouseUpEvent = const EventStreamProvider<MouseEvent>('mouseup');   static const mouseWheelEvent = const EventStreamProvider<WheelEvent>('mousewheel');   static const pauseEvent = const EventStreamProvider<Event>('pause');   static const playEvent = const EventStreamProvider<Event>('play');   static const playingEvent = const EventStreamProvider<Event>('playing');   static const rateChangeEvent = const EventStreamProvider<Event>('ratechange');   static const resetEvent = const EventStreamProvider<Event>('reset');   static const resizeEvent = const EventStreamProvider<Event>('resize');   static const scrollEvent = const EventStreamProvider<Event>('scroll');   static const seekedEvent = const EventStreamProvider<Event>('seeked');   static const seekingEvent = const EventStreamProvider<Event>('seeking');   static const selectEvent = const EventStreamProvider<Event>('select');   static const stalledEvent = const EventStreamProvider<Event>('stalled');   static const submitEvent = const EventStreamProvider<Event>('submit');   static const suspendEvent = const EventStreamProvider<Event>('suspend');   static const timeUpdateEvent = const EventStreamProvider<Event>('timeupdate');   static const volumeChangeEvent = const EventStreamProvider<Event>('volumechange');   static const waitingEvent = const EventStreamProvider<Event>('waiting');   HtmlElement.created() : super.created() { throw new UnsupportedError("new HtmlElement.created() is unsupported on this platform."); }   @DomName('HTMLElement.contentEditable') @DocsEditable() String get contentEditable {}   @DomName('HTMLElement.contentEditable') @DocsEditable() void set contentEditable(String value) {}   @DomName('HTMLElement.dir') @DocsEditable() String get dir {}   @DomName('HTMLElement.dir') @DocsEditable() void set dir(String value) {}   @DomName('HTMLElement.draggable') @DocsEditable() bool get draggable {}   @DomName('HTMLElement.draggable') @DocsEditable() void set draggable(bool value) {}   @DomName('HTMLElement.hidden') @DocsEditable() bool get hidden {}   @DomName('HTMLElement.hidden') @DocsEditable() void set hidden(bool value) {}   @DomName('HTMLElement.inputMethodContext') @DocsEditable() @Experimental() InputMethodContext get inputMethodContext {}   @DomName('HTMLElement.isContentEditable') @DocsEditable() bool get isContentEditable {}   @DomName('HTMLElement.lang') @DocsEditable() String get lang {}   @DomName('HTMLElement.lang') @DocsEditable() void set lang(String value) {}   @DomName('HTMLElement.spellcheck') @DocsEditable() @Experimental() bool get spellcheck {}   @DomName('HTMLElement.spellcheck') @DocsEditable() @Experimental() void set spellcheck(bool value) {}   @DomName('HTMLElement.tabIndex') @DocsEditable() int get tabIndex {}   @DomName('HTMLElement.tabIndex') @DocsEditable() void set tabIndex(int value) {}   @DomName('HTMLElement.title') @DocsEditable() String get title {}   @DomName('HTMLElement.title') @DocsEditable() void set title(String value) {}   @DomName('HTMLElement.translate') @DocsEditable() bool get translate {}   @DomName('HTMLElement.translate') @DocsEditable() void set translate(bool value) {}   @DomName('HTMLElement.webkitdropzone') @DocsEditable() @SupportedBrowser(SupportedBrowser.CHROME) @SupportedBrowser(SupportedBrowser.SAFARI) @Experimental() String get dropzone {}   @DomName('HTMLElement.webkitdropzone') @DocsEditable() @SupportedBrowser(SupportedBrowser.CHROME) @SupportedBrowser(SupportedBrowser.SAFARI) @Experimental() void set dropzone(String value) {}   @DomName('HTMLElement.click') @DocsEditable() void click() {}   @DomName('HTMLElement.onabort') @DocsEditable() @Experimental() ElementStream<Event> get onAbort {}   @DomName('HTMLElement.onblur') @DocsEditable() @Experimental() ElementStream<Event> get onBlur {}   @DomName('HTMLElement.oncanplay') @DocsEditable() @Experimental() ElementStream<Event> get onCanPlay {}   @DomName('HTMLElement.oncanplaythrough') @DocsEditable() @Experimental() ElementStream<Event> get onCanPlayThrough {}   @DomName('HTMLElement.onchange') @DocsEditable() @Experimental() ElementStream<Event> get onChange {}   @DomName('HTMLElement.onclick') @DocsEditable() @Experimental() ElementStream<MouseEvent> get onClick {}   @DomName('HTMLElement.oncontextmenu') @DocsEditable() @Experimental() ElementStream<MouseEvent> get onContextMenu {}   @DomName('HTMLElement.ondblclick') @DocsEditable() @Experimental() ElementStream<Event> get onDoubleClick {}   @DomName('HTMLElement.ondrag') @DocsEditable() @Experimental() ElementStream<MouseEvent> get onDrag {}   @DomName('HTMLElement.ondragend') @DocsEditable() @Experimental() ElementStream<MouseEvent> get onDragEnd {}   @DomName('HTMLElement.ondragenter') @DocsEditable() @Experimental() ElementStream<MouseEvent> get onDragEnter {}   @DomName('HTMLElement.ondragleave') @DocsEditable() @Experimental() ElementStream<MouseEvent> get onDragLeave {}   @DomName('HTMLElement.ondragover') @DocsEditable() @Experimental() ElementStream<MouseEvent> get onDragOver {}   @DomName('HTMLElement.ondragstart') @DocsEditable() @Experimental() ElementStream<MouseEvent> get onDragStart {}   @DomName('HTMLElement.ondrop') @DocsEditable() @Experimental() ElementStream<MouseEvent> get onDrop {}   @DomName('HTMLElement.ondurationchange') @DocsEditable() @Experimental() ElementStream<Event> get onDurationChange {}   @DomName('HTMLElement.onemptied') @DocsEditable() @Experimental() ElementStream<Event> get onEmptied {}   @DomName('HTMLElement.onended') @DocsEditable() @Experimental() ElementStream<Event> get onEnded {}   @DomName('HTMLElement.onerror') @DocsEditable() @Experimental() ElementStream<Event> get onError {}   @DomName('HTMLElement.onfocus') @DocsEditable() @Experimental() ElementStream<Event> get onFocus {}   @DomName('HTMLElement.oninput') @DocsEditable() @Experimental() ElementStream<Event> get onInput {}   @DomName('HTMLElement.oninvalid') @DocsEditable() @Experimental() ElementStream<Event> get onInvalid {}   @DomName('HTMLElement.onkeydown') @DocsEditable() @Experimental() ElementStream<KeyboardEvent> get onKeyDown {}   @DomName('HTMLElement.onkeypress') @DocsEditable() @Experimental() ElementStream<KeyboardEvent> get onKeyPress {}   @DomName('HTMLElement.onkeyup') @DocsEditable() @Experimental() ElementStream<KeyboardEvent> get onKeyUp {}   @DomName('HTMLElement.onload') @DocsEditable() @Experimental() ElementStream<Event> get onLoad {}   @DomName('HTMLElement.onloadeddata') @DocsEditable() @Experimental() ElementStream<Event> get onLoadedData {}   @DomName('HTMLElement.onloadedmetadata') @DocsEditable() @Experimental() ElementStream<Event> get onLoadedMetadata {}   @DomName('HTMLElement.onmousedown') @DocsEditable() @Experimental() ElementStream<MouseEvent> get onMouseDown {}   @DomName('HTMLElement.onmouseenter') @DocsEditable() @Experimental() ElementStream<MouseEvent> get onMouseEnter {}   @DomName('HTMLElement.onmouseleave') @DocsEditable() @Experimental() ElementStream<MouseEvent> get onMouseLeave {}   @DomName('HTMLElement.onmousemove') @DocsEditable() @Experimental() ElementStream<MouseEvent> get onMouseMove {}   @DomName('HTMLElement.onmouseout') @DocsEditable() @Experimental() ElementStream<MouseEvent> get onMouseOut {}   @DomName('HTMLElement.onmouseover') @DocsEditable() @Experimental() ElementStream<MouseEvent> get onMouseOver {}   @DomName('HTMLElement.onmouseup') @DocsEditable() @Experimental() ElementStream<MouseEvent> get onMouseUp {}   @DomName('HTMLElement.onmousewheel') @DocsEditable() @Experimental() ElementStream<WheelEvent> get onMouseWheel {}   @DomName('HTMLElement.onpause') @DocsEditable() @Experimental() ElementStream<Event> get onPause {}   @DomName('HTMLElement.onplay') @DocsEditable() @Experimental() ElementStream<Event> get onPlay {}   @DomName('HTMLElement.onplaying') @DocsEditable() @Experimental() ElementStream<Event> get onPlaying {}   @DomName('HTMLElement.onratechange') @DocsEditable() @Experimental() ElementStream<Event> get onRateChange {}   @DomName('HTMLElement.onreset') @DocsEditable() @Experimental() ElementStream<Event> get onReset {}   @DomName('HTMLElement.onresize') @DocsEditable() @Experimental() ElementStream<Event> get onResize {}   @DomName('HTMLElement.onscroll') @DocsEditable() @Experimental() ElementStream<Event> get onScroll {}   @DomName('HTMLElement.onseeked') @DocsEditable() @Experimental() ElementStream<Event> get onSeeked {}   @DomName('HTMLElement.onseeking') @DocsEditable() @Experimental() ElementStream<Event> get onSeeking {}   @DomName('HTMLElement.onselect') @DocsEditable() @Experimental() ElementStream<Event> get onSelect {}   @DomName('HTMLElement.onstalled') @DocsEditable() @Experimental() ElementStream<Event> get onStalled {}   @DomName('HTMLElement.onsubmit') @DocsEditable() @Experimental() ElementStream<Event> get onSubmit {}   @DomName('HTMLElement.onsuspend') @DocsEditable() @Experimental() ElementStream<Event> get onSuspend {}   @DomName('HTMLElement.ontimeupdate') @DocsEditable() @Experimental() ElementStream<Event> get onTimeUpdate {}   @DomName('HTMLElement.onvolumechange') @DocsEditable() @Experimental() ElementStream<Event> get onVolumeChange {}   @DomName('HTMLElement.onwaiting') @DocsEditable() @Experimental() ElementStream<Event> get onWaiting {} } @DocsEditable() @DomName('HTMLFormControlsCollection') class HtmlFormControlsCollection extends HtmlCollection { factory HtmlFormControlsCollection._() { throw new UnsupportedError("new HtmlFormControlsCollection._() is unsupported on this platform."); }   @DomName('HTMLFormControlsCollection.namedItem') @DocsEditable() Object namedItem(String name) {} } @DocsEditable() @DomName('HTMLHtmlElement') class HtmlHtmlElement extends HtmlElement { factory HtmlHtmlElement._() { throw new UnsupportedError("new HtmlHtmlElement._() is unsupported on this platform."); }   @DomName('HTMLHtmlElement.HTMLHtmlElement') @DocsEditable() factory HtmlHtmlElement() { throw new UnsupportedError("new HtmlHtmlElement() is unsupported on this platform."); }   HtmlHtmlElement.created() : super.created() { throw new UnsupportedError("new HtmlHtmlElement.created() is unsupported on this platform."); } } @DocsEditable() @DomName('HTMLOptionsCollection') class HtmlOptionsCollection extends HtmlCollection { factory HtmlOptionsCollection._() { throw new UnsupportedError("new HtmlOptionsCollection._() is unsupported on this platform."); } } @DomName('XMLHttpRequest') class HttpRequest extends HttpRequestEventTarget { static Future<String> getString(String url, {bool withCredentials, void onProgress(ProgressEvent e)}) { throw new UnsupportedError("HttpRequest.getString() is unsupported on this platform."); }   static Future<HttpRequest> postFormData(String url, Map<String, String> data, {bool withCredentials, String responseType, Map<String, String> requestHeaders, void onProgress(ProgressEvent e)}) { throw new UnsupportedError("HttpRequest.postFormData() is unsupported on this platform."); }   static Future<HttpRequest> request(String url, {String method, bool withCredentials, String responseType, String mimeType, Map<String, String> requestHeaders, sendData, void onProgress(ProgressEvent e)}) { throw new UnsupportedError("HttpRequest.request() is unsupported on this platform."); }   static bool get supportsProgressEvent { throw new UnsupportedError("HttpRequest.supportsProgressEvent is unsupported on this platform."); }   static bool get supportsCrossOrigin { throw new UnsupportedError("HttpRequest.supportsCrossOrigin is unsupported on this platform."); }   static bool get supportsLoadEndEvent { throw new UnsupportedError("HttpRequest.supportsLoadEndEvent is unsupported on this platform."); }   static bool get supportsOverrideMimeType { throw new UnsupportedError("HttpRequest.supportsOverrideMimeType is unsupported on this platform."); }   @Experimental() static Future<String> requestCrossOrigin(String url, {String method, String sendData}) { throw new UnsupportedError("HttpRequest.requestCrossOrigin() is unsupported on this platform."); }   Map<String, String> get responseHeaders {}   factory HttpRequest._() { throw new UnsupportedError("new HttpRequest._() is unsupported on this platform."); }   static const readyStateChangeEvent = const EventStreamProvider<ProgressEvent>('readystatechange');   @DomName('XMLHttpRequest.XMLHttpRequest') @DocsEditable() factory HttpRequest() { throw new UnsupportedError("new HttpRequest() is unsupported on this platform."); }   @DocsEditable() static HttpRequest _create() { throw new UnsupportedError("HttpRequest._create() is unsupported on this platform."); }   static const DONE = 4;   static const HEADERS_RECEIVED = 2;   static const LOADING = 3;   static const OPENED = 1;   static const UNSENT = 0;   @DomName('XMLHttpRequest.readyState') @DocsEditable() int get readyState {}   @DomName('XMLHttpRequest.response') @DocsEditable() @SupportedBrowser(SupportedBrowser.CHROME) @SupportedBrowser(SupportedBrowser.FIREFOX) @SupportedBrowser(SupportedBrowser.IE, '10') @SupportedBrowser(SupportedBrowser.SAFARI) Object get response {}   @DomName('XMLHttpRequest.responseText') @DocsEditable() String get responseText {}   @DomName('XMLHttpRequest.responseType') @DocsEditable() String get responseType {}   @DomName('XMLHttpRequest.responseType') @DocsEditable() void set responseType(String value) {}   @DomName('XMLHttpRequest.responseURL') @DocsEditable() @Experimental() String get responseUrl {}   @DomName('XMLHttpRequest.responseXML') @DocsEditable() Document get responseXml {}   @DomName('XMLHttpRequest.status') @DocsEditable() int get status {}   @DomName('XMLHttpRequest.statusText') @DocsEditable() String get statusText {}   @DomName('XMLHttpRequest.timeout') @DocsEditable() @Experimental() int get timeout {}   @DomName('XMLHttpRequest.timeout') @DocsEditable() @Experimental() void set timeout(int value) {}   @DomName('XMLHttpRequest.upload') @DocsEditable() @Unstable() HttpRequestUpload get upload {}   @DomName('XMLHttpRequest.withCredentials') @DocsEditable() bool get withCredentials {}   @DomName('XMLHttpRequest.withCredentials') @DocsEditable() void set withCredentials(bool value) {}   @DomName('XMLHttpRequest.abort') @DocsEditable() void abort() {}   @DomName('XMLHttpRequest.getAllResponseHeaders') @DocsEditable() @Unstable() String getAllResponseHeaders() {}   @DomName('XMLHttpRequest.getResponseHeader') @DocsEditable() @Unstable() String getResponseHeader(String header) {}   @DomName('XMLHttpRequest.open') @DocsEditable() void open(String method, String url, {bool async, String user, String password}) {}   @DomName('XMLHttpRequest.overrideMimeType') @DocsEditable() @SupportedBrowser(SupportedBrowser.CHROME) @SupportedBrowser(SupportedBrowser.FIREFOX) @SupportedBrowser(SupportedBrowser.SAFARI) void overrideMimeType(String override) {}   @DomName('XMLHttpRequest.send') @DocsEditable() void send([data]) {}   @DomName('XMLHttpRequest.setRequestHeader') @DocsEditable() void setRequestHeader(String header, String value) {}   @DomName('XMLHttpRequest.onreadystatechange') @DocsEditable() Stream<ProgressEvent> get onReadyStateChange {} } @DocsEditable() @DomName('XMLHttpRequestEventTarget') @Experimental() class HttpRequestEventTarget extends EventTarget { factory HttpRequestEventTarget._() { throw new UnsupportedError("new HttpRequestEventTarget._() is unsupported on this platform."); }   static const abortEvent = const EventStreamProvider<ProgressEvent>('abort');   static const errorEvent = const EventStreamProvider<ProgressEvent>('error');   static const loadEvent = const EventStreamProvider<ProgressEvent>('load');   static const loadEndEvent = const EventStreamProvider<ProgressEvent>('loadend');   static const loadStartEvent = const EventStreamProvider<ProgressEvent>('loadstart');   static const progressEvent = const EventStreamProvider<ProgressEvent>('progress');   static const timeoutEvent = const EventStreamProvider<ProgressEvent>('timeout');   @DomName('XMLHttpRequestEventTarget.onabort') @DocsEditable() @Experimental() Stream<ProgressEvent> get onAbort {}   @DomName('XMLHttpRequestEventTarget.onerror') @DocsEditable() @Experimental() Stream<ProgressEvent> get onError {}   @DomName('XMLHttpRequestEventTarget.onload') @DocsEditable() @Experimental() Stream<ProgressEvent> get onLoad {}   @DomName('XMLHttpRequestEventTarget.onloadend') @DocsEditable() @SupportedBrowser(SupportedBrowser.CHROME) @SupportedBrowser(SupportedBrowser.FIREFOX) @SupportedBrowser(SupportedBrowser.IE, '10') @SupportedBrowser(SupportedBrowser.SAFARI) @Experimental() Stream<ProgressEvent> get onLoadEnd {}   @DomName('XMLHttpRequestEventTarget.onloadstart') @DocsEditable() @Experimental() Stream<ProgressEvent> get onLoadStart {}   @DomName('XMLHttpRequestEventTarget.onprogress') @DocsEditable() @SupportedBrowser(SupportedBrowser.CHROME) @SupportedBrowser(SupportedBrowser.FIREFOX) @SupportedBrowser(SupportedBrowser.IE, '10') @SupportedBrowser(SupportedBrowser.SAFARI) @Experimental() Stream<ProgressEvent> get onProgress {}   @DomName('XMLHttpRequestEventTarget.ontimeout') @DocsEditable() @Experimental() Stream<ProgressEvent> get onTimeout {} } @DocsEditable() @DomName('XMLHttpRequestUpload') @Experimental() class HttpRequestUpload extends HttpRequestEventTarget { factory HttpRequestUpload._() { throw new UnsupportedError("new HttpRequestUpload._() is unsupported on this platform."); } } @DocsEditable() @DomName('HTMLIFrameElement') class IFrameElement extends HtmlElement { factory IFrameElement._() { throw new UnsupportedError("new IFrameElement._() is unsupported on this platform."); }   @DomName('HTMLIFrameElement.HTMLIFrameElement') @DocsEditable() factory IFrameElement() { throw new UnsupportedError("new IFrameElement() is unsupported on this platform."); }   IFrameElement.created() : super.created() { throw new UnsupportedError("new IFrameElement.created() is unsupported on this platform."); }   @DomName('HTMLIFrameElement.allowFullscreen') @DocsEditable() @Experimental() bool get allowFullscreen {}   @DomName('HTMLIFrameElement.allowFullscreen') @DocsEditable() @Experimental() void set allowFullscreen(bool value) {}   @DomName('HTMLIFrameElement.contentWindow') @DocsEditable() WindowBase get contentWindow {}   @DomName('HTMLIFrameElement.height') @DocsEditable() String get height {}   @DomName('HTMLIFrameElement.height') @DocsEditable() void set height(String value) {}   @DomName('HTMLIFrameElement.integrity') @DocsEditable() @Experimental() String get integrity {}   @DomName('HTMLIFrameElement.integrity') @DocsEditable() @Experimental() void set integrity(String value) {}   @DomName('HTMLIFrameElement.name') @DocsEditable() String get name {}   @DomName('HTMLIFrameElement.name') @DocsEditable() void set name(String value) {}   @DomName('HTMLIFrameElement.sandbox') @DocsEditable() String get sandbox {}   @DomName('HTMLIFrameElement.sandbox') @DocsEditable() void set sandbox(String value) {}   @DomName('HTMLIFrameElement.src') @DocsEditable() String get src {}   @DomName('HTMLIFrameElement.src') @DocsEditable() void set src(String value) {}   @DomName('HTMLIFrameElement.srcdoc') @DocsEditable() String get srcdoc {}   @DomName('HTMLIFrameElement.srcdoc') @DocsEditable() void set srcdoc(String value) {}   @DomName('HTMLIFrameElement.width') @DocsEditable() String get width {}   @DomName('HTMLIFrameElement.width') @DocsEditable() void set width(String value) {} } @DocsEditable() @DomName('ImageBitmap') @Experimental() class ImageBitmap extends NativeFieldWrapperClass2 { factory ImageBitmap._() { throw new UnsupportedError("new ImageBitmap._() is unsupported on this platform."); }   @DomName('ImageBitmap.height') @DocsEditable() @Experimental() int get height {}   @DomName('ImageBitmap.width') @DocsEditable() @Experimental() int get width {} } @DomName('ImageData') class ImageData extends NativeFieldWrapperClass2 {   List<int> get data {}   factory ImageData._() { throw new UnsupportedError("new ImageData._() is unsupported on this platform."); }   @DomName('ImageData.ImageData') @DocsEditable() factory ImageData(data_OR_width, int height_OR_width, [int height]) { throw new UnsupportedError("new ImageData() is unsupported on this platform."); }    @DomName('ImageData.height') @DocsEditable() int get height {}   @DomName('ImageData.width') @DocsEditable() int get width {} } @DomName('HTMLImageElement') class ImageElement extends HtmlElement implements CanvasImageSource { factory ImageElement._() { throw new UnsupportedError("new ImageElement._() is unsupported on this platform."); }   @DomName('HTMLImageElement.HTMLImageElement') @DocsEditable() factory ImageElement({String src, int width, int height}) { throw new UnsupportedError("new ImageElement() is unsupported on this platform."); }   ImageElement.created() : super.created() { throw new UnsupportedError("new ImageElement.created() is unsupported on this platform."); }   @DomName('HTMLImageElement.alt') @DocsEditable() String get alt {}   @DomName('HTMLImageElement.alt') @DocsEditable() void set alt(String value) {}   @DomName('HTMLImageElement.complete') @DocsEditable() bool get complete {}   @DomName('HTMLImageElement.crossOrigin') @DocsEditable() String get crossOrigin {}   @DomName('HTMLImageElement.crossOrigin') @DocsEditable() void set crossOrigin(String value) {}   @DomName('HTMLImageElement.currentSrc') @DocsEditable() @Experimental() String get currentSrc {}   @DomName('HTMLImageElement.height') @DocsEditable() int get height {}   @DomName('HTMLImageElement.height') @DocsEditable() void set height(int value) {}   @DomName('HTMLImageElement.integrity') @DocsEditable() @Experimental() String get integrity {}   @DomName('HTMLImageElement.integrity') @DocsEditable() @Experimental() void set integrity(String value) {}   @DomName('HTMLImageElement.isMap') @DocsEditable() bool get isMap {}   @DomName('HTMLImageElement.isMap') @DocsEditable() void set isMap(bool value) {}   @DomName('HTMLImageElement.naturalHeight') @DocsEditable() int get naturalHeight {}   @DomName('HTMLImageElement.naturalWidth') @DocsEditable() int get naturalWidth {}   @DomName('HTMLImageElement.sizes') @DocsEditable() @Experimental() String get sizes {}   @DomName('HTMLImageElement.sizes') @DocsEditable() @Experimental() void set sizes(String value) {}   @DomName('HTMLImageElement.src') @DocsEditable() String get src {}   @DomName('HTMLImageElement.src') @DocsEditable() void set src(String value) {}   @DomName('HTMLImageElement.srcset') @DocsEditable() @Experimental() String get srcset {}   @DomName('HTMLImageElement.srcset') @DocsEditable() @Experimental() void set srcset(String value) {}   @DomName('HTMLImageElement.useMap') @DocsEditable() String get useMap {}   @DomName('HTMLImageElement.useMap') @DocsEditable() void set useMap(String value) {}   @DomName('HTMLImageElement.width') @DocsEditable() int get width {}   @DomName('HTMLImageElement.width') @DocsEditable() void set width(int value) {} } @DocsEditable() @DomName('InjectedScriptHost') @Experimental() class InjectedScriptHost extends NativeFieldWrapperClass2 { factory InjectedScriptHost._() { throw new UnsupportedError("new InjectedScriptHost._() is unsupported on this platform."); }   @DomName('InjectedScriptHost.inspect') @DocsEditable() @Experimental() void inspect(Object objectId, Object hints) {} } @DomName('HTMLInputElement') class InputElement extends HtmlElement implements HiddenInputElement, SearchInputElement, TextInputElement, UrlInputElement, TelephoneInputElement, EmailInputElement, PasswordInputElement, DateInputElement, MonthInputElement, WeekInputElement, TimeInputElement, LocalDateTimeInputElement, NumberInputElement, RangeInputElement, CheckboxInputElement, RadioButtonInputElement, FileUploadInputElement, SubmitButtonInputElement, ImageButtonInputElement, ResetButtonInputElement, ButtonInputElement { factory InputElement({String type}) { throw new UnsupportedError("new InputElement() is unsupported on this platform."); }   factory InputElement._() { throw new UnsupportedError("new InputElement._() is unsupported on this platform."); }   InputElement.created() : super.created() { throw new UnsupportedError("new InputElement.created() is unsupported on this platform."); }   @DomName('HTMLInputElement.accept') @DocsEditable() String get accept {}   @DomName('HTMLInputElement.accept') @DocsEditable() void set accept(String value) {}   @DomName('HTMLInputElement.alt') @DocsEditable() String get alt {}   @DomName('HTMLInputElement.alt') @DocsEditable() void set alt(String value) {}   @DomName('HTMLInputElement.autocomplete') @DocsEditable() String get autocomplete {}   @DomName('HTMLInputElement.autocomplete') @DocsEditable() void set autocomplete(String value) {}   @DomName('HTMLInputElement.autofocus') @DocsEditable() bool get autofocus {}   @DomName('HTMLInputElement.autofocus') @DocsEditable() void set autofocus(bool value) {}   @DomName('HTMLInputElement.capture') @DocsEditable() @Experimental() bool get capture {}   @DomName('HTMLInputElement.capture') @DocsEditable() @Experimental() void set capture(bool value) {}   @DomName('HTMLInputElement.checked') @DocsEditable() bool get checked {}   @DomName('HTMLInputElement.checked') @DocsEditable() void set checked(bool value) {}   @DomName('HTMLInputElement.defaultChecked') @DocsEditable() bool get defaultChecked {}   @DomName('HTMLInputElement.defaultChecked') @DocsEditable() void set defaultChecked(bool value) {}   @DomName('HTMLInputElement.defaultValue') @DocsEditable() String get defaultValue {}   @DomName('HTMLInputElement.defaultValue') @DocsEditable() void set defaultValue(String value) {}   @DomName('HTMLInputElement.dirName') @DocsEditable() String get dirName {}   @DomName('HTMLInputElement.dirName') @DocsEditable() void set dirName(String value) {}   @DomName('HTMLInputElement.disabled') @DocsEditable() bool get disabled {}   @DomName('HTMLInputElement.disabled') @DocsEditable() void set disabled(bool value) {}   @DomName('HTMLInputElement.files') @DocsEditable() List<File> get files {}   @DomName('HTMLInputElement.files') @DocsEditable() void set files(List<File> value) {}   @DomName('HTMLInputElement.form') @DocsEditable() FormElement get form {}   @DomName('HTMLInputElement.formAction') @DocsEditable() String get formAction {}   @DomName('HTMLInputElement.formAction') @DocsEditable() void set formAction(String value) {}   @DomName('HTMLInputElement.formEnctype') @DocsEditable() String get formEnctype {}   @DomName('HTMLInputElement.formEnctype') @DocsEditable() void set formEnctype(String value) {}   @DomName('HTMLInputElement.formMethod') @DocsEditable() String get formMethod {}   @DomName('HTMLInputElement.formMethod') @DocsEditable() void set formMethod(String value) {}   @DomName('HTMLInputElement.formNoValidate') @DocsEditable() bool get formNoValidate {}   @DomName('HTMLInputElement.formNoValidate') @DocsEditable() void set formNoValidate(bool value) {}   @DomName('HTMLInputElement.formTarget') @DocsEditable() String get formTarget {}   @DomName('HTMLInputElement.formTarget') @DocsEditable() void set formTarget(String value) {}   @DomName('HTMLInputElement.height') @DocsEditable() int get height {}   @DomName('HTMLInputElement.height') @DocsEditable() void set height(int value) {}   @DomName('HTMLInputElement.incremental') @DocsEditable() @Experimental() bool get incremental {}   @DomName('HTMLInputElement.incremental') @DocsEditable() @Experimental() void set incremental(bool value) {}   @DomName('HTMLInputElement.indeterminate') @DocsEditable() bool get indeterminate {}   @DomName('HTMLInputElement.indeterminate') @DocsEditable() void set indeterminate(bool value) {}   @DomName('HTMLInputElement.inputMode') @DocsEditable() @Experimental() String get inputMode {}   @DomName('HTMLInputElement.inputMode') @DocsEditable() @Experimental() void set inputMode(String value) {}   @DomName('HTMLInputElement.labels') @DocsEditable() List<Node> get labels {}   @DomName('HTMLInputElement.list') @DocsEditable() HtmlElement get list {}   @DomName('HTMLInputElement.max') @DocsEditable() String get max {}   @DomName('HTMLInputElement.max') @DocsEditable() void set max(String value) {}   @DomName('HTMLInputElement.maxLength') @DocsEditable() int get maxLength {}   @DomName('HTMLInputElement.maxLength') @DocsEditable() void set maxLength(int value) {}   @DomName('HTMLInputElement.min') @DocsEditable() String get min {}   @DomName('HTMLInputElement.min') @DocsEditable() void set min(String value) {}   @DomName('HTMLInputElement.multiple') @DocsEditable() bool get multiple {}   @DomName('HTMLInputElement.multiple') @DocsEditable() void set multiple(bool value) {}   @DomName('HTMLInputElement.name') @DocsEditable() String get name {}   @DomName('HTMLInputElement.name') @DocsEditable() void set name(String value) {}   @DomName('HTMLInputElement.pattern') @DocsEditable() String get pattern {}   @DomName('HTMLInputElement.pattern') @DocsEditable() void set pattern(String value) {}   @DomName('HTMLInputElement.placeholder') @DocsEditable() String get placeholder {}   @DomName('HTMLInputElement.placeholder') @DocsEditable() void set placeholder(String value) {}   @DomName('HTMLInputElement.readOnly') @DocsEditable() bool get readOnly {}   @DomName('HTMLInputElement.readOnly') @DocsEditable() void set readOnly(bool value) {}   @DomName('HTMLInputElement.required') @DocsEditable() bool get required {}   @DomName('HTMLInputElement.required') @DocsEditable() void set required(bool value) {}   @DomName('HTMLInputElement.selectionDirection') @DocsEditable() String get selectionDirection {}   @DomName('HTMLInputElement.selectionDirection') @DocsEditable() void set selectionDirection(String value) {}   @DomName('HTMLInputElement.selectionEnd') @DocsEditable() int get selectionEnd {}   @DomName('HTMLInputElement.selectionEnd') @DocsEditable() void set selectionEnd(int value) {}   @DomName('HTMLInputElement.selectionStart') @DocsEditable() int get selectionStart {}   @DomName('HTMLInputElement.selectionStart') @DocsEditable() void set selectionStart(int value) {}   @DomName('HTMLInputElement.size') @DocsEditable() int get size {}   @DomName('HTMLInputElement.size') @DocsEditable() void set size(int value) {}   @DomName('HTMLInputElement.src') @DocsEditable() String get src {}   @DomName('HTMLInputElement.src') @DocsEditable() void set src(String value) {}   @DomName('HTMLInputElement.step') @DocsEditable() String get step {}   @DomName('HTMLInputElement.step') @DocsEditable() void set step(String value) {}   @DomName('HTMLInputElement.type') @DocsEditable() String get type {}   @DomName('HTMLInputElement.type') @DocsEditable() void set type(String value) {}   @DomName('HTMLInputElement.validationMessage') @DocsEditable() String get validationMessage {}   @DomName('HTMLInputElement.validity') @DocsEditable() ValidityState get validity {}   @DomName('HTMLInputElement.value') @DocsEditable() String get value {}   @DomName('HTMLInputElement.value') @DocsEditable() void set value(String value) {}   @DomName('HTMLInputElement.valueAsDate') @DocsEditable() DateTime get valueAsDate {}   @DomName('HTMLInputElement.valueAsDate') @DocsEditable() void set valueAsDate(DateTime value) {}   @DomName('HTMLInputElement.valueAsNumber') @DocsEditable() num get valueAsNumber {}   @DomName('HTMLInputElement.valueAsNumber') @DocsEditable() void set valueAsNumber(num value) {}   @DomName('HTMLInputElement.webkitEntries') @DocsEditable() @SupportedBrowser(SupportedBrowser.CHROME) @SupportedBrowser(SupportedBrowser.SAFARI) @Experimental() List<Entry> get entries {}   @DomName('HTMLInputElement.webkitdirectory') @DocsEditable() @SupportedBrowser(SupportedBrowser.CHROME) @SupportedBrowser(SupportedBrowser.SAFARI) @Experimental() bool get directory {}   @DomName('HTMLInputElement.webkitdirectory') @DocsEditable() @SupportedBrowser(SupportedBrowser.CHROME) @SupportedBrowser(SupportedBrowser.SAFARI) @Experimental() void set directory(bool value) {}   @DomName('HTMLInputElement.width') @DocsEditable() int get width {}   @DomName('HTMLInputElement.width') @DocsEditable() void set width(int value) {}   @DomName('HTMLInputElement.willValidate') @DocsEditable() bool get willValidate {}   @DomName('HTMLInputElement.checkValidity') @DocsEditable() bool checkValidity() {}   @DomName('HTMLInputElement.select') @DocsEditable() void select() {}   @DomName('HTMLInputElement.setCustomValidity') @DocsEditable() void setCustomValidity(String error) {}   void setRangeText(String replacement, {int start, int end, String selectionMode}) {}   void setSelectionRange(int start, int end, [String direction]) {}   void stepDown([int n]) {}   void stepUp([int n]) {} } abstract class InputElementBase implements Element { bool get autofocus => throw new UnsupportedError("InputElementBase.autofocus is unsupported on this platform."); set autofocus(bool _) { throw new UnsupportedError("InputElementBase.autofocus= is unsupported on this platform."); }   bool get disabled => throw new UnsupportedError("InputElementBase.disabled is unsupported on this platform."); set disabled(bool _) { throw new UnsupportedError("InputElementBase.disabled= is unsupported on this platform."); }   bool get incremental => throw new UnsupportedError("InputElementBase.incremental is unsupported on this platform."); set incremental(bool _) { throw new UnsupportedError("InputElementBase.incremental= is unsupported on this platform."); }   bool get indeterminate => throw new UnsupportedError("InputElementBase.indeterminate is unsupported on this platform."); set indeterminate(bool _) { throw new UnsupportedError("InputElementBase.indeterminate= is unsupported on this platform."); }   @DomName('HTMLInputElement.labels') List<Node> get labels;   String get name => throw new UnsupportedError("InputElementBase.name is unsupported on this platform."); set name(String _) { throw new UnsupportedError("InputElementBase.name= is unsupported on this platform."); }   @DomName('HTMLInputElement.validationMessage') String get validationMessage;   @DomName('HTMLInputElement.validity') ValidityState get validity;   String get value => throw new UnsupportedError("InputElementBase.value is unsupported on this platform."); set value(String _) { throw new UnsupportedError("InputElementBase.value= is unsupported on this platform."); }   @DomName('HTMLInputElement.willValidate') bool get willValidate;   @DomName('HTMLInputElement.checkValidity') bool checkValidity();   @DomName('HTMLInputElement.setCustomValidity') void setCustomValidity(String error); } abstract class HiddenInputElement implements InputElementBase { factory HiddenInputElement() { throw new UnsupportedError("new HiddenInputElement() is unsupported on this platform."); } } abstract class TextInputElementBase implements InputElementBase { String get autocomplete => throw new UnsupportedError("TextInputElementBase.autocomplete is unsupported on this platform."); set autocomplete(String _) { throw new UnsupportedError("TextInputElementBase.autocomplete= is unsupported on this platform."); }   int get maxLength => throw new UnsupportedError("TextInputElementBase.maxLength is unsupported on this platform."); set maxLength(int _) { throw new UnsupportedError("TextInputElementBase.maxLength= is unsupported on this platform."); }   String get pattern => throw new UnsupportedError("TextInputElementBase.pattern is unsupported on this platform."); set pattern(String _) { throw new UnsupportedError("TextInputElementBase.pattern= is unsupported on this platform."); }   String get placeholder => throw new UnsupportedError("TextInputElementBase.placeholder is unsupported on this platform."); set placeholder(String _) { throw new UnsupportedError("TextInputElementBase.placeholder= is unsupported on this platform."); }   bool get readOnly => throw new UnsupportedError("TextInputElementBase.readOnly is unsupported on this platform."); set readOnly(bool _) { throw new UnsupportedError("TextInputElementBase.readOnly= is unsupported on this platform."); }   bool get required => throw new UnsupportedError("TextInputElementBase.required is unsupported on this platform."); set required(bool _) { throw new UnsupportedError("TextInputElementBase.required= is unsupported on this platform."); }   int get size => throw new UnsupportedError("TextInputElementBase.size is unsupported on this platform."); set size(int _) { throw new UnsupportedError("TextInputElementBase.size= is unsupported on this platform."); }   @DomName('HTMLInputElement.select') void select();   String get selectionDirection => throw new UnsupportedError("TextInputElementBase.selectionDirection is unsupported on this platform."); set selectionDirection(String _) { throw new UnsupportedError("TextInputElementBase.selectionDirection= is unsupported on this platform."); }   int get selectionEnd => throw new UnsupportedError("TextInputElementBase.selectionEnd is unsupported on this platform."); set selectionEnd(int _) { throw new UnsupportedError("TextInputElementBase.selectionEnd= is unsupported on this platform."); }   int get selectionStart => throw new UnsupportedError("TextInputElementBase.selectionStart is unsupported on this platform."); set selectionStart(int _) { throw new UnsupportedError("TextInputElementBase.selectionStart= is unsupported on this platform."); }   @DomName('HTMLInputElement.setSelectionRange') void setSelectionRange(int start, int end, [String direction]); } @SupportedBrowser(SupportedBrowser.CHROME) @SupportedBrowser(SupportedBrowser.FIREFOX) @SupportedBrowser(SupportedBrowser.IE, '10') @SupportedBrowser(SupportedBrowser.SAFARI) abstract class SearchInputElement implements TextInputElementBase { factory SearchInputElement() { throw new UnsupportedError("new SearchInputElement() is unsupported on this platform."); }   String dirName  @DomName('HTMLInputElement.list') Element get list;   static bool get supported { throw new UnsupportedError("SearchInputElement.supported is unsupported on this platform."); } } abstract class TextInputElement implements TextInputElementBase { factory TextInputElement() { throw new UnsupportedError("new TextInputElement() is unsupported on this platform."); }   String dirName  @DomName('HTMLInputElement.list') Element get list; } @SupportedBrowser(SupportedBrowser.CHROME) @SupportedBrowser(SupportedBrowser.FIREFOX) @SupportedBrowser(SupportedBrowser.IE, '10') @SupportedBrowser(SupportedBrowser.SAFARI) abstract class UrlInputElement implements TextInputElementBase { factory UrlInputElement() { throw new UnsupportedError("new UrlInputElement() is unsupported on this platform."); }   @DomName('HTMLInputElement.list') Element get list;   static bool get supported { throw new UnsupportedError("UrlInputElement.supported is unsupported on this platform."); } } @SupportedBrowser(SupportedBrowser.CHROME) @SupportedBrowser(SupportedBrowser.FIREFOX) @SupportedBrowser(SupportedBrowser.IE, '10') @SupportedBrowser(SupportedBrowser.SAFARI) abstract class TelephoneInputElement implements TextInputElementBase { factory TelephoneInputElement() { throw new UnsupportedError("new TelephoneInputElement() is unsupported on this platform."); }   @DomName('HTMLInputElement.list') Element get list;   static bool get supported { throw new UnsupportedError("TelephoneInputElement.supported is unsupported on this platform."); } } @SupportedBrowser(SupportedBrowser.CHROME) @SupportedBrowser(SupportedBrowser.FIREFOX) @SupportedBrowser(SupportedBrowser.IE, '10') @SupportedBrowser(SupportedBrowser.SAFARI) abstract class EmailInputElement implements TextInputElementBase { factory EmailInputElement() { throw new UnsupportedError("new EmailInputElement() is unsupported on this platform."); }   String autocomplete  bool autofocus  @DomName('HTMLInputElement.list') Element get list;   int maxLength  bool multiple  String pattern  String placeholder  bool readOnly  bool required  int size  static bool get supported { throw new UnsupportedError("EmailInputElement.supported is unsupported on this platform."); } } abstract class PasswordInputElement implements TextInputElementBase { factory PasswordInputElement() { throw new UnsupportedError("new PasswordInputElement() is unsupported on this platform."); } } abstract class RangeInputElementBase implements InputElementBase { @DomName('HTMLInputElement.list') Element get list;   String get max => throw new UnsupportedError("RangeInputElementBase.max is unsupported on this platform."); set max(String _) { throw new UnsupportedError("RangeInputElementBase.max= is unsupported on this platform."); }   String get min => throw new UnsupportedError("RangeInputElementBase.min is unsupported on this platform."); set min(String _) { throw new UnsupportedError("RangeInputElementBase.min= is unsupported on this platform."); }   String get step => throw new UnsupportedError("RangeInputElementBase.step is unsupported on this platform."); set step(String _) { throw new UnsupportedError("RangeInputElementBase.step= is unsupported on this platform."); }   num get valueAsNumber => throw new UnsupportedError("RangeInputElementBase.valueAsNumber is unsupported on this platform."); set valueAsNumber(num _) { throw new UnsupportedError("RangeInputElementBase.valueAsNumber= is unsupported on this platform."); }   @DomName('HTMLInputElement.stepDown') void stepDown([int n]);   @DomName('HTMLInputElement.stepUp') void stepUp([int n]); } @SupportedBrowser(SupportedBrowser.CHROME, '25') @Experimental() abstract class DateInputElement implements RangeInputElementBase { factory DateInputElement() { throw new UnsupportedError("new DateInputElement() is unsupported on this platform."); }   DateTime valueAsDate  bool readOnly  bool required  static bool get supported { throw new UnsupportedError("DateInputElement.supported is unsupported on this platform."); } } @SupportedBrowser(SupportedBrowser.CHROME, '25') @Experimental() abstract class MonthInputElement implements RangeInputElementBase { factory MonthInputElement() { throw new UnsupportedError("new MonthInputElement() is unsupported on this platform."); }   DateTime valueAsDate  bool readOnly  bool required  static bool get supported { throw new UnsupportedError("MonthInputElement.supported is unsupported on this platform."); } } @SupportedBrowser(SupportedBrowser.CHROME, '25') @Experimental() abstract class WeekInputElement implements RangeInputElementBase { factory WeekInputElement() { throw new UnsupportedError("new WeekInputElement() is unsupported on this platform."); }   DateTime valueAsDate  bool readOnly  bool required  static bool get supported { throw new UnsupportedError("WeekInputElement.supported is unsupported on this platform."); } } @SupportedBrowser(SupportedBrowser.CHROME) @Experimental() abstract class TimeInputElement implements RangeInputElementBase { factory TimeInputElement() { throw new UnsupportedError("new TimeInputElement() is unsupported on this platform."); }   DateTime valueAsDate  bool readOnly  bool required  static bool get supported { throw new UnsupportedError("TimeInputElement.supported is unsupported on this platform."); } } @SupportedBrowser(SupportedBrowser.CHROME, '25') @Experimental() abstract class LocalDateTimeInputElement implements RangeInputElementBase { factory LocalDateTimeInputElement() { throw new UnsupportedError("new LocalDateTimeInputElement() is unsupported on this platform."); }   bool readOnly  bool required  static bool get supported { throw new UnsupportedError("LocalDateTimeInputElement.supported is unsupported on this platform."); } } @SupportedBrowser(SupportedBrowser.CHROME) @SupportedBrowser(SupportedBrowser.IE) @SupportedBrowser(SupportedBrowser.SAFARI) @Experimental() abstract class NumberInputElement implements RangeInputElementBase { factory NumberInputElement() { throw new UnsupportedError("new NumberInputElement() is unsupported on this platform."); }   String placeholder  bool readOnly  bool required  static bool get supported { throw new UnsupportedError("NumberInputElement.supported is unsupported on this platform."); } } @SupportedBrowser(SupportedBrowser.CHROME) @SupportedBrowser(SupportedBrowser.IE, '10') @Experimental() abstract class RangeInputElement implements RangeInputElementBase { factory RangeInputElement() { throw new UnsupportedError("new RangeInputElement() is unsupported on this platform."); }   static bool get supported { throw new UnsupportedError("RangeInputElement.supported is unsupported on this platform."); } } abstract class CheckboxInputElement implements InputElementBase { factory CheckboxInputElement() { throw new UnsupportedError("new CheckboxInputElement() is unsupported on this platform."); }   bool checked  bool required} abstract class RadioButtonInputElement implements InputElementBase { factory RadioButtonInputElement() { throw new UnsupportedError("new RadioButtonInputElement() is unsupported on this platform."); }   bool checked  bool required} abstract class FileUploadInputElement implements InputElementBase { factory FileUploadInputElement() { throw new UnsupportedError("new FileUploadInputElement() is unsupported on this platform."); }   String accept  bool multiple  bool required  List<File> files} abstract class SubmitButtonInputElement implements InputElementBase { factory SubmitButtonInputElement() { throw new UnsupportedError("new SubmitButtonInputElement() is unsupported on this platform."); }   String formAction  String formEnctype  String formMethod  bool formNoValidate  String formTarget} abstract class ImageButtonInputElement implements InputElementBase { factory ImageButtonInputElement() { throw new UnsupportedError("new ImageButtonInputElement() is unsupported on this platform."); }   String alt  String formAction  String formEnctype  String formMethod  bool formNoValidate  String formTarget  int height  String src  int width} abstract class ResetButtonInputElement implements InputElementBase { factory ResetButtonInputElement() { throw new UnsupportedError("new ResetButtonInputElement() is unsupported on this platform."); } } abstract class ButtonInputElement implements InputElementBase { factory ButtonInputElement() { throw new UnsupportedError("new ButtonInputElement() is unsupported on this platform."); } } @DocsEditable() @DomName('InputMethodContext') @Experimental() class InputMethodContext extends EventTarget { factory InputMethodContext._() { throw new UnsupportedError("new InputMethodContext._() is unsupported on this platform."); }   @DomName('InputMethodContext.compositionEndOffset') @DocsEditable() @Experimental() int get compositionEndOffset {}   @DomName('InputMethodContext.compositionStartOffset') @DocsEditable() @Experimental() int get compositionStartOffset {}   @DomName('InputMethodContext.locale') @DocsEditable() String get locale {}   @DomName('InputMethodContext.target') @DocsEditable() @Experimental() HtmlElement get target {}   @DomName('InputMethodContext.confirmComposition') @DocsEditable() void confirmComposition() {} } @DocsEditable() @DomName('InstallEvent') @Experimental() class InstallEvent extends InstallPhaseEvent { factory InstallEvent._() { throw new UnsupportedError("new InstallEvent._() is unsupported on this platform."); }   @DomName('InstallEvent.reloadAll') @DocsEditable() @Experimental() Future reloadAll() {}   @DomName('InstallEvent.replace') @DocsEditable() @Experimental() void replace() {} } @DocsEditable() @DomName('InstallPhaseEvent') @Experimental() class InstallPhaseEvent extends Event { factory InstallPhaseEvent._() { throw new UnsupportedError("new InstallPhaseEvent._() is unsupported on this platform."); }   @DomName('InstallPhaseEvent.waitUntil') @DocsEditable() @Experimental() void waitUntil(Object value) {} } @DomName('KeyboardEvent') class KeyboardEvent extends UIEvent { factory KeyboardEvent(String type, {Window view, bool canBubble : true, bool cancelable : true, int keyLocation : 1, bool ctrlKey : false, bool altKey : false, bool shiftKey : false, bool metaKey : false}) { throw new UnsupportedError("new KeyboardEvent() is unsupported on this platform."); }   @DomName('KeyboardEvent.keyCode') int get keyCode {}   @DomName('KeyboardEvent.charCode') int get charCode {}   factory KeyboardEvent._() { throw new UnsupportedError("new KeyboardEvent._() is unsupported on this platform."); }   static const DOM_KEY_LOCATION_LEFT = 0x01;   static const DOM_KEY_LOCATION_NUMPAD = 0x03;   static const DOM_KEY_LOCATION_RIGHT = 0x02;   static const DOM_KEY_LOCATION_STANDARD = 0x00;   @DomName('KeyboardEvent.altKey') @DocsEditable() bool get altKey {}   @DomName('KeyboardEvent.ctrlKey') @DocsEditable() bool get ctrlKey {}    @DomName('KeyboardEvent.keyLocation') @DocsEditable() @Experimental() int get keyLocation {}   @DomName('KeyboardEvent.location') @DocsEditable() @Experimental() int get location {}   @DomName('KeyboardEvent.metaKey') @DocsEditable() bool get metaKey {}   @DomName('KeyboardEvent.repeat') @DocsEditable() @Experimental() bool get repeat {}   @DomName('KeyboardEvent.shiftKey') @DocsEditable() bool get shiftKey {}   @DomName('KeyboardEvent.getModifierState') @DocsEditable() @Experimental() bool getModifierState(String keyArgument) {}  } @DocsEditable() @DomName('HTMLKeygenElement') @SupportedBrowser(SupportedBrowser.CHROME) @SupportedBrowser(SupportedBrowser.SAFARI) @Experimental() class KeygenElement extends HtmlElement { factory KeygenElement._() { throw new UnsupportedError("new KeygenElement._() is unsupported on this platform."); }   @DomName('HTMLKeygenElement.HTMLKeygenElement') @DocsEditable() factory KeygenElement() { throw new UnsupportedError("new KeygenElement() is unsupported on this platform."); }   KeygenElement.created() : super.created() { throw new UnsupportedError("new KeygenElement.created() is unsupported on this platform."); }   static bool get supported { throw new UnsupportedError("KeygenElement.supported is unsupported on this platform."); }   @DomName('HTMLKeygenElement.autofocus') @DocsEditable() bool get autofocus {}   @DomName('HTMLKeygenElement.autofocus') @DocsEditable() void set autofocus(bool value) {}   @DomName('HTMLKeygenElement.challenge') @DocsEditable() String get challenge {}   @DomName('HTMLKeygenElement.challenge') @DocsEditable() void set challenge(String value) {}   @DomName('HTMLKeygenElement.disabled') @DocsEditable() bool get disabled {}   @DomName('HTMLKeygenElement.disabled') @DocsEditable() void set disabled(bool value) {}   @DomName('HTMLKeygenElement.form') @DocsEditable() FormElement get form {}   @DomName('HTMLKeygenElement.keytype') @DocsEditable() String get keytype {}   @DomName('HTMLKeygenElement.keytype') @DocsEditable() void set keytype(String value) {}   @DomName('HTMLKeygenElement.labels') @DocsEditable() @Unstable() List<Node> get labels {}   @DomName('HTMLKeygenElement.name') @DocsEditable() String get name {}   @DomName('HTMLKeygenElement.name') @DocsEditable() void set name(String value) {}   @DomName('HTMLKeygenElement.type') @DocsEditable() String get type {}   @DomName('HTMLKeygenElement.validationMessage') @DocsEditable() String get validationMessage {}   @DomName('HTMLKeygenElement.validity') @DocsEditable() ValidityState get validity {}   @DomName('HTMLKeygenElement.willValidate') @DocsEditable() bool get willValidate {}   @DomName('HTMLKeygenElement.checkValidity') @DocsEditable() bool checkValidity() {}   @DomName('HTMLKeygenElement.setCustomValidity') @DocsEditable() void setCustomValidity(String error) {} } @DocsEditable() @DomName('HTMLLIElement') class LIElement extends HtmlElement { factory LIElement._() { throw new UnsupportedError("new LIElement._() is unsupported on this platform."); }   @DomName('HTMLLIElement.HTMLLIElement') @DocsEditable() factory LIElement() { throw new UnsupportedError("new LIElement() is unsupported on this platform."); }   LIElement.created() : super.created() { throw new UnsupportedError("new LIElement.created() is unsupported on this platform."); }   @DomName('HTMLLIElement.value') @DocsEditable() int get value {}   @DomName('HTMLLIElement.value') @DocsEditable() void set value(int value) {} } @DocsEditable() @DomName('HTMLLabelElement') class LabelElement extends HtmlElement { factory LabelElement._() { throw new UnsupportedError("new LabelElement._() is unsupported on this platform."); }   @DomName('HTMLLabelElement.HTMLLabelElement') @DocsEditable() factory LabelElement() { throw new UnsupportedError("new LabelElement() is unsupported on this platform."); }   LabelElement.created() : super.created() { throw new UnsupportedError("new LabelElement.created() is unsupported on this platform."); }   @DomName('HTMLLabelElement.control') @DocsEditable() HtmlElement get control {}   @DomName('HTMLLabelElement.form') @DocsEditable() FormElement get form {}   @DomName('HTMLLabelElement.htmlFor') @DocsEditable() String get htmlFor {}   @DomName('HTMLLabelElement.htmlFor') @DocsEditable() void set htmlFor(String value) {} } @DocsEditable() @DomName('HTMLLegendElement') class LegendElement extends HtmlElement { factory LegendElement._() { throw new UnsupportedError("new LegendElement._() is unsupported on this platform."); }   @DomName('HTMLLegendElement.HTMLLegendElement') @DocsEditable() factory LegendElement() { throw new UnsupportedError("new LegendElement() is unsupported on this platform."); }   LegendElement.created() : super.created() { throw new UnsupportedError("new LegendElement.created() is unsupported on this platform."); }   @DomName('HTMLLegendElement.form') @DocsEditable() FormElement get form {} } @DocsEditable() @DomName('HTMLLinkElement') class LinkElement extends HtmlElement { factory LinkElement._() { throw new UnsupportedError("new LinkElement._() is unsupported on this platform."); }   @DomName('HTMLLinkElement.HTMLLinkElement') @DocsEditable() factory LinkElement() { throw new UnsupportedError("new LinkElement() is unsupported on this platform."); }   LinkElement.created() : super.created() { throw new UnsupportedError("new LinkElement.created() is unsupported on this platform."); }   @DomName('HTMLLinkElement.crossOrigin') @DocsEditable() @Experimental() String get crossOrigin {}   @DomName('HTMLLinkElement.crossOrigin') @DocsEditable() @Experimental() void set crossOrigin(String value) {}   @DomName('HTMLLinkElement.disabled') @DocsEditable() bool get disabled {}   @DomName('HTMLLinkElement.disabled') @DocsEditable() void set disabled(bool value) {}   @DomName('HTMLLinkElement.href') @DocsEditable() String get href {}   @DomName('HTMLLinkElement.href') @DocsEditable() void set href(String value) {}   @DomName('HTMLLinkElement.hreflang') @DocsEditable() String get hreflang {}   @DomName('HTMLLinkElement.hreflang') @DocsEditable() void set hreflang(String value) {}   @DomName('HTMLLinkElement.import') @DocsEditable() @Experimental() Document get import {}   @DomName('HTMLLinkElement.integrity') @DocsEditable() @Experimental() String get integrity {}   @DomName('HTMLLinkElement.integrity') @DocsEditable() @Experimental() void set integrity(String value) {}   @DomName('HTMLLinkElement.media') @DocsEditable() String get media {}   @DomName('HTMLLinkElement.media') @DocsEditable() void set media(String value) {}   @DomName('HTMLLinkElement.rel') @DocsEditable() String get rel {}   @DomName('HTMLLinkElement.rel') @DocsEditable() void set rel(String value) {}   @DomName('HTMLLinkElement.sheet') @DocsEditable() StyleSheet get sheet {}   @DomName('HTMLLinkElement.sizes') @DocsEditable() DomSettableTokenList get sizes {}   @DomName('HTMLLinkElement.type') @DocsEditable() String get type {}   @DomName('HTMLLinkElement.type') @DocsEditable() void set type(String value) {}   bool get supportsImport {} } @DocsEditable() @DomName('LocalCredential') @Experimental() class LocalCredential extends Credential { factory LocalCredential._() { throw new UnsupportedError("new LocalCredential._() is unsupported on this platform."); }   @DomName('LocalCredential.LocalCredential') @DocsEditable() factory LocalCredential(String id, String name, String avatarURL, String password) { throw new UnsupportedError("new LocalCredential() is unsupported on this platform."); }   @DomName('LocalCredential.password') @DocsEditable() @Experimental() String get password {} } @DocsEditable() @DomName('Location') class Location extends NativeFieldWrapperClass2 implements LocationBase { factory Location._() { throw new UnsupportedError("new Location._() is unsupported on this platform."); }   @DomName('Location.ancestorOrigins') @DocsEditable() @Experimental() List<String> get ancestorOrigins {}   @DomName('Location.hash') @DocsEditable() String get hash {}   @DomName('Location.hash') @DocsEditable() void set hash(String value) {}   @DomName('Location.host') @DocsEditable() String get host {}   @DomName('Location.host') @DocsEditable() void set host(String value) {}   @DomName('Location.hostname') @DocsEditable() String get hostname {}   @DomName('Location.hostname') @DocsEditable() void set hostname(String value) {}   @DomName('Location.href') @DocsEditable() String get href {}   @DomName('Location.href') @DocsEditable() void set href(String value) {}   @DomName('Location.origin') @DocsEditable() @Experimental() String get origin {}   @DomName('Location.pathname') @DocsEditable() String get pathname {}   @DomName('Location.pathname') @DocsEditable() void set pathname(String value) {}   @DomName('Location.port') @DocsEditable() String get port {}   @DomName('Location.port') @DocsEditable() void set port(String value) {}   @DomName('Location.protocol') @DocsEditable() String get protocol {}   @DomName('Location.protocol') @DocsEditable() void set protocol(String value) {}   @DomName('Location.search') @DocsEditable() String get search {}   @DomName('Location.search') @DocsEditable() void set search(String value) {}   @DomName('Location.assign') @DocsEditable() void assign([String url]) {}   @DomName('Location.reload') @DocsEditable() void reload() {}   @DomName('Location.replace') @DocsEditable() void replace(String url) {}   @DomName('Location.toString') @DocsEditable() String toString() {} } @DomName('MIDIErrorCallback') @Experimental() typedef void MidiErrorCallback(DomError error); @DomName('MIDISuccessCallback') @Experimental() typedef void MidiSuccessCallback(MidiAccess access, bool sysex); @DocsEditable() @DomName('HTMLMapElement') class MapElement extends HtmlElement { factory MapElement._() { throw new UnsupportedError("new MapElement._() is unsupported on this platform."); }   @DomName('HTMLMapElement.HTMLMapElement') @DocsEditable() factory MapElement() { throw new UnsupportedError("new MapElement() is unsupported on this platform."); }   MapElement.created() : super.created() { throw new UnsupportedError("new MapElement.created() is unsupported on this platform."); }   @DomName('HTMLMapElement.areas') @DocsEditable() List<Node> get areas {}   @DomName('HTMLMapElement.name') @DocsEditable() String get name {}   @DomName('HTMLMapElement.name') @DocsEditable() void set name(String value) {} } @DocsEditable() @DomName('MediaController') @Experimental() class MediaController extends EventTarget { factory MediaController._() { throw new UnsupportedError("new MediaController._() is unsupported on this platform."); }   @DomName('MediaController.MediaController') @DocsEditable() factory MediaController() { throw new UnsupportedError("new MediaController() is unsupported on this platform."); }   @DomName('MediaController.buffered') @DocsEditable() TimeRanges get buffered {}   @DomName('MediaController.currentTime') @DocsEditable() num get currentTime {}   @DomName('MediaController.currentTime') @DocsEditable() void set currentTime(num value) {}   @DomName('MediaController.defaultPlaybackRate') @DocsEditable() num get defaultPlaybackRate {}   @DomName('MediaController.defaultPlaybackRate') @DocsEditable() void set defaultPlaybackRate(num value) {}   @DomName('MediaController.duration') @DocsEditable() double get duration {}   @DomName('MediaController.muted') @DocsEditable() bool get muted {}   @DomName('MediaController.muted') @DocsEditable() void set muted(bool value) {}   @DomName('MediaController.paused') @DocsEditable() bool get paused {}   @DomName('MediaController.playbackRate') @DocsEditable() num get playbackRate {}   @DomName('MediaController.playbackRate') @DocsEditable() void set playbackRate(num value) {}   @DomName('MediaController.playbackState') @DocsEditable() String get playbackState {}   @DomName('MediaController.played') @DocsEditable() TimeRanges get played {}   @DomName('MediaController.seekable') @DocsEditable() TimeRanges get seekable {}   @DomName('MediaController.volume') @DocsEditable() num get volume {}   @DomName('MediaController.volume') @DocsEditable() void set volume(num value) {}   @DomName('MediaController.pause') @DocsEditable() void pause() {}   @DomName('MediaController.play') @DocsEditable() void play() {}   @DomName('MediaController.unpause') @DocsEditable() void unpause() {} } @DocsEditable() @DomName('MediaDeviceInfo') @Experimental() class MediaDeviceInfo extends NativeFieldWrapperClass2 { factory MediaDeviceInfo._() { throw new UnsupportedError("new MediaDeviceInfo._() is unsupported on this platform."); }   @DomName('MediaDeviceInfo.deviceId') @DocsEditable() @Experimental() String get deviceId {}   @DomName('MediaDeviceInfo.groupId') @DocsEditable() @Experimental() String get groupId {}   @DomName('MediaDeviceInfo.kind') @DocsEditable() @Experimental() String get kind {}   @DomName('MediaDeviceInfo.label') @DocsEditable() @Experimental() String get label {} } @DomName('MediaDeviceInfoCallback') @Experimental() typedef void MediaDeviceInfoCallback(List<MediaDeviceInfo> devices); @DocsEditable() @DomName('HTMLMediaElement') @Unstable() class MediaElement extends HtmlElement { factory MediaElement._() { throw new UnsupportedError("new MediaElement._() is unsupported on this platform."); }   static const keyAddedEvent = const EventStreamProvider<MediaKeyEvent>('webkitkeyadded');   static const keyErrorEvent = const EventStreamProvider<MediaKeyEvent>('webkitkeyerror');   static const keyMessageEvent = const EventStreamProvider<MediaKeyEvent>('webkitkeymessage');   static const needKeyEvent = const EventStreamProvider<MediaKeyEvent>('webkitneedkey');   MediaElement.created() : super.created() { throw new UnsupportedError("new MediaElement.created() is unsupported on this platform."); }   static const HAVE_CURRENT_DATA = 2;   static const HAVE_ENOUGH_DATA = 4;   static const HAVE_FUTURE_DATA = 3;   static const HAVE_METADATA = 1;   static const HAVE_NOTHING = 0;   static const NETWORK_EMPTY = 0;   static const NETWORK_IDLE = 1;   static const NETWORK_LOADING = 2;   static const NETWORK_NO_SOURCE = 3;   @DomName('HTMLMediaElement.audioTracks') @DocsEditable() @Experimental() AudioTrackList get audioTracks {}   @DomName('HTMLMediaElement.autoplay') @DocsEditable() bool get autoplay {}   @DomName('HTMLMediaElement.autoplay') @DocsEditable() void set autoplay(bool value) {}   @DomName('HTMLMediaElement.buffered') @DocsEditable() TimeRanges get buffered {}   @DomName('HTMLMediaElement.controller') @DocsEditable() MediaController get controller {}   @DomName('HTMLMediaElement.controller') @DocsEditable() void set controller(MediaController value) {}   @DomName('HTMLMediaElement.controls') @DocsEditable() bool get controls {}   @DomName('HTMLMediaElement.controls') @DocsEditable() void set controls(bool value) {}   @DomName('HTMLMediaElement.crossOrigin') @DocsEditable() @Experimental() String get crossOrigin {}   @DomName('HTMLMediaElement.crossOrigin') @DocsEditable() @Experimental() void set crossOrigin(String value) {}   @DomName('HTMLMediaElement.currentSrc') @DocsEditable() String get currentSrc {}   @DomName('HTMLMediaElement.currentTime') @DocsEditable() num get currentTime {}   @DomName('HTMLMediaElement.currentTime') @DocsEditable() void set currentTime(num value) {}   @DomName('HTMLMediaElement.defaultMuted') @DocsEditable() bool get defaultMuted {}   @DomName('HTMLMediaElement.defaultMuted') @DocsEditable() void set defaultMuted(bool value) {}   @DomName('HTMLMediaElement.defaultPlaybackRate') @DocsEditable() num get defaultPlaybackRate {}   @DomName('HTMLMediaElement.defaultPlaybackRate') @DocsEditable() void set defaultPlaybackRate(num value) {}   @DomName('HTMLMediaElement.duration') @DocsEditable() double get duration {}   @DomName('HTMLMediaElement.ended') @DocsEditable() bool get ended {}   @DomName('HTMLMediaElement.error') @DocsEditable() MediaError get error {}   @DomName('HTMLMediaElement.integrity') @DocsEditable() @Experimental() String get integrity {}   @DomName('HTMLMediaElement.integrity') @DocsEditable() @Experimental() void set integrity(String value) {}   @DomName('HTMLMediaElement.loop') @DocsEditable() bool get loop {}   @DomName('HTMLMediaElement.loop') @DocsEditable() void set loop(bool value) {}   @DomName('HTMLMediaElement.mediaGroup') @DocsEditable() String get mediaGroup {}   @DomName('HTMLMediaElement.mediaGroup') @DocsEditable() void set mediaGroup(String value) {}   @DomName('HTMLMediaElement.mediaKeys') @DocsEditable() @Experimental() MediaKeys get mediaKeys {}   @DomName('HTMLMediaElement.muted') @DocsEditable() bool get muted {}   @DomName('HTMLMediaElement.muted') @DocsEditable() void set muted(bool value) {}   @DomName('HTMLMediaElement.networkState') @DocsEditable() int get networkState {}   @DomName('HTMLMediaElement.paused') @DocsEditable() bool get paused {}   @DomName('HTMLMediaElement.playbackRate') @DocsEditable() num get playbackRate {}   @DomName('HTMLMediaElement.playbackRate') @DocsEditable() void set playbackRate(num value) {}   @DomName('HTMLMediaElement.played') @DocsEditable() TimeRanges get played {}   @DomName('HTMLMediaElement.preload') @DocsEditable() String get preload {}   @DomName('HTMLMediaElement.preload') @DocsEditable() void set preload(String value) {}   @DomName('HTMLMediaElement.readyState') @DocsEditable() int get readyState {}   @DomName('HTMLMediaElement.seekable') @DocsEditable() TimeRanges get seekable {}   @DomName('HTMLMediaElement.seeking') @DocsEditable() bool get seeking {}   @DomName('HTMLMediaElement.src') @DocsEditable() String get src {}   @DomName('HTMLMediaElement.src') @DocsEditable() void set src(String value) {}   @DomName('HTMLMediaElement.textTracks') @DocsEditable() @Experimental() TextTrackList get textTracks {}   @DomName('HTMLMediaElement.videoTracks') @DocsEditable() @Experimental() VideoTrackList get videoTracks {}   @DomName('HTMLMediaElement.volume') @DocsEditable() num get volume {}   @DomName('HTMLMediaElement.volume') @DocsEditable() void set volume(num value) {}   @DomName('HTMLMediaElement.webkitAudioDecodedByteCount') @DocsEditable() @SupportedBrowser(SupportedBrowser.CHROME) @SupportedBrowser(SupportedBrowser.SAFARI) @Experimental() @Experimental() int get audioDecodedByteCount {}   @DomName('HTMLMediaElement.webkitVideoDecodedByteCount') @DocsEditable() @SupportedBrowser(SupportedBrowser.CHROME) @SupportedBrowser(SupportedBrowser.SAFARI) @Experimental() @Experimental() int get videoDecodedByteCount {}   TextTrack addTextTrack(String kind, [String label, String language]) {}   String canPlayType(String type, [String keySystem]) {}   @DomName('HTMLMediaElement.load') @DocsEditable() void load() {}   @DomName('HTMLMediaElement.pause') @DocsEditable() void pause() {}   @DomName('HTMLMediaElement.play') @DocsEditable() void play() {}   @DomName('HTMLMediaElement.setMediaKeys') @DocsEditable() @Experimental() void setMediaKeys(MediaKeys mediaKeys) {}   void addKey(String keySystem, Uint8List key, [Uint8List initData, String sessionId]) {}   @DomName('HTMLMediaElement.webkitCancelKeyRequest') @DocsEditable() @SupportedBrowser(SupportedBrowser.CHROME) @SupportedBrowser(SupportedBrowser.SAFARI) @Experimental() void cancelKeyRequest(String keySystem, String sessionId) {}   void generateKeyRequest(String keySystem, [Uint8List initData]) {}   @DomName('HTMLMediaElement.onwebkitkeyadded') @DocsEditable() @Experimental() ElementStream<MediaKeyEvent> get onKeyAdded {}   @DomName('HTMLMediaElement.onwebkitkeyerror') @DocsEditable() @Experimental() ElementStream<MediaKeyEvent> get onKeyError {}   @DomName('HTMLMediaElement.onwebkitkeymessage') @DocsEditable() @Experimental() ElementStream<MediaKeyEvent> get onKeyMessage {}   @DomName('HTMLMediaElement.onwebkitneedkey') @DocsEditable() @Experimental() ElementStream<MediaKeyEvent> get onNeedKey {} } @DocsEditable() @DomName('MediaError') @Unstable() class MediaError extends NativeFieldWrapperClass2 { factory MediaError._() { throw new UnsupportedError("new MediaError._() is unsupported on this platform."); }   static const MEDIA_ERR_ABORTED = 1;   static const MEDIA_ERR_DECODE = 3;   static const MEDIA_ERR_ENCRYPTED = 5;   static const MEDIA_ERR_NETWORK = 2;   static const MEDIA_ERR_SRC_NOT_SUPPORTED = 4;   @DomName('MediaError.code') @DocsEditable() int get code {} } @DocsEditable() @DomName('MediaKeyError') @Experimental() class MediaKeyError extends NativeFieldWrapperClass2 { factory MediaKeyError._() { throw new UnsupportedError("new MediaKeyError._() is unsupported on this platform."); }   static const MEDIA_KEYERR_CLIENT = 2;   static const MEDIA_KEYERR_DOMAIN = 6;   static const MEDIA_KEYERR_HARDWARECHANGE = 5;   static const MEDIA_KEYERR_OUTPUT = 4;   static const MEDIA_KEYERR_SERVICE = 3;   static const MEDIA_KEYERR_UNKNOWN = 1;   @DomName('MediaKeyError.code') @DocsEditable() int get code {}   @DomName('MediaKeyError.systemCode') @DocsEditable() @Experimental() int get systemCode {} } @DocsEditable() @DomName('MediaKeyEvent') @Experimental() class MediaKeyEvent extends Event { factory MediaKeyEvent._() { throw new UnsupportedError("new MediaKeyEvent._() is unsupported on this platform."); }   @DomName('MediaKeyEvent.defaultURL') @DocsEditable() String get defaultUrl {}   @DomName('MediaKeyEvent.errorCode') @DocsEditable() MediaKeyError get errorCode {}   @DomName('MediaKeyEvent.initData') @DocsEditable() Uint8List get initData {}   @DomName('MediaKeyEvent.keySystem') @DocsEditable() String get keySystem {}   @DomName('MediaKeyEvent.message') @DocsEditable() Uint8List get message {}   @DomName('MediaKeyEvent.sessionId') @DocsEditable() String get sessionId {}   @DomName('MediaKeyEvent.systemCode') @DocsEditable() int get systemCode {} } @DocsEditable() @DomName('MediaKeyMessageEvent') @Experimental() class MediaKeyMessageEvent extends Event { factory MediaKeyMessageEvent._() { throw new UnsupportedError("new MediaKeyMessageEvent._() is unsupported on this platform."); }   @DomName('MediaKeyMessageEvent.destinationURL') @DocsEditable() String get destinationUrl {}   @DomName('MediaKeyMessageEvent.message') @DocsEditable() ByteBuffer get message {} } @DocsEditable() @DomName('MediaKeyNeededEvent') @Experimental() class MediaKeyNeededEvent extends Event { factory MediaKeyNeededEvent._() { throw new UnsupportedError("new MediaKeyNeededEvent._() is unsupported on this platform."); }   @DomName('MediaKeyNeededEvent.contentType') @DocsEditable() @Experimental() String get contentType {}   @DomName('MediaKeyNeededEvent.initData') @DocsEditable() Uint8List get initData {} } @DocsEditable() @DomName('MediaKeySession') @Experimental() class MediaKeySession extends EventTarget { factory MediaKeySession._() { throw new UnsupportedError("new MediaKeySession._() is unsupported on this platform."); }   @DomName('MediaKeySession.closed') @DocsEditable() @Experimental() Future get closed {}   @DomName('MediaKeySession.error') @DocsEditable() MediaKeyError get error {}   @DomName('MediaKeySession.keySystem') @DocsEditable() String get keySystem {}   @DomName('MediaKeySession.sessionId') @DocsEditable() String get sessionId {}   @DomName('MediaKeySession.release') @DocsEditable() @Experimental() Future release() {}  } @DocsEditable() @DomName('MediaKeys') @Experimental() class MediaKeys extends NativeFieldWrapperClass2 { factory MediaKeys._() { throw new UnsupportedError("new MediaKeys._() is unsupported on this platform."); }   @DomName('MediaKeys.keySystem') @DocsEditable() String get keySystem {}   @DomName('MediaKeys.create') @DocsEditable() @Experimental() static Future create(String keySystem) { throw new UnsupportedError("MediaKeys.create() is unsupported on this platform."); }    @DomName('MediaKeys.isTypeSupported') @DocsEditable() @Experimental() static bool isTypeSupported(String keySystem, String contentType) { throw new UnsupportedError("MediaKeys.isTypeSupported() is unsupported on this platform."); } } @DocsEditable() @DomName('MediaList') @Unstable() class MediaList extends NativeFieldWrapperClass2 { factory MediaList._() { throw new UnsupportedError("new MediaList._() is unsupported on this platform."); }   @DomName('MediaList.length') @DocsEditable() int get length {}   @DomName('MediaList.mediaText') @DocsEditable() String get mediaText {}   @DomName('MediaList.mediaText') @DocsEditable() void set mediaText(String value) {}   @DomName('MediaList.appendMedium') @DocsEditable() void appendMedium(String newMedium) {}   @DomName('MediaList.deleteMedium') @DocsEditable() void deleteMedium(String oldMedium) {}   @DomName('MediaList.item') @DocsEditable() String item(int index) {} } @DocsEditable() @DomName('MediaQueryList') @Unstable() class MediaQueryList extends NativeFieldWrapperClass2 { factory MediaQueryList._() { throw new UnsupportedError("new MediaQueryList._() is unsupported on this platform."); }   @DomName('MediaQueryList.matches') @DocsEditable() bool get matches {}   @DomName('MediaQueryList.media') @DocsEditable() String get media {} } @DocsEditable() @DomName('MediaSource') @Experimental() class MediaSource extends EventTarget { factory MediaSource._() { throw new UnsupportedError("new MediaSource._() is unsupported on this platform."); }   @DomName('MediaSource.MediaSource') @DocsEditable() factory MediaSource() { throw new UnsupportedError("new MediaSource() is unsupported on this platform."); }   @DomName('MediaSource.activeSourceBuffers') @DocsEditable() SourceBufferList get activeSourceBuffers {}   @DomName('MediaSource.duration') @DocsEditable() num get duration {}   @DomName('MediaSource.duration') @DocsEditable() void set duration(num value) {}   @DomName('MediaSource.readyState') @DocsEditable() String get readyState {}   @DomName('MediaSource.sourceBuffers') @DocsEditable() SourceBufferList get sourceBuffers {}   @DomName('MediaSource.addSourceBuffer') @DocsEditable() SourceBuffer addSourceBuffer(String type) {}   void endOfStream([String error]) {}   @DomName('MediaSource.isTypeSupported') @DocsEditable() static bool isTypeSupported(String type) { throw new UnsupportedError("MediaSource.isTypeSupported() is unsupported on this platform."); }   @DomName('MediaSource.removeSourceBuffer') @DocsEditable() void removeSourceBuffer(SourceBuffer buffer) {} } @DomName('MediaStream') @SupportedBrowser(SupportedBrowser.CHROME) @Experimental() class MediaStream extends EventTarget { factory MediaStream._() { throw new UnsupportedError("new MediaStream._() is unsupported on this platform."); }   static const addTrackEvent = const EventStreamProvider<Event>('addtrack');   static const endedEvent = const EventStreamProvider<Event>('ended');   static const removeTrackEvent = const EventStreamProvider<Event>('removetrack');   @DomName('MediaStream.MediaStream') @DocsEditable() factory MediaStream([stream_OR_tracks]) { throw new UnsupportedError("new MediaStream() is unsupported on this platform."); }   @DomName('MediaStream.ended') @DocsEditable() bool get ended {}   @DomName('MediaStream.id') @DocsEditable() String get id {}   @DomName('MediaStream.label') @DocsEditable() @Experimental() String get label {}   @DomName('MediaStream.addTrack') @DocsEditable() void addTrack(MediaStreamTrack track) {}   @DomName('MediaStream.clone') @DocsEditable() @Experimental() MediaStream clone() {}   @DomName('MediaStream.getAudioTracks') @DocsEditable() List<MediaStreamTrack> getAudioTracks() {}   @DomName('MediaStream.getTrackById') @DocsEditable() MediaStreamTrack getTrackById(String trackId) {}   @DomName('MediaStream.getTracks') @DocsEditable() @Experimental() List<MediaStreamTrack> getTracks() {}   @DomName('MediaStream.getVideoTracks') @DocsEditable() List<MediaStreamTrack> getVideoTracks() {}   @DomName('MediaStream.removeTrack') @DocsEditable() void removeTrack(MediaStreamTrack track) {}   @DomName('MediaStream.stop') @DocsEditable() void stop() {}   @DomName('MediaStream.onaddtrack') @DocsEditable() Stream<Event> get onAddTrack {}   @DomName('MediaStream.onended') @DocsEditable() Stream<Event> get onEnded {}   @DomName('MediaStream.onremovetrack') @DocsEditable() Stream<Event> get onRemoveTrack {}   static bool get supported { throw new UnsupportedError("MediaStream.supported is unsupported on this platform."); } } @DocsEditable() @DomName('MediaStreamEvent') @SupportedBrowser(SupportedBrowser.CHROME) @Experimental() class MediaStreamEvent extends Event { factory MediaStreamEvent._() { throw new UnsupportedError("new MediaStreamEvent._() is unsupported on this platform."); }   static bool get supported { throw new UnsupportedError("MediaStreamEvent.supported is unsupported on this platform."); }   @DomName('MediaStreamEvent.stream') @DocsEditable() MediaStream get stream {} } @DocsEditable() @DomName('MediaStreamTrack') @SupportedBrowser(SupportedBrowser.CHROME) @Experimental() class MediaStreamTrack extends EventTarget { factory MediaStreamTrack._() { throw new UnsupportedError("new MediaStreamTrack._() is unsupported on this platform."); }   static const endedEvent = const EventStreamProvider<Event>('ended');   static const muteEvent = const EventStreamProvider<Event>('mute');   static const unmuteEvent = const EventStreamProvider<Event>('unmute');   @DomName('MediaStreamTrack.enabled') @DocsEditable() bool get enabled {}   @DomName('MediaStreamTrack.enabled') @DocsEditable() void set enabled(bool value) {}   @DomName('MediaStreamTrack.id') @DocsEditable() String get id {}   @DomName('MediaStreamTrack.kind') @DocsEditable() String get kind {}   @DomName('MediaStreamTrack.label') @DocsEditable() String get label {}   @DomName('MediaStreamTrack.muted') @DocsEditable() @Experimental() bool get muted {}   @DomName('MediaStreamTrack.readyState') @DocsEditable() String get readyState {}   @DomName('MediaStreamTrack.clone') @DocsEditable() @Experimental() MediaStreamTrack clone() {}   @DomName('MediaStreamTrack.getSources') @DocsEditable() @Experimental() static void _getSources(MediaStreamTrackSourcesCallback callback) { throw new UnsupportedError("MediaStreamTrack._getSources() is unsupported on this platform."); }   static Future<List<SourceInfo>> getSources() { throw new UnsupportedError("MediaStreamTrack.getSources() is unsupported on this platform."); }   @DomName('MediaStreamTrack.stop') @DocsEditable() @Experimental() void stop() {}   @DomName('MediaStreamTrack.onended') @DocsEditable() Stream<Event> get onEnded {}   @DomName('MediaStreamTrack.onmute') @DocsEditable() Stream<Event> get onMute {}   @DomName('MediaStreamTrack.onunmute') @DocsEditable() Stream<Event> get onUnmute {} } @DocsEditable() @DomName('MediaStreamTrackEvent') @SupportedBrowser(SupportedBrowser.CHROME) @Experimental() class MediaStreamTrackEvent extends Event { factory MediaStreamTrackEvent._() { throw new UnsupportedError("new MediaStreamTrackEvent._() is unsupported on this platform."); }   static bool get supported { throw new UnsupportedError("MediaStreamTrackEvent.supported is unsupported on this platform."); }   @DomName('MediaStreamTrackEvent.track') @DocsEditable() MediaStreamTrack get track {} } @DomName('MediaStreamTrackSourcesCallback') @Experimental() typedef void MediaStreamTrackSourcesCallback(List<SourceInfo> sources); @DocsEditable() @DomName('MemoryInfo') @Experimental() class MemoryInfo extends NativeFieldWrapperClass2 { factory MemoryInfo._() { throw new UnsupportedError("new MemoryInfo._() is unsupported on this platform."); }   @DomName('MemoryInfo.jsHeapSizeLimit') @DocsEditable() int get jsHeapSizeLimit {}   @DomName('MemoryInfo.totalJSHeapSize') @DocsEditable() int get totalJSHeapSize {}   @DomName('MemoryInfo.usedJSHeapSize') @DocsEditable() int get usedJSHeapSize {} } @DocsEditable() @DomName('HTMLMenuElement') class MenuElement extends HtmlElement { factory MenuElement._() { throw new UnsupportedError("new MenuElement._() is unsupported on this platform."); }   @DomName('HTMLMenuElement.HTMLMenuElement') @DocsEditable() factory MenuElement() { throw new UnsupportedError("new MenuElement() is unsupported on this platform."); }   MenuElement.created() : super.created() { throw new UnsupportedError("new MenuElement.created() is unsupported on this platform."); }   @DomName('HTMLMenuElement.label') @DocsEditable() @Experimental() String get label {}   @DomName('HTMLMenuElement.label') @DocsEditable() @Experimental() void set label(String value) {}   @DomName('HTMLMenuElement.type') @DocsEditable() @Experimental() String get type {}   @DomName('HTMLMenuElement.type') @DocsEditable() @Experimental() void set type(String value) {} } @DocsEditable() @DomName('HTMLMenuItemElement') @Experimental() class MenuItemElement extends HtmlElement { factory MenuItemElement._() { throw new UnsupportedError("new MenuItemElement._() is unsupported on this platform."); }   MenuItemElement.created() : super.created() { throw new UnsupportedError("new MenuItemElement.created() is unsupported on this platform."); }   @DomName('HTMLMenuItemElement.checked') @DocsEditable() @Experimental() bool get checked {}   @DomName('HTMLMenuItemElement.checked') @DocsEditable() @Experimental() void set checked(bool value) {}   @DomName('HTMLMenuItemElement.default') @DocsEditable() @Experimental() bool get defaultValue {}   @DomName('HTMLMenuItemElement.default') @DocsEditable() @Experimental() void set defaultValue(bool value) {}   @DomName('HTMLMenuItemElement.disabled') @DocsEditable() @Experimental() bool get disabled {}   @DomName('HTMLMenuItemElement.disabled') @DocsEditable() @Experimental() void set disabled(bool value) {}   @DomName('HTMLMenuItemElement.label') @DocsEditable() @Experimental() String get label {}   @DomName('HTMLMenuItemElement.label') @DocsEditable() @Experimental() void set label(String value) {}   @DomName('HTMLMenuItemElement.type') @DocsEditable() @Experimental() String get type {}   @DomName('HTMLMenuItemElement.type') @DocsEditable() @Experimental() void set type(String value) {} } @DocsEditable() @DomName('MessageChannel') @Unstable() class MessageChannel extends NativeFieldWrapperClass2 { factory MessageChannel._() { throw new UnsupportedError("new MessageChannel._() is unsupported on this platform."); }   @DomName('MessageChannel.port1') @DocsEditable() MessagePort get port1 {}   @DomName('MessageChannel.port2') @DocsEditable() MessagePort get port2 {} } @DomName('MessageEvent') class MessageEvent extends Event { factory MessageEvent(String type, {bool canBubble : false, bool cancelable : false, Object data, String origin, String lastEventId, Window source, List messagePorts}) { throw new UnsupportedError("new MessageEvent() is unsupported on this platform."); }   factory MessageEvent._() { throw new UnsupportedError("new MessageEvent._() is unsupported on this platform."); }   @DomName('MessageEvent.data') @DocsEditable() Object get data {}   @DomName('MessageEvent.lastEventId') @DocsEditable() @Unstable() String get lastEventId {}   @DomName('MessageEvent.origin') @DocsEditable() String get origin {}   @DomName('MessageEvent.source') @DocsEditable() EventTarget get source {}  } @DocsEditable() @DomName('MessagePort') @Unstable() class MessagePort extends EventTarget { factory MessagePort._() { throw new UnsupportedError("new MessagePort._() is unsupported on this platform."); }   static const messageEvent = const EventStreamProvider<MessageEvent>('message');   @DomName('MessagePort.close') @DocsEditable() void close() {}   @DomName('MessagePort.postMessage') @DocsEditable() void postMessage(Object message, [List<MessagePort> transfer]) {}   @DomName('MessagePort.start') @DocsEditable() void start() {}   @DomName('MessagePort.onmessage') @DocsEditable() Stream<MessageEvent> get onMessage {} } @DocsEditable() @DomName('HTMLMetaElement') class MetaElement extends HtmlElement { factory MetaElement._() { throw new UnsupportedError("new MetaElement._() is unsupported on this platform."); }   @DomName('HTMLMetaElement.HTMLMetaElement') @DocsEditable() factory MetaElement() { throw new UnsupportedError("new MetaElement() is unsupported on this platform."); }   MetaElement.created() : super.created() { throw new UnsupportedError("new MetaElement.created() is unsupported on this platform."); }   @DomName('HTMLMetaElement.content') @DocsEditable() String get content {}   @DomName('HTMLMetaElement.content') @DocsEditable() void set content(String value) {}   @DomName('HTMLMetaElement.httpEquiv') @DocsEditable() String get httpEquiv {}   @DomName('HTMLMetaElement.httpEquiv') @DocsEditable() void set httpEquiv(String value) {}   @DomName('HTMLMetaElement.name') @DocsEditable() String get name {}   @DomName('HTMLMetaElement.name') @DocsEditable() void set name(String value) {} } @DocsEditable() @DomName('Metadata') @Experimental() class Metadata extends NativeFieldWrapperClass2 { factory Metadata._() { throw new UnsupportedError("new Metadata._() is unsupported on this platform."); }   @DomName('Metadata.modificationTime') @DocsEditable() DateTime get modificationTime {}   @DomName('Metadata.size') @DocsEditable() int get size {} } @DomName('MetadataCallback') @Experimental() typedef void MetadataCallback(Metadata metadata); @DocsEditable() @DomName('HTMLMeterElement') @SupportedBrowser(SupportedBrowser.CHROME) @SupportedBrowser(SupportedBrowser.FIREFOX) @SupportedBrowser(SupportedBrowser.SAFARI) @Unstable() class MeterElement extends HtmlElement { factory MeterElement._() { throw new UnsupportedError("new MeterElement._() is unsupported on this platform."); }   @DomName('HTMLMeterElement.HTMLMeterElement') @DocsEditable() factory MeterElement() { throw new UnsupportedError("new MeterElement() is unsupported on this platform."); }   MeterElement.created() : super.created() { throw new UnsupportedError("new MeterElement.created() is unsupported on this platform."); }   static bool get supported { throw new UnsupportedError("MeterElement.supported is unsupported on this platform."); }   @DomName('HTMLMeterElement.high') @DocsEditable() num get high {}   @DomName('HTMLMeterElement.high') @DocsEditable() void set high(num value) {}   @DomName('HTMLMeterElement.labels') @DocsEditable() @Unstable() List<Node> get labels {}   @DomName('HTMLMeterElement.low') @DocsEditable() num get low {}   @DomName('HTMLMeterElement.low') @DocsEditable() void set low(num value) {}   @DomName('HTMLMeterElement.max') @DocsEditable() num get max {}   @DomName('HTMLMeterElement.max') @DocsEditable() void set max(num value) {}   @DomName('HTMLMeterElement.min') @DocsEditable() num get min {}   @DomName('HTMLMeterElement.min') @DocsEditable() void set min(num value) {}   @DomName('HTMLMeterElement.optimum') @DocsEditable() num get optimum {}   @DomName('HTMLMeterElement.optimum') @DocsEditable() void set optimum(num value) {}   @DomName('HTMLMeterElement.value') @DocsEditable() num get value {}   @DomName('HTMLMeterElement.value') @DocsEditable() void set value(num value) {} } @DocsEditable() @DomName('MIDIAccess') @Experimental() class MidiAccess extends EventTarget { factory MidiAccess._() { throw new UnsupportedError("new MidiAccess._() is unsupported on this platform."); }   static const connectEvent = const EventStreamProvider<MidiConnectionEvent>('connect');   static const disconnectEvent = const EventStreamProvider<MidiConnectionEvent>('disconnect');   @DomName('MIDIAccess.sysexEnabled') @DocsEditable() @Experimental() bool get sysexEnabled {}   @DomName('MIDIAccess.inputs') @DocsEditable() List<MidiInput> inputs() {}   @DomName('MIDIAccess.outputs') @DocsEditable() List<MidiOutput> outputs() {}   @DomName('MIDIAccess.onconnect') @DocsEditable() Stream<MidiConnectionEvent> get onConnect {}   @DomName('MIDIAccess.ondisconnect') @DocsEditable() Stream<MidiConnectionEvent> get onDisconnect {} } @DocsEditable() @DomName('MIDIConnectionEvent') @Experimental() class MidiConnectionEvent extends Event { factory MidiConnectionEvent._() { throw new UnsupportedError("new MidiConnectionEvent._() is unsupported on this platform."); }   @DomName('MIDIConnectionEvent.port') @DocsEditable() MidiPort get port {} } @DocsEditable() @DomName('MIDIInput') @Experimental() class MidiInput extends MidiPort { factory MidiInput._() { throw new UnsupportedError("new MidiInput._() is unsupported on this platform."); }   static const midiMessageEvent = const EventStreamProvider<MidiMessageEvent>('midimessage');   @DomName('MIDIInput.onmidimessage') @DocsEditable() Stream<MidiMessageEvent> get onMidiMessage {} } @DocsEditable() @DomName('MIDIMessageEvent') @Experimental() class MidiMessageEvent extends Event { factory MidiMessageEvent._() { throw new UnsupportedError("new MidiMessageEvent._() is unsupported on this platform."); }   @DomName('MIDIMessageEvent.data') @DocsEditable() Uint8List get data {}   @DomName('MIDIMessageEvent.receivedTime') @DocsEditable() double get receivedTime {} } @DocsEditable() @DomName('MIDIOutput') @Experimental() class MidiOutput extends MidiPort { factory MidiOutput._() { throw new UnsupportedError("new MidiOutput._() is unsupported on this platform."); }   void send(Uint8List data, [num timestamp]) {} } @DocsEditable() @DomName('MIDIPort') @Experimental() class MidiPort extends EventTarget { factory MidiPort._() { throw new UnsupportedError("new MidiPort._() is unsupported on this platform."); }   static const disconnectEvent = const EventStreamProvider<MidiConnectionEvent>('disconnect');   @DomName('MIDIPort.id') @DocsEditable() String get id {}   @DomName('MIDIPort.manufacturer') @DocsEditable() String get manufacturer {}   @DomName('MIDIPort.name') @DocsEditable() String get name {}   @DomName('MIDIPort.type') @DocsEditable() String get type {}   @DomName('MIDIPort.version') @DocsEditable() String get version {}   @DomName('MIDIPort.ondisconnect') @DocsEditable() Stream<MidiConnectionEvent> get onDisconnect {} } @DocsEditable() @DomName('MimeType') @Experimental() class MimeType extends NativeFieldWrapperClass2 { factory MimeType._() { throw new UnsupportedError("new MimeType._() is unsupported on this platform."); }   @DomName('MimeType.description') @DocsEditable() String get description {}   @DomName('MimeType.enabledPlugin') @DocsEditable() Plugin get enabledPlugin {}   @DomName('MimeType.suffixes') @DocsEditable() String get suffixes {}   @DomName('MimeType.type') @DocsEditable() String get type {} } @DocsEditable() @DomName('MimeTypeArray') @Experimental() class MimeTypeArray extends NativeFieldWrapperClass2 with ListMixin<MimeType>, ImmutableListMixin<MimeType> implements List<MimeType> { factory MimeTypeArray._() { throw new UnsupportedError("new MimeTypeArray._() is unsupported on this platform."); }   @DomName('MimeTypeArray.length') @DocsEditable() int get length {}   MimeType operator [](int index) {}    void operator []=(int index, MimeType value) {}   void set length(int value) {}   MimeType get first {}   MimeType get last {}   MimeType get single {}   MimeType elementAt(int index) {}    @DomName('MimeTypeArray.item') @DocsEditable() MimeType item(int index) {}   @DomName('MimeTypeArray.namedItem') @DocsEditable() MimeType namedItem(String name) {} } @DocsEditable() @DomName('HTMLModElement') @Unstable() class ModElement extends HtmlElement { factory ModElement._() { throw new UnsupportedError("new ModElement._() is unsupported on this platform."); }   ModElement.created() : super.created() { throw new UnsupportedError("new ModElement.created() is unsupported on this platform."); }   @DomName('HTMLModElement.cite') @DocsEditable() String get cite {}   @DomName('HTMLModElement.cite') @DocsEditable() void set cite(String value) {}   @DomName('HTMLModElement.dateTime') @DocsEditable() String get dateTime {}   @DomName('HTMLModElement.dateTime') @DocsEditable() void set dateTime(String value) {} } @DomName('MouseEvent') class MouseEvent extends UIEvent { factory MouseEvent(String type, {Window view, int detail : 0, int screenX : 0, int screenY : 0, int clientX : 0, int clientY : 0, int button : 0, bool canBubble : true, bool cancelable : true, bool ctrlKey : false, bool altKey : false, bool shiftKey : false, bool metaKey : false, EventTarget relatedTarget}) { throw new UnsupportedError("new MouseEvent() is unsupported on this platform."); }   factory MouseEvent._() { throw new UnsupportedError("new MouseEvent._() is unsupported on this platform."); }   @DomName('MouseEvent.altKey') @DocsEditable() bool get altKey {}   @DomName('MouseEvent.button') @DocsEditable() int get button {}     @DomName('MouseEvent.ctrlKey') @DocsEditable() bool get ctrlKey {}   @DomName('MouseEvent.dataTransfer') @DocsEditable() @Unstable() DataTransfer get dataTransfer {}   @DomName('MouseEvent.fromElement') @DocsEditable() @deprecated Node get fromElement {}   @DomName('MouseEvent.metaKey') @DocsEditable() bool get metaKey {}       @DomName('MouseEvent.region') @DocsEditable() @Experimental() String get region {}   @DomName('MouseEvent.relatedTarget') @DocsEditable() EventTarget get relatedTarget {}     @DomName('MouseEvent.shiftKey') @DocsEditable() bool get shiftKey {}   @DomName('MouseEvent.toElement') @DocsEditable() @deprecated Node get toElement {}      @deprecated int get clientX {}   @deprecated int get clientY {}   @deprecated int get offsetX {}   @deprecated int get offsetY {}   @deprecated int get movementX {}   @deprecated int get movementY {}   @deprecated int get screenX {}   @deprecated int get screenY {}   @DomName('MouseEvent.clientX') @DomName('MouseEvent.clientY') Point get client {}   @DomName('MouseEvent.movementX') @DomName('MouseEvent.movementY') @SupportedBrowser(SupportedBrowser.CHROME) @SupportedBrowser(SupportedBrowser.SAFARI) @Experimental() Point get movement {}   Point get offset {}   @DomName('MouseEvent.screenX') @DomName('MouseEvent.screenY') Point get screen {} } @DomName('MutationCallback') typedef void MutationCallback(List<MutationRecord> mutations, MutationObserver observer); @DomName('MutationObserver') @SupportedBrowser(SupportedBrowser.CHROME) @SupportedBrowser(SupportedBrowser.FIREFOX) @SupportedBrowser(SupportedBrowser.SAFARI) @Experimental() class MutationObserver extends NativeFieldWrapperClass2 { @DomName('MutationObserver.MutationObserver') @DocsEditable() factory MutationObserver._(MutationCallback callback) { throw new UnsupportedError("new MutationObserver._() is unsupported on this platform."); }   @DocsEditable() static MutationObserver _create(callback) { throw new UnsupportedError("MutationObserver._create() is unsupported on this platform."); }   @DomName('MutationObserver.disconnect') @DocsEditable() void disconnect() {}    @DomName('MutationObserver.takeRecords') @DocsEditable() List<MutationRecord> takeRecords() {}   static bool get supported { throw new UnsupportedError("MutationObserver.supported is unsupported on this platform."); }   void observe(Node target, {bool childList, bool attributes, bool characterData, bool subtree, bool attributeOldValue, bool characterDataOldValue, List<String> attributeFilter}) {}     static _createDict() { throw new UnsupportedError("MutationObserver._createDict() is unsupported on this platform."); }   static _add(m, String key, value) { throw new UnsupportedError("MutationObserver._add() is unsupported on this platform."); }   static _fixupList(list) { throw new UnsupportedError("MutationObserver._fixupList() is unsupported on this platform."); }    factory MutationObserver(MutationCallback callback) { throw new UnsupportedError("new MutationObserver() is unsupported on this platform."); } } @DocsEditable() @DomName('MutationRecord') class MutationRecord extends NativeFieldWrapperClass2 { factory MutationRecord._() { throw new UnsupportedError("new MutationRecord._() is unsupported on this platform."); }   @DomName('MutationRecord.addedNodes') @DocsEditable() List<Node> get addedNodes {}   @DomName('MutationRecord.attributeName') @DocsEditable() String get attributeName {}   @DomName('MutationRecord.attributeNamespace') @DocsEditable() String get attributeNamespace {}   @DomName('MutationRecord.nextSibling') @DocsEditable() Node get nextSibling {}   @DomName('MutationRecord.oldValue') @DocsEditable() String get oldValue {}   @DomName('MutationRecord.previousSibling') @DocsEditable() Node get previousSibling {}   @DomName('MutationRecord.removedNodes') @DocsEditable() List<Node> get removedNodes {}   @DomName('MutationRecord.target') @DocsEditable() Node get target {}   @DomName('MutationRecord.type') @DocsEditable() String get type {} } @DomName('Navigator') class Navigator extends NativeFieldWrapperClass2 implements NavigatorCpu, NavigatorLanguage, NavigatorOnLine, NavigatorID { @DomName('Navigator.webkitGetUserMedia') @SupportedBrowser(SupportedBrowser.CHROME) @Experimental() Future<MediaStream> getUserMedia({audio : false, video : false}) {}   factory Navigator._() { throw new UnsupportedError("new Navigator._() is unsupported on this platform."); }   @DomName('Navigator.connection') @DocsEditable() @Experimental() NetworkInformation get connection {}   @DomName('Navigator.cookieEnabled') @DocsEditable() @Unstable() bool get cookieEnabled {}   @DomName('Navigator.credentials') @DocsEditable() @Experimental() CredentialsContainer get credentials {}   @DomName('Navigator.doNotTrack') @DocsEditable() @Experimental() String get doNotTrack {}   @DomName('Navigator.geofencing') @DocsEditable() @Experimental() Geofencing get geofencing {}   @DomName('Navigator.geolocation') @DocsEditable() @Unstable() Geolocation get geolocation {}   @DomName('Navigator.maxTouchPoints') @DocsEditable() @Experimental() int get maxTouchPoints {}   @DomName('Navigator.mimeTypes') @DocsEditable() @Experimental() MimeTypeArray get mimeTypes {}   @DomName('Navigator.productSub') @DocsEditable() @Unstable() String get productSub {}   @DomName('Navigator.push') @DocsEditable() @Experimental() PushManager get push {}   @DomName('Navigator.serviceWorker') @DocsEditable() @Experimental() ServiceWorkerContainer get serviceWorker {}   @DomName('Navigator.storageQuota') @DocsEditable() @Experimental() StorageQuota get storageQuota {}   @DomName('Navigator.vendor') @DocsEditable() @Unstable() String get vendor {}   @DomName('Navigator.vendorSub') @DocsEditable() @Unstable() String get vendorSub {}   @DomName('Navigator.webkitPersistentStorage') @DocsEditable() @SupportedBrowser(SupportedBrowser.CHROME) @SupportedBrowser(SupportedBrowser.SAFARI) @Experimental() DeprecatedStorageQuota get persistentStorage {}   @DomName('Navigator.webkitTemporaryStorage') @DocsEditable() @SupportedBrowser(SupportedBrowser.CHROME) @SupportedBrowser(SupportedBrowser.SAFARI) @Experimental() DeprecatedStorageQuota get temporaryStorage {}   @DomName('Navigator.getBattery') @DocsEditable() @Experimental() Future getBattery() {}   @DomName('Navigator.getGamepads') @DocsEditable() @Experimental() List<Gamepad> getGamepads() {}   @DomName('Navigator.getStorageUpdates') @DocsEditable() @Experimental() void getStorageUpdates() {}   @DomName('Navigator.isProtocolHandlerRegistered') @DocsEditable() @Experimental() String isProtocolHandlerRegistered(String scheme, String url) {}   @DomName('Navigator.registerProtocolHandler') @DocsEditable() @Unstable() void registerProtocolHandler(String scheme, String url, String title) {}   bool sendBeacon(String url, data) {}   @DomName('Navigator.unregisterProtocolHandler') @DocsEditable() @Experimental() void unregisterProtocolHandler(String scheme, String url) {}    @DomName('Navigator.hardwareConcurrency') @DocsEditable() @Experimental() int get hardwareConcurrency {}   @DomName('Navigator.appCodeName') @DocsEditable() @Experimental() String get appCodeName {}   @DomName('Navigator.appName') @DocsEditable() String get appName {}   @DomName('Navigator.appVersion') @DocsEditable() String get appVersion {}   @DomName('Navigator.dartEnabled') @DocsEditable() @Experimental() bool get dartEnabled {}   @DomName('Navigator.platform') @DocsEditable() String get platform {}   @DomName('Navigator.product') @DocsEditable() @Unstable() String get product {}   @DomName('Navigator.userAgent') @DocsEditable() String get userAgent {}   @DomName('Navigator.language') @DocsEditable() String get language {}   @DomName('Navigator.languages') @DocsEditable() @Experimental() List<String> get languages {}   @DomName('Navigator.onLine') @DocsEditable() @Unstable() bool get onLine {} } @DocsEditable() @DomName('NavigatorCPU') @Experimental() abstract class NavigatorCpu extends NativeFieldWrapperClass2 { factory NavigatorCpu._() { throw new UnsupportedError("new NavigatorCpu._() is unsupported on this platform."); }   @DomName('NavigatorCPU.hardwareConcurrency') @DocsEditable() @Experimental() int get hardwareConcurrency; } @DocsEditable() @DomName('NavigatorID') @Experimental() abstract class NavigatorID extends NativeFieldWrapperClass2 { factory NavigatorID._() { throw new UnsupportedError("new NavigatorID._() is unsupported on this platform."); }   @DomName('NavigatorID.appCodeName') @DocsEditable() @Experimental() String get appCodeName;   @DomName('NavigatorID.appName') @DocsEditable() @Experimental() String get appName;   @DomName('NavigatorID.appVersion') @DocsEditable() @Experimental() String get appVersion;   @DomName('NavigatorID.dartEnabled') @DocsEditable() @Experimental() bool get dartEnabled;   @DomName('NavigatorID.platform') @DocsEditable() @Experimental() String get platform;   @DomName('NavigatorID.product') @DocsEditable() @Experimental() String get product;   @DomName('NavigatorID.userAgent') @DocsEditable() @Experimental() String get userAgent; } @DocsEditable() @DomName('NavigatorLanguage') @Experimental() abstract class NavigatorLanguage extends NativeFieldWrapperClass2 { factory NavigatorLanguage._() { throw new UnsupportedError("new NavigatorLanguage._() is unsupported on this platform."); }   @DomName('NavigatorLanguage.language') @DocsEditable() @Experimental() String get language;   @DomName('NavigatorLanguage.languages') @DocsEditable() @Experimental() List<String> get languages; } @DocsEditable() @DomName('NavigatorOnLine') @Experimental() abstract class NavigatorOnLine extends NativeFieldWrapperClass2 { factory NavigatorOnLine._() { throw new UnsupportedError("new NavigatorOnLine._() is unsupported on this platform."); }   @DomName('NavigatorOnLine.onLine') @DocsEditable() @Experimental() bool get onLine; } @DocsEditable() @DomName('NavigatorUserMediaError') @Experimental() class NavigatorUserMediaError extends NativeFieldWrapperClass2 { factory NavigatorUserMediaError._() { throw new UnsupportedError("new NavigatorUserMediaError._() is unsupported on this platform."); }   @DomName('NavigatorUserMediaError.constraintName') @DocsEditable() String get constraintName {}   @DomName('NavigatorUserMediaError.message') @DocsEditable() String get message {}   @DomName('NavigatorUserMediaError.name') @DocsEditable() String get name {} } @DomName('NavigatorUserMediaErrorCallback') @Experimental() typedef void _NavigatorUserMediaErrorCallback(NavigatorUserMediaError error); @DomName('NavigatorUserMediaSuccessCallback') @Experimental() typedef void _NavigatorUserMediaSuccessCallback(MediaStream stream); @DocsEditable() @DomName('NetworkInformation') @Experimental() class NetworkInformation extends EventTarget { factory NetworkInformation._() { throw new UnsupportedError("new NetworkInformation._() is unsupported on this platform."); }   @DomName('NetworkInformation.type') @DocsEditable() @Experimental() String get type {} } class _ChildNodeListLazy extends ListBase<Node> implements NodeListWrapper {   _ChildNodeListLazy(Node _this) { throw new UnsupportedError("new _ChildNodeListLazy() is unsupported on this platform."); }   Node get first {}   Node get last {}   Node get single {}   void add(Node value) {}   void addAll(Iterable<Node> iterable) {}   void insert(int index, Node node) {}   void insertAll(int index, Iterable<Node> iterable) {}   void setAll(int index, Iterable<Node> iterable) {}   Node removeLast() {}   Node removeAt(int index) {}   bool remove(Object object) {}    void removeWhere(bool test(Node node)) {}   void retainWhere(bool test(Node node)) {}   void clear() {}   void operator []=(int index, Node value) {}   Iterator<Node> get iterator {}   void sort([Comparator<Node> compare]) {}   void shuffle([Random random]) {}   void setRange(int start, int end, Iterable<Node> iterable, [int skipCount = 0]) {}   void fillRange(int start, int end, [Node fill]) {}   int get length {}   void set length(int value) {}   Node operator [](int index) {}   List<Node> get rawList {} } @DomName('Node') class Node extends EventTarget { Node._created() : super._created() { throw new UnsupportedError("new Node._created() is unsupported on this platform."); }   List<Node> get nodes {}   void set nodes(Iterable<Node> value) {}   @DomName('Node.removeChild') void remove() {}   @DomName('Node.replaceChild') Node replaceWith(Node otherNode) {}   Node insertAllBefore(Iterable<Node> newNodes, Node refChild) {}    String toString() {}   factory Node._() { throw new UnsupportedError("new Node._() is unsupported on this platform."); }   static const ATTRIBUTE_NODE = 2;   static const CDATA_SECTION_NODE = 4;   static const COMMENT_NODE = 8;   static const DOCUMENT_FRAGMENT_NODE = 11;   static const DOCUMENT_NODE = 9;   static const DOCUMENT_TYPE_NODE = 10;   static const ELEMENT_NODE = 1;   static const ENTITY_NODE = 6;   static const ENTITY_REFERENCE_NODE = 5;   static const NOTATION_NODE = 12;   static const PROCESSING_INSTRUCTION_NODE = 7;   static const TEXT_NODE = 3;   @DomName('Node.baseURI') @DocsEditable() String get baseUri {}   @DomName('Node.childNodes') @DocsEditable() List<Node> get childNodes {}   @DomName('Node.firstChild') @DocsEditable() Node get firstChild {}   @DomName('Node.lastChild') @DocsEditable() Node get lastChild {}     @DomName('Node.nextSibling') @DocsEditable() Node get nextNode {}   @DomName('Node.nodeName') @DocsEditable() String get nodeName {}   @DomName('Node.nodeType') @DocsEditable() int get nodeType {}   @DomName('Node.nodeValue') @DocsEditable() String get nodeValue {}   @DomName('Node.ownerDocument') @DocsEditable() Document get ownerDocument {}   @DomName('Node.parentElement') @DocsEditable() Element get parent {}   @DomName('Node.parentNode') @DocsEditable() Node get parentNode {}   @DomName('Node.previousSibling') @DocsEditable() Node get previousNode {}   @DomName('Node.textContent') @DocsEditable() String get text {}   @DomName('Node.textContent') @DocsEditable() void set text(String value) {}   @DomName('Node.appendChild') @DocsEditable() Node append(Node newChild) {}   @DomName('Node.cloneNode') @DocsEditable() Node clone(bool deep) {}   @DomName('Node.contains') @DocsEditable() bool contains(Node other) {}   @DomName('Node.hasChildNodes') @DocsEditable() bool hasChildNodes() {}   @DomName('Node.insertBefore') @DocsEditable() Node insertBefore(Node newChild, Node refChild) {}   } @DocsEditable() @DomName('NodeFilter') @Unstable() class NodeFilter extends NativeFieldWrapperClass2 { factory NodeFilter._() { throw new UnsupportedError("new NodeFilter._() is unsupported on this platform."); }   static const FILTER_ACCEPT = 1;   static const FILTER_REJECT = 2;   static const FILTER_SKIP = 3;   static const SHOW_ALL = 0xFFFFFFFF;   static const SHOW_COMMENT = 0x00000080;   static const SHOW_DOCUMENT = 0x00000100;   static const SHOW_DOCUMENT_FRAGMENT = 0x00000400;   static const SHOW_DOCUMENT_TYPE = 0x00000200;   static const SHOW_ELEMENT = 0x00000001;   static const SHOW_PROCESSING_INSTRUCTION = 0x00000040;   static const SHOW_TEXT = 0x00000004; } @DomName('NodeIterator') @Unstable() class NodeIterator extends NativeFieldWrapperClass2 { factory NodeIterator(Node root, int whatToShow) { throw new UnsupportedError("new NodeIterator() is unsupported on this platform."); }   factory NodeIterator._() { throw new UnsupportedError("new NodeIterator._() is unsupported on this platform."); }   @DomName('NodeIterator.pointerBeforeReferenceNode') @DocsEditable() bool get pointerBeforeReferenceNode {}   @DomName('NodeIterator.referenceNode') @DocsEditable() Node get referenceNode {}   @DomName('NodeIterator.root') @DocsEditable() Node get root {}   @DomName('NodeIterator.whatToShow') @DocsEditable() int get whatToShow {}   @DomName('NodeIterator.detach') @DocsEditable() void detach() {}   @DomName('NodeIterator.nextNode') @DocsEditable() Node nextNode() {}   @DomName('NodeIterator.previousNode') @DocsEditable() Node previousNode() {} } @DocsEditable() @DomName('NodeList') class NodeList extends NativeFieldWrapperClass2 with ListMixin<Node>, ImmutableListMixin<Node> implements List<Node> { factory NodeList._() { throw new UnsupportedError("new NodeList._() is unsupported on this platform."); }   @DomName('NodeList.length') @DocsEditable() int get length {}   Node operator [](int index) {}    void operator []=(int index, Node value) {}   void set length(int value) {}   Node get first {}   Node get last {}   Node get single {}   Node elementAt(int index) {}  } @DomName('Notification') @Experimental() class Notification extends EventTarget { factory Notification(String title, {String titleDir : null, String body : null, String bodyDir : null, String tag : null, String iconUrl : null}) { throw new UnsupportedError("new Notification() is unsupported on this platform."); }   factory Notification._() { throw new UnsupportedError("new Notification._() is unsupported on this platform."); }   static const clickEvent = const EventStreamProvider<Event>('click');   static const closeEvent = const EventStreamProvider<Event>('close');   static const errorEvent = const EventStreamProvider<Event>('error');   static const showEvent = const EventStreamProvider<Event>('show');   @DomName('Notification.Notification') @DocsEditable() static Notification _factoryNotification(String title, [Map options]) { throw new UnsupportedError("Notification._factoryNotification() is unsupported on this platform."); }   @DomName('Notification.body') @DocsEditable() @Experimental() String get body {}   @DomName('Notification.dir') @DocsEditable() @Experimental() String get dir {}   @DomName('Notification.icon') @DocsEditable() @Experimental() String get icon {}   @DomName('Notification.lang') @DocsEditable() @Experimental() String get lang {}   @DomName('Notification.permission') @DocsEditable() String get permission {}   @DomName('Notification.tag') @DocsEditable() @Experimental() String get tag {}   @DomName('Notification.title') @DocsEditable() @Experimental() String get title {}   @DomName('Notification.close') @DocsEditable() void close() {}   static void _requestPermission([_NotificationPermissionCallback callback]) { throw new UnsupportedError("Notification._requestPermission() is unsupported on this platform."); }   static Future<String> requestPermission() { throw new UnsupportedError("Notification.requestPermission() is unsupported on this platform."); }   @DomName('Notification.onclick') @DocsEditable() Stream<Event> get onClick {}   @DomName('Notification.onclose') @DocsEditable() Stream<Event> get onClose {}   @DomName('Notification.onerror') @DocsEditable() Stream<Event> get onError {}   @DomName('Notification.onshow') @DocsEditable() Stream<Event> get onShow {} } @DomName('NotificationPermissionCallback') @Experimental() typedef void _NotificationPermissionCallback(String permission); @DocsEditable() @DomName('HTMLOListElement') class OListElement extends HtmlElement { factory OListElement._() { throw new UnsupportedError("new OListElement._() is unsupported on this platform."); }   @DomName('HTMLOListElement.HTMLOListElement') @DocsEditable() factory OListElement() { throw new UnsupportedError("new OListElement() is unsupported on this platform."); }   OListElement.created() : super.created() { throw new UnsupportedError("new OListElement.created() is unsupported on this platform."); }   @DomName('HTMLOListElement.reversed') @DocsEditable() bool get reversed {}   @DomName('HTMLOListElement.reversed') @DocsEditable() void set reversed(bool value) {}   @DomName('HTMLOListElement.start') @DocsEditable() int get start {}   @DomName('HTMLOListElement.start') @DocsEditable() void set start(int value) {}   @DomName('HTMLOListElement.type') @DocsEditable() String get type {}   @DomName('HTMLOListElement.type') @DocsEditable() void set type(String value) {} } @DocsEditable() @DomName('HTMLObjectElement') @SupportedBrowser(SupportedBrowser.CHROME) @SupportedBrowser(SupportedBrowser.IE) @SupportedBrowser(SupportedBrowser.SAFARI) @Unstable() class ObjectElement extends HtmlElement { factory ObjectElement._() { throw new UnsupportedError("new ObjectElement._() is unsupported on this platform."); }   @DomName('HTMLObjectElement.HTMLObjectElement') @DocsEditable() factory ObjectElement() { throw new UnsupportedError("new ObjectElement() is unsupported on this platform."); }   ObjectElement.created() : super.created() { throw new UnsupportedError("new ObjectElement.created() is unsupported on this platform."); }   static bool get supported { throw new UnsupportedError("ObjectElement.supported is unsupported on this platform."); }   @DomName('HTMLObjectElement.data') @DocsEditable() String get data {}   @DomName('HTMLObjectElement.data') @DocsEditable() void set data(String value) {}   @DomName('HTMLObjectElement.form') @DocsEditable() FormElement get form {}   @DomName('HTMLObjectElement.height') @DocsEditable() String get height {}   @DomName('HTMLObjectElement.height') @DocsEditable() void set height(String value) {}   @DomName('HTMLObjectElement.integrity') @DocsEditable() @Experimental() String get integrity {}   @DomName('HTMLObjectElement.integrity') @DocsEditable() @Experimental() void set integrity(String value) {}   @DomName('HTMLObjectElement.name') @DocsEditable() String get name {}   @DomName('HTMLObjectElement.name') @DocsEditable() void set name(String value) {}   @DomName('HTMLObjectElement.type') @DocsEditable() String get type {}   @DomName('HTMLObjectElement.type') @DocsEditable() void set type(String value) {}   @DomName('HTMLObjectElement.useMap') @DocsEditable() String get useMap {}   @DomName('HTMLObjectElement.useMap') @DocsEditable() void set useMap(String value) {}   @DomName('HTMLObjectElement.validationMessage') @DocsEditable() String get validationMessage {}   @DomName('HTMLObjectElement.validity') @DocsEditable() ValidityState get validity {}   @DomName('HTMLObjectElement.width') @DocsEditable() String get width {}   @DomName('HTMLObjectElement.width') @DocsEditable() void set width(String value) {}   @DomName('HTMLObjectElement.willValidate') @DocsEditable() bool get willValidate {}     @DomName('HTMLObjectElement.checkValidity') @DocsEditable() bool checkValidity() {}   @DomName('HTMLObjectElement.setCustomValidity') @DocsEditable() void setCustomValidity(String error) {} } @DocsEditable() @DomName('HTMLOptGroupElement') class OptGroupElement extends HtmlElement { factory OptGroupElement._() { throw new UnsupportedError("new OptGroupElement._() is unsupported on this platform."); }   @DomName('HTMLOptGroupElement.HTMLOptGroupElement') @DocsEditable() factory OptGroupElement() { throw new UnsupportedError("new OptGroupElement() is unsupported on this platform."); }   OptGroupElement.created() : super.created() { throw new UnsupportedError("new OptGroupElement.created() is unsupported on this platform."); }   @DomName('HTMLOptGroupElement.disabled') @DocsEditable() bool get disabled {}   @DomName('HTMLOptGroupElement.disabled') @DocsEditable() void set disabled(bool value) {}   @DomName('HTMLOptGroupElement.label') @DocsEditable() String get label {}   @DomName('HTMLOptGroupElement.label') @DocsEditable() void set label(String value) {} } @DomName('HTMLOptionElement') class OptionElement extends HtmlElement { factory OptionElement({String data : '', String value : '', bool selected : false}) { throw new UnsupportedError("new OptionElement() is unsupported on this platform."); }   @DomName('HTMLOptionElement.HTMLOptionElement') @DocsEditable() factory OptionElement._([String data, String value, bool defaultSelected, bool selected]) { throw new UnsupportedError("new OptionElement._() is unsupported on this platform."); }   OptionElement.created() : super.created() { throw new UnsupportedError("new OptionElement.created() is unsupported on this platform."); }   @DomName('HTMLOptionElement.defaultSelected') @DocsEditable() bool get defaultSelected {}   @DomName('HTMLOptionElement.defaultSelected') @DocsEditable() void set defaultSelected(bool value) {}   @DomName('HTMLOptionElement.disabled') @DocsEditable() bool get disabled {}   @DomName('HTMLOptionElement.disabled') @DocsEditable() void set disabled(bool value) {}   @DomName('HTMLOptionElement.form') @DocsEditable() FormElement get form {}   @DomName('HTMLOptionElement.index') @DocsEditable() int get index {}   @DomName('HTMLOptionElement.label') @DocsEditable() String get label {}   @DomName('HTMLOptionElement.label') @DocsEditable() void set label(String value) {}   @DomName('HTMLOptionElement.selected') @DocsEditable() bool get selected {}   @DomName('HTMLOptionElement.selected') @DocsEditable() void set selected(bool value) {}   @DomName('HTMLOptionElement.value') @DocsEditable() String get value {}   @DomName('HTMLOptionElement.value') @DocsEditable() void set value(String value) {} } @DocsEditable() @DomName('HTMLOutputElement') @SupportedBrowser(SupportedBrowser.CHROME) @SupportedBrowser(SupportedBrowser.FIREFOX) @SupportedBrowser(SupportedBrowser.SAFARI) class OutputElement extends HtmlElement { factory OutputElement._() { throw new UnsupportedError("new OutputElement._() is unsupported on this platform."); }   @DomName('HTMLOutputElement.HTMLOutputElement') @DocsEditable() factory OutputElement() { throw new UnsupportedError("new OutputElement() is unsupported on this platform."); }   OutputElement.created() : super.created() { throw new UnsupportedError("new OutputElement.created() is unsupported on this platform."); }   static bool get supported { throw new UnsupportedError("OutputElement.supported is unsupported on this platform."); }   @DomName('HTMLOutputElement.defaultValue') @DocsEditable() String get defaultValue {}   @DomName('HTMLOutputElement.defaultValue') @DocsEditable() void set defaultValue(String value) {}   @DomName('HTMLOutputElement.form') @DocsEditable() FormElement get form {}   @DomName('HTMLOutputElement.htmlFor') @DocsEditable() DomSettableTokenList get htmlFor {}   @DomName('HTMLOutputElement.labels') @DocsEditable() @Unstable() List<Node> get labels {}   @DomName('HTMLOutputElement.name') @DocsEditable() String get name {}   @DomName('HTMLOutputElement.name') @DocsEditable() void set name(String value) {}   @DomName('HTMLOutputElement.type') @DocsEditable() String get type {}   @DomName('HTMLOutputElement.validationMessage') @DocsEditable() String get validationMessage {}   @DomName('HTMLOutputElement.validity') @DocsEditable() ValidityState get validity {}   @DomName('HTMLOutputElement.value') @DocsEditable() String get value {}   @DomName('HTMLOutputElement.value') @DocsEditable() void set value(String value) {}   @DomName('HTMLOutputElement.willValidate') @DocsEditable() bool get willValidate {}   @DomName('HTMLOutputElement.checkValidity') @DocsEditable() bool checkValidity() {}   @DomName('HTMLOutputElement.setCustomValidity') @DocsEditable() void setCustomValidity(String error) {} } @DocsEditable() @DomName('OverflowEvent') @Experimental() class OverflowEvent extends Event { factory OverflowEvent._() { throw new UnsupportedError("new OverflowEvent._() is unsupported on this platform."); }   static const BOTH = 2;   static const HORIZONTAL = 0;   static const VERTICAL = 1;   @DomName('OverflowEvent.horizontalOverflow') @DocsEditable() bool get horizontalOverflow {}   @DomName('OverflowEvent.orient') @DocsEditable() int get orient {}   @DomName('OverflowEvent.verticalOverflow') @DocsEditable() bool get verticalOverflow {} } @DocsEditable() @DomName('PageTransitionEvent') @Experimental() class PageTransitionEvent extends Event { factory PageTransitionEvent._() { throw new UnsupportedError("new PageTransitionEvent._() is unsupported on this platform."); }   @DomName('PageTransitionEvent.persisted') @DocsEditable() bool get persisted {} } @DocsEditable() @DomName('HTMLParagraphElement') class ParagraphElement extends HtmlElement { factory ParagraphElement._() { throw new UnsupportedError("new ParagraphElement._() is unsupported on this platform."); }   @DomName('HTMLParagraphElement.HTMLParagraphElement') @DocsEditable() factory ParagraphElement() { throw new UnsupportedError("new ParagraphElement() is unsupported on this platform."); }   ParagraphElement.created() : super.created() { throw new UnsupportedError("new ParagraphElement.created() is unsupported on this platform."); } } @DocsEditable() @DomName('HTMLParamElement') @Unstable() class ParamElement extends HtmlElement { factory ParamElement._() { throw new UnsupportedError("new ParamElement._() is unsupported on this platform."); }   @DomName('HTMLParamElement.HTMLParamElement') @DocsEditable() factory ParamElement() { throw new UnsupportedError("new ParamElement() is unsupported on this platform."); }   ParamElement.created() : super.created() { throw new UnsupportedError("new ParamElement.created() is unsupported on this platform."); }   @DomName('HTMLParamElement.name') @DocsEditable() String get name {}   @DomName('HTMLParamElement.name') @DocsEditable() void set name(String value) {}   @DomName('HTMLParamElement.value') @DocsEditable() String get value {}   @DomName('HTMLParamElement.value') @DocsEditable() void set value(String value) {} } @DocsEditable() @DomName('ParentNode') @Experimental() abstract class ParentNode extends NativeFieldWrapperClass2 { factory ParentNode._() { throw new UnsupportedError("new ParentNode._() is unsupported on this platform."); }       @DomName('ParentNode.querySelector') @DocsEditable() @Experimental() Element querySelector(String selectors);   @DomName('ParentNode.querySelectorAll') @DocsEditable() @Experimental() List<Node> querySelectorAll(String selectors); } @DocsEditable() @DomName('Path2D') @Experimental() class Path2D extends NativeFieldWrapperClass2 implements _CanvasPathMethods { factory Path2D._() { throw new UnsupportedError("new Path2D._() is unsupported on this platform."); }   @DomName('Path2D.Path2D') @DocsEditable() factory Path2D([path_OR_text]) { throw new UnsupportedError("new Path2D() is unsupported on this platform."); }   void addPath(Path2D path, [Matrix transform]) {}   @DomName('Path2D.arc') @DocsEditable() @Experimental() void arc(num x, num y, num radius, num startAngle, num endAngle, bool anticlockwise) {}   @DomName('Path2D.arcTo') @DocsEditable() @Experimental() void arcTo(num x1, num y1, num x2, num y2, num radius) {}   @DomName('Path2D.bezierCurveTo') @DocsEditable() @Experimental() void bezierCurveTo(num cp1x, num cp1y, num cp2x, num cp2y, num x, num y) {}   @DomName('Path2D.closePath') @DocsEditable() @Experimental() void closePath() {}   @DomName('Path2D.ellipse') @DocsEditable() @Experimental() void ellipse(num x, num y, num radiusX, num radiusY, num rotation, num startAngle, num endAngle, bool anticlockwise) {}   @DomName('Path2D.lineTo') @DocsEditable() @Experimental() void lineTo(num x, num y) {}   @DomName('Path2D.moveTo') @DocsEditable() @Experimental() void moveTo(num x, num y) {}   @DomName('Path2D.quadraticCurveTo') @DocsEditable() @Experimental() void quadraticCurveTo(num cpx, num cpy, num x, num y) {}   @DomName('Path2D.rect') @DocsEditable() @Experimental() void rect(num x, num y, num width, num height) {} } @DocsEditable() @DomName('Performance') @SupportedBrowser(SupportedBrowser.CHROME) @SupportedBrowser(SupportedBrowser.FIREFOX) @SupportedBrowser(SupportedBrowser.IE) class Performance extends EventTarget { factory Performance._() { throw new UnsupportedError("new Performance._() is unsupported on this platform."); }   static const resourceTimingBufferFullEvent = const EventStreamProvider<Event>('webkitresourcetimingbufferfull');   static bool get supported { throw new UnsupportedError("Performance.supported is unsupported on this platform."); }   @DomName('Performance.memory') @DocsEditable() @Experimental() MemoryInfo get memory {}   @DomName('Performance.navigation') @DocsEditable() PerformanceNavigation get navigation {}   @DomName('Performance.timing') @DocsEditable() PerformanceTiming get timing {}   @DomName('Performance.clearMarks') @DocsEditable() @Experimental() void clearMarks(String markName) {}   @DomName('Performance.clearMeasures') @DocsEditable() @Experimental() void clearMeasures(String measureName) {}   @DomName('Performance.getEntries') @DocsEditable() @Experimental() List<PerformanceEntry> getEntries() {}   @DomName('Performance.getEntriesByName') @DocsEditable() @Experimental() List<PerformanceEntry> getEntriesByName(String name, String entryType) {}   @DomName('Performance.getEntriesByType') @DocsEditable() @Experimental() List<PerformanceEntry> getEntriesByType(String entryType) {}   @DomName('Performance.mark') @DocsEditable() @Experimental() void mark(String markName) {}   @DomName('Performance.measure') @DocsEditable() @Experimental() void measure(String measureName, String startMark, String endMark) {}   @DomName('Performance.now') @DocsEditable() double now() {}   @DomName('Performance.webkitClearResourceTimings') @DocsEditable() @SupportedBrowser(SupportedBrowser.CHROME) @SupportedBrowser(SupportedBrowser.SAFARI) @Experimental() void clearResourceTimings() {}   @DomName('Performance.webkitSetResourceTimingBufferSize') @DocsEditable() @SupportedBrowser(SupportedBrowser.CHROME) @SupportedBrowser(SupportedBrowser.SAFARI) @Experimental() void setResourceTimingBufferSize(int maxSize) {}   @DomName('Performance.onwebkitresourcetimingbufferfull') @DocsEditable() @Experimental() Stream<Event> get onResourceTimingBufferFull {} } @DocsEditable() @DomName('PerformanceEntry') @Experimental() class PerformanceEntry extends NativeFieldWrapperClass2 { factory PerformanceEntry._() { throw new UnsupportedError("new PerformanceEntry._() is unsupported on this platform."); }   @DomName('PerformanceEntry.duration') @DocsEditable() double get duration {}   @DomName('PerformanceEntry.entryType') @DocsEditable() String get entryType {}   @DomName('PerformanceEntry.name') @DocsEditable() String get name {}   @DomName('PerformanceEntry.startTime') @DocsEditable() double get startTime {} } @DocsEditable() @DomName('PerformanceMark') @Experimental() class PerformanceMark extends PerformanceEntry { factory PerformanceMark._() { throw new UnsupportedError("new PerformanceMark._() is unsupported on this platform."); } } @DocsEditable() @DomName('PerformanceMeasure') @Experimental() class PerformanceMeasure extends PerformanceEntry { factory PerformanceMeasure._() { throw new UnsupportedError("new PerformanceMeasure._() is unsupported on this platform."); } } @DocsEditable() @DomName('PerformanceNavigation') @Unstable() class PerformanceNavigation extends NativeFieldWrapperClass2 { factory PerformanceNavigation._() { throw new UnsupportedError("new PerformanceNavigation._() is unsupported on this platform."); }   static const TYPE_BACK_FORWARD = 2;   static const TYPE_NAVIGATE = 0;   static const TYPE_RELOAD = 1;   static const TYPE_RESERVED = 255;   @DomName('PerformanceNavigation.redirectCount') @DocsEditable() int get redirectCount {}   @DomName('PerformanceNavigation.type') @DocsEditable() int get type {} } @DocsEditable() @DomName('PerformanceResourceTiming') @Experimental() class PerformanceResourceTiming extends PerformanceEntry { factory PerformanceResourceTiming._() { throw new UnsupportedError("new PerformanceResourceTiming._() is unsupported on this platform."); }   @DomName('PerformanceResourceTiming.connectEnd') @DocsEditable() double get connectEnd {}   @DomName('PerformanceResourceTiming.connectStart') @DocsEditable() double get connectStart {}   @DomName('PerformanceResourceTiming.domainLookupEnd') @DocsEditable() double get domainLookupEnd {}   @DomName('PerformanceResourceTiming.domainLookupStart') @DocsEditable() double get domainLookupStart {}   @DomName('PerformanceResourceTiming.fetchStart') @DocsEditable() double get fetchStart {}   @DomName('PerformanceResourceTiming.initiatorType') @DocsEditable() String get initiatorType {}   @DomName('PerformanceResourceTiming.redirectEnd') @DocsEditable() double get redirectEnd {}   @DomName('PerformanceResourceTiming.redirectStart') @DocsEditable() double get redirectStart {}   @DomName('PerformanceResourceTiming.requestStart') @DocsEditable() @Experimental() double get requestStart {}   @DomName('PerformanceResourceTiming.responseEnd') @DocsEditable() @Experimental() double get responseEnd {}   @DomName('PerformanceResourceTiming.responseStart') @DocsEditable() @Experimental() double get responseStart {}   @DomName('PerformanceResourceTiming.secureConnectionStart') @DocsEditable() double get secureConnectionStart {} } @DocsEditable() @DomName('PerformanceTiming') @Unstable() class PerformanceTiming extends NativeFieldWrapperClass2 { factory PerformanceTiming._() { throw new UnsupportedError("new PerformanceTiming._() is unsupported on this platform."); }   @DomName('PerformanceTiming.connectEnd') @DocsEditable() int get connectEnd {}   @DomName('PerformanceTiming.connectStart') @DocsEditable() int get connectStart {}   @DomName('PerformanceTiming.domComplete') @DocsEditable() int get domComplete {}   @DomName('PerformanceTiming.domContentLoadedEventEnd') @DocsEditable() int get domContentLoadedEventEnd {}   @DomName('PerformanceTiming.domContentLoadedEventStart') @DocsEditable() int get domContentLoadedEventStart {}   @DomName('PerformanceTiming.domInteractive') @DocsEditable() int get domInteractive {}   @DomName('PerformanceTiming.domLoading') @DocsEditable() int get domLoading {}   @DomName('PerformanceTiming.domainLookupEnd') @DocsEditable() int get domainLookupEnd {}   @DomName('PerformanceTiming.domainLookupStart') @DocsEditable() int get domainLookupStart {}   @DomName('PerformanceTiming.fetchStart') @DocsEditable() int get fetchStart {}   @DomName('PerformanceTiming.loadEventEnd') @DocsEditable() int get loadEventEnd {}   @DomName('PerformanceTiming.loadEventStart') @DocsEditable() int get loadEventStart {}   @DomName('PerformanceTiming.navigationStart') @DocsEditable() int get navigationStart {}   @DomName('PerformanceTiming.redirectEnd') @DocsEditable() int get redirectEnd {}   @DomName('PerformanceTiming.redirectStart') @DocsEditable() int get redirectStart {}   @DomName('PerformanceTiming.requestStart') @DocsEditable() int get requestStart {}   @DomName('PerformanceTiming.responseEnd') @DocsEditable() int get responseEnd {}   @DomName('PerformanceTiming.responseStart') @DocsEditable() int get responseStart {}   @DomName('PerformanceTiming.secureConnectionStart') @DocsEditable() int get secureConnectionStart {}   @DomName('PerformanceTiming.unloadEventEnd') @DocsEditable() int get unloadEventEnd {}   @DomName('PerformanceTiming.unloadEventStart') @DocsEditable() int get unloadEventStart {} } @DocsEditable() @DomName('HTMLPictureElement') @Experimental() class PictureElement extends HtmlElement { factory PictureElement._() { throw new UnsupportedError("new PictureElement._() is unsupported on this platform."); }   PictureElement.created() : super.created() { throw new UnsupportedError("new PictureElement.created() is unsupported on this platform."); } } @DocsEditable() @DomName('Plugin') @Experimental() class Plugin extends NativeFieldWrapperClass2 { factory Plugin._() { throw new UnsupportedError("new Plugin._() is unsupported on this platform."); }   @DomName('Plugin.description') @DocsEditable() String get description {}   @DomName('Plugin.filename') @DocsEditable() String get filename {}   @DomName('Plugin.length') @DocsEditable() int get length {}   @DomName('Plugin.name') @DocsEditable() String get name {}    @DomName('Plugin.item') @DocsEditable() MimeType item(int index) {}   @DomName('Plugin.namedItem') @DocsEditable() MimeType namedItem(String name) {} } @DocsEditable() @DomName('PluginArray') @Experimental() class PluginArray extends NativeFieldWrapperClass2 with ListMixin<Plugin>, ImmutableListMixin<Plugin> implements List<Plugin> { factory PluginArray._() { throw new UnsupportedError("new PluginArray._() is unsupported on this platform."); }   @DomName('PluginArray.length') @DocsEditable() int get length {}   Plugin operator [](int index) {}    void operator []=(int index, Plugin value) {}   void set length(int value) {}   Plugin get first {}   Plugin get last {}   Plugin get single {}   Plugin elementAt(int index) {}    @DomName('PluginArray.item') @DocsEditable() Plugin item(int index) {}   @DomName('PluginArray.namedItem') @DocsEditable() Plugin namedItem(String name) {}   @DomName('PluginArray.refresh') @DocsEditable() void refresh(bool reload) {} } @DocsEditable() @DomName('PopStateEvent') @SupportedBrowser(SupportedBrowser.CHROME) @SupportedBrowser(SupportedBrowser.FIREFOX) @SupportedBrowser(SupportedBrowser.IE, '10') @SupportedBrowser(SupportedBrowser.SAFARI) class PopStateEvent extends Event { factory PopStateEvent._() { throw new UnsupportedError("new PopStateEvent._() is unsupported on this platform."); }   @DomName('PopStateEvent.state') @DocsEditable() Object get state {} } @DomName('PositionCallback') @Unstable() typedef void _PositionCallback(Geoposition position); @DocsEditable() @DomName('PositionError') @Unstable() class PositionError extends NativeFieldWrapperClass2 { factory PositionError._() { throw new UnsupportedError("new PositionError._() is unsupported on this platform."); }   static const PERMISSION_DENIED = 1;   static const POSITION_UNAVAILABLE = 2;   static const TIMEOUT = 3;   @DomName('PositionError.code') @DocsEditable() int get code {}   @DomName('PositionError.message') @DocsEditable() String get message {} } @DomName('PositionErrorCallback') @Unstable() typedef void _PositionErrorCallback(PositionError error); @DocsEditable() @DomName('HTMLPreElement') class PreElement extends HtmlElement { factory PreElement._() { throw new UnsupportedError("new PreElement._() is unsupported on this platform."); }   @DomName('HTMLPreElement.HTMLPreElement') @DocsEditable() factory PreElement() { throw new UnsupportedError("new PreElement() is unsupported on this platform."); }   PreElement.created() : super.created() { throw new UnsupportedError("new PreElement.created() is unsupported on this platform."); } } @DocsEditable() @DomName('ProcessingInstruction') @Unstable() class ProcessingInstruction extends CharacterData { factory ProcessingInstruction._() { throw new UnsupportedError("new ProcessingInstruction._() is unsupported on this platform."); }   @DomName('ProcessingInstruction.sheet') @DocsEditable() @Experimental() StyleSheet get sheet {}   @DomName('ProcessingInstruction.target') @DocsEditable() String get target {} } @DocsEditable() @DomName('HTMLProgressElement') @SupportedBrowser(SupportedBrowser.CHROME) @SupportedBrowser(SupportedBrowser.FIREFOX) @SupportedBrowser(SupportedBrowser.IE, '10') @SupportedBrowser(SupportedBrowser.SAFARI) class ProgressElement extends HtmlElement { factory ProgressElement._() { throw new UnsupportedError("new ProgressElement._() is unsupported on this platform."); }   @DomName('HTMLProgressElement.HTMLProgressElement') @DocsEditable() factory ProgressElement() { throw new UnsupportedError("new ProgressElement() is unsupported on this platform."); }   ProgressElement.created() : super.created() { throw new UnsupportedError("new ProgressElement.created() is unsupported on this platform."); }   static bool get supported { throw new UnsupportedError("ProgressElement.supported is unsupported on this platform."); }   @DomName('HTMLProgressElement.labels') @DocsEditable() @Unstable() List<Node> get labels {}   @DomName('HTMLProgressElement.max') @DocsEditable() num get max {}   @DomName('HTMLProgressElement.max') @DocsEditable() void set max(num value) {}   @DomName('HTMLProgressElement.position') @DocsEditable() double get position {}   @DomName('HTMLProgressElement.value') @DocsEditable() num get value {}   @DomName('HTMLProgressElement.value') @DocsEditable() void set value(num value) {} } @DocsEditable() @DomName('ProgressEvent') class ProgressEvent extends Event { factory ProgressEvent._() { throw new UnsupportedError("new ProgressEvent._() is unsupported on this platform."); }   @DomName('ProgressEvent.lengthComputable') @DocsEditable() bool get lengthComputable {}   @DomName('ProgressEvent.loaded') @DocsEditable() int get loaded {}   @DomName('ProgressEvent.total') @DocsEditable() int get total {} } @DocsEditable() @DomName('PushEvent') @Experimental() class PushEvent extends Event { factory PushEvent._() { throw new UnsupportedError("new PushEvent._() is unsupported on this platform."); }   @DomName('PushEvent.data') @DocsEditable() @Experimental() String get data {} } @DocsEditable() @DomName('PushManager') @Experimental() class PushManager extends NativeFieldWrapperClass2 { factory PushManager._() { throw new UnsupportedError("new PushManager._() is unsupported on this platform."); }   @DomName('PushManager.register') @DocsEditable() @Experimental() Future register(String senderId) {} } @DocsEditable() @DomName('PushRegistration') @Experimental() class PushRegistration extends NativeFieldWrapperClass2 { factory PushRegistration._() { throw new UnsupportedError("new PushRegistration._() is unsupported on this platform."); }   @DomName('PushRegistration.pushEndpoint') @DocsEditable() @Experimental() String get pushEndpoint {}   @DomName('PushRegistration.pushRegistrationId') @DocsEditable() @Experimental() String get pushRegistrationId {} } @DocsEditable() @DomName('HTMLQuoteElement') class QuoteElement extends HtmlElement { factory QuoteElement._() { throw new UnsupportedError("new QuoteElement._() is unsupported on this platform."); }   @DomName('HTMLQuoteElement.HTMLQuoteElement') @DocsEditable() factory QuoteElement() { throw new UnsupportedError("new QuoteElement() is unsupported on this platform."); }   QuoteElement.created() : super.created() { throw new UnsupportedError("new QuoteElement.created() is unsupported on this platform."); }   @DomName('HTMLQuoteElement.cite') @DocsEditable() String get cite {}   @DomName('HTMLQuoteElement.cite') @DocsEditable() void set cite(String value) {} } @DomName('RTCErrorCallback') @Experimental() typedef void _RtcErrorCallback(String errorInformation); @DomName('RTCSessionDescriptionCallback') @Experimental() typedef void _RtcSessionDescriptionCallback(RtcSessionDescription sdp); @DomName('RTCStatsCallback') @Experimental() typedef void RtcStatsCallback(RtcStatsResponse response); @DomName('Range') @Unstable() class Range extends NativeFieldWrapperClass2 { factory Range() { throw new UnsupportedError("new Range() is unsupported on this platform."); }   factory Range.fromPoint(Point point) { throw new UnsupportedError("new Range.fromPoint() is unsupported on this platform."); }   factory Range._() { throw new UnsupportedError("new Range._() is unsupported on this platform."); }   static const END_TO_END = 2;   static const END_TO_START = 3;   static const NODE_AFTER = 1;   static const NODE_BEFORE = 0;   static const NODE_BEFORE_AND_AFTER = 2;   static const NODE_INSIDE = 3;   static const START_TO_END = 1;   static const START_TO_START = 0;   @DomName('Range.collapsed') @DocsEditable() bool get collapsed {}   @DomName('Range.commonAncestorContainer') @DocsEditable() Node get commonAncestorContainer {}   @DomName('Range.endContainer') @DocsEditable() Node get endContainer {}   @DomName('Range.endOffset') @DocsEditable() int get endOffset {}   @DomName('Range.startContainer') @DocsEditable() Node get startContainer {}   @DomName('Range.startOffset') @DocsEditable() int get startOffset {}   @DomName('Range.cloneContents') @DocsEditable() DocumentFragment cloneContents() {}   @DomName('Range.cloneRange') @DocsEditable() Range cloneRange() {}   void collapse([bool toStart]) {}   @DomName('Range.comparePoint') @DocsEditable() int comparePoint(Node refNode, int offset) {}   @DomName('Range.createContextualFragment') @DocsEditable() DocumentFragment createContextualFragment(String html) {}   @DomName('Range.deleteContents') @DocsEditable() void deleteContents() {}   @DomName('Range.detach') @DocsEditable() void detach() {}   @DomName('Range.expand') @DocsEditable() @Experimental() void expand(String unit) {}   @DomName('Range.extractContents') @DocsEditable() DocumentFragment extractContents() {}   @DomName('Range.getBoundingClientRect') @DocsEditable() Rectangle getBoundingClientRect() {}   @DomName('Range.getClientRects') @DocsEditable() List<Rectangle> getClientRects() {}   @DomName('Range.insertNode') @DocsEditable() void insertNode(Node newNode) {}   @DomName('Range.isPointInRange') @DocsEditable() bool isPointInRange(Node refNode, int offset) {}   @DomName('Range.selectNode') @DocsEditable() void selectNode(Node refNode) {}   @DomName('Range.selectNodeContents') @DocsEditable() void selectNodeContents(Node refNode) {}   @DomName('Range.setEnd') @DocsEditable() void setEnd(Node refNode, int offset) {}   @DomName('Range.setEndAfter') @DocsEditable() void setEndAfter(Node refNode) {}   @DomName('Range.setEndBefore') @DocsEditable() void setEndBefore(Node refNode) {}   @DomName('Range.setStart') @DocsEditable() void setStart(Node refNode, int offset) {}   @DomName('Range.setStartAfter') @DocsEditable() void setStartAfter(Node refNode) {}   @DomName('Range.setStartBefore') @DocsEditable() void setStartBefore(Node refNode) {}   @DomName('Range.surroundContents') @DocsEditable() void surroundContents(Node newParent) {}   static bool get supportsCreateContextualFragment { throw new UnsupportedError("Range.supportsCreateContextualFragment is unsupported on this platform."); } } @DocsEditable() @DomName('ReadableStream') @Experimental() class ReadableStream extends NativeFieldWrapperClass2 { factory ReadableStream._() { throw new UnsupportedError("new ReadableStream._() is unsupported on this platform."); } } @DocsEditable() @DomName('RelatedEvent') @Experimental() class RelatedEvent extends Event { factory RelatedEvent._() { throw new UnsupportedError("new RelatedEvent._() is unsupported on this platform."); }   @DomName('RelatedEvent.relatedTarget') @DocsEditable() @Experimental() EventTarget get relatedTarget {} } @DomName('RequestAnimationFrameCallback') typedef void RequestAnimationFrameCallback(num highResTime); @DocsEditable() @DomName('ResourceProgressEvent') @deprecated class ResourceProgressEvent extends ProgressEvent { factory ResourceProgressEvent._() { throw new UnsupportedError("new ResourceProgressEvent._() is unsupported on this platform."); }   @DomName('ResourceProgressEvent.url') @DocsEditable() String get url {} } @DocsEditable() @DomName('RTCDataChannel') @Experimental() class RtcDataChannel extends EventTarget { factory RtcDataChannel._() { throw new UnsupportedError("new RtcDataChannel._() is unsupported on this platform."); }   static const closeEvent = const EventStreamProvider<Event>('close');   static const errorEvent = const EventStreamProvider<Event>('error');   static const messageEvent = const EventStreamProvider<MessageEvent>('message');   static const openEvent = const EventStreamProvider<Event>('open');   @DomName('RTCDataChannel.binaryType') @DocsEditable() String get binaryType {}   @DomName('RTCDataChannel.binaryType') @DocsEditable() void set binaryType(String value) {}   @DomName('RTCDataChannel.bufferedAmount') @DocsEditable() int get bufferedAmount {}   @DomName('RTCDataChannel.id') @DocsEditable() @Experimental() int get id {}   @DomName('RTCDataChannel.label') @DocsEditable() String get label {}   @DomName('RTCDataChannel.maxRetransmitTime') @DocsEditable() @Experimental() int get maxRetransmitTime {}   @DomName('RTCDataChannel.maxRetransmits') @DocsEditable() @Experimental() int get maxRetransmits {}   @DomName('RTCDataChannel.negotiated') @DocsEditable() @Experimental() bool get negotiated {}   @DomName('RTCDataChannel.ordered') @DocsEditable() @Experimental() bool get ordered {}   @DomName('RTCDataChannel.protocol') @DocsEditable() @Experimental() String get protocol {}   @DomName('RTCDataChannel.readyState') @DocsEditable() String get readyState {}   @DomName('RTCDataChannel.reliable') @DocsEditable() bool get reliable {}   @DomName('RTCDataChannel.close') @DocsEditable() void close() {}   void send(data) {}   @DomName('RTCDataChannel.sendBlob') @DocsEditable() void sendBlob(Blob data) {}   @DomName('RTCDataChannel.sendByteBuffer') @DocsEditable() void sendByteBuffer(ByteBuffer data) {}   @DomName('RTCDataChannel.sendString') @DocsEditable() void sendString(String data) {}   @DomName('RTCDataChannel.sendTypedData') @DocsEditable() void sendTypedData(TypedData data) {}   @DomName('RTCDataChannel.onclose') @DocsEditable() Stream<Event> get onClose {}   @DomName('RTCDataChannel.onerror') @DocsEditable() Stream<Event> get onError {}   @DomName('RTCDataChannel.onmessage') @DocsEditable() Stream<MessageEvent> get onMessage {}   @DomName('RTCDataChannel.onopen') @DocsEditable() Stream<Event> get onOpen {} } @DocsEditable() @DomName('RTCDataChannelEvent') @Experimental() class RtcDataChannelEvent extends Event { factory RtcDataChannelEvent._() { throw new UnsupportedError("new RtcDataChannelEvent._() is unsupported on this platform."); }   @DomName('RTCDataChannelEvent.channel') @DocsEditable() RtcDataChannel get channel {} } @DocsEditable() @DomName('RTCDTMFSender') @Experimental() class RtcDtmfSender extends EventTarget { factory RtcDtmfSender._() { throw new UnsupportedError("new RtcDtmfSender._() is unsupported on this platform."); }   static const toneChangeEvent = const EventStreamProvider<RtcDtmfToneChangeEvent>('tonechange');   @DomName('RTCDTMFSender.canInsertDTMF') @DocsEditable() bool get canInsertDtmf {}   @DomName('RTCDTMFSender.duration') @DocsEditable() int get duration {}   @DomName('RTCDTMFSender.interToneGap') @DocsEditable() int get interToneGap {}   @DomName('RTCDTMFSender.toneBuffer') @DocsEditable() String get toneBuffer {}   @DomName('RTCDTMFSender.track') @DocsEditable() MediaStreamTrack get track {}   void insertDtmf(String tones, [int duration, int interToneGap]) {}   @DomName('RTCDTMFSender.ontonechange') @DocsEditable() Stream<RtcDtmfToneChangeEvent> get onToneChange {} } @DocsEditable() @DomName('RTCDTMFToneChangeEvent') @Experimental() class RtcDtmfToneChangeEvent extends Event { factory RtcDtmfToneChangeEvent._() { throw new UnsupportedError("new RtcDtmfToneChangeEvent._() is unsupported on this platform."); }   @DomName('RTCDTMFToneChangeEvent.tone') @DocsEditable() String get tone {} } @DocsEditable() @DomName('RTCIceCandidate') @SupportedBrowser(SupportedBrowser.CHROME) @Experimental() class RtcIceCandidate extends NativeFieldWrapperClass2 { factory RtcIceCandidate._() { throw new UnsupportedError("new RtcIceCandidate._() is unsupported on this platform."); }   @DomName('RTCIceCandidate.RTCIceCandidate') @DocsEditable() factory RtcIceCandidate(Map dictionary) { throw new UnsupportedError("new RtcIceCandidate() is unsupported on this platform."); }   @DomName('RTCIceCandidate.candidate') @DocsEditable() String get candidate {}   @DomName('RTCIceCandidate.candidate') @DocsEditable() void set candidate(String value) {}   @DomName('RTCIceCandidate.sdpMLineIndex') @DocsEditable() int get sdpMLineIndex {}   @DomName('RTCIceCandidate.sdpMLineIndex') @DocsEditable() void set sdpMLineIndex(int value) {}   @DomName('RTCIceCandidate.sdpMid') @DocsEditable() String get sdpMid {}   @DomName('RTCIceCandidate.sdpMid') @DocsEditable() void set sdpMid(String value) {} } @DocsEditable() @DomName('RTCIceCandidateEvent') @Experimental() class RtcIceCandidateEvent extends Event { factory RtcIceCandidateEvent._() { throw new UnsupportedError("new RtcIceCandidateEvent._() is unsupported on this platform."); }   @DomName('RTCIceCandidateEvent.candidate') @DocsEditable() RtcIceCandidate get candidate {} } @DomName('RTCPeerConnection') @SupportedBrowser(SupportedBrowser.CHROME) @Experimental() class RtcPeerConnection extends EventTarget { static bool get supported { throw new UnsupportedError("RtcPeerConnection.supported is unsupported on this platform."); }   Future<RtcSessionDescription> createOffer([Map mediaConstraints]) {}   Future<RtcSessionDescription> createAnswer([Map mediaConstraints]) {}   @DomName('RTCPeerConnection.getStats') Future<RtcStatsResponse> getStats(MediaStreamTrack selector) {}   factory RtcPeerConnection._() { throw new UnsupportedError("new RtcPeerConnection._() is unsupported on this platform."); }   static const addStreamEvent = const EventStreamProvider<MediaStreamEvent>('addstream');   static const dataChannelEvent = const EventStreamProvider<RtcDataChannelEvent>('datachannel');   static const iceCandidateEvent = const EventStreamProvider<RtcIceCandidateEvent>('icecandidate');   static const iceConnectionStateChangeEvent = const EventStreamProvider<Event>('iceconnectionstatechange');   static const negotiationNeededEvent = const EventStreamProvider<Event>('negotiationneeded');   static const removeStreamEvent = const EventStreamProvider<MediaStreamEvent>('removestream');   static const signalingStateChangeEvent = const EventStreamProvider<Event>('signalingstatechange');   @DomName('RTCPeerConnection.RTCPeerConnection') @DocsEditable() factory RtcPeerConnection(Map rtcConfiguration, [Map mediaConstraints]) { throw new UnsupportedError("new RtcPeerConnection() is unsupported on this platform."); }   @DomName('RTCPeerConnection.iceConnectionState') @DocsEditable() String get iceConnectionState {}   @DomName('RTCPeerConnection.iceGatheringState') @DocsEditable() String get iceGatheringState {}   @DomName('RTCPeerConnection.localDescription') @DocsEditable() RtcSessionDescription get localDescription {}   @DomName('RTCPeerConnection.remoteDescription') @DocsEditable() RtcSessionDescription get remoteDescription {}   @DomName('RTCPeerConnection.signalingState') @DocsEditable() String get signalingState {}   @DomName('RTCPeerConnection.addIceCandidate') @DocsEditable() void addIceCandidate(RtcIceCandidate candidate, VoidCallback successCallback, _RtcErrorCallback failureCallback) {}   void addStream(MediaStream stream, [Map mediaConstraints]) {}   @DomName('RTCPeerConnection.close') @DocsEditable() void close() {}    @DomName('RTCPeerConnection.createDTMFSender') @DocsEditable() RtcDtmfSender createDtmfSender(MediaStreamTrack track) {}   RtcDataChannel createDataChannel(String label, [Map options]) {}    @DomName('RTCPeerConnection.getLocalStreams') @DocsEditable() List<MediaStream> getLocalStreams() {}   @DomName('RTCPeerConnection.getRemoteStreams') @DocsEditable() List<MediaStream> getRemoteStreams() {}    @DomName('RTCPeerConnection.getStreamById') @DocsEditable() MediaStream getStreamById(String streamId) {}   @DomName('RTCPeerConnection.removeStream') @DocsEditable() void removeStream(MediaStream stream) {}    Future setLocalDescription(RtcSessionDescription description) {}    Future setRemoteDescription(RtcSessionDescription description) {}   void updateIce([Map configuration, Map mediaConstraints]) {}   @DomName('RTCPeerConnection.onaddstream') @DocsEditable() Stream<MediaStreamEvent> get onAddStream {}   @DomName('RTCPeerConnection.ondatachannel') @DocsEditable() Stream<RtcDataChannelEvent> get onDataChannel {}   @DomName('RTCPeerConnection.onicecandidate') @DocsEditable() Stream<RtcIceCandidateEvent> get onIceCandidate {}   @DomName('RTCPeerConnection.oniceconnectionstatechange') @DocsEditable() Stream<Event> get onIceConnectionStateChange {}   @DomName('RTCPeerConnection.onnegotiationneeded') @DocsEditable() Stream<Event> get onNegotiationNeeded {}   @DomName('RTCPeerConnection.onremovestream') @DocsEditable() Stream<MediaStreamEvent> get onRemoveStream {}   @DomName('RTCPeerConnection.onsignalingstatechange') @DocsEditable() Stream<Event> get onSignalingStateChange {} } @DocsEditable() @DomName('RTCSessionDescription') @SupportedBrowser(SupportedBrowser.CHROME) @Experimental() class RtcSessionDescription extends NativeFieldWrapperClass2 { factory RtcSessionDescription._() { throw new UnsupportedError("new RtcSessionDescription._() is unsupported on this platform."); }   @DomName('RTCSessionDescription.RTCSessionDescription') @DocsEditable() factory RtcSessionDescription([Map descriptionInitDict]) { throw new UnsupportedError("new RtcSessionDescription() is unsupported on this platform."); }   @DomName('RTCSessionDescription.sdp') @DocsEditable() String get sdp {}   @DomName('RTCSessionDescription.sdp') @DocsEditable() void set sdp(String value) {}   @DomName('RTCSessionDescription.type') @DocsEditable() String get type {}   @DomName('RTCSessionDescription.type') @DocsEditable() void set type(String value) {} } @DocsEditable() @DomName('RTCStatsReport') @Experimental() class RtcStatsReport extends NativeFieldWrapperClass2 { factory RtcStatsReport._() { throw new UnsupportedError("new RtcStatsReport._() is unsupported on this platform."); }   @DomName('RTCStatsReport.id') @DocsEditable() String get id {}   @DomName('RTCStatsReport.local') @DocsEditable() RtcStatsReport get local {}   @DomName('RTCStatsReport.remote') @DocsEditable() RtcStatsReport get remote {}   @DomName('RTCStatsReport.timestamp') @DocsEditable() DateTime get timestamp {}   @DomName('RTCStatsReport.type') @DocsEditable() String get type {}   @DomName('RTCStatsReport.names') @DocsEditable() List<String> names() {}   @DomName('RTCStatsReport.stat') @DocsEditable() String stat(String name) {} } @DocsEditable() @DomName('RTCStatsResponse') @Experimental() class RtcStatsResponse extends NativeFieldWrapperClass2 { factory RtcStatsResponse._() { throw new UnsupportedError("new RtcStatsResponse._() is unsupported on this platform."); }    @DomName('RTCStatsResponse.namedItem') @DocsEditable() RtcStatsReport namedItem(String name) {}   @DomName('RTCStatsResponse.result') @DocsEditable() List<RtcStatsReport> result() {} } @DocsEditable() @DomName('Screen') class Screen extends NativeFieldWrapperClass2 { @DomName('Screen.availHeight') @DomName('Screen.availLeft') @DomName('Screen.availTop') @DomName('Screen.availWidth') Rectangle get available {}   factory Screen._() { throw new UnsupportedError("new Screen._() is unsupported on this platform."); }       @DomName('Screen.colorDepth') @DocsEditable() int get colorDepth {}   @DomName('Screen.height') @DocsEditable() int get height {}   @DomName('Screen.orientation') @DocsEditable() @Experimental() ScreenOrientation get orientation {}   @DomName('Screen.pixelDepth') @DocsEditable() int get pixelDepth {}   @DomName('Screen.width') @DocsEditable() int get width {} } @DocsEditable() @DomName('ScreenOrientation') @Experimental() class ScreenOrientation extends EventTarget { factory ScreenOrientation._() { throw new UnsupportedError("new ScreenOrientation._() is unsupported on this platform."); }   static const changeEvent = const EventStreamProvider<Event>('change');   @DomName('ScreenOrientation.angle') @DocsEditable() @Experimental() int get angle {}   @DomName('ScreenOrientation.type') @DocsEditable() @Experimental() String get type {}   @DomName('ScreenOrientation.lock') @DocsEditable() @Experimental() Future lock(String orientation) {}   @DomName('ScreenOrientation.unlock') @DocsEditable() @Experimental() void unlock() {}   @DomName('ScreenOrientation.onchange') @DocsEditable() @Experimental() Stream<Event> get onChange {} } @DocsEditable() @DomName('HTMLScriptElement') class ScriptElement extends HtmlElement { factory ScriptElement._() { throw new UnsupportedError("new ScriptElement._() is unsupported on this platform."); }   @DomName('HTMLScriptElement.HTMLScriptElement') @DocsEditable() factory ScriptElement() { throw new UnsupportedError("new ScriptElement() is unsupported on this platform."); }   ScriptElement.created() : super.created() { throw new UnsupportedError("new ScriptElement.created() is unsupported on this platform."); }   @DomName('HTMLScriptElement.async') @DocsEditable() bool get async {}   @DomName('HTMLScriptElement.async') @DocsEditable() void set async(bool value) {}   @DomName('HTMLScriptElement.charset') @DocsEditable() String get charset {}   @DomName('HTMLScriptElement.charset') @DocsEditable() void set charset(String value) {}   @DomName('HTMLScriptElement.crossOrigin') @DocsEditable() @Experimental() String get crossOrigin {}   @DomName('HTMLScriptElement.crossOrigin') @DocsEditable() @Experimental() void set crossOrigin(String value) {}   @DomName('HTMLScriptElement.defer') @DocsEditable() bool get defer {}   @DomName('HTMLScriptElement.defer') @DocsEditable() void set defer(bool value) {}   @DomName('HTMLScriptElement.integrity') @DocsEditable() @Experimental() String get integrity {}   @DomName('HTMLScriptElement.integrity') @DocsEditable() @Experimental() void set integrity(String value) {}   @DomName('HTMLScriptElement.nonce') @DocsEditable() @Experimental() String get nonce {}   @DomName('HTMLScriptElement.nonce') @DocsEditable() @Experimental() void set nonce(String value) {}   @DomName('HTMLScriptElement.src') @DocsEditable() String get src {}   @DomName('HTMLScriptElement.src') @DocsEditable() void set src(String value) {}   @DomName('HTMLScriptElement.type') @DocsEditable() String get type {}   @DomName('HTMLScriptElement.type') @DocsEditable() void set type(String value) {} } @DocsEditable() @DomName('SecurityPolicyViolationEvent') @Experimental() class SecurityPolicyViolationEvent extends Event { factory SecurityPolicyViolationEvent._() { throw new UnsupportedError("new SecurityPolicyViolationEvent._() is unsupported on this platform."); }   @DomName('SecurityPolicyViolationEvent.blockedURI') @DocsEditable() String get blockedUri {}   @DomName('SecurityPolicyViolationEvent.columnNumber') @DocsEditable() int get columnNumber {}   @DomName('SecurityPolicyViolationEvent.documentURI') @DocsEditable() String get documentUri {}   @DomName('SecurityPolicyViolationEvent.effectiveDirective') @DocsEditable() String get effectiveDirective {}   @DomName('SecurityPolicyViolationEvent.lineNumber') @DocsEditable() int get lineNumber {}   @DomName('SecurityPolicyViolationEvent.originalPolicy') @DocsEditable() String get originalPolicy {}   @DomName('SecurityPolicyViolationEvent.referrer') @DocsEditable() String get referrer {}   @DomName('SecurityPolicyViolationEvent.sourceFile') @DocsEditable() String get sourceFile {}   @DomName('SecurityPolicyViolationEvent.statusCode') @DocsEditable() @Experimental() int get statusCode {}   @DomName('SecurityPolicyViolationEvent.violatedDirective') @DocsEditable() String get violatedDirective {} } @DomName('HTMLSelectElement') class SelectElement extends HtmlElement { factory SelectElement._() { throw new UnsupportedError("new SelectElement._() is unsupported on this platform."); }   @DomName('HTMLSelectElement.HTMLSelectElement') @DocsEditable() factory SelectElement() { throw new UnsupportedError("new SelectElement() is unsupported on this platform."); }   SelectElement.created() : super.created() { throw new UnsupportedError("new SelectElement.created() is unsupported on this platform."); }   @DomName('HTMLSelectElement.autofocus') @DocsEditable() bool get autofocus {}   @DomName('HTMLSelectElement.autofocus') @DocsEditable() void set autofocus(bool value) {}   @DomName('HTMLSelectElement.disabled') @DocsEditable() bool get disabled {}   @DomName('HTMLSelectElement.disabled') @DocsEditable() void set disabled(bool value) {}   @DomName('HTMLSelectElement.form') @DocsEditable() FormElement get form {}   @DomName('HTMLSelectElement.labels') @DocsEditable() @Unstable() List<Node> get labels {}   @DomName('HTMLSelectElement.length') @DocsEditable() int get length {}   @DomName('HTMLSelectElement.length') @DocsEditable() void set length(int value) {}   @DomName('HTMLSelectElement.multiple') @DocsEditable() bool get multiple {}   @DomName('HTMLSelectElement.multiple') @DocsEditable() void set multiple(bool value) {}   @DomName('HTMLSelectElement.name') @DocsEditable() String get name {}   @DomName('HTMLSelectElement.name') @DocsEditable() void set name(String value) {}   @DomName('HTMLSelectElement.required') @DocsEditable() bool get required {}   @DomName('HTMLSelectElement.required') @DocsEditable() void set required(bool value) {}   @DomName('HTMLSelectElement.selectedIndex') @DocsEditable() int get selectedIndex {}   @DomName('HTMLSelectElement.selectedIndex') @DocsEditable() void set selectedIndex(int value) {}   @DomName('HTMLSelectElement.size') @DocsEditable() int get size {}   @DomName('HTMLSelectElement.size') @DocsEditable() void set size(int value) {}   @DomName('HTMLSelectElement.type') @DocsEditable() String get type {}   @DomName('HTMLSelectElement.validationMessage') @DocsEditable() String get validationMessage {}   @DomName('HTMLSelectElement.validity') @DocsEditable() ValidityState get validity {}   @DomName('HTMLSelectElement.value') @DocsEditable() String get value {}   @DomName('HTMLSelectElement.value') @DocsEditable() void set value(String value) {}   @DomName('HTMLSelectElement.willValidate') @DocsEditable() bool get willValidate {}    @DomName('HTMLSelectElement.add') @DocsEditable() @Experimental() void add(HtmlElement element, int before) {}   @DomName('HTMLSelectElement.checkValidity') @DocsEditable() bool checkValidity() {}   @DomName('HTMLSelectElement.item') @DocsEditable() Element item(int index) {}   @DomName('HTMLSelectElement.namedItem') @DocsEditable() Element namedItem(String name) {}   @DomName('HTMLSelectElement.setCustomValidity') @DocsEditable() void setCustomValidity(String error) {}   List<OptionElement> get options {}   List<OptionElement> get selectedOptions {} } @DocsEditable() @DomName('Selection') class Selection extends NativeFieldWrapperClass2 { factory Selection._() { throw new UnsupportedError("new Selection._() is unsupported on this platform."); }   @DomName('Selection.anchorNode') @DocsEditable() Node get anchorNode {}   @DomName('Selection.anchorOffset') @DocsEditable() int get anchorOffset {}   @DomName('Selection.baseNode') @DocsEditable() @Experimental() Node get baseNode {}   @DomName('Selection.baseOffset') @DocsEditable() @Experimental() int get baseOffset {}   @DomName('Selection.extentNode') @DocsEditable() @Experimental() Node get extentNode {}   @DomName('Selection.extentOffset') @DocsEditable() @Experimental() int get extentOffset {}   @DomName('Selection.focusNode') @DocsEditable() Node get focusNode {}   @DomName('Selection.focusOffset') @DocsEditable() int get focusOffset {}   @DomName('Selection.isCollapsed') @DocsEditable() bool get isCollapsed {}   @DomName('Selection.rangeCount') @DocsEditable() int get rangeCount {}   @DomName('Selection.type') @DocsEditable() @Experimental() String get type {}   @DomName('Selection.addRange') @DocsEditable() void addRange(Range range) {}   void collapse(Node node, [int offset]) {}   @DomName('Selection.collapseToEnd') @DocsEditable() void collapseToEnd() {}   @DomName('Selection.collapseToStart') @DocsEditable() void collapseToStart() {}   @DomName('Selection.containsNode') @DocsEditable() @Experimental() bool containsNode(Node node, bool allowPartial) {}   @DomName('Selection.deleteFromDocument') @DocsEditable() void deleteFromDocument() {}   @DomName('Selection.empty') @DocsEditable() @Experimental() void empty() {}   void extend(Node node, [int offset]) {}   @DomName('Selection.getRangeAt') @DocsEditable() Range getRangeAt(int index) {}   @DomName('Selection.modify') @DocsEditable() @Experimental() void modify(String alter, String direction, String granularity) {}   @DomName('Selection.removeAllRanges') @DocsEditable() void removeAllRanges() {}   @DomName('Selection.selectAllChildren') @DocsEditable() void selectAllChildren(Node node) {}   @DomName('Selection.setBaseAndExtent') @DocsEditable() @Experimental() void setBaseAndExtent(Node baseNode, int baseOffset, Node extentNode, int extentOffset) {}   void setPosition(Node node, [int offset]) {} } @DocsEditable() @DomName('ServiceWorkerClient') @Experimental() class ServiceWorkerClient extends NativeFieldWrapperClass2 { factory ServiceWorkerClient._() { throw new UnsupportedError("new ServiceWorkerClient._() is unsupported on this platform."); }   @DomName('ServiceWorkerClient.id') @DocsEditable() @Experimental() int get id {}   @DomName('ServiceWorkerClient.postMessage') @DocsEditable() @Experimental() void postMessage(message, [List<MessagePort> transfer]) {} } @DocsEditable() @DomName('ServiceWorkerClients') @Experimental() class ServiceWorkerClients extends NativeFieldWrapperClass2 { factory ServiceWorkerClients._() { throw new UnsupportedError("new ServiceWorkerClients._() is unsupported on this platform."); }   @DomName('ServiceWorkerClients.getServiced') @DocsEditable() @Experimental() Future getServiced() {} } @DocsEditable() @DomName('ServiceWorkerContainer') @Experimental() class ServiceWorkerContainer extends NativeFieldWrapperClass2 { factory ServiceWorkerContainer._() { throw new UnsupportedError("new ServiceWorkerContainer._() is unsupported on this platform."); }   @DomName('ServiceWorkerContainer.active') @DocsEditable() @Experimental() _ServiceWorker get active {}   @DomName('ServiceWorkerContainer.controller') @DocsEditable() @Experimental() _ServiceWorker get controller {}   @DomName('ServiceWorkerContainer.installing') @DocsEditable() @Experimental() _ServiceWorker get installing {}   @DomName('ServiceWorkerContainer.ready') @DocsEditable() @Experimental() Future get ready {}   @DomName('ServiceWorkerContainer.waiting') @DocsEditable() @Experimental() _ServiceWorker get waiting {}   Future register(String url, [Map options]) {}   Future unregister([String scope]) {} } @DocsEditable() @DomName('ServiceWorkerGlobalScope') @Experimental() class ServiceWorkerGlobalScope extends WorkerGlobalScope { factory ServiceWorkerGlobalScope._() { throw new UnsupportedError("new ServiceWorkerGlobalScope._() is unsupported on this platform."); }   static const messageEvent = const EventStreamProvider<MessageEvent>('message');   @DomName('ServiceWorkerGlobalScope.clients') @DocsEditable() @Experimental() ServiceWorkerClients get clients {}   @DomName('ServiceWorkerGlobalScope.nativeCaches') @DocsEditable() @Experimental() CacheStorage get nativeCaches {}   @DomName('ServiceWorkerGlobalScope.scope') @DocsEditable() @Experimental() String get scope {}    @DomName('ServiceWorkerGlobalScope.onmessage') @DocsEditable() @Experimental() Stream<MessageEvent> get onMessage {} } @DocsEditable() @DomName('ServiceWorkerRegistration') @Experimental() class ServiceWorkerRegistration extends EventTarget { factory ServiceWorkerRegistration._() { throw new UnsupportedError("new ServiceWorkerRegistration._() is unsupported on this platform."); }   @DomName('ServiceWorkerRegistration.active') @DocsEditable() @Experimental() _ServiceWorker get active {}   @DomName('ServiceWorkerRegistration.installing') @DocsEditable() @Experimental() _ServiceWorker get installing {}   @DomName('ServiceWorkerRegistration.scope') @DocsEditable() @Experimental() String get scope {}   @DomName('ServiceWorkerRegistration.waiting') @DocsEditable() @Experimental() _ServiceWorker get waiting {}   @DomName('ServiceWorkerRegistration.unregister') @DocsEditable() @Experimental() Future unregister() {} } @DocsEditable() @DomName('HTMLShadowElement') @SupportedBrowser(SupportedBrowser.CHROME, '26') @Experimental() class ShadowElement extends HtmlElement { factory ShadowElement._() { throw new UnsupportedError("new ShadowElement._() is unsupported on this platform."); }   @DomName('HTMLShadowElement.HTMLShadowElement') @DocsEditable() factory ShadowElement() { throw new UnsupportedError("new ShadowElement() is unsupported on this platform."); }   ShadowElement.created() : super.created() { throw new UnsupportedError("new ShadowElement.created() is unsupported on this platform."); }   static bool get supported { throw new UnsupportedError("ShadowElement.supported is unsupported on this platform."); }   @DomName('HTMLShadowElement.getDistributedNodes') @DocsEditable() @Experimental() List<Node> getDistributedNodes() {} } @DomName('ShadowRoot') @SupportedBrowser(SupportedBrowser.CHROME, '26') @Experimental() class ShadowRoot extends DocumentFragment { factory ShadowRoot._() { throw new UnsupportedError("new ShadowRoot._() is unsupported on this platform."); }   @DomName('ShadowRoot.activeElement') @DocsEditable() Element get activeElement {}   @DomName('ShadowRoot.host') @DocsEditable() @Experimental() Element get host {}   @DomName('ShadowRoot.innerHTML') @DocsEditable() String get innerHtml {}   @DomName('ShadowRoot.innerHTML') @DocsEditable() void set innerHtml(String value) {}   @DomName('ShadowRoot.olderShadowRoot') @DocsEditable() @Experimental() ShadowRoot get olderShadowRoot {}   @DomName('ShadowRoot.styleSheets') @DocsEditable() @Experimental() List<StyleSheet> get styleSheets {}   @DomName('ShadowRoot.cloneNode') @DocsEditable() Node clone(bool deep) {}   @DomName('ShadowRoot.elementFromPoint') @DocsEditable() Element elementFromPoint(int x, int y) {}   @DomName('ShadowRoot.getElementById') @DocsEditable() Element getElementById(String elementId) {}   @DomName('ShadowRoot.getElementsByClassName') @DocsEditable() List<Node> getElementsByClassName(String className) {}   @DomName('ShadowRoot.getElementsByTagName') @DocsEditable() List<Node> getElementsByTagName(String tagName) {}   @DomName('ShadowRoot.getSelection') @DocsEditable() Selection getSelection() {}   static bool get supported => throw new UnsupportedError("ShadowRoot.supported is unsupported on this platform.");     static void _shadowRootDeprecationReport() { throw new UnsupportedError("ShadowRoot._shadowRootDeprecationReport() is unsupported on this platform."); }   @deprecated bool get resetStyleInheritance {}   @deprecated void set resetStyleInheritance(bool value) {}   @deprecated bool get applyAuthorStyles {}   @deprecated void set applyAuthorStyles(bool value) {} } @DocsEditable() @DomName('SharedWorker') @Experimental() class SharedWorker extends EventTarget implements AbstractWorker { factory SharedWorker._() { throw new UnsupportedError("new SharedWorker._() is unsupported on this platform."); }   static const errorEvent = const EventStreamProvider<Event>('error');   @DomName('SharedWorker.SharedWorker') @DocsEditable() factory SharedWorker(String scriptURL, [String name]) { throw new UnsupportedError("new SharedWorker() is unsupported on this platform."); }   @DomName('SharedWorker.port') @DocsEditable() MessagePort get port {}   @DomName('SharedWorker.workerStart') @DocsEditable() @Experimental() double get workerStart {}   @DomName('SharedWorker.onerror') @DocsEditable() @Experimental() Stream<Event> get onError {} } @DocsEditable() @DomName('SharedWorkerGlobalScope') @Experimental() class SharedWorkerGlobalScope extends WorkerGlobalScope { factory SharedWorkerGlobalScope._() { throw new UnsupportedError("new SharedWorkerGlobalScope._() is unsupported on this platform."); }   static const connectEvent = const EventStreamProvider<Event>('connect');   @DomName('SharedWorkerGlobalScope.name') @DocsEditable() @Experimental() String get name {}   @DomName('SharedWorkerGlobalScope.onconnect') @DocsEditable() @Experimental() Stream<Event> get onConnect {} } @DocsEditable() @DomName('SourceBuffer') @Experimental() class SourceBuffer extends EventTarget { factory SourceBuffer._() { throw new UnsupportedError("new SourceBuffer._() is unsupported on this platform."); }   @DomName('SourceBuffer.appendWindowEnd') @DocsEditable() @Experimental() num get appendWindowEnd {}   @DomName('SourceBuffer.appendWindowEnd') @DocsEditable() @Experimental() void set appendWindowEnd(num value) {}   @DomName('SourceBuffer.appendWindowStart') @DocsEditable() @Experimental() num get appendWindowStart {}   @DomName('SourceBuffer.appendWindowStart') @DocsEditable() @Experimental() void set appendWindowStart(num value) {}   @DomName('SourceBuffer.buffered') @DocsEditable() TimeRanges get buffered {}   @DomName('SourceBuffer.mode') @DocsEditable() @Experimental() String get mode {}   @DomName('SourceBuffer.mode') @DocsEditable() @Experimental() void set mode(String value) {}   @DomName('SourceBuffer.timestampOffset') @DocsEditable() num get timestampOffset {}   @DomName('SourceBuffer.timestampOffset') @DocsEditable() void set timestampOffset(num value) {}   @DomName('SourceBuffer.updating') @DocsEditable() @Experimental() bool get updating {}   @DomName('SourceBuffer.abort') @DocsEditable() void abort() {}   @DomName('SourceBuffer.appendBuffer') @DocsEditable() @Experimental() void appendBuffer(ByteBuffer data) {}   void appendStream(FileStream stream, [int maxSize]) {}   @DomName('SourceBuffer.appendTypedData') @DocsEditable() @Experimental() void appendTypedData(TypedData data) {}   @DomName('SourceBuffer.remove') @DocsEditable() @Experimental() void remove(num start, num end) {} } @DocsEditable() @DomName('SourceBufferList') @Experimental() class SourceBufferList extends EventTarget with ListMixin<SourceBuffer>, ImmutableListMixin<SourceBuffer> implements List<SourceBuffer> { factory SourceBufferList._() { throw new UnsupportedError("new SourceBufferList._() is unsupported on this platform."); }   @DomName('SourceBufferList.length') @DocsEditable() int get length {}   SourceBuffer operator [](int index) {}    void operator []=(int index, SourceBuffer value) {}   void set length(int value) {}   SourceBuffer get first {}   SourceBuffer get last {}   SourceBuffer get single {}   SourceBuffer elementAt(int index) {}   @DomName('SourceBufferList.item') @DocsEditable() SourceBuffer item(int index) {} } @DocsEditable() @DomName('HTMLSourceElement') class SourceElement extends HtmlElement { factory SourceElement._() { throw new UnsupportedError("new SourceElement._() is unsupported on this platform."); }   @DomName('HTMLSourceElement.HTMLSourceElement') @DocsEditable() factory SourceElement() { throw new UnsupportedError("new SourceElement() is unsupported on this platform."); }   SourceElement.created() : super.created() { throw new UnsupportedError("new SourceElement.created() is unsupported on this platform."); }   @DomName('HTMLSourceElement.integrity') @DocsEditable() @Experimental() String get integrity {}   @DomName('HTMLSourceElement.integrity') @DocsEditable() @Experimental() void set integrity(String value) {}   @DomName('HTMLSourceElement.media') @DocsEditable() String get media {}   @DomName('HTMLSourceElement.media') @DocsEditable() void set media(String value) {}   @DomName('HTMLSourceElement.sizes') @DocsEditable() @Experimental() String get sizes {}   @DomName('HTMLSourceElement.sizes') @DocsEditable() @Experimental() void set sizes(String value) {}   @DomName('HTMLSourceElement.src') @DocsEditable() String get src {}   @DomName('HTMLSourceElement.src') @DocsEditable() void set src(String value) {}   @DomName('HTMLSourceElement.srcset') @DocsEditable() @Experimental() String get srcset {}   @DomName('HTMLSourceElement.srcset') @DocsEditable() @Experimental() void set srcset(String value) {}   @DomName('HTMLSourceElement.type') @DocsEditable() String get type {}   @DomName('HTMLSourceElement.type') @DocsEditable() void set type(String value) {} } @DocsEditable() @DomName('SourceInfo') @Experimental() class SourceInfo extends NativeFieldWrapperClass2 { factory SourceInfo._() { throw new UnsupportedError("new SourceInfo._() is unsupported on this platform."); }   @DomName('SourceInfo.facing') @DocsEditable() @Experimental() String get facing {}   @DomName('SourceInfo.id') @DocsEditable() @Experimental() String get id {}   @DomName('SourceInfo.kind') @DocsEditable() @Experimental() String get kind {}   @DomName('SourceInfo.label') @DocsEditable() @Experimental() String get label {} } @DocsEditable() @DomName('HTMLSpanElement') class SpanElement extends HtmlElement { factory SpanElement._() { throw new UnsupportedError("new SpanElement._() is unsupported on this platform."); }   @DomName('HTMLSpanElement.HTMLSpanElement') @DocsEditable() factory SpanElement() { throw new UnsupportedError("new SpanElement() is unsupported on this platform."); }   SpanElement.created() : super.created() { throw new UnsupportedError("new SpanElement.created() is unsupported on this platform."); } } @DocsEditable() @DomName('SpeechGrammar') @Experimental() class SpeechGrammar extends NativeFieldWrapperClass2 { factory SpeechGrammar._() { throw new UnsupportedError("new SpeechGrammar._() is unsupported on this platform."); }   @DomName('SpeechGrammar.SpeechGrammar') @DocsEditable() factory SpeechGrammar() { throw new UnsupportedError("new SpeechGrammar() is unsupported on this platform."); }   @DomName('SpeechGrammar.src') @DocsEditable() String get src {}   @DomName('SpeechGrammar.src') @DocsEditable() void set src(String value) {}   @DomName('SpeechGrammar.weight') @DocsEditable() num get weight {}   @DomName('SpeechGrammar.weight') @DocsEditable() void set weight(num value) {} } @DocsEditable() @DomName('SpeechGrammarList') @Experimental() class SpeechGrammarList extends NativeFieldWrapperClass2 with ListMixin<SpeechGrammar>, ImmutableListMixin<SpeechGrammar> implements List<SpeechGrammar> { factory SpeechGrammarList._() { throw new UnsupportedError("new SpeechGrammarList._() is unsupported on this platform."); }   @DomName('SpeechGrammarList.SpeechGrammarList') @DocsEditable() factory SpeechGrammarList() { throw new UnsupportedError("new SpeechGrammarList() is unsupported on this platform."); }   @DomName('SpeechGrammarList.length') @DocsEditable() int get length {}   SpeechGrammar operator [](int index) {}    void operator []=(int index, SpeechGrammar value) {}   void set length(int value) {}   SpeechGrammar get first {}   SpeechGrammar get last {}   SpeechGrammar get single {}   SpeechGrammar elementAt(int index) {}   void addFromString(String string, [num weight]) {}   void addFromUri(String src, [num weight]) {}   @DomName('SpeechGrammarList.item') @DocsEditable() SpeechGrammar item(int index) {} } @DocsEditable() @DomName('SpeechRecognition') @SupportedBrowser(SupportedBrowser.CHROME, '25') @Experimental() class SpeechRecognition extends EventTarget { factory SpeechRecognition._() { throw new UnsupportedError("new SpeechRecognition._() is unsupported on this platform."); }   static const audioEndEvent = const EventStreamProvider<Event>('audioend');   static const audioStartEvent = const EventStreamProvider<Event>('audiostart');   static const endEvent = const EventStreamProvider<Event>('end');   static const errorEvent = const EventStreamProvider<SpeechRecognitionError>('error');   static const noMatchEvent = const EventStreamProvider<SpeechRecognitionEvent>('nomatch');   static const resultEvent = const EventStreamProvider<SpeechRecognitionEvent>('result');   static const soundEndEvent = const EventStreamProvider<Event>('soundend');   static const soundStartEvent = const EventStreamProvider<Event>('soundstart');   static const speechEndEvent = const EventStreamProvider<Event>('speechend');   static const speechStartEvent = const EventStreamProvider<Event>('speechstart');   static const startEvent = const EventStreamProvider<Event>('start');   @DomName('SpeechRecognition.SpeechRecognition') @DocsEditable() factory SpeechRecognition() { throw new UnsupportedError("new SpeechRecognition() is unsupported on this platform."); }   static bool get supported { throw new UnsupportedError("SpeechRecognition.supported is unsupported on this platform."); }   @DomName('SpeechRecognition.continuous') @DocsEditable() bool get continuous {}   @DomName('SpeechRecognition.continuous') @DocsEditable() void set continuous(bool value) {}   @DomName('SpeechRecognition.grammars') @DocsEditable() SpeechGrammarList get grammars {}   @DomName('SpeechRecognition.grammars') @DocsEditable() void set grammars(SpeechGrammarList value) {}   @DomName('SpeechRecognition.interimResults') @DocsEditable() bool get interimResults {}   @DomName('SpeechRecognition.interimResults') @DocsEditable() void set interimResults(bool value) {}   @DomName('SpeechRecognition.lang') @DocsEditable() String get lang {}   @DomName('SpeechRecognition.lang') @DocsEditable() void set lang(String value) {}   @DomName('SpeechRecognition.maxAlternatives') @DocsEditable() int get maxAlternatives {}   @DomName('SpeechRecognition.maxAlternatives') @DocsEditable() void set maxAlternatives(int value) {}   @DomName('SpeechRecognition.abort') @DocsEditable() void abort() {}   @DomName('SpeechRecognition.start') @DocsEditable() void start() {}   @DomName('SpeechRecognition.stop') @DocsEditable() void stop() {}   @DomName('SpeechRecognition.onaudioend') @DocsEditable() Stream<Event> get onAudioEnd {}   @DomName('SpeechRecognition.onaudiostart') @DocsEditable() Stream<Event> get onAudioStart {}   @DomName('SpeechRecognition.onend') @DocsEditable() Stream<Event> get onEnd {}   @DomName('SpeechRecognition.onerror') @DocsEditable() Stream<SpeechRecognitionError> get onError {}   @DomName('SpeechRecognition.onnomatch') @DocsEditable() Stream<SpeechRecognitionEvent> get onNoMatch {}   @DomName('SpeechRecognition.onresult') @DocsEditable() Stream<SpeechRecognitionEvent> get onResult {}   @DomName('SpeechRecognition.onsoundend') @DocsEditable() Stream<Event> get onSoundEnd {}   @DomName('SpeechRecognition.onsoundstart') @DocsEditable() Stream<Event> get onSoundStart {}   @DomName('SpeechRecognition.onspeechend') @DocsEditable() Stream<Event> get onSpeechEnd {}   @DomName('SpeechRecognition.onspeechstart') @DocsEditable() Stream<Event> get onSpeechStart {}   @DomName('SpeechRecognition.onstart') @DocsEditable() Stream<Event> get onStart {} } @DocsEditable() @DomName('SpeechRecognitionAlternative') @SupportedBrowser(SupportedBrowser.CHROME, '25') @Experimental() class SpeechRecognitionAlternative extends NativeFieldWrapperClass2 { factory SpeechRecognitionAlternative._() { throw new UnsupportedError("new SpeechRecognitionAlternative._() is unsupported on this platform."); }   @DomName('SpeechRecognitionAlternative.confidence') @DocsEditable() double get confidence {}   @DomName('SpeechRecognitionAlternative.transcript') @DocsEditable() String get transcript {} } @DocsEditable() @DomName('SpeechRecognitionError') @SupportedBrowser(SupportedBrowser.CHROME, '25') @Experimental() class SpeechRecognitionError extends Event { factory SpeechRecognitionError._() { throw new UnsupportedError("new SpeechRecognitionError._() is unsupported on this platform."); }   @DomName('SpeechRecognitionError.error') @DocsEditable() String get error {}   @DomName('SpeechRecognitionError.message') @DocsEditable() String get message {} } @DocsEditable() @DomName('SpeechRecognitionEvent') @SupportedBrowser(SupportedBrowser.CHROME, '25') @Experimental() class SpeechRecognitionEvent extends Event { factory SpeechRecognitionEvent._() { throw new UnsupportedError("new SpeechRecognitionEvent._() is unsupported on this platform."); }   @DomName('SpeechRecognitionEvent.emma') @DocsEditable() Document get emma {}   @DomName('SpeechRecognitionEvent.interpretation') @DocsEditable() Document get interpretation {}   @DomName('SpeechRecognitionEvent.resultIndex') @DocsEditable() int get resultIndex {}   @DomName('SpeechRecognitionEvent.results') @DocsEditable() List<SpeechRecognitionResult> get results {} } @DocsEditable() @DomName('SpeechRecognitionResult') @SupportedBrowser(SupportedBrowser.CHROME, '25') @Experimental() class SpeechRecognitionResult extends NativeFieldWrapperClass2 { factory SpeechRecognitionResult._() { throw new UnsupportedError("new SpeechRecognitionResult._() is unsupported on this platform."); }   @DomName('SpeechRecognitionResult.isFinal') @DocsEditable() bool get isFinal {}   @DomName('SpeechRecognitionResult.length') @DocsEditable() int get length {}   @DomName('SpeechRecognitionResult.item') @DocsEditable() SpeechRecognitionAlternative item(int index) {} } @DocsEditable() @DomName('SpeechSynthesis') @Experimental() class SpeechSynthesis extends EventTarget { factory SpeechSynthesis._() { throw new UnsupportedError("new SpeechSynthesis._() is unsupported on this platform."); }   @DomName('SpeechSynthesis.paused') @DocsEditable() bool get paused {}   @DomName('SpeechSynthesis.pending') @DocsEditable() bool get pending {}   @DomName('SpeechSynthesis.speaking') @DocsEditable() bool get speaking {}   @DomName('SpeechSynthesis.cancel') @DocsEditable() void cancel() {}   @DomName('SpeechSynthesis.getVoices') @DocsEditable() List<SpeechSynthesisVoice> getVoices() {}   @DomName('SpeechSynthesis.pause') @DocsEditable() void pause() {}   @DomName('SpeechSynthesis.resume') @DocsEditable() void resume() {}   @DomName('SpeechSynthesis.speak') @DocsEditable() void speak(SpeechSynthesisUtterance utterance) {} } @DocsEditable() @DomName('SpeechSynthesisEvent') @Experimental() class SpeechSynthesisEvent extends Event { factory SpeechSynthesisEvent._() { throw new UnsupportedError("new SpeechSynthesisEvent._() is unsupported on this platform."); }   @DomName('SpeechSynthesisEvent.charIndex') @DocsEditable() int get charIndex {}   @DomName('SpeechSynthesisEvent.elapsedTime') @DocsEditable() double get elapsedTime {}   @DomName('SpeechSynthesisEvent.name') @DocsEditable() String get name {} } @DocsEditable() @DomName('SpeechSynthesisUtterance') @Experimental() class SpeechSynthesisUtterance extends EventTarget { factory SpeechSynthesisUtterance._() { throw new UnsupportedError("new SpeechSynthesisUtterance._() is unsupported on this platform."); }   static const boundaryEvent = const EventStreamProvider<SpeechSynthesisEvent>('boundary');   static const endEvent = const EventStreamProvider<SpeechSynthesisEvent>('end');   static const errorEvent = const EventStreamProvider<Event>('error');   static const markEvent = const EventStreamProvider<SpeechSynthesisEvent>('mark');   static const pauseEvent = const EventStreamProvider<Event>('pause');   static const resumeEvent = const EventStreamProvider<SpeechSynthesisEvent>('resume');   static const startEvent = const EventStreamProvider<SpeechSynthesisEvent>('start');   @DomName('SpeechSynthesisUtterance.SpeechSynthesisUtterance') @DocsEditable() factory SpeechSynthesisUtterance([String text]) { throw new UnsupportedError("new SpeechSynthesisUtterance() is unsupported on this platform."); }   @DomName('SpeechSynthesisUtterance.lang') @DocsEditable() String get lang {}   @DomName('SpeechSynthesisUtterance.lang') @DocsEditable() void set lang(String value) {}   @DomName('SpeechSynthesisUtterance.pitch') @DocsEditable() num get pitch {}   @DomName('SpeechSynthesisUtterance.pitch') @DocsEditable() void set pitch(num value) {}   @DomName('SpeechSynthesisUtterance.rate') @DocsEditable() num get rate {}   @DomName('SpeechSynthesisUtterance.rate') @DocsEditable() void set rate(num value) {}   @DomName('SpeechSynthesisUtterance.text') @DocsEditable() String get text {}   @DomName('SpeechSynthesisUtterance.text') @DocsEditable() void set text(String value) {}   @DomName('SpeechSynthesisUtterance.voice') @DocsEditable() SpeechSynthesisVoice get voice {}   @DomName('SpeechSynthesisUtterance.voice') @DocsEditable() void set voice(SpeechSynthesisVoice value) {}   @DomName('SpeechSynthesisUtterance.volume') @DocsEditable() num get volume {}   @DomName('SpeechSynthesisUtterance.volume') @DocsEditable() void set volume(num value) {}   @DomName('SpeechSynthesisUtterance.onboundary') @DocsEditable() Stream<SpeechSynthesisEvent> get onBoundary {}   @DomName('SpeechSynthesisUtterance.onend') @DocsEditable() Stream<SpeechSynthesisEvent> get onEnd {}   @DomName('SpeechSynthesisUtterance.onerror') @DocsEditable() Stream<Event> get onError {}   @DomName('SpeechSynthesisUtterance.onmark') @DocsEditable() Stream<SpeechSynthesisEvent> get onMark {}   @DomName('SpeechSynthesisUtterance.onpause') @DocsEditable() Stream<Event> get onPause {}   @DomName('SpeechSynthesisUtterance.onresume') @DocsEditable() Stream<SpeechSynthesisEvent> get onResume {}   @DomName('SpeechSynthesisUtterance.onstart') @DocsEditable() Stream<SpeechSynthesisEvent> get onStart {} } @DocsEditable() @DomName('SpeechSynthesisVoice') @Experimental() class SpeechSynthesisVoice extends NativeFieldWrapperClass2 { factory SpeechSynthesisVoice._() { throw new UnsupportedError("new SpeechSynthesisVoice._() is unsupported on this platform."); }   @DomName('SpeechSynthesisVoice.default') @DocsEditable() bool get defaultValue {}   @DomName('SpeechSynthesisVoice.lang') @DocsEditable() String get lang {}   @DomName('SpeechSynthesisVoice.localService') @DocsEditable() bool get localService {}   @DomName('SpeechSynthesisVoice.name') @DocsEditable() String get name {}   @DomName('SpeechSynthesisVoice.voiceURI') @DocsEditable() String get voiceUri {} } @DomName('Storage') @Unstable() class Storage extends NativeFieldWrapperClass2 implements Map<String, String> { void addAll(Map<String, String> other) {}   bool containsValue(String value) {}   bool containsKey(String key) {}   String operator [](String key) {}   void operator []=(String key, String value) {}   String putIfAbsent(String key, String ifAbsent()) {}   String remove(String key) {}   void clear() {}   void forEach(void f(String key, String value)) {}   Iterable<String> get keys {}   Iterable<String> get values {}   int get length {}   bool get isEmpty {}   bool get isNotEmpty {}   factory Storage._() { throw new UnsupportedError("new Storage._() is unsupported on this platform."); }          } @DomName('StorageErrorCallback') @Experimental() typedef void StorageErrorCallback(DomError error); @DomName('StorageEvent') @Unstable() class StorageEvent extends Event { factory StorageEvent(String type, {bool canBubble : false, bool cancelable : false, String key, String oldValue, String newValue, String url, Storage storageArea}) { throw new UnsupportedError("new StorageEvent() is unsupported on this platform."); }   factory StorageEvent._() { throw new UnsupportedError("new StorageEvent._() is unsupported on this platform."); }   @DomName('StorageEvent.key') @DocsEditable() String get key {}   @DomName('StorageEvent.newValue') @DocsEditable() String get newValue {}   @DomName('StorageEvent.oldValue') @DocsEditable() String get oldValue {}   @DomName('StorageEvent.storageArea') @DocsEditable() Storage get storageArea {}   @DomName('StorageEvent.url') @DocsEditable() String get url {}  } @DocsEditable() @DomName('StorageInfo') @Experimental() class StorageInfo extends NativeFieldWrapperClass2 { factory StorageInfo._() { throw new UnsupportedError("new StorageInfo._() is unsupported on this platform."); }   @DomName('StorageInfo.quota') @DocsEditable() @Experimental() int get quota {}   @DomName('StorageInfo.usage') @DocsEditable() @Experimental() int get usage {} } @DocsEditable() @DomName('StorageQuota') @Experimental() class StorageQuota extends NativeFieldWrapperClass2 { factory StorageQuota._() { throw new UnsupportedError("new StorageQuota._() is unsupported on this platform."); }   @DomName('StorageQuota.supportedTypes') @DocsEditable() @Experimental() List<String> get supportedTypes {}   @DomName('StorageQuota.queryInfo') @DocsEditable() @Experimental() Future queryInfo(String type) {}   @DomName('StorageQuota.requestPersistentQuota') @DocsEditable() @Experimental() Future requestPersistentQuota(int newQuota) {} } @DomName('StorageQuotaCallback') @Experimental() typedef void StorageQuotaCallback(int grantedQuotaInBytes); @DomName('StorageUsageCallback') @Experimental() typedef void StorageUsageCallback(int currentUsageInBytes, int currentQuotaInBytes); @DomName('StringCallback') @Experimental() typedef void _StringCallback(String data); @DocsEditable() @DomName('HTMLStyleElement') class StyleElement extends HtmlElement { factory StyleElement._() { throw new UnsupportedError("new StyleElement._() is unsupported on this platform."); }   @DomName('HTMLStyleElement.HTMLStyleElement') @DocsEditable() factory StyleElement() { throw new UnsupportedError("new StyleElement() is unsupported on this platform."); }   StyleElement.created() : super.created() { throw new UnsupportedError("new StyleElement.created() is unsupported on this platform."); }   @DomName('HTMLStyleElement.disabled') @DocsEditable() bool get disabled {}   @DomName('HTMLStyleElement.disabled') @DocsEditable() void set disabled(bool value) {}   @DomName('HTMLStyleElement.media') @DocsEditable() String get media {}   @DomName('HTMLStyleElement.media') @DocsEditable() void set media(String value) {}   @DomName('HTMLStyleElement.sheet') @DocsEditable() StyleSheet get sheet {}   @DomName('HTMLStyleElement.type') @DocsEditable() String get type {}   @DomName('HTMLStyleElement.type') @DocsEditable() void set type(String value) {} } @DocsEditable() @DomName('StyleMedia') @Experimental() class StyleMedia extends NativeFieldWrapperClass2 { factory StyleMedia._() { throw new UnsupportedError("new StyleMedia._() is unsupported on this platform."); }   @DomName('StyleMedia.type') @DocsEditable() String get type {}   @DomName('StyleMedia.matchMedium') @DocsEditable() bool matchMedium(String mediaquery) {} } @DocsEditable() @DomName('StyleSheet') class StyleSheet extends NativeFieldWrapperClass2 { factory StyleSheet._() { throw new UnsupportedError("new StyleSheet._() is unsupported on this platform."); }   @DomName('StyleSheet.disabled') @DocsEditable() bool get disabled {}   @DomName('StyleSheet.disabled') @DocsEditable() void set disabled(bool value) {}   @DomName('StyleSheet.href') @DocsEditable() String get href {}   @DomName('StyleSheet.media') @DocsEditable() MediaList get media {}   @DomName('StyleSheet.ownerNode') @DocsEditable() Node get ownerNode {}   @DomName('StyleSheet.parentStyleSheet') @DocsEditable() StyleSheet get parentStyleSheet {}   @DomName('StyleSheet.title') @DocsEditable() String get title {}   @DomName('StyleSheet.type') @DocsEditable() String get type {} } @DocsEditable() @DomName('HTMLTableCaptionElement') class TableCaptionElement extends HtmlElement { factory TableCaptionElement._() { throw new UnsupportedError("new TableCaptionElement._() is unsupported on this platform."); }   @DomName('HTMLTableCaptionElement.HTMLTableCaptionElement') @DocsEditable() factory TableCaptionElement() { throw new UnsupportedError("new TableCaptionElement() is unsupported on this platform."); }   TableCaptionElement.created() : super.created() { throw new UnsupportedError("new TableCaptionElement.created() is unsupported on this platform."); } } @DocsEditable() @DomName('HTMLTableCellElement') class TableCellElement extends HtmlElement { factory TableCellElement._() { throw new UnsupportedError("new TableCellElement._() is unsupported on this platform."); }   @DomName('HTMLTableCellElement.HTMLTableCellElement') @DocsEditable() factory TableCellElement() { throw new UnsupportedError("new TableCellElement() is unsupported on this platform."); }   TableCellElement.created() : super.created() { throw new UnsupportedError("new TableCellElement.created() is unsupported on this platform."); }   @DomName('HTMLTableCellElement.cellIndex') @DocsEditable() int get cellIndex {}   @DomName('HTMLTableCellElement.colSpan') @DocsEditable() int get colSpan {}   @DomName('HTMLTableCellElement.colSpan') @DocsEditable() void set colSpan(int value) {}   @DomName('HTMLTableCellElement.headers') @DocsEditable() String get headers {}   @DomName('HTMLTableCellElement.headers') @DocsEditable() void set headers(String value) {}   @DomName('HTMLTableCellElement.rowSpan') @DocsEditable() int get rowSpan {}   @DomName('HTMLTableCellElement.rowSpan') @DocsEditable() void set rowSpan(int value) {} } @DocsEditable() @DomName('HTMLTableColElement') class TableColElement extends HtmlElement { factory TableColElement._() { throw new UnsupportedError("new TableColElement._() is unsupported on this platform."); }   @DomName('HTMLTableColElement.HTMLTableColElement') @DocsEditable() factory TableColElement() { throw new UnsupportedError("new TableColElement() is unsupported on this platform."); }   TableColElement.created() : super.created() { throw new UnsupportedError("new TableColElement.created() is unsupported on this platform."); }   @DomName('HTMLTableColElement.span') @DocsEditable() int get span {}   @DomName('HTMLTableColElement.span') @DocsEditable() void set span(int value) {} } @DocsEditable() @DomName('HTMLTableElement') class TableElement extends HtmlElement { @DomName('HTMLTableElement.tBodies') List<TableSectionElement> get tBodies {}   @DomName('HTMLTableElement.rows') List<TableRowElement> get rows {}   TableRowElement addRow() {}   TableCaptionElement createCaption() {}   TableSectionElement createTBody() {}   TableSectionElement createTFoot() {}   TableSectionElement createTHead() {}   TableRowElement insertRow(int index) {}   factory TableElement._() { throw new UnsupportedError("new TableElement._() is unsupported on this platform."); }   @DomName('HTMLTableElement.HTMLTableElement') @DocsEditable() factory TableElement() { throw new UnsupportedError("new TableElement() is unsupported on this platform."); }   TableElement.created() : super.created() { throw new UnsupportedError("new TableElement.created() is unsupported on this platform."); }   @DomName('HTMLTableElement.caption') @DocsEditable() TableCaptionElement get caption {}   @DomName('HTMLTableElement.caption') @DocsEditable() void set caption(TableCaptionElement value) {}     @DomName('HTMLTableElement.tFoot') @DocsEditable() TableSectionElement get tFoot {}   @DomName('HTMLTableElement.tFoot') @DocsEditable() void set tFoot(TableSectionElement value) {}   @DomName('HTMLTableElement.tHead') @DocsEditable() TableSectionElement get tHead {}   @DomName('HTMLTableElement.tHead') @DocsEditable() void set tHead(TableSectionElement value) {}       @DomName('HTMLTableElement.deleteCaption') @DocsEditable() void deleteCaption() {}   @DomName('HTMLTableElement.deleteRow') @DocsEditable() void deleteRow(int index) {}   @DomName('HTMLTableElement.deleteTFoot') @DocsEditable() void deleteTFoot() {}   @DomName('HTMLTableElement.deleteTHead') @DocsEditable() void deleteTHead() {}  } @DocsEditable() @DomName('HTMLTableRowElement') class TableRowElement extends HtmlElement { @DomName('HTMLTableRowElement.cells') List<TableCellElement> get cells {}   TableCellElement addCell() {}   TableCellElement insertCell(int index) {}   factory TableRowElement._() { throw new UnsupportedError("new TableRowElement._() is unsupported on this platform."); }   @DomName('HTMLTableRowElement.HTMLTableRowElement') @DocsEditable() factory TableRowElement() { throw new UnsupportedError("new TableRowElement() is unsupported on this platform."); }   TableRowElement.created() : super.created() { throw new UnsupportedError("new TableRowElement.created() is unsupported on this platform."); }    @DomName('HTMLTableRowElement.rowIndex') @DocsEditable() int get rowIndex {}   @DomName('HTMLTableRowElement.sectionRowIndex') @DocsEditable() int get sectionRowIndex {}   @DomName('HTMLTableRowElement.deleteCell') @DocsEditable() void deleteCell(int index) {}  } @DocsEditable() @DomName('HTMLTableSectionElement') class TableSectionElement extends HtmlElement { @DomName('HTMLTableSectionElement.rows') List<TableRowElement> get rows {}   TableRowElement addRow() {}   TableRowElement insertRow(int index) {}   factory TableSectionElement._() { throw new UnsupportedError("new TableSectionElement._() is unsupported on this platform."); }   TableSectionElement.created() : super.created() { throw new UnsupportedError("new TableSectionElement.created() is unsupported on this platform."); }    @DomName('HTMLTableSectionElement.deleteRow') @DocsEditable() void deleteRow(int index) {}  } @Experimental() @DomName('HTMLTemplateElement') @SupportedBrowser(SupportedBrowser.CHROME) @Experimental() class TemplateElement extends HtmlElement { factory TemplateElement._() { throw new UnsupportedError("new TemplateElement._() is unsupported on this platform."); }   @DomName('HTMLTemplateElement.HTMLTemplateElement') @DocsEditable() factory TemplateElement() { throw new UnsupportedError("new TemplateElement() is unsupported on this platform."); }   TemplateElement.created() : super.created() { throw new UnsupportedError("new TemplateElement.created() is unsupported on this platform."); }   static bool get supported { throw new UnsupportedError("TemplateElement.supported is unsupported on this platform."); }   @DomName('HTMLTemplateElement.content') @DocsEditable() DocumentFragment get content {}   void setInnerHtml(String html, {NodeValidator validator, NodeTreeSanitizer treeSanitizer}) {} } @DomName('Text') class Text extends CharacterData { factory Text(String data) { throw new UnsupportedError("new Text() is unsupported on this platform."); }   factory Text._() { throw new UnsupportedError("new Text._() is unsupported on this platform."); }   @DomName('Text.wholeText') @DocsEditable() String get wholeText {}   @DomName('Text.getDestinationInsertionPoints') @DocsEditable() @Experimental() List<Node> getDestinationInsertionPoints() {}   @DomName('Text.splitText') @DocsEditable() Text splitText(int offset) {} } @DocsEditable() @DomName('HTMLTextAreaElement') class TextAreaElement extends HtmlElement { factory TextAreaElement._() { throw new UnsupportedError("new TextAreaElement._() is unsupported on this platform."); }   @DomName('HTMLTextAreaElement.HTMLTextAreaElement') @DocsEditable() factory TextAreaElement() { throw new UnsupportedError("new TextAreaElement() is unsupported on this platform."); }   TextAreaElement.created() : super.created() { throw new UnsupportedError("new TextAreaElement.created() is unsupported on this platform."); }   @DomName('HTMLTextAreaElement.autofocus') @DocsEditable() bool get autofocus {}   @DomName('HTMLTextAreaElement.autofocus') @DocsEditable() void set autofocus(bool value) {}   @DomName('HTMLTextAreaElement.cols') @DocsEditable() int get cols {}   @DomName('HTMLTextAreaElement.cols') @DocsEditable() void set cols(int value) {}   @DomName('HTMLTextAreaElement.defaultValue') @DocsEditable() String get defaultValue {}   @DomName('HTMLTextAreaElement.defaultValue') @DocsEditable() void set defaultValue(String value) {}   @DomName('HTMLTextAreaElement.dirName') @DocsEditable() @Experimental() String get dirName {}   @DomName('HTMLTextAreaElement.dirName') @DocsEditable() @Experimental() void set dirName(String value) {}   @DomName('HTMLTextAreaElement.disabled') @DocsEditable() bool get disabled {}   @DomName('HTMLTextAreaElement.disabled') @DocsEditable() void set disabled(bool value) {}   @DomName('HTMLTextAreaElement.form') @DocsEditable() FormElement get form {}   @DomName('HTMLTextAreaElement.inputMode') @DocsEditable() @Experimental() String get inputMode {}   @DomName('HTMLTextAreaElement.inputMode') @DocsEditable() @Experimental() void set inputMode(String value) {}   @DomName('HTMLTextAreaElement.labels') @DocsEditable() @Unstable() List<Node> get labels {}   @DomName('HTMLTextAreaElement.maxLength') @DocsEditable() int get maxLength {}   @DomName('HTMLTextAreaElement.maxLength') @DocsEditable() void set maxLength(int value) {}   @DomName('HTMLTextAreaElement.name') @DocsEditable() String get name {}   @DomName('HTMLTextAreaElement.name') @DocsEditable() void set name(String value) {}   @DomName('HTMLTextAreaElement.placeholder') @DocsEditable() String get placeholder {}   @DomName('HTMLTextAreaElement.placeholder') @DocsEditable() void set placeholder(String value) {}   @DomName('HTMLTextAreaElement.readOnly') @DocsEditable() bool get readOnly {}   @DomName('HTMLTextAreaElement.readOnly') @DocsEditable() void set readOnly(bool value) {}   @DomName('HTMLTextAreaElement.required') @DocsEditable() bool get required {}   @DomName('HTMLTextAreaElement.required') @DocsEditable() void set required(bool value) {}   @DomName('HTMLTextAreaElement.rows') @DocsEditable() int get rows {}   @DomName('HTMLTextAreaElement.rows') @DocsEditable() void set rows(int value) {}   @DomName('HTMLTextAreaElement.selectionDirection') @DocsEditable() String get selectionDirection {}   @DomName('HTMLTextAreaElement.selectionDirection') @DocsEditable() void set selectionDirection(String value) {}   @DomName('HTMLTextAreaElement.selectionEnd') @DocsEditable() int get selectionEnd {}   @DomName('HTMLTextAreaElement.selectionEnd') @DocsEditable() void set selectionEnd(int value) {}   @DomName('HTMLTextAreaElement.selectionStart') @DocsEditable() int get selectionStart {}   @DomName('HTMLTextAreaElement.selectionStart') @DocsEditable() void set selectionStart(int value) {}   @DomName('HTMLTextAreaElement.textLength') @DocsEditable() int get textLength {}   @DomName('HTMLTextAreaElement.type') @DocsEditable() String get type {}   @DomName('HTMLTextAreaElement.validationMessage') @DocsEditable() String get validationMessage {}   @DomName('HTMLTextAreaElement.validity') @DocsEditable() ValidityState get validity {}   @DomName('HTMLTextAreaElement.value') @DocsEditable() String get value {}   @DomName('HTMLTextAreaElement.value') @DocsEditable() void set value(String value) {}   @DomName('HTMLTextAreaElement.willValidate') @DocsEditable() bool get willValidate {}   @DomName('HTMLTextAreaElement.wrap') @DocsEditable() String get wrap {}   @DomName('HTMLTextAreaElement.wrap') @DocsEditable() void set wrap(String value) {}   @DomName('HTMLTextAreaElement.checkValidity') @DocsEditable() bool checkValidity() {}   @DomName('HTMLTextAreaElement.select') @DocsEditable() void select() {}   @DomName('HTMLTextAreaElement.setCustomValidity') @DocsEditable() void setCustomValidity(String error) {}   void setRangeText(String replacement, {int start, int end, String selectionMode}) {}   void setSelectionRange(int start, int end, [String direction]) {} } @DomName('TextEvent') @Unstable() class TextEvent extends UIEvent { factory TextEvent(String type, {bool canBubble : false, bool cancelable : false, Window view, String data}) { throw new UnsupportedError("new TextEvent() is unsupported on this platform."); }   factory TextEvent._() { throw new UnsupportedError("new TextEvent._() is unsupported on this platform."); }   @DomName('TextEvent.data') @DocsEditable() String get data {}  } @DocsEditable() @DomName('TextMetrics') class TextMetrics extends NativeFieldWrapperClass2 { factory TextMetrics._() { throw new UnsupportedError("new TextMetrics._() is unsupported on this platform."); }   @DomName('TextMetrics.actualBoundingBoxAscent') @DocsEditable() @Experimental() double get actualBoundingBoxAscent {}   @DomName('TextMetrics.actualBoundingBoxDescent') @DocsEditable() @Experimental() double get actualBoundingBoxDescent {}   @DomName('TextMetrics.actualBoundingBoxLeft') @DocsEditable() @Experimental() double get actualBoundingBoxLeft {}   @DomName('TextMetrics.actualBoundingBoxRight') @DocsEditable() @Experimental() double get actualBoundingBoxRight {}   @DomName('TextMetrics.alphabeticBaseline') @DocsEditable() @Experimental() double get alphabeticBaseline {}   @DomName('TextMetrics.emHeightAscent') @DocsEditable() @Experimental() double get emHeightAscent {}   @DomName('TextMetrics.emHeightDescent') @DocsEditable() @Experimental() double get emHeightDescent {}   @DomName('TextMetrics.fontBoundingBoxAscent') @DocsEditable() @Experimental() double get fontBoundingBoxAscent {}   @DomName('TextMetrics.fontBoundingBoxDescent') @DocsEditable() @Experimental() double get fontBoundingBoxDescent {}   @DomName('TextMetrics.hangingBaseline') @DocsEditable() @Experimental() double get hangingBaseline {}   @DomName('TextMetrics.ideographicBaseline') @DocsEditable() @Experimental() double get ideographicBaseline {}   @DomName('TextMetrics.width') @DocsEditable() double get width {} } @DocsEditable() @DomName('TextTrack') @Experimental() class TextTrack extends EventTarget { factory TextTrack._() { throw new UnsupportedError("new TextTrack._() is unsupported on this platform."); }   static const cueChangeEvent = const EventStreamProvider<Event>('cuechange');   @DomName('TextTrack.activeCues') @DocsEditable() TextTrackCueList get activeCues {}   @DomName('TextTrack.cues') @DocsEditable() TextTrackCueList get cues {}   @DomName('TextTrack.id') @DocsEditable() @Experimental() String get id {}   @DomName('TextTrack.kind') @DocsEditable() String get kind {}   @DomName('TextTrack.label') @DocsEditable() String get label {}   @DomName('TextTrack.language') @DocsEditable() String get language {}   @DomName('TextTrack.mode') @DocsEditable() String get mode {}   @DomName('TextTrack.mode') @DocsEditable() void set mode(String value) {}   @DomName('TextTrack.regions') @DocsEditable() @Experimental() VttRegionList get regions {}   @DomName('TextTrack.addCue') @DocsEditable() void addCue(TextTrackCue cue) {}   @DomName('TextTrack.addRegion') @DocsEditable() @Experimental() void addRegion(VttRegion region) {}   @DomName('TextTrack.removeCue') @DocsEditable() void removeCue(TextTrackCue cue) {}   @DomName('TextTrack.removeRegion') @DocsEditable() @Experimental() void removeRegion(VttRegion region) {}   @DomName('TextTrack.oncuechange') @DocsEditable() Stream<Event> get onCueChange {} } @DocsEditable() @DomName('TextTrackCue') @Experimental() class TextTrackCue extends EventTarget { factory TextTrackCue._() { throw new UnsupportedError("new TextTrackCue._() is unsupported on this platform."); }   static const enterEvent = const EventStreamProvider<Event>('enter');   static const exitEvent = const EventStreamProvider<Event>('exit');   @DomName('TextTrackCue.endTime') @DocsEditable() num get endTime {}   @DomName('TextTrackCue.endTime') @DocsEditable() void set endTime(num value) {}   @DomName('TextTrackCue.id') @DocsEditable() String get id {}   @DomName('TextTrackCue.id') @DocsEditable() void set id(String value) {}   @DomName('TextTrackCue.pauseOnExit') @DocsEditable() bool get pauseOnExit {}   @DomName('TextTrackCue.pauseOnExit') @DocsEditable() void set pauseOnExit(bool value) {}   @DomName('TextTrackCue.startTime') @DocsEditable() num get startTime {}   @DomName('TextTrackCue.startTime') @DocsEditable() void set startTime(num value) {}   @DomName('TextTrackCue.track') @DocsEditable() TextTrack get track {}   @DomName('TextTrackCue.onenter') @DocsEditable() Stream<Event> get onEnter {}   @DomName('TextTrackCue.onexit') @DocsEditable() Stream<Event> get onExit {} } @DocsEditable() @DomName('TextTrackCueList') @Experimental() class TextTrackCueList extends NativeFieldWrapperClass2 with ListMixin<TextTrackCue>, ImmutableListMixin<TextTrackCue> implements List<TextTrackCue> { factory TextTrackCueList._() { throw new UnsupportedError("new TextTrackCueList._() is unsupported on this platform."); }   @DomName('TextTrackCueList.length') @DocsEditable() int get length {}   TextTrackCue operator [](int index) {}    void operator []=(int index, TextTrackCue value) {}   void set length(int value) {}   TextTrackCue get first {}   TextTrackCue get last {}   TextTrackCue get single {}   TextTrackCue elementAt(int index) {}   @DomName('TextTrackCueList.getCueById') @DocsEditable() TextTrackCue getCueById(String id) {}   @DomName('TextTrackCueList.item') @DocsEditable() TextTrackCue item(int index) {} } @DocsEditable() @DomName('TextTrackList') @Experimental() class TextTrackList extends EventTarget with ListMixin<TextTrack>, ImmutableListMixin<TextTrack> implements List<TextTrack> { factory TextTrackList._() { throw new UnsupportedError("new TextTrackList._() is unsupported on this platform."); }   static const addTrackEvent = const EventStreamProvider<TrackEvent>('addtrack');   static const changeEvent = const EventStreamProvider<Event>('change');   @DomName('TextTrackList.length') @DocsEditable() int get length {}   TextTrack operator [](int index) {}    void operator []=(int index, TextTrack value) {}   void set length(int value) {}   TextTrack get first {}   TextTrack get last {}   TextTrack get single {}   TextTrack elementAt(int index) {}   @DomName('TextTrackList.getTrackById') @DocsEditable() @Experimental() TextTrack getTrackById(String id) {}   @DomName('TextTrackList.item') @DocsEditable() TextTrack item(int index) {}   @DomName('TextTrackList.onaddtrack') @DocsEditable() Stream<TrackEvent> get onAddTrack {}   @DomName('TextTrackList.onchange') @DocsEditable() @Experimental() Stream<Event> get onChange {} } @DocsEditable() @DomName('TimeRanges') @Unstable() class TimeRanges extends NativeFieldWrapperClass2 { factory TimeRanges._() { throw new UnsupportedError("new TimeRanges._() is unsupported on this platform."); }   @DomName('TimeRanges.length') @DocsEditable() int get length {}   @DomName('TimeRanges.end') @DocsEditable() double end(int index) {}   @DomName('TimeRanges.start') @DocsEditable() double start(int index) {} } @DomName('TimeoutHandler') typedef void TimeoutHandler(); @DocsEditable() @DomName('Timing') @Experimental() class Timing extends NativeFieldWrapperClass2 { factory Timing._() { throw new UnsupportedError("new Timing._() is unsupported on this platform."); }   @DomName('Timing.delay') @DocsEditable() @Experimental() num get delay {}   @DomName('Timing.delay') @DocsEditable() @Experimental() void set delay(num value) {}   @DomName('Timing.direction') @DocsEditable() @Experimental() String get direction {}   @DomName('Timing.direction') @DocsEditable() @Experimental() void set direction(String value) {}   @DomName('Timing.easing') @DocsEditable() @Experimental() String get easing {}   @DomName('Timing.easing') @DocsEditable() @Experimental() void set easing(String value) {}   @DomName('Timing.endDelay') @DocsEditable() @Experimental() num get endDelay {}   @DomName('Timing.endDelay') @DocsEditable() @Experimental() void set endDelay(num value) {}   @DomName('Timing.fill') @DocsEditable() @Experimental() String get fill {}   @DomName('Timing.fill') @DocsEditable() @Experimental() void set fill(String value) {}   @DomName('Timing.iterationStart') @DocsEditable() @Experimental() num get iterationStart {}   @DomName('Timing.iterationStart') @DocsEditable() @Experimental() void set iterationStart(num value) {}   @DomName('Timing.iterations') @DocsEditable() @Experimental() num get iterations {}   @DomName('Timing.iterations') @DocsEditable() @Experimental() void set iterations(num value) {}   @DomName('Timing.playbackRate') @DocsEditable() @Experimental() num get playbackRate {}   @DomName('Timing.playbackRate') @DocsEditable() @Experimental() void set playbackRate(num value) {}   } @DocsEditable() @DomName('HTMLTitleElement') class TitleElement extends HtmlElement { factory TitleElement._() { throw new UnsupportedError("new TitleElement._() is unsupported on this platform."); }   @DomName('HTMLTitleElement.HTMLTitleElement') @DocsEditable() factory TitleElement() { throw new UnsupportedError("new TitleElement() is unsupported on this platform."); }   TitleElement.created() : super.created() { throw new UnsupportedError("new TitleElement.created() is unsupported on this platform."); } } @DocsEditable() @DomName('Touch') @Experimental() class Touch extends NativeFieldWrapperClass2 { factory Touch._() { throw new UnsupportedError("new Touch._() is unsupported on this platform."); }     @DomName('Touch.force') @DocsEditable() @Experimental() double get force {}   @DomName('Touch.identifier') @DocsEditable() int get identifier {}         @DomName('Touch.target') @DocsEditable() EventTarget get target {}   @DomName('Touch.webkitRotationAngle') @DocsEditable() @SupportedBrowser(SupportedBrowser.CHROME) @SupportedBrowser(SupportedBrowser.SAFARI) @Experimental() double get rotationAngle {}           @DomName('Touch.clientX') @DomName('Touch.clientY') Point get client {}   @DomName('Touch.pageX') @DomName('Touch.pageY') Point get page {}   @DomName('Touch.screenX') @DomName('Touch.screenY') Point get screen {}   @DomName('Touch.radiusX') @DocsEditable() @SupportedBrowser(SupportedBrowser.CHROME) @SupportedBrowser(SupportedBrowser.SAFARI) @Experimental() int get radiusX {}   @DomName('Touch.radiusY') @DocsEditable() @SupportedBrowser(SupportedBrowser.CHROME) @SupportedBrowser(SupportedBrowser.SAFARI) @Experimental() int get radiusY {} } @DomName('TouchEvent') @Experimental() class TouchEvent extends UIEvent { factory TouchEvent(TouchList touches, TouchList targetTouches, TouchList changedTouches, String type, {Window view, int screenX : 0, int screenY : 0, int clientX : 0, int clientY : 0, bool ctrlKey : false, bool altKey : false, bool shiftKey : false, bool metaKey : false}) { throw new UnsupportedError("new TouchEvent() is unsupported on this platform."); }   factory TouchEvent._() { throw new UnsupportedError("new TouchEvent._() is unsupported on this platform."); }   @DomName('TouchEvent.altKey') @DocsEditable() bool get altKey {}   @DomName('TouchEvent.changedTouches') @DocsEditable() TouchList get changedTouches {}   @DomName('TouchEvent.ctrlKey') @DocsEditable() bool get ctrlKey {}   @DomName('TouchEvent.metaKey') @DocsEditable() bool get metaKey {}   @DomName('TouchEvent.shiftKey') @DocsEditable() bool get shiftKey {}   @DomName('TouchEvent.targetTouches') @DocsEditable() TouchList get targetTouches {}   @DomName('TouchEvent.touches') @DocsEditable() TouchList get touches {}    static bool get supported { throw new UnsupportedError("TouchEvent.supported is unsupported on this platform."); } } @DomName('TouchList') @Experimental() class TouchList extends NativeFieldWrapperClass2 with ListMixin<Touch>, ImmutableListMixin<Touch> implements List<Touch> { factory TouchList() { throw new UnsupportedError("new TouchList() is unsupported on this platform."); }   factory TouchList._() { throw new UnsupportedError("new TouchList._() is unsupported on this platform."); }   static bool get supported { throw new UnsupportedError("TouchList.supported is unsupported on this platform."); }   @DomName('TouchList.length') @DocsEditable() int get length {}   Touch operator [](int index) {}    void operator []=(int index, Touch value) {}   void set length(int value) {}   Touch get first {}   Touch get last {}   Touch get single {}   Touch elementAt(int index) {}   @DomName('TouchList.item') @DocsEditable() Touch item(int index) {} } @DocsEditable() @DomName('HTMLTrackElement') @SupportedBrowser(SupportedBrowser.CHROME) @SupportedBrowser(SupportedBrowser.IE, '10') @SupportedBrowser(SupportedBrowser.SAFARI) @Experimental() class TrackElement extends HtmlElement { factory TrackElement._() { throw new UnsupportedError("new TrackElement._() is unsupported on this platform."); }   @DomName('HTMLTrackElement.HTMLTrackElement') @DocsEditable() factory TrackElement() { throw new UnsupportedError("new TrackElement() is unsupported on this platform."); }   TrackElement.created() : super.created() { throw new UnsupportedError("new TrackElement.created() is unsupported on this platform."); }   static bool get supported { throw new UnsupportedError("TrackElement.supported is unsupported on this platform."); }   static const ERROR = 3;   static const LOADED = 2;   static const LOADING = 1;   static const NONE = 0;   @DomName('HTMLTrackElement.default') @DocsEditable() bool get defaultValue {}   @DomName('HTMLTrackElement.default') @DocsEditable() void set defaultValue(bool value) {}   @DomName('HTMLTrackElement.integrity') @DocsEditable() @Experimental() String get integrity {}   @DomName('HTMLTrackElement.integrity') @DocsEditable() @Experimental() void set integrity(String value) {}   @DomName('HTMLTrackElement.kind') @DocsEditable() String get kind {}   @DomName('HTMLTrackElement.kind') @DocsEditable() void set kind(String value) {}   @DomName('HTMLTrackElement.label') @DocsEditable() String get label {}   @DomName('HTMLTrackElement.label') @DocsEditable() void set label(String value) {}   @DomName('HTMLTrackElement.readyState') @DocsEditable() int get readyState {}   @DomName('HTMLTrackElement.src') @DocsEditable() String get src {}   @DomName('HTMLTrackElement.src') @DocsEditable() void set src(String value) {}   @DomName('HTMLTrackElement.srclang') @DocsEditable() String get srclang {}   @DomName('HTMLTrackElement.srclang') @DocsEditable() void set srclang(String value) {}   @DomName('HTMLTrackElement.track') @DocsEditable() TextTrack get track {} } @DocsEditable() @DomName('TrackEvent') @Unstable() class TrackEvent extends Event { factory TrackEvent._() { throw new UnsupportedError("new TrackEvent._() is unsupported on this platform."); }   @DomName('TrackEvent.track') @DocsEditable() Object get track {} } @DocsEditable() @DomName('TransitionEvent') class TransitionEvent extends Event { factory TransitionEvent._() { throw new UnsupportedError("new TransitionEvent._() is unsupported on this platform."); }   @DomName('TransitionEvent.elapsedTime') @DocsEditable() double get elapsedTime {}   @DomName('TransitionEvent.propertyName') @DocsEditable() String get propertyName {}   @DomName('TransitionEvent.pseudoElement') @DocsEditable() String get pseudoElement {} } @DomName('TreeWalker') @Unstable() class TreeWalker extends NativeFieldWrapperClass2 { factory TreeWalker(Node root, int whatToShow) { throw new UnsupportedError("new TreeWalker() is unsupported on this platform."); }   factory TreeWalker._() { throw new UnsupportedError("new TreeWalker._() is unsupported on this platform."); }   @DomName('TreeWalker.currentNode') @DocsEditable() Node get currentNode {}   @DomName('TreeWalker.currentNode') @DocsEditable() void set currentNode(Node value) {}   @DomName('TreeWalker.filter') @DocsEditable() NodeFilter get filter {}   @DomName('TreeWalker.root') @DocsEditable() Node get root {}   @DomName('TreeWalker.whatToShow') @DocsEditable() int get whatToShow {}   @DomName('TreeWalker.firstChild') @DocsEditable() Node firstChild() {}   @DomName('TreeWalker.lastChild') @DocsEditable() Node lastChild() {}   @DomName('TreeWalker.nextNode') @DocsEditable() Node nextNode() {}   @DomName('TreeWalker.nextSibling') @DocsEditable() Node nextSibling() {}   @DomName('TreeWalker.parentNode') @DocsEditable() Node parentNode() {}   @DomName('TreeWalker.previousNode') @DocsEditable() Node previousNode() {}   @DomName('TreeWalker.previousSibling') @DocsEditable() Node previousSibling() {} } @DomName('UIEvent') class UIEvent extends Event { factory UIEvent(String type, {Window view, int detail : 0, bool canBubble : true, bool cancelable : true}) { throw new UnsupportedError("new UIEvent() is unsupported on this platform."); }   factory UIEvent._() { throw new UnsupportedError("new UIEvent._() is unsupported on this platform."); }    @DomName('UIEvent.detail') @DocsEditable() int get detail {}        @DomName('UIEvent.view') @DocsEditable() WindowBase get view {}   @DomName('UIEvent.which') @DocsEditable() @Unstable() int get which {}    @DomName('UIEvent.layerX') @DomName('UIEvent.layerY') Point get layer {}   @DomName('UIEvent.pageX') @DomName('UIEvent.pageY') Point get page {} } @DocsEditable() @DomName('HTMLUListElement') class UListElement extends HtmlElement { factory UListElement._() { throw new UnsupportedError("new UListElement._() is unsupported on this platform."); }   @DomName('HTMLUListElement.HTMLUListElement') @DocsEditable() factory UListElement() { throw new UnsupportedError("new UListElement() is unsupported on this platform."); }   UListElement.created() : super.created() { throw new UnsupportedError("new UListElement.created() is unsupported on this platform."); } } @DocsEditable() @DomName('HTMLUnknownElement') class UnknownElement extends HtmlElement { factory UnknownElement._() { throw new UnsupportedError("new UnknownElement._() is unsupported on this platform."); }   UnknownElement.created() : super.created() { throw new UnsupportedError("new UnknownElement.created() is unsupported on this platform."); } } @DocsEditable() @DomName('URL') class Url extends NativeFieldWrapperClass2 implements UrlUtils { factory Url._() { throw new UnsupportedError("new Url._() is unsupported on this platform."); }   static String createObjectUrl(blob_OR_source_OR_stream) { throw new UnsupportedError("Url.createObjectUrl() is unsupported on this platform."); }   @DomName('URL.createObjectUrlFromBlob') @DocsEditable() static String createObjectUrlFromBlob(Blob blob) { throw new UnsupportedError("Url.createObjectUrlFromBlob() is unsupported on this platform."); }   @DomName('URL.createObjectUrlFromSource') @DocsEditable() static String createObjectUrlFromSource(MediaSource source) { throw new UnsupportedError("Url.createObjectUrlFromSource() is unsupported on this platform."); }   @DomName('URL.createObjectUrlFromStream') @DocsEditable() static String createObjectUrlFromStream(MediaStream stream) { throw new UnsupportedError("Url.createObjectUrlFromStream() is unsupported on this platform."); }   @DomName('URL.revokeObjectURL') @DocsEditable() static void revokeObjectUrl(String url) { throw new UnsupportedError("Url.revokeObjectUrl() is unsupported on this platform."); }   @DomName('URL.hash') @DocsEditable() @Experimental() String get hash {}   @DomName('URL.hash') @DocsEditable() @Experimental() void set hash(String value) {}   @DomName('URL.host') @DocsEditable() @Experimental() String get host {}   @DomName('URL.host') @DocsEditable() @Experimental() void set host(String value) {}   @DomName('URL.hostname') @DocsEditable() @Experimental() String get hostname {}   @DomName('URL.hostname') @DocsEditable() @Experimental() void set hostname(String value) {}   @DomName('URL.href') @DocsEditable() @Experimental() String get href {}   @DomName('URL.href') @DocsEditable() @Experimental() void set href(String value) {}   @DomName('URL.origin') @DocsEditable() @Experimental() String get origin {}   @DomName('URL.password') @DocsEditable() @Experimental() String get password {}   @DomName('URL.password') @DocsEditable() @Experimental() void set password(String value) {}   @DomName('URL.pathname') @DocsEditable() @Experimental() String get pathname {}   @DomName('URL.pathname') @DocsEditable() @Experimental() void set pathname(String value) {}   @DomName('URL.port') @DocsEditable() @Experimental() String get port {}   @DomName('URL.port') @DocsEditable() @Experimental() void set port(String value) {}   @DomName('URL.protocol') @DocsEditable() @Experimental() String get protocol {}   @DomName('URL.protocol') @DocsEditable() @Experimental() void set protocol(String value) {}   @DomName('URL.search') @DocsEditable() @Experimental() String get search {}   @DomName('URL.search') @DocsEditable() @Experimental() void set search(String value) {}   @DomName('URL.username') @DocsEditable() @Experimental() String get username {}   @DomName('URL.username') @DocsEditable() @Experimental() void set username(String value) {}   @DomName('URL.toString') @DocsEditable() @Experimental() String toString() {} } @DocsEditable() @DomName('URLUtils') @Experimental() abstract class UrlUtils extends NativeFieldWrapperClass2 { factory UrlUtils._() { throw new UnsupportedError("new UrlUtils._() is unsupported on this platform."); }   @DomName('URLUtils.hash') @DocsEditable() @Experimental() String get hash;   @DomName('URLUtils.hash') @DocsEditable() @Experimental() void set hash(String value);   @DomName('URLUtils.host') @DocsEditable() @Experimental() String get host;   @DomName('URLUtils.host') @DocsEditable() @Experimental() void set host(String value);   @DomName('URLUtils.hostname') @DocsEditable() @Experimental() String get hostname;   @DomName('URLUtils.hostname') @DocsEditable() @Experimental() void set hostname(String value);   @DomName('URLUtils.href') @DocsEditable() @Experimental() String get href;   @DomName('URLUtils.href') @DocsEditable() @Experimental() void set href(String value);   @DomName('URLUtils.origin') @DocsEditable() @Experimental() String get origin;   @DomName('URLUtils.password') @DocsEditable() @Experimental() String get password;   @DomName('URLUtils.password') @DocsEditable() @Experimental() void set password(String value);   @DomName('URLUtils.pathname') @DocsEditable() @Experimental() String get pathname;   @DomName('URLUtils.pathname') @DocsEditable() @Experimental() void set pathname(String value);   @DomName('URLUtils.port') @DocsEditable() @Experimental() String get port;   @DomName('URLUtils.port') @DocsEditable() @Experimental() void set port(String value);   @DomName('URLUtils.protocol') @DocsEditable() @Experimental() String get protocol;   @DomName('URLUtils.protocol') @DocsEditable() @Experimental() void set protocol(String value);   @DomName('URLUtils.search') @DocsEditable() @Experimental() String get search;   @DomName('URLUtils.search') @DocsEditable() @Experimental() void set search(String value);   @DomName('URLUtils.username') @DocsEditable() @Experimental() String get username;   @DomName('URLUtils.username') @DocsEditable() @Experimental() void set username(String value);   @DomName('URLUtils.toString') @DocsEditable() @Experimental() String toString(); } @DocsEditable() @DomName('URLUtilsReadOnly') @Experimental() abstract class UrlUtilsReadOnly extends NativeFieldWrapperClass2 { factory UrlUtilsReadOnly._() { throw new UnsupportedError("new UrlUtilsReadOnly._() is unsupported on this platform."); }   @DomName('URLUtilsReadOnly.hash') @DocsEditable() @Experimental() String get hash;   @DomName('URLUtilsReadOnly.host') @DocsEditable() @Experimental() String get host;   @DomName('URLUtilsReadOnly.hostname') @DocsEditable() @Experimental() String get hostname;   @DomName('URLUtilsReadOnly.href') @DocsEditable() @Experimental() String get href;   @DomName('URLUtilsReadOnly.origin') @DocsEditable() @Experimental() String get origin;   @DomName('URLUtilsReadOnly.pathname') @DocsEditable() @Experimental() String get pathname;   @DomName('URLUtilsReadOnly.port') @DocsEditable() @Experimental() String get port;   @DomName('URLUtilsReadOnly.protocol') @DocsEditable() @Experimental() String get protocol;   @DomName('URLUtilsReadOnly.search') @DocsEditable() @Experimental() String get search;   @DomName('URLUtilsReadOnly.toString') @DocsEditable() @Experimental() String toString(); } @DocsEditable() @DomName('ValidityState') class ValidityState extends NativeFieldWrapperClass2 { factory ValidityState._() { throw new UnsupportedError("new ValidityState._() is unsupported on this platform."); }   @DomName('ValidityState.badInput') @DocsEditable() bool get badInput {}   @DomName('ValidityState.customError') @DocsEditable() bool get customError {}   @DomName('ValidityState.patternMismatch') @DocsEditable() bool get patternMismatch {}   @DomName('ValidityState.rangeOverflow') @DocsEditable() bool get rangeOverflow {}   @DomName('ValidityState.rangeUnderflow') @DocsEditable() bool get rangeUnderflow {}   @DomName('ValidityState.stepMismatch') @DocsEditable() bool get stepMismatch {}   @DomName('ValidityState.tooLong') @DocsEditable() bool get tooLong {}   @DomName('ValidityState.typeMismatch') @DocsEditable() bool get typeMismatch {}   @DomName('ValidityState.valid') @DocsEditable() bool get valid {}   @DomName('ValidityState.valueMissing') @DocsEditable() bool get valueMissing {} } @DomName('HTMLVideoElement') class VideoElement extends MediaElement implements CanvasImageSource { factory VideoElement._() { throw new UnsupportedError("new VideoElement._() is unsupported on this platform."); }   @DomName('HTMLVideoElement.HTMLVideoElement') @DocsEditable() factory VideoElement() { throw new UnsupportedError("new VideoElement() is unsupported on this platform."); }   VideoElement.created() : super.created() { throw new UnsupportedError("new VideoElement.created() is unsupported on this platform."); }   @DomName('HTMLVideoElement.height') @DocsEditable() int get height {}   @DomName('HTMLVideoElement.height') @DocsEditable() void set height(int value) {}   @DomName('HTMLVideoElement.poster') @DocsEditable() String get poster {}   @DomName('HTMLVideoElement.poster') @DocsEditable() void set poster(String value) {}   @DomName('HTMLVideoElement.videoHeight') @DocsEditable() int get videoHeight {}   @DomName('HTMLVideoElement.videoWidth') @DocsEditable() int get videoWidth {}   @DomName('HTMLVideoElement.webkitDecodedFrameCount') @DocsEditable() @SupportedBrowser(SupportedBrowser.CHROME) @SupportedBrowser(SupportedBrowser.SAFARI) @Experimental() int get decodedFrameCount {}   @DomName('HTMLVideoElement.webkitDroppedFrameCount') @DocsEditable() @SupportedBrowser(SupportedBrowser.CHROME) @SupportedBrowser(SupportedBrowser.SAFARI) @Experimental() int get droppedFrameCount {}   @DomName('HTMLVideoElement.width') @DocsEditable() int get width {}   @DomName('HTMLVideoElement.width') @DocsEditable() void set width(int value) {}   @DomName('HTMLVideoElement.getVideoPlaybackQuality') @DocsEditable() @Experimental() VideoPlaybackQuality getVideoPlaybackQuality() {}   @DomName('HTMLVideoElement.webkitEnterFullscreen') @DocsEditable() @SupportedBrowser(SupportedBrowser.CHROME) @SupportedBrowser(SupportedBrowser.SAFARI) @Experimental() void enterFullscreen() {}   @DomName('HTMLVideoElement.webkitExitFullscreen') @DocsEditable() @SupportedBrowser(SupportedBrowser.CHROME) @SupportedBrowser(SupportedBrowser.SAFARI) @Experimental() void exitFullscreen() {} } @DocsEditable() @DomName('VideoPlaybackQuality') @Experimental() class VideoPlaybackQuality extends NativeFieldWrapperClass2 { factory VideoPlaybackQuality._() { throw new UnsupportedError("new VideoPlaybackQuality._() is unsupported on this platform."); }   @DomName('VideoPlaybackQuality.corruptedVideoFrames') @DocsEditable() @Experimental() int get corruptedVideoFrames {}   @DomName('VideoPlaybackQuality.creationTime') @DocsEditable() @Experimental() double get creationTime {}   @DomName('VideoPlaybackQuality.droppedVideoFrames') @DocsEditable() @Experimental() int get droppedVideoFrames {}   @DomName('VideoPlaybackQuality.totalVideoFrames') @DocsEditable() @Experimental() int get totalVideoFrames {} } @DocsEditable() @DomName('VideoTrack') @Experimental() class VideoTrack extends NativeFieldWrapperClass2 { factory VideoTrack._() { throw new UnsupportedError("new VideoTrack._() is unsupported on this platform."); }   @DomName('VideoTrack.id') @DocsEditable() @Experimental() String get id {}   @DomName('VideoTrack.kind') @DocsEditable() @Experimental() String get kind {}   @DomName('VideoTrack.label') @DocsEditable() @Experimental() String get label {}   @DomName('VideoTrack.language') @DocsEditable() @Experimental() String get language {}   @DomName('VideoTrack.selected') @DocsEditable() @Experimental() bool get selected {}   @DomName('VideoTrack.selected') @DocsEditable() @Experimental() void set selected(bool value) {} } @DocsEditable() @DomName('VideoTrackList') @Experimental() class VideoTrackList extends EventTarget { factory VideoTrackList._() { throw new UnsupportedError("new VideoTrackList._() is unsupported on this platform."); }   static const changeEvent = const EventStreamProvider<Event>('change');   @DomName('VideoTrackList.length') @DocsEditable() @Experimental() int get length {}   @DomName('VideoTrackList.selectedIndex') @DocsEditable() @Experimental() int get selectedIndex {}    @DomName('VideoTrackList.getTrackById') @DocsEditable() @Experimental() VideoTrack getTrackById(String id) {}   @DomName('VideoTrackList.onchange') @DocsEditable() @Experimental() Stream<Event> get onChange {} } @DomName('VoidCallback') @Experimental() typedef void VoidCallback(); @DocsEditable() @DomName('VTTCue') @Experimental() class VttCue extends TextTrackCue { factory VttCue._() { throw new UnsupportedError("new VttCue._() is unsupported on this platform."); }   @DomName('VTTCue.VTTCue') @DocsEditable() factory VttCue(num startTime, num endTime, String text) { throw new UnsupportedError("new VttCue() is unsupported on this platform."); }   @DomName('VTTCue.align') @DocsEditable() @Experimental() String get align {}   @DomName('VTTCue.align') @DocsEditable() @Experimental() void set align(String value) {}   @DomName('VTTCue.line') @DocsEditable() @Experimental() int get line {}   @DomName('VTTCue.line') @DocsEditable() @Experimental() void set line(int value) {}   @DomName('VTTCue.position') @DocsEditable() @Experimental() int get position {}   @DomName('VTTCue.position') @DocsEditable() @Experimental() void set position(int value) {}   @DomName('VTTCue.regionId') @DocsEditable() @Experimental() String get regionId {}   @DomName('VTTCue.regionId') @DocsEditable() @Experimental() void set regionId(String value) {}   @DomName('VTTCue.size') @DocsEditable() @Experimental() int get size {}   @DomName('VTTCue.size') @DocsEditable() @Experimental() void set size(int value) {}   @DomName('VTTCue.snapToLines') @DocsEditable() @Experimental() bool get snapToLines {}   @DomName('VTTCue.snapToLines') @DocsEditable() @Experimental() void set snapToLines(bool value) {}   @DomName('VTTCue.text') @DocsEditable() @Experimental() String get text {}   @DomName('VTTCue.text') @DocsEditable() @Experimental() void set text(String value) {}   @DomName('VTTCue.vertical') @DocsEditable() @Experimental() String get vertical {}   @DomName('VTTCue.vertical') @DocsEditable() @Experimental() void set vertical(String value) {}   @DomName('VTTCue.getCueAsHTML') @DocsEditable() @Experimental() DocumentFragment getCueAsHtml() {} } @DocsEditable() @DomName('VTTRegion') @Experimental() class VttRegion extends NativeFieldWrapperClass2 { factory VttRegion._() { throw new UnsupportedError("new VttRegion._() is unsupported on this platform."); }   @DomName('VTTRegion.VTTRegion') @DocsEditable() factory VttRegion() { throw new UnsupportedError("new VttRegion() is unsupported on this platform."); }   @DomName('VTTRegion.height') @DocsEditable() @Experimental() int get height {}   @DomName('VTTRegion.height') @DocsEditable() @Experimental() void set height(int value) {}   @DomName('VTTRegion.id') @DocsEditable() @Experimental() String get id {}   @DomName('VTTRegion.id') @DocsEditable() @Experimental() void set id(String value) {}   @DomName('VTTRegion.regionAnchorX') @DocsEditable() @Experimental() num get regionAnchorX {}   @DomName('VTTRegion.regionAnchorX') @DocsEditable() @Experimental() void set regionAnchorX(num value) {}   @DomName('VTTRegion.regionAnchorY') @DocsEditable() @Experimental() num get regionAnchorY {}   @DomName('VTTRegion.regionAnchorY') @DocsEditable() @Experimental() void set regionAnchorY(num value) {}   @DomName('VTTRegion.scroll') @DocsEditable() @Experimental() String get scroll {}   @DomName('VTTRegion.scroll') @DocsEditable() @Experimental() void set scroll(String value) {}   @DomName('VTTRegion.track') @DocsEditable() @Experimental() TextTrack get track {}   @DomName('VTTRegion.viewportAnchorX') @DocsEditable() @Experimental() num get viewportAnchorX {}   @DomName('VTTRegion.viewportAnchorX') @DocsEditable() @Experimental() void set viewportAnchorX(num value) {}   @DomName('VTTRegion.viewportAnchorY') @DocsEditable() @Experimental() num get viewportAnchorY {}   @DomName('VTTRegion.viewportAnchorY') @DocsEditable() @Experimental() void set viewportAnchorY(num value) {}   @DomName('VTTRegion.width') @DocsEditable() @Experimental() num get width {}   @DomName('VTTRegion.width') @DocsEditable() @Experimental() void set width(num value) {} } @DocsEditable() @DomName('VTTRegionList') @Experimental() class VttRegionList extends NativeFieldWrapperClass2 { factory VttRegionList._() { throw new UnsupportedError("new VttRegionList._() is unsupported on this platform."); }   @DomName('VTTRegionList.length') @DocsEditable() @Experimental() int get length {}   @DomName('VTTRegionList.getRegionById') @DocsEditable() @Experimental() VttRegion getRegionById(String id) {}   @DomName('VTTRegionList.item') @DocsEditable() @Experimental() VttRegion item(int index) {} } @DocsEditable() @DomName('WebSocket') @SupportedBrowser(SupportedBrowser.CHROME) @SupportedBrowser(SupportedBrowser.FIREFOX) @SupportedBrowser(SupportedBrowser.IE, '10') @SupportedBrowser(SupportedBrowser.SAFARI) @Unstable() class WebSocket extends EventTarget { factory WebSocket._() { throw new UnsupportedError("new WebSocket._() is unsupported on this platform."); }   static const closeEvent = const EventStreamProvider<CloseEvent>('close');   static const errorEvent = const EventStreamProvider<Event>('error');   static const messageEvent = const EventStreamProvider<MessageEvent>('message');   static const openEvent = const EventStreamProvider<Event>('open');   @DomName('WebSocket.WebSocket') @DocsEditable() factory WebSocket(String url, [protocol_OR_protocols]) { throw new UnsupportedError("new WebSocket() is unsupported on this platform."); }   static bool get supported { throw new UnsupportedError("WebSocket.supported is unsupported on this platform."); }   static const CLOSED = 3;   static const CLOSING = 2;   static const CONNECTING = 0;   static const OPEN = 1;   @DomName('WebSocket.binaryType') @DocsEditable() String get binaryType {}   @DomName('WebSocket.binaryType') @DocsEditable() void set binaryType(String value) {}   @DomName('WebSocket.bufferedAmount') @DocsEditable() int get bufferedAmount {}   @DomName('WebSocket.extensions') @DocsEditable() String get extensions {}   @DomName('WebSocket.protocol') @DocsEditable() String get protocol {}   @DomName('WebSocket.readyState') @DocsEditable() int get readyState {}   @DomName('WebSocket.url') @DocsEditable() String get url {}   void close([int code, String reason]) {}   void send(data) {}   @DomName('WebSocket.sendBlob') @DocsEditable() void sendBlob(Blob data) {}   @DomName('WebSocket.sendByteBuffer') @DocsEditable() void sendByteBuffer(ByteBuffer data) {}   @DomName('WebSocket.sendString') @DocsEditable() void sendString(String data) {}   @DomName('WebSocket.sendTypedData') @DocsEditable() void sendTypedData(TypedData data) {}   @DomName('WebSocket.onclose') @DocsEditable() Stream<CloseEvent> get onClose {}   @DomName('WebSocket.onerror') @DocsEditable() Stream<Event> get onError {}   @DomName('WebSocket.onmessage') @DocsEditable() Stream<MessageEvent> get onMessage {}   @DomName('WebSocket.onopen') @DocsEditable() Stream<Event> get onOpen {} } @DomName('WheelEvent') class WheelEvent extends MouseEvent { factory WheelEvent(String type, {Window view, int deltaX : 0, int deltaY : 0, int detail : 0, int screenX : 0, int screenY : 0, int clientX : 0, int clientY : 0, int button : 0, bool canBubble : true, bool cancelable : true, bool ctrlKey : false, bool altKey : false, bool shiftKey : false, bool metaKey : false, EventTarget relatedTarget}) { throw new UnsupportedError("new WheelEvent() is unsupported on this platform."); }   factory WheelEvent._() { throw new UnsupportedError("new WheelEvent._() is unsupported on this platform."); }   static const DOM_DELTA_LINE = 0x01;   static const DOM_DELTA_PAGE = 0x02;   static const DOM_DELTA_PIXEL = 0x00;   @DomName('WheelEvent.deltaMode') @DocsEditable() int get deltaMode {}     @DomName('WheelEvent.deltaZ') @DocsEditable() @Experimental() double get deltaZ {}   @DomName('WheelEvent.wheelDeltaX') @DocsEditable() @Experimental() int get wheelDeltaX {}   @DomName('WheelEvent.wheelDeltaY') @DocsEditable() @Experimental() int get wheelDeltaY {}   @DomName('WheelEvent.deltaX') num get deltaX {}   @DomName('WheelEvent.deltaY') num get deltaY {} } @DocsEditable() @DomName('Window') class Window extends EventTarget implements WindowEventHandlers, WindowBase, GlobalEventHandlers, _WindowTimers, WindowBase64 { Future<num> get animationFrame {}   @DomName('Window.requestAnimationFrame') int requestAnimationFrame(RequestAnimationFrameCallback callback) {}   Future<FileSystem> requestFileSystem(int size, {bool persistent : false}) {}   static bool get supportsPointConversions { throw new UnsupportedError("Window.supportsPointConversions is unsupported on this platform."); }   factory Window._() { throw new UnsupportedError("new Window._() is unsupported on this platform."); }   static const contentLoadedEvent = const EventStreamProvider<Event>('DOMContentLoaded');   static const deviceMotionEvent = const EventStreamProvider<DeviceMotionEvent>('devicemotion');   static const deviceOrientationEvent = const EventStreamProvider<DeviceOrientationEvent>('deviceorientation');   static const hashChangeEvent = const EventStreamProvider<Event>('hashchange');   static const loadStartEvent = const EventStreamProvider<Event>('loadstart');   static const messageEvent = const EventStreamProvider<MessageEvent>('message');   static const offlineEvent = const EventStreamProvider<Event>('offline');   static const onlineEvent = const EventStreamProvider<Event>('online');   static const pageHideEvent = const EventStreamProvider<Event>('pagehide');   static const pageShowEvent = const EventStreamProvider<Event>('pageshow');   static const popStateEvent = const EventStreamProvider<PopStateEvent>('popstate');   static const progressEvent = const EventStreamProvider<Event>('progress');   static const storageEvent = const EventStreamProvider<StorageEvent>('storage');   static const unloadEvent = const EventStreamProvider<Event>('unload');   static const animationEndEvent = const EventStreamProvider<AnimationEvent>('webkitAnimationEnd');   static const animationIterationEvent = const EventStreamProvider<AnimationEvent>('webkitAnimationIteration');   static const animationStartEvent = const EventStreamProvider<AnimationEvent>('webkitAnimationStart');   static const PERSISTENT = 1;   static const TEMPORARY = 0;   @DomName('Window.CSS') @DocsEditable() Css get css {}   @DomName('Window.applicationCache') @DocsEditable() ApplicationCache get applicationCache {}   @DomName('Window.closed') @DocsEditable() bool get closed {}   @DomName('Window.console') @DocsEditable() Console get console {}   @DomName('Window.crypto') @DocsEditable() @Experimental() Crypto get crypto {}   @DomName('Window.defaultStatus') @DocsEditable() @Experimental() String get defaultStatus {}   @DomName('Window.defaultStatus') @DocsEditable() @Experimental() void set defaultStatus(String value) {}   @DomName('Window.defaultstatus') @DocsEditable() @Experimental() String get defaultstatus {}   @DomName('Window.defaultstatus') @DocsEditable() @Experimental() void set defaultstatus(String value) {}   @DomName('Window.devicePixelRatio') @DocsEditable() @Experimental() double get devicePixelRatio {}   @DomName('Window.document') @DocsEditable() Document get document {}   @DomName('Window.history') @DocsEditable() History get history {}   @DomName('Window.indexedDB') @DocsEditable() @SupportedBrowser(SupportedBrowser.CHROME) @SupportedBrowser(SupportedBrowser.FIREFOX, '15') @SupportedBrowser(SupportedBrowser.IE, '10') @Experimental() IdbFactory get indexedDB {}   @DomName('Window.innerHeight') @DocsEditable() int get innerHeight {}   @DomName('Window.innerWidth') @DocsEditable() int get innerWidth {}   @DomName('Window.localStorage') @DocsEditable() Storage get localStorage {}   @DomName('Window.location') @DocsEditable() Location get location {}   @DomName('Window.locationbar') @DocsEditable() BarProp get locationbar {}   @DomName('Window.menubar') @DocsEditable() BarProp get menubar {}   @DomName('Window.name') @DocsEditable() String get name {}   @DomName('Window.name') @DocsEditable() void set name(String value) {}   @DomName('Window.navigator') @DocsEditable() Navigator get navigator {}   @DomName('Window.offscreenBuffering') @DocsEditable() @Experimental() bool get offscreenBuffering {}   @DomName('Window.opener') @DocsEditable() WindowBase get opener {}   @DomName('Window.opener') @DocsEditable() void set opener(Window value) {}   @DomName('Window.orientation') @DocsEditable() @Experimental() int get orientation {}   @DomName('Window.outerHeight') @DocsEditable() int get outerHeight {}   @DomName('Window.outerWidth') @DocsEditable() int get outerWidth {}   @DomName('Window.pageXOffset') @DocsEditable() int get pageXOffset {}   @DomName('Window.pageYOffset') @DocsEditable() int get pageYOffset {}   @DomName('Window.parent') @DocsEditable() WindowBase get parent {}   @DomName('Window.performance') @DocsEditable() @SupportedBrowser(SupportedBrowser.CHROME) @SupportedBrowser(SupportedBrowser.FIREFOX) @SupportedBrowser(SupportedBrowser.IE) Performance get performance {}   @DomName('Window.screen') @DocsEditable() Screen get screen {}   @DomName('Window.screenLeft') @DocsEditable() int get screenLeft {}   @DomName('Window.screenTop') @DocsEditable() int get screenTop {}   @DomName('Window.screenX') @DocsEditable() int get screenX {}   @DomName('Window.screenY') @DocsEditable() int get screenY {}   @DomName('Window.scrollX') @DocsEditable() int get scrollX {}   @DomName('Window.scrollY') @DocsEditable() int get scrollY {}   @DomName('Window.scrollbars') @DocsEditable() BarProp get scrollbars {}   @DomName('Window.self') @DocsEditable() WindowBase get self {}   @DomName('Window.sessionStorage') @DocsEditable() Storage get sessionStorage {}   @DomName('Window.speechSynthesis') @DocsEditable() @Experimental() SpeechSynthesis get speechSynthesis {}   @DomName('Window.status') @DocsEditable() String get status {}   @DomName('Window.status') @DocsEditable() void set status(String value) {}   @DomName('Window.statusbar') @DocsEditable() BarProp get statusbar {}   @DomName('Window.styleMedia') @DocsEditable() @Experimental() StyleMedia get styleMedia {}   @DomName('Window.toolbar') @DocsEditable() BarProp get toolbar {}   @DomName('Window.top') @DocsEditable() WindowBase get top {}   @DomName('Window.window') @DocsEditable() WindowBase get window {}    void alert([String message]) {}   @DomName('Window.cancelAnimationFrame') @DocsEditable() void cancelAnimationFrame(int id) {}   @DomName('Window.close') @DocsEditable() void close() {}   bool confirm([String message]) {}   @DomName('Window.find') @DocsEditable() @Experimental() bool find(String string, bool caseSensitive, bool backwards, bool wrap, bool wholeWord, bool searchInFrames, bool showDialog) {}    @DomName('Window.getMatchedCSSRules') @DocsEditable() @Experimental() List<CssRule> getMatchedCssRules(Element element, String pseudoElement) {}   @DomName('Window.getSelection') @DocsEditable() Selection getSelection() {}   @DomName('Window.matchMedia') @DocsEditable() MediaQueryList matchMedia(String query) {}   @DomName('Window.moveBy') @DocsEditable() void moveBy(num x, num y) {}    @DomName('Window.open') @DocsEditable() WindowBase open(String url, String name, [String options]) {}   SqlDatabase openDatabase(String name, String version, String displayName, int estimatedSize, [DatabaseCallback creationCallback]) {}   @DomName('Window.postMessage') @DocsEditable() void postMessage(message, String targetOrigin, [List<MessagePort> transfer]) {}   @DomName('Window.print') @DocsEditable() void print() {}    @DomName('Window.resizeBy') @DocsEditable() void resizeBy(num x, num y) {}   @DomName('Window.resizeTo') @DocsEditable() void resizeTo(num width, num height) {}   void scroll(int x, int y, [Map scrollOptions]) {}   void scrollBy(int x, int y, [Map scrollOptions]) {}   void scrollTo(int x, int y, [Map scrollOptions]) {}   @DomName('Window.showModalDialog') @DocsEditable() Object showModalDialog(String url, [Object dialogArgs, String featureArgs]) {}   @DomName('Window.stop') @DocsEditable() void stop() {}      Future<Entry> resolveLocalFileSystemUrl(String url) {}   @DomName('Window.atob') @DocsEditable() String atob(String string) {}   @DomName('Window.btoa') @DocsEditable() String btoa(String string) {}       @DomName('Window.onDOMContentLoaded') @DocsEditable() Stream<Event> get onContentLoaded {}   @DomName('Window.onabort') @DocsEditable() Stream<Event> get onAbort {}   @DomName('Window.onblur') @DocsEditable() Stream<Event> get onBlur {}   @DomName('Window.oncanplay') @DocsEditable() Stream<Event> get onCanPlay {}   @DomName('Window.oncanplaythrough') @DocsEditable() Stream<Event> get onCanPlayThrough {}   @DomName('Window.onchange') @DocsEditable() Stream<Event> get onChange {}   @DomName('Window.onclick') @DocsEditable() Stream<MouseEvent> get onClick {}   @DomName('Window.oncontextmenu') @DocsEditable() Stream<MouseEvent> get onContextMenu {}   @DomName('Window.ondblclick') @DocsEditable() Stream<Event> get onDoubleClick {}   @DomName('Window.ondevicemotion') @DocsEditable() @Experimental() Stream<DeviceMotionEvent> get onDeviceMotion {}   @DomName('Window.ondeviceorientation') @DocsEditable() @Experimental() Stream<DeviceOrientationEvent> get onDeviceOrientation {}   @DomName('Window.ondrag') @DocsEditable() Stream<MouseEvent> get onDrag {}   @DomName('Window.ondragend') @DocsEditable() Stream<MouseEvent> get onDragEnd {}   @DomName('Window.ondragenter') @DocsEditable() Stream<MouseEvent> get onDragEnter {}   @DomName('Window.ondragleave') @DocsEditable() Stream<MouseEvent> get onDragLeave {}   @DomName('Window.ondragover') @DocsEditable() Stream<MouseEvent> get onDragOver {}   @DomName('Window.ondragstart') @DocsEditable() Stream<MouseEvent> get onDragStart {}   @DomName('Window.ondrop') @DocsEditable() Stream<MouseEvent> get onDrop {}   @DomName('Window.ondurationchange') @DocsEditable() Stream<Event> get onDurationChange {}   @DomName('Window.onemptied') @DocsEditable() Stream<Event> get onEmptied {}   @DomName('Window.onended') @DocsEditable() Stream<Event> get onEnded {}   @DomName('Window.onerror') @DocsEditable() Stream<Event> get onError {}   @DomName('Window.onfocus') @DocsEditable() Stream<Event> get onFocus {}   @DomName('Window.onhashchange') @DocsEditable() Stream<Event> get onHashChange {}   @DomName('Window.oninput') @DocsEditable() Stream<Event> get onInput {}   @DomName('Window.oninvalid') @DocsEditable() Stream<Event> get onInvalid {}   @DomName('Window.onkeydown') @DocsEditable() Stream<KeyboardEvent> get onKeyDown {}   @DomName('Window.onkeypress') @DocsEditable() Stream<KeyboardEvent> get onKeyPress {}   @DomName('Window.onkeyup') @DocsEditable() Stream<KeyboardEvent> get onKeyUp {}   @DomName('Window.onload') @DocsEditable() Stream<Event> get onLoad {}   @DomName('Window.onloadeddata') @DocsEditable() Stream<Event> get onLoadedData {}   @DomName('Window.onloadedmetadata') @DocsEditable() Stream<Event> get onLoadedMetadata {}   @DomName('Window.onloadstart') @DocsEditable() Stream<Event> get onLoadStart {}   @DomName('Window.onmessage') @DocsEditable() Stream<MessageEvent> get onMessage {}   @DomName('Window.onmousedown') @DocsEditable() Stream<MouseEvent> get onMouseDown {}   @DomName('Window.onmouseenter') @DocsEditable() @Experimental() Stream<MouseEvent> get onMouseEnter {}   @DomName('Window.onmouseleave') @DocsEditable() @Experimental() Stream<MouseEvent> get onMouseLeave {}   @DomName('Window.onmousemove') @DocsEditable() Stream<MouseEvent> get onMouseMove {}   @DomName('Window.onmouseout') @DocsEditable() Stream<MouseEvent> get onMouseOut {}   @DomName('Window.onmouseover') @DocsEditable() Stream<MouseEvent> get onMouseOver {}   @DomName('Window.onmouseup') @DocsEditable() Stream<MouseEvent> get onMouseUp {}   @DomName('Window.onmousewheel') @DocsEditable() Stream<WheelEvent> get onMouseWheel {}   @DomName('Window.onoffline') @DocsEditable() Stream<Event> get onOffline {}   @DomName('Window.ononline') @DocsEditable() Stream<Event> get onOnline {}   @DomName('Window.onpagehide') @DocsEditable() Stream<Event> get onPageHide {}   @DomName('Window.onpageshow') @DocsEditable() Stream<Event> get onPageShow {}   @DomName('Window.onpause') @DocsEditable() Stream<Event> get onPause {}   @DomName('Window.onplay') @DocsEditable() Stream<Event> get onPlay {}   @DomName('Window.onplaying') @DocsEditable() Stream<Event> get onPlaying {}   @DomName('Window.onpopstate') @DocsEditable() Stream<PopStateEvent> get onPopState {}   @DomName('Window.onprogress') @DocsEditable() Stream<Event> get onProgress {}   @DomName('Window.onratechange') @DocsEditable() Stream<Event> get onRateChange {}   @DomName('Window.onreset') @DocsEditable() Stream<Event> get onReset {}   @DomName('Window.onresize') @DocsEditable() Stream<Event> get onResize {}   @DomName('Window.onscroll') @DocsEditable() Stream<Event> get onScroll {}   @DomName('Window.onsearch') @DocsEditable() @Experimental() Stream<Event> get onSearch {}   @DomName('Window.onseeked') @DocsEditable() Stream<Event> get onSeeked {}   @DomName('Window.onseeking') @DocsEditable() Stream<Event> get onSeeking {}   @DomName('Window.onselect') @DocsEditable() Stream<Event> get onSelect {}   @DomName('Window.onstalled') @DocsEditable() Stream<Event> get onStalled {}   @DomName('Window.onstorage') @DocsEditable() Stream<StorageEvent> get onStorage {}   @DomName('Window.onsubmit') @DocsEditable() Stream<Event> get onSubmit {}   @DomName('Window.onsuspend') @DocsEditable() Stream<Event> get onSuspend {}   @DomName('Window.ontimeupdate') @DocsEditable() Stream<Event> get onTimeUpdate {}   @DomName('Window.ontouchcancel') @DocsEditable() @Experimental() Stream<TouchEvent> get onTouchCancel {}   @DomName('Window.ontouchend') @DocsEditable() @Experimental() Stream<TouchEvent> get onTouchEnd {}   @DomName('Window.ontouchmove') @DocsEditable() @Experimental() Stream<TouchEvent> get onTouchMove {}   @DomName('Window.ontouchstart') @DocsEditable() @Experimental() Stream<TouchEvent> get onTouchStart {}   @DomName('Window.ontransitionend') @DocsEditable() Stream<TransitionEvent> get onTransitionEnd {}   @DomName('Window.onunload') @DocsEditable() Stream<Event> get onUnload {}   @DomName('Window.onvolumechange') @DocsEditable() Stream<Event> get onVolumeChange {}   @DomName('Window.onwaiting') @DocsEditable() Stream<Event> get onWaiting {}   @DomName('Window.onwebkitAnimationEnd') @DocsEditable() @Experimental() Stream<AnimationEvent> get onAnimationEnd {}   @DomName('Window.onwebkitAnimationIteration') @DocsEditable() @Experimental() Stream<AnimationEvent> get onAnimationIteration {}   @DomName('Window.onwebkitAnimationStart') @DocsEditable() @Experimental() Stream<AnimationEvent> get onAnimationStart {}   static const beforeUnloadEvent = const _BeforeUnloadEventStreamProvider('beforeunload');   @DomName('Window.onbeforeunload') Stream<Event> get onBeforeUnload {}   void moveTo(Point p) {} } class _BeforeUnloadEventStreamProvider implements EventStreamProvider<BeforeUnloadEvent> {   const _BeforeUnloadEventStreamProvider(String _eventType);   Stream<BeforeUnloadEvent> forTarget(EventTarget e, {bool useCapture : false}) { throw new UnsupportedError("_BeforeUnloadEventStreamProvider.forTarget() is unsupported on this platform."); }   String getEventType(EventTarget target) { throw new UnsupportedError("_BeforeUnloadEventStreamProvider.getEventType() is unsupported on this platform."); }   ElementStream<BeforeUnloadEvent> forElement(Element e, {bool useCapture : false}) { throw new UnsupportedError("_BeforeUnloadEventStreamProvider.forElement() is unsupported on this platform."); }  } @DocsEditable() @DomName('WindowBase64') @Experimental() abstract class WindowBase64 extends NativeFieldWrapperClass2 { factory WindowBase64._() { throw new UnsupportedError("new WindowBase64._() is unsupported on this platform."); }   @DomName('WindowBase64.atob') @DocsEditable() @Experimental() String atob(String string);   @DomName('WindowBase64.btoa') @DocsEditable() @Experimental() String btoa(String string); } @DocsEditable() @DomName('WindowEventHandlers') @Experimental() abstract class WindowEventHandlers extends EventTarget { factory WindowEventHandlers._() { throw new UnsupportedError("new WindowEventHandlers._() is unsupported on this platform."); }   static const hashChangeEvent = const EventStreamProvider<Event>('hashchange');   static const messageEvent = const EventStreamProvider<MessageEvent>('message');   static const offlineEvent = const EventStreamProvider<Event>('offline');   static const onlineEvent = const EventStreamProvider<Event>('online');   static const popStateEvent = const EventStreamProvider<PopStateEvent>('popstate');   static const storageEvent = const EventStreamProvider<StorageEvent>('storage');   static const unloadEvent = const EventStreamProvider<Event>('unload');   @DomName('WindowEventHandlers.onhashchange') @DocsEditable() @Experimental() Stream<Event> get onHashChange {}   @DomName('WindowEventHandlers.onmessage') @DocsEditable() @Experimental() Stream<MessageEvent> get onMessage {}   @DomName('WindowEventHandlers.onoffline') @DocsEditable() @Experimental() Stream<Event> get onOffline {}   @DomName('WindowEventHandlers.ononline') @DocsEditable() @Experimental() Stream<Event> get onOnline {}   @DomName('WindowEventHandlers.onpopstate') @DocsEditable() @Experimental() Stream<PopStateEvent> get onPopState {}   @DomName('WindowEventHandlers.onstorage') @DocsEditable() @Experimental() Stream<StorageEvent> get onStorage {}   @DomName('WindowEventHandlers.onunload') @DocsEditable() @Experimental() Stream<Event> get onUnload {} } @DocsEditable() @DomName('Worker') @SupportedBrowser(SupportedBrowser.CHROME) @SupportedBrowser(SupportedBrowser.FIREFOX) @SupportedBrowser(SupportedBrowser.IE, '10') @SupportedBrowser(SupportedBrowser.SAFARI) @Experimental() class Worker extends EventTarget implements AbstractWorker { factory Worker._() { throw new UnsupportedError("new Worker._() is unsupported on this platform."); }   static const errorEvent = const EventStreamProvider<Event>('error');   static const messageEvent = const EventStreamProvider<MessageEvent>('message');   @DomName('Worker.Worker') @DocsEditable() factory Worker(String scriptUrl) { throw new UnsupportedError("new Worker() is unsupported on this platform."); }   static bool get supported { throw new UnsupportedError("Worker.supported is unsupported on this platform."); }   @DomName('Worker.postMessage') @DocsEditable() void postMessage(message, [List<MessagePort> transfer]) {}   @DomName('Worker.terminate') @DocsEditable() void terminate() {}   @DomName('Worker.onerror') @DocsEditable() @Experimental() Stream<Event> get onError {}   @DomName('Worker.onmessage') @DocsEditable() Stream<MessageEvent> get onMessage {} } @DocsEditable() @DomName('WorkerConsole') @Experimental() class WorkerConsole extends ConsoleBase { factory WorkerConsole._() { throw new UnsupportedError("new WorkerConsole._() is unsupported on this platform."); } } @DocsEditable() @DomName('WorkerGlobalScope') @Experimental() class WorkerGlobalScope extends EventTarget implements _WindowTimers, WindowBase64 { factory WorkerGlobalScope._() { throw new UnsupportedError("new WorkerGlobalScope._() is unsupported on this platform."); }   static const errorEvent = const EventStreamProvider<Event>('error');   static const PERSISTENT = 1;   static const TEMPORARY = 0;   @DomName('WorkerGlobalScope.console') @DocsEditable() @Experimental() WorkerConsole get console {}   @DomName('WorkerGlobalScope.crypto') @DocsEditable() @Experimental() Crypto get crypto {}   @DomName('WorkerGlobalScope.indexedDB') @DocsEditable() @Experimental() IdbFactory get indexedDB {}   @DomName('WorkerGlobalScope.location') @DocsEditable() @Experimental() _WorkerLocation get location {}   @DomName('WorkerGlobalScope.navigator') @DocsEditable() @Experimental() _WorkerNavigator get navigator {}   @DomName('WorkerGlobalScope.performance') @DocsEditable() @Experimental() WorkerPerformance get performance {}   @DomName('WorkerGlobalScope.self') @DocsEditable() @Experimental() WorkerGlobalScope get self {}   @DomName('WorkerGlobalScope.close') @DocsEditable() @Experimental() void close() {}   @DomName('WorkerGlobalScope.importScripts') @DocsEditable() @Experimental() void importScripts(String urls) {}   SqlDatabase openDatabase(String name, String version, String displayName, int estimatedSize, [DatabaseCallback creationCallback]) {}   _DatabaseSync openDatabaseSync(String name, String version, String displayName, int estimatedSize, [DatabaseCallback creationCallback]) {}    Future<FileSystem> webkitRequestFileSystem(int type, int size) {}   @DomName('WorkerGlobalScope.webkitRequestFileSystemSync') @DocsEditable() @SupportedBrowser(SupportedBrowser.CHROME) @SupportedBrowser(SupportedBrowser.SAFARI) @Experimental() @Experimental() _DOMFileSystemSync requestFileSystemSync(int type, int size) {}   @DomName('WorkerGlobalScope.webkitResolveLocalFileSystemSyncURL') @DocsEditable() @SupportedBrowser(SupportedBrowser.CHROME) @SupportedBrowser(SupportedBrowser.SAFARI) @Experimental() @Experimental() _EntrySync resolveLocalFileSystemSyncUrl(String url) {}    Future<Entry> webkitResolveLocalFileSystemUrl(String url) {}   @DomName('WorkerGlobalScope.atob') @DocsEditable() @Experimental() String atob(String string) {}   @DomName('WorkerGlobalScope.btoa') @DocsEditable() @Experimental() String btoa(String string) {}       @DomName('WorkerGlobalScope.onerror') @DocsEditable() @Experimental() Stream<Event> get onError {} } @DocsEditable() @DomName('WorkerPerformance') @Experimental() class WorkerPerformance extends NativeFieldWrapperClass2 { factory WorkerPerformance._() { throw new UnsupportedError("new WorkerPerformance._() is unsupported on this platform."); }   @DomName('WorkerPerformance.memory') @DocsEditable() @Experimental() MemoryInfo get memory {}   @DomName('WorkerPerformance.now') @DocsEditable() @Experimental() double now() {} } @DocsEditable() @DomName('XPathEvaluator') @deprecated class XPathEvaluator extends NativeFieldWrapperClass2 { factory XPathEvaluator._() { throw new UnsupportedError("new XPathEvaluator._() is unsupported on this platform."); }   @DomName('XPathEvaluator.XPathEvaluator') @DocsEditable() factory XPathEvaluator() { throw new UnsupportedError("new XPathEvaluator() is unsupported on this platform."); }   @DomName('XPathEvaluator.createExpression') @DocsEditable() XPathExpression createExpression(String expression, XPathNSResolver resolver) {}   @DomName('XPathEvaluator.createNSResolver') @DocsEditable() XPathNSResolver createNSResolver(Node nodeResolver) {}   @DomName('XPathEvaluator.evaluate') @DocsEditable() XPathResult evaluate(String expression, Node contextNode, XPathNSResolver resolver, int type, XPathResult inResult) {} } @DocsEditable() @DomName('XPathExpression') @deprecated class XPathExpression extends NativeFieldWrapperClass2 { factory XPathExpression._() { throw new UnsupportedError("new XPathExpression._() is unsupported on this platform."); }   @DomName('XPathExpression.evaluate') @DocsEditable() XPathResult evaluate(Node contextNode, int type, XPathResult inResult) {} } @DocsEditable() @DomName('XPathNSResolver') @deprecated class XPathNSResolver extends NativeFieldWrapperClass2 { factory XPathNSResolver._() { throw new UnsupportedError("new XPathNSResolver._() is unsupported on this platform."); }   @DomName('XPathNSResolver.lookupNamespaceURI') @DocsEditable() String lookupNamespaceUri(String prefix) {} } @DocsEditable() @DomName('XPathResult') @deprecated class XPathResult extends NativeFieldWrapperClass2 { factory XPathResult._() { throw new UnsupportedError("new XPathResult._() is unsupported on this platform."); }   static const ANY_TYPE = 0;   static const ANY_UNORDERED_NODE_TYPE = 8;   static const BOOLEAN_TYPE = 3;   static const FIRST_ORDERED_NODE_TYPE = 9;   static const NUMBER_TYPE = 1;   static const ORDERED_NODE_ITERATOR_TYPE = 5;   static const ORDERED_NODE_SNAPSHOT_TYPE = 7;   static const STRING_TYPE = 2;   static const UNORDERED_NODE_ITERATOR_TYPE = 4;   static const UNORDERED_NODE_SNAPSHOT_TYPE = 6;   @DomName('XPathResult.booleanValue') @DocsEditable() bool get booleanValue {}   @DomName('XPathResult.invalidIteratorState') @DocsEditable() bool get invalidIteratorState {}   @DomName('XPathResult.numberValue') @DocsEditable() double get numberValue {}   @DomName('XPathResult.resultType') @DocsEditable() int get resultType {}   @DomName('XPathResult.singleNodeValue') @DocsEditable() Node get singleNodeValue {}   @DomName('XPathResult.snapshotLength') @DocsEditable() int get snapshotLength {}   @DomName('XPathResult.stringValue') @DocsEditable() String get stringValue {}   @DomName('XPathResult.iterateNext') @DocsEditable() Node iterateNext() {}   @DomName('XPathResult.snapshotItem') @DocsEditable() Node snapshotItem(int index) {} } @DocsEditable() @DomName('XMLDocument') @Experimental() class XmlDocument extends Document { factory XmlDocument._() { throw new UnsupportedError("new XmlDocument._() is unsupported on this platform."); } } @DocsEditable() @DomName('XMLSerializer') @deprecated class XmlSerializer extends NativeFieldWrapperClass2 { factory XmlSerializer._() { throw new UnsupportedError("new XmlSerializer._() is unsupported on this platform."); }   @DomName('XMLSerializer.XMLSerializer') @DocsEditable() factory XmlSerializer() { throw new UnsupportedError("new XmlSerializer() is unsupported on this platform."); }   @DomName('XMLSerializer.serializeToString') @DocsEditable() String serializeToString(Node node) {} } @DocsEditable() @DomName('XSLTProcessor') @SupportedBrowser(SupportedBrowser.CHROME) @SupportedBrowser(SupportedBrowser.FIREFOX) @SupportedBrowser(SupportedBrowser.SAFARI) @deprecated class XsltProcessor extends NativeFieldWrapperClass2 { factory XsltProcessor._() { throw new UnsupportedError("new XsltProcessor._() is unsupported on this platform."); }   @DomName('XSLTProcessor.XSLTProcessor') @DocsEditable() factory XsltProcessor() { throw new UnsupportedError("new XsltProcessor() is unsupported on this platform."); }   static bool get supported { throw new UnsupportedError("XsltProcessor.supported is unsupported on this platform."); }   @DomName('XSLTProcessor.clearParameters') @DocsEditable() void clearParameters() {}   @DomName('XSLTProcessor.getParameter') @DocsEditable() String getParameter(String namespaceURI, String localName) {}   @DomName('XSLTProcessor.importStylesheet') @DocsEditable() void importStylesheet(Node stylesheet) {}   @DomName('XSLTProcessor.removeParameter') @DocsEditable() void removeParameter(String namespaceURI, String localName) {}   @DomName('XSLTProcessor.reset') @DocsEditable() void reset() {}   @DomName('XSLTProcessor.setParameter') @DocsEditable() void setParameter(String namespaceURI, String localName, String value) {}   @DomName('XSLTProcessor.transformToDocument') @DocsEditable() Document transformToDocument(Node source) {}   @DomName('XSLTProcessor.transformToFragment') @DocsEditable() DocumentFragment transformToFragment(Node source, Document docVal) {} } @DocsEditable() @DomName('Attr') class _Attr extends Node { factory _Attr._() { throw new UnsupportedError("new _Attr._() is unsupported on this platform."); }    @DomName('Attr.name') @DocsEditable() String get name {}    @DomName('Attr.nodeValue') @DocsEditable() @Experimental() String get nodeValue {}   @DomName('Attr.textContent') @DocsEditable() @Experimental() String get text {}   @DomName('Attr.textContent') @DocsEditable() @Experimental() void set text(String value) {}   @DomName('Attr.value') @DocsEditable() String get value {}   @DomName('Attr.value') @DocsEditable() void set value(String value) {} } @DocsEditable() @DomName('CSSPrimitiveValue') @deprecated abstract class _CSSPrimitiveValue extends _CSSValue { factory _CSSPrimitiveValue._() { throw new UnsupportedError("new _CSSPrimitiveValue._() is unsupported on this platform."); } } @DocsEditable() @DomName('CSSUnknownRule') @deprecated abstract class _CSSUnknownRule extends CssRule { factory _CSSUnknownRule._() { throw new UnsupportedError("new _CSSUnknownRule._() is unsupported on this platform."); } } @DocsEditable() @DomName('CSSValue') @deprecated abstract class _CSSValue extends NativeFieldWrapperClass2 { factory _CSSValue._() { throw new UnsupportedError("new _CSSValue._() is unsupported on this platform."); } } @DocsEditable() @DomName('Cache') @Experimental() abstract class _Cache extends NativeFieldWrapperClass2 { factory _Cache._() { throw new UnsupportedError("new _Cache._() is unsupported on this platform."); } } @DocsEditable() @DomName('CanvasPathMethods') @Experimental() abstract class _CanvasPathMethods extends NativeFieldWrapperClass2 { factory _CanvasPathMethods._() { throw new UnsupportedError("new _CanvasPathMethods._() is unsupported on this platform."); } } @DocsEditable() @DomName('ClientRect') class _ClientRect extends NativeFieldWrapperClass2 implements Rectangle { String toString() {}   bool operator ==(other) {}   int get hashCode {}   Rectangle intersection(Rectangle other) {}   bool intersects(Rectangle<num> other) {}   Rectangle boundingBox(Rectangle other) {}   bool containsRectangle(Rectangle<num> another) {}   bool containsPoint(Point<num> another) {}   Point get topLeft {}   Point get topRight {}   Point get bottomRight {}   Point get bottomLeft {}   factory _ClientRect._() { throw new UnsupportedError("new _ClientRect._() is unsupported on this platform."); }   @DomName('ClientRect.bottom') @DocsEditable() double get bottom {}   @DomName('ClientRect.height') @DocsEditable() double get height {}   @DomName('ClientRect.left') @DocsEditable() double get left {}   @DomName('ClientRect.right') @DocsEditable() double get right {}   @DomName('ClientRect.top') @DocsEditable() double get top {}   @DomName('ClientRect.width') @DocsEditable() double get width {} } class _JenkinsSmiHash { static int combine(int hash, int value) { throw new UnsupportedError("_JenkinsSmiHash.combine() is unsupported on this platform."); }   static int finish(int hash) { throw new UnsupportedError("_JenkinsSmiHash.finish() is unsupported on this platform."); }   static int hash2(a, b) { throw new UnsupportedError("_JenkinsSmiHash.hash2() is unsupported on this platform."); }   static int hash4(a, b, c, d) { throw new UnsupportedError("_JenkinsSmiHash.hash4() is unsupported on this platform."); } } @DocsEditable() @DomName('ClientRectList') class _ClientRectList extends NativeFieldWrapperClass2 with ListMixin<Rectangle>, ImmutableListMixin<Rectangle> implements List<Rectangle> { factory _ClientRectList._() { throw new UnsupportedError("new _ClientRectList._() is unsupported on this platform."); }   @DomName('ClientRectList.length') @DocsEditable() int get length {}   Rectangle operator [](int index) {}    void operator []=(int index, Rectangle value) {}   void set length(int value) {}   Rectangle get first {}   Rectangle get last {}   Rectangle get single {}   Rectangle elementAt(int index) {}   @DomName('ClientRectList.item') @DocsEditable() Rectangle item(int index) {} } @DocsEditable() @DomName('Counter') @deprecated abstract class _Counter extends NativeFieldWrapperClass2 { factory _Counter._() { throw new UnsupportedError("new _Counter._() is unsupported on this platform."); } } @DocsEditable() @DomName('CSSRuleList') class _CssRuleList extends NativeFieldWrapperClass2 with ListMixin<CssRule>, ImmutableListMixin<CssRule> implements List<CssRule> { factory _CssRuleList._() { throw new UnsupportedError("new _CssRuleList._() is unsupported on this platform."); }   @DomName('CSSRuleList.length') @DocsEditable() int get length {}   CssRule operator [](int index) {}    void operator []=(int index, CssRule value) {}   void set length(int value) {}   CssRule get first {}   CssRule get last {}   CssRule get single {}   CssRule elementAt(int index) {}   @DomName('CSSRuleList.item') @DocsEditable() CssRule item(int index) {} } @DocsEditable() @DomName('CSSValueList') @deprecated class _CssValueList extends _CSSValue with ListMixin<_CSSValue>, ImmutableListMixin<_CSSValue> implements List<_CSSValue> { factory _CssValueList._() { throw new UnsupportedError("new _CssValueList._() is unsupported on this platform."); }   @DomName('CSSValueList.length') @DocsEditable() int get length {}   _CSSValue operator [](int index) {}    void operator []=(int index, _CSSValue value) {}   void set length(int value) {}   _CSSValue get first {}   _CSSValue get last {}   _CSSValue get single {}   _CSSValue elementAt(int index) {}   @DomName('CSSValueList.item') @DocsEditable() _CSSValue item(int index) {} } @DocsEditable() @DomName('DOMFileSystemSync') @SupportedBrowser(SupportedBrowser.CHROME) @Experimental() abstract class _DOMFileSystemSync extends NativeFieldWrapperClass2 { factory _DOMFileSystemSync._() { throw new UnsupportedError("new _DOMFileSystemSync._() is unsupported on this platform."); } } @DocsEditable() @DomName('DatabaseSync') @SupportedBrowser(SupportedBrowser.CHROME) @SupportedBrowser(SupportedBrowser.SAFARI) @Experimental() @deprecated abstract class _DatabaseSync extends NativeFieldWrapperClass2 { factory _DatabaseSync._() { throw new UnsupportedError("new _DatabaseSync._() is unsupported on this platform."); } } @DocsEditable() @DomName('DirectoryEntrySync') @Experimental() abstract class _DirectoryEntrySync extends _EntrySync { factory _DirectoryEntrySync._() { throw new UnsupportedError("new _DirectoryEntrySync._() is unsupported on this platform."); } } @DocsEditable() @DomName('DirectoryReaderSync') @Experimental() abstract class _DirectoryReaderSync extends NativeFieldWrapperClass2 { factory _DirectoryReaderSync._() { throw new UnsupportedError("new _DirectoryReaderSync._() is unsupported on this platform."); } } @DocsEditable() @DomName('DocumentType') @deprecated abstract class _DocumentType extends Node implements ChildNode { factory _DocumentType._() { throw new UnsupportedError("new _DocumentType._() is unsupported on this platform."); } } @DocsEditable() @DomName('WebKitPoint') @SupportedBrowser(SupportedBrowser.CHROME) @SupportedBrowser(SupportedBrowser.SAFARI) @Experimental() @Experimental() class _DomPoint extends NativeFieldWrapperClass2 { factory _DomPoint._() { throw new UnsupportedError("new _DomPoint._() is unsupported on this platform."); }   @DomName('WebKitPoint.WebKitPoint') @DocsEditable() factory _DomPoint(num x, num y) { throw new UnsupportedError("new _DomPoint() is unsupported on this platform."); }   @DocsEditable() static _DomPoint _create(x, y) { throw new UnsupportedError("_DomPoint._create() is unsupported on this platform."); }   static bool get supported { throw new UnsupportedError("_DomPoint.supported is unsupported on this platform."); }   @DomName('WebKitPoint.x') @DocsEditable() num get x {}   @DomName('WebKitPoint.x') @DocsEditable() void set x(num value) {}   @DomName('WebKitPoint.y') @DocsEditable() num get y {}   @DomName('WebKitPoint.y') @DocsEditable() void set y(num value) {} } @DocsEditable() @DomName('DOMRect') @Experimental() class _DomRect extends DomRectReadOnly { factory _DomRect._() { throw new UnsupportedError("new _DomRect._() is unsupported on this platform."); }   @DomName('DOMRect.DOMRect') @DocsEditable() factory _DomRect([num x, num y, num width, num height]) { throw new UnsupportedError("new _DomRect() is unsupported on this platform."); }   @DomName('DOMRect.height') @DocsEditable() @Experimental() num get height {}   @DomName('DOMRect.height') @DocsEditable() @Experimental() void set height(num value) {}   @DomName('DOMRect.width') @DocsEditable() @Experimental() num get width {}   @DomName('DOMRect.width') @DocsEditable() @Experimental() void set width(num value) {}   @DomName('DOMRect.x') @DocsEditable() @Experimental() num get x {}   @DomName('DOMRect.x') @DocsEditable() @Experimental() void set x(num value) {}   @DomName('DOMRect.y') @DocsEditable() @Experimental() num get y {}   @DomName('DOMRect.y') @DocsEditable() @Experimental() void set y(num value) {} } @DocsEditable() @DomName('EntrySync') @Experimental() abstract class _EntrySync extends NativeFieldWrapperClass2 { factory _EntrySync._() { throw new UnsupportedError("new _EntrySync._() is unsupported on this platform."); } } @DocsEditable() @DomName('FileEntrySync') @Experimental() abstract class _FileEntrySync extends _EntrySync { factory _FileEntrySync._() { throw new UnsupportedError("new _FileEntrySync._() is unsupported on this platform."); } } @DocsEditable() @DomName('FileReaderSync') @Experimental() abstract class _FileReaderSync extends NativeFieldWrapperClass2 { factory _FileReaderSync._() { throw new UnsupportedError("new _FileReaderSync._() is unsupported on this platform."); }   @DomName('FileReaderSync.FileReaderSync') @DocsEditable() factory _FileReaderSync() { throw new UnsupportedError("new _FileReaderSync() is unsupported on this platform."); } } @DocsEditable() @DomName('FileWriterSync') @Experimental() abstract class _FileWriterSync extends NativeFieldWrapperClass2 { factory _FileWriterSync._() { throw new UnsupportedError("new _FileWriterSync._() is unsupported on this platform."); } } @DocsEditable() @DomName('GamepadList') @Experimental() class _GamepadList extends NativeFieldWrapperClass2 with ListMixin<Gamepad>, ImmutableListMixin<Gamepad> implements List<Gamepad> { factory _GamepadList._() { throw new UnsupportedError("new _GamepadList._() is unsupported on this platform."); }   @DomName('GamepadList.length') @DocsEditable() int get length {}   Gamepad operator [](int index) {}    void operator []=(int index, Gamepad value) {}   void set length(int value) {}   Gamepad get first {}   Gamepad get last {}   Gamepad get single {}   Gamepad elementAt(int index) {}   @DomName('GamepadList.item') @DocsEditable() Gamepad item(int index) {} } @DocsEditable() @DomName('HTMLAllCollection') @deprecated abstract class _HTMLAllCollection extends NativeFieldWrapperClass2 { factory _HTMLAllCollection._() { throw new UnsupportedError("new _HTMLAllCollection._() is unsupported on this platform."); }  } @DocsEditable() @DomName('HTMLAppletElement') @deprecated abstract class _HTMLAppletElement extends HtmlElement { factory _HTMLAppletElement._() { throw new UnsupportedError("new _HTMLAppletElement._() is unsupported on this platform."); }   _HTMLAppletElement.created() : super.created() { throw new UnsupportedError("new _HTMLAppletElement.created() is unsupported on this platform."); } } @DocsEditable() @DomName('HTMLDirectoryElement') @deprecated abstract class _HTMLDirectoryElement extends HtmlElement { factory _HTMLDirectoryElement._() { throw new UnsupportedError("new _HTMLDirectoryElement._() is unsupported on this platform."); }   _HTMLDirectoryElement.created() : super.created() { throw new UnsupportedError("new _HTMLDirectoryElement.created() is unsupported on this platform."); } } @DocsEditable() @DomName('HTMLFontElement') @deprecated abstract class _HTMLFontElement extends HtmlElement { factory _HTMLFontElement._() { throw new UnsupportedError("new _HTMLFontElement._() is unsupported on this platform."); }   _HTMLFontElement.created() : super.created() { throw new UnsupportedError("new _HTMLFontElement.created() is unsupported on this platform."); } } @DocsEditable() @DomName('HTMLFrameElement') @deprecated abstract class _HTMLFrameElement extends HtmlElement { factory _HTMLFrameElement._() { throw new UnsupportedError("new _HTMLFrameElement._() is unsupported on this platform."); }   _HTMLFrameElement.created() : super.created() { throw new UnsupportedError("new _HTMLFrameElement.created() is unsupported on this platform."); } } @DocsEditable() @DomName('HTMLFrameSetElement') @deprecated abstract class _HTMLFrameSetElement extends HtmlElement implements WindowEventHandlers { factory _HTMLFrameSetElement._() { throw new UnsupportedError("new _HTMLFrameSetElement._() is unsupported on this platform."); }   _HTMLFrameSetElement.created() : super.created() { throw new UnsupportedError("new _HTMLFrameSetElement.created() is unsupported on this platform."); } } @DocsEditable() @DomName('HTMLMarqueeElement') @deprecated abstract class _HTMLMarqueeElement extends HtmlElement { factory _HTMLMarqueeElement._() { throw new UnsupportedError("new _HTMLMarqueeElement._() is unsupported on this platform."); }   _HTMLMarqueeElement.created() : super.created() { throw new UnsupportedError("new _HTMLMarqueeElement.created() is unsupported on this platform."); } } @DomName('MutationEvent') @deprecated abstract class _MutationEvent extends Event { factory _MutationEvent(String type, {bool canBubble : false, bool cancelable : false, Node relatedNode, String prevValue, String newValue, String attrName, int attrChange : 0}) { throw new UnsupportedError("new _MutationEvent() is unsupported on this platform."); }   factory _MutationEvent._() { throw new UnsupportedError("new _MutationEvent._() is unsupported on this platform."); } } @DocsEditable() @DomName('NamedNodeMap') @deprecated class _NamedNodeMap extends NativeFieldWrapperClass2 with ListMixin<Node>, ImmutableListMixin<Node> implements List<Node> { factory _NamedNodeMap._() { throw new UnsupportedError("new _NamedNodeMap._() is unsupported on this platform."); }   @DomName('NamedNodeMap.length') @DocsEditable() int get length {}   Node operator [](int index) {}    void operator []=(int index, Node value) {}   void set length(int value) {}   Node get first {}   Node get last {}   Node get single {}   Node elementAt(int index) {}    @DomName('NamedNodeMap.getNamedItem') @DocsEditable() Node getNamedItem(String name) {}   @DomName('NamedNodeMap.getNamedItemNS') @DocsEditable() Node getNamedItemNS(String namespaceURI, String localName) {}   @DomName('NamedNodeMap.item') @DocsEditable() Node item(int index) {}   @DomName('NamedNodeMap.removeNamedItem') @DocsEditable() Node removeNamedItem(String name) {}   @DomName('NamedNodeMap.removeNamedItemNS') @DocsEditable() Node removeNamedItemNS(String namespaceURI, String localName) {}   @DomName('NamedNodeMap.setNamedItem') @DocsEditable() Node setNamedItem(Node node) {}   @DomName('NamedNodeMap.setNamedItemNS') @DocsEditable() Node setNamedItemNS(Node node) {} } @DocsEditable() @DomName('Notation') @deprecated abstract class _Notation extends Node { factory _Notation._() { throw new UnsupportedError("new _Notation._() is unsupported on this platform."); } } @DocsEditable() @DomName('PagePopupController') @deprecated abstract class _PagePopupController extends NativeFieldWrapperClass2 { factory _PagePopupController._() { throw new UnsupportedError("new _PagePopupController._() is unsupported on this platform."); } } @DocsEditable() @DomName('RGBColor') @deprecated abstract class _RGBColor extends NativeFieldWrapperClass2 { factory _RGBColor._() { throw new UnsupportedError("new _RGBColor._() is unsupported on this platform."); } } @DomName('RadioNodeList') abstract class _RadioNodeList extends NodeList { factory _RadioNodeList._() { throw new UnsupportedError("new _RadioNodeList._() is unsupported on this platform."); } } @DocsEditable() @DomName('Rect') @deprecated abstract class _Rect extends NativeFieldWrapperClass2 { factory _Rect._() { throw new UnsupportedError("new _Rect._() is unsupported on this platform."); } } @DocsEditable() @DomName('Request') @Experimental() class _Request extends NativeFieldWrapperClass2 { factory _Request._() { throw new UnsupportedError("new _Request._() is unsupported on this platform."); }   @DomName('Request.Request') @DocsEditable() factory _Request(input, [Map requestInitDict]) { throw new UnsupportedError("new _Request() is unsupported on this platform."); }   @DomName('Request.credentials') @DocsEditable() @Experimental() String get credentials {}   @DomName('Request.headers') @DocsEditable() @Experimental() Headers get headers {}   @DomName('Request.mode') @DocsEditable() @Experimental() String get mode {}   @DomName('Request.referrer') @DocsEditable() @Experimental() String get referrer {}   @DomName('Request.url') @DocsEditable() @Experimental() String get url {} } @DocsEditable() @DomName('Response') @Experimental() abstract class _Response extends NativeFieldWrapperClass2 { factory _Response._() { throw new UnsupportedError("new _Response._() is unsupported on this platform."); }   @DomName('Response.Response') @DocsEditable() factory _Response(body, [Map responseInitDict]) { throw new UnsupportedError("new _Response() is unsupported on this platform."); } } @DocsEditable() @DomName('ServiceWorker') @Experimental() abstract class _ServiceWorker extends EventTarget implements AbstractWorker { factory _ServiceWorker._() { throw new UnsupportedError("new _ServiceWorker._() is unsupported on this platform."); } } @DocsEditable() @DomName('SpeechRecognitionResultList') @Experimental() class _SpeechRecognitionResultList extends NativeFieldWrapperClass2 with ListMixin<SpeechRecognitionResult>, ImmutableListMixin<SpeechRecognitionResult> implements List<SpeechRecognitionResult> { factory _SpeechRecognitionResultList._() { throw new UnsupportedError("new _SpeechRecognitionResultList._() is unsupported on this platform."); }   @DomName('SpeechRecognitionResultList.length') @DocsEditable() int get length {}   SpeechRecognitionResult operator [](int index) {}    void operator []=(int index, SpeechRecognitionResult value) {}   void set length(int value) {}   SpeechRecognitionResult get first {}   SpeechRecognitionResult get last {}   SpeechRecognitionResult get single {}   SpeechRecognitionResult elementAt(int index) {}   @DomName('SpeechRecognitionResultList.item') @DocsEditable() SpeechRecognitionResult item(int index) {} } @DocsEditable() @DomName('StyleSheetList') class _StyleSheetList extends NativeFieldWrapperClass2 with ListMixin<StyleSheet>, ImmutableListMixin<StyleSheet> implements List<StyleSheet> { factory _StyleSheetList._() { throw new UnsupportedError("new _StyleSheetList._() is unsupported on this platform."); }   @DomName('StyleSheetList.length') @DocsEditable() int get length {}   StyleSheet operator [](int index) {}    void operator []=(int index, StyleSheet value) {}   void set length(int value) {}   StyleSheet get first {}   StyleSheet get last {}   StyleSheet get single {}   StyleSheet elementAt(int index) {}    @DomName('StyleSheetList.item') @DocsEditable() StyleSheet item(int index) {} } @DocsEditable() @DomName('SubtleCrypto') @Experimental() abstract class _SubtleCrypto extends NativeFieldWrapperClass2 { factory _SubtleCrypto._() { throw new UnsupportedError("new _SubtleCrypto._() is unsupported on this platform."); } } @DocsEditable() @DomName('WebKitCSSFilterValue') @deprecated abstract class _WebKitCSSFilterValue extends _CssValueList { factory _WebKitCSSFilterValue._() { throw new UnsupportedError("new _WebKitCSSFilterValue._() is unsupported on this platform."); } } @DocsEditable() @DomName('WebKitCSSMatrix') @SupportedBrowser(SupportedBrowser.CHROME) @SupportedBrowser(SupportedBrowser.SAFARI) @Experimental() @deprecated abstract class _WebKitCSSMatrix extends NativeFieldWrapperClass2 { factory _WebKitCSSMatrix._() { throw new UnsupportedError("new _WebKitCSSMatrix._() is unsupported on this platform."); }   @DomName('WebKitCSSMatrix.WebKitCSSMatrix') @DocsEditable() factory _WebKitCSSMatrix([String cssValue]) { throw new UnsupportedError("new _WebKitCSSMatrix() is unsupported on this platform."); } } @DocsEditable() @DomName('WebKitCSSTransformValue') @deprecated abstract class _WebKitCSSTransformValue extends _CssValueList { factory _WebKitCSSTransformValue._() { throw new UnsupportedError("new _WebKitCSSTransformValue._() is unsupported on this platform."); } } @DocsEditable() @DomName('WindowTimers') @Experimental() abstract class _WindowTimers extends NativeFieldWrapperClass2 { factory _WindowTimers._() { throw new UnsupportedError("new _WindowTimers._() is unsupported on this platform."); }     } @DocsEditable() @DomName('WorkerLocation') @Experimental() abstract class _WorkerLocation extends NativeFieldWrapperClass2 implements UrlUtilsReadOnly { factory _WorkerLocation._() { throw new UnsupportedError("new _WorkerLocation._() is unsupported on this platform."); } } @DocsEditable() @DomName('WorkerNavigator') @Experimental() abstract class _WorkerNavigator extends NativeFieldWrapperClass2 implements NavigatorCpu, NavigatorOnLine, NavigatorID { factory _WorkerNavigator._() { throw new UnsupportedError("new _WorkerNavigator._() is unsupported on this platform."); } } @DocsEditable() @DomName('XMLHttpRequestProgressEvent') @Experimental() abstract class _XMLHttpRequestProgressEvent extends ProgressEvent { factory _XMLHttpRequestProgressEvent._() { throw new UnsupportedError("new _XMLHttpRequestProgressEvent._() is unsupported on this platform."); } } abstract class _AttributeMap implements Map<String, String> {   _AttributeMap(Element _element) { throw new UnsupportedError("new _AttributeMap() is unsupported on this platform."); }   void addAll(Map<String, String> other) {}   bool containsValue(String value) {}   String putIfAbsent(String key, String ifAbsent()) {}   void clear() {}   void forEach(void f(String key, String value)) {}   Iterable<String> get keys {}   Iterable<String> get values {}   bool get isEmpty {}   bool get isNotEmpty {}  } class _ElementAttributeMap extends _AttributeMap { _ElementAttributeMap(Element element) : super(throw new UnsupportedError("new _ElementAttributeMap() is unsupported on this platform.")) { throw new UnsupportedError("new _ElementAttributeMap() is unsupported on this platform."); }   bool containsKey(String key) {}   String operator [](String key) {}   void operator []=(String key, String value) {}   String remove(String key) {}   int get length {}  } class _NamespacedAttributeMap extends _AttributeMap {   _NamespacedAttributeMap(Element element, String _namespace) : super(throw new UnsupportedError("new _NamespacedAttributeMap() is unsupported on this platform.")) { throw new UnsupportedError("new _NamespacedAttributeMap() is unsupported on this platform."); }   bool containsKey(String key) {}   String operator [](String key) {}   void operator []=(String key, String value) {}   String remove(String key) {}   int get length {}  } class _DataAttributeMap implements Map<String, String> {   _DataAttributeMap(Map<String, String> _attributes) { throw new UnsupportedError("new _DataAttributeMap() is unsupported on this platform."); }   void addAll(Map<String, String> other) {}   bool containsValue(String value) {}   bool containsKey(String key) {}   String operator [](String key) {}   void operator []=(String key, String value) {}   String putIfAbsent(String key, String ifAbsent()) {}   String remove(String key) {}   void clear() {}   void forEach(void f(String key, String value)) {}   Iterable<String> get keys {}   Iterable<String> get values {}   int get length {}   bool get isEmpty {}   bool get isNotEmpty {}      } abstract class CanvasImageSource {} abstract class WindowBase implements EventTarget { LocationBase get location;   HistoryBase get history;   bool get closed;   WindowBase get opener;   WindowBase get parent;   WindowBase get top;   void close();   void postMessage(var message, String targetOrigin, [List messagePorts]); } abstract class LocationBase { void set href(String val); } abstract class HistoryBase { void back();   void forward();   void go(int distance); } abstract class CssClassSet implements Set<String> { bool toggle(String value, [bool shouldAdd]);   bool get frozen;   bool contains(String value);   bool add(String value);   bool remove(Object value);   void addAll(Iterable<String> iterable);   void removeAll(Iterable<String> iterable);   void toggleAll(Iterable<String> iterable, [bool shouldAdd]); } class _MultiElementCssClassSet extends CssClassSetImpl {     _MultiElementCssClassSet(Iterable<Element> _elementIterable) { throw new UnsupportedError("new _MultiElementCssClassSet() is unsupported on this platform."); }   Set<String> readClasses() {}   void writeClasses(Set<String> s) {}   modify(f(Set<String> s)) {}   bool toggle(String value, [bool shouldAdd]) {}   bool remove(Object value) {}  } class _ElementCssClassSet extends CssClassSetImpl {   _ElementCssClassSet(Element _element) { throw new UnsupportedError("new _ElementCssClassSet() is unsupported on this platform."); }   Set<String> readClasses() {}   void writeClasses(Set<String> s) {} } class _ContentCssRect extends CssRect { _ContentCssRect(element) : super(throw new UnsupportedError("new _ContentCssRect() is unsupported on this platform.")) { throw new UnsupportedError("new _ContentCssRect() is unsupported on this platform."); }   num get height {}   num get width {}   void set height(newHeight) {}   void set width(newWidth) {}   num get left {}   num get top {} } class _ContentCssListRect extends _ContentCssRect {   _ContentCssListRect(elementList) : super(throw new UnsupportedError("new _ContentCssListRect() is unsupported on this platform.")) { throw new UnsupportedError("new _ContentCssListRect() is unsupported on this platform."); }   void set height(newHeight) {}   void set width(newWidth) {} } class _PaddingCssRect extends CssRect { _PaddingCssRect(element) : super(throw new UnsupportedError("new _PaddingCssRect() is unsupported on this platform.")) { throw new UnsupportedError("new _PaddingCssRect() is unsupported on this platform."); }   num get height {}   num get width {}   num get left {}   num get top {} } class _BorderCssRect extends CssRect { _BorderCssRect(element) : super(throw new UnsupportedError("new _BorderCssRect() is unsupported on this platform.")) { throw new UnsupportedError("new _BorderCssRect() is unsupported on this platform."); }   num get height {}   num get width {}   num get left {}   num get top {} } class _MarginCssRect extends CssRect { _MarginCssRect(element) : super(throw new UnsupportedError("new _MarginCssRect() is unsupported on this platform.")) { throw new UnsupportedError("new _MarginCssRect() is unsupported on this platform."); }   num get height {}   num get width {}   num get left {}   num get top {} } abstract class CssRect extends MutableRectangle<num> {   CssRect(Element _element) : super(throw new UnsupportedError("new CssRect() is unsupported on this platform."), null, null, null) { throw new UnsupportedError("new CssRect() is unsupported on this platform."); }   num get left;   num get top;   num get height;   num get width;   void set height(newHeight) {}   void set width(newWidth) {}  }      @Experimental() class Dimension {     Dimension.percent(num _value) { throw new UnsupportedError("new Dimension.percent() is unsupported on this platform."); }   Dimension.px(num _value) { throw new UnsupportedError("new Dimension.px() is unsupported on this platform."); }   Dimension.pc(num _value) { throw new UnsupportedError("new Dimension.pc() is unsupported on this platform."); }   Dimension.pt(num _value) { throw new UnsupportedError("new Dimension.pt() is unsupported on this platform."); }   Dimension.inch(num _value) { throw new UnsupportedError("new Dimension.inch() is unsupported on this platform."); }   Dimension.cm(num _value) { throw new UnsupportedError("new Dimension.cm() is unsupported on this platform."); }   Dimension.mm(num _value) { throw new UnsupportedError("new Dimension.mm() is unsupported on this platform."); }   Dimension.em(num _value) { throw new UnsupportedError("new Dimension.em() is unsupported on this platform."); }   Dimension.ex(num _value) { throw new UnsupportedError("new Dimension.ex() is unsupported on this platform."); }   Dimension.css(String cssValue) { throw new UnsupportedError("new Dimension.css() is unsupported on this platform."); }   String toString() {}   num get value {} } typedef EventListener(Event event); class EventStreamProvider<T extends Event> {   const EventStreamProvider(String _eventType);   Stream<T> forTarget(EventTarget e, {bool useCapture : false}) { throw new UnsupportedError("EventStreamProvider.forTarget() is unsupported on this platform."); }   ElementStream<T> forElement(Element e, {bool useCapture : false}) { throw new UnsupportedError("EventStreamProvider.forElement() is unsupported on this platform."); }    String getEventType(EventTarget target) { throw new UnsupportedError("EventStreamProvider.getEventType() is unsupported on this platform."); } } abstract class ElementStream<T extends Event> implements Stream<T> { Stream<T> matches(String selector);   StreamSubscription<T> capture(void onData(T event)); } class _EventStream<T extends Event> extends Stream<T> {       _EventStream(EventTarget _target, String _eventType, bool _useCapture) { throw new UnsupportedError("new _EventStream() is unsupported on this platform."); }   Stream<T> asBroadcastStream({void onListen(StreamSubscription subscription), void onCancel(StreamSubscription subscription)}) {}   bool get isBroadcast {}   StreamSubscription<T> listen(void onData(T event), {Function onError, void onDone(), bool cancelOnError}) {} } class _ElementEventStreamImpl<T extends Event> extends _EventStream<T> implements ElementStream<T> { _ElementEventStreamImpl(target, eventType, useCapture) : super(throw new UnsupportedError("new _ElementEventStreamImpl() is unsupported on this platform."), null, null) { throw new UnsupportedError("new _ElementEventStreamImpl() is unsupported on this platform."); }   Stream<T> matches(String selector) {}   StreamSubscription<T> capture(void onData(T event)) {} } class _ElementListEventStreamImpl<T extends Event> extends Stream<T> implements ElementStream<T> {       _ElementListEventStreamImpl(Iterable<Element> _targetList, String _eventType, bool _useCapture) { throw new UnsupportedError("new _ElementListEventStreamImpl() is unsupported on this platform."); }   Stream<T> matches(String selector) {}   StreamSubscription<T> listen(void onData(T event), {Function onError, void onDone(), bool cancelOnError}) {}   StreamSubscription<T> capture(void onData(T event)) {}   Stream<T> asBroadcastStream({void onListen(StreamSubscription subscription), void onCancel(StreamSubscription subscription)}) {}   bool get isBroadcast {} } class _EventStreamSubscription<T extends Event> extends StreamSubscription<T> {           _EventStreamSubscription(EventTarget _target, String _eventType, onData, bool _useCapture) { throw new UnsupportedError("new _EventStreamSubscription() is unsupported on this platform."); }   Future cancel() {}    void onData(void handleData(T event)) {}   void onError(Function handleError) {}   void onDone(void handleDone()) {}   void pause([Future resumeSignal]) {}   bool get isPaused {}   void resume() {}     Future asFuture([var futureValue]) {} } abstract class CustomStream<T extends Event> implements Stream<T> { void add(T event); } class _CustomEventStreamImpl<T extends Event> extends Stream<T> implements CustomStream<T> {     _CustomEventStreamImpl(String type) { throw new UnsupportedError("new _CustomEventStreamImpl() is unsupported on this platform."); }   StreamSubscription<T> listen(void onData(T event), {Function onError, void onDone(), bool cancelOnError}) {}   Stream<T> asBroadcastStream({void onListen(StreamSubscription subscription), void onCancel(StreamSubscription subscription)}) {}   bool get isBroadcast {}   void add(T event) {} } class _CustomKeyEventStreamImpl extends _CustomEventStreamImpl<KeyEvent> implements CustomStream<KeyEvent> { _CustomKeyEventStreamImpl(String type) : super(throw new UnsupportedError("new _CustomKeyEventStreamImpl() is unsupported on this platform.")) { throw new UnsupportedError("new _CustomKeyEventStreamImpl() is unsupported on this platform."); }   void add(KeyEvent event) {} } class _StreamPool<T> {     _StreamPool.broadcast() { throw new UnsupportedError("new _StreamPool.broadcast() is unsupported on this platform."); }   Stream<T> get stream {}   void add(Stream<T> stream) {}   void remove(Stream<T> stream) {}   void close() {} } class _CustomEventStreamProvider<T extends Event> implements EventStreamProvider<T> {   const _CustomEventStreamProvider(_eventTypeGetter);   Stream<T> forTarget(EventTarget e, {bool useCapture : false}) { throw new UnsupportedError("_CustomEventStreamProvider.forTarget() is unsupported on this platform."); }   ElementStream<T> forElement(Element e, {bool useCapture : false}) { throw new UnsupportedError("_CustomEventStreamProvider.forElement() is unsupported on this platform."); }    String getEventType(EventTarget target) { throw new UnsupportedError("_CustomEventStreamProvider.getEventType() is unsupported on this platform."); }  } class _Html5NodeValidator implements NodeValidator {   static const _standardAttributes = const <String> ['*::class', '*::dir', '*::draggable', '*::hidden', '*::id', '*::inert', '*::itemprop', '*::itemref', '*::itemscope', '*::lang', '*::spellcheck', '*::title', '*::translate', 'A::accesskey', 'A::coords', 'A::hreflang', 'A::name', 'A::shape', 'A::tabindex', 'A::target', 'A::type', 'AREA::accesskey', 'AREA::alt', 'AREA::coords', 'AREA::nohref', 'AREA::shape', 'AREA::tabindex', 'AREA::target', 'AUDIO::controls', 'AUDIO::loop', 'AUDIO::mediagroup', 'AUDIO::muted', 'AUDIO::preload', 'BDO::dir', 'BODY::alink', 'BODY::bgcolor', 'BODY::link', 'BODY::text', 'BODY::vlink', 'BR::clear', 'BUTTON::accesskey', 'BUTTON::disabled', 'BUTTON::name', 'BUTTON::tabindex', 'BUTTON::type', 'BUTTON::value', 'CANVAS::height', 'CANVAS::width', 'CAPTION::align', 'COL::align', 'COL::char', 'COL::charoff', 'COL::span', 'COL::valign', 'COL::width', 'COLGROUP::align', 'COLGROUP::char', 'COLGROUP::charoff', 'COLGROUP::span', 'COLGROUP::valign', 'COLGROUP::width', 'COMMAND::checked', 'COMMAND::command', 'COMMAND::disabled', 'COMMAND::label', 'COMMAND::radiogroup', 'COMMAND::type', 'DATA::value', 'DEL::datetime', 'DETAILS::open', 'DIR::compact', 'DIV::align', 'DL::compact', 'FIELDSET::disabled', 'FONT::color', 'FONT::face', 'FONT::size', 'FORM::accept', 'FORM::autocomplete', 'FORM::enctype', 'FORM::method', 'FORM::name', 'FORM::novalidate', 'FORM::target', 'FRAME::name', 'H1::align', 'H2::align', 'H3::align', 'H4::align', 'H5::align', 'H6::align', 'HR::align', 'HR::noshade', 'HR::size', 'HR::width', 'HTML::version', 'IFRAME::align', 'IFRAME::frameborder', 'IFRAME::height', 'IFRAME::marginheight', 'IFRAME::marginwidth', 'IFRAME::width', 'IMG::align', 'IMG::alt', 'IMG::border', 'IMG::height', 'IMG::hspace', 'IMG::ismap', 'IMG::name', 'IMG::usemap', 'IMG::vspace', 'IMG::width', 'INPUT::accept', 'INPUT::accesskey', 'INPUT::align', 'INPUT::alt', 'INPUT::autocomplete', 'INPUT::checked', 'INPUT::disabled', 'INPUT::inputmode', 'INPUT::ismap', 'INPUT::list', 'INPUT::max', 'INPUT::maxlength', 'INPUT::min', 'INPUT::multiple', 'INPUT::name', 'INPUT::placeholder', 'INPUT::readonly', 'INPUT::required', 'INPUT::size', 'INPUT::step', 'INPUT::tabindex', 'INPUT::type', 'INPUT::usemap', 'INPUT::value', 'INS::datetime', 'KEYGEN::disabled', 'KEYGEN::keytype', 'KEYGEN::name', 'LABEL::accesskey', 'LABEL::for', 'LEGEND::accesskey', 'LEGEND::align', 'LI::type', 'LI::value', 'LINK::sizes', 'MAP::name', 'MENU::compact', 'MENU::label', 'MENU::type', 'METER::high', 'METER::low', 'METER::max', 'METER::min', 'METER::value', 'OBJECT::typemustmatch', 'OL::compact', 'OL::reversed', 'OL::start', 'OL::type', 'OPTGROUP::disabled', 'OPTGROUP::label', 'OPTION::disabled', 'OPTION::label', 'OPTION::selected', 'OPTION::value', 'OUTPUT::for', 'OUTPUT::name', 'P::align', 'PRE::width', 'PROGRESS::max', 'PROGRESS::min', 'PROGRESS::value', 'SELECT::autocomplete', 'SELECT::disabled', 'SELECT::multiple', 'SELECT::name', 'SELECT::required', 'SELECT::size', 'SELECT::tabindex', 'SOURCE::type', 'TABLE::align', 'TABLE::bgcolor', 'TABLE::border', 'TABLE::cellpadding', 'TABLE::cellspacing', 'TABLE::frame', 'TABLE::rules', 'TABLE::summary', 'TABLE::width', 'TBODY::align', 'TBODY::char', 'TBODY::charoff', 'TBODY::valign', 'TD::abbr', 'TD::align', 'TD::axis', 'TD::bgcolor', 'TD::char', 'TD::charoff', 'TD::colspan', 'TD::headers', 'TD::height', 'TD::nowrap', 'TD::rowspan', 'TD::scope', 'TD::valign', 'TD::width', 'TEXTAREA::accesskey', 'TEXTAREA::autocomplete', 'TEXTAREA::cols', 'TEXTAREA::disabled', 'TEXTAREA::inputmode', 'TEXTAREA::name', 'TEXTAREA::placeholder', 'TEXTAREA::readonly', 'TEXTAREA::required', 'TEXTAREA::rows', 'TEXTAREA::tabindex', 'TEXTAREA::wrap', 'TFOOT::align', 'TFOOT::char', 'TFOOT::charoff', 'TFOOT::valign', 'TH::abbr', 'TH::align', 'TH::axis', 'TH::bgcolor', 'TH::char', 'TH::charoff', 'TH::colspan', 'TH::headers', 'TH::height', 'TH::nowrap', 'TH::rowspan', 'TH::scope', 'TH::valign', 'TH::width', 'THEAD::align', 'THEAD::char', 'THEAD::charoff', 'THEAD::valign', 'TR::align', 'TR::bgcolor', 'TR::char', 'TR::charoff', 'TR::valign', 'TRACK::default', 'TRACK::kind', 'TRACK::label', 'TRACK::srclang', 'UL::compact', 'UL::type', 'VIDEO::controls', 'VIDEO::height', 'VIDEO::loop', 'VIDEO::mediagroup', 'VIDEO::muted', 'VIDEO::preload', 'VIDEO::width'];   static const _uriAttributes = const <String> ['A::href', 'AREA::href', 'BLOCKQUOTE::cite', 'BODY::background', 'COMMAND::icon', 'DEL::cite', 'FORM::action', 'IMG::src', 'INPUT::src', 'INS::cite', 'Q::cite', 'VIDEO::poster'];   final UriPolicy uriPolicy = null;     _Html5NodeValidator({UriPolicy uriPolicy}) { throw new UnsupportedError("new _Html5NodeValidator() is unsupported on this platform."); }   bool allowsElement(Element element) {}   bool allowsAttribute(Element element, String attributeName, String value) {}   static bool _standardAttributeValidator(Element element, String attributeName, String value, _Html5NodeValidator context) { throw new UnsupportedError("_Html5NodeValidator._standardAttributeValidator() is unsupported on this platform."); }   static bool _uriAttributeValidator(Element element, String attributeName, String value, _Html5NodeValidator context) { throw new UnsupportedError("_Html5NodeValidator._uriAttributeValidator() is unsupported on this platform."); } } abstract class ImmutableListMixin<E> implements List<E> { Iterator<E> get iterator { throw new UnsupportedError("ImmutableListMixin.iterator is unsupported on this platform."); }   void add(E value) { throw new UnsupportedError("ImmutableListMixin.add() is unsupported on this platform."); }   void addAll(Iterable<E> iterable) { throw new UnsupportedError("ImmutableListMixin.addAll() is unsupported on this platform."); }   void sort([int compare(E a, E b)]) { throw new UnsupportedError("ImmutableListMixin.sort() is unsupported on this platform."); }   void shuffle([Random random]) { throw new UnsupportedError("ImmutableListMixin.shuffle() is unsupported on this platform."); }   void insert(int index, E element) { throw new UnsupportedError("ImmutableListMixin.insert() is unsupported on this platform."); }   void insertAll(int index, Iterable<E> iterable) { throw new UnsupportedError("ImmutableListMixin.insertAll() is unsupported on this platform."); }   void setAll(int index, Iterable<E> iterable) { throw new UnsupportedError("ImmutableListMixin.setAll() is unsupported on this platform."); }   E removeAt(int pos) { throw new UnsupportedError("ImmutableListMixin.removeAt() is unsupported on this platform."); }   E removeLast() { throw new UnsupportedError("ImmutableListMixin.removeLast() is unsupported on this platform."); }   bool remove(Object object) { throw new UnsupportedError("ImmutableListMixin.remove() is unsupported on this platform."); }   void removeWhere(bool test(E element)) { throw new UnsupportedError("ImmutableListMixin.removeWhere() is unsupported on this platform."); }   void retainWhere(bool test(E element)) { throw new UnsupportedError("ImmutableListMixin.retainWhere() is unsupported on this platform."); }   void setRange(int start, int end, Iterable<E> iterable, [int skipCount = 0]) { throw new UnsupportedError("ImmutableListMixin.setRange() is unsupported on this platform."); }   void removeRange(int start, int end) { throw new UnsupportedError("ImmutableListMixin.removeRange() is unsupported on this platform."); }   void replaceRange(int start, int end, Iterable<E> iterable) { throw new UnsupportedError("ImmutableListMixin.replaceRange() is unsupported on this platform."); }   void fillRange(int start, int end, [E fillValue]) { throw new UnsupportedError("ImmutableListMixin.fillRange() is unsupported on this platform."); } } abstract class KeyCode { static const WIN_KEY_FF_LINUX = 0;   static const MAC_ENTER = 3;   static const BACKSPACE = 8;   static const TAB = 9;   static const NUM_CENTER = 12;   static const ENTER = 13;   static const SHIFT = 16;   static const CTRL = 17;   static const ALT = 18;   static const PAUSE = 19;   static const CAPS_LOCK = 20;   static const ESC = 27;   static const SPACE = 32;   static const PAGE_UP = 33;   static const PAGE_DOWN = 34;   static const END = 35;   static const HOME = 36;   static const LEFT = 37;   static const UP = 38;   static const RIGHT = 39;   static const DOWN = 40;   static const NUM_NORTH_EAST = 33;   static const NUM_SOUTH_EAST = 34;   static const NUM_SOUTH_WEST = 35;   static const NUM_NORTH_WEST = 36;   static const NUM_WEST = 37;   static const NUM_NORTH = 38;   static const NUM_EAST = 39;   static const NUM_SOUTH = 40;   static const PRINT_SCREEN = 44;   static const INSERT = 45;   static const NUM_INSERT = 45;   static const DELETE = 46;   static const NUM_DELETE = 46;   static const ZERO = 48;   static const ONE = 49;   static const TWO = 50;   static const THREE = 51;   static const FOUR = 52;   static const FIVE = 53;   static const SIX = 54;   static const SEVEN = 55;   static const EIGHT = 56;   static const NINE = 57;   static const FF_SEMICOLON = 59;   static const FF_EQUALS = 61;   static const QUESTION_MARK = 63;   static const A = 65;   static const B = 66;   static const C = 67;   static const D = 68;   static const E = 69;   static const F = 70;   static const G = 71;   static const H = 72;   static const I = 73;   static const J = 74;   static const K = 75;   static const L = 76;   static const M = 77;   static const N = 78;   static const O = 79;   static const P = 80;   static const Q = 81;   static const R = 82;   static const S = 83;   static const T = 84;   static const U = 85;   static const V = 86;   static const W = 87;   static const X = 88;   static const Y = 89;   static const Z = 90;   static const META = 91;   static const WIN_KEY_LEFT = 91;   static const WIN_KEY_RIGHT = 92;   static const CONTEXT_MENU = 93;   static const NUM_ZERO = 96;   static const NUM_ONE = 97;   static const NUM_TWO = 98;   static const NUM_THREE = 99;   static const NUM_FOUR = 100;   static const NUM_FIVE = 101;   static const NUM_SIX = 102;   static const NUM_SEVEN = 103;   static const NUM_EIGHT = 104;   static const NUM_NINE = 105;   static const NUM_MULTIPLY = 106;   static const NUM_PLUS = 107;   static const NUM_MINUS = 109;   static const NUM_PERIOD = 110;   static const NUM_DIVISION = 111;   static const F1 = 112;   static const F2 = 113;   static const F3 = 114;   static const F4 = 115;   static const F5 = 116;   static const F6 = 117;   static const F7 = 118;   static const F8 = 119;   static const F9 = 120;   static const F10 = 121;   static const F11 = 122;   static const F12 = 123;   static const NUMLOCK = 144;   static const SCROLL_LOCK = 145;   static const FIRST_MEDIA_KEY = 166;   static const LAST_MEDIA_KEY = 183;   static const SEMICOLON = 186;   static const DASH = 189;   static const EQUALS = 187;   static const COMMA = 188;   static const PERIOD = 190;   static const SLASH = 191;   static const APOSTROPHE = 192;   static const TILDE = 192;   static const SINGLE_QUOTE = 222;   static const OPEN_SQUARE_BRACKET = 219;   static const BACKSLASH = 220;   static const CLOSE_SQUARE_BRACKET = 221;   static const WIN_KEY = 224;   static const MAC_FF_META = 224;   static const WIN_IME = 229;   static const UNKNOWN = -1;   static bool isCharacterKey(int keyCode) { throw new UnsupportedError("KeyCode.isCharacterKey() is unsupported on this platform."); }   static String _convertKeyCodeToKeyName(int keyCode) { throw new UnsupportedError("KeyCode._convertKeyCodeToKeyName() is unsupported on this platform."); } } abstract class KeyLocation { static const STANDARD = 0;   static const LEFT = 1;   static const RIGHT = 2;   static const NUMPAD = 3;   static const MOBILE = 4;   static const JOYSTICK = 5; } abstract class _KeyName { static const ACCEPT = "Accept";   static const ADD = "Add";   static const AGAIN = "Again";   static const ALL_CANDIDATES = "AllCandidates";   static const ALPHANUMERIC = "Alphanumeric";   static const ALT = "Alt";   static const ALT_GRAPH = "AltGraph";   static const APPS = "Apps";   static const ATTN = "Attn";   static const BROWSER_BACK = "BrowserBack";   static const BROWSER_FAVORTIES = "BrowserFavorites";   static const BROWSER_FORWARD = "BrowserForward";   static const BROWSER_NAME = "BrowserHome";   static const BROWSER_REFRESH = "BrowserRefresh";   static const BROWSER_SEARCH = "BrowserSearch";   static const BROWSER_STOP = "BrowserStop";   static const CAMERA = "Camera";   static const CAPS_LOCK = "CapsLock";   static const CLEAR = "Clear";   static const CODE_INPUT = "CodeInput";   static const COMPOSE = "Compose";   static const CONTROL = "Control";   static const CRSEL = "Crsel";   static const CONVERT = "Convert";   static const COPY = "Copy";   static const CUT = "Cut";   static const DECIMAL = "Decimal";   static const DIVIDE = "Divide";   static const DOWN = "Down";   static const DOWN_LEFT = "DownLeft";   static const DOWN_RIGHT = "DownRight";   static const EJECT = "Eject";   static const END = "End";   static const ENTER = "Enter";   static const ERASE_EOF = "EraseEof";   static const EXECUTE = "Execute";   static const EXSEL = "Exsel";   static const FN = "Fn";   static const F1 = "F1";   static const F2 = "F2";   static const F3 = "F3";   static const F4 = "F4";   static const F5 = "F5";   static const F6 = "F6";   static const F7 = "F7";   static const F8 = "F8";   static const F9 = "F9";   static const F10 = "F10";   static const F11 = "F11";   static const F12 = "F12";   static const F13 = "F13";   static const F14 = "F14";   static const F15 = "F15";   static const F16 = "F16";   static const F17 = "F17";   static const F18 = "F18";   static const F19 = "F19";   static const F20 = "F20";   static const F21 = "F21";   static const F22 = "F22";   static const F23 = "F23";   static const F24 = "F24";   static const FINAL_MODE = "FinalMode";   static const FIND = "Find";   static const FULL_WIDTH = "FullWidth";   static const HALF_WIDTH = "HalfWidth";   static const HANGUL_MODE = "HangulMode";   static const HANJA_MODE = "HanjaMode";   static const HELP = "Help";   static const HIRAGANA = "Hiragana";   static const HOME = "Home";   static const INSERT = "Insert";   static const JAPANESE_HIRAGANA = "JapaneseHiragana";   static const JAPANESE_KATAKANA = "JapaneseKatakana";   static const JAPANESE_ROMAJI = "JapaneseRomaji";   static const JUNJA_MODE = "JunjaMode";   static const KANA_MODE = "KanaMode";   static const KANJI_MODE = "KanjiMode";   static const KATAKANA = "Katakana";   static const LAUNCH_APPLICATION_1 = "LaunchApplication1";   static const LAUNCH_APPLICATION_2 = "LaunchApplication2";   static const LAUNCH_MAIL = "LaunchMail";   static const LEFT = "Left";   static const MENU = "Menu";   static const META = "Meta";   static const MEDIA_NEXT_TRACK = "MediaNextTrack";   static const MEDIA_PAUSE_PLAY = "MediaPlayPause";   static const MEDIA_PREVIOUS_TRACK = "MediaPreviousTrack";   static const MEDIA_STOP = "MediaStop";   static const MODE_CHANGE = "ModeChange";   static const NEXT_CANDIDATE = "NextCandidate";   static const NON_CONVERT = "Nonconvert";   static const NUM_LOCK = "NumLock";   static const PAGE_DOWN = "PageDown";   static const PAGE_UP = "PageUp";   static const PASTE = "Paste";   static const PAUSE = "Pause";   static const PLAY = "Play";   static const POWER = "Power";   static const PREVIOUS_CANDIDATE = "PreviousCandidate";   static const PRINT_SCREEN = "PrintScreen";   static const PROCESS = "Process";   static const PROPS = "Props";   static const RIGHT = "Right";   static const ROMAN_CHARACTERS = "RomanCharacters";   static const SCROLL = "Scroll";   static const SELECT = "Select";   static const SELECT_MEDIA = "SelectMedia";   static const SEPARATOR = "Separator";   static const SHIFT = "Shift";   static const SOFT_1 = "Soft1";   static const SOFT_2 = "Soft2";   static const SOFT_3 = "Soft3";   static const SOFT_4 = "Soft4";   static const STOP = "Stop";   static const SUBTRACT = "Subtract";   static const SYMBOL_LOCK = "SymbolLock";   static const UP = "Up";   static const UP_LEFT = "UpLeft";   static const UP_RIGHT = "UpRight";   static const UNDO = "Undo";   static const VOLUME_DOWN = "VolumeDown";   static const VOLUMN_MUTE = "VolumeMute";   static const VOLUMN_UP = "VolumeUp";   static const WIN = "Win";   static const ZOOM = "Zoom";   static const BACKSPACE = "Backspace";   static const TAB = "Tab";   static const CANCEL = "Cancel";   static const ESC = "Esc";   static const SPACEBAR = "Spacebar";   static const DEL = "Del";   static const DEAD_GRAVE = "DeadGrave";   static const DEAD_EACUTE = "DeadEacute";   static const DEAD_CIRCUMFLEX = "DeadCircumflex";   static const DEAD_TILDE = "DeadTilde";   static const DEAD_MACRON = "DeadMacron";   static const DEAD_BREVE = "DeadBreve";   static const DEAD_ABOVE_DOT = "DeadAboveDot";   static const DEAD_UMLAUT = "DeadUmlaut";   static const DEAD_ABOVE_RING = "DeadAboveRing";   static const DEAD_DOUBLEACUTE = "DeadDoubleacute";   static const DEAD_CARON = "DeadCaron";   static const DEAD_CEDILLA = "DeadCedilla";   static const DEAD_OGONEK = "DeadOgonek";   static const DEAD_IOTA = "DeadIota";   static const DEAD_VOICED_SOUND = "DeadVoicedSound";   static const DEC_SEMIVOICED_SOUND = "DeadSemivoicedSound";   static const UNIDENTIFIED = "Unidentified"; } class _KeyboardEventHandler extends EventStreamProvider<KeyEvent> {           static const _EVENT_TYPE = 'KeyEvent';   static const _keyIdentifier = const {'Up' : KeyCode.UP, 'Down' : KeyCode.DOWN, 'Left' : KeyCode.LEFT, 'Right' : KeyCode.RIGHT, 'Enter' : KeyCode.ENTER, 'F1' : KeyCode.F1, 'F2' : KeyCode.F2, 'F3' : KeyCode.F3, 'F4' : KeyCode.F4, 'F5' : KeyCode.F5, 'F6' : KeyCode.F6, 'F7' : KeyCode.F7, 'F8' : KeyCode.F8, 'F9' : KeyCode.F9, 'F10' : KeyCode.F10, 'F11' : KeyCode.F11, 'F12' : KeyCode.F12, 'U+007F' : KeyCode.DELETE, 'Home' : KeyCode.HOME, 'End' : KeyCode.END, 'PageUp' : KeyCode.PAGE_UP, 'PageDown' : KeyCode.PAGE_DOWN, 'Insert' : KeyCode.INSERT};   CustomStream<KeyEvent> forTarget(EventTarget e, {bool useCapture : false}) {}   _KeyboardEventHandler(String _type) : super(throw new UnsupportedError("new _KeyboardEventHandler() is unsupported on this platform.")) { throw new UnsupportedError("new _KeyboardEventHandler() is unsupported on this platform."); }   _KeyboardEventHandler.initializeAllEventListeners(String _type, EventTarget _target) : super(throw new UnsupportedError("new _KeyboardEventHandler.initializeAllEventListeners() is unsupported on this platform.")) { throw new UnsupportedError("new _KeyboardEventHandler.initializeAllEventListeners() is unsupported on this platform."); }        void processKeyDown(KeyboardEvent e) {}   void processKeyPress(KeyboardEvent event) {}   void processKeyUp(KeyboardEvent event) {} } class KeyboardEventStream { static CustomStream<KeyEvent> onKeyPress(EventTarget target) { throw new UnsupportedError("KeyboardEventStream.onKeyPress() is unsupported on this platform."); }   static CustomStream<KeyEvent> onKeyUp(EventTarget target) { throw new UnsupportedError("KeyboardEventStream.onKeyUp() is unsupported on this platform."); }   static CustomStream<KeyEvent> onKeyDown(EventTarget target) { throw new UnsupportedError("KeyboardEventStream.onKeyDown() is unsupported on this platform."); } } class NodeValidatorBuilder implements NodeValidator {   NodeValidatorBuilder() { throw new UnsupportedError("new NodeValidatorBuilder() is unsupported on this platform."); }   NodeValidatorBuilder.common() { throw new UnsupportedError("new NodeValidatorBuilder.common() is unsupported on this platform."); }   void allowNavigation([UriPolicy uriPolicy]) {}   void allowImages([UriPolicy uriPolicy]) {}   void allowTextElements() {}   void allowInlineStyles({String tagName}) {}   void allowHtml5({UriPolicy uriPolicy}) {}   void allowSvg() {}   void allowCustomElement(String tagName, {UriPolicy uriPolicy, Iterable<String> attributes, Iterable<String> uriAttributes}) {}   void allowTagExtension(String tagName, String baseName, {UriPolicy uriPolicy, Iterable<String> attributes, Iterable<String> uriAttributes}) {}   void allowElement(String tagName, {UriPolicy uriPolicy, Iterable<String> attributes, Iterable<String> uriAttributes}) {}   void allowTemplating() {}   void add(NodeValidator validator) {}   bool allowsElement(Element element) {}   bool allowsAttribute(Element element, String attributeName, String value) {} } class _SimpleNodeValidator implements NodeValidator { final Set<String> allowedElements = null;   final Set<String> allowedAttributes = null;   final Set<String> allowedUriAttributes = null;   final UriPolicy uriPolicy = null;   factory _SimpleNodeValidator.allowNavigation(UriPolicy uriPolicy) { throw new UnsupportedError("new _SimpleNodeValidator.allowNavigation() is unsupported on this platform."); }   factory _SimpleNodeValidator.allowImages(UriPolicy uriPolicy) { throw new UnsupportedError("new _SimpleNodeValidator.allowImages() is unsupported on this platform."); }   factory _SimpleNodeValidator.allowTextElements() { throw new UnsupportedError("new _SimpleNodeValidator.allowTextElements() is unsupported on this platform."); }   _SimpleNodeValidator(UriPolicy uriPolicy, {Iterable<String> allowedElements, Iterable<String> allowedAttributes, Iterable<String> allowedUriAttributes}) { throw new UnsupportedError("new _SimpleNodeValidator() is unsupported on this platform."); }   bool allowsElement(Element element) {}   bool allowsAttribute(Element element, String attributeName, String value) {} } class _CustomElementNodeValidator extends _SimpleNodeValidator { final bool allowTypeExtension = null;   final bool allowCustomTag = null;   _CustomElementNodeValidator(UriPolicy uriPolicy, Iterable<String> allowedElements, Iterable<String> allowedAttributes, Iterable<String> allowedUriAttributes, bool allowTypeExtension, bool allowCustomTag) : super(throw new UnsupportedError("new _CustomElementNodeValidator() is unsupported on this platform.")) { throw new UnsupportedError("new _CustomElementNodeValidator() is unsupported on this platform."); }   bool allowsElement(Element element) {}   bool allowsAttribute(Element element, String attributeName, String value) {} } class _TemplatingNodeValidator extends _SimpleNodeValidator { static const _TEMPLATE_ATTRS = const <String> ['bind', 'if', 'ref', 'repeat', 'syntax'];     _TemplatingNodeValidator() : super(throw new UnsupportedError("new _TemplatingNodeValidator() is unsupported on this platform.")) { throw new UnsupportedError("new _TemplatingNodeValidator() is unsupported on this platform."); }   bool allowsAttribute(Element element, String attributeName, String value) {} } class _SvgNodeValidator implements NodeValidator { bool allowsElement(Element element) { throw new UnsupportedError("_SvgNodeValidator.allowsElement() is unsupported on this platform."); }   bool allowsAttribute(Element element, String attributeName, String value) { throw new UnsupportedError("_SvgNodeValidator.allowsAttribute() is unsupported on this platform."); } } abstract class ReadyState { static const LOADING = "loading";   static const INTERACTIVE = "interactive";   static const COMPLETE = "complete"; } abstract class NodeValidator { factory NodeValidator({UriPolicy uriPolicy}) { throw new UnsupportedError("new NodeValidator() is unsupported on this platform."); }   factory NodeValidator.throws(NodeValidator base) { throw new UnsupportedError("new NodeValidator.throws() is unsupported on this platform."); }   bool allowsElement(Element element);   bool allowsAttribute(Element element, String attributeName, String value); } abstract class NodeTreeSanitizer { factory NodeTreeSanitizer(NodeValidator validator) { throw new UnsupportedError("new NodeTreeSanitizer() is unsupported on this platform."); }   void sanitizeTree(Node node); } abstract class UriPolicy { factory UriPolicy() { throw new UnsupportedError("new UriPolicy() is unsupported on this platform."); }   bool allowsUri(String uri); } class _SameOriginUriPolicy implements UriPolicy {     bool allowsUri(String uri) { throw new UnsupportedError("_SameOriginUriPolicy.allowsUri() is unsupported on this platform."); } } class _ThrowsNodeValidator implements NodeValidator { final NodeValidator validator = null;   _ThrowsNodeValidator(NodeValidator validator) { throw new UnsupportedError("new _ThrowsNodeValidator() is unsupported on this platform."); }   bool allowsElement(Element element) {}   bool allowsAttribute(Element element, String attributeName, String value) {} } class _ValidatingTreeSanitizer implements NodeTreeSanitizer { NodeValidator validator  _ValidatingTreeSanitizer(NodeValidator validator) { throw new UnsupportedError("new _ValidatingTreeSanitizer() is unsupported on this platform."); }   void sanitizeTree(Node node) {}   void sanitizeNode(Node node) {} } class _WrappedList<E extends Node> extends ListBase<E> implements NodeListWrapper {   _WrappedList(List _list) { throw new UnsupportedError("new _WrappedList() is unsupported on this platform."); }   Iterator<E> get iterator {}   int get length {}   void add(E element) {}   bool remove(Object element) {}   void clear() {}   E operator [](int index) {}   void operator []=(int index, E value) {}   void set length(int newLength) {}   void sort([int compare(E a, E b)]) {}   int indexOf(Object element, [int start = 0]) {}   int lastIndexOf(Object element, [int start]) {}   void insert(int index, E element) {}   E removeAt(int index) {}   void setRange(int start, int end, Iterable<E> iterable, [int skipCount = 0]) {}   void removeRange(int start, int end) {}   void replaceRange(int start, int end, Iterable<E> iterable) {}   void fillRange(int start, int end, [E fillValue]) {}   List<Node> get rawList {} } class _WrappedIterator<E> implements Iterator<E> {   _WrappedIterator(Iterator _iterator) { throw new UnsupportedError("new _WrappedIterator() is unsupported on this platform."); }   bool moveNext() {}   E get current {} } class _HttpRequestUtils { static HttpRequest get(String url, onComplete(HttpRequest request), bool withCredentials) { throw new UnsupportedError("_HttpRequestUtils.get() is unsupported on this platform."); } } class FixedSizeListIterator<T> implements Iterator<T> {         FixedSizeListIterator(List<T> array) { throw new UnsupportedError("new FixedSizeListIterator() is unsupported on this platform."); }   bool moveNext() {}   T get current {} } class _VariableSizeListIterator<T> implements Iterator<T> {       _VariableSizeListIterator(List<T> array) { throw new UnsupportedError("new _VariableSizeListIterator() is unsupported on this platform."); }   bool moveNext() {}   T get current {} } class _VMElementUpgrader implements ElementUpgrader {     _VMElementUpgrader(Document document, Type type, String extendsTag) { throw new UnsupportedError("new _VMElementUpgrader() is unsupported on this platform."); }   Element upgrade(Element element) {} } ClassMirror _validateCustomType(Type type) { throw new UnsupportedError("_validateCustomType() is unsupported on this platform."); }  bool _isBuiltinType(ClassMirror cls) { throw new UnsupportedError("_isBuiltinType() is unsupported on this platform."); }  @Experimental() class KeyEvent extends _WrappedEvent implements KeyboardEvent {         int get keyCode {}   int get charCode {}   bool get altKey {}   int get which {}        KeyEvent.wrap(KeyboardEvent parent) : super(throw new UnsupportedError("new KeyEvent.wrap() is unsupported on this platform.")) { throw new UnsupportedError("new KeyEvent.wrap() is unsupported on this platform."); }   factory KeyEvent(String type, {Window view, bool canBubble : true, bool cancelable : true, int keyCode : 0, int charCode : 0, int keyLocation : 1, bool ctrlKey : false, bool altKey : false, bool shiftKey : false, bool metaKey : false, EventTarget currentTarget}) { throw new UnsupportedError("new KeyEvent() is unsupported on this platform."); }   static EventStreamProvider<KeyEvent> get keyDownEvent => throw new UnsupportedError("KeyEvent.keyDownEvent is unsupported on this platform."); static set keyDownEvent(EventStreamProvider<KeyEvent> _) { throw new UnsupportedError("KeyEvent.keyDownEvent= is unsupported on this platform."); }   static EventStreamProvider<KeyEvent> get keyUpEvent => throw new UnsupportedError("KeyEvent.keyUpEvent is unsupported on this platform."); static set keyUpEvent(EventStreamProvider<KeyEvent> _) { throw new UnsupportedError("KeyEvent.keyUpEvent= is unsupported on this platform."); }   static EventStreamProvider<KeyEvent> get keyPressEvent => throw new UnsupportedError("KeyEvent.keyPressEvent is unsupported on this platform."); static set keyPressEvent(EventStreamProvider<KeyEvent> _) { throw new UnsupportedError("KeyEvent.keyPressEvent= is unsupported on this platform."); }   EventTarget get currentTarget {}   DataTransfer get clipboardData {}   bool get ctrlKey {}   int get detail {}   int get keyLocation {}   Point get layer {}   bool get metaKey {}   Point get page {}   bool get shiftKey {}   Window get view {}             @Experimental() bool getModifierState(String keyArgument) {}   @Experimental() int get location {}   @Experimental() bool get repeat {}  } class Platform { static get supportsTypedData => throw new UnsupportedError("Platform.supportsTypedData is unsupported on this platform.");   static get supportsSimd => throw new UnsupportedError("Platform.supportsSimd is unsupported on this platform."); } class _WrappedEvent implements Event { final Event wrapped = null;     _WrappedEvent(Event wrapped) { throw new UnsupportedError("new _WrappedEvent() is unsupported on this platform."); }   bool get bubbles {}   bool get cancelable {}   DataTransfer get clipboardData {}   EventTarget get currentTarget {}   bool get defaultPrevented {}   int get eventPhase {}   EventTarget get target {}   int get timeStamp {}   String get type {}    void preventDefault() {}   void stopImmediatePropagation() {}   void stopPropagation() {}   Element get matchingTarget {}   @Experimental() List<Node> get path {} } _wrapZone(callback(arg)) { throw new UnsupportedError("_wrapZone() is unsupported on this platform."); }  _wrapBinaryZone(callback(arg1, arg2)) { throw new UnsupportedError("_wrapBinaryZone() is unsupported on this platform."); }  @deprecated @Experimental() Element query(String relativeSelectors) { throw new UnsupportedError("query() is unsupported on this platform."); }  @deprecated @Experimental() ElementList queryAll(String relativeSelectors) { throw new UnsupportedError("queryAll() is unsupported on this platform."); }  Element querySelector(String selectors) { throw new UnsupportedError("querySelector() is unsupported on this platform."); }  ElementList querySelectorAll(String selectors) { throw new UnsupportedError("querySelectorAll() is unsupported on this platform."); }  abstract class ElementUpgrader { Element upgrade(Element element); } class _Property { _Property(String name) { throw new UnsupportedError("new _Property() is unsupported on this platform."); }   bool get hasValue {}   get value {}   set value(v) {}   final String name = null;   Function setter  Function getter      bool writable  bool isMethod  bool isOwn  bool wasThrown} class _ConsoleVariables {   noSuchMethod(Invocation invocation) { throw new UnsupportedError("_ConsoleVariables.noSuchMethod() is unsupported on this platform."); }   void clear() { throw new UnsupportedError("_ConsoleVariables.clear() is unsupported on this platform."); }   List variables() { throw new UnsupportedError("_ConsoleVariables.variables() is unsupported on this platform."); }   void setVariable(String name, value) { throw new UnsupportedError("_ConsoleVariables.setVariable() is unsupported on this platform."); } } abstract class _Trampoline implements Function {       _Trampoline(ObjectMirror _receiver, MethodMirror _methodMirror, Symbol _selector) { throw new UnsupportedError("new _Trampoline() is unsupported on this platform."); } } class _MethodTrampoline extends _Trampoline { _MethodTrampoline(ObjectMirror receiver, MethodMirror methodMirror, Symbol selector) : super(throw new UnsupportedError("new _MethodTrampoline() is unsupported on this platform."), null, null) { throw new UnsupportedError("new _MethodTrampoline() is unsupported on this platform."); }   noSuchMethod(Invocation msg) {} } class _GetterTrampoline extends _Trampoline { _GetterTrampoline(ObjectMirror receiver, MethodMirror methodMirror, Symbol selector) : super(throw new UnsupportedError("new _GetterTrampoline() is unsupported on this platform."), null, null) { throw new UnsupportedError("new _GetterTrampoline() is unsupported on this platform."); }   call() {} } class _SetterTrampoline extends _Trampoline { _SetterTrampoline(ObjectMirror receiver, MethodMirror methodMirror, Symbol selector) : super(throw new UnsupportedError("new _SetterTrampoline() is unsupported on this platform."), null, null) { throw new UnsupportedError("new _SetterTrampoline() is unsupported on this platform."); }   call(value) {} } class _Utils { static double dateTimeToDouble(DateTime dateTime) { throw new UnsupportedError("_Utils.dateTimeToDouble() is unsupported on this platform."); }   static DateTime doubleToDateTime(double dateTime) { throw new UnsupportedError("_Utils.doubleToDateTime() is unsupported on this platform."); }   static List convertToList(List list) { throw new UnsupportedError("_Utils.convertToList() is unsupported on this platform."); }   static List convertMapToList(Map map) { throw new UnsupportedError("_Utils.convertMapToList() is unsupported on this platform."); }   static int convertCanvasElementGetContextMap(Map map) { throw new UnsupportedError("_Utils.convertCanvasElementGetContextMap() is unsupported on this platform."); }   static void populateMap(Map result, List list) { throw new UnsupportedError("_Utils.populateMap() is unsupported on this platform."); }   static bool isMap(obj) { throw new UnsupportedError("_Utils.isMap() is unsupported on this platform."); }   static List toListIfIterable(obj) { throw new UnsupportedError("_Utils.toListIfIterable() is unsupported on this platform."); }   static Map createMap() { throw new UnsupportedError("_Utils.createMap() is unsupported on this platform."); }   static parseJson(String jsonSource) { throw new UnsupportedError("_Utils.parseJson() is unsupported on this platform."); }   static makeUnimplementedError(String fileName, int lineNo) { throw new UnsupportedError("_Utils.makeUnimplementedError() is unsupported on this platform."); }   static bool isTypeSubclassOf(Type type, Type other) { throw new UnsupportedError("_Utils.isTypeSubclassOf() is unsupported on this platform."); }   static Element getAndValidateNativeType(Type type, String tagName) { throw new UnsupportedError("_Utils.getAndValidateNativeType() is unsupported on this platform."); }   static window() { throw new UnsupportedError("_Utils.window() is unsupported on this platform."); }   static forwardingPrint(String message) { throw new UnsupportedError("_Utils.forwardingPrint() is unsupported on this platform."); }   static spawnDomUri(String uri) { throw new UnsupportedError("_Utils.spawnDomUri() is unsupported on this platform."); }   static String stripMemberName(String name) { throw new UnsupportedError("_Utils.stripMemberName() is unsupported on this platform."); }   static Map<String, dynamic> createLocalVariablesMap(List localVariables) { throw new UnsupportedError("_Utils.createLocalVariablesMap() is unsupported on this platform."); }     static List wrapExpressionAsClosure(String expression, List locals, bool includeCommandLineAPI) { throw new UnsupportedError("_Utils.wrapExpressionAsClosure() is unsupported on this platform."); }   static String _getShortSymbolName(Symbol symbol, DeclarationMirror declaration) { throw new UnsupportedError("_Utils._getShortSymbolName() is unsupported on this platform."); }   static List<String> getCompletions(o) { throw new UnsupportedError("_Utils.getCompletions() is unsupported on this platform."); }   static void _getCompletionsHelper(ClassMirror classMirror, bool staticContext, LibraryMirror libraryMirror, Set<String> output) { throw new UnsupportedError("_Utils._getCompletionsHelper() is unsupported on this platform."); }   static void _getLibraryCompletionsHelper(LibraryMirror library, bool includePrivate, Set<String> output) { throw new UnsupportedError("_Utils._getLibraryCompletionsHelper() is unsupported on this platform."); }   static LibraryMirror getLibraryMirror(String url) { throw new UnsupportedError("_Utils.getLibraryMirror() is unsupported on this platform."); }   static List<String> getObjectCompletions(o, String libraryUrl) { throw new UnsupportedError("_Utils.getObjectCompletions() is unsupported on this platform."); }   static void getClassCompletions(ClassMirror classMirror, Set<String> names, bool staticContext, String libraryUrl) { throw new UnsupportedError("_Utils.getClassCompletions() is unsupported on this platform."); }   static List<String> getLibraryCompletions(String url) { throw new UnsupportedError("_Utils.getLibraryCompletions() is unsupported on this platform."); }   static List<String> getLibraryCompletionsIncludingImports(String url) { throw new UnsupportedError("_Utils.getLibraryCompletionsIncludingImports() is unsupported on this platform."); }   static get SIDE_EFFECT_FREE_LIBRARIES => throw new UnsupportedError("_Utils.SIDE_EFFECT_FREE_LIBRARIES is unsupported on this platform.");   static LibraryMirror _getLibrary(MethodMirror methodMirror) { throw new UnsupportedError("_Utils._getLibrary() is unsupported on this platform."); }   static bool _isSideEffectFreeGetter(MethodMirror methodMirror, LibraryMirror libraryMirror) { throw new UnsupportedError("_Utils._isSideEffectFreeGetter() is unsupported on this platform."); }   static bool treatPropertyAsField(MethodMirror methodMirror, LibraryMirror libraryMirror) { throw new UnsupportedError("_Utils.treatPropertyAsField() is unsupported on this platform."); }   static String describeFunction(function) { throw new UnsupportedError("_Utils.describeFunction() is unsupported on this platform."); }   static List getInvocationTrampolineDetails(_Trampoline method) { throw new UnsupportedError("_Utils.getInvocationTrampolineDetails() is unsupported on this platform."); }   static List getLibraryProperties(String libraryUrl, bool ownProperties, bool accessorPropertiesOnly) { throw new UnsupportedError("_Utils.getLibraryProperties() is unsupported on this platform."); }   static List getObjectProperties(o, bool ownProperties, bool accessorPropertiesOnly) { throw new UnsupportedError("_Utils.getObjectProperties() is unsupported on this platform."); }   static List getObjectClassProperties(o, bool ownProperties, bool accessorPropertiesOnly) { throw new UnsupportedError("_Utils.getObjectClassProperties() is unsupported on this platform."); }   static List getClassProperties(Type t, bool ownProperties, bool accessorPropertiesOnly) { throw new UnsupportedError("_Utils.getClassProperties() is unsupported on this platform."); }   static void _addStatics(ClassMirror classMirror, Map<String, _Property> properties, bool accessorPropertiesOnly) { throw new UnsupportedError("_Utils._addStatics() is unsupported on this platform."); }   static void _fillMethodMirrorProperty(LibraryMirror libraryMirror, methodOwner, MethodMirror methodMirror, Symbol symbol, bool accessorPropertiesOnly, _Property property) { throw new UnsupportedError("_Utils._fillMethodMirrorProperty() is unsupported on this platform."); }   static void _addInstanceMirrors(ObjectMirror objectMirror, LibraryMirror libraryMirror, Map<Symbol, Mirror> declarations, bool ownProperties, bool accessorPropertiesOnly, bool hideFields, bool hideMethods, Map<String, _Property> properties) { throw new UnsupportedError("_Utils._addInstanceMirrors() is unsupported on this platform."); }   static List packageProperties(Map<String, _Property> properties) { throw new UnsupportedError("_Utils.packageProperties() is unsupported on this platform."); }   static getObjectPropertySafe(o, String propertyName) { throw new UnsupportedError("_Utils.getObjectPropertySafe() is unsupported on this platform."); }   static List consoleApi(host) { throw new UnsupportedError("_Utils.consoleApi() is unsupported on this platform."); }   static List getMapKeyList(Map map) { throw new UnsupportedError("_Utils.getMapKeyList() is unsupported on this platform."); }   static bool isNoSuchMethodError(obj) { throw new UnsupportedError("_Utils.isNoSuchMethodError() is unsupported on this platform."); }   static void register(Document document, String tag, Type type, String extendsTagName) { throw new UnsupportedError("_Utils.register() is unsupported on this platform."); }   static void _register(Document document, String tag, Type customType, String extendsTagName) { throw new UnsupportedError("_Utils._register() is unsupported on this platform."); }   static Element createElement(Document document, String tagName) { throw new UnsupportedError("_Utils.createElement() is unsupported on this platform."); }   static void initializeCustomElement(HtmlElement element) { throw new UnsupportedError("_Utils.initializeCustomElement() is unsupported on this platform."); }   static Element changeElementWrapper(HtmlElement element, Type type) { throw new UnsupportedError("_Utils.changeElementWrapper() is unsupported on this platform."); } } class _DOMWindowCrossFrame extends NativeFieldWrapperClass2 implements WindowBase { _DOMWindowCrossFrame.internal() { throw new UnsupportedError("new _DOMWindowCrossFrame.internal() is unsupported on this platform."); }   HistoryBase get history {}   LocationBase get location {}   bool get closed {}   WindowBase get opener {}   WindowBase get parent {}   WindowBase get top {}   void close() {}   void postMessage(message, String targetOrigin, [List messagePorts]) {}   String get typeName {}   Events get on {}    void addEventListener(String type, EventListener listener, [bool useCapture]) {}   bool dispatchEvent(Event event) {}    void removeEventListener(String type, EventListener listener, [bool useCapture]) {} } class _HistoryCrossFrame extends NativeFieldWrapperClass2 implements HistoryBase { _HistoryCrossFrame.internal() { throw new UnsupportedError("new _HistoryCrossFrame.internal() is unsupported on this platform."); }   void back() {}   void forward() {}   void go(int distance) {}   String get typeName {} } class _LocationCrossFrame extends NativeFieldWrapperClass2 implements LocationBase { _LocationCrossFrame.internal() { throw new UnsupportedError("new _LocationCrossFrame.internal() is unsupported on this platform."); }   void set href(String h) {}   String get typeName {} } class _DOMStringMap extends NativeFieldWrapperClass2 implements Map<String, String> { _DOMStringMap.internal() { throw new UnsupportedError("new _DOMStringMap.internal() is unsupported on this platform."); }   bool containsValue(String value) {}   bool containsKey(String key) {}   String operator [](String key) {}   void operator []=(String key, String value) {}   String putIfAbsent(String key, String ifAbsent()) {}   String remove(String key) {}   void clear() {}   void forEach(void f(String key, String value)) {}   Iterable<String> get keys {}   Iterable<String> get values {}   int get length {}   bool get isEmpty {}   bool get isNotEmpty {}   void addAll(Map<String, String> other) {} }      class _Timer implements Timer { static const _STATE_TIMEOUT = 0;   static const _STATE_INTERVAL = 1;     _Timer(int milliSeconds, void callback(Timer timer), bool repeating) { throw new UnsupportedError("new _Timer() is unsupported on this platform."); }   void cancel() {}   bool get isActive {} } get _timerFactoryClosure { throw new UnsupportedError("_timerFactoryClosure is unsupported on this platform."); }  get _pureIsolateTimerFactoryClosure { throw new UnsupportedError("_pureIsolateTimerFactoryClosure is unsupported on this platform."); }  class _ScheduleImmediateHelper {       _ScheduleImmediateHelper() { throw new UnsupportedError("new _ScheduleImmediateHelper() is unsupported on this platform."); }   }  get _scheduleImmediateClosure { throw new UnsupportedError("_scheduleImmediateClosure is unsupported on this platform."); }  get _pureIsolateScheduleImmediateClosure { throw new UnsupportedError("_pureIsolateScheduleImmediateClosure is unsupported on this platform."); }  void _initializeCustomElement(Element e) { throw new UnsupportedError("_initializeCustomElement() is unsupported on this platform."); }  class _UnsupportedBrowserObject extends NativeFieldWrapperClass2 {}