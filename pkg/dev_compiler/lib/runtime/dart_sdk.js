dart_library.library('dart_sdk', null, /* Imports */[
], function load__dart_sdk(exports) {
  'use strict';
  const dart = Object.create(null);
  const dartx = Object.create(null);
  const _debugger = Object.create(null);
  const _foreign_helper = Object.create(null);
  const _interceptors = Object.create(null);
  const _internal = Object.create(null);
  const _isolate_helper = Object.create(null);
  const _js_embedded_names = Object.create(null);
  const _js_helper = Object.create(null);
  const _js_mirrors = Object.create(null);
  const _js_primitives = Object.create(null);
  const _metadata = Object.create(null);
  const _native_typed_data = Object.create(null);
  const async = Object.create(null);
  const collection = Object.create(null);
  const convert = Object.create(null);
  const core = Object.create(null);
  const isolate = Object.create(null);
  const js = Object.create(null);
  const math = Object.create(null);
  const mirrors = Object.create(null);
  const typed_data = Object.create(null);
  const indexed_db = Object.create(null);
  const html$ = Object.create(null);
  const html_common = Object.create(null);
  const svg$ = Object.create(null);
  const web_audio = Object.create(null);
  const web_gl = Object.create(null);
  const web_sql = Object.create(null);
  let ListOfObject = () => (ListOfObject = dart.constFn(core.List$(core.Object)))();
  let JSArrayOfListOfObject = () => (JSArrayOfListOfObject = dart.constFn(_interceptors.JSArray$(ListOfObject())))();
  let JSArrayOfObject = () => (JSArrayOfObject = dart.constFn(_interceptors.JSArray$(core.Object)))();
  let MapOfSymbol$dynamic = () => (MapOfSymbol$dynamic = dart.constFn(core.Map$(core.Symbol, dart.dynamic)))();
  let MapOfString$int = () => (MapOfString$int = dart.constFn(core.Map$(core.String, core.int)))();
  let ListOfString = () => (ListOfString = dart.constFn(core.List$(core.String)))();
  let JSArrayOfFormatter = () => (JSArrayOfFormatter = dart.constFn(_interceptors.JSArray$(_debugger.Formatter)))();
  let JSArrayOfNameValuePair = () => (JSArrayOfNameValuePair = dart.constFn(_interceptors.JSArray$(_debugger.NameValuePair)))();
  let LinkedHashSetOfNameValuePair = () => (LinkedHashSetOfNameValuePair = dart.constFn(collection.LinkedHashSet$(_debugger.NameValuePair)))();
  let SetOfString = () => (SetOfString = dart.constFn(core.Set$(core.String)))();
  let JSArrayOfJsonMLFormatter = () => (JSArrayOfJsonMLFormatter = dart.constFn(_interceptors.JSArray$(_debugger.JsonMLFormatter)))();
  let JSArray = () => (JSArray = dart.constFn(_interceptors.JSArray$()))();
  let JSMutableArray = () => (JSMutableArray = dart.constFn(_interceptors.JSMutableArray$()))();
  let JSFixedArray = () => (JSFixedArray = dart.constFn(_interceptors.JSFixedArray$()))();
  let JSExtendableArray = () => (JSExtendableArray = dart.constFn(_interceptors.JSExtendableArray$()))();
  let JSUnmodifiableArray = () => (JSUnmodifiableArray = dart.constFn(_interceptors.JSUnmodifiableArray$()))();
  let ArrayIterator = () => (ArrayIterator = dart.constFn(_interceptors.ArrayIterator$()))();
  let JSArrayOfString = () => (JSArrayOfString = dart.constFn(_interceptors.JSArray$(core.String)))();
  let MatchToString = () => (MatchToString = dart.constFn(dart.functionType(core.String, [core.Match])))();
  let StringToString = () => (StringToString = dart.constFn(dart.functionType(core.String, [core.String])))();
  let ComparableOfnum = () => (ComparableOfnum = dart.constFn(core.Comparable$(core.num)))();
  let ListMixin = () => (ListMixin = dart.constFn(collection.ListMixin$()))();
  let ListBase = () => (ListBase = dart.constFn(collection.ListBase$()))();
  let UnmodifiableListMixin = () => (UnmodifiableListMixin = dart.constFn(_internal.UnmodifiableListMixin$()))();
  let UnmodifiableListBase = () => (UnmodifiableListBase = dart.constFn(_internal.UnmodifiableListBase$()))();
  let StringToint = () => (StringToint = dart.constFn(dart.functionType(core.int, [core.String])))();
  let Iterable = () => (Iterable = dart.constFn(core.Iterable$()))();
  let ListIterable = () => (ListIterable = dart.constFn(_internal.ListIterable$()))();
  let SubListIterable = () => (SubListIterable = dart.constFn(_internal.SubListIterable$()))();
  let ListIterator = () => (ListIterator = dart.constFn(_internal.ListIterator$()))();
  let _Transformation = () => (_Transformation = dart.constFn(_internal._Transformation$()))();
  let MappedIterable = () => (MappedIterable = dart.constFn(_internal.MappedIterable$()))();
  let EfficientLengthMappedIterable = () => (EfficientLengthMappedIterable = dart.constFn(_internal.EfficientLengthMappedIterable$()))();
  let Iterator = () => (Iterator = dart.constFn(core.Iterator$()))();
  let MappedIterator = () => (MappedIterator = dart.constFn(_internal.MappedIterator$()))();
  let MappedListIterable = () => (MappedListIterable = dart.constFn(_internal.MappedListIterable$()))();
  let _ElementPredicate = () => (_ElementPredicate = dart.constFn(_internal._ElementPredicate$()))();
  let WhereIterable = () => (WhereIterable = dart.constFn(_internal.WhereIterable$()))();
  let WhereIterator = () => (WhereIterator = dart.constFn(_internal.WhereIterator$()))();
  let _ExpandFunction = () => (_ExpandFunction = dart.constFn(_internal._ExpandFunction$()))();
  let ExpandIterable = () => (ExpandIterable = dart.constFn(_internal.ExpandIterable$()))();
  let ExpandIterator = () => (ExpandIterator = dart.constFn(_internal.ExpandIterator$()))();
  let TakeIterable = () => (TakeIterable = dart.constFn(_internal.TakeIterable$()))();
  let EfficientLengthTakeIterable = () => (EfficientLengthTakeIterable = dart.constFn(_internal.EfficientLengthTakeIterable$()))();
  let TakeIterator = () => (TakeIterator = dart.constFn(_internal.TakeIterator$()))();
  let TakeWhileIterable = () => (TakeWhileIterable = dart.constFn(_internal.TakeWhileIterable$()))();
  let TakeWhileIterator = () => (TakeWhileIterator = dart.constFn(_internal.TakeWhileIterator$()))();
  let SkipIterable = () => (SkipIterable = dart.constFn(_internal.SkipIterable$()))();
  let EfficientLengthSkipIterable = () => (EfficientLengthSkipIterable = dart.constFn(_internal.EfficientLengthSkipIterable$()))();
  let SkipIterator = () => (SkipIterator = dart.constFn(_internal.SkipIterator$()))();
  let SkipWhileIterable = () => (SkipWhileIterable = dart.constFn(_internal.SkipWhileIterable$()))();
  let SkipWhileIterator = () => (SkipWhileIterator = dart.constFn(_internal.SkipWhileIterator$()))();
  let EmptyIterable = () => (EmptyIterable = dart.constFn(_internal.EmptyIterable$()))();
  let EmptyIterator = () => (EmptyIterator = dart.constFn(_internal.EmptyIterator$()))();
  let FixedLengthListMixin = () => (FixedLengthListMixin = dart.constFn(_internal.FixedLengthListMixin$()))();
  let FixedLengthListBase = () => (FixedLengthListBase = dart.constFn(_internal.FixedLengthListBase$()))();
  let ListMapView = () => (ListMapView = dart.constFn(_internal.ListMapView$()))();
  let ReversedListIterable = () => (ReversedListIterable = dart.constFn(_internal.ReversedListIterable$()))();
  let MapOfint$_IsolateContext = () => (MapOfint$_IsolateContext = dart.constFn(core.Map$(core.int, _isolate_helper._IsolateContext)))();
  let MapOfint$dynamic = () => (MapOfint$dynamic = dart.constFn(core.Map$(core.int, dart.dynamic)))();
  let MapOfint$RawReceivePortImpl = () => (MapOfint$RawReceivePortImpl = dart.constFn(core.Map$(core.int, _isolate_helper.RawReceivePortImpl)))();
  let SetOfint = () => (SetOfint = dart.constFn(core.Set$(core.int)))();
  let JSArrayOf_IsolateEvent = () => (JSArrayOf_IsolateEvent = dart.constFn(_interceptors.JSArray$(_isolate_helper._IsolateEvent)))();
  let SetOfCapability = () => (SetOfCapability = dart.constFn(core.Set$(isolate.Capability)))();
  let SetOfSendPort = () => (SetOfSendPort = dart.constFn(core.Set$(isolate.SendPort)))();
  let QueueOf_IsolateEvent = () => (QueueOf_IsolateEvent = dart.constFn(collection.Queue$(_isolate_helper._IsolateEvent)))();
  let CompleterOfList = () => (CompleterOfList = dart.constFn(async.Completer$(core.List)))();
  let ExpandoOfint = () => (ExpandoOfint = dart.constFn(core.Expando$(core.int)))();
  let _FutureOfString = () => (_FutureOfString = dart.constFn(async._Future$(core.String)))();
  let _FutureOfbool = () => (_FutureOfbool = dart.constFn(async._Future$(core.bool)))();
  let _FutureOfint = () => (_FutureOfint = dart.constFn(async._Future$(core.int)))();
  let dynamicTobool = () => (dynamicTobool = dart.constFn(dart.functionType(core.bool, [dart.dynamic])))();
  let VoidToObject = () => (VoidToObject = dart.constFn(dart.functionType(core.Object, [])))();
  let Stream = () => (Stream = dart.constFn(async.Stream$()))();
  let VoidTovoid = () => (VoidTovoid = dart.constFn(dart.functionType(dart.void, [])))();
  let MapOfdynamic$int = () => (MapOfdynamic$int = dart.constFn(core.Map$(dart.dynamic, core.int)))();
  let dynamicTodynamic = () => (dynamicTodynamic = dart.constFn(dart.functionType(dart.dynamic, [dart.dynamic])))();
  let JSArrayOfint = () => (JSArrayOfint = dart.constFn(_interceptors.JSArray$(core.int)))();
  let SyncIterator = () => (SyncIterator = dart.constFn(_js_helper.SyncIterator$()))();
  let IterableBase = () => (IterableBase = dart.constFn(collection.IterableBase$()))();
  let SyncIterable = () => (SyncIterable = dart.constFn(_js_helper.SyncIterable$()))();
  let JsLinkedHashMap = () => (JsLinkedHashMap = dart.constFn(_js_helper.JsLinkedHashMap$()))();
  let Es6LinkedHashMap = () => (Es6LinkedHashMap = dart.constFn(_js_helper.Es6LinkedHashMap$()))();
  let LinkedHashMapCell = () => (LinkedHashMapCell = dart.constFn(_js_helper.LinkedHashMapCell$()))();
  let LinkedHashMapKeyIterable = () => (LinkedHashMapKeyIterable = dart.constFn(_js_helper.LinkedHashMapKeyIterable$()))();
  let LinkedHashMapKeyIterator = () => (LinkedHashMapKeyIterator = dart.constFn(_js_helper.LinkedHashMapKeyIterator$()))();
  let IteratorOfMatch = () => (IteratorOfMatch = dart.constFn(core.Iterator$(core.Match)))();
  let IterableOfMatch = () => (IterableOfMatch = dart.constFn(core.Iterable$(core.Match)))();
  let JSArrayOfInstanceMirror = () => (JSArrayOfInstanceMirror = dart.constFn(_interceptors.JSArray$(mirrors.InstanceMirror)))();
  let ListOfInstanceMirror = () => (ListOfInstanceMirror = dart.constFn(core.List$(mirrors.InstanceMirror)))();
  let MapOfSymbol$MethodMirror = () => (MapOfSymbol$MethodMirror = dart.constFn(core.Map$(core.Symbol, mirrors.MethodMirror)))();
  let JSArrayOfClassMirror = () => (JSArrayOfClassMirror = dart.constFn(_interceptors.JSArray$(mirrors.ClassMirror)))();
  let ListOfType = () => (ListOfType = dart.constFn(core.List$(core.Type)))();
  let JSArrayOfParameterMirror = () => (JSArrayOfParameterMirror = dart.constFn(_interceptors.JSArray$(mirrors.ParameterMirror)))();
  let ListOfParameterMirror = () => (ListOfParameterMirror = dart.constFn(core.List$(mirrors.ParameterMirror)))();
  let ListOfint = () => (ListOfint = dart.constFn(core.List$(core.int)))();
  let ZoneBinaryCallbackOfdynamic$dynamic$StackTrace = () => (ZoneBinaryCallbackOfdynamic$dynamic$StackTrace = dart.constFn(async.ZoneBinaryCallback$(dart.dynamic, dart.dynamic, core.StackTrace)))();
  let _StreamImpl = () => (_StreamImpl = dart.constFn(async._StreamImpl$()))();
  let _ControllerStream = () => (_ControllerStream = dart.constFn(async._ControllerStream$()))();
  let _BroadcastStream = () => (_BroadcastStream = dart.constFn(async._BroadcastStream$()))();
  let ZoneBinaryCallbackOfdynamic$Object$StackTrace = () => (ZoneBinaryCallbackOfdynamic$Object$StackTrace = dart.constFn(async.ZoneBinaryCallback$(dart.dynamic, core.Object, core.StackTrace)))();
  let _BufferingStreamSubscription = () => (_BufferingStreamSubscription = dart.constFn(async._BufferingStreamSubscription$()))();
  let _ControllerSubscription = () => (_ControllerSubscription = dart.constFn(async._ControllerSubscription$()))();
  let _BroadcastSubscription = () => (_BroadcastSubscription = dart.constFn(async._BroadcastSubscription$()))();
  let _BroadcastStreamController = () => (_BroadcastStreamController = dart.constFn(async._BroadcastStreamController$()))();
  let _SyncBroadcastStreamController = () => (_SyncBroadcastStreamController = dart.constFn(async._SyncBroadcastStreamController$()))();
  let _AsyncBroadcastStreamController = () => (_AsyncBroadcastStreamController = dart.constFn(async._AsyncBroadcastStreamController$()))();
  let _AsBroadcastStreamController = () => (_AsBroadcastStreamController = dart.constFn(async._AsBroadcastStreamController$()))();
  let _DoneSubscription = () => (_DoneSubscription = dart.constFn(async._DoneSubscription$()))();
  let Future = () => (Future = dart.constFn(async.Future$()))();
  let Completer = () => (Completer = dart.constFn(async.Completer$()))();
  let _FutureOnValue = () => (_FutureOnValue = dart.constFn(async._FutureOnValue$()))();
  let _Completer = () => (_Completer = dart.constFn(async._Completer$()))();
  let _AsyncCompleter = () => (_AsyncCompleter = dart.constFn(async._AsyncCompleter$()))();
  let _SyncCompleter = () => (_SyncCompleter = dart.constFn(async._SyncCompleter$()))();
  let ZoneBinaryCallbackOfObject$Object$StackTrace = () => (ZoneBinaryCallbackOfObject$Object$StackTrace = dart.constFn(async.ZoneBinaryCallback$(core.Object, core.Object, core.StackTrace)))();
  let _FutureListener = () => (_FutureListener = dart.constFn(async._FutureListener$()))();
  let VoidTodynamic = () => (VoidTodynamic = dart.constFn(dart.functionType(dart.dynamic, [])))();
  let _Future = () => (_Future = dart.constFn(async._Future$()))();
  let StreamSubscription = () => (StreamSubscription = dart.constFn(async.StreamSubscription$()))();
  let EventSink = () => (EventSink = dart.constFn(async.EventSink$()))();
  let StreamView = () => (StreamView = dart.constFn(async.StreamView$()))();
  let StreamConsumer = () => (StreamConsumer = dart.constFn(async.StreamConsumer$()))();
  let StreamSink = () => (StreamSink = dart.constFn(async.StreamSink$()))();
  let StreamTransformer = () => (StreamTransformer = dart.constFn(async.StreamTransformer$()))();
  let StreamIterator = () => (StreamIterator = dart.constFn(async.StreamIterator$()))();
  let _ControllerEventSinkWrapper = () => (_ControllerEventSinkWrapper = dart.constFn(async._ControllerEventSinkWrapper$()))();
  let StreamController = () => (StreamController = dart.constFn(async.StreamController$()))();
  let SynchronousStreamController = () => (SynchronousStreamController = dart.constFn(async.SynchronousStreamController$()))();
  let _StreamControllerLifecycle = () => (_StreamControllerLifecycle = dart.constFn(async._StreamControllerLifecycle$()))();
  let _StreamController = () => (_StreamController = dart.constFn(async._StreamController$()))();
  let _SyncStreamControllerDispatch = () => (_SyncStreamControllerDispatch = dart.constFn(async._SyncStreamControllerDispatch$()))();
  let _AsyncStreamControllerDispatch = () => (_AsyncStreamControllerDispatch = dart.constFn(async._AsyncStreamControllerDispatch$()))();
  let _AsyncStreamController = () => (_AsyncStreamController = dart.constFn(async._AsyncStreamController$()))();
  let _SyncStreamController = () => (_SyncStreamController = dart.constFn(async._SyncStreamController$()))();
  let _StreamSinkWrapper = () => (_StreamSinkWrapper = dart.constFn(async._StreamSinkWrapper$()))();
  let _AddStreamState = () => (_AddStreamState = dart.constFn(async._AddStreamState$()))();
  let _StreamControllerAddStreamState = () => (_StreamControllerAddStreamState = dart.constFn(async._StreamControllerAddStreamState$()))();
  let _EventSink = () => (_EventSink = dart.constFn(async._EventSink$()))();
  let _EventDispatch = () => (_EventDispatch = dart.constFn(async._EventDispatch$()))();
  let _EventGenerator = () => (_EventGenerator = dart.constFn(async._EventGenerator$()))();
  let _GeneratedStreamImpl = () => (_GeneratedStreamImpl = dart.constFn(async._GeneratedStreamImpl$()))();
  let _PendingEvents = () => (_PendingEvents = dart.constFn(async._PendingEvents$()))();
  let _IterablePendingEvents = () => (_IterablePendingEvents = dart.constFn(async._IterablePendingEvents$()))();
  let _DataHandler = () => (_DataHandler = dart.constFn(async._DataHandler$()))();
  let _DelayedEvent = () => (_DelayedEvent = dart.constFn(async._DelayedEvent$()))();
  let _DelayedData = () => (_DelayedData = dart.constFn(async._DelayedData$()))();
  let _StreamImplEvents = () => (_StreamImplEvents = dart.constFn(async._StreamImplEvents$()))();
  let _BroadcastCallback = () => (_BroadcastCallback = dart.constFn(async._BroadcastCallback$()))();
  let _DoneStreamSubscription = () => (_DoneStreamSubscription = dart.constFn(async._DoneStreamSubscription$()))();
  let _AsBroadcastStream = () => (_AsBroadcastStream = dart.constFn(async._AsBroadcastStream$()))();
  let _BroadcastSubscriptionWrapper = () => (_BroadcastSubscriptionWrapper = dart.constFn(async._BroadcastSubscriptionWrapper$()))();
  let _StreamIteratorImpl = () => (_StreamIteratorImpl = dart.constFn(async._StreamIteratorImpl$()))();
  let _EmptyStream = () => (_EmptyStream = dart.constFn(async._EmptyStream$()))();
  let _ForwardingStream = () => (_ForwardingStream = dart.constFn(async._ForwardingStream$()))();
  let _ForwardingStreamSubscription = () => (_ForwardingStreamSubscription = dart.constFn(async._ForwardingStreamSubscription$()))();
  let _Predicate = () => (_Predicate = dart.constFn(async._Predicate$()))();
  let _WhereStream = () => (_WhereStream = dart.constFn(async._WhereStream$()))();
  let _Transformation$ = () => (_Transformation$ = dart.constFn(async._Transformation$()))();
  let _MapStream = () => (_MapStream = dart.constFn(async._MapStream$()))();
  let _ExpandStream = () => (_ExpandStream = dart.constFn(async._ExpandStream$()))();
  let _HandleErrorStream = () => (_HandleErrorStream = dart.constFn(async._HandleErrorStream$()))();
  let _TakeStream = () => (_TakeStream = dart.constFn(async._TakeStream$()))();
  let _StateStreamSubscription = () => (_StateStreamSubscription = dart.constFn(async._StateStreamSubscription$()))();
  let _TakeWhileStream = () => (_TakeWhileStream = dart.constFn(async._TakeWhileStream$()))();
  let _SkipStream = () => (_SkipStream = dart.constFn(async._SkipStream$()))();
  let _SkipWhileStream = () => (_SkipWhileStream = dart.constFn(async._SkipWhileStream$()))();
  let _Equality = () => (_Equality = dart.constFn(async._Equality$()))();
  let _DistinctStream = () => (_DistinctStream = dart.constFn(async._DistinctStream$()))();
  let _EventSinkWrapper = () => (_EventSinkWrapper = dart.constFn(async._EventSinkWrapper$()))();
  let _SinkTransformerStreamSubscription = () => (_SinkTransformerStreamSubscription = dart.constFn(async._SinkTransformerStreamSubscription$()))();
  let _SinkMapper = () => (_SinkMapper = dart.constFn(async._SinkMapper$()))();
  let _StreamSinkTransformer = () => (_StreamSinkTransformer = dart.constFn(async._StreamSinkTransformer$()))();
  let _BoundSinkStream = () => (_BoundSinkStream = dart.constFn(async._BoundSinkStream$()))();
  let _TransformDataHandler = () => (_TransformDataHandler = dart.constFn(async._TransformDataHandler$()))();
  let _TransformErrorHandler = () => (_TransformErrorHandler = dart.constFn(async._TransformErrorHandler$()))();
  let _TransformDoneHandler = () => (_TransformDoneHandler = dart.constFn(async._TransformDoneHandler$()))();
  let _HandlerEventSink = () => (_HandlerEventSink = dart.constFn(async._HandlerEventSink$()))();
  let _StreamHandlerTransformer = () => (_StreamHandlerTransformer = dart.constFn(async._StreamHandlerTransformer$()))();
  let _SubscriptionTransformer = () => (_SubscriptionTransformer = dart.constFn(async._SubscriptionTransformer$()))();
  let _StreamSubscriptionTransformer = () => (_StreamSubscriptionTransformer = dart.constFn(async._StreamSubscriptionTransformer$()))();
  let _BoundSubscriptionStream = () => (_BoundSubscriptionStream = dart.constFn(async._BoundSubscriptionStream$()))();
  let ZoneCallback = () => (ZoneCallback = dart.constFn(async.ZoneCallback$()))();
  let ZoneUnaryCallback = () => (ZoneUnaryCallback = dart.constFn(async.ZoneUnaryCallback$()))();
  let ZoneBinaryCallback = () => (ZoneBinaryCallback = dart.constFn(async.ZoneBinaryCallback$()))();
  let HandleUncaughtErrorHandler = () => (HandleUncaughtErrorHandler = dart.constFn(async.HandleUncaughtErrorHandler$()))();
  let RunHandler = () => (RunHandler = dart.constFn(async.RunHandler$()))();
  let RunUnaryHandler = () => (RunUnaryHandler = dart.constFn(async.RunUnaryHandler$()))();
  let RunBinaryHandler = () => (RunBinaryHandler = dart.constFn(async.RunBinaryHandler$()))();
  let RegisterCallbackHandler = () => (RegisterCallbackHandler = dart.constFn(async.RegisterCallbackHandler$()))();
  let RegisterUnaryCallbackHandler = () => (RegisterUnaryCallbackHandler = dart.constFn(async.RegisterUnaryCallbackHandler$()))();
  let RegisterBinaryCallbackHandler = () => (RegisterBinaryCallbackHandler = dart.constFn(async.RegisterBinaryCallbackHandler$()))();
  let _ZoneFunction = () => (_ZoneFunction = dart.constFn(async._ZoneFunction$()))();
  let _ZoneFunctionOfRunHandler = () => (_ZoneFunctionOfRunHandler = dart.constFn(async._ZoneFunction$(async.RunHandler)))();
  let _ZoneFunctionOfRunUnaryHandler = () => (_ZoneFunctionOfRunUnaryHandler = dart.constFn(async._ZoneFunction$(async.RunUnaryHandler)))();
  let _ZoneFunctionOfRunBinaryHandler = () => (_ZoneFunctionOfRunBinaryHandler = dart.constFn(async._ZoneFunction$(async.RunBinaryHandler)))();
  let _ZoneFunctionOfRegisterCallbackHandler = () => (_ZoneFunctionOfRegisterCallbackHandler = dart.constFn(async._ZoneFunction$(async.RegisterCallbackHandler)))();
  let _ZoneFunctionOfRegisterUnaryCallbackHandler = () => (_ZoneFunctionOfRegisterUnaryCallbackHandler = dart.constFn(async._ZoneFunction$(async.RegisterUnaryCallbackHandler)))();
  let _ZoneFunctionOfRegisterBinaryCallbackHandler = () => (_ZoneFunctionOfRegisterBinaryCallbackHandler = dart.constFn(async._ZoneFunction$(async.RegisterBinaryCallbackHandler)))();
  let _ZoneFunctionOfErrorCallbackHandler = () => (_ZoneFunctionOfErrorCallbackHandler = dart.constFn(async._ZoneFunction$(async.ErrorCallbackHandler)))();
  let _ZoneFunctionOfScheduleMicrotaskHandler = () => (_ZoneFunctionOfScheduleMicrotaskHandler = dart.constFn(async._ZoneFunction$(async.ScheduleMicrotaskHandler)))();
  let _ZoneFunctionOfCreateTimerHandler = () => (_ZoneFunctionOfCreateTimerHandler = dart.constFn(async._ZoneFunction$(async.CreateTimerHandler)))();
  let _ZoneFunctionOfCreatePeriodicTimerHandler = () => (_ZoneFunctionOfCreatePeriodicTimerHandler = dart.constFn(async._ZoneFunction$(async.CreatePeriodicTimerHandler)))();
  let _ZoneFunctionOfPrintHandler = () => (_ZoneFunctionOfPrintHandler = dart.constFn(async._ZoneFunction$(async.PrintHandler)))();
  let _ZoneFunctionOfForkHandler = () => (_ZoneFunctionOfForkHandler = dart.constFn(async._ZoneFunction$(async.ForkHandler)))();
  let _ZoneFunctionOfHandleUncaughtErrorHandler = () => (_ZoneFunctionOfHandleUncaughtErrorHandler = dart.constFn(async._ZoneFunction$(async.HandleUncaughtErrorHandler)))();
  let TimerTovoid = () => (TimerTovoid = dart.constFn(dart.functionType(dart.void, [async.Timer])))();
  let _HashMap = () => (_HashMap = dart.constFn(collection._HashMap$()))();
  let _IdentityHashMap = () => (_IdentityHashMap = dart.constFn(collection._IdentityHashMap$()))();
  let _CustomHashMap = () => (_CustomHashMap = dart.constFn(collection._CustomHashMap$()))();
  let _HashMapKeyIterable = () => (_HashMapKeyIterable = dart.constFn(collection._HashMapKeyIterable$()))();
  let _HashMapKeyIterator = () => (_HashMapKeyIterator = dart.constFn(collection._HashMapKeyIterator$()))();
  let _LinkedIdentityHashMap = () => (_LinkedIdentityHashMap = dart.constFn(collection._LinkedIdentityHashMap$()))();
  let _Es6LinkedIdentityHashMap = () => (_Es6LinkedIdentityHashMap = dart.constFn(collection._Es6LinkedIdentityHashMap$()))();
  let _Es6MapIterable = () => (_Es6MapIterable = dart.constFn(collection._Es6MapIterable$()))();
  let _Es6MapIterator = () => (_Es6MapIterator = dart.constFn(collection._Es6MapIterator$()))();
  let _LinkedCustomHashMap = () => (_LinkedCustomHashMap = dart.constFn(collection._LinkedCustomHashMap$()))();
  let SetMixin = () => (SetMixin = dart.constFn(collection.SetMixin$()))();
  let SetBase = () => (SetBase = dart.constFn(collection.SetBase$()))();
  let _HashSetBase = () => (_HashSetBase = dart.constFn(collection._HashSetBase$()))();
  let _HashSet = () => (_HashSet = dart.constFn(collection._HashSet$()))();
  let _IdentityHashSet = () => (_IdentityHashSet = dart.constFn(collection._IdentityHashSet$()))();
  let _CustomHashSet = () => (_CustomHashSet = dart.constFn(collection._CustomHashSet$()))();
  let _HashSetIterator = () => (_HashSetIterator = dart.constFn(collection._HashSetIterator$()))();
  let _LinkedHashSet = () => (_LinkedHashSet = dart.constFn(collection._LinkedHashSet$()))();
  let _LinkedIdentityHashSet = () => (_LinkedIdentityHashSet = dart.constFn(collection._LinkedIdentityHashSet$()))();
  let _LinkedCustomHashSet = () => (_LinkedCustomHashSet = dart.constFn(collection._LinkedCustomHashSet$()))();
  let _LinkedHashSetCell = () => (_LinkedHashSetCell = dart.constFn(collection._LinkedHashSetCell$()))();
  let _LinkedHashSetIterator = () => (_LinkedHashSetIterator = dart.constFn(collection._LinkedHashSetIterator$()))();
  let UnmodifiableListView = () => (UnmodifiableListView = dart.constFn(collection.UnmodifiableListView$()))();
  let _Equality$ = () => (_Equality$ = dart.constFn(collection._Equality$()))();
  let _Hasher = () => (_Hasher = dart.constFn(collection._Hasher$()))();
  let ObjectTobool = () => (ObjectTobool = dart.constFn(dart.functionType(core.bool, [core.Object])))();
  let HashMap = () => (HashMap = dart.constFn(collection.HashMap$()))();
  let HashSet = () => (HashSet = dart.constFn(collection.HashSet$()))();
  let IterableMixin = () => (IterableMixin = dart.constFn(collection.IterableMixin$()))();
  let HasNextIterator = () => (HasNextIterator = dart.constFn(collection.HasNextIterator$()))();
  let LinkedHashMap = () => (LinkedHashMap = dart.constFn(collection.LinkedHashMap$()))();
  let LinkedHashSet = () => (LinkedHashSet = dart.constFn(collection.LinkedHashSet$()))();
  let LinkedList = () => (LinkedList = dart.constFn(collection.LinkedList$()))();
  let _LinkedListIterator = () => (_LinkedListIterator = dart.constFn(collection._LinkedListIterator$()))();
  let LinkedListEntry = () => (LinkedListEntry = dart.constFn(collection.LinkedListEntry$()))();
  let MapMixin = () => (MapMixin = dart.constFn(collection.MapMixin$()))();
  let MapBase = () => (MapBase = dart.constFn(collection.MapBase$()))();
  let _UnmodifiableMapMixin = () => (_UnmodifiableMapMixin = dart.constFn(collection._UnmodifiableMapMixin$()))();
  let UnmodifiableMapBase = () => (UnmodifiableMapBase = dart.constFn(collection.UnmodifiableMapBase$()))();
  let _MapBaseValueIterable = () => (_MapBaseValueIterable = dart.constFn(collection._MapBaseValueIterable$()))();
  let _MapBaseValueIterator = () => (_MapBaseValueIterator = dart.constFn(collection._MapBaseValueIterator$()))();
  let MapView = () => (MapView = dart.constFn(collection.MapView$()))();
  let UnmodifiableMapView = () => (UnmodifiableMapView = dart.constFn(collection.UnmodifiableMapView$()))();
  let Queue = () => (Queue = dart.constFn(collection.Queue$()))();
  let _DoubleLink = () => (_DoubleLink = dart.constFn(collection._DoubleLink$()))();
  let DoubleLinkedQueueEntry = () => (DoubleLinkedQueueEntry = dart.constFn(collection.DoubleLinkedQueueEntry$()))();
  let _UserDoubleLinkedQueueEntry = () => (_UserDoubleLinkedQueueEntry = dart.constFn(collection._UserDoubleLinkedQueueEntry$()))();
  let _DoubleLinkedQueueEntry = () => (_DoubleLinkedQueueEntry = dart.constFn(collection._DoubleLinkedQueueEntry$()))();
  let _DoubleLinkedQueueElement = () => (_DoubleLinkedQueueElement = dart.constFn(collection._DoubleLinkedQueueElement$()))();
  let _DoubleLinkedQueueSentinel = () => (_DoubleLinkedQueueSentinel = dart.constFn(collection._DoubleLinkedQueueSentinel$()))();
  let DoubleLinkedQueue = () => (DoubleLinkedQueue = dart.constFn(collection.DoubleLinkedQueue$()))();
  let _DoubleLinkedQueueIterator = () => (_DoubleLinkedQueueIterator = dart.constFn(collection._DoubleLinkedQueueIterator$()))();
  let ListQueue = () => (ListQueue = dart.constFn(collection.ListQueue$()))();
  let _ListQueueIterator = () => (_ListQueueIterator = dart.constFn(collection._ListQueueIterator$()))();
  let _Predicate$ = () => (_Predicate$ = dart.constFn(collection._Predicate$()))();
  let _SplayTreeNode = () => (_SplayTreeNode = dart.constFn(collection._SplayTreeNode$()))();
  let _SplayTreeMapNode = () => (_SplayTreeMapNode = dart.constFn(collection._SplayTreeMapNode$()))();
  let _SplayTree = () => (_SplayTree = dart.constFn(collection._SplayTree$()))();
  let _TypeTest = () => (_TypeTest = dart.constFn(collection._TypeTest$()))();
  let SplayTreeMap = () => (SplayTreeMap = dart.constFn(collection.SplayTreeMap$()))();
  let _SplayTreeIterator = () => (_SplayTreeIterator = dart.constFn(collection._SplayTreeIterator$()))();
  let _SplayTreeKeyIterable = () => (_SplayTreeKeyIterable = dart.constFn(collection._SplayTreeKeyIterable$()))();
  let _SplayTreeValueIterable = () => (_SplayTreeValueIterable = dart.constFn(collection._SplayTreeValueIterable$()))();
  let _SplayTreeKeyIterator = () => (_SplayTreeKeyIterator = dart.constFn(collection._SplayTreeKeyIterator$()))();
  let _SplayTreeValueIterator = () => (_SplayTreeValueIterator = dart.constFn(collection._SplayTreeValueIterator$()))();
  let _SplayTreeNodeIterator = () => (_SplayTreeNodeIterator = dart.constFn(collection._SplayTreeNodeIterator$()))();
  let SplayTreeSet = () => (SplayTreeSet = dart.constFn(collection.SplayTreeSet$()))();
  let dynamicAnddynamicTodynamic = () => (dynamicAnddynamicTodynamic = dart.constFn(dart.functionType(dart.dynamic, [dart.dynamic, dart.dynamic])))();
  let Codec = () => (Codec = dart.constFn(convert.Codec$()))();
  let ComparableOfString = () => (ComparableOfString = dart.constFn(core.Comparable$(core.String)))();
  let List = () => (List = dart.constFn(core.List$()))();
  let Converter = () => (Converter = dart.constFn(convert.Converter$()))();
  let ChunkedConversionSink = () => (ChunkedConversionSink = dart.constFn(convert.ChunkedConversionSink$()))();
  let _ChunkedConversionCallback = () => (_ChunkedConversionCallback = dart.constFn(convert._ChunkedConversionCallback$()))();
  let ChunkedConverter = () => (ChunkedConverter = dart.constFn(convert.ChunkedConverter$()))();
  let _SimpleCallbackSink = () => (_SimpleCallbackSink = dart.constFn(convert._SimpleCallbackSink$()))();
  let _ConverterStreamEventSink = () => (_ConverterStreamEventSink = dart.constFn(convert._ConverterStreamEventSink$()))();
  let _FusedCodec = () => (_FusedCodec = dart.constFn(convert._FusedCodec$()))();
  let _InvertedCodec = () => (_InvertedCodec = dart.constFn(convert._InvertedCodec$()))();
  let _FusedConverter = () => (_FusedConverter = dart.constFn(convert._FusedConverter$()))();
  let JSArrayOfListOfint = () => (JSArrayOfListOfint = dart.constFn(_interceptors.JSArray$(ListOfint())))();
  let StreamOfString = () => (StreamOfString = dart.constFn(async.Stream$(core.String)))();
  let EventSinkOfString = () => (EventSinkOfString = dart.constFn(async.EventSink$(core.String)))();
  let StreamTransformerOfString$String = () => (StreamTransformerOfString$String = dart.constFn(async.StreamTransformer$(core.String, core.String)))();
  let Comparator = () => (Comparator = dart.constFn(core.Comparator$()))();
  let Comparable = () => (Comparable = dart.constFn(core.Comparable$()))();
  let ComparableOfDateTime = () => (ComparableOfDateTime = dart.constFn(core.Comparable$(core.DateTime)))();
  let ComparableOfDuration = () => (ComparableOfDuration = dart.constFn(core.Comparable$(core.Duration)))();
  let Expando = () => (Expando = dart.constFn(core.Expando$()))();
  let _Generator = () => (_Generator = dart.constFn(core._Generator$()))();
  let _GeneratorIterable = () => (_GeneratorIterable = dart.constFn(core._GeneratorIterable$()))();
  let _GeneratorIterator = () => (_GeneratorIterator = dart.constFn(core._GeneratorIterator$()))();
  let BidirectionalIterator = () => (BidirectionalIterator = dart.constFn(core.BidirectionalIterator$()))();
  let Map$ = () => (Map$ = dart.constFn(core.Map$()))();
  let Set = () => (Set = dart.constFn(core.Set$()))();
  let Sink = () => (Sink = dart.constFn(core.Sink$()))();
  let BidirectionalIteratorOfint = () => (BidirectionalIteratorOfint = dart.constFn(core.BidirectionalIterator$(core.int)))();
  let UnmodifiableMapViewOfString$String = () => (UnmodifiableMapViewOfString$String = dart.constFn(collection.UnmodifiableMapView$(core.String, core.String)))();
  let MapOfString$ListOfString = () => (MapOfString$ListOfString = dart.constFn(core.Map$(core.String, ListOfString())))();
  let MapOfString$String = () => (MapOfString$String = dart.constFn(core.Map$(core.String, core.String)))();
  let IterableOfString = () => (IterableOfString = dart.constFn(core.Iterable$(core.String)))();
  let MapOfString$dynamic = () => (MapOfString$dynamic = dart.constFn(core.Map$(core.String, dart.dynamic)))();
  let FutureOfIsolate = () => (FutureOfIsolate = dart.constFn(async.Future$(isolate.Isolate)))();
  let JsArray = () => (JsArray = dart.constFn(js.JsArray$()))();
  let ExpandoOfFunction = () => (ExpandoOfFunction = dart.constFn(core.Expando$(core.Function)))();
  let PointOfnum = () => (PointOfnum = dart.constFn(math.Point$(core.num)))();
  let Point$ = () => (Point$ = dart.constFn(math.Point$()))();
  let RectangleOfnum = () => (RectangleOfnum = dart.constFn(math.Rectangle$(core.num)))();
  let _RectangleBase = () => (_RectangleBase = dart.constFn(math._RectangleBase$()))();
  let Rectangle = () => (Rectangle = dart.constFn(math.Rectangle$()))();
  let MutableRectangle = () => (MutableRectangle = dart.constFn(math.MutableRectangle$()))();
  let ListOfdouble = () => (ListOfdouble = dart.constFn(core.List$(core.double)))();
  let ListOfFloat32x4 = () => (ListOfFloat32x4 = dart.constFn(core.List$(typed_data.Float32x4)))();
  let ListOfInt32x4 = () => (ListOfInt32x4 = dart.constFn(core.List$(typed_data.Int32x4)))();
  let ListOfFloat64x2 = () => (ListOfFloat64x2 = dart.constFn(core.List$(typed_data.Float64x2)))();
  let EventStreamProviderOfEvent = () => (EventStreamProviderOfEvent = dart.constFn(html$.EventStreamProvider$(html$.Event)))();
  let EventStreamProviderOfVersionChangeEvent = () => (EventStreamProviderOfVersionChangeEvent = dart.constFn(html$.EventStreamProvider$(indexed_db.VersionChangeEvent)))();
  let FutureOfDatabase = () => (FutureOfDatabase = dart.constFn(async.Future$(indexed_db.Database)))();
  let CompleterOfIdbFactory = () => (CompleterOfIdbFactory = dart.constFn(async.Completer$(indexed_db.IdbFactory)))();
  let FutureOfIdbFactory = () => (FutureOfIdbFactory = dart.constFn(async.Future$(indexed_db.IdbFactory)))();
  let FutureOfListOfString = () => (FutureOfListOfString = dart.constFn(async.Future$(ListOfString())))();
  let dynamicTovoid = () => (dynamicTovoid = dart.constFn(dart.functionType(dart.void, [dart.dynamic])))();
  let EventTovoid = () => (EventTovoid = dart.constFn(dart.functionType(dart.void, [html$.Event])))();
  let FutureOfint = () => (FutureOfint = dart.constFn(async.Future$(core.int)))();
  let CompleterOfDatabase = () => (CompleterOfDatabase = dart.constFn(async.Completer$(indexed_db.Database)))();
  let _CustomEventStreamProviderOfWheelEvent = () => (_CustomEventStreamProviderOfWheelEvent = dart.constFn(html$._CustomEventStreamProvider$(html$.WheelEvent)))();
  let _CustomEventStreamProviderOfTransitionEvent = () => (_CustomEventStreamProviderOfTransitionEvent = dart.constFn(html$._CustomEventStreamProvider$(html$.TransitionEvent)))();
  let EventStreamProviderOfMouseEvent = () => (EventStreamProviderOfMouseEvent = dart.constFn(html$.EventStreamProvider$(html$.MouseEvent)))();
  let EventStreamProviderOfClipboardEvent = () => (EventStreamProviderOfClipboardEvent = dart.constFn(html$.EventStreamProvider$(html$.ClipboardEvent)))();
  let EventStreamProviderOfKeyboardEvent = () => (EventStreamProviderOfKeyboardEvent = dart.constFn(html$.EventStreamProvider$(html$.KeyboardEvent)))();
  let EventStreamProviderOfTouchEvent = () => (EventStreamProviderOfTouchEvent = dart.constFn(html$.EventStreamProvider$(html$.TouchEvent)))();
  let ListOfEntry = () => (ListOfEntry = dart.constFn(core.List$(html$.Entry)))();
  let EventStreamProviderOfProgressEvent = () => (EventStreamProviderOfProgressEvent = dart.constFn(html$.EventStreamProvider$(html$.ProgressEvent)))();
  let EventStreamProviderOfMediaKeyEvent = () => (EventStreamProviderOfMediaKeyEvent = dart.constFn(html$.EventStreamProvider$(html$.MediaKeyEvent)))();
  let EventStreamProviderOfMessageEvent = () => (EventStreamProviderOfMessageEvent = dart.constFn(html$.EventStreamProvider$(html$.MessageEvent)))();
  let EventStreamProviderOfPopStateEvent = () => (EventStreamProviderOfPopStateEvent = dart.constFn(html$.EventStreamProvider$(html$.PopStateEvent)))();
  let EventStreamProviderOfStorageEvent = () => (EventStreamProviderOfStorageEvent = dart.constFn(html$.EventStreamProvider$(html$.StorageEvent)))();
  let EventStreamProviderOfContextEvent = () => (EventStreamProviderOfContextEvent = dart.constFn(html$.EventStreamProvider$(web_gl.ContextEvent)))();
  let CompleterOfFileSystem = () => (CompleterOfFileSystem = dart.constFn(async.Completer$(html$.FileSystem)))();
  let CompleterOfEntry = () => (CompleterOfEntry = dart.constFn(async.Completer$(html$.Entry)))();
  let CompleterOfString = () => (CompleterOfString = dart.constFn(async.Completer$(core.String)))();
  let CompleterOfMetadata = () => (CompleterOfMetadata = dart.constFn(async.Completer$(html$.Metadata)))();
  let CompleterOfListOfEntry = () => (CompleterOfListOfEntry = dart.constFn(async.Completer$(ListOfEntry())))();
  let EventStreamProviderOfSecurityPolicyViolationEvent = () => (EventStreamProviderOfSecurityPolicyViolationEvent = dart.constFn(html$.EventStreamProvider$(html$.SecurityPolicyViolationEvent)))();
  let ImmutableListMixin = () => (ImmutableListMixin = dart.constFn(html$.ImmutableListMixin$()))();
  let ListOfElement = () => (ListOfElement = dart.constFn(core.List$(html$.Element)))();
  let ElementList = () => (ElementList = dart.constFn(html$.ElementList$()))();
  let _FrozenElementList = () => (_FrozenElementList = dart.constFn(html$._FrozenElementList$()))();
  let _EventStreamOfEvent = () => (_EventStreamOfEvent = dart.constFn(html$._EventStream$(html$.Event)))();
  let _ElementEventStreamImplOfEvent = () => (_ElementEventStreamImplOfEvent = dart.constFn(html$._ElementEventStreamImpl$(html$.Event)))();
  let CompleterOfFileWriter = () => (CompleterOfFileWriter = dart.constFn(async.Completer$(html$.FileWriter)))();
  let CompleterOfFile = () => (CompleterOfFile = dart.constFn(async.Completer$(html$.File)))();
  let ListOfFile = () => (ListOfFile = dart.constFn(core.List$(html$.File)))();
  let CompleterOfGeoposition = () => (CompleterOfGeoposition = dart.constFn(async.Completer$(html$.Geoposition)))();
  let StreamControllerOfGeoposition = () => (StreamControllerOfGeoposition = dart.constFn(async.StreamController$(html$.Geoposition)))();
  let EventStreamProviderOfWheelEvent = () => (EventStreamProviderOfWheelEvent = dart.constFn(html$.EventStreamProvider$(html$.WheelEvent)))();
  let ListOfNode = () => (ListOfNode = dart.constFn(core.List$(html$.Node)))();
  let _CustomEventStreamProviderOfEvent = () => (_CustomEventStreamProviderOfEvent = dart.constFn(html$._CustomEventStreamProvider$(html$.Event)))();
  let CompleterOfHttpRequest = () => (CompleterOfHttpRequest = dart.constFn(async.Completer$(html$.HttpRequest)))();
  let ProgressEventTovoid = () => (ProgressEventTovoid = dart.constFn(dart.functionType(dart.void, [html$.ProgressEvent])))();
  let ListOfMap = () => (ListOfMap = dart.constFn(core.List$(core.Map)))();
  let ListOfMediaStreamTrack = () => (ListOfMediaStreamTrack = dart.constFn(core.List$(html$.MediaStreamTrack)))();
  let ListOfSourceInfo = () => (ListOfSourceInfo = dart.constFn(core.List$(html$.SourceInfo)))();
  let CompleterOfListOfSourceInfo = () => (CompleterOfListOfSourceInfo = dart.constFn(async.Completer$(ListOfSourceInfo())))();
  let ListOfMessagePort = () => (ListOfMessagePort = dart.constFn(core.List$(html$.MessagePort)))();
  let EventStreamProviderOfMidiMessageEvent = () => (EventStreamProviderOfMidiMessageEvent = dart.constFn(html$.EventStreamProvider$(html$.MidiMessageEvent)))();
  let ListOfMimeType = () => (ListOfMimeType = dart.constFn(core.List$(html$.MimeType)))();
  let CompleterOfMediaStream = () => (CompleterOfMediaStream = dart.constFn(async.Completer$(html$.MediaStream)))();
  let ListOfPlugin = () => (ListOfPlugin = dart.constFn(core.List$(html$.Plugin)))();
  let EventStreamProviderOfRtcDtmfToneChangeEvent = () => (EventStreamProviderOfRtcDtmfToneChangeEvent = dart.constFn(html$.EventStreamProvider$(html$.RtcDtmfToneChangeEvent)))();
  let JSArrayOfMapOfString$String = () => (JSArrayOfMapOfString$String = dart.constFn(_interceptors.JSArray$(MapOfString$String())))();
  let CompleterOfRtcSessionDescription = () => (CompleterOfRtcSessionDescription = dart.constFn(async.Completer$(html$.RtcSessionDescription)))();
  let CompleterOfRtcStatsResponse = () => (CompleterOfRtcStatsResponse = dart.constFn(async.Completer$(html$.RtcStatsResponse)))();
  let EventStreamProviderOfMediaStreamEvent = () => (EventStreamProviderOfMediaStreamEvent = dart.constFn(html$.EventStreamProvider$(html$.MediaStreamEvent)))();
  let EventStreamProviderOfRtcDataChannelEvent = () => (EventStreamProviderOfRtcDataChannelEvent = dart.constFn(html$.EventStreamProvider$(html$.RtcDataChannelEvent)))();
  let EventStreamProviderOfRtcIceCandidateEvent = () => (EventStreamProviderOfRtcIceCandidateEvent = dart.constFn(html$.EventStreamProvider$(html$.RtcIceCandidateEvent)))();
  let ListOfOptionElement = () => (ListOfOptionElement = dart.constFn(core.List$(html$.OptionElement)))();
  let UnmodifiableListViewOfOptionElement = () => (UnmodifiableListViewOfOptionElement = dart.constFn(collection.UnmodifiableListView$(html$.OptionElement)))();
  let JSArrayOfOptionElement = () => (JSArrayOfOptionElement = dart.constFn(_interceptors.JSArray$(html$.OptionElement)))();
  let ListOfSourceBuffer = () => (ListOfSourceBuffer = dart.constFn(core.List$(html$.SourceBuffer)))();
  let ListOfSpeechGrammar = () => (ListOfSpeechGrammar = dart.constFn(core.List$(html$.SpeechGrammar)))();
  let EventStreamProviderOfSpeechRecognitionError = () => (EventStreamProviderOfSpeechRecognitionError = dart.constFn(html$.EventStreamProvider$(html$.SpeechRecognitionError)))();
  let EventStreamProviderOfSpeechRecognitionEvent = () => (EventStreamProviderOfSpeechRecognitionEvent = dart.constFn(html$.EventStreamProvider$(html$.SpeechRecognitionEvent)))();
  let EventStreamProviderOfSpeechSynthesisEvent = () => (EventStreamProviderOfSpeechSynthesisEvent = dart.constFn(html$.EventStreamProvider$(html$.SpeechSynthesisEvent)))();
  let _WrappedListOfTableSectionElement = () => (_WrappedListOfTableSectionElement = dart.constFn(html$._WrappedList$(html$.TableSectionElement)))();
  let _WrappedListOfTableRowElement = () => (_WrappedListOfTableRowElement = dart.constFn(html$._WrappedList$(html$.TableRowElement)))();
  let _WrappedListOfTableCellElement = () => (_WrappedListOfTableCellElement = dart.constFn(html$._WrappedList$(html$.TableCellElement)))();
  let ListOfTextTrackCue = () => (ListOfTextTrackCue = dart.constFn(core.List$(html$.TextTrackCue)))();
  let ListOfTextTrack = () => (ListOfTextTrack = dart.constFn(core.List$(html$.TextTrack)))();
  let EventStreamProviderOfTrackEvent = () => (EventStreamProviderOfTrackEvent = dart.constFn(html$.EventStreamProvider$(html$.TrackEvent)))();
  let ListOfTouch = () => (ListOfTouch = dart.constFn(core.List$(html$.Touch)))();
  let EventStreamProviderOfCloseEvent = () => (EventStreamProviderOfCloseEvent = dart.constFn(html$.EventStreamProvider$(html$.CloseEvent)))();
  let CompleterOfnum = () => (CompleterOfnum = dart.constFn(async.Completer$(core.num)))();
  let EventStreamProviderOfDeviceMotionEvent = () => (EventStreamProviderOfDeviceMotionEvent = dart.constFn(html$.EventStreamProvider$(html$.DeviceMotionEvent)))();
  let EventStreamProviderOfDeviceOrientationEvent = () => (EventStreamProviderOfDeviceOrientationEvent = dart.constFn(html$.EventStreamProvider$(html$.DeviceOrientationEvent)))();
  let EventStreamProviderOfAnimationEvent = () => (EventStreamProviderOfAnimationEvent = dart.constFn(html$.EventStreamProvider$(html$.AnimationEvent)))();
  let StreamControllerOfBeforeUnloadEvent = () => (StreamControllerOfBeforeUnloadEvent = dart.constFn(async.StreamController$(html$.BeforeUnloadEvent)))();
  let _ElementListEventStreamImplOfEvent = () => (_ElementListEventStreamImplOfEvent = dart.constFn(html$._ElementListEventStreamImpl$(html$.Event)))();
  let EventStreamProviderOfBeforeUnloadEvent = () => (EventStreamProviderOfBeforeUnloadEvent = dart.constFn(html$.EventStreamProvider$(html$.BeforeUnloadEvent)))();
  let ListOfRectangleOfnum = () => (ListOfRectangleOfnum = dart.constFn(core.List$(RectangleOfnum())))();
  let ListOfCssRule = () => (ListOfCssRule = dart.constFn(core.List$(html$.CssRule)))();
  let ListOfGamepad = () => (ListOfGamepad = dart.constFn(core.List$(html$.Gamepad)))();
  let ListOfSpeechRecognitionResult = () => (ListOfSpeechRecognitionResult = dart.constFn(core.List$(html$.SpeechRecognitionResult)))();
  let ListOfStyleSheet = () => (ListOfStyleSheet = dart.constFn(core.List$(html$.StyleSheet)))();
  let ListOfCssClassSetImpl = () => (ListOfCssClassSetImpl = dart.constFn(core.List$(html_common.CssClassSetImpl)))();
  let LinkedHashSetOfString = () => (LinkedHashSetOfString = dart.constFn(collection.LinkedHashSet$(core.String)))();
  let VoidToString = () => (VoidToString = dart.constFn(dart.functionType(core.String, [])))();
  let EventStreamProvider = () => (EventStreamProvider = dart.constFn(html$.EventStreamProvider$()))();
  let ElementStream = () => (ElementStream = dart.constFn(html$.ElementStream$()))();
  let _EventStream = () => (_EventStream = dart.constFn(html$._EventStream$()))();
  let _ElementEventStreamImpl = () => (_ElementEventStreamImpl = dart.constFn(html$._ElementEventStreamImpl$()))();
  let _ElementListEventStreamImpl = () => (_ElementListEventStreamImpl = dart.constFn(html$._ElementListEventStreamImpl$()))();
  let _EventListener = () => (_EventListener = dart.constFn(html$._EventListener$()))();
  let _wrapZoneCallbackOfEvent$dynamic = () => (_wrapZoneCallbackOfEvent$dynamic = dart.constFn(html$._wrapZoneCallback$(html$.Event, dart.dynamic)))();
  let _EventStreamSubscription = () => (_EventStreamSubscription = dart.constFn(html$._EventStreamSubscription$()))();
  let CustomStream = () => (CustomStream = dart.constFn(html$.CustomStream$()))();
  let _CustomEventStreamImpl = () => (_CustomEventStreamImpl = dart.constFn(html$._CustomEventStreamImpl$()))();
  let CustomStreamOfKeyEvent = () => (CustomStreamOfKeyEvent = dart.constFn(html$.CustomStream$(html$.KeyEvent)))();
  let _StreamPool = () => (_StreamPool = dart.constFn(html$._StreamPool$()))();
  let _CustomEventStreamProvider = () => (_CustomEventStreamProvider = dart.constFn(html$._CustomEventStreamProvider$()))();
  let JSArrayOfKeyEvent = () => (JSArrayOfKeyEvent = dart.constFn(_interceptors.JSArray$(html$.KeyEvent)))();
  let JSArrayOfNodeValidator = () => (JSArrayOfNodeValidator = dart.constFn(_interceptors.JSArray$(html$.NodeValidator)))();
  let _WrappedIteratorOfNode = () => (_WrappedIteratorOfNode = dart.constFn(html$._WrappedIterator$(html$.Node)))();
  let _WrappedList = () => (_WrappedList = dart.constFn(html$._WrappedList$()))();
  let _WrappedIterator = () => (_WrappedIterator = dart.constFn(html$._WrappedIterator$()))();
  let FixedSizeListIterator = () => (FixedSizeListIterator = dart.constFn(html$.FixedSizeListIterator$()))();
  let _VariableSizeListIterator = () => (_VariableSizeListIterator = dart.constFn(html$._VariableSizeListIterator$()))();
  let _wrapZoneCallback = () => (_wrapZoneCallback = dart.constFn(html$._wrapZoneCallback$()))();
  let _wrapZoneBinaryCallback = () => (_wrapZoneBinaryCallback = dart.constFn(html$._wrapZoneBinaryCallback$()))();
  let ElementListOfElement = () => (ElementListOfElement = dart.constFn(html$.ElementList$(html$.Element)))();
  let ListOfLength = () => (ListOfLength = dart.constFn(core.List$(svg$.Length)))();
  let ListOfNumber = () => (ListOfNumber = dart.constFn(core.List$(svg$.Number)))();
  let ListOfPathSeg = () => (ListOfPathSeg = dart.constFn(core.List$(svg$.PathSeg)))();
  let ListOfTransform = () => (ListOfTransform = dart.constFn(core.List$(svg$.Transform)))();
  let CompleterOfAudioBuffer = () => (CompleterOfAudioBuffer = dart.constFn(async.Completer$(web_audio.AudioBuffer)))();
  let EventStreamProviderOfAudioProcessingEvent = () => (EventStreamProviderOfAudioProcessingEvent = dart.constFn(html$.EventStreamProvider$(web_audio.AudioProcessingEvent)))();
  let StringAndStringToint = () => (StringAndStringToint = dart.constFn(dart.definiteFunctionType(core.int, [core.String, core.String])))();
  let dynamicTodynamic$ = () => (dynamicTodynamic$ = dart.constFn(dart.definiteFunctionType(dart.dynamic, [dart.dynamic])))();
  let dynamicToString = () => (dynamicToString = dart.constFn(dart.definiteFunctionType(core.String, [dart.dynamic])))();
  let dynamicToListOfString = () => (dynamicToListOfString = dart.constFn(dart.definiteFunctionType(ListOfString(), [dart.dynamic])))();
  let dynamicToList = () => (dynamicToList = dart.constFn(dart.definiteFunctionType(core.List, [dart.dynamic])))();
  let TypeToString = () => (TypeToString = dart.constFn(dart.definiteFunctionType(core.String, [core.Type])))();
  let dynamicAndStringTobool = () => (dynamicAndStringTobool = dart.constFn(dart.definiteFunctionType(core.bool, [dart.dynamic, core.String])))();
  let dynamicTobool$ = () => (dynamicTobool$ = dart.constFn(dart.definiteFunctionType(core.bool, [dart.dynamic])))();
  let dynamicAnddynamicTovoid = () => (dynamicAnddynamicTovoid = dart.constFn(dart.definiteFunctionType(dart.void, [dart.dynamic, dart.dynamic])))();
  let VoidTodynamic$ = () => (VoidTodynamic$ = dart.constFn(dart.definiteFunctionType(dart.dynamic, [])))();
  let StringAndString__Todynamic = () => (StringAndString__Todynamic = dart.constFn(dart.definiteFunctionType(dart.dynamic, [core.String, core.String], [dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic])))();
  let VoidToIsolateContext = () => (VoidToIsolateContext = dart.constFn(dart.definiteFunctionType(_foreign_helper.IsolateContext, [])))();
  let dynamicAndFunctionTodynamic = () => (dynamicAndFunctionTodynamic = dart.constFn(dart.definiteFunctionType(dart.dynamic, [dart.dynamic, core.Function])))();
  let dynamicTovoid$ = () => (dynamicTovoid$ = dart.constFn(dart.definiteFunctionType(dart.void, [dart.dynamic])))();
  let TypeTodynamic = () => (TypeTodynamic = dart.constFn(dart.definiteFunctionType(dart.dynamic, [core.Type])))();
  let VoidToString$ = () => (VoidToString$ = dart.constFn(dart.definiteFunctionType(core.String, [])))();
  let StringToString$ = () => (StringToString$ = dart.constFn(dart.definiteFunctionType(core.String, [core.String])))();
  let StringAndStringTodynamic = () => (StringAndStringTodynamic = dart.constFn(dart.definiteFunctionType(dart.dynamic, [core.String, core.String])))();
  let StringTobool = () => (StringTobool = dart.constFn(dart.definiteFunctionType(core.bool, [core.String])))();
  let FunctionTovoid = () => (FunctionTovoid = dart.constFn(dart.definiteFunctionType(dart.void, [core.Function])))();
  let StringAndStringToString = () => (StringAndStringToString = dart.constFn(dart.definiteFunctionType(core.String, [core.String, core.String])))();
  let TypeAndStringTodynamic = () => (TypeAndStringTodynamic = dart.constFn(dart.definiteFunctionType(dart.dynamic, [core.Type, core.String])))();
  let dynamicAnddynamicTodynamic$ = () => (dynamicAnddynamicTodynamic$ = dart.constFn(dart.definiteFunctionType(dart.dynamic, [dart.dynamic, dart.dynamic])))();
  let ListOfEToListOfE = () => (ListOfEToListOfE = dart.constFn(dart.definiteFunctionType(E => [core.List$(E), [core.List$(E)]])))();
  let StringTovoid = () => (StringTovoid = dart.constFn(dart.definiteFunctionType(dart.void, [core.String])))();
  let _IsolateContextAndFunctionTodynamic = () => (_IsolateContextAndFunctionTodynamic = dart.constFn(dart.definiteFunctionType(dart.dynamic, [_isolate_helper._IsolateContext, core.Function])))();
  let VoidTobool = () => (VoidTobool = dart.constFn(dart.definiteFunctionType(core.bool, [])))();
  let VoidTo_IsolateContext = () => (VoidTo_IsolateContext = dart.constFn(dart.definiteFunctionType(_isolate_helper._IsolateContext, [])))();
  let VoidTovoid$ = () => (VoidTovoid$ = dart.constFn(dart.definiteFunctionType(dart.void, [])))();
  let ListTodynamic = () => (ListTodynamic = dart.constFn(dart.definiteFunctionType(dart.dynamic, [core.List])))();
  let StringTodynamic = () => (StringTodynamic = dart.constFn(dart.definiteFunctionType(dart.dynamic, [core.String])))();
  let TimerTovoid$ = () => (TimerTovoid$ = dart.constFn(dart.definiteFunctionType(dart.void, [async.Timer])))();
  let dynamicToFuture = () => (dynamicToFuture = dart.constFn(dart.definiteFunctionType(async.Future, [dart.dynamic])))();
  let boolTodynamic = () => (boolTodynamic = dart.constFn(dart.definiteFunctionType(dart.dynamic, [core.bool])))();
  let dynamicAndStackTraceTovoid = () => (dynamicAndStackTraceTovoid = dart.constFn(dart.definiteFunctionType(dart.void, [dart.dynamic, core.StackTrace])))();
  let VoidToFuture = () => (VoidToFuture = dart.constFn(dart.definiteFunctionType(async.Future, [])))();
  let VoidToint = () => (VoidToint = dart.constFn(dart.definiteFunctionType(core.int, [])))();
  let dynamicAnddynamicToError = () => (dynamicAnddynamicToError = dart.constFn(dart.definiteFunctionType(core.Error, [dart.dynamic, dart.dynamic])))();
  let dynamicAnddynamicAnddynamicToError = () => (dynamicAnddynamicAnddynamicToError = dart.constFn(dart.definiteFunctionType(core.Error, [dart.dynamic, dart.dynamic, dart.dynamic])))();
  let dynamicAnddynamicAnddynamicTodynamic = () => (dynamicAnddynamicAnddynamicTodynamic = dart.constFn(dart.definiteFunctionType(dart.dynamic, [dart.dynamic, dart.dynamic, dart.dynamic])))();
  let dynamicToArgumentError = () => (dynamicToArgumentError = dart.constFn(dart.definiteFunctionType(core.ArgumentError, [dart.dynamic])))();
  let dynamicToStackTrace = () => (dynamicToStackTrace = dart.constFn(dart.definiteFunctionType(core.StackTrace, [dart.dynamic])))();
  let dynamicToint = () => (dynamicToint = dart.constFn(dart.definiteFunctionType(core.int, [dart.dynamic])))();
  let dynamicAndMapTodynamic = () => (dynamicAndMapTodynamic = dart.constFn(dart.definiteFunctionType(dart.dynamic, [dart.dynamic, core.Map])))();
  let dynamicAndStringTodynamic = () => (dynamicAndStringTodynamic = dart.constFn(dart.definiteFunctionType(dart.dynamic, [dart.dynamic, core.String])))();
  let dynamicAndStringAnddynamicTovoid = () => (dynamicAndStringAnddynamicTovoid = dart.constFn(dart.definiteFunctionType(dart.void, [dart.dynamic, core.String, dart.dynamic])))();
  let FAndintToF = () => (FAndintToF = dart.constFn(dart.definiteFunctionType(F => [F, [F, core.int]])))();
  let JSSyntaxRegExpTodynamic = () => (JSSyntaxRegExpTodynamic = dart.constFn(dart.definiteFunctionType(dart.dynamic, [_js_helper.JSSyntaxRegExp])))();
  let JSSyntaxRegExpToint = () => (JSSyntaxRegExpToint = dart.constFn(dart.definiteFunctionType(core.int, [_js_helper.JSSyntaxRegExp])))();
  let JSSyntaxRegExpAndStringAndintToMatch = () => (JSSyntaxRegExpAndStringAndintToMatch = dart.constFn(dart.definiteFunctionType(core.Match, [_js_helper.JSSyntaxRegExp, core.String, core.int])))();
  let dynamicAnddynamicAnddynamicToint = () => (dynamicAnddynamicAnddynamicToint = dart.constFn(dart.definiteFunctionType(core.int, [dart.dynamic, dart.dynamic, dart.dynamic])))();
  let dynamicAnddynamicToString = () => (dynamicAnddynamicToString = dart.constFn(dart.definiteFunctionType(core.String, [dart.dynamic, dart.dynamic])))();
  let dynamicAnddynamicAnddynamicToString = () => (dynamicAnddynamicAnddynamicToString = dart.constFn(dart.definiteFunctionType(core.String, [dart.dynamic, dart.dynamic, dart.dynamic])))();
  let dynamicAnddynamicAnddynamicTobool = () => (dynamicAnddynamicAnddynamicTobool = dart.constFn(dart.definiteFunctionType(core.bool, [dart.dynamic, dart.dynamic, dart.dynamic])))();
  let StringAndStringAndintToIterableOfMatch = () => (StringAndStringAndintToIterableOfMatch = dart.constFn(dart.definiteFunctionType(IterableOfMatch(), [core.String, core.String, core.int])))();
  let StringAnddynamicAndintTobool = () => (StringAnddynamicAndintTobool = dart.constFn(dart.definiteFunctionType(core.bool, [core.String, dart.dynamic, core.int])))();
  let StringAndJSSyntaxRegExpAndString__ToString = () => (StringAndJSSyntaxRegExpAndString__ToString = dart.constFn(dart.definiteFunctionType(core.String, [core.String, _js_helper.JSSyntaxRegExp, core.String, core.int])))();
  let StringAndPatternAndStringToString = () => (StringAndPatternAndStringToString = dart.constFn(dart.definiteFunctionType(core.String, [core.String, core.Pattern, core.String])))();
  let MatchToString$ = () => (MatchToString$ = dart.constFn(dart.definiteFunctionType(core.String, [core.Match])))();
  let StringAndPatternAndFn__ToString = () => (StringAndPatternAndFn__ToString = dart.constFn(dart.definiteFunctionType(core.String, [core.String, core.Pattern, MatchToString(), StringToString()])))();
  let StringAndFnAndFnToString = () => (StringAndFnAndFnToString = dart.constFn(dart.definiteFunctionType(core.String, [core.String, MatchToString(), StringToString()])))();
  let StringAndStringAndFn__ToString = () => (StringAndStringAndFn__ToString = dart.constFn(dart.definiteFunctionType(core.String, [core.String, core.String, MatchToString(), StringToString()])))();
  let StringAndPatternAndString__ToString = () => (StringAndPatternAndString__ToString = dart.constFn(dart.definiteFunctionType(core.String, [core.String, core.Pattern, core.String, core.int])))();
  let StringAndPatternAndFn__ToString$ = () => (StringAndPatternAndFn__ToString$ = dart.constFn(dart.definiteFunctionType(core.String, [core.String, core.Pattern, MatchToString(), core.int])))();
  let StringAndintAndint__ToString = () => (StringAndintAndint__ToString = dart.constFn(dart.definiteFunctionType(core.String, [core.String, core.int, core.int, core.String])))();
  let dynamicToType = () => (dynamicToType = dart.constFn(dart.definiteFunctionType(core.Type, [dart.dynamic])))();
  let dynamicAndintTodynamic = () => (dynamicAndintTodynamic = dart.constFn(dart.definiteFunctionType(dart.dynamic, [dart.dynamic, core.int])))();
  let SymbolToString = () => (SymbolToString = dart.constFn(dart.definiteFunctionType(core.String, [core.Symbol])))();
  let dynamicAnddynamicToSymbol = () => (dynamicAnddynamicToSymbol = dart.constFn(dart.definiteFunctionType(core.Symbol, [dart.dynamic, dart.dynamic])))();
  let dynamicToInstanceMirror = () => (dynamicToInstanceMirror = dart.constFn(dart.definiteFunctionType(mirrors.InstanceMirror, [dart.dynamic])))();
  let TypeToTypeMirror = () => (TypeToTypeMirror = dart.constFn(dart.definiteFunctionType(mirrors.TypeMirror, [core.Type])))();
  let dynamicAndStringAndListTodynamic = () => (dynamicAndStringAndListTodynamic = dart.constFn(dart.definiteFunctionType(dart.dynamic, [dart.dynamic, core.String, core.List])))();
  let SymbolAnddynamicTovoid = () => (SymbolAnddynamicTovoid = dart.constFn(dart.definiteFunctionType(dart.void, [core.Symbol, dart.dynamic])))();
  let dynamicToJsInstanceMirror = () => (dynamicToJsInstanceMirror = dart.constFn(dart.definiteFunctionType(_js_mirrors.JsInstanceMirror, [dart.dynamic])))();
  let TypeToJsClassMirror = () => (TypeToJsClassMirror = dart.constFn(dart.definiteFunctionType(_js_mirrors.JsClassMirror, [core.Type])))();
  let dynamicAnddynamicAnddynamicTovoid = () => (dynamicAnddynamicAnddynamicTovoid = dart.constFn(dart.definiteFunctionType(dart.void, [dart.dynamic, dart.dynamic, dart.dynamic])))();
  let ListToList = () => (ListToList = dart.constFn(dart.definiteFunctionType(core.List, [core.List])))();
  let intTobool = () => (intTobool = dart.constFn(dart.definiteFunctionType(core.bool, [core.int])))();
  let intAndListAndintTovoid = () => (intAndListAndintTovoid = dart.constFn(dart.definiteFunctionType(dart.void, [core.int, core.List, core.int])))();
  let intAndintAndintToint = () => (intAndintAndintToint = dart.constFn(dart.definiteFunctionType(core.int, [core.int, core.int, core.int])))();
  let FunctionAndObjectAndStackTraceTodynamic = () => (FunctionAndObjectAndStackTraceTodynamic = dart.constFn(dart.definiteFunctionType(dart.dynamic, [core.Function, core.Object, core.StackTrace])))();
  let FunctionAndZoneToFunction = () => (FunctionAndZoneToFunction = dart.constFn(dart.definiteFunctionType(R => [core.Function, [core.Function, async.Zone]])))();
  let VoidToObject$ = () => (VoidToObject$ = dart.constFn(dart.definiteFunctionType(core.Object, [])))();
  let _FutureAnddynamicAnddynamicTovoid = () => (_FutureAnddynamicAnddynamicTovoid = dart.constFn(dart.definiteFunctionType(dart.void, [async._Future, dart.dynamic, dart.dynamic])))();
  let ObjectToObject = () => (ObjectToObject = dart.constFn(dart.definiteFunctionType(core.Object, [core.Object])))();
  let dynamic__Todynamic = () => (dynamic__Todynamic = dart.constFn(dart.definiteFunctionType(dart.dynamic, [dart.dynamic], [dart.dynamic])))();
  let dynamicTo_Future = () => (dynamicTo_Future = dart.constFn(dart.definiteFunctionType(async._Future, [dart.dynamic])))();
  let _AsyncCallbackTovoid = () => (_AsyncCallbackTovoid = dart.constFn(dart.definiteFunctionType(dart.void, [async._AsyncCallback])))();
  let FnTodynamic = () => (FnTodynamic = dart.constFn(dart.definiteFunctionType(dart.dynamic, [VoidTovoid()])))();
  let _NotificationHandlerToFuture = () => (_NotificationHandlerToFuture = dart.constFn(dart.definiteFunctionType(async.Future, [async._NotificationHandler])))();
  let dynamicAndStackTraceTodynamic = () => (dynamicAndStackTraceTodynamic = dart.constFn(dart.definiteFunctionType(dart.dynamic, [dart.dynamic, core.StackTrace])))();
  let dynamic__Tovoid = () => (dynamic__Tovoid = dart.constFn(dart.definiteFunctionType(dart.void, [dart.dynamic], [core.StackTrace])))();
  let FnAndFnAndFnTodynamic = () => (FnAndFnAndFnTodynamic = dart.constFn(dart.definiteFunctionType(dart.dynamic, [VoidTodynamic(), dynamicTodynamic(), ZoneBinaryCallbackOfdynamic$dynamic$StackTrace()])))();
  let StreamSubscriptionAnd_FutureAnddynamic__Tovoid = () => (StreamSubscriptionAnd_FutureAnddynamic__Tovoid = dart.constFn(dart.definiteFunctionType(dart.void, [async.StreamSubscription, async._Future, dart.dynamic, core.StackTrace])))();
  let StreamSubscriptionAnd_FutureTo_ErrorCallback = () => (StreamSubscriptionAnd_FutureTo_ErrorCallback = dart.constFn(dart.definiteFunctionType(async._ErrorCallback, [async.StreamSubscription, async._Future])))();
  let StreamSubscriptionAnd_FutureAnddynamicTovoid = () => (StreamSubscriptionAnd_FutureAnddynamicTovoid = dart.constFn(dart.definiteFunctionType(dart.void, [async.StreamSubscription, async._Future, dart.dynamic])))();
  let _EventSinkAnddynamicAnddynamicTovoid = () => (_EventSinkAnddynamicAnddynamicTovoid = dart.constFn(dart.definiteFunctionType(dart.void, [async._EventSink, dart.dynamic, dart.dynamic])))();
  let _ZoneToZoneDelegate = () => (_ZoneToZoneDelegate = dart.constFn(dart.definiteFunctionType(async.ZoneDelegate, [async._Zone])))();
  let ZoneAndZoneDelegateAndZone__ToR = () => (ZoneAndZoneDelegateAndZone__ToR = dart.constFn(dart.definiteFunctionType(R => [R, [async.Zone, async.ZoneDelegate, async.Zone, dart.dynamic, core.StackTrace]])))();
  let ObjectAndStackTraceTovoid = () => (ObjectAndStackTraceTovoid = dart.constFn(dart.definiteFunctionType(dart.void, [core.Object, core.StackTrace])))();
  let ZoneAndZoneDelegateAndZone__ToR$ = () => (ZoneAndZoneDelegateAndZone__ToR$ = dart.constFn(dart.definiteFunctionType(R => [R, [async.Zone, async.ZoneDelegate, async.Zone, dart.functionType(R, [])]])))();
  let ZoneAndZoneDelegateAndZone__ToR$0 = () => (ZoneAndZoneDelegateAndZone__ToR$0 = dart.constFn(dart.definiteFunctionType((R, T) => [R, [async.Zone, async.ZoneDelegate, async.Zone, dart.functionType(R, [T]), T]])))();
  let ZoneAndZoneDelegateAndZone__ToR$1 = () => (ZoneAndZoneDelegateAndZone__ToR$1 = dart.constFn(dart.definiteFunctionType((R, T1, T2) => [R, [async.Zone, async.ZoneDelegate, async.Zone, dart.functionType(R, [T1, T2]), T1, T2]])))();
  let ZoneAndZoneDelegateAndZone__ToZoneCallbackOfR = () => (ZoneAndZoneDelegateAndZone__ToZoneCallbackOfR = dart.constFn(dart.definiteFunctionType(R => [async.ZoneCallback$(R), [async.Zone, async.ZoneDelegate, async.Zone, dart.functionType(R, [])]])))();
  let ZoneAndZoneDelegateAndZone__ToZoneUnaryCallbackOfR$T = () => (ZoneAndZoneDelegateAndZone__ToZoneUnaryCallbackOfR$T = dart.constFn(dart.definiteFunctionType((R, T) => [async.ZoneUnaryCallback$(R, T), [async.Zone, async.ZoneDelegate, async.Zone, dart.functionType(R, [T])]])))();
  let ZoneAndZoneDelegateAndZone__ToZoneBinaryCallbackOfR$T1$T2 = () => (ZoneAndZoneDelegateAndZone__ToZoneBinaryCallbackOfR$T1$T2 = dart.constFn(dart.definiteFunctionType((R, T1, T2) => [async.ZoneBinaryCallback$(R, T1, T2), [async.Zone, async.ZoneDelegate, async.Zone, dart.functionType(R, [T1, T2])]])))();
  let ZoneAndZoneDelegateAndZone__ToAsyncError = () => (ZoneAndZoneDelegateAndZone__ToAsyncError = dart.constFn(dart.definiteFunctionType(async.AsyncError, [async.Zone, async.ZoneDelegate, async.Zone, core.Object, core.StackTrace])))();
  let ZoneAndZoneDelegateAndZone__Tovoid = () => (ZoneAndZoneDelegateAndZone__Tovoid = dart.constFn(dart.definiteFunctionType(dart.void, [async.Zone, async.ZoneDelegate, async.Zone, VoidTodynamic()])))();
  let ZoneAndZoneDelegateAndZone__ToTimer = () => (ZoneAndZoneDelegateAndZone__ToTimer = dart.constFn(dart.definiteFunctionType(async.Timer, [async.Zone, async.ZoneDelegate, async.Zone, core.Duration, VoidTovoid()])))();
  let ZoneAndZoneDelegateAndZone__ToTimer$ = () => (ZoneAndZoneDelegateAndZone__ToTimer$ = dart.constFn(dart.definiteFunctionType(async.Timer, [async.Zone, async.ZoneDelegate, async.Zone, core.Duration, TimerTovoid()])))();
  let ZoneAndZoneDelegateAndZone__Tovoid$ = () => (ZoneAndZoneDelegateAndZone__Tovoid$ = dart.constFn(dart.definiteFunctionType(dart.void, [async.Zone, async.ZoneDelegate, async.Zone, core.String])))();
  let ZoneAndZoneDelegateAndZone__ToZone = () => (ZoneAndZoneDelegateAndZone__ToZone = dart.constFn(dart.definiteFunctionType(async.Zone, [async.Zone, async.ZoneDelegate, async.Zone, async.ZoneSpecification, core.Map])))();
  let ZoneAndZoneDelegateAndZone__Todynamic = () => (ZoneAndZoneDelegateAndZone__Todynamic = dart.constFn(dart.definiteFunctionType(dart.dynamic, [async.Zone, async.ZoneDelegate, async.Zone, dart.dynamic, core.StackTrace])))();
  let Fn__ToR = () => (Fn__ToR = dart.constFn(dart.definiteFunctionType(R => [R, [dart.functionType(R, [])], {zoneValues: core.Map, zoneSpecification: async.ZoneSpecification, onError: core.Function}])))();
  let ObjectTobool$ = () => (ObjectTobool$ = dart.constFn(dart.definiteFunctionType(core.bool, [core.Object])))();
  let dynamicAnddynamicTobool = () => (dynamicAnddynamicTobool = dart.constFn(dart.definiteFunctionType(core.bool, [dart.dynamic, dart.dynamic])))();
  let IterableAndListTovoid = () => (IterableAndListTovoid = dart.constFn(dart.definiteFunctionType(dart.void, [core.Iterable, core.List])))();
  let _SplayTreeMapNodeTobool = () => (_SplayTreeMapNodeTobool = dart.constFn(dart.definiteFunctionType(core.bool, [collection._SplayTreeMapNode])))();
  let dynamicAndFnTodynamic = () => (dynamicAndFnTodynamic = dart.constFn(dart.definiteFunctionType(dart.dynamic, [dart.dynamic, dynamicAnddynamicTodynamic()])))();
  let EventSinkTo_ConverterStreamEventSink = () => (EventSinkTo_ConverterStreamEventSink = dart.constFn(dart.definiteFunctionType(convert._ConverterStreamEventSink, [async.EventSink])))();
  let Uint8ListAndintAndintTovoid = () => (Uint8ListAndintAndintTovoid = dart.constFn(dart.definiteFunctionType(dart.void, [typed_data.Uint8List, core.int, core.int])))();
  let StringAndFnTodynamic = () => (StringAndFnTodynamic = dart.constFn(dart.definiteFunctionType(dart.dynamic, [core.String, dynamicAnddynamicTodynamic()])))();
  let EventSinkOfStringTo_LineSplitterEventSink = () => (EventSinkOfStringTo_LineSplitterEventSink = dart.constFn(dart.definiteFunctionType(convert._LineSplitterEventSink, [EventSinkOfString()])))();
  let intAndintToint = () => (intAndintToint = dart.constFn(dart.definiteFunctionType(core.int, [core.int, core.int])))();
  let dynamicAndintToint = () => (dynamicAndintToint = dart.constFn(dart.definiteFunctionType(core.int, [dart.dynamic, core.int])))();
  let intAndintTovoid = () => (intAndintTovoid = dart.constFn(dart.definiteFunctionType(dart.void, [core.int, core.int])))();
  let StringToint$ = () => (StringToint$ = dart.constFn(dart.definiteFunctionType(core.int, [core.String])))();
  let intToString = () => (intToString = dart.constFn(dart.definiteFunctionType(core.String, [core.int])))();
  let ObjectAndObjectTobool = () => (ObjectAndObjectTobool = dart.constFn(dart.definiteFunctionType(core.bool, [core.Object, core.Object])))();
  let ObjectToint = () => (ObjectToint = dart.constFn(dart.definiteFunctionType(core.int, [core.Object])))();
  let ObjectTovoid = () => (ObjectTovoid = dart.constFn(dart.definiteFunctionType(dart.void, [core.Object])))();
  let StringAndStringTovoid = () => (StringAndStringTovoid = dart.constFn(dart.definiteFunctionType(dart.void, [core.String, core.String])))();
  let StringAnddynamicTovoid = () => (StringAnddynamicTovoid = dart.constFn(dart.definiteFunctionType(dart.void, [core.String, dart.dynamic])))();
  let dynamicAnddynamicToint = () => (dynamicAnddynamicToint = dart.constFn(dart.definiteFunctionType(core.int, [dart.dynamic, dart.dynamic])))();
  let MapOfString$StringAndStringToMapOfString$String = () => (MapOfString$StringAndStringToMapOfString$String = dart.constFn(dart.definiteFunctionType(MapOfString$String(), [MapOfString$String(), core.String])))();
  let intAndintAndintTovoid = () => (intAndintAndintTovoid = dart.constFn(dart.definiteFunctionType(dart.void, [core.int, core.int, core.int])))();
  let String__Tovoid = () => (String__Tovoid = dart.constFn(dart.definiteFunctionType(dart.void, [core.String], [dart.dynamic])))();
  let ListToIsolate = () => (ListToIsolate = dart.constFn(dart.definiteFunctionType(isolate.Isolate, [core.List])))();
  let dynamicTo_DartObject = () => (dynamicTo_DartObject = dart.constFn(dart.definiteFunctionType(js._DartObject, [dart.dynamic])))();
  let dynamicToObject = () => (dynamicToObject = dart.constFn(dart.definiteFunctionType(core.Object, [dart.dynamic])))();
  let dynamicToJsObject = () => (dynamicToJsObject = dart.constFn(dart.definiteFunctionType(js.JsObject, [dart.dynamic])))();
  let dynamicAnddynamicAndFnToObject = () => (dynamicAnddynamicAndFnToObject = dart.constFn(dart.definiteFunctionType(core.Object, [dart.dynamic, dart.dynamic, dynamicTodynamic()])))();
  let FunctionToFunction = () => (FunctionToFunction = dart.constFn(dart.definiteFunctionType(core.Function, [core.Function])))();
  let TAndTToT = () => (TAndTToT = dart.constFn(dart.definiteFunctionType(T => [T, [T, T]])))();
  let TAndTToT$ = () => (TAndTToT$ = dart.constFn(dart.definiteFunctionType(T => [T, [T, T]])))();
  let numAndnumTodouble = () => (numAndnumTodouble = dart.constFn(dart.definiteFunctionType(core.double, [core.num, core.num])))();
  let numAndnumTonum = () => (numAndnumTonum = dart.constFn(dart.definiteFunctionType(core.num, [core.num, core.num])))();
  let numTodouble = () => (numTodouble = dart.constFn(dart.definiteFunctionType(core.double, [core.num])))();
  let TToT = () => (TToT = dart.constFn(dart.definiteFunctionType(T => [T, [T]])))();
  let LibraryMirrorTobool = () => (LibraryMirrorTobool = dart.constFn(dart.definiteFunctionType(core.bool, [mirrors.LibraryMirror])))();
  let VoidToMirrorSystem = () => (VoidToMirrorSystem = dart.constFn(dart.definiteFunctionType(mirrors.MirrorSystem, [])))();
  let ObjectToInstanceMirror = () => (ObjectToInstanceMirror = dart.constFn(dart.definiteFunctionType(mirrors.InstanceMirror, [core.Object])))();
  let TypeToClassMirror = () => (TypeToClassMirror = dart.constFn(dart.definiteFunctionType(mirrors.ClassMirror, [core.Type])))();
  let EventTovoid$ = () => (EventTovoid$ = dart.constFn(dart.definiteFunctionType(dart.void, [html$.Event])))();
  let RequestToFutureOfT = () => (RequestToFutureOfT = dart.constFn(dart.definiteFunctionType(T => [async.Future$(T), [indexed_db.Request]])))();
  let dynamicToTo = () => (dynamicToTo = dart.constFn(dart.definiteFunctionType(To => [To, [dart.dynamic]])))();
  let EventTodynamic = () => (EventTodynamic = dart.constFn(dart.definiteFunctionType(dart.dynamic, [html$.Event])))();
  let NodeTobool = () => (NodeTobool = dart.constFn(dart.definiteFunctionType(core.bool, [html$.Node])))();
  let MapOfString$dynamicTobool = () => (MapOfString$dynamicTobool = dart.constFn(dart.definiteFunctionType(core.bool, [MapOfString$dynamic()])))();
  let UriAndListOfStringAnddynamicToFutureOfIsolate = () => (UriAndListOfStringAnddynamicToFutureOfIsolate = dart.constFn(dart.definiteFunctionType(FutureOfIsolate(), [core.Uri, ListOfString(), dart.dynamic])))();
  let TypeAnddynamicTodynamic = () => (TypeAnddynamicTodynamic = dart.constFn(dart.definiteFunctionType(dart.dynamic, [core.Type, dart.dynamic])))();
  let FileSystemTovoid = () => (FileSystemTovoid = dart.constFn(dart.definiteFunctionType(dart.void, [html$.FileSystem])))();
  let FileErrorTovoid = () => (FileErrorTovoid = dart.constFn(dart.definiteFunctionType(dart.void, [html$.FileError])))();
  let EntryTovoid = () => (EntryTovoid = dart.constFn(dart.definiteFunctionType(dart.void, [html$.Entry])))();
  let dynamicToCssStyleDeclaration = () => (dynamicToCssStyleDeclaration = dart.constFn(dart.definiteFunctionType(html$.CssStyleDeclaration, [dart.dynamic])))();
  let CssStyleDeclarationTovoid = () => (CssStyleDeclarationTovoid = dart.constFn(dart.definiteFunctionType(dart.void, [html$.CssStyleDeclaration])))();
  let MetadataTovoid = () => (MetadataTovoid = dart.constFn(dart.definiteFunctionType(dart.void, [html$.Metadata])))();
  let ListOfEntryTovoid = () => (ListOfEntryTovoid = dart.constFn(dart.definiteFunctionType(dart.void, [ListOfEntry()])))();
  let ElementTobool = () => (ElementTobool = dart.constFn(dart.definiteFunctionType(core.bool, [html$.Element])))();
  let FileWriterTovoid = () => (FileWriterTovoid = dart.constFn(dart.definiteFunctionType(dart.void, [html$.FileWriter])))();
  let FileTovoid = () => (FileTovoid = dart.constFn(dart.definiteFunctionType(dart.void, [html$.File])))();
  let GeopositionTovoid = () => (GeopositionTovoid = dart.constFn(dart.definiteFunctionType(dart.void, [html$.Geoposition])))();
  let PositionErrorTovoid = () => (PositionErrorTovoid = dart.constFn(dart.definiteFunctionType(dart.void, [html$.PositionError])))();
  let HttpRequestToString = () => (HttpRequestToString = dart.constFn(dart.definiteFunctionType(core.String, [html$.HttpRequest])))();
  let ProgressEventTovoid$ = () => (ProgressEventTovoid$ = dart.constFn(dart.definiteFunctionType(dart.void, [html$.ProgressEvent])))();
  let ListOfSourceInfoTovoid = () => (ListOfSourceInfoTovoid = dart.constFn(dart.definiteFunctionType(dart.void, [ListOfSourceInfo()])))();
  let MediaStreamTovoid = () => (MediaStreamTovoid = dart.constFn(dart.definiteFunctionType(dart.void, [html$.MediaStream])))();
  let NavigatorUserMediaErrorTovoid = () => (NavigatorUserMediaErrorTovoid = dart.constFn(dart.definiteFunctionType(dart.void, [html$.NavigatorUserMediaError])))();
  let RtcSessionDescriptionTovoid = () => (RtcSessionDescriptionTovoid = dart.constFn(dart.definiteFunctionType(dart.void, [html$.RtcSessionDescription])))();
  let RtcStatsResponseTovoid = () => (RtcStatsResponseTovoid = dart.constFn(dart.definiteFunctionType(dart.void, [html$.RtcStatsResponse])))();
  let OptionElementTobool = () => (OptionElementTobool = dart.constFn(dart.definiteFunctionType(core.bool, [html$.OptionElement])))();
  let numTovoid = () => (numTovoid = dart.constFn(dart.definiteFunctionType(dart.void, [core.num])))();
  let ElementTovoid = () => (ElementTovoid = dart.constFn(dart.definiteFunctionType(dart.void, [html$.Element])))();
  let ElementToCssClassSet = () => (ElementToCssClassSet = dart.constFn(dart.definiteFunctionType(html$.CssClassSet, [html$.Element])))();
  let CssClassSetImplTovoid = () => (CssClassSetImplTovoid = dart.constFn(dart.definiteFunctionType(dart.void, [html_common.CssClassSetImpl])))();
  let boolAndCssClassSetImplTobool = () => (boolAndCssClassSetImplTobool = dart.constFn(dart.definiteFunctionType(core.bool, [core.bool, html_common.CssClassSetImpl])))();
  let SetOfStringTobool = () => (SetOfStringTobool = dart.constFn(dart.definiteFunctionType(core.bool, [SetOfString()])))();
  let SetOfStringTovoid = () => (SetOfStringTovoid = dart.constFn(dart.definiteFunctionType(dart.void, [SetOfString()])))();
  let EventAndStringTobool = () => (EventAndStringTobool = dart.constFn(dart.definiteFunctionType(core.bool, [html$.Event, core.String])))();
  let KeyEventTobool = () => (KeyEventTobool = dart.constFn(dart.definiteFunctionType(core.bool, [html$.KeyEvent])))();
  let NodeValidatorTobool = () => (NodeValidatorTobool = dart.constFn(dart.definiteFunctionType(core.bool, [html$.NodeValidator])))();
  let NodeAndNodeToint = () => (NodeAndNodeToint = dart.constFn(dart.definiteFunctionType(core.int, [html$.Node, html$.Node])))();
  let FromToTo = () => (FromToTo = dart.constFn(dart.definiteFunctionType((From, To) => [To, [From]])))();
  let dynamicToWindowBase = () => (dynamicToWindowBase = dart.constFn(dart.definiteFunctionType(html$.WindowBase, [dart.dynamic])))();
  let dynamicToEventTarget = () => (dynamicToEventTarget = dart.constFn(dart.definiteFunctionType(html$.EventTarget, [dart.dynamic])))();
  let dynamicAnddynamicAnddynamic__Todynamic = () => (dynamicAnddynamicAnddynamic__Todynamic = dart.constFn(dart.definiteFunctionType(dart.dynamic, [dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic])))();
  let dynamicAnddynamicAndString__Tovoid = () => (dynamicAnddynamicAndString__Tovoid = dart.constFn(dart.definiteFunctionType(dart.void, [dart.dynamic, dart.dynamic, core.String, core.Type, core.String])))();
  let _wrapZoneCallbackOfA$RTo_wrapZoneCallbackOfA$R = () => (_wrapZoneCallbackOfA$RTo_wrapZoneCallbackOfA$R = dart.constFn(dart.definiteFunctionType((A, R) => [html$._wrapZoneCallback$(A, R), [html$._wrapZoneCallback$(A, R)]])))();
  let _wrapZoneBinaryCallbackOfA$B$RTo_wrapZoneBinaryCallbackOfA$B$R = () => (_wrapZoneBinaryCallbackOfA$B$RTo_wrapZoneBinaryCallbackOfA$B$R = dart.constFn(dart.definiteFunctionType((A, B, R) => [html$._wrapZoneBinaryCallback$(A, B, R), [html$._wrapZoneBinaryCallback$(A, B, R)]])))();
  let StringToElement = () => (StringToElement = dart.constFn(dart.definiteFunctionType(html$.Element, [core.String])))();
  let StringToElementListOfElement = () => (StringToElementListOfElement = dart.constFn(dart.definiteFunctionType(ElementListOfElement(), [core.String])))();
  let NodeAndNodeTovoid = () => (NodeAndNodeTovoid = dart.constFn(dart.definiteFunctionType(dart.void, [html$.Node, html$.Node])))();
  let dynamicToImageData = () => (dynamicToImageData = dart.constFn(dart.definiteFunctionType(html$.ImageData, [dart.dynamic])))();
  let ImageDataTodynamic = () => (ImageDataTodynamic = dart.constFn(dart.definiteFunctionType(dart.dynamic, [html$.ImageData])))();
  let dynamicToMap = () => (dynamicToMap = dart.constFn(dart.definiteFunctionType(core.Map, [dart.dynamic])))();
  let Map__Todynamic = () => (Map__Todynamic = dart.constFn(dart.definiteFunctionType(dart.dynamic, [core.Map], [dynamicTovoid()])))();
  let ListOfStringToList = () => (ListOfStringToList = dart.constFn(dart.definiteFunctionType(core.List, [ListOfString()])))();
  let dynamicToDateTime = () => (dynamicToDateTime = dart.constFn(dart.definiteFunctionType(core.DateTime, [dart.dynamic])))();
  let DateTimeTodynamic = () => (DateTimeTodynamic = dart.constFn(dart.definiteFunctionType(dart.dynamic, [core.DateTime])))();
  let dynamic__Todynamic$ = () => (dynamic__Todynamic$ = dart.constFn(dart.definiteFunctionType(dart.dynamic, [dart.dynamic], {mustCopy: dart.dynamic})))();
  let NodeToElement = () => (NodeToElement = dart.constFn(dart.definiteFunctionType(html$.Element, [html$.Node])))();
  let AudioBufferTovoid = () => (AudioBufferTovoid = dart.constFn(dart.definiteFunctionType(dart.void, [web_audio.AudioBuffer])))();
  dart.mixin = function(base, ...mixins) {
    class Mixin extends base {}
    for (let m of mixins) {
      dart.copyProperties(Mixin.prototype, m.prototype);
    }
    Mixin.prototype.new = function(...args) {
      for (let i = mixins.length - 1; i >= 0; i--) {
        mixins[i].prototype.new.call(this);
      }
      base.prototype.new.apply(this, args);
    };
    dart.setSignature(Mixin, {
      methods: () => {
        let s = {};
        for (let m of mixins) {
          dart.copyProperties(s, m[dart._methodSig]);
        }
        return s;
      }
    });
    Mixin[dart._mixins] = mixins;
    return Mixin;
  };
  dart.getMixins = function(clazz) {
    return clazz[dart._mixins];
  };
  dart.getImplements = function(clazz) {
    return clazz[dart.implements];
  };
  dart.flattenFutures = function(builder) {
    function flatten(T) {
      if (!T) return builder(dart.dynamic);
      let futureClass = dart.getGenericClass(async.Future);
      if (dart.getGenericClass(T) == futureClass) {
        let args = dart.getGenericArgs(T);
        if (args) return builder(args[0]);
      }
      return builder(T);
    }
    return flatten;
  };
  dart.generic = function(typeConstructor) {
    let length = typeConstructor.length;
    if (length < 1) {
      dart.throwInternalError('must have at least one generic type argument');
    }
    let resultMap = new Map();
    function makeGenericType(...args) {
      if (args.length != length && args.length != 0) {
        dart.throwInternalError('requires ' + length + ' or 0 type arguments');
      }
      while (args.length < length)
        args.push(dart.dynamic);
      let value = resultMap;
      for (let i = 0; i < length; i++) {
        let arg = args[i];
        if (arg == null) {
          dart.throwInternalError('type arguments should not be null: ' + typeConstructor);
        }
        let map = value;
        value = map.get(arg);
        if (value === void 0) {
          if (i + 1 == length) {
            value = typeConstructor.apply(null, args);
            if (value) {
              value[dart._typeArguments] = args;
              value[dart._originalDeclaration] = makeGenericType;
            }
          } else {
            value = new Map();
          }
          map.set(arg, value);
        }
      }
      return value;
    }
    return makeGenericType;
  };
  dart.getGenericClass = function(type) {
    return dart.safeGetOwnProperty(type, dart._originalDeclaration);
  };
  dart.getGenericArgs = function(type) {
    return dart.safeGetOwnProperty(type, dart._typeArguments);
  };
  dart.getMethodType = function(obj, name) {
    let type = obj == null ? core.Object : obj.__proto__.constructor;
    return dart.getMethodTypeFromType(type, name);
  };
  dart.getMethodTypeFromType = function(type, name) {
    let sigObj = type[dart._methodSig];
    if (sigObj === void 0) return void 0;
    return sigObj[name];
  };
  dart.classGetConstructorType = function(cls, name) {
    if (!name) name = cls.name;
    if (cls === void 0) return void 0;
    if (cls == null) return void 0;
    let sigCtor = cls[dart._constructorSig];
    if (sigCtor === void 0) return void 0;
    return sigCtor[name];
  };
  dart.bind = function(obj, name, f) {
    if (f === void 0) f = obj[name];
    f = f.bind(obj);
    let sig = dart.getMethodType(obj, name);
    dart.assert(sig);
    dart.tag(f, sig);
    return f;
  };
  dart.gbind = function(f, ...typeArgs) {
    let result = f.apply(null, typeArgs);
    let sig = dart._getRuntimeType(f).apply(null, typeArgs);
    dart.tag(result, sig);
    return result;
  };
  dart._setMethodSignature = function(f, sigF) {
    dart.defineMemoizedGetter(f, dart._methodSig, () => {
      let sigObj = sigF();
      sigObj.__proto__ = f.__proto__[dart._methodSig];
      return sigObj;
    });
  };
  dart._setConstructorSignature = function(f, sigF) {
    return dart.defineMemoizedGetter(f, dart._constructorSig, sigF);
  };
  dart._setStaticSignature = function(f, sigF) {
    return dart.defineMemoizedGetter(f, dart._staticSig, sigF);
  };
  dart._setStaticTypes = function(f, names) {
    for (let name of names) {
      if (!f[name]) continue;
      dart.tagLazy(f[name], function() {
        return f[dart._staticSig][name];
      });
    }
  };
  dart.setSignature = function(f, signature) {
    let constructors = 'constructors' in signature ? signature.constructors : () => ({});
    let methods = 'methods' in signature ? signature.methods : () => ({});
    let statics = 'statics' in signature ? signature.statics : () => ({});
    let names = 'names' in signature ? signature.names : [];
    dart._setConstructorSignature(f, constructors);
    dart._setMethodSignature(f, methods);
    dart._setStaticSignature(f, statics);
    dart._setStaticTypes(f, names);
    dart.tagLazy(f, () => core.Type);
  };
  dart.hasMethod = function(obj, name) {
    return dart.getMethodType(obj, name) !== void 0;
  };
  dart.defineNamedConstructor = function(clazz, name) {
    let proto = clazz.prototype;
    let initMethod = proto[name];
    let ctor = function(...args) {
      initMethod.apply(this, args);
    };
    ctor.prototype = proto;
    dart.defineProperty(clazz, name, {value: ctor, configurable: true});
  };
  dart.getExtensionType = function(obj) {
    return obj[dart._extensionType];
  };
  dart.getExtensionSymbol = function(name) {
    let sym = dartx[name];
    if (sym == null) {
      sym = Symbol("dartx." + name.toString());
      dartx[name] = sym;
    }
    return sym;
  };
  dart.defineExtensionNames = function(names) {
    return names.forEach(dart.getExtensionSymbol);
  };
  dart._installProperties = function(jsProto, extProto) {
    let coreObjProto = core.Object.prototype;
    let parentsExtension = jsProto.__proto__[dart._extensionType];
    let installedParent = parentsExtension && parentsExtension.prototype;
    dart._installProperties2(jsProto, extProto, coreObjProto, installedParent);
  };
  dart._installProperties2 = function(jsProto, extProto, coreObjProto, installedParent) {
    if (extProto === coreObjProto) {
      dart._installPropertiesForObject(jsProto, coreObjProto);
      return;
    }
    if (jsProto !== extProto) {
      let extParent = extProto.__proto__;
      if (installedParent !== extParent) {
        dart._installProperties2(jsProto, extParent, coreObjProto, installedParent);
      }
    }
    dart.copyTheseProperties(jsProto, extProto, dart.getOwnPropertySymbols(extProto));
  };
  dart._installPropertiesForObject = function(jsProto, coreObjProto) {
    let names = dart.getOwnPropertyNames(coreObjProto);
    for (let i = 0; i < names.length; ++i) {
      let name = names[i];
      let desc = dart.getOwnPropertyDescriptor(coreObjProto, name);
      dart.defineProperty(jsProto, dart.getExtensionSymbol(name), desc);
    }
    return;
  };
  dart.registerExtension = function(jsType, dartExtType) {
    if (!jsType) return;
    let extProto = dartExtType.prototype;
    let jsProto = jsType.prototype;
    jsProto[dart._extensionType] = dartExtType;
    dart._installProperties(jsProto, extProto);
    let originalSigFn = dart.getOwnPropertyDescriptor(dartExtType, dart._methodSig).get;
    dart.assert(originalSigFn);
    dart.defineMemoizedGetter(jsType, dart._methodSig, originalSigFn);
  };
  dart.defineExtensionMembers = function(type, methodNames) {
    let proto = type.prototype;
    for (let name of methodNames) {
      let method = dart.getOwnPropertyDescriptor(proto, name);
      if (!method) continue;
      dart.defineProperty(proto, dart.getExtensionSymbol(name), method);
    }
    let originalSigFn = dart.getOwnPropertyDescriptor(type, dart._methodSig).get;
    dart.defineMemoizedGetter(type, dart._methodSig, function() {
      let sig = originalSigFn();
      for (let name of methodNames) {
        sig[dart.getExtensionSymbol(name)] = sig[name];
      }
      return sig;
    });
  };
  dart.setType = function(obj, type) {
    obj.__proto__ = type.prototype;
    return obj;
  };
  dart.list = function(obj, elementType) {
    return dart.setType(obj, dart.getGenericClass(_interceptors.JSArray)(elementType));
  };
  dart.setBaseClass = function(derived, base) {
    derived.prototype.__proto__ = base.prototype;
    derived.__proto__ = base;
  };
  dart.setExtensionBaseClass = function(derived, base) {
    derived.prototype[dart._extensionType] = derived;
    derived.prototype.__proto__ = base.prototype;
  };
  dart.callableClass = function(callableCtor, classExpr) {
    callableCtor.prototype = classExpr.prototype;
    callableCtor.prototype.constructor = callableCtor;
    callableCtor.__proto__ = classExpr.__proto__;
    return callableCtor;
  };
  dart.defineNamedConstructorCallable = function(clazz, name, ctor) {
    ctor.prototype = clazz.prototype;
    dart.defineProperty(clazz, name, {value: ctor, configurable: true});
  };
  dart.fn = function(closure, t) {
    if (t == null) {
      t = dart.definiteFunctionType(dart.dynamic, Array(closure.length).fill(dart.dynamic), void 0);
    }
    dart.tag(closure, t);
    return closure;
  };
  dart.lazyFn = function(closure, computeType) {
    dart.tagLazy(closure, computeType);
    return closure;
  };
  dart._checkPrimitiveType = function(obj) {
    if (obj == null) return core.Null;
    if (typeof obj == "number") {
      if (Math.floor(obj) == obj) {
        return core.int;
      }
      return core.double;
    }
    if (typeof obj == "boolean") {
      return core.bool;
    }
    if (typeof obj == "string") {
      return core.String;
    }
    if (typeof obj == "symbol") {
      return dart.jsobject;
    }
    return null;
  };
  dart.getFunctionType = function(obj) {
    let args = Array(obj.length).fill(dart.dynamic);
    return dart.definiteFunctionType(dart.bottom, args, void 0);
  };
  dart.getReifiedType = function(obj) {
    let result = dart._checkPrimitiveType(obj);
    if (result != null) return result;
    return dart._nonPrimitiveRuntimeType(obj);
  };
  dart._nonPrimitiveRuntimeType = function(obj) {
    let result = dart._getRuntimeType(obj);
    if (result != null) return result;
    result = dart.getExtensionType(obj);
    if (result != null) return result;
    result = obj.constructor;
    if (result === Function) {
      return dart.jsobject;
    }
    if (result == null) {
      return dart.jsobject;
    }
    return result;
  };
  dart.wrapType = function(type) {
    if (type.hasOwnProperty(dart._typeObject)) {
      return type[dart._typeObject];
    }
    return type[dart._typeObject] = new dart.WrappedType(type);
  };
  const _wrappedType = Symbol('_wrappedType');
  dart.unwrapType = function(obj) {
    return dart.dload(obj, _wrappedType);
  };
  dart._getRuntimeType = function(value) {
    return value[dart._runtimeType];
  };
  dart.tag = function(value, t) {
    value[dart._runtimeType] = t;
  };
  dart.tagComputed = function(value, compute) {
    dart.defineProperty(value, dart._runtimeType, {get: compute});
  };
  dart.tagLazy = function(value, compute) {
    dart.defineLazyProperty(value, dart._runtimeType, {get: compute});
  };
  dart._initialize2 = function() {
    dart.TypeRep.prototype.is = function is_T(object) {
      return dart.is(object, this);
    };
    dart.TypeRep.prototype.as = function as_T(object) {
      return dart.as(object, this);
    };
    dart.TypeRep.prototype._check = function check_T(object) {
      return dart.check(object, this);
    };
    dart.Dynamic.prototype.is = function is_Dynamic(object) {
      return true;
    };
    dart.Dynamic.prototype.as = function as_Dynamic(object) {
      return object;
    };
    dart.Dynamic.prototype._check = function check_Dynamic(object) {
      return object;
    };
  };
  dart._functionType = function(definite, returnType, args, extra) {
    if (args === void 0 && extra === void 0) {
      const fnTypeParts = returnType;
      function makeGenericFnType(...types) {
        let parts = fnTypeParts.apply(null, types);
        return dart.FunctionType.create(definite, parts[0], parts[1], parts[2]);
      }
      makeGenericFnType[dart._typeFormalCount] = fnTypeParts.length;
      return makeGenericFnType;
    }
    return dart.FunctionType.create(definite, returnType, args, extra);
  };
  dart.functionType = function(returnType, args, extra) {
    return dart._functionType(false, returnType, args, extra);
  };
  dart.definiteFunctionType = function(returnType, args, extra) {
    return dart._functionType(true, returnType, args, extra);
  };
  dart.typedef = function(name, closure) {
    return new dart.Typedef(name, closure);
  };
  dart.typeName = function(type) {
    if (type === void 0) return "undefined type";
    if (type === null) return "null type";
    if (type instanceof dart.TypeRep) {
      if (type instanceof dart.Typedef) {
        return type.name + "(" + type.functionType.toString() + ")";
      }
      return type.toString();
    }
    let tag = dart._getRuntimeType(type);
    if (tag === core.Type) {
      let name = type.name;
      let args = dart.getGenericArgs(type);
      if (!args) return name;
      let result = name;
      let allDynamic = true;
      result += '<';
      for (let i = 0; i < args.length; ++i) {
        if (i > 0) result += ', ';
        let argName = dart.typeName(args[i]);
        if (argName != 'dynamic') allDynamic = false;
        result += argName;
      }
      result += '>';
      if (allDynamic) return name;
      return result;
    }
    if (tag) return "Not a type: " + tag.name;
    return "JSObject<" + type.name + ">";
  };
  dart.getImplicitFunctionType = function(type) {
    if (dart.test(dart.isFunctionType(type))) return type;
    return dart.getMethodTypeFromType(type, 'call');
  };
  dart.isFunctionType = function(type) {
    return type instanceof dart.AbstractFunctionType || type === core.Function;
  };
  dart.isFunctionSubtype = function(ft1, ft2, covariant) {
    if (ft2 === core.Function) {
      return true;
    }
    if (ft1 === core.Function) {
      return false;
    }
    let ret1 = ft1.returnType;
    let ret2 = ft2.returnType;
    let args1 = ft1.args;
    let args2 = ft2.args;
    if (args1.length > args2.length) {
      return covariant ? false : null;
    }
    for (let i = 0; i < args1.length; ++i) {
      if (!dart._isSubtype(args2[i], args1[i], !covariant)) {
        return null;
      }
    }
    let optionals1 = ft1.optionals;
    let optionals2 = ft2.optionals;
    if (args1.length + optionals1.length < args2.length + optionals2.length) {
      return covariant ? false : null;
    }
    let j = 0;
    for (let i = args1.length; i < args2.length; ++i, ++j) {
      if (!dart._isSubtype(args2[i], optionals1[j], !covariant)) {
        return null;
      }
    }
    for (let i = 0; i < optionals2.length; ++i, ++j) {
      if (!dart._isSubtype(optionals2[i], optionals1[j], !covariant)) {
        return null;
      }
    }
    let named1 = ft1.named;
    let named2 = ft2.named;
    let names = dart.getOwnPropertyNames(named2);
    for (let i = 0; i < names.length; ++i) {
      let name = names[i];
      let n1 = named1[name];
      let n2 = named2[name];
      if (n1 === void 0) {
        return covariant ? false : null;
      }
      if (!dart._isSubtype(n2, n1, !covariant)) {
        return null;
      }
    }
    if (ret2 === dart.void) return true;
    if (ret1 === dart.void) return ret2 === dart.dynamic;
    if (!dart._isSubtype(ret1, ret2, covariant)) return null;
    return true;
  };
  dart._subtypeMemo = function(f) {
    let memo = new Map();
    return (t1, t2) => {
      let map = memo.get(t1);
      let result;
      if (map) {
        result = map.get(t2);
        if (result !== void 0) return result;
      } else {
        memo.set(t1, map = new Map());
      }
      result = f(t1, t2);
      map.set(t2, result);
      return result;
    };
  };
  dart._isBottom = function(type) {
    return type == dart.bottom;
  };
  dart._isTop = function(type) {
    return type == core.Object || type == dart.dynamic;
  };
  dart._isSubtype = function(t1, t2, covariant) {
    if (t1 === t2) return true;
    if (dart._isTop(t2) || dart._isBottom(t1)) {
      return true;
    }
    if (dart._isBottom(t2)) return null;
    if (dart._isTop(t1)) {
      if (t1 === dart.dynamic) return null;
      return false;
    }
    if (!(t1 instanceof dart.AbstractFunctionType) && !(t2 instanceof dart.AbstractFunctionType)) {
      let result = dart.isClassSubType(t1, t2, covariant);
      if (result === true || result === null) return result;
    }
    t1 = dart.getImplicitFunctionType(t1);
    if (!t1) return false;
    if (dart.isFunctionType(t1) && dart.isFunctionType(t2)) {
      return dart.isFunctionSubtype(t1, t2, covariant);
    }
    return false;
  };
  dart.isClassSubType = function(t1, t2, covariant) {
    if (t1 == t2) return true;
    if (t1 == core.Object) return false;
    if (t1 == null) return t2 == core.Object || t2 == dart.dynamic;
    let raw1 = dart.getGenericClass(t1);
    let raw2 = dart.getGenericClass(t2);
    if (raw1 != null && raw1 == raw2) {
      let typeArguments1 = dart.getGenericArgs(t1);
      let typeArguments2 = dart.getGenericArgs(t2);
      let length = typeArguments1.length;
      if (typeArguments2.length == 0) {
        return true;
      } else if (length == 0) {
        if (typeArguments2.every(dart._isTop)) return true;
        return null;
      }
      dart.assert(length == typeArguments2.length);
      for (let i = 0; i < length; ++i) {
        let result = dart._isSubtype(typeArguments1[i], typeArguments2[i], covariant);
        if (!result) {
          return result;
        }
      }
      return true;
    }
    let indefinite = false;
    function definitive(t1, t2) {
      let result = dart.isClassSubType(t1, t2, covariant);
      if (result == null) {
        indefinite = true;
        return false;
      }
      return result;
    }
    if (definitive(t1.__proto__, t2)) return true;
    let mixins = dart.getMixins(t1);
    if (mixins) {
      for (let m1 of mixins) {
        if (m1 != null && definitive(m1, t2)) return true;
      }
    }
    let getInterfaces = dart.getImplements(t1);
    if (getInterfaces) {
      for (let i1 of getInterfaces()) {
        if (i1 != null && definitive(i1, t2)) return true;
      }
    }
    if (indefinite) return null;
    return false;
  };
  dart.isGroundType = function(type) {
    if (type instanceof dart.AbstractFunctionType) {
      if (!dart._isTop(type.returnType)) return false;
      for (let i = 0; i < type.args.length; ++i) {
        if (!dart._isBottom(type.args[i])) return false;
      }
      for (let i = 0; i < type.optionals.length; ++i) {
        if (!dart._isBottom(type.optionals[i])) return false;
      }
      let names = dart.getOwnPropertyNames(type.named);
      for (let i = 0; i < names.length; ++i) {
        if (!dart._isBottom(type.named[names[i]])) return false;
      }
      return true;
    }
    let typeArgs = dart.getGenericArgs(type);
    if (!typeArgs) return true;
    for (let t of typeArgs) {
      if (t != core.Object && t != dart.dynamic) return false;
    }
    return true;
  };
  dart.throwCastError = function(object, actual, type) {
    dart.throw(new _js_helper.CastErrorImplementation(object, dart.typeName(actual), dart.typeName(type)));
  };
  dart.throwTypeError = function(object, actual, type) {
    dart.throw(new _js_helper.TypeErrorImplementation(object, dart.typeName(actual), dart.typeName(type)));
  };
  dart.throwStrongModeCastError = function(object, actual, type) {
    dart.throw(new _js_helper.StrongModeCastError(object, dart.typeName(actual), dart.typeName(type)));
  };
  dart.throwStrongModeTypeError = function(object, actual, type) {
    dart.throw(new _js_helper.StrongModeTypeError(object, dart.typeName(actual), dart.typeName(type)));
  };
  dart.throwUnimplementedError = function(message) {
    dart.throw(new core.UnimplementedError(message));
  };
  dart.throwAssertionError = function() {
    dart.throw(new core.AssertionError());
  };
  dart.throwNullValueError = function() {
    dart.throw(new core.NoSuchMethodError(null, new core.Symbol('<Unexpected Null Value>'), null, null, null));
  };
  dart.syncStar = function(gen, E, ...args) {
    const SyncIterable_E = dart.getGenericClass(_js_helper.SyncIterable)(E);
    return new SyncIterable_E(gen, args);
  };
  dart.async = function(gen, T, ...args) {
    let iter;
    function onValue(res) {
      if (res === void 0) res = null;
      return next(iter.next(res));
    }
    function onError(err) {
      return next(iter.throw(err));
    }
    function next(ret) {
      if (ret.done) return ret.value;
      let future = ret.value;
      if (!dart.is(future, dart.getGenericClass(async.Future))) {
        future = async.Future.value(future);
      }
      return future.then(dart.dynamic)(onValue, {onError: onError});
    }
    return dart.getGenericClass(async.Future)(T).new(function() {
      iter = gen.apply(null, args)[Symbol.iterator]();
      return onValue();
    });
  };
  dart.asyncStar = function(gen, T, ...args) {
    return new dart._AsyncStarStreamController(gen, T, args).controller.stream;
  };
  dart.dload = function(obj, field) {
    let f = dart._canonicalMember(obj, field);
    dart._trackCall(obj, f);
    if (f != null) {
      if (dart.test(dart.hasMethod(obj, f))) return dart.bind(obj, f, void 0);
      return obj[f];
    }
    return dart.noSuchMethod(obj, new dart._Invocation(core.String._check(field), [], {isGetter: true}));
  };
  dart.dput = function(obj, field, value) {
    let f = dart._canonicalMember(obj, field);
    dart._trackCall(obj, f);
    if (f != null) {
      return obj[f] = value;
    }
    return dart.noSuchMethod(obj, new dart._Invocation(core.String._check(field), [value], {isSetter: true}));
  };
  dart._checkApply = function(type, actuals) {
    if (actuals.length < type.args.length) return false;
    let index = 0;
    for (let i = 0; i < type.args.length; ++i) {
      if (!dart.instanceOfOrNull(actuals[i], type.args[i])) return false;
      ++index;
    }
    if (actuals.length == type.args.length) return true;
    let extras = actuals.length - type.args.length;
    if (type.optionals.length > 0) {
      if (extras > type.optionals.length) return false;
      for (let i = 0, j = index; i < extras; ++i, ++j) {
        if (!dart.instanceOfOrNull(actuals[j], type.optionals[i])) return false;
      }
      return true;
    }
    if (extras != 1) return false;
    if (dart.getOwnPropertyNames(type.named).length == 0) return false;
    let opts = actuals[index];
    let names = dart.getOwnPropertyNames(opts);
    if (names.length == 0) return false;
    for (var name of names) {
      if (!dart.hasOwnProperty.call(type.named, name)) {
        return false;
      }
      if (!dart.instanceOfOrNull(opts[name], type.named[name])) return false;
    }
    return true;
  };
  dart._dartSymbol = function(name) {
    return dart.const(core.Symbol.new(name.toString()));
  };
  dart._checkAndCall = function(f, ftype, obj, typeArgs, args, name) {
    dart._trackCall(obj, name);
    let originalTarget = obj === void 0 ? f : obj;
    function callNSM() {
      let namedArgs = null;
      if (args.length > 0 && args[args.length - 1].__proto__ == Object.prototype) {
        namedArgs = args.pop();
      }
      return dart.noSuchMethod(originalTarget, new dart._Invocation(name, args, {namedArguments: namedArgs, isMethod: true}));
    }
    if (!(f instanceof Function)) {
      if (f != null) {
        ftype = dart.getMethodType(f, 'call');
        f = f.call;
      }
      if (!(f instanceof Function)) {
        return callNSM();
      }
    }
    if (ftype === void 0) {
      ftype = dart._getRuntimeType(f);
    }
    if (!ftype) {
      if (typeArgs != null) {
        dart.throwStrongModeError('call to JS object `' + obj + '` with type arguments <' + typeArgs + '> is not supported.');
      }
      return f.apply(obj, args);
    }
    let formalCount = ftype[dart._typeFormalCount];
    if (formalCount != null) {
      if (typeArgs == null) {
        typeArgs = Array(formalCount).fill(dart.dynamic);
      } else if (typeArgs.length != formalCount) {
        dart.throwStrongModeError('incorrect number of arguments to generic function ' + dart.typeName(ftype) + ', got <' + typeArgs + '> expected ' + formalCount + '.');
      }
      ftype = ftype.apply(null, typeArgs);
    } else if (typeArgs != null) {
      dart.throwStrongModeError('got type arguments to non-generic function ' + dart.typeName(ftype) + ', got <' + typeArgs + '> expected none.');
    }
    if (dart._checkApply(ftype, args)) {
      if (typeArgs != null) {
        return f.apply(obj, typeArgs).apply(obj, args);
      }
      return f.apply(obj, args);
    }
    return callNSM();
  };
  dart.dcall = function(f, ...args) {
    return dart._checkAndCall(f, dart._getRuntimeType(f), void 0, null, args, 'call');
  };
  dart.dgcall = function(f, typeArgs, ...args) {
    return dart._checkAndCall(f, dart._getRuntimeType(f), void 0, typeArgs, args, 'call');
  };
  dart.getDynamicStats = function() {
    let ret = JSArrayOfListOfObject().of([]);
    let keys = dart._callMethodStats[dartx.keys][dartx.toList]();
    keys[dartx.sort](dart.fn((a, b) => dart._callMethodStats[dartx.get](b)[dartx.compareTo](dart._callMethodStats[dartx.get](a)), StringAndStringToint()));
    for (let key of keys) {
      let count = dart._callMethodStats[dartx.get](key);
      ret[dartx.add](JSArrayOfObject().of([key, count]));
    }
    return ret;
  };
  dart.clearDynamicStats = function() {
    dart._callMethodStats[dartx.clear]();
  };
  dart._trackCall = function(obj, name) {
    if (!dart.trackProfile) return;
    let actual = dart.getReifiedType(obj);
    let stackStr = new Error().stack;
    let stack = stackStr[dartx.split]('\n    at ');
    let src = '';
    for (let i = 2; i < dart.notNull(stack[dartx.length]); ++i) {
      let frame = stack[dartx.get](i);
      if (!dart.test(frame[dartx.contains]('dev_compiler/lib/runtime/dart_sdk.js'))) {
        src = frame;
        break;
      }
    }
    name = dart.str`${dart.typeName(actual)}.${name} <${src}>`;
    if (dart.test(dart._callMethodStats[dartx.containsKey](name))) {
      dart._callMethodStats[dartx.set](core.String._check(name), dart.notNull(dart._callMethodStats[dartx.get](name)) + 1);
    } else {
      dart._callMethodStats[dartx.set](core.String._check(name), 1);
    }
  };
  dart._callMethod = function(obj, name, typeArgs, args, displayName) {
    let symbol = dart._canonicalMember(obj, name);
    if (symbol == null) {
      return dart.noSuchMethod(obj, new dart._Invocation(core.String._check(displayName), core.List._check(args), {isMethod: true}));
    }
    let f = obj != null ? obj[symbol] : null;
    let ftype = dart.getMethodType(obj, symbol);
    return dart._checkAndCall(f, ftype, obj, typeArgs, args, displayName);
  };
  dart.dsend = function(obj, method, ...args) {
    return dart._callMethod(obj, method, null, args, method);
  };
  dart.dgsend = function(obj, typeArgs, method, ...args) {
    return dart._callMethod(obj, method, typeArgs, args, method);
  };
  dart.dindex = function(obj, index) {
    return dart._callMethod(obj, 'get', null, [index], '[]');
  };
  dart.dsetindex = function(obj, index, value) {
    return dart._callMethod(obj, 'set', null, [index, value], '[]=');
  };
  dart._ignoreMemo = function(f) {
    let memo = new Map();
    return (t1, t2) => {
      let map = memo.get(t1);
      let result;
      if (map) {
        result = map.get(t2);
        if (result !== void 0) return result;
      } else {
        memo.set(t1, map = new Map());
      }
      result = f(t1, t2);
      map.set(t2, result);
      return result;
    };
  };
  dart.strongInstanceOf = function(obj, type, ignoreFromWhiteList) {
    let actual = dart.getReifiedType(obj);
    let result = dart.isSubtype(actual, type);
    if (result || actual == dart.jsobject || actual == core.int && type == core.double) return true;
    if (result === false) return false;
    if (ignoreFromWhiteList == void 0) return result;
    if (dart._ignoreTypeFailure(actual, type)) return true;
    return result;
  };
  dart.instanceOfOrNull = function(obj, type) {
    if (obj == null || dart.strongInstanceOf(obj, type, true)) return true;
    return false;
  };
  dart.is = function(obj, type) {
    let result = dart.strongInstanceOf(obj, type);
    if (result !== null) return result;
    let actual = dart.getReifiedType(obj);
    dart.throwStrongModeError('Strong mode is-check failure: ' + dart.typeName(actual) + ' does not soundly subtype ' + dart.typeName(type));
  };
  dart.as = function(obj, type) {
    if (type == dart.dynamic || obj == null) return obj;
    let result = dart.strongInstanceOf(obj, type, true);
    if (result) return obj;
    dart._throwCastError(obj, type, result);
  };
  dart.check = function(obj, type) {
    if (type == dart.dynamic || obj == null) return obj;
    let result = dart.strongInstanceOf(obj, type, true);
    if (result) return obj;
    dart._throwTypeError(obj, type, result);
  };
  dart.test = function(obj) {
    if (typeof obj == 'boolean') return obj;
    return dart.booleanConversionFailed(obj);
  };
  dart.booleanConversionFailed = function(obj) {
    if (obj == null) {
      dart.throw(new _js_helper.BooleanConversionAssertionError());
    }
    let actual = dart.getReifiedType(obj);
    let expected = core.bool;
    dart.throw(new _js_helper.TypeErrorImplementation.fromMessage(dart.str`type '${dart.typeName(actual)}' is not a subtype of ` + dart.str`type '${dart.typeName(expected)}' in boolean expression`));
  };
  dart._throwCastError = function(obj, type, result) {
    let actual = dart.getReifiedType(obj);
    if (result == false) dart.throwCastError(obj, actual, type);
    dart.throwStrongModeCastError(obj, actual, type);
  };
  dart._throwTypeError = function(obj, type, result) {
    let actual = dart.getReifiedType(obj);
    if (result == false) dart.throwTypeError(obj, actual, type);
    dart.throwStrongModeTypeError(obj, actual, type);
  };
  dart.asInt = function(obj) {
    if (obj == null) return null;
    if (Math.floor(obj) != obj) {
      dart.throwCastError(obj, dart.getReifiedType(obj), core.int);
    }
    return obj;
  };
  dart.addSimpleTypeTests = function(ctor) {
    ctor.is = function is_C(object) {
      if (object instanceof this) return true;
      return dart.is(object, this);
    };
    ctor.as = function as_C(object) {
      if (object instanceof this) return object;
      return dart.as(object, this);
    };
    ctor._check = function check_C(object) {
      if (object instanceof this) return object;
      return dart.check(object, this);
    };
  };
  dart.addTypeTests = function(ctor) {
    ctor.as = function as_G(object) {
      return dart.as(object, this);
    };
    ctor.is = function is_G(object) {
      return dart.is(object, this);
    };
    ctor._check = function check_G(object) {
      return dart.check(object, this);
    };
  };
  dart.equals = function(x, y) {
    if (x == null || y == null) return x == y;
    let eq = x['=='];
    return eq ? eq.call(x, y) : x === y;
  };
  dart.notNull = function(x) {
    if (x == null) dart.throwNullValueError();
    return x;
  };
  dart.map = function(values, K, V) {
    if (K === void 0) K = null;
    if (V === void 0) V = null;
    return (() => {
      if (K == null) K = dart.dynamic;
      if (V == null) V = dart.dynamic;
      let map = dart.getGenericClass(collection.LinkedHashMap)(K, V).new();
      if (Array.isArray(values)) {
        for (let i = 0, end = values.length - 1; i < end; i += 2) {
          let key = values[i];
          let value = values[i + 1];
          map.set(key, value);
        }
      } else if (typeof values === 'object') {
        for (let key of dart.getOwnPropertyNames(values)) {
          map.set(key, values[key]);
        }
      }
      return map;
    })();
  };
  dart.assert = function(condition) {
    if (!condition) dart.throwAssertionError();
  };
  dart.throw = function(obj) {
    if (obj != null && (typeof obj == 'object' || typeof obj == 'function')) {
      dart._stack.set(obj, new Error());
    }
    throw obj;
  };
  dart.getError = function(exception) {
    var stack = dart._stack.get(exception);
    return stack !== void 0 ? stack : exception;
  };
  dart.stackPrint = function(exception) {
    var error = dart.getError(exception);
    console.log(error.stack ? error.stack : 'No stack trace for: ' + error);
  };
  dart.stackTrace = function(exception) {
    var error = dart.getError(exception);
    return _js_helper.getTraceFromException(error);
  };
  dart.nullSafe = function(obj, ...callbacks) {
    if (obj == null) return obj;
    for (const callback of callbacks) {
      obj = callback(obj);
      if (obj == null) break;
    }
    return obj;
  };
  dart.multiKeyPutIfAbsent = function(map, keys, valueFn) {
    for (let k of keys) {
      let value = map.get(k);
      if (!value) {
        map.set(k, value = new Map());
      }
      map = value;
    }
    if (map.has(dart._value)) return map.get(dart._value);
    let value = valueFn();
    map.set(dart._value, value);
    return value;
  };
  dart.const = function(obj) {
    function lookupNonTerminal(map, key) {
      let result = map.get(key);
      if (result !== void 0) return result;
      map.set(key, result = new Map());
      return result;
    }
    let names = dart.getOwnNamesAndSymbols(obj);
    let count = names.length;
    let map = lookupNonTerminal(dart.constants, count);
    for (let i = 0; i < count; i++) {
      let name = names[i];
      map = lookupNonTerminal(map, name);
      map = lookupNonTerminal(map, obj[name]);
    }
    let type = dart.getReifiedType(obj);
    let value = map.get(type);
    if (value) return value;
    map.set(type, obj);
    return obj;
  };
  dart.constList = function(elements, elementType) {
    function lookupNonTerminal(map, key) {
      let result = map.get(key);
      if (result !== void 0) return result;
      map.set(key, result = new Map());
      return result;
    }
    let count = elements.length;
    let map = lookupNonTerminal(dart.constantLists, count);
    for (let i = 0; i < count; i++) {
      map = lookupNonTerminal(map, elements[i]);
    }
    let value = map.get(elementType);
    if (value) return value;
    value = dart.list(elements, elementType);
    map.set(elementType, value);
    return value;
  };
  dart.hashCode = function(obj) {
    if (obj == null) return 0;
    switch (typeof obj) {
      case "number":
      {
        return obj & 0x1FFFFFFF;
      }
      case "boolean":
      {
        return obj ? 2 * 3 * 23 * 3761 : 269 * 811;
      }
      case "function":
      {
        return _js_helper.Primitives.objectHashCode(obj);
      }
    }
    let extension = dart.getExtensionType(obj);
    if (extension != null) {
      return obj[dartx.hashCode];
    }
    return obj.hashCode;
  };
  dart.toString = function(obj) {
    if (obj == null) return "null";
    let extension = dart.getExtensionType(obj);
    if (extension != null) {
      return obj[dartx.toString]();
    }
    if (typeof obj == "function") {
      return "Closure: " + dart.getReifiedType(obj) + " from: " + obj;
    }
    return obj.toString();
  };
  dart.noSuchMethod = function(obj, invocation) {
    if (obj == null || typeof obj == "function") {
      dart.throw(new core.NoSuchMethodError(obj, invocation.memberName, invocation.positionalArguments, invocation.namedArguments));
    }
    let extension = dart.getExtensionType(obj);
    if (extension != null) {
      return obj[dartx.noSuchMethod](invocation);
    }
    return obj.noSuchMethod(invocation);
  };
  dart.constFn = function(x) {
    return () => x;
  };
  dart.runtimeType = function(obj) {
    let result = dart._checkPrimitiveType(obj);
    if (result != null) return dart.wrapType(result);
    let extension = dart.getExtensionType(obj);
    if (extension != null) {
      return obj[dartx.runtimeType];
    }
    if (typeof obj == "function") {
      return dart.wrapType(dart.getReifiedType(obj));
    }
    return obj.runtimeType;
  };
  dart.str = function(strings, ...values) {
    let s = strings[0];
    for (let i = 0, len = values.length; i < len;) {
      s += dart.notNull(dart.toString(values[i])) + strings[++i];
    }
    return s;
  };
  dart._canonicalMember = function(obj, name) {
    if (typeof name === "symbol") return name;
    if (obj != null && dart.getExtensionType(obj) != null) {
      return dartx[name];
    }
    if (dart.equals(name, 'constructor') || dart.equals(name, 'prototype')) {
      name = '+' + dart.notNull(core.String._check(name));
    }
    return name;
  };
  dart.defineProperty = function(obj, name, desc) {
    return Object.defineProperty(obj, name, desc);
  };
  dart.getOwnPropertyDescriptor = function(obj, name) {
    return Object.getOwnPropertyDescriptor(obj, name);
  };
  dart.getOwnPropertyNames = function(obj) {
    return Object.getOwnPropertyNames(obj);
  };
  dart.getOwnPropertySymbols = function(obj) {
    return Object.getOwnPropertySymbols(obj);
  };
  dart.throwStrongModeError = function(message) {
    throw new _js_helper.StrongModeErrorImplementation(message);
  };
  dart.throwInternalError = function(message) {
    throw Error(message);
  };
  dart.getOwnNamesAndSymbols = function(obj) {
    let names = dart.getOwnPropertyNames(obj);
    let symbols = dart.getOwnPropertySymbols(obj);
    return names.concat(symbols);
  };
  dart.safeGetOwnProperty = function(obj, name) {
    let desc = dart.getOwnPropertyDescriptor(obj, name);
    if (desc != null) return desc.value;
  };
  dart.defineLazyProperty = function(to, name, desc) {
    let init = desc.get;
    let value = null;
    function lazySetter(x) {
      init = null;
      value = x;
    }
    function circularInitError() {
      dart.throwInternalError('circular initialization for field ' + name);
    }
    function lazyGetter() {
      if (init == null) return value;
      let f = init;
      init = circularInitError;
      lazySetter(f());
      return value;
    }
    desc.get = lazyGetter;
    desc.configurable = true;
    if (desc.set) desc.set = lazySetter;
    return dart.defineProperty(to, name, desc);
  };
  dart.defineLazy = function(to, from) {
    for (let name of dart.getOwnNamesAndSymbols(from)) {
      dart.defineLazyProperty(to, name, dart.getOwnPropertyDescriptor(from, name));
    }
  };
  dart.defineMemoizedGetter = function(obj, name, getter) {
    return dart.defineLazyProperty(obj, name, {get: getter});
  };
  dart.copyTheseProperties = function(to, from, names) {
    for (let i = 0; i < names.length; ++i) {
      dart.copyProperty(to, from, names[i]);
    }
    return to;
  };
  dart.copyProperty = function(to, from, name) {
    let desc = dart.getOwnPropertyDescriptor(from, name);
    if (name == Symbol.iterator) {
      let existing = dart.getOwnPropertyDescriptor(to, name);
      if (existing != null) {
        if (existing.writable) {
          to[name] = desc.value;
        }
        return;
      }
    }
    dart.defineProperty(to, name, desc);
  };
  dart.export = function(to, from, name) {
    return dart.copyProperty(to, from, name);
  };
  dart.copyProperties = function(to, from) {
    return dart.copyTheseProperties(to, from, dart.getOwnNamesAndSymbols(from));
  };
  dart.global = typeof window == "undefined" ? global : window;
  dart.JsSymbol = Symbol;
  dart._mixins = Symbol("mixins");
  dart.implements = Symbol("implements");
  dart._typeArguments = Symbol("typeArguments");
  dart._originalDeclaration = Symbol("originalDeclaration");
  dart._constructorSig = Symbol("sigCtor");
  dart._methodSig = Symbol("sig");
  dart._staticSig = Symbol("sigStatic");
  dart._extensionType = Symbol("extensionType");
  dart.dartx = dartx;
  dart._runtimeType = Symbol("_runtimeType");
  dart.metadata = Symbol("metadata");
  dart._typeObject = Symbol("typeObject");
  core.Object = class Object {
    constructor(...args) {
      return this.new.apply(this, args);
    }
    new() {
    }
    ['=='](other) {
      return core.identical(this, other);
    }
    get hashCode() {
      return _js_helper.Primitives.objectHashCode(this);
    }
    toString() {
      return _js_helper.Primitives.objectToString(this);
    }
    noSuchMethod(invocation) {
      dart.throw(new core.NoSuchMethodError(this, invocation.memberName, invocation.positionalArguments, invocation.namedArguments));
    }
    get runtimeType() {
      return dart.wrapType(dart.getReifiedType(this));
    }
  };
  core.Object.is = function is_Object(o) {
    if (o instanceof this) return true;
    return dart.is(o, this);
  };
  core.Object.as = function as_Object(o) {
    if (o == null || o instanceof this) return o;
    return dart.as(o, this);
  };
  core.Object._check = function check_Object(o) {
    if (o == null || o instanceof this) return o;
    return dart.check(o, this);
  };
  dart.setSignature(core.Object, {
    constructors: () => ({new: dart.definiteFunctionType(core.Object, [])}),
    methods: () => ({
      '==': dart.definiteFunctionType(core.bool, [dart.dynamic]),
      toString: dart.definiteFunctionType(core.String, []),
      noSuchMethod: dart.definiteFunctionType(dart.dynamic, [core.Invocation])
    })
  });
  dart.TypeRep = class TypeRep extends core.Object {
    new() {
      dart._initialize;
    }
    get name() {
      return this.toString();
    }
  };
  dart.TypeRep[dart.implements] = () => [core.Type];
  dart.setSignature(dart.TypeRep, {
    constructors: () => ({new: dart.definiteFunctionType(dart.TypeRep, [])})
  });
  dart.Dynamic = class Dynamic extends dart.TypeRep {
    new() {
      super.new();
    }
    toString() {
      return 'dynamic';
    }
  };
  dart.dynamic = new dart.Dynamic();
  dart._initialize = dart._initialize2();
  dart.Void = class Void extends dart.TypeRep {
    new() {
      super.new();
    }
    toString() {
      return 'void';
    }
  };
  dart.void = new dart.Void();
  dart.Bottom = class Bottom extends dart.TypeRep {
    new() {
      super.new();
    }
    toString() {
      return 'bottom';
    }
  };
  dart.bottom = new dart.Bottom();
  dart.JSObject = class JSObject extends dart.TypeRep {
    new() {
      super.new();
    }
    toString() {
      return 'NativeJavaScriptObject';
    }
  };
  dart.jsobject = new dart.JSObject();
  core.Type = class Type extends core.Object {};
  dart.WrappedType = class WrappedType extends core.Type {
    new(wrappedType) {
      this[_wrappedType] = wrappedType;
    }
    toString() {
      return core.String._check(dart.typeName(this[_wrappedType]));
    }
  };
  dart.setSignature(dart.WrappedType, {
    constructors: () => ({new: dart.definiteFunctionType(dart.WrappedType, [dart.dynamic])})
  });
  dart.AbstractFunctionType = class AbstractFunctionType extends dart.TypeRep {
    constructor() {
      super();
      this._stringValue = null;
    }
    toString() {
      return this.name;
    }
    get name() {
      if (this._stringValue) return this._stringValue;
      let buffer = '(';
      for (let i = 0; i < this.args.length; ++i) {
        if (i > 0) {
          buffer += ', ';
        }
        buffer += dart.typeName(this.args[i]);
      }
      if (this.optionals.length > 0) {
        if (this.args.length > 0) buffer += ', ';
        buffer += '[';
        for (let i = 0; i < this.optionals.length; ++i) {
          if (i > 0) {
            buffer += ', ';
          }
          buffer += dart.typeName(this.optionals[i]);
        }
        buffer += ']';
      } else if (Object.keys(this.named).length > 0) {
        if (this.args.length > 0) buffer += ', ';
        buffer += '{';
        let names = dart.getOwnPropertyNames(this.named).sort();
        for (let i = 0; i < names.length; ++i) {
          if (i > 0) {
            buffer += ', ';
          }
          buffer += names[i] + ': ' + dart.typeName(this.named[names[i]]);
        }
        buffer += '}';
      }
      buffer += ') -> ' + dart.typeName(this.returnType);
      this._stringValue = buffer;
      return buffer;
    }
  };
  dart._fnTypeNamedArgMap = new Map();
  dart._fnTypeArrayArgMap = new Map();
  dart._fnTypeTypeMap = new Map();
  dart._fnTypeSmallMap = [new Map(), new Map(), new Map()];
  dart.FunctionType = class FunctionType extends dart.AbstractFunctionType {
    static _memoizeArray(map, arr, create) {
      let len = arr.length;
      map = FunctionType._lookupNonTerminal(map, len);
      for (var i = 0; i < len - 1; ++i) {
        map = FunctionType._lookupNonTerminal(map, arr[i]);
      }
      let result = map.get(arr[len - 1]);
      if (result !== void 0) return result;
      map.set(arr[len - 1], result = create());
      return result;
    }
    static _normalizeParameter(a) {
      if (a instanceof Array) {
        let result = [];
        result.push(a[0] == dart.dynamic ? dart.bottom : a[0]);
        result.push(a.slice(1));
        return result;
      }
      return a == dart.dynamic ? dart.bottom : a;
    }
    static _canonicalizeArray(definite, array, map) {
      let arr = definite ? array : array.map(FunctionType._normalizeParameter);
      return FunctionType._memoizeArray(map, arr, () => arr);
    }
    static _canonicalizeNamed(definite, named, map) {
      let key = [];
      let names = dart.getOwnPropertyNames(named);
      let r = {};
      for (var i = 0; i < names.length; ++i) {
        let name = names[i];
        let type = named[name];
        if (!definite) r[name] = type = FunctionType._normalizeParameter(type);
        key.push(name);
        key.push(type);
      }
      if (!definite) named = r;
      return FunctionType._memoizeArray(map, key, () => named);
    }
    static _lookupNonTerminal(map, key) {
      let result = map.get(key);
      if (result !== void 0) return result;
      map.set(key, result = new Map());
      return result;
    }
    static _createSmall(count, definite, returnType, required) {
      let map = dart._fnTypeSmallMap[count];
      let args = definite ? required : required.map(FunctionType._normalizeParameter);
      for (var i = 0; i < count; ++i) {
        map = FunctionType._lookupNonTerminal(map, args[i]);
      }
      let result = map.get(returnType);
      if (result !== void 0) return result;
      result = new FunctionType(returnType, args, [], {});
      map.set(returnType, result);
      return result;
    }
    static create(definite, returnType, args, extra) {
      if (extra === void 0 && args.length < 3) {
        return FunctionType._createSmall(args.length, definite, returnType, args);
      }
      args = FunctionType._canonicalizeArray(definite, args, dart._fnTypeArrayArgMap);
      let keys;
      let create;
      if (extra === void 0) {
        keys = [returnType, args];
        create = () => new FunctionType(returnType, args, [], {});
      } else if (extra instanceof Array) {
        let optionals = FunctionType._canonicalizeArray(definite, extra, dart._fnTypeArrayArgMap);
        keys = [returnType, args, optionals];
        create = () => new FunctionType(returnType, args, optionals, {});
      } else {
        let named = FunctionType._canonicalizeNamed(definite, extra, dart._fnTypeNamedArgMap);
        keys = [returnType, args, named];
        create = () => new FunctionType(returnType, args, [], named);
      }
      return FunctionType._memoizeArray(dart._fnTypeTypeMap, keys, create);
    }
    constructor(returnType, args, optionals, named) {
      super();
      this.returnType = returnType;
      this.args = args;
      this.optionals = optionals;
      this.named = named;
      this.metadata = [];
      function process(array, metadata) {
        var result = [];
        for (var i = 0; i < array.length; ++i) {
          var arg = array[i];
          if (arg instanceof Array) {
            metadata.push(arg.slice(1));
            result.push(arg[0]);
          } else {
            metadata.push([]);
            result.push(arg);
          }
        }
        return result;
      }
      this.args = process(this.args, this.metadata);
      this.optionals = process(this.optionals, this.metadata);
    }
  };
  dart.Typedef = class Typedef extends dart.AbstractFunctionType {
    constructor(name, closure) {
      super();
      this._name = name;
      this._closure = closure;
      this._functionType = null;
    }
    get name() {
      return this._name;
    }
    get functionType() {
      if (!this._functionType) {
        this._functionType = this._closure();
      }
      return this._functionType;
    }
    get returnType() {
      return this.functionType.returnType;
    }
    get args() {
      return this.functionType.args;
    }
    get optionals() {
      return this.functionType.optionals;
    }
    get named() {
      return this.functionType.named;
    }
    get metadata() {
      return this.functionType.metadata;
    }
  };
  dart._typeFormalCount = Symbol("_typeFormalCount");
  dart.isSubtype = dart._subtypeMemo((t1, t2) => t1 === t2 || dart._isSubtype(t1, t2, true));
  dart._jsIterator = Symbol("_jsIterator");
  dart._current = Symbol("_current");
  dart._AsyncStarStreamController = class _AsyncStarStreamController {
    constructor(generator, T, args) {
      this.isAdding = false;
      this.isWaiting = false;
      this.isScheduled = false;
      this.isSuspendedAtYield = false;
      this.canceler = null;
      this.iterator = generator(this, ...args)[Symbol.iterator]();
      this.controller = dart.getGenericClass(async.StreamController)(T).new({
        onListen: () => this.scheduleGenerator(),
        onResume: () => this.onResume(),
        onCancel: () => this.onCancel()
      });
    }
    onResume() {
      if (this.isSuspendedAtYield) {
        this.scheduleGenerator();
      }
    }
    onCancel() {
      if (this.controller.isClosed) {
        return null;
      }
      if (this.canceler == null) {
        this.canceler = async.Completer.new();
        this.scheduleGenerator();
      }
      return this.canceler.future;
    }
    close() {
      if (this.canceler != null && !this.canceler.isCompleted) {
        this.canceler.complete();
      }
      this.controller.close();
    }
    scheduleGenerator() {
      if (this.isScheduled || this.controller.isPaused || this.isAdding || this.isWaiting) {
        return;
      }
      this.isScheduled = true;
      async.scheduleMicrotask(() => this.runBody());
    }
    runBody(opt_awaitValue) {
      this.isScheduled = false;
      this.isSuspendedAtYield = false;
      this.isWaiting = false;
      let iter;
      try {
        iter = this.iterator.next(opt_awaitValue);
      } catch (e) {
        this.addError(e, dart.stackTrace(e));
        this.close();
        return;
      }

      if (iter.done) {
        this.close();
        return;
      }
      if (this.isSuspendedAtYield || this.isAdding) return;
      this.isWaiting = true;
      let future = iter.value;
      if (!dart.is(future, dart.getGenericClass(async.Future))) {
        future = async.Future.value(future);
      }
      return future.then(dart.dynamic)(x => this.runBody(x), {
        onError: (e, s) => this.throwError(e, s)
      });
    }
    add(event) {
      if (!this.controller.hasListener) return true;
      this.controller.add(event);
      this.scheduleGenerator();
      this.isSuspendedAtYield = true;
      return false;
    }
    addStream(stream) {
      if (!this.controller.hasListener) return true;
      this.isAdding = true;
      this.controller.addStream(stream, {cancelOnError: false}).then(dart.dynamic)(() => {
        this.isAdding = false;
        this.scheduleGenerator();
      }, {
        onError: (e, s) => this.throwError(e, s)
      });
    }
    throwError(error, stackTrace) {
      try {
        this.iterator.throw(error);
      } catch (e) {
        this.addError(e, stackTrace);
      }

    }
    addError(error, stackTrace) {
      if (this.canceler != null && !this.canceler.isCompleted) {
        this.canceler.completeError(error, stackTrace);
        return;
      }
      if (!this.controller.hasListener) return;
      this.controller.addError(error, stackTrace);
    }
  };
  core.Invocation = class Invocation extends core.Object {
    get isAccessor() {
      return dart.test(this.isGetter) || dart.test(this.isSetter);
    }
  };
  dart._Invocation = class _Invocation extends core.Invocation {
    new(memberName, positionalArguments, opts) {
      let namedArguments = opts && 'namedArguments' in opts ? opts.namedArguments : null;
      let isMethod = opts && 'isMethod' in opts ? opts.isMethod : false;
      let isGetter = opts && 'isGetter' in opts ? opts.isGetter : false;
      let isSetter = opts && 'isSetter' in opts ? opts.isSetter : false;
      this.positionalArguments = positionalArguments;
      this.isMethod = isMethod;
      this.isGetter = isGetter;
      this.isSetter = isSetter;
      this.memberName = dart._dartSymbol(memberName);
      this.namedArguments = dart._Invocation._namedArgsToSymbols(namedArguments);
    }
    static _namedArgsToSymbols(namedArgs) {
      if (namedArgs == null) return dart.map();
      return MapOfSymbol$dynamic().fromIterable(dart.getOwnPropertyNames(namedArgs), {key: dart._dartSymbol, value: dart.fn(k => namedArgs[k], dynamicTodynamic$())});
    }
  };
  dart.setSignature(dart._Invocation, {
    constructors: () => ({new: dart.definiteFunctionType(dart._Invocation, [core.String, core.List], {namedArguments: dart.dynamic, isMethod: core.bool, isGetter: core.bool, isSetter: core.bool})}),
    statics: () => ({_namedArgsToSymbols: dart.definiteFunctionType(core.Map$(core.Symbol, dart.dynamic), [dart.dynamic])}),
    names: ['_namedArgsToSymbols']
  });
  dart.defineLazy(dart, {
    get _callMethodStats() {
      return MapOfString$int().new();
    },
    set _callMethodStats(_) {}
  });
  dart.defineLazy(dart, {
    get trackProfile() {
      return dart.global.trackDdcProfile;
    },
    set trackProfile(_) {}
  });
  dart._ignoreTypeFailure = (() => {
    return dart._ignoreMemo((actual, type) => {
      if (!!dart.isSubtype(type, core.Iterable) && !!dart.isSubtype(actual, core.Iterable) || !!dart.isSubtype(type, async.Future) && !!dart.isSubtype(actual, async.Future) || !!dart.isSubtype(type, core.Map) && !!dart.isSubtype(actual, core.Map) || dart.isFunctionType(type) && dart.isFunctionType(actual) || !!dart.isSubtype(type, async.Stream) && !!dart.isSubtype(actual, async.Stream) || !!dart.isSubtype(type, async.StreamSubscription) && !!dart.isSubtype(actual, async.StreamSubscription)) {
        console.warn('Ignoring cast fail from ' + dart.typeName(actual) + ' to ' + dart.typeName(type));
        return true;
      }
      return false;
    });
  })();
  dart._stack = new WeakMap();
  dart._value = Symbol("_value");
  dart.constants = new Map();
  dart.constantLists = new Map();
  dart.JsIterator = class JsIterator {
    constructor(dartIterator) {
      this.dartIterator = dartIterator;
    }
    next() {
      let i = this.dartIterator;
      let done = !i.moveNext();
      return {done: done, value: done ? void 0 : i.current};
    }
  };
  dart.hasOwnProperty = Object.prototype.hasOwnProperty;
  _debugger.JsonMLConfig = class JsonMLConfig extends core.Object {
    new(name) {
      this.name = name;
    }
  };
  dart.setSignature(_debugger.JsonMLConfig, {
    constructors: () => ({new: dart.definiteFunctionType(_debugger.JsonMLConfig, [core.String])})
  });
  dart.defineLazy(_debugger.JsonMLConfig, {
    get none() {
      return dart.const(new _debugger.JsonMLConfig("none"));
    },
    get skipDart() {
      return dart.const(new _debugger.JsonMLConfig("skipDart"));
    },
    get keyToString() {
      return dart.const(new _debugger.JsonMLConfig("keyToString"));
    }
  });
  _debugger.maxIterableChildrenToDisplay = 50;
  dart.defineLazy(_debugger, {
    get _devtoolsFormatter() {
      return new _debugger.JsonMLFormatter(new _debugger.DartFormatter());
    },
    set _devtoolsFormatter(_) {}
  });
  _debugger._typeof = function(object) {
    return typeof object;
  };
  dart.lazyFn(_debugger._typeof, () => dynamicToString());
  _debugger.getOwnPropertyNames = function(object) {
    return dart.list(Object.getOwnPropertyNames(object), core.String);
  };
  dart.lazyFn(_debugger.getOwnPropertyNames, () => dynamicToListOfString());
  _debugger.getOwnPropertySymbols = function(object) {
    return Object.getOwnPropertySymbols(object);
  };
  dart.lazyFn(_debugger.getOwnPropertySymbols, () => dynamicToList());
  _debugger.JSNative = class JSNative extends core.Object {
    static getProperty(object, name) {
      return object[name];
    }
    static setProperty(object, name, value) {
      return object[name] = value;
    }
  };
  dart.setSignature(_debugger.JSNative, {
    statics: () => ({
      getProperty: dart.definiteFunctionType(dart.dynamic, [dart.dynamic, dart.dynamic]),
      setProperty: dart.definiteFunctionType(dart.dynamic, [dart.dynamic, dart.dynamic, dart.dynamic])
    }),
    names: ['getProperty', 'setProperty']
  });
  _debugger.getObjectTypeName = function(object) {
    let reifiedType = dart.getReifiedType(object);
    if (reifiedType == null) {
      if (_debugger._typeof(object) == 'function') {
        return '[[Raw JavaScript Function]]';
      }
      return '<Error getting type name>';
    }
    return _debugger.getTypeName(core.Type._check(reifiedType));
  };
  dart.lazyFn(_debugger.getObjectTypeName, () => dynamicToString());
  _debugger.getTypeName = function(type) {
    let name = dart.typeName(type);
    if (dart.equals(name, 'JSArray<dynamic>') || dart.equals(name, 'JSObject<Array>')) return 'List<dynamic>';
    return core.String._check(name);
  };
  dart.lazyFn(_debugger.getTypeName, () => TypeToString());
  const _simpleFormatter = Symbol('_simpleFormatter');
  _debugger.safePreview = function(object) {
    try {
      let preview = _debugger._devtoolsFormatter[_simpleFormatter].preview(object);
      if (preview != null) return preview;
      return dart.toString(object);
    } catch (e) {
      return dart.str`<Exception thrown> ${e}`;
    }

  };
  dart.lazyFn(_debugger.safePreview, () => dynamicToString());
  _debugger.symbolName = function(symbol) {
    let name = dart.toString(symbol);
    dart.assert(name[dartx.startsWith]('Symbol('));
    return name[dartx.substring]('Symbol('[dartx.length], dart.notNull(name[dartx.length]) - 1);
  };
  dart.lazyFn(_debugger.symbolName, () => dynamicToString());
  _debugger.hasMethod = function(object, name) {
    try {
      return core.bool._check(dart.hasMethod(object, name));
    } catch (e) {
      return false;
    }

  };
  dart.lazyFn(_debugger.hasMethod, () => dynamicAndStringTobool());
  _debugger.NameValuePair = class NameValuePair extends core.Object {
    new(opts) {
      let name = opts && 'name' in opts ? opts.name : null;
      let value = opts && 'value' in opts ? opts.value : null;
      let config = opts && 'config' in opts ? opts.config : _debugger.JsonMLConfig.none;
      this.name = name;
      this.value = value;
      this.config = config;
    }
    ['=='](other) {
      return _debugger.NameValuePair.is(other) && other.name == this.name;
    }
    get hashCode() {
      return dart.hashCode(this.name);
    }
  };
  dart.setSignature(_debugger.NameValuePair, {
    constructors: () => ({new: dart.definiteFunctionType(_debugger.NameValuePair, [], {name: core.String, value: core.Object, config: _debugger.JsonMLConfig})})
  });
  _debugger.MapEntry = class MapEntry extends core.Object {
    new(opts) {
      let key = opts && 'key' in opts ? opts.key : null;
      let value = opts && 'value' in opts ? opts.value : null;
      this.key = key;
      this.value = value;
    }
  };
  dart.setSignature(_debugger.MapEntry, {
    constructors: () => ({new: dart.definiteFunctionType(_debugger.MapEntry, [], {key: core.Object, value: core.Object})})
  });
  _debugger.ClassMetadata = class ClassMetadata extends core.Object {
    new(object) {
      this.object = object;
    }
  };
  dart.setSignature(_debugger.ClassMetadata, {
    constructors: () => ({new: dart.definiteFunctionType(_debugger.ClassMetadata, [core.Object])})
  });
  _debugger.HeritageClause = class HeritageClause extends core.Object {
    new(name, types) {
      this.name = name;
      this.types = types;
    }
  };
  dart.setSignature(_debugger.HeritageClause, {
    constructors: () => ({new: dart.definiteFunctionType(_debugger.HeritageClause, [core.String, core.List])})
  });
  const _attributes = Symbol('_attributes');
  const _jsonML = Symbol('_jsonML');
  _debugger.JsonMLElement = class JsonMLElement extends core.Object {
    new(tagName) {
      this[_attributes] = null;
      this[_jsonML] = null;
      this[_attributes] = {};
      this[_jsonML] = [tagName, this[_attributes]];
    }
    appendChild(element) {
      this[_jsonML][dartx.add](dart.dsend(element, 'toJsonML'));
    }
    createChild(tagName) {
      let c = new _debugger.JsonMLElement(tagName);
      this[_jsonML][dartx.add](c.toJsonML());
      return c;
    }
    createObjectTag(object) {
      return (() => {
        let _ = this.createChild('object');
        _.addAttribute('object', object);
        return _;
      })();
    }
    setStyle(style) {
      dart.dput(this[_attributes], 'style', style);
    }
    addStyle(style) {
      if (dart.dload(this[_attributes], 'style') == null) {
        dart.dput(this[_attributes], 'style', style);
      } else {
        let o = this[_attributes];
        dart.dput(o, 'style', dart.dsend(dart.dload(o, 'style'), '+', style));
      }
    }
    addAttribute(key, value) {
      _debugger.JSNative.setProperty(this[_attributes], key, value);
    }
    createTextChild(text) {
      this[_jsonML][dartx.add](text);
    }
    toJsonML() {
      return this[_jsonML];
    }
  };
  dart.setSignature(_debugger.JsonMLElement, {
    constructors: () => ({new: dart.definiteFunctionType(_debugger.JsonMLElement, [dart.dynamic])}),
    methods: () => ({
      appendChild: dart.definiteFunctionType(dart.dynamic, [dart.dynamic]),
      createChild: dart.definiteFunctionType(_debugger.JsonMLElement, [core.String]),
      createObjectTag: dart.definiteFunctionType(_debugger.JsonMLElement, [dart.dynamic]),
      setStyle: dart.definiteFunctionType(dart.void, [core.String]),
      addStyle: dart.definiteFunctionType(dart.dynamic, [core.String]),
      addAttribute: dart.definiteFunctionType(dart.dynamic, [dart.dynamic, dart.dynamic]),
      createTextChild: dart.definiteFunctionType(dart.dynamic, [core.String]),
      toJsonML: dart.definiteFunctionType(dart.dynamic, [])
    })
  });
  _debugger.isNativeJavaScriptObject = function(object) {
    let type = _debugger._typeof(object);
    return type != 'object' && type != 'function' || dart.JSObject.is(object) || html$.Node.is(object);
  };
  dart.lazyFn(_debugger.isNativeJavaScriptObject, () => dynamicTobool$());
  _debugger.JsonMLFormatter = class JsonMLFormatter extends core.Object {
    new(simpleFormatter) {
      this[_simpleFormatter] = simpleFormatter;
    }
    header(object, config) {
      if (dart.equals(config, _debugger.JsonMLConfig.skipDart) || dart.test(_debugger.isNativeJavaScriptObject(object))) {
        return null;
      }
      let c = this[_simpleFormatter].preview(object);
      if (c == null) return null;
      if (dart.equals(config, _debugger.JsonMLConfig.keyToString)) {
        c = dart.toString(object);
      }
      let element = new _debugger.JsonMLElement('span');
      element.setStyle('background-color: #d9edf7');
      element.createTextChild(c);
      return element.toJsonML();
    }
    hasBody(object) {
      return this[_simpleFormatter].hasChildren(object);
    }
    body(object) {
      let body = new _debugger.JsonMLElement('ol');
      body.setStyle('list-style-type: none;' + 'padding-left: 0px;' + 'margin-top: 0px;' + 'margin-bottom: 0px;' + 'margin-left: 12px');
      let children = this[_simpleFormatter].children(object);
      for (let child of children) {
        let li = body.createChild('li');
        let nameSpan = new _debugger.JsonMLElement('span');
        nameSpan.createTextChild(child.name != null ? dart.notNull(child.name) + ': ' : '');
        nameSpan.setStyle('color: rgb(136, 19, 145);');
        if (_debugger._typeof(child.value) == 'object' || _debugger._typeof(child.value) == 'function') {
          nameSpan.addStyle("padding-left: 13px;");
          li.appendChild(nameSpan);
          let objectTag = li.createObjectTag(child.value);
          objectTag.addAttribute('config', child.config);
          if (!dart.test(this[_simpleFormatter].hasChildren(child.value))) {
            li.setStyle("padding-left: 13px;");
          }
        } else {
          li.setStyle("padding-left: 13px;");
          let _ = li.createChild('span');
          _.appendChild(nameSpan);
          _.createTextChild(_debugger.safePreview(child.value));
        }
      }
      return body.toJsonML();
    }
  };
  dart.setSignature(_debugger.JsonMLFormatter, {
    constructors: () => ({new: dart.definiteFunctionType(_debugger.JsonMLFormatter, [_debugger.DartFormatter])}),
    methods: () => ({
      header: dart.definiteFunctionType(dart.dynamic, [dart.dynamic, dart.dynamic]),
      hasBody: dart.definiteFunctionType(core.bool, [dart.dynamic]),
      body: dart.definiteFunctionType(dart.dynamic, [dart.dynamic])
    })
  });
  _debugger.Formatter = class Formatter extends core.Object {};
  const _formatters = Symbol('_formatters');
  _debugger.DartFormatter = class DartFormatter extends core.Object {
    new() {
      this[_formatters] = null;
      this[_formatters] = JSArrayOfFormatter().of([new _debugger.FunctionFormatter(), new _debugger.MapFormatter(), new _debugger.IterableFormatter(), new _debugger.MapEntryFormatter(), new _debugger.ClassMetadataFormatter(), new _debugger.HeritageClauseFormatter(), new _debugger.ObjectFormatter()]);
    }
    preview(object) {
      try {
        if (object == null || typeof object == 'number' || typeof object == 'string' || dart.test(_debugger.isNativeJavaScriptObject(object))) {
          return dart.toString(object);
        }
        for (let formatter of this[_formatters]) {
          if (dart.test(formatter.accept(object))) return formatter.preview(object);
        }
      } catch (e) {
        let trace = dart.stackTrace(e);
        html$.window[dartx.console].error(dart.str`Caught exception ${e}\n trace:\n${trace}`);
      }

      return null;
    }
    hasChildren(object) {
      if (object == null) return false;
      try {
        for (let formatter of this[_formatters]) {
          if (dart.test(formatter.accept(object))) return formatter.hasChildren(object);
        }
      } catch (e) {
        let trace = dart.stackTrace(e);
        html$.window[dartx.console].error(dart.str`[hasChildren] Caught exception ${e}\n trace:\n${trace}`);
      }

      return false;
    }
    children(object) {
      try {
        if (object != null) {
          for (let formatter of this[_formatters]) {
            if (dart.test(formatter.accept(object))) return formatter.children(object);
          }
        }
      } catch (e) {
        let trace = dart.stackTrace(e);
        html$.window[dartx.console].error(dart.str`Caught exception ${e}\n trace:\n${trace}`);
      }

      return JSArrayOfNameValuePair().of([]);
    }
  };
  dart.setSignature(_debugger.DartFormatter, {
    constructors: () => ({new: dart.definiteFunctionType(_debugger.DartFormatter, [])}),
    methods: () => ({
      preview: dart.definiteFunctionType(core.String, [dart.dynamic]),
      hasChildren: dart.definiteFunctionType(core.bool, [dart.dynamic]),
      children: dart.definiteFunctionType(core.List$(_debugger.NameValuePair), [dart.dynamic])
    })
  });
  _debugger.ObjectFormatter = class ObjectFormatter extends _debugger.Formatter {
    accept(object) {
      return !dart.test(_debugger.isNativeJavaScriptObject(object));
    }
    preview(object) {
      return _debugger.getObjectTypeName(object);
    }
    hasChildren(object) {
      return true;
    }
    children(object) {
      let properties = LinkedHashSetOfNameValuePair().new();
      this.addMetadataChildren(object, properties);
      let protoChain = JSArrayOfObject().of([]);
      let current = object;
      while (current != null && !dart.test(_debugger.isNativeJavaScriptObject(current)) && current !== Object.prototype) {
        protoChain[dartx.add](current);
        current = _debugger.JSNative.getProperty(current, '__proto__');
      }
      for (/* Unimplemented unknown name */current of protoChain) {
        for (let symbol of _debugger.getOwnPropertySymbols(current)) {
          let dartName = _debugger.symbolName(symbol);
          if (dart.test(_debugger.hasMethod(object, dartName))) {
            continue;
          }
          let dartXPrefix = 'dartx.';
          if (dart.test(dartName[dartx.startsWith](dartXPrefix))) {
            dartName = dartName[dartx.substring](dartXPrefix[dartx.length]);
          } else if (!dart.test(dartName[dartx.startsWith]('_'))) {
            continue;
          }
          let value = null;
          try {
            value = _debugger.JSNative.getProperty(object, symbol);
          } catch (e) {
            value = dart.str`<Exception thrown> ${e}`;
          }

          properties.add(new _debugger.NameValuePair({name: dartName, value: value}));
        }
      }
      for (/* Unimplemented unknown name */current of protoChain) {
        let className = dart.dload(dart.getReifiedType(current), 'name');
        for (let name of _debugger.getOwnPropertyNames(current)) {
          if (dart.test(_debugger.ObjectFormatter._customNames.contains(name)) || dart.equals(name, className)) continue;
          if (dart.test(_debugger.hasMethod(object, name))) {
            continue;
          }
          let value = null;
          try {
            value = _debugger.JSNative.getProperty(object, name);
          } catch (e) {
            value = dart.str`<Exception thrown> ${e}`;
          }

          properties.add(new _debugger.NameValuePair({name: name, value: value}));
        }
      }
      return properties.toList();
    }
    addMetadataChildren(object, ret) {
      ret.add(new _debugger.NameValuePair({name: '[[class]]', value: new _debugger.ClassMetadata(object)}));
    }
  };
  dart.setSignature(_debugger.ObjectFormatter, {
    methods: () => ({
      accept: dart.definiteFunctionType(core.bool, [dart.dynamic]),
      preview: dart.definiteFunctionType(core.String, [dart.dynamic]),
      hasChildren: dart.definiteFunctionType(core.bool, [dart.dynamic]),
      children: dart.definiteFunctionType(core.List$(_debugger.NameValuePair), [dart.dynamic]),
      addMetadataChildren: dart.definiteFunctionType(dart.dynamic, [dart.dynamic, core.Set$(_debugger.NameValuePair)])
    })
  });
  dart.defineLazy(_debugger.ObjectFormatter, {
    get _customNames() {
      return (() => {
        let _ = SetOfString().new();
        _.add('constructor');
        _.add('prototype');
        _.add('__proto__');
        return _;
      })();
    },
    set _customNames(_) {}
  });
  _debugger.FunctionFormatter = class FunctionFormatter extends _debugger.Formatter {
    accept(object) {
      if (_debugger._typeof(object) != 'function') return false;
      return dart.getReifiedType(object) != null;
    }
    hasChildren(object) {
      return true;
    }
    preview(object) {
      return core.String._check(dart.typeName(dart.getReifiedType(object)));
    }
    children(object) {
      return JSArrayOfNameValuePair().of([new _debugger.NameValuePair({name: 'signature', value: this.preview(object)}), new _debugger.NameValuePair({name: 'JavaScript Function', value: object, config: _debugger.JsonMLConfig.skipDart})]);
    }
  };
  dart.setSignature(_debugger.FunctionFormatter, {
    methods: () => ({
      accept: dart.definiteFunctionType(core.bool, [dart.dynamic]),
      hasChildren: dart.definiteFunctionType(core.bool, [dart.dynamic]),
      preview: dart.definiteFunctionType(core.String, [dart.dynamic]),
      children: dart.definiteFunctionType(core.List$(_debugger.NameValuePair), [dart.dynamic])
    })
  });
  _debugger.MapFormatter = class MapFormatter extends _debugger.ObjectFormatter {
    accept(object) {
      return core.Map.is(object);
    }
    hasChildren(object) {
      return true;
    }
    preview(object) {
      let map = core.Map._check(object);
      return dart.str`${_debugger.getObjectTypeName(map)} length ${map[dartx.length]}`;
    }
    children(object) {
      let map = core.Map._check(object);
      let entries = LinkedHashSetOfNameValuePair().new();
      map[dartx.forEach](dart.fn((key, value) => {
        let entryWrapper = new _debugger.MapEntry({key: key, value: value});
        entries.add(new _debugger.NameValuePair({name: dart.toString(entries.length), value: entryWrapper}));
      }, dynamicAnddynamicTovoid()));
      this.addMetadataChildren(object, entries);
      return entries.toList();
    }
  };
  _debugger.IterableFormatter = class IterableFormatter extends _debugger.ObjectFormatter {
    accept(object) {
      return core.Iterable.is(object);
    }
    preview(object) {
      let iterable = core.Iterable._check(object);
      try {
        let length = iterable[dartx.length];
        return dart.str`${_debugger.getObjectTypeName(iterable)} length ${length}`;
      } catch (_) {
        return dart.str`${_debugger.getObjectTypeName(iterable)}`;
      }

    }
    hasChildren(object) {
      return true;
    }
    children(object) {
      let iterable = core.Iterable._check(object);
      let ret = LinkedHashSetOfNameValuePair().new();
      let i = 0;
      for (let entry of iterable) {
        if (i > dart.notNull(_debugger.maxIterableChildrenToDisplay)) {
          ret.add(new _debugger.NameValuePair({name: 'Warning', value: 'Truncated Iterable display'}));
          break;
        }
        ret.add(new _debugger.NameValuePair({name: dart.toString(i), value: entry}));
        i++;
      }
      this.addMetadataChildren(object, ret);
      return ret.toList();
    }
  };
  const _getType = Symbol('_getType');
  _debugger.ClassMetadataFormatter = class ClassMetadataFormatter extends core.Object {
    accept(object) {
      return _debugger.ClassMetadata.is(object);
    }
    [_getType](object) {
      if (core.Type.is(object)) return object;
      return dart.getReifiedType(object);
    }
    preview(object) {
      let entry = _debugger.ClassMetadata._check(object);
      return _debugger.getTypeName(core.Type._check(this[_getType](entry.object)));
    }
    hasChildren(object) {
      return true;
    }
    children(object) {
      let entry = _debugger.ClassMetadata._check(object);
      let type = this[_getType](entry.object);
      let ret = JSArrayOfNameValuePair().of([]);
      let implements$ = dart.getImplements(type);
      if (implements$ != null) {
        ret[dartx.add](new _debugger.NameValuePair({name: '[[Implements]]', value: new _debugger.HeritageClause('implements', core.List._check(dart.dcall(implements$)))}));
      }
      let mixins = dart.getMixins(type);
      if (mixins != null && dart.test(dart.dload(mixins, 'isNotEmpty'))) {
        ret[dartx.add](new _debugger.NameValuePair({name: '[[Mixins]]', value: new _debugger.HeritageClause('mixins', core.List._check(mixins))}));
      }
      ret[dartx.add](new _debugger.NameValuePair({name: '[[JavaScript View]]', value: entry.object, config: _debugger.JsonMLConfig.skipDart}));
      if (!core.Type.is(entry.object)) {
        ret[dartx.add](new _debugger.NameValuePair({name: '[[JavaScript Constructor]]', value: _debugger.JSNative.getProperty(entry.object, 'constructor'), config: _debugger.JsonMLConfig.skipDart}));
      }
      return ret;
    }
  };
  _debugger.ClassMetadataFormatter[dart.implements] = () => [_debugger.Formatter];
  dart.setSignature(_debugger.ClassMetadataFormatter, {
    methods: () => ({
      accept: dart.definiteFunctionType(core.bool, [dart.dynamic]),
      [_getType]: dart.definiteFunctionType(dart.dynamic, [dart.dynamic]),
      preview: dart.definiteFunctionType(core.String, [dart.dynamic]),
      hasChildren: dart.definiteFunctionType(core.bool, [dart.dynamic]),
      children: dart.definiteFunctionType(core.List$(_debugger.NameValuePair), [dart.dynamic])
    })
  });
  _debugger.MapEntryFormatter = class MapEntryFormatter extends core.Object {
    accept(object) {
      return _debugger.MapEntry.is(object);
    }
    preview(object) {
      let entry = _debugger.MapEntry._check(object);
      return dart.str`${_debugger.safePreview(entry.key)} => ${_debugger.safePreview(entry.value)}`;
    }
    hasChildren(object) {
      return true;
    }
    children(object) {
      return JSArrayOfNameValuePair().of([new _debugger.NameValuePair({name: 'key', value: dart.dload(object, 'key'), config: _debugger.JsonMLConfig.keyToString}), new _debugger.NameValuePair({name: 'value', value: dart.dload(object, 'value')})]);
    }
  };
  _debugger.MapEntryFormatter[dart.implements] = () => [_debugger.Formatter];
  dart.setSignature(_debugger.MapEntryFormatter, {
    methods: () => ({
      accept: dart.definiteFunctionType(core.bool, [dart.dynamic]),
      preview: dart.definiteFunctionType(core.String, [dart.dynamic]),
      hasChildren: dart.definiteFunctionType(core.bool, [dart.dynamic]),
      children: dart.definiteFunctionType(core.List$(_debugger.NameValuePair), [dart.dynamic])
    })
  });
  _debugger.HeritageClauseFormatter = class HeritageClauseFormatter extends core.Object {
    accept(object) {
      return _debugger.HeritageClause.is(object);
    }
    preview(object) {
      let clause = _debugger.HeritageClause._check(object);
      let typeNames = clause.types[dartx.map](core.String)(dart.fn(type => _debugger.getTypeName(core.Type._check(type)), dynamicToString()));
      return dart.str`${clause.name} ${typeNames[dartx.join](", ")}`;
    }
    hasChildren(object) {
      return true;
    }
    children(object) {
      let clause = _debugger.HeritageClause._check(object);
      let ret = JSArrayOfNameValuePair().of([]);
      for (let type of clause.types) {
        ret[dartx.add](new _debugger.NameValuePair({value: new _debugger.ClassMetadata(type)}));
      }
      return ret;
    }
  };
  _debugger.HeritageClauseFormatter[dart.implements] = () => [_debugger.Formatter];
  dart.setSignature(_debugger.HeritageClauseFormatter, {
    methods: () => ({
      accept: dart.definiteFunctionType(core.bool, [dart.dynamic]),
      preview: dart.definiteFunctionType(core.String, [dart.dynamic]),
      hasChildren: dart.definiteFunctionType(core.bool, [dart.dynamic]),
      children: dart.definiteFunctionType(core.List$(_debugger.NameValuePair), [dart.dynamic])
    })
  });
  _debugger.registerDevtoolsFormatter = function() {
    let formatters = JSArrayOfJsonMLFormatter().of([_debugger._devtoolsFormatter]);
    dart.global.devtoolsFormatters = formatters;
  };
  dart.fn(_debugger.registerDevtoolsFormatter, VoidTodynamic$());
  _foreign_helper.JS = function(typeDescription, codeTemplate, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11) {
    if (arg0 === void 0) arg0 = null;
    if (arg1 === void 0) arg1 = null;
    if (arg2 === void 0) arg2 = null;
    if (arg3 === void 0) arg3 = null;
    if (arg4 === void 0) arg4 = null;
    if (arg5 === void 0) arg5 = null;
    if (arg6 === void 0) arg6 = null;
    if (arg7 === void 0) arg7 = null;
    if (arg8 === void 0) arg8 = null;
    if (arg9 === void 0) arg9 = null;
    if (arg10 === void 0) arg10 = null;
    if (arg11 === void 0) arg11 = null;
  };
  dart.lazyFn(_foreign_helper.JS, () => StringAndString__Todynamic());
  _foreign_helper.JSExportName = class JSExportName extends core.Object {
    new(name) {
      this.name = name;
    }
  };
  dart.setSignature(_foreign_helper.JSExportName, {
    constructors: () => ({new: dart.definiteFunctionType(_foreign_helper.JSExportName, [core.String])})
  });
  _foreign_helper.JS_CURRENT_ISOLATE_CONTEXT = function() {
  };
  dart.lazyFn(_foreign_helper.JS_CURRENT_ISOLATE_CONTEXT, () => VoidToIsolateContext());
  _foreign_helper.IsolateContext = class IsolateContext extends core.Object {};
  _foreign_helper.JS_CALL_IN_ISOLATE = function(isolate, func) {
  };
  dart.lazyFn(_foreign_helper.JS_CALL_IN_ISOLATE, () => dynamicAndFunctionTodynamic());
  _foreign_helper.JS_SET_CURRENT_ISOLATE = function(isolate) {
  };
  dart.fn(_foreign_helper.JS_SET_CURRENT_ISOLATE, dynamicTovoid$());
  _foreign_helper.JS_CREATE_ISOLATE = function() {
  };
  dart.fn(_foreign_helper.JS_CREATE_ISOLATE, VoidTodynamic$());
  _foreign_helper.JS_DART_OBJECT_CONSTRUCTOR = function() {
  };
  dart.fn(_foreign_helper.JS_DART_OBJECT_CONSTRUCTOR, VoidTodynamic$());
  _foreign_helper.JS_INTERCEPTOR_CONSTANT = function(type) {
  };
  dart.fn(_foreign_helper.JS_INTERCEPTOR_CONSTANT, TypeTodynamic());
  _foreign_helper.JS_OPERATOR_IS_PREFIX = function() {
  };
  dart.lazyFn(_foreign_helper.JS_OPERATOR_IS_PREFIX, () => VoidToString$());
  _foreign_helper.JS_OPERATOR_AS_PREFIX = function() {
  };
  dart.lazyFn(_foreign_helper.JS_OPERATOR_AS_PREFIX, () => VoidToString$());
  _foreign_helper.JS_OBJECT_CLASS_NAME = function() {
  };
  dart.lazyFn(_foreign_helper.JS_OBJECT_CLASS_NAME, () => VoidToString$());
  _foreign_helper.JS_NULL_CLASS_NAME = function() {
  };
  dart.lazyFn(_foreign_helper.JS_NULL_CLASS_NAME, () => VoidToString$());
  _foreign_helper.JS_FUNCTION_CLASS_NAME = function() {
  };
  dart.lazyFn(_foreign_helper.JS_FUNCTION_CLASS_NAME, () => VoidToString$());
  _foreign_helper.JS_IS_INDEXABLE_FIELD_NAME = function() {
  };
  dart.lazyFn(_foreign_helper.JS_IS_INDEXABLE_FIELD_NAME, () => VoidToString$());
  _foreign_helper.JS_CURRENT_ISOLATE = function() {
  };
  dart.fn(_foreign_helper.JS_CURRENT_ISOLATE, VoidTodynamic$());
  _foreign_helper.JS_SIGNATURE_NAME = function() {
  };
  dart.lazyFn(_foreign_helper.JS_SIGNATURE_NAME, () => VoidToString$());
  _foreign_helper.JS_TYPEDEF_TAG = function() {
  };
  dart.lazyFn(_foreign_helper.JS_TYPEDEF_TAG, () => VoidToString$());
  _foreign_helper.JS_FUNCTION_TYPE_TAG = function() {
  };
  dart.lazyFn(_foreign_helper.JS_FUNCTION_TYPE_TAG, () => VoidToString$());
  _foreign_helper.JS_FUNCTION_TYPE_VOID_RETURN_TAG = function() {
  };
  dart.lazyFn(_foreign_helper.JS_FUNCTION_TYPE_VOID_RETURN_TAG, () => VoidToString$());
  _foreign_helper.JS_FUNCTION_TYPE_RETURN_TYPE_TAG = function() {
  };
  dart.lazyFn(_foreign_helper.JS_FUNCTION_TYPE_RETURN_TYPE_TAG, () => VoidToString$());
  _foreign_helper.JS_FUNCTION_TYPE_REQUIRED_PARAMETERS_TAG = function() {
  };
  dart.lazyFn(_foreign_helper.JS_FUNCTION_TYPE_REQUIRED_PARAMETERS_TAG, () => VoidToString$());
  _foreign_helper.JS_FUNCTION_TYPE_OPTIONAL_PARAMETERS_TAG = function() {
  };
  dart.lazyFn(_foreign_helper.JS_FUNCTION_TYPE_OPTIONAL_PARAMETERS_TAG, () => VoidToString$());
  _foreign_helper.JS_FUNCTION_TYPE_NAMED_PARAMETERS_TAG = function() {
  };
  dart.lazyFn(_foreign_helper.JS_FUNCTION_TYPE_NAMED_PARAMETERS_TAG, () => VoidToString$());
  _foreign_helper.JS_GET_NAME = function(name) {
  };
  dart.lazyFn(_foreign_helper.JS_GET_NAME, () => StringToString$());
  _foreign_helper.JS_EMBEDDED_GLOBAL = function(typeDescription, name) {
  };
  dart.lazyFn(_foreign_helper.JS_EMBEDDED_GLOBAL, () => StringAndStringTodynamic());
  _foreign_helper.JS_GET_FLAG = function(name) {
  };
  dart.lazyFn(_foreign_helper.JS_GET_FLAG, () => StringTobool());
  _foreign_helper.JS_EFFECT = function(code) {
    dart.dcall(code, null);
  };
  dart.lazyFn(_foreign_helper.JS_EFFECT, () => FunctionTovoid());
  _foreign_helper.JS_CONST = class JS_CONST extends core.Object {
    new(code) {
      this.code = code;
    }
  };
  dart.setSignature(_foreign_helper.JS_CONST, {
    constructors: () => ({new: dart.definiteFunctionType(_foreign_helper.JS_CONST, [core.String])})
  });
  _foreign_helper.JS_STRING_CONCAT = function(a, b) {
    return a + b;
  };
  dart.lazyFn(_foreign_helper.JS_STRING_CONCAT, () => StringAndStringToString());
  _foreign_helper._Rest = class _Rest extends core.Object {
    new() {
    }
  };
  dart.setSignature(_foreign_helper._Rest, {
    constructors: () => ({new: dart.definiteFunctionType(_foreign_helper._Rest, [])})
  });
  _foreign_helper.rest = dart.const(new _foreign_helper._Rest());
  _foreign_helper.spread = function(args) {
    dart.throw(new core.StateError('The spread function cannot be called, ' + 'it should be compiled away.'));
  };
  dart.fn(_foreign_helper.spread, dynamicTodynamic$());
  _interceptors.Interceptor = class Interceptor extends core.Object {
    new() {
    }
  };
  dart.addTypeTests(_interceptors.Interceptor);
  dart.setSignature(_interceptors.Interceptor, {
    constructors: () => ({new: dart.definiteFunctionType(_interceptors.Interceptor, [])})
  });
  _interceptors.getInterceptor = function(obj) {
    return obj;
  };
  dart.fn(_interceptors.getInterceptor, dynamicTodynamic$());
  dart.defineExtensionNames([
    'toString',
    'hashCode',
    'runtimeType'
  ]);
  _interceptors.JSBool = class JSBool extends _interceptors.Interceptor {
    new() {
      super.new();
    }
    [dartx.toString]() {
      return String(this);
    }
    get [dartx.hashCode]() {
      return this ? 2 * 3 * 23 * 3761 : 269 * 811;
    }
    get [dartx.runtimeType]() {
      return dart.wrapType(core.bool);
    }
  };
  _interceptors.JSBool[dart.implements] = () => [core.bool];
  dart.setSignature(_interceptors.JSBool, {
    constructors: () => ({new: dart.definiteFunctionType(_interceptors.JSBool, [])})
  });
  dart.registerExtension(dart.global.Boolean, _interceptors.JSBool);
  _interceptors.JSIndexable = class JSIndexable extends core.Object {};
  _interceptors.JSMutableIndexable = class JSMutableIndexable extends _interceptors.JSIndexable {};
  _interceptors.JSObject = class JSObject extends core.Object {};
  _interceptors.JavaScriptObject = class JavaScriptObject extends _interceptors.Interceptor {
    new() {
      super.new();
    }
    get hashCode() {
      return 0;
    }
    get runtimeType() {
      return dart.wrapType(_interceptors.JSObject);
    }
  };
  _interceptors.JavaScriptObject[dart.implements] = () => [_interceptors.JSObject];
  dart.setSignature(_interceptors.JavaScriptObject, {
    constructors: () => ({new: dart.definiteFunctionType(_interceptors.JavaScriptObject, [])})
  });
  _interceptors.PlainJavaScriptObject = class PlainJavaScriptObject extends _interceptors.JavaScriptObject {
    new() {
      super.new();
    }
  };
  dart.setSignature(_interceptors.PlainJavaScriptObject, {
    constructors: () => ({new: dart.definiteFunctionType(_interceptors.PlainJavaScriptObject, [])})
  });
  _interceptors.UnknownJavaScriptObject = class UnknownJavaScriptObject extends _interceptors.JavaScriptObject {
    new() {
      super.new();
    }
    toString() {
      return String(this);
    }
  };
  dart.setSignature(_interceptors.UnknownJavaScriptObject, {
    constructors: () => ({new: dart.definiteFunctionType(_interceptors.UnknownJavaScriptObject, [])})
  });
  _interceptors.findInterceptorConstructorForType = function(type) {
  };
  dart.fn(_interceptors.findInterceptorConstructorForType, TypeTodynamic());
  _interceptors.findConstructorForNativeSubclassType = function(type, name) {
  };
  dart.lazyFn(_interceptors.findConstructorForNativeSubclassType, () => TypeAndStringTodynamic());
  _interceptors.getNativeInterceptor = function(object) {
  };
  dart.fn(_interceptors.getNativeInterceptor, dynamicTodynamic$());
  _interceptors.setDispatchProperty = function(object, value) {
  };
  dart.fn(_interceptors.setDispatchProperty, dynamicAnddynamicTodynamic$());
  const _removeWhere = Symbol('_removeWhere');
  _interceptors.JSArray$ = dart.generic(E => {
    let JSArrayOfE = () => (JSArrayOfE = dart.constFn(_interceptors.JSArray$(E)))();
    let IterableOfE = () => (IterableOfE = dart.constFn(core.Iterable$(E)))();
    let WhereIterableOfE = () => (WhereIterableOfE = dart.constFn(_internal.WhereIterable$(E)))();
    let SubListIterableOfE = () => (SubListIterableOfE = dart.constFn(_internal.SubListIterable$(E)))();
    let TakeWhileIterableOfE = () => (TakeWhileIterableOfE = dart.constFn(_internal.TakeWhileIterable$(E)))();
    let SkipWhileIterableOfE = () => (SkipWhileIterableOfE = dart.constFn(_internal.SkipWhileIterable$(E)))();
    let EAndEToE = () => (EAndEToE = dart.constFn(dart.functionType(E, [E, E])))();
    let VoidToE = () => (VoidToE = dart.constFn(dart.functionType(E, [])))();
    let ListOfE = () => (ListOfE = dart.constFn(core.List$(E)))();
    let ReversedListIterableOfE = () => (ReversedListIterableOfE = dart.constFn(_internal.ReversedListIterable$(E)))();
    let SetOfE = () => (SetOfE = dart.constFn(core.Set$(E)))();
    let ArrayIteratorOfE = () => (ArrayIteratorOfE = dart.constFn(_interceptors.ArrayIterator$(E)))();
    let ListMapViewOfE = () => (ListMapViewOfE = dart.constFn(_internal.ListMapView$(E)))();
    dart.defineExtensionNames([
      'checkMutable',
      'checkGrowable',
      'add',
      'removeAt',
      'insert',
      'insertAll',
      'setAll',
      'removeLast',
      'remove',
      'removeWhere',
      'retainWhere',
      'where',
      'expand',
      'addAll',
      'clear',
      'forEach',
      'map',
      'join',
      'take',
      'takeWhile',
      'skip',
      'skipWhile',
      'reduce',
      'fold',
      'firstWhere',
      'lastWhere',
      'singleWhere',
      'elementAt',
      'sublist',
      'getRange',
      'first',
      'last',
      'single',
      'removeRange',
      'setRange',
      'fillRange',
      'replaceRange',
      'any',
      'every',
      'reversed',
      'sort',
      'shuffle',
      'indexOf',
      'lastIndexOf',
      'contains',
      'isEmpty',
      'isNotEmpty',
      'toString',
      'toList',
      'toSet',
      'iterator',
      'hashCode',
      'length',
      'length',
      'get',
      'set',
      'asMap'
    ]);
    class JSArray extends core.Object {
      new() {
      }
      static typed(allocation) {
        return dart.list(allocation, E);
      }
      static of(allocation) {
        return dart.setType(allocation, JSArray);
      }
      static markFixed(allocation) {
        return JSArrayOfE().typed(_interceptors.JSArray.markFixedList(core.List._check(allocation)));
      }
      static markGrowable(allocation) {
        return JSArrayOfE().typed(allocation);
      }
      static markFixedList(list) {
        list.fixed$length = Array;
        return list;
      }
      static markUnmodifiableList(list) {
        list.fixed$length = Array;
        list.immutable$list = Array;
        return list;
      }
      [dartx.checkMutable](reason) {
        if (this.immutable$list) {
          dart.throw(new core.UnsupportedError(core.String._check(reason)));
        }
      }
      [dartx.checkGrowable](reason) {
        if (this.fixed$length) {
          dart.throw(new core.UnsupportedError(core.String._check(reason)));
        }
      }
      [dartx.add](value) {
        E._check(value);
        this[dartx.checkGrowable]('add');
        this.push(value);
      }
      [dartx.removeAt](index) {
        this[dartx.checkGrowable]('removeAt');
        if (!(typeof index == 'number')) dart.throw(_js_helper.argumentErrorValue(index));
        if (dart.notNull(index) < 0 || dart.notNull(index) >= dart.notNull(this[dartx.length])) {
          dart.throw(new core.RangeError.value(index));
        }
        return this.splice(index, 1)[0];
      }
      [dartx.insert](index, value) {
        E._check(value);
        this[dartx.checkGrowable]('insert');
        if (!(typeof index == 'number')) dart.throw(_js_helper.argumentErrorValue(index));
        if (dart.notNull(index) < 0 || dart.notNull(index) > dart.notNull(this[dartx.length])) {
          dart.throw(new core.RangeError.value(index));
        }
        this.splice(index, 0, value);
      }
      [dartx.insertAll](index, iterable) {
        IterableOfE()._check(iterable);
        this[dartx.checkGrowable]('insertAll');
        core.RangeError.checkValueInInterval(index, 0, this[dartx.length], "index");
        if (!_internal.EfficientLength.is(iterable)) {
          iterable = iterable[dartx.toList]();
        }
        let insertionLength = iterable[dartx.length];
        this[dartx.length] = dart.notNull(this[dartx.length]) + dart.notNull(insertionLength);
        let end = dart.notNull(index) + dart.notNull(insertionLength);
        this[dartx.setRange](end, this[dartx.length], this, index);
        this[dartx.setRange](index, end, iterable);
      }
      [dartx.setAll](index, iterable) {
        IterableOfE()._check(iterable);
        this[dartx.checkMutable]('setAll');
        core.RangeError.checkValueInInterval(index, 0, this[dartx.length], "index");
        for (let element of iterable) {
          this[dartx.set]((() => {
            let x = index;
            index = dart.notNull(x) + 1;
            return x;
          })(), element);
        }
      }
      [dartx.removeLast]() {
        this[dartx.checkGrowable]('removeLast');
        if (this[dartx.length] == 0) dart.throw(_js_helper.diagnoseIndexError(this, -1));
        return this.pop();
      }
      [dartx.remove](element) {
        this[dartx.checkGrowable]('remove');
        for (let i = 0; i < dart.notNull(this[dartx.length]); i++) {
          if (dart.equals(this[dartx.get](i), element)) {
            this.splice(i, 1);
            return true;
          }
        }
        return false;
      }
      [dartx.removeWhere](test) {
        this[dartx.checkGrowable]('removeWhere');
        this[_removeWhere](test, true);
      }
      [dartx.retainWhere](test) {
        this[dartx.checkGrowable]('retainWhere');
        this[_removeWhere](test, false);
      }
      [_removeWhere](test, removeMatching) {
        let retained = [];
        let end = this[dartx.length];
        for (let i = 0; i < dart.notNull(end); i++) {
          let element = this[i];
          if (!dart.test(test(E._check(element))) == removeMatching) {
            retained[dartx.add](element);
          }
          if (this[dartx.length] != end) dart.throw(new core.ConcurrentModificationError(this));
        }
        if (retained[dartx.length] == end) return;
        this[dartx.length] = retained[dartx.length];
        for (let i = 0; i < dart.notNull(retained[dartx.length]); i++) {
          this[dartx.set](i, E._check(retained[dartx.get](i)));
        }
      }
      [dartx.where](f) {
        return new (WhereIterableOfE())(this, f);
      }
      [dartx.expand](T) {
        return f => {
          return new (_internal.ExpandIterable$(E, T))(this, f);
        };
      }
      [dartx.addAll](collection) {
        IterableOfE()._check(collection);
        let i = this[dartx.length];
        this[dartx.checkGrowable]('addAll');
        for (let e of collection) {
          dart.assert(i == this[dartx.length] || dart.test(dart.throw(new core.ConcurrentModificationError(this))));
          i = dart.notNull(i) + 1;
          this.push(e);
        }
      }
      [dartx.clear]() {
        this[dartx.length] = 0;
      }
      [dartx.forEach](f) {
        let end = this[dartx.length];
        for (let i = 0; i < dart.notNull(end); i++) {
          let element = this[i];
          f(element);
          if (this[dartx.length] != end) dart.throw(new core.ConcurrentModificationError(this));
        }
      }
      [dartx.map](T) {
        return f => {
          return new (_internal.MappedListIterable$(E, T))(this, f);
        };
      }
      [dartx.join](separator) {
        if (separator === void 0) separator = "";
        let list = core.List.new(this[dartx.length]);
        for (let i = 0; i < dart.notNull(this[dartx.length]); i++) {
          list[dartx.set](i, dart.str`${this[dartx.get](i)}`);
        }
        return list.join(separator);
      }
      [dartx.take](n) {
        return new (SubListIterableOfE())(this, 0, n);
      }
      [dartx.takeWhile](test) {
        return new (TakeWhileIterableOfE())(this, test);
      }
      [dartx.skip](n) {
        return new (SubListIterableOfE())(this, n, null);
      }
      [dartx.skipWhile](test) {
        return new (SkipWhileIterableOfE())(this, test);
      }
      [dartx.reduce](combine) {
        EAndEToE()._check(combine);
        let length = this[dartx.length];
        if (length == 0) dart.throw(_internal.IterableElementError.noElement());
        let value = this[dartx.get](0);
        for (let i = 1; i < dart.notNull(length); i++) {
          let element = this[i];
          value = combine(value, element);
          if (length != this[dartx.length]) dart.throw(new core.ConcurrentModificationError(this));
        }
        return value;
      }
      [dartx.fold](T) {
        return (initialValue, combine) => {
          let value = initialValue;
          let length = this[dartx.length];
          for (let i = 0; i < dart.notNull(length); i++) {
            let element = this[i];
            value = combine(value, element);
            if (this[dartx.length] != length) dart.throw(new core.ConcurrentModificationError(this));
          }
          return value;
        };
      }
      [dartx.firstWhere](test, opts) {
        let orElse = opts && 'orElse' in opts ? opts.orElse : null;
        VoidToE()._check(orElse);
        let end = this[dartx.length];
        for (let i = 0; i < dart.notNull(end); ++i) {
          let element = this[i];
          if (dart.test(test(element))) return element;
          if (this[dartx.length] != end) dart.throw(new core.ConcurrentModificationError(this));
        }
        if (orElse != null) return orElse();
        dart.throw(_internal.IterableElementError.noElement());
      }
      [dartx.lastWhere](test, opts) {
        let orElse = opts && 'orElse' in opts ? opts.orElse : null;
        VoidToE()._check(orElse);
        let length = this[dartx.length];
        for (let i = dart.notNull(length) - 1; i >= 0; i--) {
          let element = this[i];
          if (dart.test(test(element))) return element;
          if (length != this[dartx.length]) {
            dart.throw(new core.ConcurrentModificationError(this));
          }
        }
        if (orElse != null) return orElse();
        dart.throw(_internal.IterableElementError.noElement());
      }
      [dartx.singleWhere](test) {
        let length = this[dartx.length];
        let match = null;
        let matchFound = false;
        for (let i = 0; i < dart.notNull(length); i++) {
          let element = this[i];
          if (dart.test(test(E._check(element)))) {
            if (matchFound) {
              dart.throw(_internal.IterableElementError.tooMany());
            }
            matchFound = true;
            match = E._check(element);
          }
          if (length != this[dartx.length]) {
            dart.throw(new core.ConcurrentModificationError(this));
          }
        }
        if (matchFound) return match;
        dart.throw(_internal.IterableElementError.noElement());
      }
      [dartx.elementAt](index) {
        return this[dartx.get](index);
      }
      [dartx.sublist](start, end) {
        if (end === void 0) end = null;
        _js_helper.checkNull(start);
        if (!(typeof start == 'number')) dart.throw(_js_helper.argumentErrorValue(start));
        if (dart.notNull(start) < 0 || dart.notNull(start) > dart.notNull(this[dartx.length])) {
          dart.throw(new core.RangeError.range(start, 0, this[dartx.length], "start"));
        }
        if (end == null) {
          end = this[dartx.length];
        } else {
          if (!(typeof end == 'number')) dart.throw(_js_helper.argumentErrorValue(end));
          if (dart.notNull(end) < dart.notNull(start) || dart.notNull(end) > dart.notNull(this[dartx.length])) {
            dart.throw(new core.RangeError.range(end, start, this[dartx.length], "end"));
          }
        }
        if (start == end) return JSArrayOfE().of([]);
        return JSArrayOfE().typed(this.slice(start, end));
      }
      [dartx.getRange](start, end) {
        core.RangeError.checkValidRange(start, end, this[dartx.length]);
        return new (SubListIterableOfE())(this, start, end);
      }
      get [dartx.first]() {
        if (dart.notNull(this[dartx.length]) > 0) return this[dartx.get](0);
        dart.throw(_internal.IterableElementError.noElement());
      }
      get [dartx.last]() {
        if (dart.notNull(this[dartx.length]) > 0) return this[dartx.get](dart.notNull(this[dartx.length]) - 1);
        dart.throw(_internal.IterableElementError.noElement());
      }
      get [dartx.single]() {
        if (this[dartx.length] == 1) return this[dartx.get](0);
        if (this[dartx.length] == 0) dart.throw(_internal.IterableElementError.noElement());
        dart.throw(_internal.IterableElementError.tooMany());
      }
      [dartx.removeRange](start, end) {
        this[dartx.checkGrowable]('removeRange');
        core.RangeError.checkValidRange(start, end, this[dartx.length]);
        let deleteCount = dart.notNull(end) - dart.notNull(start);
        this.splice(start, deleteCount);
      }
      [dartx.setRange](start, end, iterable, skipCount) {
        IterableOfE()._check(iterable);
        if (skipCount === void 0) skipCount = 0;
        this[dartx.checkMutable]('set range');
        core.RangeError.checkValidRange(start, end, this[dartx.length]);
        let length = dart.notNull(end) - dart.notNull(start);
        if (length == 0) return;
        core.RangeError.checkNotNegative(skipCount, "skipCount");
        let otherList = null;
        let otherStart = null;
        if (core.List.is(iterable)) {
          otherList = ListOfE()._check(iterable);
          otherStart = skipCount;
        } else {
          otherList = iterable[dartx.skip](skipCount)[dartx.toList]({growable: false});
          otherStart = 0;
        }
        if (dart.notNull(otherStart) + length > dart.notNull(otherList[dartx.length])) {
          dart.throw(_internal.IterableElementError.tooFew());
        }
        if (dart.notNull(otherStart) < dart.notNull(start)) {
          for (let i = length - 1; i >= 0; i--) {
            let element = otherList[dartx.get](dart.notNull(otherStart) + i);
            this[dart.notNull(start) + i] = element;
          }
        } else {
          for (let i = 0; i < length; i++) {
            let element = otherList[dartx.get](dart.notNull(otherStart) + i);
            this[dart.notNull(start) + i] = element;
          }
        }
      }
      [dartx.fillRange](start, end, fillValue) {
        if (fillValue === void 0) fillValue = null;
        E._check(fillValue);
        this[dartx.checkMutable]('fill range');
        core.RangeError.checkValidRange(start, end, this[dartx.length]);
        for (let i = start; dart.notNull(i) < dart.notNull(end); i = dart.notNull(i) + 1) {
          this[i] = fillValue;
        }
      }
      [dartx.replaceRange](start, end, replacement) {
        IterableOfE()._check(replacement);
        this[dartx.checkGrowable]('replace range');
        core.RangeError.checkValidRange(start, end, this[dartx.length]);
        if (!_internal.EfficientLength.is(replacement)) {
          replacement = replacement[dartx.toList]();
        }
        let removeLength = dart.notNull(end) - dart.notNull(start);
        let insertLength = replacement[dartx.length];
        if (removeLength >= dart.notNull(insertLength)) {
          let delta = removeLength - dart.notNull(insertLength);
          let insertEnd = dart.notNull(start) + dart.notNull(insertLength);
          let newLength = dart.notNull(this[dartx.length]) - delta;
          this[dartx.setRange](start, insertEnd, replacement);
          if (delta != 0) {
            this[dartx.setRange](insertEnd, newLength, this, end);
            this[dartx.length] = newLength;
          }
        } else {
          let delta = dart.notNull(insertLength) - removeLength;
          let newLength = dart.notNull(this[dartx.length]) + delta;
          let insertEnd = dart.notNull(start) + dart.notNull(insertLength);
          this[dartx.length] = newLength;
          this[dartx.setRange](insertEnd, newLength, this, end);
          this[dartx.setRange](start, insertEnd, replacement);
        }
      }
      [dartx.any](test) {
        let end = this[dartx.length];
        for (let i = 0; i < dart.notNull(end); i++) {
          let element = this[i];
          if (dart.test(test(element))) return true;
          if (this[dartx.length] != end) dart.throw(new core.ConcurrentModificationError(this));
        }
        return false;
      }
      [dartx.every](test) {
        let end = this[dartx.length];
        for (let i = 0; i < dart.notNull(end); i++) {
          let element = this[i];
          if (!dart.test(test(element))) return false;
          if (this[dartx.length] != end) dart.throw(new core.ConcurrentModificationError(this));
        }
        return true;
      }
      get [dartx.reversed]() {
        return new (ReversedListIterableOfE())(this);
      }
      [dartx.sort](compare) {
        if (compare === void 0) compare = null;
        this[dartx.checkMutable]('sort');
        _internal.Sort.sort(dart.dynamic)(this, compare == null ? core.Comparable.compare : compare);
      }
      [dartx.shuffle](random) {
        if (random === void 0) random = null;
        this[dartx.checkMutable]('shuffle');
        if (random == null) random = math.Random.new();
        let length = this[dartx.length];
        while (dart.notNull(length) > 1) {
          let pos = random.nextInt(length);
          length = dart.notNull(length) - 1;
          let tmp = this[dartx.get](length);
          this[dartx.set](length, this[dartx.get](pos));
          this[dartx.set](pos, tmp);
        }
      }
      [dartx.indexOf](element, start) {
        if (start === void 0) start = 0;
        if (dart.notNull(start) >= dart.notNull(this[dartx.length])) {
          return -1;
        }
        if (dart.notNull(start) < 0) {
          start = 0;
        }
        for (let i = start; dart.notNull(i) < dart.notNull(this[dartx.length]); i = dart.notNull(i) + 1) {
          if (dart.equals(this[dartx.get](i), element)) {
            return i;
          }
        }
        return -1;
      }
      [dartx.lastIndexOf](element, startIndex) {
        if (startIndex === void 0) startIndex = null;
        if (startIndex == null) {
          startIndex = dart.notNull(this[dartx.length]) - 1;
        } else {
          if (dart.notNull(startIndex) < 0) {
            return -1;
          }
          if (dart.notNull(startIndex) >= dart.notNull(this[dartx.length])) {
            startIndex = dart.notNull(this[dartx.length]) - 1;
          }
        }
        for (let i = startIndex; dart.notNull(i) >= 0; i = dart.notNull(i) - 1) {
          if (dart.equals(this[dartx.get](i), element)) {
            return i;
          }
        }
        return -1;
      }
      [dartx.contains](other) {
        for (let i = 0; i < dart.notNull(this[dartx.length]); i++) {
          if (dart.equals(this[dartx.get](i), other)) return true;
        }
        return false;
      }
      get [dartx.isEmpty]() {
        return this[dartx.length] == 0;
      }
      get [dartx.isNotEmpty]() {
        return !dart.test(this[dartx.isEmpty]);
      }
      [dartx.toString]() {
        return collection.ListBase.listToString(this);
      }
      [dartx.toList](opts) {
        let growable = opts && 'growable' in opts ? opts.growable : true;
        let list = this.slice();
        if (!dart.test(growable)) _interceptors.JSArray.markFixedList(core.List._check(list));
        return JSArrayOfE().typed(list);
      }
      [dartx.toSet]() {
        return SetOfE().from(this);
      }
      get [dartx.iterator]() {
        return new (ArrayIteratorOfE())(this);
      }
      get [dartx.hashCode]() {
        return _js_helper.Primitives.objectHashCode(this);
      }
      get [dartx.length]() {
        return this.length;
      }
      set [dartx.length](newLength) {
        this[dartx.checkGrowable]('set length');
        if (!(typeof newLength == 'number')) {
          dart.throw(new core.ArgumentError.value(newLength, 'newLength'));
        }
        if (dart.notNull(newLength) < 0) {
          dart.throw(new core.RangeError.range(newLength, 0, null, 'newLength'));
        }
        this.length = newLength;
      }
      [dartx.get](index) {
        if (!(typeof index == 'number')) dart.throw(_js_helper.diagnoseIndexError(this, index));
        if (dart.notNull(index) >= dart.notNull(this[dartx.length]) || dart.notNull(index) < 0) dart.throw(_js_helper.diagnoseIndexError(this, index));
        return this[index];
      }
      [dartx.set](index, value) {
        E._check(value);
        this[dartx.checkMutable]('indexed set');
        if (!(typeof index == 'number')) dart.throw(_js_helper.diagnoseIndexError(this, index));
        if (dart.notNull(index) >= dart.notNull(this[dartx.length]) || dart.notNull(index) < 0) dart.throw(_js_helper.diagnoseIndexError(this, index));
        this[index] = value;
        return value;
      }
      [dartx.asMap]() {
        return new (ListMapViewOfE())(this);
      }
    }
    dart.setExtensionBaseClass(JSArray, dart.global.Array);
    dart.addTypeTests(JSArray);
    JSArray[dart.implements] = () => [ListOfE(), _interceptors.JSIndexable];
    dart.setSignature(JSArray, {
      constructors: () => ({
        new: dart.definiteFunctionType(_interceptors.JSArray$(E), []),
        typed: dart.definiteFunctionType(_interceptors.JSArray$(E), [dart.dynamic]),
        of: dart.definiteFunctionType(_interceptors.JSArray$(E), [dart.dynamic]),
        markFixed: dart.definiteFunctionType(_interceptors.JSArray$(E), [dart.dynamic]),
        markGrowable: dart.definiteFunctionType(_interceptors.JSArray$(E), [dart.dynamic])
      }),
      methods: () => ({
        [dartx.checkMutable]: dart.definiteFunctionType(dart.dynamic, [dart.dynamic]),
        [dartx.checkGrowable]: dart.definiteFunctionType(dart.dynamic, [dart.dynamic]),
        [dartx.add]: dart.definiteFunctionType(dart.void, [E]),
        [dartx.removeAt]: dart.definiteFunctionType(E, [core.int]),
        [dartx.insert]: dart.definiteFunctionType(dart.void, [core.int, E]),
        [dartx.insertAll]: dart.definiteFunctionType(dart.void, [core.int, core.Iterable$(E)]),
        [dartx.setAll]: dart.definiteFunctionType(dart.void, [core.int, core.Iterable$(E)]),
        [dartx.removeLast]: dart.definiteFunctionType(E, []),
        [dartx.remove]: dart.definiteFunctionType(core.bool, [core.Object]),
        [dartx.removeWhere]: dart.definiteFunctionType(dart.void, [dart.functionType(core.bool, [E])]),
        [dartx.retainWhere]: dart.definiteFunctionType(dart.void, [dart.functionType(core.bool, [E])]),
        [_removeWhere]: dart.definiteFunctionType(dart.void, [dart.functionType(core.bool, [E]), core.bool]),
        [dartx.where]: dart.definiteFunctionType(core.Iterable$(E), [dart.functionType(core.bool, [E])]),
        [dartx.expand]: dart.definiteFunctionType(T => [core.Iterable$(T), [dart.functionType(core.Iterable$(T), [E])]]),
        [dartx.addAll]: dart.definiteFunctionType(dart.void, [core.Iterable$(E)]),
        [dartx.clear]: dart.definiteFunctionType(dart.void, []),
        [dartx.forEach]: dart.definiteFunctionType(dart.void, [dart.functionType(dart.void, [E])]),
        [dartx.map]: dart.definiteFunctionType(T => [core.Iterable$(T), [dart.functionType(T, [E])]]),
        [dartx.join]: dart.definiteFunctionType(core.String, [], [core.String]),
        [dartx.take]: dart.definiteFunctionType(core.Iterable$(E), [core.int]),
        [dartx.takeWhile]: dart.definiteFunctionType(core.Iterable$(E), [dart.functionType(core.bool, [E])]),
        [dartx.skip]: dart.definiteFunctionType(core.Iterable$(E), [core.int]),
        [dartx.skipWhile]: dart.definiteFunctionType(core.Iterable$(E), [dart.functionType(core.bool, [E])]),
        [dartx.reduce]: dart.definiteFunctionType(E, [dart.functionType(E, [E, E])]),
        [dartx.fold]: dart.definiteFunctionType(T => [T, [T, dart.functionType(T, [T, E])]]),
        [dartx.firstWhere]: dart.definiteFunctionType(E, [dart.functionType(core.bool, [E])], {orElse: VoidToE()}),
        [dartx.lastWhere]: dart.definiteFunctionType(E, [dart.functionType(core.bool, [E])], {orElse: VoidToE()}),
        [dartx.singleWhere]: dart.definiteFunctionType(E, [dart.functionType(core.bool, [E])]),
        [dartx.elementAt]: dart.definiteFunctionType(E, [core.int]),
        [dartx.sublist]: dart.definiteFunctionType(core.List$(E), [core.int], [core.int]),
        [dartx.getRange]: dart.definiteFunctionType(core.Iterable$(E), [core.int, core.int]),
        [dartx.removeRange]: dart.definiteFunctionType(dart.void, [core.int, core.int]),
        [dartx.setRange]: dart.definiteFunctionType(dart.void, [core.int, core.int, core.Iterable$(E)], [core.int]),
        [dartx.fillRange]: dart.definiteFunctionType(dart.void, [core.int, core.int], [E]),
        [dartx.replaceRange]: dart.definiteFunctionType(dart.void, [core.int, core.int, core.Iterable$(E)]),
        [dartx.any]: dart.definiteFunctionType(core.bool, [dart.functionType(core.bool, [E])]),
        [dartx.every]: dart.definiteFunctionType(core.bool, [dart.functionType(core.bool, [E])]),
        [dartx.sort]: dart.definiteFunctionType(dart.void, [], [dart.functionType(core.int, [E, E])]),
        [dartx.shuffle]: dart.definiteFunctionType(dart.void, [], [math.Random]),
        [dartx.indexOf]: dart.definiteFunctionType(core.int, [core.Object], [core.int]),
        [dartx.lastIndexOf]: dart.definiteFunctionType(core.int, [core.Object], [core.int]),
        [dartx.contains]: dart.definiteFunctionType(core.bool, [core.Object]),
        [dartx.toList]: dart.definiteFunctionType(core.List$(E), [], {growable: core.bool}),
        [dartx.toSet]: dart.definiteFunctionType(core.Set$(E), []),
        [dartx.get]: dart.definiteFunctionType(E, [core.int]),
        [dartx.set]: dart.definiteFunctionType(dart.void, [core.int, E]),
        [dartx.asMap]: dart.definiteFunctionType(core.Map$(core.int, E), [])
      }),
      statics: () => ({
        markFixedList: dart.definiteFunctionType(core.List, [core.List]),
        markUnmodifiableList: dart.definiteFunctionType(core.List, [core.List])
      }),
      names: ['markFixedList', 'markUnmodifiableList']
    });
    return JSArray;
  });
  _interceptors.JSArray = JSArray();
  dart.registerExtension(dart.global.Array, _interceptors.JSArray);
  _interceptors.JSMutableArray$ = dart.generic(E => {
    class JSMutableArray extends _interceptors.JSArray$(E) {
      new() {
        super.new();
      }
    }
    JSMutableArray[dart.implements] = () => [_interceptors.JSMutableIndexable];
    return JSMutableArray;
  });
  _interceptors.JSMutableArray = JSMutableArray();
  _interceptors.JSFixedArray$ = dart.generic(E => {
    class JSFixedArray extends _interceptors.JSMutableArray$(E) {}
    return JSFixedArray;
  });
  _interceptors.JSFixedArray = JSFixedArray();
  _interceptors.JSExtendableArray$ = dart.generic(E => {
    class JSExtendableArray extends _interceptors.JSMutableArray$(E) {}
    return JSExtendableArray;
  });
  _interceptors.JSExtendableArray = JSExtendableArray();
  _interceptors.JSUnmodifiableArray$ = dart.generic(E => {
    class JSUnmodifiableArray extends _interceptors.JSArray$(E) {
      new() {
        super.new();
      }
    }
    return JSUnmodifiableArray;
  });
  _interceptors.JSUnmodifiableArray = JSUnmodifiableArray();
  const _iterable = Symbol('_iterable');
  const _length = Symbol('_length');
  const _index = Symbol('_index');
  const _current = Symbol('_current');
  _interceptors.ArrayIterator$ = dart.generic(E => {
    let IteratorOfE = () => (IteratorOfE = dart.constFn(core.Iterator$(E)))();
    class ArrayIterator extends core.Object {
      new(iterable) {
        this[_iterable] = iterable;
        this[_length] = iterable[dartx.length];
        this[_index] = 0;
        this[_current] = null;
      }
      get current() {
        return this[_current];
      }
      moveNext() {
        let length = this[_iterable][dartx.length];
        if (this[_length] != length) {
          dart.throw(_js_helper.throwConcurrentModificationError(this[_iterable]));
        }
        if (dart.notNull(this[_index]) >= dart.notNull(length)) {
          this[_current] = null;
          return false;
        }
        this[_current] = this[_iterable][dartx.get](this[_index]);
        this[_index] = dart.notNull(this[_index]) + 1;
        return true;
      }
    }
    dart.addTypeTests(ArrayIterator);
    ArrayIterator[dart.implements] = () => [IteratorOfE()];
    dart.setSignature(ArrayIterator, {
      constructors: () => ({new: dart.definiteFunctionType(_interceptors.ArrayIterator$(E), [_interceptors.JSArray$(E)])}),
      methods: () => ({moveNext: dart.definiteFunctionType(core.bool, [])})
    });
    return ArrayIterator;
  });
  _interceptors.ArrayIterator = ArrayIterator();
  const _isInt32 = Symbol('_isInt32');
  const _tdivSlow = Symbol('_tdivSlow');
  const _shlPositive = Symbol('_shlPositive');
  const _shrOtherPositive = Symbol('_shrOtherPositive');
  const _shrBothPositive = Symbol('_shrBothPositive');
  dart.defineExtensionNames([
    'compareTo',
    'isNegative',
    'isNaN',
    'isInfinite',
    'isFinite',
    'remainder',
    'abs',
    'sign',
    'toInt',
    'truncate',
    'ceil',
    'floor',
    'round',
    'ceilToDouble',
    'floorToDouble',
    'roundToDouble',
    'truncateToDouble',
    'clamp',
    'toDouble',
    'toStringAsFixed',
    'toStringAsExponential',
    'toStringAsPrecision',
    'toRadixString',
    'toString',
    'hashCode',
    'unary-',
    '+',
    '-',
    '/',
    '*',
    '%',
    '~/',
    '<<',
    '>>',
    '&',
    '|',
    '^',
    '<',
    '>',
    '<=',
    '>=',
    'isEven',
    'isOdd',
    'toUnsigned',
    'toSigned',
    'bitLength',
    'modPow',
    'modInverse',
    'gcd',
    '~'
  ]);
  _interceptors.JSNumber = class JSNumber extends _interceptors.Interceptor {
    new() {
      super.new();
    }
    [dartx.compareTo](b) {
      if (this < dart.notNull(b)) {
        return -1;
      } else if (this > dart.notNull(b)) {
        return 1;
      } else if (this == b) {
        if (this == 0) {
          let bIsNegative = b[dartx.isNegative];
          if (this[dartx.isNegative] == bIsNegative) return 0;
          if (dart.test(this[dartx.isNegative])) return -1;
          return 1;
        }
        return 0;
      } else if (dart.test(this[dartx.isNaN])) {
        if (dart.test(b[dartx.isNaN])) {
          return 0;
        }
        return 1;
      } else {
        return -1;
      }
    }
    get [dartx.isNegative]() {
      return this == 0 ? 1 / this < 0 : this < 0;
    }
    get [dartx.isNaN]() {
      return isNaN(this);
    }
    get [dartx.isInfinite]() {
      return this == 1 / 0 || this == -1 / 0;
    }
    get [dartx.isFinite]() {
      return isFinite(this);
    }
    [dartx.remainder](b) {
      if (!(typeof b == 'number')) dart.throw(_js_helper.argumentErrorValue(b));
      return this % b;
    }
    [dartx.abs]() {
      return Math.abs(this);
    }
    get [dartx.sign]() {
      return this > 0 ? 1 : this < 0 ? -1 : this;
    }
    [dartx.toInt]() {
      if (this >= _interceptors.JSNumber._MIN_INT32 && this <= _interceptors.JSNumber._MAX_INT32) {
        return this | 0;
      }
      if (isFinite(this)) {
        return this[dartx.truncateToDouble]() + 0;
      }
      dart.throw(new core.UnsupportedError("" + this));
    }
    [dartx.truncate]() {
      return this[dartx.toInt]();
    }
    [dartx.ceil]() {
      return this[dartx.ceilToDouble]()[dartx.toInt]();
    }
    [dartx.floor]() {
      return this[dartx.floorToDouble]()[dartx.toInt]();
    }
    [dartx.round]() {
      if (this > 0) {
        if (this !== 1 / 0) {
          return Math.round(this);
        }
      } else if (this > -1 / 0) {
        return 0 - Math.round(0 - this);
      }
      dart.throw(new core.UnsupportedError("" + this));
    }
    [dartx.ceilToDouble]() {
      return Math.ceil(this);
    }
    [dartx.floorToDouble]() {
      return Math.floor(this);
    }
    [dartx.roundToDouble]() {
      if (this < 0) {
        return -Math.round(-this);
      } else {
        return Math.round(this);
      }
    }
    [dartx.truncateToDouble]() {
      return this < 0 ? this[dartx.ceilToDouble]() : this[dartx.floorToDouble]();
    }
    [dartx.clamp](lowerLimit, upperLimit) {
      if (dart.notNull(lowerLimit[dartx.compareTo](upperLimit)) > 0) {
        dart.throw(_js_helper.argumentErrorValue(lowerLimit));
      }
      if (dart.notNull(this[dartx.compareTo](lowerLimit)) < 0) return lowerLimit;
      if (dart.notNull(this[dartx.compareTo](upperLimit)) > 0) return upperLimit;
      return this;
    }
    [dartx.toDouble]() {
      return this;
    }
    [dartx.toStringAsFixed](fractionDigits) {
      _js_helper.checkInt(fractionDigits);
      if (dart.notNull(fractionDigits) < 0 || dart.notNull(fractionDigits) > 20) {
        dart.throw(new core.RangeError.range(fractionDigits, 0, 20, "fractionDigits"));
      }
      let result = this.toFixed(fractionDigits);
      if (this == 0 && dart.test(this[dartx.isNegative])) return dart.str`-${result}`;
      return result;
    }
    [dartx.toStringAsExponential](fractionDigits) {
      if (fractionDigits === void 0) fractionDigits = null;
      let result = null;
      if (fractionDigits != null) {
        _js_helper.checkInt(fractionDigits);
        if (dart.notNull(fractionDigits) < 0 || dart.notNull(fractionDigits) > 20) {
          dart.throw(new core.RangeError.range(fractionDigits, 0, 20, "fractionDigits"));
        }
        result = this.toExponential(fractionDigits);
      } else {
        result = this.toExponential();
      }
      if (this == 0 && dart.test(this[dartx.isNegative])) return dart.str`-${result}`;
      return result;
    }
    [dartx.toStringAsPrecision](precision) {
      _js_helper.checkInt(precision);
      if (dart.notNull(precision) < 1 || dart.notNull(precision) > 21) {
        dart.throw(new core.RangeError.range(precision, 1, 21, "precision"));
      }
      let result = this.toPrecision(precision);
      if (this == 0 && dart.test(this[dartx.isNegative])) return dart.str`-${result}`;
      return result;
    }
    [dartx.toRadixString](radix) {
      _js_helper.checkInt(radix);
      if (dart.notNull(radix) < 2 || dart.notNull(radix) > 36) {
        dart.throw(new core.RangeError.range(radix, 2, 36, "radix"));
      }
      let result = this.toString(radix);
      let rightParenCode = 41;
      if (result[dartx.codeUnitAt](dart.notNull(result[dartx.length]) - 1) != rightParenCode) {
        return result;
      }
      return _interceptors.JSNumber._handleIEtoString(result);
    }
    static _handleIEtoString(result) {
      let match = /^([\da-z]+)(?:\.([\da-z]+))?\(e\+(\d+)\)$/.exec(result);
      if (match == null) {
        dart.throw(new core.UnsupportedError(dart.str`Unexpected toString result: ${result}`));
      }
      result = dart.dindex(match, 1);
      let exponent = +dart.dindex(match, 3);
      if (dart.dindex(match, 2) != null) {
        result = result + dart.dindex(match, 2);
        exponent = exponent - dart.dindex(match, 2).length;
      }
      return dart.notNull(result) + "0"[dartx['*']](exponent);
    }
    [dartx.toString]() {
      if (this == 0 && 1 / this < 0) {
        return '-0.0';
      } else {
        return "" + this;
      }
    }
    get [dartx.hashCode]() {
      return this & 0x1FFFFFFF;
    }
    [dartx['unary-']]() {
      return -this;
    }
    [dartx['+']](other) {
      if (!(typeof other == 'number')) dart.throw(_js_helper.argumentErrorValue(other));
      return this + other;
    }
    [dartx['-']](other) {
      if (!(typeof other == 'number')) dart.throw(_js_helper.argumentErrorValue(other));
      return this - other;
    }
    [dartx['/']](other) {
      if (!(typeof other == 'number')) dart.throw(_js_helper.argumentErrorValue(other));
      return this / other;
    }
    [dartx['*']](other) {
      if (!(typeof other == 'number')) dart.throw(_js_helper.argumentErrorValue(other));
      return this * other;
    }
    [dartx['%']](other) {
      if (!(typeof other == 'number')) dart.throw(_js_helper.argumentErrorValue(other));
      let result = this % other;
      if (result == 0) return 0;
      if (result > 0) return result;
      if (other < 0) {
        return result - other;
      } else {
        return result + other;
      }
    }
    [_isInt32](value) {
      return (value | 0) === value;
    }
    [dartx['~/']](other) {
      if (dart.test(this[_isInt32](this)) && dart.test(this[_isInt32](other)) && 0 != other && -1 != other) {
        return this / other | 0;
      } else {
        return this[_tdivSlow](other);
      }
    }
    [_tdivSlow](other) {
      if (!(typeof other == 'number')) dart.throw(_js_helper.argumentErrorValue(other));
      return (this / other)[dartx.toInt]();
    }
    [dartx['<<']](other) {
      if (!(typeof other == 'number')) dart.throw(_js_helper.argumentErrorValue(other));
      if (other < 0) dart.throw(_js_helper.argumentErrorValue(other));
      return this[_shlPositive](other);
    }
    [_shlPositive](other) {
      return other > 31 ? 0 : this << other >>> 0;
    }
    [dartx['>>']](other) {
      if (!(typeof other == 'number')) dart.throw(_js_helper.argumentErrorValue(other));
      if (other < 0) dart.throw(_js_helper.argumentErrorValue(other));
      return this[_shrOtherPositive](other);
    }
    [_shrOtherPositive](other) {
      return this > 0 ? this[_shrBothPositive](other) : this >> (dart.notNull(other) > 31 ? 31 : other) >>> 0;
    }
    [_shrBothPositive](other) {
      return other > 31 ? 0 : this >>> other;
    }
    [dartx['&']](other) {
      if (!(typeof other == 'number')) dart.throw(_js_helper.argumentErrorValue(other));
      return (this & other) >>> 0;
    }
    [dartx['|']](other) {
      if (!(typeof other == 'number')) dart.throw(_js_helper.argumentErrorValue(other));
      return (this | other) >>> 0;
    }
    [dartx['^']](other) {
      if (!(typeof other == 'number')) dart.throw(_js_helper.argumentErrorValue(other));
      return (this ^ other) >>> 0;
    }
    [dartx['<']](other) {
      if (!(typeof other == 'number')) dart.throw(_js_helper.argumentErrorValue(other));
      return this < other;
    }
    [dartx['>']](other) {
      if (!(typeof other == 'number')) dart.throw(_js_helper.argumentErrorValue(other));
      return this > other;
    }
    [dartx['<=']](other) {
      if (!(typeof other == 'number')) dart.throw(_js_helper.argumentErrorValue(other));
      return this <= other;
    }
    [dartx['>=']](other) {
      if (!(typeof other == 'number')) dart.throw(_js_helper.argumentErrorValue(other));
      return this >= other;
    }
    get [dartx.isEven]() {
      return (this & 1) == 0;
    }
    get [dartx.isOdd]() {
      return (this & 1) == 1;
    }
    [dartx.toUnsigned](width) {
      return (this & (1)[dartx['<<']](width) - 1) >>> 0;
    }
    [dartx.toSigned](width) {
      let signMask = (1)[dartx['<<']](dart.notNull(width) - 1);
      return ((this & signMask - 1) >>> 0) - ((this & signMask) >>> 0);
    }
    get [dartx.bitLength]() {
      let nonneg = this < 0 ? -this - 1 : this;
      if (nonneg >= 4294967296) {
        nonneg = (nonneg / 4294967296)[dartx.truncate]();
        return dart.notNull(_interceptors.JSNumber._bitCount(_interceptors.JSNumber._spread(nonneg))) + 32;
      }
      return _interceptors.JSNumber._bitCount(_interceptors.JSNumber._spread(nonneg));
    }
    [dartx.modPow](e, m) {
      if (!(typeof e == 'number')) {
        dart.throw(new core.ArgumentError.value(e, "exponent", "not an integer"));
      }
      if (!(typeof m == 'number')) {
        dart.throw(new core.ArgumentError.value(m, "modulus", "not an integer"));
      }
      if (dart.notNull(e) < 0) dart.throw(new core.RangeError.range(e, 0, null, "exponent"));
      if (dart.notNull(m) <= 0) dart.throw(new core.RangeError.range(m, 1, null, "modulus"));
      if (e == 0) return 1;
      let b = this;
      if (dart.notNull(b) < 0 || dart.notNull(b) > dart.notNull(m)) {
        b = b[dartx['%']](m);
      }
      let r = 1;
      while (dart.notNull(e) > 0) {
        if (dart.test(e[dartx.isOdd])) {
          r = (r * dart.notNull(b))[dartx['%']](m);
        }
        e = (dart.notNull(e) / 2)[dartx.truncate]();
        b = (dart.notNull(b) * dart.notNull(b))[dartx['%']](m);
      }
      return r;
    }
    static _binaryGcd(x, y, inv) {
      let s = 1;
      if (!dart.test(inv)) {
        while (dart.test(x[dartx.isEven]) && dart.test(y[dartx.isEven])) {
          x = (dart.notNull(x) / 2)[dartx.truncate]();
          y = (dart.notNull(y) / 2)[dartx.truncate]();
          s = s * 2;
        }
        if (dart.test(y[dartx.isOdd])) {
          let t = x;
          x = y;
          y = t;
        }
      }
      let ac = x[dartx.isEven];
      let u = x;
      let v = y;
      let a = 1, b = 0, c = 0, d = 1;
      do {
        while (dart.test(u[dartx.isEven])) {
          u = (dart.notNull(u) / 2)[dartx.truncate]();
          if (dart.test(ac)) {
            if (!dart.test(a[dartx.isEven]) || !dart.test(b[dartx.isEven])) {
              a = dart.notNull(a) + dart.notNull(y);
              b = dart.notNull(b) - dart.notNull(x);
            }
            a = (dart.notNull(a) / 2)[dartx.truncate]();
          } else if (!dart.test(b[dartx.isEven])) {
            b = dart.notNull(b) - dart.notNull(x);
          }
          b = (dart.notNull(b) / 2)[dartx.truncate]();
        }
        while (dart.test(v[dartx.isEven])) {
          v = (dart.notNull(v) / 2)[dartx.truncate]();
          if (dart.test(ac)) {
            if (!dart.test(c[dartx.isEven]) || !dart.test(d[dartx.isEven])) {
              c = dart.notNull(c) + dart.notNull(y);
              d = dart.notNull(d) - dart.notNull(x);
            }
            c = (dart.notNull(c) / 2)[dartx.truncate]();
          } else if (!dart.test(d[dartx.isEven])) {
            d = dart.notNull(d) - dart.notNull(x);
          }
          d = (dart.notNull(d) / 2)[dartx.truncate]();
        }
        if (dart.notNull(u) >= dart.notNull(v)) {
          u = dart.notNull(u) - dart.notNull(v);
          if (dart.test(ac)) {
            a = dart.notNull(a) - dart.notNull(c);
          }
          b = dart.notNull(b) - dart.notNull(d);
        } else {
          v = dart.notNull(v) - dart.notNull(u);
          if (dart.test(ac)) {
            c = dart.notNull(c) - dart.notNull(a);
          }
          d = dart.notNull(d) - dart.notNull(b);
        }
      } while (u != 0);
      if (!dart.test(inv)) return s * dart.notNull(v);
      if (v != 1) dart.throw(core.Exception.new("Not coprime"));
      if (dart.notNull(d) < 0) {
        d = dart.notNull(d) + dart.notNull(x);
        if (dart.notNull(d) < 0) {
          d = dart.notNull(d) + dart.notNull(x);
        }
      } else if (dart.notNull(d) > dart.notNull(x)) {
        d = dart.notNull(d) - dart.notNull(x);
        if (dart.notNull(d) > dart.notNull(x)) {
          d = dart.notNull(d) - dart.notNull(x);
        }
      }
      return d;
    }
    [dartx.modInverse](m) {
      if (!(typeof m == 'number')) {
        dart.throw(new core.ArgumentError.value(m, "modulus", "not an integer"));
      }
      if (dart.notNull(m) <= 0) dart.throw(new core.RangeError.range(m, 1, null, "modulus"));
      if (m == 1) return 0;
      let t = this;
      if (dart.notNull(t) < 0 || dart.notNull(t) >= dart.notNull(m)) {
        t = t[dartx['%']](m);
      }
      if (t == 1) return 1;
      if (t == 0 || dart.test(t[dartx.isEven]) && dart.test(m[dartx.isEven])) {
        dart.throw(core.Exception.new("Not coprime"));
      }
      return _interceptors.JSNumber._binaryGcd(m, t, true);
    }
    [dartx.gcd](other) {
      if (!(typeof other == 'number')) {
        dart.throw(new core.ArgumentError.value(other, "other", "not an integer"));
      }
      let x = this[dartx.abs]();
      let y = other[dartx.abs]();
      if (x == 0) return y;
      if (y == 0) return x;
      if (x == 1 || y == 1) return 1;
      return _interceptors.JSNumber._binaryGcd(x, y, false);
    }
    static _bitCount(i) {
      i = dart.notNull(_interceptors.JSNumber._shru(i, 0)) - (dart.notNull(_interceptors.JSNumber._shru(i, 1)) & 1431655765);
      i = (dart.notNull(i) & 858993459) + (dart.notNull(_interceptors.JSNumber._shru(i, 2)) & 858993459);
      i = 252645135 & dart.notNull(i) + dart.notNull(_interceptors.JSNumber._shru(i, 4));
      i = dart.notNull(i) + dart.notNull(_interceptors.JSNumber._shru(i, 8));
      i = dart.notNull(i) + dart.notNull(_interceptors.JSNumber._shru(i, 16));
      return dart.notNull(i) & 63;
    }
    static _shru(value, shift) {
      return value >>> shift;
    }
    static _shrs(value, shift) {
      return value >> shift;
    }
    static _ors(a, b) {
      return a | b;
    }
    static _spread(i) {
      i = _interceptors.JSNumber._ors(i, _interceptors.JSNumber._shrs(i, 1));
      i = _interceptors.JSNumber._ors(i, _interceptors.JSNumber._shrs(i, 2));
      i = _interceptors.JSNumber._ors(i, _interceptors.JSNumber._shrs(i, 4));
      i = _interceptors.JSNumber._ors(i, _interceptors.JSNumber._shrs(i, 8));
      i = _interceptors.JSNumber._shru(_interceptors.JSNumber._ors(i, _interceptors.JSNumber._shrs(i, 16)), 0);
      return i;
    }
    [dartx['~']]() {
      return ~this >>> 0;
    }
  };
  _interceptors.JSNumber[dart.implements] = () => [core.int, core.double];
  dart.setSignature(_interceptors.JSNumber, {
    constructors: () => ({new: dart.definiteFunctionType(_interceptors.JSNumber, [])}),
    methods: () => ({
      [dartx.compareTo]: dart.definiteFunctionType(core.int, [core.num]),
      [dartx.remainder]: dart.definiteFunctionType(_interceptors.JSNumber, [core.num]),
      [dartx.abs]: dart.definiteFunctionType(_interceptors.JSNumber, []),
      [dartx.toInt]: dart.definiteFunctionType(core.int, []),
      [dartx.truncate]: dart.definiteFunctionType(core.int, []),
      [dartx.ceil]: dart.definiteFunctionType(core.int, []),
      [dartx.floor]: dart.definiteFunctionType(core.int, []),
      [dartx.round]: dart.definiteFunctionType(core.int, []),
      [dartx.ceilToDouble]: dart.definiteFunctionType(core.double, []),
      [dartx.floorToDouble]: dart.definiteFunctionType(core.double, []),
      [dartx.roundToDouble]: dart.definiteFunctionType(core.double, []),
      [dartx.truncateToDouble]: dart.definiteFunctionType(core.double, []),
      [dartx.clamp]: dart.definiteFunctionType(core.num, [core.num, core.num]),
      [dartx.toDouble]: dart.definiteFunctionType(core.double, []),
      [dartx.toStringAsFixed]: dart.definiteFunctionType(core.String, [core.int]),
      [dartx.toStringAsExponential]: dart.definiteFunctionType(core.String, [], [core.int]),
      [dartx.toStringAsPrecision]: dart.definiteFunctionType(core.String, [core.int]),
      [dartx.toRadixString]: dart.definiteFunctionType(core.String, [core.int]),
      [dartx['unary-']]: dart.definiteFunctionType(_interceptors.JSNumber, []),
      [dartx['+']]: dart.definiteFunctionType(_interceptors.JSNumber, [core.num]),
      [dartx['-']]: dart.definiteFunctionType(_interceptors.JSNumber, [core.num]),
      [dartx['/']]: dart.definiteFunctionType(core.double, [core.num]),
      [dartx['*']]: dart.definiteFunctionType(_interceptors.JSNumber, [core.num]),
      [dartx['%']]: dart.definiteFunctionType(_interceptors.JSNumber, [core.num]),
      [_isInt32]: dart.definiteFunctionType(core.bool, [dart.dynamic]),
      [dartx['~/']]: dart.definiteFunctionType(core.int, [core.num]),
      [_tdivSlow]: dart.definiteFunctionType(core.int, [core.num]),
      [dartx['<<']]: dart.definiteFunctionType(core.int, [core.num]),
      [_shlPositive]: dart.definiteFunctionType(core.int, [core.num]),
      [dartx['>>']]: dart.definiteFunctionType(core.int, [core.num]),
      [_shrOtherPositive]: dart.definiteFunctionType(core.int, [core.num]),
      [_shrBothPositive]: dart.definiteFunctionType(core.int, [core.num]),
      [dartx['&']]: dart.definiteFunctionType(core.int, [core.num]),
      [dartx['|']]: dart.definiteFunctionType(core.int, [core.num]),
      [dartx['^']]: dart.definiteFunctionType(core.int, [core.num]),
      [dartx['<']]: dart.definiteFunctionType(core.bool, [core.num]),
      [dartx['>']]: dart.definiteFunctionType(core.bool, [core.num]),
      [dartx['<=']]: dart.definiteFunctionType(core.bool, [core.num]),
      [dartx['>=']]: dart.definiteFunctionType(core.bool, [core.num]),
      [dartx.toUnsigned]: dart.definiteFunctionType(core.int, [core.int]),
      [dartx.toSigned]: dart.definiteFunctionType(core.int, [core.int]),
      [dartx.modPow]: dart.definiteFunctionType(core.int, [core.int, core.int]),
      [dartx.modInverse]: dart.definiteFunctionType(core.int, [core.int]),
      [dartx.gcd]: dart.definiteFunctionType(core.int, [core.int]),
      [dartx['~']]: dart.definiteFunctionType(core.int, [])
    }),
    statics: () => ({
      _handleIEtoString: dart.definiteFunctionType(core.String, [core.String]),
      _binaryGcd: dart.definiteFunctionType(core.int, [core.int, core.int, core.bool]),
      _bitCount: dart.definiteFunctionType(core.int, [core.int]),
      _shru: dart.definiteFunctionType(core.int, [core.int, core.int]),
      _shrs: dart.definiteFunctionType(core.int, [core.int, core.int]),
      _ors: dart.definiteFunctionType(core.int, [core.int, core.int]),
      _spread: dart.definiteFunctionType(core.int, [core.int])
    }),
    names: ['_handleIEtoString', '_binaryGcd', '_bitCount', '_shru', '_shrs', '_ors', '_spread']
  });
  _interceptors.JSNumber._MIN_INT32 = -2147483648;
  _interceptors.JSNumber._MAX_INT32 = 2147483647;
  dart.registerExtension(dart.global.Number, _interceptors.JSNumber);
  const _defaultSplit = Symbol('_defaultSplit');
  let const$;
  dart.defineExtensionNames([
    'codeUnitAt',
    'allMatches',
    'matchAsPrefix',
    '+',
    'endsWith',
    'replaceAll',
    'replaceAllMapped',
    'splitMapJoin',
    'replaceFirst',
    'replaceFirstMapped',
    'split',
    'replaceRange',
    'startsWith',
    'substring',
    'toLowerCase',
    'toUpperCase',
    'trim',
    'trimLeft',
    'trimRight',
    '*',
    'padLeft',
    'padRight',
    'codeUnits',
    'runes',
    'indexOf',
    'lastIndexOf',
    'contains',
    'isEmpty',
    'isNotEmpty',
    'compareTo',
    'toString',
    'hashCode',
    'runtimeType',
    'length',
    'get'
  ]);
  _interceptors.JSString = class JSString extends _interceptors.Interceptor {
    new() {
      super.new();
    }
    [dartx.codeUnitAt](index) {
      if (!(typeof index == 'number')) dart.throw(_js_helper.diagnoseIndexError(this, index));
      if (dart.notNull(index) < 0) dart.throw(_js_helper.diagnoseIndexError(this, index));
      if (dart.notNull(index) >= dart.notNull(this[dartx.length])) dart.throw(_js_helper.diagnoseIndexError(this, index));
      return this.charCodeAt(index);
    }
    [dartx.allMatches](string, start) {
      if (start === void 0) start = 0;
      _js_helper.checkString(string);
      _js_helper.checkInt(start);
      if (0 > dart.notNull(start) || dart.notNull(start) > dart.notNull(string[dartx.length])) {
        dart.throw(new core.RangeError.range(start, 0, string[dartx.length]));
      }
      return _js_helper.allMatchesInStringUnchecked(this, string, start);
    }
    [dartx.matchAsPrefix](string, start) {
      if (start === void 0) start = 0;
      if (dart.notNull(start) < 0 || dart.notNull(start) > dart.notNull(string[dartx.length])) {
        dart.throw(new core.RangeError.range(start, 0, string[dartx.length]));
      }
      if (dart.notNull(start) + dart.notNull(this[dartx.length]) > dart.notNull(string[dartx.length])) return null;
      for (let i = 0; i < dart.notNull(this[dartx.length]); i++) {
        if (string[dartx.codeUnitAt](dart.notNull(start) + i) != this[dartx.codeUnitAt](i)) {
          return null;
        }
      }
      return new _js_helper.StringMatch(start, string, this);
    }
    [dartx['+']](other) {
      if (!(typeof other == 'string')) dart.throw(new core.ArgumentError.value(other));
      return this + other;
    }
    [dartx.endsWith](other) {
      _js_helper.checkString(other);
      let otherLength = other[dartx.length];
      if (dart.notNull(otherLength) > dart.notNull(this[dartx.length])) return false;
      return other == this[dartx.substring](dart.notNull(this[dartx.length]) - dart.notNull(otherLength));
    }
    [dartx.replaceAll](from, to) {
      _js_helper.checkString(to);
      return _js_helper.stringReplaceAllUnchecked(this, from, to);
    }
    [dartx.replaceAllMapped](from, convert) {
      return this[dartx.splitMapJoin](from, {onMatch: convert});
    }
    [dartx.splitMapJoin](from, opts) {
      let onMatch = opts && 'onMatch' in opts ? opts.onMatch : null;
      let onNonMatch = opts && 'onNonMatch' in opts ? opts.onNonMatch : null;
      return _js_helper.stringReplaceAllFuncUnchecked(this, from, onMatch, onNonMatch);
    }
    [dartx.replaceFirst](from, to, startIndex) {
      if (startIndex === void 0) startIndex = 0;
      _js_helper.checkString(to);
      _js_helper.checkInt(startIndex);
      core.RangeError.checkValueInInterval(startIndex, 0, this[dartx.length], "startIndex");
      return _js_helper.stringReplaceFirstUnchecked(this, from, to, startIndex);
    }
    [dartx.replaceFirstMapped](from, replace, startIndex) {
      if (startIndex === void 0) startIndex = 0;
      _js_helper.checkNull(replace);
      _js_helper.checkInt(startIndex);
      core.RangeError.checkValueInInterval(startIndex, 0, this[dartx.length], "startIndex");
      return _js_helper.stringReplaceFirstMappedUnchecked(this, from, replace, startIndex);
    }
    [dartx.split](pattern) {
      _js_helper.checkNull(pattern);
      if (typeof pattern == 'string') {
        return this.split(pattern);
      } else if (_js_helper.JSSyntaxRegExp.is(pattern) && _js_helper.regExpCaptureCount(pattern) == 0) {
        let re = _js_helper.regExpGetNative(pattern);
        return this.split(re);
      } else {
        return this[_defaultSplit](pattern);
      }
    }
    [dartx.replaceRange](start, end, replacement) {
      _js_helper.checkString(replacement);
      _js_helper.checkInt(start);
      end = core.RangeError.checkValidRange(start, end, this[dartx.length]);
      _js_helper.checkInt(end);
      return _js_helper.stringReplaceRangeUnchecked(this, start, end, replacement);
    }
    [_defaultSplit](pattern) {
      let result = JSArrayOfString().of([]);
      let start = 0;
      let length = 1;
      for (let match of pattern[dartx.allMatches](this)) {
        let matchStart = match.start;
        let matchEnd = match.end;
        length = dart.notNull(matchEnd) - dart.notNull(matchStart);
        if (length == 0 && start == matchStart) {
          continue;
        }
        let end = matchStart;
        result[dartx.add](this[dartx.substring](start, end));
        start = matchEnd;
      }
      if (dart.notNull(start) < dart.notNull(this[dartx.length]) || length > 0) {
        result[dartx.add](this[dartx.substring](start));
      }
      return result;
    }
    [dartx.startsWith](pattern, index) {
      if (index === void 0) index = 0;
      _js_helper.checkInt(index);
      if (dart.notNull(index) < 0 || dart.notNull(index) > dart.notNull(this[dartx.length])) {
        dart.throw(new core.RangeError.range(index, 0, this[dartx.length]));
      }
      if (typeof pattern == 'string') {
        let other = pattern;
        let otherLength = other[dartx.length];
        let endIndex = dart.notNull(index) + dart.notNull(otherLength);
        if (endIndex > dart.notNull(this[dartx.length])) return false;
        return other == this.substring(index, endIndex);
      }
      return pattern[dartx.matchAsPrefix](this, index) != null;
    }
    [dartx.substring](startIndex, endIndex) {
      if (endIndex === void 0) endIndex = null;
      _js_helper.checkInt(startIndex);
      if (endIndex == null) endIndex = this[dartx.length];
      _js_helper.checkInt(endIndex);
      if (dart.notNull(startIndex) < 0) dart.throw(new core.RangeError.value(startIndex));
      if (dart.notNull(startIndex) > dart.notNull(endIndex)) dart.throw(new core.RangeError.value(startIndex));
      if (dart.notNull(endIndex) > dart.notNull(this[dartx.length])) dart.throw(new core.RangeError.value(endIndex));
      return this.substring(startIndex, endIndex);
    }
    [dartx.toLowerCase]() {
      return this.toLowerCase();
    }
    [dartx.toUpperCase]() {
      return this.toUpperCase();
    }
    static _isWhitespace(codeUnit) {
      if (dart.notNull(codeUnit) < 256) {
        switch (codeUnit) {
          case 9:
          case 10:
          case 11:
          case 12:
          case 13:
          case 32:
          case 133:
          case 160:
          {
            return true;
          }
          default:
          {
            return false;
          }
        }
      }
      switch (codeUnit) {
        case 5760:
        case 6158:
        case 8192:
        case 8193:
        case 8194:
        case 8195:
        case 8196:
        case 8197:
        case 8198:
        case 8199:
        case 8200:
        case 8201:
        case 8202:
        case 8232:
        case 8233:
        case 8239:
        case 8287:
        case 12288:
        case 65279:
        {
          return true;
        }
        default:
        {
          return false;
        }
      }
    }
    static _skipLeadingWhitespace(string, index) {
      let SPACE = 32;
      let CARRIAGE_RETURN = 13;
      while (dart.notNull(index) < dart.notNull(string[dartx.length])) {
        let codeUnit = string[dartx.codeUnitAt](index);
        if (codeUnit != SPACE && codeUnit != CARRIAGE_RETURN && !dart.test(_interceptors.JSString._isWhitespace(codeUnit))) {
          break;
        }
        index = dart.notNull(index) + 1;
      }
      return index;
    }
    static _skipTrailingWhitespace(string, index) {
      let SPACE = 32;
      let CARRIAGE_RETURN = 13;
      while (dart.notNull(index) > 0) {
        let codeUnit = string[dartx.codeUnitAt](dart.notNull(index) - 1);
        if (codeUnit != SPACE && codeUnit != CARRIAGE_RETURN && !dart.test(_interceptors.JSString._isWhitespace(codeUnit))) {
          break;
        }
        index = dart.notNull(index) - 1;
      }
      return index;
    }
    [dartx.trim]() {
      let NEL = 133;
      let result = this.trim();
      if (result[dartx.length] == 0) return result;
      let firstCode = result[dartx.codeUnitAt](0);
      let startIndex = 0;
      if (firstCode == NEL) {
        startIndex = _interceptors.JSString._skipLeadingWhitespace(result, 1);
        if (startIndex == result[dartx.length]) return "";
      }
      let endIndex = result[dartx.length];
      let lastCode = result[dartx.codeUnitAt](dart.notNull(endIndex) - 1);
      if (lastCode == NEL) {
        endIndex = _interceptors.JSString._skipTrailingWhitespace(result, dart.notNull(endIndex) - 1);
      }
      if (startIndex == 0 && endIndex == result[dartx.length]) return result;
      return result.substring(startIndex, endIndex);
    }
    [dartx.trimLeft]() {
      let NEL = 133;
      let result = null;
      let startIndex = 0;
      if (typeof this.trimLeft != "undefined") {
        result = this.trimLeft();
        if (result[dartx.length] == 0) return result;
        let firstCode = result[dartx.codeUnitAt](0);
        if (firstCode == NEL) {
          startIndex = _interceptors.JSString._skipLeadingWhitespace(result, 1);
        }
      } else {
        result = this;
        startIndex = _interceptors.JSString._skipLeadingWhitespace(this, 0);
      }
      if (startIndex == 0) return result;
      if (startIndex == result[dartx.length]) return "";
      return result.substring(startIndex);
    }
    [dartx.trimRight]() {
      let NEL = 133;
      let result = null;
      let endIndex = null;
      if (typeof this.trimRight != "undefined") {
        result = this.trimRight();
        endIndex = result[dartx.length];
        if (endIndex == 0) return result;
        let lastCode = result[dartx.codeUnitAt](dart.notNull(endIndex) - 1);
        if (lastCode == NEL) {
          endIndex = _interceptors.JSString._skipTrailingWhitespace(result, dart.notNull(endIndex) - 1);
        }
      } else {
        result = this;
        endIndex = _interceptors.JSString._skipTrailingWhitespace(this, this[dartx.length]);
      }
      if (endIndex == result[dartx.length]) return result;
      if (endIndex == 0) return "";
      return result.substring(0, endIndex);
    }
    [dartx['*']](times) {
      if (0 >= dart.notNull(times)) return '';
      if (times == 1 || this[dartx.length] == 0) return this;
      if (times != times >>> 0) {
        dart.throw(const$ || (const$ = dart.const(new core.OutOfMemoryError())));
      }
      let result = '';
      let s = this;
      while (true) {
        if ((dart.notNull(times) & 1) == 1) result = s + result;
        times = times >>> 1;
        if (times == 0) break;
        s = s + s;
      }
      return result;
    }
    [dartx.padLeft](width, padding) {
      if (padding === void 0) padding = ' ';
      let delta = dart.notNull(width) - dart.notNull(this[dartx.length]);
      if (delta <= 0) return this;
      return padding[dartx['*']](delta) + this;
    }
    [dartx.padRight](width, padding) {
      if (padding === void 0) padding = ' ';
      let delta = dart.notNull(width) - dart.notNull(this[dartx.length]);
      if (delta <= 0) return this;
      return this[dartx['+']](padding[dartx['*']](delta));
    }
    get [dartx.codeUnits]() {
      return new _internal.CodeUnits(this);
    }
    get [dartx.runes]() {
      return new core.Runes(this);
    }
    [dartx.indexOf](pattern, start) {
      if (start === void 0) start = 0;
      _js_helper.checkNull(pattern);
      if (!(typeof start == 'number')) dart.throw(_js_helper.argumentErrorValue(start));
      if (dart.notNull(start) < 0 || dart.notNull(start) > dart.notNull(this[dartx.length])) {
        dart.throw(new core.RangeError.range(start, 0, this[dartx.length]));
      }
      if (typeof pattern == 'string') {
        return _js_helper.stringIndexOfStringUnchecked(this, pattern, start);
      }
      if (_js_helper.JSSyntaxRegExp.is(pattern)) {
        let re = pattern;
        let match = _js_helper.firstMatchAfter(re, this, start);
        return match == null ? -1 : match.start;
      }
      for (let i = start; dart.notNull(i) <= dart.notNull(this[dartx.length]); i = dart.notNull(i) + 1) {
        if (pattern[dartx.matchAsPrefix](this, i) != null) return i;
      }
      return -1;
    }
    [dartx.lastIndexOf](pattern, start) {
      if (start === void 0) start = null;
      _js_helper.checkNull(pattern);
      if (start == null) {
        start = this[dartx.length];
      } else if (!(typeof start == 'number')) {
        dart.throw(_js_helper.argumentErrorValue(start));
      } else if (dart.notNull(start) < 0 || dart.notNull(start) > dart.notNull(this[dartx.length])) {
        dart.throw(new core.RangeError.range(start, 0, this[dartx.length]));
      }
      if (typeof pattern == 'string') {
        let other = pattern;
        if (dart.notNull(start) + dart.notNull(other[dartx.length]) > dart.notNull(this[dartx.length])) {
          start = dart.notNull(this[dartx.length]) - dart.notNull(other[dartx.length]);
        }
        return core.int._check(_js_helper.stringLastIndexOfUnchecked(this, other, start));
      }
      for (let i = start; dart.notNull(i) >= 0; i = dart.notNull(i) - 1) {
        if (pattern[dartx.matchAsPrefix](this, i) != null) return i;
      }
      return -1;
    }
    [dartx.contains](other, startIndex) {
      if (startIndex === void 0) startIndex = 0;
      _js_helper.checkNull(other);
      if (dart.notNull(startIndex) < 0 || dart.notNull(startIndex) > dart.notNull(this[dartx.length])) {
        dart.throw(new core.RangeError.range(startIndex, 0, this[dartx.length]));
      }
      return _js_helper.stringContainsUnchecked(this, other, startIndex);
    }
    get [dartx.isEmpty]() {
      return this[dartx.length] == 0;
    }
    get [dartx.isNotEmpty]() {
      return !dart.test(this[dartx.isEmpty]);
    }
    [dartx.compareTo](other) {
      if (!(typeof other == 'string')) dart.throw(_js_helper.argumentErrorValue(other));
      return dart.equals(this, other) ? 0 : this < other ? -1 : 1;
    }
    [dartx.toString]() {
      return this;
    }
    get [dartx.hashCode]() {
      let hash = 0;
      for (let i = 0; i < dart.notNull(this[dartx.length]); i++) {
        hash = 536870911 & hash + this.charCodeAt(i);
        hash = 536870911 & hash + ((524287 & hash) << 10);
        hash = hash ^ hash >> 6;
      }
      hash = 536870911 & hash + ((67108863 & hash) << 3);
      hash = hash ^ hash >> 11;
      return 536870911 & hash + ((16383 & hash) << 15);
    }
    get [dartx.runtimeType]() {
      return dart.wrapType(core.String);
    }
    get [dartx.length]() {
      return this.length;
    }
    [dartx.get](index) {
      if (!(typeof index == 'number')) dart.throw(_js_helper.diagnoseIndexError(this, index));
      if (dart.notNull(index) >= dart.notNull(this[dartx.length]) || dart.notNull(index) < 0) dart.throw(_js_helper.diagnoseIndexError(this, index));
      return this[index];
    }
  };
  _interceptors.JSString[dart.implements] = () => [core.String, _interceptors.JSIndexable];
  dart.setSignature(_interceptors.JSString, {
    constructors: () => ({new: dart.definiteFunctionType(_interceptors.JSString, [])}),
    methods: () => ({
      [dartx.codeUnitAt]: dart.definiteFunctionType(core.int, [core.int]),
      [dartx.allMatches]: dart.definiteFunctionType(core.Iterable$(core.Match), [core.String], [core.int]),
      [dartx.matchAsPrefix]: dart.definiteFunctionType(core.Match, [core.String], [core.int]),
      [dartx['+']]: dart.definiteFunctionType(core.String, [core.String]),
      [dartx.endsWith]: dart.definiteFunctionType(core.bool, [core.String]),
      [dartx.replaceAll]: dart.definiteFunctionType(core.String, [core.Pattern, core.String]),
      [dartx.replaceAllMapped]: dart.definiteFunctionType(core.String, [core.Pattern, dart.functionType(core.String, [core.Match])]),
      [dartx.splitMapJoin]: dart.definiteFunctionType(core.String, [core.Pattern], {onMatch: MatchToString(), onNonMatch: StringToString()}),
      [dartx.replaceFirst]: dart.definiteFunctionType(core.String, [core.Pattern, core.String], [core.int]),
      [dartx.replaceFirstMapped]: dart.definiteFunctionType(core.String, [core.Pattern, dart.functionType(core.String, [core.Match])], [core.int]),
      [dartx.split]: dart.definiteFunctionType(core.List$(core.String), [core.Pattern]),
      [dartx.replaceRange]: dart.definiteFunctionType(core.String, [core.int, core.int, core.String]),
      [_defaultSplit]: dart.definiteFunctionType(core.List$(core.String), [core.Pattern]),
      [dartx.startsWith]: dart.definiteFunctionType(core.bool, [core.Pattern], [core.int]),
      [dartx.substring]: dart.definiteFunctionType(core.String, [core.int], [core.int]),
      [dartx.toLowerCase]: dart.definiteFunctionType(core.String, []),
      [dartx.toUpperCase]: dart.definiteFunctionType(core.String, []),
      [dartx.trim]: dart.definiteFunctionType(core.String, []),
      [dartx.trimLeft]: dart.definiteFunctionType(core.String, []),
      [dartx.trimRight]: dart.definiteFunctionType(core.String, []),
      [dartx['*']]: dart.definiteFunctionType(core.String, [core.int]),
      [dartx.padLeft]: dart.definiteFunctionType(core.String, [core.int], [core.String]),
      [dartx.padRight]: dart.definiteFunctionType(core.String, [core.int], [core.String]),
      [dartx.indexOf]: dart.definiteFunctionType(core.int, [core.Pattern], [core.int]),
      [dartx.lastIndexOf]: dart.definiteFunctionType(core.int, [core.Pattern], [core.int]),
      [dartx.contains]: dart.definiteFunctionType(core.bool, [core.Pattern], [core.int]),
      [dartx.compareTo]: dart.definiteFunctionType(core.int, [core.String]),
      [dartx.get]: dart.definiteFunctionType(core.String, [core.int])
    }),
    statics: () => ({
      _isWhitespace: dart.definiteFunctionType(core.bool, [core.int]),
      _skipLeadingWhitespace: dart.definiteFunctionType(core.int, [core.String, core.int]),
      _skipTrailingWhitespace: dart.definiteFunctionType(core.int, [core.String, core.int])
    }),
    names: ['_isWhitespace', '_skipLeadingWhitespace', '_skipTrailingWhitespace']
  });
  dart.registerExtension(dart.global.String, _interceptors.JSString);
  core.num = class num extends core.Object {
    static parse(input, onError) {
      if (onError === void 0) onError = null;
      let source = input[dartx.trim]();
      let result = core.int.parse(source, {onError: core.num._returnIntNull});
      if (result != null) return result;
      result = core.double.parse(source, core.num._returnDoubleNull);
      if (result != null) return result;
      if (onError == null) dart.throw(new core.FormatException(input));
      return onError(input);
    }
    static _returnIntNull(_) {
      return null;
    }
    static _returnDoubleNull(_) {
      return null;
    }
  };
  core.num.is = function is_num(o) {
    return typeof o == "number";
  };
  core.num.as = function as_num(o) {
    if (typeof o == "number" || o == null) return o;
    return dart.as(o, core.num);
  };
  core.num._check = function check_num(o) {
    if (typeof o == "number" || o == null) return o;
    return dart.check(o, core.num);
  };
  core.num[dart.implements] = () => [ComparableOfnum()];
  dart.setSignature(core.num, {
    statics: () => ({
      parse: dart.definiteFunctionType(core.num, [core.String], [dart.functionType(core.num, [core.String])]),
      _returnIntNull: dart.definiteFunctionType(core.int, [core.String]),
      _returnDoubleNull: dart.definiteFunctionType(core.double, [core.String])
    }),
    names: ['parse', '_returnIntNull', '_returnDoubleNull']
  });
  core.double = class double extends core.num {
    static parse(source, onError) {
      if (onError === void 0) onError = null;
      return _js_helper.Primitives.parseDouble(source, onError);
    }
  };
  dart.setSignature(core.double, {
    statics: () => ({parse: dart.definiteFunctionType(core.double, [core.String], [dart.functionType(core.double, [core.String])])}),
    names: ['parse']
  });
  core.double.NAN = 0.0 / 0.0;
  core.double.INFINITY = 1.0 / 0.0;
  core.double.MIN_POSITIVE = 5e-324;
  core.double.MAX_FINITE = 1.7976931348623157e+308;
  dart.defineLazy(core.double, {
    get NEGATIVE_INFINITY() {
      return -core.double.INFINITY;
    }
  });
  _internal.POWERS_OF_TEN = dart.constList([1.0, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, 10000000.0, 100000000.0, 1000000000.0, 10000000000.0, 100000000000.0, 1000000000000.0, 10000000000000.0, 100000000000000.0, 1000000000000000.0, 10000000000000000.0, 100000000000000000.0, 1000000000000000000.0, 10000000000000000000.0, 100000000000000000000.0, 1e+21, 1e+22], core.double);
  const _string = Symbol('_string');
  collection.ListMixin$ = dart.generic(E => {
    let ListIteratorOfE = () => (ListIteratorOfE = dart.constFn(_internal.ListIterator$(E)))();
    let VoidToE = () => (VoidToE = dart.constFn(dart.functionType(E, [])))();
    let WhereIterableOfE = () => (WhereIterableOfE = dart.constFn(_internal.WhereIterable$(E)))();
    let EAndEToE = () => (EAndEToE = dart.constFn(dart.functionType(E, [E, E])))();
    let SubListIterableOfE = () => (SubListIterableOfE = dart.constFn(_internal.SubListIterable$(E)))();
    let SkipWhileIterableOfE = () => (SkipWhileIterableOfE = dart.constFn(_internal.SkipWhileIterable$(E)))();
    let TakeWhileIterableOfE = () => (TakeWhileIterableOfE = dart.constFn(_internal.TakeWhileIterable$(E)))();
    let ListOfE = () => (ListOfE = dart.constFn(core.List$(E)))();
    let SetOfE = () => (SetOfE = dart.constFn(core.Set$(E)))();
    let IterableOfE = () => (IterableOfE = dart.constFn(core.Iterable$(E)))();
    let ListMapViewOfE = () => (ListMapViewOfE = dart.constFn(_internal.ListMapView$(E)))();
    let ReversedListIterableOfE = () => (ReversedListIterableOfE = dart.constFn(_internal.ReversedListIterable$(E)))();
    dart.defineExtensionNames([
      'iterator',
      'elementAt',
      'forEach',
      'isEmpty',
      'isNotEmpty',
      'first',
      'last',
      'single',
      'contains',
      'every',
      'any',
      'firstWhere',
      'lastWhere',
      'singleWhere',
      'join',
      'where',
      'map',
      'expand',
      'reduce',
      'fold',
      'skip',
      'skipWhile',
      'take',
      'takeWhile',
      'toList',
      'toSet',
      'add',
      'addAll',
      'remove',
      'removeWhere',
      'retainWhere',
      'clear',
      'removeLast',
      'sort',
      'shuffle',
      'asMap',
      'sublist',
      'getRange',
      'removeRange',
      'fillRange',
      'setRange',
      'replaceRange',
      'indexOf',
      'lastIndexOf',
      'insert',
      'removeAt',
      'insertAll',
      'setAll',
      'reversed',
      'toString'
    ]);
    class ListMixin extends core.Object {
      get iterator() {
        return new (ListIteratorOfE())(this);
      }
      [Symbol.iterator]() {
        return new dart.JsIterator(this[dartx.iterator]);
      }
      elementAt(index) {
        return this[dartx.get](index);
      }
      forEach(action) {
        let length = this[dartx.length];
        for (let i = 0; i < dart.notNull(length); i++) {
          action(this[dartx.get](i));
          if (length != this[dartx.length]) {
            dart.throw(new core.ConcurrentModificationError(this));
          }
        }
      }
      get isEmpty() {
        return this[dartx.length] == 0;
      }
      get isNotEmpty() {
        return !dart.test(this[dartx.isEmpty]);
      }
      get first() {
        if (this[dartx.length] == 0) dart.throw(_internal.IterableElementError.noElement());
        return this[dartx.get](0);
      }
      get last() {
        if (this[dartx.length] == 0) dart.throw(_internal.IterableElementError.noElement());
        return this[dartx.get](dart.notNull(this[dartx.length]) - 1);
      }
      get single() {
        if (this[dartx.length] == 0) dart.throw(_internal.IterableElementError.noElement());
        if (dart.notNull(this[dartx.length]) > 1) dart.throw(_internal.IterableElementError.tooMany());
        return this[dartx.get](0);
      }
      contains(element) {
        let length = this[dartx.length];
        for (let i = 0; i < dart.notNull(this[dartx.length]); i++) {
          if (dart.equals(this[dartx.get](i), element)) return true;
          if (length != this[dartx.length]) {
            dart.throw(new core.ConcurrentModificationError(this));
          }
        }
        return false;
      }
      every(test) {
        let length = this[dartx.length];
        for (let i = 0; i < dart.notNull(length); i++) {
          if (!dart.test(test(this[dartx.get](i)))) return false;
          if (length != this[dartx.length]) {
            dart.throw(new core.ConcurrentModificationError(this));
          }
        }
        return true;
      }
      any(test) {
        let length = this[dartx.length];
        for (let i = 0; i < dart.notNull(length); i++) {
          if (dart.test(test(this[dartx.get](i)))) return true;
          if (length != this[dartx.length]) {
            dart.throw(new core.ConcurrentModificationError(this));
          }
        }
        return false;
      }
      firstWhere(test, opts) {
        let orElse = opts && 'orElse' in opts ? opts.orElse : null;
        VoidToE()._check(orElse);
        let length = this[dartx.length];
        for (let i = 0; i < dart.notNull(length); i++) {
          let element = this[dartx.get](i);
          if (dart.test(test(element))) return element;
          if (length != this[dartx.length]) {
            dart.throw(new core.ConcurrentModificationError(this));
          }
        }
        if (orElse != null) return orElse();
        dart.throw(_internal.IterableElementError.noElement());
      }
      lastWhere(test, opts) {
        let orElse = opts && 'orElse' in opts ? opts.orElse : null;
        VoidToE()._check(orElse);
        let length = this[dartx.length];
        for (let i = dart.notNull(length) - 1; i >= 0; i--) {
          let element = this[dartx.get](i);
          if (dart.test(test(element))) return element;
          if (length != this[dartx.length]) {
            dart.throw(new core.ConcurrentModificationError(this));
          }
        }
        if (orElse != null) return orElse();
        dart.throw(_internal.IterableElementError.noElement());
      }
      singleWhere(test) {
        let length = this[dartx.length];
        let match = null;
        let matchFound = false;
        for (let i = 0; i < dart.notNull(length); i++) {
          let element = this[dartx.get](i);
          if (dart.test(test(element))) {
            if (matchFound) {
              dart.throw(_internal.IterableElementError.tooMany());
            }
            matchFound = true;
            match = element;
          }
          if (length != this[dartx.length]) {
            dart.throw(new core.ConcurrentModificationError(this));
          }
        }
        if (matchFound) return match;
        dart.throw(_internal.IterableElementError.noElement());
      }
      join(separator) {
        if (separator === void 0) separator = "";
        if (this[dartx.length] == 0) return "";
        let buffer = new core.StringBuffer();
        buffer.writeAll(this, separator);
        return buffer.toString();
      }
      where(test) {
        return new (WhereIterableOfE())(this, test);
      }
      map(T) {
        return f => {
          return new (_internal.MappedListIterable$(E, T))(this, f);
        };
      }
      expand(T) {
        return f => {
          return new (_internal.ExpandIterable$(E, T))(this, f);
        };
      }
      reduce(combine) {
        EAndEToE()._check(combine);
        let length = this[dartx.length];
        if (length == 0) dart.throw(_internal.IterableElementError.noElement());
        let value = this[dartx.get](0);
        for (let i = 1; i < dart.notNull(length); i++) {
          value = combine(value, this[dartx.get](i));
          if (length != this[dartx.length]) {
            dart.throw(new core.ConcurrentModificationError(this));
          }
        }
        return value;
      }
      fold(T) {
        return (initialValue, combine) => {
          let value = initialValue;
          let length = this[dartx.length];
          for (let i = 0; i < dart.notNull(length); i++) {
            value = combine(value, this[dartx.get](i));
            if (length != this[dartx.length]) {
              dart.throw(new core.ConcurrentModificationError(this));
            }
          }
          return value;
        };
      }
      skip(count) {
        return new (SubListIterableOfE())(this, count, null);
      }
      skipWhile(test) {
        return new (SkipWhileIterableOfE())(this, test);
      }
      take(count) {
        return new (SubListIterableOfE())(this, 0, count);
      }
      takeWhile(test) {
        return new (TakeWhileIterableOfE())(this, test);
      }
      toList(opts) {
        let growable = opts && 'growable' in opts ? opts.growable : true;
        let result = null;
        if (dart.test(growable)) {
          result = ListOfE().new();
          result[dartx.length] = this[dartx.length];
        } else {
          result = ListOfE().new(this[dartx.length]);
        }
        for (let i = 0; i < dart.notNull(this[dartx.length]); i++) {
          result[dartx.set](i, this[dartx.get](i));
        }
        return result;
      }
      toSet() {
        let result = SetOfE().new();
        for (let i = 0; i < dart.notNull(this[dartx.length]); i++) {
          result.add(this[dartx.get](i));
        }
        return result;
      }
      add(element) {
        E._check(element);
        this[dartx.set]((() => {
          let x = this[dartx.length];
          this[dartx.length] = dart.notNull(x) + 1;
          return x;
        })(), element);
      }
      addAll(iterable) {
        IterableOfE()._check(iterable);
        let i = this[dartx.length];
        for (let element of iterable) {
          dart.assert(this[dartx.length] == i || dart.test(dart.throw(new core.ConcurrentModificationError(this))));
          this[dartx.length] = dart.notNull(i) + 1;
          this[dartx.set](i, element);
          i = dart.notNull(i) + 1;
        }
      }
      remove(element) {
        for (let i = 0; i < dart.notNull(this[dartx.length]); i++) {
          if (dart.equals(this[dartx.get](i), element)) {
            this[dartx.setRange](i, dart.notNull(this[dartx.length]) - 1, this, i + 1);
            this[dartx.length] = dart.notNull(this[dartx.length]) - 1;
            return true;
          }
        }
        return false;
      }
      removeWhere(test) {
        collection.ListMixin._filter(this, test, false);
      }
      retainWhere(test) {
        collection.ListMixin._filter(this, test, true);
      }
      static _filter(source, test, retainMatching) {
        let retained = [];
        let length = source[dartx.length];
        for (let i = 0; i < dart.notNull(length); i++) {
          let element = source[dartx.get](i);
          if (dart.dcall(test, element) == retainMatching) {
            retained[dartx.add](element);
          }
          if (length != source[dartx.length]) {
            dart.throw(new core.ConcurrentModificationError(source));
          }
        }
        if (retained[dartx.length] != source[dartx.length]) {
          source[dartx.setRange](0, retained[dartx.length], retained);
          source[dartx.length] = retained[dartx.length];
        }
      }
      clear() {
        this[dartx.length] = 0;
      }
      removeLast() {
        if (this[dartx.length] == 0) {
          dart.throw(_internal.IterableElementError.noElement());
        }
        let result = this[dartx.get](dart.notNull(this[dartx.length]) - 1);
        this[dartx.length] = dart.notNull(this[dartx.length]) - 1;
        return result;
      }
      sort(compare) {
        if (compare === void 0) compare = null;
        if (compare == null) {
          _internal.Sort.sort(dart.dynamic)(this, core.Comparable.compare);
        } else {
          _internal.Sort.sort(E)(this, compare);
        }
      }
      shuffle(random) {
        if (random === void 0) random = null;
        if (random == null) random = math.Random.new();
        let length = this[dartx.length];
        while (dart.notNull(length) > 1) {
          let pos = random.nextInt(length);
          length = dart.notNull(length) - 1;
          let tmp = this[dartx.get](length);
          this[dartx.set](length, this[dartx.get](pos));
          this[dartx.set](pos, tmp);
        }
      }
      asMap() {
        return new (ListMapViewOfE())(this);
      }
      sublist(start, end) {
        if (end === void 0) end = null;
        let listLength = this[dartx.length];
        if (end == null) end = listLength;
        core.RangeError.checkValidRange(start, end, listLength);
        let length = dart.notNull(end) - dart.notNull(start);
        let result = ListOfE().new();
        result[dartx.length] = length;
        for (let i = 0; i < length; i++) {
          result[dartx.set](i, this[dartx.get](dart.notNull(start) + i));
        }
        return result;
      }
      getRange(start, end) {
        core.RangeError.checkValidRange(start, end, this[dartx.length]);
        return new (SubListIterableOfE())(this, start, end);
      }
      removeRange(start, end) {
        core.RangeError.checkValidRange(start, end, this[dartx.length]);
        let length = dart.notNull(end) - dart.notNull(start);
        this[dartx.setRange](start, dart.notNull(this[dartx.length]) - length, this, end);
        this[dartx.length] = dart.notNull(this[dartx.length]) - length;
      }
      fillRange(start, end, fill) {
        if (fill === void 0) fill = null;
        E._check(fill);
        core.RangeError.checkValidRange(start, end, this[dartx.length]);
        for (let i = start; dart.notNull(i) < dart.notNull(end); i = dart.notNull(i) + 1) {
          this[dartx.set](i, fill);
        }
      }
      setRange(start, end, iterable, skipCount) {
        IterableOfE()._check(iterable);
        if (skipCount === void 0) skipCount = 0;
        core.RangeError.checkValidRange(start, end, this[dartx.length]);
        let length = dart.notNull(end) - dart.notNull(start);
        if (length == 0) return;
        core.RangeError.checkNotNegative(skipCount, "skipCount");
        let otherList = null;
        let otherStart = null;
        if (ListOfE().is(iterable)) {
          otherList = iterable;
          otherStart = skipCount;
        } else {
          otherList = iterable[dartx.skip](skipCount)[dartx.toList]({growable: false});
          otherStart = 0;
        }
        if (dart.notNull(otherStart) + length > dart.notNull(otherList[dartx.length])) {
          dart.throw(_internal.IterableElementError.tooFew());
        }
        if (dart.notNull(otherStart) < dart.notNull(start)) {
          for (let i = length - 1; i >= 0; i--) {
            this[dartx.set](dart.notNull(start) + i, otherList[dartx.get](dart.notNull(otherStart) + i));
          }
        } else {
          for (let i = 0; i < length; i++) {
            this[dartx.set](dart.notNull(start) + i, otherList[dartx.get](dart.notNull(otherStart) + i));
          }
        }
      }
      replaceRange(start, end, newContents) {
        IterableOfE()._check(newContents);
        core.RangeError.checkValidRange(start, end, this[dartx.length]);
        if (!_internal.EfficientLength.is(newContents)) {
          newContents = newContents[dartx.toList]();
        }
        let removeLength = dart.notNull(end) - dart.notNull(start);
        let insertLength = newContents[dartx.length];
        if (removeLength >= dart.notNull(insertLength)) {
          let delta = removeLength - dart.notNull(insertLength);
          let insertEnd = dart.notNull(start) + dart.notNull(insertLength);
          let newLength = dart.notNull(this[dartx.length]) - delta;
          this[dartx.setRange](start, insertEnd, newContents);
          if (delta != 0) {
            this[dartx.setRange](insertEnd, newLength, this, end);
            this[dartx.length] = newLength;
          }
        } else {
          let delta = dart.notNull(insertLength) - removeLength;
          let newLength = dart.notNull(this[dartx.length]) + delta;
          let insertEnd = dart.notNull(start) + dart.notNull(insertLength);
          this[dartx.length] = newLength;
          this[dartx.setRange](insertEnd, newLength, this, end);
          this[dartx.setRange](start, insertEnd, newContents);
        }
      }
      indexOf(element, startIndex) {
        if (startIndex === void 0) startIndex = 0;
        if (dart.notNull(startIndex) >= dart.notNull(this[dartx.length])) {
          return -1;
        }
        if (dart.notNull(startIndex) < 0) {
          startIndex = 0;
        }
        for (let i = startIndex; dart.notNull(i) < dart.notNull(this[dartx.length]); i = dart.notNull(i) + 1) {
          if (dart.equals(this[dartx.get](i), element)) {
            return i;
          }
        }
        return -1;
      }
      lastIndexOf(element, startIndex) {
        if (startIndex === void 0) startIndex = null;
        if (startIndex == null) {
          startIndex = dart.notNull(this[dartx.length]) - 1;
        } else {
          if (dart.notNull(startIndex) < 0) {
            return -1;
          }
          if (dart.notNull(startIndex) >= dart.notNull(this[dartx.length])) {
            startIndex = dart.notNull(this[dartx.length]) - 1;
          }
        }
        for (let i = startIndex; dart.notNull(i) >= 0; i = dart.notNull(i) - 1) {
          if (dart.equals(this[dartx.get](i), element)) {
            return i;
          }
        }
        return -1;
      }
      insert(index, element) {
        E._check(element);
        core.RangeError.checkValueInInterval(index, 0, this[dartx.length], "index");
        if (index == this[dartx.length]) {
          this[dartx.add](element);
          return;
        }
        if (!(typeof index == 'number')) dart.throw(new core.ArgumentError(index));
        this[dartx.length] = dart.notNull(this[dartx.length]) + 1;
        this[dartx.setRange](dart.notNull(index) + 1, this[dartx.length], this, index);
        this[dartx.set](index, element);
      }
      removeAt(index) {
        let result = this[dartx.get](index);
        this[dartx.setRange](index, dart.notNull(this[dartx.length]) - 1, this, dart.notNull(index) + 1);
        this[dartx.length] = dart.notNull(this[dartx.length]) - 1;
        return result;
      }
      insertAll(index, iterable) {
        IterableOfE()._check(iterable);
        core.RangeError.checkValueInInterval(index, 0, this[dartx.length], "index");
        if (!_internal.EfficientLength.is(iterable) || core.identical(iterable, this)) {
          iterable = iterable[dartx.toList]();
        }
        let insertionLength = iterable[dartx.length];
        this[dartx.length] = dart.notNull(this[dartx.length]) + dart.notNull(insertionLength);
        if (iterable[dartx.length] != insertionLength) {
          this[dartx.length] = dart.notNull(this[dartx.length]) - dart.notNull(insertionLength);
          dart.throw(new core.ConcurrentModificationError(iterable));
        }
        this[dartx.setRange](dart.notNull(index) + dart.notNull(insertionLength), this[dartx.length], this, index);
        this[dartx.setAll](index, iterable);
      }
      setAll(index, iterable) {
        IterableOfE()._check(iterable);
        if (core.List.is(iterable)) {
          this[dartx.setRange](index, dart.notNull(index) + dart.notNull(iterable[dartx.length]), iterable);
        } else {
          for (let element of iterable) {
            this[dartx.set]((() => {
              let x = index;
              index = dart.notNull(x) + 1;
              return x;
            })(), element);
          }
        }
      }
      get reversed() {
        return new (ReversedListIterableOfE())(this);
      }
      toString() {
        return collection.IterableBase.iterableToFullString(this, '[', ']');
      }
    }
    dart.addTypeTests(ListMixin);
    ListMixin[dart.implements] = () => [ListOfE()];
    dart.setSignature(ListMixin, {
      methods: () => ({
        elementAt: dart.definiteFunctionType(E, [core.int]),
        forEach: dart.definiteFunctionType(dart.void, [dart.functionType(dart.void, [E])]),
        contains: dart.definiteFunctionType(core.bool, [core.Object]),
        every: dart.definiteFunctionType(core.bool, [dart.functionType(core.bool, [E])]),
        any: dart.definiteFunctionType(core.bool, [dart.functionType(core.bool, [E])]),
        firstWhere: dart.definiteFunctionType(E, [dart.functionType(core.bool, [E])], {orElse: VoidToE()}),
        lastWhere: dart.definiteFunctionType(E, [dart.functionType(core.bool, [E])], {orElse: VoidToE()}),
        singleWhere: dart.definiteFunctionType(E, [dart.functionType(core.bool, [E])]),
        join: dart.definiteFunctionType(core.String, [], [core.String]),
        where: dart.definiteFunctionType(core.Iterable$(E), [dart.functionType(core.bool, [E])]),
        map: dart.definiteFunctionType(T => [core.Iterable$(T), [dart.functionType(T, [E])]]),
        expand: dart.definiteFunctionType(T => [core.Iterable$(T), [dart.functionType(core.Iterable$(T), [E])]]),
        reduce: dart.definiteFunctionType(E, [dart.functionType(E, [E, E])]),
        fold: dart.definiteFunctionType(T => [T, [T, dart.functionType(T, [T, E])]]),
        skip: dart.definiteFunctionType(core.Iterable$(E), [core.int]),
        skipWhile: dart.definiteFunctionType(core.Iterable$(E), [dart.functionType(core.bool, [E])]),
        take: dart.definiteFunctionType(core.Iterable$(E), [core.int]),
        takeWhile: dart.definiteFunctionType(core.Iterable$(E), [dart.functionType(core.bool, [E])]),
        toList: dart.definiteFunctionType(core.List$(E), [], {growable: core.bool}),
        toSet: dart.definiteFunctionType(core.Set$(E), []),
        add: dart.definiteFunctionType(dart.void, [E]),
        addAll: dart.definiteFunctionType(dart.void, [core.Iterable$(E)]),
        remove: dart.definiteFunctionType(core.bool, [core.Object]),
        removeWhere: dart.definiteFunctionType(dart.void, [dart.functionType(core.bool, [E])]),
        retainWhere: dart.definiteFunctionType(dart.void, [dart.functionType(core.bool, [E])]),
        clear: dart.definiteFunctionType(dart.void, []),
        removeLast: dart.definiteFunctionType(E, []),
        sort: dart.definiteFunctionType(dart.void, [], [dart.functionType(core.int, [E, E])]),
        shuffle: dart.definiteFunctionType(dart.void, [], [math.Random]),
        asMap: dart.definiteFunctionType(core.Map$(core.int, E), []),
        sublist: dart.definiteFunctionType(core.List$(E), [core.int], [core.int]),
        getRange: dart.definiteFunctionType(core.Iterable$(E), [core.int, core.int]),
        removeRange: dart.definiteFunctionType(dart.void, [core.int, core.int]),
        fillRange: dart.definiteFunctionType(dart.void, [core.int, core.int], [E]),
        setRange: dart.definiteFunctionType(dart.void, [core.int, core.int, core.Iterable$(E)], [core.int]),
        replaceRange: dart.definiteFunctionType(dart.void, [core.int, core.int, core.Iterable$(E)]),
        indexOf: dart.definiteFunctionType(core.int, [core.Object], [core.int]),
        lastIndexOf: dart.definiteFunctionType(core.int, [core.Object], [core.int]),
        insert: dart.definiteFunctionType(dart.void, [core.int, E]),
        removeAt: dart.definiteFunctionType(E, [core.int]),
        insertAll: dart.definiteFunctionType(dart.void, [core.int, core.Iterable$(E)]),
        setAll: dart.definiteFunctionType(dart.void, [core.int, core.Iterable$(E)])
      }),
      statics: () => ({_filter: dart.definiteFunctionType(dart.void, [core.List, dart.functionType(core.bool, [dart.dynamic]), core.bool])}),
      names: ['_filter']
    });
    dart.defineExtensionMembers(ListMixin, [
      'elementAt',
      'forEach',
      'contains',
      'every',
      'any',
      'firstWhere',
      'lastWhere',
      'singleWhere',
      'join',
      'where',
      'map',
      'expand',
      'reduce',
      'fold',
      'skip',
      'skipWhile',
      'take',
      'takeWhile',
      'toList',
      'toSet',
      'add',
      'addAll',
      'remove',
      'removeWhere',
      'retainWhere',
      'clear',
      'removeLast',
      'sort',
      'shuffle',
      'asMap',
      'sublist',
      'getRange',
      'removeRange',
      'fillRange',
      'setRange',
      'replaceRange',
      'indexOf',
      'lastIndexOf',
      'insert',
      'removeAt',
      'insertAll',
      'setAll',
      'toString',
      'iterator',
      'isEmpty',
      'isNotEmpty',
      'first',
      'last',
      'single',
      'reversed'
    ]);
    return ListMixin;
  });
  collection.ListMixin = ListMixin();
  collection.ListBase$ = dart.generic(E => {
    class ListBase extends dart.mixin(core.Object, collection.ListMixin$(E)) {
      static listToString(list) {
        return collection.IterableBase.iterableToFullString(list, '[', ']');
      }
    }
    dart.addTypeTests(ListBase);
    dart.setSignature(ListBase, {
      statics: () => ({listToString: dart.definiteFunctionType(core.String, [core.List])}),
      names: ['listToString']
    });
    return ListBase;
  });
  collection.ListBase = ListBase();
  _internal.UnmodifiableListMixin$ = dart.generic(E => {
    let IterableOfE = () => (IterableOfE = dart.constFn(core.Iterable$(E)))();
    let ListOfE = () => (ListOfE = dart.constFn(core.List$(E)))();
    class UnmodifiableListMixin extends core.Object {
      set(index, value) {
        E._check(value);
        dart.throw(new core.UnsupportedError("Cannot modify an unmodifiable list"));
        return value;
      }
      set length(newLength) {
        dart.throw(new core.UnsupportedError("Cannot change the length of an unmodifiable list"));
      }
      setAll(at, iterable) {
        IterableOfE()._check(iterable);
        dart.throw(new core.UnsupportedError("Cannot modify an unmodifiable list"));
      }
      add(value) {
        E._check(value);
        dart.throw(new core.UnsupportedError("Cannot add to an unmodifiable list"));
      }
      insert(index, element) {
        E._check(element);
        dart.throw(new core.UnsupportedError("Cannot add to an unmodifiable list"));
      }
      insertAll(at, iterable) {
        IterableOfE()._check(iterable);
        dart.throw(new core.UnsupportedError("Cannot add to an unmodifiable list"));
      }
      addAll(iterable) {
        IterableOfE()._check(iterable);
        dart.throw(new core.UnsupportedError("Cannot add to an unmodifiable list"));
      }
      remove(element) {
        dart.throw(new core.UnsupportedError("Cannot remove from an unmodifiable list"));
      }
      removeWhere(test) {
        dart.throw(new core.UnsupportedError("Cannot remove from an unmodifiable list"));
      }
      retainWhere(test) {
        dart.throw(new core.UnsupportedError("Cannot remove from an unmodifiable list"));
      }
      sort(compare) {
        if (compare === void 0) compare = null;
        dart.throw(new core.UnsupportedError("Cannot modify an unmodifiable list"));
      }
      shuffle(random) {
        if (random === void 0) random = null;
        dart.throw(new core.UnsupportedError("Cannot modify an unmodifiable list"));
      }
      clear() {
        dart.throw(new core.UnsupportedError("Cannot clear an unmodifiable list"));
      }
      removeAt(index) {
        dart.throw(new core.UnsupportedError("Cannot remove from an unmodifiable list"));
      }
      removeLast() {
        dart.throw(new core.UnsupportedError("Cannot remove from an unmodifiable list"));
      }
      setRange(start, end, iterable, skipCount) {
        IterableOfE()._check(iterable);
        if (skipCount === void 0) skipCount = 0;
        dart.throw(new core.UnsupportedError("Cannot modify an unmodifiable list"));
      }
      removeRange(start, end) {
        dart.throw(new core.UnsupportedError("Cannot remove from an unmodifiable list"));
      }
      replaceRange(start, end, iterable) {
        IterableOfE()._check(iterable);
        dart.throw(new core.UnsupportedError("Cannot remove from an unmodifiable list"));
      }
      fillRange(start, end, fillValue) {
        if (fillValue === void 0) fillValue = null;
        E._check(fillValue);
        dart.throw(new core.UnsupportedError("Cannot modify an unmodifiable list"));
      }
    }
    dart.addTypeTests(UnmodifiableListMixin);
    UnmodifiableListMixin[dart.implements] = () => [ListOfE()];
    dart.setSignature(UnmodifiableListMixin, {
      methods: () => ({
        set: dart.definiteFunctionType(dart.void, [core.int, E]),
        setAll: dart.definiteFunctionType(dart.void, [core.int, core.Iterable$(E)]),
        add: dart.definiteFunctionType(dart.void, [E]),
        insert: dart.definiteFunctionType(dart.void, [core.int, E]),
        insertAll: dart.definiteFunctionType(dart.void, [core.int, core.Iterable$(E)]),
        addAll: dart.definiteFunctionType(dart.void, [core.Iterable$(E)]),
        remove: dart.definiteFunctionType(core.bool, [core.Object]),
        removeWhere: dart.definiteFunctionType(dart.void, [dart.functionType(core.bool, [E])]),
        retainWhere: dart.definiteFunctionType(dart.void, [dart.functionType(core.bool, [E])]),
        sort: dart.definiteFunctionType(dart.void, [], [core.Comparator$(E)]),
        shuffle: dart.definiteFunctionType(dart.void, [], [math.Random]),
        clear: dart.definiteFunctionType(dart.void, []),
        removeAt: dart.definiteFunctionType(E, [core.int]),
        removeLast: dart.definiteFunctionType(E, []),
        setRange: dart.definiteFunctionType(dart.void, [core.int, core.int, core.Iterable$(E)], [core.int]),
        removeRange: dart.definiteFunctionType(dart.void, [core.int, core.int]),
        replaceRange: dart.definiteFunctionType(dart.void, [core.int, core.int, core.Iterable$(E)]),
        fillRange: dart.definiteFunctionType(dart.void, [core.int, core.int], [E])
      })
    });
    dart.defineExtensionMembers(UnmodifiableListMixin, [
      'set',
      'setAll',
      'add',
      'insert',
      'insertAll',
      'addAll',
      'remove',
      'removeWhere',
      'retainWhere',
      'sort',
      'shuffle',
      'clear',
      'removeAt',
      'removeLast',
      'setRange',
      'removeRange',
      'replaceRange',
      'fillRange',
      'length'
    ]);
    return UnmodifiableListMixin;
  });
  _internal.UnmodifiableListMixin = UnmodifiableListMixin();
  _internal.UnmodifiableListBase$ = dart.generic(E => {
    class UnmodifiableListBase extends dart.mixin(collection.ListBase$(E), _internal.UnmodifiableListMixin$(E)) {
      new() {
        super.new();
      }
    }
    return UnmodifiableListBase;
  });
  _internal.UnmodifiableListBase = UnmodifiableListBase();
  core.int = class int extends core.num {
    static fromEnvironment(name, opts) {
      let defaultValue = opts && 'defaultValue' in opts ? opts.defaultValue : null;
      dart.throw(new core.UnsupportedError('int.fromEnvironment can only be used as a const constructor'));
    }
    static parse(source, opts) {
      let radix = opts && 'radix' in opts ? opts.radix : null;
      let onError = opts && 'onError' in opts ? opts.onError : null;
      return _js_helper.Primitives.parseInt(source, radix, onError);
    }
  };
  core.int.is = function is_int(o) {
    return typeof o == "number" && Math.floor(o) == o;
  };
  core.int.as = function as_int(o) {
    if (typeof o == "number" && Math.floor(o) == o || o == null) return o;
    return dart.as(o, core.int);
  };
  core.int._check = function check_int(o) {
    if (typeof o == "number" && Math.floor(o) == o || o == null) return o;
    return dart.check(o, core.int);
  };
  dart.setSignature(core.int, {
    constructors: () => ({fromEnvironment: dart.definiteFunctionType(core.int, [core.String], {defaultValue: core.int})}),
    statics: () => ({parse: dart.definiteFunctionType(core.int, [core.String], {radix: core.int, onError: StringToint()})}),
    names: ['parse']
  });
  _internal.CodeUnits = class CodeUnits extends _internal.UnmodifiableListBase$(core.int) {
    new(string) {
      this[_string] = string;
    }
    get length() {
      return this[_string][dartx.length];
    }
    set length(value) {
      super.length = value;
    }
    get(i) {
      return this[_string][dartx.codeUnitAt](i);
    }
    static stringOf(u) {
      return u[_string];
    }
  };
  dart.addSimpleTypeTests(_internal.CodeUnits);
  dart.setSignature(_internal.CodeUnits, {
    constructors: () => ({new: dart.definiteFunctionType(_internal.CodeUnits, [core.String])}),
    methods: () => ({get: dart.definiteFunctionType(core.int, [core.int])}),
    statics: () => ({stringOf: dart.definiteFunctionType(core.String, [_internal.CodeUnits])}),
    names: ['stringOf']
  });
  dart.defineExtensionMembers(_internal.CodeUnits, ['get', 'length']);
  _internal.EfficientLength = class EfficientLength extends core.Object {};
  core.Iterable$ = dart.generic(E => {
    let EmptyIterableOfE = () => (EmptyIterableOfE = dart.constFn(_internal.EmptyIterable$(E)))();
    let _GeneratorIterableOfE = () => (_GeneratorIterableOfE = dart.constFn(core._GeneratorIterable$(E)))();
    let WhereIterableOfE = () => (WhereIterableOfE = dart.constFn(_internal.WhereIterable$(E)))();
    let EAndEToE = () => (EAndEToE = dart.constFn(dart.functionType(E, [E, E])))();
    let ListOfE = () => (ListOfE = dart.constFn(core.List$(E)))();
    let SetOfE = () => (SetOfE = dart.constFn(core.Set$(E)))();
    let TakeIterableOfE = () => (TakeIterableOfE = dart.constFn(_internal.TakeIterable$(E)))();
    let TakeWhileIterableOfE = () => (TakeWhileIterableOfE = dart.constFn(_internal.TakeWhileIterable$(E)))();
    let SkipIterableOfE = () => (SkipIterableOfE = dart.constFn(_internal.SkipIterable$(E)))();
    let SkipWhileIterableOfE = () => (SkipWhileIterableOfE = dart.constFn(_internal.SkipWhileIterable$(E)))();
    let VoidToE = () => (VoidToE = dart.constFn(dart.functionType(E, [])))();
    dart.defineExtensionNames([
      'map',
      'where',
      'expand',
      'contains',
      'forEach',
      'reduce',
      'fold',
      'every',
      'join',
      'any',
      'toList',
      'toSet',
      'length',
      'isEmpty',
      'isNotEmpty',
      'take',
      'takeWhile',
      'skip',
      'skipWhile',
      'first',
      'last',
      'single',
      'firstWhere',
      'lastWhere',
      'singleWhere',
      'elementAt',
      'toString'
    ]);
    class Iterable extends core.Object {
      new() {
      }
      static generate(count, generator) {
        if (generator === void 0) generator = null;
        if (dart.notNull(count) <= 0) return new (EmptyIterableOfE())();
        return new (_GeneratorIterableOfE())(count, generator);
      }
      static empty() {
        return new (EmptyIterableOfE())();
      }
      [Symbol.iterator]() {
        return new dart.JsIterator(this[dartx.iterator]);
      }
      map(T) {
        return f => {
          return _internal.MappedIterable$(E, T).new(this, f);
        };
      }
      where(test) {
        return new (WhereIterableOfE())(this, test);
      }
      expand(T) {
        return f => {
          return new (_internal.ExpandIterable$(E, T))(this, f);
        };
      }
      contains(element) {
        for (let e of this) {
          if (dart.equals(e, element)) return true;
        }
        return false;
      }
      forEach(f) {
        for (let element of this)
          f(element);
      }
      reduce(combine) {
        EAndEToE()._check(combine);
        let iterator = this[dartx.iterator];
        if (!dart.test(iterator.moveNext())) {
          dart.throw(_internal.IterableElementError.noElement());
        }
        let value = iterator.current;
        while (dart.test(iterator.moveNext())) {
          value = combine(value, iterator.current);
        }
        return value;
      }
      fold(T) {
        return (initialValue, combine) => {
          let value = initialValue;
          for (let element of this)
            value = combine(value, element);
          return value;
        };
      }
      every(f) {
        for (let element of this) {
          if (!dart.test(f(element))) return false;
        }
        return true;
      }
      join(separator) {
        if (separator === void 0) separator = "";
        let iterator = this[dartx.iterator];
        if (!dart.test(iterator.moveNext())) return "";
        let buffer = new core.StringBuffer();
        if (separator == null || separator == "") {
          do {
            buffer.write(dart.str`${iterator.current}`);
          } while (dart.test(iterator.moveNext()));
        } else {
          buffer.write(dart.str`${iterator.current}`);
          while (dart.test(iterator.moveNext())) {
            buffer.write(separator);
            buffer.write(dart.str`${iterator.current}`);
          }
        }
        return buffer.toString();
      }
      any(f) {
        for (let element of this) {
          if (dart.test(f(element))) return true;
        }
        return false;
      }
      toList(opts) {
        let growable = opts && 'growable' in opts ? opts.growable : true;
        return ListOfE().from(this, {growable: growable});
      }
      toSet() {
        return SetOfE().from(this);
      }
      get length() {
        dart.assert(!_internal.EfficientLength.is(this));
        let count = 0;
        let it = this[dartx.iterator];
        while (dart.test(it.moveNext())) {
          count++;
        }
        return count;
      }
      get isEmpty() {
        return !dart.test(this[dartx.iterator].moveNext());
      }
      get isNotEmpty() {
        return !dart.test(this[dartx.isEmpty]);
      }
      take(count) {
        return TakeIterableOfE().new(this, count);
      }
      takeWhile(test) {
        return new (TakeWhileIterableOfE())(this, test);
      }
      skip(count) {
        return SkipIterableOfE().new(this, count);
      }
      skipWhile(test) {
        return new (SkipWhileIterableOfE())(this, test);
      }
      get first() {
        let it = this[dartx.iterator];
        if (!dart.test(it.moveNext())) {
          dart.throw(_internal.IterableElementError.noElement());
        }
        return it.current;
      }
      get last() {
        let it = this[dartx.iterator];
        if (!dart.test(it.moveNext())) {
          dart.throw(_internal.IterableElementError.noElement());
        }
        let result = null;
        do {
          result = it.current;
        } while (dart.test(it.moveNext()));
        return result;
      }
      get single() {
        let it = this[dartx.iterator];
        if (!dart.test(it.moveNext())) dart.throw(_internal.IterableElementError.noElement());
        let result = it.current;
        if (dart.test(it.moveNext())) dart.throw(_internal.IterableElementError.tooMany());
        return result;
      }
      firstWhere(test, opts) {
        let orElse = opts && 'orElse' in opts ? opts.orElse : null;
        VoidToE()._check(orElse);
        for (let element of this) {
          if (dart.test(test(element))) return element;
        }
        if (orElse != null) return orElse();
        dart.throw(_internal.IterableElementError.noElement());
      }
      lastWhere(test, opts) {
        let orElse = opts && 'orElse' in opts ? opts.orElse : null;
        VoidToE()._check(orElse);
        let result = null;
        let foundMatching = false;
        for (let element of this) {
          if (dart.test(test(element))) {
            result = element;
            foundMatching = true;
          }
        }
        if (foundMatching) return result;
        if (orElse != null) return orElse();
        dart.throw(_internal.IterableElementError.noElement());
      }
      singleWhere(test) {
        let result = null;
        let foundMatching = false;
        for (let element of this) {
          if (dart.test(test(element))) {
            if (foundMatching) {
              dart.throw(_internal.IterableElementError.tooMany());
            }
            result = element;
            foundMatching = true;
          }
        }
        if (foundMatching) return result;
        dart.throw(_internal.IterableElementError.noElement());
      }
      elementAt(index) {
        if (!(typeof index == 'number')) dart.throw(new core.ArgumentError.notNull("index"));
        core.RangeError.checkNotNegative(index, "index");
        let elementIndex = 0;
        for (let element of this) {
          if (index == elementIndex) return element;
          elementIndex++;
        }
        dart.throw(core.RangeError.index(index, this, "index", null, elementIndex));
      }
      toString() {
        return collection.IterableBase.iterableToShortString(this, '(', ')');
      }
    }
    dart.addTypeTests(Iterable);
    dart.setSignature(Iterable, {
      constructors: () => ({
        new: dart.definiteFunctionType(core.Iterable$(E), []),
        generate: dart.definiteFunctionType(core.Iterable$(E), [core.int], [dart.functionType(E, [core.int])]),
        empty: dart.definiteFunctionType(core.Iterable$(E), [])
      }),
      methods: () => ({
        map: dart.definiteFunctionType(T => [core.Iterable$(T), [dart.functionType(T, [E])]]),
        where: dart.definiteFunctionType(core.Iterable$(E), [dart.functionType(core.bool, [E])]),
        expand: dart.definiteFunctionType(T => [core.Iterable$(T), [dart.functionType(core.Iterable$(T), [E])]]),
        contains: dart.definiteFunctionType(core.bool, [core.Object]),
        forEach: dart.definiteFunctionType(dart.void, [dart.functionType(dart.void, [E])]),
        reduce: dart.definiteFunctionType(E, [dart.functionType(E, [E, E])]),
        fold: dart.definiteFunctionType(T => [T, [T, dart.functionType(T, [T, E])]]),
        every: dart.definiteFunctionType(core.bool, [dart.functionType(core.bool, [E])]),
        join: dart.definiteFunctionType(core.String, [], [core.String]),
        any: dart.definiteFunctionType(core.bool, [dart.functionType(core.bool, [E])]),
        toList: dart.definiteFunctionType(core.List$(E), [], {growable: core.bool}),
        toSet: dart.definiteFunctionType(core.Set$(E), []),
        take: dart.definiteFunctionType(core.Iterable$(E), [core.int]),
        takeWhile: dart.definiteFunctionType(core.Iterable$(E), [dart.functionType(core.bool, [E])]),
        skip: dart.definiteFunctionType(core.Iterable$(E), [core.int]),
        skipWhile: dart.definiteFunctionType(core.Iterable$(E), [dart.functionType(core.bool, [E])]),
        firstWhere: dart.definiteFunctionType(E, [dart.functionType(core.bool, [E])], {orElse: VoidToE()}),
        lastWhere: dart.definiteFunctionType(E, [dart.functionType(core.bool, [E])], {orElse: VoidToE()}),
        singleWhere: dart.definiteFunctionType(E, [dart.functionType(core.bool, [E])]),
        elementAt: dart.definiteFunctionType(E, [core.int])
      })
    });
    dart.defineExtensionMembers(Iterable, [
      'map',
      'where',
      'expand',
      'contains',
      'forEach',
      'reduce',
      'fold',
      'every',
      'join',
      'any',
      'toList',
      'toSet',
      'take',
      'takeWhile',
      'skip',
      'skipWhile',
      'firstWhere',
      'lastWhere',
      'singleWhere',
      'elementAt',
      'toString',
      'length',
      'isEmpty',
      'isNotEmpty',
      'first',
      'last',
      'single'
    ]);
    return Iterable;
  });
  core.Iterable = Iterable();
  _internal.ListIterable$ = dart.generic(E => {
    let ListIteratorOfE = () => (ListIteratorOfE = dart.constFn(_internal.ListIterator$(E)))();
    let VoidToE = () => (VoidToE = dart.constFn(dart.functionType(E, [])))();
    let dynamicAndEToE = () => (dynamicAndEToE = dart.constFn(dart.functionType(E, [dart.dynamic, E])))();
    let SubListIterableOfE = () => (SubListIterableOfE = dart.constFn(_internal.SubListIterable$(E)))();
    let ListOfE = () => (ListOfE = dart.constFn(core.List$(E)))();
    let SetOfE = () => (SetOfE = dart.constFn(core.Set$(E)))();
    class ListIterable extends core.Iterable$(E) {
      new() {
        super.new();
      }
      get iterator() {
        return new (ListIteratorOfE())(this);
      }
      forEach(action) {
        let length = this.length;
        for (let i = 0; i < dart.notNull(length); i++) {
          action(this.elementAt(i));
          if (length != this.length) {
            dart.throw(new core.ConcurrentModificationError(this));
          }
        }
      }
      get isEmpty() {
        return this.length == 0;
      }
      get first() {
        if (this.length == 0) dart.throw(_internal.IterableElementError.noElement());
        return this.elementAt(0);
      }
      get last() {
        if (this.length == 0) dart.throw(_internal.IterableElementError.noElement());
        return this.elementAt(dart.notNull(this.length) - 1);
      }
      get single() {
        if (this.length == 0) dart.throw(_internal.IterableElementError.noElement());
        if (dart.notNull(this.length) > 1) dart.throw(_internal.IterableElementError.tooMany());
        return this.elementAt(0);
      }
      contains(element) {
        let length = this.length;
        for (let i = 0; i < dart.notNull(length); i++) {
          if (dart.equals(this.elementAt(i), element)) return true;
          if (length != this.length) {
            dart.throw(new core.ConcurrentModificationError(this));
          }
        }
        return false;
      }
      every(test) {
        let length = this.length;
        for (let i = 0; i < dart.notNull(length); i++) {
          if (!dart.test(test(this.elementAt(i)))) return false;
          if (length != this.length) {
            dart.throw(new core.ConcurrentModificationError(this));
          }
        }
        return true;
      }
      any(test) {
        let length = this.length;
        for (let i = 0; i < dart.notNull(length); i++) {
          if (dart.test(test(this.elementAt(i)))) return true;
          if (length != this.length) {
            dart.throw(new core.ConcurrentModificationError(this));
          }
        }
        return false;
      }
      firstWhere(test, opts) {
        let orElse = opts && 'orElse' in opts ? opts.orElse : null;
        VoidToE()._check(orElse);
        let length = this.length;
        for (let i = 0; i < dart.notNull(length); i++) {
          let element = this.elementAt(i);
          if (dart.test(test(element))) return element;
          if (length != this.length) {
            dart.throw(new core.ConcurrentModificationError(this));
          }
        }
        if (orElse != null) return orElse();
        dart.throw(_internal.IterableElementError.noElement());
      }
      lastWhere(test, opts) {
        let orElse = opts && 'orElse' in opts ? opts.orElse : null;
        VoidToE()._check(orElse);
        let length = this.length;
        for (let i = dart.notNull(length) - 1; i >= 0; i--) {
          let element = this.elementAt(i);
          if (dart.test(test(element))) return element;
          if (length != this.length) {
            dart.throw(new core.ConcurrentModificationError(this));
          }
        }
        if (orElse != null) return orElse();
        dart.throw(_internal.IterableElementError.noElement());
      }
      singleWhere(test) {
        let length = this.length;
        let match = null;
        let matchFound = false;
        for (let i = 0; i < dart.notNull(length); i++) {
          let element = this.elementAt(i);
          if (dart.test(test(element))) {
            if (matchFound) {
              dart.throw(_internal.IterableElementError.tooMany());
            }
            matchFound = true;
            match = element;
          }
          if (length != this.length) {
            dart.throw(new core.ConcurrentModificationError(this));
          }
        }
        if (matchFound) return match;
        dart.throw(_internal.IterableElementError.noElement());
      }
      join(separator) {
        if (separator === void 0) separator = "";
        let length = this.length;
        if (!dart.test(separator[dartx.isEmpty])) {
          if (length == 0) return "";
          let first = dart.str`${this.elementAt(0)}`;
          if (length != this.length) {
            dart.throw(new core.ConcurrentModificationError(this));
          }
          let buffer = new core.StringBuffer(first);
          for (let i = 1; i < dart.notNull(length); i++) {
            buffer.write(separator);
            buffer.write(this.elementAt(i));
            if (length != this.length) {
              dart.throw(new core.ConcurrentModificationError(this));
            }
          }
          return buffer.toString();
        } else {
          let buffer = new core.StringBuffer();
          for (let i = 0; i < dart.notNull(length); i++) {
            buffer.write(this.elementAt(i));
            if (length != this.length) {
              dart.throw(new core.ConcurrentModificationError(this));
            }
          }
          return buffer.toString();
        }
      }
      where(test) {
        return super.where(test);
      }
      map(T) {
        return f => {
          return new (_internal.MappedListIterable$(E, T))(this, f);
        };
      }
      reduce(combine) {
        dynamicAndEToE()._check(combine);
        let length = this.length;
        if (length == 0) dart.throw(_internal.IterableElementError.noElement());
        let value = this.elementAt(0);
        for (let i = 1; i < dart.notNull(length); i++) {
          value = dart.dcall(combine, value, this.elementAt(i));
          if (length != this.length) {
            dart.throw(new core.ConcurrentModificationError(this));
          }
        }
        return value;
      }
      fold(T) {
        return (initialValue, combine) => {
          let value = initialValue;
          let length = this.length;
          for (let i = 0; i < dart.notNull(length); i++) {
            value = combine(value, this.elementAt(i));
            if (length != this.length) {
              dart.throw(new core.ConcurrentModificationError(this));
            }
          }
          return value;
        };
      }
      skip(count) {
        return new (SubListIterableOfE())(this, count, null);
      }
      skipWhile(test) {
        return super.skipWhile(test);
      }
      take(count) {
        return new (SubListIterableOfE())(this, 0, count);
      }
      takeWhile(test) {
        return super.takeWhile(test);
      }
      toList(opts) {
        let growable = opts && 'growable' in opts ? opts.growable : true;
        let result = null;
        if (dart.test(growable)) {
          result = ListOfE().new();
          result[dartx.length] = this.length;
        } else {
          result = ListOfE().new(this.length);
        }
        for (let i = 0; i < dart.notNull(this.length); i++) {
          result[dartx.set](i, this.elementAt(i));
        }
        return result;
      }
      toSet() {
        let result = SetOfE().new();
        for (let i = 0; i < dart.notNull(this.length); i++) {
          result.add(this.elementAt(i));
        }
        return result;
      }
    }
    ListIterable[dart.implements] = () => [_internal.EfficientLength];
    dart.setSignature(ListIterable, {
      constructors: () => ({new: dart.definiteFunctionType(_internal.ListIterable$(E), [])}),
      methods: () => ({
        forEach: dart.definiteFunctionType(dart.void, [dart.functionType(dart.void, [E])]),
        every: dart.definiteFunctionType(core.bool, [dart.functionType(core.bool, [E])]),
        any: dart.definiteFunctionType(core.bool, [dart.functionType(core.bool, [E])]),
        firstWhere: dart.definiteFunctionType(E, [dart.functionType(core.bool, [E])], {orElse: VoidToE()}),
        lastWhere: dart.definiteFunctionType(E, [dart.functionType(core.bool, [E])], {orElse: VoidToE()}),
        singleWhere: dart.definiteFunctionType(E, [dart.functionType(core.bool, [E])]),
        where: dart.definiteFunctionType(core.Iterable$(E), [dart.functionType(core.bool, [E])]),
        map: dart.definiteFunctionType(T => [core.Iterable$(T), [dart.functionType(T, [E])]]),
        reduce: dart.definiteFunctionType(E, [dart.functionType(E, [dart.dynamic, E])]),
        fold: dart.definiteFunctionType(T => [T, [T, dart.functionType(T, [T, E])]]),
        skip: dart.definiteFunctionType(core.Iterable$(E), [core.int]),
        skipWhile: dart.definiteFunctionType(core.Iterable$(E), [dart.functionType(core.bool, [E])]),
        take: dart.definiteFunctionType(core.Iterable$(E), [core.int]),
        takeWhile: dart.definiteFunctionType(core.Iterable$(E), [dart.functionType(core.bool, [E])]),
        toList: dart.definiteFunctionType(core.List$(E), [], {growable: core.bool}),
        toSet: dart.definiteFunctionType(core.Set$(E), [])
      })
    });
    dart.defineExtensionMembers(ListIterable, [
      'forEach',
      'contains',
      'every',
      'any',
      'firstWhere',
      'lastWhere',
      'singleWhere',
      'join',
      'where',
      'map',
      'reduce',
      'fold',
      'skip',
      'skipWhile',
      'take',
      'takeWhile',
      'toList',
      'toSet',
      'iterator',
      'isEmpty',
      'first',
      'last',
      'single'
    ]);
    return ListIterable;
  });
  _internal.ListIterable = ListIterable();
  const _iterable$ = Symbol('_iterable');
  const _start = Symbol('_start');
  const _endOrLength = Symbol('_endOrLength');
  const _endIndex = Symbol('_endIndex');
  const _startIndex = Symbol('_startIndex');
  _internal.SubListIterable$ = dart.generic(E => {
    let EmptyIterableOfE = () => (EmptyIterableOfE = dart.constFn(_internal.EmptyIterable$(E)))();
    let SubListIterableOfE = () => (SubListIterableOfE = dart.constFn(_internal.SubListIterable$(E)))();
    let ListOfE = () => (ListOfE = dart.constFn(core.List$(E)))();
    class SubListIterable extends _internal.ListIterable$(E) {
      new(iterable, start, endOrLength) {
        this[_iterable$] = iterable;
        this[_start] = start;
        this[_endOrLength] = endOrLength;
        super.new();
        core.RangeError.checkNotNegative(this[_start], "start");
        if (this[_endOrLength] != null) {
          core.RangeError.checkNotNegative(this[_endOrLength], "end");
          if (dart.notNull(this[_start]) > dart.notNull(this[_endOrLength])) {
            dart.throw(new core.RangeError.range(this[_start], 0, this[_endOrLength], "start"));
          }
        }
      }
      get [_endIndex]() {
        let length = this[_iterable$][dartx.length];
        if (this[_endOrLength] == null || dart.notNull(this[_endOrLength]) > dart.notNull(length)) return length;
        return this[_endOrLength];
      }
      get [_startIndex]() {
        let length = this[_iterable$][dartx.length];
        if (dart.notNull(this[_start]) > dart.notNull(length)) return length;
        return this[_start];
      }
      get length() {
        let length = this[_iterable$][dartx.length];
        if (dart.notNull(this[_start]) >= dart.notNull(length)) return 0;
        if (this[_endOrLength] == null || dart.notNull(this[_endOrLength]) >= dart.notNull(length)) {
          return dart.notNull(length) - dart.notNull(this[_start]);
        }
        return dart.notNull(this[_endOrLength]) - dart.notNull(this[_start]);
      }
      elementAt(index) {
        let realIndex = dart.notNull(this[_startIndex]) + dart.notNull(index);
        if (dart.notNull(index) < 0 || realIndex >= dart.notNull(this[_endIndex])) {
          dart.throw(core.RangeError.index(index, this, "index"));
        }
        return this[_iterable$][dartx.elementAt](realIndex);
      }
      skip(count) {
        core.RangeError.checkNotNegative(count, "count");
        let newStart = dart.notNull(this[_start]) + dart.notNull(count);
        if (this[_endOrLength] != null && newStart >= dart.notNull(this[_endOrLength])) {
          return new (EmptyIterableOfE())();
        }
        return new (SubListIterableOfE())(this[_iterable$], newStart, this[_endOrLength]);
      }
      take(count) {
        core.RangeError.checkNotNegative(count, "count");
        if (this[_endOrLength] == null) {
          return new (SubListIterableOfE())(this[_iterable$], this[_start], dart.notNull(this[_start]) + dart.notNull(count));
        } else {
          let newEnd = dart.notNull(this[_start]) + dart.notNull(count);
          if (dart.notNull(this[_endOrLength]) < newEnd) return this;
          return new (SubListIterableOfE())(this[_iterable$], this[_start], newEnd);
        }
      }
      toList(opts) {
        let growable = opts && 'growable' in opts ? opts.growable : true;
        let start = this[_start];
        let end = this[_iterable$][dartx.length];
        if (this[_endOrLength] != null && dart.notNull(this[_endOrLength]) < dart.notNull(end)) end = this[_endOrLength];
        let length = dart.notNull(end) - dart.notNull(start);
        if (length < 0) length = 0;
        let result = dart.test(growable) ? (() => {
          let _ = ListOfE().new();
          _[dartx.length] = length;
          return _;
        })() : ListOfE().new(length);
        for (let i = 0; i < length; i++) {
          result[dartx.set](i, this[_iterable$][dartx.elementAt](dart.notNull(start) + i));
          if (dart.notNull(this[_iterable$][dartx.length]) < dart.notNull(end)) dart.throw(new core.ConcurrentModificationError(this));
        }
        return result;
      }
    }
    dart.setSignature(SubListIterable, {
      constructors: () => ({new: dart.definiteFunctionType(_internal.SubListIterable$(E), [core.Iterable$(E), core.int, core.int])}),
      methods: () => ({
        elementAt: dart.definiteFunctionType(E, [core.int]),
        skip: dart.definiteFunctionType(core.Iterable$(E), [core.int]),
        take: dart.definiteFunctionType(core.Iterable$(E), [core.int]),
        toList: dart.definiteFunctionType(core.List$(E), [], {growable: core.bool})
      })
    });
    dart.defineExtensionMembers(SubListIterable, [
      'elementAt',
      'skip',
      'take',
      'toList',
      'length'
    ]);
    return SubListIterable;
  });
  _internal.SubListIterable = SubListIterable();
  const _length$ = Symbol('_length');
  const _index$ = Symbol('_index');
  const _current$ = Symbol('_current');
  _internal.ListIterator$ = dart.generic(E => {
    let IteratorOfE = () => (IteratorOfE = dart.constFn(core.Iterator$(E)))();
    class ListIterator extends core.Object {
      new(iterable) {
        this[_iterable$] = iterable;
        this[_length$] = iterable[dartx.length];
        this[_index$] = 0;
        this[_current$] = null;
      }
      get current() {
        return this[_current$];
      }
      moveNext() {
        let length = this[_iterable$][dartx.length];
        if (this[_length$] != length) {
          dart.throw(new core.ConcurrentModificationError(this[_iterable$]));
        }
        if (dart.notNull(this[_index$]) >= dart.notNull(length)) {
          this[_current$] = null;
          return false;
        }
        this[_current$] = this[_iterable$][dartx.elementAt](this[_index$]);
        this[_index$] = dart.notNull(this[_index$]) + 1;
        return true;
      }
    }
    dart.addTypeTests(ListIterator);
    ListIterator[dart.implements] = () => [IteratorOfE()];
    dart.setSignature(ListIterator, {
      constructors: () => ({new: dart.definiteFunctionType(_internal.ListIterator$(E), [core.Iterable$(E)])}),
      methods: () => ({moveNext: dart.definiteFunctionType(core.bool, [])})
    });
    return ListIterator;
  });
  _internal.ListIterator = ListIterator();
  _internal._Transformation$ = dart.generic((S, T) => {
    const _Transformation = dart.typedef('_Transformation', () => dart.functionType(T, [S]));
    return _Transformation;
  });
  _internal._Transformation = _Transformation();
  const _f = Symbol('_f');
  _internal.MappedIterable$ = dart.generic((S, T) => {
    let EfficientLengthMappedIterableOfS$T = () => (EfficientLengthMappedIterableOfS$T = dart.constFn(_internal.EfficientLengthMappedIterable$(S, T)))();
    let MappedIterableOfS$T = () => (MappedIterableOfS$T = dart.constFn(_internal.MappedIterable$(S, T)))();
    let MappedIteratorOfS$T = () => (MappedIteratorOfS$T = dart.constFn(_internal.MappedIterator$(S, T)))();
    class MappedIterable extends core.Iterable$(T) {
      static new(iterable, func) {
        if (_internal.EfficientLength.is(iterable)) {
          return new (EfficientLengthMappedIterableOfS$T())(iterable, func);
        }
        return new (MappedIterableOfS$T())._(iterable, func);
      }
      _(iterable, f) {
        this[_iterable$] = iterable;
        this[_f] = f;
        super.new();
      }
      get iterator() {
        return new (MappedIteratorOfS$T())(this[_iterable$][dartx.iterator], this[_f]);
      }
      get length() {
        return this[_iterable$][dartx.length];
      }
      get isEmpty() {
        return this[_iterable$][dartx.isEmpty];
      }
      get first() {
        return this[_f](this[_iterable$][dartx.first]);
      }
      get last() {
        return this[_f](this[_iterable$][dartx.last]);
      }
      get single() {
        return this[_f](this[_iterable$][dartx.single]);
      }
      elementAt(index) {
        return this[_f](this[_iterable$][dartx.elementAt](index));
      }
    }
    dart.defineNamedConstructor(MappedIterable, '_');
    dart.setSignature(MappedIterable, {
      constructors: () => ({
        new: dart.definiteFunctionType(_internal.MappedIterable$(S, T), [core.Iterable$(S), dart.functionType(T, [S])]),
        _: dart.definiteFunctionType(_internal.MappedIterable$(S, T), [core.Iterable$(S), dart.functionType(T, [S])])
      }),
      methods: () => ({elementAt: dart.definiteFunctionType(T, [core.int])})
    });
    dart.defineExtensionMembers(MappedIterable, [
      'elementAt',
      'iterator',
      'length',
      'isEmpty',
      'first',
      'last',
      'single'
    ]);
    return MappedIterable;
  });
  _internal.MappedIterable = MappedIterable();
  _internal.EfficientLengthMappedIterable$ = dart.generic((S, T) => {
    class EfficientLengthMappedIterable extends _internal.MappedIterable$(S, T) {
      new(iterable, func) {
        super._(iterable, func);
      }
    }
    EfficientLengthMappedIterable[dart.implements] = () => [_internal.EfficientLength];
    dart.setSignature(EfficientLengthMappedIterable, {
      constructors: () => ({new: dart.definiteFunctionType(_internal.EfficientLengthMappedIterable$(S, T), [core.Iterable$(S), dart.functionType(T, [S])])})
    });
    return EfficientLengthMappedIterable;
  });
  _internal.EfficientLengthMappedIterable = EfficientLengthMappedIterable();
  const _iterator = Symbol('_iterator');
  core.Iterator$ = dart.generic(E => {
    class Iterator extends core.Object {}
    dart.addTypeTests(Iterator);
    return Iterator;
  });
  core.Iterator = Iterator();
  _internal.MappedIterator$ = dart.generic((S, T) => {
    class MappedIterator extends core.Iterator$(T) {
      new(iterator, f) {
        this[_iterator] = iterator;
        this[_f] = f;
        this[_current$] = null;
      }
      moveNext() {
        if (dart.test(this[_iterator].moveNext())) {
          this[_current$] = this[_f](this[_iterator].current);
          return true;
        }
        this[_current$] = null;
        return false;
      }
      get current() {
        return this[_current$];
      }
    }
    dart.setSignature(MappedIterator, {
      constructors: () => ({new: dart.definiteFunctionType(_internal.MappedIterator$(S, T), [core.Iterator$(S), dart.functionType(T, [S])])}),
      methods: () => ({moveNext: dart.definiteFunctionType(core.bool, [])})
    });
    return MappedIterator;
  });
  _internal.MappedIterator = MappedIterator();
  const _source = Symbol('_source');
  _internal.MappedListIterable$ = dart.generic((S, T) => {
    class MappedListIterable extends _internal.ListIterable$(T) {
      new(source, f) {
        this[_source] = source;
        this[_f] = f;
        super.new();
      }
      get length() {
        return this[_source][dartx.length];
      }
      elementAt(index) {
        return this[_f](this[_source][dartx.elementAt](index));
      }
    }
    MappedListIterable[dart.implements] = () => [_internal.EfficientLength];
    dart.setSignature(MappedListIterable, {
      constructors: () => ({new: dart.definiteFunctionType(_internal.MappedListIterable$(S, T), [core.Iterable$(S), dart.functionType(T, [S])])}),
      methods: () => ({elementAt: dart.definiteFunctionType(T, [core.int])})
    });
    dart.defineExtensionMembers(MappedListIterable, ['elementAt', 'length']);
    return MappedListIterable;
  });
  _internal.MappedListIterable = MappedListIterable();
  _internal._ElementPredicate$ = dart.generic(E => {
    const _ElementPredicate = dart.typedef('_ElementPredicate', () => dart.functionType(core.bool, [E]));
    return _ElementPredicate;
  });
  _internal._ElementPredicate = _ElementPredicate();
  _internal.WhereIterable$ = dart.generic(E => {
    let WhereIteratorOfE = () => (WhereIteratorOfE = dart.constFn(_internal.WhereIterator$(E)))();
    class WhereIterable extends core.Iterable$(E) {
      new(iterable, f) {
        this[_iterable$] = iterable;
        this[_f] = f;
        super.new();
      }
      get iterator() {
        return new (WhereIteratorOfE())(this[_iterable$][dartx.iterator], this[_f]);
      }
    }
    dart.setSignature(WhereIterable, {
      constructors: () => ({new: dart.definiteFunctionType(_internal.WhereIterable$(E), [core.Iterable$(E), dart.functionType(core.bool, [E])])})
    });
    dart.defineExtensionMembers(WhereIterable, ['iterator']);
    return WhereIterable;
  });
  _internal.WhereIterable = WhereIterable();
  _internal.WhereIterator$ = dart.generic(E => {
    class WhereIterator extends core.Iterator$(E) {
      new(iterator, f) {
        this[_iterator] = iterator;
        this[_f] = f;
      }
      moveNext() {
        while (dart.test(this[_iterator].moveNext())) {
          if (dart.test(this[_f](this[_iterator].current))) {
            return true;
          }
        }
        return false;
      }
      get current() {
        return this[_iterator].current;
      }
    }
    dart.setSignature(WhereIterator, {
      constructors: () => ({new: dart.definiteFunctionType(_internal.WhereIterator$(E), [core.Iterator$(E), dart.functionType(core.bool, [E])])}),
      methods: () => ({moveNext: dart.definiteFunctionType(core.bool, [])})
    });
    return WhereIterator;
  });
  _internal.WhereIterator = WhereIterator();
  _internal._ExpandFunction$ = dart.generic((S, T) => {
    const _ExpandFunction = dart.typedef('_ExpandFunction', () => dart.functionType(core.Iterable$(T), [S]));
    return _ExpandFunction;
  });
  _internal._ExpandFunction = _ExpandFunction();
  _internal.ExpandIterable$ = dart.generic((S, T) => {
    let ExpandIteratorOfS$T = () => (ExpandIteratorOfS$T = dart.constFn(_internal.ExpandIterator$(S, T)))();
    class ExpandIterable extends core.Iterable$(T) {
      new(iterable, f) {
        this[_iterable$] = iterable;
        this[_f] = f;
        super.new();
      }
      get iterator() {
        return new (ExpandIteratorOfS$T())(this[_iterable$][dartx.iterator], this[_f]);
      }
    }
    dart.setSignature(ExpandIterable, {
      constructors: () => ({new: dart.definiteFunctionType(_internal.ExpandIterable$(S, T), [core.Iterable$(S), dart.functionType(core.Iterable$(T), [S])])})
    });
    dart.defineExtensionMembers(ExpandIterable, ['iterator']);
    return ExpandIterable;
  });
  _internal.ExpandIterable = ExpandIterable();
  const _currentExpansion = Symbol('_currentExpansion');
  _internal.ExpandIterator$ = dart.generic((S, T) => {
    let EmptyIteratorOfT = () => (EmptyIteratorOfT = dart.constFn(_internal.EmptyIterator$(T)))();
    let IteratorOfT = () => (IteratorOfT = dart.constFn(core.Iterator$(T)))();
    class ExpandIterator extends core.Object {
      new(iterator, f) {
        this[_iterator] = iterator;
        this[_f] = f;
        this[_currentExpansion] = dart.const(new (EmptyIteratorOfT())());
        this[_current$] = null;
      }
      get current() {
        return this[_current$];
      }
      moveNext() {
        if (this[_currentExpansion] == null) return false;
        while (!dart.test(this[_currentExpansion].moveNext())) {
          this[_current$] = null;
          if (dart.test(this[_iterator].moveNext())) {
            this[_currentExpansion] = null;
            this[_currentExpansion] = this[_f](this[_iterator].current)[dartx.iterator];
          } else {
            return false;
          }
        }
        this[_current$] = this[_currentExpansion].current;
        return true;
      }
    }
    dart.addTypeTests(ExpandIterator);
    ExpandIterator[dart.implements] = () => [IteratorOfT()];
    dart.setSignature(ExpandIterator, {
      constructors: () => ({new: dart.definiteFunctionType(_internal.ExpandIterator$(S, T), [core.Iterator$(S), dart.functionType(core.Iterable$(T), [S])])}),
      methods: () => ({moveNext: dart.definiteFunctionType(core.bool, [])})
    });
    return ExpandIterator;
  });
  _internal.ExpandIterator = ExpandIterator();
  const _takeCount = Symbol('_takeCount');
  _internal.TakeIterable$ = dart.generic(E => {
    let EfficientLengthTakeIterableOfE = () => (EfficientLengthTakeIterableOfE = dart.constFn(_internal.EfficientLengthTakeIterable$(E)))();
    let TakeIterableOfE = () => (TakeIterableOfE = dart.constFn(_internal.TakeIterable$(E)))();
    let TakeIteratorOfE = () => (TakeIteratorOfE = dart.constFn(_internal.TakeIterator$(E)))();
    class TakeIterable extends core.Iterable$(E) {
      static new(iterable, takeCount) {
        if (!(typeof takeCount == 'number') || dart.notNull(takeCount) < 0) {
          dart.throw(new core.ArgumentError(takeCount));
        }
        if (_internal.EfficientLength.is(iterable)) {
          return new (EfficientLengthTakeIterableOfE())(iterable, takeCount);
        }
        return new (TakeIterableOfE())._(iterable, takeCount);
      }
      _(iterable, takeCount) {
        this[_iterable$] = iterable;
        this[_takeCount] = takeCount;
        super.new();
      }
      get iterator() {
        return new (TakeIteratorOfE())(this[_iterable$][dartx.iterator], this[_takeCount]);
      }
    }
    dart.defineNamedConstructor(TakeIterable, '_');
    dart.setSignature(TakeIterable, {
      constructors: () => ({
        new: dart.definiteFunctionType(_internal.TakeIterable$(E), [core.Iterable$(E), core.int]),
        _: dart.definiteFunctionType(_internal.TakeIterable$(E), [core.Iterable$(E), core.int])
      })
    });
    dart.defineExtensionMembers(TakeIterable, ['iterator']);
    return TakeIterable;
  });
  _internal.TakeIterable = TakeIterable();
  _internal.EfficientLengthTakeIterable$ = dart.generic(E => {
    class EfficientLengthTakeIterable extends _internal.TakeIterable$(E) {
      new(iterable, takeCount) {
        super._(iterable, takeCount);
      }
      get length() {
        let iterableLength = this[_iterable$][dartx.length];
        if (dart.notNull(iterableLength) > dart.notNull(this[_takeCount])) return this[_takeCount];
        return iterableLength;
      }
    }
    EfficientLengthTakeIterable[dart.implements] = () => [_internal.EfficientLength];
    dart.setSignature(EfficientLengthTakeIterable, {
      constructors: () => ({new: dart.definiteFunctionType(_internal.EfficientLengthTakeIterable$(E), [core.Iterable$(E), core.int])})
    });
    dart.defineExtensionMembers(EfficientLengthTakeIterable, ['length']);
    return EfficientLengthTakeIterable;
  });
  _internal.EfficientLengthTakeIterable = EfficientLengthTakeIterable();
  const _remaining = Symbol('_remaining');
  _internal.TakeIterator$ = dart.generic(E => {
    class TakeIterator extends core.Iterator$(E) {
      new(iterator, remaining) {
        this[_iterator] = iterator;
        this[_remaining] = remaining;
        dart.assert(typeof this[_remaining] == 'number' && dart.notNull(this[_remaining]) >= 0);
      }
      moveNext() {
        this[_remaining] = dart.notNull(this[_remaining]) - 1;
        if (dart.notNull(this[_remaining]) >= 0) {
          return this[_iterator].moveNext();
        }
        this[_remaining] = -1;
        return false;
      }
      get current() {
        if (dart.notNull(this[_remaining]) < 0) return null;
        return this[_iterator].current;
      }
    }
    dart.setSignature(TakeIterator, {
      constructors: () => ({new: dart.definiteFunctionType(_internal.TakeIterator$(E), [core.Iterator$(E), core.int])}),
      methods: () => ({moveNext: dart.definiteFunctionType(core.bool, [])})
    });
    return TakeIterator;
  });
  _internal.TakeIterator = TakeIterator();
  _internal.TakeWhileIterable$ = dart.generic(E => {
    let TakeWhileIteratorOfE = () => (TakeWhileIteratorOfE = dart.constFn(_internal.TakeWhileIterator$(E)))();
    class TakeWhileIterable extends core.Iterable$(E) {
      new(iterable, f) {
        this[_iterable$] = iterable;
        this[_f] = f;
        super.new();
      }
      get iterator() {
        return new (TakeWhileIteratorOfE())(this[_iterable$][dartx.iterator], this[_f]);
      }
    }
    dart.setSignature(TakeWhileIterable, {
      constructors: () => ({new: dart.definiteFunctionType(_internal.TakeWhileIterable$(E), [core.Iterable$(E), dart.functionType(core.bool, [E])])})
    });
    dart.defineExtensionMembers(TakeWhileIterable, ['iterator']);
    return TakeWhileIterable;
  });
  _internal.TakeWhileIterable = TakeWhileIterable();
  const _isFinished = Symbol('_isFinished');
  _internal.TakeWhileIterator$ = dart.generic(E => {
    class TakeWhileIterator extends core.Iterator$(E) {
      new(iterator, f) {
        this[_iterator] = iterator;
        this[_f] = f;
        this[_isFinished] = false;
      }
      moveNext() {
        if (dart.test(this[_isFinished])) return false;
        if (!dart.test(this[_iterator].moveNext()) || !dart.test(this[_f](this[_iterator].current))) {
          this[_isFinished] = true;
          return false;
        }
        return true;
      }
      get current() {
        if (dart.test(this[_isFinished])) return null;
        return this[_iterator].current;
      }
    }
    dart.setSignature(TakeWhileIterator, {
      constructors: () => ({new: dart.definiteFunctionType(_internal.TakeWhileIterator$(E), [core.Iterator$(E), dart.functionType(core.bool, [E])])}),
      methods: () => ({moveNext: dart.definiteFunctionType(core.bool, [])})
    });
    return TakeWhileIterator;
  });
  _internal.TakeWhileIterator = TakeWhileIterator();
  const _skipCount = Symbol('_skipCount');
  _internal.SkipIterable$ = dart.generic(E => {
    let EfficientLengthSkipIterableOfE = () => (EfficientLengthSkipIterableOfE = dart.constFn(_internal.EfficientLengthSkipIterable$(E)))();
    let SkipIterableOfE = () => (SkipIterableOfE = dart.constFn(_internal.SkipIterable$(E)))();
    let SkipIteratorOfE = () => (SkipIteratorOfE = dart.constFn(_internal.SkipIterator$(E)))();
    class SkipIterable extends core.Iterable$(E) {
      static new(iterable, count) {
        if (_internal.EfficientLength.is(iterable)) {
          return new (EfficientLengthSkipIterableOfE())(iterable, count);
        }
        return new (SkipIterableOfE())._(iterable, count);
      }
      _(iterable, skipCount) {
        this[_iterable$] = iterable;
        this[_skipCount] = skipCount;
        super.new();
        if (!(typeof this[_skipCount] == 'number')) {
          dart.throw(new core.ArgumentError.value(this[_skipCount], "count is not an integer"));
        }
        core.RangeError.checkNotNegative(this[_skipCount], "count");
      }
      skip(count) {
        if (!(typeof this[_skipCount] == 'number')) {
          dart.throw(new core.ArgumentError.value(this[_skipCount], "count is not an integer"));
        }
        core.RangeError.checkNotNegative(this[_skipCount], "count");
        return new (SkipIterableOfE())._(this[_iterable$], dart.notNull(this[_skipCount]) + dart.notNull(count));
      }
      get iterator() {
        return new (SkipIteratorOfE())(this[_iterable$][dartx.iterator], this[_skipCount]);
      }
    }
    dart.defineNamedConstructor(SkipIterable, '_');
    dart.setSignature(SkipIterable, {
      constructors: () => ({
        new: dart.definiteFunctionType(_internal.SkipIterable$(E), [core.Iterable$(E), core.int]),
        _: dart.definiteFunctionType(_internal.SkipIterable$(E), [core.Iterable$(E), core.int])
      }),
      methods: () => ({skip: dart.definiteFunctionType(core.Iterable$(E), [core.int])})
    });
    dart.defineExtensionMembers(SkipIterable, ['skip', 'iterator']);
    return SkipIterable;
  });
  _internal.SkipIterable = SkipIterable();
  _internal.EfficientLengthSkipIterable$ = dart.generic(E => {
    class EfficientLengthSkipIterable extends _internal.SkipIterable$(E) {
      new(iterable, skipCount) {
        super._(iterable, skipCount);
      }
      get length() {
        let length = dart.notNull(this[_iterable$][dartx.length]) - dart.notNull(this[_skipCount]);
        if (length >= 0) return length;
        return 0;
      }
    }
    EfficientLengthSkipIterable[dart.implements] = () => [_internal.EfficientLength];
    dart.setSignature(EfficientLengthSkipIterable, {
      constructors: () => ({new: dart.definiteFunctionType(_internal.EfficientLengthSkipIterable$(E), [core.Iterable$(E), core.int])})
    });
    dart.defineExtensionMembers(EfficientLengthSkipIterable, ['length']);
    return EfficientLengthSkipIterable;
  });
  _internal.EfficientLengthSkipIterable = EfficientLengthSkipIterable();
  _internal.SkipIterator$ = dart.generic(E => {
    class SkipIterator extends core.Iterator$(E) {
      new(iterator, skipCount) {
        this[_iterator] = iterator;
        this[_skipCount] = skipCount;
        dart.assert(typeof this[_skipCount] == 'number' && dart.notNull(this[_skipCount]) >= 0);
      }
      moveNext() {
        for (let i = 0; i < dart.notNull(this[_skipCount]); i++)
          this[_iterator].moveNext();
        this[_skipCount] = 0;
        return this[_iterator].moveNext();
      }
      get current() {
        return this[_iterator].current;
      }
    }
    dart.setSignature(SkipIterator, {
      constructors: () => ({new: dart.definiteFunctionType(_internal.SkipIterator$(E), [core.Iterator$(E), core.int])}),
      methods: () => ({moveNext: dart.definiteFunctionType(core.bool, [])})
    });
    return SkipIterator;
  });
  _internal.SkipIterator = SkipIterator();
  _internal.SkipWhileIterable$ = dart.generic(E => {
    let SkipWhileIteratorOfE = () => (SkipWhileIteratorOfE = dart.constFn(_internal.SkipWhileIterator$(E)))();
    class SkipWhileIterable extends core.Iterable$(E) {
      new(iterable, f) {
        this[_iterable$] = iterable;
        this[_f] = f;
        super.new();
      }
      get iterator() {
        return new (SkipWhileIteratorOfE())(this[_iterable$][dartx.iterator], this[_f]);
      }
    }
    dart.setSignature(SkipWhileIterable, {
      constructors: () => ({new: dart.definiteFunctionType(_internal.SkipWhileIterable$(E), [core.Iterable$(E), dart.functionType(core.bool, [E])])})
    });
    dart.defineExtensionMembers(SkipWhileIterable, ['iterator']);
    return SkipWhileIterable;
  });
  _internal.SkipWhileIterable = SkipWhileIterable();
  const _hasSkipped = Symbol('_hasSkipped');
  _internal.SkipWhileIterator$ = dart.generic(E => {
    class SkipWhileIterator extends core.Iterator$(E) {
      new(iterator, f) {
        this[_iterator] = iterator;
        this[_f] = f;
        this[_hasSkipped] = false;
      }
      moveNext() {
        if (!dart.test(this[_hasSkipped])) {
          this[_hasSkipped] = true;
          while (dart.test(this[_iterator].moveNext())) {
            if (!dart.test(this[_f](this[_iterator].current))) return true;
          }
        }
        return this[_iterator].moveNext();
      }
      get current() {
        return this[_iterator].current;
      }
    }
    dart.setSignature(SkipWhileIterator, {
      constructors: () => ({new: dart.definiteFunctionType(_internal.SkipWhileIterator$(E), [core.Iterator$(E), dart.functionType(core.bool, [E])])}),
      methods: () => ({moveNext: dart.definiteFunctionType(core.bool, [])})
    });
    return SkipWhileIterator;
  });
  _internal.SkipWhileIterator = SkipWhileIterator();
  _internal.EmptyIterable$ = dart.generic(E => {
    let EmptyIteratorOfE = () => (EmptyIteratorOfE = dart.constFn(_internal.EmptyIterator$(E)))();
    let VoidToE = () => (VoidToE = dart.constFn(dart.functionType(E, [])))();
    let EAndEToE = () => (EAndEToE = dart.constFn(dart.functionType(E, [E, E])))();
    let JSArrayOfE = () => (JSArrayOfE = dart.constFn(_interceptors.JSArray$(E)))();
    let ListOfE = () => (ListOfE = dart.constFn(core.List$(E)))();
    let SetOfE = () => (SetOfE = dart.constFn(core.Set$(E)))();
    class EmptyIterable extends core.Iterable$(E) {
      new() {
        super.new();
      }
      get iterator() {
        return dart.const(new (EmptyIteratorOfE())());
      }
      forEach(action) {}
      get isEmpty() {
        return true;
      }
      get length() {
        return 0;
      }
      get first() {
        dart.throw(_internal.IterableElementError.noElement());
      }
      get last() {
        dart.throw(_internal.IterableElementError.noElement());
      }
      get single() {
        dart.throw(_internal.IterableElementError.noElement());
      }
      elementAt(index) {
        dart.throw(new core.RangeError.range(index, 0, 0, "index"));
      }
      contains(element) {
        return false;
      }
      every(test) {
        return true;
      }
      any(test) {
        return false;
      }
      firstWhere(test, opts) {
        let orElse = opts && 'orElse' in opts ? opts.orElse : null;
        VoidToE()._check(orElse);
        if (orElse != null) return orElse();
        dart.throw(_internal.IterableElementError.noElement());
      }
      lastWhere(test, opts) {
        let orElse = opts && 'orElse' in opts ? opts.orElse : null;
        VoidToE()._check(orElse);
        if (orElse != null) return orElse();
        dart.throw(_internal.IterableElementError.noElement());
      }
      singleWhere(test, opts) {
        let orElse = opts && 'orElse' in opts ? opts.orElse : null;
        VoidToE()._check(orElse);
        if (orElse != null) return orElse();
        dart.throw(_internal.IterableElementError.noElement());
      }
      join(separator) {
        if (separator === void 0) separator = "";
        return "";
      }
      where(test) {
        return this;
      }
      map(T) {
        return f => {
          return dart.const(new (_internal.EmptyIterable$(T))());
        };
      }
      reduce(combine) {
        EAndEToE()._check(combine);
        dart.throw(_internal.IterableElementError.noElement());
      }
      fold(T) {
        return (initialValue, combine) => {
          return initialValue;
        };
      }
      skip(count) {
        core.RangeError.checkNotNegative(count, "count");
        return this;
      }
      skipWhile(test) {
        return this;
      }
      take(count) {
        core.RangeError.checkNotNegative(count, "count");
        return this;
      }
      takeWhile(test) {
        return this;
      }
      toList(opts) {
        let growable = opts && 'growable' in opts ? opts.growable : true;
        return dart.test(growable) ? JSArrayOfE().of([]) : ListOfE().new(0);
      }
      toSet() {
        return SetOfE().new();
      }
    }
    EmptyIterable[dart.implements] = () => [_internal.EfficientLength];
    dart.setSignature(EmptyIterable, {
      constructors: () => ({new: dart.definiteFunctionType(_internal.EmptyIterable$(E), [])}),
      methods: () => ({
        forEach: dart.definiteFunctionType(dart.void, [dart.functionType(dart.void, [E])]),
        elementAt: dart.definiteFunctionType(E, [core.int]),
        every: dart.definiteFunctionType(core.bool, [dart.functionType(core.bool, [E])]),
        any: dart.definiteFunctionType(core.bool, [dart.functionType(core.bool, [E])]),
        firstWhere: dart.definiteFunctionType(E, [dart.functionType(core.bool, [E])], {orElse: VoidToE()}),
        lastWhere: dart.definiteFunctionType(E, [dart.functionType(core.bool, [E])], {orElse: VoidToE()}),
        singleWhere: dart.definiteFunctionType(E, [dart.functionType(core.bool, [E])], {orElse: VoidToE()}),
        where: dart.definiteFunctionType(core.Iterable$(E), [dart.functionType(core.bool, [E])]),
        map: dart.definiteFunctionType(T => [core.Iterable$(T), [dart.functionType(T, [E])]]),
        reduce: dart.definiteFunctionType(E, [dart.functionType(E, [E, E])]),
        fold: dart.definiteFunctionType(T => [T, [T, dart.functionType(T, [T, E])]]),
        skip: dart.definiteFunctionType(core.Iterable$(E), [core.int]),
        skipWhile: dart.definiteFunctionType(core.Iterable$(E), [dart.functionType(core.bool, [E])]),
        take: dart.definiteFunctionType(core.Iterable$(E), [core.int]),
        takeWhile: dart.definiteFunctionType(core.Iterable$(E), [dart.functionType(core.bool, [E])]),
        toList: dart.definiteFunctionType(core.List$(E), [], {growable: core.bool}),
        toSet: dart.definiteFunctionType(core.Set$(E), [])
      })
    });
    dart.defineExtensionMembers(EmptyIterable, [
      'forEach',
      'elementAt',
      'contains',
      'every',
      'any',
      'firstWhere',
      'lastWhere',
      'singleWhere',
      'join',
      'where',
      'map',
      'reduce',
      'fold',
      'skip',
      'skipWhile',
      'take',
      'takeWhile',
      'toList',
      'toSet',
      'iterator',
      'isEmpty',
      'length',
      'first',
      'last',
      'single'
    ]);
    return EmptyIterable;
  });
  _internal.EmptyIterable = EmptyIterable();
  _internal.EmptyIterator$ = dart.generic(E => {
    let IteratorOfE = () => (IteratorOfE = dart.constFn(core.Iterator$(E)))();
    class EmptyIterator extends core.Object {
      new() {
      }
      moveNext() {
        return false;
      }
      get current() {
        return null;
      }
    }
    dart.addTypeTests(EmptyIterator);
    EmptyIterator[dart.implements] = () => [IteratorOfE()];
    dart.setSignature(EmptyIterator, {
      constructors: () => ({new: dart.definiteFunctionType(_internal.EmptyIterator$(E), [])}),
      methods: () => ({moveNext: dart.definiteFunctionType(core.bool, [])})
    });
    return EmptyIterator;
  });
  _internal.EmptyIterator = EmptyIterator();
  _internal.IterableElementError = class IterableElementError extends core.Object {
    static noElement() {
      return new core.StateError("No element");
    }
    static tooMany() {
      return new core.StateError("Too many elements");
    }
    static tooFew() {
      return new core.StateError("Too few elements");
    }
  };
  dart.setSignature(_internal.IterableElementError, {
    statics: () => ({
      noElement: dart.definiteFunctionType(core.StateError, []),
      tooMany: dart.definiteFunctionType(core.StateError, []),
      tooFew: dart.definiteFunctionType(core.StateError, [])
    }),
    names: ['noElement', 'tooMany', 'tooFew']
  });
  _internal.FixedLengthListMixin$ = dart.generic(E => {
    let IterableOfE = () => (IterableOfE = dart.constFn(core.Iterable$(E)))();
    dart.defineExtensionNames([
      'length',
      'add',
      'insert',
      'insertAll',
      'addAll',
      'remove',
      'removeWhere',
      'retainWhere',
      'clear',
      'removeAt',
      'removeLast',
      'removeRange',
      'replaceRange'
    ]);
    class FixedLengthListMixin extends core.Object {
      set length(newLength) {
        dart.throw(new core.UnsupportedError("Cannot change the length of a fixed-length list"));
      }
      add(value) {
        E._check(value);
        dart.throw(new core.UnsupportedError("Cannot add to a fixed-length list"));
      }
      insert(index, value) {
        E._check(value);
        dart.throw(new core.UnsupportedError("Cannot add to a fixed-length list"));
      }
      insertAll(at, iterable) {
        IterableOfE()._check(iterable);
        dart.throw(new core.UnsupportedError("Cannot add to a fixed-length list"));
      }
      addAll(iterable) {
        IterableOfE()._check(iterable);
        dart.throw(new core.UnsupportedError("Cannot add to a fixed-length list"));
      }
      remove(element) {
        dart.throw(new core.UnsupportedError("Cannot remove from a fixed-length list"));
      }
      removeWhere(test) {
        dart.throw(new core.UnsupportedError("Cannot remove from a fixed-length list"));
      }
      retainWhere(test) {
        dart.throw(new core.UnsupportedError("Cannot remove from a fixed-length list"));
      }
      clear() {
        dart.throw(new core.UnsupportedError("Cannot clear a fixed-length list"));
      }
      removeAt(index) {
        dart.throw(new core.UnsupportedError("Cannot remove from a fixed-length list"));
      }
      removeLast() {
        dart.throw(new core.UnsupportedError("Cannot remove from a fixed-length list"));
      }
      removeRange(start, end) {
        dart.throw(new core.UnsupportedError("Cannot remove from a fixed-length list"));
      }
      replaceRange(start, end, iterable) {
        IterableOfE()._check(iterable);
        dart.throw(new core.UnsupportedError("Cannot remove from a fixed-length list"));
      }
    }
    dart.addTypeTests(FixedLengthListMixin);
    dart.setSignature(FixedLengthListMixin, {
      methods: () => ({
        add: dart.definiteFunctionType(dart.void, [E]),
        insert: dart.definiteFunctionType(dart.void, [core.int, E]),
        insertAll: dart.definiteFunctionType(dart.void, [core.int, core.Iterable$(E)]),
        addAll: dart.definiteFunctionType(dart.void, [core.Iterable$(E)]),
        remove: dart.definiteFunctionType(core.bool, [core.Object]),
        removeWhere: dart.definiteFunctionType(dart.void, [dart.functionType(core.bool, [E])]),
        retainWhere: dart.definiteFunctionType(dart.void, [dart.functionType(core.bool, [E])]),
        clear: dart.definiteFunctionType(dart.void, []),
        removeAt: dart.definiteFunctionType(E, [core.int]),
        removeLast: dart.definiteFunctionType(E, []),
        removeRange: dart.definiteFunctionType(dart.void, [core.int, core.int]),
        replaceRange: dart.definiteFunctionType(dart.void, [core.int, core.int, core.Iterable$(E)])
      })
    });
    dart.defineExtensionMembers(FixedLengthListMixin, [
      'add',
      'insert',
      'insertAll',
      'addAll',
      'remove',
      'removeWhere',
      'retainWhere',
      'clear',
      'removeAt',
      'removeLast',
      'removeRange',
      'replaceRange',
      'length'
    ]);
    return FixedLengthListMixin;
  });
  _internal.FixedLengthListMixin = FixedLengthListMixin();
  _internal.FixedLengthListBase$ = dart.generic(E => {
    class FixedLengthListBase extends dart.mixin(collection.ListBase$(E), _internal.FixedLengthListMixin$(E)) {
      new() {
        super.new();
      }
    }
    return FixedLengthListBase;
  });
  _internal.FixedLengthListBase = FixedLengthListBase();
  const _backedList = Symbol('_backedList');
  _internal._ListIndicesIterable = class _ListIndicesIterable extends _internal.ListIterable$(core.int) {
    new(backedList) {
      this[_backedList] = backedList;
      super.new();
    }
    get length() {
      return this[_backedList][dartx.length];
    }
    elementAt(index) {
      core.RangeError.checkValidIndex(index, this);
      return index;
    }
  };
  dart.addSimpleTypeTests(_internal._ListIndicesIterable);
  dart.setSignature(_internal._ListIndicesIterable, {
    constructors: () => ({new: dart.definiteFunctionType(_internal._ListIndicesIterable, [core.List])}),
    methods: () => ({elementAt: dart.definiteFunctionType(core.int, [core.int])})
  });
  dart.defineExtensionMembers(_internal._ListIndicesIterable, ['elementAt', 'length']);
  const _values = Symbol('_values');
  _internal.ListMapView$ = dart.generic(E => {
    let SubListIterableOfE = () => (SubListIterableOfE = dart.constFn(_internal.SubListIterable$(E)))();
    let VoidToE = () => (VoidToE = dart.constFn(dart.functionType(E, [])))();
    let MapOfint$E = () => (MapOfint$E = dart.constFn(core.Map$(core.int, E)))();
    class ListMapView extends core.Object {
      new(values) {
        this[_values] = values;
      }
      get(key) {
        return dart.test(this.containsKey(key)) ? this[_values][dartx.get](core.int._check(key)) : null;
      }
      get length() {
        return this[_values][dartx.length];
      }
      get values() {
        return new (SubListIterableOfE())(this[_values], 0, null);
      }
      get keys() {
        return new _internal._ListIndicesIterable(this[_values]);
      }
      get isEmpty() {
        return this[_values][dartx.isEmpty];
      }
      get isNotEmpty() {
        return this[_values][dartx.isNotEmpty];
      }
      containsValue(value) {
        return this[_values][dartx.contains](value);
      }
      containsKey(key) {
        return typeof key == 'number' && dart.notNull(key) >= 0 && dart.notNull(key) < dart.notNull(this.length);
      }
      forEach(f) {
        let length = this[_values][dartx.length];
        for (let i = 0; i < dart.notNull(length); i++) {
          f(i, this[_values][dartx.get](i));
          if (length != this[_values][dartx.length]) {
            dart.throw(new core.ConcurrentModificationError(this[_values]));
          }
        }
      }
      set(key, value) {
        E._check(value);
        dart.throw(new core.UnsupportedError("Cannot modify an unmodifiable map"));
        return value;
      }
      putIfAbsent(key, ifAbsent) {
        VoidToE()._check(ifAbsent);
        dart.throw(new core.UnsupportedError("Cannot modify an unmodifiable map"));
      }
      remove(key) {
        dart.throw(new core.UnsupportedError("Cannot modify an unmodifiable map"));
      }
      clear() {
        dart.throw(new core.UnsupportedError("Cannot modify an unmodifiable map"));
      }
      addAll(other) {
        MapOfint$E()._check(other);
        dart.throw(new core.UnsupportedError("Cannot modify an unmodifiable map"));
      }
      toString() {
        return collection.Maps.mapToString(this);
      }
    }
    dart.addTypeTests(ListMapView);
    ListMapView[dart.implements] = () => [MapOfint$E()];
    dart.setSignature(ListMapView, {
      constructors: () => ({new: dart.definiteFunctionType(_internal.ListMapView$(E), [core.List$(E)])}),
      methods: () => ({
        get: dart.definiteFunctionType(E, [core.Object]),
        containsValue: dart.definiteFunctionType(core.bool, [core.Object]),
        containsKey: dart.definiteFunctionType(core.bool, [core.Object]),
        forEach: dart.definiteFunctionType(dart.void, [dart.functionType(dart.void, [core.int, E])]),
        set: dart.definiteFunctionType(dart.void, [core.int, E]),
        putIfAbsent: dart.definiteFunctionType(E, [core.int, dart.functionType(E, [])]),
        remove: dart.definiteFunctionType(E, [core.Object]),
        clear: dart.definiteFunctionType(dart.void, []),
        addAll: dart.definiteFunctionType(dart.void, [core.Map$(core.int, E)])
      })
    });
    dart.defineExtensionMembers(ListMapView, [
      'get',
      'containsValue',
      'containsKey',
      'forEach',
      'set',
      'putIfAbsent',
      'remove',
      'clear',
      'addAll',
      'length',
      'values',
      'keys',
      'isEmpty',
      'isNotEmpty'
    ]);
    return ListMapView;
  });
  _internal.ListMapView = ListMapView();
  _internal.ReversedListIterable$ = dart.generic(E => {
    class ReversedListIterable extends _internal.ListIterable$(E) {
      new(source) {
        this[_source] = source;
        super.new();
      }
      get length() {
        return this[_source][dartx.length];
      }
      elementAt(index) {
        return this[_source][dartx.elementAt](dart.notNull(this[_source][dartx.length]) - 1 - dart.notNull(index));
      }
    }
    dart.setSignature(ReversedListIterable, {
      constructors: () => ({new: dart.definiteFunctionType(_internal.ReversedListIterable$(E), [core.Iterable$(E)])}),
      methods: () => ({elementAt: dart.definiteFunctionType(E, [core.int])})
    });
    dart.defineExtensionMembers(ReversedListIterable, ['elementAt', 'length']);
    return ReversedListIterable;
  });
  _internal.ReversedListIterable = ReversedListIterable();
  _internal.UnmodifiableListError = class UnmodifiableListError extends core.Object {
    static add() {
      return new core.UnsupportedError("Cannot add to unmodifiable List");
    }
    static change() {
      return new core.UnsupportedError("Cannot change the content of an unmodifiable List");
    }
    static length() {
      return new core.UnsupportedError("Cannot change length of unmodifiable List");
    }
    static remove() {
      return new core.UnsupportedError("Cannot remove from unmodifiable List");
    }
  };
  dart.setSignature(_internal.UnmodifiableListError, {
    statics: () => ({
      add: dart.definiteFunctionType(core.UnsupportedError, []),
      change: dart.definiteFunctionType(core.UnsupportedError, []),
      length: dart.definiteFunctionType(core.UnsupportedError, []),
      remove: dart.definiteFunctionType(core.UnsupportedError, [])
    }),
    names: ['add', 'change', 'length', 'remove']
  });
  _internal.NonGrowableListError = class NonGrowableListError extends core.Object {
    static add() {
      return new core.UnsupportedError("Cannot add to non-growable List");
    }
    static length() {
      return new core.UnsupportedError("Cannot change length of non-growable List");
    }
    static remove() {
      return new core.UnsupportedError("Cannot remove from non-growable List");
    }
  };
  dart.setSignature(_internal.NonGrowableListError, {
    statics: () => ({
      add: dart.definiteFunctionType(core.UnsupportedError, []),
      length: dart.definiteFunctionType(core.UnsupportedError, []),
      remove: dart.definiteFunctionType(core.UnsupportedError, [])
    }),
    names: ['add', 'length', 'remove']
  });
  _internal.makeListFixedLength = function(E) {
    return growableList => {
      _interceptors.JSArray.markFixedList(growableList);
      return growableList;
    };
  };
  dart.lazyFn(_internal.makeListFixedLength, () => ListOfEToListOfE());
  _internal.makeFixedListUnmodifiable = function(E) {
    return fixedLengthList => {
      _interceptors.JSArray.markUnmodifiableList(fixedLengthList);
      return fixedLengthList;
    };
  };
  dart.lazyFn(_internal.makeFixedListUnmodifiable, () => ListOfEToListOfE());
  _internal.Lists = class Lists extends core.Object {
    static copy(src, srcStart, dst, dstStart, count) {
      if (dart.notNull(srcStart) < dart.notNull(dstStart)) {
        for (let i = dart.notNull(srcStart) + dart.notNull(count) - 1, j = dart.notNull(dstStart) + dart.notNull(count) - 1; i >= dart.notNull(srcStart); i--, j--) {
          dst[dartx.set](j, src[dartx.get](i));
        }
      } else {
        for (let i = srcStart, j = dstStart; dart.notNull(i) < dart.notNull(srcStart) + dart.notNull(count); i = dart.notNull(i) + 1, j = dart.notNull(j) + 1) {
          dst[dartx.set](j, src[dartx.get](i));
        }
      }
    }
    static areEqual(a, b) {
      if (core.identical(a, b)) return true;
      if (!core.List.is(b)) return false;
      let length = a[dartx.length];
      if (!dart.equals(length, dart.dload(b, 'length'))) return false;
      for (let i = 0; i < dart.notNull(length); i++) {
        if (!core.identical(a[dartx.get](i), dart.dindex(b, i))) return false;
      }
      return true;
    }
    static indexOf(a, element, startIndex, endIndex) {
      if (dart.notNull(startIndex) >= dart.notNull(a[dartx.length])) {
        return -1;
      }
      if (dart.notNull(startIndex) < 0) {
        startIndex = 0;
      }
      for (let i = startIndex; dart.notNull(i) < dart.notNull(endIndex); i = dart.notNull(i) + 1) {
        if (dart.equals(a[dartx.get](i), element)) {
          return i;
        }
      }
      return -1;
    }
    static lastIndexOf(a, element, startIndex) {
      if (dart.notNull(startIndex) < 0) {
        return -1;
      }
      if (dart.notNull(startIndex) >= dart.notNull(a[dartx.length])) {
        startIndex = dart.notNull(a[dartx.length]) - 1;
      }
      for (let i = startIndex; dart.notNull(i) >= 0; i = dart.notNull(i) - 1) {
        if (dart.equals(a[dartx.get](i), element)) {
          return i;
        }
      }
      return -1;
    }
    static indicesCheck(a, start, end) {
      core.RangeError.checkValidRange(start, end, a[dartx.length]);
    }
    static rangeCheck(a, start, length) {
      core.RangeError.checkNotNegative(length);
      core.RangeError.checkNotNegative(start);
      if (dart.notNull(start) + dart.notNull(length) > dart.notNull(a[dartx.length])) {
        let message = dart.str`${start} + ${length} must be in the range [0..${a[dartx.length]}]`;
        dart.throw(new core.RangeError.range(length, 0, dart.notNull(a[dartx.length]) - dart.notNull(start), "length", message));
      }
    }
  };
  dart.setSignature(_internal.Lists, {
    statics: () => ({
      copy: dart.definiteFunctionType(dart.void, [core.List, core.int, core.List, core.int, core.int]),
      areEqual: dart.definiteFunctionType(core.bool, [core.List, dart.dynamic]),
      indexOf: dart.definiteFunctionType(core.int, [core.List, core.Object, core.int, core.int]),
      lastIndexOf: dart.definiteFunctionType(core.int, [core.List, core.Object, core.int]),
      indicesCheck: dart.definiteFunctionType(dart.void, [core.List, core.int, core.int]),
      rangeCheck: dart.definiteFunctionType(dart.void, [core.List, core.int, core.int])
    }),
    names: ['copy', 'areEqual', 'indexOf', 'lastIndexOf', 'indicesCheck', 'rangeCheck']
  });
  _internal.printToZone = null;
  _internal.printToConsole = function(line) {
    _js_primitives.printString(dart.str`${line}`);
  };
  dart.lazyFn(_internal.printToConsole, () => StringTovoid());
  _internal.Sort = class Sort extends core.Object {
    static sort(E) {
      return (a, compare) => {
        _internal.Sort._doSort(E)(a, 0, dart.notNull(a[dartx.length]) - 1, compare);
      };
    }
    static sortRange(E) {
      return (a, from, to, compare) => {
        if (dart.notNull(from) < 0 || dart.notNull(to) > dart.notNull(a[dartx.length]) || dart.notNull(to) < dart.notNull(from)) {
          dart.throw("OutOfRange");
        }
        _internal.Sort._doSort(E)(a, from, dart.notNull(to) - 1, compare);
      };
    }
    static _doSort(E) {
      return (a, left, right, compare) => {
        if (dart.notNull(right) - dart.notNull(left) <= _internal.Sort._INSERTION_SORT_THRESHOLD) {
          _internal.Sort._insertionSort(E)(a, left, right, compare);
        } else {
          _internal.Sort._dualPivotQuicksort(E)(a, left, right, compare);
        }
      };
    }
    static _insertionSort(E) {
      return (a, left, right, compare) => {
        for (let i = dart.notNull(left) + 1; i <= dart.notNull(right); i++) {
          let el = a[dartx.get](i);
          let j = i;
          while (j > dart.notNull(left) && dart.notNull(compare(a[dartx.get](j - 1), el)) > 0) {
            a[dartx.set](j, a[dartx.get](j - 1));
            j--;
          }
          a[dartx.set](j, el);
        }
      };
    }
    static _dualPivotQuicksort(E) {
      return (a, left, right, compare) => {
        dart.assert(dart.notNull(right) - dart.notNull(left) > _internal.Sort._INSERTION_SORT_THRESHOLD);
        let sixth = ((dart.notNull(right) - dart.notNull(left) + 1) / 6)[dartx.truncate]();
        let index1 = dart.notNull(left) + sixth;
        let index5 = dart.notNull(right) - sixth;
        let index3 = ((dart.notNull(left) + dart.notNull(right)) / 2)[dartx.truncate]();
        let index2 = index3 - sixth;
        let index4 = index3 + sixth;
        let el1 = a[dartx.get](index1);
        let el2 = a[dartx.get](index2);
        let el3 = a[dartx.get](index3);
        let el4 = a[dartx.get](index4);
        let el5 = a[dartx.get](index5);
        if (dart.notNull(compare(el1, el2)) > 0) {
          let t = el1;
          el1 = el2;
          el2 = t;
        }
        if (dart.notNull(compare(el4, el5)) > 0) {
          let t = el4;
          el4 = el5;
          el5 = t;
        }
        if (dart.notNull(compare(el1, el3)) > 0) {
          let t = el1;
          el1 = el3;
          el3 = t;
        }
        if (dart.notNull(compare(el2, el3)) > 0) {
          let t = el2;
          el2 = el3;
          el3 = t;
        }
        if (dart.notNull(compare(el1, el4)) > 0) {
          let t = el1;
          el1 = el4;
          el4 = t;
        }
        if (dart.notNull(compare(el3, el4)) > 0) {
          let t = el3;
          el3 = el4;
          el4 = t;
        }
        if (dart.notNull(compare(el2, el5)) > 0) {
          let t = el2;
          el2 = el5;
          el5 = t;
        }
        if (dart.notNull(compare(el2, el3)) > 0) {
          let t = el2;
          el2 = el3;
          el3 = t;
        }
        if (dart.notNull(compare(el4, el5)) > 0) {
          let t = el4;
          el4 = el5;
          el5 = t;
        }
        let pivot1 = el2;
        let pivot2 = el4;
        a[dartx.set](index1, el1);
        a[dartx.set](index3, el3);
        a[dartx.set](index5, el5);
        a[dartx.set](index2, a[dartx.get](left));
        a[dartx.set](index4, a[dartx.get](right));
        let less = dart.notNull(left) + 1;
        let great = dart.notNull(right) - 1;
        let pivots_are_equal = compare(pivot1, pivot2) == 0;
        if (pivots_are_equal) {
          let pivot = pivot1;
          for (let k = less; k <= great; k++) {
            let ak = a[dartx.get](k);
            let comp = compare(ak, pivot);
            if (comp == 0) continue;
            if (dart.notNull(comp) < 0) {
              if (k != less) {
                a[dartx.set](k, a[dartx.get](less));
                a[dartx.set](less, ak);
              }
              less++;
            } else {
              while (true) {
                comp = compare(a[dartx.get](great), pivot);
                if (dart.notNull(comp) > 0) {
                  great--;
                  continue;
                } else if (dart.notNull(comp) < 0) {
                  a[dartx.set](k, a[dartx.get](less));
                  a[dartx.set](less++, a[dartx.get](great));
                  a[dartx.set](great--, ak);
                  break;
                } else {
                  a[dartx.set](k, a[dartx.get](great));
                  a[dartx.set](great--, ak);
                  break;
                }
              }
            }
          }
        } else {
          for (let k = less; k <= great; k++) {
            let ak = a[dartx.get](k);
            let comp_pivot1 = compare(ak, pivot1);
            if (dart.notNull(comp_pivot1) < 0) {
              if (k != less) {
                a[dartx.set](k, a[dartx.get](less));
                a[dartx.set](less, ak);
              }
              less++;
            } else {
              let comp_pivot2 = compare(ak, pivot2);
              if (dart.notNull(comp_pivot2) > 0) {
                while (true) {
                  let comp = compare(a[dartx.get](great), pivot2);
                  if (dart.notNull(comp) > 0) {
                    great--;
                    if (great < k) break;
                    continue;
                  } else {
                    comp = compare(a[dartx.get](great), pivot1);
                    if (dart.notNull(comp) < 0) {
                      a[dartx.set](k, a[dartx.get](less));
                      a[dartx.set](less++, a[dartx.get](great));
                      a[dartx.set](great--, ak);
                    } else {
                      a[dartx.set](k, a[dartx.get](great));
                      a[dartx.set](great--, ak);
                    }
                    break;
                  }
                }
              }
            }
          }
        }
        a[dartx.set](left, a[dartx.get](less - 1));
        a[dartx.set](less - 1, pivot1);
        a[dartx.set](right, a[dartx.get](great + 1));
        a[dartx.set](great + 1, pivot2);
        _internal.Sort._doSort(E)(a, left, less - 2, compare);
        _internal.Sort._doSort(E)(a, great + 2, right, compare);
        if (pivots_are_equal) {
          return;
        }
        if (less < index1 && great > index5) {
          while (compare(a[dartx.get](less), pivot1) == 0) {
            less++;
          }
          while (compare(a[dartx.get](great), pivot2) == 0) {
            great--;
          }
          for (let k = less; k <= great; k++) {
            let ak = a[dartx.get](k);
            let comp_pivot1 = compare(ak, pivot1);
            if (comp_pivot1 == 0) {
              if (k != less) {
                a[dartx.set](k, a[dartx.get](less));
                a[dartx.set](less, ak);
              }
              less++;
            } else {
              let comp_pivot2 = compare(ak, pivot2);
              if (comp_pivot2 == 0) {
                while (true) {
                  let comp = compare(a[dartx.get](great), pivot2);
                  if (comp == 0) {
                    great--;
                    if (great < k) break;
                    continue;
                  } else {
                    comp = compare(a[dartx.get](great), pivot1);
                    if (dart.notNull(comp) < 0) {
                      a[dartx.set](k, a[dartx.get](less));
                      a[dartx.set](less++, a[dartx.get](great));
                      a[dartx.set](great--, ak);
                    } else {
                      a[dartx.set](k, a[dartx.get](great));
                      a[dartx.set](great--, ak);
                    }
                    break;
                  }
                }
              }
            }
          }
          _internal.Sort._doSort(E)(a, less, great, compare);
        } else {
          _internal.Sort._doSort(E)(a, less, great, compare);
        }
      };
    }
  };
  dart.setSignature(_internal.Sort, {
    statics: () => ({
      sort: dart.definiteFunctionType(E => [dart.void, [core.List$(E), dart.functionType(core.int, [E, E])]]),
      sortRange: dart.definiteFunctionType(E => [dart.void, [core.List$(E), core.int, core.int, dart.functionType(core.int, [E, E])]]),
      _doSort: dart.definiteFunctionType(E => [dart.void, [core.List$(E), core.int, core.int, dart.functionType(core.int, [E, E])]]),
      _insertionSort: dart.definiteFunctionType(E => [dart.void, [core.List$(E), core.int, core.int, dart.functionType(core.int, [E, E])]]),
      _dualPivotQuicksort: dart.definiteFunctionType(E => [dart.void, [core.List$(E), core.int, core.int, dart.functionType(core.int, [E, E])]])
    }),
    names: ['sort', 'sortRange', '_doSort', '_insertionSort', '_dualPivotQuicksort']
  });
  _internal.Sort._INSERTION_SORT_THRESHOLD = 32;
  const _name = Symbol('_name');
  _internal.Symbol = class Symbol extends core.Object {
    new(name) {
      this[_name] = name;
    }
    unvalidated(name) {
      this[_name] = name;
    }
    validated(name) {
      this[_name] = _internal.Symbol.validatePublicSymbol(name);
    }
    ['=='](other) {
      return _internal.Symbol.is(other) && this[_name] == other[_name];
    }
    get hashCode() {
      let hash = this._hashCode;
      if (hash != null) return hash;
      let arbitraryPrime = 664597;
      hash = 536870911 & arbitraryPrime * dart.notNull(dart.hashCode(this[_name]));
      this._hashCode = hash;
      return hash;
    }
    toString() {
      return dart.str`Symbol("${this[_name]}")`;
    }
    static getName(symbol) {
      return symbol[_name];
    }
    static validatePublicSymbol(name) {
      if (dart.test(name[dartx.isEmpty]) || dart.test(_internal.Symbol.publicSymbolPattern.hasMatch(name))) return name;
      if (dart.test(name[dartx.startsWith]('_'))) {
        dart.throw(new core.ArgumentError(dart.str`"${name}" is a private identifier`));
      }
      dart.throw(new core.ArgumentError(dart.str`"${name}" is not a valid (qualified) symbol name`));
    }
    static isValidSymbol(name) {
      return dart.test(name[dartx.isEmpty]) || dart.test(_internal.Symbol.symbolPattern.hasMatch(name));
    }
  };
  dart.defineNamedConstructor(_internal.Symbol, 'unvalidated');
  dart.defineNamedConstructor(_internal.Symbol, 'validated');
  _internal.Symbol[dart.implements] = () => [core.Symbol];
  dart.setSignature(_internal.Symbol, {
    constructors: () => ({
      new: dart.definiteFunctionType(_internal.Symbol, [core.String]),
      unvalidated: dart.definiteFunctionType(_internal.Symbol, [core.String]),
      validated: dart.definiteFunctionType(_internal.Symbol, [core.String])
    }),
    methods: () => ({'==': dart.definiteFunctionType(core.bool, [core.Object])}),
    statics: () => ({
      getName: dart.definiteFunctionType(core.String, [_internal.Symbol]),
      validatePublicSymbol: dart.definiteFunctionType(core.String, [core.String]),
      isValidSymbol: dart.definiteFunctionType(core.bool, [core.String])
    }),
    names: ['getName', 'validatePublicSymbol', 'isValidSymbol']
  });
  _internal.Symbol.reservedWordRE = '(?:assert|break|c(?:a(?:se|tch)|lass|on(?:st|tinue))|d(?:efault|o)|' + 'e(?:lse|num|xtends)|f(?:alse|inal(?:ly)?|or)|i[fns]|n(?:ew|ull)|' + 'ret(?:hrow|urn)|s(?:uper|witch)|t(?:h(?:is|row)|r(?:ue|y))|' + 'v(?:ar|oid)|w(?:hile|ith))';
  _internal.Symbol.operatorRE = '(?:[\\-+*/%&|^]|\\[\\]=?|==|~/?|<[<=]?|>[>=]?|unary-)';
  dart.defineLazy(_internal.Symbol, {
    get publicIdentifierRE() {
      return '(?!' + dart.str`${_internal.Symbol.reservedWordRE}` + '\\b(?!\\$))[a-zA-Z$][\\w$]*';
    },
    get identifierRE() {
      return '(?!' + dart.str`${_internal.Symbol.reservedWordRE}` + '\\b(?!\\$))[a-zA-Z$_][\\w$]*';
    },
    get publicSymbolPattern() {
      return core.RegExp.new(dart.str`^(?:${_internal.Symbol.operatorRE}\$|${_internal.Symbol.publicIdentifierRE}(?:=?\$|[.](?!\$)))+?\$`);
    },
    get symbolPattern() {
      return core.RegExp.new(dart.str`^(?:${_internal.Symbol.operatorRE}\$|${_internal.Symbol.identifierRE}(?:=?\$|[.](?!\$)))+?\$`);
    }
  });
  _isolate_helper._callInIsolate = function(isolate, func) {
    let result = isolate.eval(func);
    _isolate_helper._globalState.topEventLoop.run();
    return result;
  };
  dart.lazyFn(_isolate_helper._callInIsolate, () => _IsolateContextAndFunctionTodynamic());
  const _activeJsAsyncCount = Symbol('_activeJsAsyncCount');
  _isolate_helper.enterJsAsync = function() {
    let o = _isolate_helper._globalState.topEventLoop;
    o[_activeJsAsyncCount] = dart.notNull(o[_activeJsAsyncCount]) + 1;
  };
  dart.fn(_isolate_helper.enterJsAsync, VoidTodynamic$());
  _isolate_helper.leaveJsAsync = function() {
    let o = _isolate_helper._globalState.topEventLoop;
    o[_activeJsAsyncCount] = dart.notNull(o[_activeJsAsyncCount]) - 1;
    dart.assert(dart.notNull(_isolate_helper._globalState.topEventLoop[_activeJsAsyncCount]) >= 0);
  };
  dart.fn(_isolate_helper.leaveJsAsync, VoidTodynamic$());
  _isolate_helper.isWorker = function() {
    return _isolate_helper._globalState.isWorker;
  };
  dart.lazyFn(_isolate_helper.isWorker, () => VoidTobool());
  _isolate_helper._currentIsolate = function() {
    return _isolate_helper._globalState.currentContext;
  };
  dart.lazyFn(_isolate_helper._currentIsolate, () => VoidTo_IsolateContext());
  _isolate_helper.startRootIsolate = function(entry, args) {
    args = args;
    if (args == null) args = [];
    if (!core.List.is(args)) {
      dart.throw(new core.ArgumentError(dart.str`Arguments to main must be a List: ${args}`));
    }
    _isolate_helper._globalState = new _isolate_helper._Manager(core.Function._check(entry));
    if (dart.test(_isolate_helper._globalState.isWorker)) return;
    let rootContext = new _isolate_helper._IsolateContext();
    _isolate_helper._globalState.rootContext = rootContext;
    _isolate_helper._globalState.currentContext = rootContext;
    if (_isolate_helper._MainFunctionArgs.is(entry)) {
      rootContext.eval(dart.fn(() => {
        dart.dcall(entry, args);
      }, VoidTodynamic$()));
    } else if (_isolate_helper._MainFunctionArgsMessage.is(entry)) {
      rootContext.eval(dart.fn(() => {
        dart.dcall(entry, args, null);
      }, VoidTodynamic$()));
    } else {
      rootContext.eval(core.Function._check(entry));
    }
    _isolate_helper._globalState.topEventLoop.run();
  };
  dart.fn(_isolate_helper.startRootIsolate, dynamicAnddynamicTovoid());
  dart.copyProperties(_isolate_helper, {
    get _globalState() {
      return dart.globalState;
    },
    set _globalState(val) {
      dart.globalState = val;
    }
  });
  const _nativeDetectEnvironment = Symbol('_nativeDetectEnvironment');
  const _nativeInitWorkerMessageHandler = Symbol('_nativeInitWorkerMessageHandler');
  _isolate_helper._Manager = class _Manager extends core.Object {
    get useWorkers() {
      return this.supportsWorkers;
    }
    new(entry) {
      this.entry = entry;
      this.nextIsolateId = 0;
      this.currentManagerId = 0;
      this.nextManagerId = 1;
      this.currentContext = null;
      this.rootContext = null;
      this.topEventLoop = null;
      this.fromCommandLine = null;
      this.isWorker = null;
      this.supportsWorkers = null;
      this.isolates = null;
      this.mainManager = null;
      this.managers = null;
      this[_nativeDetectEnvironment]();
      this.topEventLoop = new _isolate_helper._EventLoop();
      this.isolates = MapOfint$_IsolateContext().new();
      this.managers = MapOfint$dynamic().new();
      if (dart.test(this.isWorker)) {
        this.mainManager = new _isolate_helper._MainManagerStub();
        this[_nativeInitWorkerMessageHandler]();
      }
    }
    [_nativeDetectEnvironment]() {
      let isWindowDefined = _isolate_helper.globalWindow != null;
      let isWorkerDefined = _isolate_helper.globalWorker != null;
      this.isWorker = !isWindowDefined && dart.test(_isolate_helper.globalPostMessageDefined);
      this.supportsWorkers = dart.test(this.isWorker) || isWorkerDefined && _isolate_helper.IsolateNatives.thisScript != null;
      this.fromCommandLine = !isWindowDefined && !dart.test(this.isWorker);
    }
    [_nativeInitWorkerMessageHandler]() {
      let func = (function(f, a) {
        return function(e) {
          f(a, e);
        };
      })(_isolate_helper.IsolateNatives._processWorkerMessage, this.mainManager);
      self.onmessage = func;
      self.dartPrint = self.dartPrint || (function(serialize) {
        return function(object) {
          if (self.console && self.console.log) {
            self.console.log(object);
          } else {
            self.postMessage(serialize(object));
          }
        };
      })(_isolate_helper._Manager._serializePrintMessage);
    }
    static _serializePrintMessage(object) {
      return _isolate_helper._serializeMessage(dart.map({command: "print", msg: object}));
    }
    maybeCloseWorker() {
      if (dart.test(this.isWorker) && dart.test(this.isolates[dartx.isEmpty]) && this.topEventLoop[_activeJsAsyncCount] == 0) {
        this.mainManager.postMessage(_isolate_helper._serializeMessage(dart.map({command: 'close'})));
      }
    }
  };
  dart.setSignature(_isolate_helper._Manager, {
    constructors: () => ({new: dart.definiteFunctionType(_isolate_helper._Manager, [core.Function])}),
    methods: () => ({
      [_nativeDetectEnvironment]: dart.definiteFunctionType(dart.void, []),
      [_nativeInitWorkerMessageHandler]: dart.definiteFunctionType(dart.void, []),
      maybeCloseWorker: dart.definiteFunctionType(dart.void, [])
    }),
    statics: () => ({_serializePrintMessage: dart.definiteFunctionType(dart.dynamic, [dart.dynamic])}),
    names: ['_serializePrintMessage']
  });
  const _scheduledControlEvents = Symbol('_scheduledControlEvents');
  const _isExecutingEvent = Symbol('_isExecutingEvent');
  const _id = Symbol('_id');
  const _updateGlobalState = Symbol('_updateGlobalState');
  const _setGlobals = Symbol('_setGlobals');
  const _addRegistration = Symbol('_addRegistration');
  const _close = Symbol('_close');
  _isolate_helper._IsolateContext = class _IsolateContext extends core.Object {
    new() {
      this.id = (() => {
        let o = _isolate_helper._globalState, x = o.nextIsolateId;
        o.nextIsolateId = dart.notNull(x) + 1;
        return x;
      })();
      this.ports = MapOfint$RawReceivePortImpl().new();
      this.weakPorts = SetOfint().new();
      this.isolateStatics = _foreign_helper.JS_CREATE_ISOLATE();
      this.controlPort = new _isolate_helper.RawReceivePortImpl._controlPort();
      this.pauseCapability = isolate.Capability.new();
      this.terminateCapability = isolate.Capability.new();
      this.delayedEvents = JSArrayOf_IsolateEvent().of([]);
      this.pauseTokens = SetOfCapability().new();
      this.errorPorts = SetOfSendPort().new();
      this.initialized = false;
      this.isPaused = false;
      this.doneHandlers = null;
      this[_scheduledControlEvents] = null;
      this[_isExecutingEvent] = false;
      this.errorsAreFatal = true;
      this.registerWeak(this.controlPort[_id], this.controlPort);
    }
    addPause(authentification, resume) {
      if (!dart.equals(this.pauseCapability, authentification)) return;
      if (dart.test(this.pauseTokens.add(resume)) && !dart.test(this.isPaused)) {
        this.isPaused = true;
      }
      this[_updateGlobalState]();
    }
    removePause(resume) {
      if (!dart.test(this.isPaused)) return;
      this.pauseTokens.remove(resume);
      if (dart.test(this.pauseTokens.isEmpty)) {
        while (dart.test(this.delayedEvents[dartx.isNotEmpty])) {
          let event = this.delayedEvents[dartx.removeLast]();
          _isolate_helper._globalState.topEventLoop.prequeue(event);
        }
        this.isPaused = false;
      }
      this[_updateGlobalState]();
    }
    addDoneListener(responsePort) {
      if (this.doneHandlers == null) {
        this.doneHandlers = [];
      }
      if (dart.test(dart.dsend(this.doneHandlers, 'contains', responsePort))) return;
      dart.dsend(this.doneHandlers, 'add', responsePort);
    }
    removeDoneListener(responsePort) {
      if (this.doneHandlers == null) return;
      dart.dsend(this.doneHandlers, 'remove', responsePort);
    }
    setErrorsFatal(authentification, errorsAreFatal) {
      if (!dart.equals(this.terminateCapability, authentification)) return;
      this.errorsAreFatal = errorsAreFatal;
    }
    handlePing(responsePort, pingType) {
      if (pingType == isolate.Isolate.IMMEDIATE || pingType == isolate.Isolate.BEFORE_NEXT_EVENT && !dart.test(this[_isExecutingEvent])) {
        responsePort.send(null);
        return;
      }
      function respond() {
        responsePort.send(null);
      }
      dart.fn(respond, VoidTovoid$());
      if (pingType == isolate.Isolate.AS_EVENT) {
        _isolate_helper._globalState.topEventLoop.enqueue(this, respond, "ping");
        return;
      }
      dart.assert(pingType == isolate.Isolate.BEFORE_NEXT_EVENT);
      if (this[_scheduledControlEvents] == null) {
        this[_scheduledControlEvents] = collection.Queue.new();
      }
      dart.dsend(this[_scheduledControlEvents], 'addLast', respond);
    }
    handleKill(authentification, priority) {
      if (!dart.equals(this.terminateCapability, authentification)) return;
      if (priority == isolate.Isolate.IMMEDIATE || priority == isolate.Isolate.BEFORE_NEXT_EVENT && !dart.test(this[_isExecutingEvent])) {
        this.kill();
        return;
      }
      if (priority == isolate.Isolate.AS_EVENT) {
        _isolate_helper._globalState.topEventLoop.enqueue(this, dart.bind(this, 'kill'), "kill");
        return;
      }
      dart.assert(priority == isolate.Isolate.BEFORE_NEXT_EVENT);
      if (this[_scheduledControlEvents] == null) {
        this[_scheduledControlEvents] = collection.Queue.new();
      }
      dart.dsend(this[_scheduledControlEvents], 'addLast', dart.bind(this, 'kill'));
    }
    addErrorListener(port) {
      this.errorPorts.add(port);
    }
    removeErrorListener(port) {
      this.errorPorts.remove(port);
    }
    handleUncaughtError(error, stackTrace) {
      if (dart.test(this.errorPorts.isEmpty)) {
        if (dart.test(this.errorsAreFatal) && core.identical(this, _isolate_helper._globalState.rootContext)) {
          return;
        }
        if (self.console && self.console.error) {
          self.console.error(error, stackTrace);
        } else {
          core.print(error);
          if (stackTrace != null) core.print(stackTrace);
        }
        return;
      }
      let message = core.List.new(2);
      message[dartx.set](0, dart.toString(error));
      message[dartx.set](1, stackTrace == null ? null : dart.toString(stackTrace));
      for (let port of this.errorPorts)
        port.send(message);
    }
    eval(code) {
      let old = _isolate_helper._globalState.currentContext;
      _isolate_helper._globalState.currentContext = this;
      this[_setGlobals]();
      let result = null;
      this[_isExecutingEvent] = true;
      try {
        result = dart.dcall(code);
      } catch (e) {
        let s = dart.stackTrace(e);
        this.handleUncaughtError(e, s);
        if (dart.test(this.errorsAreFatal)) {
          this.kill();
          if (core.identical(this, _isolate_helper._globalState.rootContext)) {
            throw e;
          }
        }
      }
 finally {
        this[_isExecutingEvent] = false;
        _isolate_helper._globalState.currentContext = old;
        if (old != null) old[_setGlobals]();
        if (this[_scheduledControlEvents] != null) {
          while (dart.test(dart.dload(this[_scheduledControlEvents], 'isNotEmpty'))) {
            dart.dcall(dart.dsend(this[_scheduledControlEvents], 'removeFirst'));
          }
        }
      }
      return result;
    }
    [_setGlobals]() {
      _foreign_helper.JS_SET_CURRENT_ISOLATE(this.isolateStatics);
    }
    handleControlMessage(message) {
      switch (dart.dindex(message, 0)) {
        case "pause":
        {
          this.addPause(isolate.Capability._check(dart.dindex(message, 1)), isolate.Capability._check(dart.dindex(message, 2)));
          break;
        }
        case "resume":
        {
          this.removePause(isolate.Capability._check(dart.dindex(message, 1)));
          break;
        }
        case 'add-ondone':
        {
          this.addDoneListener(isolate.SendPort._check(dart.dindex(message, 1)));
          break;
        }
        case 'remove-ondone':
        {
          this.removeDoneListener(isolate.SendPort._check(dart.dindex(message, 1)));
          break;
        }
        case 'set-errors-fatal':
        {
          this.setErrorsFatal(isolate.Capability._check(dart.dindex(message, 1)), core.bool._check(dart.dindex(message, 2)));
          break;
        }
        case "ping":
        {
          this.handlePing(isolate.SendPort._check(dart.dindex(message, 1)), core.int._check(dart.dindex(message, 2)));
          break;
        }
        case "kill":
        {
          this.handleKill(isolate.Capability._check(dart.dindex(message, 1)), core.int._check(dart.dindex(message, 2)));
          break;
        }
        case "getErrors":
        {
          this.addErrorListener(isolate.SendPort._check(dart.dindex(message, 1)));
          break;
        }
        case "stopErrors":
        {
          this.removeErrorListener(isolate.SendPort._check(dart.dindex(message, 1)));
          break;
        }
        default:
      }
    }
    lookup(portId) {
      return this.ports[dartx.get](portId);
    }
    [_addRegistration](portId, port) {
      if (dart.test(this.ports[dartx.containsKey](portId))) {
        dart.throw(core.Exception.new("Registry: ports must be registered only once."));
      }
      this.ports[dartx.set](portId, port);
    }
    register(portId, port) {
      this[_addRegistration](portId, port);
      this[_updateGlobalState]();
    }
    registerWeak(portId, port) {
      this.weakPorts.add(portId);
      this[_addRegistration](portId, port);
    }
    [_updateGlobalState]() {
      if (dart.notNull(this.ports[dartx.length]) - dart.notNull(this.weakPorts.length) > 0 || dart.test(this.isPaused) || !dart.test(this.initialized)) {
        _isolate_helper._globalState.isolates[dartx.set](this.id, this);
      } else {
        this.kill();
      }
    }
    kill() {
      if (this[_scheduledControlEvents] != null) {
        dart.dsend(this[_scheduledControlEvents], 'clear');
      }
      for (let port of this.ports[dartx.values]) {
        port[_close]();
      }
      this.ports[dartx.clear]();
      this.weakPorts.clear();
      _isolate_helper._globalState.isolates[dartx.remove](this.id);
      this.errorPorts.clear();
      if (this.doneHandlers != null) {
        for (let port of core.Iterable._check(this.doneHandlers)) {
          isolate.SendPort._check(port);
          port.send(null);
        }
        this.doneHandlers = null;
      }
    }
    unregister(portId) {
      this.ports[dartx.remove](portId);
      this.weakPorts.remove(portId);
      this[_updateGlobalState]();
    }
  };
  _isolate_helper._IsolateContext[dart.implements] = () => [_foreign_helper.IsolateContext];
  dart.setSignature(_isolate_helper._IsolateContext, {
    constructors: () => ({new: dart.definiteFunctionType(_isolate_helper._IsolateContext, [])}),
    methods: () => ({
      addPause: dart.definiteFunctionType(dart.void, [isolate.Capability, isolate.Capability]),
      removePause: dart.definiteFunctionType(dart.void, [isolate.Capability]),
      addDoneListener: dart.definiteFunctionType(dart.void, [isolate.SendPort]),
      removeDoneListener: dart.definiteFunctionType(dart.void, [isolate.SendPort]),
      setErrorsFatal: dart.definiteFunctionType(dart.void, [isolate.Capability, core.bool]),
      handlePing: dart.definiteFunctionType(dart.void, [isolate.SendPort, core.int]),
      handleKill: dart.definiteFunctionType(dart.void, [isolate.Capability, core.int]),
      addErrorListener: dart.definiteFunctionType(dart.void, [isolate.SendPort]),
      removeErrorListener: dart.definiteFunctionType(dart.void, [isolate.SendPort]),
      handleUncaughtError: dart.definiteFunctionType(dart.void, [dart.dynamic, core.StackTrace]),
      eval: dart.definiteFunctionType(dart.dynamic, [core.Function]),
      [_setGlobals]: dart.definiteFunctionType(dart.void, []),
      handleControlMessage: dart.definiteFunctionType(dart.void, [dart.dynamic]),
      lookup: dart.definiteFunctionType(_isolate_helper.RawReceivePortImpl, [core.int]),
      [_addRegistration]: dart.definiteFunctionType(dart.void, [core.int, _isolate_helper.RawReceivePortImpl]),
      register: dart.definiteFunctionType(dart.void, [core.int, _isolate_helper.RawReceivePortImpl]),
      registerWeak: dart.definiteFunctionType(dart.void, [core.int, _isolate_helper.RawReceivePortImpl]),
      [_updateGlobalState]: dart.definiteFunctionType(dart.void, []),
      kill: dart.definiteFunctionType(dart.void, []),
      unregister: dart.definiteFunctionType(dart.void, [core.int])
    })
  });
  const _runHelper = Symbol('_runHelper');
  _isolate_helper._EventLoop = class _EventLoop extends core.Object {
    new() {
      this.events = QueueOf_IsolateEvent().new();
      this[_activeJsAsyncCount] = 0;
    }
    enqueue(isolate, fn, msg) {
      this.events.addLast(new _isolate_helper._IsolateEvent(_isolate_helper._IsolateContext._check(isolate), core.Function._check(fn), core.String._check(msg)));
    }
    prequeue(event) {
      this.events.addFirst(event);
    }
    dequeue() {
      if (dart.test(this.events.isEmpty)) return null;
      return this.events.removeFirst();
    }
    checkOpenReceivePortsFromCommandLine() {
      if (_isolate_helper._globalState.rootContext != null && dart.test(_isolate_helper._globalState.isolates[dartx.containsKey](_isolate_helper._globalState.rootContext.id)) && dart.test(_isolate_helper._globalState.fromCommandLine) && dart.test(_isolate_helper._globalState.rootContext.ports[dartx.isEmpty])) {
        dart.throw(core.Exception.new("Program exited with open ReceivePorts."));
      }
    }
    runIteration() {
      let event = this.dequeue();
      if (event == null) {
        this.checkOpenReceivePortsFromCommandLine();
        _isolate_helper._globalState.maybeCloseWorker();
        return false;
      }
      event.process();
      return true;
    }
    [_runHelper]() {
      if (_isolate_helper.globalWindow != null) {
        const next = (function() {
          if (!dart.test(this.runIteration())) return;
          async.Timer.run(next);
        }).bind(this);
        dart.fn(next, VoidTodynamic$());
        next();
      } else {
        while (dart.test(this.runIteration())) {
        }
      }
    }
    run() {
      if (!dart.test(_isolate_helper._globalState.isWorker)) {
        this[_runHelper]();
      } else {
        try {
          this[_runHelper]();
        } catch (e) {
          let trace = dart.stackTrace(e);
          _isolate_helper._globalState.mainManager.postMessage(_isolate_helper._serializeMessage(dart.map({command: 'error', msg: dart.str`${e}\n${trace}`})));
        }

      }
    }
  };
  dart.setSignature(_isolate_helper._EventLoop, {
    constructors: () => ({new: dart.definiteFunctionType(_isolate_helper._EventLoop, [])}),
    methods: () => ({
      enqueue: dart.definiteFunctionType(dart.void, [dart.dynamic, dart.dynamic, dart.dynamic]),
      prequeue: dart.definiteFunctionType(dart.void, [_isolate_helper._IsolateEvent]),
      dequeue: dart.definiteFunctionType(_isolate_helper._IsolateEvent, []),
      checkOpenReceivePortsFromCommandLine: dart.definiteFunctionType(dart.void, []),
      runIteration: dart.definiteFunctionType(core.bool, []),
      [_runHelper]: dart.definiteFunctionType(dart.void, []),
      run: dart.definiteFunctionType(dart.void, [])
    })
  });
  _isolate_helper._IsolateEvent = class _IsolateEvent extends core.Object {
    new(isolate, fn, message) {
      this.isolate = isolate;
      this.fn = fn;
      this.message = message;
    }
    process() {
      if (dart.test(this.isolate.isPaused)) {
        this.isolate.delayedEvents[dartx.add](this);
        return;
      }
      this.isolate.eval(this.fn);
    }
  };
  dart.setSignature(_isolate_helper._IsolateEvent, {
    constructors: () => ({new: dart.definiteFunctionType(_isolate_helper._IsolateEvent, [_isolate_helper._IsolateContext, core.Function, core.String])}),
    methods: () => ({process: dart.definiteFunctionType(dart.void, [])})
  });
  dart.defineLazy(_isolate_helper, {
    get _global() {
      return typeof global == 'undefined' ? self : global;
    }
  });
  _isolate_helper._MainManagerStub = class _MainManagerStub extends core.Object {
    postMessage(msg) {
      _isolate_helper._global.postMessage(msg);
    }
  };
  dart.setSignature(_isolate_helper._MainManagerStub, {
    methods: () => ({postMessage: dart.definiteFunctionType(dart.void, [dart.dynamic])})
  });
  _isolate_helper._SPAWNED_SIGNAL = "spawned";
  _isolate_helper._SPAWN_FAILED_SIGNAL = "spawn failed";
  dart.copyProperties(_isolate_helper, {
    get globalWindow() {
      return _isolate_helper._global.window;
    }
  });
  dart.copyProperties(_isolate_helper, {
    get globalWorker() {
      return _isolate_helper._global.Worker;
    }
  });
  dart.copyProperties(_isolate_helper, {
    get globalPostMessageDefined() {
      return !!_isolate_helper._global.postMessage;
    }
  });
  _isolate_helper._MainFunction = dart.typedef('_MainFunction', () => dart.functionType(dart.dynamic, []));
  _isolate_helper._MainFunctionArgs = dart.typedef('_MainFunctionArgs', () => dart.functionType(dart.dynamic, [dart.dynamic]));
  _isolate_helper._MainFunctionArgsMessage = dart.typedef('_MainFunctionArgsMessage', () => dart.functionType(dart.dynamic, [dart.dynamic, dart.dynamic]));
  _isolate_helper.IsolateNatives = class IsolateNatives extends core.Object {
    static computeThisScript() {
      let currentScript = document.currentScript;
      if (currentScript != null) {
        return String(currentScript.src);
      }
      if (dart.test(_js_helper.Primitives.isD8)) return _isolate_helper.IsolateNatives.computeThisScriptD8();
      if (dart.test(_js_helper.Primitives.isJsshell)) return _isolate_helper.IsolateNatives.computeThisScriptJsshell();
      if (_isolate_helper._globalState != null && dart.test(_isolate_helper._globalState.isWorker)) {
        return _isolate_helper.IsolateNatives.computeThisScriptFromTrace();
      }
      return null;
    }
    static computeThisScriptJsshell() {
      return thisFilename();
    }
    static computeThisScriptD8() {
      return _isolate_helper.IsolateNatives.computeThisScriptFromTrace();
    }
    static computeThisScriptFromTrace() {
      let stack = new Error().stack;
      if (stack == null) {
        stack = (function() {
          try {
            throw new Error();
          } catch (e) {
            return e.stack;
          }

        })();
        if (stack == null) dart.throw(new core.UnsupportedError('No stack trace'));
      }
      let pattern = null, matches = null;
      pattern = new RegExp("^ *at [^(]*\\((.*):[0-9]*:[0-9]*\\)$", "m");
      matches = stack.match(pattern);
      if (matches != null) return matches[1];
      pattern = new RegExp("^[^@]*@(.*):[0-9]*$", "m");
      matches = stack.match(pattern);
      if (matches != null) return matches[1];
      dart.throw(new core.UnsupportedError(dart.str`Cannot extract URI from "${stack}"`));
    }
    static _getEventData(e) {
      return e.data;
    }
    static _processWorkerMessage(sender, e) {
      let msg = _isolate_helper._deserializeMessage(_isolate_helper.IsolateNatives._getEventData(e));
      switch (dart.dindex(msg, 'command')) {
        case 'start':
        {
          _isolate_helper._globalState.currentManagerId = core.int._check(dart.dindex(msg, 'id'));
          let functionName = core.String._check(dart.dindex(msg, 'functionName'));
          let entryPoint = core.Function._check(functionName == null ? _isolate_helper._globalState.entry : _isolate_helper.IsolateNatives._getJSFunctionFromName(functionName));
          let args = dart.dindex(msg, 'args');
          let message = _isolate_helper._deserializeMessage(dart.dindex(msg, 'msg'));
          let isSpawnUri = dart.dindex(msg, 'isSpawnUri');
          let startPaused = dart.dindex(msg, 'startPaused');
          let replyTo = _isolate_helper._deserializeMessage(dart.dindex(msg, 'replyTo'));
          let context = new _isolate_helper._IsolateContext();
          _isolate_helper._globalState.topEventLoop.enqueue(context, dart.fn(() => {
            _isolate_helper.IsolateNatives._startIsolate(entryPoint, ListOfString()._check(args), message, core.bool._check(isSpawnUri), core.bool._check(startPaused), isolate.SendPort._check(replyTo));
          }, VoidTodynamic$()), 'worker-start');
          _isolate_helper._globalState.currentContext = context;
          _isolate_helper._globalState.topEventLoop.run();
          break;
        }
        case 'spawn-worker':
        {
          if (_isolate_helper.IsolateNatives.enableSpawnWorker != null) _isolate_helper.IsolateNatives.handleSpawnWorkerRequest(msg);
          break;
        }
        case 'message':
        {
          let port = isolate.SendPort._check(dart.dindex(msg, 'port'));
          if (port != null) {
            dart.dsend(dart.dindex(msg, 'port'), 'send', dart.dindex(msg, 'msg'));
          }
          _isolate_helper._globalState.topEventLoop.run();
          break;
        }
        case 'close':
        {
          _isolate_helper._globalState.managers[dartx.remove](_isolate_helper.IsolateNatives.workerIds.get(sender));
          sender.terminate();
          _isolate_helper._globalState.topEventLoop.run();
          break;
        }
        case 'log':
        {
          _isolate_helper.IsolateNatives._log(dart.dindex(msg, 'msg'));
          break;
        }
        case 'print':
        {
          if (dart.test(_isolate_helper._globalState.isWorker)) {
            _isolate_helper._globalState.mainManager.postMessage(_isolate_helper._serializeMessage(dart.map({command: 'print', msg: msg})));
          } else {
            core.print(dart.dindex(msg, 'msg'));
          }
          break;
        }
        case 'error':
        {
          dart.throw(dart.dindex(msg, 'msg'));
        }
      }
    }
    static handleSpawnWorkerRequest(msg) {
      let replyPort = dart.dindex(msg, 'replyPort');
      _isolate_helper.IsolateNatives.spawn(core.String._check(dart.dindex(msg, 'functionName')), core.String._check(dart.dindex(msg, 'uri')), ListOfString()._check(dart.dindex(msg, 'args')), dart.dindex(msg, 'msg'), false, core.bool._check(dart.dindex(msg, 'isSpawnUri')), core.bool._check(dart.dindex(msg, 'startPaused'))).then(dart.dynamic)(dart.fn(msg => {
        dart.dsend(replyPort, 'send', msg);
      }, ListTodynamic()), {onError: dart.fn(errorMessage => {
          dart.dsend(replyPort, 'send', JSArrayOfString().of([_isolate_helper._SPAWN_FAILED_SIGNAL, errorMessage]));
        }, StringTodynamic())});
    }
    static _log(msg) {
      if (dart.test(_isolate_helper._globalState.isWorker)) {
        _isolate_helper._globalState.mainManager.postMessage(_isolate_helper._serializeMessage(dart.map({command: 'log', msg: msg})));
      } else {
        try {
          _isolate_helper.IsolateNatives._consoleLog(msg);
        } catch (e) {
          let trace = dart.stackTrace(e);
          dart.throw(core.Exception.new(trace));
        }

      }
    }
    static _consoleLog(msg) {
      self.console.log(msg);
    }
    static _getJSFunctionFromName(functionName) {
      let globalFunctionsContainer = _foreign_helper.JS_EMBEDDED_GLOBAL("", _js_embedded_names.GLOBAL_FUNCTIONS);
      return globalFunctionsContainer[functionName]();
    }
    static _getJSFunctionName(f) {
      return f.$name;
    }
    static _allocate(ctor) {
      return new ctor();
    }
    static spawnFunction(topLevelFunction, message, startPaused) {
      _isolate_helper.IsolateNatives.enableSpawnWorker = true;
      let name = _isolate_helper.IsolateNatives._getJSFunctionName(topLevelFunction);
      if (name == null) {
        dart.throw(new core.UnsupportedError("only top-level functions can be spawned."));
      }
      let isLight = false;
      let isSpawnUri = false;
      return _isolate_helper.IsolateNatives.spawn(name, null, null, message, isLight, isSpawnUri, startPaused);
    }
    static spawnUri(uri, args, message, startPaused) {
      _isolate_helper.IsolateNatives.enableSpawnWorker = true;
      let isLight = false;
      let isSpawnUri = true;
      return _isolate_helper.IsolateNatives.spawn(null, dart.toString(uri), args, message, isLight, isSpawnUri, startPaused);
    }
    static spawn(functionName, uri, args, message, isLight, isSpawnUri, startPaused) {
      if (uri != null && dart.test(uri[dartx.endsWith](".dart"))) {
        uri = dart.notNull(uri) + ".js";
      }
      let port = isolate.ReceivePort.new();
      let completer = CompleterOfList().new();
      port.first.then(dart.dynamic)(dart.fn(msg => {
        if (dart.equals(dart.dindex(msg, 0), _isolate_helper._SPAWNED_SIGNAL)) {
          completer.complete(msg);
        } else {
          dart.assert(dart.equals(dart.dindex(msg, 0), _isolate_helper._SPAWN_FAILED_SIGNAL));
          completer.completeError(dart.dindex(msg, 1));
        }
      }, dynamicTodynamic$()));
      let signalReply = port.sendPort;
      if (dart.test(_isolate_helper._globalState.useWorkers) && !dart.test(isLight)) {
        _isolate_helper.IsolateNatives._startWorker(functionName, uri, args, message, isSpawnUri, startPaused, signalReply, dart.fn(message => completer.completeError(message), StringTovoid()));
      } else {
        _isolate_helper.IsolateNatives._startNonWorker(functionName, uri, args, message, isSpawnUri, startPaused, signalReply);
      }
      return completer.future;
    }
    static _startWorker(functionName, uri, args, message, isSpawnUri, startPaused, replyPort, onError) {
      if (args != null) args = ListOfString().from(args);
      if (dart.test(_isolate_helper._globalState.isWorker)) {
        _isolate_helper._globalState.mainManager.postMessage(_isolate_helper._serializeMessage(dart.map({command: 'spawn-worker', functionName: functionName, args: args, msg: message, uri: uri, isSpawnUri: isSpawnUri, startPaused: startPaused, replyPort: replyPort})));
      } else {
        _isolate_helper.IsolateNatives._spawnWorker(functionName, uri, args, message, isSpawnUri, startPaused, replyPort, onError);
      }
    }
    static _startNonWorker(functionName, uri, args, message, isSpawnUri, startPaused, replyPort) {
      if (uri != null) {
        dart.throw(new core.UnsupportedError("Currently spawnUri is not supported without web workers."));
      }
      message = _isolate_helper._clone(message);
      if (args != null) args = ListOfString().from(args);
      _isolate_helper._globalState.topEventLoop.enqueue(new _isolate_helper._IsolateContext(), dart.fn(() => {
        let func = _isolate_helper.IsolateNatives._getJSFunctionFromName(functionName);
        _isolate_helper.IsolateNatives._startIsolate(core.Function._check(func), args, message, isSpawnUri, startPaused, replyPort);
      }, VoidTodynamic$()), 'nonworker start');
    }
    static get currentIsolate() {
      let context = _isolate_helper._IsolateContext._check(_foreign_helper.JS_CURRENT_ISOLATE_CONTEXT());
      return new isolate.Isolate(context.controlPort.sendPort, {pauseCapability: context.pauseCapability, terminateCapability: context.terminateCapability});
    }
    static _startIsolate(topLevel, args, message, isSpawnUri, startPaused, replyTo) {
      let context = _isolate_helper._IsolateContext._check(_foreign_helper.JS_CURRENT_ISOLATE_CONTEXT());
      _js_helper.Primitives.initializeStatics(context.id);
      replyTo.send(JSArrayOfObject().of([_isolate_helper._SPAWNED_SIGNAL, context.controlPort.sendPort, context.pauseCapability, context.terminateCapability]));
      function runStartFunction() {
        context.initialized = true;
        if (!dart.test(isSpawnUri)) {
          dart.dcall(topLevel, message);
        } else if (_isolate_helper._MainFunctionArgsMessage.is(topLevel)) {
          dart.dcall(topLevel, args, message);
        } else if (_isolate_helper._MainFunctionArgs.is(topLevel)) {
          dart.dcall(topLevel, args);
        } else {
          dart.dcall(topLevel);
        }
      }
      dart.fn(runStartFunction, VoidTovoid$());
      if (dart.test(startPaused)) {
        context.addPause(context.pauseCapability, context.pauseCapability);
        _isolate_helper._globalState.topEventLoop.enqueue(context, runStartFunction, 'start isolate');
      } else {
        runStartFunction();
      }
    }
    static _spawnWorker(functionName, uri, args, message, isSpawnUri, startPaused, replyPort, onError) {
      if (uri == null) uri = _isolate_helper.IsolateNatives.thisScript;
      let worker = new Worker(uri);
      let onerrorTrampoline = (function(f, u, c) {
        return function(e) {
          return f(e, u, c);
        };
      })(_isolate_helper.IsolateNatives.workerOnError, uri, onError);
      worker.onerror = onerrorTrampoline;
      let processWorkerMessageTrampoline = (function(f, a) {
        return function(e) {
          e.onerror = null;
          return f(a, e);
        };
      })(_isolate_helper.IsolateNatives._processWorkerMessage, worker);
      worker.onmessage = processWorkerMessageTrampoline;
      let o = _isolate_helper._globalState;
      let workerId = o.nextManagerId;
      o.nextManagerId = dart.notNull(workerId) + 1;
      _isolate_helper.IsolateNatives.workerIds.set(worker, workerId);
      _isolate_helper._globalState.managers[dartx.set](workerId, worker);
      worker.postMessage(_isolate_helper._serializeMessage(dart.map({command: 'start', id: workerId, replyTo: _isolate_helper._serializeMessage(replyPort), args: args, msg: _isolate_helper._serializeMessage(message), isSpawnUri: isSpawnUri, startPaused: startPaused, functionName: functionName})));
    }
    static workerOnError(event, uri, onError) {
      event.preventDefault();
      let message = event.message;
      if (message == null) {
        message = dart.str`Error spawning worker for ${uri}`;
      } else {
        message = dart.str`Error spawning worker for ${uri} (${message})`;
      }
      onError(message);
      return true;
    }
  };
  dart.setSignature(_isolate_helper.IsolateNatives, {
    statics: () => ({
      computeThisScript: dart.definiteFunctionType(core.String, []),
      computeThisScriptJsshell: dart.definiteFunctionType(core.String, []),
      computeThisScriptD8: dart.definiteFunctionType(core.String, []),
      computeThisScriptFromTrace: dart.definiteFunctionType(core.String, []),
      _getEventData: dart.definiteFunctionType(dart.dynamic, [dart.dynamic]),
      _processWorkerMessage: dart.definiteFunctionType(dart.void, [dart.dynamic, dart.dynamic]),
      handleSpawnWorkerRequest: dart.definiteFunctionType(dart.dynamic, [dart.dynamic]),
      _log: dart.definiteFunctionType(dart.dynamic, [dart.dynamic]),
      _consoleLog: dart.definiteFunctionType(dart.void, [dart.dynamic]),
      _getJSFunctionFromName: dart.definiteFunctionType(dart.dynamic, [core.String]),
      _getJSFunctionName: dart.definiteFunctionType(core.String, [core.Function]),
      _allocate: dart.definiteFunctionType(dart.dynamic, [dart.dynamic]),
      spawnFunction: dart.definiteFunctionType(async.Future$(core.List), [dart.functionType(dart.void, [dart.dynamic]), dart.dynamic, core.bool]),
      spawnUri: dart.definiteFunctionType(async.Future$(core.List), [core.Uri, core.List$(core.String), dart.dynamic, core.bool]),
      spawn: dart.definiteFunctionType(async.Future$(core.List), [core.String, core.String, core.List$(core.String), dart.dynamic, core.bool, core.bool, core.bool]),
      _startWorker: dart.definiteFunctionType(dart.void, [core.String, core.String, core.List$(core.String), dart.dynamic, core.bool, core.bool, isolate.SendPort, dart.functionType(dart.void, [core.String])]),
      _startNonWorker: dart.definiteFunctionType(dart.void, [core.String, core.String, core.List$(core.String), dart.dynamic, core.bool, core.bool, isolate.SendPort]),
      _startIsolate: dart.definiteFunctionType(dart.void, [core.Function, core.List$(core.String), dart.dynamic, core.bool, core.bool, isolate.SendPort]),
      _spawnWorker: dart.definiteFunctionType(dart.void, [dart.dynamic, core.String, core.List$(core.String), dart.dynamic, core.bool, core.bool, isolate.SendPort, dart.functionType(dart.void, [core.String])]),
      workerOnError: dart.definiteFunctionType(core.bool, [dart.dynamic, core.String, dart.functionType(dart.void, [core.String])])
    }),
    names: ['computeThisScript', 'computeThisScriptJsshell', 'computeThisScriptD8', 'computeThisScriptFromTrace', '_getEventData', '_processWorkerMessage', 'handleSpawnWorkerRequest', '_log', '_consoleLog', '_getJSFunctionFromName', '_getJSFunctionName', '_allocate', 'spawnFunction', 'spawnUri', 'spawn', '_startWorker', '_startNonWorker', '_startIsolate', '_spawnWorker', 'workerOnError']
  });
  _isolate_helper.IsolateNatives.enableSpawnWorker = null;
  dart.defineLazy(_isolate_helper.IsolateNatives, {
    get thisScript() {
      return _isolate_helper.IsolateNatives.computeThisScript();
    },
    set thisScript(_) {},
    get workerIds() {
      return new (ExpandoOfint())();
    }
  });
  const _isolateId = Symbol('_isolateId');
  const _checkReplyTo = Symbol('_checkReplyTo');
  _isolate_helper._BaseSendPort = class _BaseSendPort extends core.Object {
    new(isolateId) {
      this[_isolateId] = isolateId;
    }
    [_checkReplyTo](replyTo) {
      if (replyTo != null && !_isolate_helper._NativeJsSendPort.is(replyTo) && !_isolate_helper._WorkerSendPort.is(replyTo)) {
        dart.throw(core.Exception.new("SendPort.send: Illegal replyTo port type"));
      }
    }
  };
  _isolate_helper._BaseSendPort[dart.implements] = () => [isolate.SendPort];
  dart.setSignature(_isolate_helper._BaseSendPort, {
    constructors: () => ({new: dart.definiteFunctionType(_isolate_helper._BaseSendPort, [core.int])}),
    methods: () => ({[_checkReplyTo]: dart.definiteFunctionType(dart.void, [isolate.SendPort])})
  });
  const _receivePort = Symbol('_receivePort');
  const _isClosed = Symbol('_isClosed');
  const _add = Symbol('_add');
  _isolate_helper._NativeJsSendPort = class _NativeJsSendPort extends _isolate_helper._BaseSendPort {
    new(receivePort, isolateId) {
      this[_receivePort] = receivePort;
      super.new(isolateId);
    }
    send(message) {
      let isolate = _isolate_helper._globalState.isolates[dartx.get](this[_isolateId]);
      if (isolate == null) return;
      if (dart.test(this[_receivePort][_isClosed])) return;
      let msg = _isolate_helper._clone(message);
      if (dart.equals(isolate.controlPort, this[_receivePort])) {
        isolate.handleControlMessage(msg);
        return;
      }
      _isolate_helper._globalState.topEventLoop.enqueue(isolate, dart.fn(() => {
        if (!dart.test(this[_receivePort][_isClosed])) {
          this[_receivePort][_add](msg);
        }
      }, VoidTodynamic$()), dart.str`receive ${message}`);
    }
    ['=='](other) {
      return _isolate_helper._NativeJsSendPort.is(other) && dart.equals(this[_receivePort], other[_receivePort]);
    }
    get hashCode() {
      return this[_receivePort][_id];
    }
  };
  _isolate_helper._NativeJsSendPort[dart.implements] = () => [isolate.SendPort];
  dart.setSignature(_isolate_helper._NativeJsSendPort, {
    constructors: () => ({new: dart.definiteFunctionType(_isolate_helper._NativeJsSendPort, [_isolate_helper.RawReceivePortImpl, core.int])}),
    methods: () => ({send: dart.definiteFunctionType(dart.void, [dart.dynamic])})
  });
  const _workerId = Symbol('_workerId');
  const _receivePortId = Symbol('_receivePortId');
  _isolate_helper._WorkerSendPort = class _WorkerSendPort extends _isolate_helper._BaseSendPort {
    new(workerId, isolateId, receivePortId) {
      this[_workerId] = workerId;
      this[_receivePortId] = receivePortId;
      super.new(isolateId);
    }
    send(message) {
      let workerMessage = _isolate_helper._serializeMessage(dart.map({command: 'message', port: this, msg: message}));
      if (dart.test(_isolate_helper._globalState.isWorker)) {
        _isolate_helper._globalState.mainManager.postMessage(workerMessage);
      } else {
        let manager = _isolate_helper._globalState.managers[dartx.get](this[_workerId]);
        if (manager != null) {
          manager.postMessage(workerMessage);
        }
      }
    }
    ['=='](other) {
      return _isolate_helper._WorkerSendPort.is(other) && this[_workerId] == other[_workerId] && this[_isolateId] == other[_isolateId] && this[_receivePortId] == other[_receivePortId];
    }
    get hashCode() {
      return (dart.notNull(this[_workerId]) << 16 ^ dart.notNull(this[_isolateId]) << 8 ^ dart.notNull(this[_receivePortId])) >>> 0;
    }
  };
  _isolate_helper._WorkerSendPort[dart.implements] = () => [isolate.SendPort];
  dart.setSignature(_isolate_helper._WorkerSendPort, {
    constructors: () => ({new: dart.definiteFunctionType(_isolate_helper._WorkerSendPort, [core.int, core.int, core.int])}),
    methods: () => ({send: dart.definiteFunctionType(dart.void, [dart.dynamic])})
  });
  const _handler = Symbol('_handler');
  _isolate_helper.RawReceivePortImpl = class RawReceivePortImpl extends core.Object {
    new(handler) {
      this[_handler] = handler;
      this[_id] = (() => {
        let x = _isolate_helper.RawReceivePortImpl._nextFreeId;
        _isolate_helper.RawReceivePortImpl._nextFreeId = dart.notNull(x) + 1;
        return x;
      })();
      this[_isClosed] = false;
      _isolate_helper._globalState.currentContext.register(this[_id], this);
    }
    weak(handler) {
      this[_handler] = handler;
      this[_id] = (() => {
        let x = _isolate_helper.RawReceivePortImpl._nextFreeId;
        _isolate_helper.RawReceivePortImpl._nextFreeId = dart.notNull(x) + 1;
        return x;
      })();
      this[_isClosed] = false;
      _isolate_helper._globalState.currentContext.registerWeak(this[_id], this);
    }
    _controlPort() {
      this[_handler] = null;
      this[_id] = 0;
      this[_isClosed] = false;
    }
    set handler(newHandler) {
      this[_handler] = newHandler;
    }
    [_close]() {
      this[_isClosed] = true;
      this[_handler] = null;
    }
    close() {
      if (dart.test(this[_isClosed])) return;
      this[_isClosed] = true;
      this[_handler] = null;
      _isolate_helper._globalState.currentContext.unregister(this[_id]);
    }
    [_add](dataEvent) {
      if (dart.test(this[_isClosed])) return;
      dart.dcall(this[_handler], dataEvent);
    }
    get sendPort() {
      return new _isolate_helper._NativeJsSendPort(this, _isolate_helper._globalState.currentContext.id);
    }
  };
  dart.defineNamedConstructor(_isolate_helper.RawReceivePortImpl, 'weak');
  dart.defineNamedConstructor(_isolate_helper.RawReceivePortImpl, '_controlPort');
  _isolate_helper.RawReceivePortImpl[dart.implements] = () => [isolate.RawReceivePort];
  dart.setSignature(_isolate_helper.RawReceivePortImpl, {
    constructors: () => ({
      new: dart.definiteFunctionType(_isolate_helper.RawReceivePortImpl, [core.Function]),
      weak: dart.definiteFunctionType(_isolate_helper.RawReceivePortImpl, [core.Function]),
      _controlPort: dart.definiteFunctionType(_isolate_helper.RawReceivePortImpl, [])
    }),
    methods: () => ({
      [_close]: dart.definiteFunctionType(dart.void, []),
      close: dart.definiteFunctionType(dart.void, []),
      [_add]: dart.definiteFunctionType(dart.void, [dart.dynamic])
    })
  });
  _isolate_helper.RawReceivePortImpl._nextFreeId = 1;
  const _rawPort = Symbol('_rawPort');
  const _controller = Symbol('_controller');
  const _add$ = Symbol('_add');
  const _closeUnchecked = Symbol('_closeUnchecked');
  const _addError = Symbol('_addError');
  const _completeError = Symbol('_completeError');
  const _complete = Symbol('_complete');
  const _sink = Symbol('_sink');
  async.Stream$ = dart.generic(T => {
    let _EmptyStreamOfT = () => (_EmptyStreamOfT = dart.constFn(async._EmptyStream$(T)))();
    let StreamControllerOfT = () => (StreamControllerOfT = dart.constFn(async.StreamController$(T)))();
    let _StreamControllerOfT = () => (_StreamControllerOfT = dart.constFn(async._StreamController$(T)))();
    let _GeneratedStreamImplOfT = () => (_GeneratedStreamImplOfT = dart.constFn(async._GeneratedStreamImpl$(T)))();
    let _IterablePendingEventsOfT = () => (_IterablePendingEventsOfT = dart.constFn(async._IterablePendingEvents$(T)))();
    let _BoundSinkStreamOfdynamic$T = () => (_BoundSinkStreamOfdynamic$T = dart.constFn(async._BoundSinkStream$(dart.dynamic, T)))();
    let _AsBroadcastStreamOfT = () => (_AsBroadcastStreamOfT = dart.constFn(async._AsBroadcastStream$(T)))();
    let _WhereStreamOfT = () => (_WhereStreamOfT = dart.constFn(async._WhereStream$(T)))();
    let _HandleErrorStreamOfT = () => (_HandleErrorStreamOfT = dart.constFn(async._HandleErrorStream$(T)))();
    let StreamConsumerOfT = () => (StreamConsumerOfT = dart.constFn(async.StreamConsumer$(T)))();
    let TAndTToT = () => (TAndTToT = dart.constFn(dart.functionType(T, [T, T])))();
    let _FutureOfT = () => (_FutureOfT = dart.constFn(async._Future$(T)))();
    let JSArrayOfT = () => (JSArrayOfT = dart.constFn(_interceptors.JSArray$(T)))();
    let ListOfT = () => (ListOfT = dart.constFn(core.List$(T)))();
    let _FutureOfListOfT = () => (_FutureOfListOfT = dart.constFn(async._Future$(ListOfT())))();
    let SetOfT = () => (SetOfT = dart.constFn(core.Set$(T)))();
    let _FutureOfSetOfT = () => (_FutureOfSetOfT = dart.constFn(async._Future$(SetOfT())))();
    let _TakeStreamOfT = () => (_TakeStreamOfT = dart.constFn(async._TakeStream$(T)))();
    let _TakeWhileStreamOfT = () => (_TakeWhileStreamOfT = dart.constFn(async._TakeWhileStream$(T)))();
    let _SkipStreamOfT = () => (_SkipStreamOfT = dart.constFn(async._SkipStream$(T)))();
    let _SkipWhileStreamOfT = () => (_SkipWhileStreamOfT = dart.constFn(async._SkipWhileStream$(T)))();
    let _DistinctStreamOfT = () => (_DistinctStreamOfT = dart.constFn(async._DistinctStream$(T)))();
    let EventSinkOfT = () => (EventSinkOfT = dart.constFn(async.EventSink$(T)))();
    let _SyncBroadcastStreamControllerOfT = () => (_SyncBroadcastStreamControllerOfT = dart.constFn(async._SyncBroadcastStreamController$(T)))();
    let _SyncStreamControllerOfT = () => (_SyncStreamControllerOfT = dart.constFn(async._SyncStreamController$(T)))();
    let StreamSubscriptionOfT = () => (StreamSubscriptionOfT = dart.constFn(async.StreamSubscription$(T)))();
    let StreamSubscriptionOfTTovoid = () => (StreamSubscriptionOfTTovoid = dart.constFn(dart.functionType(dart.void, [StreamSubscriptionOfT()])))();
    let EventSinkOfTTovoid = () => (EventSinkOfTTovoid = dart.constFn(dart.functionType(dart.void, [EventSinkOfT()])))();
    let TTodynamic = () => (TTodynamic = dart.constFn(dart.definiteFunctionType(dart.dynamic, [T])))();
    let VoidTo_IterablePendingEventsOfT = () => (VoidTo_IterablePendingEventsOfT = dart.constFn(dart.definiteFunctionType(_IterablePendingEventsOfT(), [])))();
    let TTovoid = () => (TTovoid = dart.constFn(dart.definiteFunctionType(dart.void, [T])))();
    let VoidToT = () => (VoidToT = dart.constFn(dart.definiteFunctionType(T, [])))();
    class Stream extends core.Object {
      new() {
      }
      _internal() {
      }
      static empty() {
        return new (_EmptyStreamOfT())();
      }
      static fromFuture(future) {
        let controller = _StreamControllerOfT()._check(StreamControllerOfT().new({sync: true}));
        future.then(dart.dynamic)(dart.fn(value => {
          controller[_add$](value);
          controller[_closeUnchecked]();
        }, TTodynamic()), {onError: dart.fn((error, stackTrace) => {
            controller[_addError](error, core.StackTrace._check(stackTrace));
            controller[_closeUnchecked]();
          }, dynamicAnddynamicTodynamic$())});
        return controller.stream;
      }
      static fromFutures(futures) {
        let controller = _StreamControllerOfT()._check(StreamControllerOfT().new({sync: true}));
        let count = 0;
        let onValue = dart.fn(value => {
          if (!dart.test(controller.isClosed)) {
            controller[_add$](value);
            if (--count == 0) controller[_closeUnchecked]();
          }
        }, TTodynamic());
        let onError = dart.fn((error, stack) => {
          if (!dart.test(controller.isClosed)) {
            controller[_addError](error, core.StackTrace._check(stack));
            if (--count == 0) controller[_closeUnchecked]();
          }
        }, dynamicAnddynamicTodynamic$());
        for (let future of futures) {
          count++;
          future.then(dart.dynamic)(onValue, {onError: onError});
        }
        if (count == 0) async.scheduleMicrotask(dart.bind(controller, 'close'));
        return controller.stream;
      }
      static fromIterable(data) {
        return new (_GeneratedStreamImplOfT())(dart.fn(() => new (_IterablePendingEventsOfT())(data), VoidTo_IterablePendingEventsOfT()));
      }
      static periodic(period, computation) {
        if (computation === void 0) computation = null;
        let timer = null;
        let computationCount = 0;
        let controller = null;
        let watch = new core.Stopwatch();
        function sendEvent() {
          watch.reset();
          let data = null;
          if (computation != null) {
            try {
              data = computation(computationCount++);
            } catch (e) {
              let s = dart.stackTrace(e);
              controller.addError(e, s);
              return;
            }

          }
          controller.add(data);
        }
        dart.fn(sendEvent, VoidTovoid$());
        function startPeriodicTimer() {
          dart.assert(timer == null);
          timer = async.Timer.periodic(period, dart.fn(timer => {
            sendEvent();
          }, TimerTovoid$()));
        }
        dart.fn(startPeriodicTimer, VoidTovoid$());
        controller = StreamControllerOfT().new({sync: true, onListen: dart.fn(() => {
            watch.start();
            startPeriodicTimer();
          }, VoidTovoid$()), onPause: dart.fn(() => {
            timer.cancel();
            timer = null;
            watch.stop();
          }, VoidTovoid$()), onResume: dart.fn(() => {
            dart.assert(timer == null);
            let elapsed = watch.elapsed;
            watch.start();
            timer = async.Timer.new(period['-'](elapsed), dart.fn(() => {
              timer = null;
              startPeriodicTimer();
              sendEvent();
            }, VoidTovoid$()));
          }, VoidTovoid$()), onCancel: dart.fn(() => {
            if (timer != null) timer.cancel();
            timer = null;
          }, VoidTodynamic$())});
        return controller.stream;
      }
      static eventTransformed(source, mapSink) {
        return new (_BoundSinkStreamOfdynamic$T())(source, mapSink);
      }
      get isBroadcast() {
        return false;
      }
      asBroadcastStream(opts) {
        let onListen = opts && 'onListen' in opts ? opts.onListen : null;
        let onCancel = opts && 'onCancel' in opts ? opts.onCancel : null;
        return new (_AsBroadcastStreamOfT())(this, onListen, onCancel);
      }
      where(test) {
        return new (_WhereStreamOfT())(this, test);
      }
      map(S) {
        return convert => {
          return new (async._MapStream$(T, S))(this, convert);
        };
      }
      asyncMap(E) {
        return convert => {
          let controller = null;
          let subscription = null;
          const onListen = (function() {
            let add = dart.bind(controller, 'add');
            dart.assert(async._StreamController.is(controller) || async._BroadcastStreamController.is(controller));
            let eventSink = async._EventSink$(E).as(controller);
            let addError = dart.bind(eventSink, _addError);
            subscription = this.listen(dart.fn(event => {
              let newValue = null;
              try {
                newValue = convert(event);
              } catch (e) {
                let s = dart.stackTrace(e);
                controller.addError(e, s);
                return;
              }

              if (async.Future.is(newValue)) {
                subscription.pause();
                newValue.then(dart.dynamic)(add, {onError: addError}).whenComplete(dart.bind(subscription, 'resume'));
              } else {
                controller.add(E.as(newValue));
              }
            }, TTovoid()), {onError: addError, onDone: dart.bind(controller, 'close')});
          }).bind(this);
          dart.fn(onListen, VoidTovoid$());
          if (dart.test(this.isBroadcast)) {
            controller = async.StreamController$(E).broadcast({onListen: onListen, onCancel: dart.fn(() => {
                subscription.cancel();
              }, VoidTovoid$()), sync: true});
          } else {
            controller = async.StreamController$(E).new({onListen: onListen, onPause: dart.fn(() => {
                subscription.pause();
              }, VoidTovoid$()), onResume: dart.fn(() => {
                subscription.resume();
              }, VoidTovoid$()), onCancel: dart.fn(() => {
                subscription.cancel();
              }, VoidTodynamic$()), sync: true});
          }
          return controller.stream;
        };
      }
      asyncExpand(E) {
        return convert => {
          let controller = null;
          let subscription = null;
          const onListen = (function() {
            dart.assert(async._StreamController.is(controller) || async._BroadcastStreamController.is(controller));
            let eventSink = async._EventSink$(E).as(controller);
            subscription = this.listen(dart.fn(event => {
              let newStream = null;
              try {
                newStream = convert(event);
              } catch (e) {
                let s = dart.stackTrace(e);
                controller.addError(e, s);
                return;
              }

              if (newStream != null) {
                subscription.pause();
                controller.addStream(newStream).whenComplete(dart.bind(subscription, 'resume'));
              }
            }, TTovoid()), {onError: dart.bind(eventSink, _addError), onDone: dart.bind(controller, 'close')});
          }).bind(this);
          dart.fn(onListen, VoidTovoid$());
          if (dart.test(this.isBroadcast)) {
            controller = async.StreamController$(E).broadcast({onListen: onListen, onCancel: dart.fn(() => {
                subscription.cancel();
              }, VoidTovoid$()), sync: true});
          } else {
            controller = async.StreamController$(E).new({onListen: onListen, onPause: dart.fn(() => {
                subscription.pause();
              }, VoidTovoid$()), onResume: dart.fn(() => {
                subscription.resume();
              }, VoidTovoid$()), onCancel: dart.fn(() => {
                subscription.cancel();
              }, VoidTodynamic$()), sync: true});
          }
          return controller.stream;
        };
      }
      handleError(onError, opts) {
        let test = opts && 'test' in opts ? opts.test : null;
        return new (_HandleErrorStreamOfT())(this, onError, test);
      }
      expand(S) {
        return convert => {
          return new (async._ExpandStream$(T, S))(this, convert);
        };
      }
      pipe(streamConsumer) {
        StreamConsumerOfT()._check(streamConsumer);
        return streamConsumer.addStream(this).then(async.Future)(dart.fn(_ => streamConsumer.close(), dynamicToFuture()));
      }
      transform(S) {
        return streamTransformer => {
          async.StreamTransformer$(T, S)._check(streamTransformer);
          return streamTransformer.bind(this);
        };
      }
      reduce(combine) {
        TAndTToT()._check(combine);
        let result = new (_FutureOfT())();
        let seenFirst = false;
        let value = null;
        let subscription = null;
        subscription = this.listen(dart.fn(element => {
          if (seenFirst) {
            async._runUserCode(dart.fn(() => combine(value, element), VoidToT()), dart.fn(newValue => {
              value = newValue;
            }, TTodynamic()), async._cancelAndErrorClosure(subscription, result));
          } else {
            value = element;
            seenFirst = true;
          }
        }, TTovoid()), {onError: dart.bind(result, _completeError), onDone: dart.fn(() => {
            if (!seenFirst) {
              try {
                dart.throw(_internal.IterableElementError.noElement());
              } catch (e) {
                let s = dart.stackTrace(e);
                async._completeWithErrorCallback(result, e, s);
              }

            } else {
              result[_complete](value);
            }
          }, VoidTovoid$()), cancelOnError: true});
        return result;
      }
      fold(S) {
        return (initialValue, combine) => {
          let result = new (async._Future$(S))();
          let value = initialValue;
          let subscription = null;
          subscription = this.listen(dart.fn(element => {
            async._runUserCode(dart.fn(() => combine(value, element), dart.definiteFunctionType(S, [])), dart.fn(newValue => {
              value = newValue;
            }, dart.definiteFunctionType(dart.dynamic, [S])), async._cancelAndErrorClosure(subscription, result));
          }, TTovoid()), {onError: dart.fn((e, st) => {
              result[_completeError](e, core.StackTrace._check(st));
            }, dynamicAnddynamicTodynamic$()), onDone: dart.fn(() => {
              result[_complete](value);
            }, VoidTovoid$()), cancelOnError: true});
          return result;
        };
      }
      join(separator) {
        if (separator === void 0) separator = "";
        let result = new (_FutureOfString())();
        let buffer = new core.StringBuffer();
        let subscription = null;
        let first = true;
        subscription = this.listen(dart.fn(element => {
          if (!first) {
            buffer.write(separator);
          }
          first = false;
          try {
            buffer.write(element);
          } catch (e) {
            let s = dart.stackTrace(e);
            async._cancelAndErrorWithReplacement(subscription, result, e, s);
          }

        }, TTovoid()), {onError: dart.fn(e => {
            result[_completeError](e);
          }, dynamicTodynamic$()), onDone: dart.fn(() => {
            result[_complete](buffer.toString());
          }, VoidTovoid$()), cancelOnError: true});
        return result;
      }
      contains(needle) {
        let future = new (_FutureOfbool())();
        let subscription = null;
        subscription = this.listen(dart.fn(element => {
          async._runUserCode(dart.fn(() => dart.equals(element, needle), VoidTobool()), dart.fn(isMatch => {
            if (dart.test(isMatch)) {
              async._cancelAndValue(subscription, future, true);
            }
          }, boolTodynamic()), async._cancelAndErrorClosure(subscription, future));
        }, TTovoid()), {onError: dart.bind(future, _completeError), onDone: dart.fn(() => {
            future[_complete](false);
          }, VoidTovoid$()), cancelOnError: true});
        return future;
      }
      forEach(action) {
        let future = new async._Future();
        let subscription = null;
        subscription = this.listen(dart.fn(element => {
          async._runUserCode(dart.fn(() => action(element), VoidTovoid$()), dart.fn(_ => {
          }, dynamicTodynamic$()), async._cancelAndErrorClosure(subscription, future));
        }, TTovoid()), {onError: dart.bind(future, _completeError), onDone: dart.fn(() => {
            future[_complete](null);
          }, VoidTovoid$()), cancelOnError: true});
        return future;
      }
      every(test) {
        let future = new (_FutureOfbool())();
        let subscription = null;
        subscription = this.listen(dart.fn(element => {
          async._runUserCode(dart.fn(() => test(element), VoidTobool()), dart.fn(isMatch => {
            if (!dart.test(isMatch)) {
              async._cancelAndValue(subscription, future, false);
            }
          }, boolTodynamic()), async._cancelAndErrorClosure(subscription, future));
        }, TTovoid()), {onError: dart.bind(future, _completeError), onDone: dart.fn(() => {
            future[_complete](true);
          }, VoidTovoid$()), cancelOnError: true});
        return future;
      }
      any(test) {
        let future = new (_FutureOfbool())();
        let subscription = null;
        subscription = this.listen(dart.fn(element => {
          async._runUserCode(dart.fn(() => test(element), VoidTobool()), dart.fn(isMatch => {
            if (dart.test(isMatch)) {
              async._cancelAndValue(subscription, future, true);
            }
          }, boolTodynamic()), async._cancelAndErrorClosure(subscription, future));
        }, TTovoid()), {onError: dart.bind(future, _completeError), onDone: dart.fn(() => {
            future[_complete](false);
          }, VoidTovoid$()), cancelOnError: true});
        return future;
      }
      get length() {
        let future = new (_FutureOfint())();
        let count = 0;
        this.listen(dart.fn(_ => {
          count++;
        }, TTovoid()), {onError: dart.bind(future, _completeError), onDone: dart.fn(() => {
            future[_complete](count);
          }, VoidTovoid$()), cancelOnError: true});
        return future;
      }
      get isEmpty() {
        let future = new (_FutureOfbool())();
        let subscription = null;
        subscription = this.listen(dart.fn(_ => {
          async._cancelAndValue(subscription, future, false);
        }, TTovoid()), {onError: dart.bind(future, _completeError), onDone: dart.fn(() => {
            future[_complete](true);
          }, VoidTovoid$()), cancelOnError: true});
        return future;
      }
      toList() {
        let result = JSArrayOfT().of([]);
        let future = new (_FutureOfListOfT())();
        this.listen(dart.fn(data => {
          result[dartx.add](data);
        }, TTovoid()), {onError: dart.bind(future, _completeError), onDone: dart.fn(() => {
            future[_complete](result);
          }, VoidTovoid$()), cancelOnError: true});
        return future;
      }
      toSet() {
        let result = SetOfT().new();
        let future = new (_FutureOfSetOfT())();
        this.listen(dart.fn(data => {
          result.add(data);
        }, TTovoid()), {onError: dart.bind(future, _completeError), onDone: dart.fn(() => {
            future[_complete](result);
          }, VoidTovoid$()), cancelOnError: true});
        return future;
      }
      drain(E) {
        return futureValue => {
          if (futureValue === void 0) futureValue = null;
          return this.listen(null, {cancelOnError: true}).asFuture(E)(futureValue);
        };
      }
      take(count) {
        return new (_TakeStreamOfT())(this, count);
      }
      takeWhile(test) {
        return new (_TakeWhileStreamOfT())(this, test);
      }
      skip(count) {
        return new (_SkipStreamOfT())(this, count);
      }
      skipWhile(test) {
        return new (_SkipWhileStreamOfT())(this, test);
      }
      distinct(equals) {
        if (equals === void 0) equals = null;
        return new (_DistinctStreamOfT())(this, equals);
      }
      get first() {
        let future = new (_FutureOfT())();
        let subscription = null;
        subscription = this.listen(dart.fn(value => {
          async._cancelAndValue(subscription, future, value);
        }, TTovoid()), {onError: dart.bind(future, _completeError), onDone: dart.fn(() => {
            try {
              dart.throw(_internal.IterableElementError.noElement());
            } catch (e) {
              let s = dart.stackTrace(e);
              async._completeWithErrorCallback(future, e, s);
            }

          }, VoidTovoid$()), cancelOnError: true});
        return future;
      }
      get last() {
        let future = new (_FutureOfT())();
        let result = null;
        let foundResult = false;
        this.listen(dart.fn(value => {
          foundResult = true;
          result = value;
        }, TTovoid()), {onError: dart.bind(future, _completeError), onDone: dart.fn(() => {
            if (foundResult) {
              future[_complete](result);
              return;
            }
            try {
              dart.throw(_internal.IterableElementError.noElement());
            } catch (e) {
              let s = dart.stackTrace(e);
              async._completeWithErrorCallback(future, e, s);
            }

          }, VoidTovoid$()), cancelOnError: true});
        return future;
      }
      get single() {
        let future = new (_FutureOfT())();
        let result = null;
        let foundResult = false;
        let subscription = null;
        subscription = this.listen(dart.fn(value => {
          if (foundResult) {
            try {
              dart.throw(_internal.IterableElementError.tooMany());
            } catch (e) {
              let s = dart.stackTrace(e);
              async._cancelAndErrorWithReplacement(subscription, future, e, s);
            }

            return;
          }
          foundResult = true;
          result = value;
        }, TTovoid()), {onError: dart.bind(future, _completeError), onDone: dart.fn(() => {
            if (foundResult) {
              future[_complete](result);
              return;
            }
            try {
              dart.throw(_internal.IterableElementError.noElement());
            } catch (e) {
              let s = dart.stackTrace(e);
              async._completeWithErrorCallback(future, e, s);
            }

          }, VoidTovoid$()), cancelOnError: true});
        return future;
      }
      firstWhere(test, opts) {
        let defaultValue = opts && 'defaultValue' in opts ? opts.defaultValue : null;
        let future = new async._Future();
        let subscription = null;
        subscription = this.listen(dart.fn(value => {
          async._runUserCode(dart.fn(() => test(value), VoidTobool()), dart.fn(isMatch => {
            if (dart.test(isMatch)) {
              async._cancelAndValue(subscription, future, value);
            }
          }, boolTodynamic()), async._cancelAndErrorClosure(subscription, future));
        }, TTovoid()), {onError: dart.bind(future, _completeError), onDone: dart.fn(() => {
            if (defaultValue != null) {
              async._runUserCode(defaultValue, dart.bind(future, _complete), dart.bind(future, _completeError));
              return;
            }
            try {
              dart.throw(_internal.IterableElementError.noElement());
            } catch (e) {
              let s = dart.stackTrace(e);
              async._completeWithErrorCallback(future, e, s);
            }

          }, VoidTovoid$()), cancelOnError: true});
        return future;
      }
      lastWhere(test, opts) {
        let defaultValue = opts && 'defaultValue' in opts ? opts.defaultValue : null;
        let future = new async._Future();
        let result = null;
        let foundResult = false;
        let subscription = null;
        subscription = this.listen(dart.fn(value => {
          async._runUserCode(dart.fn(() => true == test(value), VoidTobool()), dart.fn(isMatch => {
            if (dart.test(isMatch)) {
              foundResult = true;
              result = value;
            }
          }, boolTodynamic()), async._cancelAndErrorClosure(subscription, future));
        }, TTovoid()), {onError: dart.bind(future, _completeError), onDone: dart.fn(() => {
            if (foundResult) {
              future[_complete](result);
              return;
            }
            if (defaultValue != null) {
              async._runUserCode(defaultValue, dart.bind(future, _complete), dart.bind(future, _completeError));
              return;
            }
            try {
              dart.throw(_internal.IterableElementError.noElement());
            } catch (e) {
              let s = dart.stackTrace(e);
              async._completeWithErrorCallback(future, e, s);
            }

          }, VoidTovoid$()), cancelOnError: true});
        return future;
      }
      singleWhere(test) {
        let future = new (_FutureOfT())();
        let result = null;
        let foundResult = false;
        let subscription = null;
        subscription = this.listen(dart.fn(value => {
          async._runUserCode(dart.fn(() => true == test(value), VoidTobool()), dart.fn(isMatch => {
            if (dart.test(isMatch)) {
              if (foundResult) {
                try {
                  dart.throw(_internal.IterableElementError.tooMany());
                } catch (e) {
                  let s = dart.stackTrace(e);
                  async._cancelAndErrorWithReplacement(subscription, future, e, s);
                }

                return;
              }
              foundResult = true;
              result = value;
            }
          }, boolTodynamic()), async._cancelAndErrorClosure(subscription, future));
        }, TTovoid()), {onError: dart.bind(future, _completeError), onDone: dart.fn(() => {
            if (foundResult) {
              future[_complete](result);
              return;
            }
            try {
              dart.throw(_internal.IterableElementError.noElement());
            } catch (e) {
              let s = dart.stackTrace(e);
              async._completeWithErrorCallback(future, e, s);
            }

          }, VoidTovoid$()), cancelOnError: true});
        return future;
      }
      elementAt(index) {
        if (!(typeof index == 'number') || dart.notNull(index) < 0) dart.throw(new core.ArgumentError(index));
        let future = new (_FutureOfT())();
        let subscription = null;
        let elementIndex = 0;
        subscription = this.listen(dart.fn(value => {
          if (index == elementIndex) {
            async._cancelAndValue(subscription, future, value);
            return;
          }
          elementIndex = elementIndex + 1;
        }, TTovoid()), {onError: dart.bind(future, _completeError), onDone: dart.fn(() => {
            future[_completeError](core.RangeError.index(index, this, "index", null, elementIndex));
          }, VoidTovoid$()), cancelOnError: true});
        return future;
      }
      timeout(timeLimit, opts) {
        let onTimeout = opts && 'onTimeout' in opts ? opts.onTimeout : null;
        let controller = null;
        let subscription = null;
        let timer = null;
        let zone = null;
        let timeout = null;
        function onData(event) {
          timer.cancel();
          controller.add(event);
          timer = zone.createTimer(timeLimit, timeout);
        }
        dart.fn(onData, TTovoid());
        function onError(error, stackTrace) {
          timer.cancel();
          dart.assert(async._StreamController.is(controller) || async._BroadcastStreamController.is(controller));
          let eventSink = controller;
          dart.dsend(eventSink, _addError, error, stackTrace);
          timer = zone.createTimer(timeLimit, timeout);
        }
        dart.fn(onError, dynamicAndStackTraceTovoid());
        function onDone() {
          timer.cancel();
          controller.close();
        }
        dart.fn(onDone, VoidTovoid$());
        const onListen = (function() {
          zone = async.Zone.current;
          if (onTimeout == null) {
            timeout = dart.fn(() => {
              controller.addError(new async.TimeoutException("No stream event", timeLimit), null);
            }, VoidTovoid$());
          } else {
            let registeredOnTimeout = zone.registerUnaryCallback(dart.dynamic, EventSinkOfT())(onTimeout);
            let wrapper = new async._ControllerEventSinkWrapper(null);
            timeout = dart.fn(() => {
              wrapper[_sink] = controller;
              zone.runUnaryGuarded(dart.dynamic, dart.dynamic)(registeredOnTimeout, wrapper);
              wrapper[_sink] = null;
            }, VoidTovoid$());
          }
          subscription = this.listen(onData, {onError: onError, onDone: onDone});
          timer = zone.createTimer(timeLimit, timeout);
        }).bind(this);
        dart.fn(onListen, VoidTovoid$());
        function onCancel() {
          timer.cancel();
          let result = subscription.cancel();
          subscription = null;
          return result;
        }
        dart.fn(onCancel, VoidToFuture());
        controller = dart.test(this.isBroadcast) ? new (_SyncBroadcastStreamControllerOfT())(onListen, onCancel) : new (_SyncStreamControllerOfT())(onListen, dart.fn(() => {
          timer.cancel();
          subscription.pause();
        }, VoidTovoid$()), dart.fn(() => {
          subscription.resume();
          timer = zone.createTimer(timeLimit, timeout);
        }, VoidTovoid$()), onCancel);
        return controller.stream;
      }
    }
    dart.addTypeTests(Stream);
    dart.defineNamedConstructor(Stream, '_internal');
    dart.setSignature(Stream, {
      constructors: () => ({
        new: dart.definiteFunctionType(async.Stream$(T), []),
        _internal: dart.definiteFunctionType(async.Stream$(T), []),
        empty: dart.definiteFunctionType(async.Stream$(T), []),
        fromFuture: dart.definiteFunctionType(async.Stream$(T), [async.Future$(T)]),
        fromFutures: dart.definiteFunctionType(async.Stream$(T), [core.Iterable$(async.Future$(T))]),
        fromIterable: dart.definiteFunctionType(async.Stream$(T), [core.Iterable$(T)]),
        periodic: dart.definiteFunctionType(async.Stream$(T), [core.Duration], [dart.functionType(T, [core.int])]),
        eventTransformed: dart.definiteFunctionType(async.Stream$(T), [async.Stream, dart.functionType(async.EventSink, [async.EventSink$(T)])])
      }),
      methods: () => ({
        asBroadcastStream: dart.definiteFunctionType(async.Stream$(T), [], {onListen: StreamSubscriptionOfTTovoid(), onCancel: StreamSubscriptionOfTTovoid()}),
        where: dart.definiteFunctionType(async.Stream$(T), [dart.functionType(core.bool, [T])]),
        map: dart.definiteFunctionType(S => [async.Stream$(S), [dart.functionType(S, [T])]]),
        asyncMap: dart.definiteFunctionType(E => [async.Stream$(E), [dart.functionType(dart.dynamic, [T])]]),
        asyncExpand: dart.definiteFunctionType(E => [async.Stream$(E), [dart.functionType(async.Stream$(E), [T])]]),
        handleError: dart.definiteFunctionType(async.Stream$(T), [core.Function], {test: dynamicTobool()}),
        expand: dart.definiteFunctionType(S => [async.Stream$(S), [dart.functionType(core.Iterable$(S), [T])]]),
        pipe: dart.definiteFunctionType(async.Future, [async.StreamConsumer$(T)]),
        transform: dart.definiteFunctionType(S => [async.Stream$(S), [async.StreamTransformer$(T, S)]]),
        reduce: dart.definiteFunctionType(async.Future$(T), [dart.functionType(T, [T, T])]),
        fold: dart.definiteFunctionType(S => [async.Future$(S), [S, dart.functionType(S, [S, T])]]),
        join: dart.definiteFunctionType(async.Future$(core.String), [], [core.String]),
        contains: dart.definiteFunctionType(async.Future$(core.bool), [core.Object]),
        forEach: dart.definiteFunctionType(async.Future, [dart.functionType(dart.void, [T])]),
        every: dart.definiteFunctionType(async.Future$(core.bool), [dart.functionType(core.bool, [T])]),
        any: dart.definiteFunctionType(async.Future$(core.bool), [dart.functionType(core.bool, [T])]),
        toList: dart.definiteFunctionType(async.Future$(core.List$(T)), []),
        toSet: dart.definiteFunctionType(async.Future$(core.Set$(T)), []),
        drain: dart.definiteFunctionType(E => [async.Future$(E), [], [E]]),
        take: dart.definiteFunctionType(async.Stream$(T), [core.int]),
        takeWhile: dart.definiteFunctionType(async.Stream$(T), [dart.functionType(core.bool, [T])]),
        skip: dart.definiteFunctionType(async.Stream$(T), [core.int]),
        skipWhile: dart.definiteFunctionType(async.Stream$(T), [dart.functionType(core.bool, [T])]),
        distinct: dart.definiteFunctionType(async.Stream$(T), [], [dart.functionType(core.bool, [T, T])]),
        firstWhere: dart.definiteFunctionType(async.Future, [dart.functionType(core.bool, [T])], {defaultValue: VoidToObject()}),
        lastWhere: dart.definiteFunctionType(async.Future, [dart.functionType(core.bool, [T])], {defaultValue: VoidToObject()}),
        singleWhere: dart.definiteFunctionType(async.Future$(T), [dart.functionType(core.bool, [T])]),
        elementAt: dart.definiteFunctionType(async.Future$(T), [core.int]),
        timeout: dart.definiteFunctionType(async.Stream$(T), [core.Duration], {onTimeout: EventSinkOfTTovoid()})
      })
    });
    return Stream;
  });
  async.Stream = Stream();
  _isolate_helper.ReceivePortImpl = class ReceivePortImpl extends async.Stream {
    new() {
      ReceivePortImpl.prototype.fromRawReceivePort.call(this, new _isolate_helper.RawReceivePortImpl(null));
    }
    weak() {
      ReceivePortImpl.prototype.fromRawReceivePort.call(this, new _isolate_helper.RawReceivePortImpl.weak(null));
    }
    fromRawReceivePort(rawPort) {
      this[_rawPort] = rawPort;
      this[_controller] = null;
      super.new();
      this[_controller] = async.StreamController.new({onCancel: dart.bind(this, 'close'), sync: true});
      this[_rawPort].handler = dart.bind(this[_controller], 'add');
    }
    listen(onData, opts) {
      let onError = opts && 'onError' in opts ? opts.onError : null;
      let onDone = opts && 'onDone' in opts ? opts.onDone : null;
      let cancelOnError = opts && 'cancelOnError' in opts ? opts.cancelOnError : null;
      return this[_controller].stream.listen(onData, {onError: onError, onDone: onDone, cancelOnError: cancelOnError});
    }
    close() {
      this[_rawPort].close();
      this[_controller].close();
    }
    get sendPort() {
      return this[_rawPort].sendPort;
    }
  };
  dart.addSimpleTypeTests(_isolate_helper.ReceivePortImpl);
  dart.defineNamedConstructor(_isolate_helper.ReceivePortImpl, 'weak');
  dart.defineNamedConstructor(_isolate_helper.ReceivePortImpl, 'fromRawReceivePort');
  _isolate_helper.ReceivePortImpl[dart.implements] = () => [isolate.ReceivePort];
  dart.setSignature(_isolate_helper.ReceivePortImpl, {
    constructors: () => ({
      new: dart.definiteFunctionType(_isolate_helper.ReceivePortImpl, []),
      weak: dart.definiteFunctionType(_isolate_helper.ReceivePortImpl, []),
      fromRawReceivePort: dart.definiteFunctionType(_isolate_helper.ReceivePortImpl, [isolate.RawReceivePort])
    }),
    methods: () => ({
      listen: dart.definiteFunctionType(async.StreamSubscription, [dart.functionType(dart.void, [dart.dynamic])], {onError: core.Function, onDone: VoidTovoid(), cancelOnError: core.bool}),
      close: dart.definiteFunctionType(dart.void, [])
    })
  });
  const _once = Symbol('_once');
  const _inEventLoop = Symbol('_inEventLoop');
  const _handle = Symbol('_handle');
  _isolate_helper.TimerImpl = class TimerImpl extends core.Object {
    new(milliseconds, callback) {
      this[_once] = true;
      this[_inEventLoop] = false;
      this[_handle] = null;
      if (milliseconds == 0 && (!dart.test(_isolate_helper.hasTimer()) || dart.test(_isolate_helper._globalState.isWorker))) {
        const internalCallback = (function() {
          this[_handle] = null;
          callback();
        }).bind(this);
        dart.fn(internalCallback, VoidTovoid$());
        this[_handle] = 1;
        _isolate_helper._globalState.topEventLoop.enqueue(_isolate_helper._globalState.currentContext, internalCallback, 'timer');
        this[_inEventLoop] = true;
      } else if (dart.test(_isolate_helper.hasTimer())) {
        const internalCallback = (function() {
          this[_handle] = null;
          _isolate_helper.leaveJsAsync();
          callback();
        }).bind(this);
        dart.fn(internalCallback, VoidTovoid$());
        _isolate_helper.enterJsAsync();
        this[_handle] = self.setTimeout(internalCallback, milliseconds);
      } else {
        dart.assert(dart.notNull(milliseconds) > 0);
        dart.throw(new core.UnsupportedError("Timer greater than 0."));
      }
    }
    periodic(milliseconds, callback) {
      this[_once] = false;
      this[_inEventLoop] = false;
      this[_handle] = null;
      if (dart.test(_isolate_helper.hasTimer())) {
        _isolate_helper.enterJsAsync();
        this[_handle] = self.setInterval(dart.fn(() => {
          callback(this);
        }, VoidTodynamic$()), milliseconds);
      } else {
        dart.throw(new core.UnsupportedError("Periodic timer."));
      }
    }
    cancel() {
      if (dart.test(_isolate_helper.hasTimer())) {
        if (dart.test(this[_inEventLoop])) {
          dart.throw(new core.UnsupportedError("Timer in event loop cannot be canceled."));
        }
        if (this[_handle] == null) return;
        _isolate_helper.leaveJsAsync();
        if (dart.test(this[_once])) {
          self.clearTimeout(this[_handle]);
        } else {
          self.clearInterval(this[_handle]);
        }
        this[_handle] = null;
      } else {
        dart.throw(new core.UnsupportedError("Canceling a timer."));
      }
    }
    get isActive() {
      return this[_handle] != null;
    }
  };
  dart.defineNamedConstructor(_isolate_helper.TimerImpl, 'periodic');
  _isolate_helper.TimerImpl[dart.implements] = () => [async.Timer];
  dart.setSignature(_isolate_helper.TimerImpl, {
    constructors: () => ({
      new: dart.definiteFunctionType(_isolate_helper.TimerImpl, [core.int, dart.functionType(dart.void, [])]),
      periodic: dart.definiteFunctionType(_isolate_helper.TimerImpl, [core.int, dart.functionType(dart.void, [async.Timer])])
    }),
    methods: () => ({cancel: dart.definiteFunctionType(dart.void, [])})
  });
  _isolate_helper.hasTimer = function() {
    return self.setTimeout != null;
  };
  dart.lazyFn(_isolate_helper.hasTimer, () => VoidTobool());
  _isolate_helper.CapabilityImpl = class CapabilityImpl extends core.Object {
    new() {
      CapabilityImpl.prototype._internal.call(this, _js_helper.random64());
    }
    _internal(id) {
      this[_id] = id;
    }
    get hashCode() {
      let hash = this[_id];
      hash = (hash[dartx['>>']](0) ^ (dart.notNull(hash) / 4294967296)[dartx.truncate]()) >>> 0;
      hash = ((~dart.notNull(hash) >>> 0) + (dart.notNull(hash) << 15 >>> 0) & 4294967295) >>> 0;
      hash = (dart.notNull(hash) ^ hash[dartx['>>']](12)) >>> 0;
      hash = (dart.notNull(hash) * 5 & 4294967295) >>> 0;
      hash = (dart.notNull(hash) ^ hash[dartx['>>']](4)) >>> 0;
      hash = (dart.notNull(hash) * 2057 & 4294967295) >>> 0;
      hash = (dart.notNull(hash) ^ hash[dartx['>>']](16)) >>> 0;
      return hash;
    }
    ['=='](other) {
      if (core.identical(other, this)) return true;
      if (_isolate_helper.CapabilityImpl.is(other)) {
        return core.identical(this[_id], other[_id]);
      }
      return false;
    }
  };
  dart.defineNamedConstructor(_isolate_helper.CapabilityImpl, '_internal');
  _isolate_helper.CapabilityImpl[dart.implements] = () => [isolate.Capability];
  dart.setSignature(_isolate_helper.CapabilityImpl, {
    constructors: () => ({
      new: dart.definiteFunctionType(_isolate_helper.CapabilityImpl, []),
      _internal: dart.definiteFunctionType(_isolate_helper.CapabilityImpl, [core.int])
    }),
    methods: () => ({'==': dart.definiteFunctionType(core.bool, [core.Object])})
  });
  _isolate_helper._serializeMessage = function(message) {
    return new _isolate_helper._Serializer().serialize(message);
  };
  dart.fn(_isolate_helper._serializeMessage, dynamicTodynamic$());
  _isolate_helper._deserializeMessage = function(message) {
    return new _isolate_helper._Deserializer().deserialize(message);
  };
  dart.fn(_isolate_helper._deserializeMessage, dynamicTodynamic$());
  _isolate_helper._clone = function(message) {
    let serializer = new _isolate_helper._Serializer({serializeSendPorts: false});
    let deserializer = new _isolate_helper._Deserializer();
    return deserializer.deserialize(serializer.serialize(message));
  };
  dart.fn(_isolate_helper._clone, dynamicTodynamic$());
  const _serializeSendPorts = Symbol('_serializeSendPorts');
  _isolate_helper._Serializer = class _Serializer extends core.Object {
    new(opts) {
      let serializeSendPorts = opts && 'serializeSendPorts' in opts ? opts.serializeSendPorts : true;
      this.serializedObjectIds = MapOfdynamic$int().identity();
      this[_serializeSendPorts] = core.bool._check(serializeSendPorts);
    }
    serialize(x) {
      if (dart.test(this.isPrimitive(x))) return this.serializePrimitive(x);
      let serializationId = this.serializedObjectIds[dartx.get](x);
      if (serializationId != null) return this.makeRef(serializationId);
      serializationId = this.serializedObjectIds[dartx.length];
      this.serializedObjectIds[dartx.set](x, serializationId);
      if (_native_typed_data.NativeByteBuffer.is(x)) return this.serializeByteBuffer(x);
      if (_native_typed_data.NativeTypedData.is(x)) return this.serializeTypedData(x);
      if (_interceptors.JSIndexable.is(x)) return this.serializeJSIndexable(x);
      if (_js_helper.InternalMap.is(x)) return this.serializeMap(x);
      if (_interceptors.JSObject.is(x)) return this.serializeJSObject(x);
      if (_interceptors.Interceptor.is(x)) this.unsupported(x);
      if (isolate.RawReceivePort.is(x)) {
        this.unsupported(x, "RawReceivePorts can't be transmitted:");
      }
      if (_isolate_helper._NativeJsSendPort.is(x)) return this.serializeJsSendPort(x);
      if (_isolate_helper._WorkerSendPort.is(x)) return this.serializeWorkerSendPort(x);
      if (core.Function.is(x)) return this.serializeClosure(x);
      return this.serializeDartObject(x);
    }
    unsupported(x, message) {
      if (message === void 0) message = null;
      if (message == null) message = "Can't transmit:";
      dart.throw(new core.UnsupportedError(dart.str`${message} ${x}`));
    }
    makeRef(serializationId) {
      return JSArrayOfObject().of(["ref", serializationId]);
    }
    isPrimitive(x) {
      return x == null || typeof x == 'string' || typeof x == 'number' || typeof x == 'boolean';
    }
    serializePrimitive(primitive) {
      return primitive;
    }
    serializeByteBuffer(buffer) {
      return JSArrayOfObject().of(["buffer", buffer]);
    }
    serializeTypedData(data) {
      return JSArrayOfObject().of(["typed", data]);
    }
    serializeJSIndexable(indexable) {
      dart.assert(!(typeof indexable == 'string'));
      let serialized = core.List._check(this.serializeArray(_interceptors.JSArray._check(indexable)));
      if (_interceptors.JSFixedArray.is(indexable)) return JSArrayOfObject().of(["fixed", serialized]);
      if (_interceptors.JSExtendableArray.is(indexable)) return JSArrayOfObject().of(["extendable", serialized]);
      if (_interceptors.JSMutableArray.is(indexable)) return JSArrayOfObject().of(["mutable", serialized]);
      if (_interceptors.JSArray.is(indexable)) return JSArrayOfObject().of(["const", serialized]);
      this.unsupported(indexable, "Can't serialize indexable: ");
      return null;
    }
    serializeArray(x) {
      let serialized = [];
      serialized[dartx.length] = x[dartx.length];
      for (let i = 0; i < dart.notNull(x[dartx.length]); i++) {
        serialized[dartx.set](i, this.serialize(x[dartx.get](i)));
      }
      return serialized;
    }
    serializeArrayInPlace(x) {
      for (let i = 0; i < dart.notNull(x[dartx.length]); i++) {
        x[dartx.set](i, this.serialize(x[dartx.get](i)));
      }
      return x;
    }
    serializeMap(x) {
      let serializeTearOff = dart.bind(this, 'serialize');
      return JSArrayOfObject().of(['map', x[dartx.keys][dartx.map](dart.dynamic)(dynamicTodynamic()._check(serializeTearOff))[dartx.toList](), x[dartx.values][dartx.map](dart.dynamic)(dynamicTodynamic()._check(serializeTearOff))[dartx.toList]()]);
    }
    serializeJSObject(x) {
      if (!!x.constructor && x.constructor !== Object) {
        this.unsupported(x, "Only plain JS Objects are supported:");
      }
      let keys = Object.keys(x);
      let values = [];
      values[dartx.length] = keys[dartx.length];
      for (let i = 0; i < dart.notNull(keys[dartx.length]); i++) {
        values[dartx.set](i, this.serialize(x[keys[dartx.get](i)]));
      }
      return JSArrayOfObject().of(['js-object', keys, values]);
    }
    serializeWorkerSendPort(x) {
      if (dart.test(this[_serializeSendPorts])) {
        return JSArrayOfObject().of(['sendport', x[_workerId], x[_isolateId], x[_receivePortId]]);
      }
      return JSArrayOfObject().of(['raw sendport', x]);
    }
    serializeJsSendPort(x) {
      if (dart.test(this[_serializeSendPorts])) {
        let workerId = _isolate_helper._globalState.currentManagerId;
        return JSArrayOfObject().of(['sendport', workerId, x[_isolateId], x[_receivePort][_id]]);
      }
      return JSArrayOfObject().of(['raw sendport', x]);
    }
    serializeCapability(x) {
      return JSArrayOfObject().of(['capability', x[_id]]);
    }
    serializeClosure(x) {
      let name = _isolate_helper.IsolateNatives._getJSFunctionName(x);
      if (name == null) {
        this.unsupported(x, "Closures can't be transmitted:");
      }
      return JSArrayOfString().of(['function', name]);
    }
    serializeDartObject(x) {
      let classExtractor = _foreign_helper.JS_EMBEDDED_GLOBAL('', _js_embedded_names.CLASS_ID_EXTRACTOR);
      let fieldsExtractor = _foreign_helper.JS_EMBEDDED_GLOBAL('', _js_embedded_names.CLASS_FIELDS_EXTRACTOR);
      let classId = classExtractor(x);
      let fields = fieldsExtractor(x);
      return ['dart', classId, this.serializeArrayInPlace(_interceptors.JSArray._check(fields))];
    }
  };
  dart.setSignature(_isolate_helper._Serializer, {
    constructors: () => ({new: dart.definiteFunctionType(_isolate_helper._Serializer, [], {serializeSendPorts: dart.dynamic})}),
    methods: () => ({
      serialize: dart.definiteFunctionType(dart.dynamic, [dart.dynamic]),
      unsupported: dart.definiteFunctionType(dart.void, [dart.dynamic], [core.String]),
      makeRef: dart.definiteFunctionType(dart.dynamic, [core.int]),
      isPrimitive: dart.definiteFunctionType(core.bool, [dart.dynamic]),
      serializePrimitive: dart.definiteFunctionType(dart.dynamic, [dart.dynamic]),
      serializeByteBuffer: dart.definiteFunctionType(dart.dynamic, [_native_typed_data.NativeByteBuffer]),
      serializeTypedData: dart.definiteFunctionType(dart.dynamic, [_native_typed_data.NativeTypedData]),
      serializeJSIndexable: dart.definiteFunctionType(dart.dynamic, [_interceptors.JSIndexable]),
      serializeArray: dart.definiteFunctionType(dart.dynamic, [_interceptors.JSArray]),
      serializeArrayInPlace: dart.definiteFunctionType(dart.dynamic, [_interceptors.JSArray]),
      serializeMap: dart.definiteFunctionType(dart.dynamic, [core.Map]),
      serializeJSObject: dart.definiteFunctionType(dart.dynamic, [_interceptors.JSObject]),
      serializeWorkerSendPort: dart.definiteFunctionType(dart.dynamic, [_isolate_helper._WorkerSendPort]),
      serializeJsSendPort: dart.definiteFunctionType(dart.dynamic, [_isolate_helper._NativeJsSendPort]),
      serializeCapability: dart.definiteFunctionType(dart.dynamic, [_isolate_helper.CapabilityImpl]),
      serializeClosure: dart.definiteFunctionType(dart.dynamic, [core.Function]),
      serializeDartObject: dart.definiteFunctionType(dart.dynamic, [dart.dynamic])
    })
  });
  const _adjustSendPorts = Symbol('_adjustSendPorts');
  _isolate_helper._Deserializer = class _Deserializer extends core.Object {
    new(opts) {
      let adjustSendPorts = opts && 'adjustSendPorts' in opts ? opts.adjustSendPorts : true;
      this.deserializedObjects = core.List.new();
      this[_adjustSendPorts] = core.bool._check(adjustSendPorts);
    }
    deserialize(x) {
      if (dart.test(this.isPrimitive(x))) return this.deserializePrimitive(x);
      if (!_interceptors.JSArray.is(x)) dart.throw(new core.ArgumentError(dart.str`Bad serialized message: ${x}`));
      switch (dart.dload(x, 'first')) {
        case "ref":
        {
          return this.deserializeRef(x);
        }
        case "buffer":
        {
          return this.deserializeByteBuffer(x);
        }
        case "typed":
        {
          return this.deserializeTypedData(x);
        }
        case "fixed":
        {
          return this.deserializeFixed(x);
        }
        case "extendable":
        {
          return this.deserializeExtendable(x);
        }
        case "mutable":
        {
          return this.deserializeMutable(x);
        }
        case "const":
        {
          return this.deserializeConst(x);
        }
        case "map":
        {
          return this.deserializeMap(x);
        }
        case "sendport":
        {
          return this.deserializeSendPort(x);
        }
        case "raw sendport":
        {
          return this.deserializeRawSendPort(x);
        }
        case "js-object":
        {
          return this.deserializeJSObject(x);
        }
        case "function":
        {
          return this.deserializeClosure(x);
        }
        case "dart":
        {
          return this.deserializeDartObject(x);
        }
        default:
        {
          dart.throw(dart.str`couldn't deserialize: ${x}`);
        }
      }
    }
    isPrimitive(x) {
      return x == null || typeof x == 'string' || typeof x == 'number' || typeof x == 'boolean';
    }
    deserializePrimitive(x) {
      return x;
    }
    deserializeRef(x) {
      dart.assert(dart.equals(dart.dindex(x, 0), 'ref'));
      let serializationId = core.int._check(dart.dindex(x, 1));
      return this.deserializedObjects[dartx.get](serializationId);
    }
    deserializeByteBuffer(x) {
      dart.assert(dart.equals(dart.dindex(x, 0), 'buffer'));
      let result = _native_typed_data.NativeByteBuffer._check(dart.dindex(x, 1));
      this.deserializedObjects[dartx.add](result);
      return result;
    }
    deserializeTypedData(x) {
      dart.assert(dart.equals(dart.dindex(x, 0), 'typed'));
      let result = _native_typed_data.NativeTypedData._check(dart.dindex(x, 1));
      this.deserializedObjects[dartx.add](result);
      return result;
    }
    deserializeArrayInPlace(x) {
      for (let i = 0; i < dart.notNull(x[dartx.length]); i++) {
        x[dartx.set](i, this.deserialize(x[dartx.get](i)));
      }
      return x;
    }
    deserializeFixed(x) {
      dart.assert(dart.equals(dart.dindex(x, 0), 'fixed'));
      let result = core.List._check(dart.dindex(x, 1));
      this.deserializedObjects[dartx.add](result);
      return _interceptors.JSArray.markFixed(this.deserializeArrayInPlace(_interceptors.JSArray._check(result)));
    }
    deserializeExtendable(x) {
      dart.assert(dart.equals(dart.dindex(x, 0), 'extendable'));
      let result = core.List._check(dart.dindex(x, 1));
      this.deserializedObjects[dartx.add](result);
      return _interceptors.JSArray.markGrowable(this.deserializeArrayInPlace(_interceptors.JSArray._check(result)));
    }
    deserializeMutable(x) {
      dart.assert(dart.equals(dart.dindex(x, 0), 'mutable'));
      let result = core.List._check(dart.dindex(x, 1));
      this.deserializedObjects[dartx.add](result);
      return this.deserializeArrayInPlace(_interceptors.JSArray._check(result));
    }
    deserializeConst(x) {
      dart.assert(dart.equals(dart.dindex(x, 0), 'const'));
      let result = core.List._check(dart.dindex(x, 1));
      this.deserializedObjects[dartx.add](result);
      return _interceptors.JSArray.markFixed(this.deserializeArrayInPlace(_interceptors.JSArray._check(result)));
    }
    deserializeMap(x) {
      dart.assert(dart.equals(dart.dindex(x, 0), 'map'));
      let keys = core.List._check(dart.dindex(x, 1));
      let values = core.List._check(dart.dindex(x, 2));
      let result = dart.map();
      this.deserializedObjects[dartx.add](result);
      keys = keys[dartx.map](dart.dynamic)(dart.bind(this, 'deserialize'))[dartx.toList]();
      for (let i = 0; i < dart.notNull(keys[dartx.length]); i++) {
        result[dartx.set](keys[dartx.get](i), this.deserialize(values[dartx.get](i)));
      }
      return result;
    }
    deserializeSendPort(x) {
      dart.assert(dart.equals(dart.dindex(x, 0), 'sendport'));
      let managerId = core.int._check(dart.dindex(x, 1));
      let isolateId = core.int._check(dart.dindex(x, 2));
      let receivePortId = core.int._check(dart.dindex(x, 3));
      let result = null;
      if (managerId == _isolate_helper._globalState.currentManagerId) {
        let isolate = _isolate_helper._globalState.isolates[dartx.get](isolateId);
        if (isolate == null) return null;
        let receivePort = isolate.lookup(receivePortId);
        if (receivePort == null) return null;
        result = new _isolate_helper._NativeJsSendPort(receivePort, isolateId);
      } else {
        result = new _isolate_helper._WorkerSendPort(managerId, isolateId, receivePortId);
      }
      this.deserializedObjects[dartx.add](result);
      return result;
    }
    deserializeRawSendPort(x) {
      dart.assert(dart.equals(dart.dindex(x, 0), 'raw sendport'));
      let result = isolate.SendPort._check(dart.dindex(x, 1));
      this.deserializedObjects[dartx.add](result);
      return result;
    }
    deserializeJSObject(x) {
      dart.assert(dart.equals(dart.dindex(x, 0), 'js-object'));
      let keys = core.List._check(dart.dindex(x, 1));
      let values = core.List._check(dart.dindex(x, 2));
      let o = {};
      this.deserializedObjects[dartx.add](o);
      for (let i = 0; i < dart.notNull(keys[dartx.length]); i++) {
        o[keys[dartx.get](i)] = this.deserialize(values[dartx.get](i));
      }
      return o;
    }
    deserializeClosure(x) {
      dart.assert(dart.equals(dart.dindex(x, 0), 'function'));
      let name = core.String._check(dart.dindex(x, 1));
      let result = core.Function._check(_isolate_helper.IsolateNatives._getJSFunctionFromName(name));
      this.deserializedObjects[dartx.add](result);
      return result;
    }
    deserializeDartObject(x) {
      dart.assert(dart.equals(dart.dindex(x, 0), 'dart'));
      let classId = core.String._check(dart.dindex(x, 1));
      let fields = core.List._check(dart.dindex(x, 2));
      let instanceFromClassId = _foreign_helper.JS_EMBEDDED_GLOBAL('', _js_embedded_names.INSTANCE_FROM_CLASS_ID);
      let initializeObject = _foreign_helper.JS_EMBEDDED_GLOBAL('', _js_embedded_names.INITIALIZE_EMPTY_INSTANCE);
      let emptyInstance = instanceFromClassId(classId);
      this.deserializedObjects[dartx.add](emptyInstance);
      this.deserializeArrayInPlace(_interceptors.JSArray._check(fields));
      return initializeObject(classId, emptyInstance, fields);
    }
  };
  dart.setSignature(_isolate_helper._Deserializer, {
    constructors: () => ({new: dart.definiteFunctionType(_isolate_helper._Deserializer, [], {adjustSendPorts: dart.dynamic})}),
    methods: () => ({
      deserialize: dart.definiteFunctionType(dart.dynamic, [dart.dynamic]),
      isPrimitive: dart.definiteFunctionType(core.bool, [dart.dynamic]),
      deserializePrimitive: dart.definiteFunctionType(dart.dynamic, [dart.dynamic]),
      deserializeRef: dart.definiteFunctionType(dart.dynamic, [dart.dynamic]),
      deserializeByteBuffer: dart.definiteFunctionType(_native_typed_data.NativeByteBuffer, [dart.dynamic]),
      deserializeTypedData: dart.definiteFunctionType(_native_typed_data.NativeTypedData, [dart.dynamic]),
      deserializeArrayInPlace: dart.definiteFunctionType(core.List, [_interceptors.JSArray]),
      deserializeFixed: dart.definiteFunctionType(core.List, [dart.dynamic]),
      deserializeExtendable: dart.definiteFunctionType(core.List, [dart.dynamic]),
      deserializeMutable: dart.definiteFunctionType(core.List, [dart.dynamic]),
      deserializeConst: dart.definiteFunctionType(core.List, [dart.dynamic]),
      deserializeMap: dart.definiteFunctionType(core.Map, [dart.dynamic]),
      deserializeSendPort: dart.definiteFunctionType(isolate.SendPort, [dart.dynamic]),
      deserializeRawSendPort: dart.definiteFunctionType(isolate.SendPort, [dart.dynamic]),
      deserializeJSObject: dart.definiteFunctionType(dart.dynamic, [dart.dynamic]),
      deserializeClosure: dart.definiteFunctionType(core.Function, [dart.dynamic]),
      deserializeDartObject: dart.definiteFunctionType(dart.dynamic, [dart.dynamic])
    })
  });
  _js_embedded_names.DISPATCH_PROPERTY_NAME = "dispatchPropertyName";
  _js_embedded_names.TYPE_INFORMATION = 'typeInformation';
  _js_embedded_names.GLOBAL_FUNCTIONS = 'globalFunctions';
  _js_embedded_names.STATICS = 'statics';
  _js_embedded_names.INTERCEPTED_NAMES = 'interceptedNames';
  _js_embedded_names.MANGLED_GLOBAL_NAMES = 'mangledGlobalNames';
  _js_embedded_names.MANGLED_NAMES = 'mangledNames';
  _js_embedded_names.LIBRARIES = 'libraries';
  _js_embedded_names.FINISHED_CLASSES = 'finishedClasses';
  _js_embedded_names.ALL_CLASSES = 'allClasses';
  _js_embedded_names.METADATA = 'metadata';
  _js_embedded_names.INTERCEPTORS_BY_TAG = 'interceptorsByTag';
  _js_embedded_names.LEAF_TAGS = 'leafTags';
  _js_embedded_names.LAZIES = 'lazies';
  _js_embedded_names.GET_ISOLATE_TAG = 'getIsolateTag';
  _js_embedded_names.ISOLATE_TAG = 'isolateTag';
  _js_embedded_names.CURRENT_SCRIPT = 'currentScript';
  _js_embedded_names.DEFERRED_LIBRARY_URIS = 'deferredLibraryUris';
  _js_embedded_names.DEFERRED_LIBRARY_HASHES = 'deferredLibraryHashes';
  _js_embedded_names.INITIALIZE_LOADED_HUNK = 'initializeLoadedHunk';
  _js_embedded_names.IS_HUNK_LOADED = 'isHunkLoaded';
  _js_embedded_names.IS_HUNK_INITIALIZED = 'isHunkInitialized';
  _js_embedded_names.DEFERRED_INITIALIZED = 'deferredInitialized';
  _js_embedded_names.CLASS_ID_EXTRACTOR = 'classIdExtractor';
  _js_embedded_names.CLASS_FIELDS_EXTRACTOR = 'classFieldsExtractor';
  _js_embedded_names.INSTANCE_FROM_CLASS_ID = "instanceFromClassId";
  _js_embedded_names.INITIALIZE_EMPTY_INSTANCE = "initializeEmptyInstance";
  _js_embedded_names.TYPEDEF_TYPE_PROPERTY_NAME = "$typedefType";
  _js_embedded_names.TYPEDEF_PREDICATE_PROPERTY_NAME = "$$isTypedef";
  _js_embedded_names.NATIVE_SUPERCLASS_TAG_NAME = "$nativeSuperclassTag";
  _js_embedded_names.MAP_TYPE_TO_INTERCEPTOR = "mapTypeToInterceptor";
  _js_helper._Patch = class _Patch extends core.Object {
    new() {
    }
  };
  dart.setSignature(_js_helper._Patch, {
    constructors: () => ({new: dart.definiteFunctionType(_js_helper._Patch, [])})
  });
  _js_helper.patch = dart.const(new _js_helper._Patch());
  _js_helper.InternalMap = class InternalMap extends core.Object {};
  _js_helper.Primitives = class Primitives extends core.Object {
    static initializeStatics(id) {
      _js_helper.Primitives.mirrorFunctionCacheName = dart.notNull(_js_helper.Primitives.mirrorFunctionCacheName) + dart.str`_${id}`;
      _js_helper.Primitives.mirrorInvokeCacheName = dart.notNull(_js_helper.Primitives.mirrorInvokeCacheName) + dart.str`_${id}`;
    }
    static objectHashCode(object) {
      let hash = object.$identityHash;
      if (hash == null) {
        hash = Math.random() * 0x3fffffff | 0;
        object.$identityHash = hash;
      }
      return hash;
    }
    static _parseIntError(source, handleError) {
      if (handleError == null) dart.throw(new core.FormatException(source));
      return handleError(source);
    }
    static parseInt(source, radix, handleError) {
      _js_helper.checkString(source);
      let re = /^\s*[+-]?((0x[a-f0-9]+)|(\d+)|([a-z0-9]+))\s*$/i;
      let match = re.exec(source);
      let digitsIndex = 1;
      let hexIndex = 2;
      let decimalIndex = 3;
      let nonDecimalHexIndex = 4;
      if (match == null) {
        return _js_helper.Primitives._parseIntError(source, handleError);
      }
      let decimalMatch = match[dartx.get](decimalIndex);
      if (radix == null) {
        if (decimalMatch != null) {
          return parseInt(source, 10);
        }
        if (match[dartx.get](hexIndex) != null) {
          return parseInt(source, 16);
        }
        return _js_helper.Primitives._parseIntError(source, handleError);
      }
      if (!(typeof radix == 'number')) {
        dart.throw(new core.ArgumentError.value(radix, 'radix', 'is not an integer'));
      }
      if (dart.notNull(radix) < 2 || dart.notNull(radix) > 36) {
        dart.throw(new core.RangeError.range(radix, 2, 36, 'radix'));
      }
      if (radix == 10 && decimalMatch != null) {
        return parseInt(source, 10);
      }
      if (dart.notNull(radix) < 10 || decimalMatch == null) {
        let maxCharCode = null;
        if (dart.notNull(radix) <= 10) {
          maxCharCode = 48 - 1 + dart.notNull(radix);
        } else {
          maxCharCode = 97 - 10 - 1 + dart.notNull(radix);
        }
        dart.assert(typeof match[dartx.get](digitsIndex) == 'string');
        let digitsPart = match[digitsIndex];
        for (let i = 0; i < dart.notNull(digitsPart[dartx.length]); i++) {
          let characterCode = (dart.notNull(digitsPart[dartx.codeUnitAt](i)) | 32) >>> 0;
          if (characterCode > dart.notNull(maxCharCode)) {
            return _js_helper.Primitives._parseIntError(source, handleError);
          }
        }
      }
      return parseInt(source, radix);
    }
    static _parseDoubleError(source, handleError) {
      if (handleError == null) {
        dart.throw(new core.FormatException('Invalid double', source));
      }
      return handleError(source);
    }
    static parseDouble(source, handleError) {
      _js_helper.checkString(source);
      if (!/^\s*[+-]?(?:Infinity|NaN|(?:\.\d+|\d+(?:\.\d*)?)(?:[eE][+-]?\d+)?)\s*$/.test(source)) {
        return _js_helper.Primitives._parseDoubleError(source, handleError);
      }
      let result = parseFloat(source);
      if (dart.test(result[dartx.isNaN])) {
        let trimmed = source[dartx.trim]();
        if (trimmed == 'NaN' || trimmed == '+NaN' || trimmed == '-NaN') {
          return result;
        }
        return _js_helper.Primitives._parseDoubleError(source, handleError);
      }
      return result;
    }
    static objectTypeName(object) {
      return dart.toString(_js_helper.getRuntimeType(object));
    }
    static objectToString(object) {
      let name = dart.typeName(dart.getReifiedType(object));
      return dart.str`Instance of '${name}'`;
    }
    static dateNow() {
      return Date.now();
    }
    static initTicker() {
      if (_js_helper.Primitives.timerFrequency != null) return;
      _js_helper.Primitives.timerFrequency = 1000;
      _js_helper.Primitives.timerTicks = _js_helper.Primitives.dateNow;
      if (typeof window == "undefined") return;
      let jsWindow = window;
      if (jsWindow == null) return;
      let performance = jsWindow.performance;
      if (performance == null) return;
      if (typeof performance.now != "function") return;
      _js_helper.Primitives.timerFrequency = 1000000;
      _js_helper.Primitives.timerTicks = dart.fn(() => (1000 * performance.now())[dartx.floor](), VoidToint());
    }
    static get isD8() {
      return typeof version == "function" && typeof os == "object" && "system" in os;
    }
    static get isJsshell() {
      return typeof version == "function" && typeof system == "function";
    }
    static currentUri() {
      if (!!self.location) {
        return self.location.href;
      }
      return null;
    }
    static _fromCharCodeApply(array) {
      let kMaxApply = 500;
      let end = array[dartx.length];
      if (dart.notNull(end) <= kMaxApply) {
        return String.fromCharCode.apply(null, array);
      }
      let result = '';
      for (let i = 0; i < dart.notNull(end); i = i + kMaxApply) {
        let chunkEnd = i + kMaxApply < dart.notNull(end) ? i + kMaxApply : end;
        result = result + String.fromCharCode.apply(null, array.slice(i, chunkEnd));
      }
      return result;
    }
    static stringFromCodePoints(codePoints) {
      let a = JSArrayOfint().of([]);
      for (let i of codePoints) {
        if (!(typeof i == 'number')) dart.throw(_js_helper.argumentErrorValue(i));
        if (dart.notNull(i) <= 65535) {
          a[dartx.add](i);
        } else if (dart.notNull(i) <= 1114111) {
          a[dartx.add](55296 + (dart.notNull(i) - 65536 >> 10 & 1023));
          a[dartx.add](56320 + (dart.notNull(i) & 1023));
        } else {
          dart.throw(_js_helper.argumentErrorValue(i));
        }
      }
      return _js_helper.Primitives._fromCharCodeApply(a);
    }
    static stringFromCharCodes(charCodes) {
      for (let i of charCodes) {
        if (!(typeof i == 'number')) dart.throw(_js_helper.argumentErrorValue(i));
        if (dart.notNull(i) < 0) dart.throw(_js_helper.argumentErrorValue(i));
        if (dart.notNull(i) > 65535) return _js_helper.Primitives.stringFromCodePoints(charCodes);
      }
      return _js_helper.Primitives._fromCharCodeApply(charCodes);
    }
    static stringFromNativeUint8List(charCodes, start, end) {
      let kMaxApply = 500;
      if (dart.notNull(end) <= kMaxApply && start == 0 && end == charCodes[dartx.length]) {
        return String.fromCharCode.apply(null, charCodes);
      }
      let result = '';
      for (let i = start; dart.notNull(i) < dart.notNull(end); i = dart.notNull(i) + kMaxApply) {
        let chunkEnd = dart.notNull(i) + kMaxApply < dart.notNull(end) ? dart.notNull(i) + kMaxApply : end;
        result = result + String.fromCharCode.apply(null, charCodes.subarray(i, chunkEnd));
      }
      return result;
    }
    static stringFromCharCode(charCode) {
      if (0 <= dart.notNull(charCode)) {
        if (dart.notNull(charCode) <= 65535) {
          return String.fromCharCode(charCode);
        }
        if (dart.notNull(charCode) <= 1114111) {
          let bits = dart.notNull(charCode) - 65536;
          let low = 56320 | bits & 1023;
          let high = (55296 | bits[dartx['>>']](10)) >>> 0;
          return String.fromCharCode(high, low);
        }
      }
      dart.throw(new core.RangeError.range(charCode, 0, 1114111));
    }
    static stringConcatUnchecked(string1, string2) {
      return _foreign_helper.JS_STRING_CONCAT(string1, string2);
    }
    static flattenString(str) {
      return str.charCodeAt(0) == 0 ? str : str;
    }
    static getTimeZoneName(receiver) {
      let d = _js_helper.Primitives.lazyAsJsDate(receiver);
      let match = /\((.*)\)/.exec(d.toString());
      if (match != null) return core.String._check(match[dartx.get](1));
      match = /^[A-Z,a-z]{3}\s[A-Z,a-z]{3}\s\d+\s\d{2}:\d{2}:\d{2}\s([A-Z]{3,5})\s\d{4}$/.exec(d.toString());
      if (match != null) return core.String._check(match[dartx.get](1));
      match = /(?:GMT|UTC)[+-]\d{4}/.exec(d.toString());
      if (match != null) return core.String._check(match[dartx.get](0));
      return "";
    }
    static getTimeZoneOffsetInMinutes(receiver) {
      return -_js_helper.Primitives.lazyAsJsDate(receiver).getTimezoneOffset();
    }
    static valueFromDecomposedDate(years, month, day, hours, minutes, seconds, milliseconds, isUtc) {
      let MAX_MILLISECONDS_SINCE_EPOCH = 8640000000000000;
      _js_helper.checkInt(years);
      _js_helper.checkInt(month);
      _js_helper.checkInt(day);
      _js_helper.checkInt(hours);
      _js_helper.checkInt(minutes);
      _js_helper.checkInt(seconds);
      _js_helper.checkInt(milliseconds);
      _js_helper.checkBool(isUtc);
      let jsMonth = dart.notNull(month) - 1;
      let value = null;
      if (dart.test(isUtc)) {
        value = Date.UTC(years, jsMonth, day, hours, minutes, seconds, milliseconds);
      } else {
        value = new Date(years, jsMonth, day, hours, minutes, seconds, milliseconds).valueOf();
      }
      if (dart.test(value[dartx.isNaN]) || dart.notNull(value) < -MAX_MILLISECONDS_SINCE_EPOCH || dart.notNull(value) > MAX_MILLISECONDS_SINCE_EPOCH) {
        return null;
      }
      if (dart.notNull(years) <= 0 || dart.notNull(years) < 100) return core.num._check(_js_helper.Primitives.patchUpY2K(value, years, isUtc));
      return value;
    }
    static patchUpY2K(value, years, isUtc) {
      let date = new Date(value);
      if (dart.test(isUtc)) {
        date.setUTCFullYear(years);
      } else {
        date.setFullYear(years);
      }
      return date.valueOf();
    }
    static lazyAsJsDate(receiver) {
      if (receiver.date === void 0) {
        receiver.date = new Date(receiver.millisecondsSinceEpoch);
      }
      return receiver.date;
    }
    static getYear(receiver) {
      return dart.test(receiver.isUtc) ? _js_helper.Primitives.lazyAsJsDate(receiver).getUTCFullYear() + 0 : _js_helper.Primitives.lazyAsJsDate(receiver).getFullYear() + 0;
    }
    static getMonth(receiver) {
      return dart.test(receiver.isUtc) ? _js_helper.Primitives.lazyAsJsDate(receiver).getUTCMonth() + 1 : _js_helper.Primitives.lazyAsJsDate(receiver).getMonth() + 1;
    }
    static getDay(receiver) {
      return dart.test(receiver.isUtc) ? _js_helper.Primitives.lazyAsJsDate(receiver).getUTCDate() + 0 : _js_helper.Primitives.lazyAsJsDate(receiver).getDate() + 0;
    }
    static getHours(receiver) {
      return dart.test(receiver.isUtc) ? _js_helper.Primitives.lazyAsJsDate(receiver).getUTCHours() + 0 : _js_helper.Primitives.lazyAsJsDate(receiver).getHours() + 0;
    }
    static getMinutes(receiver) {
      return dart.test(receiver.isUtc) ? _js_helper.Primitives.lazyAsJsDate(receiver).getUTCMinutes() + 0 : _js_helper.Primitives.lazyAsJsDate(receiver).getMinutes() + 0;
    }
    static getSeconds(receiver) {
      return dart.test(receiver.isUtc) ? _js_helper.Primitives.lazyAsJsDate(receiver).getUTCSeconds() + 0 : _js_helper.Primitives.lazyAsJsDate(receiver).getSeconds() + 0;
    }
    static getMilliseconds(receiver) {
      return dart.test(receiver.isUtc) ? _js_helper.Primitives.lazyAsJsDate(receiver).getUTCMilliseconds() + 0 : _js_helper.Primitives.lazyAsJsDate(receiver).getMilliseconds() + 0;
    }
    static getWeekday(receiver) {
      let weekday = dart.test(receiver.isUtc) ? _js_helper.Primitives.lazyAsJsDate(receiver).getUTCDay() + 0 : _js_helper.Primitives.lazyAsJsDate(receiver).getDay() + 0;
      return (weekday + 6)[dartx['%']](7) + 1;
    }
    static valueFromDateString(str) {
      if (!(typeof str == 'string')) dart.throw(_js_helper.argumentErrorValue(str));
      let value = Date.parse(str);
      if (dart.test(value[dartx.isNaN])) dart.throw(_js_helper.argumentErrorValue(str));
      return value;
    }
    static getProperty(object, key) {
      if (object == null || typeof object == 'boolean' || typeof object == 'number' || typeof object == 'string') {
        dart.throw(_js_helper.argumentErrorValue(object));
      }
      return object[key];
    }
    static setProperty(object, key, value) {
      if (object == null || typeof object == 'boolean' || typeof object == 'number' || typeof object == 'string') {
        dart.throw(_js_helper.argumentErrorValue(object));
      }
      object[key] = value;
    }
    static extractStackTrace(error) {
      return _js_helper.getTraceFromException(error.$thrownJsError);
    }
  };
  dart.setSignature(_js_helper.Primitives, {
    statics: () => ({
      initializeStatics: dart.definiteFunctionType(dart.void, [core.int]),
      objectHashCode: dart.definiteFunctionType(core.int, [dart.dynamic]),
      _parseIntError: dart.definiteFunctionType(core.int, [core.String, dart.functionType(core.int, [core.String])]),
      parseInt: dart.definiteFunctionType(core.int, [core.String, core.int, dart.functionType(core.int, [core.String])]),
      _parseDoubleError: dart.definiteFunctionType(core.double, [core.String, dart.functionType(core.double, [core.String])]),
      parseDouble: dart.definiteFunctionType(core.double, [core.String, dart.functionType(core.double, [core.String])]),
      objectTypeName: dart.definiteFunctionType(core.String, [core.Object]),
      objectToString: dart.definiteFunctionType(core.String, [core.Object]),
      dateNow: dart.definiteFunctionType(core.int, []),
      initTicker: dart.definiteFunctionType(dart.void, []),
      currentUri: dart.definiteFunctionType(core.String, []),
      _fromCharCodeApply: dart.definiteFunctionType(core.String, [core.List$(core.int)]),
      stringFromCodePoints: dart.definiteFunctionType(core.String, [_interceptors.JSArray$(core.int)]),
      stringFromCharCodes: dart.definiteFunctionType(core.String, [_interceptors.JSArray$(core.int)]),
      stringFromNativeUint8List: dart.definiteFunctionType(core.String, [_native_typed_data.NativeUint8List, core.int, core.int]),
      stringFromCharCode: dart.definiteFunctionType(core.String, [core.int]),
      stringConcatUnchecked: dart.definiteFunctionType(core.String, [core.String, core.String]),
      flattenString: dart.definiteFunctionType(core.String, [core.String]),
      getTimeZoneName: dart.definiteFunctionType(core.String, [core.DateTime]),
      getTimeZoneOffsetInMinutes: dart.definiteFunctionType(core.int, [core.DateTime]),
      valueFromDecomposedDate: dart.definiteFunctionType(core.num, [core.int, core.int, core.int, core.int, core.int, core.int, core.int, core.bool]),
      patchUpY2K: dart.definiteFunctionType(dart.dynamic, [dart.dynamic, dart.dynamic, dart.dynamic]),
      lazyAsJsDate: dart.definiteFunctionType(dart.dynamic, [core.DateTime]),
      getYear: dart.definiteFunctionType(dart.dynamic, [core.DateTime]),
      getMonth: dart.definiteFunctionType(dart.dynamic, [core.DateTime]),
      getDay: dart.definiteFunctionType(dart.dynamic, [core.DateTime]),
      getHours: dart.definiteFunctionType(dart.dynamic, [core.DateTime]),
      getMinutes: dart.definiteFunctionType(dart.dynamic, [core.DateTime]),
      getSeconds: dart.definiteFunctionType(dart.dynamic, [core.DateTime]),
      getMilliseconds: dart.definiteFunctionType(dart.dynamic, [core.DateTime]),
      getWeekday: dart.definiteFunctionType(dart.dynamic, [core.DateTime]),
      valueFromDateString: dart.definiteFunctionType(dart.dynamic, [dart.dynamic]),
      getProperty: dart.definiteFunctionType(dart.dynamic, [dart.dynamic, dart.dynamic]),
      setProperty: dart.definiteFunctionType(dart.void, [dart.dynamic, dart.dynamic, dart.dynamic]),
      extractStackTrace: dart.definiteFunctionType(core.StackTrace, [core.Error])
    }),
    names: ['initializeStatics', 'objectHashCode', '_parseIntError', 'parseInt', '_parseDoubleError', 'parseDouble', 'objectTypeName', 'objectToString', 'dateNow', 'initTicker', 'currentUri', '_fromCharCodeApply', 'stringFromCodePoints', 'stringFromCharCodes', 'stringFromNativeUint8List', 'stringFromCharCode', 'stringConcatUnchecked', 'flattenString', 'getTimeZoneName', 'getTimeZoneOffsetInMinutes', 'valueFromDecomposedDate', 'patchUpY2K', 'lazyAsJsDate', 'getYear', 'getMonth', 'getDay', 'getHours', 'getMinutes', 'getSeconds', 'getMilliseconds', 'getWeekday', 'valueFromDateString', 'getProperty', 'setProperty', 'extractStackTrace']
  });
  _js_helper.Primitives.mirrorFunctionCacheName = '$cachedFunction';
  _js_helper.Primitives.mirrorInvokeCacheName = '$cachedInvocation';
  _js_helper.Primitives.DOLLAR_CHAR_VALUE = 36;
  _js_helper.Primitives.timerFrequency = null;
  _js_helper.Primitives.timerTicks = null;
  _js_helper.diagnoseIndexError = function(indexable, index) {
    if (!(typeof index == 'number')) return new core.ArgumentError.value(index, 'index');
    let length = core.int._check(dart.dload(indexable, 'length'));
    if (dart.test(dart.dsend(index, '<', 0)) || dart.test(dart.dsend(index, '>=', length))) {
      return core.RangeError.index(core.int._check(index), indexable, 'index', null, length);
    }
    return new core.RangeError.value(core.num._check(index), 'index');
  };
  dart.lazyFn(_js_helper.diagnoseIndexError, () => dynamicAnddynamicToError());
  _js_helper.diagnoseRangeError = function(start, end, length) {
    if (!(typeof start == 'number')) {
      return new core.ArgumentError.value(start, 'start');
    }
    if (dart.test(dart.dsend(start, '<', 0)) || dart.test(dart.dsend(start, '>', length))) {
      return new core.RangeError.range(core.num._check(start), 0, core.int._check(length), 'start');
    }
    if (end != null) {
      if (!(typeof end == 'number')) {
        return new core.ArgumentError.value(end, 'end');
      }
      if (dart.test(dart.dsend(end, '<', start)) || dart.test(dart.dsend(end, '>', length))) {
        return new core.RangeError.range(core.num._check(end), core.int._check(start), core.int._check(length), 'end');
      }
    }
    return new core.ArgumentError.value(end, "end");
  };
  dart.lazyFn(_js_helper.diagnoseRangeError, () => dynamicAnddynamicAnddynamicToError());
  _js_helper.stringLastIndexOfUnchecked = function(receiver, element, start) {
    return receiver.lastIndexOf(element, start);
  };
  dart.fn(_js_helper.stringLastIndexOfUnchecked, dynamicAnddynamicAnddynamicTodynamic());
  _js_helper.argumentErrorValue = function(object) {
    return new core.ArgumentError.value(object);
  };
  dart.lazyFn(_js_helper.argumentErrorValue, () => dynamicToArgumentError());
  _js_helper.checkNull = function(object) {
    if (object == null) dart.throw(_js_helper.argumentErrorValue(object));
    return object;
  };
  dart.fn(_js_helper.checkNull, dynamicTodynamic$());
  _js_helper.checkNum = function(value) {
    if (!(typeof value == 'number')) dart.throw(_js_helper.argumentErrorValue(value));
    return value;
  };
  dart.fn(_js_helper.checkNum, dynamicTodynamic$());
  _js_helper.checkInt = function(value) {
    if (!(typeof value == 'number')) dart.throw(_js_helper.argumentErrorValue(value));
    return value;
  };
  dart.fn(_js_helper.checkInt, dynamicTodynamic$());
  _js_helper.checkBool = function(value) {
    if (!(typeof value == 'boolean')) dart.throw(_js_helper.argumentErrorValue(value));
    return value;
  };
  dart.fn(_js_helper.checkBool, dynamicTodynamic$());
  _js_helper.checkString = function(value) {
    if (!(typeof value == 'string')) dart.throw(_js_helper.argumentErrorValue(value));
    return value;
  };
  dart.fn(_js_helper.checkString, dynamicTodynamic$());
  _js_helper.throwRuntimeError = function(message) {
    dart.throw(new _js_helper.RuntimeError(message));
  };
  dart.fn(_js_helper.throwRuntimeError, dynamicTodynamic$());
  _js_helper.throwAbstractClassInstantiationError = function(className) {
    dart.throw(new core.AbstractClassInstantiationError(core.String._check(className)));
  };
  dart.fn(_js_helper.throwAbstractClassInstantiationError, dynamicTodynamic$());
  _js_helper.throwConcurrentModificationError = function(collection) {
    dart.throw(new core.ConcurrentModificationError(collection));
  };
  dart.fn(_js_helper.throwConcurrentModificationError, dynamicTodynamic$());
  const _message = Symbol('_message');
  const _method = Symbol('_method');
  core.Error = class Error extends core.Object {
    new() {
    }
    static safeToString(object) {
      if (typeof object == 'number' || typeof object == 'boolean' || null == object) {
        return dart.toString(object);
      }
      if (typeof object == 'string') {
        return core.Error._stringToSafeString(object);
      }
      return core.Error._objectToString(object);
    }
    static _stringToSafeString(string) {
      return _js_helper.jsonEncodeNative(string);
    }
    static _objectToString(object) {
      return _js_helper.Primitives.objectToString(object);
    }
    get stackTrace() {
      return _js_helper.Primitives.extractStackTrace(this);
    }
  };
  dart.setSignature(core.Error, {
    constructors: () => ({new: dart.definiteFunctionType(core.Error, [])}),
    statics: () => ({
      safeToString: dart.definiteFunctionType(core.String, [core.Object]),
      _stringToSafeString: dart.definiteFunctionType(core.String, [core.String]),
      _objectToString: dart.definiteFunctionType(core.String, [core.Object])
    }),
    names: ['safeToString', '_stringToSafeString', '_objectToString']
  });
  _js_helper.NullError = class NullError extends core.Error {
    new(message, match) {
      this[_message] = message;
      this[_method] = core.String._check(match == null ? null : match.method);
      super.new();
    }
    toString() {
      if (this[_method] == null) return dart.str`NullError: ${this[_message]}`;
      return dart.str`NullError: method not found: '${this[_method]}' on null`;
    }
  };
  _js_helper.NullError[dart.implements] = () => [core.NoSuchMethodError];
  dart.setSignature(_js_helper.NullError, {
    constructors: () => ({new: dart.definiteFunctionType(_js_helper.NullError, [core.String, dart.dynamic])})
  });
  const _receiver = Symbol('_receiver');
  _js_helper.JsNoSuchMethodError = class JsNoSuchMethodError extends core.Error {
    new(message, match) {
      this[_message] = message;
      this[_method] = core.String._check(match == null ? null : match.method);
      this[_receiver] = core.String._check(match == null ? null : match.receiver);
      super.new();
    }
    toString() {
      if (this[_method] == null) return dart.str`NoSuchMethodError: ${this[_message]}`;
      if (this[_receiver] == null) {
        return dart.str`NoSuchMethodError: method not found: '${this[_method]}' (${this[_message]})`;
      }
      return "NoSuchMethodError: " + dart.str`method not found: '${this[_method]}' on '${this[_receiver]}' (${this[_message]})`;
    }
  };
  _js_helper.JsNoSuchMethodError[dart.implements] = () => [core.NoSuchMethodError];
  dart.setSignature(_js_helper.JsNoSuchMethodError, {
    constructors: () => ({new: dart.definiteFunctionType(_js_helper.JsNoSuchMethodError, [core.String, dart.dynamic])})
  });
  _js_helper.UnknownJsTypeError = class UnknownJsTypeError extends core.Error {
    new(message) {
      this[_message] = message;
      super.new();
    }
    toString() {
      return dart.test(this[_message][dartx.isEmpty]) ? 'Error' : dart.str`Error: ${this[_message]}`;
    }
  };
  dart.setSignature(_js_helper.UnknownJsTypeError, {
    constructors: () => ({new: dart.definiteFunctionType(_js_helper.UnknownJsTypeError, [core.String])})
  });
  _js_helper.getTraceFromException = function(exception) {
    return new _js_helper._StackTrace(exception);
  };
  dart.lazyFn(_js_helper.getTraceFromException, () => dynamicToStackTrace());
  const _exception = Symbol('_exception');
  const _trace = Symbol('_trace');
  _js_helper._StackTrace = class _StackTrace extends core.Object {
    new(exception) {
      this[_exception] = exception;
      this[_trace] = null;
    }
    toString() {
      if (this[_trace] != null) return this[_trace];
      let trace = null;
      if (this[_exception] !== null && typeof this[_exception] === "object") {
        trace = this[_exception].stack;
      }
      return this[_trace] = trace == null ? '' : trace;
    }
  };
  _js_helper._StackTrace[dart.implements] = () => [core.StackTrace];
  dart.setSignature(_js_helper._StackTrace, {
    constructors: () => ({new: dart.definiteFunctionType(_js_helper._StackTrace, [dart.dynamic])})
  });
  _js_helper.objectHashCode = function(object) {
    if (object == null || typeof object != 'object') {
      return dart.hashCode(object);
    } else {
      return _js_helper.Primitives.objectHashCode(object);
    }
  };
  dart.fn(_js_helper.objectHashCode, dynamicToint());
  _js_helper.fillLiteralMap = function(keyValuePairs, result) {
    let index = 0;
    let length = _js_helper.getLength(keyValuePairs);
    while (index < dart.notNull(length)) {
      let key = _js_helper.getIndex(keyValuePairs, index++);
      let value = _js_helper.getIndex(keyValuePairs, index++);
      result[dartx.set](key, value);
    }
    return result;
  };
  dart.lazyFn(_js_helper.fillLiteralMap, () => dynamicAndMapTodynamic());
  _js_helper.jsHasOwnProperty = function(jsObject, property) {
    return jsObject.hasOwnProperty(property);
  };
  dart.lazyFn(_js_helper.jsHasOwnProperty, () => dynamicAndStringTobool());
  _js_helper.jsPropertyAccess = function(jsObject, property) {
    return jsObject[property];
  };
  dart.lazyFn(_js_helper.jsPropertyAccess, () => dynamicAndStringTodynamic());
  _js_helper.getFallThroughError = function() {
    return new _js_helper.FallThroughErrorImplementation();
  };
  dart.fn(_js_helper.getFallThroughError, VoidTodynamic$());
  _js_helper.Creates = class Creates extends core.Object {
    new(types) {
      this.types = types;
    }
  };
  dart.setSignature(_js_helper.Creates, {
    constructors: () => ({new: dart.definiteFunctionType(_js_helper.Creates, [core.String])})
  });
  _js_helper.Returns = class Returns extends core.Object {
    new(types) {
      this.types = types;
    }
  };
  dart.setSignature(_js_helper.Returns, {
    constructors: () => ({new: dart.definiteFunctionType(_js_helper.Returns, [core.String])})
  });
  _js_helper.JSName = class JSName extends core.Object {
    new(name) {
      this.name = name;
    }
  };
  dart.setSignature(_js_helper.JSName, {
    constructors: () => ({new: dart.definiteFunctionType(_js_helper.JSName, [core.String])})
  });
  _js_helper.JavaScriptIndexingBehavior = class JavaScriptIndexingBehavior extends _interceptors.JSMutableIndexable {};
  _js_helper.TypeErrorImplementation = class TypeErrorImplementation extends core.Error {
    new(value, actualType, expectedType) {
      this.message = dart.str`Type '${actualType}' is not a subtype ` + dart.str`of type '${expectedType}'`;
      super.new();
    }
    fromMessage(message) {
      this.message = message;
      super.new();
    }
    toString() {
      return this.message;
    }
  };
  dart.defineNamedConstructor(_js_helper.TypeErrorImplementation, 'fromMessage');
  _js_helper.TypeErrorImplementation[dart.implements] = () => [core.TypeError];
  dart.setSignature(_js_helper.TypeErrorImplementation, {
    constructors: () => ({
      new: dart.definiteFunctionType(_js_helper.TypeErrorImplementation, [core.Object, core.Object, core.Object]),
      fromMessage: dart.definiteFunctionType(_js_helper.TypeErrorImplementation, [core.String])
    })
  });
  _js_helper.CastErrorImplementation = class CastErrorImplementation extends core.Error {
    new(value, actualType, expectedType) {
      this.message = dart.str`CastError: Casting value of type '${actualType}' to` + dart.str` incompatible type '${expectedType}'`;
      super.new();
    }
    toString() {
      return this.message;
    }
  };
  _js_helper.CastErrorImplementation[dart.implements] = () => [core.CastError];
  dart.setSignature(_js_helper.CastErrorImplementation, {
    constructors: () => ({new: dart.definiteFunctionType(_js_helper.CastErrorImplementation, [core.Object, core.Object, core.Object])})
  });
  _js_helper.StrongModeTypeError = class StrongModeTypeError extends core.Error {
    new(value, actualType, expectedType) {
      this.message = dart.str`Type '${actualType}' is not a subtype ` + dart.str`of type '${expectedType}' in strong mode`;
      super.new();
    }
    toString() {
      return this.message;
    }
  };
  _js_helper.StrongModeTypeError[dart.implements] = () => [core.TypeError, core.StrongModeError];
  dart.setSignature(_js_helper.StrongModeTypeError, {
    constructors: () => ({new: dart.definiteFunctionType(_js_helper.StrongModeTypeError, [core.Object, core.Object, core.Object])})
  });
  _js_helper.StrongModeCastError = class StrongModeCastError extends core.Error {
    new(value, actualType, expectedType) {
      this.message = dart.str`CastError: Casting value of type '${actualType}' to` + dart.str` type '${expectedType}' which is incompatible in strong mode`;
      super.new();
    }
    toString() {
      return this.message;
    }
  };
  _js_helper.StrongModeCastError[dart.implements] = () => [core.CastError, core.StrongModeError];
  dart.setSignature(_js_helper.StrongModeCastError, {
    constructors: () => ({new: dart.definiteFunctionType(_js_helper.StrongModeCastError, [core.Object, core.Object, core.Object])})
  });
  _js_helper.StrongModeErrorImplementation = class StrongModeErrorImplementation extends core.Error {
    new(message) {
      this.message = message;
      super.new();
    }
    toString() {
      return this.message;
    }
  };
  _js_helper.StrongModeErrorImplementation[dart.implements] = () => [core.StrongModeError];
  dart.setSignature(_js_helper.StrongModeErrorImplementation, {
    constructors: () => ({new: dart.definiteFunctionType(_js_helper.StrongModeErrorImplementation, [core.String])})
  });
  core.FallThroughError = class FallThroughError extends core.Error {
    new() {
      super.new();
    }
  };
  dart.setSignature(core.FallThroughError, {
    constructors: () => ({new: dart.definiteFunctionType(core.FallThroughError, [])})
  });
  _js_helper.FallThroughErrorImplementation = class FallThroughErrorImplementation extends core.FallThroughError {
    new() {
      super.new();
    }
    toString() {
      return "Switch case fall-through.";
    }
  };
  dart.setSignature(_js_helper.FallThroughErrorImplementation, {
    constructors: () => ({new: dart.definiteFunctionType(_js_helper.FallThroughErrorImplementation, [])})
  });
  _js_helper.RuntimeError = class RuntimeError extends core.Error {
    new(message) {
      this.message = message;
      super.new();
    }
    toString() {
      return dart.str`RuntimeError: ${this.message}`;
    }
  };
  dart.setSignature(_js_helper.RuntimeError, {
    constructors: () => ({new: dart.definiteFunctionType(_js_helper.RuntimeError, [dart.dynamic])})
  });
  _js_helper.random64 = function() {
    let int32a = Math.random() * 0x100000000 >>> 0;
    let int32b = Math.random() * 0x100000000 >>> 0;
    return int32a + int32b * 4294967296;
  };
  dart.fn(_js_helper.random64, VoidToint());
  _js_helper.jsonEncodeNative = function(string) {
    return JSON.stringify(string);
  };
  dart.lazyFn(_js_helper.jsonEncodeNative, () => StringToString$());
  const _jsIterator = Symbol('_jsIterator');
  const _current$0 = Symbol('_current');
  _js_helper.SyncIterator$ = dart.generic(E => {
    let IteratorOfE = () => (IteratorOfE = dart.constFn(core.Iterator$(E)))();
    class SyncIterator extends core.Object {
      new(jsIterator) {
        this[_jsIterator] = jsIterator;
        this[_current$0] = null;
      }
      get current() {
        return this[_current$0];
      }
      moveNext() {
        let ret = this[_jsIterator].next();
        this[_current$0] = ret.value;
        return !ret.done;
      }
    }
    dart.addTypeTests(SyncIterator);
    SyncIterator[dart.implements] = () => [IteratorOfE()];
    dart.setSignature(SyncIterator, {
      constructors: () => ({new: dart.definiteFunctionType(_js_helper.SyncIterator$(E), [dart.dynamic])}),
      methods: () => ({moveNext: dart.definiteFunctionType(core.bool, [])})
    });
    return SyncIterator;
  });
  _js_helper.SyncIterator = SyncIterator();
  const _generator = Symbol('_generator');
  const _args = Symbol('_args');
  collection.IterableBase$ = dart.generic(E => {
    class IterableBase extends core.Iterable$(E) {
      new() {
        super.new();
      }
      static iterableToShortString(iterable, leftDelimiter, rightDelimiter) {
        if (leftDelimiter === void 0) leftDelimiter = '(';
        if (rightDelimiter === void 0) rightDelimiter = ')';
        if (dart.test(collection._isToStringVisiting(iterable))) {
          if (leftDelimiter == "(" && rightDelimiter == ")") {
            return "(...)";
          }
          return dart.str`${leftDelimiter}...${rightDelimiter}`;
        }
        let parts = [];
        collection._toStringVisiting[dartx.add](iterable);
        try {
          collection._iterablePartsToStrings(iterable, parts);
        } finally {
          dart.assert(core.identical(collection._toStringVisiting[dartx.last], iterable));
          collection._toStringVisiting[dartx.removeLast]();
        }
        return (() => {
          let _ = new core.StringBuffer(leftDelimiter);
          _.writeAll(parts, ", ");
          _.write(rightDelimiter);
          return _;
        })().toString();
      }
      static iterableToFullString(iterable, leftDelimiter, rightDelimiter) {
        if (leftDelimiter === void 0) leftDelimiter = '(';
        if (rightDelimiter === void 0) rightDelimiter = ')';
        if (dart.test(collection._isToStringVisiting(iterable))) {
          return dart.str`${leftDelimiter}...${rightDelimiter}`;
        }
        let buffer = new core.StringBuffer(leftDelimiter);
        collection._toStringVisiting[dartx.add](iterable);
        try {
          buffer.writeAll(iterable, ", ");
        } finally {
          dart.assert(core.identical(collection._toStringVisiting[dartx.last], iterable));
          collection._toStringVisiting[dartx.removeLast]();
        }
        buffer.write(rightDelimiter);
        return buffer.toString();
      }
    }
    dart.setSignature(IterableBase, {
      constructors: () => ({new: dart.definiteFunctionType(collection.IterableBase$(E), [])}),
      statics: () => ({
        iterableToShortString: dart.definiteFunctionType(core.String, [core.Iterable], [core.String, core.String]),
        iterableToFullString: dart.definiteFunctionType(core.String, [core.Iterable], [core.String, core.String])
      }),
      names: ['iterableToShortString', 'iterableToFullString']
    });
    return IterableBase;
  });
  collection.IterableBase = IterableBase();
  _js_helper.SyncIterable$ = dart.generic(E => {
    let SyncIteratorOfE = () => (SyncIteratorOfE = dart.constFn(_js_helper.SyncIterator$(E)))();
    class SyncIterable extends collection.IterableBase$(E) {
      new(generator, args) {
        this[_generator] = generator;
        this[_args] = args;
        super.new();
      }
      [_jsIterator]() {
        return this[_generator](...this[_args]);
      }
      get iterator() {
        return new (SyncIteratorOfE())(this[_jsIterator]());
      }
    }
    dart.setSignature(SyncIterable, {
      constructors: () => ({new: dart.definiteFunctionType(_js_helper.SyncIterable$(E), [dart.dynamic, dart.dynamic])}),
      methods: () => ({[_jsIterator]: dart.definiteFunctionType(dart.dynamic, [])})
    });
    dart.defineExtensionMembers(SyncIterable, ['iterator']);
    return SyncIterable;
  });
  _js_helper.SyncIterable = SyncIterable();
  core.AssertionError = class AssertionError extends core.Error {
    new() {
      super.new();
    }
    toString() {
      return "Assertion failed";
    }
  };
  dart.setSignature(core.AssertionError, {
    constructors: () => ({new: dart.definiteFunctionType(core.AssertionError, [])})
  });
  _js_helper.BooleanConversionAssertionError = class BooleanConversionAssertionError extends core.AssertionError {
    new() {
      super.new();
    }
    toString() {
      return 'Failed assertion: boolean expression must not be null';
    }
  };
  _js_helper.NoThrows = class NoThrows extends core.Object {
    new() {
    }
  };
  dart.setSignature(_js_helper.NoThrows, {
    constructors: () => ({new: dart.definiteFunctionType(_js_helper.NoThrows, [])})
  });
  _js_helper.NoInline = class NoInline extends core.Object {
    new() {
    }
  };
  dart.setSignature(_js_helper.NoInline, {
    constructors: () => ({new: dart.definiteFunctionType(_js_helper.NoInline, [])})
  });
  _js_helper.Native = class Native extends core.Object {
    new(name) {
      this.name = name;
    }
  };
  dart.setSignature(_js_helper.Native, {
    constructors: () => ({new: dart.definiteFunctionType(_js_helper.Native, [core.String])})
  });
  _js_helper.JsPeerInterface = class JsPeerInterface extends core.Object {
    new(opts) {
      let name = opts && 'name' in opts ? opts.name : null;
      this.name = name;
    }
  };
  dart.setSignature(_js_helper.JsPeerInterface, {
    constructors: () => ({new: dart.definiteFunctionType(_js_helper.JsPeerInterface, [], {name: core.String})})
  });
  _js_helper.SupportJsExtensionMethods = class SupportJsExtensionMethods extends core.Object {
    new() {
    }
  };
  dart.setSignature(_js_helper.SupportJsExtensionMethods, {
    constructors: () => ({new: dart.definiteFunctionType(_js_helper.SupportJsExtensionMethods, [])})
  });
  const _length$0 = Symbol('_length');
  const _strings = Symbol('_strings');
  const _nums = Symbol('_nums');
  const _rest = Symbol('_rest');
  const _first = Symbol('_first');
  const _last = Symbol('_last');
  const _modifications = Symbol('_modifications');
  const _containsTableEntry = Symbol('_containsTableEntry');
  const _getBucket = Symbol('_getBucket');
  const _getTableCell = Symbol('_getTableCell');
  const _newHashTable = Symbol('_newHashTable');
  const _addHashTableEntry = Symbol('_addHashTableEntry');
  const _getTableBucket = Symbol('_getTableBucket');
  const _newLinkedCell = Symbol('_newLinkedCell');
  const _setTableEntry = Symbol('_setTableEntry');
  const _removeHashTableEntry = Symbol('_removeHashTableEntry');
  const _unlinkCell = Symbol('_unlinkCell');
  const _modified = Symbol('_modified');
  const _next = Symbol('_next');
  const _deleteTableEntry = Symbol('_deleteTableEntry');
  const _previous = Symbol('_previous');
  _js_helper.JsLinkedHashMap$ = dart.generic((K, V) => {
    let JsLinkedHashMapOfK$V = () => (JsLinkedHashMapOfK$V = dart.constFn(_js_helper.JsLinkedHashMap$(K, V)))();
    let LinkedHashMapKeyIterableOfK = () => (LinkedHashMapKeyIterableOfK = dart.constFn(_js_helper.LinkedHashMapKeyIterable$(K)))();
    let MappedIterableOfK$V = () => (MappedIterableOfK$V = dart.constFn(_internal.MappedIterable$(K, V)))();
    let MapOfK$V = () => (MapOfK$V = dart.constFn(core.Map$(K, V)))();
    let LinkedHashMapCellOfK$V = () => (LinkedHashMapCellOfK$V = dart.constFn(_js_helper.LinkedHashMapCell$(K, V)))();
    let LinkedHashMapOfK$V = () => (LinkedHashMapOfK$V = dart.constFn(collection.LinkedHashMap$(K, V)))();
    let VoidToV = () => (VoidToV = dart.constFn(dart.functionType(V, [])))();
    let KToV = () => (KToV = dart.constFn(dart.definiteFunctionType(V, [K])))();
    let KTobool = () => (KTobool = dart.constFn(dart.definiteFunctionType(core.bool, [K])))();
    let KAndVTovoid = () => (KAndVTovoid = dart.constFn(dart.definiteFunctionType(dart.void, [K, V])))();
    class JsLinkedHashMap extends core.Object {
      new() {
        this[_length$0] = 0;
        this[_strings] = null;
        this[_nums] = null;
        this[_rest] = null;
        this[_first] = null;
        this[_last] = null;
        this[_modifications] = 0;
      }
      static es6() {
        return new (JsLinkedHashMapOfK$V())();
      }
      get length() {
        return this[_length$0];
      }
      get isEmpty() {
        return this[_length$0] == 0;
      }
      get isNotEmpty() {
        return !dart.test(this.isEmpty);
      }
      get keys() {
        return new (LinkedHashMapKeyIterableOfK())(this);
      }
      get values() {
        return MappedIterableOfK$V().new(this.keys, dart.fn(each => this.get(each), KToV()));
      }
      containsKey(key) {
        if (dart.test(_js_helper.JsLinkedHashMap._isStringKey(key))) {
          let strings = this[_strings];
          if (strings == null) return false;
          return this[_containsTableEntry](strings, key);
        } else if (dart.test(_js_helper.JsLinkedHashMap._isNumericKey(key))) {
          let nums = this[_nums];
          if (nums == null) return false;
          return this[_containsTableEntry](nums, key);
        } else {
          return this.internalContainsKey(key);
        }
      }
      internalContainsKey(key) {
        let rest = this[_rest];
        if (rest == null) return false;
        let bucket = this[_getBucket](rest, key);
        return dart.notNull(this.internalFindBucketIndex(bucket, key)) >= 0;
      }
      containsValue(value) {
        return this.keys[dartx.any](dart.fn(each => dart.equals(this.get(each), value), KTobool()));
      }
      addAll(other) {
        MapOfK$V()._check(other);
        other[dartx.forEach](dart.fn((key, value) => {
          this.set(key, value);
        }, KAndVTovoid()));
      }
      get(key) {
        if (dart.test(_js_helper.JsLinkedHashMap._isStringKey(key))) {
          let strings = this[_strings];
          if (strings == null) return null;
          let cell = this[_getTableCell](strings, key);
          return cell == null ? null : cell.hashMapCellValue;
        } else if (dart.test(_js_helper.JsLinkedHashMap._isNumericKey(key))) {
          let nums = this[_nums];
          if (nums == null) return null;
          let cell = this[_getTableCell](nums, key);
          return cell == null ? null : cell.hashMapCellValue;
        } else {
          return this.internalGet(key);
        }
      }
      internalGet(key) {
        let rest = this[_rest];
        if (rest == null) return null;
        let bucket = this[_getBucket](rest, key);
        let index = this.internalFindBucketIndex(bucket, key);
        if (dart.notNull(index) < 0) return null;
        let cell = bucket[index];
        return cell.hashMapCellValue;
      }
      set(key, value) {
        K._check(key);
        V._check(value);
        if (dart.test(_js_helper.JsLinkedHashMap._isStringKey(key))) {
          let strings = this[_strings];
          if (strings == null) this[_strings] = strings = this[_newHashTable]();
          this[_addHashTableEntry](strings, key, value);
        } else if (dart.test(_js_helper.JsLinkedHashMap._isNumericKey(key))) {
          let nums = this[_nums];
          if (nums == null) this[_nums] = nums = this[_newHashTable]();
          this[_addHashTableEntry](nums, key, value);
        } else {
          this.internalSet(key, value);
        }
        return value;
      }
      internalSet(key, value) {
        K._check(key);
        V._check(value);
        let rest = this[_rest];
        if (rest == null) this[_rest] = rest = this[_newHashTable]();
        let hash = this.internalComputeHashCode(key);
        let bucket = this[_getTableBucket](rest, hash);
        if (bucket == null) {
          let cell = this[_newLinkedCell](key, value);
          this[_setTableEntry](rest, hash, [cell]);
        } else {
          let index = this.internalFindBucketIndex(bucket, key);
          if (dart.notNull(index) >= 0) {
            let cell = bucket[index];
            cell.hashMapCellValue = value;
          } else {
            let cell = this[_newLinkedCell](key, value);
            bucket.push(cell);
          }
        }
      }
      putIfAbsent(key, ifAbsent) {
        K._check(key);
        VoidToV()._check(ifAbsent);
        if (dart.test(this.containsKey(key))) return this.get(key);
        let value = ifAbsent();
        this.set(key, value);
        return value;
      }
      remove(key) {
        if (dart.test(_js_helper.JsLinkedHashMap._isStringKey(key))) {
          return this[_removeHashTableEntry](this[_strings], key);
        } else if (dart.test(_js_helper.JsLinkedHashMap._isNumericKey(key))) {
          return this[_removeHashTableEntry](this[_nums], key);
        } else {
          return this.internalRemove(key);
        }
      }
      internalRemove(key) {
        let rest = this[_rest];
        if (rest == null) return null;
        let bucket = this[_getBucket](rest, key);
        let index = this.internalFindBucketIndex(bucket, key);
        if (dart.notNull(index) < 0) return null;
        let cell = bucket.splice(index, 1)[0];
        this[_unlinkCell](cell);
        return cell.hashMapCellValue;
      }
      clear() {
        if (dart.notNull(this[_length$0]) > 0) {
          this[_strings] = this[_nums] = this[_rest] = this[_first] = this[_last] = null;
          this[_length$0] = 0;
          this[_modified]();
        }
      }
      forEach(action) {
        let cell = this[_first];
        let modifications = this[_modifications];
        while (cell != null) {
          action(cell.hashMapCellKey, cell.hashMapCellValue);
          if (modifications != this[_modifications]) {
            dart.throw(new core.ConcurrentModificationError(this));
          }
          cell = cell[_next];
        }
      }
      [_addHashTableEntry](table, key, value) {
        K._check(key);
        V._check(value);
        let cell = this[_getTableCell](table, key);
        if (cell == null) {
          this[_setTableEntry](table, key, this[_newLinkedCell](key, value));
        } else {
          cell.hashMapCellValue = value;
        }
      }
      [_removeHashTableEntry](table, key) {
        if (table == null) return null;
        let cell = this[_getTableCell](table, key);
        if (cell == null) return null;
        this[_unlinkCell](cell);
        this[_deleteTableEntry](table, key);
        return cell.hashMapCellValue;
      }
      [_modified]() {
        this[_modifications] = dart.notNull(this[_modifications]) + 1 & 67108863;
      }
      [_newLinkedCell](key, value) {
        K._check(key);
        V._check(value);
        let cell = new (LinkedHashMapCellOfK$V())(key, value);
        if (this[_first] == null) {
          this[_first] = this[_last] = cell;
        } else {
          let last = this[_last];
          cell[_previous] = last;
          this[_last] = last[_next] = cell;
        }
        this[_length$0] = dart.notNull(this[_length$0]) + 1;
        this[_modified]();
        return cell;
      }
      [_unlinkCell](cell) {
        LinkedHashMapCellOfK$V()._check(cell);
        let previous = cell[_previous];
        let next = cell[_next];
        if (previous == null) {
          dart.assert(dart.equals(cell, this[_first]));
          this[_first] = next;
        } else {
          previous[_next] = next;
        }
        if (next == null) {
          dart.assert(dart.equals(cell, this[_last]));
          this[_last] = previous;
        } else {
          next[_previous] = previous;
        }
        this[_length$0] = dart.notNull(this[_length$0]) - 1;
        this[_modified]();
      }
      static _isStringKey(key) {
        return typeof key == 'string';
      }
      static _isNumericKey(key) {
        return typeof key == 'number' && (key & 0x3ffffff) === key;
      }
      internalComputeHashCode(key) {
        return dart.hashCode(key) & 0x3ffffff;
      }
      [_getBucket](table, key) {
        let hash = this.internalComputeHashCode(key);
        return this[_getTableBucket](table, hash);
      }
      internalFindBucketIndex(bucket, key) {
        if (bucket == null) return -1;
        let length = bucket.length;
        for (let i = 0; i < length; i++) {
          let cell = bucket[i];
          if (dart.equals(cell.hashMapCellKey, key)) return i;
        }
        return -1;
      }
      toString() {
        return collection.Maps.mapToString(this);
      }
      [_getTableCell](table, key) {
        return table[key];
      }
      [_getTableBucket](table, key) {
        return table[key];
      }
      [_setTableEntry](table, key, value) {
        dart.assert(value != null);
        table[key] = value;
      }
      [_deleteTableEntry](table, key) {
        delete table[key];
      }
      [_containsTableEntry](table, key) {
        let cell = this[_getTableCell](table, key);
        return cell != null;
      }
      [_newHashTable]() {
        let table = Object.create(null);
        let temporaryKey = '<non-identifier-key>';
        this[_setTableEntry](table, temporaryKey, table);
        this[_deleteTableEntry](table, temporaryKey);
        return table;
      }
    }
    dart.addTypeTests(JsLinkedHashMap);
    JsLinkedHashMap[dart.implements] = () => [LinkedHashMapOfK$V(), _js_helper.InternalMap];
    dart.setSignature(JsLinkedHashMap, {
      constructors: () => ({
        new: dart.definiteFunctionType(_js_helper.JsLinkedHashMap$(K, V), []),
        es6: dart.definiteFunctionType(_js_helper.JsLinkedHashMap$(K, V), [])
      }),
      methods: () => ({
        containsKey: dart.definiteFunctionType(core.bool, [core.Object]),
        internalContainsKey: dart.definiteFunctionType(core.bool, [core.Object]),
        containsValue: dart.definiteFunctionType(core.bool, [core.Object]),
        addAll: dart.definiteFunctionType(dart.void, [core.Map$(K, V)]),
        get: dart.definiteFunctionType(V, [core.Object]),
        internalGet: dart.definiteFunctionType(V, [core.Object]),
        set: dart.definiteFunctionType(dart.void, [K, V]),
        internalSet: dart.definiteFunctionType(dart.void, [K, V]),
        putIfAbsent: dart.definiteFunctionType(V, [K, dart.functionType(V, [])]),
        remove: dart.definiteFunctionType(V, [core.Object]),
        internalRemove: dart.definiteFunctionType(V, [core.Object]),
        clear: dart.definiteFunctionType(dart.void, []),
        forEach: dart.definiteFunctionType(dart.void, [dart.functionType(dart.void, [K, V])]),
        [_addHashTableEntry]: dart.definiteFunctionType(dart.void, [dart.dynamic, K, V]),
        [_removeHashTableEntry]: dart.definiteFunctionType(V, [dart.dynamic, core.Object]),
        [_modified]: dart.definiteFunctionType(dart.void, []),
        [_newLinkedCell]: dart.definiteFunctionType(_js_helper.LinkedHashMapCell$(K, V), [K, V]),
        [_unlinkCell]: dart.definiteFunctionType(dart.void, [_js_helper.LinkedHashMapCell$(K, V)]),
        internalComputeHashCode: dart.definiteFunctionType(core.int, [dart.dynamic]),
        [_getBucket]: dart.definiteFunctionType(core.List$(_js_helper.LinkedHashMapCell$(K, V)), [dart.dynamic, dart.dynamic]),
        internalFindBucketIndex: dart.definiteFunctionType(core.int, [dart.dynamic, dart.dynamic]),
        [_getTableCell]: dart.definiteFunctionType(_js_helper.LinkedHashMapCell$(K, V), [dart.dynamic, dart.dynamic]),
        [_getTableBucket]: dart.definiteFunctionType(core.List$(_js_helper.LinkedHashMapCell$(K, V)), [dart.dynamic, dart.dynamic]),
        [_setTableEntry]: dart.definiteFunctionType(dart.void, [dart.dynamic, dart.dynamic, dart.dynamic]),
        [_deleteTableEntry]: dart.definiteFunctionType(dart.void, [dart.dynamic, dart.dynamic]),
        [_containsTableEntry]: dart.definiteFunctionType(core.bool, [dart.dynamic, dart.dynamic]),
        [_newHashTable]: dart.definiteFunctionType(dart.dynamic, [])
      }),
      statics: () => ({
        _isStringKey: dart.definiteFunctionType(core.bool, [dart.dynamic]),
        _isNumericKey: dart.definiteFunctionType(core.bool, [dart.dynamic])
      }),
      names: ['_isStringKey', '_isNumericKey']
    });
    dart.defineExtensionMembers(JsLinkedHashMap, [
      'containsKey',
      'containsValue',
      'addAll',
      'get',
      'set',
      'putIfAbsent',
      'remove',
      'clear',
      'forEach',
      'length',
      'isEmpty',
      'isNotEmpty',
      'keys',
      'values'
    ]);
    return JsLinkedHashMap;
  });
  _js_helper.JsLinkedHashMap = JsLinkedHashMap();
  _js_helper.Es6LinkedHashMap$ = dart.generic((K, V) => {
    class Es6LinkedHashMap extends _js_helper.JsLinkedHashMap$(K, V) {
      new() {
        super.new();
      }
      [_getTableCell](table, key) {
        return table.get(key);
      }
      [_getTableBucket](table, key) {
        return table.get(key);
      }
      [_setTableEntry](table, key, value) {
        table.set(key, value);
      }
      [_deleteTableEntry](table, key) {
        table.delete(key);
      }
      [_containsTableEntry](table, key) {
        return table.has(key);
      }
      [_newHashTable]() {
        return new Map();
      }
    }
    dart.setSignature(Es6LinkedHashMap, {
      methods: () => ({
        [_getTableCell]: dart.definiteFunctionType(_js_helper.LinkedHashMapCell$(K, V), [dart.dynamic, dart.dynamic]),
        [_getTableBucket]: dart.definiteFunctionType(core.List$(_js_helper.LinkedHashMapCell$(K, V)), [dart.dynamic, dart.dynamic])
      })
    });
    return Es6LinkedHashMap;
  });
  _js_helper.Es6LinkedHashMap = Es6LinkedHashMap();
  _js_helper.LinkedHashMapCell$ = dart.generic((K, V) => {
    class LinkedHashMapCell extends core.Object {
      new(hashMapCellKey, hashMapCellValue) {
        this.hashMapCellKey = hashMapCellKey;
        this.hashMapCellValue = hashMapCellValue;
        this[_next] = null;
        this[_previous] = null;
      }
    }
    dart.addTypeTests(LinkedHashMapCell);
    dart.setSignature(LinkedHashMapCell, {
      constructors: () => ({new: dart.definiteFunctionType(_js_helper.LinkedHashMapCell$(K, V), [K, V])})
    });
    return LinkedHashMapCell;
  });
  _js_helper.LinkedHashMapCell = LinkedHashMapCell();
  const _map = Symbol('_map');
  _js_helper.LinkedHashMapKeyIterable$ = dart.generic(E => {
    let LinkedHashMapKeyIteratorOfE = () => (LinkedHashMapKeyIteratorOfE = dart.constFn(_js_helper.LinkedHashMapKeyIterator$(E)))();
    class LinkedHashMapKeyIterable extends core.Iterable$(E) {
      new(map) {
        this[_map] = map;
        super.new();
      }
      get length() {
        return this[_map][_length$0];
      }
      get isEmpty() {
        return this[_map][_length$0] == 0;
      }
      get iterator() {
        return new (LinkedHashMapKeyIteratorOfE())(this[_map], this[_map][_modifications]);
      }
      contains(element) {
        return this[_map].containsKey(element);
      }
      forEach(f) {
        let cell = this[_map][_first];
        let modifications = this[_map][_modifications];
        while (cell != null) {
          f(cell.hashMapCellKey);
          if (modifications != this[_map][_modifications]) {
            dart.throw(new core.ConcurrentModificationError(this[_map]));
          }
          cell = cell[_next];
        }
      }
    }
    LinkedHashMapKeyIterable[dart.implements] = () => [_internal.EfficientLength];
    dart.setSignature(LinkedHashMapKeyIterable, {
      constructors: () => ({new: dart.definiteFunctionType(_js_helper.LinkedHashMapKeyIterable$(E), [_js_helper.JsLinkedHashMap$(E, dart.dynamic)])}),
      methods: () => ({forEach: dart.definiteFunctionType(dart.void, [dart.functionType(dart.void, [E])])})
    });
    dart.defineExtensionMembers(LinkedHashMapKeyIterable, [
      'contains',
      'forEach',
      'length',
      'isEmpty',
      'iterator'
    ]);
    return LinkedHashMapKeyIterable;
  });
  _js_helper.LinkedHashMapKeyIterable = LinkedHashMapKeyIterable();
  const _cell = Symbol('_cell');
  _js_helper.LinkedHashMapKeyIterator$ = dart.generic(E => {
    let IteratorOfE = () => (IteratorOfE = dart.constFn(core.Iterator$(E)))();
    class LinkedHashMapKeyIterator extends core.Object {
      new(map, modifications) {
        this[_map] = map;
        this[_modifications] = modifications;
        this[_cell] = null;
        this[_current$0] = null;
        this[_cell] = this[_map][_first];
      }
      get current() {
        return this[_current$0];
      }
      moveNext() {
        if (this[_modifications] != this[_map][_modifications]) {
          dart.throw(new core.ConcurrentModificationError(this[_map]));
        } else if (this[_cell] == null) {
          this[_current$0] = null;
          return false;
        } else {
          this[_current$0] = this[_cell].hashMapCellKey;
          this[_cell] = this[_cell][_next];
          return true;
        }
      }
    }
    dart.addTypeTests(LinkedHashMapKeyIterator);
    LinkedHashMapKeyIterator[dart.implements] = () => [IteratorOfE()];
    dart.setSignature(LinkedHashMapKeyIterator, {
      constructors: () => ({new: dart.definiteFunctionType(_js_helper.LinkedHashMapKeyIterator$(E), [_js_helper.JsLinkedHashMap$(E, dart.dynamic), core.int])}),
      methods: () => ({moveNext: dart.definiteFunctionType(core.bool, [])})
    });
    return LinkedHashMapKeyIterator;
  });
  _js_helper.LinkedHashMapKeyIterator = LinkedHashMapKeyIterator();
  _js_helper.defineProperty = function(obj, property, value) {
    Object.defineProperty(obj, property, {value: value, enumerable: false, writable: true, configurable: true});
  };
  dart.lazyFn(_js_helper.defineProperty, () => dynamicAndStringAnddynamicTovoid());
  _js_helper.convertDartClosureToJS = function(F) {
    return (closure, arity) => {
      return closure;
    };
  };
  dart.fn(_js_helper.convertDartClosureToJS, FAndintToF());
  _js_helper.setNativeSubclassDispatchRecord = function(proto, interceptor) {
  };
  dart.fn(_js_helper.setNativeSubclassDispatchRecord, dynamicAnddynamicTodynamic$());
  _js_helper.findDispatchTagForInterceptorClass = function(interceptorClassConstructor) {
  };
  dart.fn(_js_helper.findDispatchTagForInterceptorClass, dynamicTodynamic$());
  _js_helper.makeLeafDispatchRecord = function(interceptor) {
  };
  dart.fn(_js_helper.makeLeafDispatchRecord, dynamicTodynamic$());
  const _nativeRegExp = Symbol('_nativeRegExp');
  _js_helper.regExpGetNative = function(regexp) {
    return regexp[_nativeRegExp];
  };
  dart.lazyFn(_js_helper.regExpGetNative, () => JSSyntaxRegExpTodynamic());
  const _nativeGlobalVersion = Symbol('_nativeGlobalVersion');
  _js_helper.regExpGetGlobalNative = function(regexp) {
    let nativeRegexp = regexp[_nativeGlobalVersion];
    nativeRegexp.lastIndex = 0;
    return nativeRegexp;
  };
  dart.lazyFn(_js_helper.regExpGetGlobalNative, () => JSSyntaxRegExpTodynamic());
  const _nativeAnchoredVersion = Symbol('_nativeAnchoredVersion');
  _js_helper.regExpCaptureCount = function(regexp) {
    let nativeAnchoredRegExp = regexp[_nativeAnchoredVersion];
    let match = nativeAnchoredRegExp.exec('');
    return core.int._check(dart.dsend(dart.dload(match, 'length'), '-', 2));
  };
  dart.lazyFn(_js_helper.regExpCaptureCount, () => JSSyntaxRegExpToint());
  const _nativeGlobalRegExp = Symbol('_nativeGlobalRegExp');
  const _nativeAnchoredRegExp = Symbol('_nativeAnchoredRegExp');
  const _isMultiLine = Symbol('_isMultiLine');
  const _isCaseSensitive = Symbol('_isCaseSensitive');
  const _execGlobal = Symbol('_execGlobal');
  const _execAnchored = Symbol('_execAnchored');
  _js_helper.JSSyntaxRegExp = class JSSyntaxRegExp extends core.Object {
    toString() {
      return dart.str`RegExp/${this.pattern}/`;
    }
    new(source, opts) {
      let multiLine = opts && 'multiLine' in opts ? opts.multiLine : false;
      let caseSensitive = opts && 'caseSensitive' in opts ? opts.caseSensitive : true;
      this.pattern = source;
      this[_nativeRegExp] = _js_helper.JSSyntaxRegExp.makeNative(source, multiLine, caseSensitive, false);
      this[_nativeGlobalRegExp] = null;
      this[_nativeAnchoredRegExp] = null;
    }
    get [_nativeGlobalVersion]() {
      if (this[_nativeGlobalRegExp] != null) return this[_nativeGlobalRegExp];
      return this[_nativeGlobalRegExp] = _js_helper.JSSyntaxRegExp.makeNative(this.pattern, this[_isMultiLine], this[_isCaseSensitive], true);
    }
    get [_nativeAnchoredVersion]() {
      if (this[_nativeAnchoredRegExp] != null) return this[_nativeAnchoredRegExp];
      return this[_nativeAnchoredRegExp] = _js_helper.JSSyntaxRegExp.makeNative(dart.str`${this.pattern}|()`, this[_isMultiLine], this[_isCaseSensitive], true);
    }
    get [_isMultiLine]() {
      return this[_nativeRegExp].multiline;
    }
    get [_isCaseSensitive]() {
      return !this[_nativeRegExp].ignoreCase;
    }
    static makeNative(source, multiLine, caseSensitive, global) {
      _js_helper.checkString(source);
      let m = dart.test(multiLine) ? 'm' : '';
      let i = dart.test(caseSensitive) ? '' : 'i';
      let g = dart.test(global) ? 'g' : '';
      let regexp = (function() {
        try {
          return new RegExp(source, m + i + g);
        } catch (e) {
          return e;
        }

      })();
      if (regexp instanceof RegExp) return regexp;
      let errorMessage = String(regexp);
      dart.throw(new core.FormatException(dart.str`Illegal RegExp pattern: ${source}, ${errorMessage}`));
    }
    firstMatch(string) {
      let m = this[_nativeRegExp].exec(_js_helper.checkString(string));
      if (m == null) return null;
      return new _js_helper._MatchImplementation(this, m);
    }
    hasMatch(string) {
      return this[_nativeRegExp].test(_js_helper.checkString(string));
    }
    stringMatch(string) {
      let match = this.firstMatch(string);
      if (match != null) return match.group(0);
      return null;
    }
    allMatches(string, start) {
      if (start === void 0) start = 0;
      _js_helper.checkString(string);
      _js_helper.checkInt(start);
      if (dart.notNull(start) < 0 || dart.notNull(start) > dart.notNull(string[dartx.length])) {
        dart.throw(new core.RangeError.range(start, 0, string[dartx.length]));
      }
      return new _js_helper._AllMatchesIterable(this, string, start);
    }
    [_execGlobal](string, start) {
      let regexp = this[_nativeGlobalVersion];
      regexp.lastIndex = start;
      let match = regexp.exec(string);
      if (match == null) return null;
      return new _js_helper._MatchImplementation(this, ListOfString()._check(match));
    }
    [_execAnchored](string, start) {
      let regexp = this[_nativeAnchoredVersion];
      regexp.lastIndex = start;
      let match = regexp.exec(string);
      if (match == null) return null;
      if (match[dartx.get](dart.notNull(match[dartx.length]) - 1) != null) return null;
      match[dartx.length] = dart.notNull(match[dartx.length]) - 1;
      return new _js_helper._MatchImplementation(this, ListOfString()._check(match));
    }
    matchAsPrefix(string, start) {
      if (start === void 0) start = 0;
      if (dart.notNull(start) < 0 || dart.notNull(start) > dart.notNull(string[dartx.length])) {
        dart.throw(new core.RangeError.range(start, 0, string[dartx.length]));
      }
      return this[_execAnchored](string, start);
    }
    get isMultiLine() {
      return this[_isMultiLine];
    }
    get isCaseSensitive() {
      return this[_isCaseSensitive];
    }
  };
  _js_helper.JSSyntaxRegExp[dart.implements] = () => [core.RegExp];
  dart.setSignature(_js_helper.JSSyntaxRegExp, {
    constructors: () => ({new: dart.definiteFunctionType(_js_helper.JSSyntaxRegExp, [core.String], {multiLine: core.bool, caseSensitive: core.bool})}),
    methods: () => ({
      firstMatch: dart.definiteFunctionType(core.Match, [core.String]),
      hasMatch: dart.definiteFunctionType(core.bool, [core.String]),
      stringMatch: dart.definiteFunctionType(core.String, [core.String]),
      allMatches: dart.definiteFunctionType(core.Iterable$(core.Match), [core.String], [core.int]),
      [_execGlobal]: dart.definiteFunctionType(core.Match, [core.String, core.int]),
      [_execAnchored]: dart.definiteFunctionType(core.Match, [core.String, core.int]),
      matchAsPrefix: dart.definiteFunctionType(core.Match, [core.String], [core.int])
    }),
    statics: () => ({makeNative: dart.definiteFunctionType(dart.dynamic, [core.String, core.bool, core.bool, core.bool])}),
    names: ['makeNative']
  });
  dart.defineExtensionMembers(_js_helper.JSSyntaxRegExp, ['allMatches', 'matchAsPrefix']);
  const _match = Symbol('_match');
  _js_helper._MatchImplementation = class _MatchImplementation extends core.Object {
    new(pattern, match) {
      this.pattern = pattern;
      this[_match] = match;
      dart.assert(typeof this[_match].input == 'string');
      dart.assert(typeof this[_match].index == 'number');
    }
    get input() {
      return this[_match].input;
    }
    get start() {
      return this[_match].index;
    }
    get end() {
      return dart.notNull(this.start) + dart.notNull(this[_match][dartx.get](0)[dartx.length]);
    }
    group(index) {
      return this[_match][dartx.get](index);
    }
    get(index) {
      return this.group(index);
    }
    get groupCount() {
      return dart.notNull(this[_match][dartx.length]) - 1;
    }
    groups(groups) {
      let out = JSArrayOfString().of([]);
      for (let i of groups) {
        out[dartx.add](this.group(i));
      }
      return out;
    }
  };
  _js_helper._MatchImplementation[dart.implements] = () => [core.Match];
  dart.setSignature(_js_helper._MatchImplementation, {
    constructors: () => ({new: dart.definiteFunctionType(_js_helper._MatchImplementation, [core.Pattern, core.List$(core.String)])}),
    methods: () => ({
      group: dart.definiteFunctionType(core.String, [core.int]),
      get: dart.definiteFunctionType(core.String, [core.int]),
      groups: dart.definiteFunctionType(core.List$(core.String), [core.List$(core.int)])
    })
  });
  const _re = Symbol('_re');
  const _string$ = Symbol('_string');
  const _start$ = Symbol('_start');
  core.Match = class Match extends core.Object {};
  _js_helper._AllMatchesIterable = class _AllMatchesIterable extends collection.IterableBase$(core.Match) {
    new(re, string, start) {
      this[_re] = re;
      this[_string$] = string;
      this[_start$] = start;
      super.new();
    }
    get iterator() {
      return new _js_helper._AllMatchesIterator(this[_re], this[_string$], this[_start$]);
    }
  };
  dart.addSimpleTypeTests(_js_helper._AllMatchesIterable);
  dart.setSignature(_js_helper._AllMatchesIterable, {
    constructors: () => ({new: dart.definiteFunctionType(_js_helper._AllMatchesIterable, [_js_helper.JSSyntaxRegExp, core.String, core.int])})
  });
  dart.defineExtensionMembers(_js_helper._AllMatchesIterable, ['iterator']);
  const _regExp = Symbol('_regExp');
  const _nextIndex = Symbol('_nextIndex');
  _js_helper._AllMatchesIterator = class _AllMatchesIterator extends core.Object {
    new(regExp, string, nextIndex) {
      this[_regExp] = regExp;
      this[_string$] = string;
      this[_nextIndex] = nextIndex;
      this[_current$0] = null;
    }
    get current() {
      return this[_current$0];
    }
    moveNext() {
      if (this[_string$] == null) return false;
      if (dart.notNull(this[_nextIndex]) <= dart.notNull(this[_string$][dartx.length])) {
        let match = this[_regExp][_execGlobal](this[_string$], this[_nextIndex]);
        if (match != null) {
          this[_current$0] = match;
          let nextIndex = match.end;
          if (match.start == nextIndex) {
            nextIndex = dart.notNull(nextIndex) + 1;
          }
          this[_nextIndex] = nextIndex;
          return true;
        }
      }
      this[_current$0] = null;
      this[_string$] = null;
      return false;
    }
  };
  _js_helper._AllMatchesIterator[dart.implements] = () => [IteratorOfMatch()];
  dart.setSignature(_js_helper._AllMatchesIterator, {
    constructors: () => ({new: dart.definiteFunctionType(_js_helper._AllMatchesIterator, [_js_helper.JSSyntaxRegExp, core.String, core.int])}),
    methods: () => ({moveNext: dart.definiteFunctionType(core.bool, [])})
  });
  _js_helper.firstMatchAfter = function(regExp, string, start) {
    return regExp[_execGlobal](string, start);
  };
  dart.lazyFn(_js_helper.firstMatchAfter, () => JSSyntaxRegExpAndStringAndintToMatch());
  _js_helper.stringIndexOfStringUnchecked = function(receiver, other, startIndex) {
    return receiver.indexOf(other, startIndex);
  };
  dart.fn(_js_helper.stringIndexOfStringUnchecked, dynamicAnddynamicAnddynamicToint());
  _js_helper.substring1Unchecked = function(receiver, startIndex) {
    return receiver.substring(startIndex);
  };
  dart.lazyFn(_js_helper.substring1Unchecked, () => dynamicAnddynamicToString());
  _js_helper.substring2Unchecked = function(receiver, startIndex, endIndex) {
    return receiver.substring(startIndex, endIndex);
  };
  dart.lazyFn(_js_helper.substring2Unchecked, () => dynamicAnddynamicAnddynamicToString());
  _js_helper.stringContainsStringUnchecked = function(receiver, other, startIndex) {
    return dart.notNull(_js_helper.stringIndexOfStringUnchecked(receiver, other, startIndex)) >= 0;
  };
  dart.lazyFn(_js_helper.stringContainsStringUnchecked, () => dynamicAnddynamicAnddynamicTobool());
  _js_helper.StringMatch = class StringMatch extends core.Object {
    new(start, input, pattern) {
      this.start = start;
      this.input = input;
      this.pattern = pattern;
    }
    get end() {
      return dart.notNull(this.start) + dart.notNull(this.pattern[dartx.length]);
    }
    get(g) {
      return this.group(g);
    }
    get groupCount() {
      return 0;
    }
    group(group_) {
      if (group_ != 0) {
        dart.throw(new core.RangeError.value(group_));
      }
      return this.pattern;
    }
    groups(groups_) {
      let result = ListOfString().new();
      for (let g of groups_) {
        result[dartx.add](this.group(g));
      }
      return result;
    }
  };
  _js_helper.StringMatch[dart.implements] = () => [core.Match];
  dart.setSignature(_js_helper.StringMatch, {
    constructors: () => ({new: dart.definiteFunctionType(_js_helper.StringMatch, [core.int, core.String, core.String])}),
    methods: () => ({
      get: dart.definiteFunctionType(core.String, [core.int]),
      group: dart.definiteFunctionType(core.String, [core.int]),
      groups: dart.definiteFunctionType(core.List$(core.String), [core.List$(core.int)])
    })
  });
  _js_helper.allMatchesInStringUnchecked = function(pattern, string, startIndex) {
    return new _js_helper._StringAllMatchesIterable(string, pattern, startIndex);
  };
  dart.lazyFn(_js_helper.allMatchesInStringUnchecked, () => StringAndStringAndintToIterableOfMatch());
  const _input = Symbol('_input');
  const _pattern = Symbol('_pattern');
  const _index$0 = Symbol('_index');
  _js_helper._StringAllMatchesIterable = class _StringAllMatchesIterable extends core.Iterable$(core.Match) {
    new(input, pattern, index) {
      this[_input] = input;
      this[_pattern] = pattern;
      this[_index$0] = index;
      super.new();
    }
    get iterator() {
      return new _js_helper._StringAllMatchesIterator(this[_input], this[_pattern], this[_index$0]);
    }
    get first() {
      let index = _js_helper.stringIndexOfStringUnchecked(this[_input], this[_pattern], this[_index$0]);
      if (dart.notNull(index) >= 0) {
        return new _js_helper.StringMatch(index, this[_input], this[_pattern]);
      }
      dart.throw(_internal.IterableElementError.noElement());
    }
  };
  dart.addSimpleTypeTests(_js_helper._StringAllMatchesIterable);
  dart.setSignature(_js_helper._StringAllMatchesIterable, {
    constructors: () => ({new: dart.definiteFunctionType(_js_helper._StringAllMatchesIterable, [core.String, core.String, core.int])})
  });
  dart.defineExtensionMembers(_js_helper._StringAllMatchesIterable, ['iterator', 'first']);
  _js_helper._StringAllMatchesIterator = class _StringAllMatchesIterator extends core.Object {
    new(input, pattern, index) {
      this[_input] = input;
      this[_pattern] = pattern;
      this[_index$0] = index;
      this[_current$0] = null;
    }
    moveNext() {
      if (dart.notNull(this[_index$0]) + dart.notNull(this[_pattern][dartx.length]) > dart.notNull(this[_input][dartx.length])) {
        this[_current$0] = null;
        return false;
      }
      let index = _js_helper.stringIndexOfStringUnchecked(this[_input], this[_pattern], this[_index$0]);
      if (dart.notNull(index) < 0) {
        this[_index$0] = dart.notNull(this[_input][dartx.length]) + 1;
        this[_current$0] = null;
        return false;
      }
      let end = dart.notNull(index) + dart.notNull(this[_pattern][dartx.length]);
      this[_current$0] = new _js_helper.StringMatch(index, this[_input], this[_pattern]);
      if (end == this[_index$0]) end++;
      this[_index$0] = end;
      return true;
    }
    get current() {
      return this[_current$0];
    }
  };
  _js_helper._StringAllMatchesIterator[dart.implements] = () => [IteratorOfMatch()];
  dart.setSignature(_js_helper._StringAllMatchesIterator, {
    constructors: () => ({new: dart.definiteFunctionType(_js_helper._StringAllMatchesIterator, [core.String, core.String, core.int])}),
    methods: () => ({moveNext: dart.definiteFunctionType(core.bool, [])})
  });
  _js_helper.stringContainsUnchecked = function(receiver, other, startIndex) {
    if (typeof other == 'string') {
      return _js_helper.stringContainsStringUnchecked(receiver, other, startIndex);
    } else if (_js_helper.JSSyntaxRegExp.is(other)) {
      return other.hasMatch(receiver[dartx.substring](startIndex));
    } else {
      let substr = receiver[dartx.substring](startIndex);
      return core.bool._check(dart.dload(dart.dsend(other, 'allMatches', substr), 'isNotEmpty'));
    }
  };
  dart.lazyFn(_js_helper.stringContainsUnchecked, () => StringAnddynamicAndintTobool());
  _js_helper.stringReplaceJS = function(receiver, replacer, replacement) {
    replacement = replacement.replace(/\$/g, "$$$$");
    return receiver.replace(replacer, replacement);
  };
  dart.lazyFn(_js_helper.stringReplaceJS, () => dynamicAnddynamicAnddynamicToString());
  _js_helper.stringReplaceFirstRE = function(receiver, regexp, replacement, startIndex) {
    let match = regexp[_execGlobal](receiver, startIndex);
    if (match == null) return receiver;
    let start = match.start;
    let end = match.end;
    return _js_helper.stringReplaceRangeUnchecked(receiver, start, end, replacement);
  };
  dart.lazyFn(_js_helper.stringReplaceFirstRE, () => StringAndJSSyntaxRegExpAndString__ToString());
  _js_helper.quoteStringForRegExp = function(string) {
    return string.replace(/[[\]{}()*+?.\\^$|]/g, "\\$&");
  };
  dart.lazyFn(_js_helper.quoteStringForRegExp, () => dynamicToString());
  _js_helper.stringReplaceAllUnchecked = function(receiver, pattern, replacement) {
    _js_helper.checkString(replacement);
    if (typeof pattern == 'string') {
      if (pattern == "") {
        if (receiver == "") {
          return replacement;
        } else {
          let result = new core.StringBuffer();
          let length = receiver[dartx.length];
          result.write(replacement);
          for (let i = 0; i < dart.notNull(length); i++) {
            result.write(receiver[dartx.get](i));
            result.write(replacement);
          }
          return result.toString();
        }
      } else {
        let quoted = _js_helper.quoteStringForRegExp(pattern);
        let replacer = new RegExp(quoted, 'g');
        return _js_helper.stringReplaceJS(receiver, replacer, replacement);
      }
    } else if (_js_helper.JSSyntaxRegExp.is(pattern)) {
      let re = _js_helper.regExpGetGlobalNative(pattern);
      return _js_helper.stringReplaceJS(receiver, re, replacement);
    } else {
      _js_helper.checkNull(pattern);
      dart.throw("String.replaceAll(Pattern) UNIMPLEMENTED");
    }
  };
  dart.lazyFn(_js_helper.stringReplaceAllUnchecked, () => StringAndPatternAndStringToString());
  _js_helper._matchString = function(match) {
    return match.get(0);
  };
  dart.lazyFn(_js_helper._matchString, () => MatchToString$());
  _js_helper._stringIdentity = function(string) {
    return string;
  };
  dart.lazyFn(_js_helper._stringIdentity, () => StringToString$());
  _js_helper.stringReplaceAllFuncUnchecked = function(receiver, pattern, onMatch, onNonMatch) {
    if (onMatch == null) onMatch = _js_helper._matchString;
    if (onNonMatch == null) onNonMatch = _js_helper._stringIdentity;
    if (typeof pattern == 'string') {
      return _js_helper.stringReplaceAllStringFuncUnchecked(receiver, pattern, onMatch, onNonMatch);
    }
    if (!core.Pattern.is(pattern)) {
      dart.throw(new core.ArgumentError.value(pattern, 'pattern', 'is not a Pattern'));
    }
    let buffer = new core.StringBuffer();
    let startIndex = 0;
    for (let match of pattern[dartx.allMatches](receiver)) {
      buffer.write(onNonMatch(receiver[dartx.substring](startIndex, match.start)));
      buffer.write(onMatch(match));
      startIndex = match.end;
    }
    buffer.write(onNonMatch(receiver[dartx.substring](startIndex)));
    return buffer.toString();
  };
  dart.lazyFn(_js_helper.stringReplaceAllFuncUnchecked, () => StringAndPatternAndFn__ToString());
  _js_helper.stringReplaceAllEmptyFuncUnchecked = function(receiver, onMatch, onNonMatch) {
    let buffer = new core.StringBuffer();
    let length = receiver[dartx.length];
    let i = 0;
    buffer.write(onNonMatch(""));
    while (i < dart.notNull(length)) {
      buffer.write(onMatch(new _js_helper.StringMatch(i, receiver, "")));
      let code = receiver[dartx.codeUnitAt](i);
      if ((dart.notNull(code) & ~1023) == 55296 && dart.notNull(length) > i + 1) {
        code = receiver[dartx.codeUnitAt](i + 1);
        if ((dart.notNull(code) & ~1023) == 56320) {
          buffer.write(onNonMatch(receiver[dartx.substring](i, i + 2)));
          i = i + 2;
          continue;
        }
      }
      buffer.write(onNonMatch(receiver[dartx.get](i)));
      i++;
    }
    buffer.write(onMatch(new _js_helper.StringMatch(i, receiver, "")));
    buffer.write(onNonMatch(""));
    return buffer.toString();
  };
  dart.lazyFn(_js_helper.stringReplaceAllEmptyFuncUnchecked, () => StringAndFnAndFnToString());
  _js_helper.stringReplaceAllStringFuncUnchecked = function(receiver, pattern, onMatch, onNonMatch) {
    let patternLength = pattern[dartx.length];
    if (patternLength == 0) {
      return _js_helper.stringReplaceAllEmptyFuncUnchecked(receiver, onMatch, onNonMatch);
    }
    let length = receiver[dartx.length];
    let buffer = new core.StringBuffer();
    let startIndex = 0;
    while (startIndex < dart.notNull(length)) {
      let position = _js_helper.stringIndexOfStringUnchecked(receiver, pattern, startIndex);
      if (position == -1) {
        break;
      }
      buffer.write(onNonMatch(receiver[dartx.substring](startIndex, position)));
      buffer.write(onMatch(new _js_helper.StringMatch(position, receiver, pattern)));
      startIndex = dart.notNull(position) + dart.notNull(patternLength);
    }
    buffer.write(onNonMatch(receiver[dartx.substring](startIndex)));
    return buffer.toString();
  };
  dart.lazyFn(_js_helper.stringReplaceAllStringFuncUnchecked, () => StringAndStringAndFn__ToString());
  _js_helper.stringReplaceFirstUnchecked = function(receiver, pattern, replacement, startIndex) {
    if (typeof pattern == 'string') {
      let index = _js_helper.stringIndexOfStringUnchecked(receiver, pattern, startIndex);
      if (dart.notNull(index) < 0) return receiver;
      let end = dart.notNull(index) + dart.notNull(pattern[dartx.length]);
      return _js_helper.stringReplaceRangeUnchecked(receiver, index, end, replacement);
    }
    if (_js_helper.JSSyntaxRegExp.is(pattern)) {
      return startIndex == 0 ? _js_helper.stringReplaceJS(receiver, _js_helper.regExpGetNative(pattern), replacement) : _js_helper.stringReplaceFirstRE(receiver, pattern, replacement, startIndex);
    }
    _js_helper.checkNull(pattern);
    let matches = pattern[dartx.allMatches](receiver, startIndex)[dartx.iterator];
    if (!dart.test(matches.moveNext())) return receiver;
    let match = matches.current;
    return receiver[dartx.replaceRange](match.start, match.end, replacement);
  };
  dart.lazyFn(_js_helper.stringReplaceFirstUnchecked, () => StringAndPatternAndString__ToString());
  _js_helper.stringReplaceFirstMappedUnchecked = function(receiver, pattern, replace, startIndex) {
    let matches = pattern[dartx.allMatches](receiver, startIndex)[dartx.iterator];
    if (!dart.test(matches.moveNext())) return receiver;
    let match = matches.current;
    let replacement = dart.str`${replace(match)}`;
    return receiver[dartx.replaceRange](match.start, match.end, replacement);
  };
  dart.lazyFn(_js_helper.stringReplaceFirstMappedUnchecked, () => StringAndPatternAndFn__ToString$());
  _js_helper.stringJoinUnchecked = function(array, separator) {
    return array.join(separator);
  };
  dart.lazyFn(_js_helper.stringJoinUnchecked, () => dynamicAnddynamicToString());
  _js_helper.stringReplaceRangeUnchecked = function(receiver, start, end, replacement) {
    let prefix = receiver.substring(0, start);
    let suffix = receiver.substring(end);
    return dart.str`${prefix}${replacement}${suffix}`;
  };
  dart.lazyFn(_js_helper.stringReplaceRangeUnchecked, () => StringAndintAndint__ToString());
  _js_helper.getRuntimeType = function(object) {
    return dart.getReifiedType(object);
  };
  dart.fn(_js_helper.getRuntimeType, dynamicToType());
  _js_helper.getIndex = function(array, index) {
    dart.assert(_js_helper.isJsArray(array));
    return array[index];
  };
  dart.fn(_js_helper.getIndex, dynamicAndintTodynamic());
  _js_helper.getLength = function(array) {
    dart.assert(_js_helper.isJsArray(array));
    return array.length;
  };
  dart.fn(_js_helper.getLength, dynamicToint());
  _js_helper.isJsArray = function(value) {
    return _interceptors.JSArray.is(value);
  };
  dart.lazyFn(_js_helper.isJsArray, () => dynamicTobool$());
  _js_mirrors.getName = function(symbol) {
    return _internal.Symbol.getName(_internal.Symbol.as(symbol));
  };
  dart.lazyFn(_js_mirrors.getName, () => SymbolToString());
  _js_mirrors.getSymbol = function(name, library) {
    return dart.throw(new core.UnimplementedError("MirrorSystem.getSymbol unimplemented"));
  };
  dart.lazyFn(_js_mirrors.getSymbol, () => dynamicAnddynamicToSymbol());
  dart.defineLazy(_js_mirrors, {
    get currentJsMirrorSystem() {
      return dart.throw(new core.UnimplementedError("MirrorSystem.currentJsMirrorSystem unimplemented"));
    }
  });
  _js_mirrors.reflect = function(reflectee) {
    return new _js_mirrors.JsInstanceMirror._(reflectee);
  };
  dart.lazyFn(_js_mirrors.reflect, () => dynamicToInstanceMirror());
  _js_mirrors.reflectType = function(key) {
    return new _js_mirrors.JsClassMirror._(key);
  };
  dart.lazyFn(_js_mirrors.reflectType, () => TypeToTypeMirror());
  dart.defineLazy(_js_mirrors, {
    get _dart() {
      return dart;
    }
  });
  _js_mirrors._dload = function(obj, name) {
    return _js_mirrors._dart.dload(obj, name);
  };
  dart.lazyFn(_js_mirrors._dload, () => dynamicAndStringTodynamic());
  _js_mirrors._dput = function(obj, name, val) {
    _js_mirrors._dart.dput(obj, name, val);
  };
  dart.lazyFn(_js_mirrors._dput, () => dynamicAndStringAnddynamicTovoid());
  _js_mirrors._dsend = function(obj, name, args) {
    return _js_mirrors._dart.dsend(obj, name, ...args);
  };
  dart.lazyFn(_js_mirrors._dsend, () => dynamicAndStringAndListTodynamic());
  _js_mirrors._unwrap = function(obj) {
    return _js_mirrors._dart.unwrapType(obj);
  };
  dart.fn(_js_mirrors._unwrap, dynamicTodynamic$());
  _js_mirrors._wrap = function(obj) {
    return _js_mirrors._dart.wrapType(obj);
  };
  dart.fn(_js_mirrors._wrap, dynamicTodynamic$());
  const _toJsMap = Symbol('_toJsMap');
  _js_mirrors.JsInstanceMirror = class JsInstanceMirror extends core.Object {
    _(reflectee) {
      this.reflectee = reflectee;
    }
    get type() {
      return dart.throw(new core.UnimplementedError("ClassMirror.type unimplemented"));
    }
    get hasReflectee() {
      return dart.throw(new core.UnimplementedError("ClassMirror.hasReflectee unimplemented"));
    }
    delegate(invocation) {
      return dart.throw(new core.UnimplementedError("ClassMirror.delegate unimplemented"));
    }
    getField(symbol) {
      let name = _js_mirrors.getName(symbol);
      let field = _js_mirrors._dload(this.reflectee, name);
      return new _js_mirrors.JsInstanceMirror._(field);
    }
    setField(symbol, value) {
      let name = _js_mirrors.getName(symbol);
      _js_mirrors._dput(this.reflectee, name, value);
      return new _js_mirrors.JsInstanceMirror._(value);
    }
    invoke(symbol, args, namedArgs) {
      if (namedArgs === void 0) namedArgs = null;
      let name = _js_mirrors.getName(symbol);
      if (namedArgs != null) {
        args = core.List.from(args);
        args[dartx.add](this[_toJsMap](namedArgs));
      }
      let result = _js_mirrors._dsend(this.reflectee, name, args);
      return new _js_mirrors.JsInstanceMirror._(result);
    }
    [_toJsMap](map) {
      let obj = {};
      map[dartx.forEach](dart.fn((key, value) => {
        obj[_js_mirrors.getName(key)] = value;
      }, SymbolAnddynamicTovoid()));
      return obj;
    }
  };
  dart.defineNamedConstructor(_js_mirrors.JsInstanceMirror, '_');
  _js_mirrors.JsInstanceMirror[dart.implements] = () => [mirrors.InstanceMirror];
  dart.setSignature(_js_mirrors.JsInstanceMirror, {
    constructors: () => ({_: dart.definiteFunctionType(_js_mirrors.JsInstanceMirror, [core.Object])}),
    methods: () => ({
      delegate: dart.definiteFunctionType(dart.dynamic, [core.Invocation]),
      getField: dart.definiteFunctionType(mirrors.InstanceMirror, [core.Symbol]),
      setField: dart.definiteFunctionType(mirrors.InstanceMirror, [core.Symbol, core.Object]),
      invoke: dart.definiteFunctionType(mirrors.InstanceMirror, [core.Symbol, core.List], [core.Map$(core.Symbol, dart.dynamic)]),
      [_toJsMap]: dart.definiteFunctionType(dart.dynamic, [core.Map$(core.Symbol, dart.dynamic)])
    })
  });
  const _metadata$ = Symbol('_metadata');
  const _declarations = Symbol('_declarations');
  const _cls = Symbol('_cls');
  _js_mirrors.JsClassMirror = class JsClassMirror extends core.Object {
    get metadata() {
      return this[_metadata$];
    }
    get declarations() {
      return this[_declarations];
    }
    _(cls) {
      this[_cls] = cls;
      this.simpleName = core.Symbol.new(_js_mirrors._unwrap(cls).name);
      this[_metadata$] = null;
      this[_declarations] = null;
      let fn = _js_mirrors._unwrap(this[_cls])[dart.metadata];
      this[_metadata$] = fn == null ? JSArrayOfInstanceMirror().of([]) : ListOfInstanceMirror().from(core.Iterable._check(dart.dsend(dart.dcall(fn), 'map', dart.fn(i => new _js_mirrors.JsInstanceMirror._(i), dynamicToJsInstanceMirror()))));
      this[_declarations] = MapOfSymbol$MethodMirror().new();
      this[_declarations][dartx.set](this.simpleName, new _js_mirrors.JsMethodMirror._(this, this[_cls]));
    }
    newInstance(constructorName, args, namedArgs) {
      if (namedArgs === void 0) namedArgs = null;
      dart.assert(_js_mirrors.getName(constructorName) == "");
      dart.assert(namedArgs == null || dart.test(namedArgs[dartx.isEmpty]));
      let instance = new (_js_mirrors._unwrap(this[_cls]))(...args);
      return new _js_mirrors.JsInstanceMirror._(instance);
    }
    get superinterfaces() {
      let interfaceThunk = _js_mirrors._unwrap(this[_cls])[dart.implements];
      if (interfaceThunk == null) {
        return JSArrayOfClassMirror().of([]);
      } else {
        let interfaces = ListOfType()._check(dart.dcall(interfaceThunk));
        return interfaces[dartx.map](_js_mirrors.JsClassMirror)(dart.fn(t => new _js_mirrors.JsClassMirror._(t), TypeToJsClassMirror()))[dartx.toList]();
      }
    }
    getField(fieldName) {
      return dart.throw(new core.UnimplementedError("ClassMirror.getField unimplemented"));
    }
    invoke(memberName, positionalArguments, namedArguments) {
      if (namedArguments === void 0) namedArguments = null;
      return dart.throw(new core.UnimplementedError("ClassMirror.invoke unimplemented"));
    }
    isAssignableTo(other) {
      return dart.throw(new core.UnimplementedError("ClassMirror.isAssignable unimplemented"));
    }
    isSubclassOf(other) {
      return dart.throw(new core.UnimplementedError("ClassMirror.isSubclassOf unimplemented"));
    }
    isSubtypeOf(other) {
      return dart.throw(new core.UnimplementedError("ClassMirror.isSubtypeOf unimplemented"));
    }
    setField(fieldName, value) {
      return dart.throw(new core.UnimplementedError("ClassMirror.setField unimplemented"));
    }
    get hasReflectedType() {
      return dart.throw(new core.UnimplementedError("ClassMirror.hasReflectedType unimplemented"));
    }
    get instanceMembers() {
      return dart.throw(new core.UnimplementedError("ClassMirror.instanceMembers unimplemented"));
    }
    get isAbstract() {
      return dart.throw(new core.UnimplementedError("ClassMirror.isAbstract unimplemented"));
    }
    get isEnum() {
      return dart.throw(new core.UnimplementedError("ClassMirror.isEnum unimplemented"));
    }
    get isOriginalDeclaration() {
      return dart.throw(new core.UnimplementedError("ClassMirror.isOriginalDeclaration unimplemented"));
    }
    get isPrivate() {
      return dart.throw(new core.UnimplementedError("ClassMirror.isPrivate unimplemented"));
    }
    get isTopLevel() {
      return dart.throw(new core.UnimplementedError("ClassMirror.isTopLevel unimplemented"));
    }
    get location() {
      return dart.throw(new core.UnimplementedError("ClassMirror.location unimplemented"));
    }
    get mixin() {
      return dart.throw(new core.UnimplementedError("ClassMirror.mixin unimplemented"));
    }
    get originalDeclaration() {
      return this;
    }
    get owner() {
      return dart.throw(new core.UnimplementedError("ClassMirror.owner unimplemented"));
    }
    get qualifiedName() {
      return dart.throw(new core.UnimplementedError("ClassMirror.qualifiedName unimplemented"));
    }
    get reflectedType() {
      return this[_cls];
    }
    get staticMembers() {
      return dart.throw(new core.UnimplementedError("ClassMirror.staticMembers unimplemented"));
    }
    get superclass() {
      if (dart.equals(this[_cls], dart.wrapType(core.Object))) {
        return null;
      } else {
        return new _js_mirrors.JsClassMirror._(core.Type._check(_js_mirrors._wrap(_js_mirrors._unwrap(this[_cls]).__proto__)));
      }
    }
    get typeArguments() {
      return dart.throw(new core.UnimplementedError("ClassMirror.typeArguments unimplemented"));
    }
    get typeVariables() {
      return dart.throw(new core.UnimplementedError("ClassMirror.typeVariables unimplemented"));
    }
  };
  dart.defineNamedConstructor(_js_mirrors.JsClassMirror, '_');
  _js_mirrors.JsClassMirror[dart.implements] = () => [mirrors.ClassMirror];
  dart.setSignature(_js_mirrors.JsClassMirror, {
    constructors: () => ({_: dart.definiteFunctionType(_js_mirrors.JsClassMirror, [core.Type])}),
    methods: () => ({
      newInstance: dart.definiteFunctionType(mirrors.InstanceMirror, [core.Symbol, core.List], [core.Map$(core.Symbol, dart.dynamic)]),
      getField: dart.definiteFunctionType(mirrors.InstanceMirror, [core.Symbol]),
      invoke: dart.definiteFunctionType(mirrors.InstanceMirror, [core.Symbol, core.List], [core.Map$(core.Symbol, dart.dynamic)]),
      isAssignableTo: dart.definiteFunctionType(core.bool, [mirrors.TypeMirror]),
      isSubclassOf: dart.definiteFunctionType(core.bool, [mirrors.ClassMirror]),
      isSubtypeOf: dart.definiteFunctionType(core.bool, [mirrors.TypeMirror]),
      setField: dart.definiteFunctionType(mirrors.InstanceMirror, [core.Symbol, core.Object])
    })
  });
  _js_mirrors.JsTypeMirror = class JsTypeMirror extends core.Object {
    _(reflectedType) {
      this.reflectedType = reflectedType;
      this.hasReflectedType = true;
    }
    isAssignableTo(other) {
      return dart.throw(new core.UnimplementedError("TypeMirror.isAssignable unimplemented"));
    }
    isSubtypeOf(other) {
      return dart.throw(new core.UnimplementedError("TypeMirror.isSubtypeOf unimplemented"));
    }
    get isOriginalDeclaration() {
      return dart.throw(new core.UnimplementedError("TypeMirror.isOriginalDeclaration unimplemented"));
    }
    get isPrivate() {
      return dart.throw(new core.UnimplementedError("TypeMirror.isPrivate unimplemented"));
    }
    get isTopLevel() {
      return dart.throw(new core.UnimplementedError("TypeMirror.isTopLevel unimplemented"));
    }
    get location() {
      return dart.throw(new core.UnimplementedError("TypeMirror.location unimplemented"));
    }
    get metadata() {
      return dart.throw(new core.UnimplementedError("TypeMirror.metadata unimplemented"));
    }
    get originalDeclaration() {
      return dart.throw(new core.UnimplementedError("TypeMirror.originalDeclaration unimplemented"));
    }
    get owner() {
      return dart.throw(new core.UnimplementedError("TypeMirror.owner unimplemented"));
    }
    get qualifiedName() {
      return dart.throw(new core.UnimplementedError("TypeMirror.qualifiedName unimplemented"));
    }
    get simpleName() {
      return dart.throw(new core.UnimplementedError("TypeMirror.simpleName unimplemented"));
    }
    get typeArguments() {
      return dart.throw(new core.UnimplementedError("TypeMirror.typeArguments unimplemented"));
    }
    get typeVariables() {
      return dart.throw(new core.UnimplementedError("TypeMirror.typeVariables unimplemented"));
    }
  };
  dart.defineNamedConstructor(_js_mirrors.JsTypeMirror, '_');
  _js_mirrors.JsTypeMirror[dart.implements] = () => [mirrors.TypeMirror];
  dart.setSignature(_js_mirrors.JsTypeMirror, {
    constructors: () => ({_: dart.definiteFunctionType(_js_mirrors.JsTypeMirror, [core.Type])}),
    methods: () => ({
      isAssignableTo: dart.definiteFunctionType(core.bool, [mirrors.TypeMirror]),
      isSubtypeOf: dart.definiteFunctionType(core.bool, [mirrors.TypeMirror])
    })
  });
  const _name$ = Symbol('_name');
  _js_mirrors.JsParameterMirror = class JsParameterMirror extends core.Object {
    _(name, t, annotations) {
      this[_name$] = name;
      this.type = new _js_mirrors.JsTypeMirror._(t);
      this.metadata = ListOfInstanceMirror().from(annotations[dartx.map](_js_mirrors.JsInstanceMirror)(dart.fn(a => new _js_mirrors.JsInstanceMirror._(a), dynamicToJsInstanceMirror())));
    }
    get defaultValue() {
      return dart.throw(new core.UnimplementedError("ParameterMirror.defaultValues unimplemented"));
    }
    get hasDefaultValue() {
      return dart.throw(new core.UnimplementedError("ParameterMirror.hasDefaultValue unimplemented"));
    }
    get isConst() {
      return dart.throw(new core.UnimplementedError("ParameterMirror.isConst unimplemented"));
    }
    get isFinal() {
      return dart.throw(new core.UnimplementedError("ParameterMirror.isFinal unimplemented"));
    }
    get isNamed() {
      return dart.throw(new core.UnimplementedError("ParameterMirror.isNamed unimplemented"));
    }
    get isOptional() {
      return dart.throw(new core.UnimplementedError("ParameterMirror.isOptional unimplemented"));
    }
    get isPrivate() {
      return dart.throw(new core.UnimplementedError("ParameterMirror.isPrivate unimplemented"));
    }
    get isStatic() {
      return dart.throw(new core.UnimplementedError("ParameterMirror.isStatic unimplemented"));
    }
    get isTopLevel() {
      return dart.throw(new core.UnimplementedError("ParameterMirror.isTopLevel unimplemented"));
    }
    get location() {
      return dart.throw(new core.UnimplementedError("ParameterMirror.location unimplemented"));
    }
    get owner() {
      return dart.throw(new core.UnimplementedError("ParameterMirror.owner unimplemented"));
    }
    get qualifiedName() {
      return dart.throw(new core.UnimplementedError("ParameterMirror.qualifiedName unimplemented"));
    }
    get simpleName() {
      return dart.throw(new core.UnimplementedError("ParameterMirror.simpleName unimplemented"));
    }
  };
  dart.defineNamedConstructor(_js_mirrors.JsParameterMirror, '_');
  _js_mirrors.JsParameterMirror[dart.implements] = () => [mirrors.ParameterMirror];
  dart.setSignature(_js_mirrors.JsParameterMirror, {
    constructors: () => ({_: dart.definiteFunctionType(_js_mirrors.JsParameterMirror, [core.String, core.Type, core.List])})
  });
  const _method$ = Symbol('_method');
  const _params = Symbol('_params');
  const _createParameterMirrorList = Symbol('_createParameterMirrorList');
  _js_mirrors.JsMethodMirror = class JsMethodMirror extends core.Object {
    _(cls, method) {
      this[_method$] = method;
      this[_name$] = _js_mirrors.getName(cls.simpleName);
      this[_params] = null;
      let ftype = _js_mirrors._dart.classGetConstructorType(_js_mirrors._unwrap(cls[_cls]));
      this[_params] = this[_createParameterMirrorList](ftype);
    }
    get constructorName() {
      return core.Symbol.new('');
    }
    get parameters() {
      return this[_params];
    }
    [_createParameterMirrorList](ftype) {
      if (ftype == null) {
        return JSArrayOfParameterMirror().of([]);
      }
      let args = core.List._check(dart.dload(ftype, 'args'));
      let opts = core.List._check(dart.dload(ftype, 'optionals'));
      let params = ListOfParameterMirror().new(dart.notNull(args[dartx.length]) + dart.notNull(opts[dartx.length]));
      for (let i = 0; i < dart.notNull(args[dartx.length]); ++i) {
        let type = args[dartx.get](i);
        let metadata = dart.dindex(dart.dload(ftype, 'metadata'), i);
        let param = new _js_mirrors.JsParameterMirror._('', core.Type._check(_js_mirrors._wrap(type)), core.List._check(metadata));
        params[dartx.set](i, param);
      }
      for (let i = 0; i < dart.notNull(opts[dartx.length]); ++i) {
        let type = opts[dartx.get](i);
        let metadata = dart.dindex(dart.dload(ftype, 'metadata'), dart.notNull(args[dartx.length]) + i);
        let param = new _js_mirrors.JsParameterMirror._('', core.Type._check(_js_mirrors._wrap(type)), core.List._check(metadata));
        params[dartx.set](i + dart.notNull(args[dartx.length]), param);
      }
      return params;
    }
    get isAbstract() {
      return dart.throw(new core.UnimplementedError("MethodMirror.isAbstract unimplemented"));
    }
    get isConstConstructor() {
      return dart.throw(new core.UnimplementedError("MethodMirror.isConstConstructor unimplemented"));
    }
    get isConstructor() {
      return dart.throw(new core.UnimplementedError("MethodMirror.isConstructor unimplemented"));
    }
    get isFactoryConstructor() {
      return dart.throw(new core.UnimplementedError("MethodMirror.isFactoryConstructor unimplemented"));
    }
    get isGenerativeConstructor() {
      return dart.throw(new core.UnimplementedError("MethodMirror.isGenerativeConstructor unimplemented"));
    }
    get isGetter() {
      return dart.throw(new core.UnimplementedError("MethodMirror.isGetter unimplemented"));
    }
    get isOperator() {
      return dart.throw(new core.UnimplementedError("MethodMirror.isOperator unimplemented"));
    }
    get isPrivate() {
      return dart.throw(new core.UnimplementedError("MethodMirror.isPrivate unimplemented"));
    }
    get isRedirectingConstructor() {
      return dart.throw(new core.UnimplementedError("MethodMirror.isRedirectingConstructor unimplemented"));
    }
    get isRegularMethod() {
      return dart.throw(new core.UnimplementedError("MethodMirror.isRegularMethod unimplemented"));
    }
    get isSetter() {
      return dart.throw(new core.UnimplementedError("MethodMirror.isSetter unimplemented"));
    }
    get isStatic() {
      return dart.throw(new core.UnimplementedError("MethodMirror.isStatic unimplemented"));
    }
    get isSynthetic() {
      return dart.throw(new core.UnimplementedError("MethodMirror.isSynthetic unimplemented"));
    }
    get isTopLevel() {
      return dart.throw(new core.UnimplementedError("MethodMirror.isTopLevel unimplemented"));
    }
    get location() {
      return dart.throw(new core.UnimplementedError("MethodMirror.location unimplemented"));
    }
    get metadata() {
      return JSArrayOfInstanceMirror().of([]);
    }
    get owner() {
      return dart.throw(new core.UnimplementedError("MethodMirror.owner unimplemented"));
    }
    get qualifiedName() {
      return dart.throw(new core.UnimplementedError("MethodMirror.qualifiedName unimplemented"));
    }
    get returnType() {
      return dart.throw(new core.UnimplementedError("MethodMirror.returnType unimplemented"));
    }
    get simpleName() {
      return dart.throw(new core.UnimplementedError("MethodMirror.simpleName unimplemented"));
    }
    get source() {
      return dart.throw(new core.UnimplementedError("MethodMirror.source unimplemented"));
    }
  };
  dart.defineNamedConstructor(_js_mirrors.JsMethodMirror, '_');
  _js_mirrors.JsMethodMirror[dart.implements] = () => [mirrors.MethodMirror];
  dart.setSignature(_js_mirrors.JsMethodMirror, {
    constructors: () => ({_: dart.definiteFunctionType(_js_mirrors.JsMethodMirror, [_js_mirrors.JsClassMirror, dart.dynamic])}),
    methods: () => ({[_createParameterMirrorList]: dart.definiteFunctionType(core.List$(mirrors.ParameterMirror), [dart.dynamic])})
  });
  _js_primitives.printString = function(string) {
    if (typeof dartPrint == "function") {
      dartPrint(string);
      return;
    }
    if (typeof console == "object" && typeof console.log != "undefined") {
      console.log(string);
      return;
    }
    if (typeof window == "object") {
      return;
    }
    if (typeof print == "function") {
      print(string);
      return;
    }
    throw "Unable to print message: " + String(string);
  };
  dart.lazyFn(_js_primitives.printString, () => StringTovoid());
  _metadata.SupportedBrowser = class SupportedBrowser extends core.Object {
    new(browserName, minimumVersion) {
      if (minimumVersion === void 0) minimumVersion = null;
      this.browserName = browserName;
      this.minimumVersion = minimumVersion;
    }
  };
  dart.setSignature(_metadata.SupportedBrowser, {
    constructors: () => ({new: dart.definiteFunctionType(_metadata.SupportedBrowser, [core.String], [core.String])})
  });
  _metadata.SupportedBrowser.CHROME = "Chrome";
  _metadata.SupportedBrowser.FIREFOX = "Firefox";
  _metadata.SupportedBrowser.IE = "Internet Explorer";
  _metadata.SupportedBrowser.OPERA = "Opera";
  _metadata.SupportedBrowser.SAFARI = "Safari";
  _metadata.Experimental = class Experimental extends core.Object {
    new() {
    }
  };
  dart.setSignature(_metadata.Experimental, {
    constructors: () => ({new: dart.definiteFunctionType(_metadata.Experimental, [])})
  });
  _metadata.DomName = class DomName extends core.Object {
    new(name) {
      this.name = name;
    }
  };
  dart.setSignature(_metadata.DomName, {
    constructors: () => ({new: dart.definiteFunctionType(_metadata.DomName, [core.String])})
  });
  _metadata.DocsEditable = class DocsEditable extends core.Object {
    new() {
    }
  };
  dart.setSignature(_metadata.DocsEditable, {
    constructors: () => ({new: dart.definiteFunctionType(_metadata.DocsEditable, [])})
  });
  _metadata.Unstable = class Unstable extends core.Object {
    new() {
    }
  };
  dart.setSignature(_metadata.Unstable, {
    constructors: () => ({new: dart.definiteFunctionType(_metadata.Unstable, [])})
  });
  dart.defineExtensionNames([
    'lengthInBytes',
    'runtimeType',
    'asUint8List',
    'asInt8List',
    'asUint8ClampedList',
    'asUint16List',
    'asInt16List',
    'asUint32List',
    'asInt32List',
    'asUint64List',
    'asInt64List',
    'asInt32x4List',
    'asFloat32List',
    'asFloat64List',
    'asFloat32x4List',
    'asFloat64x2List',
    'asByteData'
  ]);
  _native_typed_data.NativeByteBuffer = class NativeByteBuffer extends core.Object {
    get [dartx.lengthInBytes]() {
      return this.byteLength;
    }
    get [dartx.runtimeType]() {
      return dart.wrapType(typed_data.ByteBuffer);
    }
    [dartx.asUint8List](offsetInBytes, length) {
      if (offsetInBytes === void 0) offsetInBytes = 0;
      if (length === void 0) length = null;
      return _native_typed_data.NativeUint8List.view(this, offsetInBytes, length);
    }
    [dartx.asInt8List](offsetInBytes, length) {
      if (offsetInBytes === void 0) offsetInBytes = 0;
      if (length === void 0) length = null;
      return _native_typed_data.NativeInt8List.view(this, offsetInBytes, length);
    }
    [dartx.asUint8ClampedList](offsetInBytes, length) {
      if (offsetInBytes === void 0) offsetInBytes = 0;
      if (length === void 0) length = null;
      return _native_typed_data.NativeUint8ClampedList.view(this, offsetInBytes, length);
    }
    [dartx.asUint16List](offsetInBytes, length) {
      if (offsetInBytes === void 0) offsetInBytes = 0;
      if (length === void 0) length = null;
      return _native_typed_data.NativeUint16List.view(this, offsetInBytes, length);
    }
    [dartx.asInt16List](offsetInBytes, length) {
      if (offsetInBytes === void 0) offsetInBytes = 0;
      if (length === void 0) length = null;
      return _native_typed_data.NativeInt16List.view(this, offsetInBytes, length);
    }
    [dartx.asUint32List](offsetInBytes, length) {
      if (offsetInBytes === void 0) offsetInBytes = 0;
      if (length === void 0) length = null;
      return _native_typed_data.NativeUint32List.view(this, offsetInBytes, length);
    }
    [dartx.asInt32List](offsetInBytes, length) {
      if (offsetInBytes === void 0) offsetInBytes = 0;
      if (length === void 0) length = null;
      return _native_typed_data.NativeInt32List.view(this, offsetInBytes, length);
    }
    [dartx.asUint64List](offsetInBytes, length) {
      if (offsetInBytes === void 0) offsetInBytes = 0;
      if (length === void 0) length = null;
      dart.throw(new core.UnsupportedError("Uint64List not supported by dart2js."));
    }
    [dartx.asInt64List](offsetInBytes, length) {
      if (offsetInBytes === void 0) offsetInBytes = 0;
      if (length === void 0) length = null;
      dart.throw(new core.UnsupportedError("Int64List not supported by dart2js."));
    }
    [dartx.asInt32x4List](offsetInBytes, length) {
      if (offsetInBytes === void 0) offsetInBytes = 0;
      if (length === void 0) length = null;
      let storage = _native_typed_data.NativeInt32List._check(this[dartx.asInt32List](offsetInBytes, length != null ? dart.notNull(length) * 4 : null));
      return new _native_typed_data.NativeInt32x4List._externalStorage(storage);
    }
    [dartx.asFloat32List](offsetInBytes, length) {
      if (offsetInBytes === void 0) offsetInBytes = 0;
      if (length === void 0) length = null;
      return _native_typed_data.NativeFloat32List.view(this, offsetInBytes, length);
    }
    [dartx.asFloat64List](offsetInBytes, length) {
      if (offsetInBytes === void 0) offsetInBytes = 0;
      if (length === void 0) length = null;
      return _native_typed_data.NativeFloat64List.view(this, offsetInBytes, length);
    }
    [dartx.asFloat32x4List](offsetInBytes, length) {
      if (offsetInBytes === void 0) offsetInBytes = 0;
      if (length === void 0) length = null;
      let storage = _native_typed_data.NativeFloat32List._check(this[dartx.asFloat32List](offsetInBytes, length != null ? dart.notNull(length) * 4 : null));
      return new _native_typed_data.NativeFloat32x4List._externalStorage(storage);
    }
    [dartx.asFloat64x2List](offsetInBytes, length) {
      if (offsetInBytes === void 0) offsetInBytes = 0;
      if (length === void 0) length = null;
      let storage = _native_typed_data.NativeFloat64List._check(this[dartx.asFloat64List](offsetInBytes, length != null ? dart.notNull(length) * 2 : null));
      return new _native_typed_data.NativeFloat64x2List._externalStorage(storage);
    }
    [dartx.asByteData](offsetInBytes, length) {
      if (offsetInBytes === void 0) offsetInBytes = 0;
      if (length === void 0) length = null;
      return _native_typed_data.NativeByteData.view(this, offsetInBytes, length);
    }
  };
  _native_typed_data.NativeByteBuffer[dart.implements] = () => [typed_data.ByteBuffer];
  dart.setSignature(_native_typed_data.NativeByteBuffer, {
    methods: () => ({
      [dartx.asUint8List]: dart.definiteFunctionType(typed_data.Uint8List, [], [core.int, core.int]),
      [dartx.asInt8List]: dart.definiteFunctionType(typed_data.Int8List, [], [core.int, core.int]),
      [dartx.asUint8ClampedList]: dart.definiteFunctionType(typed_data.Uint8ClampedList, [], [core.int, core.int]),
      [dartx.asUint16List]: dart.definiteFunctionType(typed_data.Uint16List, [], [core.int, core.int]),
      [dartx.asInt16List]: dart.definiteFunctionType(typed_data.Int16List, [], [core.int, core.int]),
      [dartx.asUint32List]: dart.definiteFunctionType(typed_data.Uint32List, [], [core.int, core.int]),
      [dartx.asInt32List]: dart.definiteFunctionType(typed_data.Int32List, [], [core.int, core.int]),
      [dartx.asUint64List]: dart.definiteFunctionType(typed_data.Uint64List, [], [core.int, core.int]),
      [dartx.asInt64List]: dart.definiteFunctionType(typed_data.Int64List, [], [core.int, core.int]),
      [dartx.asInt32x4List]: dart.definiteFunctionType(typed_data.Int32x4List, [], [core.int, core.int]),
      [dartx.asFloat32List]: dart.definiteFunctionType(typed_data.Float32List, [], [core.int, core.int]),
      [dartx.asFloat64List]: dart.definiteFunctionType(typed_data.Float64List, [], [core.int, core.int]),
      [dartx.asFloat32x4List]: dart.definiteFunctionType(typed_data.Float32x4List, [], [core.int, core.int]),
      [dartx.asFloat64x2List]: dart.definiteFunctionType(typed_data.Float64x2List, [], [core.int, core.int]),
      [dartx.asByteData]: dart.definiteFunctionType(typed_data.ByteData, [], [core.int, core.int])
    })
  });
  dart.registerExtension(dart.global.ArrayBuffer, _native_typed_data.NativeByteBuffer);
  const _storage = Symbol('_storage');
  typed_data.Float32x4 = class Float32x4 extends core.Object {
    static new(x, y, z, w) {
      return new _native_typed_data.NativeFloat32x4(x, y, z, w);
    }
    static splat(v) {
      return new _native_typed_data.NativeFloat32x4.splat(v);
    }
    static zero() {
      return new _native_typed_data.NativeFloat32x4.zero();
    }
    static fromInt32x4Bits(x) {
      return _native_typed_data.NativeFloat32x4.fromInt32x4Bits(x);
    }
    static fromFloat64x2(v) {
      return new _native_typed_data.NativeFloat32x4.fromFloat64x2(v);
    }
  };
  dart.setSignature(typed_data.Float32x4, {
    constructors: () => ({
      new: dart.definiteFunctionType(typed_data.Float32x4, [core.double, core.double, core.double, core.double]),
      splat: dart.definiteFunctionType(typed_data.Float32x4, [core.double]),
      zero: dart.definiteFunctionType(typed_data.Float32x4, []),
      fromInt32x4Bits: dart.definiteFunctionType(typed_data.Float32x4, [typed_data.Int32x4]),
      fromFloat64x2: dart.definiteFunctionType(typed_data.Float32x4, [typed_data.Float64x2])
    })
  });
  typed_data.Float32x4.XXXX = 0;
  typed_data.Float32x4.XXXY = 64;
  typed_data.Float32x4.XXXZ = 128;
  typed_data.Float32x4.XXXW = 192;
  typed_data.Float32x4.XXYX = 16;
  typed_data.Float32x4.XXYY = 80;
  typed_data.Float32x4.XXYZ = 144;
  typed_data.Float32x4.XXYW = 208;
  typed_data.Float32x4.XXZX = 32;
  typed_data.Float32x4.XXZY = 96;
  typed_data.Float32x4.XXZZ = 160;
  typed_data.Float32x4.XXZW = 224;
  typed_data.Float32x4.XXWX = 48;
  typed_data.Float32x4.XXWY = 112;
  typed_data.Float32x4.XXWZ = 176;
  typed_data.Float32x4.XXWW = 240;
  typed_data.Float32x4.XYXX = 4;
  typed_data.Float32x4.XYXY = 68;
  typed_data.Float32x4.XYXZ = 132;
  typed_data.Float32x4.XYXW = 196;
  typed_data.Float32x4.XYYX = 20;
  typed_data.Float32x4.XYYY = 84;
  typed_data.Float32x4.XYYZ = 148;
  typed_data.Float32x4.XYYW = 212;
  typed_data.Float32x4.XYZX = 36;
  typed_data.Float32x4.XYZY = 100;
  typed_data.Float32x4.XYZZ = 164;
  typed_data.Float32x4.XYZW = 228;
  typed_data.Float32x4.XYWX = 52;
  typed_data.Float32x4.XYWY = 116;
  typed_data.Float32x4.XYWZ = 180;
  typed_data.Float32x4.XYWW = 244;
  typed_data.Float32x4.XZXX = 8;
  typed_data.Float32x4.XZXY = 72;
  typed_data.Float32x4.XZXZ = 136;
  typed_data.Float32x4.XZXW = 200;
  typed_data.Float32x4.XZYX = 24;
  typed_data.Float32x4.XZYY = 88;
  typed_data.Float32x4.XZYZ = 152;
  typed_data.Float32x4.XZYW = 216;
  typed_data.Float32x4.XZZX = 40;
  typed_data.Float32x4.XZZY = 104;
  typed_data.Float32x4.XZZZ = 168;
  typed_data.Float32x4.XZZW = 232;
  typed_data.Float32x4.XZWX = 56;
  typed_data.Float32x4.XZWY = 120;
  typed_data.Float32x4.XZWZ = 184;
  typed_data.Float32x4.XZWW = 248;
  typed_data.Float32x4.XWXX = 12;
  typed_data.Float32x4.XWXY = 76;
  typed_data.Float32x4.XWXZ = 140;
  typed_data.Float32x4.XWXW = 204;
  typed_data.Float32x4.XWYX = 28;
  typed_data.Float32x4.XWYY = 92;
  typed_data.Float32x4.XWYZ = 156;
  typed_data.Float32x4.XWYW = 220;
  typed_data.Float32x4.XWZX = 44;
  typed_data.Float32x4.XWZY = 108;
  typed_data.Float32x4.XWZZ = 172;
  typed_data.Float32x4.XWZW = 236;
  typed_data.Float32x4.XWWX = 60;
  typed_data.Float32x4.XWWY = 124;
  typed_data.Float32x4.XWWZ = 188;
  typed_data.Float32x4.XWWW = 252;
  typed_data.Float32x4.YXXX = 1;
  typed_data.Float32x4.YXXY = 65;
  typed_data.Float32x4.YXXZ = 129;
  typed_data.Float32x4.YXXW = 193;
  typed_data.Float32x4.YXYX = 17;
  typed_data.Float32x4.YXYY = 81;
  typed_data.Float32x4.YXYZ = 145;
  typed_data.Float32x4.YXYW = 209;
  typed_data.Float32x4.YXZX = 33;
  typed_data.Float32x4.YXZY = 97;
  typed_data.Float32x4.YXZZ = 161;
  typed_data.Float32x4.YXZW = 225;
  typed_data.Float32x4.YXWX = 49;
  typed_data.Float32x4.YXWY = 113;
  typed_data.Float32x4.YXWZ = 177;
  typed_data.Float32x4.YXWW = 241;
  typed_data.Float32x4.YYXX = 5;
  typed_data.Float32x4.YYXY = 69;
  typed_data.Float32x4.YYXZ = 133;
  typed_data.Float32x4.YYXW = 197;
  typed_data.Float32x4.YYYX = 21;
  typed_data.Float32x4.YYYY = 85;
  typed_data.Float32x4.YYYZ = 149;
  typed_data.Float32x4.YYYW = 213;
  typed_data.Float32x4.YYZX = 37;
  typed_data.Float32x4.YYZY = 101;
  typed_data.Float32x4.YYZZ = 165;
  typed_data.Float32x4.YYZW = 229;
  typed_data.Float32x4.YYWX = 53;
  typed_data.Float32x4.YYWY = 117;
  typed_data.Float32x4.YYWZ = 181;
  typed_data.Float32x4.YYWW = 245;
  typed_data.Float32x4.YZXX = 9;
  typed_data.Float32x4.YZXY = 73;
  typed_data.Float32x4.YZXZ = 137;
  typed_data.Float32x4.YZXW = 201;
  typed_data.Float32x4.YZYX = 25;
  typed_data.Float32x4.YZYY = 89;
  typed_data.Float32x4.YZYZ = 153;
  typed_data.Float32x4.YZYW = 217;
  typed_data.Float32x4.YZZX = 41;
  typed_data.Float32x4.YZZY = 105;
  typed_data.Float32x4.YZZZ = 169;
  typed_data.Float32x4.YZZW = 233;
  typed_data.Float32x4.YZWX = 57;
  typed_data.Float32x4.YZWY = 121;
  typed_data.Float32x4.YZWZ = 185;
  typed_data.Float32x4.YZWW = 249;
  typed_data.Float32x4.YWXX = 13;
  typed_data.Float32x4.YWXY = 77;
  typed_data.Float32x4.YWXZ = 141;
  typed_data.Float32x4.YWXW = 205;
  typed_data.Float32x4.YWYX = 29;
  typed_data.Float32x4.YWYY = 93;
  typed_data.Float32x4.YWYZ = 157;
  typed_data.Float32x4.YWYW = 221;
  typed_data.Float32x4.YWZX = 45;
  typed_data.Float32x4.YWZY = 109;
  typed_data.Float32x4.YWZZ = 173;
  typed_data.Float32x4.YWZW = 237;
  typed_data.Float32x4.YWWX = 61;
  typed_data.Float32x4.YWWY = 125;
  typed_data.Float32x4.YWWZ = 189;
  typed_data.Float32x4.YWWW = 253;
  typed_data.Float32x4.ZXXX = 2;
  typed_data.Float32x4.ZXXY = 66;
  typed_data.Float32x4.ZXXZ = 130;
  typed_data.Float32x4.ZXXW = 194;
  typed_data.Float32x4.ZXYX = 18;
  typed_data.Float32x4.ZXYY = 82;
  typed_data.Float32x4.ZXYZ = 146;
  typed_data.Float32x4.ZXYW = 210;
  typed_data.Float32x4.ZXZX = 34;
  typed_data.Float32x4.ZXZY = 98;
  typed_data.Float32x4.ZXZZ = 162;
  typed_data.Float32x4.ZXZW = 226;
  typed_data.Float32x4.ZXWX = 50;
  typed_data.Float32x4.ZXWY = 114;
  typed_data.Float32x4.ZXWZ = 178;
  typed_data.Float32x4.ZXWW = 242;
  typed_data.Float32x4.ZYXX = 6;
  typed_data.Float32x4.ZYXY = 70;
  typed_data.Float32x4.ZYXZ = 134;
  typed_data.Float32x4.ZYXW = 198;
  typed_data.Float32x4.ZYYX = 22;
  typed_data.Float32x4.ZYYY = 86;
  typed_data.Float32x4.ZYYZ = 150;
  typed_data.Float32x4.ZYYW = 214;
  typed_data.Float32x4.ZYZX = 38;
  typed_data.Float32x4.ZYZY = 102;
  typed_data.Float32x4.ZYZZ = 166;
  typed_data.Float32x4.ZYZW = 230;
  typed_data.Float32x4.ZYWX = 54;
  typed_data.Float32x4.ZYWY = 118;
  typed_data.Float32x4.ZYWZ = 182;
  typed_data.Float32x4.ZYWW = 246;
  typed_data.Float32x4.ZZXX = 10;
  typed_data.Float32x4.ZZXY = 74;
  typed_data.Float32x4.ZZXZ = 138;
  typed_data.Float32x4.ZZXW = 202;
  typed_data.Float32x4.ZZYX = 26;
  typed_data.Float32x4.ZZYY = 90;
  typed_data.Float32x4.ZZYZ = 154;
  typed_data.Float32x4.ZZYW = 218;
  typed_data.Float32x4.ZZZX = 42;
  typed_data.Float32x4.ZZZY = 106;
  typed_data.Float32x4.ZZZZ = 170;
  typed_data.Float32x4.ZZZW = 234;
  typed_data.Float32x4.ZZWX = 58;
  typed_data.Float32x4.ZZWY = 122;
  typed_data.Float32x4.ZZWZ = 186;
  typed_data.Float32x4.ZZWW = 250;
  typed_data.Float32x4.ZWXX = 14;
  typed_data.Float32x4.ZWXY = 78;
  typed_data.Float32x4.ZWXZ = 142;
  typed_data.Float32x4.ZWXW = 206;
  typed_data.Float32x4.ZWYX = 30;
  typed_data.Float32x4.ZWYY = 94;
  typed_data.Float32x4.ZWYZ = 158;
  typed_data.Float32x4.ZWYW = 222;
  typed_data.Float32x4.ZWZX = 46;
  typed_data.Float32x4.ZWZY = 110;
  typed_data.Float32x4.ZWZZ = 174;
  typed_data.Float32x4.ZWZW = 238;
  typed_data.Float32x4.ZWWX = 62;
  typed_data.Float32x4.ZWWY = 126;
  typed_data.Float32x4.ZWWZ = 190;
  typed_data.Float32x4.ZWWW = 254;
  typed_data.Float32x4.WXXX = 3;
  typed_data.Float32x4.WXXY = 67;
  typed_data.Float32x4.WXXZ = 131;
  typed_data.Float32x4.WXXW = 195;
  typed_data.Float32x4.WXYX = 19;
  typed_data.Float32x4.WXYY = 83;
  typed_data.Float32x4.WXYZ = 147;
  typed_data.Float32x4.WXYW = 211;
  typed_data.Float32x4.WXZX = 35;
  typed_data.Float32x4.WXZY = 99;
  typed_data.Float32x4.WXZZ = 163;
  typed_data.Float32x4.WXZW = 227;
  typed_data.Float32x4.WXWX = 51;
  typed_data.Float32x4.WXWY = 115;
  typed_data.Float32x4.WXWZ = 179;
  typed_data.Float32x4.WXWW = 243;
  typed_data.Float32x4.WYXX = 7;
  typed_data.Float32x4.WYXY = 71;
  typed_data.Float32x4.WYXZ = 135;
  typed_data.Float32x4.WYXW = 199;
  typed_data.Float32x4.WYYX = 23;
  typed_data.Float32x4.WYYY = 87;
  typed_data.Float32x4.WYYZ = 151;
  typed_data.Float32x4.WYYW = 215;
  typed_data.Float32x4.WYZX = 39;
  typed_data.Float32x4.WYZY = 103;
  typed_data.Float32x4.WYZZ = 167;
  typed_data.Float32x4.WYZW = 231;
  typed_data.Float32x4.WYWX = 55;
  typed_data.Float32x4.WYWY = 119;
  typed_data.Float32x4.WYWZ = 183;
  typed_data.Float32x4.WYWW = 247;
  typed_data.Float32x4.WZXX = 11;
  typed_data.Float32x4.WZXY = 75;
  typed_data.Float32x4.WZXZ = 139;
  typed_data.Float32x4.WZXW = 203;
  typed_data.Float32x4.WZYX = 27;
  typed_data.Float32x4.WZYY = 91;
  typed_data.Float32x4.WZYZ = 155;
  typed_data.Float32x4.WZYW = 219;
  typed_data.Float32x4.WZZX = 43;
  typed_data.Float32x4.WZZY = 107;
  typed_data.Float32x4.WZZZ = 171;
  typed_data.Float32x4.WZZW = 235;
  typed_data.Float32x4.WZWX = 59;
  typed_data.Float32x4.WZWY = 123;
  typed_data.Float32x4.WZWZ = 187;
  typed_data.Float32x4.WZWW = 251;
  typed_data.Float32x4.WWXX = 15;
  typed_data.Float32x4.WWXY = 79;
  typed_data.Float32x4.WWXZ = 143;
  typed_data.Float32x4.WWXW = 207;
  typed_data.Float32x4.WWYX = 31;
  typed_data.Float32x4.WWYY = 95;
  typed_data.Float32x4.WWYZ = 159;
  typed_data.Float32x4.WWYW = 223;
  typed_data.Float32x4.WWZX = 47;
  typed_data.Float32x4.WWZY = 111;
  typed_data.Float32x4.WWZZ = 175;
  typed_data.Float32x4.WWZW = 239;
  typed_data.Float32x4.WWWX = 63;
  typed_data.Float32x4.WWWY = 127;
  typed_data.Float32x4.WWWZ = 191;
  typed_data.Float32x4.WWWW = 255;
  _native_typed_data.NativeFloat32x4List = class NativeFloat32x4List extends dart.mixin(core.Object, collection.ListMixin$(typed_data.Float32x4), _internal.FixedLengthListMixin$(typed_data.Float32x4)) {
    new(length) {
      this[_storage] = _native_typed_data.NativeFloat32List.new(dart.notNull(length) * 4);
    }
    _externalStorage(storage) {
      this[_storage] = storage;
    }
    _slowFromList(list) {
      this[_storage] = _native_typed_data.NativeFloat32List.new(dart.notNull(list[dartx.length]) * 4);
      for (let i = 0; i < dart.notNull(list[dartx.length]); i++) {
        let e = list[dartx.get](i);
        this[_storage][dartx.set](i * 4 + 0, e.x);
        this[_storage][dartx.set](i * 4 + 1, e.y);
        this[_storage][dartx.set](i * 4 + 2, e.z);
        this[_storage][dartx.set](i * 4 + 3, e.w);
      }
    }
    get runtimeType() {
      return dart.wrapType(typed_data.Float32x4List);
    }
    static fromList(list) {
      if (_native_typed_data.NativeFloat32x4List.is(list)) {
        return new _native_typed_data.NativeFloat32x4List._externalStorage(_native_typed_data.NativeFloat32List.fromList(list[_storage]));
      } else {
        return new _native_typed_data.NativeFloat32x4List._slowFromList(list);
      }
    }
    get buffer() {
      return this[_storage][dartx.buffer];
    }
    get lengthInBytes() {
      return this[_storage][dartx.lengthInBytes];
    }
    get offsetInBytes() {
      return this[_storage][dartx.offsetInBytes];
    }
    get elementSizeInBytes() {
      return typed_data.Float32x4List.BYTES_PER_ELEMENT;
    }
    get length() {
      return (dart.notNull(this[_storage][dartx.length]) / 4)[dartx.truncate]();
    }
    set length(value) {
      super.length = value;
    }
    get(index) {
      _native_typed_data._checkValidIndex(index, this, this.length);
      let _x = this[_storage][dartx.get](dart.notNull(index) * 4 + 0);
      let _y = this[_storage][dartx.get](dart.notNull(index) * 4 + 1);
      let _z = this[_storage][dartx.get](dart.notNull(index) * 4 + 2);
      let _w = this[_storage][dartx.get](dart.notNull(index) * 4 + 3);
      return new _native_typed_data.NativeFloat32x4._truncated(_x, _y, _z, _w);
    }
    set(index, value) {
      _native_typed_data._checkValidIndex(index, this, this.length);
      this[_storage][dartx.set](dart.notNull(index) * 4 + 0, value.x);
      this[_storage][dartx.set](dart.notNull(index) * 4 + 1, value.y);
      this[_storage][dartx.set](dart.notNull(index) * 4 + 2, value.z);
      this[_storage][dartx.set](dart.notNull(index) * 4 + 3, value.w);
      return value;
    }
    sublist(start, end) {
      if (end === void 0) end = null;
      end = _native_typed_data._checkValidRange(start, end, this.length);
      return new _native_typed_data.NativeFloat32x4List._externalStorage(_native_typed_data.NativeFloat32List._check(this[_storage][dartx.sublist](dart.notNull(start) * 4, dart.notNull(end) * 4)));
    }
  };
  dart.defineNamedConstructor(_native_typed_data.NativeFloat32x4List, '_externalStorage');
  dart.defineNamedConstructor(_native_typed_data.NativeFloat32x4List, '_slowFromList');
  _native_typed_data.NativeFloat32x4List[dart.implements] = () => [typed_data.Float32x4List];
  dart.setSignature(_native_typed_data.NativeFloat32x4List, {
    constructors: () => ({
      new: dart.definiteFunctionType(_native_typed_data.NativeFloat32x4List, [core.int]),
      _externalStorage: dart.definiteFunctionType(_native_typed_data.NativeFloat32x4List, [_native_typed_data.NativeFloat32List]),
      _slowFromList: dart.definiteFunctionType(_native_typed_data.NativeFloat32x4List, [core.List$(typed_data.Float32x4)]),
      fromList: dart.definiteFunctionType(_native_typed_data.NativeFloat32x4List, [core.List$(typed_data.Float32x4)])
    }),
    methods: () => ({
      get: dart.definiteFunctionType(typed_data.Float32x4, [core.int]),
      set: dart.definiteFunctionType(dart.void, [core.int, typed_data.Float32x4]),
      sublist: dart.definiteFunctionType(core.List$(typed_data.Float32x4), [core.int], [core.int])
    })
  });
  dart.defineExtensionMembers(_native_typed_data.NativeFloat32x4List, [
    'get',
    'set',
    'sublist',
    'buffer',
    'lengthInBytes',
    'offsetInBytes',
    'elementSizeInBytes',
    'length'
  ]);
  typed_data.Int32x4 = class Int32x4 extends core.Object {
    static new(x, y, z, w) {
      return new _native_typed_data.NativeInt32x4(x, y, z, w);
    }
    static bool(x, y, z, w) {
      return new _native_typed_data.NativeInt32x4.bool(x, y, z, w);
    }
    static fromFloat32x4Bits(x) {
      return _native_typed_data.NativeInt32x4.fromFloat32x4Bits(x);
    }
  };
  dart.setSignature(typed_data.Int32x4, {
    constructors: () => ({
      new: dart.definiteFunctionType(typed_data.Int32x4, [core.int, core.int, core.int, core.int]),
      bool: dart.definiteFunctionType(typed_data.Int32x4, [core.bool, core.bool, core.bool, core.bool]),
      fromFloat32x4Bits: dart.definiteFunctionType(typed_data.Int32x4, [typed_data.Float32x4])
    })
  });
  typed_data.Int32x4.XXXX = 0;
  typed_data.Int32x4.XXXY = 64;
  typed_data.Int32x4.XXXZ = 128;
  typed_data.Int32x4.XXXW = 192;
  typed_data.Int32x4.XXYX = 16;
  typed_data.Int32x4.XXYY = 80;
  typed_data.Int32x4.XXYZ = 144;
  typed_data.Int32x4.XXYW = 208;
  typed_data.Int32x4.XXZX = 32;
  typed_data.Int32x4.XXZY = 96;
  typed_data.Int32x4.XXZZ = 160;
  typed_data.Int32x4.XXZW = 224;
  typed_data.Int32x4.XXWX = 48;
  typed_data.Int32x4.XXWY = 112;
  typed_data.Int32x4.XXWZ = 176;
  typed_data.Int32x4.XXWW = 240;
  typed_data.Int32x4.XYXX = 4;
  typed_data.Int32x4.XYXY = 68;
  typed_data.Int32x4.XYXZ = 132;
  typed_data.Int32x4.XYXW = 196;
  typed_data.Int32x4.XYYX = 20;
  typed_data.Int32x4.XYYY = 84;
  typed_data.Int32x4.XYYZ = 148;
  typed_data.Int32x4.XYYW = 212;
  typed_data.Int32x4.XYZX = 36;
  typed_data.Int32x4.XYZY = 100;
  typed_data.Int32x4.XYZZ = 164;
  typed_data.Int32x4.XYZW = 228;
  typed_data.Int32x4.XYWX = 52;
  typed_data.Int32x4.XYWY = 116;
  typed_data.Int32x4.XYWZ = 180;
  typed_data.Int32x4.XYWW = 244;
  typed_data.Int32x4.XZXX = 8;
  typed_data.Int32x4.XZXY = 72;
  typed_data.Int32x4.XZXZ = 136;
  typed_data.Int32x4.XZXW = 200;
  typed_data.Int32x4.XZYX = 24;
  typed_data.Int32x4.XZYY = 88;
  typed_data.Int32x4.XZYZ = 152;
  typed_data.Int32x4.XZYW = 216;
  typed_data.Int32x4.XZZX = 40;
  typed_data.Int32x4.XZZY = 104;
  typed_data.Int32x4.XZZZ = 168;
  typed_data.Int32x4.XZZW = 232;
  typed_data.Int32x4.XZWX = 56;
  typed_data.Int32x4.XZWY = 120;
  typed_data.Int32x4.XZWZ = 184;
  typed_data.Int32x4.XZWW = 248;
  typed_data.Int32x4.XWXX = 12;
  typed_data.Int32x4.XWXY = 76;
  typed_data.Int32x4.XWXZ = 140;
  typed_data.Int32x4.XWXW = 204;
  typed_data.Int32x4.XWYX = 28;
  typed_data.Int32x4.XWYY = 92;
  typed_data.Int32x4.XWYZ = 156;
  typed_data.Int32x4.XWYW = 220;
  typed_data.Int32x4.XWZX = 44;
  typed_data.Int32x4.XWZY = 108;
  typed_data.Int32x4.XWZZ = 172;
  typed_data.Int32x4.XWZW = 236;
  typed_data.Int32x4.XWWX = 60;
  typed_data.Int32x4.XWWY = 124;
  typed_data.Int32x4.XWWZ = 188;
  typed_data.Int32x4.XWWW = 252;
  typed_data.Int32x4.YXXX = 1;
  typed_data.Int32x4.YXXY = 65;
  typed_data.Int32x4.YXXZ = 129;
  typed_data.Int32x4.YXXW = 193;
  typed_data.Int32x4.YXYX = 17;
  typed_data.Int32x4.YXYY = 81;
  typed_data.Int32x4.YXYZ = 145;
  typed_data.Int32x4.YXYW = 209;
  typed_data.Int32x4.YXZX = 33;
  typed_data.Int32x4.YXZY = 97;
  typed_data.Int32x4.YXZZ = 161;
  typed_data.Int32x4.YXZW = 225;
  typed_data.Int32x4.YXWX = 49;
  typed_data.Int32x4.YXWY = 113;
  typed_data.Int32x4.YXWZ = 177;
  typed_data.Int32x4.YXWW = 241;
  typed_data.Int32x4.YYXX = 5;
  typed_data.Int32x4.YYXY = 69;
  typed_data.Int32x4.YYXZ = 133;
  typed_data.Int32x4.YYXW = 197;
  typed_data.Int32x4.YYYX = 21;
  typed_data.Int32x4.YYYY = 85;
  typed_data.Int32x4.YYYZ = 149;
  typed_data.Int32x4.YYYW = 213;
  typed_data.Int32x4.YYZX = 37;
  typed_data.Int32x4.YYZY = 101;
  typed_data.Int32x4.YYZZ = 165;
  typed_data.Int32x4.YYZW = 229;
  typed_data.Int32x4.YYWX = 53;
  typed_data.Int32x4.YYWY = 117;
  typed_data.Int32x4.YYWZ = 181;
  typed_data.Int32x4.YYWW = 245;
  typed_data.Int32x4.YZXX = 9;
  typed_data.Int32x4.YZXY = 73;
  typed_data.Int32x4.YZXZ = 137;
  typed_data.Int32x4.YZXW = 201;
  typed_data.Int32x4.YZYX = 25;
  typed_data.Int32x4.YZYY = 89;
  typed_data.Int32x4.YZYZ = 153;
  typed_data.Int32x4.YZYW = 217;
  typed_data.Int32x4.YZZX = 41;
  typed_data.Int32x4.YZZY = 105;
  typed_data.Int32x4.YZZZ = 169;
  typed_data.Int32x4.YZZW = 233;
  typed_data.Int32x4.YZWX = 57;
  typed_data.Int32x4.YZWY = 121;
  typed_data.Int32x4.YZWZ = 185;
  typed_data.Int32x4.YZWW = 249;
  typed_data.Int32x4.YWXX = 13;
  typed_data.Int32x4.YWXY = 77;
  typed_data.Int32x4.YWXZ = 141;
  typed_data.Int32x4.YWXW = 205;
  typed_data.Int32x4.YWYX = 29;
  typed_data.Int32x4.YWYY = 93;
  typed_data.Int32x4.YWYZ = 157;
  typed_data.Int32x4.YWYW = 221;
  typed_data.Int32x4.YWZX = 45;
  typed_data.Int32x4.YWZY = 109;
  typed_data.Int32x4.YWZZ = 173;
  typed_data.Int32x4.YWZW = 237;
  typed_data.Int32x4.YWWX = 61;
  typed_data.Int32x4.YWWY = 125;
  typed_data.Int32x4.YWWZ = 189;
  typed_data.Int32x4.YWWW = 253;
  typed_data.Int32x4.ZXXX = 2;
  typed_data.Int32x4.ZXXY = 66;
  typed_data.Int32x4.ZXXZ = 130;
  typed_data.Int32x4.ZXXW = 194;
  typed_data.Int32x4.ZXYX = 18;
  typed_data.Int32x4.ZXYY = 82;
  typed_data.Int32x4.ZXYZ = 146;
  typed_data.Int32x4.ZXYW = 210;
  typed_data.Int32x4.ZXZX = 34;
  typed_data.Int32x4.ZXZY = 98;
  typed_data.Int32x4.ZXZZ = 162;
  typed_data.Int32x4.ZXZW = 226;
  typed_data.Int32x4.ZXWX = 50;
  typed_data.Int32x4.ZXWY = 114;
  typed_data.Int32x4.ZXWZ = 178;
  typed_data.Int32x4.ZXWW = 242;
  typed_data.Int32x4.ZYXX = 6;
  typed_data.Int32x4.ZYXY = 70;
  typed_data.Int32x4.ZYXZ = 134;
  typed_data.Int32x4.ZYXW = 198;
  typed_data.Int32x4.ZYYX = 22;
  typed_data.Int32x4.ZYYY = 86;
  typed_data.Int32x4.ZYYZ = 150;
  typed_data.Int32x4.ZYYW = 214;
  typed_data.Int32x4.ZYZX = 38;
  typed_data.Int32x4.ZYZY = 102;
  typed_data.Int32x4.ZYZZ = 166;
  typed_data.Int32x4.ZYZW = 230;
  typed_data.Int32x4.ZYWX = 54;
  typed_data.Int32x4.ZYWY = 118;
  typed_data.Int32x4.ZYWZ = 182;
  typed_data.Int32x4.ZYWW = 246;
  typed_data.Int32x4.ZZXX = 10;
  typed_data.Int32x4.ZZXY = 74;
  typed_data.Int32x4.ZZXZ = 138;
  typed_data.Int32x4.ZZXW = 202;
  typed_data.Int32x4.ZZYX = 26;
  typed_data.Int32x4.ZZYY = 90;
  typed_data.Int32x4.ZZYZ = 154;
  typed_data.Int32x4.ZZYW = 218;
  typed_data.Int32x4.ZZZX = 42;
  typed_data.Int32x4.ZZZY = 106;
  typed_data.Int32x4.ZZZZ = 170;
  typed_data.Int32x4.ZZZW = 234;
  typed_data.Int32x4.ZZWX = 58;
  typed_data.Int32x4.ZZWY = 122;
  typed_data.Int32x4.ZZWZ = 186;
  typed_data.Int32x4.ZZWW = 250;
  typed_data.Int32x4.ZWXX = 14;
  typed_data.Int32x4.ZWXY = 78;
  typed_data.Int32x4.ZWXZ = 142;
  typed_data.Int32x4.ZWXW = 206;
  typed_data.Int32x4.ZWYX = 30;
  typed_data.Int32x4.ZWYY = 94;
  typed_data.Int32x4.ZWYZ = 158;
  typed_data.Int32x4.ZWYW = 222;
  typed_data.Int32x4.ZWZX = 46;
  typed_data.Int32x4.ZWZY = 110;
  typed_data.Int32x4.ZWZZ = 174;
  typed_data.Int32x4.ZWZW = 238;
  typed_data.Int32x4.ZWWX = 62;
  typed_data.Int32x4.ZWWY = 126;
  typed_data.Int32x4.ZWWZ = 190;
  typed_data.Int32x4.ZWWW = 254;
  typed_data.Int32x4.WXXX = 3;
  typed_data.Int32x4.WXXY = 67;
  typed_data.Int32x4.WXXZ = 131;
  typed_data.Int32x4.WXXW = 195;
  typed_data.Int32x4.WXYX = 19;
  typed_data.Int32x4.WXYY = 83;
  typed_data.Int32x4.WXYZ = 147;
  typed_data.Int32x4.WXYW = 211;
  typed_data.Int32x4.WXZX = 35;
  typed_data.Int32x4.WXZY = 99;
  typed_data.Int32x4.WXZZ = 163;
  typed_data.Int32x4.WXZW = 227;
  typed_data.Int32x4.WXWX = 51;
  typed_data.Int32x4.WXWY = 115;
  typed_data.Int32x4.WXWZ = 179;
  typed_data.Int32x4.WXWW = 243;
  typed_data.Int32x4.WYXX = 7;
  typed_data.Int32x4.WYXY = 71;
  typed_data.Int32x4.WYXZ = 135;
  typed_data.Int32x4.WYXW = 199;
  typed_data.Int32x4.WYYX = 23;
  typed_data.Int32x4.WYYY = 87;
  typed_data.Int32x4.WYYZ = 151;
  typed_data.Int32x4.WYYW = 215;
  typed_data.Int32x4.WYZX = 39;
  typed_data.Int32x4.WYZY = 103;
  typed_data.Int32x4.WYZZ = 167;
  typed_data.Int32x4.WYZW = 231;
  typed_data.Int32x4.WYWX = 55;
  typed_data.Int32x4.WYWY = 119;
  typed_data.Int32x4.WYWZ = 183;
  typed_data.Int32x4.WYWW = 247;
  typed_data.Int32x4.WZXX = 11;
  typed_data.Int32x4.WZXY = 75;
  typed_data.Int32x4.WZXZ = 139;
  typed_data.Int32x4.WZXW = 203;
  typed_data.Int32x4.WZYX = 27;
  typed_data.Int32x4.WZYY = 91;
  typed_data.Int32x4.WZYZ = 155;
  typed_data.Int32x4.WZYW = 219;
  typed_data.Int32x4.WZZX = 43;
  typed_data.Int32x4.WZZY = 107;
  typed_data.Int32x4.WZZZ = 171;
  typed_data.Int32x4.WZZW = 235;
  typed_data.Int32x4.WZWX = 59;
  typed_data.Int32x4.WZWY = 123;
  typed_data.Int32x4.WZWZ = 187;
  typed_data.Int32x4.WZWW = 251;
  typed_data.Int32x4.WWXX = 15;
  typed_data.Int32x4.WWXY = 79;
  typed_data.Int32x4.WWXZ = 143;
  typed_data.Int32x4.WWXW = 207;
  typed_data.Int32x4.WWYX = 31;
  typed_data.Int32x4.WWYY = 95;
  typed_data.Int32x4.WWYZ = 159;
  typed_data.Int32x4.WWYW = 223;
  typed_data.Int32x4.WWZX = 47;
  typed_data.Int32x4.WWZY = 111;
  typed_data.Int32x4.WWZZ = 175;
  typed_data.Int32x4.WWZW = 239;
  typed_data.Int32x4.WWWX = 63;
  typed_data.Int32x4.WWWY = 127;
  typed_data.Int32x4.WWWZ = 191;
  typed_data.Int32x4.WWWW = 255;
  _native_typed_data.NativeInt32x4List = class NativeInt32x4List extends dart.mixin(core.Object, collection.ListMixin$(typed_data.Int32x4), _internal.FixedLengthListMixin$(typed_data.Int32x4)) {
    new(length) {
      this[_storage] = _native_typed_data.NativeInt32List.new(dart.notNull(length) * 4);
    }
    _externalStorage(storage) {
      this[_storage] = storage;
    }
    _slowFromList(list) {
      this[_storage] = _native_typed_data.NativeInt32List.new(dart.notNull(list[dartx.length]) * 4);
      for (let i = 0; i < dart.notNull(list[dartx.length]); i++) {
        let e = list[dartx.get](i);
        this[_storage][dartx.set](i * 4 + 0, e.x);
        this[_storage][dartx.set](i * 4 + 1, e.y);
        this[_storage][dartx.set](i * 4 + 2, e.z);
        this[_storage][dartx.set](i * 4 + 3, e.w);
      }
    }
    get runtimeType() {
      return dart.wrapType(typed_data.Int32x4List);
    }
    static fromList(list) {
      if (_native_typed_data.NativeInt32x4List.is(list)) {
        return new _native_typed_data.NativeInt32x4List._externalStorage(_native_typed_data.NativeInt32List.fromList(list[_storage]));
      } else {
        return new _native_typed_data.NativeInt32x4List._slowFromList(list);
      }
    }
    get buffer() {
      return this[_storage][dartx.buffer];
    }
    get lengthInBytes() {
      return this[_storage][dartx.lengthInBytes];
    }
    get offsetInBytes() {
      return this[_storage][dartx.offsetInBytes];
    }
    get elementSizeInBytes() {
      return typed_data.Int32x4List.BYTES_PER_ELEMENT;
    }
    get length() {
      return (dart.notNull(this[_storage][dartx.length]) / 4)[dartx.truncate]();
    }
    set length(value) {
      super.length = value;
    }
    get(index) {
      _native_typed_data._checkValidIndex(index, this, this.length);
      let _x = this[_storage][dartx.get](dart.notNull(index) * 4 + 0);
      let _y = this[_storage][dartx.get](dart.notNull(index) * 4 + 1);
      let _z = this[_storage][dartx.get](dart.notNull(index) * 4 + 2);
      let _w = this[_storage][dartx.get](dart.notNull(index) * 4 + 3);
      return new _native_typed_data.NativeInt32x4._truncated(_x, _y, _z, _w);
    }
    set(index, value) {
      _native_typed_data._checkValidIndex(index, this, this.length);
      this[_storage][dartx.set](dart.notNull(index) * 4 + 0, value.x);
      this[_storage][dartx.set](dart.notNull(index) * 4 + 1, value.y);
      this[_storage][dartx.set](dart.notNull(index) * 4 + 2, value.z);
      this[_storage][dartx.set](dart.notNull(index) * 4 + 3, value.w);
      return value;
    }
    sublist(start, end) {
      if (end === void 0) end = null;
      end = _native_typed_data._checkValidRange(start, end, this.length);
      return new _native_typed_data.NativeInt32x4List._externalStorage(typed_data.Int32List._check(this[_storage][dartx.sublist](dart.notNull(start) * 4, dart.notNull(end) * 4)));
    }
  };
  dart.defineNamedConstructor(_native_typed_data.NativeInt32x4List, '_externalStorage');
  dart.defineNamedConstructor(_native_typed_data.NativeInt32x4List, '_slowFromList');
  _native_typed_data.NativeInt32x4List[dart.implements] = () => [typed_data.Int32x4List];
  dart.setSignature(_native_typed_data.NativeInt32x4List, {
    constructors: () => ({
      new: dart.definiteFunctionType(_native_typed_data.NativeInt32x4List, [core.int]),
      _externalStorage: dart.definiteFunctionType(_native_typed_data.NativeInt32x4List, [typed_data.Int32List]),
      _slowFromList: dart.definiteFunctionType(_native_typed_data.NativeInt32x4List, [core.List$(typed_data.Int32x4)]),
      fromList: dart.definiteFunctionType(_native_typed_data.NativeInt32x4List, [core.List$(typed_data.Int32x4)])
    }),
    methods: () => ({
      get: dart.definiteFunctionType(typed_data.Int32x4, [core.int]),
      set: dart.definiteFunctionType(dart.void, [core.int, typed_data.Int32x4]),
      sublist: dart.definiteFunctionType(core.List$(typed_data.Int32x4), [core.int], [core.int])
    })
  });
  dart.defineExtensionMembers(_native_typed_data.NativeInt32x4List, [
    'get',
    'set',
    'sublist',
    'buffer',
    'lengthInBytes',
    'offsetInBytes',
    'elementSizeInBytes',
    'length'
  ]);
  typed_data.Float64x2 = class Float64x2 extends core.Object {
    static new(x, y) {
      return new _native_typed_data.NativeFloat64x2(x, y);
    }
    static splat(v) {
      return new _native_typed_data.NativeFloat64x2.splat(v);
    }
    static zero() {
      return new _native_typed_data.NativeFloat64x2.zero();
    }
    static fromFloat32x4(v) {
      return new _native_typed_data.NativeFloat64x2.fromFloat32x4(v);
    }
  };
  dart.setSignature(typed_data.Float64x2, {
    constructors: () => ({
      new: dart.definiteFunctionType(typed_data.Float64x2, [core.double, core.double]),
      splat: dart.definiteFunctionType(typed_data.Float64x2, [core.double]),
      zero: dart.definiteFunctionType(typed_data.Float64x2, []),
      fromFloat32x4: dart.definiteFunctionType(typed_data.Float64x2, [typed_data.Float32x4])
    })
  });
  _native_typed_data.NativeFloat64x2List = class NativeFloat64x2List extends dart.mixin(core.Object, collection.ListMixin$(typed_data.Float64x2), _internal.FixedLengthListMixin$(typed_data.Float64x2)) {
    new(length) {
      this[_storage] = _native_typed_data.NativeFloat64List.new(dart.notNull(length) * 2);
    }
    _externalStorage(storage) {
      this[_storage] = storage;
    }
    _slowFromList(list) {
      this[_storage] = _native_typed_data.NativeFloat64List.new(dart.notNull(list[dartx.length]) * 2);
      for (let i = 0; i < dart.notNull(list[dartx.length]); i++) {
        let e = list[dartx.get](i);
        this[_storage][dartx.set](i * 2 + 0, e.x);
        this[_storage][dartx.set](i * 2 + 1, e.y);
      }
    }
    static fromList(list) {
      if (_native_typed_data.NativeFloat64x2List.is(list)) {
        return new _native_typed_data.NativeFloat64x2List._externalStorage(_native_typed_data.NativeFloat64List.fromList(list[_storage]));
      } else {
        return new _native_typed_data.NativeFloat64x2List._slowFromList(list);
      }
    }
    get runtimeType() {
      return dart.wrapType(typed_data.Float64x2List);
    }
    get buffer() {
      return this[_storage][dartx.buffer];
    }
    get lengthInBytes() {
      return this[_storage][dartx.lengthInBytes];
    }
    get offsetInBytes() {
      return this[_storage][dartx.offsetInBytes];
    }
    get elementSizeInBytes() {
      return typed_data.Float64x2List.BYTES_PER_ELEMENT;
    }
    get length() {
      return (dart.notNull(this[_storage][dartx.length]) / 2)[dartx.truncate]();
    }
    set length(value) {
      super.length = value;
    }
    get(index) {
      _native_typed_data._checkValidIndex(index, this, this.length);
      let _x = this[_storage][dartx.get](dart.notNull(index) * 2 + 0);
      let _y = this[_storage][dartx.get](dart.notNull(index) * 2 + 1);
      return typed_data.Float64x2.new(_x, _y);
    }
    set(index, value) {
      _native_typed_data._checkValidIndex(index, this, this.length);
      this[_storage][dartx.set](dart.notNull(index) * 2 + 0, value.x);
      this[_storage][dartx.set](dart.notNull(index) * 2 + 1, value.y);
      return value;
    }
    sublist(start, end) {
      if (end === void 0) end = null;
      end = _native_typed_data._checkValidRange(start, end, this.length);
      return new _native_typed_data.NativeFloat64x2List._externalStorage(_native_typed_data.NativeFloat64List._check(this[_storage][dartx.sublist](dart.notNull(start) * 2, dart.notNull(end) * 2)));
    }
  };
  dart.defineNamedConstructor(_native_typed_data.NativeFloat64x2List, '_externalStorage');
  dart.defineNamedConstructor(_native_typed_data.NativeFloat64x2List, '_slowFromList');
  _native_typed_data.NativeFloat64x2List[dart.implements] = () => [typed_data.Float64x2List];
  dart.setSignature(_native_typed_data.NativeFloat64x2List, {
    constructors: () => ({
      new: dart.definiteFunctionType(_native_typed_data.NativeFloat64x2List, [core.int]),
      _externalStorage: dart.definiteFunctionType(_native_typed_data.NativeFloat64x2List, [_native_typed_data.NativeFloat64List]),
      _slowFromList: dart.definiteFunctionType(_native_typed_data.NativeFloat64x2List, [core.List$(typed_data.Float64x2)]),
      fromList: dart.definiteFunctionType(_native_typed_data.NativeFloat64x2List, [core.List$(typed_data.Float64x2)])
    }),
    methods: () => ({
      get: dart.definiteFunctionType(typed_data.Float64x2, [core.int]),
      set: dart.definiteFunctionType(dart.void, [core.int, typed_data.Float64x2]),
      sublist: dart.definiteFunctionType(core.List$(typed_data.Float64x2), [core.int], [core.int])
    })
  });
  dart.defineExtensionMembers(_native_typed_data.NativeFloat64x2List, [
    'get',
    'set',
    'sublist',
    'buffer',
    'lengthInBytes',
    'offsetInBytes',
    'elementSizeInBytes',
    'length'
  ]);
  const _invalidPosition = Symbol('_invalidPosition');
  const _checkPosition = Symbol('_checkPosition');
  dart.defineExtensionNames([
    'buffer',
    'lengthInBytes',
    'offsetInBytes',
    'elementSizeInBytes'
  ]);
  _native_typed_data.NativeTypedData = class NativeTypedData extends core.Object {
    get [dartx.buffer]() {
      return this.buffer;
    }
    get [dartx.lengthInBytes]() {
      return this.byteLength;
    }
    get [dartx.offsetInBytes]() {
      return this.byteOffset;
    }
    get [dartx.elementSizeInBytes]() {
      return this.BYTES_PER_ELEMENT;
    }
    [_invalidPosition](position, length, name) {
      if (!(typeof position == 'number')) {
        dart.throw(new core.ArgumentError.value(position, name, 'Invalid list position'));
      } else {
        dart.throw(new core.RangeError.range(position, 0, length, name));
      }
    }
    [_checkPosition](position, length, name) {
      if (position >>> 0 !== position || position > dart.notNull(length)) {
        this[_invalidPosition](position, length, name);
      }
    }
  };
  _native_typed_data.NativeTypedData[dart.implements] = () => [typed_data.TypedData];
  dart.setSignature(_native_typed_data.NativeTypedData, {
    methods: () => ({
      [_invalidPosition]: dart.definiteFunctionType(dart.void, [core.int, core.int, core.String]),
      [_checkPosition]: dart.definiteFunctionType(dart.void, [core.int, core.int, core.String])
    })
  });
  dart.registerExtension(dart.global.ArrayBufferView, _native_typed_data.NativeTypedData);
  _native_typed_data._checkLength = function(length) {
    if (!(typeof length == 'number')) dart.throw(new core.ArgumentError(dart.str`Invalid length ${length}`));
    return core.int._check(length);
  };
  dart.fn(_native_typed_data._checkLength, dynamicToint());
  _native_typed_data._checkViewArguments = function(buffer, offsetInBytes, length) {
    if (!_native_typed_data.NativeByteBuffer.is(buffer)) {
      dart.throw(new core.ArgumentError('Invalid view buffer'));
    }
    if (!(typeof offsetInBytes == 'number')) {
      dart.throw(new core.ArgumentError(dart.str`Invalid view offsetInBytes ${offsetInBytes}`));
    }
    if (length != null && !(typeof length == 'number')) {
      dart.throw(new core.ArgumentError(dart.str`Invalid view length ${length}`));
    }
  };
  dart.fn(_native_typed_data._checkViewArguments, dynamicAnddynamicAnddynamicTovoid());
  _native_typed_data._ensureNativeList = function(list) {
    if (_interceptors.JSIndexable.is(list)) return list;
    let result = core.List.new(list[dartx.length]);
    for (let i = 0; i < dart.notNull(list[dartx.length]); i++) {
      result[dartx.set](i, list[dartx.get](i));
    }
    return result;
  };
  dart.lazyFn(_native_typed_data._ensureNativeList, () => ListToList());
  const _getFloat32 = Symbol('_getFloat32');
  const _getFloat64 = Symbol('_getFloat64');
  const _getInt16 = Symbol('_getInt16');
  const _getInt32 = Symbol('_getInt32');
  const _getUint16 = Symbol('_getUint16');
  const _getUint32 = Symbol('_getUint32');
  const _setFloat32 = Symbol('_setFloat32');
  const _setFloat64 = Symbol('_setFloat64');
  const _setInt16 = Symbol('_setInt16');
  const _setInt32 = Symbol('_setInt32');
  const _setUint16 = Symbol('_setUint16');
  const _setUint32 = Symbol('_setUint32');
  dart.defineExtensionNames([
    'runtimeType',
    'elementSizeInBytes',
    'getFloat32',
    'getFloat64',
    'getInt16',
    'getInt32',
    'getInt64',
    'getInt8',
    'getUint16',
    'getUint32',
    'getUint64',
    'getUint8',
    'setFloat32',
    'setFloat64',
    'setInt16',
    'setInt32',
    'setInt64',
    'setInt8',
    'setUint16',
    'setUint32',
    'setUint64',
    'setUint8'
  ]);
  _native_typed_data.NativeByteData = class NativeByteData extends _native_typed_data.NativeTypedData {
    static new(length) {
      return _native_typed_data.NativeByteData._create1(_native_typed_data._checkLength(length));
    }
    static view(buffer, offsetInBytes, length) {
      _native_typed_data._checkViewArguments(buffer, offsetInBytes, length);
      return length == null ? _native_typed_data.NativeByteData._create2(buffer, offsetInBytes) : _native_typed_data.NativeByteData._create3(buffer, offsetInBytes, length);
    }
    get [dartx.runtimeType]() {
      return dart.wrapType(typed_data.ByteData);
    }
    get [dartx.elementSizeInBytes]() {
      return 1;
    }
    [dartx.getFloat32](byteOffset, endian) {
      if (endian === void 0) endian = typed_data.Endianness.BIG_ENDIAN;
      return this[_getFloat32](byteOffset, dart.equals(typed_data.Endianness.LITTLE_ENDIAN, endian));
    }
    [_getFloat32](byteOffset, littleEndian) {
      return this.getFloat32(byteOffset, littleEndian);
    }
    [dartx.getFloat64](byteOffset, endian) {
      if (endian === void 0) endian = typed_data.Endianness.BIG_ENDIAN;
      return this[_getFloat64](byteOffset, dart.equals(typed_data.Endianness.LITTLE_ENDIAN, endian));
    }
    [_getFloat64](byteOffset, littleEndian) {
      return this.getFloat64(byteOffset, littleEndian);
    }
    [dartx.getInt16](byteOffset, endian) {
      if (endian === void 0) endian = typed_data.Endianness.BIG_ENDIAN;
      return this[_getInt16](byteOffset, dart.equals(typed_data.Endianness.LITTLE_ENDIAN, endian));
    }
    [_getInt16](byteOffset, littleEndian) {
      return this.getInt16(byteOffset, littleEndian);
    }
    [dartx.getInt32](byteOffset, endian) {
      if (endian === void 0) endian = typed_data.Endianness.BIG_ENDIAN;
      return this[_getInt32](byteOffset, dart.equals(typed_data.Endianness.LITTLE_ENDIAN, endian));
    }
    [_getInt32](byteOffset, littleEndian) {
      return this.getInt32(byteOffset, littleEndian);
    }
    [dartx.getInt64](byteOffset, endian) {
      if (endian === void 0) endian = typed_data.Endianness.BIG_ENDIAN;
      dart.throw(new core.UnsupportedError('Int64 accessor not supported by dart2js.'));
    }
    [dartx.getInt8](byteOffset) {
      return this.getInt8(byteOffset);
    }
    [dartx.getUint16](byteOffset, endian) {
      if (endian === void 0) endian = typed_data.Endianness.BIG_ENDIAN;
      return this[_getUint16](byteOffset, dart.equals(typed_data.Endianness.LITTLE_ENDIAN, endian));
    }
    [_getUint16](byteOffset, littleEndian) {
      return this.getUint16(byteOffset, littleEndian);
    }
    [dartx.getUint32](byteOffset, endian) {
      if (endian === void 0) endian = typed_data.Endianness.BIG_ENDIAN;
      return this[_getUint32](byteOffset, dart.equals(typed_data.Endianness.LITTLE_ENDIAN, endian));
    }
    [_getUint32](byteOffset, littleEndian) {
      return this.getUint32(byteOffset, littleEndian);
    }
    [dartx.getUint64](byteOffset, endian) {
      if (endian === void 0) endian = typed_data.Endianness.BIG_ENDIAN;
      dart.throw(new core.UnsupportedError('Uint64 accessor not supported by dart2js.'));
    }
    [dartx.getUint8](byteOffset) {
      return this.getUint8(byteOffset);
    }
    [dartx.setFloat32](byteOffset, value, endian) {
      if (endian === void 0) endian = typed_data.Endianness.BIG_ENDIAN;
      return this[_setFloat32](byteOffset, value, dart.equals(typed_data.Endianness.LITTLE_ENDIAN, endian));
    }
    [_setFloat32](byteOffset, value, littleEndian) {
      return this.setFloat32(byteOffset, value, littleEndian);
    }
    [dartx.setFloat64](byteOffset, value, endian) {
      if (endian === void 0) endian = typed_data.Endianness.BIG_ENDIAN;
      return this[_setFloat64](byteOffset, value, dart.equals(typed_data.Endianness.LITTLE_ENDIAN, endian));
    }
    [_setFloat64](byteOffset, value, littleEndian) {
      return this.setFloat64(byteOffset, value, littleEndian);
    }
    [dartx.setInt16](byteOffset, value, endian) {
      if (endian === void 0) endian = typed_data.Endianness.BIG_ENDIAN;
      return this[_setInt16](byteOffset, value, dart.equals(typed_data.Endianness.LITTLE_ENDIAN, endian));
    }
    [_setInt16](byteOffset, value, littleEndian) {
      return this.setInt16(byteOffset, value, littleEndian);
    }
    [dartx.setInt32](byteOffset, value, endian) {
      if (endian === void 0) endian = typed_data.Endianness.BIG_ENDIAN;
      return this[_setInt32](byteOffset, value, dart.equals(typed_data.Endianness.LITTLE_ENDIAN, endian));
    }
    [_setInt32](byteOffset, value, littleEndian) {
      return this.setInt32(byteOffset, value, littleEndian);
    }
    [dartx.setInt64](byteOffset, value, endian) {
      if (endian === void 0) endian = typed_data.Endianness.BIG_ENDIAN;
      dart.throw(new core.UnsupportedError('Int64 accessor not supported by dart2js.'));
    }
    [dartx.setInt8](byteOffset, value) {
      return this.setInt8(byteOffset, value);
    }
    [dartx.setUint16](byteOffset, value, endian) {
      if (endian === void 0) endian = typed_data.Endianness.BIG_ENDIAN;
      return this[_setUint16](byteOffset, value, dart.equals(typed_data.Endianness.LITTLE_ENDIAN, endian));
    }
    [_setUint16](byteOffset, value, littleEndian) {
      return this.setUint16(byteOffset, value, littleEndian);
    }
    [dartx.setUint32](byteOffset, value, endian) {
      if (endian === void 0) endian = typed_data.Endianness.BIG_ENDIAN;
      return this[_setUint32](byteOffset, value, dart.equals(typed_data.Endianness.LITTLE_ENDIAN, endian));
    }
    [_setUint32](byteOffset, value, littleEndian) {
      return this.setUint32(byteOffset, value, littleEndian);
    }
    [dartx.setUint64](byteOffset, value, endian) {
      if (endian === void 0) endian = typed_data.Endianness.BIG_ENDIAN;
      dart.throw(new core.UnsupportedError('Uint64 accessor not supported by dart2js.'));
    }
    [dartx.setUint8](byteOffset, value) {
      return this.setUint8(byteOffset, value);
    }
    static _create1(arg) {
      return new DataView(new ArrayBuffer(arg));
    }
    static _create2(arg1, arg2) {
      return new DataView(arg1, arg2);
    }
    static _create3(arg1, arg2, arg3) {
      return new DataView(arg1, arg2, arg3);
    }
  };
  _native_typed_data.NativeByteData[dart.implements] = () => [typed_data.ByteData];
  dart.setSignature(_native_typed_data.NativeByteData, {
    constructors: () => ({
      new: dart.definiteFunctionType(_native_typed_data.NativeByteData, [core.int]),
      view: dart.definiteFunctionType(_native_typed_data.NativeByteData, [typed_data.ByteBuffer, core.int, core.int])
    }),
    methods: () => ({
      [dartx.getFloat32]: dart.definiteFunctionType(core.double, [core.int], [typed_data.Endianness]),
      [_getFloat32]: dart.definiteFunctionType(core.double, [core.int], [core.bool]),
      [dartx.getFloat64]: dart.definiteFunctionType(core.double, [core.int], [typed_data.Endianness]),
      [_getFloat64]: dart.definiteFunctionType(core.double, [core.int], [core.bool]),
      [dartx.getInt16]: dart.definiteFunctionType(core.int, [core.int], [typed_data.Endianness]),
      [_getInt16]: dart.definiteFunctionType(core.int, [core.int], [core.bool]),
      [dartx.getInt32]: dart.definiteFunctionType(core.int, [core.int], [typed_data.Endianness]),
      [_getInt32]: dart.definiteFunctionType(core.int, [core.int], [core.bool]),
      [dartx.getInt64]: dart.definiteFunctionType(core.int, [core.int], [typed_data.Endianness]),
      [dartx.getInt8]: dart.definiteFunctionType(core.int, [core.int]),
      [dartx.getUint16]: dart.definiteFunctionType(core.int, [core.int], [typed_data.Endianness]),
      [_getUint16]: dart.definiteFunctionType(core.int, [core.int], [core.bool]),
      [dartx.getUint32]: dart.definiteFunctionType(core.int, [core.int], [typed_data.Endianness]),
      [_getUint32]: dart.definiteFunctionType(core.int, [core.int], [core.bool]),
      [dartx.getUint64]: dart.definiteFunctionType(core.int, [core.int], [typed_data.Endianness]),
      [dartx.getUint8]: dart.definiteFunctionType(core.int, [core.int]),
      [dartx.setFloat32]: dart.definiteFunctionType(dart.void, [core.int, core.num], [typed_data.Endianness]),
      [_setFloat32]: dart.definiteFunctionType(dart.void, [core.int, core.num], [core.bool]),
      [dartx.setFloat64]: dart.definiteFunctionType(dart.void, [core.int, core.num], [typed_data.Endianness]),
      [_setFloat64]: dart.definiteFunctionType(dart.void, [core.int, core.num], [core.bool]),
      [dartx.setInt16]: dart.definiteFunctionType(dart.void, [core.int, core.int], [typed_data.Endianness]),
      [_setInt16]: dart.definiteFunctionType(dart.void, [core.int, core.int], [core.bool]),
      [dartx.setInt32]: dart.definiteFunctionType(dart.void, [core.int, core.int], [typed_data.Endianness]),
      [_setInt32]: dart.definiteFunctionType(dart.void, [core.int, core.int], [core.bool]),
      [dartx.setInt64]: dart.definiteFunctionType(dart.void, [core.int, core.int], [typed_data.Endianness]),
      [dartx.setInt8]: dart.definiteFunctionType(dart.void, [core.int, core.int]),
      [dartx.setUint16]: dart.definiteFunctionType(dart.void, [core.int, core.int], [typed_data.Endianness]),
      [_setUint16]: dart.definiteFunctionType(dart.void, [core.int, core.int], [core.bool]),
      [dartx.setUint32]: dart.definiteFunctionType(dart.void, [core.int, core.int], [typed_data.Endianness]),
      [_setUint32]: dart.definiteFunctionType(dart.void, [core.int, core.int], [core.bool]),
      [dartx.setUint64]: dart.definiteFunctionType(dart.void, [core.int, core.int], [typed_data.Endianness]),
      [dartx.setUint8]: dart.definiteFunctionType(dart.void, [core.int, core.int])
    }),
    statics: () => ({
      _create1: dart.definiteFunctionType(_native_typed_data.NativeByteData, [dart.dynamic]),
      _create2: dart.definiteFunctionType(_native_typed_data.NativeByteData, [dart.dynamic, dart.dynamic]),
      _create3: dart.definiteFunctionType(_native_typed_data.NativeByteData, [dart.dynamic, dart.dynamic, dart.dynamic])
    }),
    names: ['_create1', '_create2', '_create3']
  });
  dart.registerExtension(dart.global.DataView, _native_typed_data.NativeByteData);
  const _setRangeFast = Symbol('_setRangeFast');
  _native_typed_data.NativeTypedArray = class NativeTypedArray extends _native_typed_data.NativeTypedData {
    [_setRangeFast](start, end, source, skipCount) {
      let targetLength = this[dartx.length];
      this[_checkPosition](start, targetLength, "start");
      this[_checkPosition](end, targetLength, "end");
      if (dart.notNull(start) > dart.notNull(end)) dart.throw(new core.RangeError.range(start, 0, end));
      let count = dart.notNull(end) - dart.notNull(start);
      if (dart.notNull(skipCount) < 0) dart.throw(new core.ArgumentError(skipCount));
      let sourceLength = source[dartx.length];
      if (dart.notNull(sourceLength) - dart.notNull(skipCount) < count) {
        dart.throw(new core.StateError('Not enough elements'));
      }
      if (skipCount != 0 || sourceLength != count) {
        source = source.subarray(skipCount, dart.notNull(skipCount) + count);
      }
      this.set(source, start);
    }
  };
  _native_typed_data.NativeTypedArray[dart.implements] = () => [_js_helper.JavaScriptIndexingBehavior];
  dart.setSignature(_native_typed_data.NativeTypedArray, {
    methods: () => ({[_setRangeFast]: dart.definiteFunctionType(dart.void, [core.int, core.int, _native_typed_data.NativeTypedArray, core.int])})
  });
  dart.defineExtensionNames([
    'length',
    'get',
    'set',
    'setRange'
  ]);
  _native_typed_data.NativeTypedArrayOfDouble = class NativeTypedArrayOfDouble extends dart.mixin(_native_typed_data.NativeTypedArray, collection.ListMixin$(core.double), _internal.FixedLengthListMixin$(core.double)) {
    get length() {
      return this.length;
    }
    set length(value) {
      super.length = value;
    }
    get(index) {
      _native_typed_data._checkValidIndex(index, this, this[dartx.length]);
      return this[index];
    }
    set(index, value) {
      _native_typed_data._checkValidIndex(index, this, this[dartx.length]);
      this[index] = value;
      return value;
    }
    setRange(start, end, iterable, skipCount) {
      if (skipCount === void 0) skipCount = 0;
      if (_native_typed_data.NativeTypedArrayOfDouble.is(iterable)) {
        this[_setRangeFast](start, end, iterable, skipCount);
        return;
      }
      super[dartx.setRange](start, end, iterable, skipCount);
    }
  };
  dart.setSignature(_native_typed_data.NativeTypedArrayOfDouble, {
    methods: () => ({
      get: dart.definiteFunctionType(core.double, [core.int]),
      set: dart.definiteFunctionType(dart.void, [core.int, core.num]),
      setRange: dart.definiteFunctionType(dart.void, [core.int, core.int, core.Iterable$(core.double)], [core.int])
    })
  });
  dart.defineExtensionMembers(_native_typed_data.NativeTypedArrayOfDouble, ['get', 'set', 'setRange', 'length']);
  dart.defineExtensionNames([
    'length',
    'set',
    'setRange'
  ]);
  _native_typed_data.NativeTypedArrayOfInt = class NativeTypedArrayOfInt extends dart.mixin(_native_typed_data.NativeTypedArray, collection.ListMixin$(core.int), _internal.FixedLengthListMixin$(core.int)) {
    get length() {
      return this.length;
    }
    set length(value) {
      super.length = value;
    }
    set(index, value) {
      _native_typed_data._checkValidIndex(index, this, this[dartx.length]);
      this[index] = value;
      return value;
    }
    setRange(start, end, iterable, skipCount) {
      if (skipCount === void 0) skipCount = 0;
      if (_native_typed_data.NativeTypedArrayOfInt.is(iterable)) {
        this[_setRangeFast](start, end, iterable, skipCount);
        return;
      }
      super[dartx.setRange](start, end, iterable, skipCount);
    }
  };
  _native_typed_data.NativeTypedArrayOfInt[dart.implements] = () => [ListOfint()];
  dart.setSignature(_native_typed_data.NativeTypedArrayOfInt, {
    methods: () => ({
      set: dart.definiteFunctionType(dart.void, [core.int, core.int]),
      setRange: dart.definiteFunctionType(dart.void, [core.int, core.int, core.Iterable$(core.int)], [core.int])
    })
  });
  dart.defineExtensionMembers(_native_typed_data.NativeTypedArrayOfInt, ['set', 'setRange', 'length']);
  dart.defineExtensionNames([
    'runtimeType',
    'sublist'
  ]);
  _native_typed_data.NativeFloat32List = class NativeFloat32List extends _native_typed_data.NativeTypedArrayOfDouble {
    static new(length) {
      return _native_typed_data.NativeFloat32List._create1(_native_typed_data._checkLength(length));
    }
    static fromList(elements) {
      return _native_typed_data.NativeFloat32List._create1(_native_typed_data._ensureNativeList(elements));
    }
    static view(buffer, offsetInBytes, length) {
      _native_typed_data._checkViewArguments(buffer, offsetInBytes, length);
      return length == null ? _native_typed_data.NativeFloat32List._create2(buffer, offsetInBytes) : _native_typed_data.NativeFloat32List._create3(buffer, offsetInBytes, length);
    }
    get [dartx.runtimeType]() {
      return dart.wrapType(typed_data.Float32List);
    }
    [dartx.sublist](start, end) {
      if (end === void 0) end = null;
      end = _native_typed_data._checkValidRange(start, end, this[dartx.length]);
      let source = this.subarray(start, end);
      return _native_typed_data.NativeFloat32List._create1(source);
    }
    static _create1(arg) {
      return new Float32Array(arg);
    }
    static _create2(arg1, arg2) {
      return new Float32Array(arg1, arg2);
    }
    static _create3(arg1, arg2, arg3) {
      return new Float32Array(arg1, arg2, arg3);
    }
  };
  _native_typed_data.NativeFloat32List[dart.implements] = () => [typed_data.Float32List];
  dart.setSignature(_native_typed_data.NativeFloat32List, {
    constructors: () => ({
      new: dart.definiteFunctionType(_native_typed_data.NativeFloat32List, [core.int]),
      fromList: dart.definiteFunctionType(_native_typed_data.NativeFloat32List, [core.List$(core.double)]),
      view: dart.definiteFunctionType(_native_typed_data.NativeFloat32List, [typed_data.ByteBuffer, core.int, core.int])
    }),
    methods: () => ({[dartx.sublist]: dart.definiteFunctionType(core.List$(core.double), [core.int], [core.int])}),
    statics: () => ({
      _create1: dart.definiteFunctionType(_native_typed_data.NativeFloat32List, [dart.dynamic]),
      _create2: dart.definiteFunctionType(_native_typed_data.NativeFloat32List, [dart.dynamic, dart.dynamic]),
      _create3: dart.definiteFunctionType(_native_typed_data.NativeFloat32List, [dart.dynamic, dart.dynamic, dart.dynamic])
    }),
    names: ['_create1', '_create2', '_create3']
  });
  dart.registerExtension(dart.global.Float32Array, _native_typed_data.NativeFloat32List);
  dart.defineExtensionNames([
    'runtimeType',
    'sublist'
  ]);
  _native_typed_data.NativeFloat64List = class NativeFloat64List extends _native_typed_data.NativeTypedArrayOfDouble {
    static new(length) {
      return _native_typed_data.NativeFloat64List._create1(_native_typed_data._checkLength(length));
    }
    static fromList(elements) {
      return _native_typed_data.NativeFloat64List._create1(_native_typed_data._ensureNativeList(elements));
    }
    static view(buffer, offsetInBytes, length) {
      _native_typed_data._checkViewArguments(buffer, offsetInBytes, length);
      return length == null ? _native_typed_data.NativeFloat64List._create2(buffer, offsetInBytes) : _native_typed_data.NativeFloat64List._create3(buffer, offsetInBytes, length);
    }
    get [dartx.runtimeType]() {
      return dart.wrapType(typed_data.Float64List);
    }
    [dartx.sublist](start, end) {
      if (end === void 0) end = null;
      end = _native_typed_data._checkValidRange(start, end, this[dartx.length]);
      let source = this.subarray(start, end);
      return _native_typed_data.NativeFloat64List._create1(source);
    }
    static _create1(arg) {
      return new Float64Array(arg);
    }
    static _create2(arg1, arg2) {
      return new Float64Array(arg1, arg2);
    }
    static _create3(arg1, arg2, arg3) {
      return new Float64Array(arg1, arg2, arg3);
    }
  };
  _native_typed_data.NativeFloat64List[dart.implements] = () => [typed_data.Float64List];
  dart.setSignature(_native_typed_data.NativeFloat64List, {
    constructors: () => ({
      new: dart.definiteFunctionType(_native_typed_data.NativeFloat64List, [core.int]),
      fromList: dart.definiteFunctionType(_native_typed_data.NativeFloat64List, [core.List$(core.double)]),
      view: dart.definiteFunctionType(_native_typed_data.NativeFloat64List, [typed_data.ByteBuffer, core.int, core.int])
    }),
    methods: () => ({[dartx.sublist]: dart.definiteFunctionType(core.List$(core.double), [core.int], [core.int])}),
    statics: () => ({
      _create1: dart.definiteFunctionType(_native_typed_data.NativeFloat64List, [dart.dynamic]),
      _create2: dart.definiteFunctionType(_native_typed_data.NativeFloat64List, [dart.dynamic, dart.dynamic]),
      _create3: dart.definiteFunctionType(_native_typed_data.NativeFloat64List, [dart.dynamic, dart.dynamic, dart.dynamic])
    }),
    names: ['_create1', '_create2', '_create3']
  });
  dart.registerExtension(dart.global.Float64Array, _native_typed_data.NativeFloat64List);
  dart.defineExtensionNames([
    'runtimeType',
    'get',
    'sublist'
  ]);
  _native_typed_data.NativeInt16List = class NativeInt16List extends _native_typed_data.NativeTypedArrayOfInt {
    static new(length) {
      return _native_typed_data.NativeInt16List._create1(_native_typed_data._checkLength(length));
    }
    static fromList(elements) {
      return _native_typed_data.NativeInt16List._create1(_native_typed_data._ensureNativeList(elements));
    }
    static view(buffer, offsetInBytes, length) {
      _native_typed_data._checkViewArguments(buffer, offsetInBytes, length);
      return length == null ? _native_typed_data.NativeInt16List._create2(buffer, offsetInBytes) : _native_typed_data.NativeInt16List._create3(buffer, offsetInBytes, length);
    }
    get [dartx.runtimeType]() {
      return dart.wrapType(typed_data.Int16List);
    }
    [dartx.get](index) {
      _native_typed_data._checkValidIndex(index, this, this[dartx.length]);
      return this[index];
    }
    [dartx.sublist](start, end) {
      if (end === void 0) end = null;
      end = _native_typed_data._checkValidRange(start, end, this[dartx.length]);
      let source = this.subarray(start, end);
      return _native_typed_data.NativeInt16List._create1(source);
    }
    static _create1(arg) {
      return new Int16Array(arg);
    }
    static _create2(arg1, arg2) {
      return new Int16Array(arg1, arg2);
    }
    static _create3(arg1, arg2, arg3) {
      return new Int16Array(arg1, arg2, arg3);
    }
  };
  _native_typed_data.NativeInt16List[dart.implements] = () => [typed_data.Int16List];
  dart.setSignature(_native_typed_data.NativeInt16List, {
    constructors: () => ({
      new: dart.definiteFunctionType(_native_typed_data.NativeInt16List, [core.int]),
      fromList: dart.definiteFunctionType(_native_typed_data.NativeInt16List, [core.List$(core.int)]),
      view: dart.definiteFunctionType(_native_typed_data.NativeInt16List, [_native_typed_data.NativeByteBuffer, core.int, core.int])
    }),
    methods: () => ({
      [dartx.get]: dart.definiteFunctionType(core.int, [core.int]),
      [dartx.sublist]: dart.definiteFunctionType(core.List$(core.int), [core.int], [core.int])
    }),
    statics: () => ({
      _create1: dart.definiteFunctionType(_native_typed_data.NativeInt16List, [dart.dynamic]),
      _create2: dart.definiteFunctionType(_native_typed_data.NativeInt16List, [dart.dynamic, dart.dynamic]),
      _create3: dart.definiteFunctionType(_native_typed_data.NativeInt16List, [dart.dynamic, dart.dynamic, dart.dynamic])
    }),
    names: ['_create1', '_create2', '_create3']
  });
  dart.registerExtension(dart.global.Int16Array, _native_typed_data.NativeInt16List);
  dart.defineExtensionNames([
    'runtimeType',
    'get',
    'sublist'
  ]);
  _native_typed_data.NativeInt32List = class NativeInt32List extends _native_typed_data.NativeTypedArrayOfInt {
    static new(length) {
      return _native_typed_data.NativeInt32List._create1(_native_typed_data._checkLength(length));
    }
    static fromList(elements) {
      return _native_typed_data.NativeInt32List._create1(_native_typed_data._ensureNativeList(elements));
    }
    static view(buffer, offsetInBytes, length) {
      _native_typed_data._checkViewArguments(buffer, offsetInBytes, length);
      return length == null ? _native_typed_data.NativeInt32List._create2(buffer, offsetInBytes) : _native_typed_data.NativeInt32List._create3(buffer, offsetInBytes, length);
    }
    get [dartx.runtimeType]() {
      return dart.wrapType(typed_data.Int32List);
    }
    [dartx.get](index) {
      _native_typed_data._checkValidIndex(index, this, this[dartx.length]);
      return this[index];
    }
    [dartx.sublist](start, end) {
      if (end === void 0) end = null;
      end = _native_typed_data._checkValidRange(start, end, this[dartx.length]);
      let source = this.subarray(start, end);
      return _native_typed_data.NativeInt32List._create1(source);
    }
    static _create1(arg) {
      return new Int32Array(arg);
    }
    static _create2(arg1, arg2) {
      return new Int32Array(arg1, arg2);
    }
    static _create3(arg1, arg2, arg3) {
      return new Int32Array(arg1, arg2, arg3);
    }
  };
  _native_typed_data.NativeInt32List[dart.implements] = () => [typed_data.Int32List];
  dart.setSignature(_native_typed_data.NativeInt32List, {
    constructors: () => ({
      new: dart.definiteFunctionType(_native_typed_data.NativeInt32List, [core.int]),
      fromList: dart.definiteFunctionType(_native_typed_data.NativeInt32List, [core.List$(core.int)]),
      view: dart.definiteFunctionType(_native_typed_data.NativeInt32List, [typed_data.ByteBuffer, core.int, core.int])
    }),
    methods: () => ({
      [dartx.get]: dart.definiteFunctionType(core.int, [core.int]),
      [dartx.sublist]: dart.definiteFunctionType(core.List$(core.int), [core.int], [core.int])
    }),
    statics: () => ({
      _create1: dart.definiteFunctionType(_native_typed_data.NativeInt32List, [dart.dynamic]),
      _create2: dart.definiteFunctionType(_native_typed_data.NativeInt32List, [dart.dynamic, dart.dynamic]),
      _create3: dart.definiteFunctionType(_native_typed_data.NativeInt32List, [dart.dynamic, dart.dynamic, dart.dynamic])
    }),
    names: ['_create1', '_create2', '_create3']
  });
  dart.registerExtension(dart.global.Int32Array, _native_typed_data.NativeInt32List);
  dart.defineExtensionNames([
    'runtimeType',
    'get',
    'sublist'
  ]);
  _native_typed_data.NativeInt8List = class NativeInt8List extends _native_typed_data.NativeTypedArrayOfInt {
    static new(length) {
      return _native_typed_data.NativeInt8List._create1(_native_typed_data._checkLength(length));
    }
    static fromList(elements) {
      return _native_typed_data.NativeInt8List._create1(_native_typed_data._ensureNativeList(elements));
    }
    static view(buffer, offsetInBytes, length) {
      _native_typed_data._checkViewArguments(buffer, offsetInBytes, length);
      return _native_typed_data.NativeInt8List._check(length == null ? _native_typed_data.NativeInt8List._create2(buffer, offsetInBytes) : _native_typed_data.NativeInt8List._create3(buffer, offsetInBytes, length));
    }
    get [dartx.runtimeType]() {
      return dart.wrapType(typed_data.Int8List);
    }
    [dartx.get](index) {
      _native_typed_data._checkValidIndex(index, this, this[dartx.length]);
      return this[index];
    }
    [dartx.sublist](start, end) {
      if (end === void 0) end = null;
      end = _native_typed_data._checkValidRange(start, end, this[dartx.length]);
      let source = this.subarray(start, end);
      return _native_typed_data.NativeInt8List._create1(source);
    }
    static _create1(arg) {
      return new Int8Array(arg);
    }
    static _create2(arg1, arg2) {
      return new Int8Array(arg1, arg2);
    }
    static _create3(arg1, arg2, arg3) {
      return new Int8Array(arg1, arg2, arg3);
    }
  };
  _native_typed_data.NativeInt8List[dart.implements] = () => [typed_data.Int8List];
  dart.setSignature(_native_typed_data.NativeInt8List, {
    constructors: () => ({
      new: dart.definiteFunctionType(_native_typed_data.NativeInt8List, [core.int]),
      fromList: dart.definiteFunctionType(_native_typed_data.NativeInt8List, [core.List$(core.int)]),
      view: dart.definiteFunctionType(_native_typed_data.NativeInt8List, [typed_data.ByteBuffer, core.int, core.int])
    }),
    methods: () => ({
      [dartx.get]: dart.definiteFunctionType(core.int, [core.int]),
      [dartx.sublist]: dart.definiteFunctionType(core.List$(core.int), [core.int], [core.int])
    }),
    statics: () => ({
      _create1: dart.definiteFunctionType(_native_typed_data.NativeInt8List, [dart.dynamic]),
      _create2: dart.definiteFunctionType(_native_typed_data.NativeInt8List, [dart.dynamic, dart.dynamic]),
      _create3: dart.definiteFunctionType(typed_data.Int8List, [dart.dynamic, dart.dynamic, dart.dynamic])
    }),
    names: ['_create1', '_create2', '_create3']
  });
  dart.registerExtension(dart.global.Int8Array, _native_typed_data.NativeInt8List);
  dart.defineExtensionNames([
    'runtimeType',
    'get',
    'sublist'
  ]);
  _native_typed_data.NativeUint16List = class NativeUint16List extends _native_typed_data.NativeTypedArrayOfInt {
    static new(length) {
      return _native_typed_data.NativeUint16List._create1(_native_typed_data._checkLength(length));
    }
    static fromList(list) {
      return _native_typed_data.NativeUint16List._create1(_native_typed_data._ensureNativeList(list));
    }
    static view(buffer, offsetInBytes, length) {
      _native_typed_data._checkViewArguments(buffer, offsetInBytes, length);
      return length == null ? _native_typed_data.NativeUint16List._create2(buffer, offsetInBytes) : _native_typed_data.NativeUint16List._create3(buffer, offsetInBytes, length);
    }
    get [dartx.runtimeType]() {
      return dart.wrapType(typed_data.Uint16List);
    }
    [dartx.get](index) {
      _native_typed_data._checkValidIndex(index, this, this[dartx.length]);
      return this[index];
    }
    [dartx.sublist](start, end) {
      if (end === void 0) end = null;
      end = _native_typed_data._checkValidRange(start, end, this[dartx.length]);
      let source = this.subarray(start, end);
      return _native_typed_data.NativeUint16List._create1(source);
    }
    static _create1(arg) {
      return new Uint16Array(arg);
    }
    static _create2(arg1, arg2) {
      return new Uint16Array(arg1, arg2);
    }
    static _create3(arg1, arg2, arg3) {
      return new Uint16Array(arg1, arg2, arg3);
    }
  };
  _native_typed_data.NativeUint16List[dart.implements] = () => [typed_data.Uint16List];
  dart.setSignature(_native_typed_data.NativeUint16List, {
    constructors: () => ({
      new: dart.definiteFunctionType(_native_typed_data.NativeUint16List, [core.int]),
      fromList: dart.definiteFunctionType(_native_typed_data.NativeUint16List, [core.List$(core.int)]),
      view: dart.definiteFunctionType(_native_typed_data.NativeUint16List, [typed_data.ByteBuffer, core.int, core.int])
    }),
    methods: () => ({
      [dartx.get]: dart.definiteFunctionType(core.int, [core.int]),
      [dartx.sublist]: dart.definiteFunctionType(core.List$(core.int), [core.int], [core.int])
    }),
    statics: () => ({
      _create1: dart.definiteFunctionType(_native_typed_data.NativeUint16List, [dart.dynamic]),
      _create2: dart.definiteFunctionType(_native_typed_data.NativeUint16List, [dart.dynamic, dart.dynamic]),
      _create3: dart.definiteFunctionType(_native_typed_data.NativeUint16List, [dart.dynamic, dart.dynamic, dart.dynamic])
    }),
    names: ['_create1', '_create2', '_create3']
  });
  dart.registerExtension(dart.global.Uint16Array, _native_typed_data.NativeUint16List);
  dart.defineExtensionNames([
    'runtimeType',
    'get',
    'sublist'
  ]);
  _native_typed_data.NativeUint32List = class NativeUint32List extends _native_typed_data.NativeTypedArrayOfInt {
    static new(length) {
      return _native_typed_data.NativeUint32List._create1(_native_typed_data._checkLength(length));
    }
    static fromList(elements) {
      return _native_typed_data.NativeUint32List._create1(_native_typed_data._ensureNativeList(elements));
    }
    static view(buffer, offsetInBytes, length) {
      _native_typed_data._checkViewArguments(buffer, offsetInBytes, length);
      return length == null ? _native_typed_data.NativeUint32List._create2(buffer, offsetInBytes) : _native_typed_data.NativeUint32List._create3(buffer, offsetInBytes, length);
    }
    get [dartx.runtimeType]() {
      return dart.wrapType(typed_data.Uint32List);
    }
    [dartx.get](index) {
      _native_typed_data._checkValidIndex(index, this, this[dartx.length]);
      return this[index];
    }
    [dartx.sublist](start, end) {
      if (end === void 0) end = null;
      end = _native_typed_data._checkValidRange(start, end, this[dartx.length]);
      let source = this.subarray(start, end);
      return _native_typed_data.NativeUint32List._create1(source);
    }
    static _create1(arg) {
      return new Uint32Array(arg);
    }
    static _create2(arg1, arg2) {
      return new Uint32Array(arg1, arg2);
    }
    static _create3(arg1, arg2, arg3) {
      return new Uint32Array(arg1, arg2, arg3);
    }
  };
  _native_typed_data.NativeUint32List[dart.implements] = () => [typed_data.Uint32List];
  dart.setSignature(_native_typed_data.NativeUint32List, {
    constructors: () => ({
      new: dart.definiteFunctionType(_native_typed_data.NativeUint32List, [core.int]),
      fromList: dart.definiteFunctionType(_native_typed_data.NativeUint32List, [core.List$(core.int)]),
      view: dart.definiteFunctionType(_native_typed_data.NativeUint32List, [typed_data.ByteBuffer, core.int, core.int])
    }),
    methods: () => ({
      [dartx.get]: dart.definiteFunctionType(core.int, [core.int]),
      [dartx.sublist]: dart.definiteFunctionType(core.List$(core.int), [core.int], [core.int])
    }),
    statics: () => ({
      _create1: dart.definiteFunctionType(_native_typed_data.NativeUint32List, [dart.dynamic]),
      _create2: dart.definiteFunctionType(_native_typed_data.NativeUint32List, [dart.dynamic, dart.dynamic]),
      _create3: dart.definiteFunctionType(_native_typed_data.NativeUint32List, [dart.dynamic, dart.dynamic, dart.dynamic])
    }),
    names: ['_create1', '_create2', '_create3']
  });
  dart.registerExtension(dart.global.Uint32Array, _native_typed_data.NativeUint32List);
  dart.defineExtensionNames([
    'runtimeType',
    'length',
    'get',
    'sublist'
  ]);
  _native_typed_data.NativeUint8ClampedList = class NativeUint8ClampedList extends _native_typed_data.NativeTypedArrayOfInt {
    static new(length) {
      return _native_typed_data.NativeUint8ClampedList._create1(_native_typed_data._checkLength(length));
    }
    static fromList(elements) {
      return _native_typed_data.NativeUint8ClampedList._create1(_native_typed_data._ensureNativeList(elements));
    }
    static view(buffer, offsetInBytes, length) {
      _native_typed_data._checkViewArguments(buffer, offsetInBytes, length);
      return length == null ? _native_typed_data.NativeUint8ClampedList._create2(buffer, offsetInBytes) : _native_typed_data.NativeUint8ClampedList._create3(buffer, offsetInBytes, length);
    }
    get [dartx.runtimeType]() {
      return dart.wrapType(typed_data.Uint8ClampedList);
    }
    get [dartx.length]() {
      return this.length;
    }
    set [dartx.length](value) {
      super[dartx.length] = value;
    }
    [dartx.get](index) {
      _native_typed_data._checkValidIndex(index, this, this[dartx.length]);
      return this[index];
    }
    [dartx.sublist](start, end) {
      if (end === void 0) end = null;
      end = _native_typed_data._checkValidRange(start, end, this[dartx.length]);
      let source = this.subarray(start, end);
      return _native_typed_data.NativeUint8ClampedList._create1(source);
    }
    static _create1(arg) {
      return new Uint8ClampedArray(arg);
    }
    static _create2(arg1, arg2) {
      return new Uint8ClampedArray(arg1, arg2);
    }
    static _create3(arg1, arg2, arg3) {
      return new Uint8ClampedArray(arg1, arg2, arg3);
    }
  };
  _native_typed_data.NativeUint8ClampedList[dart.implements] = () => [typed_data.Uint8ClampedList];
  dart.setSignature(_native_typed_data.NativeUint8ClampedList, {
    constructors: () => ({
      new: dart.definiteFunctionType(_native_typed_data.NativeUint8ClampedList, [core.int]),
      fromList: dart.definiteFunctionType(_native_typed_data.NativeUint8ClampedList, [core.List$(core.int)]),
      view: dart.definiteFunctionType(_native_typed_data.NativeUint8ClampedList, [typed_data.ByteBuffer, core.int, core.int])
    }),
    methods: () => ({
      [dartx.get]: dart.definiteFunctionType(core.int, [core.int]),
      [dartx.sublist]: dart.definiteFunctionType(core.List$(core.int), [core.int], [core.int])
    }),
    statics: () => ({
      _create1: dart.definiteFunctionType(_native_typed_data.NativeUint8ClampedList, [dart.dynamic]),
      _create2: dart.definiteFunctionType(_native_typed_data.NativeUint8ClampedList, [dart.dynamic, dart.dynamic]),
      _create3: dart.definiteFunctionType(_native_typed_data.NativeUint8ClampedList, [dart.dynamic, dart.dynamic, dart.dynamic])
    }),
    names: ['_create1', '_create2', '_create3']
  });
  dart.registerExtension(dart.global.Uint8ClampedArray, _native_typed_data.NativeUint8ClampedList);
  dart.defineExtensionNames([
    'runtimeType',
    'length',
    'get',
    'sublist'
  ]);
  _native_typed_data.NativeUint8List = class NativeUint8List extends _native_typed_data.NativeTypedArrayOfInt {
    static new(length) {
      return _native_typed_data.NativeUint8List._create1(_native_typed_data._checkLength(length));
    }
    static fromList(elements) {
      return _native_typed_data.NativeUint8List._create1(_native_typed_data._ensureNativeList(elements));
    }
    static view(buffer, offsetInBytes, length) {
      _native_typed_data._checkViewArguments(buffer, offsetInBytes, length);
      return length == null ? _native_typed_data.NativeUint8List._create2(buffer, offsetInBytes) : _native_typed_data.NativeUint8List._create3(buffer, offsetInBytes, length);
    }
    get [dartx.runtimeType]() {
      return dart.wrapType(typed_data.Uint8List);
    }
    get [dartx.length]() {
      return this.length;
    }
    set [dartx.length](value) {
      super[dartx.length] = value;
    }
    [dartx.get](index) {
      _native_typed_data._checkValidIndex(index, this, this[dartx.length]);
      return this[index];
    }
    [dartx.sublist](start, end) {
      if (end === void 0) end = null;
      end = _native_typed_data._checkValidRange(start, end, this[dartx.length]);
      let source = this.subarray(start, end);
      return _native_typed_data.NativeUint8List._create1(source);
    }
    static _create1(arg) {
      return new Uint8Array(arg);
    }
    static _create2(arg1, arg2) {
      return new Uint8Array(arg1, arg2);
    }
    static _create3(arg1, arg2, arg3) {
      return new Uint8Array(arg1, arg2, arg3);
    }
  };
  _native_typed_data.NativeUint8List[dart.implements] = () => [typed_data.Uint8List];
  dart.setSignature(_native_typed_data.NativeUint8List, {
    constructors: () => ({
      new: dart.definiteFunctionType(_native_typed_data.NativeUint8List, [core.int]),
      fromList: dart.definiteFunctionType(_native_typed_data.NativeUint8List, [core.List$(core.int)]),
      view: dart.definiteFunctionType(_native_typed_data.NativeUint8List, [typed_data.ByteBuffer, core.int, core.int])
    }),
    methods: () => ({
      [dartx.get]: dart.definiteFunctionType(core.int, [core.int]),
      [dartx.sublist]: dart.definiteFunctionType(core.List$(core.int), [core.int], [core.int])
    }),
    statics: () => ({
      _create1: dart.definiteFunctionType(_native_typed_data.NativeUint8List, [dart.dynamic]),
      _create2: dart.definiteFunctionType(_native_typed_data.NativeUint8List, [dart.dynamic, dart.dynamic]),
      _create3: dart.definiteFunctionType(_native_typed_data.NativeUint8List, [dart.dynamic, dart.dynamic, dart.dynamic])
    }),
    names: ['_create1', '_create2', '_create3']
  });
  dart.registerExtension(dart.global.Uint8Array, _native_typed_data.NativeUint8List);
  _native_typed_data.NativeFloat32x4 = class NativeFloat32x4 extends core.Object {
    static _truncate(x) {
      _native_typed_data.NativeFloat32x4._list[dartx.set](0, core.num._check(x));
      return _native_typed_data.NativeFloat32x4._list[dartx.get](0);
    }
    new(x, y, z, w) {
      this.x = core.double._check(_native_typed_data.NativeFloat32x4._truncate(x));
      this.y = core.double._check(_native_typed_data.NativeFloat32x4._truncate(y));
      this.z = core.double._check(_native_typed_data.NativeFloat32x4._truncate(z));
      this.w = core.double._check(_native_typed_data.NativeFloat32x4._truncate(w));
      if (!(typeof x == 'number')) dart.throw(new core.ArgumentError(x));
      if (!(typeof y == 'number')) dart.throw(new core.ArgumentError(y));
      if (!(typeof z == 'number')) dart.throw(new core.ArgumentError(z));
      if (!(typeof w == 'number')) dart.throw(new core.ArgumentError(w));
    }
    splat(v) {
      NativeFloat32x4.prototype.new.call(this, v, v, v, v);
    }
    zero() {
      NativeFloat32x4.prototype._truncated.call(this, 0.0, 0.0, 0.0, 0.0);
    }
    static fromInt32x4Bits(i) {
      _native_typed_data.NativeFloat32x4._uint32view[dartx.set](0, i.x);
      _native_typed_data.NativeFloat32x4._uint32view[dartx.set](1, i.y);
      _native_typed_data.NativeFloat32x4._uint32view[dartx.set](2, i.z);
      _native_typed_data.NativeFloat32x4._uint32view[dartx.set](3, i.w);
      return new _native_typed_data.NativeFloat32x4._truncated(_native_typed_data.NativeFloat32x4._list[dartx.get](0), _native_typed_data.NativeFloat32x4._list[dartx.get](1), _native_typed_data.NativeFloat32x4._list[dartx.get](2), _native_typed_data.NativeFloat32x4._list[dartx.get](3));
    }
    fromFloat64x2(v) {
      NativeFloat32x4.prototype._truncated.call(this, core.double._check(_native_typed_data.NativeFloat32x4._truncate(v.x)), core.double._check(_native_typed_data.NativeFloat32x4._truncate(v.y)), 0.0, 0.0);
    }
    _doubles(x, y, z, w) {
      this.x = core.double._check(_native_typed_data.NativeFloat32x4._truncate(x));
      this.y = core.double._check(_native_typed_data.NativeFloat32x4._truncate(y));
      this.z = core.double._check(_native_typed_data.NativeFloat32x4._truncate(z));
      this.w = core.double._check(_native_typed_data.NativeFloat32x4._truncate(w));
    }
    _truncated(x, y, z, w) {
      this.x = x;
      this.y = y;
      this.z = z;
      this.w = w;
    }
    toString() {
      return dart.str`[${this.x}, ${this.y}, ${this.z}, ${this.w}]`;
    }
    ['+'](other) {
      let _x = dart.notNull(this.x) + dart.notNull(other.x);
      let _y = dart.notNull(this.y) + dart.notNull(other.y);
      let _z = dart.notNull(this.z) + dart.notNull(other.z);
      let _w = dart.notNull(this.w) + dart.notNull(other.w);
      return new _native_typed_data.NativeFloat32x4._doubles(_x, _y, _z, _w);
    }
    ['unary-']() {
      return new _native_typed_data.NativeFloat32x4._truncated(-dart.notNull(this.x), -dart.notNull(this.y), -dart.notNull(this.z), -dart.notNull(this.w));
    }
    ['-'](other) {
      let _x = dart.notNull(this.x) - dart.notNull(other.x);
      let _y = dart.notNull(this.y) - dart.notNull(other.y);
      let _z = dart.notNull(this.z) - dart.notNull(other.z);
      let _w = dart.notNull(this.w) - dart.notNull(other.w);
      return new _native_typed_data.NativeFloat32x4._doubles(_x, _y, _z, _w);
    }
    ['*'](other) {
      let _x = dart.notNull(this.x) * dart.notNull(other.x);
      let _y = dart.notNull(this.y) * dart.notNull(other.y);
      let _z = dart.notNull(this.z) * dart.notNull(other.z);
      let _w = dart.notNull(this.w) * dart.notNull(other.w);
      return new _native_typed_data.NativeFloat32x4._doubles(_x, _y, _z, _w);
    }
    ['/'](other) {
      let _x = dart.notNull(this.x) / dart.notNull(other.x);
      let _y = dart.notNull(this.y) / dart.notNull(other.y);
      let _z = dart.notNull(this.z) / dart.notNull(other.z);
      let _w = dart.notNull(this.w) / dart.notNull(other.w);
      return new _native_typed_data.NativeFloat32x4._doubles(_x, _y, _z, _w);
    }
    lessThan(other) {
      let _cx = dart.notNull(this.x) < dart.notNull(other.x);
      let _cy = dart.notNull(this.y) < dart.notNull(other.y);
      let _cz = dart.notNull(this.z) < dart.notNull(other.z);
      let _cw = dart.notNull(this.w) < dart.notNull(other.w);
      return new _native_typed_data.NativeInt32x4._truncated(_cx ? -1 : 0, _cy ? -1 : 0, _cz ? -1 : 0, _cw ? -1 : 0);
    }
    lessThanOrEqual(other) {
      let _cx = dart.notNull(this.x) <= dart.notNull(other.x);
      let _cy = dart.notNull(this.y) <= dart.notNull(other.y);
      let _cz = dart.notNull(this.z) <= dart.notNull(other.z);
      let _cw = dart.notNull(this.w) <= dart.notNull(other.w);
      return new _native_typed_data.NativeInt32x4._truncated(_cx ? -1 : 0, _cy ? -1 : 0, _cz ? -1 : 0, _cw ? -1 : 0);
    }
    greaterThan(other) {
      let _cx = dart.notNull(this.x) > dart.notNull(other.x);
      let _cy = dart.notNull(this.y) > dart.notNull(other.y);
      let _cz = dart.notNull(this.z) > dart.notNull(other.z);
      let _cw = dart.notNull(this.w) > dart.notNull(other.w);
      return new _native_typed_data.NativeInt32x4._truncated(_cx ? -1 : 0, _cy ? -1 : 0, _cz ? -1 : 0, _cw ? -1 : 0);
    }
    greaterThanOrEqual(other) {
      let _cx = dart.notNull(this.x) >= dart.notNull(other.x);
      let _cy = dart.notNull(this.y) >= dart.notNull(other.y);
      let _cz = dart.notNull(this.z) >= dart.notNull(other.z);
      let _cw = dart.notNull(this.w) >= dart.notNull(other.w);
      return new _native_typed_data.NativeInt32x4._truncated(_cx ? -1 : 0, _cy ? -1 : 0, _cz ? -1 : 0, _cw ? -1 : 0);
    }
    equal(other) {
      let _cx = this.x == other.x;
      let _cy = this.y == other.y;
      let _cz = this.z == other.z;
      let _cw = this.w == other.w;
      return new _native_typed_data.NativeInt32x4._truncated(_cx ? -1 : 0, _cy ? -1 : 0, _cz ? -1 : 0, _cw ? -1 : 0);
    }
    notEqual(other) {
      let _cx = this.x != other.x;
      let _cy = this.y != other.y;
      let _cz = this.z != other.z;
      let _cw = this.w != other.w;
      return new _native_typed_data.NativeInt32x4._truncated(_cx ? -1 : 0, _cy ? -1 : 0, _cz ? -1 : 0, _cw ? -1 : 0);
    }
    scale(s) {
      let _x = dart.notNull(s) * dart.notNull(this.x);
      let _y = dart.notNull(s) * dart.notNull(this.y);
      let _z = dart.notNull(s) * dart.notNull(this.z);
      let _w = dart.notNull(s) * dart.notNull(this.w);
      return new _native_typed_data.NativeFloat32x4._doubles(_x, _y, _z, _w);
    }
    abs() {
      let _x = this.x[dartx.abs]();
      let _y = this.y[dartx.abs]();
      let _z = this.z[dartx.abs]();
      let _w = this.w[dartx.abs]();
      return new _native_typed_data.NativeFloat32x4._truncated(_x, _y, _z, _w);
    }
    clamp(lowerLimit, upperLimit) {
      let _lx = lowerLimit.x;
      let _ly = lowerLimit.y;
      let _lz = lowerLimit.z;
      let _lw = lowerLimit.w;
      let _ux = upperLimit.x;
      let _uy = upperLimit.y;
      let _uz = upperLimit.z;
      let _uw = upperLimit.w;
      let _x = this.x;
      let _y = this.y;
      let _z = this.z;
      let _w = this.w;
      _x = dart.notNull(_x) > dart.notNull(_ux) ? _ux : _x;
      _y = dart.notNull(_y) > dart.notNull(_uy) ? _uy : _y;
      _z = dart.notNull(_z) > dart.notNull(_uz) ? _uz : _z;
      _w = dart.notNull(_w) > dart.notNull(_uw) ? _uw : _w;
      _x = dart.notNull(_x) < dart.notNull(_lx) ? _lx : _x;
      _y = dart.notNull(_y) < dart.notNull(_ly) ? _ly : _y;
      _z = dart.notNull(_z) < dart.notNull(_lz) ? _lz : _z;
      _w = dart.notNull(_w) < dart.notNull(_lw) ? _lw : _w;
      return new _native_typed_data.NativeFloat32x4._truncated(_x, _y, _z, _w);
    }
    get signMask() {
      let view = _native_typed_data.NativeFloat32x4._uint32view;
      let mx = null, my = null, mz = null, mw = null;
      _native_typed_data.NativeFloat32x4._list[dartx.set](0, this.x);
      _native_typed_data.NativeFloat32x4._list[dartx.set](1, this.y);
      _native_typed_data.NativeFloat32x4._list[dartx.set](2, this.z);
      _native_typed_data.NativeFloat32x4._list[dartx.set](3, this.w);
      mx = (dart.notNull(view[dartx.get](0)) & 2147483648) >>> 31;
      my = (dart.notNull(view[dartx.get](1)) & 2147483648) >>> 30;
      mz = (dart.notNull(view[dartx.get](2)) & 2147483648) >>> 29;
      mw = (dart.notNull(view[dartx.get](3)) & 2147483648) >>> 28;
      return core.int._check(dart.dsend(dart.dsend(dart.dsend(mx, '|', my), '|', mz), '|', mw));
    }
    shuffle(mask) {
      if (dart.notNull(mask) < 0 || dart.notNull(mask) > 255) {
        dart.throw(new core.RangeError.range(mask, 0, 255, "mask"));
      }
      _native_typed_data.NativeFloat32x4._list[dartx.set](0, this.x);
      _native_typed_data.NativeFloat32x4._list[dartx.set](1, this.y);
      _native_typed_data.NativeFloat32x4._list[dartx.set](2, this.z);
      _native_typed_data.NativeFloat32x4._list[dartx.set](3, this.w);
      let _x = _native_typed_data.NativeFloat32x4._list[dartx.get](dart.notNull(mask) & 3);
      let _y = _native_typed_data.NativeFloat32x4._list[dartx.get](dart.notNull(mask) >> 2 & 3);
      let _z = _native_typed_data.NativeFloat32x4._list[dartx.get](dart.notNull(mask) >> 4 & 3);
      let _w = _native_typed_data.NativeFloat32x4._list[dartx.get](dart.notNull(mask) >> 6 & 3);
      return new _native_typed_data.NativeFloat32x4._truncated(_x, _y, _z, _w);
    }
    shuffleMix(other, mask) {
      if (dart.notNull(mask) < 0 || dart.notNull(mask) > 255) {
        dart.throw(new core.RangeError.range(mask, 0, 255, "mask"));
      }
      _native_typed_data.NativeFloat32x4._list[dartx.set](0, this.x);
      _native_typed_data.NativeFloat32x4._list[dartx.set](1, this.y);
      _native_typed_data.NativeFloat32x4._list[dartx.set](2, this.z);
      _native_typed_data.NativeFloat32x4._list[dartx.set](3, this.w);
      let _x = _native_typed_data.NativeFloat32x4._list[dartx.get](dart.notNull(mask) & 3);
      let _y = _native_typed_data.NativeFloat32x4._list[dartx.get](dart.notNull(mask) >> 2 & 3);
      _native_typed_data.NativeFloat32x4._list[dartx.set](0, other.x);
      _native_typed_data.NativeFloat32x4._list[dartx.set](1, other.y);
      _native_typed_data.NativeFloat32x4._list[dartx.set](2, other.z);
      _native_typed_data.NativeFloat32x4._list[dartx.set](3, other.w);
      let _z = _native_typed_data.NativeFloat32x4._list[dartx.get](dart.notNull(mask) >> 4 & 3);
      let _w = _native_typed_data.NativeFloat32x4._list[dartx.get](dart.notNull(mask) >> 6 & 3);
      return new _native_typed_data.NativeFloat32x4._truncated(_x, _y, _z, _w);
    }
    withX(newX) {
      return new _native_typed_data.NativeFloat32x4._truncated(core.double._check(_native_typed_data.NativeFloat32x4._truncate(newX)), this.y, this.z, this.w);
    }
    withY(newY) {
      return new _native_typed_data.NativeFloat32x4._truncated(this.x, core.double._check(_native_typed_data.NativeFloat32x4._truncate(newY)), this.z, this.w);
    }
    withZ(newZ) {
      return new _native_typed_data.NativeFloat32x4._truncated(this.x, this.y, core.double._check(_native_typed_data.NativeFloat32x4._truncate(newZ)), this.w);
    }
    withW(newW) {
      return new _native_typed_data.NativeFloat32x4._truncated(this.x, this.y, this.z, core.double._check(_native_typed_data.NativeFloat32x4._truncate(newW)));
    }
    min(other) {
      let _x = dart.notNull(this.x) < dart.notNull(other.x) ? this.x : other.x;
      let _y = dart.notNull(this.y) < dart.notNull(other.y) ? this.y : other.y;
      let _z = dart.notNull(this.z) < dart.notNull(other.z) ? this.z : other.z;
      let _w = dart.notNull(this.w) < dart.notNull(other.w) ? this.w : other.w;
      return new _native_typed_data.NativeFloat32x4._truncated(_x, _y, _z, _w);
    }
    max(other) {
      let _x = dart.notNull(this.x) > dart.notNull(other.x) ? this.x : other.x;
      let _y = dart.notNull(this.y) > dart.notNull(other.y) ? this.y : other.y;
      let _z = dart.notNull(this.z) > dart.notNull(other.z) ? this.z : other.z;
      let _w = dart.notNull(this.w) > dart.notNull(other.w) ? this.w : other.w;
      return new _native_typed_data.NativeFloat32x4._truncated(_x, _y, _z, _w);
    }
    sqrt() {
      let _x = math.sqrt(this.x);
      let _y = math.sqrt(this.y);
      let _z = math.sqrt(this.z);
      let _w = math.sqrt(this.w);
      return new _native_typed_data.NativeFloat32x4._doubles(_x, _y, _z, _w);
    }
    reciprocal() {
      let _x = 1.0 / dart.notNull(this.x);
      let _y = 1.0 / dart.notNull(this.y);
      let _z = 1.0 / dart.notNull(this.z);
      let _w = 1.0 / dart.notNull(this.w);
      return new _native_typed_data.NativeFloat32x4._doubles(_x, _y, _z, _w);
    }
    reciprocalSqrt() {
      let _x = math.sqrt(1.0 / dart.notNull(this.x));
      let _y = math.sqrt(1.0 / dart.notNull(this.y));
      let _z = math.sqrt(1.0 / dart.notNull(this.z));
      let _w = math.sqrt(1.0 / dart.notNull(this.w));
      return new _native_typed_data.NativeFloat32x4._doubles(_x, _y, _z, _w);
    }
  };
  dart.defineNamedConstructor(_native_typed_data.NativeFloat32x4, 'splat');
  dart.defineNamedConstructor(_native_typed_data.NativeFloat32x4, 'zero');
  dart.defineNamedConstructor(_native_typed_data.NativeFloat32x4, 'fromFloat64x2');
  dart.defineNamedConstructor(_native_typed_data.NativeFloat32x4, '_doubles');
  dart.defineNamedConstructor(_native_typed_data.NativeFloat32x4, '_truncated');
  _native_typed_data.NativeFloat32x4[dart.implements] = () => [typed_data.Float32x4];
  dart.setSignature(_native_typed_data.NativeFloat32x4, {
    constructors: () => ({
      new: dart.definiteFunctionType(_native_typed_data.NativeFloat32x4, [core.double, core.double, core.double, core.double]),
      splat: dart.definiteFunctionType(_native_typed_data.NativeFloat32x4, [core.double]),
      zero: dart.definiteFunctionType(_native_typed_data.NativeFloat32x4, []),
      fromInt32x4Bits: dart.definiteFunctionType(_native_typed_data.NativeFloat32x4, [typed_data.Int32x4]),
      fromFloat64x2: dart.definiteFunctionType(_native_typed_data.NativeFloat32x4, [typed_data.Float64x2]),
      _doubles: dart.definiteFunctionType(_native_typed_data.NativeFloat32x4, [core.double, core.double, core.double, core.double]),
      _truncated: dart.definiteFunctionType(_native_typed_data.NativeFloat32x4, [core.double, core.double, core.double, core.double])
    }),
    methods: () => ({
      '+': dart.definiteFunctionType(typed_data.Float32x4, [typed_data.Float32x4]),
      'unary-': dart.definiteFunctionType(typed_data.Float32x4, []),
      '-': dart.definiteFunctionType(typed_data.Float32x4, [typed_data.Float32x4]),
      '*': dart.definiteFunctionType(typed_data.Float32x4, [typed_data.Float32x4]),
      '/': dart.definiteFunctionType(typed_data.Float32x4, [typed_data.Float32x4]),
      lessThan: dart.definiteFunctionType(typed_data.Int32x4, [typed_data.Float32x4]),
      lessThanOrEqual: dart.definiteFunctionType(typed_data.Int32x4, [typed_data.Float32x4]),
      greaterThan: dart.definiteFunctionType(typed_data.Int32x4, [typed_data.Float32x4]),
      greaterThanOrEqual: dart.definiteFunctionType(typed_data.Int32x4, [typed_data.Float32x4]),
      equal: dart.definiteFunctionType(typed_data.Int32x4, [typed_data.Float32x4]),
      notEqual: dart.definiteFunctionType(typed_data.Int32x4, [typed_data.Float32x4]),
      scale: dart.definiteFunctionType(typed_data.Float32x4, [core.double]),
      abs: dart.definiteFunctionType(typed_data.Float32x4, []),
      clamp: dart.definiteFunctionType(typed_data.Float32x4, [typed_data.Float32x4, typed_data.Float32x4]),
      shuffle: dart.definiteFunctionType(typed_data.Float32x4, [core.int]),
      shuffleMix: dart.definiteFunctionType(typed_data.Float32x4, [typed_data.Float32x4, core.int]),
      withX: dart.definiteFunctionType(typed_data.Float32x4, [core.double]),
      withY: dart.definiteFunctionType(typed_data.Float32x4, [core.double]),
      withZ: dart.definiteFunctionType(typed_data.Float32x4, [core.double]),
      withW: dart.definiteFunctionType(typed_data.Float32x4, [core.double]),
      min: dart.definiteFunctionType(typed_data.Float32x4, [typed_data.Float32x4]),
      max: dart.definiteFunctionType(typed_data.Float32x4, [typed_data.Float32x4]),
      sqrt: dart.definiteFunctionType(typed_data.Float32x4, []),
      reciprocal: dart.definiteFunctionType(typed_data.Float32x4, []),
      reciprocalSqrt: dart.definiteFunctionType(typed_data.Float32x4, [])
    }),
    statics: () => ({_truncate: dart.definiteFunctionType(dart.dynamic, [dart.dynamic])}),
    names: ['_truncate']
  });
  dart.defineLazy(_native_typed_data.NativeFloat32x4, {
    get _list() {
      return _native_typed_data.NativeFloat32List.new(4);
    },
    get _uint32view() {
      return _native_typed_data.NativeFloat32x4._list[dartx.buffer][dartx.asUint32List]();
    }
  });
  _native_typed_data.NativeInt32x4 = class NativeInt32x4 extends core.Object {
    static _truncate(x) {
      _native_typed_data.NativeInt32x4._list[dartx.set](0, core.int._check(x));
      return _native_typed_data.NativeInt32x4._list[dartx.get](0);
    }
    new(x, y, z, w) {
      this.x = core.int._check(_native_typed_data.NativeInt32x4._truncate(x));
      this.y = core.int._check(_native_typed_data.NativeInt32x4._truncate(y));
      this.z = core.int._check(_native_typed_data.NativeInt32x4._truncate(z));
      this.w = core.int._check(_native_typed_data.NativeInt32x4._truncate(w));
      if (x != this.x && !(typeof x == 'number')) dart.throw(new core.ArgumentError(x));
      if (y != this.y && !(typeof y == 'number')) dart.throw(new core.ArgumentError(y));
      if (z != this.z && !(typeof z == 'number')) dart.throw(new core.ArgumentError(z));
      if (w != this.w && !(typeof w == 'number')) dart.throw(new core.ArgumentError(w));
    }
    bool(x, y, z, w) {
      this.x = dart.test(x) ? -1 : 0;
      this.y = dart.test(y) ? -1 : 0;
      this.z = dart.test(z) ? -1 : 0;
      this.w = dart.test(w) ? -1 : 0;
    }
    static fromFloat32x4Bits(f) {
      let floatList = _native_typed_data.NativeFloat32x4._list;
      floatList[dartx.set](0, f.x);
      floatList[dartx.set](1, f.y);
      floatList[dartx.set](2, f.z);
      floatList[dartx.set](3, f.w);
      let view = _native_typed_data.NativeInt32List._check(floatList[dartx.buffer][dartx.asInt32List]());
      return new _native_typed_data.NativeInt32x4._truncated(view[dartx.get](0), view[dartx.get](1), view[dartx.get](2), view[dartx.get](3));
    }
    _truncated(x, y, z, w) {
      this.x = x;
      this.y = y;
      this.z = z;
      this.w = w;
    }
    toString() {
      return dart.str`[${this.x}, ${this.y}, ${this.z}, ${this.w}]`;
    }
    ['|'](other) {
      return new _native_typed_data.NativeInt32x4._truncated(this.x | other.x, this.y | other.y, this.z | other.z, this.w | other.w);
    }
    ['&'](other) {
      return new _native_typed_data.NativeInt32x4._truncated(this.x & other.x, this.y & other.y, this.z & other.z, this.w & other.w);
    }
    ['^'](other) {
      return new _native_typed_data.NativeInt32x4._truncated(this.x ^ other.x, this.y ^ other.y, this.z ^ other.z, this.w ^ other.w);
    }
    ['+'](other) {
      return new _native_typed_data.NativeInt32x4._truncated(this.x + other.x | 0, this.y + other.y | 0, this.z + other.z | 0, this.w + other.w | 0);
    }
    ['-'](other) {
      return new _native_typed_data.NativeInt32x4._truncated(this.x - other.x | 0, this.y - other.y | 0, this.z - other.z | 0, this.w - other.w | 0);
    }
    ['unary-']() {
      return new _native_typed_data.NativeInt32x4._truncated(-this.x | 0, -this.y | 0, -this.z | 0, -this.w | 0);
    }
    get signMask() {
      let mx = (dart.notNull(this.x) & 2147483648) >>> 31;
      let my = (dart.notNull(this.y) & 2147483648) >>> 31;
      let mz = (dart.notNull(this.z) & 2147483648) >>> 31;
      let mw = (dart.notNull(this.w) & 2147483648) >>> 31;
      return (mx | my << 1 | mz << 2 | mw << 3) >>> 0;
    }
    shuffle(mask) {
      if (dart.notNull(mask) < 0 || dart.notNull(mask) > 255) {
        dart.throw(new core.RangeError.range(mask, 0, 255, "mask"));
      }
      _native_typed_data.NativeInt32x4._list[dartx.set](0, this.x);
      _native_typed_data.NativeInt32x4._list[dartx.set](1, this.y);
      _native_typed_data.NativeInt32x4._list[dartx.set](2, this.z);
      _native_typed_data.NativeInt32x4._list[dartx.set](3, this.w);
      let _x = _native_typed_data.NativeInt32x4._list[dartx.get](dart.notNull(mask) & 3);
      let _y = _native_typed_data.NativeInt32x4._list[dartx.get](dart.notNull(mask) >> 2 & 3);
      let _z = _native_typed_data.NativeInt32x4._list[dartx.get](dart.notNull(mask) >> 4 & 3);
      let _w = _native_typed_data.NativeInt32x4._list[dartx.get](dart.notNull(mask) >> 6 & 3);
      return new _native_typed_data.NativeInt32x4._truncated(_x, _y, _z, _w);
    }
    shuffleMix(other, mask) {
      if (dart.notNull(mask) < 0 || dart.notNull(mask) > 255) {
        dart.throw(new core.RangeError.range(mask, 0, 255, "mask"));
      }
      _native_typed_data.NativeInt32x4._list[dartx.set](0, this.x);
      _native_typed_data.NativeInt32x4._list[dartx.set](1, this.y);
      _native_typed_data.NativeInt32x4._list[dartx.set](2, this.z);
      _native_typed_data.NativeInt32x4._list[dartx.set](3, this.w);
      let _x = _native_typed_data.NativeInt32x4._list[dartx.get](dart.notNull(mask) & 3);
      let _y = _native_typed_data.NativeInt32x4._list[dartx.get](dart.notNull(mask) >> 2 & 3);
      _native_typed_data.NativeInt32x4._list[dartx.set](0, other.x);
      _native_typed_data.NativeInt32x4._list[dartx.set](1, other.y);
      _native_typed_data.NativeInt32x4._list[dartx.set](2, other.z);
      _native_typed_data.NativeInt32x4._list[dartx.set](3, other.w);
      let _z = _native_typed_data.NativeInt32x4._list[dartx.get](dart.notNull(mask) >> 4 & 3);
      let _w = _native_typed_data.NativeInt32x4._list[dartx.get](dart.notNull(mask) >> 6 & 3);
      return new _native_typed_data.NativeInt32x4._truncated(_x, _y, _z, _w);
    }
    withX(x) {
      let _x = core.int._check(_native_typed_data.NativeInt32x4._truncate(x));
      return new _native_typed_data.NativeInt32x4._truncated(_x, this.y, this.z, this.w);
    }
    withY(y) {
      let _y = core.int._check(_native_typed_data.NativeInt32x4._truncate(y));
      return new _native_typed_data.NativeInt32x4._truncated(this.x, _y, this.z, this.w);
    }
    withZ(z) {
      let _z = core.int._check(_native_typed_data.NativeInt32x4._truncate(z));
      return new _native_typed_data.NativeInt32x4._truncated(this.x, this.y, _z, this.w);
    }
    withW(w) {
      let _w = core.int._check(_native_typed_data.NativeInt32x4._truncate(w));
      return new _native_typed_data.NativeInt32x4._truncated(this.x, this.y, this.z, _w);
    }
    get flagX() {
      return this.x != 0;
    }
    get flagY() {
      return this.y != 0;
    }
    get flagZ() {
      return this.z != 0;
    }
    get flagW() {
      return this.w != 0;
    }
    withFlagX(flagX) {
      let _x = dart.test(flagX) ? -1 : 0;
      return new _native_typed_data.NativeInt32x4._truncated(_x, this.y, this.z, this.w);
    }
    withFlagY(flagY) {
      let _y = dart.test(flagY) ? -1 : 0;
      return new _native_typed_data.NativeInt32x4._truncated(this.x, _y, this.z, this.w);
    }
    withFlagZ(flagZ) {
      let _z = dart.test(flagZ) ? -1 : 0;
      return new _native_typed_data.NativeInt32x4._truncated(this.x, this.y, _z, this.w);
    }
    withFlagW(flagW) {
      let _w = dart.test(flagW) ? -1 : 0;
      return new _native_typed_data.NativeInt32x4._truncated(this.x, this.y, this.z, _w);
    }
    select(trueValue, falseValue) {
      let floatList = _native_typed_data.NativeFloat32x4._list;
      let intView = _native_typed_data.NativeFloat32x4._uint32view;
      floatList[dartx.set](0, trueValue.x);
      floatList[dartx.set](1, trueValue.y);
      floatList[dartx.set](2, trueValue.z);
      floatList[dartx.set](3, trueValue.w);
      let stx = intView[dartx.get](0);
      let sty = intView[dartx.get](1);
      let stz = intView[dartx.get](2);
      let stw = intView[dartx.get](3);
      floatList[dartx.set](0, falseValue.x);
      floatList[dartx.set](1, falseValue.y);
      floatList[dartx.set](2, falseValue.z);
      floatList[dartx.set](3, falseValue.w);
      let sfx = intView[dartx.get](0);
      let sfy = intView[dartx.get](1);
      let sfz = intView[dartx.get](2);
      let sfw = intView[dartx.get](3);
      let _x = (dart.notNull(this.x) & dart.notNull(stx) | ~dart.notNull(this.x) & dart.notNull(sfx)) >>> 0;
      let _y = (dart.notNull(this.y) & dart.notNull(sty) | ~dart.notNull(this.y) & dart.notNull(sfy)) >>> 0;
      let _z = (dart.notNull(this.z) & dart.notNull(stz) | ~dart.notNull(this.z) & dart.notNull(sfz)) >>> 0;
      let _w = (dart.notNull(this.w) & dart.notNull(stw) | ~dart.notNull(this.w) & dart.notNull(sfw)) >>> 0;
      intView[dartx.set](0, _x);
      intView[dartx.set](1, _y);
      intView[dartx.set](2, _z);
      intView[dartx.set](3, _w);
      return new _native_typed_data.NativeFloat32x4._truncated(floatList[dartx.get](0), floatList[dartx.get](1), floatList[dartx.get](2), floatList[dartx.get](3));
    }
  };
  dart.defineNamedConstructor(_native_typed_data.NativeInt32x4, 'bool');
  dart.defineNamedConstructor(_native_typed_data.NativeInt32x4, '_truncated');
  _native_typed_data.NativeInt32x4[dart.implements] = () => [typed_data.Int32x4];
  dart.setSignature(_native_typed_data.NativeInt32x4, {
    constructors: () => ({
      new: dart.definiteFunctionType(_native_typed_data.NativeInt32x4, [core.int, core.int, core.int, core.int]),
      bool: dart.definiteFunctionType(_native_typed_data.NativeInt32x4, [core.bool, core.bool, core.bool, core.bool]),
      fromFloat32x4Bits: dart.definiteFunctionType(_native_typed_data.NativeInt32x4, [typed_data.Float32x4]),
      _truncated: dart.definiteFunctionType(_native_typed_data.NativeInt32x4, [core.int, core.int, core.int, core.int])
    }),
    methods: () => ({
      '|': dart.definiteFunctionType(typed_data.Int32x4, [typed_data.Int32x4]),
      '&': dart.definiteFunctionType(typed_data.Int32x4, [typed_data.Int32x4]),
      '^': dart.definiteFunctionType(typed_data.Int32x4, [typed_data.Int32x4]),
      '+': dart.definiteFunctionType(typed_data.Int32x4, [typed_data.Int32x4]),
      '-': dart.definiteFunctionType(typed_data.Int32x4, [typed_data.Int32x4]),
      'unary-': dart.definiteFunctionType(typed_data.Int32x4, []),
      shuffle: dart.definiteFunctionType(typed_data.Int32x4, [core.int]),
      shuffleMix: dart.definiteFunctionType(typed_data.Int32x4, [typed_data.Int32x4, core.int]),
      withX: dart.definiteFunctionType(typed_data.Int32x4, [core.int]),
      withY: dart.definiteFunctionType(typed_data.Int32x4, [core.int]),
      withZ: dart.definiteFunctionType(typed_data.Int32x4, [core.int]),
      withW: dart.definiteFunctionType(typed_data.Int32x4, [core.int]),
      withFlagX: dart.definiteFunctionType(typed_data.Int32x4, [core.bool]),
      withFlagY: dart.definiteFunctionType(typed_data.Int32x4, [core.bool]),
      withFlagZ: dart.definiteFunctionType(typed_data.Int32x4, [core.bool]),
      withFlagW: dart.definiteFunctionType(typed_data.Int32x4, [core.bool]),
      select: dart.definiteFunctionType(typed_data.Float32x4, [typed_data.Float32x4, typed_data.Float32x4])
    }),
    statics: () => ({_truncate: dart.definiteFunctionType(dart.dynamic, [dart.dynamic])}),
    names: ['_truncate']
  });
  dart.defineLazy(_native_typed_data.NativeInt32x4, {
    get _list() {
      return _native_typed_data.NativeInt32List.new(4);
    }
  });
  _native_typed_data.NativeFloat64x2 = class NativeFloat64x2 extends core.Object {
    new(x, y) {
      this.x = x;
      this.y = y;
      if (!(typeof this.x == 'number')) dart.throw(new core.ArgumentError(this.x));
      if (!(typeof this.y == 'number')) dart.throw(new core.ArgumentError(this.y));
    }
    splat(v) {
      NativeFloat64x2.prototype.new.call(this, v, v);
    }
    zero() {
      NativeFloat64x2.prototype.splat.call(this, 0.0);
    }
    fromFloat32x4(v) {
      NativeFloat64x2.prototype.new.call(this, v.x, v.y);
    }
    _doubles(x, y) {
      this.x = x;
      this.y = y;
    }
    toString() {
      return dart.str`[${this.x}, ${this.y}]`;
    }
    ['+'](other) {
      return new _native_typed_data.NativeFloat64x2._doubles(dart.notNull(this.x) + dart.notNull(other.x), dart.notNull(this.y) + dart.notNull(other.y));
    }
    ['unary-']() {
      return new _native_typed_data.NativeFloat64x2._doubles(-dart.notNull(this.x), -dart.notNull(this.y));
    }
    ['-'](other) {
      return new _native_typed_data.NativeFloat64x2._doubles(dart.notNull(this.x) - dart.notNull(other.x), dart.notNull(this.y) - dart.notNull(other.y));
    }
    ['*'](other) {
      return new _native_typed_data.NativeFloat64x2._doubles(dart.notNull(this.x) * dart.notNull(other.x), dart.notNull(this.y) * dart.notNull(other.y));
    }
    ['/'](other) {
      return new _native_typed_data.NativeFloat64x2._doubles(dart.notNull(this.x) / dart.notNull(other.x), dart.notNull(this.y) / dart.notNull(other.y));
    }
    scale(s) {
      return new _native_typed_data.NativeFloat64x2._doubles(dart.notNull(this.x) * dart.notNull(s), dart.notNull(this.y) * dart.notNull(s));
    }
    abs() {
      return new _native_typed_data.NativeFloat64x2._doubles(this.x[dartx.abs](), this.y[dartx.abs]());
    }
    clamp(lowerLimit, upperLimit) {
      let _lx = lowerLimit.x;
      let _ly = lowerLimit.y;
      let _ux = upperLimit.x;
      let _uy = upperLimit.y;
      let _x = this.x;
      let _y = this.y;
      _x = dart.notNull(_x) > dart.notNull(_ux) ? _ux : _x;
      _y = dart.notNull(_y) > dart.notNull(_uy) ? _uy : _y;
      _x = dart.notNull(_x) < dart.notNull(_lx) ? _lx : _x;
      _y = dart.notNull(_y) < dart.notNull(_ly) ? _ly : _y;
      return new _native_typed_data.NativeFloat64x2._doubles(_x, _y);
    }
    get signMask() {
      let view = _native_typed_data.NativeFloat64x2._uint32View;
      _native_typed_data.NativeFloat64x2._list[dartx.set](0, this.x);
      _native_typed_data.NativeFloat64x2._list[dartx.set](1, this.y);
      let mx = (dart.notNull(view[dartx.get](1)) & 2147483648) >>> 31;
      let my = (dart.notNull(view[dartx.get](3)) & 2147483648) >>> 31;
      return (mx | my << 1) >>> 0;
    }
    withX(x) {
      if (!(typeof x == 'number')) dart.throw(new core.ArgumentError(x));
      return new _native_typed_data.NativeFloat64x2._doubles(x, this.y);
    }
    withY(y) {
      if (!(typeof y == 'number')) dart.throw(new core.ArgumentError(y));
      return new _native_typed_data.NativeFloat64x2._doubles(this.x, y);
    }
    min(other) {
      return new _native_typed_data.NativeFloat64x2._doubles(dart.notNull(this.x) < dart.notNull(other.x) ? this.x : other.x, dart.notNull(this.y) < dart.notNull(other.y) ? this.y : other.y);
    }
    max(other) {
      return new _native_typed_data.NativeFloat64x2._doubles(dart.notNull(this.x) > dart.notNull(other.x) ? this.x : other.x, dart.notNull(this.y) > dart.notNull(other.y) ? this.y : other.y);
    }
    sqrt() {
      return new _native_typed_data.NativeFloat64x2._doubles(math.sqrt(this.x), math.sqrt(this.y));
    }
  };
  dart.defineNamedConstructor(_native_typed_data.NativeFloat64x2, 'splat');
  dart.defineNamedConstructor(_native_typed_data.NativeFloat64x2, 'zero');
  dart.defineNamedConstructor(_native_typed_data.NativeFloat64x2, 'fromFloat32x4');
  dart.defineNamedConstructor(_native_typed_data.NativeFloat64x2, '_doubles');
  _native_typed_data.NativeFloat64x2[dart.implements] = () => [typed_data.Float64x2];
  dart.setSignature(_native_typed_data.NativeFloat64x2, {
    constructors: () => ({
      new: dart.definiteFunctionType(_native_typed_data.NativeFloat64x2, [core.double, core.double]),
      splat: dart.definiteFunctionType(_native_typed_data.NativeFloat64x2, [core.double]),
      zero: dart.definiteFunctionType(_native_typed_data.NativeFloat64x2, []),
      fromFloat32x4: dart.definiteFunctionType(_native_typed_data.NativeFloat64x2, [typed_data.Float32x4]),
      _doubles: dart.definiteFunctionType(_native_typed_data.NativeFloat64x2, [core.double, core.double])
    }),
    methods: () => ({
      '+': dart.definiteFunctionType(typed_data.Float64x2, [typed_data.Float64x2]),
      'unary-': dart.definiteFunctionType(typed_data.Float64x2, []),
      '-': dart.definiteFunctionType(typed_data.Float64x2, [typed_data.Float64x2]),
      '*': dart.definiteFunctionType(typed_data.Float64x2, [typed_data.Float64x2]),
      '/': dart.definiteFunctionType(typed_data.Float64x2, [typed_data.Float64x2]),
      scale: dart.definiteFunctionType(typed_data.Float64x2, [core.double]),
      abs: dart.definiteFunctionType(typed_data.Float64x2, []),
      clamp: dart.definiteFunctionType(typed_data.Float64x2, [typed_data.Float64x2, typed_data.Float64x2]),
      withX: dart.definiteFunctionType(typed_data.Float64x2, [core.double]),
      withY: dart.definiteFunctionType(typed_data.Float64x2, [core.double]),
      min: dart.definiteFunctionType(typed_data.Float64x2, [typed_data.Float64x2]),
      max: dart.definiteFunctionType(typed_data.Float64x2, [typed_data.Float64x2]),
      sqrt: dart.definiteFunctionType(typed_data.Float64x2, [])
    })
  });
  dart.defineLazy(_native_typed_data.NativeFloat64x2, {
    get _list() {
      return _native_typed_data.NativeFloat64List.new(2);
    },
    set _list(_) {},
    get _uint32View() {
      return _native_typed_data.NativeUint32List._check(_native_typed_data.NativeFloat64x2._list[dartx.buffer][dartx.asUint32List]());
    },
    set _uint32View(_) {}
  });
  _native_typed_data._isInvalidArrayIndex = function(index) {
    return index >>> 0 !== index;
  };
  dart.lazyFn(_native_typed_data._isInvalidArrayIndex, () => intTobool());
  _native_typed_data._checkValidIndex = function(index, list, length) {
    if (dart.test(_native_typed_data._isInvalidArrayIndex(index)) || index >= dart.notNull(length)) {
      dart.throw(_js_helper.diagnoseIndexError(list, index));
    }
  };
  dart.lazyFn(_native_typed_data._checkValidIndex, () => intAndListAndintTovoid());
  _native_typed_data._checkValidRange = function(start, end, length) {
    if (dart.test(_native_typed_data._isInvalidArrayIndex(start)) || (end == null ? dart.notNull(start) > dart.notNull(length) : dart.test(_native_typed_data._isInvalidArrayIndex(end)) || dart.notNull(start) > dart.notNull(end) || dart.notNull(end) > dart.notNull(length))) {
      dart.throw(_js_helper.diagnoseRangeError(start, end, length));
    }
    if (end == null) return length;
    return end;
  };
  dart.fn(_native_typed_data._checkValidRange, intAndintAndintToint());
  async._invokeErrorHandler = function(errorHandler, error, stackTrace) {
    if (async.ZoneBinaryCallback.is(errorHandler)) {
      return dart.dcall(errorHandler, error, stackTrace);
    } else {
      let unaryErrorHandler = async.ZoneUnaryCallback._check(errorHandler);
      return dart.dcall(unaryErrorHandler, error);
    }
  };
  dart.lazyFn(async._invokeErrorHandler, () => FunctionAndObjectAndStackTraceTodynamic());
  async._registerErrorHandler = function(R) {
    return (errorHandler, zone) => {
      if (async.ZoneBinaryCallback.is(errorHandler)) {
        return zone.registerBinaryCallback(dart.dynamic, dart.dynamic, core.StackTrace)(ZoneBinaryCallbackOfdynamic$dynamic$StackTrace().as(errorHandler));
      } else {
        return zone.registerUnaryCallback(dart.dynamic, dart.dynamic)(async.ZoneUnaryCallback.as(errorHandler));
      }
    };
  };
  dart.lazyFn(async._registerErrorHandler, () => FunctionAndZoneToFunction());
  async.AsyncError = class AsyncError extends core.Object {
    new(error, stackTrace) {
      this.error = error;
      this.stackTrace = stackTrace;
    }
    toString() {
      return dart.str`${this.error}`;
    }
  };
  async.AsyncError[dart.implements] = () => [core.Error];
  dart.setSignature(async.AsyncError, {
    constructors: () => ({new: dart.definiteFunctionType(async.AsyncError, [core.Object, core.StackTrace])})
  });
  async._UncaughtAsyncError = class _UncaughtAsyncError extends async.AsyncError {
    new(error, stackTrace) {
      super.new(error, async._UncaughtAsyncError._getBestStackTrace(error, stackTrace));
    }
    static _getBestStackTrace(error, stackTrace) {
      if (stackTrace != null) return stackTrace;
      if (core.Error.is(error)) {
        return error.stackTrace;
      }
      return null;
    }
    toString() {
      let result = dart.str`Uncaught Error: ${this.error}`;
      if (this.stackTrace != null) {
        result = result + dart.str`\nStack Trace:\n${this.stackTrace}`;
      }
      return result;
    }
  };
  dart.setSignature(async._UncaughtAsyncError, {
    constructors: () => ({new: dart.definiteFunctionType(async._UncaughtAsyncError, [dart.dynamic, core.StackTrace])}),
    statics: () => ({_getBestStackTrace: dart.definiteFunctionType(core.StackTrace, [dart.dynamic, core.StackTrace])}),
    names: ['_getBestStackTrace']
  });
  const _controller$ = Symbol('_controller');
  const _subscribe = Symbol('_subscribe');
  const _createSubscription = Symbol('_createSubscription');
  const _onListen = Symbol('_onListen');
  async._StreamImpl$ = dart.generic(T => {
    let _BufferingStreamSubscriptionOfT = () => (_BufferingStreamSubscriptionOfT = dart.constFn(async._BufferingStreamSubscription$(T)))();
    class _StreamImpl extends async.Stream$(T) {
      new() {
        super.new();
      }
      listen(onData, opts) {
        let onError = opts && 'onError' in opts ? opts.onError : null;
        let onDone = opts && 'onDone' in opts ? opts.onDone : null;
        let cancelOnError = opts && 'cancelOnError' in opts ? opts.cancelOnError : null;
        cancelOnError = core.identical(true, cancelOnError);
        let subscription = this[_createSubscription](onData, onError, onDone, cancelOnError);
        this[_onListen](subscription);
        return subscription;
      }
      [_createSubscription](onData, onError, onDone, cancelOnError) {
        return new (_BufferingStreamSubscriptionOfT())(onData, onError, onDone, cancelOnError);
      }
      [_onListen](subscription) {}
    }
    dart.setSignature(_StreamImpl, {
      methods: () => ({
        listen: dart.definiteFunctionType(async.StreamSubscription$(T), [dart.functionType(dart.void, [T])], {onError: core.Function, onDone: VoidTovoid(), cancelOnError: core.bool}),
        [_createSubscription]: dart.definiteFunctionType(async.StreamSubscription$(T), [dart.functionType(dart.void, [T]), core.Function, dart.functionType(dart.void, []), core.bool]),
        [_onListen]: dart.definiteFunctionType(dart.void, [async.StreamSubscription])
      })
    });
    return _StreamImpl;
  });
  async._StreamImpl = _StreamImpl();
  async._ControllerStream$ = dart.generic(T => {
    class _ControllerStream extends async._StreamImpl$(T) {
      new(controller) {
        this[_controller$] = controller;
      }
      [_createSubscription](onData, onError, onDone, cancelOnError) {
        return this[_controller$][_subscribe](onData, onError, onDone, cancelOnError);
      }
      get hashCode() {
        return (dart.notNull(dart.hashCode(this[_controller$])) ^ 892482866) >>> 0;
      }
      ['=='](other) {
        if (core.identical(this, other)) return true;
        if (!async._ControllerStream.is(other)) return false;
        let otherStream = async._ControllerStream._check(other);
        return core.identical(otherStream[_controller$], this[_controller$]);
      }
    }
    dart.setSignature(_ControllerStream, {
      constructors: () => ({new: dart.definiteFunctionType(async._ControllerStream$(T), [async._StreamControllerLifecycle$(T)])}),
      methods: () => ({
        [_createSubscription]: dart.definiteFunctionType(async.StreamSubscription$(T), [dart.functionType(dart.void, [T]), core.Function, dart.functionType(dart.void, []), core.bool]),
        '==': dart.definiteFunctionType(core.bool, [core.Object])
      })
    });
    return _ControllerStream;
  });
  async._ControllerStream = _ControllerStream();
  async._BroadcastStream$ = dart.generic(T => {
    class _BroadcastStream extends async._ControllerStream$(T) {
      new(controller) {
        super.new(controller);
      }
      get isBroadcast() {
        return true;
      }
    }
    dart.setSignature(_BroadcastStream, {
      constructors: () => ({new: dart.definiteFunctionType(async._BroadcastStream$(T), [async._StreamControllerLifecycle$(T)])})
    });
    return _BroadcastStream;
  });
  async._BroadcastStream = _BroadcastStream();
  const _eventState = Symbol('_eventState');
  const _next$ = Symbol('_next');
  const _previous$ = Symbol('_previous');
  const _expectsEvent = Symbol('_expectsEvent');
  const _toggleEventId = Symbol('_toggleEventId');
  const _isFiring = Symbol('_isFiring');
  const _setRemoveAfterFiring = Symbol('_setRemoveAfterFiring');
  const _removeAfterFiring = Symbol('_removeAfterFiring');
  const _onPause = Symbol('_onPause');
  const _onResume = Symbol('_onResume');
  const _recordCancel = Symbol('_recordCancel');
  const _onCancel = Symbol('_onCancel');
  const _recordPause = Symbol('_recordPause');
  const _recordResume = Symbol('_recordResume');
  const _zone = Symbol('_zone');
  const _state = Symbol('_state');
  const _onData = Symbol('_onData');
  const _onError = Symbol('_onError');
  const _onDone = Symbol('_onDone');
  const _cancelFuture = Symbol('_cancelFuture');
  const _pending = Symbol('_pending');
  const _setPendingEvents = Symbol('_setPendingEvents');
  const _isCanceled = Symbol('_isCanceled');
  const _isPaused = Symbol('_isPaused');
  const _isInputPaused = Symbol('_isInputPaused');
  const _inCallback = Symbol('_inCallback');
  const _guardCallback = Symbol('_guardCallback');
  const _decrementPauseCount = Symbol('_decrementPauseCount');
  const _hasPending = Symbol('_hasPending');
  const _mayResumeInput = Symbol('_mayResumeInput');
  const _cancel = Symbol('_cancel');
  const _isClosed$ = Symbol('_isClosed');
  const _waitsForCancel = Symbol('_waitsForCancel');
  const _canFire = Symbol('_canFire');
  const _cancelOnError = Symbol('_cancelOnError');
  const _incrementPauseCount = Symbol('_incrementPauseCount');
  const _sendData = Symbol('_sendData');
  const _addPending = Symbol('_addPending');
  const _sendError = Symbol('_sendError');
  const _sendDone = Symbol('_sendDone');
  let const$0;
  const _close$ = Symbol('_close');
  const _checkState = Symbol('_checkState');
  async._BufferingStreamSubscription$ = dart.generic(T => {
    let _PendingEventsOfT = () => (_PendingEventsOfT = dart.constFn(async._PendingEvents$(T)))();
    let _DelayedDataOfT = () => (_DelayedDataOfT = dart.constFn(async._DelayedData$(T)))();
    let _StreamImplEventsOfT = () => (_StreamImplEventsOfT = dart.constFn(async._StreamImplEvents$(T)))();
    let StreamSubscriptionOfT = () => (StreamSubscriptionOfT = dart.constFn(async.StreamSubscription$(T)))();
    let _EventSinkOfT = () => (_EventSinkOfT = dart.constFn(async._EventSink$(T)))();
    let _EventDispatchOfT = () => (_EventDispatchOfT = dart.constFn(async._EventDispatch$(T)))();
    class _BufferingStreamSubscription extends core.Object {
      new(onData, onError, onDone, cancelOnError) {
        this[_zone] = async.Zone.current;
        this[_state] = dart.test(cancelOnError) ? async._BufferingStreamSubscription._STATE_CANCEL_ON_ERROR : 0;
        this[_onData] = null;
        this[_onError] = null;
        this[_onDone] = null;
        this[_cancelFuture] = null;
        this[_pending] = null;
        this.onData(onData);
        this.onError(onError);
        this.onDone(onDone);
      }
      [_setPendingEvents](pendingEvents) {
        _PendingEventsOfT()._check(pendingEvents);
        dart.assert(this[_pending] == null);
        if (pendingEvents == null) return;
        this[_pending] = pendingEvents;
        if (!dart.test(pendingEvents.isEmpty)) {
          this[_state] = (dart.notNull(this[_state]) | async._BufferingStreamSubscription._STATE_HAS_PENDING) >>> 0;
          this[_pending].schedule(this);
        }
      }
      onData(handleData) {
        if (handleData == null) handleData = async._nullDataHandler;
        this[_onData] = this[_zone].registerUnaryCallback(dart.dynamic, T)(handleData);
      }
      onError(handleError) {
        if (handleError == null) handleError = async._nullErrorHandler;
        this[_onError] = async._registerErrorHandler(T)(handleError, this[_zone]);
      }
      onDone(handleDone) {
        if (handleDone == null) handleDone = async._nullDoneHandler;
        this[_onDone] = this[_zone].registerCallback(dart.dynamic)(handleDone);
      }
      pause(resumeSignal) {
        if (resumeSignal === void 0) resumeSignal = null;
        if (dart.test(this[_isCanceled])) return;
        let wasPaused = this[_isPaused];
        let wasInputPaused = this[_isInputPaused];
        this[_state] = (dart.notNull(this[_state]) + async._BufferingStreamSubscription._STATE_PAUSE_COUNT | async._BufferingStreamSubscription._STATE_INPUT_PAUSED) >>> 0;
        if (resumeSignal != null) resumeSignal.whenComplete(dart.bind(this, 'resume'));
        if (!dart.test(wasPaused) && this[_pending] != null) this[_pending].cancelSchedule();
        if (!dart.test(wasInputPaused) && !dart.test(this[_inCallback])) this[_guardCallback](dart.bind(this, _onPause));
      }
      resume() {
        if (dart.test(this[_isCanceled])) return;
        if (dart.test(this[_isPaused])) {
          this[_decrementPauseCount]();
          if (!dart.test(this[_isPaused])) {
            if (dart.test(this[_hasPending]) && !dart.test(this[_pending].isEmpty)) {
              this[_pending].schedule(this);
            } else {
              dart.assert(this[_mayResumeInput]);
              this[_state] = (dart.notNull(this[_state]) & ~async._BufferingStreamSubscription._STATE_INPUT_PAUSED) >>> 0;
              if (!dart.test(this[_inCallback])) this[_guardCallback](dart.bind(this, _onResume));
            }
          }
        }
      }
      cancel() {
        this[_state] = (dart.notNull(this[_state]) & ~async._BufferingStreamSubscription._STATE_WAIT_FOR_CANCEL) >>> 0;
        if (dart.test(this[_isCanceled])) return this[_cancelFuture];
        this[_cancel]();
        return this[_cancelFuture];
      }
      asFuture(E) {
        return futureValue => {
          if (futureValue === void 0) futureValue = null;
          let result = new (async._Future$(E))();
          this[_onDone] = dart.fn(() => {
            result[_complete](futureValue);
          }, VoidTovoid$());
          this[_onError] = dart.fn((error, stackTrace) => {
            this.cancel();
            result[_completeError](error, core.StackTrace._check(stackTrace));
          }, dynamicAnddynamicTodynamic$());
          return result;
        };
      }
      get [_isInputPaused]() {
        return (dart.notNull(this[_state]) & async._BufferingStreamSubscription._STATE_INPUT_PAUSED) != 0;
      }
      get [_isClosed$]() {
        return (dart.notNull(this[_state]) & async._BufferingStreamSubscription._STATE_CLOSED) != 0;
      }
      get [_isCanceled]() {
        return (dart.notNull(this[_state]) & async._BufferingStreamSubscription._STATE_CANCELED) != 0;
      }
      get [_waitsForCancel]() {
        return (dart.notNull(this[_state]) & async._BufferingStreamSubscription._STATE_WAIT_FOR_CANCEL) != 0;
      }
      get [_inCallback]() {
        return (dart.notNull(this[_state]) & async._BufferingStreamSubscription._STATE_IN_CALLBACK) != 0;
      }
      get [_hasPending]() {
        return (dart.notNull(this[_state]) & async._BufferingStreamSubscription._STATE_HAS_PENDING) != 0;
      }
      get [_isPaused]() {
        return dart.notNull(this[_state]) >= async._BufferingStreamSubscription._STATE_PAUSE_COUNT;
      }
      get [_canFire]() {
        return dart.notNull(this[_state]) < async._BufferingStreamSubscription._STATE_IN_CALLBACK;
      }
      get [_mayResumeInput]() {
        return !dart.test(this[_isPaused]) && (this[_pending] == null || dart.test(this[_pending].isEmpty));
      }
      get [_cancelOnError]() {
        return (dart.notNull(this[_state]) & async._BufferingStreamSubscription._STATE_CANCEL_ON_ERROR) != 0;
      }
      get isPaused() {
        return this[_isPaused];
      }
      [_cancel]() {
        this[_state] = (dart.notNull(this[_state]) | async._BufferingStreamSubscription._STATE_CANCELED) >>> 0;
        if (dart.test(this[_hasPending])) {
          this[_pending].cancelSchedule();
        }
        if (!dart.test(this[_inCallback])) this[_pending] = null;
        this[_cancelFuture] = this[_onCancel]();
      }
      [_incrementPauseCount]() {
        this[_state] = (dart.notNull(this[_state]) + async._BufferingStreamSubscription._STATE_PAUSE_COUNT | async._BufferingStreamSubscription._STATE_INPUT_PAUSED) >>> 0;
      }
      [_decrementPauseCount]() {
        dart.assert(this[_isPaused]);
        this[_state] = dart.notNull(this[_state]) - async._BufferingStreamSubscription._STATE_PAUSE_COUNT;
      }
      [_add$](data) {
        T._check(data);
        dart.assert(!dart.test(this[_isClosed$]));
        if (dart.test(this[_isCanceled])) return;
        if (dart.test(this[_canFire])) {
          this[_sendData](data);
        } else {
          this[_addPending](new (_DelayedDataOfT())(data));
        }
      }
      [_addError](error, stackTrace) {
        if (dart.test(this[_isCanceled])) return;
        if (dart.test(this[_canFire])) {
          this[_sendError](error, stackTrace);
        } else {
          this[_addPending](new async._DelayedError(error, stackTrace));
        }
      }
      [_close$]() {
        dart.assert(!dart.test(this[_isClosed$]));
        if (dart.test(this[_isCanceled])) return;
        this[_state] = (dart.notNull(this[_state]) | async._BufferingStreamSubscription._STATE_CLOSED) >>> 0;
        if (dart.test(this[_canFire])) {
          this[_sendDone]();
        } else {
          this[_addPending](const$0 || (const$0 = dart.const(new async._DelayedDone())));
        }
      }
      [_onPause]() {
        dart.assert(this[_isInputPaused]);
      }
      [_onResume]() {
        dart.assert(!dart.test(this[_isInputPaused]));
      }
      [_onCancel]() {
        dart.assert(this[_isCanceled]);
        return null;
      }
      [_addPending](event) {
        let pending = _StreamImplEventsOfT()._check(this[_pending]);
        if (this[_pending] == null) {
          pending = this[_pending] = new (_StreamImplEventsOfT())();
        }
        pending.add(event);
        if (!dart.test(this[_hasPending])) {
          this[_state] = (dart.notNull(this[_state]) | async._BufferingStreamSubscription._STATE_HAS_PENDING) >>> 0;
          if (!dart.test(this[_isPaused])) {
            this[_pending].schedule(this);
          }
        }
      }
      [_sendData](data) {
        T._check(data);
        dart.assert(!dart.test(this[_isCanceled]));
        dart.assert(!dart.test(this[_isPaused]));
        dart.assert(!dart.test(this[_inCallback]));
        let wasInputPaused = this[_isInputPaused];
        this[_state] = (dart.notNull(this[_state]) | async._BufferingStreamSubscription._STATE_IN_CALLBACK) >>> 0;
        this[_zone].runUnaryGuarded(dart.dynamic, T)(this[_onData], data);
        this[_state] = (dart.notNull(this[_state]) & ~async._BufferingStreamSubscription._STATE_IN_CALLBACK) >>> 0;
        this[_checkState](wasInputPaused);
      }
      [_sendError](error, stackTrace) {
        dart.assert(!dart.test(this[_isCanceled]));
        dart.assert(!dart.test(this[_isPaused]));
        dart.assert(!dart.test(this[_inCallback]));
        let wasInputPaused = this[_isInputPaused];
        const sendError = (function() {
          if (dart.test(this[_isCanceled]) && !dart.test(this[_waitsForCancel])) return;
          this[_state] = (dart.notNull(this[_state]) | async._BufferingStreamSubscription._STATE_IN_CALLBACK) >>> 0;
          if (ZoneBinaryCallbackOfdynamic$Object$StackTrace().is(this[_onError])) {
            let errorCallback = ZoneBinaryCallbackOfdynamic$Object$StackTrace().as(this[_onError]);
            this[_zone].runBinaryGuarded(dart.dynamic, core.Object, core.StackTrace)(errorCallback, error, stackTrace);
          } else {
            this[_zone].runUnaryGuarded(dart.dynamic, dart.dynamic)(async.ZoneUnaryCallback.as(this[_onError]), error);
          }
          this[_state] = (dart.notNull(this[_state]) & ~async._BufferingStreamSubscription._STATE_IN_CALLBACK) >>> 0;
        }).bind(this);
        dart.fn(sendError, VoidTovoid$());
        if (dart.test(this[_cancelOnError])) {
          this[_state] = (dart.notNull(this[_state]) | async._BufferingStreamSubscription._STATE_WAIT_FOR_CANCEL) >>> 0;
          this[_cancel]();
          if (async.Future.is(this[_cancelFuture])) {
            this[_cancelFuture].whenComplete(sendError);
          } else {
            sendError();
          }
        } else {
          sendError();
          this[_checkState](wasInputPaused);
        }
      }
      [_sendDone]() {
        dart.assert(!dart.test(this[_isCanceled]));
        dart.assert(!dart.test(this[_isPaused]));
        dart.assert(!dart.test(this[_inCallback]));
        const sendDone = (function() {
          if (!dart.test(this[_waitsForCancel])) return;
          this[_state] = (dart.notNull(this[_state]) | async._BufferingStreamSubscription._STATE_CANCELED | async._BufferingStreamSubscription._STATE_CLOSED | async._BufferingStreamSubscription._STATE_IN_CALLBACK) >>> 0;
          this[_zone].runGuarded(dart.dynamic)(this[_onDone]);
          this[_state] = (dart.notNull(this[_state]) & ~async._BufferingStreamSubscription._STATE_IN_CALLBACK) >>> 0;
        }).bind(this);
        dart.fn(sendDone, VoidTovoid$());
        this[_cancel]();
        this[_state] = (dart.notNull(this[_state]) | async._BufferingStreamSubscription._STATE_WAIT_FOR_CANCEL) >>> 0;
        if (async.Future.is(this[_cancelFuture])) {
          this[_cancelFuture].whenComplete(sendDone);
        } else {
          sendDone();
        }
      }
      [_guardCallback](callback) {
        dart.assert(!dart.test(this[_inCallback]));
        let wasInputPaused = this[_isInputPaused];
        this[_state] = (dart.notNull(this[_state]) | async._BufferingStreamSubscription._STATE_IN_CALLBACK) >>> 0;
        dart.dcall(callback);
        this[_state] = (dart.notNull(this[_state]) & ~async._BufferingStreamSubscription._STATE_IN_CALLBACK) >>> 0;
        this[_checkState](wasInputPaused);
      }
      [_checkState](wasInputPaused) {
        dart.assert(!dart.test(this[_inCallback]));
        if (dart.test(this[_hasPending]) && dart.test(this[_pending].isEmpty)) {
          this[_state] = (dart.notNull(this[_state]) & ~async._BufferingStreamSubscription._STATE_HAS_PENDING) >>> 0;
          if (dart.test(this[_isInputPaused]) && dart.test(this[_mayResumeInput])) {
            this[_state] = (dart.notNull(this[_state]) & ~async._BufferingStreamSubscription._STATE_INPUT_PAUSED) >>> 0;
          }
        }
        while (true) {
          if (dart.test(this[_isCanceled])) {
            this[_pending] = null;
            return;
          }
          let isInputPaused = this[_isInputPaused];
          if (wasInputPaused == isInputPaused) break;
          this[_state] = (dart.notNull(this[_state]) ^ async._BufferingStreamSubscription._STATE_IN_CALLBACK) >>> 0;
          if (dart.test(isInputPaused)) {
            this[_onPause]();
          } else {
            this[_onResume]();
          }
          this[_state] = (dart.notNull(this[_state]) & ~async._BufferingStreamSubscription._STATE_IN_CALLBACK) >>> 0;
          wasInputPaused = isInputPaused;
        }
        if (dart.test(this[_hasPending]) && !dart.test(this[_isPaused])) {
          this[_pending].schedule(this);
        }
      }
    }
    dart.addTypeTests(_BufferingStreamSubscription);
    _BufferingStreamSubscription[dart.implements] = () => [StreamSubscriptionOfT(), _EventSinkOfT(), _EventDispatchOfT()];
    dart.setSignature(_BufferingStreamSubscription, {
      constructors: () => ({new: dart.definiteFunctionType(async._BufferingStreamSubscription$(T), [dart.functionType(dart.void, [T]), core.Function, dart.functionType(dart.void, []), core.bool])}),
      methods: () => ({
        [_setPendingEvents]: dart.definiteFunctionType(dart.void, [async._PendingEvents$(T)]),
        onData: dart.definiteFunctionType(dart.void, [dart.functionType(dart.void, [T])]),
        onError: dart.definiteFunctionType(dart.void, [core.Function]),
        onDone: dart.definiteFunctionType(dart.void, [dart.functionType(dart.void, [])]),
        pause: dart.definiteFunctionType(dart.void, [], [async.Future]),
        resume: dart.definiteFunctionType(dart.void, []),
        cancel: dart.definiteFunctionType(async.Future, []),
        asFuture: dart.definiteFunctionType(E => [async.Future$(E), [], [E]]),
        [_cancel]: dart.definiteFunctionType(dart.void, []),
        [_incrementPauseCount]: dart.definiteFunctionType(dart.void, []),
        [_decrementPauseCount]: dart.definiteFunctionType(dart.void, []),
        [_add$]: dart.definiteFunctionType(dart.void, [T]),
        [_addError]: dart.definiteFunctionType(dart.void, [core.Object, core.StackTrace]),
        [_close$]: dart.definiteFunctionType(dart.void, []),
        [_onPause]: dart.definiteFunctionType(dart.void, []),
        [_onResume]: dart.definiteFunctionType(dart.void, []),
        [_onCancel]: dart.definiteFunctionType(async.Future, []),
        [_addPending]: dart.definiteFunctionType(dart.void, [async._DelayedEvent]),
        [_sendData]: dart.definiteFunctionType(dart.void, [T]),
        [_sendError]: dart.definiteFunctionType(dart.void, [core.Object, core.StackTrace]),
        [_sendDone]: dart.definiteFunctionType(dart.void, []),
        [_guardCallback]: dart.definiteFunctionType(dart.void, [dart.dynamic]),
        [_checkState]: dart.definiteFunctionType(dart.void, [core.bool])
      })
    });
    return _BufferingStreamSubscription;
  });
  async._BufferingStreamSubscription = _BufferingStreamSubscription();
  async._BufferingStreamSubscription._STATE_CANCEL_ON_ERROR = 1;
  async._BufferingStreamSubscription._STATE_CLOSED = 2;
  async._BufferingStreamSubscription._STATE_INPUT_PAUSED = 4;
  async._BufferingStreamSubscription._STATE_CANCELED = 8;
  async._BufferingStreamSubscription._STATE_WAIT_FOR_CANCEL = 16;
  async._BufferingStreamSubscription._STATE_IN_CALLBACK = 32;
  async._BufferingStreamSubscription._STATE_HAS_PENDING = 64;
  async._BufferingStreamSubscription._STATE_PAUSE_COUNT = 128;
  async._BufferingStreamSubscription._STATE_PAUSE_COUNT_SHIFT = 7;
  async._ControllerSubscription$ = dart.generic(T => {
    class _ControllerSubscription extends async._BufferingStreamSubscription$(T) {
      new(controller, onData, onError, onDone, cancelOnError) {
        this[_controller$] = controller;
        super.new(onData, onError, onDone, cancelOnError);
      }
      [_onCancel]() {
        return this[_controller$][_recordCancel](this);
      }
      [_onPause]() {
        this[_controller$][_recordPause](this);
      }
      [_onResume]() {
        this[_controller$][_recordResume](this);
      }
    }
    dart.setSignature(_ControllerSubscription, {
      constructors: () => ({new: dart.definiteFunctionType(async._ControllerSubscription$(T), [async._StreamControllerLifecycle$(T), dart.functionType(dart.void, [T]), core.Function, dart.functionType(dart.void, []), core.bool])})
    });
    return _ControllerSubscription;
  });
  async._ControllerSubscription = _ControllerSubscription();
  async._BroadcastSubscription$ = dart.generic(T => {
    class _BroadcastSubscription extends async._ControllerSubscription$(T) {
      new(controller, onData, onError, onDone, cancelOnError) {
        this[_eventState] = 0;
        this[_next$] = null;
        this[_previous$] = null;
        super.new(controller, onData, onError, onDone, cancelOnError);
        this[_next$] = this[_previous$] = this;
      }
      [_expectsEvent](eventId) {
        return (dart.notNull(this[_eventState]) & async._BroadcastSubscription._STATE_EVENT_ID) == eventId;
      }
      [_toggleEventId]() {
        this[_eventState] = (dart.notNull(this[_eventState]) ^ async._BroadcastSubscription._STATE_EVENT_ID) >>> 0;
      }
      get [_isFiring]() {
        return (dart.notNull(this[_eventState]) & async._BroadcastSubscription._STATE_FIRING) != 0;
      }
      [_setRemoveAfterFiring]() {
        dart.assert(this[_isFiring]);
        this[_eventState] = (dart.notNull(this[_eventState]) | async._BroadcastSubscription._STATE_REMOVE_AFTER_FIRING) >>> 0;
      }
      get [_removeAfterFiring]() {
        return (dart.notNull(this[_eventState]) & async._BroadcastSubscription._STATE_REMOVE_AFTER_FIRING) != 0;
      }
      [_onPause]() {}
      [_onResume]() {}
    }
    dart.setSignature(_BroadcastSubscription, {
      constructors: () => ({new: dart.definiteFunctionType(async._BroadcastSubscription$(T), [async._StreamControllerLifecycle$(T), dart.functionType(dart.void, [T]), core.Function, dart.functionType(dart.void, []), core.bool])}),
      methods: () => ({
        [_expectsEvent]: dart.definiteFunctionType(core.bool, [core.int]),
        [_toggleEventId]: dart.definiteFunctionType(dart.void, []),
        [_setRemoveAfterFiring]: dart.definiteFunctionType(dart.void, [])
      })
    });
    return _BroadcastSubscription;
  });
  async._BroadcastSubscription = _BroadcastSubscription();
  async._BroadcastSubscription._STATE_EVENT_ID = 1;
  async._BroadcastSubscription._STATE_FIRING = 2;
  async._BroadcastSubscription._STATE_REMOVE_AFTER_FIRING = 4;
  const _firstSubscription = Symbol('_firstSubscription');
  const _lastSubscription = Symbol('_lastSubscription');
  const _addStreamState = Symbol('_addStreamState');
  const _doneFuture = Symbol('_doneFuture');
  const _isEmpty = Symbol('_isEmpty');
  const _hasOneListener = Symbol('_hasOneListener');
  const _isAddingStream = Symbol('_isAddingStream');
  const _mayAddEvent = Symbol('_mayAddEvent');
  const _ensureDoneFuture = Symbol('_ensureDoneFuture');
  const _addListener = Symbol('_addListener');
  const _removeListener = Symbol('_removeListener');
  const _callOnCancel = Symbol('_callOnCancel');
  const _addEventError = Symbol('_addEventError');
  const _forEachListener = Symbol('_forEachListener');
  const _mayComplete = Symbol('_mayComplete');
  const _asyncComplete = Symbol('_asyncComplete');
  async._BroadcastStreamController$ = dart.generic(T => {
    let _BroadcastStreamOfT = () => (_BroadcastStreamOfT = dart.constFn(async._BroadcastStream$(T)))();
    let _StreamSinkWrapperOfT = () => (_StreamSinkWrapperOfT = dart.constFn(async._StreamSinkWrapper$(T)))();
    let _BroadcastSubscriptionOfT = () => (_BroadcastSubscriptionOfT = dart.constFn(async._BroadcastSubscription$(T)))();
    let _DoneStreamSubscriptionOfT = () => (_DoneStreamSubscriptionOfT = dart.constFn(async._DoneStreamSubscription$(T)))();
    let StreamSubscriptionOfT = () => (StreamSubscriptionOfT = dart.constFn(async.StreamSubscription$(T)))();
    let StreamOfT = () => (StreamOfT = dart.constFn(async.Stream$(T)))();
    let _AddStreamStateOfT = () => (_AddStreamStateOfT = dart.constFn(async._AddStreamState$(T)))();
    let StreamControllerOfT = () => (StreamControllerOfT = dart.constFn(async.StreamController$(T)))();
    let _StreamControllerLifecycleOfT = () => (_StreamControllerLifecycleOfT = dart.constFn(async._StreamControllerLifecycle$(T)))();
    let _EventSinkOfT = () => (_EventSinkOfT = dart.constFn(async._EventSink$(T)))();
    let _EventDispatchOfT = () => (_EventDispatchOfT = dart.constFn(async._EventDispatch$(T)))();
    class _BroadcastStreamController extends core.Object {
      new(onListen, onCancel) {
        this.onListen = onListen;
        this.onCancel = onCancel;
        this[_state] = async._BroadcastStreamController._STATE_INITIAL;
        this[_firstSubscription] = null;
        this[_lastSubscription] = null;
        this[_addStreamState] = null;
        this[_doneFuture] = null;
      }
      get onPause() {
        dart.throw(new core.UnsupportedError("Broadcast stream controllers do not support pause callbacks"));
      }
      set onPause(onPauseHandler) {
        dart.throw(new core.UnsupportedError("Broadcast stream controllers do not support pause callbacks"));
      }
      get onResume() {
        dart.throw(new core.UnsupportedError("Broadcast stream controllers do not support pause callbacks"));
      }
      set onResume(onResumeHandler) {
        dart.throw(new core.UnsupportedError("Broadcast stream controllers do not support pause callbacks"));
      }
      get stream() {
        return new (_BroadcastStreamOfT())(this);
      }
      get sink() {
        return new (_StreamSinkWrapperOfT())(this);
      }
      get isClosed() {
        return (dart.notNull(this[_state]) & async._BroadcastStreamController._STATE_CLOSED) != 0;
      }
      get isPaused() {
        return false;
      }
      get hasListener() {
        return !dart.test(this[_isEmpty]);
      }
      get [_hasOneListener]() {
        dart.assert(!dart.test(this[_isEmpty]));
        return core.identical(this[_firstSubscription], this[_lastSubscription]);
      }
      get [_isFiring]() {
        return (dart.notNull(this[_state]) & async._BroadcastStreamController._STATE_FIRING) != 0;
      }
      get [_isAddingStream]() {
        return (dart.notNull(this[_state]) & async._BroadcastStreamController._STATE_ADDSTREAM) != 0;
      }
      get [_mayAddEvent]() {
        return dart.notNull(this[_state]) < async._BroadcastStreamController._STATE_CLOSED;
      }
      [_ensureDoneFuture]() {
        if (this[_doneFuture] != null) return this[_doneFuture];
        return this[_doneFuture] = new async._Future();
      }
      get [_isEmpty]() {
        return this[_firstSubscription] == null;
      }
      [_addListener](subscription) {
        _BroadcastSubscriptionOfT()._check(subscription);
        dart.assert(core.identical(subscription[_next$], subscription));
        subscription[_eventState] = dart.notNull(this[_state]) & async._BroadcastStreamController._STATE_EVENT_ID;
        let oldLast = this[_lastSubscription];
        this[_lastSubscription] = subscription;
        subscription[_next$] = null;
        subscription[_previous$] = oldLast;
        if (oldLast == null) {
          this[_firstSubscription] = subscription;
        } else {
          oldLast[_next$] = subscription;
        }
      }
      [_removeListener](subscription) {
        _BroadcastSubscriptionOfT()._check(subscription);
        dart.assert(core.identical(subscription[_controller$], this));
        dart.assert(!core.identical(subscription[_next$], subscription));
        let previous = subscription[_previous$];
        let next = subscription[_next$];
        if (previous == null) {
          this[_firstSubscription] = next;
        } else {
          previous[_next$] = next;
        }
        if (next == null) {
          this[_lastSubscription] = previous;
        } else {
          next[_previous$] = previous;
        }
        subscription[_next$] = subscription[_previous$] = subscription;
      }
      [_subscribe](onData, onError, onDone, cancelOnError) {
        if (dart.test(this.isClosed)) {
          if (onDone == null) onDone = async._nullDoneHandler;
          return new (_DoneStreamSubscriptionOfT())(onDone);
        }
        let subscription = new (_BroadcastSubscriptionOfT())(this, onData, onError, onDone, cancelOnError);
        this[_addListener](_BroadcastSubscriptionOfT()._check(subscription));
        if (core.identical(this[_firstSubscription], this[_lastSubscription])) {
          async._runGuarded(this.onListen);
        }
        return subscription;
      }
      [_recordCancel](sub) {
        StreamSubscriptionOfT()._check(sub);
        let subscription = _BroadcastSubscriptionOfT()._check(sub);
        if (core.identical(subscription[_next$], subscription)) return null;
        if (dart.test(subscription[_isFiring])) {
          subscription[_setRemoveAfterFiring]();
        } else {
          this[_removeListener](subscription);
          if (!dart.test(this[_isFiring]) && dart.test(this[_isEmpty])) {
            this[_callOnCancel]();
          }
        }
        return null;
      }
      [_recordPause](subscription) {
        StreamSubscriptionOfT()._check(subscription);
      }
      [_recordResume](subscription) {
        StreamSubscriptionOfT()._check(subscription);
      }
      [_addEventError]() {
        if (dart.test(this.isClosed)) {
          return new core.StateError("Cannot add new events after calling close");
        }
        dart.assert(this[_isAddingStream]);
        return new core.StateError("Cannot add new events while doing an addStream");
      }
      add(data) {
        T._check(data);
        if (!dart.test(this[_mayAddEvent])) dart.throw(this[_addEventError]());
        this[_sendData](data);
      }
      addError(error, stackTrace) {
        if (stackTrace === void 0) stackTrace = null;
        error = async._nonNullError(error);
        if (!dart.test(this[_mayAddEvent])) dart.throw(this[_addEventError]());
        let replacement = async.Zone.current.errorCallback(error, stackTrace);
        if (replacement != null) {
          error = async._nonNullError(replacement.error);
          stackTrace = replacement.stackTrace;
        }
        this[_sendError](error, stackTrace);
      }
      close() {
        if (dart.test(this.isClosed)) {
          dart.assert(this[_doneFuture] != null);
          return this[_doneFuture];
        }
        if (!dart.test(this[_mayAddEvent])) dart.throw(this[_addEventError]());
        this[_state] = (dart.notNull(this[_state]) | async._BroadcastStreamController._STATE_CLOSED) >>> 0;
        let doneFuture = this[_ensureDoneFuture]();
        this[_sendDone]();
        return doneFuture;
      }
      get done() {
        return this[_ensureDoneFuture]();
      }
      addStream(stream, opts) {
        StreamOfT()._check(stream);
        let cancelOnError = opts && 'cancelOnError' in opts ? opts.cancelOnError : true;
        if (!dart.test(this[_mayAddEvent])) dart.throw(this[_addEventError]());
        this[_state] = (dart.notNull(this[_state]) | async._BroadcastStreamController._STATE_ADDSTREAM) >>> 0;
        this[_addStreamState] = new (_AddStreamStateOfT())(this, stream, cancelOnError);
        return this[_addStreamState].addStreamFuture;
      }
      [_add$](data) {
        T._check(data);
        this[_sendData](data);
      }
      [_addError](error, stackTrace) {
        this[_sendError](error, stackTrace);
      }
      [_close$]() {
        dart.assert(this[_isAddingStream]);
        let addState = this[_addStreamState];
        this[_addStreamState] = null;
        this[_state] = (dart.notNull(this[_state]) & ~async._BroadcastStreamController._STATE_ADDSTREAM) >>> 0;
        addState.complete();
      }
      [_forEachListener](action) {
        if (dart.test(this[_isFiring])) {
          dart.throw(new core.StateError("Cannot fire new event. Controller is already firing an event"));
        }
        if (dart.test(this[_isEmpty])) return;
        let id = dart.notNull(this[_state]) & async._BroadcastStreamController._STATE_EVENT_ID;
        this[_state] = (dart.notNull(this[_state]) ^ (async._BroadcastStreamController._STATE_EVENT_ID | async._BroadcastStreamController._STATE_FIRING)) >>> 0;
        let subscription = this[_firstSubscription];
        while (subscription != null) {
          if (dart.test(subscription[_expectsEvent](id))) {
            subscription[_eventState] = (dart.notNull(subscription[_eventState]) | async._BroadcastSubscription._STATE_FIRING) >>> 0;
            action(subscription);
            subscription[_toggleEventId]();
            let next = subscription[_next$];
            if (dart.test(subscription[_removeAfterFiring])) {
              this[_removeListener](subscription);
            }
            subscription[_eventState] = (dart.notNull(subscription[_eventState]) & ~async._BroadcastSubscription._STATE_FIRING) >>> 0;
            subscription = next;
          } else {
            subscription = subscription[_next$];
          }
        }
        this[_state] = (dart.notNull(this[_state]) & ~async._BroadcastStreamController._STATE_FIRING) >>> 0;
        if (dart.test(this[_isEmpty])) {
          this[_callOnCancel]();
        }
      }
      [_callOnCancel]() {
        dart.assert(this[_isEmpty]);
        if (dart.test(this.isClosed) && dart.test(this[_doneFuture][_mayComplete])) {
          this[_doneFuture][_asyncComplete](null);
        }
        async._runGuarded(this.onCancel);
      }
    }
    dart.addTypeTests(_BroadcastStreamController);
    _BroadcastStreamController[dart.implements] = () => [StreamControllerOfT(), _StreamControllerLifecycleOfT(), _EventSinkOfT(), _EventDispatchOfT()];
    dart.setSignature(_BroadcastStreamController, {
      constructors: () => ({new: dart.definiteFunctionType(async._BroadcastStreamController$(T), [async.ControllerCallback, async.ControllerCancelCallback])}),
      methods: () => ({
        [_ensureDoneFuture]: dart.definiteFunctionType(async._Future, []),
        [_addListener]: dart.definiteFunctionType(dart.void, [async._BroadcastSubscription$(T)]),
        [_removeListener]: dart.definiteFunctionType(dart.void, [async._BroadcastSubscription$(T)]),
        [_subscribe]: dart.definiteFunctionType(async.StreamSubscription$(T), [dart.functionType(dart.void, [T]), core.Function, dart.functionType(dart.void, []), core.bool]),
        [_recordCancel]: dart.definiteFunctionType(async.Future, [async.StreamSubscription$(T)]),
        [_recordPause]: dart.definiteFunctionType(dart.void, [async.StreamSubscription$(T)]),
        [_recordResume]: dart.definiteFunctionType(dart.void, [async.StreamSubscription$(T)]),
        [_addEventError]: dart.definiteFunctionType(core.Error, []),
        add: dart.definiteFunctionType(dart.void, [T]),
        addError: dart.definiteFunctionType(dart.void, [core.Object], [core.StackTrace]),
        close: dart.definiteFunctionType(async.Future, []),
        addStream: dart.definiteFunctionType(async.Future, [async.Stream$(T)], {cancelOnError: core.bool}),
        [_add$]: dart.definiteFunctionType(dart.void, [T]),
        [_addError]: dart.definiteFunctionType(dart.void, [core.Object, core.StackTrace]),
        [_close$]: dart.definiteFunctionType(dart.void, []),
        [_forEachListener]: dart.definiteFunctionType(dart.void, [dart.functionType(dart.void, [async._BufferingStreamSubscription$(T)])]),
        [_callOnCancel]: dart.definiteFunctionType(dart.void, [])
      })
    });
    return _BroadcastStreamController;
  });
  async._BroadcastStreamController = _BroadcastStreamController();
  async._BroadcastStreamController._STATE_INITIAL = 0;
  async._BroadcastStreamController._STATE_EVENT_ID = 1;
  async._BroadcastStreamController._STATE_FIRING = 2;
  async._BroadcastStreamController._STATE_CLOSED = 4;
  async._BroadcastStreamController._STATE_ADDSTREAM = 8;
  async._SyncBroadcastStreamController$ = dart.generic(T => {
    let _BufferingStreamSubscriptionOfT = () => (_BufferingStreamSubscriptionOfT = dart.constFn(async._BufferingStreamSubscription$(T)))();
    let SynchronousStreamControllerOfT = () => (SynchronousStreamControllerOfT = dart.constFn(async.SynchronousStreamController$(T)))();
    let _BufferingStreamSubscriptionOfTTovoid = () => (_BufferingStreamSubscriptionOfTTovoid = dart.constFn(dart.definiteFunctionType(dart.void, [_BufferingStreamSubscriptionOfT()])))();
    class _SyncBroadcastStreamController extends async._BroadcastStreamController$(T) {
      new(onListen, onCancel) {
        super.new(onListen, onCancel);
      }
      get [_mayAddEvent]() {
        return dart.test(super[_mayAddEvent]) && !dart.test(this[_isFiring]);
      }
      [_addEventError]() {
        if (dart.test(this[_isFiring])) {
          return new core.StateError("Cannot fire new event. Controller is already firing an event");
        }
        return super[_addEventError]();
      }
      [_sendData](data) {
        T._check(data);
        if (dart.test(this[_isEmpty])) return;
        if (dart.test(this[_hasOneListener])) {
          this[_state] = (dart.notNull(this[_state]) | async._BroadcastStreamController._STATE_FIRING) >>> 0;
          let subscription = this[_firstSubscription];
          subscription[_add$](data);
          this[_state] = (dart.notNull(this[_state]) & ~async._BroadcastStreamController._STATE_FIRING) >>> 0;
          if (dart.test(this[_isEmpty])) {
            this[_callOnCancel]();
          }
          return;
        }
        this[_forEachListener](dart.fn(subscription => {
          subscription[_add$](data);
        }, _BufferingStreamSubscriptionOfTTovoid()));
      }
      [_sendError](error, stackTrace) {
        if (dart.test(this[_isEmpty])) return;
        this[_forEachListener](dart.fn(subscription => {
          subscription[_addError](error, stackTrace);
        }, _BufferingStreamSubscriptionOfTTovoid()));
      }
      [_sendDone]() {
        if (!dart.test(this[_isEmpty])) {
          this[_forEachListener](dart.fn(subscription => {
            subscription[_close$]();
          }, _BufferingStreamSubscriptionOfTTovoid()));
        } else {
          dart.assert(this[_doneFuture] != null);
          dart.assert(this[_doneFuture][_mayComplete]);
          this[_doneFuture][_asyncComplete](null);
        }
      }
    }
    _SyncBroadcastStreamController[dart.implements] = () => [SynchronousStreamControllerOfT()];
    dart.setSignature(_SyncBroadcastStreamController, {
      constructors: () => ({new: dart.definiteFunctionType(async._SyncBroadcastStreamController$(T), [dart.functionType(dart.void, []), dart.functionType(dart.void, [])])}),
      methods: () => ({
        [_sendData]: dart.definiteFunctionType(dart.void, [T]),
        [_sendError]: dart.definiteFunctionType(dart.void, [core.Object, core.StackTrace]),
        [_sendDone]: dart.definiteFunctionType(dart.void, [])
      })
    });
    return _SyncBroadcastStreamController;
  });
  async._SyncBroadcastStreamController = _SyncBroadcastStreamController();
  let const$1;
  async._AsyncBroadcastStreamController$ = dart.generic(T => {
    let _DelayedDataOfT = () => (_DelayedDataOfT = dart.constFn(async._DelayedData$(T)))();
    class _AsyncBroadcastStreamController extends async._BroadcastStreamController$(T) {
      new(onListen, onCancel) {
        super.new(onListen, onCancel);
      }
      [_sendData](data) {
        T._check(data);
        for (let subscription = this[_firstSubscription]; subscription != null; subscription = subscription[_next$]) {
          subscription[_addPending](new (_DelayedDataOfT())(data));
        }
      }
      [_sendError](error, stackTrace) {
        for (let subscription = this[_firstSubscription]; subscription != null; subscription = subscription[_next$]) {
          subscription[_addPending](new async._DelayedError(error, stackTrace));
        }
      }
      [_sendDone]() {
        if (!dart.test(this[_isEmpty])) {
          for (let subscription = this[_firstSubscription]; subscription != null; subscription = subscription[_next$]) {
            subscription[_addPending](const$1 || (const$1 = dart.const(new async._DelayedDone())));
          }
        } else {
          dart.assert(this[_doneFuture] != null);
          dart.assert(this[_doneFuture][_mayComplete]);
          this[_doneFuture][_asyncComplete](null);
        }
      }
    }
    dart.setSignature(_AsyncBroadcastStreamController, {
      constructors: () => ({new: dart.definiteFunctionType(async._AsyncBroadcastStreamController$(T), [dart.functionType(dart.void, []), dart.functionType(dart.void, [])])}),
      methods: () => ({
        [_sendData]: dart.definiteFunctionType(dart.void, [T]),
        [_sendError]: dart.definiteFunctionType(dart.void, [core.Object, core.StackTrace]),
        [_sendDone]: dart.definiteFunctionType(dart.void, [])
      })
    });
    return _AsyncBroadcastStreamController;
  });
  async._AsyncBroadcastStreamController = _AsyncBroadcastStreamController();
  const _addPendingEvent = Symbol('_addPendingEvent');
  let const$2;
  async._AsBroadcastStreamController$ = dart.generic(T => {
    let _StreamImplEventsOfT = () => (_StreamImplEventsOfT = dart.constFn(async._StreamImplEvents$(T)))();
    let _DelayedDataOfT = () => (_DelayedDataOfT = dart.constFn(async._DelayedData$(T)))();
    let _EventDispatchOfT = () => (_EventDispatchOfT = dart.constFn(async._EventDispatch$(T)))();
    class _AsBroadcastStreamController extends async._SyncBroadcastStreamController$(T) {
      new(onListen, onCancel) {
        this[_pending] = null;
        super.new(onListen, onCancel);
      }
      get [_hasPending]() {
        return this[_pending] != null && !dart.test(this[_pending].isEmpty);
      }
      [_addPendingEvent](event) {
        if (this[_pending] == null) {
          this[_pending] = new (_StreamImplEventsOfT())();
        }
        this[_pending].add(event);
      }
      add(data) {
        T._check(data);
        if (!dart.test(this.isClosed) && dart.test(this[_isFiring])) {
          this[_addPendingEvent](new (_DelayedDataOfT())(data));
          return;
        }
        super.add(data);
        while (dart.test(this[_hasPending])) {
          this[_pending].handleNext(this);
        }
      }
      addError(error, stackTrace) {
        if (stackTrace === void 0) stackTrace = null;
        if (!dart.test(this.isClosed) && dart.test(this[_isFiring])) {
          this[_addPendingEvent](new async._DelayedError(error, stackTrace));
          return;
        }
        if (!dart.test(this[_mayAddEvent])) dart.throw(this[_addEventError]());
        this[_sendError](error, stackTrace);
        while (dart.test(this[_hasPending])) {
          this[_pending].handleNext(this);
        }
      }
      close() {
        if (!dart.test(this.isClosed) && dart.test(this[_isFiring])) {
          this[_addPendingEvent](const$2 || (const$2 = dart.const(new async._DelayedDone())));
          this[_state] = (dart.notNull(this[_state]) | async._BroadcastStreamController._STATE_CLOSED) >>> 0;
          return super.done;
        }
        let result = super.close();
        dart.assert(!dart.test(this[_hasPending]));
        return result;
      }
      [_callOnCancel]() {
        if (dart.test(this[_hasPending])) {
          this[_pending].clear();
          this[_pending] = null;
        }
        super[_callOnCancel]();
      }
    }
    _AsBroadcastStreamController[dart.implements] = () => [_EventDispatchOfT()];
    dart.setSignature(_AsBroadcastStreamController, {
      constructors: () => ({new: dart.definiteFunctionType(async._AsBroadcastStreamController$(T), [dart.functionType(dart.void, []), dart.functionType(dart.void, [])])}),
      methods: () => ({
        [_addPendingEvent]: dart.definiteFunctionType(dart.void, [async._DelayedEvent]),
        add: dart.definiteFunctionType(dart.void, [T])
      })
    });
    return _AsBroadcastStreamController;
  });
  async._AsBroadcastStreamController = _AsBroadcastStreamController();
  const _pauseCount = Symbol('_pauseCount');
  const _resume = Symbol('_resume');
  async._DoneSubscription$ = dart.generic(T => {
    let StreamSubscriptionOfT = () => (StreamSubscriptionOfT = dart.constFn(async.StreamSubscription$(T)))();
    class _DoneSubscription extends core.Object {
      new() {
        this[_pauseCount] = 0;
      }
      onData(handleData) {}
      onError(handleError) {}
      onDone(handleDone) {}
      pause(resumeSignal) {
        if (resumeSignal === void 0) resumeSignal = null;
        if (resumeSignal != null) resumeSignal.then(dart.dynamic)(dart.bind(this, _resume));
        this[_pauseCount] = dart.notNull(this[_pauseCount]) + 1;
      }
      resume() {
        this[_resume](null);
      }
      [_resume](_) {
        if (dart.notNull(this[_pauseCount]) > 0) {
          this[_pauseCount] = dart.notNull(this[_pauseCount]) - 1;
        }
      }
      cancel() {
        return new async._Future.immediate(null);
      }
      get isPaused() {
        return dart.notNull(this[_pauseCount]) > 0;
      }
      asFuture(E) {
        return value => {
          if (value === void 0) value = null;
          return new (async._Future$(E))();
        };
      }
    }
    dart.addTypeTests(_DoneSubscription);
    _DoneSubscription[dart.implements] = () => [StreamSubscriptionOfT()];
    dart.setSignature(_DoneSubscription, {
      methods: () => ({
        onData: dart.definiteFunctionType(dart.void, [dart.functionType(dart.void, [T])]),
        onError: dart.definiteFunctionType(dart.void, [core.Function]),
        onDone: dart.definiteFunctionType(dart.void, [dart.functionType(dart.void, [])]),
        pause: dart.definiteFunctionType(dart.void, [], [async.Future]),
        resume: dart.definiteFunctionType(dart.void, []),
        [_resume]: dart.definiteFunctionType(dart.void, [dart.dynamic]),
        cancel: dart.definiteFunctionType(async.Future, []),
        asFuture: dart.definiteFunctionType(E => [async.Future$(E), [], [E]])
      })
    });
    return _DoneSubscription;
  });
  async._DoneSubscription = _DoneSubscription();
  async.DeferredLibrary = class DeferredLibrary extends core.Object {
    new(libraryName, opts) {
      let uri = opts && 'uri' in opts ? opts.uri : null;
      this.libraryName = libraryName;
      this.uri = uri;
    }
    load() {
      dart.throw('DeferredLibrary not supported. ' + 'please use the `import "lib.dart" deferred as lib` syntax.');
    }
  };
  dart.setSignature(async.DeferredLibrary, {
    constructors: () => ({new: dart.definiteFunctionType(async.DeferredLibrary, [core.String], {uri: core.String})}),
    methods: () => ({load: dart.definiteFunctionType(async.Future$(core.Null), [])})
  });
  const _s = Symbol('_s');
  async.DeferredLoadException = class DeferredLoadException extends core.Object {
    new(s) {
      this[_s] = s;
    }
    toString() {
      return dart.str`DeferredLoadException: '${this[_s]}'`;
    }
  };
  async.DeferredLoadException[dart.implements] = () => [core.Exception];
  dart.setSignature(async.DeferredLoadException, {
    constructors: () => ({new: dart.definiteFunctionType(async.DeferredLoadException, [core.String])})
  });
  const _completeWithValue = Symbol('_completeWithValue');
  let const$3;
  async.Future$ = dart.flattenFutures(dart.generic(T => {
    let _FutureOfT = () => (_FutureOfT = dart.constFn(async._Future$(T)))();
    let FutureOfT = () => (FutureOfT = dart.constFn(async.Future$(T)))();
    class Future extends core.Object {
      static new(computation) {
        let result = new (_FutureOfT())();
        async.Timer.run(dart.fn(() => {
          try {
            result[_complete](computation());
          } catch (e) {
            let s = dart.stackTrace(e);
            async._completeWithErrorCallback(result, e, s);
          }

        }, VoidTovoid$()));
        return result;
      }
      static microtask(computation) {
        let result = new (_FutureOfT())();
        async.scheduleMicrotask(dart.fn(() => {
          try {
            result[_complete](computation());
          } catch (e) {
            let s = dart.stackTrace(e);
            async._completeWithErrorCallback(result, e, s);
          }

        }, VoidTovoid$()));
        return result;
      }
      static sync(computation) {
        try {
          let result = computation();
          return FutureOfT().value(result);
        } catch (error) {
          let stackTrace = dart.stackTrace(error);
          return FutureOfT().error(error, stackTrace);
        }

      }
      static value(value) {
        if (value === void 0) value = null;
        return new (_FutureOfT()).immediate(value);
      }
      static error(error, stackTrace) {
        if (stackTrace === void 0) stackTrace = null;
        error = async._nonNullError(error);
        if (!core.identical(async.Zone.current, async._ROOT_ZONE)) {
          let replacement = async.Zone.current.errorCallback(error, stackTrace);
          if (replacement != null) {
            error = async._nonNullError(replacement.error);
            stackTrace = replacement.stackTrace;
          }
        }
        return new (_FutureOfT()).immediateError(error, stackTrace);
      }
      static delayed(duration, computation) {
        if (computation === void 0) computation = null;
        let result = new (_FutureOfT())();
        async.Timer.new(duration, dart.fn(() => {
          try {
            result[_complete](computation == null ? null : computation());
          } catch (e) {
            let s = dart.stackTrace(e);
            async._completeWithErrorCallback(result, e, s);
          }

        }, VoidTovoid$()));
        return result;
      }
      static wait(T) {
        return (futures, opts) => {
          let eagerError = opts && 'eagerError' in opts ? opts.eagerError : false;
          let cleanUp = opts && 'cleanUp' in opts ? opts.cleanUp : null;
          let result = new (async._Future$(core.List$(T)))();
          let values = null;
          let remaining = 0;
          let error = null;
          let stackTrace = null;
          function handleError(theError, theStackTrace) {
            remaining--;
            if (values != null) {
              if (cleanUp != null) {
                for (let value of values) {
                  if (value != null) {
                    async.Future.sync(dart.fn(() => {
                      cleanUp(value);
                    }, VoidTodynamic$()));
                  }
                }
              }
              values = null;
              if (remaining == 0 || dart.test(eagerError)) {
                result[_completeError](theError, core.StackTrace._check(theStackTrace));
              } else {
                error = theError;
                stackTrace = core.StackTrace._check(theStackTrace);
              }
            } else if (remaining == 0 && !dart.test(eagerError)) {
              result[_completeError](error, stackTrace);
            }
          }
          dart.fn(handleError, dynamicAnddynamicTovoid());
          for (let future of futures) {
            let pos = remaining++;
            future.then(dart.dynamic)(dart.fn(value => {
              remaining--;
              if (values != null) {
                values[dartx.set](pos, value);
                if (remaining == 0) {
                  result[_completeWithValue](values);
                }
              } else {
                if (cleanUp != null && value != null) {
                  async.Future.sync(dart.fn(() => {
                    cleanUp(value);
                  }, VoidTodynamic$()));
                }
                if (remaining == 0 && !dart.test(eagerError)) {
                  result[_completeError](error, stackTrace);
                }
              }
            }, dart.definiteFunctionType(dart.dynamic, [T])), {onError: handleError});
          }
          if (remaining == 0) {
            return async.Future$(core.List$(T)).value(const$3 || (const$3 = dart.constList([], dart.dynamic)));
          }
          values = core.List$(T).new(remaining);
          return result;
        };
      }
      static any(T) {
        return futures => {
          let completer = async.Completer$(T).sync();
          let onValue = dart.fn(value => {
            if (!dart.test(completer.isCompleted)) completer.complete(value);
          }, dart.definiteFunctionType(dart.dynamic, [T]));
          let onError = dart.fn((error, stack) => {
            if (!dart.test(completer.isCompleted)) completer.completeError(error, core.StackTrace._check(stack));
          }, dynamicAnddynamicTodynamic$());
          for (let future of futures) {
            future.then(dart.dynamic)(onValue, {onError: onError});
          }
          return completer.future;
        };
      }
      static forEach(input, f) {
        let iterator = input[dartx.iterator];
        return async.Future.doWhile(dart.fn(() => {
          if (!dart.test(iterator.moveNext())) return false;
          return async.Future.sync(dart.fn(() => dart.dcall(f, iterator.current), VoidTodynamic$())).then(core.bool)(dart.fn(_ => true, dynamicTobool$()));
        }, VoidToObject$()));
      }
      static doWhile(f) {
        let doneSignal = new async._Future();
        let nextIteration = null;
        nextIteration = async.Zone.current.bindUnaryCallback(dart.dynamic, core.bool)(dart.fn(keepGoing => {
          if (dart.test(keepGoing)) {
            async.Future.sync(f).then(dart.dynamic)(dynamicTodynamic()._check(nextIteration), {onError: dart.bind(doneSignal, _completeError)});
          } else {
            doneSignal[_complete](null);
          }
        }, boolTodynamic()), {runGuarded: true});
        dart.dcall(nextIteration, true);
        return doneSignal;
      }
    }
    dart.addTypeTests(Future);
    dart.setSignature(Future, {
      constructors: () => ({
        new: dart.definiteFunctionType(async.Future$(T), [dart.functionType(dart.dynamic, [])]),
        microtask: dart.definiteFunctionType(async.Future$(T), [dart.functionType(dart.dynamic, [])]),
        sync: dart.definiteFunctionType(async.Future$(T), [dart.functionType(dart.dynamic, [])]),
        value: dart.definiteFunctionType(async.Future$(T), [], [dart.dynamic]),
        error: dart.definiteFunctionType(async.Future$(T), [core.Object], [core.StackTrace]),
        delayed: dart.definiteFunctionType(async.Future$(T), [core.Duration], [dart.functionType(dart.dynamic, [])])
      }),
      statics: () => ({
        wait: dart.definiteFunctionType(T => [async.Future$(core.List$(T)), [core.Iterable$(async.Future$(T))], {eagerError: core.bool, cleanUp: dart.functionType(dart.void, [T])}]),
        any: dart.definiteFunctionType(T => [async.Future$(T), [core.Iterable$(async.Future$(T))]]),
        forEach: dart.definiteFunctionType(async.Future, [core.Iterable, dart.functionType(dart.dynamic, [dart.dynamic])]),
        doWhile: dart.definiteFunctionType(async.Future, [dart.functionType(dart.dynamic, [])])
      }),
      names: ['wait', 'any', 'forEach', 'doWhile']
    });
    return Future;
  }));
  async.Future = Future();
  dart.defineLazy(async.Future, {
    get _nullFuture() {
      return async._Future._check(async.Future.value(null));
    }
  });
  async.TimeoutException = class TimeoutException extends core.Object {
    new(message, duration) {
      if (duration === void 0) duration = null;
      this.message = message;
      this.duration = duration;
    }
    toString() {
      let result = "TimeoutException";
      if (this.duration != null) result = dart.str`TimeoutException after ${this.duration}`;
      if (this.message != null) result = dart.str`${result}: ${this.message}`;
      return result;
    }
  };
  async.TimeoutException[dart.implements] = () => [core.Exception];
  dart.setSignature(async.TimeoutException, {
    constructors: () => ({new: dart.definiteFunctionType(async.TimeoutException, [core.String], [core.Duration])})
  });
  async.Completer$ = dart.generic(T => {
    let _AsyncCompleterOfT = () => (_AsyncCompleterOfT = dart.constFn(async._AsyncCompleter$(T)))();
    let _SyncCompleterOfT = () => (_SyncCompleterOfT = dart.constFn(async._SyncCompleter$(T)))();
    class Completer extends core.Object {
      static new() {
        return new (_AsyncCompleterOfT())();
      }
      static sync() {
        return new (_SyncCompleterOfT())();
      }
    }
    dart.addTypeTests(Completer);
    dart.setSignature(Completer, {
      constructors: () => ({
        new: dart.definiteFunctionType(async.Completer$(T), []),
        sync: dart.definiteFunctionType(async.Completer$(T), [])
      })
    });
    return Completer;
  });
  async.Completer = Completer();
  async._completeWithErrorCallback = function(result, error, stackTrace) {
    let replacement = async.Zone.current.errorCallback(error, core.StackTrace._check(stackTrace));
    if (replacement != null) {
      error = async._nonNullError(replacement.error);
      stackTrace = replacement.stackTrace;
    }
    result[_completeError](error, core.StackTrace._check(stackTrace));
  };
  dart.lazyFn(async._completeWithErrorCallback, () => _FutureAnddynamicAnddynamicTovoid());
  async._nonNullError = function(error) {
    return error != null ? error : new core.NullThrownError();
  };
  dart.fn(async._nonNullError, ObjectToObject());
  async._FutureOnValue$ = dart.generic((S, T) => {
    const _FutureOnValue = dart.typedef('_FutureOnValue', () => dart.functionType(dart.dynamic, [S]));
    return _FutureOnValue;
  });
  async._FutureOnValue = _FutureOnValue();
  async._FutureErrorTest = dart.typedef('_FutureErrorTest', () => dart.functionType(core.bool, [dart.dynamic]));
  async._FutureAction = dart.typedef('_FutureAction', () => dart.functionType(dart.dynamic, []));
  async._Completer$ = dart.generic(T => {
    let _FutureOfT = () => (_FutureOfT = dart.constFn(async._Future$(T)))();
    let CompleterOfT = () => (CompleterOfT = dart.constFn(async.Completer$(T)))();
    class _Completer extends core.Object {
      new() {
        this.future = new (_FutureOfT())();
      }
      completeError(error, stackTrace) {
        if (stackTrace === void 0) stackTrace = null;
        error = async._nonNullError(error);
        if (!dart.test(this.future[_mayComplete])) dart.throw(new core.StateError("Future already completed"));
        let replacement = async.Zone.current.errorCallback(error, stackTrace);
        if (replacement != null) {
          error = async._nonNullError(replacement.error);
          stackTrace = replacement.stackTrace;
        }
        this[_completeError](error, stackTrace);
      }
      get isCompleted() {
        return !dart.test(this.future[_mayComplete]);
      }
    }
    dart.addTypeTests(_Completer);
    _Completer[dart.implements] = () => [CompleterOfT()];
    dart.setSignature(_Completer, {
      methods: () => ({completeError: dart.definiteFunctionType(dart.void, [core.Object], [core.StackTrace])})
    });
    return _Completer;
  });
  async._Completer = _Completer();
  const _asyncCompleteError = Symbol('_asyncCompleteError');
  async._AsyncCompleter$ = dart.generic(T => {
    class _AsyncCompleter extends async._Completer$(T) {
      new() {
        super.new();
      }
      complete(value) {
        if (value === void 0) value = null;
        if (!dart.test(this.future[_mayComplete])) dart.throw(new core.StateError("Future already completed"));
        this.future[_asyncComplete](value);
      }
      [_completeError](error, stackTrace) {
        this.future[_asyncCompleteError](error, stackTrace);
      }
    }
    dart.setSignature(_AsyncCompleter, {
      methods: () => ({
        complete: dart.definiteFunctionType(dart.void, [], [dart.dynamic]),
        [_completeError]: dart.definiteFunctionType(dart.void, [core.Object, core.StackTrace])
      })
    });
    return _AsyncCompleter;
  });
  async._AsyncCompleter = _AsyncCompleter();
  async._SyncCompleter$ = dart.generic(T => {
    class _SyncCompleter extends async._Completer$(T) {
      new() {
        super.new();
      }
      complete(value) {
        if (value === void 0) value = null;
        if (!dart.test(this.future[_mayComplete])) dart.throw(new core.StateError("Future already completed"));
        this.future[_complete](value);
      }
      [_completeError](error, stackTrace) {
        this.future[_completeError](error, stackTrace);
      }
    }
    dart.setSignature(_SyncCompleter, {
      methods: () => ({
        complete: dart.definiteFunctionType(dart.void, [], [dart.dynamic]),
        [_completeError]: dart.definiteFunctionType(dart.void, [core.Object, core.StackTrace])
      })
    });
    return _SyncCompleter;
  });
  async._SyncCompleter = _SyncCompleter();
  const _nextListener = Symbol('_nextListener');
  const _onValue = Symbol('_onValue');
  const _errorTest = Symbol('_errorTest');
  const _whenCompleteAction = Symbol('_whenCompleteAction');
  async._FutureListener$ = dart.generic((S, T) => {
    let _FutureOnValueOfS$T = () => (_FutureOnValueOfS$T = dart.constFn(async._FutureOnValue$(S, T)))();
    class _FutureListener extends core.Object {
      then(result, onValue, errorCallback) {
        this.result = result;
        this.callback = onValue;
        this.errorCallback = errorCallback;
        this.state = errorCallback == null ? async._FutureListener.STATE_THEN : async._FutureListener.STATE_THEN_ONERROR;
        this[_nextListener] = null;
      }
      catchError(result, errorCallback, test) {
        this.result = result;
        this.errorCallback = errorCallback;
        this.callback = test;
        this.state = test == null ? async._FutureListener.STATE_CATCHERROR : async._FutureListener.STATE_CATCHERROR_TEST;
        this[_nextListener] = null;
      }
      whenComplete(result, onComplete) {
        this.result = result;
        this.callback = onComplete;
        this.errorCallback = null;
        this.state = async._FutureListener.STATE_WHENCOMPLETE;
        this[_nextListener] = null;
      }
      get [_zone]() {
        return this.result[_zone];
      }
      get handlesValue() {
        return (dart.notNull(this.state) & async._FutureListener.MASK_VALUE) != 0;
      }
      get handlesError() {
        return (dart.notNull(this.state) & async._FutureListener.MASK_ERROR) != 0;
      }
      get hasErrorTest() {
        return this.state == async._FutureListener.STATE_CATCHERROR_TEST;
      }
      get handlesComplete() {
        return this.state == async._FutureListener.STATE_WHENCOMPLETE;
      }
      get [_onValue]() {
        dart.assert(this.handlesValue);
        return _FutureOnValueOfS$T().as(this.callback);
      }
      get [_onError]() {
        return this.errorCallback;
      }
      get [_errorTest]() {
        dart.assert(this.hasErrorTest);
        return async._FutureErrorTest.as(this.callback);
      }
      get [_whenCompleteAction]() {
        dart.assert(this.handlesComplete);
        return async._FutureAction.as(this.callback);
      }
      get hasErrorCallback() {
        dart.assert(this.handlesError);
        return this[_onError] != null;
      }
      handleValue(sourceResult) {
        S._check(sourceResult);
        return this[_zone].runUnary(dart.dynamic, S)(this[_onValue], sourceResult);
      }
      matchesErrorTest(asyncError) {
        if (!dart.test(this.hasErrorTest)) return true;
        let test = this[_errorTest];
        return this[_zone].runUnary(core.bool, dart.dynamic)(this[_errorTest], asyncError.error);
      }
      handleError(asyncError) {
        dart.assert(dart.test(this.handlesError) && dart.test(this.hasErrorCallback));
        if (async.ZoneBinaryCallback.is(this.errorCallback)) {
          let typedErrorCallback = ZoneBinaryCallbackOfObject$Object$StackTrace().as(this.errorCallback);
          return this[_zone].runBinary(core.Object, core.Object, core.StackTrace)(typedErrorCallback, asyncError.error, asyncError.stackTrace);
        } else {
          return this[_zone].runUnary(dart.dynamic, dart.dynamic)(dynamicTodynamic()._check(this.errorCallback), asyncError.error);
        }
      }
      handleWhenComplete() {
        dart.assert(!dart.test(this.handlesError));
        return this[_zone].run(dart.dynamic)(this[_whenCompleteAction]);
      }
    }
    dart.addTypeTests(_FutureListener);
    dart.defineNamedConstructor(_FutureListener, 'then');
    dart.defineNamedConstructor(_FutureListener, 'catchError');
    dart.defineNamedConstructor(_FutureListener, 'whenComplete');
    dart.setSignature(_FutureListener, {
      constructors: () => ({
        then: dart.definiteFunctionType(async._FutureListener$(S, T), [async._Future$(T), async._FutureOnValue$(S, T), core.Function]),
        catchError: dart.definiteFunctionType(async._FutureListener$(S, T), [async._Future$(T), core.Function, async._FutureErrorTest]),
        whenComplete: dart.definiteFunctionType(async._FutureListener$(S, T), [async._Future$(T), async._FutureAction])
      }),
      methods: () => ({
        handleValue: dart.definiteFunctionType(dart.dynamic, [S]),
        matchesErrorTest: dart.definiteFunctionType(core.bool, [async.AsyncError]),
        handleError: dart.definiteFunctionType(dart.dynamic, [async.AsyncError]),
        handleWhenComplete: dart.definiteFunctionType(dart.dynamic, [])
      })
    });
    return _FutureListener;
  });
  async._FutureListener = _FutureListener();
  async._FutureListener.MASK_VALUE = 1;
  async._FutureListener.MASK_ERROR = 2;
  async._FutureListener.MASK_TEST_ERROR = 4;
  async._FutureListener.MASK_WHENCOMPLETE = 8;
  async._FutureListener.STATE_CHAIN = 0;
  async._FutureListener.STATE_THEN_ONERROR = 3;
  async._FutureListener.STATE_CATCHERROR_TEST = 6;
  dart.defineLazy(async._FutureListener, {
    get STATE_THEN() {
      return async._FutureListener.MASK_VALUE;
    },
    get STATE_CATCHERROR() {
      return async._FutureListener.MASK_ERROR;
    },
    get STATE_WHENCOMPLETE() {
      return async._FutureListener.MASK_WHENCOMPLETE;
    }
  });
  const _resultOrListeners = Symbol('_resultOrListeners');
  const _isPendingComplete = Symbol('_isPendingComplete');
  const _mayAddListener = Symbol('_mayAddListener');
  const _isChained = Symbol('_isChained');
  const _isComplete = Symbol('_isComplete');
  const _hasError = Symbol('_hasError');
  const _setChained = Symbol('_setChained');
  const _thenNoZoneRegistration = Symbol('_thenNoZoneRegistration');
  const _setPendingComplete = Symbol('_setPendingComplete');
  const _error = Symbol('_error');
  const _chainSource = Symbol('_chainSource');
  const _setValue = Symbol('_setValue');
  const _setErrorObject = Symbol('_setErrorObject');
  const _setError = Symbol('_setError');
  const _cloneResult = Symbol('_cloneResult');
  const _prependListeners = Symbol('_prependListeners');
  const _reverseListeners = Symbol('_reverseListeners');
  const _removeListeners = Symbol('_removeListeners');
  async._Future$ = dart.flattenFutures(dart.generic(T => {
    let _FutureOfT = () => (_FutureOfT = dart.constFn(async._Future$(T)))();
    let _FutureListenerOfT$T = () => (_FutureListenerOfT$T = dart.constFn(async._FutureListener$(T, T)))();
    let StreamOfT = () => (StreamOfT = dart.constFn(async.Stream$(T)))();
    let FutureOfT = () => (FutureOfT = dart.constFn(async.Future$(T)))();
    let TTodynamic = () => (TTodynamic = dart.constFn(dart.definiteFunctionType(dart.dynamic, [T])))();
    class _Future extends core.Object {
      new() {
        this[_zone] = async.Zone.current;
        this[_state] = async._Future._INCOMPLETE;
        this[_resultOrListeners] = null;
      }
      immediate(value) {
        this[_zone] = async.Zone.current;
        this[_state] = async._Future._INCOMPLETE;
        this[_resultOrListeners] = null;
        this[_asyncComplete](value);
      }
      immediateError(error, stackTrace) {
        if (stackTrace === void 0) stackTrace = null;
        this[_zone] = async.Zone.current;
        this[_state] = async._Future._INCOMPLETE;
        this[_resultOrListeners] = null;
        this[_asyncCompleteError](error, stackTrace);
      }
      get [_mayComplete]() {
        return this[_state] == async._Future._INCOMPLETE;
      }
      get [_isPendingComplete]() {
        return this[_state] == async._Future._PENDING_COMPLETE;
      }
      get [_mayAddListener]() {
        return dart.notNull(this[_state]) <= async._Future._PENDING_COMPLETE;
      }
      get [_isChained]() {
        return this[_state] == async._Future._CHAINED;
      }
      get [_isComplete]() {
        return dart.notNull(this[_state]) >= async._Future._VALUE;
      }
      get [_hasError]() {
        return this[_state] == async._Future._ERROR;
      }
      [_setChained](source) {
        dart.assert(this[_mayAddListener]);
        this[_state] = async._Future._CHAINED;
        this[_resultOrListeners] = source;
      }
      then(E) {
        return (f, opts) => {
          let onError = opts && 'onError' in opts ? opts.onError : null;
          let currentZone = async.Zone.current;
          let registered = null;
          if (!core.identical(currentZone, async._ROOT_ZONE)) {
            f = currentZone.registerUnaryCallback(dart.dynamic, T)(f);
            if (onError != null) {
              onError = async._registerErrorHandler(T)(onError, currentZone);
            }
          }
          return this[_thenNoZoneRegistration](E)(f, onError);
        };
      }
      [_thenNoZoneRegistration](E) {
        return (f, onError) => {
          let result = new (async._Future$(E))();
          this[_addListener](new (async._FutureListener$(T, E)).then(result, f, onError));
          return result;
        };
      }
      catchError(onError, opts) {
        let test = opts && 'test' in opts ? opts.test : null;
        let result = new (_FutureOfT())();
        if (!core.identical(result[_zone], async._ROOT_ZONE)) {
          onError = async._registerErrorHandler(T)(onError, result[_zone]);
          if (test != null) test = result[_zone].registerUnaryCallback(core.bool, dart.dynamic)(test);
        }
        this[_addListener](new (_FutureListenerOfT$T()).catchError(result, onError, test));
        return result;
      }
      whenComplete(action) {
        let result = new (_FutureOfT())();
        if (!core.identical(result[_zone], async._ROOT_ZONE)) {
          action = result[_zone].registerCallback(dart.dynamic)(action);
        }
        this[_addListener](new (_FutureListenerOfT$T()).whenComplete(result, action));
        return result;
      }
      asStream() {
        return StreamOfT().fromFuture(this);
      }
      [_setPendingComplete]() {
        dart.assert(this[_mayComplete]);
        this[_state] = async._Future._PENDING_COMPLETE;
      }
      get [_error]() {
        dart.assert(this[_hasError]);
        return async.AsyncError._check(this[_resultOrListeners]);
      }
      get [_chainSource]() {
        dart.assert(this[_isChained]);
        return async._Future._check(this[_resultOrListeners]);
      }
      [_setValue](value) {
        T._check(value);
        dart.assert(!dart.test(this[_isComplete]));
        this[_state] = async._Future._VALUE;
        this[_resultOrListeners] = value;
      }
      [_setErrorObject](error) {
        dart.assert(!dart.test(this[_isComplete]));
        this[_state] = async._Future._ERROR;
        this[_resultOrListeners] = error;
      }
      [_setError](error, stackTrace) {
        this[_setErrorObject](new async.AsyncError(error, stackTrace));
      }
      [_cloneResult](source) {
        dart.assert(!dart.test(this[_isComplete]));
        dart.assert(source[_isComplete]);
        this[_state] = source[_state];
        this[_resultOrListeners] = source[_resultOrListeners];
      }
      [_addListener](listener) {
        dart.assert(listener[_nextListener] == null);
        if (dart.test(this[_mayAddListener])) {
          listener[_nextListener] = async._FutureListener._check(this[_resultOrListeners]);
          this[_resultOrListeners] = listener;
        } else {
          if (dart.test(this[_isChained])) {
            let source = this[_chainSource];
            if (!dart.test(source[_isComplete])) {
              source[_addListener](listener);
              return;
            }
            this[_cloneResult](source);
          }
          dart.assert(this[_isComplete]);
          this[_zone].scheduleMicrotask(dart.fn(() => {
            async._Future._propagateToListeners(this, listener);
          }, VoidTovoid$()));
        }
      }
      [_prependListeners](listeners) {
        if (listeners == null) return;
        if (dart.test(this[_mayAddListener])) {
          let existingListeners = async._FutureListener._check(this[_resultOrListeners]);
          this[_resultOrListeners] = listeners;
          if (existingListeners != null) {
            let cursor = listeners;
            while (cursor[_nextListener] != null) {
              cursor = cursor[_nextListener];
            }
            cursor[_nextListener] = existingListeners;
          }
        } else {
          if (dart.test(this[_isChained])) {
            let source = this[_chainSource];
            if (!dart.test(source[_isComplete])) {
              source[_prependListeners](listeners);
              return;
            }
            this[_cloneResult](source);
          }
          dart.assert(this[_isComplete]);
          listeners = this[_reverseListeners](listeners);
          this[_zone].scheduleMicrotask(dart.fn(() => {
            async._Future._propagateToListeners(this, listeners);
          }, VoidTovoid$()));
        }
      }
      [_removeListeners]() {
        dart.assert(!dart.test(this[_isComplete]));
        let current = async._FutureListener._check(this[_resultOrListeners]);
        this[_resultOrListeners] = null;
        return this[_reverseListeners](current);
      }
      [_reverseListeners](listeners) {
        let prev = null;
        let current = listeners;
        while (current != null) {
          let next = current[_nextListener];
          current[_nextListener] = prev;
          prev = current;
          current = next;
        }
        return prev;
      }
      static _chainForeignFuture(source, target) {
        dart.assert(!dart.test(target[_isComplete]));
        dart.assert(!async._Future.is(source));
        target[_setPendingComplete]();
        try {
          source.then(dart.dynamic)(dart.fn(value => {
            dart.assert(target[_isPendingComplete]);
            target[_completeWithValue](value);
          }, dynamicTodynamic$()), {onError: dart.fn((error, stackTrace) => {
              if (stackTrace === void 0) stackTrace = null;
              dart.assert(target[_isPendingComplete]);
              target[_completeError](error, core.StackTrace._check(stackTrace));
            }, dynamic__Todynamic())});
        } catch (e) {
          let s = dart.stackTrace(e);
          async.scheduleMicrotask(dart.fn(() => {
            target[_completeError](e, s);
          }, VoidTovoid$()));
        }

      }
      static _chainCoreFuture(source, target) {
        dart.assert(target[_mayAddListener]);
        while (dart.test(source[_isChained])) {
          source = source[_chainSource];
        }
        if (dart.test(source[_isComplete])) {
          let listeners = target[_removeListeners]();
          target[_cloneResult](source);
          async._Future._propagateToListeners(target, listeners);
        } else {
          let listeners = async._FutureListener._check(target[_resultOrListeners]);
          target[_setChained](source);
          source[_prependListeners](listeners);
        }
      }
      [_complete](value) {
        dart.assert(!dart.test(this[_isComplete]));
        if (async.Future.is(value)) {
          if (async._Future.is(value)) {
            async._Future._chainCoreFuture(value, this);
          } else {
            async._Future._chainForeignFuture(value, this);
          }
        } else {
          let listeners = this[_removeListeners]();
          this[_setValue](T.as(value));
          async._Future._propagateToListeners(this, listeners);
        }
      }
      [_completeWithValue](value) {
        T._check(value);
        dart.assert(!dart.test(this[_isComplete]));
        dart.assert(!async.Future.is(value));
        let listeners = this[_removeListeners]();
        this[_setValue](value);
        async._Future._propagateToListeners(this, listeners);
      }
      [_completeError](error, stackTrace) {
        if (stackTrace === void 0) stackTrace = null;
        dart.assert(!dart.test(this[_isComplete]));
        let listeners = this[_removeListeners]();
        this[_setError](error, stackTrace);
        async._Future._propagateToListeners(this, listeners);
      }
      [_asyncComplete](value) {
        dart.assert(!dart.test(this[_isComplete]));
        if (async.Future.is(value)) {
          let typedFuture = FutureOfT().as(value);
          if (async._Future.is(typedFuture)) {
            let coreFuture = _FutureOfT()._check(typedFuture);
            if (dart.test(coreFuture[_hasError])) {
              this[_setPendingComplete]();
              this[_zone].scheduleMicrotask(dart.fn(() => {
                async._Future._chainCoreFuture(coreFuture, this);
              }, VoidTovoid$()));
            } else {
              async._Future._chainCoreFuture(coreFuture, this);
            }
          } else {
            async._Future._chainForeignFuture(typedFuture, this);
          }
          return;
        }
        let typedValue = T.as(value);
        this[_setPendingComplete]();
        this[_zone].scheduleMicrotask(dart.fn(() => {
          this[_completeWithValue](typedValue);
        }, VoidTovoid$()));
      }
      [_asyncCompleteError](error, stackTrace) {
        dart.assert(!dart.test(this[_isComplete]));
        this[_setPendingComplete]();
        this[_zone].scheduleMicrotask(dart.fn(() => {
          this[_completeError](error, stackTrace);
        }, VoidTovoid$()));
      }
      static _propagateToListeners(source, listeners) {
        while (true) {
          dart.assert(source[_isComplete]);
          let hasError = source[_hasError];
          if (listeners == null) {
            if (dart.test(hasError)) {
              let asyncError = source[_error];
              source[_zone].handleUncaughtError(dart.dynamic)(asyncError.error, asyncError.stackTrace);
            }
            return;
          }
          while (listeners[_nextListener] != null) {
            let listener = listeners;
            listeners = listener[_nextListener];
            listener[_nextListener] = null;
            async._Future._propagateToListeners(source, listener);
          }
          let listener = listeners;
          let sourceResult = source[_resultOrListeners];
          let listenerHasError = hasError;
          let listenerValueOrError = sourceResult;
          if (dart.test(hasError) || dart.test(listener.handlesValue) || dart.test(listener.handlesComplete)) {
            let zone = listener[_zone];
            if (dart.test(hasError) && !dart.test(source[_zone].inSameErrorZone(zone))) {
              let asyncError = source[_error];
              source[_zone].handleUncaughtError(dart.dynamic)(asyncError.error, asyncError.stackTrace);
              return;
            }
            let oldZone = null;
            if (!core.identical(async.Zone.current, zone)) {
              oldZone = async.Zone._enter(zone);
            }
            function handleWhenCompleteCallback() {
              dart.assert(!dart.test(listener.handlesValue));
              dart.assert(!dart.test(listener.handlesError));
              let completeResult = null;
              try {
                completeResult = listener.handleWhenComplete();
              } catch (e) {
                let s = dart.stackTrace(e);
                if (dart.test(hasError) && core.identical(source[_error].error, e)) {
                  listenerValueOrError = source[_error];
                } else {
                  listenerValueOrError = new async.AsyncError(e, s);
                }
                listenerHasError = true;
                return;
              }

              if (async.Future.is(completeResult)) {
                if (async._Future.is(completeResult) && dart.test(completeResult[_isComplete])) {
                  if (dart.test(completeResult[_hasError])) {
                    listenerValueOrError = completeResult[_error];
                    listenerHasError = true;
                  }
                  return;
                }
                let originalSource = source;
                listenerValueOrError = completeResult.then(async._Future)(dart.fn(_ => originalSource, dynamicTo_Future()));
                listenerHasError = false;
              }
            }
            dart.fn(handleWhenCompleteCallback, VoidTovoid$());
            function handleValueCallback() {
              try {
                listenerValueOrError = listener.handleValue(sourceResult);
              } catch (e) {
                let s = dart.stackTrace(e);
                listenerValueOrError = new async.AsyncError(e, s);
                listenerHasError = true;
              }

            }
            dart.fn(handleValueCallback, VoidTovoid$());
            function handleError() {
              try {
                let asyncError = source[_error];
                if (dart.test(listener.matchesErrorTest(asyncError)) && dart.test(listener.hasErrorCallback)) {
                  listenerValueOrError = listener.handleError(asyncError);
                  listenerHasError = false;
                }
              } catch (e) {
                let s = dart.stackTrace(e);
                if (core.identical(source[_error].error, e)) {
                  listenerValueOrError = source[_error];
                } else {
                  listenerValueOrError = new async.AsyncError(e, s);
                }
                listenerHasError = true;
              }

            }
            dart.fn(handleError, VoidTovoid$());
            if (dart.test(listener.handlesComplete)) {
              handleWhenCompleteCallback();
            } else if (!dart.test(hasError)) {
              if (dart.test(listener.handlesValue)) {
                handleValueCallback();
              }
            } else {
              if (dart.test(listener.handlesError)) {
                handleError();
              }
            }
            if (oldZone != null) async.Zone._leave(oldZone);
            if (async.Future.is(listenerValueOrError)) {
              let chainSource = async.Future._check(listenerValueOrError);
              let result = listener.result;
              if (async._Future.is(chainSource)) {
                if (dart.test(chainSource[_isComplete])) {
                  listeners = result[_removeListeners]();
                  result[_cloneResult](chainSource);
                  source = chainSource;
                  continue;
                } else {
                  async._Future._chainCoreFuture(chainSource, result);
                }
              } else {
                async._Future._chainForeignFuture(chainSource, result);
              }
              return;
            }
          }
          let result = listener.result;
          listeners = result[_removeListeners]();
          if (!dart.test(listenerHasError)) {
            result[_setValue](listenerValueOrError);
          } else {
            let asyncError = async.AsyncError._check(listenerValueOrError);
            result[_setErrorObject](asyncError);
          }
          source = result;
        }
      }
      timeout(timeLimit, opts) {
        let onTimeout = opts && 'onTimeout' in opts ? opts.onTimeout : null;
        if (dart.test(this[_isComplete])) return new (_FutureOfT()).immediate(this);
        let result = new (_FutureOfT())();
        let timer = null;
        if (onTimeout == null) {
          timer = async.Timer.new(timeLimit, dart.fn(() => {
            result[_completeError](new async.TimeoutException("Future not completed", timeLimit));
          }, VoidTovoid$()));
        } else {
          let zone = async.Zone.current;
          onTimeout = zone.registerCallback(dart.dynamic)(onTimeout);
          timer = async.Timer.new(timeLimit, dart.fn(() => {
            try {
              result[_complete](zone.run(dart.dynamic)(onTimeout));
            } catch (e) {
              let s = dart.stackTrace(e);
              result[_completeError](e, s);
            }

          }, VoidTovoid$()));
        }
        this.then(dart.dynamic)(dart.fn(v => {
          if (dart.test(timer.isActive)) {
            timer.cancel();
            result[_completeWithValue](v);
          }
        }, TTodynamic()), {onError: dart.fn((e, s) => {
            if (dart.test(timer.isActive)) {
              timer.cancel();
              result[_completeError](e, core.StackTrace._check(s));
            }
          }, dynamicAnddynamicTodynamic$())});
        return result;
      }
    }
    dart.addTypeTests(_Future);
    dart.defineNamedConstructor(_Future, 'immediate');
    dart.defineNamedConstructor(_Future, 'immediateError');
    _Future[dart.implements] = () => [FutureOfT()];
    dart.setSignature(_Future, {
      constructors: () => ({
        new: dart.definiteFunctionType(async._Future$(T), []),
        immediate: dart.definiteFunctionType(async._Future$(T), [dart.dynamic]),
        immediateError: dart.definiteFunctionType(async._Future$(T), [dart.dynamic], [core.StackTrace])
      }),
      methods: () => ({
        [_setChained]: dart.definiteFunctionType(dart.void, [async._Future]),
        then: dart.definiteFunctionType(E => [async.Future$(E), [dart.functionType(dart.dynamic, [T])], {onError: core.Function}]),
        [_thenNoZoneRegistration]: dart.definiteFunctionType(E => [async.Future$(E), [dart.functionType(dart.dynamic, [T]), core.Function]]),
        catchError: dart.definiteFunctionType(async.Future$(T), [core.Function], {test: dynamicTobool()}),
        whenComplete: dart.definiteFunctionType(async.Future$(T), [dart.functionType(dart.dynamic, [])]),
        asStream: dart.definiteFunctionType(async.Stream$(T), []),
        [_setPendingComplete]: dart.definiteFunctionType(dart.void, []),
        [_setValue]: dart.definiteFunctionType(dart.void, [T]),
        [_setErrorObject]: dart.definiteFunctionType(dart.void, [async.AsyncError]),
        [_setError]: dart.definiteFunctionType(dart.void, [core.Object, core.StackTrace]),
        [_cloneResult]: dart.definiteFunctionType(dart.void, [async._Future]),
        [_addListener]: dart.definiteFunctionType(dart.void, [async._FutureListener]),
        [_prependListeners]: dart.definiteFunctionType(dart.void, [async._FutureListener]),
        [_removeListeners]: dart.definiteFunctionType(async._FutureListener, []),
        [_reverseListeners]: dart.definiteFunctionType(async._FutureListener, [async._FutureListener]),
        [_complete]: dart.definiteFunctionType(dart.void, [dart.dynamic]),
        [_completeWithValue]: dart.definiteFunctionType(dart.void, [T]),
        [_completeError]: dart.definiteFunctionType(dart.void, [dart.dynamic], [core.StackTrace]),
        [_asyncComplete]: dart.definiteFunctionType(dart.void, [dart.dynamic]),
        [_asyncCompleteError]: dart.definiteFunctionType(dart.void, [dart.dynamic, core.StackTrace]),
        timeout: dart.definiteFunctionType(async.Future$(T), [core.Duration], {onTimeout: VoidTodynamic()})
      }),
      statics: () => ({
        _chainForeignFuture: dart.definiteFunctionType(dart.void, [async.Future, async._Future]),
        _chainCoreFuture: dart.definiteFunctionType(dart.void, [async._Future, async._Future]),
        _propagateToListeners: dart.definiteFunctionType(dart.void, [async._Future, async._FutureListener])
      }),
      names: ['_chainForeignFuture', '_chainCoreFuture', '_propagateToListeners']
    });
    return _Future;
  }));
  async._Future = _Future();
  async._Future._INCOMPLETE = 0;
  async._Future._PENDING_COMPLETE = 1;
  async._Future._CHAINED = 2;
  async._Future._VALUE = 4;
  async._Future._ERROR = 8;
  async._AsyncCallback = dart.typedef('_AsyncCallback', () => dart.functionType(dart.void, []));
  async._AsyncCallbackEntry = class _AsyncCallbackEntry extends core.Object {
    new(callback) {
      this.callback = callback;
      this.next = null;
    }
  };
  dart.setSignature(async._AsyncCallbackEntry, {
    constructors: () => ({new: dart.definiteFunctionType(async._AsyncCallbackEntry, [async._AsyncCallback])})
  });
  async._nextCallback = null;
  async._lastCallback = null;
  async._lastPriorityCallback = null;
  async._isInCallbackLoop = false;
  async._microtaskLoop = function() {
    while (async._nextCallback != null) {
      async._lastPriorityCallback = null;
      let entry = async._nextCallback;
      async._nextCallback = entry.next;
      if (async._nextCallback == null) async._lastCallback = null;
      entry.callback();
    }
  };
  dart.fn(async._microtaskLoop, VoidTovoid$());
  async._startMicrotaskLoop = function() {
    async._isInCallbackLoop = true;
    try {
      async._microtaskLoop();
    } finally {
      async._lastPriorityCallback = null;
      async._isInCallbackLoop = false;
      if (async._nextCallback != null) {
        async._AsyncRun._scheduleImmediate(async._startMicrotaskLoop);
      }
    }
  };
  dart.fn(async._startMicrotaskLoop, VoidTovoid$());
  async._scheduleAsyncCallback = function(callback) {
    let newEntry = new async._AsyncCallbackEntry(callback);
    if (async._nextCallback == null) {
      async._nextCallback = async._lastCallback = newEntry;
      if (!dart.test(async._isInCallbackLoop)) {
        async._AsyncRun._scheduleImmediate(async._startMicrotaskLoop);
      }
    } else {
      async._lastCallback.next = newEntry;
      async._lastCallback = newEntry;
    }
  };
  dart.fn(async._scheduleAsyncCallback, _AsyncCallbackTovoid());
  async._schedulePriorityAsyncCallback = function(callback) {
    if (async._nextCallback == null) {
      async._scheduleAsyncCallback(callback);
      async._lastPriorityCallback = async._lastCallback;
      return;
    }
    let entry = new async._AsyncCallbackEntry(callback);
    if (async._lastPriorityCallback == null) {
      entry.next = async._nextCallback;
      async._nextCallback = async._lastPriorityCallback = entry;
    } else {
      entry.next = async._lastPriorityCallback.next;
      async._lastPriorityCallback.next = entry;
      async._lastPriorityCallback = entry;
      if (entry.next == null) {
        async._lastCallback = entry;
      }
    }
  };
  dart.fn(async._schedulePriorityAsyncCallback, _AsyncCallbackTovoid());
  const _scheduleMicrotask = Symbol('_scheduleMicrotask');
  async.scheduleMicrotask = function(callback) {
    let currentZone = async._Zone._check(async.Zone.current);
    if (core.identical(async._ROOT_ZONE, currentZone)) {
      async._rootScheduleMicrotask(null, null, async._ROOT_ZONE, callback);
      return;
    }
    let implementation = currentZone[_scheduleMicrotask];
    if (core.identical(async._ROOT_ZONE, implementation.zone) && dart.test(async._ROOT_ZONE.inSameErrorZone(currentZone))) {
      async._rootScheduleMicrotask(null, null, currentZone, currentZone.registerCallback(dart.dynamic)(callback));
      return;
    }
    async.Zone.current.scheduleMicrotask(async.Zone.current.bindCallback(dart.dynamic)(callback, {runGuarded: true}));
  };
  dart.fn(async.scheduleMicrotask, _AsyncCallbackTovoid());
  async._AsyncRun = class _AsyncRun extends core.Object {
    static _scheduleImmediate(callback) {
      dart.dcall(async._AsyncRun._scheduleImmediateClosure, callback);
    }
    static _initializeScheduleImmediate() {
      if (self.scheduleImmediate != null) {
        return async._AsyncRun._scheduleImmediateJsOverride;
      }
      if (self.MutationObserver != null && self.document != null) {
        let div = self.document.createElement("div");
        let span = self.document.createElement("span");
        let storedCallback = null;
        function internalCallback(_) {
          _isolate_helper.leaveJsAsync();
          let f = storedCallback;
          storedCallback = null;
          dart.dcall(f);
        }
        dart.fn(internalCallback, dynamicTodynamic$());
        ;
        let observer = new self.MutationObserver(internalCallback);
        observer.observe(div, {childList: true});
        return dart.fn(callback => {
          dart.assert(storedCallback == null);
          _isolate_helper.enterJsAsync();
          storedCallback = callback;
          div.firstChild ? div.removeChild(span) : div.appendChild(span);
        }, FnTodynamic());
      } else if (self.setImmediate != null) {
        return async._AsyncRun._scheduleImmediateWithSetImmediate;
      }
      return async._AsyncRun._scheduleImmediateWithTimer;
    }
    static _scheduleImmediateJsOverride(callback) {
      function internalCallback() {
        _isolate_helper.leaveJsAsync();
        callback();
      }
      dart.fn(internalCallback, VoidTodynamic$());
      ;
      _isolate_helper.enterJsAsync();
      self.scheduleImmediate(internalCallback);
    }
    static _scheduleImmediateWithSetImmediate(callback) {
      function internalCallback() {
        _isolate_helper.leaveJsAsync();
        callback();
      }
      dart.fn(internalCallback, VoidTodynamic$());
      ;
      _isolate_helper.enterJsAsync();
      self.setImmediate(internalCallback);
    }
    static _scheduleImmediateWithTimer(callback) {
      async.Timer._createTimer(core.Duration.ZERO, callback);
    }
  };
  dart.setSignature(async._AsyncRun, {
    statics: () => ({
      _scheduleImmediate: dart.definiteFunctionType(dart.void, [dart.functionType(dart.void, [])]),
      _initializeScheduleImmediate: dart.definiteFunctionType(core.Function, []),
      _scheduleImmediateJsOverride: dart.definiteFunctionType(dart.void, [dart.functionType(dart.void, [])]),
      _scheduleImmediateWithSetImmediate: dart.definiteFunctionType(dart.void, [dart.functionType(dart.void, [])]),
      _scheduleImmediateWithTimer: dart.definiteFunctionType(dart.void, [dart.functionType(dart.void, [])])
    }),
    names: ['_scheduleImmediate', '_initializeScheduleImmediate', '_scheduleImmediateJsOverride', '_scheduleImmediateWithSetImmediate', '_scheduleImmediateWithTimer']
  });
  dart.defineLazy(async._AsyncRun, {
    get _scheduleImmediateClosure() {
      return async._AsyncRun._initializeScheduleImmediate();
    }
  });
  async._TimerCallback = dart.typedef('_TimerCallback', () => dart.functionType(dart.void, []));
  async.StreamSubscription$ = dart.generic(T => {
    class StreamSubscription extends core.Object {}
    dart.addTypeTests(StreamSubscription);
    return StreamSubscription;
  });
  async.StreamSubscription = StreamSubscription();
  async.EventSink$ = dart.generic(T => {
    let SinkOfT = () => (SinkOfT = dart.constFn(core.Sink$(T)))();
    class EventSink extends core.Object {}
    dart.addTypeTests(EventSink);
    EventSink[dart.implements] = () => [SinkOfT()];
    return EventSink;
  });
  async.EventSink = EventSink();
  const _stream = Symbol('_stream');
  async.StreamView$ = dart.generic(T => {
    let StreamSubscriptionOfT = () => (StreamSubscriptionOfT = dart.constFn(async.StreamSubscription$(T)))();
    let StreamSubscriptionOfTTovoid = () => (StreamSubscriptionOfTTovoid = dart.constFn(dart.functionType(dart.void, [StreamSubscriptionOfT()])))();
    class StreamView extends async.Stream$(T) {
      new(stream) {
        this[_stream] = stream;
        super._internal();
      }
      get isBroadcast() {
        return this[_stream].isBroadcast;
      }
      asBroadcastStream(opts) {
        let onListen = opts && 'onListen' in opts ? opts.onListen : null;
        let onCancel = opts && 'onCancel' in opts ? opts.onCancel : null;
        return this[_stream].asBroadcastStream({onListen: onListen, onCancel: onCancel});
      }
      listen(onData, opts) {
        let onError = opts && 'onError' in opts ? opts.onError : null;
        let onDone = opts && 'onDone' in opts ? opts.onDone : null;
        let cancelOnError = opts && 'cancelOnError' in opts ? opts.cancelOnError : null;
        return this[_stream].listen(onData, {onError: onError, onDone: onDone, cancelOnError: cancelOnError});
      }
    }
    dart.setSignature(StreamView, {
      constructors: () => ({new: dart.definiteFunctionType(async.StreamView$(T), [async.Stream$(T)])}),
      methods: () => ({
        asBroadcastStream: dart.definiteFunctionType(async.Stream$(T), [], {onListen: StreamSubscriptionOfTTovoid(), onCancel: StreamSubscriptionOfTTovoid()}),
        listen: dart.definiteFunctionType(async.StreamSubscription$(T), [dart.functionType(dart.void, [T])], {onError: core.Function, onDone: VoidTovoid(), cancelOnError: core.bool})
      })
    });
    return StreamView;
  });
  async.StreamView = StreamView();
  async.StreamConsumer$ = dart.generic(S => {
    class StreamConsumer extends core.Object {}
    dart.addTypeTests(StreamConsumer);
    return StreamConsumer;
  });
  async.StreamConsumer = StreamConsumer();
  async.StreamSink$ = dart.generic(S => {
    let EventSinkOfS = () => (EventSinkOfS = dart.constFn(async.EventSink$(S)))();
    let StreamConsumerOfS = () => (StreamConsumerOfS = dart.constFn(async.StreamConsumer$(S)))();
    class StreamSink extends core.Object {}
    dart.addTypeTests(StreamSink);
    StreamSink[dart.implements] = () => [EventSinkOfS(), StreamConsumerOfS()];
    return StreamSink;
  });
  async.StreamSink = StreamSink();
  async.StreamTransformer$ = dart.generic((S, T) => {
    let _StreamSubscriptionTransformerOfS$T = () => (_StreamSubscriptionTransformerOfS$T = dart.constFn(async._StreamSubscriptionTransformer$(S, T)))();
    let _StreamHandlerTransformerOfS$T = () => (_StreamHandlerTransformerOfS$T = dart.constFn(async._StreamHandlerTransformer$(S, T)))();
    let SAndEventSinkOfTTovoid = () => (SAndEventSinkOfTTovoid = dart.constFn(dart.functionType(dart.void, [S, EventSinkOfT()])))();
    let EventSinkOfT = () => (EventSinkOfT = dart.constFn(async.EventSink$(T)))();
    let ObjectAndStackTraceAndEventSinkOfTTovoid = () => (ObjectAndStackTraceAndEventSinkOfTTovoid = dart.constFn(dart.functionType(dart.void, [core.Object, core.StackTrace, EventSinkOfT()])))();
    let EventSinkOfTTovoid = () => (EventSinkOfTTovoid = dart.constFn(dart.functionType(dart.void, [EventSinkOfT()])))();
    class StreamTransformer extends core.Object {
      static new(transformer) {
        return new (_StreamSubscriptionTransformerOfS$T())(transformer);
      }
      static fromHandlers(opts) {
        return new (_StreamHandlerTransformerOfS$T())(opts);
      }
    }
    dart.addTypeTests(StreamTransformer);
    dart.setSignature(StreamTransformer, {
      constructors: () => ({
        new: dart.definiteFunctionType(async.StreamTransformer$(S, T), [dart.functionType(async.StreamSubscription$(T), [async.Stream$(S), core.bool])]),
        fromHandlers: dart.definiteFunctionType(async.StreamTransformer$(S, T), [], {handleData: SAndEventSinkOfTTovoid(), handleError: ObjectAndStackTraceAndEventSinkOfTTovoid(), handleDone: EventSinkOfTTovoid()})
      })
    });
    return StreamTransformer;
  });
  async.StreamTransformer = StreamTransformer();
  async.StreamIterator$ = dart.generic(T => {
    let _StreamIteratorImplOfT = () => (_StreamIteratorImplOfT = dart.constFn(async._StreamIteratorImpl$(T)))();
    class StreamIterator extends core.Object {
      static new(stream) {
        return new (_StreamIteratorImplOfT())(stream);
      }
    }
    dart.addTypeTests(StreamIterator);
    dart.setSignature(StreamIterator, {
      constructors: () => ({new: dart.definiteFunctionType(async.StreamIterator$(T), [async.Stream$(T)])})
    });
    return StreamIterator;
  });
  async.StreamIterator = StreamIterator();
  async._ControllerEventSinkWrapper$ = dart.generic(T => {
    let EventSinkOfT = () => (EventSinkOfT = dart.constFn(async.EventSink$(T)))();
    class _ControllerEventSinkWrapper extends core.Object {
      new(sink) {
        this[_sink] = sink;
      }
      add(data) {
        T._check(data);
        this[_sink].add(data);
      }
      addError(error, stackTrace) {
        if (stackTrace === void 0) stackTrace = null;
        this[_sink].addError(error, stackTrace);
      }
      close() {
        this[_sink].close();
      }
    }
    dart.addTypeTests(_ControllerEventSinkWrapper);
    _ControllerEventSinkWrapper[dart.implements] = () => [EventSinkOfT()];
    dart.setSignature(_ControllerEventSinkWrapper, {
      constructors: () => ({new: dart.definiteFunctionType(async._ControllerEventSinkWrapper$(T), [async.EventSink])}),
      methods: () => ({
        add: dart.definiteFunctionType(dart.void, [T]),
        addError: dart.definiteFunctionType(dart.void, [dart.dynamic], [core.StackTrace]),
        close: dart.definiteFunctionType(dart.void, [])
      })
    });
    return _ControllerEventSinkWrapper;
  });
  async._ControllerEventSinkWrapper = _ControllerEventSinkWrapper();
  async.ControllerCallback = dart.typedef('ControllerCallback', () => dart.functionType(dart.void, []));
  async.ControllerCancelCallback = dart.typedef('ControllerCancelCallback', () => dart.functionType(dart.dynamic, []));
  async.StreamController$ = dart.generic(T => {
    let _SyncStreamControllerOfT = () => (_SyncStreamControllerOfT = dart.constFn(async._SyncStreamController$(T)))();
    let _AsyncStreamControllerOfT = () => (_AsyncStreamControllerOfT = dart.constFn(async._AsyncStreamController$(T)))();
    let _SyncBroadcastStreamControllerOfT = () => (_SyncBroadcastStreamControllerOfT = dart.constFn(async._SyncBroadcastStreamController$(T)))();
    let _AsyncBroadcastStreamControllerOfT = () => (_AsyncBroadcastStreamControllerOfT = dart.constFn(async._AsyncBroadcastStreamController$(T)))();
    let StreamSinkOfT = () => (StreamSinkOfT = dart.constFn(async.StreamSink$(T)))();
    class StreamController extends core.Object {
      static new(opts) {
        let onListen = opts && 'onListen' in opts ? opts.onListen : null;
        let onPause = opts && 'onPause' in opts ? opts.onPause : null;
        let onResume = opts && 'onResume' in opts ? opts.onResume : null;
        let onCancel = opts && 'onCancel' in opts ? opts.onCancel : null;
        let sync = opts && 'sync' in opts ? opts.sync : false;
        return dart.test(sync) ? new (_SyncStreamControllerOfT())(onListen, onPause, onResume, onCancel) : new (_AsyncStreamControllerOfT())(onListen, onPause, onResume, onCancel);
      }
      static broadcast(opts) {
        let onListen = opts && 'onListen' in opts ? opts.onListen : null;
        let onCancel = opts && 'onCancel' in opts ? opts.onCancel : null;
        let sync = opts && 'sync' in opts ? opts.sync : false;
        return dart.test(sync) ? new (_SyncBroadcastStreamControllerOfT())(onListen, onCancel) : new (_AsyncBroadcastStreamControllerOfT())(onListen, onCancel);
      }
    }
    dart.addTypeTests(StreamController);
    StreamController[dart.implements] = () => [StreamSinkOfT()];
    dart.setSignature(StreamController, {
      constructors: () => ({
        new: dart.definiteFunctionType(async.StreamController$(T), [], {onListen: VoidTovoid(), onPause: VoidTovoid(), onResume: VoidTovoid(), onCancel: VoidTodynamic(), sync: core.bool}),
        broadcast: dart.definiteFunctionType(async.StreamController$(T), [], {onListen: VoidTovoid(), onCancel: VoidTovoid(), sync: core.bool})
      })
    });
    return StreamController;
  });
  async.StreamController = StreamController();
  async.SynchronousStreamController$ = dart.generic(T => {
    let StreamControllerOfT = () => (StreamControllerOfT = dart.constFn(async.StreamController$(T)))();
    class SynchronousStreamController extends core.Object {}
    dart.addTypeTests(SynchronousStreamController);
    SynchronousStreamController[dart.implements] = () => [StreamControllerOfT()];
    return SynchronousStreamController;
  });
  async.SynchronousStreamController = SynchronousStreamController();
  async._StreamControllerLifecycle$ = dart.generic(T => {
    let StreamSubscriptionOfT = () => (StreamSubscriptionOfT = dart.constFn(async.StreamSubscription$(T)))();
    class _StreamControllerLifecycle extends core.Object {
      [_recordPause](subscription) {
        StreamSubscriptionOfT()._check(subscription);
      }
      [_recordResume](subscription) {
        StreamSubscriptionOfT()._check(subscription);
      }
      [_recordCancel](subscription) {
        StreamSubscriptionOfT()._check(subscription);
        return null;
      }
    }
    dart.addTypeTests(_StreamControllerLifecycle);
    dart.setSignature(_StreamControllerLifecycle, {
      methods: () => ({
        [_recordPause]: dart.definiteFunctionType(dart.void, [async.StreamSubscription$(T)]),
        [_recordResume]: dart.definiteFunctionType(dart.void, [async.StreamSubscription$(T)]),
        [_recordCancel]: dart.definiteFunctionType(async.Future, [async.StreamSubscription$(T)])
      })
    });
    return _StreamControllerLifecycle;
  });
  async._StreamControllerLifecycle = _StreamControllerLifecycle();
  const _varData = Symbol('_varData');
  const _isInitialState = Symbol('_isInitialState');
  const _subscription = Symbol('_subscription');
  const _pendingEvents = Symbol('_pendingEvents');
  const _ensurePendingEvents = Symbol('_ensurePendingEvents');
  const _badEventState = Symbol('_badEventState');
  let const$4;
  async._StreamController$ = dart.generic(T => {
    let _ControllerStreamOfT = () => (_ControllerStreamOfT = dart.constFn(async._ControllerStream$(T)))();
    let _StreamSinkWrapperOfT = () => (_StreamSinkWrapperOfT = dart.constFn(async._StreamSinkWrapper$(T)))();
    let _PendingEventsOfT = () => (_PendingEventsOfT = dart.constFn(async._PendingEvents$(T)))();
    let _StreamControllerAddStreamStateOfT = () => (_StreamControllerAddStreamStateOfT = dart.constFn(async._StreamControllerAddStreamState$(T)))();
    let _StreamImplEventsOfT = () => (_StreamImplEventsOfT = dart.constFn(async._StreamImplEvents$(T)))();
    let _ControllerSubscriptionOfT = () => (_ControllerSubscriptionOfT = dart.constFn(async._ControllerSubscription$(T)))();
    let StreamOfT = () => (StreamOfT = dart.constFn(async.Stream$(T)))();
    let _DelayedDataOfT = () => (_DelayedDataOfT = dart.constFn(async._DelayedData$(T)))();
    let StreamSubscriptionOfT = () => (StreamSubscriptionOfT = dart.constFn(async.StreamSubscription$(T)))();
    let StreamControllerOfT = () => (StreamControllerOfT = dart.constFn(async.StreamController$(T)))();
    let _StreamControllerLifecycleOfT = () => (_StreamControllerLifecycleOfT = dart.constFn(async._StreamControllerLifecycle$(T)))();
    let _EventSinkOfT = () => (_EventSinkOfT = dart.constFn(async._EventSink$(T)))();
    let _EventDispatchOfT = () => (_EventDispatchOfT = dart.constFn(async._EventDispatch$(T)))();
    class _StreamController extends core.Object {
      new(onListen, onPause, onResume, onCancel) {
        this.onListen = onListen;
        this.onPause = onPause;
        this.onResume = onResume;
        this.onCancel = onCancel;
        this[_varData] = null;
        this[_state] = async._StreamController._STATE_INITIAL;
        this[_doneFuture] = null;
      }
      get stream() {
        return new (_ControllerStreamOfT())(this);
      }
      get sink() {
        return new (_StreamSinkWrapperOfT())(this);
      }
      get [_isCanceled]() {
        return (dart.notNull(this[_state]) & async._StreamController._STATE_CANCELED) != 0;
      }
      get hasListener() {
        return (dart.notNull(this[_state]) & async._StreamController._STATE_SUBSCRIBED) != 0;
      }
      get [_isInitialState]() {
        return (dart.notNull(this[_state]) & async._StreamController._STATE_SUBSCRIPTION_MASK) == async._StreamController._STATE_INITIAL;
      }
      get isClosed() {
        return (dart.notNull(this[_state]) & async._StreamController._STATE_CLOSED) != 0;
      }
      get isPaused() {
        return dart.test(this.hasListener) ? this[_subscription][_isInputPaused] : !dart.test(this[_isCanceled]);
      }
      get [_isAddingStream]() {
        return (dart.notNull(this[_state]) & async._StreamController._STATE_ADDSTREAM) != 0;
      }
      get [_mayAddEvent]() {
        return dart.notNull(this[_state]) < async._StreamController._STATE_CLOSED;
      }
      get [_pendingEvents]() {
        dart.assert(this[_isInitialState]);
        if (!dart.test(this[_isAddingStream])) {
          return _PendingEventsOfT().as(this[_varData]);
        }
        let state = _StreamControllerAddStreamStateOfT().as(this[_varData]);
        return _PendingEventsOfT().as(state.varData);
      }
      [_ensurePendingEvents]() {
        dart.assert(this[_isInitialState]);
        if (!dart.test(this[_isAddingStream])) {
          if (this[_varData] == null) this[_varData] = new (_StreamImplEventsOfT())();
          return _StreamImplEventsOfT().as(this[_varData]);
        }
        let state = _StreamControllerAddStreamStateOfT().as(this[_varData]);
        if (state.varData == null) state.varData = new (_StreamImplEventsOfT())();
        return _StreamImplEventsOfT().as(state.varData);
      }
      get [_subscription]() {
        dart.assert(this.hasListener);
        if (dart.test(this[_isAddingStream])) {
          let addState = _StreamControllerAddStreamStateOfT().as(this[_varData]);
          return _ControllerSubscriptionOfT().as(addState.varData);
        }
        return _ControllerSubscriptionOfT().as(this[_varData]);
      }
      [_badEventState]() {
        if (dart.test(this.isClosed)) {
          return new core.StateError("Cannot add event after closing");
        }
        dart.assert(this[_isAddingStream]);
        return new core.StateError("Cannot add event while adding a stream");
      }
      addStream(source, opts) {
        StreamOfT()._check(source);
        let cancelOnError = opts && 'cancelOnError' in opts ? opts.cancelOnError : true;
        if (!dart.test(this[_mayAddEvent])) dart.throw(this[_badEventState]());
        if (dart.test(this[_isCanceled])) return new async._Future.immediate(null);
        let addState = new (_StreamControllerAddStreamStateOfT())(this, this[_varData], source, cancelOnError);
        this[_varData] = addState;
        this[_state] = (dart.notNull(this[_state]) | async._StreamController._STATE_ADDSTREAM) >>> 0;
        return addState.addStreamFuture;
      }
      get done() {
        return this[_ensureDoneFuture]();
      }
      [_ensureDoneFuture]() {
        if (this[_doneFuture] == null) {
          this[_doneFuture] = dart.test(this[_isCanceled]) ? async.Future._nullFuture : new async._Future();
        }
        return this[_doneFuture];
      }
      add(value) {
        T._check(value);
        if (!dart.test(this[_mayAddEvent])) dart.throw(this[_badEventState]());
        this[_add$](value);
      }
      addError(error, stackTrace) {
        if (stackTrace === void 0) stackTrace = null;
        if (!dart.test(this[_mayAddEvent])) dart.throw(this[_badEventState]());
        error = async._nonNullError(error);
        let replacement = async.Zone.current.errorCallback(error, stackTrace);
        if (replacement != null) {
          error = async._nonNullError(replacement.error);
          stackTrace = replacement.stackTrace;
        }
        this[_addError](error, stackTrace);
      }
      close() {
        if (dart.test(this.isClosed)) {
          return this[_ensureDoneFuture]();
        }
        if (!dart.test(this[_mayAddEvent])) dart.throw(this[_badEventState]());
        this[_closeUnchecked]();
        return this[_ensureDoneFuture]();
      }
      [_closeUnchecked]() {
        this[_state] = (dart.notNull(this[_state]) | async._StreamController._STATE_CLOSED) >>> 0;
        if (dart.test(this.hasListener)) {
          this[_sendDone]();
        } else if (dart.test(this[_isInitialState])) {
          this[_ensurePendingEvents]().add(const$4 || (const$4 = dart.const(new async._DelayedDone())));
        }
      }
      [_add$](value) {
        T._check(value);
        if (dart.test(this.hasListener)) {
          this[_sendData](value);
        } else if (dart.test(this[_isInitialState])) {
          this[_ensurePendingEvents]().add(new (_DelayedDataOfT())(value));
        }
      }
      [_addError](error, stackTrace) {
        if (dart.test(this.hasListener)) {
          this[_sendError](error, stackTrace);
        } else if (dart.test(this[_isInitialState])) {
          this[_ensurePendingEvents]().add(new async._DelayedError(error, stackTrace));
        }
      }
      [_close$]() {
        dart.assert(this[_isAddingStream]);
        let addState = _StreamControllerAddStreamStateOfT().as(this[_varData]);
        this[_varData] = addState.varData;
        this[_state] = (dart.notNull(this[_state]) & ~async._StreamController._STATE_ADDSTREAM) >>> 0;
        addState.complete();
      }
      [_subscribe](onData, onError, onDone, cancelOnError) {
        if (!dart.test(this[_isInitialState])) {
          dart.throw(new core.StateError("Stream has already been listened to."));
        }
        let subscription = new (_ControllerSubscriptionOfT())(this, onData, onError, onDone, cancelOnError);
        let pendingEvents = this[_pendingEvents];
        this[_state] = (dart.notNull(this[_state]) | async._StreamController._STATE_SUBSCRIBED) >>> 0;
        if (dart.test(this[_isAddingStream])) {
          let addState = _StreamControllerAddStreamStateOfT().as(this[_varData]);
          addState.varData = subscription;
          addState.resume();
        } else {
          this[_varData] = subscription;
        }
        subscription[_setPendingEvents](pendingEvents);
        subscription[_guardCallback](dart.fn(() => {
          async._runGuarded(this.onListen);
        }, VoidTodynamic$()));
        return subscription;
      }
      [_recordCancel](subscription) {
        StreamSubscriptionOfT()._check(subscription);
        let result = null;
        if (dart.test(this[_isAddingStream])) {
          let addState = _StreamControllerAddStreamStateOfT().as(this[_varData]);
          result = addState.cancel();
        }
        this[_varData] = null;
        this[_state] = (dart.notNull(this[_state]) & ~(async._StreamController._STATE_SUBSCRIBED | async._StreamController._STATE_ADDSTREAM) | async._StreamController._STATE_CANCELED) >>> 0;
        if (this.onCancel != null) {
          if (result == null) {
            try {
              result = async.Future._check(this.onCancel());
            } catch (e) {
              let s = dart.stackTrace(e);
              result = new async._Future();
              result[_asyncCompleteError](e, s);
            }

          } else {
            result = result.whenComplete(this.onCancel);
          }
        }
        const complete = (function() {
          if (this[_doneFuture] != null && dart.test(this[_doneFuture][_mayComplete])) {
            this[_doneFuture][_asyncComplete](null);
          }
        }).bind(this);
        dart.fn(complete, VoidTovoid$());
        if (result != null) {
          result = result.whenComplete(complete);
        } else {
          complete();
        }
        return result;
      }
      [_recordPause](subscription) {
        StreamSubscriptionOfT()._check(subscription);
        if (dart.test(this[_isAddingStream])) {
          let addState = _StreamControllerAddStreamStateOfT().as(this[_varData]);
          addState.pause();
        }
        async._runGuarded(this.onPause);
      }
      [_recordResume](subscription) {
        StreamSubscriptionOfT()._check(subscription);
        if (dart.test(this[_isAddingStream])) {
          let addState = _StreamControllerAddStreamStateOfT().as(this[_varData]);
          addState.resume();
        }
        async._runGuarded(this.onResume);
      }
    }
    dart.addTypeTests(_StreamController);
    _StreamController[dart.implements] = () => [StreamControllerOfT(), _StreamControllerLifecycleOfT(), _EventSinkOfT(), _EventDispatchOfT()];
    dart.setSignature(_StreamController, {
      constructors: () => ({new: dart.definiteFunctionType(async._StreamController$(T), [async.ControllerCallback, async.ControllerCallback, async.ControllerCallback, async.ControllerCancelCallback])}),
      methods: () => ({
        [_ensurePendingEvents]: dart.definiteFunctionType(async._StreamImplEvents$(T), []),
        [_badEventState]: dart.definiteFunctionType(core.Error, []),
        addStream: dart.definiteFunctionType(async.Future, [async.Stream$(T)], {cancelOnError: core.bool}),
        [_ensureDoneFuture]: dart.definiteFunctionType(async.Future, []),
        add: dart.definiteFunctionType(dart.void, [T]),
        addError: dart.definiteFunctionType(dart.void, [core.Object], [core.StackTrace]),
        close: dart.definiteFunctionType(async.Future, []),
        [_closeUnchecked]: dart.definiteFunctionType(dart.void, []),
        [_add$]: dart.definiteFunctionType(dart.void, [T]),
        [_addError]: dart.definiteFunctionType(dart.void, [core.Object, core.StackTrace]),
        [_close$]: dart.definiteFunctionType(dart.void, []),
        [_subscribe]: dart.definiteFunctionType(async.StreamSubscription$(T), [dart.functionType(dart.void, [T]), core.Function, dart.functionType(dart.void, []), core.bool]),
        [_recordCancel]: dart.definiteFunctionType(async.Future, [async.StreamSubscription$(T)]),
        [_recordPause]: dart.definiteFunctionType(dart.void, [async.StreamSubscription$(T)]),
        [_recordResume]: dart.definiteFunctionType(dart.void, [async.StreamSubscription$(T)])
      })
    });
    return _StreamController;
  });
  async._StreamController = _StreamController();
  async._StreamController._STATE_INITIAL = 0;
  async._StreamController._STATE_SUBSCRIBED = 1;
  async._StreamController._STATE_CANCELED = 2;
  async._StreamController._STATE_SUBSCRIPTION_MASK = 3;
  async._StreamController._STATE_CLOSED = 4;
  async._StreamController._STATE_ADDSTREAM = 8;
  async._SyncStreamControllerDispatch$ = dart.generic(T => {
    let _StreamControllerOfT = () => (_StreamControllerOfT = dart.constFn(async._StreamController$(T)))();
    let SynchronousStreamControllerOfT = () => (SynchronousStreamControllerOfT = dart.constFn(async.SynchronousStreamController$(T)))();
    class _SyncStreamControllerDispatch extends core.Object {
      [_sendData](data) {
        T._check(data);
        this[_subscription][_add$](data);
      }
      [_sendError](error, stackTrace) {
        this[_subscription][_addError](error, stackTrace);
      }
      [_sendDone]() {
        this[_subscription][_close$]();
      }
    }
    dart.addTypeTests(_SyncStreamControllerDispatch);
    _SyncStreamControllerDispatch[dart.implements] = () => [_StreamControllerOfT(), SynchronousStreamControllerOfT()];
    dart.setSignature(_SyncStreamControllerDispatch, {
      methods: () => ({
        [_sendData]: dart.definiteFunctionType(dart.void, [T]),
        [_sendError]: dart.definiteFunctionType(dart.void, [core.Object, core.StackTrace]),
        [_sendDone]: dart.definiteFunctionType(dart.void, [])
      })
    });
    return _SyncStreamControllerDispatch;
  });
  async._SyncStreamControllerDispatch = _SyncStreamControllerDispatch();
  let const$5;
  async._AsyncStreamControllerDispatch$ = dart.generic(T => {
    let _DelayedDataOfT = () => (_DelayedDataOfT = dart.constFn(async._DelayedData$(T)))();
    let _StreamControllerOfT = () => (_StreamControllerOfT = dart.constFn(async._StreamController$(T)))();
    class _AsyncStreamControllerDispatch extends core.Object {
      [_sendData](data) {
        T._check(data);
        this[_subscription][_addPending](new (_DelayedDataOfT())(data));
      }
      [_sendError](error, stackTrace) {
        this[_subscription][_addPending](new async._DelayedError(error, stackTrace));
      }
      [_sendDone]() {
        this[_subscription][_addPending](const$5 || (const$5 = dart.const(new async._DelayedDone())));
      }
    }
    dart.addTypeTests(_AsyncStreamControllerDispatch);
    _AsyncStreamControllerDispatch[dart.implements] = () => [_StreamControllerOfT()];
    dart.setSignature(_AsyncStreamControllerDispatch, {
      methods: () => ({
        [_sendData]: dart.definiteFunctionType(dart.void, [T]),
        [_sendError]: dart.definiteFunctionType(dart.void, [core.Object, core.StackTrace]),
        [_sendDone]: dart.definiteFunctionType(dart.void, [])
      })
    });
    return _AsyncStreamControllerDispatch;
  });
  async._AsyncStreamControllerDispatch = _AsyncStreamControllerDispatch();
  async._AsyncStreamController$ = dart.generic(T => {
    class _AsyncStreamController extends dart.mixin(async._StreamController$(T), async._AsyncStreamControllerDispatch$(T)) {
      new(onListen, onPause, onResume, onCancel) {
        super.new(onListen, onPause, onResume, onCancel);
      }
    }
    return _AsyncStreamController;
  });
  async._AsyncStreamController = _AsyncStreamController();
  async._SyncStreamController$ = dart.generic(T => {
    class _SyncStreamController extends dart.mixin(async._StreamController$(T), async._SyncStreamControllerDispatch$(T)) {
      new(onListen, onPause, onResume, onCancel) {
        super.new(onListen, onPause, onResume, onCancel);
      }
    }
    return _SyncStreamController;
  });
  async._SyncStreamController = _SyncStreamController();
  async._NotificationHandler = dart.typedef('_NotificationHandler', () => dart.functionType(dart.dynamic, []));
  async._runGuarded = function(notificationHandler) {
    if (notificationHandler == null) return null;
    try {
      let result = notificationHandler();
      if (async.Future.is(result)) return result;
      return null;
    } catch (e) {
      let s = dart.stackTrace(e);
      async.Zone.current.handleUncaughtError(dart.dynamic)(e, s);
    }

  };
  dart.fn(async._runGuarded, _NotificationHandlerToFuture());
  const _target = Symbol('_target');
  async._StreamSinkWrapper$ = dart.generic(T => {
    let StreamOfT = () => (StreamOfT = dart.constFn(async.Stream$(T)))();
    let StreamSinkOfT = () => (StreamSinkOfT = dart.constFn(async.StreamSink$(T)))();
    class _StreamSinkWrapper extends core.Object {
      new(target) {
        this[_target] = target;
      }
      add(data) {
        T._check(data);
        this[_target].add(data);
      }
      addError(error, stackTrace) {
        if (stackTrace === void 0) stackTrace = null;
        this[_target].addError(error, stackTrace);
      }
      close() {
        return this[_target].close();
      }
      addStream(source, opts) {
        StreamOfT()._check(source);
        let cancelOnError = opts && 'cancelOnError' in opts ? opts.cancelOnError : true;
        return this[_target].addStream(source, {cancelOnError: cancelOnError});
      }
      get done() {
        return this[_target].done;
      }
    }
    dart.addTypeTests(_StreamSinkWrapper);
    _StreamSinkWrapper[dart.implements] = () => [StreamSinkOfT()];
    dart.setSignature(_StreamSinkWrapper, {
      constructors: () => ({new: dart.definiteFunctionType(async._StreamSinkWrapper$(T), [async.StreamController])}),
      methods: () => ({
        add: dart.definiteFunctionType(dart.void, [T]),
        addError: dart.definiteFunctionType(dart.void, [core.Object], [core.StackTrace]),
        close: dart.definiteFunctionType(async.Future, []),
        addStream: dart.definiteFunctionType(async.Future, [async.Stream$(T)], {cancelOnError: core.bool})
      })
    });
    return _StreamSinkWrapper;
  });
  async._StreamSinkWrapper = _StreamSinkWrapper();
  async._AddStreamState$ = dart.generic(T => {
    class _AddStreamState extends core.Object {
      new(controller, source, cancelOnError) {
        this.addStreamFuture = new async._Future();
        this.addSubscription = source.listen(dart.bind(controller, _add$), {onError: core.Function._check(dart.test(cancelOnError) ? async._AddStreamState.makeErrorHandler(controller) : dart.bind(controller, _addError)), onDone: dart.bind(controller, _close$), cancelOnError: cancelOnError});
      }
      static makeErrorHandler(controller) {
        return dart.fn((e, s) => {
          controller[_addError](e, s);
          controller[_close$]();
        }, dynamicAndStackTraceTodynamic());
      }
      pause() {
        this.addSubscription.pause();
      }
      resume() {
        this.addSubscription.resume();
      }
      cancel() {
        let cancel = this.addSubscription.cancel();
        if (cancel == null) {
          this.addStreamFuture[_asyncComplete](null);
          return null;
        }
        return cancel.whenComplete(dart.fn(() => {
          this.addStreamFuture[_asyncComplete](null);
        }, VoidTodynamic$()));
      }
      complete() {
        this.addStreamFuture[_asyncComplete](null);
      }
    }
    dart.addTypeTests(_AddStreamState);
    dart.setSignature(_AddStreamState, {
      constructors: () => ({new: dart.definiteFunctionType(async._AddStreamState$(T), [async._EventSink$(T), async.Stream, core.bool])}),
      methods: () => ({
        pause: dart.definiteFunctionType(dart.void, []),
        resume: dart.definiteFunctionType(dart.void, []),
        cancel: dart.definiteFunctionType(async.Future, []),
        complete: dart.definiteFunctionType(dart.void, [])
      }),
      statics: () => ({makeErrorHandler: dart.definiteFunctionType(dart.dynamic, [async._EventSink])}),
      names: ['makeErrorHandler']
    });
    return _AddStreamState;
  });
  async._AddStreamState = _AddStreamState();
  async._StreamControllerAddStreamState$ = dart.generic(T => {
    class _StreamControllerAddStreamState extends async._AddStreamState$(T) {
      new(controller, varData, source, cancelOnError) {
        this.varData = varData;
        super.new(controller, source, cancelOnError);
        if (dart.test(controller.isPaused)) {
          this.addSubscription.pause();
        }
      }
    }
    dart.setSignature(_StreamControllerAddStreamState, {
      constructors: () => ({new: dart.definiteFunctionType(async._StreamControllerAddStreamState$(T), [async._StreamController$(T), dart.dynamic, async.Stream, core.bool])})
    });
    return _StreamControllerAddStreamState;
  });
  async._StreamControllerAddStreamState = _StreamControllerAddStreamState();
  async._EventSink$ = dart.generic(T => {
    class _EventSink extends core.Object {}
    dart.addTypeTests(_EventSink);
    return _EventSink;
  });
  async._EventSink = _EventSink();
  async._EventDispatch$ = dart.generic(T => {
    class _EventDispatch extends core.Object {}
    dart.addTypeTests(_EventDispatch);
    return _EventDispatch;
  });
  async._EventDispatch = _EventDispatch();
  async._EventGenerator$ = dart.generic(T => {
    const _EventGenerator = dart.typedef('_EventGenerator', () => dart.functionType(async._PendingEvents$(T), []));
    return _EventGenerator;
  });
  async._EventGenerator = _EventGenerator();
  const _isUsed = Symbol('_isUsed');
  async._GeneratedStreamImpl$ = dart.generic(T => {
    let _BufferingStreamSubscriptionOfT = () => (_BufferingStreamSubscriptionOfT = dart.constFn(async._BufferingStreamSubscription$(T)))();
    class _GeneratedStreamImpl extends async._StreamImpl$(T) {
      new(pending) {
        this[_pending] = pending;
        this[_isUsed] = false;
      }
      [_createSubscription](onData, onError, onDone, cancelOnError) {
        if (dart.test(this[_isUsed])) dart.throw(new core.StateError("Stream has already been listened to."));
        this[_isUsed] = true;
        let _ = new (_BufferingStreamSubscriptionOfT())(onData, onError, onDone, cancelOnError);
        _[_setPendingEvents](this[_pending]());
        return _;
      }
    }
    dart.setSignature(_GeneratedStreamImpl, {
      constructors: () => ({new: dart.definiteFunctionType(async._GeneratedStreamImpl$(T), [async._EventGenerator$(T)])}),
      methods: () => ({[_createSubscription]: dart.definiteFunctionType(async.StreamSubscription$(T), [dart.functionType(dart.void, [T]), core.Function, dart.functionType(dart.void, []), core.bool])})
    });
    return _GeneratedStreamImpl;
  });
  async._GeneratedStreamImpl = _GeneratedStreamImpl();
  const _iterator$ = Symbol('_iterator');
  const _eventScheduled = Symbol('_eventScheduled');
  async._PendingEvents$ = dart.generic(T => {
    let _EventDispatchOfT = () => (_EventDispatchOfT = dart.constFn(async._EventDispatch$(T)))();
    class _PendingEvents extends core.Object {
      new() {
        this[_state] = async._PendingEvents._STATE_UNSCHEDULED;
      }
      get isScheduled() {
        return this[_state] == async._PendingEvents._STATE_SCHEDULED;
      }
      get [_eventScheduled]() {
        return dart.notNull(this[_state]) >= async._PendingEvents._STATE_SCHEDULED;
      }
      schedule(dispatch) {
        _EventDispatchOfT()._check(dispatch);
        if (dart.test(this.isScheduled)) return;
        dart.assert(!dart.test(this.isEmpty));
        if (dart.test(this[_eventScheduled])) {
          dart.assert(this[_state] == async._PendingEvents._STATE_CANCELED);
          this[_state] = async._PendingEvents._STATE_SCHEDULED;
          return;
        }
        async.scheduleMicrotask(dart.fn(() => {
          let oldState = this[_state];
          this[_state] = async._PendingEvents._STATE_UNSCHEDULED;
          if (oldState == async._PendingEvents._STATE_CANCELED) return;
          this.handleNext(dispatch);
        }, VoidTovoid$()));
        this[_state] = async._PendingEvents._STATE_SCHEDULED;
      }
      cancelSchedule() {
        if (dart.test(this.isScheduled)) this[_state] = async._PendingEvents._STATE_CANCELED;
      }
    }
    dart.addTypeTests(_PendingEvents);
    dart.setSignature(_PendingEvents, {
      methods: () => ({
        schedule: dart.definiteFunctionType(dart.void, [async._EventDispatch$(T)]),
        cancelSchedule: dart.definiteFunctionType(dart.void, [])
      })
    });
    return _PendingEvents;
  });
  async._PendingEvents = _PendingEvents();
  async._PendingEvents._STATE_UNSCHEDULED = 0;
  async._PendingEvents._STATE_SCHEDULED = 1;
  async._PendingEvents._STATE_CANCELED = 3;
  async._IterablePendingEvents$ = dart.generic(T => {
    let _EventDispatchOfT = () => (_EventDispatchOfT = dart.constFn(async._EventDispatch$(T)))();
    class _IterablePendingEvents extends async._PendingEvents$(T) {
      new(data) {
        this[_iterator$] = data[dartx.iterator];
        super.new();
      }
      get isEmpty() {
        return this[_iterator$] == null;
      }
      handleNext(dispatch) {
        _EventDispatchOfT()._check(dispatch);
        if (this[_iterator$] == null) {
          dart.throw(new core.StateError("No events pending."));
        }
        let isDone = null;
        try {
          isDone = !dart.test(this[_iterator$].moveNext());
        } catch (e) {
          let s = dart.stackTrace(e);
          this[_iterator$] = null;
          dispatch[_sendError](e, s);
          return;
        }

        if (!dart.test(isDone)) {
          dispatch[_sendData](this[_iterator$].current);
        } else {
          this[_iterator$] = null;
          dispatch[_sendDone]();
        }
      }
      clear() {
        if (dart.test(this.isScheduled)) this.cancelSchedule();
        this[_iterator$] = null;
      }
    }
    dart.setSignature(_IterablePendingEvents, {
      constructors: () => ({new: dart.definiteFunctionType(async._IterablePendingEvents$(T), [core.Iterable$(T)])}),
      methods: () => ({
        handleNext: dart.definiteFunctionType(dart.void, [async._EventDispatch$(T)]),
        clear: dart.definiteFunctionType(dart.void, [])
      })
    });
    return _IterablePendingEvents;
  });
  async._IterablePendingEvents = _IterablePendingEvents();
  async._DataHandler$ = dart.generic(T => {
    const _DataHandler = dart.typedef('_DataHandler', () => dart.functionType(dart.void, [T]));
    return _DataHandler;
  });
  async._DataHandler = _DataHandler();
  async._DoneHandler = dart.typedef('_DoneHandler', () => dart.functionType(dart.void, []));
  async._nullDataHandler = function(value) {
  };
  dart.fn(async._nullDataHandler, dynamicTovoid$());
  async._nullErrorHandler = function(error, stackTrace) {
    if (stackTrace === void 0) stackTrace = null;
    async.Zone.current.handleUncaughtError(dart.dynamic)(error, stackTrace);
  };
  dart.lazyFn(async._nullErrorHandler, () => dynamic__Tovoid());
  async._nullDoneHandler = function() {
  };
  dart.fn(async._nullDoneHandler, VoidTovoid$());
  async._DelayedEvent$ = dart.generic(T => {
    class _DelayedEvent extends core.Object {
      new() {
        this.next = null;
      }
    }
    dart.addTypeTests(_DelayedEvent);
    return _DelayedEvent;
  });
  async._DelayedEvent = _DelayedEvent();
  async._DelayedData$ = dart.generic(T => {
    let _EventDispatchOfT = () => (_EventDispatchOfT = dart.constFn(async._EventDispatch$(T)))();
    class _DelayedData extends async._DelayedEvent$(T) {
      new(value) {
        this.value = value;
        super.new();
      }
      perform(dispatch) {
        _EventDispatchOfT()._check(dispatch);
        dispatch[_sendData](this.value);
      }
    }
    dart.setSignature(_DelayedData, {
      constructors: () => ({new: dart.definiteFunctionType(async._DelayedData$(T), [T])}),
      methods: () => ({perform: dart.definiteFunctionType(dart.void, [async._EventDispatch$(T)])})
    });
    return _DelayedData;
  });
  async._DelayedData = _DelayedData();
  async._DelayedError = class _DelayedError extends async._DelayedEvent {
    new(error, stackTrace) {
      this.error = error;
      this.stackTrace = stackTrace;
      super.new();
    }
    perform(dispatch) {
      dispatch[_sendError](this.error, this.stackTrace);
    }
  };
  dart.addSimpleTypeTests(async._DelayedError);
  dart.setSignature(async._DelayedError, {
    constructors: () => ({new: dart.definiteFunctionType(async._DelayedError, [dart.dynamic, core.StackTrace])}),
    methods: () => ({perform: dart.definiteFunctionType(dart.void, [async._EventDispatch])})
  });
  async._DelayedDone = class _DelayedDone extends core.Object {
    new() {
    }
    perform(dispatch) {
      dispatch[_sendDone]();
    }
    get next() {
      return null;
    }
    set next(_) {
      dart.throw(new core.StateError("No events after a done."));
    }
  };
  async._DelayedDone[dart.implements] = () => [async._DelayedEvent];
  dart.setSignature(async._DelayedDone, {
    constructors: () => ({new: dart.definiteFunctionType(async._DelayedDone, [])}),
    methods: () => ({perform: dart.definiteFunctionType(dart.void, [async._EventDispatch])})
  });
  async._StreamImplEvents$ = dart.generic(T => {
    let _EventDispatchOfT = () => (_EventDispatchOfT = dart.constFn(async._EventDispatch$(T)))();
    class _StreamImplEvents extends async._PendingEvents$(T) {
      new() {
        this.firstPendingEvent = null;
        this.lastPendingEvent = null;
        super.new();
      }
      get isEmpty() {
        return this.lastPendingEvent == null;
      }
      add(event) {
        if (this.lastPendingEvent == null) {
          this.firstPendingEvent = this.lastPendingEvent = event;
        } else {
          this.lastPendingEvent = this.lastPendingEvent.next = event;
        }
      }
      handleNext(dispatch) {
        _EventDispatchOfT()._check(dispatch);
        dart.assert(!dart.test(this.isScheduled));
        let event = this.firstPendingEvent;
        this.firstPendingEvent = event.next;
        if (this.firstPendingEvent == null) {
          this.lastPendingEvent = null;
        }
        event.perform(dispatch);
      }
      clear() {
        if (dart.test(this.isScheduled)) this.cancelSchedule();
        this.firstPendingEvent = this.lastPendingEvent = null;
      }
    }
    dart.setSignature(_StreamImplEvents, {
      methods: () => ({
        add: dart.definiteFunctionType(dart.void, [async._DelayedEvent]),
        handleNext: dart.definiteFunctionType(dart.void, [async._EventDispatch$(T)]),
        clear: dart.definiteFunctionType(dart.void, [])
      })
    });
    return _StreamImplEvents;
  });
  async._StreamImplEvents = _StreamImplEvents();
  const _unlink = Symbol('_unlink');
  const _insertBefore = Symbol('_insertBefore');
  async._BroadcastLinkedList = class _BroadcastLinkedList extends core.Object {
    new() {
      this[_next$] = null;
      this[_previous$] = null;
    }
    [_unlink]() {
      this[_previous$][_next$] = this[_next$];
      this[_next$][_previous$] = this[_previous$];
      this[_next$] = this[_previous$] = this;
    }
    [_insertBefore](newNext) {
      let newPrevious = newNext[_previous$];
      newPrevious[_next$] = this;
      newNext[_previous$] = this[_previous$];
      this[_previous$][_next$] = newNext;
      this[_previous$] = newPrevious;
    }
  };
  dart.setSignature(async._BroadcastLinkedList, {
    methods: () => ({
      [_unlink]: dart.definiteFunctionType(dart.void, []),
      [_insertBefore]: dart.definiteFunctionType(dart.void, [async._BroadcastLinkedList])
    })
  });
  async._BroadcastCallback$ = dart.generic(T => {
    const _BroadcastCallback = dart.typedef('_BroadcastCallback', () => dart.functionType(dart.void, [async.StreamSubscription$(T)]));
    return _BroadcastCallback;
  });
  async._BroadcastCallback = _BroadcastCallback();
  const _schedule = Symbol('_schedule');
  const _isSent = Symbol('_isSent');
  const _isScheduled = Symbol('_isScheduled');
  async._DoneStreamSubscription$ = dart.generic(T => {
    let StreamSubscriptionOfT = () => (StreamSubscriptionOfT = dart.constFn(async.StreamSubscription$(T)))();
    class _DoneStreamSubscription extends core.Object {
      new(onDone) {
        this[_onDone] = onDone;
        this[_zone] = async.Zone.current;
        this[_state] = 0;
        this[_schedule]();
      }
      get [_isSent]() {
        return (dart.notNull(this[_state]) & async._DoneStreamSubscription._DONE_SENT) != 0;
      }
      get [_isScheduled]() {
        return (dart.notNull(this[_state]) & async._DoneStreamSubscription._SCHEDULED) != 0;
      }
      get isPaused() {
        return dart.notNull(this[_state]) >= async._DoneStreamSubscription._PAUSED;
      }
      [_schedule]() {
        if (dart.test(this[_isScheduled])) return;
        this[_zone].scheduleMicrotask(dart.bind(this, _sendDone));
        this[_state] = (dart.notNull(this[_state]) | async._DoneStreamSubscription._SCHEDULED) >>> 0;
      }
      onData(handleData) {}
      onError(handleError) {}
      onDone(handleDone) {
        this[_onDone] = handleDone;
      }
      pause(resumeSignal) {
        if (resumeSignal === void 0) resumeSignal = null;
        this[_state] = dart.notNull(this[_state]) + async._DoneStreamSubscription._PAUSED;
        if (resumeSignal != null) resumeSignal.whenComplete(dart.bind(this, 'resume'));
      }
      resume() {
        if (dart.test(this.isPaused)) {
          this[_state] = dart.notNull(this[_state]) - async._DoneStreamSubscription._PAUSED;
          if (!dart.test(this.isPaused) && !dart.test(this[_isSent])) {
            this[_schedule]();
          }
        }
      }
      cancel() {
        return null;
      }
      asFuture(E) {
        return futureValue => {
          if (futureValue === void 0) futureValue = null;
          let result = new (async._Future$(E))();
          this[_onDone] = dart.fn(() => {
            result[_completeWithValue](null);
          }, VoidTovoid$());
          return result;
        };
      }
      [_sendDone]() {
        this[_state] = (dart.notNull(this[_state]) & ~async._DoneStreamSubscription._SCHEDULED) >>> 0;
        if (dart.test(this.isPaused)) return;
        this[_state] = (dart.notNull(this[_state]) | async._DoneStreamSubscription._DONE_SENT) >>> 0;
        if (this[_onDone] != null) this[_zone].runGuarded(dart.dynamic)(this[_onDone]);
      }
    }
    dart.addTypeTests(_DoneStreamSubscription);
    _DoneStreamSubscription[dart.implements] = () => [StreamSubscriptionOfT()];
    dart.setSignature(_DoneStreamSubscription, {
      constructors: () => ({new: dart.definiteFunctionType(async._DoneStreamSubscription$(T), [async._DoneHandler])}),
      methods: () => ({
        [_schedule]: dart.definiteFunctionType(dart.void, []),
        onData: dart.definiteFunctionType(dart.void, [dart.functionType(dart.void, [T])]),
        onError: dart.definiteFunctionType(dart.void, [core.Function]),
        onDone: dart.definiteFunctionType(dart.void, [dart.functionType(dart.void, [])]),
        pause: dart.definiteFunctionType(dart.void, [], [async.Future]),
        resume: dart.definiteFunctionType(dart.void, []),
        cancel: dart.definiteFunctionType(async.Future, []),
        asFuture: dart.definiteFunctionType(E => [async.Future$(E), [], [E]]),
        [_sendDone]: dart.definiteFunctionType(dart.void, [])
      })
    });
    return _DoneStreamSubscription;
  });
  async._DoneStreamSubscription = _DoneStreamSubscription();
  async._DoneStreamSubscription._DONE_SENT = 1;
  async._DoneStreamSubscription._SCHEDULED = 2;
  async._DoneStreamSubscription._PAUSED = 4;
  const _source$ = Symbol('_source');
  const _onListenHandler = Symbol('_onListenHandler');
  const _onCancelHandler = Symbol('_onCancelHandler');
  const _cancelSubscription = Symbol('_cancelSubscription');
  const _pauseSubscription = Symbol('_pauseSubscription');
  const _resumeSubscription = Symbol('_resumeSubscription');
  const _isSubscriptionPaused = Symbol('_isSubscriptionPaused');
  async._AsBroadcastStream$ = dart.generic(T => {
    let StreamSubscriptionOfT = () => (StreamSubscriptionOfT = dart.constFn(async.StreamSubscription$(T)))();
    let _AsBroadcastStreamControllerOfT = () => (_AsBroadcastStreamControllerOfT = dart.constFn(async._AsBroadcastStreamController$(T)))();
    let _DoneStreamSubscriptionOfT = () => (_DoneStreamSubscriptionOfT = dart.constFn(async._DoneStreamSubscription$(T)))();
    let _BroadcastSubscriptionWrapperOfT = () => (_BroadcastSubscriptionWrapperOfT = dart.constFn(async._BroadcastSubscriptionWrapper$(T)))();
    class _AsBroadcastStream extends async.Stream$(T) {
      new(source, onListenHandler, onCancelHandler) {
        this[_source$] = source;
        this[_onListenHandler] = async.Zone.current.registerUnaryCallback(dart.dynamic, StreamSubscriptionOfT())(onListenHandler);
        this[_onCancelHandler] = async.Zone.current.registerUnaryCallback(dart.dynamic, StreamSubscriptionOfT())(onCancelHandler);
        this[_zone] = async.Zone.current;
        this[_controller$] = null;
        this[_subscription] = null;
        super.new();
        this[_controller$] = new (_AsBroadcastStreamControllerOfT())(dart.bind(this, _onListen), dart.bind(this, _onCancel));
      }
      get isBroadcast() {
        return true;
      }
      listen(onData, opts) {
        let onError = opts && 'onError' in opts ? opts.onError : null;
        let onDone = opts && 'onDone' in opts ? opts.onDone : null;
        let cancelOnError = opts && 'cancelOnError' in opts ? opts.cancelOnError : null;
        if (this[_controller$] == null || dart.test(this[_controller$].isClosed)) {
          return new (_DoneStreamSubscriptionOfT())(onDone);
        }
        if (this[_subscription] == null) {
          this[_subscription] = this[_source$].listen(dart.bind(this[_controller$], 'add'), {onError: dart.bind(this[_controller$], 'addError'), onDone: dart.bind(this[_controller$], 'close')});
        }
        cancelOnError = core.identical(true, cancelOnError);
        return this[_controller$][_subscribe](onData, onError, onDone, cancelOnError);
      }
      [_onCancel]() {
        let shutdown = this[_controller$] == null || dart.test(this[_controller$].isClosed);
        if (this[_onCancelHandler] != null) {
          this[_zone].runUnary(dart.dynamic, _BroadcastSubscriptionWrapperOfT())(this[_onCancelHandler], new (_BroadcastSubscriptionWrapperOfT())(this));
        }
        if (shutdown) {
          if (this[_subscription] != null) {
            this[_subscription].cancel();
            this[_subscription] = null;
          }
        }
      }
      [_onListen]() {
        if (this[_onListenHandler] != null) {
          this[_zone].runUnary(dart.dynamic, _BroadcastSubscriptionWrapperOfT())(this[_onListenHandler], new (_BroadcastSubscriptionWrapperOfT())(this));
        }
      }
      [_cancelSubscription]() {
        if (this[_subscription] == null) return;
        let subscription = this[_subscription];
        this[_subscription] = null;
        this[_controller$] = null;
        subscription.cancel();
      }
      [_pauseSubscription](resumeSignal) {
        if (this[_subscription] == null) return;
        this[_subscription].pause(resumeSignal);
      }
      [_resumeSubscription]() {
        if (this[_subscription] == null) return;
        this[_subscription].resume();
      }
      get [_isSubscriptionPaused]() {
        if (this[_subscription] == null) return false;
        return this[_subscription].isPaused;
      }
    }
    dart.setSignature(_AsBroadcastStream, {
      constructors: () => ({new: dart.definiteFunctionType(async._AsBroadcastStream$(T), [async.Stream$(T), dart.functionType(dart.void, [async.StreamSubscription$(T)]), dart.functionType(dart.void, [async.StreamSubscription$(T)])])}),
      methods: () => ({
        listen: dart.definiteFunctionType(async.StreamSubscription$(T), [dart.functionType(dart.void, [T])], {onError: core.Function, onDone: VoidTovoid(), cancelOnError: core.bool}),
        [_onCancel]: dart.definiteFunctionType(dart.void, []),
        [_onListen]: dart.definiteFunctionType(dart.void, []),
        [_cancelSubscription]: dart.definiteFunctionType(dart.void, []),
        [_pauseSubscription]: dart.definiteFunctionType(dart.void, [async.Future]),
        [_resumeSubscription]: dart.definiteFunctionType(dart.void, [])
      })
    });
    return _AsBroadcastStream;
  });
  async._AsBroadcastStream = _AsBroadcastStream();
  async._BroadcastSubscriptionWrapper$ = dart.generic(T => {
    let StreamSubscriptionOfT = () => (StreamSubscriptionOfT = dart.constFn(async.StreamSubscription$(T)))();
    class _BroadcastSubscriptionWrapper extends core.Object {
      new(stream) {
        this[_stream] = stream;
      }
      onData(handleData) {
        dart.throw(new core.UnsupportedError("Cannot change handlers of asBroadcastStream source subscription."));
      }
      onError(handleError) {
        dart.throw(new core.UnsupportedError("Cannot change handlers of asBroadcastStream source subscription."));
      }
      onDone(handleDone) {
        dart.throw(new core.UnsupportedError("Cannot change handlers of asBroadcastStream source subscription."));
      }
      pause(resumeSignal) {
        if (resumeSignal === void 0) resumeSignal = null;
        this[_stream][_pauseSubscription](resumeSignal);
      }
      resume() {
        this[_stream][_resumeSubscription]();
      }
      cancel() {
        this[_stream][_cancelSubscription]();
        return null;
      }
      get isPaused() {
        return this[_stream][_isSubscriptionPaused];
      }
      asFuture(E) {
        return futureValue => {
          if (futureValue === void 0) futureValue = null;
          dart.throw(new core.UnsupportedError("Cannot change handlers of asBroadcastStream source subscription."));
        };
      }
    }
    dart.addTypeTests(_BroadcastSubscriptionWrapper);
    _BroadcastSubscriptionWrapper[dart.implements] = () => [StreamSubscriptionOfT()];
    dart.setSignature(_BroadcastSubscriptionWrapper, {
      constructors: () => ({new: dart.definiteFunctionType(async._BroadcastSubscriptionWrapper$(T), [async._AsBroadcastStream])}),
      methods: () => ({
        onData: dart.definiteFunctionType(dart.void, [dart.functionType(dart.void, [T])]),
        onError: dart.definiteFunctionType(dart.void, [core.Function]),
        onDone: dart.definiteFunctionType(dart.void, [dart.functionType(dart.void, [])]),
        pause: dart.definiteFunctionType(dart.void, [], [async.Future]),
        resume: dart.definiteFunctionType(dart.void, []),
        cancel: dart.definiteFunctionType(async.Future, []),
        asFuture: dart.definiteFunctionType(E => [async.Future$(E), [], [E]])
      })
    });
    return _BroadcastSubscriptionWrapper;
  });
  async._BroadcastSubscriptionWrapper = _BroadcastSubscriptionWrapper();
  const _current$1 = Symbol('_current');
  const _futureOrPrefetch = Symbol('_futureOrPrefetch');
  const _clear = Symbol('_clear');
  async._StreamIteratorImpl$ = dart.generic(T => {
    let StreamIteratorOfT = () => (StreamIteratorOfT = dart.constFn(async.StreamIterator$(T)))();
    class _StreamIteratorImpl extends core.Object {
      new(stream) {
        this[_subscription] = null;
        this[_current$1] = null;
        this[_futureOrPrefetch] = null;
        this[_state] = async._StreamIteratorImpl._STATE_FOUND;
        this[_subscription] = stream.listen(dart.bind(this, _onData), {onError: dart.bind(this, _onError), onDone: dart.bind(this, _onDone), cancelOnError: true});
      }
      get current() {
        return this[_current$1];
      }
      moveNext() {
        if (this[_state] == async._StreamIteratorImpl._STATE_DONE) {
          return new (_FutureOfbool()).immediate(false);
        }
        if (this[_state] == async._StreamIteratorImpl._STATE_MOVING) {
          dart.throw(new core.StateError("Already waiting for next."));
        }
        if (this[_state] == async._StreamIteratorImpl._STATE_FOUND) {
          this[_state] = async._StreamIteratorImpl._STATE_MOVING;
          this[_current$1] = null;
          let result = new (_FutureOfbool())();
          this[_futureOrPrefetch] = result;
          return result;
        } else {
          dart.assert(dart.notNull(this[_state]) >= async._StreamIteratorImpl._STATE_EXTRA_DATA);
          switch (this[_state]) {
            case async._StreamIteratorImpl._STATE_EXTRA_DATA:
            {
              this[_state] = async._StreamIteratorImpl._STATE_FOUND;
              this[_current$1] = T.as(this[_futureOrPrefetch]);
              this[_futureOrPrefetch] = null;
              this[_subscription].resume();
              return new (_FutureOfbool()).immediate(true);
            }
            case async._StreamIteratorImpl._STATE_EXTRA_ERROR:
            {
              let prefetch = async.AsyncError._check(this[_futureOrPrefetch]);
              this[_clear]();
              return new (_FutureOfbool()).immediateError(prefetch.error, prefetch.stackTrace);
            }
            case async._StreamIteratorImpl._STATE_EXTRA_DONE:
            {
              this[_clear]();
              return new (_FutureOfbool()).immediate(false);
            }
          }
        }
      }
      [_clear]() {
        this[_subscription] = null;
        this[_futureOrPrefetch] = null;
        this[_current$1] = null;
        this[_state] = async._StreamIteratorImpl._STATE_DONE;
      }
      cancel() {
        let subscription = this[_subscription];
        if (subscription == null) return null;
        if (this[_state] == async._StreamIteratorImpl._STATE_MOVING) {
          let hasNext = _FutureOfbool().as(this[_futureOrPrefetch]);
          this[_clear]();
          hasNext[_complete](false);
        } else {
          this[_clear]();
        }
        return subscription.cancel();
      }
      [_onData](data) {
        T._check(data);
        if (this[_state] == async._StreamIteratorImpl._STATE_MOVING) {
          this[_current$1] = data;
          let hasNext = _FutureOfbool().as(this[_futureOrPrefetch]);
          this[_futureOrPrefetch] = null;
          this[_state] = async._StreamIteratorImpl._STATE_FOUND;
          hasNext[_complete](true);
          return;
        }
        this[_subscription].pause();
        dart.assert(this[_futureOrPrefetch] == null);
        this[_futureOrPrefetch] = data;
        this[_state] = async._StreamIteratorImpl._STATE_EXTRA_DATA;
      }
      [_onError](error, stackTrace) {
        if (stackTrace === void 0) stackTrace = null;
        if (this[_state] == async._StreamIteratorImpl._STATE_MOVING) {
          let hasNext = _FutureOfbool().as(this[_futureOrPrefetch]);
          this[_clear]();
          hasNext[_completeError](error, stackTrace);
          return;
        }
        this[_subscription].pause();
        dart.assert(this[_futureOrPrefetch] == null);
        this[_futureOrPrefetch] = new async.AsyncError(error, stackTrace);
        this[_state] = async._StreamIteratorImpl._STATE_EXTRA_ERROR;
      }
      [_onDone]() {
        if (this[_state] == async._StreamIteratorImpl._STATE_MOVING) {
          let hasNext = _FutureOfbool().as(this[_futureOrPrefetch]);
          this[_clear]();
          hasNext[_complete](false);
          return;
        }
        this[_subscription].pause();
        this[_futureOrPrefetch] = null;
        this[_state] = async._StreamIteratorImpl._STATE_EXTRA_DONE;
      }
    }
    dart.addTypeTests(_StreamIteratorImpl);
    _StreamIteratorImpl[dart.implements] = () => [StreamIteratorOfT()];
    dart.setSignature(_StreamIteratorImpl, {
      constructors: () => ({new: dart.definiteFunctionType(async._StreamIteratorImpl$(T), [async.Stream$(T)])}),
      methods: () => ({
        moveNext: dart.definiteFunctionType(async.Future$(core.bool), []),
        [_clear]: dart.definiteFunctionType(dart.void, []),
        cancel: dart.definiteFunctionType(async.Future, []),
        [_onData]: dart.definiteFunctionType(dart.void, [T]),
        [_onError]: dart.definiteFunctionType(dart.void, [core.Object], [core.StackTrace]),
        [_onDone]: dart.definiteFunctionType(dart.void, [])
      })
    });
    return _StreamIteratorImpl;
  });
  async._StreamIteratorImpl = _StreamIteratorImpl();
  async._StreamIteratorImpl._STATE_FOUND = 0;
  async._StreamIteratorImpl._STATE_DONE = 1;
  async._StreamIteratorImpl._STATE_MOVING = 2;
  async._StreamIteratorImpl._STATE_EXTRA_DATA = 3;
  async._StreamIteratorImpl._STATE_EXTRA_ERROR = 4;
  async._StreamIteratorImpl._STATE_EXTRA_DONE = 5;
  async._EmptyStream$ = dart.generic(T => {
    let _DoneStreamSubscriptionOfT = () => (_DoneStreamSubscriptionOfT = dart.constFn(async._DoneStreamSubscription$(T)))();
    class _EmptyStream extends async.Stream$(T) {
      new() {
        super._internal();
      }
      get isBroadcast() {
        return true;
      }
      listen(onData, opts) {
        let onError = opts && 'onError' in opts ? opts.onError : null;
        let onDone = opts && 'onDone' in opts ? opts.onDone : null;
        let cancelOnError = opts && 'cancelOnError' in opts ? opts.cancelOnError : null;
        return new (_DoneStreamSubscriptionOfT())(onDone);
      }
    }
    dart.setSignature(_EmptyStream, {
      constructors: () => ({new: dart.definiteFunctionType(async._EmptyStream$(T), [])}),
      methods: () => ({listen: dart.definiteFunctionType(async.StreamSubscription$(T), [dart.functionType(dart.void, [T])], {onError: core.Function, onDone: VoidTovoid(), cancelOnError: core.bool})})
    });
    return _EmptyStream;
  });
  async._EmptyStream = _EmptyStream();
  async._runUserCode = function(userCode, onSuccess, onError) {
    try {
      dart.dcall(onSuccess, userCode());
    } catch (e) {
      let s = dart.stackTrace(e);
      let replacement = async.Zone.current.errorCallback(e, s);
      if (replacement == null) {
        dart.dcall(onError, e, s);
      } else {
        let error = async._nonNullError(replacement.error);
        let stackTrace = replacement.stackTrace;
        dart.dcall(onError, error, stackTrace);
      }
    }

  };
  dart.lazyFn(async._runUserCode, () => FnAndFnAndFnTodynamic());
  async._cancelAndError = function(subscription, future, error, stackTrace) {
    let cancelFuture = subscription.cancel();
    if (async.Future.is(cancelFuture)) {
      cancelFuture.whenComplete(dart.fn(() => future[_completeError](error, stackTrace), VoidTovoid$()));
    } else {
      future[_completeError](error, stackTrace);
    }
  };
  dart.lazyFn(async._cancelAndError, () => StreamSubscriptionAnd_FutureAnddynamic__Tovoid());
  async._cancelAndErrorWithReplacement = function(subscription, future, error, stackTrace) {
    let replacement = async.Zone.current.errorCallback(error, stackTrace);
    if (replacement != null) {
      error = async._nonNullError(replacement.error);
      stackTrace = replacement.stackTrace;
    }
    async._cancelAndError(subscription, future, error, stackTrace);
  };
  dart.lazyFn(async._cancelAndErrorWithReplacement, () => StreamSubscriptionAnd_FutureAnddynamic__Tovoid());
  async._ErrorCallback = dart.typedef('_ErrorCallback', () => dart.functionType(dart.void, [dart.dynamic, core.StackTrace]));
  async._cancelAndErrorClosure = function(subscription, future) {
    return dart.fn((error, stackTrace) => {
      async._cancelAndError(subscription, future, error, stackTrace);
    }, dynamicAndStackTraceTovoid());
  };
  dart.fn(async._cancelAndErrorClosure, StreamSubscriptionAnd_FutureTo_ErrorCallback());
  async._cancelAndValue = function(subscription, future, value) {
    let cancelFuture = subscription.cancel();
    if (async.Future.is(cancelFuture)) {
      cancelFuture.whenComplete(dart.fn(() => future[_complete](value), VoidTovoid$()));
    } else {
      future[_complete](value);
    }
  };
  dart.fn(async._cancelAndValue, StreamSubscriptionAnd_FutureAnddynamicTovoid());
  const _handleData = Symbol('_handleData');
  const _handleError = Symbol('_handleError');
  const _handleDone = Symbol('_handleDone');
  async._ForwardingStream$ = dart.generic((S, T) => {
    let _ForwardingStreamSubscriptionOfS$T = () => (_ForwardingStreamSubscriptionOfS$T = dart.constFn(async._ForwardingStreamSubscription$(S, T)))();
    let _EventSinkOfT = () => (_EventSinkOfT = dart.constFn(async._EventSink$(T)))();
    class _ForwardingStream extends async.Stream$(T) {
      new(source) {
        this[_source$] = source;
        super.new();
      }
      get isBroadcast() {
        return this[_source$].isBroadcast;
      }
      listen(onData, opts) {
        let onError = opts && 'onError' in opts ? opts.onError : null;
        let onDone = opts && 'onDone' in opts ? opts.onDone : null;
        let cancelOnError = opts && 'cancelOnError' in opts ? opts.cancelOnError : null;
        cancelOnError = core.identical(true, cancelOnError);
        return this[_createSubscription](onData, onError, onDone, cancelOnError);
      }
      [_createSubscription](onData, onError, onDone, cancelOnError) {
        return new (_ForwardingStreamSubscriptionOfS$T())(this, onData, onError, onDone, cancelOnError);
      }
      [_handleData](data, sink) {
        S._check(data);
        _EventSinkOfT()._check(sink);
        sink[_add$](T.as(data));
      }
      [_handleError](error, stackTrace, sink) {
        _EventSinkOfT()._check(sink);
        sink[_addError](error, stackTrace);
      }
      [_handleDone](sink) {
        _EventSinkOfT()._check(sink);
        sink[_close$]();
      }
    }
    dart.setSignature(_ForwardingStream, {
      constructors: () => ({new: dart.definiteFunctionType(async._ForwardingStream$(S, T), [async.Stream$(S)])}),
      methods: () => ({
        listen: dart.definiteFunctionType(async.StreamSubscription$(T), [dart.functionType(dart.void, [T])], {onError: core.Function, onDone: VoidTovoid(), cancelOnError: core.bool}),
        [_createSubscription]: dart.definiteFunctionType(async.StreamSubscription$(T), [dart.functionType(dart.void, [T]), core.Function, dart.functionType(dart.void, []), core.bool]),
        [_handleData]: dart.definiteFunctionType(dart.void, [S, async._EventSink$(T)]),
        [_handleError]: dart.definiteFunctionType(dart.void, [dart.dynamic, core.StackTrace, async._EventSink$(T)]),
        [_handleDone]: dart.definiteFunctionType(dart.void, [async._EventSink$(T)])
      })
    });
    return _ForwardingStream;
  });
  async._ForwardingStream = _ForwardingStream();
  async._ForwardingStreamSubscription$ = dart.generic((S, T) => {
    class _ForwardingStreamSubscription extends async._BufferingStreamSubscription$(T) {
      new(stream, onData, onError, onDone, cancelOnError) {
        this[_stream] = stream;
        this[_subscription] = null;
        super.new(onData, onError, onDone, cancelOnError);
        this[_subscription] = this[_stream][_source$].listen(dart.bind(this, _handleData), {onError: dart.bind(this, _handleError), onDone: dart.bind(this, _handleDone)});
      }
      [_add$](data) {
        T._check(data);
        if (dart.test(this[_isClosed$])) return;
        super[_add$](data);
      }
      [_addError](error, stackTrace) {
        if (dart.test(this[_isClosed$])) return;
        super[_addError](error, stackTrace);
      }
      [_onPause]() {
        if (this[_subscription] == null) return;
        this[_subscription].pause();
      }
      [_onResume]() {
        if (this[_subscription] == null) return;
        this[_subscription].resume();
      }
      [_onCancel]() {
        if (this[_subscription] != null) {
          let subscription = this[_subscription];
          this[_subscription] = null;
          return subscription.cancel();
        }
        return null;
      }
      [_handleData](data) {
        S._check(data);
        this[_stream][_handleData](data, this);
      }
      [_handleError](error, stackTrace) {
        this[_stream][_handleError](error, stackTrace, this);
      }
      [_handleDone]() {
        this[_stream][_handleDone](this);
      }
    }
    dart.setSignature(_ForwardingStreamSubscription, {
      constructors: () => ({new: dart.definiteFunctionType(async._ForwardingStreamSubscription$(S, T), [async._ForwardingStream$(S, T), dart.functionType(dart.void, [T]), core.Function, dart.functionType(dart.void, []), core.bool])}),
      methods: () => ({
        [_add$]: dart.definiteFunctionType(dart.void, [T]),
        [_handleData]: dart.definiteFunctionType(dart.void, [S]),
        [_handleError]: dart.definiteFunctionType(dart.void, [dart.dynamic, core.StackTrace]),
        [_handleDone]: dart.definiteFunctionType(dart.void, [])
      })
    });
    return _ForwardingStreamSubscription;
  });
  async._ForwardingStreamSubscription = _ForwardingStreamSubscription();
  async._Predicate$ = dart.generic(T => {
    const _Predicate = dart.typedef('_Predicate', () => dart.functionType(core.bool, [T]));
    return _Predicate;
  });
  async._Predicate = _Predicate();
  async._addErrorWithReplacement = function(sink, error, stackTrace) {
    let replacement = async.Zone.current.errorCallback(error, core.StackTrace._check(stackTrace));
    if (replacement != null) {
      error = async._nonNullError(replacement.error);
      stackTrace = replacement.stackTrace;
    }
    sink[_addError](error, core.StackTrace._check(stackTrace));
  };
  dart.fn(async._addErrorWithReplacement, _EventSinkAnddynamicAnddynamicTovoid());
  const _test = Symbol('_test');
  async._WhereStream$ = dart.generic(T => {
    let _EventSinkOfT = () => (_EventSinkOfT = dart.constFn(async._EventSink$(T)))();
    class _WhereStream extends async._ForwardingStream$(T, T) {
      new(source, test) {
        this[_test] = test;
        super.new(source);
      }
      [_handleData](inputEvent, sink) {
        T._check(inputEvent);
        _EventSinkOfT()._check(sink);
        let satisfies = null;
        try {
          satisfies = this[_test](inputEvent);
        } catch (e) {
          let s = dart.stackTrace(e);
          async._addErrorWithReplacement(sink, e, s);
          return;
        }

        if (dart.test(satisfies)) {
          sink[_add$](inputEvent);
        }
      }
    }
    dart.setSignature(_WhereStream, {
      constructors: () => ({new: dart.definiteFunctionType(async._WhereStream$(T), [async.Stream$(T), dart.functionType(core.bool, [T])])}),
      methods: () => ({[_handleData]: dart.definiteFunctionType(dart.void, [T, async._EventSink$(T)])})
    });
    return _WhereStream;
  });
  async._WhereStream = _WhereStream();
  async._Transformation$ = dart.generic((S, T) => {
    const _Transformation = dart.typedef('_Transformation', () => dart.functionType(T, [S]));
    return _Transformation;
  });
  async._Transformation = _Transformation$();
  const _transform = Symbol('_transform');
  async._MapStream$ = dart.generic((S, T) => {
    let _EventSinkOfT = () => (_EventSinkOfT = dart.constFn(async._EventSink$(T)))();
    class _MapStream extends async._ForwardingStream$(S, T) {
      new(source, transform) {
        this[_transform] = transform;
        super.new(source);
      }
      [_handleData](inputEvent, sink) {
        S._check(inputEvent);
        _EventSinkOfT()._check(sink);
        let outputEvent = null;
        try {
          outputEvent = this[_transform](inputEvent);
        } catch (e) {
          let s = dart.stackTrace(e);
          async._addErrorWithReplacement(sink, e, s);
          return;
        }

        sink[_add$](outputEvent);
      }
    }
    dart.setSignature(_MapStream, {
      constructors: () => ({new: dart.definiteFunctionType(async._MapStream$(S, T), [async.Stream$(S), dart.functionType(T, [S])])}),
      methods: () => ({[_handleData]: dart.definiteFunctionType(dart.void, [S, async._EventSink$(T)])})
    });
    return _MapStream;
  });
  async._MapStream = _MapStream();
  const _expand = Symbol('_expand');
  async._ExpandStream$ = dart.generic((S, T) => {
    let _EventSinkOfT = () => (_EventSinkOfT = dart.constFn(async._EventSink$(T)))();
    class _ExpandStream extends async._ForwardingStream$(S, T) {
      new(source, expand) {
        this[_expand] = expand;
        super.new(source);
      }
      [_handleData](inputEvent, sink) {
        S._check(inputEvent);
        _EventSinkOfT()._check(sink);
        try {
          for (let value of this[_expand](inputEvent)) {
            sink[_add$](value);
          }
        } catch (e) {
          let s = dart.stackTrace(e);
          async._addErrorWithReplacement(sink, e, s);
        }

      }
    }
    dart.setSignature(_ExpandStream, {
      constructors: () => ({new: dart.definiteFunctionType(async._ExpandStream$(S, T), [async.Stream$(S), dart.functionType(core.Iterable$(T), [S])])}),
      methods: () => ({[_handleData]: dart.definiteFunctionType(dart.void, [S, async._EventSink$(T)])})
    });
    return _ExpandStream;
  });
  async._ExpandStream = _ExpandStream();
  async._ErrorTest = dart.typedef('_ErrorTest', () => dart.functionType(core.bool, [dart.dynamic]));
  async._HandleErrorStream$ = dart.generic(T => {
    let _EventSinkOfT = () => (_EventSinkOfT = dart.constFn(async._EventSink$(T)))();
    class _HandleErrorStream extends async._ForwardingStream$(T, T) {
      new(source, onError, test) {
        this[_transform] = onError;
        this[_test] = test;
        super.new(source);
      }
      [_handleError](error, stackTrace, sink) {
        _EventSinkOfT()._check(sink);
        let matches = true;
        if (this[_test] != null) {
          try {
            matches = dart.dcall(this[_test], error);
          } catch (e) {
            let s = dart.stackTrace(e);
            async._addErrorWithReplacement(sink, e, s);
            return;
          }

        }
        if (dart.test(matches)) {
          try {
            async._invokeErrorHandler(this[_transform], error, stackTrace);
          } catch (e) {
            let s = dart.stackTrace(e);
            if (core.identical(e, error)) {
              sink[_addError](error, stackTrace);
            } else {
              async._addErrorWithReplacement(sink, e, s);
            }
            return;
          }

        } else {
          sink[_addError](error, stackTrace);
        }
      }
    }
    dart.setSignature(_HandleErrorStream, {
      constructors: () => ({new: dart.definiteFunctionType(async._HandleErrorStream$(T), [async.Stream$(T), core.Function, dart.functionType(core.bool, [dart.dynamic])])}),
      methods: () => ({[_handleError]: dart.definiteFunctionType(dart.void, [core.Object, core.StackTrace, async._EventSink$(T)])})
    });
    return _HandleErrorStream;
  });
  async._HandleErrorStream = _HandleErrorStream();
  const _count = Symbol('_count');
  async._TakeStream$ = dart.generic(T => {
    let _StateStreamSubscriptionOfT = () => (_StateStreamSubscriptionOfT = dart.constFn(async._StateStreamSubscription$(T)))();
    let _EventSinkOfT = () => (_EventSinkOfT = dart.constFn(async._EventSink$(T)))();
    class _TakeStream extends async._ForwardingStream$(T, T) {
      new(source, count) {
        this[_count] = count;
        super.new(source);
        if (!(typeof count == 'number')) dart.throw(new core.ArgumentError(count));
      }
      [_createSubscription](onData, onError, onDone, cancelOnError) {
        return new (_StateStreamSubscriptionOfT())(this, onData, onError, onDone, cancelOnError, this[_count]);
      }
      [_handleData](inputEvent, sink) {
        T._check(inputEvent);
        _EventSinkOfT()._check(sink);
        let subscription = _StateStreamSubscriptionOfT()._check(sink);
        let count = subscription[_count];
        if (dart.notNull(count) > 0) {
          sink[_add$](inputEvent);
          count = dart.notNull(count) - 1;
          subscription[_count] = count;
          if (count == 0) {
            sink[_close$]();
          }
        }
      }
    }
    dart.setSignature(_TakeStream, {
      constructors: () => ({new: dart.definiteFunctionType(async._TakeStream$(T), [async.Stream$(T), core.int])}),
      methods: () => ({
        [_createSubscription]: dart.definiteFunctionType(async.StreamSubscription$(T), [dart.functionType(dart.void, [T]), core.Function, dart.functionType(dart.void, []), core.bool]),
        [_handleData]: dart.definiteFunctionType(dart.void, [T, async._EventSink$(T)])
      })
    });
    return _TakeStream;
  });
  async._TakeStream = _TakeStream();
  const _sharedState = Symbol('_sharedState');
  const _flag = Symbol('_flag');
  async._StateStreamSubscription$ = dart.generic(T => {
    class _StateStreamSubscription extends async._ForwardingStreamSubscription$(T, T) {
      new(stream, onData, onError, onDone, cancelOnError, sharedState) {
        this[_sharedState] = sharedState;
        super.new(stream, onData, onError, onDone, cancelOnError);
      }
      get [_flag]() {
        return core.bool._check(this[_sharedState]);
      }
      set [_flag](flag) {
        this[_sharedState] = flag;
      }
      get [_count]() {
        return core.int._check(this[_sharedState]);
      }
      set [_count](count) {
        this[_sharedState] = count;
      }
    }
    dart.setSignature(_StateStreamSubscription, {
      constructors: () => ({new: dart.definiteFunctionType(async._StateStreamSubscription$(T), [async._ForwardingStream$(T, T), dart.functionType(dart.void, [T]), core.Function, dart.functionType(dart.void, []), core.bool, dart.dynamic])})
    });
    return _StateStreamSubscription;
  });
  async._StateStreamSubscription = _StateStreamSubscription();
  async._TakeWhileStream$ = dart.generic(T => {
    let _EventSinkOfT = () => (_EventSinkOfT = dart.constFn(async._EventSink$(T)))();
    class _TakeWhileStream extends async._ForwardingStream$(T, T) {
      new(source, test) {
        this[_test] = test;
        super.new(source);
      }
      [_handleData](inputEvent, sink) {
        T._check(inputEvent);
        _EventSinkOfT()._check(sink);
        let satisfies = null;
        try {
          satisfies = this[_test](inputEvent);
        } catch (e) {
          let s = dart.stackTrace(e);
          async._addErrorWithReplacement(sink, e, s);
          sink[_close$]();
          return;
        }

        if (dart.test(satisfies)) {
          sink[_add$](inputEvent);
        } else {
          sink[_close$]();
        }
      }
    }
    dart.setSignature(_TakeWhileStream, {
      constructors: () => ({new: dart.definiteFunctionType(async._TakeWhileStream$(T), [async.Stream$(T), dart.functionType(core.bool, [T])])}),
      methods: () => ({[_handleData]: dart.definiteFunctionType(dart.void, [T, async._EventSink$(T)])})
    });
    return _TakeWhileStream;
  });
  async._TakeWhileStream = _TakeWhileStream();
  async._SkipStream$ = dart.generic(T => {
    let _StateStreamSubscriptionOfT = () => (_StateStreamSubscriptionOfT = dart.constFn(async._StateStreamSubscription$(T)))();
    let _EventSinkOfT = () => (_EventSinkOfT = dart.constFn(async._EventSink$(T)))();
    class _SkipStream extends async._ForwardingStream$(T, T) {
      new(source, count) {
        this[_count] = count;
        super.new(source);
        if (!(typeof count == 'number') || dart.notNull(count) < 0) dart.throw(new core.ArgumentError(count));
      }
      [_createSubscription](onData, onError, onDone, cancelOnError) {
        return new (_StateStreamSubscriptionOfT())(this, onData, onError, onDone, cancelOnError, this[_count]);
      }
      [_handleData](inputEvent, sink) {
        T._check(inputEvent);
        _EventSinkOfT()._check(sink);
        let subscription = _StateStreamSubscriptionOfT()._check(sink);
        let count = subscription[_count];
        if (dart.notNull(count) > 0) {
          subscription[_count] = dart.notNull(count) - 1;
          return;
        }
        sink[_add$](inputEvent);
      }
    }
    dart.setSignature(_SkipStream, {
      constructors: () => ({new: dart.definiteFunctionType(async._SkipStream$(T), [async.Stream$(T), core.int])}),
      methods: () => ({
        [_createSubscription]: dart.definiteFunctionType(async.StreamSubscription$(T), [dart.functionType(dart.void, [T]), core.Function, dart.functionType(dart.void, []), core.bool]),
        [_handleData]: dart.definiteFunctionType(dart.void, [T, async._EventSink$(T)])
      })
    });
    return _SkipStream;
  });
  async._SkipStream = _SkipStream();
  async._SkipWhileStream$ = dart.generic(T => {
    let _StateStreamSubscriptionOfT = () => (_StateStreamSubscriptionOfT = dart.constFn(async._StateStreamSubscription$(T)))();
    let _EventSinkOfT = () => (_EventSinkOfT = dart.constFn(async._EventSink$(T)))();
    class _SkipWhileStream extends async._ForwardingStream$(T, T) {
      new(source, test) {
        this[_test] = test;
        super.new(source);
      }
      [_createSubscription](onData, onError, onDone, cancelOnError) {
        return new (_StateStreamSubscriptionOfT())(this, onData, onError, onDone, cancelOnError, false);
      }
      [_handleData](inputEvent, sink) {
        T._check(inputEvent);
        _EventSinkOfT()._check(sink);
        let subscription = _StateStreamSubscriptionOfT()._check(sink);
        let hasFailed = subscription[_flag];
        if (dart.test(hasFailed)) {
          sink[_add$](inputEvent);
          return;
        }
        let satisfies = null;
        try {
          satisfies = this[_test](inputEvent);
        } catch (e) {
          let s = dart.stackTrace(e);
          async._addErrorWithReplacement(sink, e, s);
          subscription[_flag] = true;
          return;
        }

        if (!dart.test(satisfies)) {
          subscription[_flag] = true;
          sink[_add$](inputEvent);
        }
      }
    }
    dart.setSignature(_SkipWhileStream, {
      constructors: () => ({new: dart.definiteFunctionType(async._SkipWhileStream$(T), [async.Stream$(T), dart.functionType(core.bool, [T])])}),
      methods: () => ({
        [_createSubscription]: dart.definiteFunctionType(async.StreamSubscription$(T), [dart.functionType(dart.void, [T]), core.Function, dart.functionType(dart.void, []), core.bool]),
        [_handleData]: dart.definiteFunctionType(dart.void, [T, async._EventSink$(T)])
      })
    });
    return _SkipWhileStream;
  });
  async._SkipWhileStream = _SkipWhileStream();
  async._Equality$ = dart.generic(T => {
    const _Equality = dart.typedef('_Equality', () => dart.functionType(core.bool, [T, T]));
    return _Equality;
  });
  async._Equality = _Equality();
  const _equals = Symbol('_equals');
  async._DistinctStream$ = dart.generic(T => {
    let _EventSinkOfT = () => (_EventSinkOfT = dart.constFn(async._EventSink$(T)))();
    class _DistinctStream extends async._ForwardingStream$(T, T) {
      new(source, equals) {
        this[_previous$] = async._DistinctStream._SENTINEL;
        this[_equals] = equals;
        super.new(source);
      }
      [_handleData](inputEvent, sink) {
        T._check(inputEvent);
        _EventSinkOfT()._check(sink);
        if (core.identical(this[_previous$], async._DistinctStream._SENTINEL)) {
          this[_previous$] = inputEvent;
          return sink[_add$](inputEvent);
        } else {
          let isEqual = null;
          try {
            if (this[_equals] == null) {
              isEqual = dart.equals(this[_previous$], inputEvent);
            } else {
              isEqual = this[_equals](T.as(this[_previous$]), inputEvent);
            }
          } catch (e) {
            let s = dart.stackTrace(e);
            async._addErrorWithReplacement(sink, e, s);
            return null;
          }

          if (!dart.test(isEqual)) {
            sink[_add$](inputEvent);
            this[_previous$] = inputEvent;
          }
        }
      }
    }
    dart.setSignature(_DistinctStream, {
      constructors: () => ({new: dart.definiteFunctionType(async._DistinctStream$(T), [async.Stream$(T), dart.functionType(core.bool, [T, T])])}),
      methods: () => ({[_handleData]: dart.definiteFunctionType(dart.void, [T, async._EventSink$(T)])})
    });
    return _DistinctStream;
  });
  async._DistinctStream = _DistinctStream();
  dart.defineLazy(async._DistinctStream, {
    get _SENTINEL() {
      return new core.Object();
    },
    set _SENTINEL(_) {}
  });
  async._EventSinkWrapper$ = dart.generic(T => {
    let EventSinkOfT = () => (EventSinkOfT = dart.constFn(async.EventSink$(T)))();
    class _EventSinkWrapper extends core.Object {
      new(sink) {
        this[_sink] = sink;
      }
      add(data) {
        T._check(data);
        this[_sink][_add$](data);
      }
      addError(error, stackTrace) {
        if (stackTrace === void 0) stackTrace = null;
        this[_sink][_addError](error, stackTrace);
      }
      close() {
        this[_sink][_close$]();
      }
    }
    dart.addTypeTests(_EventSinkWrapper);
    _EventSinkWrapper[dart.implements] = () => [EventSinkOfT()];
    dart.setSignature(_EventSinkWrapper, {
      constructors: () => ({new: dart.definiteFunctionType(async._EventSinkWrapper$(T), [async._EventSink])}),
      methods: () => ({
        add: dart.definiteFunctionType(dart.void, [T]),
        addError: dart.definiteFunctionType(dart.void, [dart.dynamic], [core.StackTrace]),
        close: dart.definiteFunctionType(dart.void, [])
      })
    });
    return _EventSinkWrapper;
  });
  async._EventSinkWrapper = _EventSinkWrapper();
  const _transformerSink = Symbol('_transformerSink');
  const _isSubscribed = Symbol('_isSubscribed');
  async._SinkTransformerStreamSubscription$ = dart.generic((S, T) => {
    let _EventSinkWrapperOfT = () => (_EventSinkWrapperOfT = dart.constFn(async._EventSinkWrapper$(T)))();
    class _SinkTransformerStreamSubscription extends async._BufferingStreamSubscription$(T) {
      new(source, mapper, onData, onError, onDone, cancelOnError) {
        this[_transformerSink] = null;
        this[_subscription] = null;
        super.new(onData, onError, onDone, cancelOnError);
        let eventSink = new (_EventSinkWrapperOfT())(this);
        this[_transformerSink] = mapper(eventSink);
        this[_subscription] = source.listen(dart.bind(this, _handleData), {onError: dart.bind(this, _handleError), onDone: dart.bind(this, _handleDone)});
      }
      get [_isSubscribed]() {
        return this[_subscription] != null;
      }
      [_add$](data) {
        T._check(data);
        if (dart.test(this[_isClosed$])) {
          dart.throw(new core.StateError("Stream is already closed"));
        }
        super[_add$](data);
      }
      [_addError](error, stackTrace) {
        if (dart.test(this[_isClosed$])) {
          dart.throw(new core.StateError("Stream is already closed"));
        }
        super[_addError](error, stackTrace);
      }
      [_close$]() {
        if (dart.test(this[_isClosed$])) {
          dart.throw(new core.StateError("Stream is already closed"));
        }
        super[_close$]();
      }
      [_onPause]() {
        if (dart.test(this[_isSubscribed])) this[_subscription].pause();
      }
      [_onResume]() {
        if (dart.test(this[_isSubscribed])) this[_subscription].resume();
      }
      [_onCancel]() {
        if (dart.test(this[_isSubscribed])) {
          let subscription = this[_subscription];
          this[_subscription] = null;
          subscription.cancel();
        }
        return null;
      }
      [_handleData](data) {
        S._check(data);
        try {
          this[_transformerSink].add(data);
        } catch (e) {
          let s = dart.stackTrace(e);
          this[_addError](e, s);
        }

      }
      [_handleError](error, stackTrace) {
        if (stackTrace === void 0) stackTrace = null;
        try {
          this[_transformerSink].addError(error, core.StackTrace._check(stackTrace));
        } catch (e) {
          let s = dart.stackTrace(e);
          if (core.identical(e, error)) {
            this[_addError](error, core.StackTrace._check(stackTrace));
          } else {
            this[_addError](e, s);
          }
        }

      }
      [_handleDone]() {
        try {
          this[_subscription] = null;
          this[_transformerSink].close();
        } catch (e) {
          let s = dart.stackTrace(e);
          this[_addError](e, s);
        }

      }
    }
    dart.setSignature(_SinkTransformerStreamSubscription, {
      constructors: () => ({new: dart.definiteFunctionType(async._SinkTransformerStreamSubscription$(S, T), [async.Stream$(S), async._SinkMapper$(S, T), dart.functionType(dart.void, [T]), core.Function, dart.functionType(dart.void, []), core.bool])}),
      methods: () => ({
        [_add$]: dart.definiteFunctionType(dart.void, [T]),
        [_handleData]: dart.definiteFunctionType(dart.void, [S]),
        [_handleError]: dart.definiteFunctionType(dart.void, [dart.dynamic], [dart.dynamic]),
        [_handleDone]: dart.definiteFunctionType(dart.void, [])
      })
    });
    return _SinkTransformerStreamSubscription;
  });
  async._SinkTransformerStreamSubscription = _SinkTransformerStreamSubscription();
  async._SinkMapper$ = dart.generic((S, T) => {
    const _SinkMapper = dart.typedef('_SinkMapper', () => dart.functionType(async.EventSink$(S), [async.EventSink$(T)]));
    return _SinkMapper;
  });
  async._SinkMapper = _SinkMapper();
  const _sinkMapper = Symbol('_sinkMapper');
  async._StreamSinkTransformer$ = dart.generic((S, T) => {
    let StreamOfS = () => (StreamOfS = dart.constFn(async.Stream$(S)))();
    let _BoundSinkStreamOfS$T = () => (_BoundSinkStreamOfS$T = dart.constFn(async._BoundSinkStream$(S, T)))();
    let StreamTransformerOfS$T = () => (StreamTransformerOfS$T = dart.constFn(async.StreamTransformer$(S, T)))();
    class _StreamSinkTransformer extends core.Object {
      new(sinkMapper) {
        this[_sinkMapper] = sinkMapper;
      }
      bind(stream) {
        StreamOfS()._check(stream);
        return new (_BoundSinkStreamOfS$T())(stream, this[_sinkMapper]);
      }
    }
    dart.addTypeTests(_StreamSinkTransformer);
    _StreamSinkTransformer[dart.implements] = () => [StreamTransformerOfS$T()];
    dart.setSignature(_StreamSinkTransformer, {
      constructors: () => ({new: dart.definiteFunctionType(async._StreamSinkTransformer$(S, T), [async._SinkMapper$(S, T)])}),
      methods: () => ({bind: dart.definiteFunctionType(async.Stream$(T), [async.Stream$(S)])})
    });
    return _StreamSinkTransformer;
  });
  async._StreamSinkTransformer = _StreamSinkTransformer();
  async._BoundSinkStream$ = dart.generic((S, T) => {
    let _SinkTransformerStreamSubscriptionOfS$T = () => (_SinkTransformerStreamSubscriptionOfS$T = dart.constFn(async._SinkTransformerStreamSubscription$(S, T)))();
    class _BoundSinkStream extends async.Stream$(T) {
      get isBroadcast() {
        return this[_stream].isBroadcast;
      }
      new(stream, sinkMapper) {
        this[_stream] = stream;
        this[_sinkMapper] = sinkMapper;
        super.new();
      }
      listen(onData, opts) {
        let onError = opts && 'onError' in opts ? opts.onError : null;
        let onDone = opts && 'onDone' in opts ? opts.onDone : null;
        let cancelOnError = opts && 'cancelOnError' in opts ? opts.cancelOnError : null;
        cancelOnError = core.identical(true, cancelOnError);
        let subscription = new (_SinkTransformerStreamSubscriptionOfS$T())(this[_stream], this[_sinkMapper], onData, onError, onDone, cancelOnError);
        return subscription;
      }
    }
    dart.setSignature(_BoundSinkStream, {
      constructors: () => ({new: dart.definiteFunctionType(async._BoundSinkStream$(S, T), [async.Stream$(S), async._SinkMapper$(S, T)])}),
      methods: () => ({listen: dart.definiteFunctionType(async.StreamSubscription$(T), [dart.functionType(dart.void, [T])], {onError: core.Function, onDone: VoidTovoid(), cancelOnError: core.bool})})
    });
    return _BoundSinkStream;
  });
  async._BoundSinkStream = _BoundSinkStream();
  async._TransformDataHandler$ = dart.generic((S, T) => {
    const _TransformDataHandler = dart.typedef('_TransformDataHandler', () => dart.functionType(dart.void, [S, async.EventSink$(T)]));
    return _TransformDataHandler;
  });
  async._TransformDataHandler = _TransformDataHandler();
  async._TransformErrorHandler$ = dart.generic(T => {
    const _TransformErrorHandler = dart.typedef('_TransformErrorHandler', () => dart.functionType(dart.void, [core.Object, core.StackTrace, async.EventSink$(T)]));
    return _TransformErrorHandler;
  });
  async._TransformErrorHandler = _TransformErrorHandler();
  async._TransformDoneHandler$ = dart.generic(T => {
    const _TransformDoneHandler = dart.typedef('_TransformDoneHandler', () => dart.functionType(dart.void, [async.EventSink$(T)]));
    return _TransformDoneHandler;
  });
  async._TransformDoneHandler = _TransformDoneHandler();
  async._HandlerEventSink$ = dart.generic((S, T) => {
    let EventSinkOfS = () => (EventSinkOfS = dart.constFn(async.EventSink$(S)))();
    class _HandlerEventSink extends core.Object {
      new(handleData, handleError, handleDone, sink) {
        this[_handleData] = handleData;
        this[_handleError] = handleError;
        this[_handleDone] = handleDone;
        this[_sink] = sink;
      }
      add(data) {
        S._check(data);
        this[_handleData](data, this[_sink]);
      }
      addError(error, stackTrace) {
        if (stackTrace === void 0) stackTrace = null;
        this[_handleError](error, stackTrace, this[_sink]);
      }
      close() {
        this[_handleDone](this[_sink]);
      }
    }
    dart.addTypeTests(_HandlerEventSink);
    _HandlerEventSink[dart.implements] = () => [EventSinkOfS()];
    dart.setSignature(_HandlerEventSink, {
      constructors: () => ({new: dart.definiteFunctionType(async._HandlerEventSink$(S, T), [async._TransformDataHandler$(S, T), async._TransformErrorHandler$(T), async._TransformDoneHandler$(T), async.EventSink$(T)])}),
      methods: () => ({
        add: dart.definiteFunctionType(dart.void, [S]),
        addError: dart.definiteFunctionType(dart.void, [core.Object], [core.StackTrace]),
        close: dart.definiteFunctionType(dart.void, [])
      })
    });
    return _HandlerEventSink;
  });
  async._HandlerEventSink = _HandlerEventSink();
  async._StreamHandlerTransformer$ = dart.generic((S, T) => {
    let _HandlerEventSinkOfS$T = () => (_HandlerEventSinkOfS$T = dart.constFn(async._HandlerEventSink$(S, T)))();
    let EventSinkOfS = () => (EventSinkOfS = dart.constFn(async.EventSink$(S)))();
    let StreamOfS = () => (StreamOfS = dart.constFn(async.Stream$(S)))();
    let SAndEventSinkOfTTovoid = () => (SAndEventSinkOfTTovoid = dart.constFn(dart.functionType(dart.void, [S, EventSinkOfT()])))();
    let EventSinkOfT = () => (EventSinkOfT = dart.constFn(async.EventSink$(T)))();
    let ObjectAndStackTraceAndEventSinkOfTTovoid = () => (ObjectAndStackTraceAndEventSinkOfTTovoid = dart.constFn(dart.functionType(dart.void, [core.Object, core.StackTrace, EventSinkOfT()])))();
    let EventSinkOfTTovoid = () => (EventSinkOfTTovoid = dart.constFn(dart.functionType(dart.void, [EventSinkOfT()])))();
    let EventSinkOfTToEventSinkOfS = () => (EventSinkOfTToEventSinkOfS = dart.constFn(dart.definiteFunctionType(EventSinkOfS(), [EventSinkOfT()])))();
    class _StreamHandlerTransformer extends async._StreamSinkTransformer$(S, T) {
      new(opts) {
        let handleData = opts && 'handleData' in opts ? opts.handleData : null;
        let handleError = opts && 'handleError' in opts ? opts.handleError : null;
        let handleDone = opts && 'handleDone' in opts ? opts.handleDone : null;
        super.new(dart.fn(outputSink => {
          if (handleData == null) handleData = async._StreamHandlerTransformer._defaultHandleData;
          if (handleError == null) handleError = async._StreamHandlerTransformer._defaultHandleError;
          if (handleDone == null) handleDone = async._StreamHandlerTransformer._defaultHandleDone;
          return new (_HandlerEventSinkOfS$T())(handleData, handleError, handleDone, outputSink);
        }, EventSinkOfTToEventSinkOfS()));
      }
      bind(stream) {
        StreamOfS()._check(stream);
        return super.bind(stream);
      }
      static _defaultHandleData(data, sink) {
        sink.add(data);
      }
      static _defaultHandleError(error, stackTrace, sink) {
        sink.addError(error, stackTrace);
      }
      static _defaultHandleDone(sink) {
        sink.close();
      }
    }
    dart.setSignature(_StreamHandlerTransformer, {
      constructors: () => ({new: dart.definiteFunctionType(async._StreamHandlerTransformer$(S, T), [], {handleData: SAndEventSinkOfTTovoid(), handleError: ObjectAndStackTraceAndEventSinkOfTTovoid(), handleDone: EventSinkOfTTovoid()})}),
      methods: () => ({bind: dart.definiteFunctionType(async.Stream$(T), [async.Stream$(S)])}),
      statics: () => ({
        _defaultHandleData: dart.definiteFunctionType(dart.void, [dart.dynamic, async.EventSink]),
        _defaultHandleError: dart.definiteFunctionType(dart.void, [dart.dynamic, core.StackTrace, async.EventSink]),
        _defaultHandleDone: dart.definiteFunctionType(dart.void, [async.EventSink])
      }),
      names: ['_defaultHandleData', '_defaultHandleError', '_defaultHandleDone']
    });
    return _StreamHandlerTransformer;
  });
  async._StreamHandlerTransformer = _StreamHandlerTransformer();
  async._SubscriptionTransformer$ = dart.generic((S, T) => {
    const _SubscriptionTransformer = dart.typedef('_SubscriptionTransformer', () => dart.functionType(async.StreamSubscription$(T), [async.Stream$(S), core.bool]));
    return _SubscriptionTransformer;
  });
  async._SubscriptionTransformer = _SubscriptionTransformer();
  const _transformer = Symbol('_transformer');
  async._StreamSubscriptionTransformer$ = dart.generic((S, T) => {
    let StreamOfS = () => (StreamOfS = dart.constFn(async.Stream$(S)))();
    let _BoundSubscriptionStreamOfS$T = () => (_BoundSubscriptionStreamOfS$T = dart.constFn(async._BoundSubscriptionStream$(S, T)))();
    let StreamTransformerOfS$T = () => (StreamTransformerOfS$T = dart.constFn(async.StreamTransformer$(S, T)))();
    class _StreamSubscriptionTransformer extends core.Object {
      new(transformer) {
        this[_transformer] = transformer;
      }
      bind(stream) {
        StreamOfS()._check(stream);
        return new (_BoundSubscriptionStreamOfS$T())(stream, this[_transformer]);
      }
    }
    dart.addTypeTests(_StreamSubscriptionTransformer);
    _StreamSubscriptionTransformer[dart.implements] = () => [StreamTransformerOfS$T()];
    dart.setSignature(_StreamSubscriptionTransformer, {
      constructors: () => ({new: dart.definiteFunctionType(async._StreamSubscriptionTransformer$(S, T), [async._SubscriptionTransformer$(S, T)])}),
      methods: () => ({bind: dart.definiteFunctionType(async.Stream$(T), [async.Stream$(S)])})
    });
    return _StreamSubscriptionTransformer;
  });
  async._StreamSubscriptionTransformer = _StreamSubscriptionTransformer();
  async._BoundSubscriptionStream$ = dart.generic((S, T) => {
    class _BoundSubscriptionStream extends async.Stream$(T) {
      new(stream, transformer) {
        this[_stream] = stream;
        this[_transformer] = transformer;
        super.new();
      }
      listen(onData, opts) {
        let onError = opts && 'onError' in opts ? opts.onError : null;
        let onDone = opts && 'onDone' in opts ? opts.onDone : null;
        let cancelOnError = opts && 'cancelOnError' in opts ? opts.cancelOnError : null;
        cancelOnError = core.identical(true, cancelOnError);
        let result = this[_transformer](this[_stream], cancelOnError);
        result.onData(onData);
        result.onError(onError);
        result.onDone(onDone);
        return result;
      }
    }
    dart.setSignature(_BoundSubscriptionStream, {
      constructors: () => ({new: dart.definiteFunctionType(async._BoundSubscriptionStream$(S, T), [async.Stream$(S), async._SubscriptionTransformer$(S, T)])}),
      methods: () => ({listen: dart.definiteFunctionType(async.StreamSubscription$(T), [dart.functionType(dart.void, [T])], {onError: core.Function, onDone: VoidTovoid(), cancelOnError: core.bool})})
    });
    return _BoundSubscriptionStream;
  });
  async._BoundSubscriptionStream = _BoundSubscriptionStream();
  async.Timer = class Timer extends core.Object {
    static new(duration, callback) {
      if (dart.equals(async.Zone.current, async.Zone.ROOT)) {
        return async.Zone.current.createTimer(duration, callback);
      }
      return async.Zone.current.createTimer(duration, async.Zone.current.bindCallback(dart.dynamic)(callback, {runGuarded: true}));
    }
    static periodic(duration, callback) {
      if (dart.equals(async.Zone.current, async.Zone.ROOT)) {
        return async.Zone.current.createPeriodicTimer(duration, callback);
      }
      let boundCallback = async.Zone.current.bindUnaryCallback(dart.dynamic, async.Timer)(callback, {runGuarded: true});
      return async.Zone.current.createPeriodicTimer(duration, boundCallback);
    }
    static run(callback) {
      async.Timer.new(core.Duration.ZERO, callback);
    }
    static _createTimer(duration, callback) {
      let milliseconds = duration.inMilliseconds;
      if (dart.notNull(milliseconds) < 0) milliseconds = 0;
      return new _isolate_helper.TimerImpl(milliseconds, callback);
    }
    static _createPeriodicTimer(duration, callback) {
      let milliseconds = duration.inMilliseconds;
      if (dart.notNull(milliseconds) < 0) milliseconds = 0;
      return new _isolate_helper.TimerImpl.periodic(milliseconds, callback);
    }
  };
  dart.setSignature(async.Timer, {
    constructors: () => ({
      new: dart.definiteFunctionType(async.Timer, [core.Duration, dart.functionType(dart.void, [])]),
      periodic: dart.definiteFunctionType(async.Timer, [core.Duration, dart.functionType(dart.void, [async.Timer])])
    }),
    statics: () => ({
      run: dart.definiteFunctionType(dart.void, [dart.functionType(dart.void, [])]),
      _createTimer: dart.definiteFunctionType(async.Timer, [core.Duration, dart.functionType(dart.void, [])]),
      _createPeriodicTimer: dart.definiteFunctionType(async.Timer, [core.Duration, dart.functionType(dart.void, [async.Timer])])
    }),
    names: ['run', '_createTimer', '_createPeriodicTimer']
  });
  async.ZoneCallback$ = dart.generic(R => {
    const ZoneCallback = dart.typedef('ZoneCallback', () => dart.functionType(R, []));
    return ZoneCallback;
  });
  async.ZoneCallback = ZoneCallback();
  async.ZoneUnaryCallback$ = dart.generic((R, T) => {
    const ZoneUnaryCallback = dart.typedef('ZoneUnaryCallback', () => dart.functionType(R, [T]));
    return ZoneUnaryCallback;
  });
  async.ZoneUnaryCallback = ZoneUnaryCallback();
  async.ZoneBinaryCallback$ = dart.generic((R, T1, T2) => {
    const ZoneBinaryCallback = dart.typedef('ZoneBinaryCallback', () => dart.functionType(R, [T1, T2]));
    return ZoneBinaryCallback;
  });
  async.ZoneBinaryCallback = ZoneBinaryCallback();
  async.HandleUncaughtErrorHandler$ = dart.generic(R => {
    const HandleUncaughtErrorHandler = dart.typedef('HandleUncaughtErrorHandler', () => dart.functionType(R, [async.Zone, async.ZoneDelegate, async.Zone, dart.dynamic, core.StackTrace]));
    return HandleUncaughtErrorHandler;
  });
  async.HandleUncaughtErrorHandler = HandleUncaughtErrorHandler();
  async.RunHandler$ = dart.generic(R => {
    const RunHandler = dart.typedef('RunHandler', () => dart.functionType(R, [async.Zone, async.ZoneDelegate, async.Zone, dart.functionType(R, [])]));
    return RunHandler;
  });
  async.RunHandler = RunHandler();
  async.RunUnaryHandler$ = dart.generic((R, T) => {
    const RunUnaryHandler = dart.typedef('RunUnaryHandler', () => dart.functionType(R, [async.Zone, async.ZoneDelegate, async.Zone, dart.functionType(R, [T]), T]));
    return RunUnaryHandler;
  });
  async.RunUnaryHandler = RunUnaryHandler();
  async.RunBinaryHandler$ = dart.generic((R, T1, T2) => {
    const RunBinaryHandler = dart.typedef('RunBinaryHandler', () => dart.functionType(R, [async.Zone, async.ZoneDelegate, async.Zone, dart.functionType(R, [T1, T2]), T1, T2]));
    return RunBinaryHandler;
  });
  async.RunBinaryHandler = RunBinaryHandler();
  async.RegisterCallbackHandler$ = dart.generic(R => {
    const RegisterCallbackHandler = dart.typedef('RegisterCallbackHandler', () => dart.functionType(async.ZoneCallback$(R), [async.Zone, async.ZoneDelegate, async.Zone, dart.functionType(R, [])]));
    return RegisterCallbackHandler;
  });
  async.RegisterCallbackHandler = RegisterCallbackHandler();
  async.RegisterUnaryCallbackHandler$ = dart.generic((R, T) => {
    const RegisterUnaryCallbackHandler = dart.typedef('RegisterUnaryCallbackHandler', () => dart.functionType(async.ZoneUnaryCallback$(R, T), [async.Zone, async.ZoneDelegate, async.Zone, dart.functionType(R, [T])]));
    return RegisterUnaryCallbackHandler;
  });
  async.RegisterUnaryCallbackHandler = RegisterUnaryCallbackHandler();
  async.RegisterBinaryCallbackHandler$ = dart.generic((R, T1, T2) => {
    const RegisterBinaryCallbackHandler = dart.typedef('RegisterBinaryCallbackHandler', () => dart.functionType(async.ZoneBinaryCallback$(R, T1, T2), [async.Zone, async.ZoneDelegate, async.Zone, dart.functionType(R, [T1, T2])]));
    return RegisterBinaryCallbackHandler;
  });
  async.RegisterBinaryCallbackHandler = RegisterBinaryCallbackHandler();
  async.ErrorCallbackHandler = dart.typedef('ErrorCallbackHandler', () => dart.functionType(async.AsyncError, [async.Zone, async.ZoneDelegate, async.Zone, core.Object, core.StackTrace]));
  async.ScheduleMicrotaskHandler = dart.typedef('ScheduleMicrotaskHandler', () => dart.functionType(dart.void, [async.Zone, async.ZoneDelegate, async.Zone, dart.functionType(dart.void, [])]));
  async.CreateTimerHandler = dart.typedef('CreateTimerHandler', () => dart.functionType(async.Timer, [async.Zone, async.ZoneDelegate, async.Zone, core.Duration, dart.functionType(dart.void, [])]));
  async.CreatePeriodicTimerHandler = dart.typedef('CreatePeriodicTimerHandler', () => dart.functionType(async.Timer, [async.Zone, async.ZoneDelegate, async.Zone, core.Duration, dart.functionType(dart.void, [async.Timer])]));
  async.PrintHandler = dart.typedef('PrintHandler', () => dart.functionType(dart.void, [async.Zone, async.ZoneDelegate, async.Zone, core.String]));
  async.ForkHandler = dart.typedef('ForkHandler', () => dart.functionType(async.Zone, [async.Zone, async.ZoneDelegate, async.Zone, async.ZoneSpecification, core.Map]));
  async._ZoneFunction$ = dart.generic(T => {
    class _ZoneFunction extends core.Object {
      new(zone, func) {
        this.zone = zone;
        this.function = func;
      }
    }
    dart.addTypeTests(_ZoneFunction);
    dart.setSignature(_ZoneFunction, {
      constructors: () => ({new: dart.definiteFunctionType(async._ZoneFunction$(T), [async._Zone, T])})
    });
    return _ZoneFunction;
  });
  async._ZoneFunction = _ZoneFunction();
  async.ZoneSpecification = class ZoneSpecification extends core.Object {
    static new(opts) {
      return new async._ZoneSpecification(opts);
    }
    static from(other, opts) {
      let handleUncaughtError = opts && 'handleUncaughtError' in opts ? opts.handleUncaughtError : null;
      let run = opts && 'run' in opts ? opts.run : null;
      let runUnary = opts && 'runUnary' in opts ? opts.runUnary : null;
      let runBinary = opts && 'runBinary' in opts ? opts.runBinary : null;
      let registerCallback = opts && 'registerCallback' in opts ? opts.registerCallback : null;
      let registerUnaryCallback = opts && 'registerUnaryCallback' in opts ? opts.registerUnaryCallback : null;
      let registerBinaryCallback = opts && 'registerBinaryCallback' in opts ? opts.registerBinaryCallback : null;
      let errorCallback = opts && 'errorCallback' in opts ? opts.errorCallback : null;
      let scheduleMicrotask = opts && 'scheduleMicrotask' in opts ? opts.scheduleMicrotask : null;
      let createTimer = opts && 'createTimer' in opts ? opts.createTimer : null;
      let createPeriodicTimer = opts && 'createPeriodicTimer' in opts ? opts.createPeriodicTimer : null;
      let print = opts && 'print' in opts ? opts.print : null;
      let fork = opts && 'fork' in opts ? opts.fork : null;
      return async.ZoneSpecification.new({handleUncaughtError: (handleUncaughtError != null ? handleUncaughtError : other.handleUncaughtError), run: (run != null ? run : other.run), runUnary: (runUnary != null ? runUnary : other.runUnary), runBinary: (runBinary != null ? runBinary : other.runBinary), registerCallback: (registerCallback != null ? registerCallback : other.registerCallback), registerUnaryCallback: (registerUnaryCallback != null ? registerUnaryCallback : other.registerUnaryCallback), registerBinaryCallback: (registerBinaryCallback != null ? registerBinaryCallback : other.registerBinaryCallback), errorCallback: (errorCallback != null ? errorCallback : other.errorCallback), scheduleMicrotask: (scheduleMicrotask != null ? scheduleMicrotask : other.scheduleMicrotask), createTimer: (createTimer != null ? createTimer : other.createTimer), createPeriodicTimer: (createPeriodicTimer != null ? createPeriodicTimer : other.createPeriodicTimer), print: (print != null ? print : other.print), fork: (fork != null ? fork : other.fork)});
    }
  };
  dart.setSignature(async.ZoneSpecification, {
    constructors: () => ({
      new: dart.definiteFunctionType(async.ZoneSpecification, [], {handleUncaughtError: async.HandleUncaughtErrorHandler, run: async.RunHandler, runUnary: async.RunUnaryHandler, runBinary: async.RunBinaryHandler, registerCallback: async.RegisterCallbackHandler, registerUnaryCallback: async.RegisterUnaryCallbackHandler, registerBinaryCallback: async.RegisterBinaryCallbackHandler, errorCallback: async.ErrorCallbackHandler, scheduleMicrotask: async.ScheduleMicrotaskHandler, createTimer: async.CreateTimerHandler, createPeriodicTimer: async.CreatePeriodicTimerHandler, print: async.PrintHandler, fork: async.ForkHandler}),
      from: dart.definiteFunctionType(async.ZoneSpecification, [async.ZoneSpecification], {handleUncaughtError: async.HandleUncaughtErrorHandler, run: async.RunHandler, runUnary: async.RunUnaryHandler, runBinary: async.RunBinaryHandler, registerCallback: async.RegisterCallbackHandler, registerUnaryCallback: async.RegisterUnaryCallbackHandler, registerBinaryCallback: async.RegisterBinaryCallbackHandler, errorCallback: async.ErrorCallbackHandler, scheduleMicrotask: async.ScheduleMicrotaskHandler, createTimer: async.CreateTimerHandler, createPeriodicTimer: async.CreatePeriodicTimerHandler, print: async.PrintHandler, fork: async.ForkHandler})
    })
  });
  async._ZoneSpecification = class _ZoneSpecification extends core.Object {
    new(opts) {
      let handleUncaughtError = opts && 'handleUncaughtError' in opts ? opts.handleUncaughtError : null;
      let run = opts && 'run' in opts ? opts.run : null;
      let runUnary = opts && 'runUnary' in opts ? opts.runUnary : null;
      let runBinary = opts && 'runBinary' in opts ? opts.runBinary : null;
      let registerCallback = opts && 'registerCallback' in opts ? opts.registerCallback : null;
      let registerUnaryCallback = opts && 'registerUnaryCallback' in opts ? opts.registerUnaryCallback : null;
      let registerBinaryCallback = opts && 'registerBinaryCallback' in opts ? opts.registerBinaryCallback : null;
      let errorCallback = opts && 'errorCallback' in opts ? opts.errorCallback : null;
      let scheduleMicrotask = opts && 'scheduleMicrotask' in opts ? opts.scheduleMicrotask : null;
      let createTimer = opts && 'createTimer' in opts ? opts.createTimer : null;
      let createPeriodicTimer = opts && 'createPeriodicTimer' in opts ? opts.createPeriodicTimer : null;
      let print = opts && 'print' in opts ? opts.print : null;
      let fork = opts && 'fork' in opts ? opts.fork : null;
      this.handleUncaughtError = handleUncaughtError;
      this.run = run;
      this.runUnary = runUnary;
      this.runBinary = runBinary;
      this.registerCallback = registerCallback;
      this.registerUnaryCallback = registerUnaryCallback;
      this.registerBinaryCallback = registerBinaryCallback;
      this.errorCallback = errorCallback;
      this.scheduleMicrotask = scheduleMicrotask;
      this.createTimer = createTimer;
      this.createPeriodicTimer = createPeriodicTimer;
      this.print = print;
      this.fork = fork;
    }
  };
  async._ZoneSpecification[dart.implements] = () => [async.ZoneSpecification];
  dart.setSignature(async._ZoneSpecification, {
    constructors: () => ({new: dart.definiteFunctionType(async._ZoneSpecification, [], {handleUncaughtError: async.HandleUncaughtErrorHandler, run: async.RunHandler, runUnary: async.RunUnaryHandler, runBinary: async.RunBinaryHandler, registerCallback: async.RegisterCallbackHandler, registerUnaryCallback: async.RegisterUnaryCallbackHandler, registerBinaryCallback: async.RegisterBinaryCallbackHandler, errorCallback: async.ErrorCallbackHandler, scheduleMicrotask: async.ScheduleMicrotaskHandler, createTimer: async.CreateTimerHandler, createPeriodicTimer: async.CreatePeriodicTimerHandler, print: async.PrintHandler, fork: async.ForkHandler})})
  });
  async.ZoneDelegate = class ZoneDelegate extends core.Object {};
  async.Zone = class Zone extends core.Object {
    _() {
    }
    static get current() {
      return async.Zone._current;
    }
    static _enter(zone) {
      dart.assert(zone != null);
      dart.assert(!core.identical(zone, async.Zone._current));
      let previous = async.Zone._current;
      async.Zone._current = zone;
      return previous;
    }
    static _leave(previous) {
      dart.assert(previous != null);
      async.Zone._current = previous;
    }
  };
  dart.defineNamedConstructor(async.Zone, '_');
  dart.setSignature(async.Zone, {
    constructors: () => ({_: dart.definiteFunctionType(async.Zone, [])}),
    statics: () => ({
      _enter: dart.definiteFunctionType(async.Zone, [async.Zone]),
      _leave: dart.definiteFunctionType(dart.void, [async.Zone])
    }),
    names: ['_enter', '_leave']
  });
  dart.defineLazy(async.Zone, {
    get ROOT() {
      return async._ROOT_ZONE;
    },
    get _current() {
      return async._ROOT_ZONE;
    },
    set _current(_) {}
  });
  const _delegate = Symbol('_delegate');
  async._parentDelegate = function(zone) {
    if (zone.parent == null) return null;
    return zone.parent[_delegate];
  };
  dart.lazyFn(async._parentDelegate, () => _ZoneToZoneDelegate());
  const _delegationTarget = Symbol('_delegationTarget');
  const _handleUncaughtError = Symbol('_handleUncaughtError');
  const _run = Symbol('_run');
  const _runUnary = Symbol('_runUnary');
  const _runBinary = Symbol('_runBinary');
  const _registerCallback = Symbol('_registerCallback');
  const _registerUnaryCallback = Symbol('_registerUnaryCallback');
  const _registerBinaryCallback = Symbol('_registerBinaryCallback');
  const _errorCallback = Symbol('_errorCallback');
  const _createTimer = Symbol('_createTimer');
  const _createPeriodicTimer = Symbol('_createPeriodicTimer');
  const _print = Symbol('_print');
  const _fork = Symbol('_fork');
  async._ZoneDelegate = class _ZoneDelegate extends core.Object {
    new(delegationTarget) {
      this[_delegationTarget] = delegationTarget;
    }
    handleUncaughtError(R) {
      return (zone, error, stackTrace) => {
        let implementation = this[_delegationTarget][_handleUncaughtError];
        let implZone = implementation.zone;
        let handler = implementation.function;
        return R.as(dart.dcall(handler, implZone, async._parentDelegate(implZone), zone, error, stackTrace));
      };
    }
    run(R) {
      return (zone, f) => {
        let implementation = this[_delegationTarget][_run];
        let implZone = implementation.zone;
        let handler = implementation.function;
        return R.as(handler(implZone, async._parentDelegate(implZone), zone, f));
      };
    }
    runUnary(R, T) {
      return (zone, f, arg) => {
        let implementation = this[_delegationTarget][_runUnary];
        let implZone = implementation.zone;
        let handler = implementation.function;
        return R.as(dart.dcall(handler, implZone, async._parentDelegate(implZone), zone, f, arg));
      };
    }
    runBinary(R, T1, T2) {
      return (zone, f, arg1, arg2) => {
        let implementation = this[_delegationTarget][_runBinary];
        let implZone = implementation.zone;
        let handler = implementation.function;
        return R.as(dart.dcall(handler, implZone, async._parentDelegate(implZone), zone, f, arg1, arg2));
      };
    }
    registerCallback(R) {
      return (zone, f) => {
        let implementation = this[_delegationTarget][_registerCallback];
        let implZone = implementation.zone;
        let handler = implementation.function;
        return async.ZoneCallback$(R).as(handler(implZone, async._parentDelegate(implZone), zone, f));
      };
    }
    registerUnaryCallback(R, T) {
      return (zone, f) => {
        let implementation = this[_delegationTarget][_registerUnaryCallback];
        let implZone = implementation.zone;
        let handler = implementation.function;
        return async.ZoneUnaryCallback$(R, T).as(handler(implZone, async._parentDelegate(implZone), zone, f));
      };
    }
    registerBinaryCallback(R, T1, T2) {
      return (zone, f) => {
        let implementation = this[_delegationTarget][_registerBinaryCallback];
        let implZone = implementation.zone;
        let handler = implementation.function;
        return async.ZoneBinaryCallback$(R, T1, T2).as(handler(implZone, async._parentDelegate(implZone), zone, f));
      };
    }
    errorCallback(zone, error, stackTrace) {
      let implementation = this[_delegationTarget][_errorCallback];
      let implZone = implementation.zone;
      if (core.identical(implZone, async._ROOT_ZONE)) return null;
      let handler = implementation.function;
      return handler(implZone, async._parentDelegate(implZone), zone, error, stackTrace);
    }
    scheduleMicrotask(zone, f) {
      let implementation = this[_delegationTarget][_scheduleMicrotask];
      let implZone = implementation.zone;
      let handler = implementation.function;
      handler(implZone, async._parentDelegate(implZone), zone, f);
    }
    createTimer(zone, duration, f) {
      let implementation = this[_delegationTarget][_createTimer];
      let implZone = implementation.zone;
      let handler = implementation.function;
      return handler(implZone, async._parentDelegate(implZone), zone, duration, f);
    }
    createPeriodicTimer(zone, period, f) {
      let implementation = this[_delegationTarget][_createPeriodicTimer];
      let implZone = implementation.zone;
      let handler = implementation.function;
      return handler(implZone, async._parentDelegate(implZone), zone, period, f);
    }
    print(zone, line) {
      let implementation = this[_delegationTarget][_print];
      let implZone = implementation.zone;
      let handler = implementation.function;
      handler(implZone, async._parentDelegate(implZone), zone, line);
    }
    fork(zone, specification, zoneValues) {
      let implementation = this[_delegationTarget][_fork];
      let implZone = implementation.zone;
      let handler = implementation.function;
      return handler(implZone, async._parentDelegate(implZone), zone, specification, zoneValues);
    }
  };
  async._ZoneDelegate[dart.implements] = () => [async.ZoneDelegate];
  dart.setSignature(async._ZoneDelegate, {
    constructors: () => ({new: dart.definiteFunctionType(async._ZoneDelegate, [async._Zone])}),
    methods: () => ({
      handleUncaughtError: dart.definiteFunctionType(R => [R, [async.Zone, dart.dynamic, core.StackTrace]]),
      run: dart.definiteFunctionType(R => [R, [async.Zone, dart.functionType(R, [])]]),
      runUnary: dart.definiteFunctionType((R, T) => [R, [async.Zone, dart.functionType(R, [T]), T]]),
      runBinary: dart.definiteFunctionType((R, T1, T2) => [R, [async.Zone, dart.functionType(R, [T1, T2]), T1, T2]]),
      registerCallback: dart.definiteFunctionType(R => [async.ZoneCallback$(R), [async.Zone, dart.functionType(R, [])]]),
      registerUnaryCallback: dart.definiteFunctionType((R, T) => [async.ZoneUnaryCallback$(R, T), [async.Zone, dart.functionType(R, [T])]]),
      registerBinaryCallback: dart.definiteFunctionType((R, T1, T2) => [async.ZoneBinaryCallback$(R, T1, T2), [async.Zone, dart.functionType(R, [T1, T2])]]),
      errorCallback: dart.definiteFunctionType(async.AsyncError, [async.Zone, core.Object, core.StackTrace]),
      scheduleMicrotask: dart.definiteFunctionType(dart.void, [async.Zone, dart.functionType(dart.dynamic, [])]),
      createTimer: dart.definiteFunctionType(async.Timer, [async.Zone, core.Duration, dart.functionType(dart.void, [])]),
      createPeriodicTimer: dart.definiteFunctionType(async.Timer, [async.Zone, core.Duration, dart.functionType(dart.void, [async.Timer])]),
      print: dart.definiteFunctionType(dart.void, [async.Zone, core.String]),
      fork: dart.definiteFunctionType(async.Zone, [async.Zone, async.ZoneSpecification, core.Map])
    })
  });
  const _map$ = Symbol('_map');
  async._Zone = class _Zone extends core.Object {
    new() {
    }
    inSameErrorZone(otherZone) {
      return core.identical(this, otherZone) || core.identical(this.errorZone, otherZone.errorZone);
    }
  };
  async._Zone[dart.implements] = () => [async.Zone];
  dart.setSignature(async._Zone, {
    constructors: () => ({new: dart.definiteFunctionType(async._Zone, [])}),
    methods: () => ({inSameErrorZone: dart.definiteFunctionType(core.bool, [async.Zone])})
  });
  const _delegateCache = Symbol('_delegateCache');
  async._CustomZone = class _CustomZone extends async._Zone {
    get [_delegate]() {
      if (this[_delegateCache] != null) return this[_delegateCache];
      this[_delegateCache] = new async._ZoneDelegate(this);
      return this[_delegateCache];
    }
    new(parent, specification, map) {
      this.parent = parent;
      this[_map$] = map;
      this[_run] = null;
      this[_runUnary] = null;
      this[_runBinary] = null;
      this[_registerCallback] = null;
      this[_registerUnaryCallback] = null;
      this[_registerBinaryCallback] = null;
      this[_errorCallback] = null;
      this[_scheduleMicrotask] = null;
      this[_createTimer] = null;
      this[_createPeriodicTimer] = null;
      this[_print] = null;
      this[_fork] = null;
      this[_handleUncaughtError] = null;
      this[_delegateCache] = null;
      super.new();
      this[_run] = specification.run != null ? new (_ZoneFunctionOfRunHandler())(this, specification.run) : this.parent[_run];
      this[_runUnary] = specification.runUnary != null ? new (_ZoneFunctionOfRunUnaryHandler())(this, specification.runUnary) : this.parent[_runUnary];
      this[_runBinary] = specification.runBinary != null ? new (_ZoneFunctionOfRunBinaryHandler())(this, specification.runBinary) : this.parent[_runBinary];
      this[_registerCallback] = specification.registerCallback != null ? new (_ZoneFunctionOfRegisterCallbackHandler())(this, specification.registerCallback) : this.parent[_registerCallback];
      this[_registerUnaryCallback] = specification.registerUnaryCallback != null ? new (_ZoneFunctionOfRegisterUnaryCallbackHandler())(this, specification.registerUnaryCallback) : this.parent[_registerUnaryCallback];
      this[_registerBinaryCallback] = specification.registerBinaryCallback != null ? new (_ZoneFunctionOfRegisterBinaryCallbackHandler())(this, specification.registerBinaryCallback) : this.parent[_registerBinaryCallback];
      this[_errorCallback] = specification.errorCallback != null ? new (_ZoneFunctionOfErrorCallbackHandler())(this, specification.errorCallback) : this.parent[_errorCallback];
      this[_scheduleMicrotask] = specification.scheduleMicrotask != null ? new (_ZoneFunctionOfScheduleMicrotaskHandler())(this, specification.scheduleMicrotask) : this.parent[_scheduleMicrotask];
      this[_createTimer] = specification.createTimer != null ? new (_ZoneFunctionOfCreateTimerHandler())(this, specification.createTimer) : this.parent[_createTimer];
      this[_createPeriodicTimer] = specification.createPeriodicTimer != null ? new (_ZoneFunctionOfCreatePeriodicTimerHandler())(this, specification.createPeriodicTimer) : this.parent[_createPeriodicTimer];
      this[_print] = specification.print != null ? new (_ZoneFunctionOfPrintHandler())(this, specification.print) : this.parent[_print];
      this[_fork] = specification.fork != null ? new (_ZoneFunctionOfForkHandler())(this, specification.fork) : this.parent[_fork];
      this[_handleUncaughtError] = specification.handleUncaughtError != null ? new (_ZoneFunctionOfHandleUncaughtErrorHandler())(this, specification.handleUncaughtError) : this.parent[_handleUncaughtError];
    }
    get errorZone() {
      return this[_handleUncaughtError].zone;
    }
    runGuarded(R) {
      return f => {
        try {
          return this.run(R)(f);
        } catch (e) {
          let s = dart.stackTrace(e);
          return this.handleUncaughtError(R)(e, s);
        }

      };
    }
    runUnaryGuarded(R, T) {
      return (f, arg) => {
        try {
          return this.runUnary(R, T)(f, arg);
        } catch (e) {
          let s = dart.stackTrace(e);
          return this.handleUncaughtError(R)(e, s);
        }

      };
    }
    runBinaryGuarded(R, T1, T2) {
      return (f, arg1, arg2) => {
        try {
          return this.runBinary(R, T1, T2)(f, arg1, arg2);
        } catch (e) {
          let s = dart.stackTrace(e);
          return this.handleUncaughtError(R)(e, s);
        }

      };
    }
    bindCallback(R) {
      return (f, opts) => {
        let runGuarded = opts && 'runGuarded' in opts ? opts.runGuarded : true;
        let registered = this.registerCallback(R)(f);
        if (dart.test(runGuarded)) {
          return dart.fn(() => this.runGuarded(R)(registered), dart.definiteFunctionType(R, []));
        } else {
          return dart.fn(() => this.run(R)(registered), dart.definiteFunctionType(R, []));
        }
      };
    }
    bindUnaryCallback(R, T) {
      return (f, opts) => {
        let runGuarded = opts && 'runGuarded' in opts ? opts.runGuarded : true;
        let registered = this.registerUnaryCallback(R, T)(f);
        if (dart.test(runGuarded)) {
          return dart.fn(arg => this.runUnaryGuarded(R, T)(registered, arg), dart.definiteFunctionType(R, [T]));
        } else {
          return dart.fn(arg => this.runUnary(R, T)(registered, arg), dart.definiteFunctionType(R, [T]));
        }
      };
    }
    bindBinaryCallback(R, T1, T2) {
      return (f, opts) => {
        let runGuarded = opts && 'runGuarded' in opts ? opts.runGuarded : true;
        let registered = this.registerBinaryCallback(R, T1, T2)(f);
        if (dart.test(runGuarded)) {
          return dart.fn((arg1, arg2) => this.runBinaryGuarded(R, T1, T2)(registered, arg1, arg2), dart.definiteFunctionType(R, [T1, T2]));
        } else {
          return dart.fn((arg1, arg2) => this.runBinary(R, T1, T2)(registered, arg1, arg2), dart.definiteFunctionType(R, [T1, T2]));
        }
      };
    }
    get(key) {
      let result = this[_map$][dartx.get](key);
      if (result != null || dart.test(this[_map$][dartx.containsKey](key))) return result;
      if (this.parent != null) {
        let value = this.parent.get(key);
        if (value != null) {
          this[_map$][dartx.set](key, value);
        }
        return value;
      }
      dart.assert(dart.equals(this, async._ROOT_ZONE));
      return null;
    }
    handleUncaughtError(R) {
      return (error, stackTrace) => {
        let implementation = this[_handleUncaughtError];
        dart.assert(implementation != null);
        let parentDelegate = async._parentDelegate(implementation.zone);
        let handler = implementation.function;
        return R.as(dart.dcall(handler, implementation.zone, parentDelegate, this, error, stackTrace));
      };
    }
    fork(opts) {
      let specification = opts && 'specification' in opts ? opts.specification : null;
      let zoneValues = opts && 'zoneValues' in opts ? opts.zoneValues : null;
      let implementation = this[_fork];
      dart.assert(implementation != null);
      let parentDelegate = async._parentDelegate(implementation.zone);
      let handler = implementation.function;
      return handler(implementation.zone, parentDelegate, this, specification, zoneValues);
    }
    run(R) {
      return f => {
        let implementation = this[_run];
        dart.assert(implementation != null);
        let parentDelegate = async._parentDelegate(implementation.zone);
        let handler = implementation.function;
        return R.as(handler(implementation.zone, parentDelegate, this, f));
      };
    }
    runUnary(R, T) {
      return (f, arg) => {
        let implementation = this[_runUnary];
        dart.assert(implementation != null);
        let parentDelegate = async._parentDelegate(implementation.zone);
        let handler = implementation.function;
        return R.as(dart.dcall(handler, implementation.zone, parentDelegate, this, f, arg));
      };
    }
    runBinary(R, T1, T2) {
      return (f, arg1, arg2) => {
        let implementation = this[_runBinary];
        dart.assert(implementation != null);
        let parentDelegate = async._parentDelegate(implementation.zone);
        let handler = implementation.function;
        return R.as(dart.dcall(handler, implementation.zone, parentDelegate, this, f, arg1, arg2));
      };
    }
    registerCallback(R) {
      return callback => {
        let implementation = this[_registerCallback];
        dart.assert(implementation != null);
        let parentDelegate = async._parentDelegate(implementation.zone);
        let handler = implementation.function;
        return async.ZoneCallback$(R).as(handler(implementation.zone, parentDelegate, this, callback));
      };
    }
    registerUnaryCallback(R, T) {
      return callback => {
        let implementation = this[_registerUnaryCallback];
        dart.assert(implementation != null);
        let parentDelegate = async._parentDelegate(implementation.zone);
        let handler = implementation.function;
        return async.ZoneUnaryCallback$(R, T).as(handler(implementation.zone, parentDelegate, this, callback));
      };
    }
    registerBinaryCallback(R, T1, T2) {
      return callback => {
        let implementation = this[_registerBinaryCallback];
        dart.assert(implementation != null);
        let parentDelegate = async._parentDelegate(implementation.zone);
        let handler = implementation.function;
        return async.ZoneBinaryCallback$(R, T1, T2).as(handler(implementation.zone, parentDelegate, this, callback));
      };
    }
    errorCallback(error, stackTrace) {
      let implementation = this[_errorCallback];
      dart.assert(implementation != null);
      let implementationZone = implementation.zone;
      if (core.identical(implementationZone, async._ROOT_ZONE)) return null;
      let parentDelegate = async._parentDelegate(async._Zone._check(implementationZone));
      let handler = implementation.function;
      return handler(implementationZone, parentDelegate, this, error, stackTrace);
    }
    scheduleMicrotask(f) {
      let implementation = this[_scheduleMicrotask];
      dart.assert(implementation != null);
      let parentDelegate = async._parentDelegate(implementation.zone);
      let handler = implementation.function;
      return handler(implementation.zone, parentDelegate, this, f);
    }
    createTimer(duration, f) {
      let implementation = this[_createTimer];
      dart.assert(implementation != null);
      let parentDelegate = async._parentDelegate(implementation.zone);
      let handler = implementation.function;
      return handler(implementation.zone, parentDelegate, this, duration, f);
    }
    createPeriodicTimer(duration, f) {
      let implementation = this[_createPeriodicTimer];
      dart.assert(implementation != null);
      let parentDelegate = async._parentDelegate(implementation.zone);
      let handler = implementation.function;
      return handler(implementation.zone, parentDelegate, this, duration, f);
    }
    print(line) {
      let implementation = this[_print];
      dart.assert(implementation != null);
      let parentDelegate = async._parentDelegate(implementation.zone);
      let handler = implementation.function;
      return handler(implementation.zone, parentDelegate, this, line);
    }
  };
  dart.setSignature(async._CustomZone, {
    constructors: () => ({new: dart.definiteFunctionType(async._CustomZone, [async._Zone, async.ZoneSpecification, core.Map])}),
    methods: () => ({
      runGuarded: dart.definiteFunctionType(R => [R, [dart.functionType(R, [])]]),
      runUnaryGuarded: dart.definiteFunctionType((R, T) => [R, [dart.functionType(R, [T]), T]]),
      runBinaryGuarded: dart.definiteFunctionType((R, T1, T2) => [R, [dart.functionType(R, [T1, T2]), T1, T2]]),
      bindCallback: dart.definiteFunctionType(R => [async.ZoneCallback$(R), [dart.functionType(R, [])], {runGuarded: core.bool}]),
      bindUnaryCallback: dart.definiteFunctionType((R, T) => [async.ZoneUnaryCallback$(R, T), [dart.functionType(R, [T])], {runGuarded: core.bool}]),
      bindBinaryCallback: dart.definiteFunctionType((R, T1, T2) => [async.ZoneBinaryCallback$(R, T1, T2), [dart.functionType(R, [T1, T2])], {runGuarded: core.bool}]),
      get: dart.definiteFunctionType(dart.dynamic, [core.Object]),
      handleUncaughtError: dart.definiteFunctionType(R => [R, [dart.dynamic, core.StackTrace]]),
      fork: dart.definiteFunctionType(async.Zone, [], {specification: async.ZoneSpecification, zoneValues: core.Map}),
      run: dart.definiteFunctionType(R => [R, [dart.functionType(R, [])]]),
      runUnary: dart.definiteFunctionType((R, T) => [R, [dart.functionType(R, [T]), T]]),
      runBinary: dart.definiteFunctionType((R, T1, T2) => [R, [dart.functionType(R, [T1, T2]), T1, T2]]),
      registerCallback: dart.definiteFunctionType(R => [async.ZoneCallback$(R), [dart.functionType(R, [])]]),
      registerUnaryCallback: dart.definiteFunctionType((R, T) => [async.ZoneUnaryCallback$(R, T), [dart.functionType(R, [T])]]),
      registerBinaryCallback: dart.definiteFunctionType((R, T1, T2) => [async.ZoneBinaryCallback$(R, T1, T2), [dart.functionType(R, [T1, T2])]]),
      errorCallback: dart.definiteFunctionType(async.AsyncError, [core.Object, core.StackTrace]),
      scheduleMicrotask: dart.definiteFunctionType(dart.void, [dart.functionType(dart.void, [])]),
      createTimer: dart.definiteFunctionType(async.Timer, [core.Duration, dart.functionType(dart.void, [])]),
      createPeriodicTimer: dart.definiteFunctionType(async.Timer, [core.Duration, dart.functionType(dart.void, [async.Timer])]),
      print: dart.definiteFunctionType(dart.void, [core.String])
    })
  });
  async._rootHandleUncaughtError = function(R) {
    return (self, parent, zone, error, stackTrace) => {
      async._schedulePriorityAsyncCallback(dart.fn(() => {
        if (error == null) error = new core.NullThrownError();
        if (stackTrace == null) dart.throw(error);
        async._rethrow(error, stackTrace);
      }, VoidTovoid$()));
    };
  };
  dart.lazyFn(async._rootHandleUncaughtError, () => ZoneAndZoneDelegateAndZone__ToR());
  async._rethrow = function(error, stackTrace) {
    error.stack = dart.toString(stackTrace);
    throw error;
  };
  dart.lazyFn(async._rethrow, () => ObjectAndStackTraceTovoid());
  async._rootRun = function(R) {
    return (self, parent, zone, f) => {
      if (dart.equals(async.Zone._current, zone)) return f();
      let old = async.Zone._enter(zone);
      try {
        return f();
      } finally {
        async.Zone._leave(old);
      }
    };
  };
  dart.fn(async._rootRun, ZoneAndZoneDelegateAndZone__ToR$());
  async._rootRunUnary = function(R, T) {
    return (self, parent, zone, f, arg) => {
      if (dart.equals(async.Zone._current, zone)) return f(arg);
      let old = async.Zone._enter(zone);
      try {
        return f(arg);
      } finally {
        async.Zone._leave(old);
      }
    };
  };
  dart.fn(async._rootRunUnary, ZoneAndZoneDelegateAndZone__ToR$0());
  async._rootRunBinary = function(R, T1, T2) {
    return (self, parent, zone, f, arg1, arg2) => {
      if (dart.equals(async.Zone._current, zone)) return f(arg1, arg2);
      let old = async.Zone._enter(zone);
      try {
        return f(arg1, arg2);
      } finally {
        async.Zone._leave(old);
      }
    };
  };
  dart.fn(async._rootRunBinary, ZoneAndZoneDelegateAndZone__ToR$1());
  async._rootRegisterCallback = function(R) {
    return (self, parent, zone, f) => {
      return f;
    };
  };
  dart.fn(async._rootRegisterCallback, ZoneAndZoneDelegateAndZone__ToZoneCallbackOfR());
  async._rootRegisterUnaryCallback = function(R, T) {
    return (self, parent, zone, f) => {
      return f;
    };
  };
  dart.fn(async._rootRegisterUnaryCallback, ZoneAndZoneDelegateAndZone__ToZoneUnaryCallbackOfR$T());
  async._rootRegisterBinaryCallback = function(R, T1, T2) {
    return (self, parent, zone, f) => {
      return f;
    };
  };
  dart.fn(async._rootRegisterBinaryCallback, ZoneAndZoneDelegateAndZone__ToZoneBinaryCallbackOfR$T1$T2());
  async._rootErrorCallback = function(self, parent, zone, error, stackTrace) {
    return null;
  };
  dart.lazyFn(async._rootErrorCallback, () => ZoneAndZoneDelegateAndZone__ToAsyncError());
  async._rootScheduleMicrotask = function(self, parent, zone, f) {
    if (!core.identical(async._ROOT_ZONE, zone)) {
      let hasErrorHandler = !dart.test(async._ROOT_ZONE.inSameErrorZone(zone));
      f = zone.bindCallback(dart.dynamic)(f, {runGuarded: hasErrorHandler});
      zone = async._ROOT_ZONE;
    }
    async._scheduleAsyncCallback(f);
  };
  dart.fn(async._rootScheduleMicrotask, ZoneAndZoneDelegateAndZone__Tovoid());
  async._rootCreateTimer = function(self, parent, zone, duration, callback) {
    if (!core.identical(async._ROOT_ZONE, zone)) {
      callback = zone.bindCallback(dart.dynamic)(callback);
    }
    return async.Timer._createTimer(duration, callback);
  };
  dart.lazyFn(async._rootCreateTimer, () => ZoneAndZoneDelegateAndZone__ToTimer());
  async._rootCreatePeriodicTimer = function(self, parent, zone, duration, callback) {
    if (!core.identical(async._ROOT_ZONE, zone)) {
      callback = zone.bindUnaryCallback(dart.dynamic, async.Timer)(callback);
    }
    return async.Timer._createPeriodicTimer(duration, callback);
  };
  dart.lazyFn(async._rootCreatePeriodicTimer, () => ZoneAndZoneDelegateAndZone__ToTimer$());
  async._rootPrint = function(self, parent, zone, line) {
    _internal.printToConsole(line);
  };
  dart.lazyFn(async._rootPrint, () => ZoneAndZoneDelegateAndZone__Tovoid$());
  async._printToZone = function(line) {
    async.Zone.current.print(line);
  };
  dart.lazyFn(async._printToZone, () => StringTovoid());
  let const$6;
  async._rootFork = function(self, parent, zone, specification, zoneValues) {
    _internal.printToZone = async._printToZone;
    if (specification == null) {
      specification = const$6 || (const$6 = dart.const(async.ZoneSpecification.new()));
    } else if (!async._ZoneSpecification.is(specification)) {
      dart.throw(new core.ArgumentError("ZoneSpecifications must be instantiated" + " with the provided constructor."));
    }
    let valueMap = null;
    if (zoneValues == null) {
      if (async._Zone.is(zone)) {
        valueMap = zone[_map$];
      } else {
        valueMap = collection.HashMap.new();
      }
    } else {
      valueMap = collection.HashMap.from(zoneValues);
    }
    return new async._CustomZone(async._Zone._check(zone), specification, valueMap);
  };
  dart.lazyFn(async._rootFork, () => ZoneAndZoneDelegateAndZone__ToZone());
  let const$7;
  let const$8;
  let const$9;
  let const$10;
  let const$11;
  let const$12;
  let const$13;
  let const$14;
  let const$15;
  let const$16;
  let const$17;
  let const$18;
  let const$19;
  async._RootZone = class _RootZone extends async._Zone {
    new() {
      super.new();
    }
    get [_run]() {
      return const$7 || (const$7 = dart.const(new (_ZoneFunctionOfRunHandler())(async._ROOT_ZONE, dart.gbind(async._rootRun, dart.dynamic))));
    }
    get [_runUnary]() {
      return const$8 || (const$8 = dart.const(new (_ZoneFunctionOfRunUnaryHandler())(async._ROOT_ZONE, dart.gbind(async._rootRunUnary, dart.dynamic, dart.dynamic))));
    }
    get [_runBinary]() {
      return const$9 || (const$9 = dart.const(new (_ZoneFunctionOfRunBinaryHandler())(async._ROOT_ZONE, dart.gbind(async._rootRunBinary, dart.dynamic, dart.dynamic, dart.dynamic))));
    }
    get [_registerCallback]() {
      return const$10 || (const$10 = dart.const(new (_ZoneFunctionOfRegisterCallbackHandler())(async._ROOT_ZONE, dart.gbind(async._rootRegisterCallback, dart.dynamic))));
    }
    get [_registerUnaryCallback]() {
      return const$11 || (const$11 = dart.const(new (_ZoneFunctionOfRegisterUnaryCallbackHandler())(async._ROOT_ZONE, dart.gbind(async._rootRegisterUnaryCallback, dart.dynamic, dart.dynamic))));
    }
    get [_registerBinaryCallback]() {
      return const$12 || (const$12 = dart.const(new (_ZoneFunctionOfRegisterBinaryCallbackHandler())(async._ROOT_ZONE, dart.gbind(async._rootRegisterBinaryCallback, dart.dynamic, dart.dynamic, dart.dynamic))));
    }
    get [_errorCallback]() {
      return const$13 || (const$13 = dart.const(new (_ZoneFunctionOfErrorCallbackHandler())(async._ROOT_ZONE, async._rootErrorCallback)));
    }
    get [_scheduleMicrotask]() {
      return const$14 || (const$14 = dart.const(new (_ZoneFunctionOfScheduleMicrotaskHandler())(async._ROOT_ZONE, async._rootScheduleMicrotask)));
    }
    get [_createTimer]() {
      return const$15 || (const$15 = dart.const(new (_ZoneFunctionOfCreateTimerHandler())(async._ROOT_ZONE, async._rootCreateTimer)));
    }
    get [_createPeriodicTimer]() {
      return const$16 || (const$16 = dart.const(new (_ZoneFunctionOfCreatePeriodicTimerHandler())(async._ROOT_ZONE, async._rootCreatePeriodicTimer)));
    }
    get [_print]() {
      return const$17 || (const$17 = dart.const(new (_ZoneFunctionOfPrintHandler())(async._ROOT_ZONE, async._rootPrint)));
    }
    get [_fork]() {
      return const$18 || (const$18 = dart.const(new (_ZoneFunctionOfForkHandler())(async._ROOT_ZONE, async._rootFork)));
    }
    get [_handleUncaughtError]() {
      return const$19 || (const$19 = dart.const(new (_ZoneFunctionOfHandleUncaughtErrorHandler())(async._ROOT_ZONE, dart.gbind(async._rootHandleUncaughtError, dart.dynamic))));
    }
    get parent() {
      return null;
    }
    get [_map$]() {
      return async._RootZone._rootMap;
    }
    get [_delegate]() {
      if (async._RootZone._rootDelegate != null) return async._RootZone._rootDelegate;
      return async._RootZone._rootDelegate = new async._ZoneDelegate(this);
    }
    get errorZone() {
      return this;
    }
    runGuarded(R) {
      return f => {
        try {
          if (core.identical(async._ROOT_ZONE, async.Zone._current)) {
            return f();
          }
          return async._rootRun(R)(null, null, this, f);
        } catch (e) {
          let s = dart.stackTrace(e);
          return this.handleUncaughtError(R)(e, s);
        }

      };
    }
    runUnaryGuarded(R, T) {
      return (f, arg) => {
        try {
          if (core.identical(async._ROOT_ZONE, async.Zone._current)) {
            return f(arg);
          }
          return async._rootRunUnary(R, T)(null, null, this, f, arg);
        } catch (e) {
          let s = dart.stackTrace(e);
          return this.handleUncaughtError(R)(e, s);
        }

      };
    }
    runBinaryGuarded(R, T1, T2) {
      return (f, arg1, arg2) => {
        try {
          if (core.identical(async._ROOT_ZONE, async.Zone._current)) {
            return f(arg1, arg2);
          }
          return async._rootRunBinary(R, T1, T2)(null, null, this, f, arg1, arg2);
        } catch (e) {
          let s = dart.stackTrace(e);
          return this.handleUncaughtError(R)(e, s);
        }

      };
    }
    bindCallback(R) {
      return (f, opts) => {
        let runGuarded = opts && 'runGuarded' in opts ? opts.runGuarded : true;
        if (dart.test(runGuarded)) {
          return dart.fn(() => this.runGuarded(R)(f), dart.definiteFunctionType(R, []));
        } else {
          return dart.fn(() => this.run(R)(f), dart.definiteFunctionType(R, []));
        }
      };
    }
    bindUnaryCallback(R, T) {
      return (f, opts) => {
        let runGuarded = opts && 'runGuarded' in opts ? opts.runGuarded : true;
        if (dart.test(runGuarded)) {
          return dart.fn(arg => this.runUnaryGuarded(R, T)(f, arg), dart.definiteFunctionType(R, [T]));
        } else {
          return dart.fn(arg => this.runUnary(R, T)(f, arg), dart.definiteFunctionType(R, [T]));
        }
      };
    }
    bindBinaryCallback(R, T1, T2) {
      return (f, opts) => {
        let runGuarded = opts && 'runGuarded' in opts ? opts.runGuarded : true;
        if (dart.test(runGuarded)) {
          return dart.fn((arg1, arg2) => this.runBinaryGuarded(R, T1, T2)(f, arg1, arg2), dart.definiteFunctionType(R, [T1, T2]));
        } else {
          return dart.fn((arg1, arg2) => this.runBinary(R, T1, T2)(f, arg1, arg2), dart.definiteFunctionType(R, [T1, T2]));
        }
      };
    }
    get(key) {
      return null;
    }
    handleUncaughtError(R) {
      return (error, stackTrace) => {
        return async._rootHandleUncaughtError(R)(null, null, this, error, stackTrace);
      };
    }
    fork(opts) {
      let specification = opts && 'specification' in opts ? opts.specification : null;
      let zoneValues = opts && 'zoneValues' in opts ? opts.zoneValues : null;
      return async._rootFork(null, null, this, specification, zoneValues);
    }
    run(R) {
      return f => {
        if (core.identical(async.Zone._current, async._ROOT_ZONE)) return f();
        return async._rootRun(R)(null, null, this, f);
      };
    }
    runUnary(R, T) {
      return (f, arg) => {
        if (core.identical(async.Zone._current, async._ROOT_ZONE)) return f(arg);
        return async._rootRunUnary(R, T)(null, null, this, f, arg);
      };
    }
    runBinary(R, T1, T2) {
      return (f, arg1, arg2) => {
        if (core.identical(async.Zone._current, async._ROOT_ZONE)) return f(arg1, arg2);
        return async._rootRunBinary(R, T1, T2)(null, null, this, f, arg1, arg2);
      };
    }
    registerCallback(R) {
      return f => {
        return f;
      };
    }
    registerUnaryCallback(R, T) {
      return f => {
        return f;
      };
    }
    registerBinaryCallback(R, T1, T2) {
      return f => {
        return f;
      };
    }
    errorCallback(error, stackTrace) {
      return null;
    }
    scheduleMicrotask(f) {
      async._rootScheduleMicrotask(null, null, this, f);
    }
    createTimer(duration, f) {
      return async.Timer._createTimer(duration, f);
    }
    createPeriodicTimer(duration, f) {
      return async.Timer._createPeriodicTimer(duration, f);
    }
    print(line) {
      _internal.printToConsole(line);
    }
  };
  dart.setSignature(async._RootZone, {
    constructors: () => ({new: dart.definiteFunctionType(async._RootZone, [])}),
    methods: () => ({
      runGuarded: dart.definiteFunctionType(R => [R, [dart.functionType(R, [])]]),
      runUnaryGuarded: dart.definiteFunctionType((R, T) => [R, [dart.functionType(R, [T]), T]]),
      runBinaryGuarded: dart.definiteFunctionType((R, T1, T2) => [R, [dart.functionType(R, [T1, T2]), T1, T2]]),
      bindCallback: dart.definiteFunctionType(R => [async.ZoneCallback$(R), [dart.functionType(R, [])], {runGuarded: core.bool}]),
      bindUnaryCallback: dart.definiteFunctionType((R, T) => [async.ZoneUnaryCallback$(R, T), [dart.functionType(R, [T])], {runGuarded: core.bool}]),
      bindBinaryCallback: dart.definiteFunctionType((R, T1, T2) => [async.ZoneBinaryCallback$(R, T1, T2), [dart.functionType(R, [T1, T2])], {runGuarded: core.bool}]),
      get: dart.definiteFunctionType(dart.dynamic, [core.Object]),
      handleUncaughtError: dart.definiteFunctionType(R => [R, [dart.dynamic, core.StackTrace]]),
      fork: dart.definiteFunctionType(async.Zone, [], {specification: async.ZoneSpecification, zoneValues: core.Map}),
      run: dart.definiteFunctionType(R => [R, [dart.functionType(R, [])]]),
      runUnary: dart.definiteFunctionType((R, T) => [R, [dart.functionType(R, [T]), T]]),
      runBinary: dart.definiteFunctionType((R, T1, T2) => [R, [dart.functionType(R, [T1, T2]), T1, T2]]),
      registerCallback: dart.definiteFunctionType(R => [async.ZoneCallback$(R), [dart.functionType(R, [])]]),
      registerUnaryCallback: dart.definiteFunctionType((R, T) => [async.ZoneUnaryCallback$(R, T), [dart.functionType(R, [T])]]),
      registerBinaryCallback: dart.definiteFunctionType((R, T1, T2) => [async.ZoneBinaryCallback$(R, T1, T2), [dart.functionType(R, [T1, T2])]]),
      errorCallback: dart.definiteFunctionType(async.AsyncError, [core.Object, core.StackTrace]),
      scheduleMicrotask: dart.definiteFunctionType(dart.void, [dart.functionType(dart.void, [])]),
      createTimer: dart.definiteFunctionType(async.Timer, [core.Duration, dart.functionType(dart.void, [])]),
      createPeriodicTimer: dart.definiteFunctionType(async.Timer, [core.Duration, dart.functionType(dart.void, [async.Timer])]),
      print: dart.definiteFunctionType(dart.void, [core.String])
    })
  });
  async._RootZone._rootDelegate = null;
  dart.defineLazy(async._RootZone, {
    get _rootMap() {
      return collection.HashMap.new();
    },
    set _rootMap(_) {}
  });
  async._ROOT_ZONE = dart.const(new async._RootZone());
  async.runZoned = function(R) {
    return (body, opts) => {
      let zoneValues = opts && 'zoneValues' in opts ? opts.zoneValues : null;
      let zoneSpecification = opts && 'zoneSpecification' in opts ? opts.zoneSpecification : null;
      let onError = opts && 'onError' in opts ? opts.onError : null;
      let errorHandler = null;
      if (onError != null) {
        errorHandler = dart.fn((self, parent, zone, error, stackTrace) => {
          try {
            if (ZoneBinaryCallbackOfdynamic$dynamic$StackTrace().is(onError)) {
              return R.as(self.parent.runBinary(dart.dynamic, dart.dynamic, core.StackTrace)(onError, error, stackTrace));
            }
            return self.parent.runUnary(dart.dynamic, dart.dynamic)(dynamicTodynamic()._check(onError), error);
          } catch (e) {
            let s = dart.stackTrace(e);
            if (core.identical(e, error)) {
              return parent.handleUncaughtError(dart.dynamic)(zone, error, stackTrace);
            } else {
              return parent.handleUncaughtError(dart.dynamic)(zone, e, s);
            }
          }

        }, ZoneAndZoneDelegateAndZone__Todynamic());
      }
      if (zoneSpecification == null) {
        zoneSpecification = async.ZoneSpecification.new({handleUncaughtError: errorHandler});
      } else if (errorHandler != null) {
        zoneSpecification = async.ZoneSpecification.from(zoneSpecification, {handleUncaughtError: errorHandler});
      }
      let zone = async.Zone.current.fork({specification: zoneSpecification, zoneValues: zoneValues});
      if (onError != null) {
        return zone.runGuarded(R)(body);
      } else {
        return zone.run(R)(body);
      }
    };
  };
  dart.lazyFn(async.runZoned, () => Fn__ToR());
  collection._USE_ES6_MAPS = true;
  const _length$1 = Symbol('_length');
  const _strings$ = Symbol('_strings');
  const _nums$ = Symbol('_nums');
  const _rest$ = Symbol('_rest');
  const _keys = Symbol('_keys');
  const _containsKey = Symbol('_containsKey');
  const _getBucket$ = Symbol('_getBucket');
  const _findBucketIndex = Symbol('_findBucketIndex');
  const _computeKeys = Symbol('_computeKeys');
  const _get = Symbol('_get');
  const _addHashTableEntry$ = Symbol('_addHashTableEntry');
  const _set = Symbol('_set');
  const _computeHashCode = Symbol('_computeHashCode');
  const _removeHashTableEntry$ = Symbol('_removeHashTableEntry');
  const _remove = Symbol('_remove');
  collection._HashMap$ = dart.generic((K, V) => {
    let _HashMapKeyIterableOfK = () => (_HashMapKeyIterableOfK = dart.constFn(collection._HashMapKeyIterable$(K)))();
    let MappedIterableOfK$V = () => (MappedIterableOfK$V = dart.constFn(_internal.MappedIterable$(K, V)))();
    let MapOfK$V = () => (MapOfK$V = dart.constFn(core.Map$(K, V)))();
    let ListOfK = () => (ListOfK = dart.constFn(core.List$(K)))();
    let HashMapOfK$V = () => (HashMapOfK$V = dart.constFn(collection.HashMap$(K, V)))();
    let VoidToV = () => (VoidToV = dart.constFn(dart.functionType(V, [])))();
    let KToV = () => (KToV = dart.constFn(dart.definiteFunctionType(V, [K])))();
    let KTobool = () => (KTobool = dart.constFn(dart.definiteFunctionType(core.bool, [K])))();
    let KAndVTovoid = () => (KAndVTovoid = dart.constFn(dart.definiteFunctionType(dart.void, [K, V])))();
    class _HashMap extends core.Object {
      new() {
        this[_length$1] = 0;
        this[_strings$] = null;
        this[_nums$] = null;
        this[_rest$] = null;
        this[_keys] = null;
      }
      get length() {
        return this[_length$1];
      }
      get isEmpty() {
        return this[_length$1] == 0;
      }
      get isNotEmpty() {
        return !dart.test(this.isEmpty);
      }
      get keys() {
        return new (_HashMapKeyIterableOfK())(this);
      }
      get values() {
        return MappedIterableOfK$V().new(this.keys, dart.fn(each => this.get(each), KToV()));
      }
      containsKey(key) {
        if (dart.test(collection._HashMap._isStringKey(key))) {
          let strings = this[_strings$];
          return strings == null ? false : collection._HashMap._hasTableEntry(strings, key);
        } else if (dart.test(collection._HashMap._isNumericKey(key))) {
          let nums = this[_nums$];
          return nums == null ? false : collection._HashMap._hasTableEntry(nums, key);
        } else {
          return this[_containsKey](key);
        }
      }
      [_containsKey](key) {
        let rest = this[_rest$];
        if (rest == null) return false;
        let bucket = this[_getBucket$](rest, key);
        return dart.notNull(this[_findBucketIndex](bucket, key)) >= 0;
      }
      containsValue(value) {
        return this[_computeKeys]()[dartx.any](dart.fn(each => dart.equals(this.get(each), value), KTobool()));
      }
      addAll(other) {
        MapOfK$V()._check(other);
        other[dartx.forEach](dart.fn((key, value) => {
          this.set(key, value);
        }, KAndVTovoid()));
      }
      get(key) {
        if (dart.test(collection._HashMap._isStringKey(key))) {
          let strings = this[_strings$];
          return V._check(strings == null ? null : collection._HashMap._getTableEntry(strings, key));
        } else if (dart.test(collection._HashMap._isNumericKey(key))) {
          let nums = this[_nums$];
          return V._check(nums == null ? null : collection._HashMap._getTableEntry(nums, key));
        } else {
          return this[_get](key);
        }
      }
      [_get](key) {
        let rest = this[_rest$];
        if (rest == null) return null;
        let bucket = this[_getBucket$](rest, key);
        let index = this[_findBucketIndex](bucket, key);
        return V._check(dart.notNull(index) < 0 ? null : bucket[dart.notNull(index) + 1]);
      }
      set(key, value) {
        K._check(key);
        V._check(value);
        if (dart.test(collection._HashMap._isStringKey(key))) {
          let strings = this[_strings$];
          if (strings == null) this[_strings$] = strings = collection._HashMap._newHashTable();
          this[_addHashTableEntry$](strings, key, value);
        } else if (dart.test(collection._HashMap._isNumericKey(key))) {
          let nums = this[_nums$];
          if (nums == null) this[_nums$] = nums = collection._HashMap._newHashTable();
          this[_addHashTableEntry$](nums, key, value);
        } else {
          this[_set](key, value);
        }
        return value;
      }
      [_set](key, value) {
        K._check(key);
        V._check(value);
        let rest = this[_rest$];
        if (rest == null) this[_rest$] = rest = collection._HashMap._newHashTable();
        let hash = this[_computeHashCode](key);
        let bucket = rest[hash];
        if (bucket == null) {
          collection._HashMap._setTableEntry(rest, hash, [key, value]);
          this[_length$1] = dart.notNull(this[_length$1]) + 1;
          this[_keys] = null;
        } else {
          let index = this[_findBucketIndex](bucket, key);
          if (dart.notNull(index) >= 0) {
            bucket[dart.notNull(index) + 1] = value;
          } else {
            bucket.push(key, value);
            this[_length$1] = dart.notNull(this[_length$1]) + 1;
            this[_keys] = null;
          }
        }
      }
      putIfAbsent(key, ifAbsent) {
        K._check(key);
        VoidToV()._check(ifAbsent);
        if (dart.test(this.containsKey(key))) return this.get(key);
        let value = ifAbsent();
        this.set(key, value);
        return value;
      }
      remove(key) {
        if (dart.test(collection._HashMap._isStringKey(key))) {
          return this[_removeHashTableEntry$](this[_strings$], key);
        } else if (dart.test(collection._HashMap._isNumericKey(key))) {
          return this[_removeHashTableEntry$](this[_nums$], key);
        } else {
          return this[_remove](key);
        }
      }
      [_remove](key) {
        let rest = this[_rest$];
        if (rest == null) return null;
        let bucket = this[_getBucket$](rest, key);
        let index = this[_findBucketIndex](bucket, key);
        if (dart.notNull(index) < 0) return null;
        this[_length$1] = dart.notNull(this[_length$1]) - 1;
        this[_keys] = null;
        return bucket.splice(index, 2)[1];
      }
      clear() {
        if (dart.notNull(this[_length$1]) > 0) {
          this[_strings$] = this[_nums$] = this[_rest$] = this[_keys] = null;
          this[_length$1] = 0;
        }
      }
      forEach(action) {
        let keys = this[_computeKeys]();
        for (let i = 0, length = keys[dartx.length]; i < dart.notNull(length); i++) {
          let key = keys[i];
          action(K._check(key), this.get(key));
          if (keys !== this[_keys]) {
            dart.throw(new core.ConcurrentModificationError(this));
          }
        }
      }
      [_computeKeys]() {
        if (this[_keys] != null) return this[_keys];
        let result = ListOfK().new(this[_length$1]);
        let index = 0;
        let strings = this[_strings$];
        if (strings != null) {
          let names = Object.getOwnPropertyNames(strings);
          let entries = names.length;
          for (let i = 0; i < entries; i++) {
            let key = names[i];
            result[index] = key;
            index++;
          }
        }
        let nums = this[_nums$];
        if (nums != null) {
          let names = Object.getOwnPropertyNames(nums);
          let entries = names.length;
          for (let i = 0; i < entries; i++) {
            let key = +names[i];
            result[index] = key;
            index++;
          }
        }
        let rest = this[_rest$];
        if (rest != null) {
          let names = Object.getOwnPropertyNames(rest);
          let entries = names.length;
          for (let i = 0; i < entries; i++) {
            let key = names[i];
            let bucket = rest[key];
            let length = bucket.length;
            for (let i = 0; i < length; i = i + 2) {
              let key = bucket[i];
              result[index] = key;
              index++;
            }
          }
        }
        dart.assert(index == this[_length$1]);
        return this[_keys] = result;
      }
      [_addHashTableEntry$](table, key, value) {
        K._check(key);
        V._check(value);
        if (!dart.test(collection._HashMap._hasTableEntry(table, key))) {
          this[_length$1] = dart.notNull(this[_length$1]) + 1;
          this[_keys] = null;
        }
        collection._HashMap._setTableEntry(table, key, value);
      }
      [_removeHashTableEntry$](table, key) {
        if (table != null && dart.test(collection._HashMap._hasTableEntry(table, key))) {
          let value = V._check(collection._HashMap._getTableEntry(table, key));
          collection._HashMap._deleteTableEntry(table, key);
          this[_length$1] = dart.notNull(this[_length$1]) - 1;
          this[_keys] = null;
          return value;
        } else {
          return null;
        }
      }
      static _isStringKey(key) {
        return typeof key == 'string' && key != '__proto__';
      }
      static _isNumericKey(key) {
        return typeof key == 'number' && (key & 0x3ffffff) === key;
      }
      [_computeHashCode](key) {
        return dart.hashCode(key) & 0x3ffffff;
      }
      static _hasTableEntry(table, key) {
        let entry = table[key];
        return entry != null;
      }
      static _getTableEntry(table, key) {
        let entry = table[key];
        return entry === table ? null : entry;
      }
      static _setTableEntry(table, key, value) {
        if (value == null) {
          table[key] = table;
        } else {
          table[key] = value;
        }
      }
      static _deleteTableEntry(table, key) {
        delete table[key];
      }
      [_getBucket$](table, key) {
        let hash = this[_computeHashCode](key);
        return table[hash];
      }
      [_findBucketIndex](bucket, key) {
        if (bucket == null) return -1;
        let length = bucket.length;
        for (let i = 0; i < length; i = i + 2) {
          if (dart.equals(bucket[i], key)) return i;
        }
        return -1;
      }
      static _newHashTable() {
        let table = Object.create(null);
        let temporaryKey = '<non-identifier-key>';
        collection._HashMap._setTableEntry(table, temporaryKey, table);
        collection._HashMap._deleteTableEntry(table, temporaryKey);
        return table;
      }
    }
    dart.addTypeTests(_HashMap);
    _HashMap[dart.implements] = () => [HashMapOfK$V()];
    dart.setSignature(_HashMap, {
      constructors: () => ({new: dart.definiteFunctionType(collection._HashMap$(K, V), [])}),
      methods: () => ({
        containsKey: dart.definiteFunctionType(core.bool, [core.Object]),
        [_containsKey]: dart.definiteFunctionType(core.bool, [core.Object]),
        containsValue: dart.definiteFunctionType(core.bool, [core.Object]),
        addAll: dart.definiteFunctionType(dart.void, [core.Map$(K, V)]),
        get: dart.definiteFunctionType(V, [core.Object]),
        [_get]: dart.definiteFunctionType(V, [core.Object]),
        set: dart.definiteFunctionType(dart.void, [K, V]),
        [_set]: dart.definiteFunctionType(dart.void, [K, V]),
        putIfAbsent: dart.definiteFunctionType(V, [K, dart.functionType(V, [])]),
        remove: dart.definiteFunctionType(V, [core.Object]),
        [_remove]: dart.definiteFunctionType(V, [core.Object]),
        clear: dart.definiteFunctionType(dart.void, []),
        forEach: dart.definiteFunctionType(dart.void, [dart.functionType(dart.void, [K, V])]),
        [_computeKeys]: dart.definiteFunctionType(core.List$(K), []),
        [_addHashTableEntry$]: dart.definiteFunctionType(dart.void, [dart.dynamic, K, V]),
        [_removeHashTableEntry$]: dart.definiteFunctionType(V, [dart.dynamic, core.Object]),
        [_computeHashCode]: dart.definiteFunctionType(core.int, [dart.dynamic]),
        [_getBucket$]: dart.definiteFunctionType(core.List, [dart.dynamic, dart.dynamic]),
        [_findBucketIndex]: dart.definiteFunctionType(core.int, [dart.dynamic, core.Object])
      }),
      statics: () => ({
        _isStringKey: dart.definiteFunctionType(core.bool, [dart.dynamic]),
        _isNumericKey: dart.definiteFunctionType(core.bool, [dart.dynamic]),
        _hasTableEntry: dart.definiteFunctionType(core.bool, [dart.dynamic, dart.dynamic]),
        _getTableEntry: dart.definiteFunctionType(dart.dynamic, [dart.dynamic, dart.dynamic]),
        _setTableEntry: dart.definiteFunctionType(dart.void, [dart.dynamic, dart.dynamic, dart.dynamic]),
        _deleteTableEntry: dart.definiteFunctionType(dart.void, [dart.dynamic, dart.dynamic]),
        _newHashTable: dart.definiteFunctionType(dart.dynamic, [])
      }),
      names: ['_isStringKey', '_isNumericKey', '_hasTableEntry', '_getTableEntry', '_setTableEntry', '_deleteTableEntry', '_newHashTable']
    });
    dart.defineExtensionMembers(_HashMap, [
      'containsKey',
      'containsValue',
      'addAll',
      'get',
      'set',
      'putIfAbsent',
      'remove',
      'clear',
      'forEach',
      'length',
      'isEmpty',
      'isNotEmpty',
      'keys',
      'values'
    ]);
    return _HashMap;
  });
  collection._HashMap = _HashMap();
  collection._IdentityHashMap$ = dart.generic((K, V) => {
    class _IdentityHashMap extends collection._HashMap$(K, V) {
      new() {
        super.new();
      }
      [_computeHashCode](key) {
        return core.identityHashCode(key) & 0x3ffffff;
      }
      [_findBucketIndex](bucket, key) {
        if (bucket == null) return -1;
        let length = bucket.length;
        for (let i = 0; i < length; i = i + 2) {
          if (core.identical(bucket[i], key)) return i;
        }
        return -1;
      }
    }
    return _IdentityHashMap;
  });
  collection._IdentityHashMap = _IdentityHashMap();
  const _equals$ = Symbol('_equals');
  const _hashCode = Symbol('_hashCode');
  const _validKey = Symbol('_validKey');
  collection._CustomHashMap$ = dart.generic((K, V) => {
    class _CustomHashMap extends collection._HashMap$(K, V) {
      new(equals, hashCode, validKey) {
        this[_equals$] = equals;
        this[_hashCode] = hashCode;
        this[_validKey] = validKey != null ? validKey : dart.fn(v => K.is(v), ObjectTobool$());
        super.new();
      }
      get(key) {
        if (!dart.test(this[_validKey](key))) return null;
        return super[_get](key);
      }
      set(key, value) {
        K._check(key);
        V._check(value);
        super[_set](key, value);
        return value;
      }
      containsKey(key) {
        if (!dart.test(this[_validKey](key))) return false;
        return super[_containsKey](key);
      }
      remove(key) {
        if (!dart.test(this[_validKey](key))) return null;
        return super[_remove](key);
      }
      [_computeHashCode](key) {
        return this[_hashCode](K._check(key)) & 0x3ffffff;
      }
      [_findBucketIndex](bucket, key) {
        if (bucket == null) return -1;
        let length = bucket.length;
        for (let i = 0; i < length; i = i + 2) {
          if (dart.test(this[_equals$](bucket[i], K._check(key)))) return i;
        }
        return -1;
      }
      toString() {
        return collection.Maps.mapToString(this);
      }
    }
    dart.setSignature(_CustomHashMap, {
      constructors: () => ({new: dart.definiteFunctionType(collection._CustomHashMap$(K, V), [collection._Equality$(K), collection._Hasher$(K), dart.functionType(core.bool, [core.Object])])}),
      methods: () => ({
        get: dart.definiteFunctionType(V, [core.Object]),
        set: dart.definiteFunctionType(dart.void, [K, V]),
        remove: dart.definiteFunctionType(V, [core.Object])
      })
    });
    dart.defineExtensionMembers(_CustomHashMap, ['get', 'set', 'containsKey', 'remove']);
    return _CustomHashMap;
  });
  collection._CustomHashMap = _CustomHashMap();
  const _map$0 = Symbol('_map');
  collection._HashMapKeyIterable$ = dart.generic(E => {
    let _HashMapKeyIteratorOfE = () => (_HashMapKeyIteratorOfE = dart.constFn(collection._HashMapKeyIterator$(E)))();
    class _HashMapKeyIterable extends core.Iterable$(E) {
      new(map) {
        this[_map$0] = map;
        super.new();
      }
      get length() {
        return this[_map$0][_length$1];
      }
      get isEmpty() {
        return this[_map$0][_length$1] == 0;
      }
      get iterator() {
        return new (_HashMapKeyIteratorOfE())(this[_map$0], this[_map$0][_computeKeys]());
      }
      contains(element) {
        return this[_map$0].containsKey(element);
      }
      forEach(f) {
        let keys = this[_map$0][_computeKeys]();
        for (let i = 0, length = keys.length; i < length; i++) {
          f(keys[i]);
          if (keys !== this[_map$0][_keys]) {
            dart.throw(new core.ConcurrentModificationError(this[_map$0]));
          }
        }
      }
    }
    _HashMapKeyIterable[dart.implements] = () => [_internal.EfficientLength];
    dart.setSignature(_HashMapKeyIterable, {
      constructors: () => ({new: dart.definiteFunctionType(collection._HashMapKeyIterable$(E), [collection._HashMap$(E, dart.dynamic)])}),
      methods: () => ({forEach: dart.definiteFunctionType(dart.void, [dart.functionType(dart.void, [E])])})
    });
    dart.defineExtensionMembers(_HashMapKeyIterable, [
      'contains',
      'forEach',
      'length',
      'isEmpty',
      'iterator'
    ]);
    return _HashMapKeyIterable;
  });
  collection._HashMapKeyIterable = _HashMapKeyIterable();
  const _offset = Symbol('_offset');
  const _current$2 = Symbol('_current');
  collection._HashMapKeyIterator$ = dart.generic(E => {
    let IteratorOfE = () => (IteratorOfE = dart.constFn(core.Iterator$(E)))();
    class _HashMapKeyIterator extends core.Object {
      new(map, keys) {
        this[_map$0] = map;
        this[_keys] = keys;
        this[_offset] = 0;
        this[_current$2] = null;
      }
      get current() {
        return this[_current$2];
      }
      moveNext() {
        let keys = this[_keys];
        let offset = this[_offset];
        if (keys !== this[_map$0][_keys]) {
          dart.throw(new core.ConcurrentModificationError(this[_map$0]));
        } else if (dart.notNull(offset) >= keys.length) {
          this[_current$2] = null;
          return false;
        } else {
          this[_current$2] = keys[offset];
          this[_offset] = dart.notNull(offset) + 1;
          return true;
        }
      }
    }
    dart.addTypeTests(_HashMapKeyIterator);
    _HashMapKeyIterator[dart.implements] = () => [IteratorOfE()];
    dart.setSignature(_HashMapKeyIterator, {
      constructors: () => ({new: dart.definiteFunctionType(collection._HashMapKeyIterator$(E), [collection._HashMap$(E, dart.dynamic), core.List$(E)])}),
      methods: () => ({moveNext: dart.definiteFunctionType(core.bool, [])})
    });
    return _HashMapKeyIterator;
  });
  collection._HashMapKeyIterator = _HashMapKeyIterator();
  collection._LinkedIdentityHashMap$ = dart.generic((K, V) => {
    let _Es6LinkedIdentityHashMapOfK$V = () => (_Es6LinkedIdentityHashMapOfK$V = dart.constFn(collection._Es6LinkedIdentityHashMap$(K, V)))();
    let _LinkedIdentityHashMapOfK$V = () => (_LinkedIdentityHashMapOfK$V = dart.constFn(collection._LinkedIdentityHashMap$(K, V)))();
    class _LinkedIdentityHashMap extends _js_helper.JsLinkedHashMap$(K, V) {
      static get _supportsEs6Maps() {
        return true;
      }
      static es6() {
        return collection._USE_ES6_MAPS && dart.test(collection._LinkedIdentityHashMap._supportsEs6Maps) ? new (_Es6LinkedIdentityHashMapOfK$V())() : new (_LinkedIdentityHashMapOfK$V())();
      }
      new() {
        super.new();
      }
      internalComputeHashCode(key) {
        return core.identityHashCode(key) & 0x3ffffff;
      }
      internalFindBucketIndex(bucket, key) {
        if (bucket == null) return -1;
        let length = bucket.length;
        for (let i = 0; i < length; i++) {
          let cell = bucket[i];
          if (core.identical(cell.hashMapCellKey, key)) return i;
        }
        return -1;
      }
    }
    dart.setSignature(_LinkedIdentityHashMap, {
      constructors: () => ({
        es6: dart.definiteFunctionType(collection._LinkedIdentityHashMap$(K, V), []),
        new: dart.definiteFunctionType(collection._LinkedIdentityHashMap$(K, V), [])
      })
    });
    return _LinkedIdentityHashMap;
  });
  collection._LinkedIdentityHashMap = _LinkedIdentityHashMap();
  const _modifications$ = Symbol('_modifications');
  const _modified$ = Symbol('_modified');
  collection._Es6LinkedIdentityHashMap$ = dart.generic((K, V) => {
    let _Es6MapIterableOfK = () => (_Es6MapIterableOfK = dart.constFn(collection._Es6MapIterable$(K)))();
    let MapOfK$V = () => (MapOfK$V = dart.constFn(core.Map$(K, V)))();
    let _Es6MapIterableOfV = () => (_Es6MapIterableOfV = dart.constFn(collection._Es6MapIterable$(V)))();
    let VoidToV = () => (VoidToV = dart.constFn(dart.functionType(V, [])))();
    let KAndVTovoid = () => (KAndVTovoid = dart.constFn(dart.definiteFunctionType(dart.void, [K, V])))();
    let VTobool = () => (VTobool = dart.constFn(dart.definiteFunctionType(core.bool, [V])))();
    class _Es6LinkedIdentityHashMap extends collection._LinkedIdentityHashMap$(K, V) {
      new() {
        this[_map$0] = new Map();
        this[_modifications$] = 0;
        super.new();
      }
      get length() {
        return this[_map$0].size;
      }
      get isEmpty() {
        return this.length == 0;
      }
      get isNotEmpty() {
        return !dart.test(this.isEmpty);
      }
      get keys() {
        return new (_Es6MapIterableOfK())(this, true);
      }
      get values() {
        return new (_Es6MapIterableOfV())(this, false);
      }
      containsKey(key) {
        return this[_map$0].has(key);
      }
      containsValue(value) {
        return this.values[dartx.any](dart.fn(each => dart.equals(each, value), VTobool()));
      }
      addAll(other) {
        MapOfK$V()._check(other);
        other[dartx.forEach](dart.fn((key, value) => {
          this.set(key, value);
        }, KAndVTovoid()));
      }
      get(key) {
        return this[_map$0].get(key);
      }
      set(key, value) {
        K._check(key);
        V._check(value);
        this[_map$0].set(key, value);
        this[_modified$]();
        return value;
      }
      putIfAbsent(key, ifAbsent) {
        K._check(key);
        VoidToV()._check(ifAbsent);
        if (dart.test(this.containsKey(key))) return this.get(key);
        let value = ifAbsent();
        this.set(key, value);
        return value;
      }
      remove(key) {
        let value = this.get(key);
        this[_map$0].delete(key);
        this[_modified$]();
        return value;
      }
      clear() {
        this[_map$0].clear();
        this[_modified$]();
      }
      forEach(action) {
        let jsEntries = this[_map$0].entries();
        let modifications = this[_modifications$];
        while (true) {
          let next = jsEntries.next();
          let done = next.done;
          if (done) break;
          let entry = next.value;
          let key = entry[0];
          let value = entry[1];
          action(K._check(key), V._check(value));
          if (modifications != this[_modifications$]) {
            dart.throw(new core.ConcurrentModificationError(this));
          }
        }
      }
      [_modified$]() {
        this[_modifications$] = dart.notNull(this[_modifications$]) + 1 & 67108863;
      }
      toString() {
        return collection.Maps.mapToString(this);
      }
    }
    _Es6LinkedIdentityHashMap[dart.implements] = () => [_js_helper.InternalMap];
    dart.setSignature(_Es6LinkedIdentityHashMap, {
      constructors: () => ({new: dart.definiteFunctionType(collection._Es6LinkedIdentityHashMap$(K, V), [])}),
      methods: () => ({
        addAll: dart.definiteFunctionType(dart.void, [core.Map$(K, V)]),
        get: dart.definiteFunctionType(V, [core.Object]),
        set: dart.definiteFunctionType(dart.void, [K, V]),
        putIfAbsent: dart.definiteFunctionType(V, [K, dart.functionType(V, [])]),
        remove: dart.definiteFunctionType(V, [core.Object]),
        forEach: dart.definiteFunctionType(dart.void, [dart.functionType(dart.void, [K, V])]),
        [_modified$]: dart.definiteFunctionType(dart.void, [])
      })
    });
    dart.defineExtensionMembers(_Es6LinkedIdentityHashMap, [
      'containsKey',
      'containsValue',
      'addAll',
      'get',
      'set',
      'putIfAbsent',
      'remove',
      'clear',
      'forEach',
      'length',
      'isEmpty',
      'isNotEmpty',
      'keys',
      'values'
    ]);
    return _Es6LinkedIdentityHashMap;
  });
  collection._Es6LinkedIdentityHashMap = _Es6LinkedIdentityHashMap();
  const _isKeys = Symbol('_isKeys');
  collection._Es6MapIterable$ = dart.generic(E => {
    let _Es6MapIteratorOfE = () => (_Es6MapIteratorOfE = dart.constFn(collection._Es6MapIterator$(E)))();
    class _Es6MapIterable extends core.Iterable$(E) {
      new(map, isKeys) {
        this[_map$0] = map;
        this[_isKeys] = isKeys;
        super.new();
      }
      get length() {
        return core.int._check(dart.dload(this[_map$0], 'length'));
      }
      get isEmpty() {
        return core.bool._check(dart.dload(this[_map$0], 'isEmpty'));
      }
      get iterator() {
        return new (_Es6MapIteratorOfE())(this[_map$0], core.int._check(dart.dload(this[_map$0], _modifications$)), this[_isKeys]);
      }
      contains(element) {
        return core.bool._check(dart.dsend(this[_map$0], 'containsKey', element));
      }
      forEach(f) {
        let jsIterator = null;
        if (dart.test(this[_isKeys])) {
          jsIterator = dart.dload(this[_map$0], _map$0).keys();
        } else {
          jsIterator = dart.dload(this[_map$0], _map$0).values();
        }
        let modifications = core.int._check(dart.dload(this[_map$0], _modifications$));
        while (true) {
          let next = jsIterator.next();
          let done = next.done;
          if (done) break;
          let value = next.value;
          f(E._check(value));
          if (!dart.equals(modifications, dart.dload(this[_map$0], _modifications$))) {
            dart.throw(new core.ConcurrentModificationError(this[_map$0]));
          }
        }
      }
    }
    _Es6MapIterable[dart.implements] = () => [_internal.EfficientLength];
    dart.setSignature(_Es6MapIterable, {
      constructors: () => ({new: dart.definiteFunctionType(collection._Es6MapIterable$(E), [dart.dynamic, core.bool])}),
      methods: () => ({forEach: dart.definiteFunctionType(dart.void, [dart.functionType(dart.void, [E])])})
    });
    dart.defineExtensionMembers(_Es6MapIterable, [
      'contains',
      'forEach',
      'length',
      'isEmpty',
      'iterator'
    ]);
    return _Es6MapIterable;
  });
  collection._Es6MapIterable = _Es6MapIterable();
  const _jsIterator$ = Symbol('_jsIterator');
  const _next$0 = Symbol('_next');
  const _done = Symbol('_done');
  collection._Es6MapIterator$ = dart.generic(E => {
    let IteratorOfE = () => (IteratorOfE = dart.constFn(core.Iterator$(E)))();
    class _Es6MapIterator extends core.Object {
      new(map, modifications, isKeys) {
        this[_map$0] = map;
        this[_modifications$] = modifications;
        this[_isKeys] = isKeys;
        this[_jsIterator$] = null;
        this[_next$0] = null;
        this[_current$2] = null;
        this[_done] = null;
        if (dart.test(this[_isKeys])) {
          this[_jsIterator$] = dart.dload(this[_map$0], _map$0).keys();
        } else {
          this[_jsIterator$] = dart.dload(this[_map$0], _map$0).values();
        }
        this[_done] = false;
      }
      get current() {
        return this[_current$2];
      }
      moveNext() {
        if (!dart.equals(this[_modifications$], dart.dload(this[_map$0], _modifications$))) {
          dart.throw(new core.ConcurrentModificationError(this[_map$0]));
        }
        if (dart.test(this[_done])) return false;
        this[_next$0] = this[_jsIterator$].next();
        let done = this[_next$0].done;
        if (done) {
          this[_current$2] = null;
          this[_done] = true;
          return false;
        } else {
          this[_current$2] = this[_next$0].value;
          return true;
        }
      }
    }
    dart.addTypeTests(_Es6MapIterator);
    _Es6MapIterator[dart.implements] = () => [IteratorOfE()];
    dart.setSignature(_Es6MapIterator, {
      constructors: () => ({new: dart.definiteFunctionType(collection._Es6MapIterator$(E), [dart.dynamic, core.int, core.bool])}),
      methods: () => ({moveNext: dart.definiteFunctionType(core.bool, [])})
    });
    return _Es6MapIterator;
  });
  collection._Es6MapIterator = _Es6MapIterator();
  collection._LinkedCustomHashMap$ = dart.generic((K, V) => {
    class _LinkedCustomHashMap extends _js_helper.JsLinkedHashMap$(K, V) {
      new(equals, hashCode, validKey) {
        this[_equals$] = equals;
        this[_hashCode] = hashCode;
        this[_validKey] = validKey != null ? validKey : dart.fn(v => K.is(v), ObjectTobool$());
        super.new();
      }
      get(key) {
        if (!dart.test(this[_validKey](key))) return null;
        return super.internalGet(key);
      }
      set(key, value) {
        K._check(key);
        V._check(value);
        super.internalSet(key, value);
        return value;
      }
      containsKey(key) {
        if (!dart.test(this[_validKey](key))) return false;
        return super.internalContainsKey(key);
      }
      remove(key) {
        if (!dart.test(this[_validKey](key))) return null;
        return super.internalRemove(key);
      }
      internalComputeHashCode(key) {
        return this[_hashCode](K._check(key)) & 0x3ffffff;
      }
      internalFindBucketIndex(bucket, key) {
        if (bucket == null) return -1;
        let length = bucket.length;
        for (let i = 0; i < length; i++) {
          let cell = bucket[i];
          if (dart.test(this[_equals$](cell.hashMapCellKey, K._check(key)))) return i;
        }
        return -1;
      }
    }
    dart.setSignature(_LinkedCustomHashMap, {
      constructors: () => ({new: dart.definiteFunctionType(collection._LinkedCustomHashMap$(K, V), [collection._Equality$(K), collection._Hasher$(K), dart.functionType(core.bool, [core.Object])])}),
      methods: () => ({
        get: dart.definiteFunctionType(V, [core.Object]),
        set: dart.definiteFunctionType(dart.void, [K, V]),
        remove: dart.definiteFunctionType(V, [core.Object])
      })
    });
    dart.defineExtensionMembers(_LinkedCustomHashMap, ['get', 'set', 'containsKey', 'remove']);
    return _LinkedCustomHashMap;
  });
  collection._LinkedCustomHashMap = _LinkedCustomHashMap();
  const _elements = Symbol('_elements');
  const _newSet = Symbol('_newSet');
  const _computeElements = Symbol('_computeElements');
  const _contains = Symbol('_contains');
  const _lookup = Symbol('_lookup');
  const _add$0 = Symbol('_add');
  collection.SetMixin$ = dart.generic(E => {
    let IterableOfE = () => (IterableOfE = dart.constFn(core.Iterable$(E)))();
    let SetOfE = () => (SetOfE = dart.constFn(core.Set$(E)))();
    let ListOfE = () => (ListOfE = dart.constFn(core.List$(E)))();
    let WhereIterableOfE = () => (WhereIterableOfE = dart.constFn(_internal.WhereIterable$(E)))();
    let EAndEToE = () => (EAndEToE = dart.constFn(dart.functionType(E, [E, E])))();
    let TakeIterableOfE = () => (TakeIterableOfE = dart.constFn(_internal.TakeIterable$(E)))();
    let TakeWhileIterableOfE = () => (TakeWhileIterableOfE = dart.constFn(_internal.TakeWhileIterable$(E)))();
    let SkipIterableOfE = () => (SkipIterableOfE = dart.constFn(_internal.SkipIterable$(E)))();
    let SkipWhileIterableOfE = () => (SkipWhileIterableOfE = dart.constFn(_internal.SkipWhileIterable$(E)))();
    let VoidToE = () => (VoidToE = dart.constFn(dart.functionType(E, [])))();
    class SetMixin extends core.Object {
      [Symbol.iterator]() {
        return new dart.JsIterator(this.iterator);
      }
      get isEmpty() {
        return this.length == 0;
      }
      get isNotEmpty() {
        return this.length != 0;
      }
      clear() {
        this.removeAll(this.toList());
      }
      addAll(elements) {
        IterableOfE()._check(elements);
        for (let element of elements)
          this.add(element);
      }
      removeAll(elements) {
        for (let element of elements)
          this.remove(element);
      }
      retainAll(elements) {
        let toRemove = this.toSet();
        for (let o of elements) {
          toRemove.remove(o);
        }
        this.removeAll(toRemove);
      }
      removeWhere(test) {
        let toRemove = [];
        for (let element of this) {
          if (dart.test(test(element))) toRemove[dartx.add](element);
        }
        this.removeAll(toRemove);
      }
      retainWhere(test) {
        let toRemove = [];
        for (let element of this) {
          if (!dart.test(test(element))) toRemove[dartx.add](element);
        }
        this.removeAll(toRemove);
      }
      containsAll(other) {
        for (let o of other) {
          if (!dart.test(this.contains(o))) return false;
        }
        return true;
      }
      union(other) {
        SetOfE()._check(other);
        let _ = this.toSet();
        _.addAll(other);
        return _;
      }
      intersection(other) {
        let result = this.toSet();
        for (let element of this) {
          if (!dart.test(other.contains(element))) result.remove(element);
        }
        return result;
      }
      difference(other) {
        let result = this.toSet();
        for (let element of this) {
          if (dart.test(other.contains(element))) result.remove(element);
        }
        return result;
      }
      toList(opts) {
        let growable = opts && 'growable' in opts ? opts.growable : true;
        let result = dart.test(growable) ? (() => {
          let _ = ListOfE().new();
          _[dartx.length] = this.length;
          return _;
        })() : ListOfE().new(this.length);
        let i = 0;
        for (let element of this)
          result[dartx.set](i++, element);
        return result;
      }
      map(T) {
        return f => {
          return new (_internal.EfficientLengthMappedIterable$(E, T))(this, f);
        };
      }
      get single() {
        if (dart.notNull(this.length) > 1) dart.throw(_internal.IterableElementError.tooMany());
        let it = this.iterator;
        if (!dart.test(it.moveNext())) dart.throw(_internal.IterableElementError.noElement());
        let result = it.current;
        return result;
      }
      toString() {
        return collection.IterableBase.iterableToFullString(this, '{', '}');
      }
      where(f) {
        return new (WhereIterableOfE())(this, f);
      }
      expand(T) {
        return f => {
          return new (_internal.ExpandIterable$(E, T))(this, f);
        };
      }
      forEach(f) {
        for (let element of this)
          f(element);
      }
      reduce(combine) {
        EAndEToE()._check(combine);
        let iterator = this.iterator;
        if (!dart.test(iterator.moveNext())) {
          dart.throw(_internal.IterableElementError.noElement());
        }
        let value = iterator.current;
        while (dart.test(iterator.moveNext())) {
          value = combine(value, iterator.current);
        }
        return value;
      }
      fold(T) {
        return (initialValue, combine) => {
          let value = initialValue;
          for (let element of this)
            value = combine(value, element);
          return value;
        };
      }
      every(f) {
        for (let element of this) {
          if (!dart.test(f(element))) return false;
        }
        return true;
      }
      join(separator) {
        if (separator === void 0) separator = "";
        let iterator = this.iterator;
        if (!dart.test(iterator.moveNext())) return "";
        let buffer = new core.StringBuffer();
        if (separator == null || separator == "") {
          do {
            buffer.write(dart.str`${iterator.current}`);
          } while (dart.test(iterator.moveNext()));
        } else {
          buffer.write(dart.str`${iterator.current}`);
          while (dart.test(iterator.moveNext())) {
            buffer.write(separator);
            buffer.write(dart.str`${iterator.current}`);
          }
        }
        return buffer.toString();
      }
      any(test) {
        for (let element of this) {
          if (dart.test(test(element))) return true;
        }
        return false;
      }
      take(n) {
        return TakeIterableOfE().new(this, n);
      }
      takeWhile(test) {
        return new (TakeWhileIterableOfE())(this, test);
      }
      skip(n) {
        return SkipIterableOfE().new(this, n);
      }
      skipWhile(test) {
        return new (SkipWhileIterableOfE())(this, test);
      }
      get first() {
        let it = this.iterator;
        if (!dart.test(it.moveNext())) {
          dart.throw(_internal.IterableElementError.noElement());
        }
        return it.current;
      }
      get last() {
        let it = this.iterator;
        if (!dart.test(it.moveNext())) {
          dart.throw(_internal.IterableElementError.noElement());
        }
        let result = null;
        do {
          result = it.current;
        } while (dart.test(it.moveNext()));
        return result;
      }
      firstWhere(test, opts) {
        let orElse = opts && 'orElse' in opts ? opts.orElse : null;
        VoidToE()._check(orElse);
        for (let element of this) {
          if (dart.test(test(element))) return element;
        }
        if (orElse != null) return orElse();
        dart.throw(_internal.IterableElementError.noElement());
      }
      lastWhere(test, opts) {
        let orElse = opts && 'orElse' in opts ? opts.orElse : null;
        VoidToE()._check(orElse);
        let result = null;
        let foundMatching = false;
        for (let element of this) {
          if (dart.test(test(element))) {
            result = element;
            foundMatching = true;
          }
        }
        if (foundMatching) return result;
        if (orElse != null) return orElse();
        dart.throw(_internal.IterableElementError.noElement());
      }
      singleWhere(test) {
        let result = null;
        let foundMatching = false;
        for (let element of this) {
          if (dart.test(test(element))) {
            if (foundMatching) {
              dart.throw(_internal.IterableElementError.tooMany());
            }
            result = element;
            foundMatching = true;
          }
        }
        if (foundMatching) return result;
        dart.throw(_internal.IterableElementError.noElement());
      }
      elementAt(index) {
        if (!(typeof index == 'number')) dart.throw(new core.ArgumentError.notNull("index"));
        core.RangeError.checkNotNegative(index, "index");
        let elementIndex = 0;
        for (let element of this) {
          if (index == elementIndex) return element;
          elementIndex++;
        }
        dart.throw(core.RangeError.index(index, this, "index", null, elementIndex));
      }
    }
    dart.addTypeTests(SetMixin);
    SetMixin[dart.implements] = () => [SetOfE()];
    dart.setSignature(SetMixin, {
      methods: () => ({
        clear: dart.definiteFunctionType(dart.void, []),
        addAll: dart.definiteFunctionType(dart.void, [core.Iterable$(E)]),
        removeAll: dart.definiteFunctionType(dart.void, [core.Iterable$(core.Object)]),
        retainAll: dart.definiteFunctionType(dart.void, [core.Iterable$(core.Object)]),
        removeWhere: dart.definiteFunctionType(dart.void, [dart.functionType(core.bool, [E])]),
        retainWhere: dart.definiteFunctionType(dart.void, [dart.functionType(core.bool, [E])]),
        containsAll: dart.definiteFunctionType(core.bool, [core.Iterable$(core.Object)]),
        union: dart.definiteFunctionType(core.Set$(E), [core.Set$(E)]),
        intersection: dart.definiteFunctionType(core.Set$(E), [core.Set$(core.Object)]),
        difference: dart.definiteFunctionType(core.Set$(E), [core.Set$(core.Object)]),
        toList: dart.definiteFunctionType(core.List$(E), [], {growable: core.bool}),
        map: dart.definiteFunctionType(T => [core.Iterable$(T), [dart.functionType(T, [E])]]),
        where: dart.definiteFunctionType(core.Iterable$(E), [dart.functionType(core.bool, [E])]),
        expand: dart.definiteFunctionType(T => [core.Iterable$(T), [dart.functionType(core.Iterable$(T), [E])]]),
        forEach: dart.definiteFunctionType(dart.void, [dart.functionType(dart.void, [E])]),
        reduce: dart.definiteFunctionType(E, [dart.functionType(E, [E, E])]),
        fold: dart.definiteFunctionType(T => [T, [T, dart.functionType(T, [T, E])]]),
        every: dart.definiteFunctionType(core.bool, [dart.functionType(core.bool, [E])]),
        join: dart.definiteFunctionType(core.String, [], [core.String]),
        any: dart.definiteFunctionType(core.bool, [dart.functionType(core.bool, [E])]),
        take: dart.definiteFunctionType(core.Iterable$(E), [core.int]),
        takeWhile: dart.definiteFunctionType(core.Iterable$(E), [dart.functionType(core.bool, [E])]),
        skip: dart.definiteFunctionType(core.Iterable$(E), [core.int]),
        skipWhile: dart.definiteFunctionType(core.Iterable$(E), [dart.functionType(core.bool, [E])]),
        firstWhere: dart.definiteFunctionType(E, [dart.functionType(core.bool, [E])], {orElse: VoidToE()}),
        lastWhere: dart.definiteFunctionType(E, [dart.functionType(core.bool, [E])], {orElse: VoidToE()}),
        singleWhere: dart.definiteFunctionType(E, [dart.functionType(core.bool, [E])]),
        elementAt: dart.definiteFunctionType(E, [core.int])
      })
    });
    dart.defineExtensionMembers(SetMixin, [
      'toList',
      'map',
      'toString',
      'where',
      'expand',
      'forEach',
      'reduce',
      'fold',
      'every',
      'join',
      'any',
      'take',
      'takeWhile',
      'skip',
      'skipWhile',
      'firstWhere',
      'lastWhere',
      'singleWhere',
      'elementAt',
      'isEmpty',
      'isNotEmpty',
      'single',
      'first',
      'last'
    ]);
    return SetMixin;
  });
  collection.SetMixin = SetMixin();
  collection.SetBase$ = dart.generic(E => {
    class SetBase extends collection.SetMixin$(E) {
      static setToString(set) {
        return collection.IterableBase.iterableToFullString(set, '{', '}');
      }
    }
    dart.setSignature(SetBase, {
      statics: () => ({setToString: dart.definiteFunctionType(core.String, [core.Set])}),
      names: ['setToString']
    });
    return SetBase;
  });
  collection.SetBase = SetBase();
  collection._HashSetBase$ = dart.generic(E => {
    class _HashSetBase extends collection.SetBase$(E) {
      difference(other) {
        let result = this[_newSet]();
        for (let element of this) {
          if (!dart.test(other.contains(element))) result.add(element);
        }
        return result;
      }
      intersection(other) {
        let result = this[_newSet]();
        for (let element of this) {
          if (dart.test(other.contains(element))) result.add(element);
        }
        return result;
      }
      toSet() {
        return (() => {
          let _ = this[_newSet]();
          _.addAll(this);
          return _;
        })();
      }
    }
    dart.setSignature(_HashSetBase, {
      methods: () => ({
        difference: dart.definiteFunctionType(core.Set$(E), [core.Set$(core.Object)]),
        intersection: dart.definiteFunctionType(core.Set$(E), [core.Set$(core.Object)]),
        toSet: dart.definiteFunctionType(core.Set$(E), [])
      })
    });
    dart.defineExtensionMembers(_HashSetBase, ['toSet']);
    return _HashSetBase;
  });
  collection._HashSetBase = _HashSetBase();
  collection._HashSet$ = dart.generic(E => {
    let _HashSetOfE = () => (_HashSetOfE = dart.constFn(collection._HashSet$(E)))();
    let _HashSetIteratorOfE = () => (_HashSetIteratorOfE = dart.constFn(collection._HashSetIterator$(E)))();
    let IterableOfE = () => (IterableOfE = dart.constFn(core.Iterable$(E)))();
    let ListOfE = () => (ListOfE = dart.constFn(core.List$(E)))();
    let HashSetOfE = () => (HashSetOfE = dart.constFn(collection.HashSet$(E)))();
    class _HashSet extends collection._HashSetBase$(E) {
      new() {
        this[_length$1] = 0;
        this[_strings$] = null;
        this[_nums$] = null;
        this[_rest$] = null;
        this[_elements] = null;
      }
      [_newSet]() {
        return new (_HashSetOfE())();
      }
      get iterator() {
        return new (_HashSetIteratorOfE())(this, this[_computeElements]());
      }
      get length() {
        return this[_length$1];
      }
      get isEmpty() {
        return this[_length$1] == 0;
      }
      get isNotEmpty() {
        return !dart.test(this.isEmpty);
      }
      contains(object) {
        if (dart.test(collection._HashSet._isStringElement(object))) {
          let strings = this[_strings$];
          return strings == null ? false : collection._HashSet._hasTableEntry(strings, object);
        } else if (dart.test(collection._HashSet._isNumericElement(object))) {
          let nums = this[_nums$];
          return nums == null ? false : collection._HashSet._hasTableEntry(nums, object);
        } else {
          return this[_contains](object);
        }
      }
      [_contains](object) {
        let rest = this[_rest$];
        if (rest == null) return false;
        let bucket = this[_getBucket$](rest, object);
        return dart.notNull(this[_findBucketIndex](bucket, object)) >= 0;
      }
      lookup(object) {
        if (dart.test(collection._HashSet._isStringElement(object)) || dart.test(collection._HashSet._isNumericElement(object))) {
          return E._check(dart.test(this.contains(object)) ? object : null);
        }
        return this[_lookup](object);
      }
      [_lookup](object) {
        let rest = this[_rest$];
        if (rest == null) return null;
        let bucket = this[_getBucket$](rest, object);
        let index = this[_findBucketIndex](bucket, object);
        if (dart.notNull(index) < 0) return null;
        return bucket[dartx.get](index);
      }
      add(element) {
        E._check(element);
        if (dart.test(collection._HashSet._isStringElement(element))) {
          let strings = this[_strings$];
          if (strings == null) this[_strings$] = strings = collection._HashSet._newHashTable();
          return this[_addHashTableEntry$](strings, element);
        } else if (dart.test(collection._HashSet._isNumericElement(element))) {
          let nums = this[_nums$];
          if (nums == null) this[_nums$] = nums = collection._HashSet._newHashTable();
          return this[_addHashTableEntry$](nums, element);
        } else {
          return this[_add$0](element);
        }
      }
      [_add$0](element) {
        E._check(element);
        let rest = this[_rest$];
        if (rest == null) this[_rest$] = rest = collection._HashSet._newHashTable();
        let hash = this[_computeHashCode](element);
        let bucket = rest[hash];
        if (bucket == null) {
          collection._HashSet._setTableEntry(rest, hash, [element]);
        } else {
          let index = this[_findBucketIndex](bucket, element);
          if (dart.notNull(index) >= 0) return false;
          bucket.push(element);
        }
        this[_length$1] = dart.notNull(this[_length$1]) + 1;
        this[_elements] = null;
        return true;
      }
      addAll(objects) {
        IterableOfE()._check(objects);
        for (let each of objects) {
          this.add(each);
        }
      }
      remove(object) {
        if (dart.test(collection._HashSet._isStringElement(object))) {
          return this[_removeHashTableEntry$](this[_strings$], object);
        } else if (dart.test(collection._HashSet._isNumericElement(object))) {
          return this[_removeHashTableEntry$](this[_nums$], object);
        } else {
          return this[_remove](object);
        }
      }
      [_remove](object) {
        let rest = this[_rest$];
        if (rest == null) return false;
        let bucket = this[_getBucket$](rest, object);
        let index = this[_findBucketIndex](bucket, object);
        if (dart.notNull(index) < 0) return false;
        this[_length$1] = dart.notNull(this[_length$1]) - 1;
        this[_elements] = null;
        bucket.splice(index, 1);
        return true;
      }
      clear() {
        if (dart.notNull(this[_length$1]) > 0) {
          this[_strings$] = this[_nums$] = this[_rest$] = this[_elements] = null;
          this[_length$1] = 0;
        }
      }
      [_computeElements]() {
        if (this[_elements] != null) return this[_elements];
        let result = ListOfE().new(this[_length$1]);
        let index = 0;
        let strings = this[_strings$];
        if (strings != null) {
          let names = Object.getOwnPropertyNames(strings);
          let entries = names.length;
          for (let i = 0; i < entries; i++) {
            let element = names[i];
            result[index] = element;
            index++;
          }
        }
        let nums = this[_nums$];
        if (nums != null) {
          let names = Object.getOwnPropertyNames(nums);
          let entries = names.length;
          for (let i = 0; i < entries; i++) {
            let element = +names[i];
            result[index] = element;
            index++;
          }
        }
        let rest = this[_rest$];
        if (rest != null) {
          let names = Object.getOwnPropertyNames(rest);
          let entries = names.length;
          for (let i = 0; i < entries; i++) {
            let entry = names[i];
            let bucket = rest[entry];
            let length = bucket.length;
            for (let i = 0; i < length; i++) {
              result[index] = bucket[i];
              index++;
            }
          }
        }
        dart.assert(index == this[_length$1]);
        return this[_elements] = result;
      }
      [_addHashTableEntry$](table, element) {
        E._check(element);
        if (dart.test(collection._HashSet._hasTableEntry(table, element))) return false;
        collection._HashSet._setTableEntry(table, element, 0);
        this[_length$1] = dart.notNull(this[_length$1]) + 1;
        this[_elements] = null;
        return true;
      }
      [_removeHashTableEntry$](table, element) {
        if (table != null && dart.test(collection._HashSet._hasTableEntry(table, element))) {
          collection._HashSet._deleteTableEntry(table, element);
          this[_length$1] = dart.notNull(this[_length$1]) - 1;
          this[_elements] = null;
          return true;
        } else {
          return false;
        }
      }
      static _isStringElement(element) {
        return typeof element == 'string' && element != '__proto__';
      }
      static _isNumericElement(element) {
        return typeof element == 'number' && (element & 0x3ffffff) === element;
      }
      [_computeHashCode](element) {
        return dart.hashCode(element) & 0x3ffffff;
      }
      static _hasTableEntry(table, key) {
        let entry = table[key];
        return entry != null;
      }
      static _setTableEntry(table, key, value) {
        dart.assert(value != null);
        table[key] = value;
      }
      static _deleteTableEntry(table, key) {
        delete table[key];
      }
      [_getBucket$](table, element) {
        let hash = this[_computeHashCode](element);
        return table[hash];
      }
      [_findBucketIndex](bucket, element) {
        if (bucket == null) return -1;
        let length = bucket.length;
        for (let i = 0; i < length; i++) {
          if (dart.equals(bucket[i], element)) return i;
        }
        return -1;
      }
      static _newHashTable() {
        let table = Object.create(null);
        let temporaryKey = '<non-identifier-key>';
        collection._HashSet._setTableEntry(table, temporaryKey, table);
        collection._HashSet._deleteTableEntry(table, temporaryKey);
        return table;
      }
    }
    _HashSet[dart.implements] = () => [HashSetOfE()];
    dart.setSignature(_HashSet, {
      constructors: () => ({new: dart.definiteFunctionType(collection._HashSet$(E), [])}),
      methods: () => ({
        [_newSet]: dart.definiteFunctionType(core.Set$(E), []),
        contains: dart.definiteFunctionType(core.bool, [core.Object]),
        [_contains]: dart.definiteFunctionType(core.bool, [core.Object]),
        lookup: dart.definiteFunctionType(E, [core.Object]),
        [_lookup]: dart.definiteFunctionType(E, [core.Object]),
        add: dart.definiteFunctionType(core.bool, [E]),
        [_add$0]: dart.definiteFunctionType(core.bool, [E]),
        addAll: dart.definiteFunctionType(dart.void, [core.Iterable$(E)]),
        remove: dart.definiteFunctionType(core.bool, [core.Object]),
        [_remove]: dart.definiteFunctionType(core.bool, [core.Object]),
        [_computeElements]: dart.definiteFunctionType(core.List$(E), []),
        [_addHashTableEntry$]: dart.definiteFunctionType(core.bool, [dart.dynamic, E]),
        [_removeHashTableEntry$]: dart.definiteFunctionType(core.bool, [dart.dynamic, core.Object]),
        [_computeHashCode]: dart.definiteFunctionType(core.int, [dart.dynamic]),
        [_getBucket$]: dart.definiteFunctionType(core.List$(E), [dart.dynamic, dart.dynamic]),
        [_findBucketIndex]: dart.definiteFunctionType(core.int, [dart.dynamic, dart.dynamic])
      }),
      statics: () => ({
        _isStringElement: dart.definiteFunctionType(core.bool, [dart.dynamic]),
        _isNumericElement: dart.definiteFunctionType(core.bool, [dart.dynamic]),
        _hasTableEntry: dart.definiteFunctionType(core.bool, [dart.dynamic, dart.dynamic]),
        _setTableEntry: dart.definiteFunctionType(dart.void, [dart.dynamic, dart.dynamic, dart.dynamic]),
        _deleteTableEntry: dart.definiteFunctionType(dart.void, [dart.dynamic, dart.dynamic]),
        _newHashTable: dart.definiteFunctionType(dart.dynamic, [])
      }),
      names: ['_isStringElement', '_isNumericElement', '_hasTableEntry', '_setTableEntry', '_deleteTableEntry', '_newHashTable']
    });
    dart.defineExtensionMembers(_HashSet, [
      'contains',
      'iterator',
      'length',
      'isEmpty',
      'isNotEmpty'
    ]);
    return _HashSet;
  });
  collection._HashSet = _HashSet();
  collection._IdentityHashSet$ = dart.generic(E => {
    let _IdentityHashSetOfE = () => (_IdentityHashSetOfE = dart.constFn(collection._IdentityHashSet$(E)))();
    class _IdentityHashSet extends collection._HashSet$(E) {
      new() {
        super.new();
      }
      [_newSet]() {
        return new (_IdentityHashSetOfE())();
      }
      [_computeHashCode](key) {
        return core.identityHashCode(key) & 0x3ffffff;
      }
      [_findBucketIndex](bucket, element) {
        if (bucket == null) return -1;
        let length = bucket.length;
        for (let i = 0; i < length; i++) {
          if (core.identical(bucket[i], element)) return i;
        }
        return -1;
      }
    }
    dart.setSignature(_IdentityHashSet, {
      methods: () => ({[_newSet]: dart.definiteFunctionType(core.Set$(E), [])})
    });
    return _IdentityHashSet;
  });
  collection._IdentityHashSet = _IdentityHashSet();
  const _equality = Symbol('_equality');
  const _hasher = Symbol('_hasher');
  collection._CustomHashSet$ = dart.generic(E => {
    let _CustomHashSetOfE = () => (_CustomHashSetOfE = dart.constFn(collection._CustomHashSet$(E)))();
    class _CustomHashSet extends collection._HashSet$(E) {
      new(equality, hasher, validKey) {
        this[_equality] = equality;
        this[_hasher] = hasher;
        this[_validKey] = validKey != null ? validKey : dart.fn(x => E.is(x), ObjectTobool$());
        super.new();
      }
      [_newSet]() {
        return new (_CustomHashSetOfE())(this[_equality], this[_hasher], this[_validKey]);
      }
      [_findBucketIndex](bucket, element) {
        if (bucket == null) return -1;
        let length = bucket.length;
        for (let i = 0; i < length; i++) {
          if (dart.test(this[_equality](bucket[i], E._check(element)))) return i;
        }
        return -1;
      }
      [_computeHashCode](element) {
        return this[_hasher](E._check(element)) & 0x3ffffff;
      }
      add(object) {
        E._check(object);
        return super[_add$0](object);
      }
      contains(object) {
        if (!dart.test(this[_validKey](object))) return false;
        return super[_contains](object);
      }
      lookup(object) {
        if (!dart.test(this[_validKey](object))) return null;
        return super[_lookup](object);
      }
      remove(object) {
        if (!dart.test(this[_validKey](object))) return false;
        return super[_remove](object);
      }
    }
    dart.setSignature(_CustomHashSet, {
      constructors: () => ({new: dart.definiteFunctionType(collection._CustomHashSet$(E), [collection._Equality$(E), collection._Hasher$(E), dart.functionType(core.bool, [core.Object])])}),
      methods: () => ({
        [_newSet]: dart.definiteFunctionType(core.Set$(E), []),
        add: dart.definiteFunctionType(core.bool, [E]),
        lookup: dart.definiteFunctionType(E, [core.Object])
      })
    });
    dart.defineExtensionMembers(_CustomHashSet, ['contains']);
    return _CustomHashSet;
  });
  collection._CustomHashSet = _CustomHashSet();
  collection._HashSetIterator$ = dart.generic(E => {
    let IteratorOfE = () => (IteratorOfE = dart.constFn(core.Iterator$(E)))();
    class _HashSetIterator extends core.Object {
      new(set, elements) {
        this[_set] = set;
        this[_elements] = elements;
        this[_offset] = 0;
        this[_current$2] = null;
      }
      get current() {
        return this[_current$2];
      }
      moveNext() {
        let elements = this[_elements];
        let offset = this[_offset];
        if (elements !== dart.dload(this[_set], _elements)) {
          dart.throw(new core.ConcurrentModificationError(this[_set]));
        } else if (dart.notNull(offset) >= elements.length) {
          this[_current$2] = null;
          return false;
        } else {
          this[_current$2] = elements[offset];
          this[_offset] = dart.notNull(offset) + 1;
          return true;
        }
      }
    }
    dart.addTypeTests(_HashSetIterator);
    _HashSetIterator[dart.implements] = () => [IteratorOfE()];
    dart.setSignature(_HashSetIterator, {
      constructors: () => ({new: dart.definiteFunctionType(collection._HashSetIterator$(E), [dart.dynamic, core.List$(E)])}),
      methods: () => ({moveNext: dart.definiteFunctionType(core.bool, [])})
    });
    return _HashSetIterator;
  });
  collection._HashSetIterator = _HashSetIterator();
  const _first$ = Symbol('_first');
  const _last$ = Symbol('_last');
  const _unsupported = Symbol('_unsupported');
  const _getTableEntry = Symbol('_getTableEntry');
  const _element = Symbol('_element');
  const _newLinkedCell$ = Symbol('_newLinkedCell');
  const _unlinkCell$ = Symbol('_unlinkCell');
  const _filterWhere = Symbol('_filterWhere');
  const _previous$0 = Symbol('_previous');
  collection._LinkedHashSet$ = dart.generic(E => {
    let _LinkedHashSetOfE = () => (_LinkedHashSetOfE = dart.constFn(collection._LinkedHashSet$(E)))();
    let _LinkedHashSetIteratorOfE = () => (_LinkedHashSetIteratorOfE = dart.constFn(collection._LinkedHashSetIterator$(E)))();
    let _LinkedHashSetCellOfE = () => (_LinkedHashSetCellOfE = dart.constFn(collection._LinkedHashSetCell$(E)))();
    let LinkedHashSetOfE = () => (LinkedHashSetOfE = dart.constFn(collection.LinkedHashSet$(E)))();
    class _LinkedHashSet extends collection._HashSetBase$(E) {
      new() {
        this[_length$1] = 0;
        this[_strings$] = null;
        this[_nums$] = null;
        this[_rest$] = null;
        this[_first$] = null;
        this[_last$] = null;
        this[_modifications$] = 0;
      }
      [_newSet]() {
        return new (_LinkedHashSetOfE())();
      }
      [_unsupported](operation) {
        dart.throw(dart.str`LinkedHashSet: unsupported ${operation}`);
      }
      get iterator() {
        return new (_LinkedHashSetIteratorOfE())(this, this[_modifications$]);
      }
      get length() {
        return this[_length$1];
      }
      get isEmpty() {
        return this[_length$1] == 0;
      }
      get isNotEmpty() {
        return !dart.test(this.isEmpty);
      }
      contains(object) {
        if (dart.test(collection._LinkedHashSet._isStringElement(object))) {
          let strings = this[_strings$];
          if (strings == null) return false;
          let cell = this[_getTableEntry](strings, object);
          return cell != null;
        } else if (dart.test(collection._LinkedHashSet._isNumericElement(object))) {
          let nums = this[_nums$];
          if (nums == null) return false;
          let cell = this[_getTableEntry](nums, object);
          return cell != null;
        } else {
          return this[_contains](object);
        }
      }
      [_contains](object) {
        let rest = this[_rest$];
        if (rest == null) return false;
        let bucket = this[_getBucket$](rest, object);
        return dart.notNull(this[_findBucketIndex](bucket, object)) >= 0;
      }
      lookup(object) {
        if (dart.test(collection._LinkedHashSet._isStringElement(object)) || dart.test(collection._LinkedHashSet._isNumericElement(object))) {
          return E._check(dart.test(this.contains(object)) ? object : null);
        } else {
          return this[_lookup](object);
        }
      }
      [_lookup](object) {
        let rest = this[_rest$];
        if (rest == null) return null;
        let bucket = this[_getBucket$](rest, object);
        let index = this[_findBucketIndex](bucket, object);
        if (dart.notNull(index) < 0) return null;
        return bucket[dartx.get](index)[_element];
      }
      forEach(action) {
        let cell = this[_first$];
        let modifications = this[_modifications$];
        while (cell != null) {
          action(cell[_element]);
          if (modifications != this[_modifications$]) {
            dart.throw(new core.ConcurrentModificationError(this));
          }
          cell = cell[_next$0];
        }
      }
      get first() {
        if (this[_first$] == null) dart.throw(new core.StateError("No elements"));
        return this[_first$][_element];
      }
      get last() {
        if (this[_last$] == null) dart.throw(new core.StateError("No elements"));
        return this[_last$][_element];
      }
      add(element) {
        E._check(element);
        if (dart.test(collection._LinkedHashSet._isStringElement(element))) {
          let strings = this[_strings$];
          if (strings == null) this[_strings$] = strings = collection._LinkedHashSet._newHashTable();
          return this[_addHashTableEntry$](strings, element);
        } else if (dart.test(collection._LinkedHashSet._isNumericElement(element))) {
          let nums = this[_nums$];
          if (nums == null) this[_nums$] = nums = collection._LinkedHashSet._newHashTable();
          return this[_addHashTableEntry$](nums, element);
        } else {
          return this[_add$0](element);
        }
      }
      [_add$0](element) {
        E._check(element);
        let rest = this[_rest$];
        if (rest == null) this[_rest$] = rest = collection._LinkedHashSet._newHashTable();
        let hash = this[_computeHashCode](element);
        let bucket = rest[hash];
        if (bucket == null) {
          let cell = this[_newLinkedCell$](element);
          collection._LinkedHashSet._setTableEntry(rest, hash, [cell]);
        } else {
          let index = this[_findBucketIndex](bucket, element);
          if (dart.notNull(index) >= 0) return false;
          let cell = this[_newLinkedCell$](element);
          bucket.push(cell);
        }
        return true;
      }
      remove(object) {
        if (dart.test(collection._LinkedHashSet._isStringElement(object))) {
          return this[_removeHashTableEntry$](this[_strings$], object);
        } else if (dart.test(collection._LinkedHashSet._isNumericElement(object))) {
          return this[_removeHashTableEntry$](this[_nums$], object);
        } else {
          return this[_remove](object);
        }
      }
      [_remove](object) {
        let rest = this[_rest$];
        if (rest == null) return false;
        let bucket = this[_getBucket$](rest, object);
        let index = this[_findBucketIndex](bucket, object);
        if (dart.notNull(index) < 0) return false;
        let cell = bucket.splice(index, 1)[0];
        this[_unlinkCell$](cell);
        return true;
      }
      removeWhere(test) {
        this[_filterWhere](test, true);
      }
      retainWhere(test) {
        this[_filterWhere](test, false);
      }
      [_filterWhere](test, removeMatching) {
        let cell = this[_first$];
        while (cell != null) {
          let element = cell[_element];
          let next = cell[_next$0];
          let modifications = this[_modifications$];
          let shouldRemove = removeMatching == test(element);
          if (modifications != this[_modifications$]) {
            dart.throw(new core.ConcurrentModificationError(this));
          }
          if (shouldRemove) this.remove(element);
          cell = next;
        }
      }
      clear() {
        if (dart.notNull(this[_length$1]) > 0) {
          this[_strings$] = this[_nums$] = this[_rest$] = this[_first$] = this[_last$] = null;
          this[_length$1] = 0;
          this[_modified$]();
        }
      }
      [_addHashTableEntry$](table, element) {
        E._check(element);
        let cell = this[_getTableEntry](table, element);
        if (cell != null) return false;
        collection._LinkedHashSet._setTableEntry(table, element, this[_newLinkedCell$](element));
        return true;
      }
      [_removeHashTableEntry$](table, element) {
        if (table == null) return false;
        let cell = this[_getTableEntry](table, element);
        if (cell == null) return false;
        this[_unlinkCell$](cell);
        collection._LinkedHashSet._deleteTableEntry(table, element);
        return true;
      }
      [_modified$]() {
        this[_modifications$] = dart.notNull(this[_modifications$]) + 1 & 67108863;
      }
      [_newLinkedCell$](element) {
        E._check(element);
        let cell = new (_LinkedHashSetCellOfE())(element);
        if (this[_first$] == null) {
          this[_first$] = this[_last$] = cell;
        } else {
          let last = this[_last$];
          cell[_previous$0] = last;
          this[_last$] = last[_next$0] = cell;
        }
        this[_length$1] = dart.notNull(this[_length$1]) + 1;
        this[_modified$]();
        return cell;
      }
      [_unlinkCell$](cell) {
        _LinkedHashSetCellOfE()._check(cell);
        let previous = cell[_previous$0];
        let next = cell[_next$0];
        if (previous == null) {
          dart.assert(dart.equals(cell, this[_first$]));
          this[_first$] = next;
        } else {
          previous[_next$0] = next;
        }
        if (next == null) {
          dart.assert(dart.equals(cell, this[_last$]));
          this[_last$] = previous;
        } else {
          next[_previous$0] = previous;
        }
        this[_length$1] = dart.notNull(this[_length$1]) - 1;
        this[_modified$]();
      }
      static _isStringElement(element) {
        return typeof element == 'string' && element != '__proto__';
      }
      static _isNumericElement(element) {
        return typeof element == 'number' && (element & 0x3ffffff) === element;
      }
      [_computeHashCode](element) {
        return dart.hashCode(element) & 0x3ffffff;
      }
      [_getTableEntry](table, key) {
        return table[key];
      }
      static _setTableEntry(table, key, value) {
        dart.assert(value != null);
        table[key] = value;
      }
      static _deleteTableEntry(table, key) {
        delete table[key];
      }
      [_getBucket$](table, element) {
        let hash = this[_computeHashCode](element);
        return table[hash];
      }
      [_findBucketIndex](bucket, element) {
        if (bucket == null) return -1;
        let length = bucket.length;
        for (let i = 0; i < length; i++) {
          let cell = bucket[i];
          if (dart.equals(cell[_element], element)) return i;
        }
        return -1;
      }
      static _newHashTable() {
        let table = Object.create(null);
        let temporaryKey = '<non-identifier-key>';
        collection._LinkedHashSet._setTableEntry(table, temporaryKey, table);
        collection._LinkedHashSet._deleteTableEntry(table, temporaryKey);
        return table;
      }
    }
    _LinkedHashSet[dart.implements] = () => [LinkedHashSetOfE()];
    dart.setSignature(_LinkedHashSet, {
      constructors: () => ({new: dart.definiteFunctionType(collection._LinkedHashSet$(E), [])}),
      methods: () => ({
        [_newSet]: dart.definiteFunctionType(core.Set$(E), []),
        [_unsupported]: dart.definiteFunctionType(dart.void, [core.String]),
        contains: dart.definiteFunctionType(core.bool, [core.Object]),
        [_contains]: dart.definiteFunctionType(core.bool, [core.Object]),
        lookup: dart.definiteFunctionType(E, [core.Object]),
        [_lookup]: dart.definiteFunctionType(E, [core.Object]),
        forEach: dart.definiteFunctionType(dart.void, [dart.functionType(dart.void, [E])]),
        add: dart.definiteFunctionType(core.bool, [E]),
        [_add$0]: dart.definiteFunctionType(core.bool, [E]),
        remove: dart.definiteFunctionType(core.bool, [core.Object]),
        [_remove]: dart.definiteFunctionType(core.bool, [core.Object]),
        removeWhere: dart.definiteFunctionType(dart.void, [dart.functionType(core.bool, [E])]),
        retainWhere: dart.definiteFunctionType(dart.void, [dart.functionType(core.bool, [E])]),
        [_filterWhere]: dart.definiteFunctionType(dart.void, [dart.functionType(core.bool, [E]), core.bool]),
        [_addHashTableEntry$]: dart.definiteFunctionType(core.bool, [dart.dynamic, E]),
        [_removeHashTableEntry$]: dart.definiteFunctionType(core.bool, [dart.dynamic, core.Object]),
        [_modified$]: dart.definiteFunctionType(dart.void, []),
        [_newLinkedCell$]: dart.definiteFunctionType(collection._LinkedHashSetCell$(E), [E]),
        [_unlinkCell$]: dart.definiteFunctionType(dart.void, [collection._LinkedHashSetCell$(E)]),
        [_computeHashCode]: dart.definiteFunctionType(core.int, [dart.dynamic]),
        [_getTableEntry]: dart.definiteFunctionType(collection._LinkedHashSetCell$(E), [dart.dynamic, dart.dynamic]),
        [_getBucket$]: dart.definiteFunctionType(core.List$(collection._LinkedHashSetCell$(E)), [dart.dynamic, dart.dynamic]),
        [_findBucketIndex]: dart.definiteFunctionType(core.int, [dart.dynamic, dart.dynamic])
      }),
      statics: () => ({
        _isStringElement: dart.definiteFunctionType(core.bool, [dart.dynamic]),
        _isNumericElement: dart.definiteFunctionType(core.bool, [dart.dynamic]),
        _setTableEntry: dart.definiteFunctionType(dart.void, [dart.dynamic, dart.dynamic, dart.dynamic]),
        _deleteTableEntry: dart.definiteFunctionType(dart.void, [dart.dynamic, dart.dynamic]),
        _newHashTable: dart.definiteFunctionType(dart.dynamic, [])
      }),
      names: ['_isStringElement', '_isNumericElement', '_setTableEntry', '_deleteTableEntry', '_newHashTable']
    });
    dart.defineExtensionMembers(_LinkedHashSet, [
      'contains',
      'forEach',
      'iterator',
      'length',
      'isEmpty',
      'isNotEmpty',
      'first',
      'last'
    ]);
    return _LinkedHashSet;
  });
  collection._LinkedHashSet = _LinkedHashSet();
  collection._LinkedIdentityHashSet$ = dart.generic(E => {
    let _LinkedIdentityHashSetOfE = () => (_LinkedIdentityHashSetOfE = dart.constFn(collection._LinkedIdentityHashSet$(E)))();
    class _LinkedIdentityHashSet extends collection._LinkedHashSet$(E) {
      new() {
        super.new();
      }
      [_newSet]() {
        return new (_LinkedIdentityHashSetOfE())();
      }
      [_computeHashCode](key) {
        return core.identityHashCode(key) & 0x3ffffff;
      }
      [_findBucketIndex](bucket, element) {
        if (bucket == null) return -1;
        let length = bucket.length;
        for (let i = 0; i < length; i++) {
          let cell = bucket[i];
          if (core.identical(cell[_element], element)) return i;
        }
        return -1;
      }
    }
    dart.setSignature(_LinkedIdentityHashSet, {
      methods: () => ({[_newSet]: dart.definiteFunctionType(core.Set$(E), [])})
    });
    return _LinkedIdentityHashSet;
  });
  collection._LinkedIdentityHashSet = _LinkedIdentityHashSet();
  collection._LinkedCustomHashSet$ = dart.generic(E => {
    let _LinkedCustomHashSetOfE = () => (_LinkedCustomHashSetOfE = dart.constFn(collection._LinkedCustomHashSet$(E)))();
    class _LinkedCustomHashSet extends collection._LinkedHashSet$(E) {
      new(equality, hasher, validKey) {
        this[_equality] = equality;
        this[_hasher] = hasher;
        this[_validKey] = validKey != null ? validKey : dart.fn(x => E.is(x), ObjectTobool$());
        super.new();
      }
      [_newSet]() {
        return new (_LinkedCustomHashSetOfE())(this[_equality], this[_hasher], this[_validKey]);
      }
      [_findBucketIndex](bucket, element) {
        if (bucket == null) return -1;
        let length = bucket.length;
        for (let i = 0; i < length; i++) {
          let cell = bucket[i];
          if (dart.test(this[_equality](cell[_element], E._check(element)))) return i;
        }
        return -1;
      }
      [_computeHashCode](element) {
        return this[_hasher](E._check(element)) & 0x3ffffff;
      }
      add(element) {
        E._check(element);
        return super[_add$0](element);
      }
      contains(object) {
        if (!dart.test(this[_validKey](object))) return false;
        return super[_contains](object);
      }
      lookup(object) {
        if (!dart.test(this[_validKey](object))) return null;
        return super[_lookup](object);
      }
      remove(object) {
        if (!dart.test(this[_validKey](object))) return false;
        return super[_remove](object);
      }
      containsAll(elements) {
        for (let element of elements) {
          if (!dart.test(this[_validKey](element)) || !dart.test(this.contains(element))) return false;
        }
        return true;
      }
      removeAll(elements) {
        for (let element of elements) {
          if (dart.test(this[_validKey](element))) {
            super[_remove](element);
          }
        }
      }
    }
    dart.setSignature(_LinkedCustomHashSet, {
      constructors: () => ({new: dart.definiteFunctionType(collection._LinkedCustomHashSet$(E), [collection._Equality$(E), collection._Hasher$(E), dart.functionType(core.bool, [core.Object])])}),
      methods: () => ({
        [_newSet]: dart.definiteFunctionType(core.Set$(E), []),
        add: dart.definiteFunctionType(core.bool, [E]),
        lookup: dart.definiteFunctionType(E, [core.Object])
      })
    });
    dart.defineExtensionMembers(_LinkedCustomHashSet, ['contains']);
    return _LinkedCustomHashSet;
  });
  collection._LinkedCustomHashSet = _LinkedCustomHashSet();
  collection._LinkedHashSetCell$ = dart.generic(E => {
    class _LinkedHashSetCell extends core.Object {
      new(element) {
        this[_element] = element;
        this[_next$0] = null;
        this[_previous$0] = null;
      }
    }
    dart.addTypeTests(_LinkedHashSetCell);
    dart.setSignature(_LinkedHashSetCell, {
      constructors: () => ({new: dart.definiteFunctionType(collection._LinkedHashSetCell$(E), [E])})
    });
    return _LinkedHashSetCell;
  });
  collection._LinkedHashSetCell = _LinkedHashSetCell();
  const _cell$ = Symbol('_cell');
  collection._LinkedHashSetIterator$ = dart.generic(E => {
    let IteratorOfE = () => (IteratorOfE = dart.constFn(core.Iterator$(E)))();
    class _LinkedHashSetIterator extends core.Object {
      new(set, modifications) {
        this[_set] = set;
        this[_modifications$] = modifications;
        this[_cell$] = null;
        this[_current$2] = null;
        this[_cell$] = collection._LinkedHashSetCell._check(dart.dload(this[_set], _first$));
      }
      get current() {
        return this[_current$2];
      }
      moveNext() {
        if (!dart.equals(this[_modifications$], dart.dload(this[_set], _modifications$))) {
          dart.throw(new core.ConcurrentModificationError(this[_set]));
        } else if (this[_cell$] == null) {
          this[_current$2] = null;
          return false;
        } else {
          this[_current$2] = E._check(this[_cell$][_element]);
          this[_cell$] = this[_cell$][_next$0];
          return true;
        }
      }
    }
    dart.addTypeTests(_LinkedHashSetIterator);
    _LinkedHashSetIterator[dart.implements] = () => [IteratorOfE()];
    dart.setSignature(_LinkedHashSetIterator, {
      constructors: () => ({new: dart.definiteFunctionType(collection._LinkedHashSetIterator$(E), [dart.dynamic, core.int])}),
      methods: () => ({moveNext: dart.definiteFunctionType(core.bool, [])})
    });
    return _LinkedHashSetIterator;
  });
  collection._LinkedHashSetIterator = _LinkedHashSetIterator();
  const _source$0 = Symbol('_source');
  collection.UnmodifiableListView$ = dart.generic(E => {
    class UnmodifiableListView extends _internal.UnmodifiableListBase$(E) {
      new(source) {
        this[_source$0] = source;
      }
      get length() {
        return this[_source$0][dartx.length];
      }
      set length(value) {
        super.length = value;
      }
      get(index) {
        return this[_source$0][dartx.elementAt](index);
      }
    }
    dart.setSignature(UnmodifiableListView, {
      constructors: () => ({new: dart.definiteFunctionType(collection.UnmodifiableListView$(E), [core.Iterable$(E)])}),
      methods: () => ({get: dart.definiteFunctionType(E, [core.int])})
    });
    dart.defineExtensionMembers(UnmodifiableListView, ['get', 'length']);
    return UnmodifiableListView;
  });
  collection.UnmodifiableListView = UnmodifiableListView();
  collection._defaultEquals = function(a, b) {
    return dart.equals(a, b);
  };
  dart.lazyFn(collection._defaultEquals, () => dynamicAnddynamicTobool());
  collection._defaultHashCode = function(a) {
    return dart.hashCode(a);
  };
  dart.fn(collection._defaultHashCode, dynamicToint());
  collection._Equality$ = dart.generic(K => {
    const _Equality = dart.typedef('_Equality', () => dart.functionType(core.bool, [K, K]));
    return _Equality;
  });
  collection._Equality = _Equality$();
  collection._Hasher$ = dart.generic(K => {
    const _Hasher = dart.typedef('_Hasher', () => dart.functionType(core.int, [K]));
    return _Hasher;
  });
  collection._Hasher = _Hasher();
  collection.HashMap$ = dart.generic((K, V) => {
    let _HashMapOfK$V = () => (_HashMapOfK$V = dart.constFn(collection._HashMap$(K, V)))();
    let _IdentityHashMapOfK$V = () => (_IdentityHashMapOfK$V = dart.constFn(collection._IdentityHashMap$(K, V)))();
    let _CustomHashMapOfK$V = () => (_CustomHashMapOfK$V = dart.constFn(collection._CustomHashMap$(K, V)))();
    let HashMapOfK$V = () => (HashMapOfK$V = dart.constFn(collection.HashMap$(K, V)))();
    let MapOfK$V = () => (MapOfK$V = dart.constFn(core.Map$(K, V)))();
    let KAndKTobool = () => (KAndKTobool = dart.constFn(dart.functionType(core.bool, [K, K])))();
    let KToint = () => (KToint = dart.constFn(dart.functionType(core.int, [K])))();
    let dynamicToK = () => (dynamicToK = dart.constFn(dart.functionType(K, [dart.dynamic])))();
    let dynamicToV = () => (dynamicToV = dart.constFn(dart.functionType(V, [dart.dynamic])))();
    class HashMap extends core.Object {
      static new(opts) {
        let equals = opts && 'equals' in opts ? opts.equals : null;
        let hashCode = opts && 'hashCode' in opts ? opts.hashCode : null;
        let isValidKey = opts && 'isValidKey' in opts ? opts.isValidKey : null;
        if (isValidKey == null) {
          if (hashCode == null) {
            if (equals == null) {
              return new (_HashMapOfK$V())();
            }
            hashCode = collection._defaultHashCode;
          } else {
            if (core.identical(core.identityHashCode, hashCode) && core.identical(core.identical, equals)) {
              return new (_IdentityHashMapOfK$V())();
            }
            if (equals == null) {
              equals = collection._defaultEquals;
            }
          }
        } else {
          if (hashCode == null) {
            hashCode = collection._defaultHashCode;
          }
          if (equals == null) {
            equals = collection._defaultEquals;
          }
        }
        return new (_CustomHashMapOfK$V())(equals, hashCode, isValidKey);
      }
      static identity() {
        return new (_IdentityHashMapOfK$V())();
      }
      static from(other) {
        let result = HashMapOfK$V().new();
        other[dartx.forEach](dart.fn((k, v) => {
          result.set(K.as(k), V.as(v));
        }, dynamicAnddynamicTovoid()));
        return result;
      }
      static fromIterable(iterable, opts) {
        let key = opts && 'key' in opts ? opts.key : null;
        let value = opts && 'value' in opts ? opts.value : null;
        let map = HashMapOfK$V().new();
        collection.Maps._fillMapWithMappedIterable(map, iterable, key, value);
        return map;
      }
      static fromIterables(keys, values) {
        let map = HashMapOfK$V().new();
        collection.Maps._fillMapWithIterables(map, keys, values);
        return map;
      }
    }
    dart.addTypeTests(HashMap);
    HashMap[dart.implements] = () => [MapOfK$V()];
    dart.setSignature(HashMap, {
      constructors: () => ({
        new: dart.definiteFunctionType(collection.HashMap$(K, V), [], {equals: KAndKTobool(), hashCode: KToint(), isValidKey: ObjectTobool()}),
        identity: dart.definiteFunctionType(collection.HashMap$(K, V), []),
        from: dart.definiteFunctionType(collection.HashMap$(K, V), [core.Map]),
        fromIterable: dart.definiteFunctionType(collection.HashMap$(K, V), [core.Iterable], {key: dynamicToK(), value: dynamicToV()}),
        fromIterables: dart.definiteFunctionType(collection.HashMap$(K, V), [core.Iterable$(K), core.Iterable$(V)])
      })
    });
    return HashMap;
  });
  collection.HashMap = HashMap();
  collection.HashSet$ = dart.generic(E => {
    let _HashSetOfE = () => (_HashSetOfE = dart.constFn(collection._HashSet$(E)))();
    let _IdentityHashSetOfE = () => (_IdentityHashSetOfE = dart.constFn(collection._IdentityHashSet$(E)))();
    let _CustomHashSetOfE = () => (_CustomHashSetOfE = dart.constFn(collection._CustomHashSet$(E)))();
    let HashSetOfE = () => (HashSetOfE = dart.constFn(collection.HashSet$(E)))();
    let SetOfE = () => (SetOfE = dart.constFn(core.Set$(E)))();
    let EAndETobool = () => (EAndETobool = dart.constFn(dart.functionType(core.bool, [E, E])))();
    let EToint = () => (EToint = dart.constFn(dart.functionType(core.int, [E])))();
    class HashSet extends core.Object {
      static new(opts) {
        let equals = opts && 'equals' in opts ? opts.equals : null;
        let hashCode = opts && 'hashCode' in opts ? opts.hashCode : null;
        let isValidKey = opts && 'isValidKey' in opts ? opts.isValidKey : null;
        if (isValidKey == null) {
          if (hashCode == null) {
            if (equals == null) {
              return new (_HashSetOfE())();
            }
            hashCode = collection._defaultHashCode;
          } else {
            if (core.identical(core.identityHashCode, hashCode) && core.identical(core.identical, equals)) {
              return new (_IdentityHashSetOfE())();
            }
            if (equals == null) {
              equals = collection._defaultEquals;
            }
          }
        } else {
          if (hashCode == null) {
            hashCode = collection._defaultHashCode;
          }
          if (equals == null) {
            equals = collection._defaultEquals;
          }
        }
        return new (_CustomHashSetOfE())(equals, hashCode, isValidKey);
      }
      static identity() {
        return new (_IdentityHashSetOfE())();
      }
      static from(elements) {
        let result = HashSetOfE().new();
        for (let e of elements) {
          let element = E.as(e);
          result.add(element);
        }
        return result;
      }
      [Symbol.iterator]() {
        return new dart.JsIterator(this.iterator);
      }
    }
    dart.addTypeTests(HashSet);
    HashSet[dart.implements] = () => [SetOfE()];
    dart.setSignature(HashSet, {
      constructors: () => ({
        new: dart.definiteFunctionType(collection.HashSet$(E), [], {equals: EAndETobool(), hashCode: EToint(), isValidKey: ObjectTobool()}),
        identity: dart.definiteFunctionType(collection.HashSet$(E), []),
        from: dart.definiteFunctionType(collection.HashSet$(E), [core.Iterable])
      })
    });
    return HashSet;
  });
  collection.HashSet = HashSet();
  collection.IterableMixin$ = dart.generic(E => {
    let WhereIterableOfE = () => (WhereIterableOfE = dart.constFn(_internal.WhereIterable$(E)))();
    let EAndEToE = () => (EAndEToE = dart.constFn(dart.functionType(E, [E, E])))();
    let ListOfE = () => (ListOfE = dart.constFn(core.List$(E)))();
    let SetOfE = () => (SetOfE = dart.constFn(core.Set$(E)))();
    let TakeIterableOfE = () => (TakeIterableOfE = dart.constFn(_internal.TakeIterable$(E)))();
    let TakeWhileIterableOfE = () => (TakeWhileIterableOfE = dart.constFn(_internal.TakeWhileIterable$(E)))();
    let SkipIterableOfE = () => (SkipIterableOfE = dart.constFn(_internal.SkipIterable$(E)))();
    let SkipWhileIterableOfE = () => (SkipWhileIterableOfE = dart.constFn(_internal.SkipWhileIterable$(E)))();
    let VoidToE = () => (VoidToE = dart.constFn(dart.functionType(E, [])))();
    let IterableOfE = () => (IterableOfE = dart.constFn(core.Iterable$(E)))();
    class IterableMixin extends core.Object {
      map(T) {
        return f => {
          return _internal.MappedIterable$(E, T).new(this, f);
        };
      }
      where(f) {
        return new (WhereIterableOfE())(this, f);
      }
      expand(T) {
        return f => {
          return new (_internal.ExpandIterable$(E, T))(this, f);
        };
      }
      contains(element) {
        for (let e of this) {
          if (dart.equals(e, element)) return true;
        }
        return false;
      }
      forEach(f) {
        for (let element of this)
          f(element);
      }
      reduce(combine) {
        EAndEToE()._check(combine);
        let iterator = this.iterator;
        if (!dart.test(iterator.moveNext())) {
          dart.throw(_internal.IterableElementError.noElement());
        }
        let value = iterator.current;
        while (dart.test(iterator.moveNext())) {
          value = combine(value, iterator.current);
        }
        return value;
      }
      fold(T) {
        return (initialValue, combine) => {
          let value = initialValue;
          for (let element of this)
            value = combine(value, element);
          return value;
        };
      }
      every(f) {
        for (let element of this) {
          if (!dart.test(f(element))) return false;
        }
        return true;
      }
      join(separator) {
        if (separator === void 0) separator = "";
        let iterator = this.iterator;
        if (!dart.test(iterator.moveNext())) return "";
        let buffer = new core.StringBuffer();
        if (separator == null || separator == "") {
          do {
            buffer.write(dart.str`${iterator.current}`);
          } while (dart.test(iterator.moveNext()));
        } else {
          buffer.write(dart.str`${iterator.current}`);
          while (dart.test(iterator.moveNext())) {
            buffer.write(separator);
            buffer.write(dart.str`${iterator.current}`);
          }
        }
        return buffer.toString();
      }
      any(f) {
        for (let element of this) {
          if (dart.test(f(element))) return true;
        }
        return false;
      }
      toList(opts) {
        let growable = opts && 'growable' in opts ? opts.growable : true;
        return ListOfE().from(this, {growable: growable});
      }
      toSet() {
        return SetOfE().from(this);
      }
      get length() {
        dart.assert(!_internal.EfficientLength.is(this));
        let count = 0;
        let it = this[dartx.iterator];
        while (dart.test(it.moveNext())) {
          count++;
        }
        return count;
      }
      get isEmpty() {
        return !dart.test(this[dartx.iterator].moveNext());
      }
      get isNotEmpty() {
        return !dart.test(this.isEmpty);
      }
      take(count) {
        return TakeIterableOfE().new(this, count);
      }
      takeWhile(test) {
        return new (TakeWhileIterableOfE())(this, test);
      }
      skip(count) {
        return SkipIterableOfE().new(this, count);
      }
      skipWhile(test) {
        return new (SkipWhileIterableOfE())(this, test);
      }
      get first() {
        let it = this[dartx.iterator];
        if (!dart.test(it.moveNext())) {
          dart.throw(_internal.IterableElementError.noElement());
        }
        return it.current;
      }
      get last() {
        let it = this[dartx.iterator];
        if (!dart.test(it.moveNext())) {
          dart.throw(_internal.IterableElementError.noElement());
        }
        let result = null;
        do {
          result = it.current;
        } while (dart.test(it.moveNext()));
        return result;
      }
      get single() {
        let it = this[dartx.iterator];
        if (!dart.test(it.moveNext())) dart.throw(_internal.IterableElementError.noElement());
        let result = it.current;
        if (dart.test(it.moveNext())) dart.throw(_internal.IterableElementError.tooMany());
        return result;
      }
      firstWhere(test, opts) {
        let orElse = opts && 'orElse' in opts ? opts.orElse : null;
        VoidToE()._check(orElse);
        for (let element of this) {
          if (dart.test(test(element))) return element;
        }
        if (orElse != null) return orElse();
        dart.throw(_internal.IterableElementError.noElement());
      }
      lastWhere(test, opts) {
        let orElse = opts && 'orElse' in opts ? opts.orElse : null;
        VoidToE()._check(orElse);
        let result = null;
        let foundMatching = false;
        for (let element of this) {
          if (dart.test(test(element))) {
            result = element;
            foundMatching = true;
          }
        }
        if (foundMatching) return result;
        if (orElse != null) return orElse();
        dart.throw(_internal.IterableElementError.noElement());
      }
      singleWhere(test) {
        let result = null;
        let foundMatching = false;
        for (let element of this) {
          if (dart.test(test(element))) {
            if (foundMatching) {
              dart.throw(_internal.IterableElementError.tooMany());
            }
            result = element;
            foundMatching = true;
          }
        }
        if (foundMatching) return result;
        dart.throw(_internal.IterableElementError.noElement());
      }
      elementAt(index) {
        if (!(typeof index == 'number')) dart.throw(new core.ArgumentError.notNull("index"));
        core.RangeError.checkNotNegative(index, "index");
        let elementIndex = 0;
        for (let element of this) {
          if (index == elementIndex) return element;
          elementIndex++;
        }
        dart.throw(core.RangeError.index(index, this, "index", null, elementIndex));
      }
      toString() {
        return collection.IterableBase.iterableToShortString(this, '(', ')');
      }
      [Symbol.iterator]() {
        return new dart.JsIterator(this.iterator);
      }
    }
    dart.addTypeTests(IterableMixin);
    IterableMixin[dart.implements] = () => [IterableOfE()];
    dart.setSignature(IterableMixin, {
      methods: () => ({
        map: dart.definiteFunctionType(T => [core.Iterable$(T), [dart.functionType(T, [E])]]),
        where: dart.definiteFunctionType(core.Iterable$(E), [dart.functionType(core.bool, [E])]),
        expand: dart.definiteFunctionType(T => [core.Iterable$(T), [dart.functionType(core.Iterable$(T), [E])]]),
        contains: dart.definiteFunctionType(core.bool, [core.Object]),
        forEach: dart.definiteFunctionType(dart.void, [dart.functionType(dart.void, [E])]),
        reduce: dart.definiteFunctionType(E, [dart.functionType(E, [E, E])]),
        fold: dart.definiteFunctionType(T => [T, [T, dart.functionType(T, [T, E])]]),
        every: dart.definiteFunctionType(core.bool, [dart.functionType(core.bool, [E])]),
        join: dart.definiteFunctionType(core.String, [], [core.String]),
        any: dart.definiteFunctionType(core.bool, [dart.functionType(core.bool, [E])]),
        toList: dart.definiteFunctionType(core.List$(E), [], {growable: core.bool}),
        toSet: dart.definiteFunctionType(core.Set$(E), []),
        take: dart.definiteFunctionType(core.Iterable$(E), [core.int]),
        takeWhile: dart.definiteFunctionType(core.Iterable$(E), [dart.functionType(core.bool, [E])]),
        skip: dart.definiteFunctionType(core.Iterable$(E), [core.int]),
        skipWhile: dart.definiteFunctionType(core.Iterable$(E), [dart.functionType(core.bool, [E])]),
        firstWhere: dart.definiteFunctionType(E, [dart.functionType(core.bool, [E])], {orElse: VoidToE()}),
        lastWhere: dart.definiteFunctionType(E, [dart.functionType(core.bool, [E])], {orElse: VoidToE()}),
        singleWhere: dart.definiteFunctionType(E, [dart.functionType(core.bool, [E])]),
        elementAt: dart.definiteFunctionType(E, [core.int])
      })
    });
    dart.defineExtensionMembers(IterableMixin, [
      'map',
      'where',
      'expand',
      'contains',
      'forEach',
      'reduce',
      'fold',
      'every',
      'join',
      'any',
      'toList',
      'toSet',
      'take',
      'takeWhile',
      'skip',
      'skipWhile',
      'firstWhere',
      'lastWhere',
      'singleWhere',
      'elementAt',
      'toString',
      'length',
      'isEmpty',
      'isNotEmpty',
      'first',
      'last',
      'single'
    ]);
    return IterableMixin;
  });
  collection.IterableMixin = IterableMixin();
  dart.defineLazy(collection, {
    get _toStringVisiting() {
      return [];
    }
  });
  collection._isToStringVisiting = function(o) {
    for (let i = 0; i < dart.notNull(collection._toStringVisiting[dartx.length]); i++) {
      if (core.identical(o, collection._toStringVisiting[dartx.get](i))) return true;
    }
    return false;
  };
  dart.lazyFn(collection._isToStringVisiting, () => ObjectTobool$());
  collection._iterablePartsToStrings = function(iterable, parts) {
    let LENGTH_LIMIT = 80;
    let HEAD_COUNT = 3;
    let TAIL_COUNT = 2;
    let MAX_COUNT = 100;
    let OVERHEAD = 2;
    let ELLIPSIS_SIZE = 3;
    let length = 0;
    let count = 0;
    let it = iterable[dartx.iterator];
    while (dart.notNull(length) < LENGTH_LIMIT || count < HEAD_COUNT) {
      if (!dart.test(it.moveNext())) return;
      let next = dart.str`${it.current}`;
      parts[dartx.add](next);
      length = dart.notNull(length) + (dart.notNull(next[dartx.length]) + OVERHEAD);
      count++;
    }
    let penultimateString = null;
    let ultimateString = null;
    let penultimate = null;
    let ultimate = null;
    if (!dart.test(it.moveNext())) {
      if (count <= HEAD_COUNT + TAIL_COUNT) return;
      ultimateString = core.String._check(parts[dartx.removeLast]());
      penultimateString = core.String._check(parts[dartx.removeLast]());
    } else {
      penultimate = it.current;
      count++;
      if (!dart.test(it.moveNext())) {
        if (count <= HEAD_COUNT + 1) {
          parts[dartx.add](dart.str`${penultimate}`);
          return;
        }
        ultimateString = dart.str`${penultimate}`;
        penultimateString = core.String._check(parts[dartx.removeLast]());
        length = dart.notNull(length) + (dart.notNull(ultimateString[dartx.length]) + OVERHEAD);
      } else {
        ultimate = it.current;
        count++;
        dart.assert(count < MAX_COUNT);
        while (dart.test(it.moveNext())) {
          penultimate = ultimate;
          ultimate = it.current;
          count++;
          if (count > MAX_COUNT) {
            while (dart.notNull(length) > LENGTH_LIMIT - ELLIPSIS_SIZE - OVERHEAD && count > HEAD_COUNT) {
              length = dart.notNull(length) - dart.notNull(core.int._check(dart.dsend(dart.dload(parts[dartx.removeLast](), 'length'), '+', OVERHEAD)));
              count--;
            }
            parts[dartx.add]("...");
            return;
          }
        }
        penultimateString = dart.str`${penultimate}`;
        ultimateString = dart.str`${ultimate}`;
        length = dart.notNull(length) + (dart.notNull(ultimateString[dartx.length]) + dart.notNull(penultimateString[dartx.length]) + 2 * OVERHEAD);
      }
    }
    let elision = null;
    if (count > dart.notNull(parts[dartx.length]) + TAIL_COUNT) {
      elision = "...";
      length = dart.notNull(length) + (ELLIPSIS_SIZE + OVERHEAD);
    }
    while (dart.notNull(length) > LENGTH_LIMIT && dart.notNull(parts[dartx.length]) > HEAD_COUNT) {
      length = dart.notNull(length) - dart.notNull(core.int._check(dart.dsend(dart.dload(parts[dartx.removeLast](), 'length'), '+', OVERHEAD)));
      if (elision == null) {
        elision = "...";
        length = dart.notNull(length) + (ELLIPSIS_SIZE + OVERHEAD);
      }
    }
    if (elision != null) {
      parts[dartx.add](elision);
    }
    parts[dartx.add](penultimateString);
    parts[dartx.add](ultimateString);
  };
  dart.lazyFn(collection._iterablePartsToStrings, () => IterableAndListTovoid());
  const _iterator$0 = Symbol('_iterator');
  const _state$ = Symbol('_state');
  const _move = Symbol('_move');
  collection.HasNextIterator$ = dart.generic(E => {
    class HasNextIterator extends core.Object {
      new(iterator) {
        this[_iterator$0] = iterator;
        this[_state$] = collection.HasNextIterator._NOT_MOVED_YET;
      }
      get hasNext() {
        if (this[_state$] == collection.HasNextIterator._NOT_MOVED_YET) this[_move]();
        return this[_state$] == collection.HasNextIterator._HAS_NEXT_AND_NEXT_IN_CURRENT;
      }
      next() {
        if (!dart.test(this.hasNext)) dart.throw(new core.StateError("No more elements"));
        dart.assert(this[_state$] == collection.HasNextIterator._HAS_NEXT_AND_NEXT_IN_CURRENT);
        let result = this[_iterator$0].current;
        this[_move]();
        return result;
      }
      [_move]() {
        if (dart.test(this[_iterator$0].moveNext())) {
          this[_state$] = collection.HasNextIterator._HAS_NEXT_AND_NEXT_IN_CURRENT;
        } else {
          this[_state$] = collection.HasNextIterator._NO_NEXT;
        }
      }
    }
    dart.addTypeTests(HasNextIterator);
    dart.setSignature(HasNextIterator, {
      constructors: () => ({new: dart.definiteFunctionType(collection.HasNextIterator$(E), [core.Iterator$(E)])}),
      methods: () => ({
        next: dart.definiteFunctionType(E, []),
        [_move]: dart.definiteFunctionType(dart.void, [])
      })
    });
    return HasNextIterator;
  });
  collection.HasNextIterator = HasNextIterator();
  collection.HasNextIterator._HAS_NEXT_AND_NEXT_IN_CURRENT = 0;
  collection.HasNextIterator._NO_NEXT = 1;
  collection.HasNextIterator._NOT_MOVED_YET = 2;
  collection.LinkedHashMap$ = dart.generic((K, V) => {
    let JsLinkedHashMapOfK$V = () => (JsLinkedHashMapOfK$V = dart.constFn(_js_helper.JsLinkedHashMap$(K, V)))();
    let _LinkedIdentityHashMapOfK$V = () => (_LinkedIdentityHashMapOfK$V = dart.constFn(collection._LinkedIdentityHashMap$(K, V)))();
    let _LinkedCustomHashMapOfK$V = () => (_LinkedCustomHashMapOfK$V = dart.constFn(collection._LinkedCustomHashMap$(K, V)))();
    let LinkedHashMapOfK$V = () => (LinkedHashMapOfK$V = dart.constFn(collection.LinkedHashMap$(K, V)))();
    let HashMapOfK$V = () => (HashMapOfK$V = dart.constFn(collection.HashMap$(K, V)))();
    let KAndKTobool = () => (KAndKTobool = dart.constFn(dart.functionType(core.bool, [K, K])))();
    let KToint = () => (KToint = dart.constFn(dart.functionType(core.int, [K])))();
    let dynamicToK = () => (dynamicToK = dart.constFn(dart.functionType(K, [dart.dynamic])))();
    let dynamicToV = () => (dynamicToV = dart.constFn(dart.functionType(V, [dart.dynamic])))();
    class LinkedHashMap extends core.Object {
      static new(opts) {
        let equals = opts && 'equals' in opts ? opts.equals : null;
        let hashCode = opts && 'hashCode' in opts ? opts.hashCode : null;
        let isValidKey = opts && 'isValidKey' in opts ? opts.isValidKey : null;
        if (isValidKey == null) {
          if (hashCode == null) {
            if (equals == null) {
              return JsLinkedHashMapOfK$V().es6();
            }
            hashCode = collection._defaultHashCode;
          } else {
            if (core.identical(core.identityHashCode, hashCode) && core.identical(core.identical, equals)) {
              return _LinkedIdentityHashMapOfK$V().es6();
            }
            if (equals == null) {
              equals = collection._defaultEquals;
            }
          }
        } else {
          if (hashCode == null) {
            hashCode = collection._defaultHashCode;
          }
          if (equals == null) {
            equals = collection._defaultEquals;
          }
        }
        return new (_LinkedCustomHashMapOfK$V())(equals, hashCode, isValidKey);
      }
      static identity() {
        return _LinkedIdentityHashMapOfK$V().es6();
      }
      static from(other) {
        let result = LinkedHashMapOfK$V().new();
        other[dartx.forEach](dart.fn((k, v) => {
          result.set(K.as(k), V.as(v));
        }, dynamicAnddynamicTovoid()));
        return result;
      }
      static fromIterable(iterable, opts) {
        let key = opts && 'key' in opts ? opts.key : null;
        let value = opts && 'value' in opts ? opts.value : null;
        let map = LinkedHashMapOfK$V().new();
        collection.Maps._fillMapWithMappedIterable(map, iterable, key, value);
        return map;
      }
      static fromIterables(keys, values) {
        let map = LinkedHashMapOfK$V().new();
        collection.Maps._fillMapWithIterables(map, keys, values);
        return map;
      }
    }
    dart.addTypeTests(LinkedHashMap);
    LinkedHashMap[dart.implements] = () => [HashMapOfK$V()];
    dart.setSignature(LinkedHashMap, {
      constructors: () => ({
        new: dart.definiteFunctionType(collection.LinkedHashMap$(K, V), [], {equals: KAndKTobool(), hashCode: KToint(), isValidKey: ObjectTobool()}),
        identity: dart.definiteFunctionType(collection.LinkedHashMap$(K, V), []),
        from: dart.definiteFunctionType(collection.LinkedHashMap$(K, V), [core.Map]),
        fromIterable: dart.definiteFunctionType(collection.LinkedHashMap$(K, V), [core.Iterable], {key: dynamicToK(), value: dynamicToV()}),
        fromIterables: dart.definiteFunctionType(collection.LinkedHashMap$(K, V), [core.Iterable$(K), core.Iterable$(V)])
      })
    });
    return LinkedHashMap;
  });
  collection.LinkedHashMap = LinkedHashMap();
  collection.LinkedHashSet$ = dart.generic(E => {
    let _LinkedHashSetOfE = () => (_LinkedHashSetOfE = dart.constFn(collection._LinkedHashSet$(E)))();
    let _LinkedIdentityHashSetOfE = () => (_LinkedIdentityHashSetOfE = dart.constFn(collection._LinkedIdentityHashSet$(E)))();
    let _LinkedCustomHashSetOfE = () => (_LinkedCustomHashSetOfE = dart.constFn(collection._LinkedCustomHashSet$(E)))();
    let LinkedHashSetOfE = () => (LinkedHashSetOfE = dart.constFn(collection.LinkedHashSet$(E)))();
    let HashSetOfE = () => (HashSetOfE = dart.constFn(collection.HashSet$(E)))();
    let EAndETobool = () => (EAndETobool = dart.constFn(dart.functionType(core.bool, [E, E])))();
    let EToint = () => (EToint = dart.constFn(dart.functionType(core.int, [E])))();
    class LinkedHashSet extends core.Object {
      static new(opts) {
        let equals = opts && 'equals' in opts ? opts.equals : null;
        let hashCode = opts && 'hashCode' in opts ? opts.hashCode : null;
        let isValidKey = opts && 'isValidKey' in opts ? opts.isValidKey : null;
        if (isValidKey == null) {
          if (hashCode == null) {
            if (equals == null) {
              return new (_LinkedHashSetOfE())();
            }
            hashCode = collection._defaultHashCode;
          } else {
            if (core.identical(core.identityHashCode, hashCode) && core.identical(core.identical, equals)) {
              return new (_LinkedIdentityHashSetOfE())();
            }
            if (equals == null) {
              equals = collection._defaultEquals;
            }
          }
        } else {
          if (hashCode == null) {
            hashCode = collection._defaultHashCode;
          }
          if (equals == null) {
            equals = collection._defaultEquals;
          }
        }
        return new (_LinkedCustomHashSetOfE())(equals, hashCode, isValidKey);
      }
      static identity() {
        return new (_LinkedIdentityHashSetOfE())();
      }
      static from(elements) {
        let result = LinkedHashSetOfE().new();
        for (let element of elements) {
          let e = E.as(element);
          result.add(e);
        }
        return result;
      }
      [Symbol.iterator]() {
        return new dart.JsIterator(this.iterator);
      }
    }
    dart.addTypeTests(LinkedHashSet);
    LinkedHashSet[dart.implements] = () => [HashSetOfE()];
    dart.setSignature(LinkedHashSet, {
      constructors: () => ({
        new: dart.definiteFunctionType(collection.LinkedHashSet$(E), [], {equals: EAndETobool(), hashCode: EToint(), isValidKey: ObjectTobool()}),
        identity: dart.definiteFunctionType(collection.LinkedHashSet$(E), []),
        from: dart.definiteFunctionType(collection.LinkedHashSet$(E), [core.Iterable])
      })
    });
    return LinkedHashSet;
  });
  collection.LinkedHashSet = LinkedHashSet();
  const _modificationCount = Symbol('_modificationCount');
  const _insertBefore$ = Symbol('_insertBefore');
  const _list = Symbol('_list');
  const _unlink$ = Symbol('_unlink');
  collection.LinkedList$ = dart.generic(E => {
    let IterableOfE = () => (IterableOfE = dart.constFn(core.Iterable$(E)))();
    let _LinkedListIteratorOfE = () => (_LinkedListIteratorOfE = dart.constFn(collection._LinkedListIterator$(E)))();
    class LinkedList extends core.Iterable$(E) {
      new() {
        this[_modificationCount] = 0;
        this[_length$1] = 0;
        this[_first$] = null;
        super.new();
      }
      addFirst(entry) {
        E._check(entry);
        this[_insertBefore$](this[_first$], entry, {updateFirst: true});
        this[_first$] = entry;
      }
      add(entry) {
        E._check(entry);
        this[_insertBefore$](this[_first$], entry, {updateFirst: false});
      }
      addAll(entries) {
        IterableOfE()._check(entries);
        entries[dartx.forEach](dart.bind(this, 'add'));
      }
      remove(entry) {
        E._check(entry);
        if (!dart.equals(entry[_list], this)) return false;
        this[_unlink$](entry);
        return true;
      }
      get iterator() {
        return new (_LinkedListIteratorOfE())(this);
      }
      get length() {
        return this[_length$1];
      }
      clear() {
        this[_modificationCount] = dart.notNull(this[_modificationCount]) + 1;
        if (dart.test(this.isEmpty)) return;
        let next = this[_first$];
        do {
          let entry = next;
          next = entry[_next$0];
          entry[_next$0] = entry[_previous$0] = entry[_list] = null;
        } while (!core.identical(next, this[_first$]));
        this[_first$] = null;
        this[_length$1] = 0;
      }
      get first() {
        if (dart.test(this.isEmpty)) {
          dart.throw(new core.StateError('No such element'));
        }
        return this[_first$];
      }
      get last() {
        if (dart.test(this.isEmpty)) {
          dart.throw(new core.StateError('No such element'));
        }
        return this[_first$][_previous$0];
      }
      get single() {
        if (dart.test(this.isEmpty)) {
          dart.throw(new core.StateError('No such element'));
        }
        if (dart.notNull(this[_length$1]) > 1) {
          dart.throw(new core.StateError('Too many elements'));
        }
        return this[_first$];
      }
      forEach(action) {
        let modificationCount = this[_modificationCount];
        if (dart.test(this.isEmpty)) return;
        let current = this[_first$];
        do {
          action(current);
          if (modificationCount != this[_modificationCount]) {
            dart.throw(new core.ConcurrentModificationError(this));
          }
          current = current[_next$0];
        } while (!core.identical(current, this[_first$]));
      }
      get isEmpty() {
        return this[_length$1] == 0;
      }
      [_insertBefore$](entry, newEntry, opts) {
        E._check(entry);
        E._check(newEntry);
        let updateFirst = opts && 'updateFirst' in opts ? opts.updateFirst : null;
        if (newEntry.list != null) {
          dart.throw(new core.StateError('LinkedListEntry is already in a LinkedList'));
        }
        this[_modificationCount] = dart.notNull(this[_modificationCount]) + 1;
        newEntry[_list] = this;
        if (dart.test(this.isEmpty)) {
          dart.assert(entry == null);
          newEntry[_previous$0] = newEntry[_next$0] = newEntry;
          this[_first$] = newEntry;
          this[_length$1] = dart.notNull(this[_length$1]) + 1;
          return;
        }
        let predecessor = entry[_previous$0];
        let successor = entry;
        newEntry[_previous$0] = predecessor;
        newEntry[_next$0] = successor;
        predecessor[_next$0] = newEntry;
        successor[_previous$0] = newEntry;
        if (dart.test(updateFirst) && core.identical(entry, this[_first$])) {
          this[_first$] = newEntry;
        }
        this[_length$1] = dart.notNull(this[_length$1]) + 1;
      }
      [_unlink$](entry) {
        E._check(entry);
        this[_modificationCount] = dart.notNull(this[_modificationCount]) + 1;
        entry[_next$0][_previous$0] = entry[_previous$0];
        let next = entry[_previous$0][_next$0] = entry[_next$0];
        this[_length$1] = dart.notNull(this[_length$1]) - 1;
        entry[_list] = entry[_next$0] = entry[_previous$0] = null;
        if (dart.test(this.isEmpty)) {
          this[_first$] = null;
        } else if (core.identical(entry, this[_first$])) {
          this[_first$] = next;
        }
      }
    }
    dart.setSignature(LinkedList, {
      constructors: () => ({new: dart.definiteFunctionType(collection.LinkedList$(E), [])}),
      methods: () => ({
        addFirst: dart.definiteFunctionType(dart.void, [E]),
        add: dart.definiteFunctionType(dart.void, [E]),
        addAll: dart.definiteFunctionType(dart.void, [core.Iterable$(E)]),
        remove: dart.definiteFunctionType(core.bool, [E]),
        clear: dart.definiteFunctionType(dart.void, []),
        forEach: dart.definiteFunctionType(dart.void, [dart.functionType(dart.void, [E])]),
        [_insertBefore$]: dart.definiteFunctionType(dart.void, [E, E], {updateFirst: core.bool}),
        [_unlink$]: dart.definiteFunctionType(dart.void, [E])
      })
    });
    dart.defineExtensionMembers(LinkedList, [
      'forEach',
      'iterator',
      'length',
      'first',
      'last',
      'single',
      'isEmpty'
    ]);
    return LinkedList;
  });
  collection.LinkedList = LinkedList();
  const _visitedFirst = Symbol('_visitedFirst');
  collection._LinkedListIterator$ = dart.generic(E => {
    let IteratorOfE = () => (IteratorOfE = dart.constFn(core.Iterator$(E)))();
    class _LinkedListIterator extends core.Object {
      new(list) {
        this[_list] = list;
        this[_modificationCount] = list[_modificationCount];
        this[_next$0] = list[_first$];
        this[_visitedFirst] = false;
        this[_current$2] = null;
      }
      get current() {
        return this[_current$2];
      }
      moveNext() {
        if (this[_modificationCount] != this[_list][_modificationCount]) {
          dart.throw(new core.ConcurrentModificationError(this));
        }
        if (dart.test(this[_list].isEmpty) || dart.test(this[_visitedFirst]) && core.identical(this[_next$0], this[_list].first)) {
          this[_current$2] = null;
          return false;
        }
        this[_visitedFirst] = true;
        this[_current$2] = E._check(this[_next$0]);
        this[_next$0] = this[_next$0][_next$0];
        return true;
      }
    }
    dart.addTypeTests(_LinkedListIterator);
    _LinkedListIterator[dart.implements] = () => [IteratorOfE()];
    dart.setSignature(_LinkedListIterator, {
      constructors: () => ({new: dart.definiteFunctionType(collection._LinkedListIterator$(E), [collection.LinkedList$(E)])}),
      methods: () => ({moveNext: dart.definiteFunctionType(core.bool, [])})
    });
    return _LinkedListIterator;
  });
  collection._LinkedListIterator = _LinkedListIterator();
  collection.LinkedListEntry$ = dart.generic(E => {
    class LinkedListEntry extends core.Object {
      new() {
        this[_list] = null;
        this[_next$0] = null;
        this[_previous$0] = null;
      }
      get list() {
        return this[_list];
      }
      unlink() {
        this[_list][_unlink$](E._check(this));
      }
      get next() {
        if (core.identical(this, this[_next$0])) return null;
        return this[_next$0];
      }
      get previous() {
        if (core.identical(this, this[_previous$0])) return null;
        return this[_previous$0];
      }
      insertAfter(entry) {
        E._check(entry);
        this[_list][_insertBefore$](this[_next$0], entry, {updateFirst: false});
      }
      insertBefore(entry) {
        E._check(entry);
        this[_list][_insertBefore$](E.as(this), entry, {updateFirst: true});
      }
    }
    dart.addTypeTests(LinkedListEntry);
    dart.setSignature(LinkedListEntry, {
      methods: () => ({
        unlink: dart.definiteFunctionType(dart.void, []),
        insertAfter: dart.definiteFunctionType(dart.void, [E]),
        insertBefore: dart.definiteFunctionType(dart.void, [E])
      })
    });
    return LinkedListEntry;
  });
  collection.LinkedListEntry = LinkedListEntry();
  collection.MapMixin$ = dart.generic((K, V) => {
    let MapOfK$V = () => (MapOfK$V = dart.constFn(core.Map$(K, V)))();
    let _MapBaseValueIterableOfK$V = () => (_MapBaseValueIterableOfK$V = dart.constFn(collection._MapBaseValueIterable$(K, V)))();
    let VoidToV = () => (VoidToV = dart.constFn(dart.functionType(V, [])))();
    class MapMixin extends core.Object {
      forEach(action) {
        for (let key of this.keys) {
          action(key, this.get(key));
        }
      }
      addAll(other) {
        MapOfK$V()._check(other);
        for (let key of other[dartx.keys]) {
          this.set(key, other[dartx.get](key));
        }
      }
      containsValue(value) {
        for (let key of this.keys) {
          if (dart.equals(this.get(key), value)) return true;
        }
        return false;
      }
      putIfAbsent(key, ifAbsent) {
        K._check(key);
        VoidToV()._check(ifAbsent);
        if (dart.test(this.containsKey(key))) {
          return this.get(key);
        }
        return this.set(key, ifAbsent());
      }
      containsKey(key) {
        return this.keys[dartx.contains](key);
      }
      get length() {
        return this.keys[dartx.length];
      }
      get isEmpty() {
        return this.keys[dartx.isEmpty];
      }
      get isNotEmpty() {
        return this.keys[dartx.isNotEmpty];
      }
      get values() {
        return new (_MapBaseValueIterableOfK$V())(this);
      }
      toString() {
        return collection.Maps.mapToString(this);
      }
    }
    dart.addTypeTests(MapMixin);
    MapMixin[dart.implements] = () => [MapOfK$V()];
    dart.setSignature(MapMixin, {
      methods: () => ({
        forEach: dart.definiteFunctionType(dart.void, [dart.functionType(dart.void, [K, V])]),
        addAll: dart.definiteFunctionType(dart.void, [core.Map$(K, V)]),
        containsValue: dart.definiteFunctionType(core.bool, [core.Object]),
        putIfAbsent: dart.definiteFunctionType(V, [K, dart.functionType(V, [])]),
        containsKey: dart.definiteFunctionType(core.bool, [core.Object])
      })
    });
    dart.defineExtensionMembers(MapMixin, [
      'forEach',
      'addAll',
      'containsValue',
      'putIfAbsent',
      'containsKey',
      'length',
      'isEmpty',
      'isNotEmpty',
      'values'
    ]);
    return MapMixin;
  });
  collection.MapMixin = MapMixin();
  collection.MapBase$ = dart.generic((K, V) => {
    class MapBase extends dart.mixin(core.Object, collection.MapMixin$(K, V)) {}
    return MapBase;
  });
  collection.MapBase = MapBase();
  collection._UnmodifiableMapMixin$ = dart.generic((K, V) => {
    let MapOfK$V = () => (MapOfK$V = dart.constFn(core.Map$(K, V)))();
    let VoidToV = () => (VoidToV = dart.constFn(dart.functionType(V, [])))();
    class _UnmodifiableMapMixin extends core.Object {
      set(key, value) {
        K._check(key);
        V._check(value);
        dart.throw(new core.UnsupportedError("Cannot modify unmodifiable map"));
        return value;
      }
      addAll(other) {
        MapOfK$V()._check(other);
        dart.throw(new core.UnsupportedError("Cannot modify unmodifiable map"));
      }
      clear() {
        dart.throw(new core.UnsupportedError("Cannot modify unmodifiable map"));
      }
      remove(key) {
        dart.throw(new core.UnsupportedError("Cannot modify unmodifiable map"));
      }
      putIfAbsent(key, ifAbsent) {
        K._check(key);
        VoidToV()._check(ifAbsent);
        dart.throw(new core.UnsupportedError("Cannot modify unmodifiable map"));
      }
    }
    dart.addTypeTests(_UnmodifiableMapMixin);
    _UnmodifiableMapMixin[dart.implements] = () => [MapOfK$V()];
    dart.setSignature(_UnmodifiableMapMixin, {
      methods: () => ({
        set: dart.definiteFunctionType(dart.void, [K, V]),
        addAll: dart.definiteFunctionType(dart.void, [core.Map$(K, V)]),
        clear: dart.definiteFunctionType(dart.void, []),
        remove: dart.definiteFunctionType(V, [core.Object]),
        putIfAbsent: dart.definiteFunctionType(V, [K, dart.functionType(V, [])])
      })
    });
    dart.defineExtensionMembers(_UnmodifiableMapMixin, [
      'set',
      'addAll',
      'clear',
      'remove',
      'putIfAbsent'
    ]);
    return _UnmodifiableMapMixin;
  });
  collection._UnmodifiableMapMixin = _UnmodifiableMapMixin();
  collection.UnmodifiableMapBase$ = dart.generic((K, V) => {
    class UnmodifiableMapBase extends dart.mixin(collection.MapBase$(K, V), collection._UnmodifiableMapMixin$(K, V)) {
      new() {
        super.new();
      }
    }
    return UnmodifiableMapBase;
  });
  collection.UnmodifiableMapBase = UnmodifiableMapBase();
  collection._MapBaseValueIterable$ = dart.generic((K, V) => {
    let _MapBaseValueIteratorOfK$V = () => (_MapBaseValueIteratorOfK$V = dart.constFn(collection._MapBaseValueIterator$(K, V)))();
    class _MapBaseValueIterable extends core.Iterable$(V) {
      new(map) {
        this[_map$0] = map;
        super.new();
      }
      get length() {
        return this[_map$0][dartx.length];
      }
      get isEmpty() {
        return this[_map$0][dartx.isEmpty];
      }
      get isNotEmpty() {
        return this[_map$0][dartx.isNotEmpty];
      }
      get first() {
        return this[_map$0][dartx.get](this[_map$0][dartx.keys][dartx.first]);
      }
      get single() {
        return this[_map$0][dartx.get](this[_map$0][dartx.keys][dartx.single]);
      }
      get last() {
        return this[_map$0][dartx.get](this[_map$0][dartx.keys][dartx.last]);
      }
      get iterator() {
        return new (_MapBaseValueIteratorOfK$V())(this[_map$0]);
      }
    }
    _MapBaseValueIterable[dart.implements] = () => [_internal.EfficientLength];
    dart.setSignature(_MapBaseValueIterable, {
      constructors: () => ({new: dart.definiteFunctionType(collection._MapBaseValueIterable$(K, V), [core.Map$(K, V)])})
    });
    dart.defineExtensionMembers(_MapBaseValueIterable, [
      'length',
      'isEmpty',
      'isNotEmpty',
      'first',
      'single',
      'last',
      'iterator'
    ]);
    return _MapBaseValueIterable;
  });
  collection._MapBaseValueIterable = _MapBaseValueIterable();
  collection._MapBaseValueIterator$ = dart.generic((K, V) => {
    let IteratorOfV = () => (IteratorOfV = dart.constFn(core.Iterator$(V)))();
    class _MapBaseValueIterator extends core.Object {
      new(map) {
        this[_map$0] = map;
        this[_keys] = map[dartx.keys][dartx.iterator];
        this[_current$2] = null;
      }
      moveNext() {
        if (dart.test(this[_keys].moveNext())) {
          this[_current$2] = this[_map$0][dartx.get](this[_keys].current);
          return true;
        }
        this[_current$2] = null;
        return false;
      }
      get current() {
        return this[_current$2];
      }
    }
    dart.addTypeTests(_MapBaseValueIterator);
    _MapBaseValueIterator[dart.implements] = () => [IteratorOfV()];
    dart.setSignature(_MapBaseValueIterator, {
      constructors: () => ({new: dart.definiteFunctionType(collection._MapBaseValueIterator$(K, V), [core.Map$(K, V)])}),
      methods: () => ({moveNext: dart.definiteFunctionType(core.bool, [])})
    });
    return _MapBaseValueIterator;
  });
  collection._MapBaseValueIterator = _MapBaseValueIterator();
  collection.MapView$ = dart.generic((K, V) => {
    let MapOfK$V = () => (MapOfK$V = dart.constFn(core.Map$(K, V)))();
    let VoidToV = () => (VoidToV = dart.constFn(dart.functionType(V, [])))();
    class MapView extends core.Object {
      new(map) {
        this[_map$0] = map;
      }
      get(key) {
        return this[_map$0][dartx.get](key);
      }
      set(key, value) {
        K._check(key);
        V._check(value);
        this[_map$0][dartx.set](key, value);
        return value;
      }
      addAll(other) {
        MapOfK$V()._check(other);
        this[_map$0][dartx.addAll](other);
      }
      clear() {
        this[_map$0][dartx.clear]();
      }
      putIfAbsent(key, ifAbsent) {
        K._check(key);
        VoidToV()._check(ifAbsent);
        return this[_map$0][dartx.putIfAbsent](key, ifAbsent);
      }
      containsKey(key) {
        return this[_map$0][dartx.containsKey](key);
      }
      containsValue(value) {
        return this[_map$0][dartx.containsValue](value);
      }
      forEach(action) {
        this[_map$0][dartx.forEach](action);
      }
      get isEmpty() {
        return this[_map$0][dartx.isEmpty];
      }
      get isNotEmpty() {
        return this[_map$0][dartx.isNotEmpty];
      }
      get length() {
        return this[_map$0][dartx.length];
      }
      get keys() {
        return this[_map$0][dartx.keys];
      }
      remove(key) {
        return this[_map$0][dartx.remove](key);
      }
      toString() {
        return dart.toString(this[_map$0]);
      }
      get values() {
        return this[_map$0][dartx.values];
      }
    }
    dart.addTypeTests(MapView);
    MapView[dart.implements] = () => [MapOfK$V()];
    dart.setSignature(MapView, {
      constructors: () => ({new: dart.definiteFunctionType(collection.MapView$(K, V), [core.Map$(K, V)])}),
      methods: () => ({
        get: dart.definiteFunctionType(V, [core.Object]),
        set: dart.definiteFunctionType(dart.void, [K, V]),
        addAll: dart.definiteFunctionType(dart.void, [core.Map$(K, V)]),
        clear: dart.definiteFunctionType(dart.void, []),
        putIfAbsent: dart.definiteFunctionType(V, [K, dart.functionType(V, [])]),
        containsKey: dart.definiteFunctionType(core.bool, [core.Object]),
        containsValue: dart.definiteFunctionType(core.bool, [core.Object]),
        forEach: dart.definiteFunctionType(dart.void, [dart.functionType(dart.void, [K, V])]),
        remove: dart.definiteFunctionType(V, [core.Object])
      })
    });
    dart.defineExtensionMembers(MapView, [
      'get',
      'set',
      'addAll',
      'clear',
      'putIfAbsent',
      'containsKey',
      'containsValue',
      'forEach',
      'remove',
      'isEmpty',
      'isNotEmpty',
      'length',
      'keys',
      'values'
    ]);
    return MapView;
  });
  collection.MapView = MapView();
  collection.UnmodifiableMapView$ = dart.generic((K, V) => {
    class UnmodifiableMapView extends dart.mixin(collection.MapView$(K, V), collection._UnmodifiableMapMixin$(K, V)) {
      new(map) {
        super.new(map);
      }
    }
    return UnmodifiableMapView;
  });
  collection.UnmodifiableMapView = UnmodifiableMapView();
  collection.Maps = class Maps extends core.Object {
    static containsValue(map, value) {
      for (let v of map[dartx.values]) {
        if (dart.equals(v, value)) {
          return true;
        }
      }
      return false;
    }
    static containsKey(map, key) {
      for (let k of map[dartx.keys]) {
        if (dart.equals(k, key)) {
          return true;
        }
      }
      return false;
    }
    static putIfAbsent(map, key, ifAbsent) {
      if (dart.test(map[dartx.containsKey](key))) {
        return map[dartx.get](key);
      }
      let v = ifAbsent();
      map[dartx.set](key, v);
      return v;
    }
    static clear(map) {
      for (let k of map[dartx.keys][dartx.toList]()) {
        map[dartx.remove](k);
      }
    }
    static forEach(map, f) {
      for (let k of map[dartx.keys]) {
        dart.dcall(f, k, map[dartx.get](k));
      }
    }
    static getValues(map) {
      return map[dartx.keys][dartx.map](dart.dynamic)(dart.fn(key => map[dartx.get](key), dynamicTodynamic$()));
    }
    static length(map) {
      return map[dartx.keys][dartx.length];
    }
    static isEmpty(map) {
      return map[dartx.keys][dartx.isEmpty];
    }
    static isNotEmpty(map) {
      return map[dartx.keys][dartx.isNotEmpty];
    }
    static mapToString(m) {
      if (dart.test(collection._isToStringVisiting(m))) {
        return '{...}';
      }
      let result = new core.StringBuffer();
      try {
        collection._toStringVisiting[dartx.add](m);
        result.write('{');
        let first = true;
        m[dartx.forEach](dart.fn((k, v) => {
          if (!first) {
            result.write(', ');
          }
          first = false;
          result.write(k);
          result.write(': ');
          result.write(v);
        }, dynamicAnddynamicTovoid()));
        result.write('}');
      } finally {
        dart.assert(core.identical(collection._toStringVisiting[dartx.last], m));
        collection._toStringVisiting[dartx.removeLast]();
      }
      return result.toString();
    }
    static _id(x) {
      return x;
    }
    static _fillMapWithMappedIterable(map, iterable, key, value) {
      if (key == null) key = collection.Maps._id;
      if (value == null) value = collection.Maps._id;
      for (let element of iterable) {
        map[dartx.set](dart.dcall(key, element), dart.dcall(value, element));
      }
    }
    static _fillMapWithIterables(map, keys, values) {
      let keyIterator = keys[dartx.iterator];
      let valueIterator = values[dartx.iterator];
      let hasNextKey = keyIterator.moveNext();
      let hasNextValue = valueIterator.moveNext();
      while (dart.test(hasNextKey) && dart.test(hasNextValue)) {
        map[dartx.set](keyIterator.current, valueIterator.current);
        hasNextKey = keyIterator.moveNext();
        hasNextValue = valueIterator.moveNext();
      }
      if (dart.test(hasNextKey) || dart.test(hasNextValue)) {
        dart.throw(new core.ArgumentError("Iterables do not have same length."));
      }
    }
  };
  dart.setSignature(collection.Maps, {
    statics: () => ({
      containsValue: dart.definiteFunctionType(core.bool, [core.Map, core.Object]),
      containsKey: dart.definiteFunctionType(core.bool, [core.Map, core.Object]),
      putIfAbsent: dart.definiteFunctionType(dart.dynamic, [core.Map, dart.dynamic, dart.functionType(dart.dynamic, [])]),
      clear: dart.definiteFunctionType(dart.dynamic, [core.Map]),
      forEach: dart.definiteFunctionType(dart.dynamic, [core.Map, dart.functionType(dart.void, [dart.dynamic, dart.dynamic])]),
      getValues: dart.definiteFunctionType(core.Iterable, [core.Map]),
      length: dart.definiteFunctionType(core.int, [core.Map]),
      isEmpty: dart.definiteFunctionType(core.bool, [core.Map]),
      isNotEmpty: dart.definiteFunctionType(core.bool, [core.Map]),
      mapToString: dart.definiteFunctionType(core.String, [core.Map]),
      _id: dart.definiteFunctionType(dart.dynamic, [dart.dynamic]),
      _fillMapWithMappedIterable: dart.definiteFunctionType(dart.void, [core.Map, core.Iterable, dart.functionType(dart.dynamic, [dart.dynamic]), dart.functionType(dart.dynamic, [dart.dynamic])]),
      _fillMapWithIterables: dart.definiteFunctionType(dart.void, [core.Map, core.Iterable, core.Iterable])
    }),
    names: ['containsValue', 'containsKey', 'putIfAbsent', 'clear', 'forEach', 'getValues', 'length', 'isEmpty', 'isNotEmpty', 'mapToString', '_id', '_fillMapWithMappedIterable', '_fillMapWithIterables']
  });
  collection.Queue$ = dart.generic(E => {
    let ListQueueOfE = () => (ListQueueOfE = dart.constFn(collection.ListQueue$(E)))();
    let IterableOfE = () => (IterableOfE = dart.constFn(core.Iterable$(E)))();
    class Queue extends core.Object {
      static new() {
        return new (ListQueueOfE())();
      }
      static from(elements) {
        return ListQueueOfE().from(elements);
      }
      [Symbol.iterator]() {
        return new dart.JsIterator(this.iterator);
      }
    }
    dart.addTypeTests(Queue);
    Queue[dart.implements] = () => [IterableOfE(), _internal.EfficientLength];
    dart.setSignature(Queue, {
      constructors: () => ({
        new: dart.definiteFunctionType(collection.Queue$(E), []),
        from: dart.definiteFunctionType(collection.Queue$(E), [core.Iterable])
      })
    });
    return Queue;
  });
  collection.Queue = Queue();
  const _previousLink = Symbol('_previousLink');
  const _nextLink = Symbol('_nextLink');
  const _link = Symbol('_link');
  collection._DoubleLink$ = dart.generic(E => {
    class _DoubleLink extends core.Object {
      new() {
        this[_previousLink] = null;
        this[_nextLink] = null;
      }
      [_link](previous, next) {
        E._check(previous);
        E._check(next);
        this[_nextLink] = next;
        this[_previousLink] = previous;
        if (previous != null) previous[_nextLink] = this;
        if (next != null) next[_previousLink] = this;
      }
      [_unlink$]() {
        if (this[_previousLink] != null) this[_previousLink][_nextLink] = this[_nextLink];
        if (this[_nextLink] != null) this[_nextLink][_previousLink] = this[_previousLink];
        this[_nextLink] = null;
        this[_previousLink] = null;
      }
    }
    dart.addTypeTests(_DoubleLink);
    dart.setSignature(_DoubleLink, {
      methods: () => ({
        [_link]: dart.definiteFunctionType(dart.void, [E, E]),
        [_unlink$]: dart.definiteFunctionType(dart.void, [])
      })
    });
    return _DoubleLink;
  });
  collection._DoubleLink = _DoubleLink();
  collection.DoubleLinkedQueueEntry$ = dart.generic(E => {
    let _UserDoubleLinkedQueueEntryOfE = () => (_UserDoubleLinkedQueueEntryOfE = dart.constFn(collection._UserDoubleLinkedQueueEntry$(E)))();
    class DoubleLinkedQueueEntry extends core.Object {
      static new(element) {
        return new (_UserDoubleLinkedQueueEntryOfE())(element);
      }
    }
    dart.addTypeTests(DoubleLinkedQueueEntry);
    dart.setSignature(DoubleLinkedQueueEntry, {
      constructors: () => ({new: dart.definiteFunctionType(collection.DoubleLinkedQueueEntry$(E), [E])})
    });
    return DoubleLinkedQueueEntry;
  });
  collection.DoubleLinkedQueueEntry = DoubleLinkedQueueEntry();
  collection._UserDoubleLinkedQueueEntry$ = dart.generic(E => {
    let _UserDoubleLinkedQueueEntryOfE = () => (_UserDoubleLinkedQueueEntryOfE = dart.constFn(collection._UserDoubleLinkedQueueEntry$(E)))();
    let DoubleLinkedQueueEntryOfE = () => (DoubleLinkedQueueEntryOfE = dart.constFn(collection.DoubleLinkedQueueEntry$(E)))();
    class _UserDoubleLinkedQueueEntry extends collection._DoubleLink {
      new(element) {
        this.element = element;
        super.new();
      }
      append(e) {
        E._check(e);
        new (_UserDoubleLinkedQueueEntryOfE())(e)[_link](this, this[_nextLink]);
      }
      prepend(e) {
        E._check(e);
        new (_UserDoubleLinkedQueueEntryOfE())(e)[_link](this[_previousLink], this);
      }
      remove() {
        this[_unlink$]();
        return this.element;
      }
      previousEntry() {
        return this[_previousLink];
      }
      nextEntry() {
        return this[_nextLink];
      }
    }
    dart.setBaseClass(_UserDoubleLinkedQueueEntry, collection._DoubleLink$(_UserDoubleLinkedQueueEntry));
    _UserDoubleLinkedQueueEntry[dart.implements] = () => [DoubleLinkedQueueEntryOfE()];
    dart.setSignature(_UserDoubleLinkedQueueEntry, {
      constructors: () => ({new: dart.definiteFunctionType(collection._UserDoubleLinkedQueueEntry$(E), [E])}),
      methods: () => ({
        append: dart.definiteFunctionType(dart.void, [E]),
        prepend: dart.definiteFunctionType(dart.void, [E]),
        remove: dart.definiteFunctionType(E, []),
        previousEntry: dart.definiteFunctionType(collection.DoubleLinkedQueueEntry$(E), []),
        nextEntry: dart.definiteFunctionType(collection.DoubleLinkedQueueEntry$(E), [])
      })
    });
    return _UserDoubleLinkedQueueEntry;
  });
  collection._UserDoubleLinkedQueueEntry = _UserDoubleLinkedQueueEntry();
  const _queue = Symbol('_queue');
  const _append = Symbol('_append');
  const _prepend = Symbol('_prepend');
  const _asNonSentinelEntry = Symbol('_asNonSentinelEntry');
  collection._DoubleLinkedQueueEntry$ = dart.generic(E => {
    let _DoubleLinkedQueueElementOfE = () => (_DoubleLinkedQueueElementOfE = dart.constFn(collection._DoubleLinkedQueueElement$(E)))();
    class _DoubleLinkedQueueEntry extends collection._DoubleLink {
      new(queue) {
        this[_queue] = queue;
        super.new();
      }
      [_append](e) {
        E._check(e);
        new (_DoubleLinkedQueueElementOfE())(e, this[_queue])[_link](this, this[_nextLink]);
      }
      [_prepend](e) {
        E._check(e);
        new (_DoubleLinkedQueueElementOfE())(e, this[_queue])[_link](this[_previousLink], this);
      }
      nextEntry() {
        return this[_nextLink][_asNonSentinelEntry]();
      }
      previousEntry() {
        return this[_previousLink][_asNonSentinelEntry]();
      }
    }
    dart.setBaseClass(_DoubleLinkedQueueEntry, collection._DoubleLink$(_DoubleLinkedQueueEntry));
    dart.setSignature(_DoubleLinkedQueueEntry, {
      constructors: () => ({new: dart.definiteFunctionType(collection._DoubleLinkedQueueEntry$(E), [collection.DoubleLinkedQueue$(E)])}),
      methods: () => ({
        [_append]: dart.definiteFunctionType(dart.void, [E]),
        [_prepend]: dart.definiteFunctionType(dart.void, [E]),
        nextEntry: dart.definiteFunctionType(collection.DoubleLinkedQueueEntry$(E), []),
        previousEntry: dart.definiteFunctionType(collection.DoubleLinkedQueueEntry$(E), [])
      })
    });
    return _DoubleLinkedQueueEntry;
  });
  collection._DoubleLinkedQueueEntry = _DoubleLinkedQueueEntry();
  const _elementCount = Symbol('_elementCount');
  collection._DoubleLinkedQueueElement$ = dart.generic(E => {
    let DoubleLinkedQueueEntryOfE = () => (DoubleLinkedQueueEntryOfE = dart.constFn(collection.DoubleLinkedQueueEntry$(E)))();
    class _DoubleLinkedQueueElement extends collection._DoubleLinkedQueueEntry$(E) {
      new(element, queue) {
        this.element = element;
        super.new(queue);
      }
      append(e) {
        E._check(e);
        this[_append](e);
        if (this[_queue] != null) {
          let o = this[_queue];
          o[_elementCount] = dart.notNull(o[_elementCount]) + 1;
        }
      }
      prepend(e) {
        E._check(e);
        this[_prepend](e);
        if (this[_queue] != null) {
          let o = this[_queue];
          o[_elementCount] = dart.notNull(o[_elementCount]) + 1;
        }
      }
      [_remove]() {
        this[_queue] = null;
        this[_unlink$]();
        return this.element;
      }
      remove() {
        if (this[_queue] != null) {
          let o = this[_queue];
          o[_elementCount] = dart.notNull(o[_elementCount]) - 1;
        }
        return this[_remove]();
      }
      [_asNonSentinelEntry]() {
        return this;
      }
    }
    _DoubleLinkedQueueElement[dart.implements] = () => [DoubleLinkedQueueEntryOfE()];
    dart.setSignature(_DoubleLinkedQueueElement, {
      constructors: () => ({new: dart.definiteFunctionType(collection._DoubleLinkedQueueElement$(E), [E, collection.DoubleLinkedQueue$(E)])}),
      methods: () => ({
        append: dart.definiteFunctionType(dart.void, [E]),
        prepend: dart.definiteFunctionType(dart.void, [E]),
        [_remove]: dart.definiteFunctionType(E, []),
        remove: dart.definiteFunctionType(E, []),
        [_asNonSentinelEntry]: dart.definiteFunctionType(collection._DoubleLinkedQueueElement$(E), [])
      })
    });
    return _DoubleLinkedQueueElement;
  });
  collection._DoubleLinkedQueueElement = _DoubleLinkedQueueElement();
  collection._DoubleLinkedQueueSentinel$ = dart.generic(E => {
    class _DoubleLinkedQueueSentinel extends collection._DoubleLinkedQueueEntry$(E) {
      new(queue) {
        super.new(queue);
        this[_previousLink] = this;
        this[_nextLink] = this;
      }
      [_asNonSentinelEntry]() {
        return null;
      }
      [_remove]() {
        dart.throw(_internal.IterableElementError.noElement());
      }
      get element() {
        dart.throw(_internal.IterableElementError.noElement());
      }
    }
    dart.setSignature(_DoubleLinkedQueueSentinel, {
      constructors: () => ({new: dart.definiteFunctionType(collection._DoubleLinkedQueueSentinel$(E), [collection.DoubleLinkedQueue$(E)])}),
      methods: () => ({
        [_asNonSentinelEntry]: dart.definiteFunctionType(collection.DoubleLinkedQueueEntry$(E), []),
        [_remove]: dart.definiteFunctionType(E, [])
      })
    });
    return _DoubleLinkedQueueSentinel;
  });
  collection._DoubleLinkedQueueSentinel = _DoubleLinkedQueueSentinel();
  const _sentinel = Symbol('_sentinel');
  const _filter = Symbol('_filter');
  collection.DoubleLinkedQueue$ = dart.generic(E => {
    let _DoubleLinkedQueueSentinelOfE = () => (_DoubleLinkedQueueSentinelOfE = dart.constFn(collection._DoubleLinkedQueueSentinel$(E)))();
    let DoubleLinkedQueueOfE = () => (DoubleLinkedQueueOfE = dart.constFn(collection.DoubleLinkedQueue$(E)))();
    let IterableOfE = () => (IterableOfE = dart.constFn(core.Iterable$(E)))();
    let _DoubleLinkedQueueElementOfE = () => (_DoubleLinkedQueueElementOfE = dart.constFn(collection._DoubleLinkedQueueElement$(E)))();
    let _DoubleLinkedQueueIteratorOfE = () => (_DoubleLinkedQueueIteratorOfE = dart.constFn(collection._DoubleLinkedQueueIterator$(E)))();
    let QueueOfE = () => (QueueOfE = dart.constFn(collection.Queue$(E)))();
    class DoubleLinkedQueue extends core.Iterable$(E) {
      new() {
        this[_sentinel] = null;
        this[_elementCount] = 0;
        super.new();
        this[_sentinel] = new (_DoubleLinkedQueueSentinelOfE())(this);
      }
      static from(elements) {
        let list = new (DoubleLinkedQueueOfE())();
        for (let e of elements) {
          let element = E.as(e);
          list.addLast(element);
        }
        return DoubleLinkedQueueOfE()._check(list);
      }
      get length() {
        return this[_elementCount];
      }
      addLast(value) {
        E._check(value);
        this[_sentinel][_prepend](value);
        this[_elementCount] = dart.notNull(this[_elementCount]) + 1;
      }
      addFirst(value) {
        E._check(value);
        this[_sentinel][_append](value);
        this[_elementCount] = dart.notNull(this[_elementCount]) + 1;
      }
      add(value) {
        E._check(value);
        this[_sentinel][_prepend](value);
        this[_elementCount] = dart.notNull(this[_elementCount]) + 1;
      }
      addAll(iterable) {
        IterableOfE()._check(iterable);
        for (let value of iterable) {
          this[_sentinel][_prepend](value);
          this[_elementCount] = dart.notNull(this[_elementCount]) + 1;
        }
      }
      removeLast() {
        let lastEntry = this[_sentinel][_previousLink];
        let result = lastEntry[_remove]();
        this[_elementCount] = dart.notNull(this[_elementCount]) - 1;
        return result;
      }
      removeFirst() {
        let firstEntry = this[_sentinel][_nextLink];
        let result = firstEntry[_remove]();
        this[_elementCount] = dart.notNull(this[_elementCount]) - 1;
        return result;
      }
      remove(o) {
        let entry = this[_sentinel][_nextLink];
        while (!core.identical(entry, this[_sentinel])) {
          if (dart.equals(entry.element, o)) {
            entry[_remove]();
            this[_elementCount] = dart.notNull(this[_elementCount]) - 1;
            return true;
          }
          entry = entry[_nextLink];
        }
        return false;
      }
      [_filter](test, removeMatching) {
        let entry = this[_sentinel][_nextLink];
        while (!core.identical(entry, this[_sentinel])) {
          let next = entry[_nextLink];
          if (core.identical(removeMatching, test(entry.element))) {
            entry[_remove]();
            this[_elementCount] = dart.notNull(this[_elementCount]) - 1;
          }
          entry = next;
        }
      }
      removeWhere(test) {
        this[_filter](test, true);
      }
      retainWhere(test) {
        this[_filter](test, false);
      }
      get first() {
        let firstEntry = this[_sentinel][_nextLink];
        return firstEntry.element;
      }
      get last() {
        let lastEntry = this[_sentinel][_previousLink];
        return lastEntry.element;
      }
      get single() {
        if (core.identical(this[_sentinel][_nextLink], this[_sentinel][_previousLink])) {
          let entry = this[_sentinel][_nextLink];
          return entry.element;
        }
        dart.throw(_internal.IterableElementError.tooMany());
      }
      lastEntry() {
        return this[_sentinel].previousEntry();
      }
      firstEntry() {
        return this[_sentinel].nextEntry();
      }
      get isEmpty() {
        return core.identical(this[_sentinel][_nextLink], this[_sentinel]);
      }
      clear() {
        this[_sentinel][_nextLink] = this[_sentinel];
        this[_sentinel][_previousLink] = this[_sentinel];
        this[_elementCount] = 0;
      }
      forEachEntry(f) {
        let entry = this[_sentinel][_nextLink];
        while (!core.identical(entry, this[_sentinel])) {
          let nextEntry = entry[_nextLink];
          let element = _DoubleLinkedQueueElementOfE()._check(entry);
          f(element);
          entry = nextEntry;
        }
      }
      get iterator() {
        return new (_DoubleLinkedQueueIteratorOfE())(this[_sentinel]);
      }
      toString() {
        return collection.IterableBase.iterableToFullString(this, '{', '}');
      }
    }
    DoubleLinkedQueue[dart.implements] = () => [QueueOfE()];
    dart.setSignature(DoubleLinkedQueue, {
      constructors: () => ({
        new: dart.definiteFunctionType(collection.DoubleLinkedQueue$(E), []),
        from: dart.definiteFunctionType(collection.DoubleLinkedQueue$(E), [core.Iterable])
      }),
      methods: () => ({
        addLast: dart.definiteFunctionType(dart.void, [E]),
        addFirst: dart.definiteFunctionType(dart.void, [E]),
        add: dart.definiteFunctionType(dart.void, [E]),
        addAll: dart.definiteFunctionType(dart.void, [core.Iterable$(E)]),
        removeLast: dart.definiteFunctionType(E, []),
        removeFirst: dart.definiteFunctionType(E, []),
        remove: dart.definiteFunctionType(core.bool, [core.Object]),
        [_filter]: dart.definiteFunctionType(dart.void, [dart.functionType(core.bool, [E]), core.bool]),
        removeWhere: dart.definiteFunctionType(dart.void, [dart.functionType(core.bool, [E])]),
        retainWhere: dart.definiteFunctionType(dart.void, [dart.functionType(core.bool, [E])]),
        lastEntry: dart.definiteFunctionType(collection.DoubleLinkedQueueEntry$(E), []),
        firstEntry: dart.definiteFunctionType(collection.DoubleLinkedQueueEntry$(E), []),
        clear: dart.definiteFunctionType(dart.void, []),
        forEachEntry: dart.definiteFunctionType(dart.void, [dart.functionType(dart.void, [collection.DoubleLinkedQueueEntry$(E)])])
      })
    });
    dart.defineExtensionMembers(DoubleLinkedQueue, [
      'toString',
      'length',
      'first',
      'last',
      'single',
      'isEmpty',
      'iterator'
    ]);
    return DoubleLinkedQueue;
  });
  collection.DoubleLinkedQueue = DoubleLinkedQueue();
  const _nextEntry = Symbol('_nextEntry');
  collection._DoubleLinkedQueueIterator$ = dart.generic(E => {
    let _DoubleLinkedQueueElementOfE = () => (_DoubleLinkedQueueElementOfE = dart.constFn(collection._DoubleLinkedQueueElement$(E)))();
    let IteratorOfE = () => (IteratorOfE = dart.constFn(core.Iterator$(E)))();
    class _DoubleLinkedQueueIterator extends core.Object {
      new(sentinel) {
        this[_sentinel] = sentinel;
        this[_nextEntry] = sentinel[_nextLink];
        this[_current$2] = null;
      }
      moveNext() {
        if (core.identical(this[_nextEntry], this[_sentinel])) {
          this[_current$2] = null;
          this[_nextEntry] = null;
          this[_sentinel] = null;
          return false;
        }
        let elementEntry = _DoubleLinkedQueueElementOfE()._check(this[_nextEntry]);
        if (elementEntry[_queue] == null) {
          dart.throw(new core.ConcurrentModificationError(this[_sentinel][_queue]));
        }
        this[_current$2] = elementEntry.element;
        this[_nextEntry] = elementEntry[_nextLink];
        return true;
      }
      get current() {
        return this[_current$2];
      }
    }
    dart.addTypeTests(_DoubleLinkedQueueIterator);
    _DoubleLinkedQueueIterator[dart.implements] = () => [IteratorOfE()];
    dart.setSignature(_DoubleLinkedQueueIterator, {
      constructors: () => ({new: dart.definiteFunctionType(collection._DoubleLinkedQueueIterator$(E), [collection._DoubleLinkedQueueSentinel$(E)])}),
      methods: () => ({moveNext: dart.definiteFunctionType(core.bool, [])})
    });
    return _DoubleLinkedQueueIterator;
  });
  collection._DoubleLinkedQueueIterator = _DoubleLinkedQueueIterator();
  const _head = Symbol('_head');
  const _tail = Symbol('_tail');
  const _table = Symbol('_table');
  const _checkModification = Symbol('_checkModification');
  const _writeToList = Symbol('_writeToList');
  const _preGrow = Symbol('_preGrow');
  const _grow = Symbol('_grow');
  collection.ListQueue$ = dart.generic(E => {
    let ListOfE = () => (ListOfE = dart.constFn(core.List$(E)))();
    let ListQueueOfE = () => (ListQueueOfE = dart.constFn(collection.ListQueue$(E)))();
    let _ListQueueIteratorOfE = () => (_ListQueueIteratorOfE = dart.constFn(collection._ListQueueIterator$(E)))();
    let IterableOfE = () => (IterableOfE = dart.constFn(core.Iterable$(E)))();
    let QueueOfE = () => (QueueOfE = dart.constFn(collection.Queue$(E)))();
    class ListQueue extends core.Iterable$(E) {
      new(initialCapacity) {
        if (initialCapacity === void 0) initialCapacity = null;
        this[_head] = 0;
        this[_tail] = 0;
        this[_table] = null;
        this[_modificationCount] = 0;
        super.new();
        if (initialCapacity == null || dart.notNull(initialCapacity) < collection.ListQueue._INITIAL_CAPACITY) {
          initialCapacity = collection.ListQueue._INITIAL_CAPACITY;
        } else if (!dart.test(collection.ListQueue._isPowerOf2(initialCapacity))) {
          initialCapacity = collection.ListQueue._nextPowerOf2(initialCapacity);
        }
        dart.assert(collection.ListQueue._isPowerOf2(initialCapacity));
        this[_table] = ListOfE().new(initialCapacity);
      }
      static from(elements) {
        if (core.List.is(elements)) {
          let length = elements[dartx.length];
          let queue = new (ListQueueOfE())(dart.notNull(length) + 1);
          dart.assert(dart.notNull(queue[_table][dartx.length]) > dart.notNull(length));
          for (let i = 0; i < dart.notNull(length); i++) {
            queue[_table][dartx.set](i, E.as(elements[dartx.get](i)));
          }
          queue[_tail] = length;
          return queue;
        } else {
          let capacity = collection.ListQueue._INITIAL_CAPACITY;
          if (_internal.EfficientLength.is(elements)) {
            capacity = elements[dartx.length];
          }
          let result = new (ListQueueOfE())(capacity);
          for (let element of elements) {
            result.addLast(E.as(element));
          }
          return result;
        }
      }
      get iterator() {
        return new (_ListQueueIteratorOfE())(this);
      }
      forEach(action) {
        let modificationCount = this[_modificationCount];
        for (let i = this[_head]; i != this[_tail]; i = (dart.notNull(i) + 1 & dart.notNull(this[_table][dartx.length]) - 1) >>> 0) {
          action(this[_table][dartx.get](i));
          this[_checkModification](modificationCount);
        }
      }
      get isEmpty() {
        return this[_head] == this[_tail];
      }
      get length() {
        return (dart.notNull(this[_tail]) - dart.notNull(this[_head]) & dart.notNull(this[_table][dartx.length]) - 1) >>> 0;
      }
      get first() {
        if (this[_head] == this[_tail]) dart.throw(_internal.IterableElementError.noElement());
        return this[_table][dartx.get](this[_head]);
      }
      get last() {
        if (this[_head] == this[_tail]) dart.throw(_internal.IterableElementError.noElement());
        return this[_table][dartx.get]((dart.notNull(this[_tail]) - 1 & dart.notNull(this[_table][dartx.length]) - 1) >>> 0);
      }
      get single() {
        if (this[_head] == this[_tail]) dart.throw(_internal.IterableElementError.noElement());
        if (dart.notNull(this.length) > 1) dart.throw(_internal.IterableElementError.tooMany());
        return this[_table][dartx.get](this[_head]);
      }
      elementAt(index) {
        core.RangeError.checkValidIndex(index, this);
        return this[_table][dartx.get]((dart.notNull(this[_head]) + dart.notNull(index) & dart.notNull(this[_table][dartx.length]) - 1) >>> 0);
      }
      toList(opts) {
        let growable = opts && 'growable' in opts ? opts.growable : true;
        let list = null;
        if (dart.test(growable)) {
          list = ListOfE().new();
          list[dartx.length] = this.length;
        } else {
          list = ListOfE().new(this.length);
        }
        this[_writeToList](list);
        return list;
      }
      add(value) {
        E._check(value);
        this[_add$0](value);
      }
      addAll(elements) {
        IterableOfE()._check(elements);
        if (ListOfE().is(elements)) {
          let list = elements;
          let addCount = list[dartx.length];
          let length = this.length;
          if (dart.notNull(length) + dart.notNull(addCount) >= dart.notNull(this[_table][dartx.length])) {
            this[_preGrow](dart.notNull(length) + dart.notNull(addCount));
            this[_table][dartx.setRange](length, dart.notNull(length) + dart.notNull(addCount), list, 0);
            this[_tail] = dart.notNull(this[_tail]) + dart.notNull(addCount);
          } else {
            let endSpace = dart.notNull(this[_table][dartx.length]) - dart.notNull(this[_tail]);
            if (dart.notNull(addCount) < endSpace) {
              this[_table][dartx.setRange](this[_tail], dart.notNull(this[_tail]) + dart.notNull(addCount), list, 0);
              this[_tail] = dart.notNull(this[_tail]) + dart.notNull(addCount);
            } else {
              let preSpace = dart.notNull(addCount) - endSpace;
              this[_table][dartx.setRange](this[_tail], dart.notNull(this[_tail]) + endSpace, list, 0);
              this[_table][dartx.setRange](0, preSpace, list, endSpace);
              this[_tail] = preSpace;
            }
          }
          this[_modificationCount] = dart.notNull(this[_modificationCount]) + 1;
        } else {
          for (let element of elements)
            this[_add$0](element);
        }
      }
      remove(value) {
        for (let i = this[_head]; i != this[_tail]; i = (dart.notNull(i) + 1 & dart.notNull(this[_table][dartx.length]) - 1) >>> 0) {
          let element = this[_table][dartx.get](i);
          if (dart.equals(element, value)) {
            this[_remove](i);
            this[_modificationCount] = dart.notNull(this[_modificationCount]) + 1;
            return true;
          }
        }
        return false;
      }
      [_filterWhere](test, removeMatching) {
        let modificationCount = this[_modificationCount];
        let i = this[_head];
        while (i != this[_tail]) {
          let element = this[_table][dartx.get](i);
          let remove = core.identical(removeMatching, test(element));
          this[_checkModification](modificationCount);
          if (remove) {
            i = this[_remove](i);
            modificationCount = this[_modificationCount] = dart.notNull(this[_modificationCount]) + 1;
          } else {
            i = (dart.notNull(i) + 1 & dart.notNull(this[_table][dartx.length]) - 1) >>> 0;
          }
        }
      }
      removeWhere(test) {
        this[_filterWhere](test, true);
      }
      retainWhere(test) {
        this[_filterWhere](test, false);
      }
      clear() {
        if (this[_head] != this[_tail]) {
          for (let i = this[_head]; i != this[_tail]; i = (dart.notNull(i) + 1 & dart.notNull(this[_table][dartx.length]) - 1) >>> 0) {
            this[_table][dartx.set](i, null);
          }
          this[_head] = this[_tail] = 0;
          this[_modificationCount] = dart.notNull(this[_modificationCount]) + 1;
        }
      }
      toString() {
        return collection.IterableBase.iterableToFullString(this, "{", "}");
      }
      addLast(value) {
        E._check(value);
        this[_add$0](value);
      }
      addFirst(value) {
        E._check(value);
        this[_head] = (dart.notNull(this[_head]) - 1 & dart.notNull(this[_table][dartx.length]) - 1) >>> 0;
        this[_table][dartx.set](this[_head], value);
        if (this[_head] == this[_tail]) this[_grow]();
        this[_modificationCount] = dart.notNull(this[_modificationCount]) + 1;
      }
      removeFirst() {
        if (this[_head] == this[_tail]) dart.throw(_internal.IterableElementError.noElement());
        this[_modificationCount] = dart.notNull(this[_modificationCount]) + 1;
        let result = this[_table][dartx.get](this[_head]);
        this[_table][dartx.set](this[_head], null);
        this[_head] = (dart.notNull(this[_head]) + 1 & dart.notNull(this[_table][dartx.length]) - 1) >>> 0;
        return result;
      }
      removeLast() {
        if (this[_head] == this[_tail]) dart.throw(_internal.IterableElementError.noElement());
        this[_modificationCount] = dart.notNull(this[_modificationCount]) + 1;
        this[_tail] = (dart.notNull(this[_tail]) - 1 & dart.notNull(this[_table][dartx.length]) - 1) >>> 0;
        let result = this[_table][dartx.get](this[_tail]);
        this[_table][dartx.set](this[_tail], null);
        return result;
      }
      static _isPowerOf2(number) {
        return (dart.notNull(number) & dart.notNull(number) - 1) == 0;
      }
      static _nextPowerOf2(number) {
        dart.assert(dart.notNull(number) > 0);
        number = (dart.notNull(number) << 1 >>> 0) - 1;
        for (;;) {
          let nextNumber = (dart.notNull(number) & dart.notNull(number) - 1) >>> 0;
          if (nextNumber == 0) return number;
          number = nextNumber;
        }
      }
      [_checkModification](expectedModificationCount) {
        if (expectedModificationCount != this[_modificationCount]) {
          dart.throw(new core.ConcurrentModificationError(this));
        }
      }
      [_add$0](element) {
        E._check(element);
        this[_table][dartx.set](this[_tail], element);
        this[_tail] = (dart.notNull(this[_tail]) + 1 & dart.notNull(this[_table][dartx.length]) - 1) >>> 0;
        if (this[_head] == this[_tail]) this[_grow]();
        this[_modificationCount] = dart.notNull(this[_modificationCount]) + 1;
      }
      [_remove](offset) {
        let mask = dart.notNull(this[_table][dartx.length]) - 1;
        let startDistance = (dart.notNull(offset) - dart.notNull(this[_head]) & mask) >>> 0;
        let endDistance = (dart.notNull(this[_tail]) - dart.notNull(offset) & mask) >>> 0;
        if (startDistance < endDistance) {
          let i = offset;
          while (i != this[_head]) {
            let prevOffset = (dart.notNull(i) - 1 & mask) >>> 0;
            this[_table][dartx.set](i, this[_table][dartx.get](prevOffset));
            i = prevOffset;
          }
          this[_table][dartx.set](this[_head], null);
          this[_head] = (dart.notNull(this[_head]) + 1 & mask) >>> 0;
          return (dart.notNull(offset) + 1 & mask) >>> 0;
        } else {
          this[_tail] = (dart.notNull(this[_tail]) - 1 & mask) >>> 0;
          let i = offset;
          while (i != this[_tail]) {
            let nextOffset = (dart.notNull(i) + 1 & mask) >>> 0;
            this[_table][dartx.set](i, this[_table][dartx.get](nextOffset));
            i = nextOffset;
          }
          this[_table][dartx.set](this[_tail], null);
          return offset;
        }
      }
      [_grow]() {
        let newTable = ListOfE().new(dart.notNull(this[_table][dartx.length]) * 2);
        let split = dart.notNull(this[_table][dartx.length]) - dart.notNull(this[_head]);
        newTable[dartx.setRange](0, split, this[_table], this[_head]);
        newTable[dartx.setRange](split, split + dart.notNull(this[_head]), this[_table], 0);
        this[_head] = 0;
        this[_tail] = this[_table][dartx.length];
        this[_table] = newTable;
      }
      [_writeToList](target) {
        ListOfE()._check(target);
        dart.assert(dart.notNull(target[dartx.length]) >= dart.notNull(this.length));
        if (dart.notNull(this[_head]) <= dart.notNull(this[_tail])) {
          let length = dart.notNull(this[_tail]) - dart.notNull(this[_head]);
          target[dartx.setRange](0, length, this[_table], this[_head]);
          return length;
        } else {
          let firstPartSize = dart.notNull(this[_table][dartx.length]) - dart.notNull(this[_head]);
          target[dartx.setRange](0, firstPartSize, this[_table], this[_head]);
          target[dartx.setRange](firstPartSize, firstPartSize + dart.notNull(this[_tail]), this[_table], 0);
          return dart.notNull(this[_tail]) + firstPartSize;
        }
      }
      [_preGrow](newElementCount) {
        dart.assert(dart.notNull(newElementCount) >= dart.notNull(this.length));
        newElementCount = dart.notNull(newElementCount) + newElementCount[dartx['>>']](1);
        let newCapacity = collection.ListQueue._nextPowerOf2(newElementCount);
        let newTable = ListOfE().new(newCapacity);
        this[_tail] = this[_writeToList](newTable);
        this[_table] = newTable;
        this[_head] = 0;
      }
    }
    ListQueue[dart.implements] = () => [QueueOfE()];
    dart.setSignature(ListQueue, {
      constructors: () => ({
        new: dart.definiteFunctionType(collection.ListQueue$(E), [], [core.int]),
        from: dart.definiteFunctionType(collection.ListQueue$(E), [core.Iterable])
      }),
      methods: () => ({
        forEach: dart.definiteFunctionType(dart.void, [dart.functionType(dart.void, [E])]),
        elementAt: dart.definiteFunctionType(E, [core.int]),
        toList: dart.definiteFunctionType(core.List$(E), [], {growable: core.bool}),
        add: dart.definiteFunctionType(dart.void, [E]),
        addAll: dart.definiteFunctionType(dart.void, [core.Iterable$(E)]),
        remove: dart.definiteFunctionType(core.bool, [core.Object]),
        [_filterWhere]: dart.definiteFunctionType(dart.void, [dart.functionType(core.bool, [E]), core.bool]),
        removeWhere: dart.definiteFunctionType(dart.void, [dart.functionType(core.bool, [E])]),
        retainWhere: dart.definiteFunctionType(dart.void, [dart.functionType(core.bool, [E])]),
        clear: dart.definiteFunctionType(dart.void, []),
        addLast: dart.definiteFunctionType(dart.void, [E]),
        addFirst: dart.definiteFunctionType(dart.void, [E]),
        removeFirst: dart.definiteFunctionType(E, []),
        removeLast: dart.definiteFunctionType(E, []),
        [_checkModification]: dart.definiteFunctionType(dart.void, [core.int]),
        [_add$0]: dart.definiteFunctionType(dart.void, [E]),
        [_remove]: dart.definiteFunctionType(core.int, [core.int]),
        [_grow]: dart.definiteFunctionType(dart.void, []),
        [_writeToList]: dart.definiteFunctionType(core.int, [core.List$(E)]),
        [_preGrow]: dart.definiteFunctionType(dart.void, [core.int])
      }),
      statics: () => ({
        _isPowerOf2: dart.definiteFunctionType(core.bool, [core.int]),
        _nextPowerOf2: dart.definiteFunctionType(core.int, [core.int])
      }),
      names: ['_isPowerOf2', '_nextPowerOf2']
    });
    dart.defineExtensionMembers(ListQueue, [
      'forEach',
      'elementAt',
      'toList',
      'toString',
      'iterator',
      'isEmpty',
      'length',
      'first',
      'last',
      'single'
    ]);
    return ListQueue;
  });
  collection.ListQueue = ListQueue();
  collection.ListQueue._INITIAL_CAPACITY = 8;
  const _end = Symbol('_end');
  const _position = Symbol('_position');
  collection._ListQueueIterator$ = dart.generic(E => {
    let IteratorOfE = () => (IteratorOfE = dart.constFn(core.Iterator$(E)))();
    class _ListQueueIterator extends core.Object {
      new(queue) {
        this[_queue] = queue;
        this[_end] = queue[_tail];
        this[_modificationCount] = queue[_modificationCount];
        this[_position] = queue[_head];
        this[_current$2] = null;
      }
      get current() {
        return this[_current$2];
      }
      moveNext() {
        this[_queue][_checkModification](this[_modificationCount]);
        if (this[_position] == this[_end]) {
          this[_current$2] = null;
          return false;
        }
        this[_current$2] = this[_queue][_table][dartx.get](this[_position]);
        this[_position] = (dart.notNull(this[_position]) + 1 & dart.notNull(this[_queue][_table][dartx.length]) - 1) >>> 0;
        return true;
      }
    }
    dart.addTypeTests(_ListQueueIterator);
    _ListQueueIterator[dart.implements] = () => [IteratorOfE()];
    dart.setSignature(_ListQueueIterator, {
      constructors: () => ({new: dart.definiteFunctionType(collection._ListQueueIterator$(E), [collection.ListQueue$(E)])}),
      methods: () => ({moveNext: dart.definiteFunctionType(core.bool, [])})
    });
    return _ListQueueIterator;
  });
  collection._ListQueueIterator = _ListQueueIterator();
  collection._Predicate$ = dart.generic(T => {
    const _Predicate = dart.typedef('_Predicate', () => dart.functionType(core.bool, [T]));
    return _Predicate;
  });
  collection._Predicate = _Predicate$();
  collection._SplayTreeNode$ = dart.generic(K => {
    class _SplayTreeNode extends core.Object {
      new(key) {
        this.key = key;
        this.left = null;
        this.right = null;
      }
    }
    dart.addTypeTests(_SplayTreeNode);
    dart.setSignature(_SplayTreeNode, {
      constructors: () => ({new: dart.definiteFunctionType(collection._SplayTreeNode$(K), [K])})
    });
    return _SplayTreeNode;
  });
  collection._SplayTreeNode = _SplayTreeNode();
  collection._SplayTreeMapNode$ = dart.generic((K, V) => {
    class _SplayTreeMapNode extends collection._SplayTreeNode$(K) {
      new(key, value) {
        this.value = value;
        super.new(key);
      }
    }
    dart.setSignature(_SplayTreeMapNode, {
      constructors: () => ({new: dart.definiteFunctionType(collection._SplayTreeMapNode$(K, V), [K, V])})
    });
    return _SplayTreeMapNode;
  });
  collection._SplayTreeMapNode = _SplayTreeMapNode();
  const _count$ = Symbol('_count');
  const _splayCount = Symbol('_splayCount');
  const _root = Symbol('_root');
  const _dummy = Symbol('_dummy');
  const _comparator = Symbol('_comparator');
  const _compare = Symbol('_compare');
  const _splay = Symbol('_splay');
  const _splayMin = Symbol('_splayMin');
  const _splayMax = Symbol('_splayMax');
  const _addNewRoot = Symbol('_addNewRoot');
  const _clear$ = Symbol('_clear');
  collection._SplayTree$ = dart.generic((K, Node) => {
    class _SplayTree extends core.Object {
      new() {
        this[_count$] = 0;
        this[_modificationCount] = 0;
        this[_splayCount] = 0;
      }
      [_splay](key) {
        K._check(key);
        if (this[_root] == null) return -1;
        let left = this[_dummy];
        let right = this[_dummy];
        let current = this[_root];
        let comp = null;
        while (true) {
          comp = this[_compare](current.key, key);
          if (dart.notNull(comp) > 0) {
            if (current.left == null) break;
            comp = this[_compare](current.left.key, key);
            if (dart.notNull(comp) > 0) {
              let tmp = current.left;
              current.left = tmp.right;
              tmp.right = current;
              current = Node._check(tmp);
              if (current.left == null) break;
            }
            right.left = current;
            right = current;
            current = Node._check(current.left);
          } else if (dart.notNull(comp) < 0) {
            if (current.right == null) break;
            comp = this[_compare](current.right.key, key);
            if (dart.notNull(comp) < 0) {
              let tmp = Node._check(current.right);
              current.right = tmp.left;
              tmp.left = current;
              current = tmp;
              if (current.right == null) break;
            }
            left.right = current;
            left = current;
            current = Node._check(current.right);
          } else {
            break;
          }
        }
        left.right = current.left;
        right.left = current.right;
        current.left = this[_dummy].right;
        current.right = this[_dummy].left;
        this[_root] = current;
        this[_dummy].right = null;
        this[_dummy].left = null;
        this[_splayCount] = dart.notNull(this[_splayCount]) + 1;
        return comp;
      }
      [_splayMin](node) {
        Node._check(node);
        let current = node;
        while (current.left != null) {
          let left = Node._check(current.left);
          current.left = left.right;
          left.right = current;
          current = left;
        }
        return current;
      }
      [_splayMax](node) {
        Node._check(node);
        let current = node;
        while (current.right != null) {
          let right = Node._check(current.right);
          current.right = right.left;
          right.left = current;
          current = right;
        }
        return current;
      }
      [_remove](key) {
        K._check(key);
        if (this[_root] == null) return null;
        let comp = this[_splay](key);
        if (comp != 0) return null;
        let result = this[_root];
        this[_count$] = dart.notNull(this[_count$]) - 1;
        if (this[_root].left == null) {
          this[_root] = Node._check(this[_root].right);
        } else {
          let right = Node._check(this[_root].right);
          this[_root] = this[_splayMax](Node._check(this[_root].left));
          this[_root].right = right;
        }
        this[_modificationCount] = dart.notNull(this[_modificationCount]) + 1;
        return result;
      }
      [_addNewRoot](node, comp) {
        Node._check(node);
        this[_count$] = dart.notNull(this[_count$]) + 1;
        this[_modificationCount] = dart.notNull(this[_modificationCount]) + 1;
        if (this[_root] == null) {
          this[_root] = node;
          return;
        }
        if (dart.notNull(comp) < 0) {
          node.left = this[_root];
          node.right = this[_root].right;
          this[_root].right = null;
        } else {
          node.right = this[_root];
          node.left = this[_root].left;
          this[_root].left = null;
        }
        this[_root] = node;
      }
      get [_first$]() {
        if (this[_root] == null) return null;
        this[_root] = this[_splayMin](this[_root]);
        return this[_root];
      }
      get [_last$]() {
        if (this[_root] == null) return null;
        this[_root] = this[_splayMax](this[_root]);
        return this[_root];
      }
      [_clear$]() {
        this[_root] = null;
        this[_count$] = 0;
        this[_modificationCount] = dart.notNull(this[_modificationCount]) + 1;
      }
    }
    dart.addTypeTests(_SplayTree);
    dart.setSignature(_SplayTree, {
      methods: () => ({
        [_splay]: dart.definiteFunctionType(core.int, [K]),
        [_splayMin]: dart.definiteFunctionType(Node, [Node]),
        [_splayMax]: dart.definiteFunctionType(Node, [Node]),
        [_remove]: dart.definiteFunctionType(Node, [K]),
        [_addNewRoot]: dart.definiteFunctionType(dart.void, [Node, core.int]),
        [_clear$]: dart.definiteFunctionType(dart.void, [])
      })
    });
    return _SplayTree;
  });
  collection._SplayTree = _SplayTree();
  collection._TypeTest$ = dart.generic(T => {
    class _TypeTest extends core.Object {
      test(v) {
        return T.is(v);
      }
    }
    dart.addTypeTests(_TypeTest);
    dart.setSignature(_TypeTest, {
      methods: () => ({test: dart.definiteFunctionType(core.bool, [dart.dynamic])})
    });
    return _TypeTest;
  });
  collection._TypeTest = _TypeTest();
  collection.SplayTreeMap$ = dart.generic((K, V) => {
    let _SplayTreeMapNodeOfK$V = () => (_SplayTreeMapNodeOfK$V = dart.constFn(collection._SplayTreeMapNode$(K, V)))();
    let ComparatorOfK = () => (ComparatorOfK = dart.constFn(core.Comparator$(K)))();
    let SplayTreeMapOfK$V = () => (SplayTreeMapOfK$V = dart.constFn(collection.SplayTreeMap$(K, V)))();
    let MapOfK$V = () => (MapOfK$V = dart.constFn(core.Map$(K, V)))();
    let _SplayTreeNodeIteratorOfK = () => (_SplayTreeNodeIteratorOfK = dart.constFn(collection._SplayTreeNodeIterator$(K)))();
    let _SplayTreeKeyIterableOfK = () => (_SplayTreeKeyIterableOfK = dart.constFn(collection._SplayTreeKeyIterable$(K)))();
    let _SplayTreeValueIterableOfK$V = () => (_SplayTreeValueIterableOfK$V = dart.constFn(collection._SplayTreeValueIterable$(K, V)))();
    let dynamicToK = () => (dynamicToK = dart.constFn(dart.functionType(K, [dart.dynamic])))();
    let VoidToV = () => (VoidToV = dart.constFn(dart.functionType(V, [])))();
    let dynamicToV = () => (dynamicToV = dart.constFn(dart.functionType(V, [dart.dynamic])))();
    let KAndVTovoid = () => (KAndVTovoid = dart.constFn(dart.definiteFunctionType(dart.void, [K, V])))();
    class SplayTreeMap extends collection._SplayTree$(K, collection._SplayTreeMapNode$(K, V)) {
      new(compare, isValidKey) {
        if (compare === void 0) compare = null;
        if (isValidKey === void 0) isValidKey = null;
        this[_dummy] = new (_SplayTreeMapNodeOfK$V())(null, null);
        this[_comparator] = (() => {
          let l = compare;
          return l != null ? l : ComparatorOfK().as(core.Comparable.compare);
        })();
        this[_validKey] = (() => {
          let l = isValidKey;
          return l != null ? l : dart.fn(v => K.is(v), dynamicTobool$());
        })();
        this[_root] = null;
        super.new();
      }
      static from(other, compare, isValidKey) {
        if (compare === void 0) compare = null;
        if (isValidKey === void 0) isValidKey = null;
        let result = new (SplayTreeMapOfK$V())(compare, isValidKey);
        other[dartx.forEach](dart.fn((k, v) => {
          result.set(K.as(k), V.as(v));
        }, dynamicAnddynamicTovoid()));
        return result;
      }
      static fromIterable(iterable, opts) {
        let key = opts && 'key' in opts ? opts.key : null;
        let value = opts && 'value' in opts ? opts.value : null;
        let compare = opts && 'compare' in opts ? opts.compare : null;
        let isValidKey = opts && 'isValidKey' in opts ? opts.isValidKey : null;
        let map = new (SplayTreeMapOfK$V())(compare, isValidKey);
        collection.Maps._fillMapWithMappedIterable(map, iterable, key, value);
        return map;
      }
      static fromIterables(keys, values, compare, isValidKey) {
        if (compare === void 0) compare = null;
        if (isValidKey === void 0) isValidKey = null;
        let map = new (SplayTreeMapOfK$V())(compare, isValidKey);
        collection.Maps._fillMapWithIterables(map, keys, values);
        return map;
      }
      [_compare](key1, key2) {
        K._check(key1);
        K._check(key2);
        return this[_comparator](key1, key2);
      }
      _internal() {
        this[_dummy] = new (_SplayTreeMapNodeOfK$V())(null, null);
        this[_root] = null;
        this[_comparator] = null;
        this[_validKey] = null;
        super.new();
      }
      get(key) {
        if (!dart.test(dart.dcall(this[_validKey], key))) return null;
        if (this[_root] != null) {
          let comp = this[_splay](K.as(key));
          if (comp == 0) {
            return this[_root].value;
          }
        }
        return null;
      }
      remove(key) {
        if (!dart.test(dart.dcall(this[_validKey], key))) return null;
        let mapRoot = this[_remove](K.as(key));
        if (mapRoot != null) return mapRoot.value;
        return null;
      }
      set(key, value) {
        (() => {
          K._check(key);
          V._check(value);
          if (key == null) dart.throw(new core.ArgumentError(key));
          let comp = this[_splay](key);
          if (comp == 0) {
            this[_root].value = value;
            return;
          }
          this[_addNewRoot](new (_SplayTreeMapNodeOfK$V())(key, value), comp);
        })();
        return value;
      }
      putIfAbsent(key, ifAbsent) {
        K._check(key);
        VoidToV()._check(ifAbsent);
        if (key == null) dart.throw(new core.ArgumentError(key));
        let comp = this[_splay](key);
        if (comp == 0) {
          return this[_root].value;
        }
        let modificationCount = this[_modificationCount];
        let splayCount = this[_splayCount];
        let value = ifAbsent();
        if (modificationCount != this[_modificationCount]) {
          dart.throw(new core.ConcurrentModificationError(this));
        }
        if (splayCount != this[_splayCount]) {
          comp = this[_splay](key);
          dart.assert(comp != 0);
        }
        this[_addNewRoot](new (_SplayTreeMapNodeOfK$V())(key, value), comp);
        return value;
      }
      addAll(other) {
        MapOfK$V()._check(other);
        other[dartx.forEach](dart.fn((key, value) => {
          this.set(key, value);
        }, KAndVTovoid()));
      }
      get isEmpty() {
        return this[_root] == null;
      }
      get isNotEmpty() {
        return !dart.test(this.isEmpty);
      }
      forEach(f) {
        let nodes = new (_SplayTreeNodeIteratorOfK())(this);
        while (dart.test(nodes.moveNext())) {
          let node = _SplayTreeMapNodeOfK$V()._check(nodes.current);
          f(node.key, node.value);
        }
      }
      get length() {
        return this[_count$];
      }
      clear() {
        this[_clear$]();
      }
      containsKey(key) {
        return dart.test(dart.dcall(this[_validKey], key)) && this[_splay](K.as(key)) == 0;
      }
      containsValue(value) {
        let found = false;
        let initialSplayCount = this[_splayCount];
        const visit = (function(node) {
          while (node != null) {
            if (dart.equals(node.value, value)) return true;
            if (initialSplayCount != this[_splayCount]) {
              dart.throw(new core.ConcurrentModificationError(this));
            }
            if (node.right != null && dart.test(visit(collection._SplayTreeMapNode._check(node.right)))) return true;
            node = collection._SplayTreeMapNode._check(node.left);
          }
          return false;
        }).bind(this);
        dart.fn(visit, _SplayTreeMapNodeTobool());
        return visit(this[_root]);
      }
      get keys() {
        return new (_SplayTreeKeyIterableOfK())(this);
      }
      get values() {
        return new (_SplayTreeValueIterableOfK$V())(this);
      }
      toString() {
        return collection.Maps.mapToString(this);
      }
      firstKey() {
        if (this[_root] == null) return null;
        return this[_first$].key;
      }
      lastKey() {
        if (this[_root] == null) return null;
        return this[_last$].key;
      }
      lastKeyBefore(key) {
        K._check(key);
        if (key == null) dart.throw(new core.ArgumentError(key));
        if (this[_root] == null) return null;
        let comp = this[_splay](key);
        if (dart.notNull(comp) < 0) return this[_root].key;
        let node = this[_root].left;
        if (node == null) return null;
        while (node.right != null) {
          node = node.right;
        }
        return node.key;
      }
      firstKeyAfter(key) {
        K._check(key);
        if (key == null) dart.throw(new core.ArgumentError(key));
        if (this[_root] == null) return null;
        let comp = this[_splay](key);
        if (dart.notNull(comp) > 0) return this[_root].key;
        let node = this[_root].right;
        if (node == null) return null;
        while (node.left != null) {
          node = node.left;
        }
        return node.key;
      }
    }
    dart.defineNamedConstructor(SplayTreeMap, '_internal');
    SplayTreeMap[dart.implements] = () => [MapOfK$V()];
    dart.setSignature(SplayTreeMap, {
      constructors: () => ({
        new: dart.definiteFunctionType(collection.SplayTreeMap$(K, V), [], [dart.functionType(core.int, [K, K]), dart.functionType(core.bool, [dart.dynamic])]),
        from: dart.definiteFunctionType(collection.SplayTreeMap$(K, V), [core.Map], [dart.functionType(core.int, [K, K]), dart.functionType(core.bool, [dart.dynamic])]),
        fromIterable: dart.definiteFunctionType(collection.SplayTreeMap$(K, V), [core.Iterable], {key: dynamicToK(), value: dynamicToV(), compare: ComparatorOfK(), isValidKey: dynamicTobool()}),
        fromIterables: dart.definiteFunctionType(collection.SplayTreeMap$(K, V), [core.Iterable$(K), core.Iterable$(V)], [dart.functionType(core.int, [K, K]), dart.functionType(core.bool, [dart.dynamic])]),
        _internal: dart.definiteFunctionType(collection.SplayTreeMap$(K, V), [])
      }),
      methods: () => ({
        [_compare]: dart.definiteFunctionType(core.int, [K, K]),
        get: dart.definiteFunctionType(V, [core.Object]),
        remove: dart.definiteFunctionType(V, [core.Object]),
        set: dart.definiteFunctionType(dart.void, [K, V]),
        putIfAbsent: dart.definiteFunctionType(V, [K, dart.functionType(V, [])]),
        addAll: dart.definiteFunctionType(dart.void, [core.Map$(K, V)]),
        forEach: dart.definiteFunctionType(dart.void, [dart.functionType(dart.void, [K, V])]),
        clear: dart.definiteFunctionType(dart.void, []),
        containsKey: dart.definiteFunctionType(core.bool, [core.Object]),
        containsValue: dart.definiteFunctionType(core.bool, [core.Object]),
        firstKey: dart.definiteFunctionType(K, []),
        lastKey: dart.definiteFunctionType(K, []),
        lastKeyBefore: dart.definiteFunctionType(K, [K]),
        firstKeyAfter: dart.definiteFunctionType(K, [K])
      })
    });
    dart.defineExtensionMembers(SplayTreeMap, [
      'get',
      'remove',
      'set',
      'putIfAbsent',
      'addAll',
      'forEach',
      'clear',
      'containsKey',
      'containsValue',
      'isEmpty',
      'isNotEmpty',
      'length',
      'keys',
      'values'
    ]);
    return SplayTreeMap;
  });
  collection.SplayTreeMap = SplayTreeMap();
  const _workList = Symbol('_workList');
  const _tree = Symbol('_tree');
  const _currentNode = Symbol('_currentNode');
  const _findLeftMostDescendent = Symbol('_findLeftMostDescendent');
  const _getValue = Symbol('_getValue');
  const _rebuildWorkList = Symbol('_rebuildWorkList');
  collection._SplayTreeIterator$ = dart.generic((K, T) => {
    let _SplayTreeNodeOfK = () => (_SplayTreeNodeOfK = dart.constFn(collection._SplayTreeNode$(K)))();
    let JSArrayOf_SplayTreeNodeOfK = () => (JSArrayOf_SplayTreeNodeOfK = dart.constFn(_interceptors.JSArray$(_SplayTreeNodeOfK())))();
    let IteratorOfT = () => (IteratorOfT = dart.constFn(core.Iterator$(T)))();
    class _SplayTreeIterator extends core.Object {
      new(tree) {
        this[_workList] = JSArrayOf_SplayTreeNodeOfK().of([]);
        this[_tree] = tree;
        this[_modificationCount] = tree[_modificationCount];
        this[_splayCount] = tree[_splayCount];
        this[_currentNode] = null;
        this[_findLeftMostDescendent](tree[_root]);
      }
      startAt(tree, startKey) {
        this[_workList] = JSArrayOf_SplayTreeNodeOfK().of([]);
        this[_tree] = tree;
        this[_modificationCount] = tree[_modificationCount];
        this[_splayCount] = null;
        this[_currentNode] = null;
        if (tree[_root] == null) return;
        let compare = tree[_splay](startKey);
        this[_splayCount] = tree[_splayCount];
        if (dart.notNull(compare) < 0) {
          this[_findLeftMostDescendent](tree[_root].right);
        } else {
          this[_workList][dartx.add](tree[_root]);
        }
      }
      get current() {
        if (this[_currentNode] == null) return null;
        return this[_getValue](this[_currentNode]);
      }
      [_findLeftMostDescendent](node) {
        _SplayTreeNodeOfK()._check(node);
        while (node != null) {
          this[_workList][dartx.add](node);
          node = node.left;
        }
      }
      [_rebuildWorkList](currentNode) {
        _SplayTreeNodeOfK()._check(currentNode);
        dart.assert(!dart.test(this[_workList][dartx.isEmpty]));
        this[_workList][dartx.clear]();
        if (currentNode == null) {
          this[_findLeftMostDescendent](this[_tree][_root]);
        } else {
          this[_tree][_splay](currentNode.key);
          this[_findLeftMostDescendent](this[_tree][_root].right);
          dart.assert(!dart.test(this[_workList][dartx.isEmpty]));
        }
      }
      moveNext() {
        if (this[_modificationCount] != this[_tree][_modificationCount]) {
          dart.throw(new core.ConcurrentModificationError(this[_tree]));
        }
        if (dart.test(this[_workList][dartx.isEmpty])) {
          this[_currentNode] = null;
          return false;
        }
        if (this[_tree][_splayCount] != this[_splayCount] && this[_currentNode] != null) {
          this[_rebuildWorkList](this[_currentNode]);
        }
        this[_currentNode] = this[_workList][dartx.removeLast]();
        this[_findLeftMostDescendent](this[_currentNode].right);
        return true;
      }
    }
    dart.addTypeTests(_SplayTreeIterator);
    dart.defineNamedConstructor(_SplayTreeIterator, 'startAt');
    _SplayTreeIterator[dart.implements] = () => [IteratorOfT()];
    dart.setSignature(_SplayTreeIterator, {
      constructors: () => ({
        new: dart.definiteFunctionType(collection._SplayTreeIterator$(K, T), [collection._SplayTree$(K, collection._SplayTreeNode$(K))]),
        startAt: dart.definiteFunctionType(collection._SplayTreeIterator$(K, T), [collection._SplayTree$(K, collection._SplayTreeNode$(K)), K])
      }),
      methods: () => ({
        [_findLeftMostDescendent]: dart.definiteFunctionType(dart.void, [collection._SplayTreeNode$(K)]),
        [_rebuildWorkList]: dart.definiteFunctionType(dart.void, [collection._SplayTreeNode$(K)]),
        moveNext: dart.definiteFunctionType(core.bool, [])
      })
    });
    return _SplayTreeIterator;
  });
  collection._SplayTreeIterator = _SplayTreeIterator();
  const _copyNode = Symbol('_copyNode');
  collection._SplayTreeKeyIterable$ = dart.generic(K => {
    let _SplayTreeKeyIteratorOfK = () => (_SplayTreeKeyIteratorOfK = dart.constFn(collection._SplayTreeKeyIterator$(K)))();
    let SplayTreeSetOfK = () => (SplayTreeSetOfK = dart.constFn(collection.SplayTreeSet$(K)))();
    class _SplayTreeKeyIterable extends core.Iterable$(K) {
      new(tree) {
        this[_tree] = tree;
        super.new();
      }
      get length() {
        return this[_tree][_count$];
      }
      get isEmpty() {
        return this[_tree][_count$] == 0;
      }
      get iterator() {
        return new (_SplayTreeKeyIteratorOfK())(this[_tree]);
      }
      toSet() {
        let set = new (SplayTreeSetOfK())(this[_tree][_comparator], this[_tree][_validKey]);
        set[_count$] = this[_tree][_count$];
        set[_root] = set[_copyNode](this[_tree][_root]);
        return set;
      }
    }
    _SplayTreeKeyIterable[dart.implements] = () => [_internal.EfficientLength];
    dart.setSignature(_SplayTreeKeyIterable, {
      constructors: () => ({new: dart.definiteFunctionType(collection._SplayTreeKeyIterable$(K), [collection._SplayTree$(K, collection._SplayTreeNode$(K))])}),
      methods: () => ({toSet: dart.definiteFunctionType(core.Set$(K), [])})
    });
    dart.defineExtensionMembers(_SplayTreeKeyIterable, ['toSet', 'length', 'isEmpty', 'iterator']);
    return _SplayTreeKeyIterable;
  });
  collection._SplayTreeKeyIterable = _SplayTreeKeyIterable();
  collection._SplayTreeValueIterable$ = dart.generic((K, V) => {
    let _SplayTreeValueIteratorOfK$V = () => (_SplayTreeValueIteratorOfK$V = dart.constFn(collection._SplayTreeValueIterator$(K, V)))();
    class _SplayTreeValueIterable extends core.Iterable$(V) {
      new(map) {
        this[_map$0] = map;
        super.new();
      }
      get length() {
        return this[_map$0][_count$];
      }
      get isEmpty() {
        return this[_map$0][_count$] == 0;
      }
      get iterator() {
        return new (_SplayTreeValueIteratorOfK$V())(this[_map$0]);
      }
    }
    _SplayTreeValueIterable[dart.implements] = () => [_internal.EfficientLength];
    dart.setSignature(_SplayTreeValueIterable, {
      constructors: () => ({new: dart.definiteFunctionType(collection._SplayTreeValueIterable$(K, V), [collection.SplayTreeMap$(K, V)])})
    });
    dart.defineExtensionMembers(_SplayTreeValueIterable, ['length', 'isEmpty', 'iterator']);
    return _SplayTreeValueIterable;
  });
  collection._SplayTreeValueIterable = _SplayTreeValueIterable();
  collection._SplayTreeKeyIterator$ = dart.generic(K => {
    let _SplayTreeNodeOfK = () => (_SplayTreeNodeOfK = dart.constFn(collection._SplayTreeNode$(K)))();
    class _SplayTreeKeyIterator extends collection._SplayTreeIterator$(K, K) {
      new(map) {
        super.new(map);
      }
      [_getValue](node) {
        _SplayTreeNodeOfK()._check(node);
        return node.key;
      }
    }
    dart.setSignature(_SplayTreeKeyIterator, {
      constructors: () => ({new: dart.definiteFunctionType(collection._SplayTreeKeyIterator$(K), [collection._SplayTree$(K, collection._SplayTreeNode$(K))])}),
      methods: () => ({[_getValue]: dart.definiteFunctionType(K, [collection._SplayTreeNode$(K)])})
    });
    return _SplayTreeKeyIterator;
  });
  collection._SplayTreeKeyIterator = _SplayTreeKeyIterator();
  collection._SplayTreeValueIterator$ = dart.generic((K, V) => {
    let _SplayTreeNodeOfK = () => (_SplayTreeNodeOfK = dart.constFn(collection._SplayTreeNode$(K)))();
    let _SplayTreeMapNodeOfK$V = () => (_SplayTreeMapNodeOfK$V = dart.constFn(collection._SplayTreeMapNode$(K, V)))();
    class _SplayTreeValueIterator extends collection._SplayTreeIterator$(K, V) {
      new(map) {
        super.new(map);
      }
      [_getValue](node) {
        _SplayTreeNodeOfK()._check(node);
        let mapNode = _SplayTreeMapNodeOfK$V().as(node);
        return mapNode.value;
      }
    }
    dart.setSignature(_SplayTreeValueIterator, {
      constructors: () => ({new: dart.definiteFunctionType(collection._SplayTreeValueIterator$(K, V), [collection.SplayTreeMap$(K, V)])}),
      methods: () => ({[_getValue]: dart.definiteFunctionType(V, [collection._SplayTreeNode$(K)])})
    });
    return _SplayTreeValueIterator;
  });
  collection._SplayTreeValueIterator = _SplayTreeValueIterator();
  collection._SplayTreeNodeIterator$ = dart.generic(K => {
    let _SplayTreeNodeOfK = () => (_SplayTreeNodeOfK = dart.constFn(collection._SplayTreeNode$(K)))();
    class _SplayTreeNodeIterator extends collection._SplayTreeIterator$(K, collection._SplayTreeNode$(K)) {
      new(tree) {
        super.new(tree);
      }
      startAt(tree, startKey) {
        super.startAt(tree, startKey);
      }
      [_getValue](node) {
        _SplayTreeNodeOfK()._check(node);
        return node;
      }
    }
    dart.defineNamedConstructor(_SplayTreeNodeIterator, 'startAt');
    dart.setSignature(_SplayTreeNodeIterator, {
      constructors: () => ({
        new: dart.definiteFunctionType(collection._SplayTreeNodeIterator$(K), [collection._SplayTree$(K, collection._SplayTreeNode$(K))]),
        startAt: dart.definiteFunctionType(collection._SplayTreeNodeIterator$(K), [collection._SplayTree$(K, collection._SplayTreeNode$(K)), K])
      }),
      methods: () => ({[_getValue]: dart.definiteFunctionType(collection._SplayTreeNode$(K), [collection._SplayTreeNode$(K)])})
    });
    return _SplayTreeNodeIterator;
  });
  collection._SplayTreeNodeIterator = _SplayTreeNodeIterator();
  const _clone = Symbol('_clone');
  collection.SplayTreeSet$ = dart.generic(E => {
    let _SplayTreeNodeOfE = () => (_SplayTreeNodeOfE = dart.constFn(collection._SplayTreeNode$(E)))();
    let ComparatorOfE = () => (ComparatorOfE = dart.constFn(core.Comparator$(E)))();
    let SplayTreeSetOfE = () => (SplayTreeSetOfE = dart.constFn(collection.SplayTreeSet$(E)))();
    let _SplayTreeKeyIteratorOfE = () => (_SplayTreeKeyIteratorOfE = dart.constFn(collection._SplayTreeKeyIterator$(E)))();
    let IterableOfE = () => (IterableOfE = dart.constFn(core.Iterable$(E)))();
    let SetOfE = () => (SetOfE = dart.constFn(core.Set$(E)))();
    class SplayTreeSet extends dart.mixin(collection._SplayTree$(E, collection._SplayTreeNode$(E)), collection.IterableMixin$(E), collection.SetMixin$(E)) {
      new(compare, isValidKey) {
        if (compare === void 0) compare = null;
        if (isValidKey === void 0) isValidKey = null;
        this[_dummy] = new (_SplayTreeNodeOfE())(null);
        this[_comparator] = (() => {
          let l = compare;
          return l != null ? l : ComparatorOfE().as(core.Comparable.compare);
        })();
        this[_validKey] = (() => {
          let l = isValidKey;
          return l != null ? l : dart.fn(v => E.is(v), dynamicTobool$());
        })();
        this[_root] = null;
        super.new();
      }
      static from(elements, compare, isValidKey) {
        if (compare === void 0) compare = null;
        if (isValidKey === void 0) isValidKey = null;
        let result = new (SplayTreeSetOfE())(compare, isValidKey);
        for (let element of elements) {
          let e = E.as(element);
          result.add(e);
        }
        return result;
      }
      [_compare](e1, e2) {
        E._check(e1);
        E._check(e2);
        return this[_comparator](e1, e2);
      }
      get iterator() {
        return new (_SplayTreeKeyIteratorOfE())(this);
      }
      get length() {
        return this[_count$];
      }
      get isEmpty() {
        return this[_root] == null;
      }
      get isNotEmpty() {
        return this[_root] != null;
      }
      get first() {
        if (this[_count$] == 0) dart.throw(_internal.IterableElementError.noElement());
        return this[_first$].key;
      }
      get last() {
        if (this[_count$] == 0) dart.throw(_internal.IterableElementError.noElement());
        return this[_last$].key;
      }
      get single() {
        if (this[_count$] == 0) dart.throw(_internal.IterableElementError.noElement());
        if (dart.notNull(this[_count$]) > 1) dart.throw(_internal.IterableElementError.tooMany());
        return this[_root].key;
      }
      contains(object) {
        return dart.test(dart.dcall(this[_validKey], object)) && this[_splay](E.as(object)) == 0;
      }
      add(element) {
        E._check(element);
        let compare = this[_splay](element);
        if (compare == 0) return false;
        this[_addNewRoot](new (_SplayTreeNodeOfE())(element), compare);
        return true;
      }
      remove(object) {
        if (!dart.test(dart.dcall(this[_validKey], object))) return false;
        return this[_remove](E.as(object)) != null;
      }
      addAll(elements) {
        IterableOfE()._check(elements);
        for (let element of elements) {
          let compare = this[_splay](element);
          if (compare != 0) {
            this[_addNewRoot](new (_SplayTreeNodeOfE())(element), compare);
          }
        }
      }
      removeAll(elements) {
        for (let element of elements) {
          if (dart.test(dart.dcall(this[_validKey], element))) this[_remove](E.as(element));
        }
      }
      retainAll(elements) {
        let retainSet = new (SplayTreeSetOfE())(this[_comparator], this[_validKey]);
        let modificationCount = this[_modificationCount];
        for (let object of elements) {
          if (modificationCount != this[_modificationCount]) {
            dart.throw(new core.ConcurrentModificationError(this));
          }
          if (dart.test(dart.dcall(this[_validKey], object)) && this[_splay](E.as(object)) == 0) {
            retainSet.add(this[_root].key);
          }
        }
        if (retainSet[_count$] != this[_count$]) {
          this[_root] = retainSet[_root];
          this[_count$] = retainSet[_count$];
          this[_modificationCount] = dart.notNull(this[_modificationCount]) + 1;
        }
      }
      lookup(object) {
        if (!dart.test(dart.dcall(this[_validKey], object))) return null;
        let comp = this[_splay](E.as(object));
        if (comp != 0) return null;
        return this[_root].key;
      }
      intersection(other) {
        let result = new (SplayTreeSetOfE())(this[_comparator], this[_validKey]);
        for (let element of this) {
          if (dart.test(other.contains(element))) result.add(element);
        }
        return result;
      }
      difference(other) {
        let result = new (SplayTreeSetOfE())(this[_comparator], this[_validKey]);
        for (let element of this) {
          if (!dart.test(other.contains(element))) result.add(element);
        }
        return result;
      }
      union(other) {
        SetOfE()._check(other);
        let _ = this[_clone]();
        _.addAll(other);
        return _;
      }
      [_clone]() {
        let set = new (SplayTreeSetOfE())(this[_comparator], this[_validKey]);
        set[_count$] = this[_count$];
        set[_root] = this[_copyNode](this[_root]);
        return set;
      }
      [_copyNode](node) {
        _SplayTreeNodeOfE()._check(node);
        if (node == null) return null;
        let _ = new (_SplayTreeNodeOfE())(node.key);
        _.left = this[_copyNode](node.left);
        _.right = this[_copyNode](node.right);
        return _;
      }
      clear() {
        this[_clear$]();
      }
      toSet() {
        return this[_clone]();
      }
      toString() {
        return collection.IterableBase.iterableToFullString(this, '{', '}');
      }
    }
    dart.setSignature(SplayTreeSet, {
      constructors: () => ({
        new: dart.definiteFunctionType(collection.SplayTreeSet$(E), [], [dart.functionType(core.int, [E, E]), dart.functionType(core.bool, [dart.dynamic])]),
        from: dart.definiteFunctionType(collection.SplayTreeSet$(E), [core.Iterable], [dart.functionType(core.int, [E, E]), dart.functionType(core.bool, [dart.dynamic])])
      }),
      methods: () => ({
        [_compare]: dart.definiteFunctionType(core.int, [E, E]),
        contains: dart.definiteFunctionType(core.bool, [core.Object]),
        add: dart.definiteFunctionType(core.bool, [E]),
        remove: dart.definiteFunctionType(core.bool, [core.Object]),
        addAll: dart.definiteFunctionType(dart.void, [core.Iterable$(E)]),
        lookup: dart.definiteFunctionType(E, [core.Object]),
        intersection: dart.definiteFunctionType(core.Set$(E), [core.Set$(core.Object)]),
        difference: dart.definiteFunctionType(core.Set$(E), [core.Set$(core.Object)]),
        union: dart.definiteFunctionType(core.Set$(E), [core.Set$(E)]),
        [_clone]: dart.definiteFunctionType(collection.SplayTreeSet$(E), []),
        [_copyNode]: dart.definiteFunctionType(collection._SplayTreeNode$(E), [collection._SplayTreeNode$(E)]),
        toSet: dart.definiteFunctionType(core.Set$(E), [])
      })
    });
    dart.defineExtensionMembers(SplayTreeSet, [
      'contains',
      'toSet',
      'toString',
      'iterator',
      'length',
      'isEmpty',
      'isNotEmpty',
      'first',
      'last',
      'single'
    ]);
    return SplayTreeSet;
  });
  collection.SplayTreeSet = SplayTreeSet();
  const _processed = Symbol('_processed');
  const _computeKeys$ = Symbol('_computeKeys');
  const _original = Symbol('_original');
  convert._convertJsonToDart = function(json, reviver) {
    dart.assert(reviver != null);
    function walk(e) {
      if (e == null || typeof e != "object") {
        return e;
      }
      if (Object.getPrototypeOf(e) === Array.prototype) {
        for (let i = 0; i < e.length; i++) {
          let item = e[i];
          e[i] = dart.dcall(reviver, i, walk(item));
        }
        return e;
      }
      let map = new convert._JsonMap(e);
      let processed = map[_processed];
      let keys = map[_computeKeys$]();
      for (let i = 0; i < dart.notNull(keys[dartx.length]); i++) {
        let key = keys[dartx.get](i);
        let revived = dart.dcall(reviver, key, walk(e[key]));
        processed[key] = revived;
      }
      map[_original] = processed;
      return map;
    }
    dart.fn(walk, dynamicTodynamic$());
    return dart.dcall(reviver, null, walk(json));
  };
  dart.fn(convert._convertJsonToDart, dynamicAndFnTodynamic());
  convert._convertJsonToDartLazy = function(object) {
    if (object == null) return null;
    if (typeof object != "object") {
      return object;
    }
    if (Object.getPrototypeOf(object) !== Array.prototype) {
      return new convert._JsonMap(object);
    }
    for (let i = 0; i < object.length; i++) {
      let item = object[i];
      object[i] = convert._convertJsonToDartLazy(item);
    }
    return object;
  };
  dart.fn(convert._convertJsonToDartLazy, dynamicTodynamic$());
  const _data = Symbol('_data');
  const _isUpgraded = Symbol('_isUpgraded');
  const _upgradedMap = Symbol('_upgradedMap');
  const _process = Symbol('_process');
  const _upgrade = Symbol('_upgrade');
  convert._JsonMap = class _JsonMap extends core.Object {
    new(original) {
      this[_processed] = convert._JsonMap._newJavaScriptObject();
      this[_original] = original;
      this[_data] = null;
    }
    get(key) {
      if (dart.test(this[_isUpgraded])) {
        return this[_upgradedMap][dartx.get](key);
      } else if (!(typeof key == 'string')) {
        return null;
      } else {
        let result = convert._JsonMap._getProperty(this[_processed], core.String._check(key));
        if (dart.test(convert._JsonMap._isUnprocessed(result))) result = this[_process](core.String._check(key));
        return result;
      }
    }
    get length() {
      return dart.test(this[_isUpgraded]) ? this[_upgradedMap][dartx.length] : this[_computeKeys$]()[dartx.length];
    }
    get isEmpty() {
      return this.length == 0;
    }
    get isNotEmpty() {
      return dart.notNull(this.length) > 0;
    }
    get keys() {
      if (dart.test(this[_isUpgraded])) return this[_upgradedMap][dartx.keys];
      return new convert._JsonMapKeyIterable(this);
    }
    get values() {
      if (dart.test(this[_isUpgraded])) return this[_upgradedMap][dartx.values];
      return _internal.MappedIterable.new(this[_computeKeys$](), dart.fn(each => this.get(each), dynamicTodynamic$()));
    }
    set(key, value) {
      if (dart.test(this[_isUpgraded])) {
        this[_upgradedMap][dartx.set](key, value);
      } else if (dart.test(this.containsKey(key))) {
        let processed = this[_processed];
        convert._JsonMap._setProperty(processed, core.String._check(key), value);
        let original = this[_original];
        if (!core.identical(original, processed)) {
          convert._JsonMap._setProperty(original, core.String._check(key), null);
        }
      } else {
        this[_upgrade]()[dartx.set](key, value);
      }
      return value;
    }
    addAll(other) {
      other[dartx.forEach](dart.fn((key, value) => {
        this.set(key, value);
      }, dynamicAnddynamicTovoid()));
    }
    containsValue(value) {
      if (dart.test(this[_isUpgraded])) return this[_upgradedMap][dartx.containsValue](value);
      let keys = this[_computeKeys$]();
      for (let i = 0; i < dart.notNull(keys[dartx.length]); i++) {
        let key = keys[dartx.get](i);
        if (dart.equals(this.get(key), value)) return true;
      }
      return false;
    }
    containsKey(key) {
      if (dart.test(this[_isUpgraded])) return this[_upgradedMap][dartx.containsKey](key);
      if (!(typeof key == 'string')) return false;
      return convert._JsonMap._hasProperty(this[_original], core.String._check(key));
    }
    putIfAbsent(key, ifAbsent) {
      if (dart.test(this.containsKey(key))) return this.get(key);
      let value = ifAbsent();
      this.set(key, value);
      return value;
    }
    remove(key) {
      if (!dart.test(this[_isUpgraded]) && !dart.test(this.containsKey(key))) return null;
      return this[_upgrade]()[dartx.remove](key);
    }
    clear() {
      if (dart.test(this[_isUpgraded])) {
        this[_upgradedMap][dartx.clear]();
      } else {
        if (this[_data] != null) {
          dart.dsend(this[_data], 'clear');
        }
        this[_original] = this[_processed] = null;
        this[_data] = dart.map();
      }
    }
    forEach(f) {
      if (dart.test(this[_isUpgraded])) return this[_upgradedMap][dartx.forEach](f);
      let keys = this[_computeKeys$]();
      for (let i = 0; i < dart.notNull(keys[dartx.length]); i++) {
        let key = keys[dartx.get](i);
        let value = convert._JsonMap._getProperty(this[_processed], key);
        if (dart.test(convert._JsonMap._isUnprocessed(value))) {
          value = convert._convertJsonToDartLazy(convert._JsonMap._getProperty(this[_original], key));
          convert._JsonMap._setProperty(this[_processed], key, value);
        }
        dart.dcall(f, key, value);
        if (!core.identical(keys, this[_data])) {
          dart.throw(new core.ConcurrentModificationError(this));
        }
      }
    }
    toString() {
      return collection.Maps.mapToString(this);
    }
    get [_isUpgraded]() {
      return this[_processed] == null;
    }
    get [_upgradedMap]() {
      dart.assert(this[_isUpgraded]);
      return this[_data];
    }
    [_computeKeys$]() {
      dart.assert(!dart.test(this[_isUpgraded]));
      let keys = core.List._check(this[_data]);
      if (keys == null) {
        keys = this[_data] = convert._JsonMap._getPropertyNames(this[_original]);
      }
      return keys;
    }
    [_upgrade]() {
      if (dart.test(this[_isUpgraded])) return this[_upgradedMap];
      let result = dart.map();
      let keys = this[_computeKeys$]();
      for (let i = 0; i < dart.notNull(keys[dartx.length]); i++) {
        let key = keys[dartx.get](i);
        result[dartx.set](key, this.get(key));
      }
      if (dart.test(keys[dartx.isEmpty])) {
        keys[dartx.add](null);
      } else {
        keys[dartx.clear]();
      }
      this[_original] = this[_processed] = null;
      this[_data] = result;
      dart.assert(this[_isUpgraded]);
      return result;
    }
    [_process](key) {
      if (!dart.test(convert._JsonMap._hasProperty(this[_original], key))) return null;
      let result = convert._convertJsonToDartLazy(convert._JsonMap._getProperty(this[_original], key));
      return convert._JsonMap._setProperty(this[_processed], key, result);
    }
    static _hasProperty(object, key) {
      return Object.prototype.hasOwnProperty.call(object, key);
    }
    static _getProperty(object, key) {
      return object[key];
    }
    static _setProperty(object, key, value) {
      return object[key] = value;
    }
    static _getPropertyNames(object) {
      return Object.keys(object);
    }
    static _isUnprocessed(object) {
      return typeof object == "undefined";
    }
    static _newJavaScriptObject() {
      return Object.create(null);
    }
  };
  convert._JsonMap[dart.implements] = () => [collection.LinkedHashMap];
  dart.setSignature(convert._JsonMap, {
    constructors: () => ({new: dart.definiteFunctionType(convert._JsonMap, [dart.dynamic])}),
    methods: () => ({
      get: dart.definiteFunctionType(dart.dynamic, [core.Object]),
      set: dart.definiteFunctionType(dart.void, [dart.dynamic, dart.dynamic]),
      addAll: dart.definiteFunctionType(dart.void, [core.Map]),
      containsValue: dart.definiteFunctionType(core.bool, [core.Object]),
      containsKey: dart.definiteFunctionType(core.bool, [core.Object]),
      putIfAbsent: dart.definiteFunctionType(dart.dynamic, [dart.dynamic, dart.functionType(dart.dynamic, [])]),
      remove: dart.definiteFunctionType(dart.dynamic, [core.Object]),
      clear: dart.definiteFunctionType(dart.void, []),
      forEach: dart.definiteFunctionType(dart.void, [dart.functionType(dart.void, [dart.dynamic, dart.dynamic])]),
      [_computeKeys$]: dart.definiteFunctionType(core.List$(core.String), []),
      [_upgrade]: dart.definiteFunctionType(core.Map, []),
      [_process]: dart.definiteFunctionType(dart.dynamic, [core.String])
    }),
    statics: () => ({
      _hasProperty: dart.definiteFunctionType(core.bool, [dart.dynamic, core.String]),
      _getProperty: dart.definiteFunctionType(dart.dynamic, [dart.dynamic, core.String]),
      _setProperty: dart.definiteFunctionType(dart.dynamic, [dart.dynamic, core.String, dart.dynamic]),
      _getPropertyNames: dart.definiteFunctionType(core.List, [dart.dynamic]),
      _isUnprocessed: dart.definiteFunctionType(core.bool, [dart.dynamic]),
      _newJavaScriptObject: dart.definiteFunctionType(dart.dynamic, [])
    }),
    names: ['_hasProperty', '_getProperty', '_setProperty', '_getPropertyNames', '_isUnprocessed', '_newJavaScriptObject']
  });
  dart.defineExtensionMembers(convert._JsonMap, [
    'get',
    'set',
    'addAll',
    'containsValue',
    'containsKey',
    'putIfAbsent',
    'remove',
    'clear',
    'forEach',
    'length',
    'isEmpty',
    'isNotEmpty',
    'keys',
    'values'
  ]);
  const _parent = Symbol('_parent');
  convert._JsonMapKeyIterable = class _JsonMapKeyIterable extends _internal.ListIterable {
    new(parent) {
      this[_parent] = parent;
      super.new();
    }
    get length() {
      return this[_parent].length;
    }
    elementAt(index) {
      return core.String._check(dart.test(this[_parent][_isUpgraded]) ? this[_parent].keys[dartx.elementAt](index) : this[_parent][_computeKeys$]()[dartx.get](index));
    }
    get iterator() {
      return dart.test(this[_parent][_isUpgraded]) ? this[_parent].keys[dartx.iterator] : this[_parent][_computeKeys$]()[dartx.iterator];
    }
    contains(key) {
      return this[_parent].containsKey(key);
    }
  };
  dart.addSimpleTypeTests(convert._JsonMapKeyIterable);
  dart.setSignature(convert._JsonMapKeyIterable, {
    constructors: () => ({new: dart.definiteFunctionType(convert._JsonMapKeyIterable, [convert._JsonMap])}),
    methods: () => ({elementAt: dart.definiteFunctionType(core.String, [core.int])})
  });
  dart.defineExtensionMembers(convert._JsonMapKeyIterable, ['elementAt', 'contains', 'length', 'iterator']);
  const _reviver = Symbol('_reviver');
  const _sink$ = Symbol('_sink');
  const _stringSink = Symbol('_stringSink');
  convert.StringConversionSinkMixin = class StringConversionSinkMixin extends core.Object {
    add(str) {
      this.addSlice(str, 0, str[dartx.length], false);
    }
    asUtf8Sink(allowMalformed) {
      return new convert._Utf8ConversionSink(this, allowMalformed);
    }
    asStringSink() {
      return new convert._StringConversionSinkAsStringSinkAdapter(this);
    }
  };
  convert.StringConversionSinkMixin[dart.implements] = () => [convert.StringConversionSink];
  dart.setSignature(convert.StringConversionSinkMixin, {
    methods: () => ({
      add: dart.definiteFunctionType(dart.void, [core.String]),
      asUtf8Sink: dart.definiteFunctionType(convert.ByteConversionSink, [core.bool]),
      asStringSink: dart.definiteFunctionType(convert.ClosableStringSink, [])
    })
  });
  convert.StringConversionSinkBase = class StringConversionSinkBase extends convert.StringConversionSinkMixin {};
  convert._StringSinkConversionSink = class _StringSinkConversionSink extends convert.StringConversionSinkBase {
    new(stringSink) {
      this[_stringSink] = stringSink;
    }
    close() {}
    addSlice(str, start, end, isLast) {
      if (start != 0 || end != str[dartx.length]) {
        for (let i = start; dart.notNull(i) < dart.notNull(end); i = dart.notNull(i) + 1) {
          this[_stringSink].writeCharCode(str[dartx.codeUnitAt](i));
        }
      } else {
        this[_stringSink].write(str);
      }
      if (dart.test(isLast)) this.close();
    }
    add(str) {
      this[_stringSink].write(str);
    }
    asUtf8Sink(allowMalformed) {
      return new convert._Utf8StringSinkAdapter(this, this[_stringSink], allowMalformed);
    }
    asStringSink() {
      return convert.ClosableStringSink.fromStringSink(this[_stringSink], dart.bind(this, 'close'));
    }
  };
  dart.setSignature(convert._StringSinkConversionSink, {
    constructors: () => ({new: dart.definiteFunctionType(convert._StringSinkConversionSink, [core.StringSink])}),
    methods: () => ({
      close: dart.definiteFunctionType(dart.void, []),
      addSlice: dart.definiteFunctionType(dart.void, [core.String, core.int, core.int, core.bool])
    })
  });
  convert._JsonDecoderSink = class _JsonDecoderSink extends convert._StringSinkConversionSink {
    new(reviver, sink) {
      this[_reviver] = reviver;
      this[_sink$] = sink;
      super.new(new core.StringBuffer());
    }
    close() {
      super.close();
      let buffer = core.StringBuffer._check(this[_stringSink]);
      let accumulated = dart.toString(buffer);
      buffer.clear();
      let decoded = convert._parseJson(accumulated, this[_reviver]);
      this[_sink$].add(decoded);
      this[_sink$].close();
    }
  };
  dart.setSignature(convert._JsonDecoderSink, {
    constructors: () => ({new: dart.definiteFunctionType(convert._JsonDecoderSink, [convert._Reviver, core.Sink$(core.Object)])})
  });
  const _allowInvalid = Symbol('_allowInvalid');
  let const$20;
  let const$21;
  let const$22;
  let const$23;
  let const$24;
  convert.Codec$ = dart.generic((S, T) => {
    let _FusedCodecOfS$T$dynamic = () => (_FusedCodecOfS$T$dynamic = dart.constFn(convert._FusedCodec$(S, T, dart.dynamic)))();
    let _InvertedCodecOfT$S = () => (_InvertedCodecOfT$S = dart.constFn(convert._InvertedCodec$(T, S)))();
    let CodecOfT$dynamic = () => (CodecOfT$dynamic = dart.constFn(convert.Codec$(T, dart.dynamic)))();
    class Codec extends core.Object {
      new() {
      }
      encode(input) {
        S._check(input);
        return this.encoder.convert(input);
      }
      decode(encoded) {
        T._check(encoded);
        return this.decoder.convert(encoded);
      }
      fuse(other) {
        CodecOfT$dynamic()._check(other);
        return new (_FusedCodecOfS$T$dynamic())(this, other);
      }
      get inverted() {
        return new (_InvertedCodecOfT$S())(this);
      }
    }
    dart.addTypeTests(Codec);
    dart.setSignature(Codec, {
      constructors: () => ({new: dart.definiteFunctionType(convert.Codec$(S, T), [])}),
      methods: () => ({
        encode: dart.definiteFunctionType(T, [S]),
        decode: dart.definiteFunctionType(S, [T]),
        fuse: dart.definiteFunctionType(convert.Codec$(S, dart.dynamic), [convert.Codec$(T, dart.dynamic)])
      })
    });
    return Codec;
  });
  convert.Codec = Codec();
  core.String = class String extends core.Object {
    static fromCharCodes(charCodes, start, end) {
      if (start === void 0) start = 0;
      if (end === void 0) end = null;
      if (_interceptors.JSArray.is(charCodes)) {
        return core.String._stringFromJSArray(JSArrayOfint()._check(charCodes), start, end);
      }
      if (_native_typed_data.NativeUint8List.is(charCodes)) {
        return core.String._stringFromUint8List(charCodes, start, end);
      }
      return core.String._stringFromIterable(charCodes, start, end);
    }
    static fromCharCode(charCode) {
      return _js_helper.Primitives.stringFromCharCode(charCode);
    }
    static fromEnvironment(name, opts) {
      let defaultValue = opts && 'defaultValue' in opts ? opts.defaultValue : null;
      dart.throw(new core.UnsupportedError('String.fromEnvironment can only be used as a const constructor'));
    }
    static _stringFromJSArray(list, start, endOrNull) {
      let len = list[dartx.length];
      let end = core.RangeError.checkValidRange(start, endOrNull, len);
      if (dart.notNull(start) > 0 || dart.notNull(end) < dart.notNull(len)) {
        list = JSArrayOfint()._check(list[dartx.sublist](start, end));
      }
      return _js_helper.Primitives.stringFromCharCodes(list);
    }
    static _stringFromUint8List(charCodes, start, endOrNull) {
      let len = charCodes[dartx.length];
      let end = core.RangeError.checkValidRange(start, endOrNull, len);
      return _js_helper.Primitives.stringFromNativeUint8List(charCodes, start, end);
    }
    static _stringFromIterable(charCodes, start, end) {
      if (dart.notNull(start) < 0) dart.throw(new core.RangeError.range(start, 0, charCodes[dartx.length]));
      if (end != null && dart.notNull(end) < dart.notNull(start)) {
        dart.throw(new core.RangeError.range(end, start, charCodes[dartx.length]));
      }
      let it = charCodes[dartx.iterator];
      for (let i = 0; i < dart.notNull(start); i++) {
        if (!dart.test(it.moveNext())) {
          dart.throw(new core.RangeError.range(start, 0, i));
        }
      }
      let list = JSArrayOfint().of([]);
      if (end == null) {
        while (dart.test(it.moveNext()))
          list[dartx.add](it.current);
      } else {
        for (let i = start; dart.notNull(i) < dart.notNull(end); i = dart.notNull(i) + 1) {
          if (!dart.test(it.moveNext())) {
            dart.throw(new core.RangeError.range(end, start, i));
          }
          list[dartx.add](it.current);
        }
      }
      return _js_helper.Primitives.stringFromCharCodes(JSArrayOfint()._check(list));
    }
  };
  core.String.is = function is_String(o) {
    return typeof o == "string";
  };
  core.String.as = function as_String(o) {
    if (typeof o == "string" || o == null) return o;
    return dart.as(o, core.String);
  };
  core.String._check = function check_String(o) {
    if (typeof o == "string" || o == null) return o;
    return dart.check(o, core.String);
  };
  core.String[dart.implements] = () => [ComparableOfString(), core.Pattern];
  dart.setSignature(core.String, {
    constructors: () => ({
      fromCharCodes: dart.definiteFunctionType(core.String, [core.Iterable$(core.int)], [core.int, core.int]),
      fromCharCode: dart.definiteFunctionType(core.String, [core.int]),
      fromEnvironment: dart.definiteFunctionType(core.String, [core.String], {defaultValue: core.String})
    }),
    statics: () => ({
      _stringFromJSArray: dart.definiteFunctionType(core.String, [_interceptors.JSArray$(core.int), core.int, core.int]),
      _stringFromUint8List: dart.definiteFunctionType(core.String, [_native_typed_data.NativeUint8List, core.int, core.int]),
      _stringFromIterable: dart.definiteFunctionType(core.String, [core.Iterable$(core.int), core.int, core.int])
    }),
    names: ['_stringFromJSArray', '_stringFromUint8List', '_stringFromIterable']
  });
  core.List$ = dart.generic(E => {
    let JSArrayOfE = () => (JSArrayOfE = dart.constFn(_interceptors.JSArray$(E)))();
    let ListOfE = () => (ListOfE = dart.constFn(core.List$(E)))();
    let IterableOfE = () => (IterableOfE = dart.constFn(core.Iterable$(E)))();
    class List extends core.Object {
      static new(length) {
        if (length === void 0) length = null;
        let list = null;
        if (length == null) {
          list = [];
        } else {
          if (!(typeof length == 'number') || dart.notNull(length) < 0) {
            dart.throw(new core.ArgumentError(dart.str`Length must be a non-negative integer: ${length}`));
          }
          list = _interceptors.JSArray.markFixedList(new Array(length));
        }
        return JSArrayOfE().typed(list);
      }
      static filled(length, fill) {
        let result = ListOfE().new(length);
        if (length != 0 && fill != null) {
          for (let i = 0; i < dart.notNull(result[dartx.length]); i++) {
            result[dartx.set](i, fill);
          }
        }
        return result;
      }
      static from(elements, opts) {
        let growable = opts && 'growable' in opts ? opts.growable : true;
        let list = ListOfE().new();
        for (let e of elements) {
          list[dartx.add](E._check(e));
        }
        if (dart.test(growable)) return list;
        return _internal.makeListFixedLength(E)(list);
      }
      static generate(length, generator, opts) {
        let growable = opts && 'growable' in opts ? opts.growable : true;
        let result = null;
        if (dart.test(growable)) {
          result = JSArrayOfE().of([]);
          result[dartx.length] = length;
        } else {
          result = ListOfE().new(length);
        }
        for (let i = 0; i < dart.notNull(length); i++) {
          result[dartx.set](i, generator(i));
        }
        return result;
      }
      static unmodifiable(elements) {
        let result = ListOfE().from(elements, {growable: false});
        return _internal.makeFixedListUnmodifiable(E)(result);
      }
      [Symbol.iterator]() {
        return new dart.JsIterator(this[dartx.iterator]);
      }
    }
    dart.addTypeTests(List);
    List[dart.implements] = () => [IterableOfE(), _internal.EfficientLength];
    dart.setSignature(List, {
      constructors: () => ({
        new: dart.definiteFunctionType(core.List$(E), [], [core.int]),
        filled: dart.definiteFunctionType(core.List$(E), [core.int, E]),
        from: dart.definiteFunctionType(core.List$(E), [core.Iterable], {growable: core.bool}),
        generate: dart.definiteFunctionType(core.List$(E), [core.int, dart.functionType(E, [core.int])], {growable: core.bool}),
        unmodifiable: dart.definiteFunctionType(core.List$(E), [core.Iterable])
      })
    });
    return List;
  });
  core.List = List();
  convert.Encoding = class Encoding extends convert.Codec$(core.String, core.List$(core.int)) {
    new() {
      super.new();
    }
    decodeStream(byteStream) {
      return byteStream.transform(core.String)(this.decoder).fold(dart.dynamic)(new core.StringBuffer(), dart.fn((buffer, string) => ((() => {
        dart.dsend(buffer, 'write', string);
        return buffer;
      })()), dynamicAndStringTodynamic())).then(core.String)(dart.fn(buffer => dart.toString(buffer), dynamicToString()));
    }
    static getByName(name) {
      if (name == null) return null;
      name = name[dartx.toLowerCase]();
      return convert.Encoding._nameToEncoding[dartx.get](name);
    }
  };
  dart.addSimpleTypeTests(convert.Encoding);
  dart.setSignature(convert.Encoding, {
    constructors: () => ({new: dart.definiteFunctionType(convert.Encoding, [])}),
    methods: () => ({decodeStream: dart.definiteFunctionType(async.Future$(core.String), [async.Stream$(core.List$(core.int))])}),
    statics: () => ({getByName: dart.definiteFunctionType(convert.Encoding, [core.String])}),
    names: ['getByName']
  });
  dart.defineLazy(convert.Encoding, {
    get _nameToEncoding() {
      return dart.map({"iso_8859-1:1987": convert.LATIN1, "iso-ir-100": convert.LATIN1, "iso_8859-1": convert.LATIN1, "iso-8859-1": convert.LATIN1, latin1: convert.LATIN1, l1: convert.LATIN1, ibm819: convert.LATIN1, cp819: convert.LATIN1, csisolatin1: convert.LATIN1, "iso-ir-6": convert.ASCII, "ansi_x3.4-1968": convert.ASCII, "ansi_x3.4-1986": convert.ASCII, "iso_646.irv:1991": convert.ASCII, "iso646-us": convert.ASCII, "us-ascii": convert.ASCII, us: convert.ASCII, ibm367: convert.ASCII, cp367: convert.ASCII, csascii: convert.ASCII, ascii: convert.ASCII, csutf8: convert.UTF8, "utf-8": convert.UTF8}, core.String, convert.Encoding);
    },
    set _nameToEncoding(_) {}
  });
  convert.AsciiCodec = class AsciiCodec extends convert.Encoding {
    new(opts) {
      let allowInvalid = opts && 'allowInvalid' in opts ? opts.allowInvalid : false;
      this[_allowInvalid] = allowInvalid;
      super.new();
    }
    get name() {
      return "us-ascii";
    }
    decode(bytes, opts) {
      let allowInvalid = opts && 'allowInvalid' in opts ? opts.allowInvalid : null;
      if (allowInvalid == null) allowInvalid = this[_allowInvalid];
      if (dart.test(allowInvalid)) {
        return (const$20 || (const$20 = dart.const(new convert.AsciiDecoder({allowInvalid: true})))).convert(bytes);
      } else {
        return (const$21 || (const$21 = dart.const(new convert.AsciiDecoder({allowInvalid: false})))).convert(bytes);
      }
    }
    get encoder() {
      return const$22 || (const$22 = dart.const(new convert.AsciiEncoder()));
    }
    get decoder() {
      return dart.test(this[_allowInvalid]) ? const$23 || (const$23 = dart.const(new convert.AsciiDecoder({allowInvalid: true}))) : const$24 || (const$24 = dart.const(new convert.AsciiDecoder({allowInvalid: false})));
    }
  };
  dart.setSignature(convert.AsciiCodec, {
    constructors: () => ({new: dart.definiteFunctionType(convert.AsciiCodec, [], {allowInvalid: core.bool})}),
    methods: () => ({decode: dart.definiteFunctionType(core.String, [core.List$(core.int)], {allowInvalid: core.bool})})
  });
  convert.ASCII = dart.const(new convert.AsciiCodec());
  convert._ASCII_MASK = 127;
  const _subsetMask = Symbol('_subsetMask');
  convert.Converter$ = dart.generic((S, T) => {
    let StreamOfS = () => (StreamOfS = dart.constFn(async.Stream$(S)))();
    let StreamTransformerOfS$T = () => (StreamTransformerOfS$T = dart.constFn(async.StreamTransformer$(S, T)))();
    let SinkOfT = () => (SinkOfT = dart.constFn(core.Sink$(T)))();
    let StreamOfT = () => (StreamOfT = dart.constFn(async.Stream$(T)))();
    class Converter extends core.Object {
      new() {
      }
      fuse(TT) {
        return other => {
          convert.Converter$(T, TT)._check(other);
          return new (convert._FusedConverter$(S, T, TT))(this, other);
        };
      }
      startChunkedConversion(sink) {
        SinkOfT()._check(sink);
        dart.throw(new core.UnsupportedError(dart.str`This converter does not support chunked conversions: ${this}`));
      }
      bind(stream) {
        StreamOfS()._check(stream);
        return StreamOfT().eventTransformed(stream, dart.fn(sink => new convert._ConverterStreamEventSink(this, sink), EventSinkTo_ConverterStreamEventSink()));
      }
    }
    dart.addTypeTests(Converter);
    Converter[dart.implements] = () => [StreamTransformerOfS$T()];
    dart.setSignature(Converter, {
      constructors: () => ({new: dart.definiteFunctionType(convert.Converter$(S, T), [])}),
      methods: () => ({
        fuse: dart.definiteFunctionType(TT => [convert.Converter$(S, TT), [convert.Converter$(T, TT)]]),
        startChunkedConversion: dart.definiteFunctionType(core.Sink$(S), [core.Sink$(T)]),
        bind: dart.definiteFunctionType(async.Stream$(T), [async.Stream$(S)])
      })
    });
    return Converter;
  });
  convert.Converter = Converter();
  convert._UnicodeSubsetEncoder = class _UnicodeSubsetEncoder extends convert.Converter$(core.String, core.List$(core.int)) {
    new(subsetMask) {
      this[_subsetMask] = subsetMask;
      super.new();
    }
    convert(string, start, end) {
      if (start === void 0) start = 0;
      if (end === void 0) end = null;
      let stringLength = string[dartx.length];
      core.RangeError.checkValidRange(start, end, stringLength);
      if (end == null) end = stringLength;
      let length = dart.notNull(end) - dart.notNull(start);
      let result = typed_data.Uint8List.new(length);
      for (let i = 0; i < length; i++) {
        let codeUnit = string[dartx.codeUnitAt](dart.notNull(start) + i);
        if ((dart.notNull(codeUnit) & ~dart.notNull(this[_subsetMask])) != 0) {
          dart.throw(new core.ArgumentError("String contains invalid characters."));
        }
        result[dartx.set](i, codeUnit);
      }
      return result;
    }
    startChunkedConversion(sink) {
      if (!convert.ByteConversionSink.is(sink)) {
        sink = convert.ByteConversionSink.from(sink);
      }
      return new convert._UnicodeSubsetEncoderSink(this[_subsetMask], convert.ByteConversionSink._check(sink));
    }
    bind(stream) {
      return super.bind(stream);
    }
  };
  dart.addSimpleTypeTests(convert._UnicodeSubsetEncoder);
  dart.setSignature(convert._UnicodeSubsetEncoder, {
    constructors: () => ({new: dart.definiteFunctionType(convert._UnicodeSubsetEncoder, [core.int])}),
    methods: () => ({
      convert: dart.definiteFunctionType(core.List$(core.int), [core.String], [core.int, core.int]),
      startChunkedConversion: dart.definiteFunctionType(convert.StringConversionSink, [core.Sink$(core.List$(core.int))]),
      bind: dart.definiteFunctionType(async.Stream$(core.List$(core.int)), [async.Stream$(core.String)])
    })
  });
  convert.AsciiEncoder = class AsciiEncoder extends convert._UnicodeSubsetEncoder {
    new() {
      super.new(convert._ASCII_MASK);
    }
  };
  dart.setSignature(convert.AsciiEncoder, {
    constructors: () => ({new: dart.definiteFunctionType(convert.AsciiEncoder, [])})
  });
  convert._UnicodeSubsetEncoderSink = class _UnicodeSubsetEncoderSink extends convert.StringConversionSinkBase {
    new(subsetMask, sink) {
      this[_subsetMask] = subsetMask;
      this[_sink$] = sink;
    }
    close() {
      this[_sink$].close();
    }
    addSlice(source, start, end, isLast) {
      core.RangeError.checkValidRange(start, end, source[dartx.length]);
      for (let i = start; dart.notNull(i) < dart.notNull(end); i = dart.notNull(i) + 1) {
        let codeUnit = source[dartx.codeUnitAt](i);
        if ((dart.notNull(codeUnit) & ~dart.notNull(this[_subsetMask])) != 0) {
          dart.throw(new core.ArgumentError(dart.str`Source contains invalid character with code point: ${codeUnit}.`));
        }
      }
      this[_sink$].add(source[dartx.codeUnits][dartx.sublist](start, end));
      if (dart.test(isLast)) {
        this.close();
      }
    }
  };
  dart.setSignature(convert._UnicodeSubsetEncoderSink, {
    constructors: () => ({new: dart.definiteFunctionType(convert._UnicodeSubsetEncoderSink, [core.int, convert.ByteConversionSink])}),
    methods: () => ({
      close: dart.definiteFunctionType(dart.void, []),
      addSlice: dart.definiteFunctionType(dart.void, [core.String, core.int, core.int, core.bool])
    })
  });
  const _convertInvalid = Symbol('_convertInvalid');
  convert._UnicodeSubsetDecoder = class _UnicodeSubsetDecoder extends convert.Converter$(core.List$(core.int), core.String) {
    new(allowInvalid, subsetMask) {
      this[_allowInvalid] = allowInvalid;
      this[_subsetMask] = subsetMask;
      super.new();
    }
    convert(bytes, start, end) {
      if (start === void 0) start = 0;
      if (end === void 0) end = null;
      let byteCount = bytes[dartx.length];
      core.RangeError.checkValidRange(start, end, byteCount);
      if (end == null) end = byteCount;
      for (let i = start; dart.notNull(i) < dart.notNull(end); i = dart.notNull(i) + 1) {
        let byte = bytes[dartx.get](i);
        if ((dart.notNull(byte) & ~dart.notNull(this[_subsetMask])) != 0) {
          if (!dart.test(this[_allowInvalid])) {
            dart.throw(new core.FormatException(dart.str`Invalid value in input: ${byte}`));
          }
          return this[_convertInvalid](bytes, start, end);
        }
      }
      return core.String.fromCharCodes(bytes, start, end);
    }
    [_convertInvalid](bytes, start, end) {
      let buffer = new core.StringBuffer();
      for (let i = start; dart.notNull(i) < dart.notNull(end); i = dart.notNull(i) + 1) {
        let value = bytes[dartx.get](i);
        if ((dart.notNull(value) & ~dart.notNull(this[_subsetMask])) != 0) value = 65533;
        buffer.writeCharCode(value);
      }
      return buffer.toString();
    }
    bind(stream) {
      return super.bind(stream);
    }
  };
  dart.addSimpleTypeTests(convert._UnicodeSubsetDecoder);
  dart.setSignature(convert._UnicodeSubsetDecoder, {
    constructors: () => ({new: dart.definiteFunctionType(convert._UnicodeSubsetDecoder, [core.bool, core.int])}),
    methods: () => ({
      convert: dart.definiteFunctionType(core.String, [core.List$(core.int)], [core.int, core.int]),
      [_convertInvalid]: dart.definiteFunctionType(core.String, [core.List$(core.int), core.int, core.int]),
      bind: dart.definiteFunctionType(async.Stream$(core.String), [async.Stream$(core.List$(core.int))])
    })
  });
  convert.AsciiDecoder = class AsciiDecoder extends convert._UnicodeSubsetDecoder {
    new(opts) {
      let allowInvalid = opts && 'allowInvalid' in opts ? opts.allowInvalid : false;
      super.new(allowInvalid, convert._ASCII_MASK);
    }
    startChunkedConversion(sink) {
      let stringSink = null;
      if (convert.StringConversionSink.is(sink)) {
        stringSink = sink;
      } else {
        stringSink = convert.StringConversionSink.from(sink);
      }
      if (dart.test(this[_allowInvalid])) {
        return new convert._ErrorHandlingAsciiDecoderSink(stringSink.asUtf8Sink(false));
      } else {
        return new convert._SimpleAsciiDecoderSink(stringSink);
      }
    }
  };
  dart.setSignature(convert.AsciiDecoder, {
    constructors: () => ({new: dart.definiteFunctionType(convert.AsciiDecoder, [], {allowInvalid: core.bool})}),
    methods: () => ({startChunkedConversion: dart.definiteFunctionType(convert.ByteConversionSink, [core.Sink$(core.String)])})
  });
  const _utf8Sink = Symbol('_utf8Sink');
  let const$25;
  convert.ChunkedConversionSink$ = dart.generic(T => {
    let _SimpleCallbackSinkOfT = () => (_SimpleCallbackSinkOfT = dart.constFn(convert._SimpleCallbackSink$(T)))();
    let SinkOfT = () => (SinkOfT = dart.constFn(core.Sink$(T)))();
    class ChunkedConversionSink extends core.Object {
      new() {
      }
      static withCallback(callback) {
        return new (_SimpleCallbackSinkOfT())(callback);
      }
    }
    dart.addTypeTests(ChunkedConversionSink);
    ChunkedConversionSink[dart.implements] = () => [SinkOfT()];
    dart.setSignature(ChunkedConversionSink, {
      constructors: () => ({
        new: dart.definiteFunctionType(convert.ChunkedConversionSink$(T), []),
        withCallback: dart.definiteFunctionType(convert.ChunkedConversionSink$(T), [dart.functionType(dart.void, [core.List$(T)])])
      })
    });
    return ChunkedConversionSink;
  });
  convert.ChunkedConversionSink = ChunkedConversionSink();
  convert.ByteConversionSink = class ByteConversionSink extends convert.ChunkedConversionSink$(core.List$(core.int)) {
    new() {
      super.new();
    }
    static withCallback(callback) {
      return new convert._ByteCallbackSink(callback);
    }
    static from(sink) {
      return new convert._ByteAdapterSink(sink);
    }
  };
  dart.addSimpleTypeTests(convert.ByteConversionSink);
  dart.setSignature(convert.ByteConversionSink, {
    constructors: () => ({
      new: dart.definiteFunctionType(convert.ByteConversionSink, []),
      withCallback: dart.definiteFunctionType(convert.ByteConversionSink, [dart.functionType(dart.void, [core.List$(core.int)])]),
      from: dart.definiteFunctionType(convert.ByteConversionSink, [core.Sink$(core.List$(core.int))])
    })
  });
  convert.ByteConversionSinkBase = class ByteConversionSinkBase extends convert.ByteConversionSink {
    new() {
      super.new();
    }
    addSlice(chunk, start, end, isLast) {
      this.add(chunk[dartx.sublist](start, end));
      if (dart.test(isLast)) this.close();
    }
  };
  dart.setSignature(convert.ByteConversionSinkBase, {
    methods: () => ({addSlice: dart.definiteFunctionType(dart.void, [core.List$(core.int), core.int, core.int, core.bool])})
  });
  convert._ErrorHandlingAsciiDecoderSink = class _ErrorHandlingAsciiDecoderSink extends convert.ByteConversionSinkBase {
    new(utf8Sink) {
      this[_utf8Sink] = utf8Sink;
    }
    close() {
      this[_utf8Sink].close();
    }
    add(source) {
      this.addSlice(source, 0, source[dartx.length], false);
    }
    addSlice(source, start, end, isLast) {
      core.RangeError.checkValidRange(start, end, source[dartx.length]);
      for (let i = start; dart.notNull(i) < dart.notNull(end); i = dart.notNull(i) + 1) {
        if ((dart.notNull(source[dartx.get](i)) & ~convert._ASCII_MASK) != 0) {
          if (dart.notNull(i) > dart.notNull(start)) this[_utf8Sink].addSlice(source, start, i, false);
          this[_utf8Sink].add(const$25 || (const$25 = dart.constList([239, 191, 189], core.int)));
          start = dart.notNull(i) + 1;
        }
      }
      if (dart.notNull(start) < dart.notNull(end)) {
        this[_utf8Sink].addSlice(source, start, end, isLast);
      } else if (dart.test(isLast)) {
        this.close();
      }
    }
  };
  dart.setSignature(convert._ErrorHandlingAsciiDecoderSink, {
    constructors: () => ({new: dart.definiteFunctionType(convert._ErrorHandlingAsciiDecoderSink, [convert.ByteConversionSink])}),
    methods: () => ({
      close: dart.definiteFunctionType(dart.void, []),
      add: dart.definiteFunctionType(dart.void, [core.List$(core.int)])
    })
  });
  convert._SimpleAsciiDecoderSink = class _SimpleAsciiDecoderSink extends convert.ByteConversionSinkBase {
    new(sink) {
      this[_sink$] = sink;
    }
    close() {
      this[_sink$].close();
    }
    add(source) {
      for (let i = 0; i < dart.notNull(source[dartx.length]); i++) {
        if ((dart.notNull(source[dartx.get](i)) & ~convert._ASCII_MASK) != 0) {
          dart.throw(new core.FormatException("Source contains non-ASCII bytes."));
        }
      }
      this[_sink$].add(core.String.fromCharCodes(source));
    }
    addSlice(source, start, end, isLast) {
      let length = source[dartx.length];
      core.RangeError.checkValidRange(start, end, length);
      if (dart.notNull(start) < dart.notNull(end)) {
        if (start != 0 || end != length) {
          source = source[dartx.sublist](start, end);
        }
        this.add(source);
      }
      if (dart.test(isLast)) this.close();
    }
  };
  dart.setSignature(convert._SimpleAsciiDecoderSink, {
    constructors: () => ({new: dart.definiteFunctionType(convert._SimpleAsciiDecoderSink, [core.Sink])}),
    methods: () => ({
      close: dart.definiteFunctionType(dart.void, []),
      add: dart.definiteFunctionType(dart.void, [core.List$(core.int)])
    })
  });
  const _urlSafe = Symbol('_urlSafe');
  convert.Base64Encoder = class Base64Encoder extends convert.Converter$(core.List$(core.int), core.String) {
    new() {
      this[_urlSafe] = false;
      super.new();
    }
    urlSafe() {
      this[_urlSafe] = true;
      super.new();
    }
    convert(input) {
      if (dart.test(input[dartx.isEmpty])) return "";
      let encoder = new convert._Base64Encoder(this[_urlSafe]);
      let buffer = encoder.encode(input, 0, input[dartx.length], true);
      return core.String.fromCharCodes(buffer);
    }
    startChunkedConversion(sink) {
      if (convert.StringConversionSink.is(sink)) {
        return new convert._Utf8Base64EncoderSink(sink.asUtf8Sink(false), this[_urlSafe]);
      }
      return new convert._AsciiBase64EncoderSink(sink, this[_urlSafe]);
    }
  };
  dart.addSimpleTypeTests(convert.Base64Encoder);
  dart.defineNamedConstructor(convert.Base64Encoder, 'urlSafe');
  dart.setSignature(convert.Base64Encoder, {
    constructors: () => ({
      new: dart.definiteFunctionType(convert.Base64Encoder, []),
      urlSafe: dart.definiteFunctionType(convert.Base64Encoder, [])
    }),
    methods: () => ({
      convert: dart.definiteFunctionType(core.String, [core.List$(core.int)]),
      startChunkedConversion: dart.definiteFunctionType(convert.ByteConversionSink, [core.Sink$(core.String)])
    })
  });
  let const$26;
  const _encoder = Symbol('_encoder');
  let const$27;
  let const$28;
  convert.Base64Codec = class Base64Codec extends convert.Codec$(core.List$(core.int), core.String) {
    new() {
      this[_encoder] = const$26 || (const$26 = dart.const(new convert.Base64Encoder()));
      super.new();
    }
    urlSafe() {
      this[_encoder] = const$27 || (const$27 = dart.const(new convert.Base64Encoder.urlSafe()));
      super.new();
    }
    get encoder() {
      return this[_encoder];
    }
    get decoder() {
      return const$28 || (const$28 = dart.const(new convert.Base64Decoder()));
    }
  };
  dart.addSimpleTypeTests(convert.Base64Codec);
  dart.defineNamedConstructor(convert.Base64Codec, 'urlSafe');
  dart.setSignature(convert.Base64Codec, {
    constructors: () => ({
      new: dart.definiteFunctionType(convert.Base64Codec, []),
      urlSafe: dart.definiteFunctionType(convert.Base64Codec, [])
    })
  });
  convert.BASE64 = dart.const(new convert.Base64Codec());
  convert.BASE64URL = dart.const(new convert.Base64Codec.urlSafe());
  convert._paddingChar = 61;
  const _alphabet = Symbol('_alphabet');
  const _state$0 = Symbol('_state');
  convert._Base64Encoder = class _Base64Encoder extends core.Object {
    new(urlSafe) {
      this[_alphabet] = dart.test(urlSafe) ? convert._Base64Encoder._base64urlAlphabet : convert._Base64Encoder._base64Alphabet;
      this[_state$0] = 0;
    }
    static _encodeState(count, bits) {
      dart.assert(dart.notNull(count) <= convert._Base64Encoder._countMask);
      return (dart.notNull(bits) << convert._Base64Encoder._valueShift | dart.notNull(count)) >>> 0;
    }
    static _stateBits(state) {
      return state[dartx['>>']](convert._Base64Encoder._valueShift);
    }
    static _stateCount(state) {
      return dart.notNull(state) & convert._Base64Encoder._countMask;
    }
    createBuffer(bufferLength) {
      return typed_data.Uint8List.new(bufferLength);
    }
    encode(bytes, start, end, isLast) {
      dart.assert(0 <= dart.notNull(start));
      dart.assert(dart.notNull(start) <= dart.notNull(end));
      dart.assert(bytes == null || dart.notNull(end) <= dart.notNull(bytes[dartx.length]));
      let length = dart.notNull(end) - dart.notNull(start);
      let count = convert._Base64Encoder._stateCount(this[_state$0]);
      let byteCount = dart.notNull(count) + length;
      let fullChunks = (byteCount / 3)[dartx.truncate]();
      let partialChunkLength = byteCount - fullChunks * 3;
      let bufferLength = fullChunks * 4;
      if (dart.test(isLast) && partialChunkLength > 0) {
        bufferLength = bufferLength + 4;
      }
      let output = this.createBuffer(bufferLength);
      this[_state$0] = convert._Base64Encoder.encodeChunk(this[_alphabet], bytes, start, end, isLast, output, 0, this[_state$0]);
      if (bufferLength > 0) return output;
      return null;
    }
    static encodeChunk(alphabet, bytes, start, end, isLast, output, outputIndex, state) {
      let bits = convert._Base64Encoder._stateBits(state);
      let expectedChars = 3 - dart.notNull(convert._Base64Encoder._stateCount(state));
      let byteOr = 0;
      for (let i = start; dart.notNull(i) < dart.notNull(end); i = dart.notNull(i) + 1) {
        let byte = bytes[dartx.get](i);
        byteOr = (dart.notNull(byteOr) | dart.notNull(byte)) >>> 0;
        bits = (dart.notNull(bits) << 8 | dart.notNull(byte)) & 16777215;
        expectedChars--;
        if (expectedChars == 0) {
          output[dartx.set]((() => {
            let x = outputIndex;
            outputIndex = dart.notNull(x) + 1;
            return x;
          })(), alphabet[dartx.codeUnitAt](dart.notNull(bits) >> 18 & convert._Base64Encoder._sixBitMask));
          output[dartx.set]((() => {
            let x = outputIndex;
            outputIndex = dart.notNull(x) + 1;
            return x;
          })(), alphabet[dartx.codeUnitAt](dart.notNull(bits) >> 12 & convert._Base64Encoder._sixBitMask));
          output[dartx.set]((() => {
            let x = outputIndex;
            outputIndex = dart.notNull(x) + 1;
            return x;
          })(), alphabet[dartx.codeUnitAt](dart.notNull(bits) >> 6 & convert._Base64Encoder._sixBitMask));
          output[dartx.set]((() => {
            let x = outputIndex;
            outputIndex = dart.notNull(x) + 1;
            return x;
          })(), alphabet[dartx.codeUnitAt](dart.notNull(bits) & convert._Base64Encoder._sixBitMask));
          expectedChars = 3;
          bits = 0;
        }
      }
      if (dart.notNull(byteOr) >= 0 && dart.notNull(byteOr) <= 255) {
        if (dart.test(isLast) && expectedChars < 3) {
          convert._Base64Encoder.writeFinalChunk(alphabet, output, outputIndex, 3 - expectedChars, bits);
          return 0;
        }
        return convert._Base64Encoder._encodeState(3 - expectedChars, bits);
      }
      let i = start;
      while (dart.notNull(i) < dart.notNull(end)) {
        let byte = bytes[dartx.get](i);
        if (dart.notNull(byte) < 0 || dart.notNull(byte) > 255) break;
        i = dart.notNull(i) + 1;
      }
      dart.throw(new core.ArgumentError.value(bytes, dart.str`Not a byte value at index ${i}: 0x${bytes[dartx.get](i)[dartx.toRadixString](16)}`));
    }
    static writeFinalChunk(alphabet, output, outputIndex, count, bits) {
      dart.assert(dart.notNull(count) > 0);
      if (count == 1) {
        output[dartx.set]((() => {
          let x = outputIndex;
          outputIndex = dart.notNull(x) + 1;
          return x;
        })(), alphabet[dartx.codeUnitAt](dart.notNull(bits) >> 2 & convert._Base64Encoder._sixBitMask));
        output[dartx.set]((() => {
          let x = outputIndex;
          outputIndex = dart.notNull(x) + 1;
          return x;
        })(), alphabet[dartx.codeUnitAt](dart.notNull(bits) << 4 & convert._Base64Encoder._sixBitMask));
        output[dartx.set]((() => {
          let x = outputIndex;
          outputIndex = dart.notNull(x) + 1;
          return x;
        })(), convert._paddingChar);
        output[dartx.set]((() => {
          let x = outputIndex;
          outputIndex = dart.notNull(x) + 1;
          return x;
        })(), convert._paddingChar);
      } else {
        dart.assert(count == 2);
        output[dartx.set]((() => {
          let x = outputIndex;
          outputIndex = dart.notNull(x) + 1;
          return x;
        })(), alphabet[dartx.codeUnitAt](dart.notNull(bits) >> 10 & convert._Base64Encoder._sixBitMask));
        output[dartx.set]((() => {
          let x = outputIndex;
          outputIndex = dart.notNull(x) + 1;
          return x;
        })(), alphabet[dartx.codeUnitAt](dart.notNull(bits) >> 4 & convert._Base64Encoder._sixBitMask));
        output[dartx.set]((() => {
          let x = outputIndex;
          outputIndex = dart.notNull(x) + 1;
          return x;
        })(), alphabet[dartx.codeUnitAt](dart.notNull(bits) << 2 & convert._Base64Encoder._sixBitMask));
        output[dartx.set]((() => {
          let x = outputIndex;
          outputIndex = dart.notNull(x) + 1;
          return x;
        })(), convert._paddingChar);
      }
    }
  };
  dart.setSignature(convert._Base64Encoder, {
    constructors: () => ({new: dart.definiteFunctionType(convert._Base64Encoder, [core.bool])}),
    methods: () => ({
      createBuffer: dart.definiteFunctionType(typed_data.Uint8List, [core.int]),
      encode: dart.definiteFunctionType(typed_data.Uint8List, [core.List$(core.int), core.int, core.int, core.bool])
    }),
    statics: () => ({
      _encodeState: dart.definiteFunctionType(core.int, [core.int, core.int]),
      _stateBits: dart.definiteFunctionType(core.int, [core.int]),
      _stateCount: dart.definiteFunctionType(core.int, [core.int]),
      encodeChunk: dart.definiteFunctionType(core.int, [core.String, core.List$(core.int), core.int, core.int, core.bool, typed_data.Uint8List, core.int, core.int]),
      writeFinalChunk: dart.definiteFunctionType(dart.void, [core.String, typed_data.Uint8List, core.int, core.int, core.int])
    }),
    names: ['_encodeState', '_stateBits', '_stateCount', 'encodeChunk', 'writeFinalChunk']
  });
  convert._Base64Encoder._base64Alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  convert._Base64Encoder._base64urlAlphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";
  convert._Base64Encoder._valueShift = 2;
  convert._Base64Encoder._countMask = 3;
  convert._Base64Encoder._sixBitMask = 63;
  convert._BufferCachingBase64Encoder = class _BufferCachingBase64Encoder extends convert._Base64Encoder {
    new(urlSafe) {
      this.bufferCache = null;
      super.new(urlSafe);
    }
    createBuffer(bufferLength) {
      if (this.bufferCache == null || dart.notNull(this.bufferCache[dartx.length]) < dart.notNull(bufferLength)) {
        this.bufferCache = typed_data.Uint8List.new(bufferLength);
      }
      return typed_data.Uint8List.view(this.bufferCache[dartx.buffer], 0, bufferLength);
    }
  };
  dart.setSignature(convert._BufferCachingBase64Encoder, {
    constructors: () => ({new: dart.definiteFunctionType(convert._BufferCachingBase64Encoder, [core.bool])})
  });
  const _add$1 = Symbol('_add');
  convert._Base64EncoderSink = class _Base64EncoderSink extends convert.ByteConversionSinkBase {
    add(source) {
      this[_add$1](source, 0, source[dartx.length], false);
    }
    close() {
      this[_add$1](null, 0, 0, true);
    }
    addSlice(source, start, end, isLast) {
      if (end == null) dart.throw(new core.ArgumentError.notNull("end"));
      core.RangeError.checkValidRange(start, end, source[dartx.length]);
      this[_add$1](source, start, end, isLast);
    }
  };
  dart.setSignature(convert._Base64EncoderSink, {
    methods: () => ({
      add: dart.definiteFunctionType(dart.void, [core.List$(core.int)]),
      close: dart.definiteFunctionType(dart.void, [])
    })
  });
  convert._AsciiBase64EncoderSink = class _AsciiBase64EncoderSink extends convert._Base64EncoderSink {
    new(sink, urlSafe) {
      this[_sink$] = sink;
      this[_encoder] = new convert._BufferCachingBase64Encoder(urlSafe);
    }
    [_add$1](source, start, end, isLast) {
      let buffer = this[_encoder].encode(source, start, end, isLast);
      if (buffer != null) {
        let string = core.String.fromCharCodes(buffer);
        this[_sink$].add(string);
      }
      if (dart.test(isLast)) {
        this[_sink$].close();
      }
    }
  };
  dart.setSignature(convert._AsciiBase64EncoderSink, {
    constructors: () => ({new: dart.definiteFunctionType(convert._AsciiBase64EncoderSink, [core.Sink$(core.String), core.bool])}),
    methods: () => ({[_add$1]: dart.definiteFunctionType(dart.void, [core.List$(core.int), core.int, core.int, core.bool])})
  });
  convert._Utf8Base64EncoderSink = class _Utf8Base64EncoderSink extends convert._Base64EncoderSink {
    new(sink, urlSafe) {
      this[_sink$] = sink;
      this[_encoder] = new convert._Base64Encoder(urlSafe);
    }
    [_add$1](source, start, end, isLast) {
      let buffer = this[_encoder].encode(source, start, end, isLast);
      if (buffer != null) {
        this[_sink$].addSlice(buffer, 0, buffer[dartx.length], isLast);
      }
    }
  };
  dart.setSignature(convert._Utf8Base64EncoderSink, {
    constructors: () => ({new: dart.definiteFunctionType(convert._Utf8Base64EncoderSink, [convert.ByteConversionSink, core.bool])}),
    methods: () => ({[_add$1]: dart.definiteFunctionType(dart.void, [core.List$(core.int), core.int, core.int, core.bool])})
  });
  convert.Base64Decoder = class Base64Decoder extends convert.Converter$(core.String, core.List$(core.int)) {
    new() {
      super.new();
    }
    convert(input, start, end) {
      if (start === void 0) start = 0;
      if (end === void 0) end = null;
      end = core.RangeError.checkValidRange(start, end, input[dartx.length]);
      if (start == end) return typed_data.Uint8List.new(0);
      let decoder = new convert._Base64Decoder();
      let buffer = decoder.decode(input, start, end);
      decoder.close(input, end);
      return buffer;
    }
    startChunkedConversion(sink) {
      return new convert._Base64DecoderSink(sink);
    }
  };
  dart.addSimpleTypeTests(convert.Base64Decoder);
  dart.setSignature(convert.Base64Decoder, {
    constructors: () => ({new: dart.definiteFunctionType(convert.Base64Decoder, [])}),
    methods: () => ({
      convert: dart.definiteFunctionType(core.List$(core.int), [core.String], [core.int, core.int]),
      startChunkedConversion: dart.definiteFunctionType(convert.StringConversionSink, [core.Sink$(core.List$(core.int))])
    })
  });
  convert._Base64Decoder = class _Base64Decoder extends core.Object {
    new() {
      this[_state$0] = 0;
    }
    static _encodeCharacterState(count, bits) {
      dart.assert(count == (dart.notNull(count) & convert._Base64Decoder._countMask));
      return (dart.notNull(bits) << convert._Base64Decoder._valueShift | dart.notNull(count)) >>> 0;
    }
    static _stateCount(state) {
      dart.assert(dart.notNull(state) >= 0);
      return dart.notNull(state) & convert._Base64Decoder._countMask;
    }
    static _stateBits(state) {
      dart.assert(dart.notNull(state) >= 0);
      return state[dartx['>>']](convert._Base64Decoder._valueShift);
    }
    static _encodePaddingState(expectedPadding) {
      dart.assert(dart.notNull(expectedPadding) >= 0);
      dart.assert(dart.notNull(expectedPadding) <= 5);
      return -dart.notNull(expectedPadding) - 1;
    }
    static _statePadding(state) {
      dart.assert(dart.notNull(state) < 0);
      return -dart.notNull(state) - 1;
    }
    static _hasSeenPadding(state) {
      return dart.notNull(state) < 0;
    }
    decode(input, start, end) {
      dart.assert(0 <= dart.notNull(start));
      dart.assert(dart.notNull(start) <= dart.notNull(end));
      dart.assert(dart.notNull(end) <= dart.notNull(input[dartx.length]));
      if (dart.test(convert._Base64Decoder._hasSeenPadding(this[_state$0]))) {
        this[_state$0] = convert._Base64Decoder._checkPadding(input, start, end, this[_state$0]);
        return null;
      }
      if (start == end) return typed_data.Uint8List.new(0);
      let buffer = convert._Base64Decoder._allocateBuffer(input, start, end, this[_state$0]);
      this[_state$0] = convert._Base64Decoder.decodeChunk(input, start, end, buffer, 0, this[_state$0]);
      return buffer;
    }
    close(input, end) {
      if (dart.notNull(this[_state$0]) < dart.notNull(convert._Base64Decoder._encodePaddingState(0))) {
        dart.throw(new core.FormatException("Missing padding character", input, end));
      }
      if (dart.notNull(this[_state$0]) > 0) {
        dart.throw(new core.FormatException("Invalid length, must be multiple of four", input, end));
      }
      this[_state$0] = convert._Base64Decoder._encodePaddingState(0);
    }
    static decodeChunk(input, start, end, output, outIndex, state) {
      dart.assert(!dart.test(convert._Base64Decoder._hasSeenPadding(state)));
      let asciiMask = 127;
      let asciiMax = 127;
      let eightBitMask = 255;
      let bitsPerCharacter = 6;
      let bits = convert._Base64Decoder._stateBits(state);
      let count = convert._Base64Decoder._stateCount(state);
      let charOr = 0;
      for (let i = start; dart.notNull(i) < dart.notNull(end); i = dart.notNull(i) + 1) {
        let char = input[dartx.codeUnitAt](i);
        charOr = (dart.notNull(charOr) | dart.notNull(char)) >>> 0;
        let code = convert._Base64Decoder._inverseAlphabet[dartx.get]((dart.notNull(char) & asciiMask) >>> 0);
        if (dart.notNull(code) >= 0) {
          bits = (bits[dartx['<<']](bitsPerCharacter) | dart.notNull(code)) & 16777215;
          count = dart.notNull(count) + 1 & 3;
          if (count == 0) {
            dart.assert(dart.notNull(outIndex) + 3 <= dart.notNull(output[dartx.length]));
            output[dartx.set]((() => {
              let x = outIndex;
              outIndex = dart.notNull(x) + 1;
              return x;
            })(), (bits[dartx['>>']](16) & eightBitMask) >>> 0);
            output[dartx.set]((() => {
              let x = outIndex;
              outIndex = dart.notNull(x) + 1;
              return x;
            })(), (bits[dartx['>>']](8) & eightBitMask) >>> 0);
            output[dartx.set]((() => {
              let x = outIndex;
              outIndex = dart.notNull(x) + 1;
              return x;
            })(), (dart.notNull(bits) & eightBitMask) >>> 0);
            bits = 0;
          }
          continue;
        } else if (code == convert._Base64Decoder._padding && dart.notNull(count) > 1) {
          if (dart.notNull(charOr) < 0 || dart.notNull(charOr) > asciiMax) break;
          if (count == 3) {
            if ((dart.notNull(bits) & 3) != 0) {
              dart.throw(new core.FormatException("Invalid encoding before padding", input, i));
            }
            output[dartx.set]((() => {
              let x = outIndex;
              outIndex = dart.notNull(x) + 1;
              return x;
            })(), bits[dartx['>>']](10));
            output[dartx.set]((() => {
              let x = outIndex;
              outIndex = dart.notNull(x) + 1;
              return x;
            })(), bits[dartx['>>']](2));
          } else {
            if ((dart.notNull(bits) & 15) != 0) {
              dart.throw(new core.FormatException("Invalid encoding before padding", input, i));
            }
            output[dartx.set]((() => {
              let x = outIndex;
              outIndex = dart.notNull(x) + 1;
              return x;
            })(), bits[dartx['>>']](4));
          }
          let expectedPadding = (3 - dart.notNull(count)) * 3;
          if (char == convert._Base64Decoder._char_percent) {
            expectedPadding = expectedPadding + 2;
          }
          state = convert._Base64Decoder._encodePaddingState(expectedPadding);
          return convert._Base64Decoder._checkPadding(input, dart.notNull(i) + 1, end, state);
        }
        dart.throw(new core.FormatException("Invalid character", input, i));
      }
      if (dart.notNull(charOr) >= 0 && dart.notNull(charOr) <= asciiMax) {
        return convert._Base64Decoder._encodeCharacterState(count, bits);
      }
      let i = null;
      for (i = start; dart.notNull(i) < dart.notNull(end); i = dart.notNull(i) + 1) {
        let char = input[dartx.codeUnitAt](i);
        if (dart.notNull(char) < 0 || dart.notNull(char) > asciiMax) break;
      }
      dart.throw(new core.FormatException("Invalid character", input, i));
    }
    static _allocateBuffer(input, start, end, state) {
      dart.assert(dart.notNull(state) >= 0);
      let paddingStart = convert._Base64Decoder._trimPaddingChars(input, start, end);
      let length = dart.notNull(convert._Base64Decoder._stateCount(state)) + (dart.notNull(paddingStart) - dart.notNull(start));
      let bufferLength = length[dartx['>>']](2) * 3;
      let remainderLength = length & 3;
      if (remainderLength != 0 && dart.notNull(paddingStart) < dart.notNull(end)) {
        bufferLength = bufferLength + (remainderLength - 1);
      }
      if (bufferLength > 0) return typed_data.Uint8List.new(bufferLength);
      return null;
    }
    static _trimPaddingChars(input, start, end) {
      let padding = 0;
      let index = end;
      let newEnd = end;
      while (dart.notNull(index) > dart.notNull(start) && padding < 2) {
        index = dart.notNull(index) - 1;
        let char = input[dartx.codeUnitAt](index);
        if (char == convert._paddingChar) {
          padding++;
          newEnd = index;
          continue;
        }
        if ((dart.notNull(char) | 32) == convert._Base64Decoder._char_d) {
          if (index == start) break;
          index = dart.notNull(index) - 1;
          char = input[dartx.codeUnitAt](index);
        }
        if (char == convert._Base64Decoder._char_3) {
          if (index == start) break;
          index = dart.notNull(index) - 1;
          char = input[dartx.codeUnitAt](index);
        }
        if (char == convert._Base64Decoder._char_percent) {
          padding++;
          newEnd = index;
          continue;
        }
        break;
      }
      return newEnd;
    }
    static _checkPadding(input, start, end, state) {
      dart.assert(convert._Base64Decoder._hasSeenPadding(state));
      if (start == end) return state;
      let expectedPadding = convert._Base64Decoder._statePadding(state);
      dart.assert(dart.notNull(expectedPadding) >= 0);
      dart.assert(dart.notNull(expectedPadding) < 6);
      while (dart.notNull(expectedPadding) > 0) {
        let char = input[dartx.codeUnitAt](start);
        if (expectedPadding == 3) {
          if (char == convert._paddingChar) {
            expectedPadding = dart.notNull(expectedPadding) - 3;
            start = dart.notNull(start) + 1;
            break;
          }
          if (char == convert._Base64Decoder._char_percent) {
            expectedPadding = dart.notNull(expectedPadding) - 1;
            start = dart.notNull(start) + 1;
            if (start == end) break;
            char = input[dartx.codeUnitAt](start);
          } else {
            break;
          }
        }
        let expectedPartialPadding = expectedPadding;
        if (dart.notNull(expectedPartialPadding) > 3) {
          expectedPartialPadding = dart.notNull(expectedPartialPadding) - 3;
        }
        if (expectedPartialPadding == 2) {
          if (char != convert._Base64Decoder._char_3) break;
          start = dart.notNull(start) + 1;
          expectedPadding = dart.notNull(expectedPadding) - 1;
          if (start == end) break;
          char = input[dartx.codeUnitAt](start);
        }
        if ((dart.notNull(char) | 32) != convert._Base64Decoder._char_d) break;
        start = dart.notNull(start) + 1;
        expectedPadding = dart.notNull(expectedPadding) - 1;
        if (start == end) break;
      }
      if (start != end) {
        dart.throw(new core.FormatException("Invalid padding character", input, start));
      }
      return convert._Base64Decoder._encodePaddingState(expectedPadding);
    }
  };
  dart.setSignature(convert._Base64Decoder, {
    methods: () => ({
      decode: dart.definiteFunctionType(typed_data.Uint8List, [core.String, core.int, core.int]),
      close: dart.definiteFunctionType(dart.void, [core.String, core.int])
    }),
    statics: () => ({
      _encodeCharacterState: dart.definiteFunctionType(core.int, [core.int, core.int]),
      _stateCount: dart.definiteFunctionType(core.int, [core.int]),
      _stateBits: dart.definiteFunctionType(core.int, [core.int]),
      _encodePaddingState: dart.definiteFunctionType(core.int, [core.int]),
      _statePadding: dart.definiteFunctionType(core.int, [core.int]),
      _hasSeenPadding: dart.definiteFunctionType(core.bool, [core.int]),
      decodeChunk: dart.definiteFunctionType(core.int, [core.String, core.int, core.int, typed_data.Uint8List, core.int, core.int]),
      _allocateBuffer: dart.definiteFunctionType(typed_data.Uint8List, [core.String, core.int, core.int, core.int]),
      _trimPaddingChars: dart.definiteFunctionType(core.int, [core.String, core.int, core.int]),
      _checkPadding: dart.definiteFunctionType(core.int, [core.String, core.int, core.int, core.int])
    }),
    names: ['_encodeCharacterState', '_stateCount', '_stateBits', '_encodePaddingState', '_statePadding', '_hasSeenPadding', 'decodeChunk', '_allocateBuffer', '_trimPaddingChars', '_checkPadding']
  });
  convert._Base64Decoder._valueShift = 2;
  convert._Base64Decoder._countMask = 3;
  convert._Base64Decoder._invalid = -2;
  convert._Base64Decoder._padding = -1;
  convert._Base64Decoder._char_percent = 37;
  convert._Base64Decoder._char_3 = 51;
  convert._Base64Decoder._char_d = 100;
  dart.defineLazy(convert._Base64Decoder, {
    get __() {
      return convert._Base64Decoder._invalid;
    },
    get _p() {
      return convert._Base64Decoder._padding;
    },
    get _inverseAlphabet() {
      return typed_data.Int8List.fromList(JSArrayOfint().of([convert._Base64Decoder.__, convert._Base64Decoder.__, convert._Base64Decoder.__, convert._Base64Decoder.__, convert._Base64Decoder.__, convert._Base64Decoder.__, convert._Base64Decoder.__, convert._Base64Decoder.__, convert._Base64Decoder.__, convert._Base64Decoder.__, convert._Base64Decoder.__, convert._Base64Decoder.__, convert._Base64Decoder.__, convert._Base64Decoder.__, convert._Base64Decoder.__, convert._Base64Decoder.__, convert._Base64Decoder.__, convert._Base64Decoder.__, convert._Base64Decoder.__, convert._Base64Decoder.__, convert._Base64Decoder.__, convert._Base64Decoder.__, convert._Base64Decoder.__, convert._Base64Decoder.__, convert._Base64Decoder.__, convert._Base64Decoder.__, convert._Base64Decoder.__, convert._Base64Decoder.__, convert._Base64Decoder.__, convert._Base64Decoder.__, convert._Base64Decoder.__, convert._Base64Decoder.__, convert._Base64Decoder.__, convert._Base64Decoder.__, convert._Base64Decoder.__, convert._Base64Decoder.__, convert._Base64Decoder.__, convert._Base64Decoder._p, convert._Base64Decoder.__, convert._Base64Decoder.__, convert._Base64Decoder.__, convert._Base64Decoder.__, convert._Base64Decoder.__, 62, convert._Base64Decoder.__, 62, convert._Base64Decoder.__, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, convert._Base64Decoder.__, convert._Base64Decoder.__, convert._Base64Decoder.__, convert._Base64Decoder._p, convert._Base64Decoder.__, convert._Base64Decoder.__, convert._Base64Decoder.__, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, convert._Base64Decoder.__, convert._Base64Decoder.__, convert._Base64Decoder.__, convert._Base64Decoder.__, 63, convert._Base64Decoder.__, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, convert._Base64Decoder.__, convert._Base64Decoder.__, convert._Base64Decoder.__, convert._Base64Decoder.__, convert._Base64Decoder.__]));
    }
  });
  const _decoder = Symbol('_decoder');
  convert._Base64DecoderSink = class _Base64DecoderSink extends convert.StringConversionSinkBase {
    new(sink) {
      this[_decoder] = new convert._Base64Decoder();
      this[_sink$] = sink;
    }
    add(string) {
      if (dart.test(string[dartx.isEmpty])) return;
      let buffer = this[_decoder].decode(string, 0, string[dartx.length]);
      if (buffer != null) this[_sink$].add(buffer);
    }
    close() {
      this[_decoder].close(null, null);
      this[_sink$].close();
    }
    addSlice(string, start, end, isLast) {
      end = core.RangeError.checkValidRange(start, end, string[dartx.length]);
      if (start == end) return;
      let buffer = this[_decoder].decode(string, start, end);
      if (buffer != null) this[_sink$].add(buffer);
      if (dart.test(isLast)) {
        this[_decoder].close(string, end);
        this[_sink$].close();
      }
    }
  };
  dart.setSignature(convert._Base64DecoderSink, {
    constructors: () => ({new: dart.definiteFunctionType(convert._Base64DecoderSink, [core.Sink$(core.List$(core.int))])}),
    methods: () => ({
      close: dart.definiteFunctionType(dart.void, []),
      addSlice: dart.definiteFunctionType(dart.void, [core.String, core.int, core.int, core.bool])
    })
  });
  convert._ByteAdapterSink = class _ByteAdapterSink extends convert.ByteConversionSinkBase {
    new(sink) {
      this[_sink$] = sink;
    }
    add(chunk) {
      this[_sink$].add(chunk);
    }
    close() {
      this[_sink$].close();
    }
  };
  dart.setSignature(convert._ByteAdapterSink, {
    constructors: () => ({new: dart.definiteFunctionType(convert._ByteAdapterSink, [core.Sink$(core.List$(core.int))])}),
    methods: () => ({
      add: dart.definiteFunctionType(dart.void, [core.List$(core.int)]),
      close: dart.definiteFunctionType(dart.void, [])
    })
  });
  const _buffer = Symbol('_buffer');
  const _callback = Symbol('_callback');
  const _bufferIndex = Symbol('_bufferIndex');
  convert._ByteCallbackSink = class _ByteCallbackSink extends convert.ByteConversionSinkBase {
    new(callback) {
      this[_buffer] = typed_data.Uint8List.new(convert._ByteCallbackSink._INITIAL_BUFFER_SIZE);
      this[_callback] = callback;
      this[_bufferIndex] = 0;
    }
    add(chunk) {
      let freeCount = dart.notNull(this[_buffer][dartx.length]) - dart.notNull(this[_bufferIndex]);
      if (dart.notNull(chunk[dartx.length]) > freeCount) {
        let oldLength = this[_buffer][dartx.length];
        let newLength = dart.notNull(convert._ByteCallbackSink._roundToPowerOf2(dart.notNull(chunk[dartx.length]) + dart.notNull(oldLength))) * 2;
        let grown = typed_data.Uint8List.new(newLength);
        grown[dartx.setRange](0, this[_buffer][dartx.length], this[_buffer]);
        this[_buffer] = grown;
      }
      this[_buffer][dartx.setRange](this[_bufferIndex], dart.notNull(this[_bufferIndex]) + dart.notNull(chunk[dartx.length]), chunk);
      this[_bufferIndex] = dart.notNull(this[_bufferIndex]) + dart.notNull(chunk[dartx.length]);
    }
    static _roundToPowerOf2(v) {
      dart.assert(dart.notNull(v) > 0);
      v = dart.notNull(v) - 1;
      v = (dart.notNull(v) | v[dartx['>>']](1)) >>> 0;
      v = (dart.notNull(v) | v[dartx['>>']](2)) >>> 0;
      v = (dart.notNull(v) | v[dartx['>>']](4)) >>> 0;
      v = (dart.notNull(v) | v[dartx['>>']](8)) >>> 0;
      v = (dart.notNull(v) | v[dartx['>>']](16)) >>> 0;
      v = dart.notNull(v) + 1;
      return v;
    }
    close() {
      this[_callback](this[_buffer][dartx.sublist](0, this[_bufferIndex]));
    }
  };
  dart.setSignature(convert._ByteCallbackSink, {
    constructors: () => ({new: dart.definiteFunctionType(convert._ByteCallbackSink, [dart.functionType(dart.void, [core.List$(core.int)])])}),
    methods: () => ({
      add: dart.definiteFunctionType(dart.void, [core.Iterable$(core.int)]),
      close: dart.definiteFunctionType(dart.void, [])
    }),
    statics: () => ({_roundToPowerOf2: dart.definiteFunctionType(core.int, [core.int])}),
    names: ['_roundToPowerOf2']
  });
  convert._ByteCallbackSink._INITIAL_BUFFER_SIZE = 1024;
  convert._ChunkedConversionCallback$ = dart.generic(T => {
    const _ChunkedConversionCallback = dart.typedef('_ChunkedConversionCallback', () => dart.functionType(dart.void, [T]));
    return _ChunkedConversionCallback;
  });
  convert._ChunkedConversionCallback = _ChunkedConversionCallback();
  convert.ChunkedConverter$ = dart.generic((S, T, S2, T2) => {
    let StreamOfS = () => (StreamOfS = dart.constFn(async.Stream$(S)))();
    let SinkOfT = () => (SinkOfT = dart.constFn(core.Sink$(T)))();
    class ChunkedConverter extends convert.Converter$(S, T) {
      new() {
        super.new();
      }
      bind(other) {
        return super.bind(StreamOfS()._check(other));
      }
      startChunkedConversion(sink) {
        return super.startChunkedConversion(SinkOfT()._check(sink));
      }
    }
    dart.setSignature(ChunkedConverter, {
      constructors: () => ({new: dart.definiteFunctionType(convert.ChunkedConverter$(S, T, S2, T2), [])}),
      methods: () => ({
        bind: dart.definiteFunctionType(dart.dynamic, [dart.dynamic]),
        startChunkedConversion: dart.definiteFunctionType(dart.dynamic, [dart.dynamic])
      })
    });
    return ChunkedConverter;
  });
  convert.ChunkedConverter = ChunkedConverter();
  const _accumulated = Symbol('_accumulated');
  convert._SimpleCallbackSink$ = dart.generic(T => {
    let JSArrayOfT = () => (JSArrayOfT = dart.constFn(_interceptors.JSArray$(T)))();
    class _SimpleCallbackSink extends convert.ChunkedConversionSink$(T) {
      new(callback) {
        this[_accumulated] = JSArrayOfT().of([]);
        this[_callback] = callback;
        super.new();
      }
      add(chunk) {
        T._check(chunk);
        this[_accumulated][dartx.add](chunk);
      }
      close() {
        this[_callback](this[_accumulated]);
      }
    }
    dart.setSignature(_SimpleCallbackSink, {
      constructors: () => ({new: dart.definiteFunctionType(convert._SimpleCallbackSink$(T), [convert._ChunkedConversionCallback$(core.List$(T))])}),
      methods: () => ({
        add: dart.definiteFunctionType(dart.void, [T]),
        close: dart.definiteFunctionType(dart.void, [])
      })
    });
    return _SimpleCallbackSink;
  });
  convert._SimpleCallbackSink = _SimpleCallbackSink();
  const _eventSink = Symbol('_eventSink');
  const _chunkedSink = Symbol('_chunkedSink');
  convert._ConverterStreamEventSink$ = dart.generic((S, T) => {
    let EventSinkOfS = () => (EventSinkOfS = dart.constFn(async.EventSink$(S)))();
    class _ConverterStreamEventSink extends core.Object {
      new(converter, sink) {
        this[_eventSink] = sink;
        this[_chunkedSink] = converter.startChunkedConversion(sink);
      }
      add(o) {
        S._check(o);
        this[_chunkedSink].add(o);
      }
      addError(error, stackTrace) {
        if (stackTrace === void 0) stackTrace = null;
        this[_eventSink].addError(error, stackTrace);
      }
      close() {
        this[_chunkedSink].close();
      }
    }
    dart.addTypeTests(_ConverterStreamEventSink);
    _ConverterStreamEventSink[dart.implements] = () => [EventSinkOfS()];
    dart.setSignature(_ConverterStreamEventSink, {
      constructors: () => ({new: dart.definiteFunctionType(convert._ConverterStreamEventSink$(S, T), [convert.Converter$(S, T), async.EventSink$(T)])}),
      methods: () => ({
        add: dart.definiteFunctionType(dart.void, [S]),
        addError: dart.definiteFunctionType(dart.void, [core.Object], [core.StackTrace]),
        close: dart.definiteFunctionType(dart.void, [])
      })
    });
    return _ConverterStreamEventSink;
  });
  convert._ConverterStreamEventSink = _ConverterStreamEventSink();
  const _second = Symbol('_second');
  const _first$0 = Symbol('_first');
  convert._FusedCodec$ = dart.generic((S, M, T) => {
    class _FusedCodec extends convert.Codec$(S, T) {
      get encoder() {
        return this[_first$0].encoder.fuse(T)(this[_second].encoder);
      }
      get decoder() {
        return this[_second].decoder.fuse(S)(this[_first$0].decoder);
      }
      new(first, second) {
        this[_first$0] = first;
        this[_second] = second;
        super.new();
      }
    }
    dart.setSignature(_FusedCodec, {
      constructors: () => ({new: dart.definiteFunctionType(convert._FusedCodec$(S, M, T), [convert.Codec$(S, M), convert.Codec$(M, T)])})
    });
    return _FusedCodec;
  });
  convert._FusedCodec = _FusedCodec();
  const _codec = Symbol('_codec');
  convert._InvertedCodec$ = dart.generic((T, S) => {
    class _InvertedCodec extends convert.Codec$(T, S) {
      new(codec) {
        this[_codec] = codec;
        super.new();
      }
      get encoder() {
        return this[_codec].decoder;
      }
      get decoder() {
        return this[_codec].encoder;
      }
      get inverted() {
        return this[_codec];
      }
    }
    dart.setSignature(_InvertedCodec, {
      constructors: () => ({new: dart.definiteFunctionType(convert._InvertedCodec$(T, S), [convert.Codec$(S, T)])})
    });
    return _InvertedCodec;
  });
  convert._InvertedCodec = _InvertedCodec();
  convert._FusedConverter$ = dart.generic((S, M, T) => {
    let SinkOfT = () => (SinkOfT = dart.constFn(core.Sink$(T)))();
    class _FusedConverter extends convert.Converter$(S, T) {
      new(first, second) {
        this[_first$0] = first;
        this[_second] = second;
        super.new();
      }
      convert(input) {
        S._check(input);
        return this[_second].convert(this[_first$0].convert(input));
      }
      startChunkedConversion(sink) {
        SinkOfT()._check(sink);
        return this[_first$0].startChunkedConversion(this[_second].startChunkedConversion(sink));
      }
    }
    dart.setSignature(_FusedConverter, {
      constructors: () => ({new: dart.definiteFunctionType(convert._FusedConverter$(S, M, T), [convert.Converter$(S, M), convert.Converter$(M, T)])}),
      methods: () => ({
        convert: dart.definiteFunctionType(T, [S]),
        startChunkedConversion: dart.definiteFunctionType(core.Sink$(S), [core.Sink$(T)])
      })
    });
    return _FusedConverter;
  });
  convert._FusedConverter = _FusedConverter();
  const _name$0 = Symbol('_name');
  let const$29;
  let const$30;
  let const$31;
  let const$32;
  let const$33;
  let const$34;
  let const$35;
  let const$36;
  convert.HtmlEscapeMode = class HtmlEscapeMode extends core.Object {
    _(name, escapeLtGt, escapeQuot, escapeApos, escapeSlash) {
      this[_name$0] = name;
      this.escapeLtGt = escapeLtGt;
      this.escapeQuot = escapeQuot;
      this.escapeApos = escapeApos;
      this.escapeSlash = escapeSlash;
    }
    new(opts) {
      let name = opts && 'name' in opts ? opts.name : "custom";
      let escapeLtGt = opts && 'escapeLtGt' in opts ? opts.escapeLtGt : false;
      let escapeQuot = opts && 'escapeQuot' in opts ? opts.escapeQuot : false;
      let escapeApos = opts && 'escapeApos' in opts ? opts.escapeApos : false;
      let escapeSlash = opts && 'escapeSlash' in opts ? opts.escapeSlash : false;
      this.escapeLtGt = escapeLtGt;
      this.escapeQuot = escapeQuot;
      this.escapeApos = escapeApos;
      this.escapeSlash = escapeSlash;
      this[_name$0] = name;
    }
    toString() {
      return this[_name$0];
    }
  };
  dart.defineNamedConstructor(convert.HtmlEscapeMode, '_');
  dart.setSignature(convert.HtmlEscapeMode, {
    constructors: () => ({
      _: dart.definiteFunctionType(convert.HtmlEscapeMode, [core.String, core.bool, core.bool, core.bool, core.bool]),
      new: dart.definiteFunctionType(convert.HtmlEscapeMode, [], {name: core.String, escapeLtGt: core.bool, escapeQuot: core.bool, escapeApos: core.bool, escapeSlash: core.bool})
    })
  });
  dart.defineLazy(convert.HtmlEscapeMode, {
    get UNKNOWN() {
      return const$33 || (const$33 = dart.const(new convert.HtmlEscapeMode._('unknown', true, true, true, true)));
    },
    get ATTRIBUTE() {
      return const$34 || (const$34 = dart.const(new convert.HtmlEscapeMode._('attribute', true, true, false, false)));
    },
    get SQ_ATTRIBUTE() {
      return const$35 || (const$35 = dart.const(new convert.HtmlEscapeMode._('attribute', true, false, true, false)));
    },
    get ELEMENT() {
      return const$36 || (const$36 = dart.const(new convert.HtmlEscapeMode._('element', true, false, false, false)));
    }
  });
  const _convert = Symbol('_convert');
  convert.HtmlEscape = class HtmlEscape extends convert.Converter$(core.String, core.String) {
    new(mode) {
      if (mode === void 0) mode = convert.HtmlEscapeMode.UNKNOWN;
      this.mode = mode;
      super.new();
    }
    convert(text) {
      let val = this[_convert](text, 0, text[dartx.length]);
      return val == null ? text : val;
    }
    [_convert](text, start, end) {
      let result = null;
      for (let i = start; dart.notNull(i) < dart.notNull(end); i = dart.notNull(i) + 1) {
        let ch = text[dartx.get](i);
        let replacement = null;
        switch (ch) {
          case '&':
          {
            replacement = '&amp;';
            break;
          }
          case '"':
          {
            if (dart.test(this.mode.escapeQuot)) replacement = '&quot;';
            break;
          }
          case "'":
          {
            if (dart.test(this.mode.escapeApos)) replacement = '&#39;';
            break;
          }
          case '<':
          {
            if (dart.test(this.mode.escapeLtGt)) replacement = '&lt;';
            break;
          }
          case '>':
          {
            if (dart.test(this.mode.escapeLtGt)) replacement = '&gt;';
            break;
          }
          case '/':
          {
            if (dart.test(this.mode.escapeSlash)) replacement = '&#47;';
            break;
          }
        }
        if (replacement != null) {
          if (result == null) result = new core.StringBuffer();
          if (dart.notNull(i) > dart.notNull(start)) result.write(text[dartx.substring](start, i));
          result.write(replacement);
          start = dart.notNull(i) + 1;
        }
      }
      if (result == null) return null;
      if (dart.notNull(end) > dart.notNull(start)) result.write(text[dartx.substring](start, end));
      return dart.toString(result);
    }
    startChunkedConversion(sink) {
      if (!convert.StringConversionSink.is(sink)) {
        sink = convert.StringConversionSink.from(sink);
      }
      return new convert._HtmlEscapeSink(this, convert.StringConversionSink._check(sink));
    }
  };
  dart.addSimpleTypeTests(convert.HtmlEscape);
  dart.setSignature(convert.HtmlEscape, {
    constructors: () => ({new: dart.definiteFunctionType(convert.HtmlEscape, [], [convert.HtmlEscapeMode])}),
    methods: () => ({
      convert: dart.definiteFunctionType(core.String, [core.String]),
      [_convert]: dart.definiteFunctionType(core.String, [core.String, core.int, core.int]),
      startChunkedConversion: dart.definiteFunctionType(convert.StringConversionSink, [core.Sink$(core.String)])
    })
  });
  convert.HTML_ESCAPE = dart.const(new convert.HtmlEscape());
  const _escape = Symbol('_escape');
  convert._HtmlEscapeSink = class _HtmlEscapeSink extends convert.StringConversionSinkBase {
    new(escape, sink) {
      this[_escape] = escape;
      this[_sink$] = sink;
    }
    addSlice(chunk, start, end, isLast) {
      let val = this[_escape][_convert](chunk, start, end);
      if (val == null) {
        this[_sink$].addSlice(chunk, start, end, isLast);
      } else {
        this[_sink$].add(val);
        if (dart.test(isLast)) this[_sink$].close();
      }
    }
    close() {
      this[_sink$].close();
    }
  };
  dart.setSignature(convert._HtmlEscapeSink, {
    constructors: () => ({new: dart.definiteFunctionType(convert._HtmlEscapeSink, [convert.HtmlEscape, convert.StringConversionSink])}),
    methods: () => ({
      addSlice: dart.definiteFunctionType(dart.void, [core.String, core.int, core.int, core.bool]),
      close: dart.definiteFunctionType(dart.void, [])
    })
  });
  convert.JsonUnsupportedObjectError = class JsonUnsupportedObjectError extends core.Error {
    new(unsupportedObject, opts) {
      let cause = opts && 'cause' in opts ? opts.cause : null;
      this.unsupportedObject = unsupportedObject;
      this.cause = cause;
      super.new();
    }
    toString() {
      if (this.cause != null) {
        return "Converting object to an encodable object failed.";
      } else {
        return "Converting object did not return an encodable object.";
      }
    }
  };
  dart.setSignature(convert.JsonUnsupportedObjectError, {
    constructors: () => ({new: dart.definiteFunctionType(convert.JsonUnsupportedObjectError, [dart.dynamic], {cause: dart.dynamic})})
  });
  convert.JsonCyclicError = class JsonCyclicError extends convert.JsonUnsupportedObjectError {
    new(object) {
      super.new(object);
    }
    toString() {
      return "Cyclic error in JSON stringify";
    }
  };
  dart.setSignature(convert.JsonCyclicError, {
    constructors: () => ({new: dart.definiteFunctionType(convert.JsonCyclicError, [core.Object])})
  });
  const _toEncodable = Symbol('_toEncodable');
  let const$37;
  let const$38;
  convert.JsonCodec = class JsonCodec extends convert.Codec$(core.Object, core.String) {
    new(opts) {
      let reviver = opts && 'reviver' in opts ? opts.reviver : null;
      let toEncodable = opts && 'toEncodable' in opts ? opts.toEncodable : null;
      this[_reviver] = reviver;
      this[_toEncodable] = toEncodable;
      super.new();
    }
    withReviver(reviver) {
      JsonCodec.prototype.new.call(this, {reviver: reviver});
    }
    decode(source, opts) {
      let reviver = opts && 'reviver' in opts ? opts.reviver : null;
      if (reviver == null) reviver = this[_reviver];
      if (reviver == null) return this.decoder.convert(source);
      return new convert.JsonDecoder(reviver).convert(source);
    }
    encode(value, opts) {
      let toEncodable = opts && 'toEncodable' in opts ? opts.toEncodable : null;
      if (toEncodable == null) toEncodable = this[_toEncodable];
      if (toEncodable == null) return this.encoder.convert(value);
      return new convert.JsonEncoder(toEncodable).convert(value);
    }
    get encoder() {
      if (this[_toEncodable] == null) return const$37 || (const$37 = dart.const(new convert.JsonEncoder()));
      return new convert.JsonEncoder(this[_toEncodable]);
    }
    get decoder() {
      if (this[_reviver] == null) return const$38 || (const$38 = dart.const(new convert.JsonDecoder()));
      return new convert.JsonDecoder(this[_reviver]);
    }
  };
  dart.addSimpleTypeTests(convert.JsonCodec);
  dart.defineNamedConstructor(convert.JsonCodec, 'withReviver');
  dart.setSignature(convert.JsonCodec, {
    constructors: () => ({
      new: dart.definiteFunctionType(convert.JsonCodec, [], {reviver: dynamicAnddynamicTodynamic(), toEncodable: dynamicTodynamic()}),
      withReviver: dart.definiteFunctionType(convert.JsonCodec, [dart.functionType(dart.dynamic, [dart.dynamic, dart.dynamic])])
    }),
    methods: () => ({
      decode: dart.definiteFunctionType(dart.dynamic, [core.String], {reviver: dynamicAnddynamicTodynamic()}),
      encode: dart.definiteFunctionType(core.String, [core.Object], {toEncodable: dynamicTodynamic()})
    })
  });
  convert.JSON = dart.const(new convert.JsonCodec());
  convert._Reviver = dart.typedef('_Reviver', () => dart.functionType(dart.dynamic, [dart.dynamic, dart.dynamic]));
  convert._ToEncodable = dart.typedef('_ToEncodable', () => dart.functionType(dart.dynamic, [dart.dynamic]));
  convert.JsonEncoder = class JsonEncoder extends convert.Converter$(core.Object, core.String) {
    new(toEncodable) {
      if (toEncodable === void 0) toEncodable = null;
      this.indent = null;
      this[_toEncodable] = toEncodable;
      super.new();
    }
    withIndent(indent, toEncodable) {
      if (toEncodable === void 0) toEncodable = null;
      this.indent = indent;
      this[_toEncodable] = toEncodable;
      super.new();
    }
    convert(object) {
      return convert._JsonStringStringifier.stringify(object, this[_toEncodable], this.indent);
    }
    startChunkedConversion(sink) {
      if (!convert.StringConversionSink.is(sink)) {
        sink = convert.StringConversionSink.from(sink);
      } else if (convert._Utf8EncoderSink.is(sink)) {
        return new convert._JsonUtf8EncoderSink(sink[_sink$], this[_toEncodable], convert.JsonUtf8Encoder._utf8Encode(this.indent), convert.JsonUtf8Encoder.DEFAULT_BUFFER_SIZE);
      }
      return new convert._JsonEncoderSink(convert.StringConversionSink._check(sink), this[_toEncodable], this.indent);
    }
    bind(stream) {
      return super.bind(stream);
    }
    fuse(T) {
      return other => {
        if (convert.Utf8Encoder.is(other)) {
          return convert.Converter$(core.Object, T).as(new convert.JsonUtf8Encoder(this.indent, this[_toEncodable]));
        }
        return super.fuse(T)(other);
      };
    }
  };
  dart.addSimpleTypeTests(convert.JsonEncoder);
  dart.defineNamedConstructor(convert.JsonEncoder, 'withIndent');
  dart.setSignature(convert.JsonEncoder, {
    constructors: () => ({
      new: dart.definiteFunctionType(convert.JsonEncoder, [], [dart.functionType(dart.dynamic, [dart.dynamic])]),
      withIndent: dart.definiteFunctionType(convert.JsonEncoder, [core.String], [dart.functionType(dart.dynamic, [dart.dynamic])])
    }),
    methods: () => ({
      convert: dart.definiteFunctionType(core.String, [core.Object]),
      startChunkedConversion: dart.definiteFunctionType(convert.ChunkedConversionSink$(core.Object), [core.Sink$(core.String)]),
      bind: dart.definiteFunctionType(async.Stream$(core.String), [async.Stream$(core.Object)]),
      fuse: dart.definiteFunctionType(T => [convert.Converter$(core.Object, T), [convert.Converter$(core.String, T)]])
    })
  });
  const _indent = Symbol('_indent');
  const _bufferSize = Symbol('_bufferSize');
  convert.JsonUtf8Encoder = class JsonUtf8Encoder extends convert.Converter$(core.Object, core.List$(core.int)) {
    new(indent, toEncodable, bufferSize) {
      if (indent === void 0) indent = null;
      if (toEncodable === void 0) toEncodable = null;
      if (bufferSize === void 0) bufferSize = convert.JsonUtf8Encoder.DEFAULT_BUFFER_SIZE;
      this[_indent] = convert.JsonUtf8Encoder._utf8Encode(indent);
      this[_toEncodable] = toEncodable;
      this[_bufferSize] = bufferSize;
      super.new();
    }
    static _utf8Encode(string) {
      if (string == null) return null;
      if (dart.test(string[dartx.isEmpty])) return typed_data.Uint8List.new(0);
      checkAscii: {
        for (let i = 0; i < dart.notNull(string[dartx.length]); i++) {
          if (dart.notNull(string[dartx.codeUnitAt](i)) >= 128) break checkAscii;
        }
        return string[dartx.codeUnits];
      }
      return convert.UTF8.encode(string);
    }
    convert(object) {
      let bytes = JSArrayOfListOfint().of([]);
      function addChunk(chunk, start, end) {
        if (dart.notNull(start) > 0 || dart.notNull(end) < dart.notNull(chunk[dartx.length])) {
          let length = dart.notNull(end) - dart.notNull(start);
          chunk = typed_data.Uint8List.view(chunk[dartx.buffer], dart.notNull(chunk[dartx.offsetInBytes]) + dart.notNull(start), length);
        }
        bytes[dartx.add](chunk);
      }
      dart.fn(addChunk, Uint8ListAndintAndintTovoid());
      convert._JsonUtf8Stringifier.stringify(object, this[_indent], this[_toEncodable], this[_bufferSize], addChunk);
      if (bytes[dartx.length] == 1) return bytes[dartx.get](0);
      let length = 0;
      for (let i = 0; i < dart.notNull(bytes[dartx.length]); i++) {
        length = dart.notNull(length) + dart.notNull(bytes[dartx.get](i)[dartx.length]);
      }
      let result = typed_data.Uint8List.new(length);
      for (let i = 0, offset = 0; i < dart.notNull(bytes[dartx.length]); i++) {
        let byteList = bytes[dartx.get](i);
        let end = offset + dart.notNull(byteList[dartx.length]);
        result[dartx.setRange](offset, end, byteList);
        offset = end;
      }
      return result;
    }
    startChunkedConversion(sink) {
      let byteSink = null;
      if (convert.ByteConversionSink.is(sink)) {
        byteSink = sink;
      } else {
        byteSink = convert.ByteConversionSink.from(sink);
      }
      return new convert._JsonUtf8EncoderSink(byteSink, this[_toEncodable], this[_indent], this[_bufferSize]);
    }
    bind(stream) {
      return super.bind(stream);
    }
  };
  dart.addSimpleTypeTests(convert.JsonUtf8Encoder);
  dart.setSignature(convert.JsonUtf8Encoder, {
    constructors: () => ({new: dart.definiteFunctionType(convert.JsonUtf8Encoder, [], [core.String, dart.functionType(dart.dynamic, [dart.dynamic]), core.int])}),
    methods: () => ({
      convert: dart.definiteFunctionType(core.List$(core.int), [core.Object]),
      startChunkedConversion: dart.definiteFunctionType(convert.ChunkedConversionSink$(core.Object), [core.Sink$(core.List$(core.int))]),
      bind: dart.definiteFunctionType(async.Stream$(core.List$(core.int)), [async.Stream$(core.Object)])
    }),
    statics: () => ({_utf8Encode: dart.definiteFunctionType(core.List$(core.int), [core.String])}),
    names: ['_utf8Encode']
  });
  convert.JsonUtf8Encoder.DEFAULT_BUFFER_SIZE = 256;
  const _isDone = Symbol('_isDone');
  convert._JsonEncoderSink = class _JsonEncoderSink extends convert.ChunkedConversionSink$(core.Object) {
    new(sink, toEncodable, indent) {
      this[_sink$] = sink;
      this[_toEncodable] = toEncodable;
      this[_indent] = indent;
      this[_isDone] = false;
      super.new();
    }
    add(o) {
      if (dart.test(this[_isDone])) {
        dart.throw(new core.StateError("Only one call to add allowed"));
      }
      this[_isDone] = true;
      let stringSink = this[_sink$].asStringSink();
      convert._JsonStringStringifier.printOn(o, stringSink, this[_toEncodable], this[_indent]);
      stringSink.close();
    }
    close() {}
  };
  dart.addSimpleTypeTests(convert._JsonEncoderSink);
  dart.setSignature(convert._JsonEncoderSink, {
    constructors: () => ({new: dart.definiteFunctionType(convert._JsonEncoderSink, [convert.StringConversionSink, convert._ToEncodable, core.String])}),
    methods: () => ({
      add: dart.definiteFunctionType(dart.void, [core.Object]),
      close: dart.definiteFunctionType(dart.void, [])
    })
  });
  const _addChunk = Symbol('_addChunk');
  convert._JsonUtf8EncoderSink = class _JsonUtf8EncoderSink extends convert.ChunkedConversionSink$(core.Object) {
    new(sink, toEncodable, indent, bufferSize) {
      this[_sink$] = sink;
      this[_toEncodable] = toEncodable;
      this[_indent] = indent;
      this[_bufferSize] = bufferSize;
      this[_isDone] = false;
      super.new();
    }
    [_addChunk](chunk, start, end) {
      this[_sink$].addSlice(chunk, start, end, false);
    }
    add(object) {
      if (dart.test(this[_isDone])) {
        dart.throw(new core.StateError("Only one call to add allowed"));
      }
      this[_isDone] = true;
      convert._JsonUtf8Stringifier.stringify(object, this[_indent], this[_toEncodable], this[_bufferSize], dart.bind(this, _addChunk));
      this[_sink$].close();
    }
    close() {
      if (!dart.test(this[_isDone])) {
        this[_isDone] = true;
        this[_sink$].close();
      }
    }
  };
  dart.addSimpleTypeTests(convert._JsonUtf8EncoderSink);
  dart.setSignature(convert._JsonUtf8EncoderSink, {
    constructors: () => ({new: dart.definiteFunctionType(convert._JsonUtf8EncoderSink, [convert.ByteConversionSink, convert._ToEncodable, core.List$(core.int), core.int])}),
    methods: () => ({
      [_addChunk]: dart.definiteFunctionType(dart.void, [typed_data.Uint8List, core.int, core.int]),
      add: dart.definiteFunctionType(dart.void, [core.Object]),
      close: dart.definiteFunctionType(dart.void, [])
    })
  });
  convert.JsonDecoder = class JsonDecoder extends convert.Converter$(core.String, core.Object) {
    new(reviver) {
      if (reviver === void 0) reviver = null;
      this[_reviver] = reviver;
      super.new();
    }
    convert(input) {
      return convert._parseJson(input, this[_reviver]);
    }
    startChunkedConversion(sink) {
      return new convert._JsonDecoderSink(this[_reviver], sink);
    }
    bind(stream) {
      return super.bind(stream);
    }
  };
  dart.addSimpleTypeTests(convert.JsonDecoder);
  dart.setSignature(convert.JsonDecoder, {
    constructors: () => ({new: dart.definiteFunctionType(convert.JsonDecoder, [], [dart.functionType(dart.dynamic, [dart.dynamic, dart.dynamic])])}),
    methods: () => ({
      convert: dart.definiteFunctionType(dart.dynamic, [core.String]),
      startChunkedConversion: dart.definiteFunctionType(convert.StringConversionSink, [core.Sink$(core.Object)]),
      bind: dart.definiteFunctionType(async.Stream$(core.Object), [async.Stream$(core.String)])
    })
  });
  convert._parseJson = function(source, reviver) {
    if (!(typeof source == 'string')) dart.throw(_js_helper.argumentErrorValue(source));
    let parsed = null;
    try {
      parsed = JSON.parse(source);
    } catch (e) {
      dart.throw(new core.FormatException(String(e)));
    }

    if (reviver == null) {
      return convert._convertJsonToDartLazy(parsed);
    } else {
      return convert._convertJsonToDart(parsed, reviver);
    }
  };
  dart.fn(convert._parseJson, StringAndFnTodynamic());
  convert._defaultToEncodable = function(object) {
    return dart.dsend(object, 'toJson');
  };
  dart.fn(convert._defaultToEncodable, dynamicTodynamic$());
  const _seen = Symbol('_seen');
  const _checkCycle = Symbol('_checkCycle');
  const _removeSeen = Symbol('_removeSeen');
  convert._JsonStringifier = class _JsonStringifier extends core.Object {
    new(toEncodable) {
      this[_seen] = core.List.new();
      this[_toEncodable] = (() => {
        let l = toEncodable;
        return l != null ? l : convert._defaultToEncodable;
      })();
    }
    static hexDigit(x) {
      return dart.notNull(x) < 10 ? 48 + dart.notNull(x) : 87 + dart.notNull(x);
    }
    writeStringContent(s) {
      let offset = 0;
      let length = s[dartx.length];
      for (let i = 0; i < dart.notNull(length); i++) {
        let charCode = s[dartx.codeUnitAt](i);
        if (dart.notNull(charCode) > convert._JsonStringifier.BACKSLASH) continue;
        if (dart.notNull(charCode) < 32) {
          if (i > offset) this.writeStringSlice(s, offset, i);
          offset = i + 1;
          this.writeCharCode(convert._JsonStringifier.BACKSLASH);
          switch (charCode) {
            case convert._JsonStringifier.BACKSPACE:
            {
              this.writeCharCode(convert._JsonStringifier.CHAR_b);
              break;
            }
            case convert._JsonStringifier.TAB:
            {
              this.writeCharCode(convert._JsonStringifier.CHAR_t);
              break;
            }
            case convert._JsonStringifier.NEWLINE:
            {
              this.writeCharCode(convert._JsonStringifier.CHAR_n);
              break;
            }
            case convert._JsonStringifier.FORM_FEED:
            {
              this.writeCharCode(convert._JsonStringifier.CHAR_f);
              break;
            }
            case convert._JsonStringifier.CARRIAGE_RETURN:
            {
              this.writeCharCode(convert._JsonStringifier.CHAR_r);
              break;
            }
            default:
            {
              this.writeCharCode(convert._JsonStringifier.CHAR_u);
              this.writeCharCode(convert._JsonStringifier.CHAR_0);
              this.writeCharCode(convert._JsonStringifier.CHAR_0);
              this.writeCharCode(convert._JsonStringifier.hexDigit(dart.notNull(charCode) >> 4 & 15));
              this.writeCharCode(convert._JsonStringifier.hexDigit(dart.notNull(charCode) & 15));
              break;
            }
          }
        } else if (charCode == convert._JsonStringifier.QUOTE || charCode == convert._JsonStringifier.BACKSLASH) {
          if (i > offset) this.writeStringSlice(s, offset, i);
          offset = i + 1;
          this.writeCharCode(convert._JsonStringifier.BACKSLASH);
          this.writeCharCode(charCode);
        }
      }
      if (offset == 0) {
        this.writeString(s);
      } else if (offset < dart.notNull(length)) {
        this.writeStringSlice(s, offset, length);
      }
    }
    [_checkCycle](object) {
      for (let i = 0; i < dart.notNull(this[_seen][dartx.length]); i++) {
        if (core.identical(object, this[_seen][dartx.get](i))) {
          dart.throw(new convert.JsonCyclicError(object));
        }
      }
      this[_seen][dartx.add](object);
    }
    [_removeSeen](object) {
      dart.assert(!dart.test(this[_seen][dartx.isEmpty]));
      dart.assert(core.identical(this[_seen][dartx.last], object));
      this[_seen][dartx.removeLast]();
    }
    writeObject(object) {
      if (dart.test(this.writeJsonValue(object))) return;
      this[_checkCycle](object);
      try {
        let customJson = dart.dcall(this[_toEncodable], object);
        if (!dart.test(this.writeJsonValue(customJson))) {
          dart.throw(new convert.JsonUnsupportedObjectError(object));
        }
        this[_removeSeen](object);
      } catch (e) {
        dart.throw(new convert.JsonUnsupportedObjectError(object, {cause: e}));
      }

    }
    writeJsonValue(object) {
      if (typeof object == 'number') {
        if (!dart.test(object[dartx.isFinite])) return false;
        this.writeNumber(object);
        return true;
      } else if (core.identical(object, true)) {
        this.writeString('true');
        return true;
      } else if (core.identical(object, false)) {
        this.writeString('false');
        return true;
      } else if (object == null) {
        this.writeString('null');
        return true;
      } else if (typeof object == 'string') {
        this.writeString('"');
        this.writeStringContent(object);
        this.writeString('"');
        return true;
      } else if (core.List.is(object)) {
        this[_checkCycle](object);
        this.writeList(object);
        this[_removeSeen](object);
        return true;
      } else if (core.Map.is(object)) {
        this[_checkCycle](object);
        let success = this.writeMap(object);
        this[_removeSeen](object);
        return success;
      } else {
        return false;
      }
    }
    writeList(list) {
      this.writeString('[');
      if (dart.notNull(list[dartx.length]) > 0) {
        this.writeObject(list[dartx.get](0));
        for (let i = 1; i < dart.notNull(list[dartx.length]); i++) {
          this.writeString(',');
          this.writeObject(list[dartx.get](i));
        }
      }
      this.writeString(']');
    }
    writeMap(map) {
      if (dart.test(map[dartx.isEmpty])) {
        this.writeString("{}");
        return true;
      }
      let keyValueList = core.List.new(dart.notNull(map[dartx.length]) * 2);
      let i = 0;
      let allStringKeys = true;
      map[dartx.forEach](dart.fn((key, value) => {
        if (!(typeof key == 'string')) {
          allStringKeys = false;
        }
        keyValueList[dartx.set](i++, key);
        keyValueList[dartx.set](i++, value);
      }, dynamicAnddynamicTovoid()));
      if (!allStringKeys) return false;
      this.writeString('{');
      let separator = '"';
      for (let i = 0; i < dart.notNull(keyValueList[dartx.length]); i = i + 2) {
        this.writeString(separator);
        separator = ',"';
        this.writeStringContent(core.String._check(keyValueList[dartx.get](i)));
        this.writeString('":');
        this.writeObject(keyValueList[dartx.get](i + 1));
      }
      this.writeString('}');
      return true;
    }
  };
  dart.setSignature(convert._JsonStringifier, {
    constructors: () => ({new: dart.definiteFunctionType(convert._JsonStringifier, [dart.functionType(dart.dynamic, [dart.dynamic])])}),
    methods: () => ({
      writeStringContent: dart.definiteFunctionType(dart.void, [core.String]),
      [_checkCycle]: dart.definiteFunctionType(dart.void, [dart.dynamic]),
      [_removeSeen]: dart.definiteFunctionType(dart.void, [dart.dynamic]),
      writeObject: dart.definiteFunctionType(dart.void, [dart.dynamic]),
      writeJsonValue: dart.definiteFunctionType(core.bool, [dart.dynamic]),
      writeList: dart.definiteFunctionType(dart.void, [core.List]),
      writeMap: dart.definiteFunctionType(core.bool, [core.Map])
    }),
    statics: () => ({hexDigit: dart.definiteFunctionType(core.int, [core.int])}),
    names: ['hexDigit']
  });
  convert._JsonStringifier.BACKSPACE = 8;
  convert._JsonStringifier.TAB = 9;
  convert._JsonStringifier.NEWLINE = 10;
  convert._JsonStringifier.CARRIAGE_RETURN = 13;
  convert._JsonStringifier.FORM_FEED = 12;
  convert._JsonStringifier.QUOTE = 34;
  convert._JsonStringifier.CHAR_0 = 48;
  convert._JsonStringifier.BACKSLASH = 92;
  convert._JsonStringifier.CHAR_b = 98;
  convert._JsonStringifier.CHAR_f = 102;
  convert._JsonStringifier.CHAR_n = 110;
  convert._JsonStringifier.CHAR_r = 114;
  convert._JsonStringifier.CHAR_t = 116;
  convert._JsonStringifier.CHAR_u = 117;
  const _indentLevel = Symbol('_indentLevel');
  convert._JsonPrettyPrintMixin = class _JsonPrettyPrintMixin extends core.Object {
    new() {
      this[_indentLevel] = 0;
    }
    writeList(list) {
      if (dart.test(list[dartx.isEmpty])) {
        this.writeString('[]');
      } else {
        this.writeString('[\n');
        this[_indentLevel] = dart.notNull(this[_indentLevel]) + 1;
        this.writeIndentation(this[_indentLevel]);
        this.writeObject(list[dartx.get](0));
        for (let i = 1; i < dart.notNull(list[dartx.length]); i++) {
          this.writeString(',\n');
          this.writeIndentation(this[_indentLevel]);
          this.writeObject(list[dartx.get](i));
        }
        this.writeString('\n');
        this[_indentLevel] = dart.notNull(this[_indentLevel]) - 1;
        this.writeIndentation(this[_indentLevel]);
        this.writeString(']');
      }
    }
    writeMap(map) {
      if (dart.test(map[dartx.isEmpty])) {
        this.writeString("{}");
        return true;
      }
      let keyValueList = core.List.new(dart.notNull(map[dartx.length]) * 2);
      let i = 0;
      let allStringKeys = true;
      map[dartx.forEach](dart.fn((key, value) => {
        if (!(typeof key == 'string')) {
          allStringKeys = false;
        }
        keyValueList[dartx.set](i++, key);
        keyValueList[dartx.set](i++, value);
      }, dynamicAnddynamicTovoid()));
      if (!allStringKeys) return false;
      this.writeString('{\n');
      this[_indentLevel] = dart.notNull(this[_indentLevel]) + 1;
      let separator = "";
      for (let i = 0; i < dart.notNull(keyValueList[dartx.length]); i = i + 2) {
        this.writeString(separator);
        separator = ",\n";
        this.writeIndentation(this[_indentLevel]);
        this.writeString('"');
        this.writeStringContent(core.String._check(keyValueList[dartx.get](i)));
        this.writeString('": ');
        this.writeObject(keyValueList[dartx.get](i + 1));
      }
      this.writeString('\n');
      this[_indentLevel] = dart.notNull(this[_indentLevel]) - 1;
      this.writeIndentation(this[_indentLevel]);
      this.writeString('}');
      return true;
    }
  };
  convert._JsonPrettyPrintMixin[dart.implements] = () => [convert._JsonStringifier];
  dart.setSignature(convert._JsonPrettyPrintMixin, {
    methods: () => ({
      writeList: dart.definiteFunctionType(dart.void, [core.List]),
      writeMap: dart.definiteFunctionType(core.bool, [core.Map])
    })
  });
  convert._JsonStringStringifier = class _JsonStringStringifier extends convert._JsonStringifier {
    new(sink, _toEncodable) {
      this[_sink$] = sink;
      super.new(dynamicTodynamic()._check(_toEncodable));
    }
    static stringify(object, toEncodable, indent) {
      let output = new core.StringBuffer();
      convert._JsonStringStringifier.printOn(object, output, toEncodable, indent);
      return output.toString();
    }
    static printOn(object, output, toEncodable, indent) {
      let stringifier = null;
      if (indent == null) {
        stringifier = new convert._JsonStringStringifier(output, toEncodable);
      } else {
        stringifier = new convert._JsonStringStringifierPretty(output, toEncodable, indent);
      }
      dart.dsend(stringifier, 'writeObject', object);
    }
    writeNumber(number) {
      this[_sink$].write(dart.toString(number));
    }
    writeString(string) {
      this[_sink$].write(string);
    }
    writeStringSlice(string, start, end) {
      this[_sink$].write(string[dartx.substring](start, end));
    }
    writeCharCode(charCode) {
      this[_sink$].writeCharCode(charCode);
    }
  };
  dart.setSignature(convert._JsonStringStringifier, {
    constructors: () => ({new: dart.definiteFunctionType(convert._JsonStringStringifier, [core.StringSink, dart.dynamic])}),
    methods: () => ({
      writeNumber: dart.definiteFunctionType(dart.void, [core.num]),
      writeString: dart.definiteFunctionType(dart.void, [core.String]),
      writeStringSlice: dart.definiteFunctionType(dart.void, [core.String, core.int, core.int]),
      writeCharCode: dart.definiteFunctionType(dart.void, [core.int])
    }),
    statics: () => ({
      stringify: dart.definiteFunctionType(core.String, [dart.dynamic, dart.functionType(dart.dynamic, [dart.dynamic]), core.String]),
      printOn: dart.definiteFunctionType(dart.void, [dart.dynamic, core.StringSink, dart.functionType(dart.dynamic, [dart.dynamic]), core.String])
    }),
    names: ['stringify', 'printOn']
  });
  convert._JsonStringStringifierPretty = class _JsonStringStringifierPretty extends dart.mixin(convert._JsonStringStringifier, convert._JsonPrettyPrintMixin) {
    new(sink, toEncodable, indent) {
      this[_indent] = indent;
      super.new(sink, toEncodable);
    }
    writeIndentation(count) {
      for (let i = 0; i < dart.notNull(count); i++)
        this.writeString(this[_indent]);
    }
  };
  dart.setSignature(convert._JsonStringStringifierPretty, {
    constructors: () => ({new: dart.definiteFunctionType(convert._JsonStringStringifierPretty, [core.StringSink, dart.functionType(dart.dynamic, [dart.dynamic]), core.String])}),
    methods: () => ({writeIndentation: dart.definiteFunctionType(dart.void, [core.int])})
  });
  convert._AddChunk = dart.typedef('_AddChunk', () => dart.functionType(dart.void, [typed_data.Uint8List, core.int, core.int]));
  convert._JsonUtf8Stringifier = class _JsonUtf8Stringifier extends convert._JsonStringifier {
    new(toEncodable, bufferSize, addChunk) {
      this.addChunk = addChunk;
      this.bufferSize = bufferSize;
      this.buffer = typed_data.Uint8List.new(bufferSize);
      this.index = 0;
      super.new(toEncodable);
    }
    static stringify(object, indent, toEncodable, bufferSize, addChunk) {
      let stringifier = null;
      if (indent != null) {
        stringifier = new convert._JsonUtf8StringifierPretty(toEncodable, indent, bufferSize, addChunk);
      } else {
        stringifier = new convert._JsonUtf8Stringifier(toEncodable, bufferSize, addChunk);
      }
      stringifier.writeObject(object);
      stringifier.flush();
    }
    flush() {
      if (dart.notNull(this.index) > 0) {
        this.addChunk(this.buffer, 0, this.index);
      }
      this.buffer = null;
      this.index = 0;
    }
    writeNumber(number) {
      this.writeAsciiString(dart.toString(number));
    }
    writeAsciiString(string) {
      for (let i = 0; i < dart.notNull(string[dartx.length]); i++) {
        let char = string[dartx.codeUnitAt](i);
        dart.assert(dart.notNull(char) <= 127);
        this.writeByte(char);
      }
    }
    writeString(string) {
      this.writeStringSlice(string, 0, string[dartx.length]);
    }
    writeStringSlice(string, start, end) {
      for (let i = start; dart.notNull(i) < dart.notNull(end); i = dart.notNull(i) + 1) {
        let char = string[dartx.codeUnitAt](i);
        if (dart.notNull(char) <= 127) {
          this.writeByte(char);
        } else {
          if ((dart.notNull(char) & 64512) == 55296 && dart.notNull(i) + 1 < dart.notNull(end)) {
            let nextChar = string[dartx.codeUnitAt](dart.notNull(i) + 1);
            if ((dart.notNull(nextChar) & 64512) == 56320) {
              char = 65536 + ((dart.notNull(char) & 1023) << 10) + (dart.notNull(nextChar) & 1023);
              this.writeFourByteCharCode(char);
              i = dart.notNull(i) + 1;
              continue;
            }
          }
          this.writeMultiByteCharCode(char);
        }
      }
    }
    writeCharCode(charCode) {
      if (dart.notNull(charCode) <= 127) {
        this.writeByte(charCode);
        return;
      }
      this.writeMultiByteCharCode(charCode);
    }
    writeMultiByteCharCode(charCode) {
      if (dart.notNull(charCode) <= 2047) {
        this.writeByte((192 | charCode[dartx['>>']](6)) >>> 0);
        this.writeByte(128 | dart.notNull(charCode) & 63);
        return;
      }
      if (dart.notNull(charCode) <= 65535) {
        this.writeByte((224 | charCode[dartx['>>']](12)) >>> 0);
        this.writeByte(128 | dart.notNull(charCode) >> 6 & 63);
        this.writeByte(128 | dart.notNull(charCode) & 63);
        return;
      }
      this.writeFourByteCharCode(charCode);
    }
    writeFourByteCharCode(charCode) {
      dart.assert(dart.notNull(charCode) <= 1114111);
      this.writeByte((240 | charCode[dartx['>>']](18)) >>> 0);
      this.writeByte(128 | dart.notNull(charCode) >> 12 & 63);
      this.writeByte(128 | dart.notNull(charCode) >> 6 & 63);
      this.writeByte(128 | dart.notNull(charCode) & 63);
    }
    writeByte(byte) {
      dart.assert(dart.notNull(byte) <= 255);
      if (this.index == this.buffer[dartx.length]) {
        this.addChunk(this.buffer, 0, this.index);
        this.buffer = typed_data.Uint8List.new(this.bufferSize);
        this.index = 0;
      }
      this.buffer[dartx.set]((() => {
        let x = this.index;
        this.index = dart.notNull(x) + 1;
        return x;
      })(), byte);
    }
  };
  dart.setSignature(convert._JsonUtf8Stringifier, {
    constructors: () => ({new: dart.definiteFunctionType(convert._JsonUtf8Stringifier, [dart.functionType(dart.dynamic, [dart.dynamic]), core.int, convert._AddChunk])}),
    methods: () => ({
      flush: dart.definiteFunctionType(dart.void, []),
      writeNumber: dart.definiteFunctionType(dart.void, [core.num]),
      writeAsciiString: dart.definiteFunctionType(dart.void, [core.String]),
      writeString: dart.definiteFunctionType(dart.void, [core.String]),
      writeStringSlice: dart.definiteFunctionType(dart.void, [core.String, core.int, core.int]),
      writeCharCode: dart.definiteFunctionType(dart.void, [core.int]),
      writeMultiByteCharCode: dart.definiteFunctionType(dart.void, [core.int]),
      writeFourByteCharCode: dart.definiteFunctionType(dart.void, [core.int]),
      writeByte: dart.definiteFunctionType(dart.void, [core.int])
    }),
    statics: () => ({stringify: dart.definiteFunctionType(dart.void, [core.Object, core.List$(core.int), dart.functionType(dart.dynamic, [dart.dynamic]), core.int, dart.functionType(dart.void, [typed_data.Uint8List, core.int, core.int])])}),
    names: ['stringify']
  });
  convert._JsonUtf8StringifierPretty = class _JsonUtf8StringifierPretty extends dart.mixin(convert._JsonUtf8Stringifier, convert._JsonPrettyPrintMixin) {
    new(toEncodable, indent, bufferSize, addChunk) {
      this.indent = indent;
      super.new(toEncodable, core.int._check(bufferSize), addChunk);
    }
    writeIndentation(count) {
      let indent = this.indent;
      let indentLength = indent[dartx.length];
      if (indentLength == 1) {
        let char = indent[dartx.get](0);
        while (dart.notNull(count) > 0) {
          this.writeByte(char);
          count = dart.notNull(count) - 1;
        }
        return;
      }
      while (dart.notNull(count) > 0) {
        count = dart.notNull(count) - 1;
        let end = dart.notNull(this.index) + dart.notNull(indentLength);
        if (end <= dart.notNull(this.buffer[dartx.length])) {
          this.buffer[dartx.setRange](this.index, end, indent);
          this.index = end;
        } else {
          for (let i = 0; i < dart.notNull(indentLength); i++) {
            this.writeByte(indent[dartx.get](i));
          }
        }
      }
    }
  };
  dart.setSignature(convert._JsonUtf8StringifierPretty, {
    constructors: () => ({new: dart.definiteFunctionType(convert._JsonUtf8StringifierPretty, [dart.functionType(dart.dynamic, [dart.dynamic]), core.List$(core.int), dart.dynamic, dart.functionType(dart.void, [typed_data.Uint8List, core.int, core.int])])}),
    methods: () => ({writeIndentation: dart.definiteFunctionType(dart.void, [core.int])})
  });
  let const$39;
  let const$40;
  let const$41;
  let const$42;
  let const$43;
  convert.Latin1Codec = class Latin1Codec extends convert.Encoding {
    new(opts) {
      let allowInvalid = opts && 'allowInvalid' in opts ? opts.allowInvalid : false;
      this[_allowInvalid] = allowInvalid;
      super.new();
    }
    get name() {
      return "iso-8859-1";
    }
    decode(bytes, opts) {
      let allowInvalid = opts && 'allowInvalid' in opts ? opts.allowInvalid : null;
      if (allowInvalid == null) allowInvalid = this[_allowInvalid];
      if (dart.test(allowInvalid)) {
        return (const$39 || (const$39 = dart.const(new convert.Latin1Decoder({allowInvalid: true})))).convert(bytes);
      } else {
        return (const$40 || (const$40 = dart.const(new convert.Latin1Decoder({allowInvalid: false})))).convert(bytes);
      }
    }
    get encoder() {
      return const$41 || (const$41 = dart.const(new convert.Latin1Encoder()));
    }
    get decoder() {
      return dart.test(this[_allowInvalid]) ? const$42 || (const$42 = dart.const(new convert.Latin1Decoder({allowInvalid: true}))) : const$43 || (const$43 = dart.const(new convert.Latin1Decoder({allowInvalid: false})));
    }
  };
  dart.setSignature(convert.Latin1Codec, {
    constructors: () => ({new: dart.definiteFunctionType(convert.Latin1Codec, [], {allowInvalid: core.bool})}),
    methods: () => ({decode: dart.definiteFunctionType(core.String, [core.List$(core.int)], {allowInvalid: core.bool})})
  });
  convert.LATIN1 = dart.const(new convert.Latin1Codec());
  convert._LATIN1_MASK = 255;
  convert.Latin1Encoder = class Latin1Encoder extends convert._UnicodeSubsetEncoder {
    new() {
      super.new(convert._LATIN1_MASK);
    }
  };
  dart.setSignature(convert.Latin1Encoder, {
    constructors: () => ({new: dart.definiteFunctionType(convert.Latin1Encoder, [])})
  });
  convert.Latin1Decoder = class Latin1Decoder extends convert._UnicodeSubsetDecoder {
    new(opts) {
      let allowInvalid = opts && 'allowInvalid' in opts ? opts.allowInvalid : false;
      super.new(allowInvalid, convert._LATIN1_MASK);
    }
    startChunkedConversion(sink) {
      let stringSink = null;
      if (convert.StringConversionSink.is(sink)) {
        stringSink = sink;
      } else {
        stringSink = convert.StringConversionSink.from(sink);
      }
      if (!dart.test(this[_allowInvalid])) return new convert._Latin1DecoderSink(stringSink);
      return new convert._Latin1AllowInvalidDecoderSink(stringSink);
    }
  };
  dart.setSignature(convert.Latin1Decoder, {
    constructors: () => ({new: dart.definiteFunctionType(convert.Latin1Decoder, [], {allowInvalid: core.bool})}),
    methods: () => ({startChunkedConversion: dart.definiteFunctionType(convert.ByteConversionSink, [core.Sink$(core.String)])})
  });
  const _addSliceToSink = Symbol('_addSliceToSink');
  convert._Latin1DecoderSink = class _Latin1DecoderSink extends convert.ByteConversionSinkBase {
    new(sink) {
      this[_sink$] = sink;
    }
    close() {
      this[_sink$].close();
      this[_sink$] = null;
    }
    add(source) {
      this.addSlice(source, 0, source[dartx.length], false);
    }
    [_addSliceToSink](source, start, end, isLast) {
      this[_sink$].add(core.String.fromCharCodes(source, start, end));
      if (dart.test(isLast)) this.close();
    }
    addSlice(source, start, end, isLast) {
      end = core.RangeError.checkValidRange(start, end, source[dartx.length]);
      if (start == end) return;
      if (!typed_data.Uint8List.is(source)) {
        convert._Latin1DecoderSink._checkValidLatin1(source, start, end);
      }
      this[_addSliceToSink](source, start, end, isLast);
    }
    static _checkValidLatin1(source, start, end) {
      let mask = 0;
      for (let i = start; dart.notNull(i) < dart.notNull(end); i = dart.notNull(i) + 1) {
        mask = (dart.notNull(mask) | dart.notNull(source[dartx.get](i))) >>> 0;
      }
      if (dart.notNull(mask) >= 0 && dart.notNull(mask) <= convert._LATIN1_MASK) {
        return;
      }
      convert._Latin1DecoderSink._reportInvalidLatin1(source, start, end);
    }
    static _reportInvalidLatin1(source, start, end) {
      for (let i = start; dart.notNull(i) < dart.notNull(end); i = dart.notNull(i) + 1) {
        let char = source[dartx.get](i);
        if (dart.notNull(char) < 0 || dart.notNull(char) > convert._LATIN1_MASK) {
          dart.throw(new core.FormatException("Source contains non-Latin-1 characters.", source, i));
        }
      }
      dart.assert(false);
    }
  };
  dart.setSignature(convert._Latin1DecoderSink, {
    constructors: () => ({new: dart.definiteFunctionType(convert._Latin1DecoderSink, [convert.StringConversionSink])}),
    methods: () => ({
      close: dart.definiteFunctionType(dart.void, []),
      add: dart.definiteFunctionType(dart.void, [core.List$(core.int)]),
      [_addSliceToSink]: dart.definiteFunctionType(dart.void, [core.List$(core.int), core.int, core.int, core.bool])
    }),
    statics: () => ({
      _checkValidLatin1: dart.definiteFunctionType(dart.void, [core.List$(core.int), core.int, core.int]),
      _reportInvalidLatin1: dart.definiteFunctionType(dart.void, [core.List$(core.int), core.int, core.int])
    }),
    names: ['_checkValidLatin1', '_reportInvalidLatin1']
  });
  let const$44;
  convert._Latin1AllowInvalidDecoderSink = class _Latin1AllowInvalidDecoderSink extends convert._Latin1DecoderSink {
    new(sink) {
      super.new(sink);
    }
    addSlice(source, start, end, isLast) {
      core.RangeError.checkValidRange(start, end, source[dartx.length]);
      for (let i = start; dart.notNull(i) < dart.notNull(end); i = dart.notNull(i) + 1) {
        let char = source[dartx.get](i);
        if (dart.notNull(char) > convert._LATIN1_MASK || dart.notNull(char) < 0) {
          if (dart.notNull(i) > dart.notNull(start)) this[_addSliceToSink](source, start, i, false);
          this[_addSliceToSink](const$44 || (const$44 = dart.constList([65533], core.int)), 0, 1, false);
          start = dart.notNull(i) + 1;
        }
      }
      if (dart.notNull(start) < dart.notNull(end)) {
        this[_addSliceToSink](source, start, end, isLast);
      }
      if (dart.test(isLast)) {
        this.close();
      }
    }
  };
  dart.setSignature(convert._Latin1AllowInvalidDecoderSink, {
    constructors: () => ({new: dart.definiteFunctionType(convert._Latin1AllowInvalidDecoderSink, [convert.StringConversionSink])})
  });
  convert._LF = 10;
  convert._CR = 13;
  convert.LineSplitter = class LineSplitter extends core.Object {
    new() {
    }
    static split(lines, start, end) {
      return dart.syncStar(function*(lines, start, end) {
        if (start === void 0) start = 0;
        if (end === void 0) end = null;
        end = core.RangeError.checkValidRange(start, end, lines[dartx.length]);
        let sliceStart = start;
        let char = 0;
        for (let i = start; dart.notNull(i) < dart.notNull(end); i = dart.notNull(i) + 1) {
          let previousChar = char;
          char = lines[dartx.codeUnitAt](i);
          if (char != convert._CR) {
            if (char != convert._LF) continue;
            if (previousChar == convert._CR) {
              sliceStart = dart.notNull(i) + 1;
              continue;
            }
          }
          yield lines[dartx.substring](sliceStart, i);
          sliceStart = dart.notNull(i) + 1;
        }
        if (dart.notNull(sliceStart) < dart.notNull(end)) {
          yield lines[dartx.substring](sliceStart, end);
        }
      }, core.String, lines, start, end);
    }
    convert(data) {
      let lines = JSArrayOfString().of([]);
      let end = data[dartx.length];
      let sliceStart = 0;
      let char = 0;
      for (let i = 0; i < dart.notNull(end); i++) {
        let previousChar = char;
        char = data[dartx.codeUnitAt](i);
        if (char != convert._CR) {
          if (char != convert._LF) continue;
          if (previousChar == convert._CR) {
            sliceStart = i + 1;
            continue;
          }
        }
        lines[dartx.add](data[dartx.substring](sliceStart, i));
        sliceStart = i + 1;
      }
      if (sliceStart < dart.notNull(end)) {
        lines[dartx.add](data[dartx.substring](sliceStart, end));
      }
      return lines;
    }
    startChunkedConversion(sink) {
      if (!convert.StringConversionSink.is(sink)) {
        sink = convert.StringConversionSink.from(sink);
      }
      return new convert._LineSplitterSink(convert.StringConversionSink._check(sink));
    }
    bind(stream) {
      return StreamOfString().eventTransformed(stream, dart.fn(sink => new convert._LineSplitterEventSink(sink), EventSinkOfStringTo_LineSplitterEventSink()));
    }
  };
  convert.LineSplitter[dart.implements] = () => [StreamTransformerOfString$String()];
  dart.setSignature(convert.LineSplitter, {
    constructors: () => ({new: dart.definiteFunctionType(convert.LineSplitter, [])}),
    methods: () => ({
      convert: dart.definiteFunctionType(core.List$(core.String), [core.String]),
      startChunkedConversion: dart.definiteFunctionType(convert.StringConversionSink, [core.Sink$(core.String)]),
      bind: dart.definiteFunctionType(async.Stream$(core.String), [async.Stream$(core.String)])
    }),
    statics: () => ({split: dart.definiteFunctionType(core.Iterable$(core.String), [core.String], [core.int, core.int])}),
    names: ['split']
  });
  const _carry = Symbol('_carry');
  const _skipLeadingLF = Symbol('_skipLeadingLF');
  const _addLines = Symbol('_addLines');
  convert._LineSplitterSink = class _LineSplitterSink extends convert.StringConversionSinkBase {
    new(sink) {
      this[_sink$] = sink;
      this[_carry] = null;
      this[_skipLeadingLF] = false;
    }
    addSlice(chunk, start, end, isLast) {
      end = core.RangeError.checkValidRange(start, end, chunk[dartx.length]);
      if (dart.notNull(start) >= dart.notNull(end)) {
        if (dart.test(isLast)) this.close();
        return;
      }
      if (this[_carry] != null) {
        dart.assert(!dart.test(this[_skipLeadingLF]));
        chunk = dart.notNull(this[_carry]) + dart.notNull(chunk[dartx.substring](start, end));
        start = 0;
        end = chunk[dartx.length];
        this[_carry] = null;
      } else if (dart.test(this[_skipLeadingLF])) {
        if (chunk[dartx.codeUnitAt](start) == convert._LF) {
          start = dart.notNull(start) + 1;
        }
        this[_skipLeadingLF] = false;
      }
      this[_addLines](chunk, start, end);
      if (dart.test(isLast)) this.close();
    }
    close() {
      if (this[_carry] != null) {
        this[_sink$].add(this[_carry]);
        this[_carry] = null;
      }
      this[_sink$].close();
    }
    [_addLines](lines, start, end) {
      let sliceStart = start;
      let char = 0;
      for (let i = start; dart.notNull(i) < dart.notNull(end); i = dart.notNull(i) + 1) {
        let previousChar = char;
        char = lines[dartx.codeUnitAt](i);
        if (char != convert._CR) {
          if (char != convert._LF) continue;
          if (previousChar == convert._CR) {
            sliceStart = dart.notNull(i) + 1;
            continue;
          }
        }
        this[_sink$].add(lines[dartx.substring](sliceStart, i));
        sliceStart = dart.notNull(i) + 1;
      }
      if (dart.notNull(sliceStart) < dart.notNull(end)) {
        this[_carry] = lines[dartx.substring](sliceStart, end);
      } else {
        this[_skipLeadingLF] = char == convert._CR;
      }
    }
  };
  dart.setSignature(convert._LineSplitterSink, {
    constructors: () => ({new: dart.definiteFunctionType(convert._LineSplitterSink, [convert.StringConversionSink])}),
    methods: () => ({
      addSlice: dart.definiteFunctionType(dart.void, [core.String, core.int, core.int, core.bool]),
      close: dart.definiteFunctionType(dart.void, []),
      [_addLines]: dart.definiteFunctionType(dart.void, [core.String, core.int, core.int])
    })
  });
  convert._LineSplitterEventSink = class _LineSplitterEventSink extends convert._LineSplitterSink {
    new(eventSink) {
      this[_eventSink] = eventSink;
      super.new(convert.StringConversionSink.from(eventSink));
    }
    addError(o, stackTrace) {
      if (stackTrace === void 0) stackTrace = null;
      this[_eventSink].addError(o, stackTrace);
    }
  };
  convert._LineSplitterEventSink[dart.implements] = () => [EventSinkOfString()];
  dart.setSignature(convert._LineSplitterEventSink, {
    constructors: () => ({new: dart.definiteFunctionType(convert._LineSplitterEventSink, [async.EventSink$(core.String)])}),
    methods: () => ({addError: dart.definiteFunctionType(dart.void, [core.Object], [core.StackTrace])})
  });
  convert.StringConversionSink = class StringConversionSink extends convert.ChunkedConversionSink$(core.String) {
    new() {
      super.new();
    }
    static withCallback(callback) {
      return new convert._StringCallbackSink(callback);
    }
    static from(sink) {
      return new convert._StringAdapterSink(sink);
    }
    static fromStringSink(sink) {
      return new convert._StringSinkConversionSink(sink);
    }
  };
  dart.addSimpleTypeTests(convert.StringConversionSink);
  dart.setSignature(convert.StringConversionSink, {
    constructors: () => ({
      new: dart.definiteFunctionType(convert.StringConversionSink, []),
      withCallback: dart.definiteFunctionType(convert.StringConversionSink, [dart.functionType(dart.void, [core.String])]),
      from: dart.definiteFunctionType(convert.StringConversionSink, [core.Sink$(core.String)]),
      fromStringSink: dart.definiteFunctionType(convert.StringConversionSink, [core.StringSink])
    })
  });
  core.StringSink = class StringSink extends core.Object {};
  convert.ClosableStringSink = class ClosableStringSink extends core.StringSink {
    static fromStringSink(sink, onClose) {
      return new convert._ClosableStringSink(sink, onClose);
    }
  };
  dart.setSignature(convert.ClosableStringSink, {
    constructors: () => ({fromStringSink: dart.definiteFunctionType(convert.ClosableStringSink, [core.StringSink, dart.functionType(dart.void, [])])})
  });
  convert._StringSinkCloseCallback = dart.typedef('_StringSinkCloseCallback', () => dart.functionType(dart.void, []));
  convert._ClosableStringSink = class _ClosableStringSink extends core.Object {
    new(sink, callback) {
      this[_sink$] = sink;
      this[_callback] = callback;
    }
    close() {
      this[_callback]();
    }
    writeCharCode(charCode) {
      this[_sink$].writeCharCode(charCode);
    }
    write(o) {
      this[_sink$].write(o);
    }
    writeln(o) {
      if (o === void 0) o = "";
      this[_sink$].writeln(o);
    }
    writeAll(objects, separator) {
      if (separator === void 0) separator = "";
      this[_sink$].writeAll(objects, separator);
    }
  };
  convert._ClosableStringSink[dart.implements] = () => [convert.ClosableStringSink];
  dart.setSignature(convert._ClosableStringSink, {
    constructors: () => ({new: dart.definiteFunctionType(convert._ClosableStringSink, [core.StringSink, convert._StringSinkCloseCallback])}),
    methods: () => ({
      close: dart.definiteFunctionType(dart.void, []),
      writeCharCode: dart.definiteFunctionType(dart.void, [core.int]),
      write: dart.definiteFunctionType(dart.void, [core.Object]),
      writeln: dart.definiteFunctionType(dart.void, [], [core.Object]),
      writeAll: dart.definiteFunctionType(dart.void, [core.Iterable], [core.String])
    })
  });
  const _flush = Symbol('_flush');
  convert._StringConversionSinkAsStringSinkAdapter = class _StringConversionSinkAsStringSinkAdapter extends core.Object {
    new(chunkedSink) {
      this[_chunkedSink] = chunkedSink;
      this[_buffer] = new core.StringBuffer();
    }
    close() {
      if (dart.test(this[_buffer].isNotEmpty)) this[_flush]();
      this[_chunkedSink].close();
    }
    writeCharCode(charCode) {
      this[_buffer].writeCharCode(charCode);
      if (dart.notNull(this[_buffer].length) > convert._StringConversionSinkAsStringSinkAdapter._MIN_STRING_SIZE) this[_flush]();
    }
    write(o) {
      if (dart.test(this[_buffer].isNotEmpty)) this[_flush]();
      this[_chunkedSink].add(dart.toString(o));
    }
    writeln(o) {
      if (o === void 0) o = "";
      this[_buffer].writeln(o);
      if (dart.notNull(this[_buffer].length) > convert._StringConversionSinkAsStringSinkAdapter._MIN_STRING_SIZE) this[_flush]();
    }
    writeAll(objects, separator) {
      if (separator === void 0) separator = "";
      if (dart.test(this[_buffer].isNotEmpty)) this[_flush]();
      let iterator = objects[dartx.iterator];
      if (!dart.test(iterator.moveNext())) return;
      if (dart.test(separator[dartx.isEmpty])) {
        do {
          this[_chunkedSink].add(dart.toString(iterator.current));
        } while (dart.test(iterator.moveNext()));
      } else {
        this[_chunkedSink].add(dart.toString(iterator.current));
        while (dart.test(iterator.moveNext())) {
          this.write(separator);
          this[_chunkedSink].add(dart.toString(iterator.current));
        }
      }
    }
    [_flush]() {
      let accumulated = dart.toString(this[_buffer]);
      this[_buffer].clear();
      this[_chunkedSink].add(accumulated);
    }
  };
  convert._StringConversionSinkAsStringSinkAdapter[dart.implements] = () => [convert.ClosableStringSink];
  dart.setSignature(convert._StringConversionSinkAsStringSinkAdapter, {
    constructors: () => ({new: dart.definiteFunctionType(convert._StringConversionSinkAsStringSinkAdapter, [convert.StringConversionSink])}),
    methods: () => ({
      close: dart.definiteFunctionType(dart.void, []),
      writeCharCode: dart.definiteFunctionType(dart.void, [core.int]),
      write: dart.definiteFunctionType(dart.void, [core.Object]),
      writeln: dart.definiteFunctionType(dart.void, [], [core.Object]),
      writeAll: dart.definiteFunctionType(dart.void, [core.Iterable], [core.String]),
      [_flush]: dart.definiteFunctionType(dart.void, [])
    })
  });
  convert._StringConversionSinkAsStringSinkAdapter._MIN_STRING_SIZE = 16;
  convert._StringCallbackSink = class _StringCallbackSink extends convert._StringSinkConversionSink {
    new(callback) {
      this[_callback] = callback;
      super.new(new core.StringBuffer());
    }
    close() {
      let buffer = core.StringBuffer._check(this[_stringSink]);
      let accumulated = dart.toString(buffer);
      buffer.clear();
      this[_callback](accumulated);
    }
    asUtf8Sink(allowMalformed) {
      return new convert._Utf8StringSinkAdapter(this, this[_stringSink], allowMalformed);
    }
  };
  dart.setSignature(convert._StringCallbackSink, {
    constructors: () => ({new: dart.definiteFunctionType(convert._StringCallbackSink, [convert._ChunkedConversionCallback$(core.String)])})
  });
  convert._StringAdapterSink = class _StringAdapterSink extends convert.StringConversionSinkBase {
    new(sink) {
      this[_sink$] = sink;
    }
    add(str) {
      this[_sink$].add(str);
    }
    addSlice(str, start, end, isLast) {
      if (start == 0 && end == str[dartx.length]) {
        this.add(str);
      } else {
        this.add(str[dartx.substring](start, end));
      }
      if (dart.test(isLast)) this.close();
    }
    close() {
      this[_sink$].close();
    }
  };
  dart.setSignature(convert._StringAdapterSink, {
    constructors: () => ({new: dart.definiteFunctionType(convert._StringAdapterSink, [core.Sink$(core.String)])}),
    methods: () => ({
      addSlice: dart.definiteFunctionType(dart.void, [core.String, core.int, core.int, core.bool]),
      close: dart.definiteFunctionType(dart.void, [])
    })
  });
  convert._Utf8StringSinkAdapter = class _Utf8StringSinkAdapter extends convert.ByteConversionSink {
    new(sink, stringSink, allowMalformed) {
      this[_sink$] = sink;
      this[_decoder] = new convert._Utf8Decoder(stringSink, allowMalformed);
      super.new();
    }
    close() {
      this[_decoder].close();
      if (this[_sink$] != null) this[_sink$].close();
    }
    add(chunk) {
      this.addSlice(chunk, 0, chunk[dartx.length], false);
    }
    addSlice(codeUnits, startIndex, endIndex, isLast) {
      this[_decoder].convert(codeUnits, startIndex, endIndex);
      if (dart.test(isLast)) this.close();
    }
  };
  dart.setSignature(convert._Utf8StringSinkAdapter, {
    constructors: () => ({new: dart.definiteFunctionType(convert._Utf8StringSinkAdapter, [core.Sink, core.StringSink, core.bool])}),
    methods: () => ({
      close: dart.definiteFunctionType(dart.void, []),
      add: dart.definiteFunctionType(dart.void, [core.List$(core.int)]),
      addSlice: dart.definiteFunctionType(dart.void, [core.List$(core.int), core.int, core.int, core.bool])
    })
  });
  convert._Utf8ConversionSink = class _Utf8ConversionSink extends convert.ByteConversionSink {
    new(sink, allowMalformed) {
      _Utf8ConversionSink.prototype._.call(this, sink, new core.StringBuffer(), allowMalformed);
    }
    _(chunkedSink, stringBuffer, allowMalformed) {
      this[_chunkedSink] = chunkedSink;
      this[_decoder] = new convert._Utf8Decoder(stringBuffer, allowMalformed);
      this[_buffer] = stringBuffer;
      super.new();
    }
    close() {
      this[_decoder].close();
      if (dart.test(this[_buffer].isNotEmpty)) {
        let accumulated = dart.toString(this[_buffer]);
        this[_buffer].clear();
        this[_chunkedSink].addSlice(accumulated, 0, accumulated[dartx.length], true);
      } else {
        this[_chunkedSink].close();
      }
    }
    add(chunk) {
      this.addSlice(chunk, 0, chunk[dartx.length], false);
    }
    addSlice(chunk, startIndex, endIndex, isLast) {
      this[_decoder].convert(chunk, startIndex, endIndex);
      if (dart.test(this[_buffer].isNotEmpty)) {
        let accumulated = dart.toString(this[_buffer]);
        this[_chunkedSink].addSlice(accumulated, 0, accumulated[dartx.length], isLast);
        this[_buffer].clear();
        return;
      }
      if (dart.test(isLast)) this.close();
    }
  };
  dart.defineNamedConstructor(convert._Utf8ConversionSink, '_');
  dart.setSignature(convert._Utf8ConversionSink, {
    constructors: () => ({
      new: dart.definiteFunctionType(convert._Utf8ConversionSink, [convert.StringConversionSink, core.bool]),
      _: dart.definiteFunctionType(convert._Utf8ConversionSink, [convert.StringConversionSink, core.StringBuffer, core.bool])
    }),
    methods: () => ({
      close: dart.definiteFunctionType(dart.void, []),
      add: dart.definiteFunctionType(dart.void, [core.List$(core.int)]),
      addSlice: dart.definiteFunctionType(dart.void, [core.List$(core.int), core.int, core.int, core.bool])
    })
  });
  convert.UNICODE_REPLACEMENT_CHARACTER_RUNE = 65533;
  convert.UNICODE_BOM_CHARACTER_RUNE = 65279;
  const _allowMalformed = Symbol('_allowMalformed');
  let const$45;
  convert.Utf8Codec = class Utf8Codec extends convert.Encoding {
    new(opts) {
      let allowMalformed = opts && 'allowMalformed' in opts ? opts.allowMalformed : false;
      this[_allowMalformed] = allowMalformed;
      super.new();
    }
    get name() {
      return "utf-8";
    }
    decode(codeUnits, opts) {
      let allowMalformed = opts && 'allowMalformed' in opts ? opts.allowMalformed : null;
      if (allowMalformed == null) allowMalformed = this[_allowMalformed];
      return new convert.Utf8Decoder({allowMalformed: allowMalformed}).convert(codeUnits);
    }
    get encoder() {
      return const$45 || (const$45 = dart.const(new convert.Utf8Encoder()));
    }
    get decoder() {
      return new convert.Utf8Decoder({allowMalformed: this[_allowMalformed]});
    }
  };
  dart.setSignature(convert.Utf8Codec, {
    constructors: () => ({new: dart.definiteFunctionType(convert.Utf8Codec, [], {allowMalformed: core.bool})}),
    methods: () => ({decode: dart.definiteFunctionType(core.String, [core.List$(core.int)], {allowMalformed: core.bool})})
  });
  convert.UTF8 = dart.const(new convert.Utf8Codec());
  const _fillBuffer = Symbol('_fillBuffer');
  const _writeSurrogate = Symbol('_writeSurrogate');
  convert.Utf8Encoder = class Utf8Encoder extends convert.Converter$(core.String, core.List$(core.int)) {
    new() {
      super.new();
    }
    convert(string, start, end) {
      if (start === void 0) start = 0;
      if (end === void 0) end = null;
      let stringLength = string[dartx.length];
      core.RangeError.checkValidRange(start, end, stringLength);
      if (end == null) end = stringLength;
      let length = dart.notNull(end) - dart.notNull(start);
      if (length == 0) return typed_data.Uint8List.new(0);
      let encoder = new convert._Utf8Encoder.withBufferSize(length * 3);
      let endPosition = encoder[_fillBuffer](string, start, end);
      dart.assert(dart.notNull(endPosition) >= dart.notNull(end) - 1);
      if (endPosition != end) {
        let lastCodeUnit = string[dartx.codeUnitAt](dart.notNull(end) - 1);
        dart.assert(convert._isLeadSurrogate(lastCodeUnit));
        let wasCombined = encoder[_writeSurrogate](lastCodeUnit, 0);
        dart.assert(!dart.test(wasCombined));
      }
      return encoder[_buffer][dartx.sublist](0, encoder[_bufferIndex]);
    }
    startChunkedConversion(sink) {
      if (!convert.ByteConversionSink.is(sink)) {
        sink = convert.ByteConversionSink.from(sink);
      }
      return new convert._Utf8EncoderSink(convert.ByteConversionSink._check(sink));
    }
    bind(stream) {
      return super.bind(stream);
    }
  };
  dart.addSimpleTypeTests(convert.Utf8Encoder);
  dart.setSignature(convert.Utf8Encoder, {
    constructors: () => ({new: dart.definiteFunctionType(convert.Utf8Encoder, [])}),
    methods: () => ({
      convert: dart.definiteFunctionType(core.List$(core.int), [core.String], [core.int, core.int]),
      startChunkedConversion: dart.definiteFunctionType(convert.StringConversionSink, [core.Sink$(core.List$(core.int))]),
      bind: dart.definiteFunctionType(async.Stream$(core.List$(core.int)), [async.Stream$(core.String)])
    })
  });
  convert._Utf8Encoder = class _Utf8Encoder extends core.Object {
    new() {
      _Utf8Encoder.prototype.withBufferSize.call(this, convert._Utf8Encoder._DEFAULT_BYTE_BUFFER_SIZE);
    }
    withBufferSize(bufferSize) {
      this[_buffer] = convert._Utf8Encoder._createBuffer(bufferSize);
      this[_carry] = 0;
      this[_bufferIndex] = 0;
    }
    static _createBuffer(size) {
      return typed_data.Uint8List.new(size);
    }
    [_writeSurrogate](leadingSurrogate, nextCodeUnit) {
      if (dart.test(convert._isTailSurrogate(nextCodeUnit))) {
        let rune = convert._combineSurrogatePair(leadingSurrogate, nextCodeUnit);
        dart.assert(dart.notNull(rune) > convert._THREE_BYTE_LIMIT);
        dart.assert(dart.notNull(rune) <= convert._FOUR_BYTE_LIMIT);
        this[_buffer][dartx.set]((() => {
          let x = this[_bufferIndex];
          this[_bufferIndex] = dart.notNull(x) + 1;
          return x;
        })(), (240 | rune[dartx['>>']](18)) >>> 0);
        this[_buffer][dartx.set]((() => {
          let x = this[_bufferIndex];
          this[_bufferIndex] = dart.notNull(x) + 1;
          return x;
        })(), 128 | dart.notNull(rune) >> 12 & 63);
        this[_buffer][dartx.set]((() => {
          let x = this[_bufferIndex];
          this[_bufferIndex] = dart.notNull(x) + 1;
          return x;
        })(), 128 | dart.notNull(rune) >> 6 & 63);
        this[_buffer][dartx.set]((() => {
          let x = this[_bufferIndex];
          this[_bufferIndex] = dart.notNull(x) + 1;
          return x;
        })(), 128 | dart.notNull(rune) & 63);
        return true;
      } else {
        this[_buffer][dartx.set]((() => {
          let x = this[_bufferIndex];
          this[_bufferIndex] = dart.notNull(x) + 1;
          return x;
        })(), (224 | leadingSurrogate[dartx['>>']](12)) >>> 0);
        this[_buffer][dartx.set]((() => {
          let x = this[_bufferIndex];
          this[_bufferIndex] = dart.notNull(x) + 1;
          return x;
        })(), 128 | dart.notNull(leadingSurrogate) >> 6 & 63);
        this[_buffer][dartx.set]((() => {
          let x = this[_bufferIndex];
          this[_bufferIndex] = dart.notNull(x) + 1;
          return x;
        })(), 128 | dart.notNull(leadingSurrogate) & 63);
        return false;
      }
    }
    [_fillBuffer](str, start, end) {
      if (start != end && dart.test(convert._isLeadSurrogate(str[dartx.codeUnitAt](dart.notNull(end) - 1)))) {
        end = dart.notNull(end) - 1;
      }
      let stringIndex = null;
      for (stringIndex = start; dart.notNull(stringIndex) < dart.notNull(end); stringIndex = dart.notNull(stringIndex) + 1) {
        let codeUnit = str[dartx.codeUnitAt](stringIndex);
        if (dart.notNull(codeUnit) <= convert._ONE_BYTE_LIMIT) {
          if (dart.notNull(this[_bufferIndex]) >= dart.notNull(this[_buffer][dartx.length])) break;
          this[_buffer][dartx.set]((() => {
            let x = this[_bufferIndex];
            this[_bufferIndex] = dart.notNull(x) + 1;
            return x;
          })(), codeUnit);
        } else if (dart.test(convert._isLeadSurrogate(codeUnit))) {
          if (dart.notNull(this[_bufferIndex]) + 3 >= dart.notNull(this[_buffer][dartx.length])) break;
          let nextCodeUnit = str[dartx.codeUnitAt](dart.notNull(stringIndex) + 1);
          let wasCombined = this[_writeSurrogate](codeUnit, nextCodeUnit);
          if (dart.test(wasCombined)) {
            stringIndex = dart.notNull(stringIndex) + 1;
          }
        } else {
          let rune = codeUnit;
          if (dart.notNull(rune) <= convert._TWO_BYTE_LIMIT) {
            if (dart.notNull(this[_bufferIndex]) + 1 >= dart.notNull(this[_buffer][dartx.length])) break;
            this[_buffer][dartx.set]((() => {
              let x = this[_bufferIndex];
              this[_bufferIndex] = dart.notNull(x) + 1;
              return x;
            })(), (192 | rune[dartx['>>']](6)) >>> 0);
            this[_buffer][dartx.set]((() => {
              let x = this[_bufferIndex];
              this[_bufferIndex] = dart.notNull(x) + 1;
              return x;
            })(), 128 | dart.notNull(rune) & 63);
          } else {
            dart.assert(dart.notNull(rune) <= convert._THREE_BYTE_LIMIT);
            if (dart.notNull(this[_bufferIndex]) + 2 >= dart.notNull(this[_buffer][dartx.length])) break;
            this[_buffer][dartx.set]((() => {
              let x = this[_bufferIndex];
              this[_bufferIndex] = dart.notNull(x) + 1;
              return x;
            })(), (224 | rune[dartx['>>']](12)) >>> 0);
            this[_buffer][dartx.set]((() => {
              let x = this[_bufferIndex];
              this[_bufferIndex] = dart.notNull(x) + 1;
              return x;
            })(), 128 | dart.notNull(rune) >> 6 & 63);
            this[_buffer][dartx.set]((() => {
              let x = this[_bufferIndex];
              this[_bufferIndex] = dart.notNull(x) + 1;
              return x;
            })(), 128 | dart.notNull(rune) & 63);
          }
        }
      }
      return stringIndex;
    }
  };
  dart.defineNamedConstructor(convert._Utf8Encoder, 'withBufferSize');
  dart.setSignature(convert._Utf8Encoder, {
    constructors: () => ({
      new: dart.definiteFunctionType(convert._Utf8Encoder, []),
      withBufferSize: dart.definiteFunctionType(convert._Utf8Encoder, [core.int])
    }),
    methods: () => ({
      [_writeSurrogate]: dart.definiteFunctionType(core.bool, [core.int, core.int]),
      [_fillBuffer]: dart.definiteFunctionType(core.int, [core.String, core.int, core.int])
    }),
    statics: () => ({_createBuffer: dart.definiteFunctionType(core.List$(core.int), [core.int])}),
    names: ['_createBuffer']
  });
  convert._Utf8Encoder._DEFAULT_BYTE_BUFFER_SIZE = 1024;
  convert._Utf8EncoderSink = class _Utf8EncoderSink extends dart.mixin(convert._Utf8Encoder, convert.StringConversionSinkMixin) {
    new(sink) {
      this[_sink$] = sink;
      super.new();
    }
    close() {
      if (this[_carry] != 0) {
        this.addSlice("", 0, 0, true);
        return;
      }
      this[_sink$].close();
    }
    addSlice(str, start, end, isLast) {
      this[_bufferIndex] = 0;
      if (start == end && !dart.test(isLast)) {
        return;
      }
      if (this[_carry] != 0) {
        let nextCodeUnit = 0;
        if (start != end) {
          nextCodeUnit = str[dartx.codeUnitAt](start);
        } else {
          dart.assert(isLast);
        }
        let wasCombined = this[_writeSurrogate](this[_carry], nextCodeUnit);
        dart.assert(!dart.test(wasCombined) || start != end);
        if (dart.test(wasCombined)) {
          start = dart.notNull(start) + 1;
        }
        this[_carry] = 0;
      }
      do {
        start = this[_fillBuffer](str, start, end);
        let isLastSlice = dart.test(isLast) && start == end;
        if (start == dart.notNull(end) - 1 && dart.test(convert._isLeadSurrogate(str[dartx.codeUnitAt](start)))) {
          if (dart.test(isLast) && dart.notNull(this[_bufferIndex]) < dart.notNull(this[_buffer][dartx.length]) - 3) {
            let hasBeenCombined = this[_writeSurrogate](str[dartx.codeUnitAt](start), 0);
            dart.assert(!dart.test(hasBeenCombined));
          } else {
            this[_carry] = str[dartx.codeUnitAt](start);
          }
          start = dart.notNull(start) + 1;
        }
        this[_sink$].addSlice(this[_buffer], 0, this[_bufferIndex], isLastSlice);
        this[_bufferIndex] = 0;
      } while (dart.notNull(start) < dart.notNull(end));
      if (dart.test(isLast)) this.close();
    }
  };
  dart.setSignature(convert._Utf8EncoderSink, {
    constructors: () => ({new: dart.definiteFunctionType(convert._Utf8EncoderSink, [convert.ByteConversionSink])}),
    methods: () => ({
      close: dart.definiteFunctionType(dart.void, []),
      addSlice: dart.definiteFunctionType(dart.void, [core.String, core.int, core.int, core.bool])
    })
  });
  convert.Utf8Decoder = class Utf8Decoder extends convert.Converter$(core.List$(core.int), core.String) {
    new(opts) {
      let allowMalformed = opts && 'allowMalformed' in opts ? opts.allowMalformed : false;
      this[_allowMalformed] = allowMalformed;
      super.new();
    }
    convert(codeUnits, start, end) {
      if (start === void 0) start = 0;
      if (end === void 0) end = null;
      let result = convert.Utf8Decoder._convertIntercepted(this[_allowMalformed], codeUnits, start, end);
      if (result != null) {
        return result;
      }
      let length = codeUnits[dartx.length];
      core.RangeError.checkValidRange(start, end, length);
      if (end == null) end = length;
      let buffer = new core.StringBuffer();
      let decoder = new convert._Utf8Decoder(buffer, this[_allowMalformed]);
      decoder.convert(codeUnits, start, end);
      decoder.close();
      return buffer.toString();
    }
    startChunkedConversion(sink) {
      let stringSink = null;
      if (convert.StringConversionSink.is(sink)) {
        stringSink = sink;
      } else {
        stringSink = convert.StringConversionSink.from(sink);
      }
      return stringSink.asUtf8Sink(this[_allowMalformed]);
    }
    bind(stream) {
      return super.bind(stream);
    }
    fuse(T) {
      return next => {
        return super.fuse(T)(next);
      };
    }
    static _convertIntercepted(allowMalformed, codeUnits, start, end) {
      return null;
    }
  };
  dart.addSimpleTypeTests(convert.Utf8Decoder);
  dart.setSignature(convert.Utf8Decoder, {
    constructors: () => ({new: dart.definiteFunctionType(convert.Utf8Decoder, [], {allowMalformed: core.bool})}),
    methods: () => ({
      convert: dart.definiteFunctionType(core.String, [core.List$(core.int)], [core.int, core.int]),
      startChunkedConversion: dart.definiteFunctionType(convert.ByteConversionSink, [core.Sink$(core.String)]),
      bind: dart.definiteFunctionType(async.Stream$(core.String), [async.Stream$(core.List$(core.int))]),
      fuse: dart.definiteFunctionType(T => [convert.Converter$(core.List$(core.int), T), [convert.Converter$(core.String, T)]])
    }),
    statics: () => ({_convertIntercepted: dart.definiteFunctionType(core.String, [core.bool, core.List$(core.int), core.int, core.int])}),
    names: ['_convertIntercepted']
  });
  convert._ONE_BYTE_LIMIT = 127;
  convert._TWO_BYTE_LIMIT = 2047;
  convert._THREE_BYTE_LIMIT = 65535;
  convert._FOUR_BYTE_LIMIT = 1114111;
  convert._SURROGATE_MASK = 63488;
  convert._SURROGATE_TAG_MASK = 64512;
  convert._SURROGATE_VALUE_MASK = 1023;
  convert._LEAD_SURROGATE_MIN = 55296;
  convert._TAIL_SURROGATE_MIN = 56320;
  convert._isLeadSurrogate = function(codeUnit) {
    return (dart.notNull(codeUnit) & convert._SURROGATE_TAG_MASK) == convert._LEAD_SURROGATE_MIN;
  };
  dart.lazyFn(convert._isLeadSurrogate, () => intTobool());
  convert._isTailSurrogate = function(codeUnit) {
    return (dart.notNull(codeUnit) & convert._SURROGATE_TAG_MASK) == convert._TAIL_SURROGATE_MIN;
  };
  dart.lazyFn(convert._isTailSurrogate, () => intTobool());
  convert._combineSurrogatePair = function(lead, tail) {
    return (65536 + ((dart.notNull(lead) & convert._SURROGATE_VALUE_MASK) << 10) | dart.notNull(tail) & convert._SURROGATE_VALUE_MASK) >>> 0;
  };
  dart.fn(convert._combineSurrogatePair, intAndintToint());
  const _isFirstCharacter = Symbol('_isFirstCharacter');
  const _value = Symbol('_value');
  const _expectedUnits = Symbol('_expectedUnits');
  const _extraUnits = Symbol('_extraUnits');
  convert._Utf8Decoder = class _Utf8Decoder extends core.Object {
    new(stringSink, allowMalformed) {
      this[_stringSink] = stringSink;
      this[_allowMalformed] = allowMalformed;
      this[_isFirstCharacter] = true;
      this[_value] = 0;
      this[_expectedUnits] = 0;
      this[_extraUnits] = 0;
    }
    get hasPartialInput() {
      return dart.notNull(this[_expectedUnits]) > 0;
    }
    close() {
      this.flush();
    }
    flush() {
      if (dart.test(this.hasPartialInput)) {
        if (!dart.test(this[_allowMalformed])) {
          dart.throw(new core.FormatException("Unfinished UTF-8 octet sequence"));
        }
        this[_stringSink].writeCharCode(convert.UNICODE_REPLACEMENT_CHARACTER_RUNE);
        this[_value] = 0;
        this[_expectedUnits] = 0;
        this[_extraUnits] = 0;
      }
    }
    convert(codeUnits, startIndex, endIndex) {
      let value = this[_value];
      let expectedUnits = this[_expectedUnits];
      let extraUnits = this[_extraUnits];
      this[_value] = 0;
      this[_expectedUnits] = 0;
      this[_extraUnits] = 0;
      function scanOneByteCharacters(units, from) {
        let to = endIndex;
        let mask = convert._ONE_BYTE_LIMIT;
        for (let i = from; dart.notNull(i) < dart.notNull(to); i = dart.notNull(i) + 1) {
          let unit = dart.dindex(units, i);
          if (!dart.equals(dart.dsend(unit, '&', mask), unit)) return dart.notNull(i) - dart.notNull(from);
        }
        return dart.notNull(to) - dart.notNull(from);
      }
      dart.fn(scanOneByteCharacters, dynamicAndintToint());
      const addSingleBytes = (function(from, to) {
        dart.assert(dart.notNull(from) >= dart.notNull(startIndex) && dart.notNull(from) <= dart.notNull(endIndex));
        dart.assert(dart.notNull(to) >= dart.notNull(startIndex) && dart.notNull(to) <= dart.notNull(endIndex));
        this[_stringSink].write(core.String.fromCharCodes(codeUnits, from, to));
      }).bind(this);
      dart.fn(addSingleBytes, intAndintTovoid());
      let i = startIndex;
      loop:
        while (true) {
          multibyte:
            if (dart.notNull(expectedUnits) > 0) {
              do {
                if (i == endIndex) {
                  break loop;
                }
                let unit = codeUnits[dartx.get](i);
                if ((dart.notNull(unit) & 192) != 128) {
                  expectedUnits = 0;
                  if (!dart.test(this[_allowMalformed])) {
                    dart.throw(new core.FormatException(dart.str`Bad UTF-8 encoding 0x${unit[dartx.toRadixString](16)}`));
                  }
                  this[_isFirstCharacter] = false;
                  this[_stringSink].writeCharCode(convert.UNICODE_REPLACEMENT_CHARACTER_RUNE);
                  break multibyte;
                } else {
                  value = (dart.notNull(value) << 6 | dart.notNull(unit) & 63) >>> 0;
                  expectedUnits = dart.notNull(expectedUnits) - 1;
                  i = dart.notNull(i) + 1;
                }
              } while (dart.notNull(expectedUnits) > 0);
              if (dart.notNull(value) <= dart.notNull(convert._Utf8Decoder._LIMITS[dartx.get](dart.notNull(extraUnits) - 1))) {
                if (!dart.test(this[_allowMalformed])) {
                  dart.throw(new core.FormatException(dart.str`Overlong encoding of 0x${value[dartx.toRadixString](16)}`));
                }
                expectedUnits = extraUnits = 0;
                value = convert.UNICODE_REPLACEMENT_CHARACTER_RUNE;
              }
              if (dart.notNull(value) > convert._FOUR_BYTE_LIMIT) {
                if (!dart.test(this[_allowMalformed])) {
                  dart.throw(new core.FormatException("Character outside valid Unicode range: " + dart.str`0x${value[dartx.toRadixString](16)}`));
                }
                value = convert.UNICODE_REPLACEMENT_CHARACTER_RUNE;
              }
              if (!dart.test(this[_isFirstCharacter]) || value != convert.UNICODE_BOM_CHARACTER_RUNE) {
                this[_stringSink].writeCharCode(value);
              }
              this[_isFirstCharacter] = false;
            }
          while (dart.notNull(i) < dart.notNull(endIndex)) {
            let oneBytes = scanOneByteCharacters(codeUnits, i);
            if (dart.notNull(oneBytes) > 0) {
              this[_isFirstCharacter] = false;
              addSingleBytes(i, dart.notNull(i) + dart.notNull(oneBytes));
              i = dart.notNull(i) + dart.notNull(oneBytes);
              if (i == endIndex) break;
            }
            let unit = codeUnits[dartx.get]((() => {
              let x = i;
              i = dart.notNull(x) + 1;
              return x;
            })());
            if (dart.notNull(unit) < 0) {
              if (!dart.test(this[_allowMalformed])) {
                dart.throw(new core.FormatException(dart.str`Negative UTF-8 code unit: -0x${(-dart.notNull(unit))[dartx.toRadixString](16)}`));
              }
              this[_stringSink].writeCharCode(convert.UNICODE_REPLACEMENT_CHARACTER_RUNE);
            } else {
              dart.assert(dart.notNull(unit) > convert._ONE_BYTE_LIMIT);
              if ((dart.notNull(unit) & 224) == 192) {
                value = dart.notNull(unit) & 31;
                expectedUnits = extraUnits = 1;
                continue loop;
              }
              if ((dart.notNull(unit) & 240) == 224) {
                value = dart.notNull(unit) & 15;
                expectedUnits = extraUnits = 2;
                continue loop;
              }
              if ((dart.notNull(unit) & 248) == 240 && dart.notNull(unit) < 245) {
                value = dart.notNull(unit) & 7;
                expectedUnits = extraUnits = 3;
                continue loop;
              }
              if (!dart.test(this[_allowMalformed])) {
                dart.throw(new core.FormatException(dart.str`Bad UTF-8 encoding 0x${unit[dartx.toRadixString](16)}`));
              }
              value = convert.UNICODE_REPLACEMENT_CHARACTER_RUNE;
              expectedUnits = extraUnits = 0;
              this[_isFirstCharacter] = false;
              this[_stringSink].writeCharCode(value);
            }
          }
          break loop;
        }
      if (dart.notNull(expectedUnits) > 0) {
        this[_value] = value;
        this[_expectedUnits] = expectedUnits;
        this[_extraUnits] = extraUnits;
      }
    }
  };
  dart.setSignature(convert._Utf8Decoder, {
    constructors: () => ({new: dart.definiteFunctionType(convert._Utf8Decoder, [core.StringSink, core.bool])}),
    methods: () => ({
      close: dart.definiteFunctionType(dart.void, []),
      flush: dart.definiteFunctionType(dart.void, []),
      convert: dart.definiteFunctionType(dart.void, [core.List$(core.int), core.int, core.int])
    })
  });
  convert._Utf8Decoder._LIMITS = dart.constList([convert._ONE_BYTE_LIMIT, convert._TWO_BYTE_LIMIT, convert._THREE_BYTE_LIMIT, convert._FOUR_BYTE_LIMIT], core.int);
  core._symbolToString = function(symbol) {
    return _internal.Symbol.getName(_internal.Symbol._check(symbol));
  };
  dart.lazyFn(core._symbolToString, () => SymbolToString());
  core.StrongModeError = class StrongModeError extends core.Error {
    new() {
      super.new();
    }
  };
  core.Deprecated = class Deprecated extends core.Object {
    new(expires) {
      this.expires = expires;
    }
    toString() {
      return dart.str`Deprecated feature. Will be removed ${this.expires}`;
    }
  };
  dart.setSignature(core.Deprecated, {
    constructors: () => ({new: dart.definiteFunctionType(core.Deprecated, [core.String])})
  });
  core._Override = class _Override extends core.Object {
    new() {
    }
  };
  dart.setSignature(core._Override, {
    constructors: () => ({new: dart.definiteFunctionType(core._Override, [])})
  });
  core.deprecated = dart.const(new core.Deprecated("next release"));
  core.override = dart.const(new core._Override());
  core._Proxy = class _Proxy extends core.Object {
    new() {
    }
  };
  dart.setSignature(core._Proxy, {
    constructors: () => ({new: dart.definiteFunctionType(core._Proxy, [])})
  });
  core.proxy = dart.const(new core._Proxy());
  dart.defineExtensionNames([
    'toString'
  ]);
  core.bool = class bool extends core.Object {
    static fromEnvironment(name, opts) {
      let defaultValue = opts && 'defaultValue' in opts ? opts.defaultValue : false;
      dart.throw(new core.UnsupportedError('bool.fromEnvironment can only be used as a const constructor'));
    }
    [dartx.toString]() {
      return this ? "true" : "false";
    }
  };
  core.bool.is = function is_bool(o) {
    return o === true || o === false;
  };
  core.bool.as = function as_bool(o) {
    if (o === true || o === false || o == null) return o;
    return dart.as(o, core.bool);
  };
  core.bool._check = function check_bool(o) {
    if (o === true || o === false || o == null) return o;
    return dart.check(o, core.bool);
  };
  dart.setSignature(core.bool, {
    constructors: () => ({fromEnvironment: dart.definiteFunctionType(core.bool, [core.String], {defaultValue: core.bool})})
  });
  core.Comparator$ = dart.generic(T => {
    const Comparator = dart.typedef('Comparator', () => dart.functionType(core.int, [T, T]));
    return Comparator;
  });
  core.Comparator = Comparator();
  core.Comparable$ = dart.generic(T => {
    class Comparable extends core.Object {
      static compare(a, b) {
        return a[dartx.compareTo](b);
      }
    }
    dart.addTypeTests(Comparable);
    dart.setSignature(Comparable, {
      statics: () => ({compare: dart.definiteFunctionType(core.int, [core.Comparable, core.Comparable])}),
      names: ['compare']
    });
    return Comparable;
  });
  core.Comparable = Comparable();
  const _value$ = Symbol('_value');
  core.DateTime = class DateTime extends core.Object {
    new(year, month, day, hour, minute, second, millisecond, microsecond) {
      if (month === void 0) month = 1;
      if (day === void 0) day = 1;
      if (hour === void 0) hour = 0;
      if (minute === void 0) minute = 0;
      if (second === void 0) second = 0;
      if (millisecond === void 0) millisecond = 0;
      if (microsecond === void 0) microsecond = 0;
      DateTime.prototype._internal.call(this, year, month, day, hour, minute, second, millisecond, microsecond, false);
    }
    utc(year, month, day, hour, minute, second, millisecond, microsecond) {
      if (month === void 0) month = 1;
      if (day === void 0) day = 1;
      if (hour === void 0) hour = 0;
      if (minute === void 0) minute = 0;
      if (second === void 0) second = 0;
      if (millisecond === void 0) millisecond = 0;
      if (microsecond === void 0) microsecond = 0;
      DateTime.prototype._internal.call(this, year, month, day, hour, minute, second, millisecond, microsecond, true);
    }
    now() {
      DateTime.prototype._now.call(this);
    }
    static parse(formattedString) {
      let re = core.RegExp.new('^([+-]?\\d{4,6})-?(\\d\\d)-?(\\d\\d)' + '(?:[ T](\\d\\d)(?::?(\\d\\d)(?::?(\\d\\d)(?:\\.(\\d{1,6}))?)?)?' + '( ?[zZ]| ?([-+])(\\d\\d)(?::?(\\d\\d))?)?)?$');
      let match = re.firstMatch(formattedString);
      if (match != null) {
        function parseIntOrZero(matched) {
          if (matched == null) return 0;
          return core.int.parse(matched);
        }
        dart.fn(parseIntOrZero, StringToint$());
        function parseMilliAndMicroseconds(matched) {
          if (matched == null) return 0;
          let length = matched[dartx.length];
          dart.assert(dart.notNull(length) >= 1);
          dart.assert(dart.notNull(length) <= 6);
          let result = 0;
          for (let i = 0; i < 6; i++) {
            result = result * 10;
            if (i < dart.notNull(matched[dartx.length])) {
              result = result + ((dart.notNull(matched[dartx.codeUnitAt](i)) ^ 48) >>> 0);
            }
          }
          return result;
        }
        dart.fn(parseMilliAndMicroseconds, StringToint$());
        let years = core.int.parse(match.get(1));
        let month = core.int.parse(match.get(2));
        let day = core.int.parse(match.get(3));
        let hour = parseIntOrZero(match.get(4));
        let minute = parseIntOrZero(match.get(5));
        let second = parseIntOrZero(match.get(6));
        let addOneMillisecond = false;
        let milliAndMicroseconds = parseMilliAndMicroseconds(match.get(7));
        let millisecond = (dart.notNull(milliAndMicroseconds) / core.Duration.MICROSECONDS_PER_MILLISECOND)[dartx.truncate]();
        let microsecond = dart.asInt(milliAndMicroseconds[dartx.remainder](core.Duration.MICROSECONDS_PER_MILLISECOND));
        let isUtc = false;
        if (match.get(8) != null) {
          isUtc = true;
          if (match.get(9) != null) {
            let sign = match.get(9) == '-' ? -1 : 1;
            let hourDifference = core.int.parse(match.get(10));
            let minuteDifference = parseIntOrZero(match.get(11));
            minuteDifference = dart.notNull(minuteDifference) + 60 * dart.notNull(hourDifference);
            minute = dart.notNull(minute) - sign * dart.notNull(minuteDifference);
          }
        }
        let value = core.DateTime._brokenDownDateToValue(years, month, day, hour, minute, second, millisecond, microsecond, isUtc);
        if (value == null) {
          dart.throw(new core.FormatException("Time out of range", formattedString));
        }
        return new core.DateTime._withValue(value, {isUtc: isUtc});
      } else {
        dart.throw(new core.FormatException("Invalid date format", formattedString));
      }
    }
    fromMillisecondsSinceEpoch(millisecondsSinceEpoch, opts) {
      let isUtc = opts && 'isUtc' in opts ? opts.isUtc : false;
      DateTime.prototype._withValue.call(this, millisecondsSinceEpoch, {isUtc: isUtc});
    }
    fromMicrosecondsSinceEpoch(microsecondsSinceEpoch, opts) {
      let isUtc = opts && 'isUtc' in opts ? opts.isUtc : false;
      DateTime.prototype._withValue.call(this, core.DateTime._microsecondInRoundedMilliseconds(microsecondsSinceEpoch), {isUtc: isUtc});
    }
    _withValue(value, opts) {
      let isUtc = opts && 'isUtc' in opts ? opts.isUtc : null;
      this[_value$] = value;
      this.isUtc = isUtc;
      if (dart.notNull(this.millisecondsSinceEpoch[dartx.abs]()) > core.DateTime._MAX_MILLISECONDS_SINCE_EPOCH || this.millisecondsSinceEpoch[dartx.abs]() == core.DateTime._MAX_MILLISECONDS_SINCE_EPOCH && this.microsecond != 0) {
        dart.throw(new core.ArgumentError(this.millisecondsSinceEpoch));
      }
      if (this.isUtc == null) dart.throw(new core.ArgumentError(this.isUtc));
    }
    ['=='](other) {
      if (!core.DateTime.is(other)) return false;
      return dart.equals(this[_value$], dart.dload(other, _value$)) && dart.equals(this.isUtc, dart.dload(other, 'isUtc'));
    }
    isBefore(other) {
      return dart.notNull(this[_value$]) < dart.notNull(other[_value$]);
    }
    isAfter(other) {
      return dart.notNull(this[_value$]) > dart.notNull(other[_value$]);
    }
    isAtSameMomentAs(other) {
      return this[_value$] == other[_value$];
    }
    compareTo(other) {
      return this[_value$][dartx.compareTo](other[_value$]);
    }
    get hashCode() {
      return (dart.notNull(this[_value$]) ^ this[_value$][dartx['>>']](30)) & 1073741823;
    }
    toLocal() {
      if (dart.test(this.isUtc)) {
        return new core.DateTime._withValue(this[_value$], {isUtc: false});
      }
      return this;
    }
    toUtc() {
      if (dart.test(this.isUtc)) return this;
      return new core.DateTime._withValue(this[_value$], {isUtc: true});
    }
    static _fourDigits(n) {
      let absN = n[dartx.abs]();
      let sign = dart.notNull(n) < 0 ? "-" : "";
      if (dart.notNull(absN) >= 1000) return dart.str`${n}`;
      if (dart.notNull(absN) >= 100) return dart.str`${sign}0${absN}`;
      if (dart.notNull(absN) >= 10) return dart.str`${sign}00${absN}`;
      return dart.str`${sign}000${absN}`;
    }
    static _sixDigits(n) {
      dart.assert(dart.notNull(n) < -9999 || dart.notNull(n) > 9999);
      let absN = n[dartx.abs]();
      let sign = dart.notNull(n) < 0 ? "-" : "+";
      if (dart.notNull(absN) >= 100000) return dart.str`${sign}${absN}`;
      return dart.str`${sign}0${absN}`;
    }
    static _threeDigits(n) {
      if (dart.notNull(n) >= 100) return dart.str`${n}`;
      if (dart.notNull(n) >= 10) return dart.str`0${n}`;
      return dart.str`00${n}`;
    }
    static _twoDigits(n) {
      if (dart.notNull(n) >= 10) return dart.str`${n}`;
      return dart.str`0${n}`;
    }
    toString() {
      let y = core.DateTime._fourDigits(this.year);
      let m = core.DateTime._twoDigits(this.month);
      let d = core.DateTime._twoDigits(this.day);
      let h = core.DateTime._twoDigits(this.hour);
      let min = core.DateTime._twoDigits(this.minute);
      let sec = core.DateTime._twoDigits(this.second);
      let ms = core.DateTime._threeDigits(this.millisecond);
      let us = this.microsecond == 0 ? "" : core.DateTime._threeDigits(this.microsecond);
      if (dart.test(this.isUtc)) {
        return dart.str`${y}-${m}-${d} ${h}:${min}:${sec}.${ms}${us}Z`;
      } else {
        return dart.str`${y}-${m}-${d} ${h}:${min}:${sec}.${ms}${us}`;
      }
    }
    toIso8601String() {
      let y = dart.notNull(this.year) >= -9999 && dart.notNull(this.year) <= 9999 ? core.DateTime._fourDigits(this.year) : core.DateTime._sixDigits(this.year);
      let m = core.DateTime._twoDigits(this.month);
      let d = core.DateTime._twoDigits(this.day);
      let h = core.DateTime._twoDigits(this.hour);
      let min = core.DateTime._twoDigits(this.minute);
      let sec = core.DateTime._twoDigits(this.second);
      let ms = core.DateTime._threeDigits(this.millisecond);
      let us = this.microsecond == 0 ? "" : core.DateTime._threeDigits(this.microsecond);
      if (dart.test(this.isUtc)) {
        return dart.str`${y}-${m}-${d}T${h}:${min}:${sec}.${ms}${us}Z`;
      } else {
        return dart.str`${y}-${m}-${d}T${h}:${min}:${sec}.${ms}${us}`;
      }
    }
    add(duration) {
      return new core.DateTime._withValue(dart.notNull(this[_value$]) + dart.notNull(duration.inMilliseconds), {isUtc: this.isUtc});
    }
    subtract(duration) {
      return new core.DateTime._withValue(dart.notNull(this[_value$]) - dart.notNull(duration.inMilliseconds), {isUtc: this.isUtc});
    }
    difference(other) {
      return new core.Duration({milliseconds: dart.notNull(this[_value$]) - dart.notNull(other[_value$])});
    }
    _internal(year, month, day, hour, minute, second, millisecond, microsecond, isUtc) {
      this.isUtc = typeof isUtc == 'boolean' ? isUtc : dart.throw(new core.ArgumentError.value(isUtc, 'isUtc'));
      this[_value$] = core.int._check(_js_helper.checkInt(_js_helper.Primitives.valueFromDecomposedDate(year, month, day, hour, minute, second, dart.notNull(millisecond) + dart.notNull(core.DateTime._microsecondInRoundedMilliseconds(microsecond)), isUtc)));
    }
    _now() {
      this.isUtc = false;
      this[_value$] = _js_helper.Primitives.dateNow();
    }
    static _brokenDownDateToValue(year, month, day, hour, minute, second, millisecond, microsecond, isUtc) {
      return dart.asInt(_js_helper.Primitives.valueFromDecomposedDate(year, month, day, hour, minute, second, dart.notNull(millisecond) + dart.notNull(core.DateTime._microsecondInRoundedMilliseconds(microsecond)), isUtc));
    }
    get millisecondsSinceEpoch() {
      return this[_value$];
    }
    get microsecondsSinceEpoch() {
      return dart.notNull(this[_value$]) * 1000;
    }
    get timeZoneName() {
      if (dart.test(this.isUtc)) return "UTC";
      return _js_helper.Primitives.getTimeZoneName(this);
    }
    get timeZoneOffset() {
      if (dart.test(this.isUtc)) return new core.Duration();
      return new core.Duration({minutes: _js_helper.Primitives.getTimeZoneOffsetInMinutes(this)});
    }
    get year() {
      return core.int._check(_js_helper.Primitives.getYear(this));
    }
    get month() {
      return core.int._check(_js_helper.Primitives.getMonth(this));
    }
    get day() {
      return core.int._check(_js_helper.Primitives.getDay(this));
    }
    get hour() {
      return core.int._check(_js_helper.Primitives.getHours(this));
    }
    get minute() {
      return core.int._check(_js_helper.Primitives.getMinutes(this));
    }
    get second() {
      return core.int._check(_js_helper.Primitives.getSeconds(this));
    }
    get millisecond() {
      return core.int._check(_js_helper.Primitives.getMilliseconds(this));
    }
    get microsecond() {
      return 0;
    }
    get weekday() {
      return core.int._check(_js_helper.Primitives.getWeekday(this));
    }
    static _microsecondInRoundedMilliseconds(microsecond) {
      return (dart.notNull(microsecond) / 1000)[dartx.round]();
    }
  };
  dart.defineNamedConstructor(core.DateTime, 'utc');
  dart.defineNamedConstructor(core.DateTime, 'now');
  dart.defineNamedConstructor(core.DateTime, 'fromMillisecondsSinceEpoch');
  dart.defineNamedConstructor(core.DateTime, 'fromMicrosecondsSinceEpoch');
  dart.defineNamedConstructor(core.DateTime, '_withValue');
  dart.defineNamedConstructor(core.DateTime, '_internal');
  dart.defineNamedConstructor(core.DateTime, '_now');
  core.DateTime[dart.implements] = () => [ComparableOfDateTime()];
  dart.setSignature(core.DateTime, {
    constructors: () => ({
      new: dart.definiteFunctionType(core.DateTime, [core.int], [core.int, core.int, core.int, core.int, core.int, core.int, core.int]),
      utc: dart.definiteFunctionType(core.DateTime, [core.int], [core.int, core.int, core.int, core.int, core.int, core.int, core.int]),
      now: dart.definiteFunctionType(core.DateTime, []),
      fromMillisecondsSinceEpoch: dart.definiteFunctionType(core.DateTime, [core.int], {isUtc: core.bool}),
      fromMicrosecondsSinceEpoch: dart.definiteFunctionType(core.DateTime, [core.int], {isUtc: core.bool}),
      _withValue: dart.definiteFunctionType(core.DateTime, [core.int], {isUtc: core.bool}),
      _internal: dart.definiteFunctionType(core.DateTime, [core.int, core.int, core.int, core.int, core.int, core.int, core.int, core.int, core.bool]),
      _now: dart.definiteFunctionType(core.DateTime, [])
    }),
    methods: () => ({
      isBefore: dart.definiteFunctionType(core.bool, [core.DateTime]),
      isAfter: dart.definiteFunctionType(core.bool, [core.DateTime]),
      isAtSameMomentAs: dart.definiteFunctionType(core.bool, [core.DateTime]),
      compareTo: dart.definiteFunctionType(core.int, [core.DateTime]),
      toLocal: dart.definiteFunctionType(core.DateTime, []),
      toUtc: dart.definiteFunctionType(core.DateTime, []),
      toIso8601String: dart.definiteFunctionType(core.String, []),
      add: dart.definiteFunctionType(core.DateTime, [core.Duration]),
      subtract: dart.definiteFunctionType(core.DateTime, [core.Duration]),
      difference: dart.definiteFunctionType(core.Duration, [core.DateTime])
    }),
    statics: () => ({
      parse: dart.definiteFunctionType(core.DateTime, [core.String]),
      _fourDigits: dart.definiteFunctionType(core.String, [core.int]),
      _sixDigits: dart.definiteFunctionType(core.String, [core.int]),
      _threeDigits: dart.definiteFunctionType(core.String, [core.int]),
      _twoDigits: dart.definiteFunctionType(core.String, [core.int]),
      _brokenDownDateToValue: dart.definiteFunctionType(core.int, [core.int, core.int, core.int, core.int, core.int, core.int, core.int, core.int, core.bool]),
      _microsecondInRoundedMilliseconds: dart.definiteFunctionType(core.int, [core.int])
    }),
    names: ['parse', '_fourDigits', '_sixDigits', '_threeDigits', '_twoDigits', '_brokenDownDateToValue', '_microsecondInRoundedMilliseconds']
  });
  dart.defineExtensionMembers(core.DateTime, ['compareTo']);
  core.DateTime.MONDAY = 1;
  core.DateTime.TUESDAY = 2;
  core.DateTime.WEDNESDAY = 3;
  core.DateTime.THURSDAY = 4;
  core.DateTime.FRIDAY = 5;
  core.DateTime.SATURDAY = 6;
  core.DateTime.SUNDAY = 7;
  core.DateTime.DAYS_PER_WEEK = 7;
  core.DateTime.JANUARY = 1;
  core.DateTime.FEBRUARY = 2;
  core.DateTime.MARCH = 3;
  core.DateTime.APRIL = 4;
  core.DateTime.MAY = 5;
  core.DateTime.JUNE = 6;
  core.DateTime.JULY = 7;
  core.DateTime.AUGUST = 8;
  core.DateTime.SEPTEMBER = 9;
  core.DateTime.OCTOBER = 10;
  core.DateTime.NOVEMBER = 11;
  core.DateTime.DECEMBER = 12;
  core.DateTime.MONTHS_PER_YEAR = 12;
  core.DateTime._MAX_MILLISECONDS_SINCE_EPOCH = 8640000000000000;
  const _duration = Symbol('_duration');
  core.Duration = class Duration extends core.Object {
    new(opts) {
      let days = opts && 'days' in opts ? opts.days : 0;
      let hours = opts && 'hours' in opts ? opts.hours : 0;
      let minutes = opts && 'minutes' in opts ? opts.minutes : 0;
      let seconds = opts && 'seconds' in opts ? opts.seconds : 0;
      let milliseconds = opts && 'milliseconds' in opts ? opts.milliseconds : 0;
      let microseconds = opts && 'microseconds' in opts ? opts.microseconds : 0;
      Duration.prototype._microseconds.call(this, core.Duration.MICROSECONDS_PER_DAY * dart.notNull(days) + core.Duration.MICROSECONDS_PER_HOUR * dart.notNull(hours) + core.Duration.MICROSECONDS_PER_MINUTE * dart.notNull(minutes) + core.Duration.MICROSECONDS_PER_SECOND * dart.notNull(seconds) + core.Duration.MICROSECONDS_PER_MILLISECOND * dart.notNull(milliseconds) + dart.notNull(microseconds));
    }
    _microseconds(duration) {
      this[_duration] = duration;
    }
    ['+'](other) {
      return new core.Duration._microseconds(dart.notNull(this[_duration]) + dart.notNull(other[_duration]));
    }
    ['-'](other) {
      return new core.Duration._microseconds(dart.notNull(this[_duration]) - dart.notNull(other[_duration]));
    }
    ['*'](factor) {
      return new core.Duration._microseconds((dart.notNull(this[_duration]) * dart.notNull(factor))[dartx.round]());
    }
    ['~/'](quotient) {
      if (quotient == 0) dart.throw(new core.IntegerDivisionByZeroException());
      return new core.Duration._microseconds((dart.notNull(this[_duration]) / dart.notNull(quotient))[dartx.truncate]());
    }
    ['<'](other) {
      return dart.notNull(this[_duration]) < dart.notNull(other[_duration]);
    }
    ['>'](other) {
      return dart.notNull(this[_duration]) > dart.notNull(other[_duration]);
    }
    ['<='](other) {
      return dart.notNull(this[_duration]) <= dart.notNull(other[_duration]);
    }
    ['>='](other) {
      return dart.notNull(this[_duration]) >= dart.notNull(other[_duration]);
    }
    get inDays() {
      return (dart.notNull(this[_duration]) / core.Duration.MICROSECONDS_PER_DAY)[dartx.truncate]();
    }
    get inHours() {
      return (dart.notNull(this[_duration]) / core.Duration.MICROSECONDS_PER_HOUR)[dartx.truncate]();
    }
    get inMinutes() {
      return (dart.notNull(this[_duration]) / core.Duration.MICROSECONDS_PER_MINUTE)[dartx.truncate]();
    }
    get inSeconds() {
      return (dart.notNull(this[_duration]) / core.Duration.MICROSECONDS_PER_SECOND)[dartx.truncate]();
    }
    get inMilliseconds() {
      return (dart.notNull(this[_duration]) / core.Duration.MICROSECONDS_PER_MILLISECOND)[dartx.truncate]();
    }
    get inMicroseconds() {
      return this[_duration];
    }
    ['=='](other) {
      if (!core.Duration.is(other)) return false;
      return dart.equals(this[_duration], dart.dload(other, _duration));
    }
    get hashCode() {
      return dart.hashCode(this[_duration]);
    }
    compareTo(other) {
      return this[_duration][dartx.compareTo](other[_duration]);
    }
    toString() {
      function sixDigits(n) {
        if (dart.notNull(n) >= 100000) return dart.str`${n}`;
        if (dart.notNull(n) >= 10000) return dart.str`0${n}`;
        if (dart.notNull(n) >= 1000) return dart.str`00${n}`;
        if (dart.notNull(n) >= 100) return dart.str`000${n}`;
        if (dart.notNull(n) >= 10) return dart.str`0000${n}`;
        return dart.str`00000${n}`;
      }
      dart.fn(sixDigits, intToString());
      function twoDigits(n) {
        if (dart.notNull(n) >= 10) return dart.str`${n}`;
        return dart.str`0${n}`;
      }
      dart.fn(twoDigits, intToString());
      if (dart.notNull(this.inMicroseconds) < 0) {
        return dart.str`-${this['unary-']()}`;
      }
      let twoDigitMinutes = twoDigits(dart.asInt(this.inMinutes[dartx.remainder](core.Duration.MINUTES_PER_HOUR)));
      let twoDigitSeconds = twoDigits(dart.asInt(this.inSeconds[dartx.remainder](core.Duration.SECONDS_PER_MINUTE)));
      let sixDigitUs = sixDigits(dart.asInt(this.inMicroseconds[dartx.remainder](core.Duration.MICROSECONDS_PER_SECOND)));
      return dart.str`${this.inHours}:${twoDigitMinutes}:${twoDigitSeconds}.${sixDigitUs}`;
    }
    get isNegative() {
      return dart.notNull(this[_duration]) < 0;
    }
    abs() {
      return new core.Duration._microseconds(this[_duration][dartx.abs]());
    }
    ['unary-']() {
      return new core.Duration._microseconds(-dart.notNull(this[_duration]));
    }
  };
  dart.defineNamedConstructor(core.Duration, '_microseconds');
  core.Duration[dart.implements] = () => [ComparableOfDuration()];
  dart.setSignature(core.Duration, {
    constructors: () => ({
      new: dart.definiteFunctionType(core.Duration, [], {days: core.int, hours: core.int, minutes: core.int, seconds: core.int, milliseconds: core.int, microseconds: core.int}),
      _microseconds: dart.definiteFunctionType(core.Duration, [core.int])
    }),
    methods: () => ({
      '+': dart.definiteFunctionType(core.Duration, [core.Duration]),
      '-': dart.definiteFunctionType(core.Duration, [core.Duration]),
      '*': dart.definiteFunctionType(core.Duration, [core.num]),
      '~/': dart.definiteFunctionType(core.Duration, [core.int]),
      '<': dart.definiteFunctionType(core.bool, [core.Duration]),
      '>': dart.definiteFunctionType(core.bool, [core.Duration]),
      '<=': dart.definiteFunctionType(core.bool, [core.Duration]),
      '>=': dart.definiteFunctionType(core.bool, [core.Duration]),
      compareTo: dart.definiteFunctionType(core.int, [core.Duration]),
      abs: dart.definiteFunctionType(core.Duration, []),
      'unary-': dart.definiteFunctionType(core.Duration, [])
    })
  });
  dart.defineExtensionMembers(core.Duration, ['compareTo']);
  core.Duration.MICROSECONDS_PER_MILLISECOND = 1000;
  core.Duration.MILLISECONDS_PER_SECOND = 1000;
  core.Duration.SECONDS_PER_MINUTE = 60;
  core.Duration.MINUTES_PER_HOUR = 60;
  core.Duration.HOURS_PER_DAY = 24;
  dart.defineLazy(core.Duration, {
    get MICROSECONDS_PER_SECOND() {
      return core.Duration.MICROSECONDS_PER_MILLISECOND * core.Duration.MILLISECONDS_PER_SECOND;
    },
    get MICROSECONDS_PER_MINUTE() {
      return core.Duration.MICROSECONDS_PER_SECOND * core.Duration.SECONDS_PER_MINUTE;
    },
    get MICROSECONDS_PER_HOUR() {
      return core.Duration.MICROSECONDS_PER_MINUTE * core.Duration.MINUTES_PER_HOUR;
    },
    get MICROSECONDS_PER_DAY() {
      return core.Duration.MICROSECONDS_PER_HOUR * core.Duration.HOURS_PER_DAY;
    },
    get MILLISECONDS_PER_MINUTE() {
      return core.Duration.MILLISECONDS_PER_SECOND * core.Duration.SECONDS_PER_MINUTE;
    },
    get MILLISECONDS_PER_HOUR() {
      return core.Duration.MILLISECONDS_PER_MINUTE * core.Duration.MINUTES_PER_HOUR;
    },
    get MILLISECONDS_PER_DAY() {
      return core.Duration.MILLISECONDS_PER_HOUR * core.Duration.HOURS_PER_DAY;
    },
    get SECONDS_PER_HOUR() {
      return core.Duration.SECONDS_PER_MINUTE * core.Duration.MINUTES_PER_HOUR;
    },
    get SECONDS_PER_DAY() {
      return core.Duration.SECONDS_PER_HOUR * core.Duration.HOURS_PER_DAY;
    },
    get MINUTES_PER_DAY() {
      return core.Duration.MINUTES_PER_HOUR * core.Duration.HOURS_PER_DAY;
    },
    get ZERO() {
      return dart.const(new core.Duration({seconds: 0}));
    }
  });
  core.TypeError = class TypeError extends core.AssertionError {
    new() {
      super.new();
    }
  };
  core.CastError = class CastError extends core.Error {
    new() {
      super.new();
    }
  };
  core.NullThrownError = class NullThrownError extends core.Error {
    new() {
      super.new();
    }
    toString() {
      return "Throw of null.";
    }
  };
  const _hasValue = Symbol('_hasValue');
  const _errorName = Symbol('_errorName');
  const _errorExplanation = Symbol('_errorExplanation');
  core.ArgumentError = class ArgumentError extends core.Error {
    new(message) {
      if (message === void 0) message = null;
      this.message = message;
      this.invalidValue = null;
      this[_hasValue] = false;
      this.name = null;
      super.new();
    }
    value(value, name, message) {
      if (name === void 0) name = null;
      if (message === void 0) message = null;
      this.name = name;
      this.message = message;
      this.invalidValue = value;
      this[_hasValue] = true;
      super.new();
    }
    notNull(name) {
      if (name === void 0) name = null;
      this.name = name;
      this[_hasValue] = false;
      this.message = "Must not be null";
      this.invalidValue = null;
      super.new();
    }
    get [_errorName]() {
      return dart.str`Invalid argument${!dart.test(this[_hasValue]) ? "(s)" : ""}`;
    }
    get [_errorExplanation]() {
      return "";
    }
    toString() {
      let nameString = "";
      if (this.name != null) {
        nameString = dart.str` (${this.name})`;
      }
      let message = this.message == null ? "" : dart.str`: ${this.message}`;
      let prefix = dart.str`${this[_errorName]}${nameString}${message}`;
      if (!dart.test(this[_hasValue])) return prefix;
      let explanation = this[_errorExplanation];
      let errorValue = core.Error.safeToString(this.invalidValue);
      return dart.str`${prefix}${explanation}: ${errorValue}`;
    }
  };
  dart.defineNamedConstructor(core.ArgumentError, 'value');
  dart.defineNamedConstructor(core.ArgumentError, 'notNull');
  dart.setSignature(core.ArgumentError, {
    constructors: () => ({
      new: dart.definiteFunctionType(core.ArgumentError, [], [dart.dynamic]),
      value: dart.definiteFunctionType(core.ArgumentError, [dart.dynamic], [core.String, core.String]),
      notNull: dart.definiteFunctionType(core.ArgumentError, [], [core.String])
    })
  });
  core.RangeError = class RangeError extends core.ArgumentError {
    new(message) {
      this.start = null;
      this.end = null;
      super.new(message);
    }
    value(value, name, message) {
      if (name === void 0) name = null;
      if (message === void 0) message = null;
      this.start = null;
      this.end = null;
      super.value(value, name, message != null ? message : "Value not in range");
    }
    range(invalidValue, minValue, maxValue, name, message) {
      if (name === void 0) name = null;
      if (message === void 0) message = null;
      this.start = minValue;
      this.end = maxValue;
      super.value(invalidValue, name, message != null ? message : "Invalid value");
    }
    static index(index, indexable, name, message, length) {
      return new core.IndexError(index, indexable, name, message, length);
    }
    static checkValueInInterval(value, minValue, maxValue, name, message) {
      if (name === void 0) name = null;
      if (message === void 0) message = null;
      if (dart.notNull(value) < dart.notNull(minValue) || dart.notNull(value) > dart.notNull(maxValue)) {
        dart.throw(new core.RangeError.range(value, minValue, maxValue, name, message));
      }
    }
    static checkValidIndex(index, indexable, name, length, message) {
      if (name === void 0) name = null;
      if (length === void 0) length = null;
      if (message === void 0) message = null;
      if (length == null) length = core.int._check(dart.dload(indexable, 'length'));
      if (0 > dart.notNull(index) || dart.notNull(index) >= dart.notNull(length)) {
        if (name == null) name = "index";
        dart.throw(core.RangeError.index(index, indexable, name, message, length));
      }
    }
    static checkValidRange(start, end, length, startName, endName, message) {
      if (startName === void 0) startName = null;
      if (endName === void 0) endName = null;
      if (message === void 0) message = null;
      if (0 > dart.notNull(start) || dart.notNull(start) > dart.notNull(length)) {
        if (startName == null) startName = "start";
        dart.throw(new core.RangeError.range(start, 0, length, startName, message));
      }
      if (end != null) {
        if (dart.notNull(start) > dart.notNull(end) || dart.notNull(end) > dart.notNull(length)) {
          if (endName == null) endName = "end";
          dart.throw(new core.RangeError.range(end, start, length, endName, message));
        }
        return end;
      }
      return length;
    }
    static checkNotNegative(value, name, message) {
      if (name === void 0) name = null;
      if (message === void 0) message = null;
      if (dart.notNull(value) < 0) dart.throw(new core.RangeError.range(value, 0, null, name, message));
    }
    get [_errorName]() {
      return "RangeError";
    }
    get [_errorExplanation]() {
      dart.assert(this[_hasValue]);
      let explanation = "";
      if (this.start == null) {
        if (this.end != null) {
          explanation = dart.str`: Not less than or equal to ${this.end}`;
        }
      } else if (this.end == null) {
        explanation = dart.str`: Not greater than or equal to ${this.start}`;
      } else if (dart.notNull(this.end) > dart.notNull(this.start)) {
        explanation = dart.str`: Not in range ${this.start}..${this.end}, inclusive`;
      } else if (dart.notNull(this.end) < dart.notNull(this.start)) {
        explanation = ": Valid value range is empty";
      } else {
        explanation = dart.str`: Only valid value is ${this.start}`;
      }
      return explanation;
    }
  };
  dart.defineNamedConstructor(core.RangeError, 'value');
  dart.defineNamedConstructor(core.RangeError, 'range');
  dart.setSignature(core.RangeError, {
    constructors: () => ({
      new: dart.definiteFunctionType(core.RangeError, [dart.dynamic]),
      value: dart.definiteFunctionType(core.RangeError, [core.num], [core.String, core.String]),
      range: dart.definiteFunctionType(core.RangeError, [core.num, core.int, core.int], [core.String, core.String]),
      index: dart.definiteFunctionType(core.RangeError, [core.int, dart.dynamic], [core.String, core.String, core.int])
    }),
    statics: () => ({
      checkValueInInterval: dart.definiteFunctionType(dart.void, [core.int, core.int, core.int], [core.String, core.String]),
      checkValidIndex: dart.definiteFunctionType(dart.void, [core.int, dart.dynamic], [core.String, core.int, core.String]),
      checkValidRange: dart.definiteFunctionType(core.int, [core.int, core.int, core.int], [core.String, core.String, core.String]),
      checkNotNegative: dart.definiteFunctionType(dart.void, [core.int], [core.String, core.String])
    }),
    names: ['checkValueInInterval', 'checkValidIndex', 'checkValidRange', 'checkNotNegative']
  });
  core.IndexError = class IndexError extends core.ArgumentError {
    new(invalidValue, indexable, name, message, length) {
      if (name === void 0) name = null;
      if (message === void 0) message = null;
      if (length === void 0) length = null;
      this.indexable = indexable;
      this.length = core.int._check(length != null ? length : dart.dload(indexable, 'length'));
      super.value(invalidValue, name, message != null ? message : "Index out of range");
    }
    get start() {
      return 0;
    }
    get end() {
      return dart.notNull(this.length) - 1;
    }
    get [_errorName]() {
      return "RangeError";
    }
    get [_errorExplanation]() {
      dart.assert(this[_hasValue]);
      if (dart.test(dart.dsend(this.invalidValue, '<', 0))) {
        return ": index must not be negative";
      }
      if (this.length == 0) {
        return ": no indices are valid";
      }
      return dart.str`: index should be less than ${this.length}`;
    }
  };
  core.IndexError[dart.implements] = () => [core.RangeError];
  dart.setSignature(core.IndexError, {
    constructors: () => ({new: dart.definiteFunctionType(core.IndexError, [core.int, dart.dynamic], [core.String, core.String, core.int])})
  });
  const _className = Symbol('_className');
  core.AbstractClassInstantiationError = class AbstractClassInstantiationError extends core.Error {
    new(className) {
      this[_className] = className;
      super.new();
    }
    toString() {
      return dart.str`Cannot instantiate abstract class: '${this[_className]}'`;
    }
  };
  dart.setSignature(core.AbstractClassInstantiationError, {
    constructors: () => ({new: dart.definiteFunctionType(core.AbstractClassInstantiationError, [core.String])})
  });
  const _receiver$ = Symbol('_receiver');
  const _memberName = Symbol('_memberName');
  const _arguments = Symbol('_arguments');
  const _namedArguments = Symbol('_namedArguments');
  const _existingArgumentNames = Symbol('_existingArgumentNames');
  core.NoSuchMethodError = class NoSuchMethodError extends core.Error {
    new(receiver, memberName, positionalArguments, namedArguments, existingArgumentNames) {
      if (existingArgumentNames === void 0) existingArgumentNames = null;
      this[_receiver$] = receiver;
      this[_memberName] = memberName;
      this[_arguments] = positionalArguments;
      this[_namedArguments] = namedArguments;
      this[_existingArgumentNames] = existingArgumentNames;
      super.new();
    }
    toString() {
      let sb = new core.StringBuffer();
      let i = 0;
      if (this[_arguments] != null) {
        for (; i < dart.notNull(this[_arguments][dartx.length]); i++) {
          if (i > 0) {
            sb.write(", ");
          }
          sb.write(core.Error.safeToString(this[_arguments][dartx.get](i)));
        }
      }
      if (this[_namedArguments] != null) {
        this[_namedArguments][dartx.forEach](dart.fn((key, value) => {
          if (i > 0) {
            sb.write(", ");
          }
          sb.write(core._symbolToString(key));
          sb.write(": ");
          sb.write(core.Error.safeToString(value));
          i++;
        }, SymbolAnddynamicTovoid()));
      }
      if (this[_existingArgumentNames] == null) {
        return dart.str`NoSuchMethodError : method not found: '${this[_memberName]}'\n` + dart.str`Receiver: ${core.Error.safeToString(this[_receiver$])}\n` + dart.str`Arguments: [${sb}]`;
      } else {
        let actualParameters = sb.toString();
        sb = new core.StringBuffer();
        for (let i = 0; i < dart.notNull(this[_existingArgumentNames][dartx.length]); i++) {
          if (i > 0) {
            sb.write(", ");
          }
          sb.write(this[_existingArgumentNames][dartx.get](i));
        }
        let formalParameters = sb.toString();
        return "NoSuchMethodError: incorrect number of arguments passed to " + dart.str`method named '${this[_memberName]}'\n` + dart.str`Receiver: ${core.Error.safeToString(this[_receiver$])}\n` + dart.str`Tried calling: ${this[_memberName]}(${actualParameters})\n` + dart.str`Found: ${this[_memberName]}(${formalParameters})`;
      }
    }
  };
  dart.setSignature(core.NoSuchMethodError, {
    constructors: () => ({new: dart.definiteFunctionType(core.NoSuchMethodError, [core.Object, core.Symbol, core.List, core.Map$(core.Symbol, dart.dynamic)], [core.List])})
  });
  core.UnsupportedError = class UnsupportedError extends core.Error {
    new(message) {
      this.message = message;
      super.new();
    }
    toString() {
      return dart.str`Unsupported operation: ${this.message}`;
    }
  };
  dart.setSignature(core.UnsupportedError, {
    constructors: () => ({new: dart.definiteFunctionType(core.UnsupportedError, [core.String])})
  });
  core.UnimplementedError = class UnimplementedError extends core.Error {
    new(message) {
      if (message === void 0) message = null;
      this.message = message;
      super.new();
    }
    toString() {
      return this.message != null ? dart.str`UnimplementedError: ${this.message}` : "UnimplementedError";
    }
  };
  core.UnimplementedError[dart.implements] = () => [core.UnsupportedError];
  dart.setSignature(core.UnimplementedError, {
    constructors: () => ({new: dart.definiteFunctionType(core.UnimplementedError, [], [core.String])})
  });
  core.StateError = class StateError extends core.Error {
    new(message) {
      this.message = message;
      super.new();
    }
    toString() {
      return dart.str`Bad state: ${this.message}`;
    }
  };
  dart.setSignature(core.StateError, {
    constructors: () => ({new: dart.definiteFunctionType(core.StateError, [core.String])})
  });
  core.ConcurrentModificationError = class ConcurrentModificationError extends core.Error {
    new(modifiedObject) {
      if (modifiedObject === void 0) modifiedObject = null;
      this.modifiedObject = modifiedObject;
      super.new();
    }
    toString() {
      if (this.modifiedObject == null) {
        return "Concurrent modification during iteration.";
      }
      return "Concurrent modification during iteration: " + dart.str`${core.Error.safeToString(this.modifiedObject)}.`;
    }
  };
  dart.setSignature(core.ConcurrentModificationError, {
    constructors: () => ({new: dart.definiteFunctionType(core.ConcurrentModificationError, [], [core.Object])})
  });
  core.OutOfMemoryError = class OutOfMemoryError extends core.Object {
    new() {
    }
    toString() {
      return "Out of Memory";
    }
    get stackTrace() {
      return null;
    }
  };
  core.OutOfMemoryError[dart.implements] = () => [core.Error];
  dart.setSignature(core.OutOfMemoryError, {
    constructors: () => ({new: dart.definiteFunctionType(core.OutOfMemoryError, [])})
  });
  core.StackOverflowError = class StackOverflowError extends core.Object {
    new() {
    }
    toString() {
      return "Stack Overflow";
    }
    get stackTrace() {
      return null;
    }
  };
  core.StackOverflowError[dart.implements] = () => [core.Error];
  dart.setSignature(core.StackOverflowError, {
    constructors: () => ({new: dart.definiteFunctionType(core.StackOverflowError, [])})
  });
  core.CyclicInitializationError = class CyclicInitializationError extends core.Error {
    new(variableName) {
      if (variableName === void 0) variableName = null;
      this.variableName = variableName;
      super.new();
    }
    toString() {
      return this.variableName == null ? "Reading static variable during its initialization" : dart.str`Reading static variable '${this.variableName}' during its initialization`;
    }
  };
  dart.setSignature(core.CyclicInitializationError, {
    constructors: () => ({new: dart.definiteFunctionType(core.CyclicInitializationError, [], [core.String])})
  });
  core.Exception = class Exception extends core.Object {
    static new(message) {
      if (message === void 0) message = null;
      return new core._Exception(message);
    }
  };
  dart.setSignature(core.Exception, {
    constructors: () => ({new: dart.definiteFunctionType(core.Exception, [], [dart.dynamic])})
  });
  core._Exception = class _Exception extends core.Object {
    new(message) {
      if (message === void 0) message = null;
      this.message = message;
    }
    toString() {
      if (this.message == null) return "Exception";
      return dart.str`Exception: ${this.message}`;
    }
  };
  core._Exception[dart.implements] = () => [core.Exception];
  dart.setSignature(core._Exception, {
    constructors: () => ({new: dart.definiteFunctionType(core._Exception, [], [dart.dynamic])})
  });
  core.FormatException = class FormatException extends core.Object {
    new(message, source, offset) {
      if (message === void 0) message = "";
      if (source === void 0) source = null;
      if (offset === void 0) offset = null;
      this.message = message;
      this.source = source;
      this.offset = offset;
    }
    toString() {
      let report = "FormatException";
      if (this.message != null && "" != this.message) {
        report = dart.str`${report}: ${this.message}`;
      }
      let offset = this.offset;
      if (!(typeof this.source == 'string')) {
        if (offset != null) {
          report = report + dart.str` (at offset ${offset})`;
        }
        return report;
      }
      if (offset != null && (dart.notNull(offset) < 0 || dart.notNull(offset) > dart.notNull(core.num._check(dart.dload(this.source, 'length'))))) {
        offset = null;
      }
      if (offset == null) {
        let source = core.String._check(this.source);
        if (dart.notNull(source[dartx.length]) > 78) {
          source = dart.notNull(source[dartx.substring](0, 75)) + "...";
        }
        return dart.str`${report}\n${source}`;
      }
      let lineNum = 1;
      let lineStart = 0;
      let lastWasCR = null;
      for (let i = 0; i < dart.notNull(offset); i++) {
        let char = core.int._check(dart.dsend(this.source, 'codeUnitAt', i));
        if (char == 10) {
          if (lineStart != i || !dart.test(lastWasCR)) {
            lineNum++;
          }
          lineStart = i + 1;
          lastWasCR = false;
        } else if (char == 13) {
          lineNum++;
          lineStart = i + 1;
          lastWasCR = true;
        }
      }
      if (lineNum > 1) {
        report = report + dart.str` (at line ${lineNum}, character ${dart.notNull(offset) - lineStart + 1})\n`;
      } else {
        report = report + dart.str` (at character ${dart.notNull(offset) + 1})\n`;
      }
      let lineEnd = core.int._check(dart.dload(this.source, 'length'));
      for (let i = offset; dart.notNull(i) < dart.notNull(core.num._check(dart.dload(this.source, 'length'))); i = dart.notNull(i) + 1) {
        let char = core.int._check(dart.dsend(this.source, 'codeUnitAt', i));
        if (char == 10 || char == 13) {
          lineEnd = i;
          break;
        }
      }
      let length = dart.notNull(lineEnd) - lineStart;
      let start = lineStart;
      let end = lineEnd;
      let prefix = "";
      let postfix = "";
      if (length > 78) {
        let index = dart.notNull(offset) - lineStart;
        if (index < 75) {
          end = start + 75;
          postfix = "...";
        } else if (dart.notNull(end) - dart.notNull(offset) < 75) {
          start = dart.notNull(end) - 75;
          prefix = "...";
        } else {
          start = dart.notNull(offset) - 36;
          end = dart.notNull(offset) + 36;
          prefix = postfix = "...";
        }
      }
      let slice = core.String._check(dart.dsend(this.source, 'substring', start, end));
      let markOffset = dart.notNull(offset) - start + dart.notNull(prefix[dartx.length]);
      return dart.str`${report}${prefix}${slice}${postfix}\n${" "[dartx['*']](markOffset)}^\n`;
    }
  };
  core.FormatException[dart.implements] = () => [core.Exception];
  dart.setSignature(core.FormatException, {
    constructors: () => ({new: dart.definiteFunctionType(core.FormatException, [], [core.String, dart.dynamic, core.int])})
  });
  core.IntegerDivisionByZeroException = class IntegerDivisionByZeroException extends core.Object {
    new() {
    }
    toString() {
      return "IntegerDivisionByZeroException";
    }
  };
  core.IntegerDivisionByZeroException[dart.implements] = () => [core.Exception];
  dart.setSignature(core.IntegerDivisionByZeroException, {
    constructors: () => ({new: dart.definiteFunctionType(core.IntegerDivisionByZeroException, [])})
  });
  const _getKey = Symbol('_getKey');
  core.Expando$ = dart.generic(T => {
    class Expando extends core.Object {
      new(name) {
        if (name === void 0) name = null;
        this.name = name;
      }
      toString() {
        return dart.str`Expando:${this.name}`;
      }
      get(object) {
        let values = _js_helper.Primitives.getProperty(object, core.Expando._EXPANDO_PROPERTY_NAME);
        return T._check(values == null ? null : _js_helper.Primitives.getProperty(values, this[_getKey]()));
      }
      set(object, value) {
        T._check(value);
        let values = _js_helper.Primitives.getProperty(object, core.Expando._EXPANDO_PROPERTY_NAME);
        if (values == null) {
          values = new core.Object();
          _js_helper.Primitives.setProperty(object, core.Expando._EXPANDO_PROPERTY_NAME, values);
        }
        _js_helper.Primitives.setProperty(values, this[_getKey](), value);
        return value;
      }
      [_getKey]() {
        let key = core.String._check(_js_helper.Primitives.getProperty(this, core.Expando._KEY_PROPERTY_NAME));
        if (key == null) {
          key = dart.str`expando\$key\$${(() => {
            let x = core.Expando._keyCount;
            core.Expando._keyCount = dart.notNull(x) + 1;
            return x;
          })()}`;
          _js_helper.Primitives.setProperty(this, core.Expando._KEY_PROPERTY_NAME, key);
        }
        return key;
      }
    }
    dart.addTypeTests(Expando);
    dart.setSignature(Expando, {
      constructors: () => ({new: dart.definiteFunctionType(core.Expando$(T), [], [core.String])}),
      methods: () => ({
        get: dart.definiteFunctionType(T, [core.Object]),
        set: dart.definiteFunctionType(dart.void, [core.Object, T]),
        [_getKey]: dart.definiteFunctionType(core.String, [])
      })
    });
    return Expando;
  });
  core.Expando = Expando();
  core.Expando._KEY_PROPERTY_NAME = 'expando$key';
  core.Expando._EXPANDO_PROPERTY_NAME = 'expando$values';
  core.Expando._keyCount = 0;
  core.Function = class Function extends core.Object {
    static apply(f, positionalArguments, namedArguments) {
      if (namedArguments === void 0) namedArguments = null;
      return dart.dcall.apply(null, [f].concat(positionalArguments));
    }
    static _toMangledNames(namedArguments) {
      let result = dart.map();
      namedArguments[dartx.forEach](dart.fn((symbol, value) => {
        result[dartx.set](core._symbolToString(symbol), value);
      }, SymbolAnddynamicTovoid()));
      return result;
    }
  };
  dart.setSignature(core.Function, {
    statics: () => ({
      apply: dart.definiteFunctionType(dart.dynamic, [core.Function, core.List], [core.Map$(core.Symbol, dart.dynamic)]),
      _toMangledNames: dart.definiteFunctionType(core.Map$(core.String, dart.dynamic), [core.Map$(core.Symbol, dart.dynamic)])
    }),
    names: ['apply', '_toMangledNames']
  });
  core.identical = function(a, b) {
    return a == null ? b == null : a === b;
  };
  dart.fn(core.identical, ObjectAndObjectTobool());
  core.identityHashCode = function(object) {
    return _js_helper.objectHashCode(object);
  };
  dart.fn(core.identityHashCode, ObjectToint());
  core._Generator$ = dart.generic(E => {
    const _Generator = dart.typedef('_Generator', () => dart.functionType(E, [core.int]));
    return _Generator;
  });
  core._Generator = _Generator();
  const _end$ = Symbol('_end');
  const _start$0 = Symbol('_start');
  const _generator$ = Symbol('_generator');
  core._GeneratorIterable$ = dart.generic(E => {
    let _GeneratorOfE = () => (_GeneratorOfE = dart.constFn(core._Generator$(E)))();
    let _GeneratorIteratorOfE = () => (_GeneratorIteratorOfE = dart.constFn(core._GeneratorIterator$(E)))();
    let EmptyIterableOfE = () => (EmptyIterableOfE = dart.constFn(_internal.EmptyIterable$(E)))();
    let _GeneratorIterableOfE = () => (_GeneratorIterableOfE = dart.constFn(core._GeneratorIterable$(E)))();
    class _GeneratorIterable extends core.Iterable$(E) {
      new(end, generator) {
        this[_end$] = end;
        this[_start$0] = 0;
        this[_generator$] = generator != null ? generator : _GeneratorOfE().as(core._GeneratorIterable._id);
        super.new();
      }
      slice(start, end, generator) {
        this[_start$0] = start;
        this[_end$] = end;
        this[_generator$] = generator;
        super.new();
      }
      get iterator() {
        return new (_GeneratorIteratorOfE())(this[_start$0], this[_end$], this[_generator$]);
      }
      get length() {
        return dart.notNull(this[_end$]) - dart.notNull(this[_start$0]);
      }
      skip(count) {
        core.RangeError.checkNotNegative(count, "count");
        if (count == 0) return this;
        let newStart = dart.notNull(this[_start$0]) + dart.notNull(count);
        if (newStart >= dart.notNull(this[_end$])) return new (EmptyIterableOfE())();
        return new (_GeneratorIterableOfE()).slice(newStart, this[_end$], this[_generator$]);
      }
      take(count) {
        core.RangeError.checkNotNegative(count, "count");
        if (count == 0) return new (EmptyIterableOfE())();
        let newEnd = dart.notNull(this[_start$0]) + dart.notNull(count);
        if (newEnd >= dart.notNull(this[_end$])) return this;
        return new (_GeneratorIterableOfE()).slice(this[_start$0], newEnd, this[_generator$]);
      }
      static _id(n) {
        return n;
      }
    }
    dart.defineNamedConstructor(_GeneratorIterable, 'slice');
    _GeneratorIterable[dart.implements] = () => [_internal.EfficientLength];
    dart.setSignature(_GeneratorIterable, {
      constructors: () => ({
        new: dart.definiteFunctionType(core._GeneratorIterable$(E), [core.int, dart.functionType(E, [core.int])]),
        slice: dart.definiteFunctionType(core._GeneratorIterable$(E), [core.int, core.int, core._Generator$(E)])
      }),
      methods: () => ({
        skip: dart.definiteFunctionType(core.Iterable$(E), [core.int]),
        take: dart.definiteFunctionType(core.Iterable$(E), [core.int])
      }),
      statics: () => ({_id: dart.definiteFunctionType(core.int, [core.int])}),
      names: ['_id']
    });
    dart.defineExtensionMembers(_GeneratorIterable, ['skip', 'take', 'iterator', 'length']);
    return _GeneratorIterable;
  });
  core._GeneratorIterable = _GeneratorIterable();
  const _index$1 = Symbol('_index');
  const _current$3 = Symbol('_current');
  core._GeneratorIterator$ = dart.generic(E => {
    let IteratorOfE = () => (IteratorOfE = dart.constFn(core.Iterator$(E)))();
    class _GeneratorIterator extends core.Object {
      new(index, end, generator) {
        this[_index$1] = index;
        this[_end$] = end;
        this[_generator$] = generator;
        this[_current$3] = null;
      }
      moveNext() {
        if (dart.notNull(this[_index$1]) < dart.notNull(this[_end$])) {
          this[_current$3] = this[_generator$](this[_index$1]);
          this[_index$1] = dart.notNull(this[_index$1]) + 1;
          return true;
        } else {
          this[_current$3] = null;
          return false;
        }
      }
      get current() {
        return this[_current$3];
      }
    }
    dart.addTypeTests(_GeneratorIterator);
    _GeneratorIterator[dart.implements] = () => [IteratorOfE()];
    dart.setSignature(_GeneratorIterator, {
      constructors: () => ({new: dart.definiteFunctionType(core._GeneratorIterator$(E), [core.int, core.int, core._Generator$(E)])}),
      methods: () => ({moveNext: dart.definiteFunctionType(core.bool, [])})
    });
    return _GeneratorIterator;
  });
  core._GeneratorIterator = _GeneratorIterator();
  core.BidirectionalIterator$ = dart.generic(E => {
    let IteratorOfE = () => (IteratorOfE = dart.constFn(core.Iterator$(E)))();
    class BidirectionalIterator extends core.Object {}
    dart.addTypeTests(BidirectionalIterator);
    BidirectionalIterator[dart.implements] = () => [IteratorOfE()];
    return BidirectionalIterator;
  });
  core.BidirectionalIterator = BidirectionalIterator();
  core.Map$ = dart.generic((K, V) => {
    let JsLinkedHashMapOfK$V = () => (JsLinkedHashMapOfK$V = dart.constFn(_js_helper.JsLinkedHashMap$(K, V)))();
    let LinkedHashMapOfK$V = () => (LinkedHashMapOfK$V = dart.constFn(collection.LinkedHashMap$(K, V)))();
    let UnmodifiableMapViewOfK$V = () => (UnmodifiableMapViewOfK$V = dart.constFn(collection.UnmodifiableMapView$(K, V)))();
    let MapOfK$V = () => (MapOfK$V = dart.constFn(core.Map$(K, V)))();
    let dynamicToK = () => (dynamicToK = dart.constFn(dart.functionType(K, [dart.dynamic])))();
    let dynamicToV = () => (dynamicToV = dart.constFn(dart.functionType(V, [dart.dynamic])))();
    class Map extends core.Object {
      static new() {
        return JsLinkedHashMapOfK$V().es6();
      }
      static from(other) {
        return LinkedHashMapOfK$V().from(other);
      }
      static unmodifiable(other) {
        return new (UnmodifiableMapViewOfK$V())(MapOfK$V().from(other));
      }
      static identity() {
        return LinkedHashMapOfK$V().identity();
      }
      static fromIterable(iterable, opts) {
        return LinkedHashMapOfK$V().fromIterable(iterable, opts);
      }
      static fromIterables(keys, values) {
        return LinkedHashMapOfK$V().fromIterables(keys, values);
      }
    }
    dart.addTypeTests(Map);
    dart.setSignature(Map, {
      constructors: () => ({
        new: dart.definiteFunctionType(core.Map$(K, V), []),
        from: dart.definiteFunctionType(core.Map$(K, V), [core.Map]),
        unmodifiable: dart.definiteFunctionType(core.Map$(K, V), [core.Map]),
        identity: dart.definiteFunctionType(core.Map$(K, V), []),
        fromIterable: dart.definiteFunctionType(core.Map$(K, V), [core.Iterable], {key: dynamicToK(), value: dynamicToV()}),
        fromIterables: dart.definiteFunctionType(core.Map$(K, V), [core.Iterable$(K), core.Iterable$(V)])
      })
    });
    return Map;
  });
  core.Map = Map$();
  core.Null = class Null extends core.Object {
    static _uninstantiable() {
      dart.throw(new core.UnsupportedError('class Null cannot be instantiated'));
    }
    toString() {
      return "null";
    }
  };
  core.Null.is = function is_Null(o) {
    return o == null;
  };
  core.Null.as = function as_Null(o) {
    if (o == null) return o;
    return dart.as(o, core.Null);
  };
  core.Null._check = function check_Null(o) {
    if (o == null) return o;
    return dart.check(o, core.Null);
  };
  dart.setSignature(core.Null, {
    constructors: () => ({_uninstantiable: dart.definiteFunctionType(core.Null, [])})
  });
  core.Pattern = class Pattern extends core.Object {};
  core.print = function(object) {
    let line = dart.str`${object}`;
    if (_internal.printToZone == null) {
      _internal.printToConsole(line);
    } else {
      dart.dcall(_internal.printToZone, line);
    }
  };
  dart.fn(core.print, ObjectTovoid());
  core.RegExp = class RegExp extends core.Object {
    static new(source, opts) {
      let multiLine = opts && 'multiLine' in opts ? opts.multiLine : false;
      let caseSensitive = opts && 'caseSensitive' in opts ? opts.caseSensitive : true;
      return new _js_helper.JSSyntaxRegExp(source, {multiLine: multiLine, caseSensitive: caseSensitive});
    }
  };
  core.RegExp[dart.implements] = () => [core.Pattern];
  dart.setSignature(core.RegExp, {
    constructors: () => ({new: dart.definiteFunctionType(core.RegExp, [core.String], {multiLine: core.bool, caseSensitive: core.bool})})
  });
  core.Set$ = dart.generic(E => {
    let LinkedHashSetOfE = () => (LinkedHashSetOfE = dart.constFn(collection.LinkedHashSet$(E)))();
    class Set extends core.Iterable$(E) {
      static new() {
        return LinkedHashSetOfE().new();
      }
      static identity() {
        return LinkedHashSetOfE().identity();
      }
      static from(elements) {
        return LinkedHashSetOfE().from(elements);
      }
    }
    Set[dart.implements] = () => [_internal.EfficientLength];
    dart.setSignature(Set, {
      constructors: () => ({
        new: dart.definiteFunctionType(core.Set$(E), []),
        identity: dart.definiteFunctionType(core.Set$(E), []),
        from: dart.definiteFunctionType(core.Set$(E), [core.Iterable$(E)])
      })
    });
    return Set;
  });
  core.Set = Set();
  core.Sink$ = dart.generic(T => {
    class Sink extends core.Object {}
    dart.addTypeTests(Sink);
    return Sink;
  });
  core.Sink = Sink();
  core.StackTrace = class StackTrace extends core.Object {
    new() {
    }
    static fromString(stackTraceString) {
      return new core._StringStackTrace(stackTraceString);
    }
    static get current() {
      if (Error.captureStackTrace != null) {
        let error = new Error();
        Error.captureStackTrace(error);
        return _js_helper.getTraceFromException(error);
      }
      try {
        dart.throw('');
      } catch (_) {
        let stackTrace = dart.stackTrace(_);
        return stackTrace;
      }

    }
  };
  dart.setSignature(core.StackTrace, {
    constructors: () => ({
      new: dart.definiteFunctionType(core.StackTrace, []),
      fromString: dart.definiteFunctionType(core.StackTrace, [core.String])
    })
  });
  const _stackTrace = Symbol('_stackTrace');
  core._StringStackTrace = class _StringStackTrace extends core.Object {
    new(stackTrace) {
      this[_stackTrace] = stackTrace;
    }
    toString() {
      return this[_stackTrace];
    }
  };
  core._StringStackTrace[dart.implements] = () => [core.StackTrace];
  dart.setSignature(core._StringStackTrace, {
    constructors: () => ({new: dart.definiteFunctionType(core._StringStackTrace, [core.String])})
  });
  const _stop = Symbol('_stop');
  core.Stopwatch = class Stopwatch extends core.Object {
    get frequency() {
      return core.Stopwatch._frequency;
    }
    new() {
      this[_start$0] = null;
      this[_stop] = null;
      core.Stopwatch._initTicker();
    }
    start() {
      if (dart.test(this.isRunning)) return;
      if (this[_start$0] == null) {
        this[_start$0] = core.Stopwatch._now();
      } else {
        this[_start$0] = dart.notNull(core.Stopwatch._now()) - (dart.notNull(this[_stop]) - dart.notNull(this[_start$0]));
        this[_stop] = null;
      }
    }
    stop() {
      if (!dart.test(this.isRunning)) return;
      this[_stop] = core.Stopwatch._now();
    }
    reset() {
      if (this[_start$0] == null) return;
      this[_start$0] = core.Stopwatch._now();
      if (this[_stop] != null) {
        this[_stop] = this[_start$0];
      }
    }
    get elapsedTicks() {
      if (this[_start$0] == null) {
        return 0;
      }
      return this[_stop] == null ? dart.notNull(core.Stopwatch._now()) - dart.notNull(this[_start$0]) : dart.notNull(this[_stop]) - dart.notNull(this[_start$0]);
    }
    get elapsed() {
      return new core.Duration({microseconds: this.elapsedMicroseconds});
    }
    get elapsedMicroseconds() {
      return (dart.notNull(this.elapsedTicks) * 1000000 / dart.notNull(this.frequency))[dartx.truncate]();
    }
    get elapsedMilliseconds() {
      return (dart.notNull(this.elapsedTicks) * 1000 / dart.notNull(this.frequency))[dartx.truncate]();
    }
    get isRunning() {
      return this[_start$0] != null && this[_stop] == null;
    }
    static _initTicker() {
      _js_helper.Primitives.initTicker();
      core.Stopwatch._frequency = _js_helper.Primitives.timerFrequency;
    }
    static _now() {
      return core.int._check(dart.dsend(_js_helper.Primitives, 'timerTicks'));
    }
  };
  dart.setSignature(core.Stopwatch, {
    constructors: () => ({new: dart.definiteFunctionType(core.Stopwatch, [])}),
    methods: () => ({
      start: dart.definiteFunctionType(dart.void, []),
      stop: dart.definiteFunctionType(dart.void, []),
      reset: dart.definiteFunctionType(dart.void, [])
    }),
    statics: () => ({
      _initTicker: dart.definiteFunctionType(dart.void, []),
      _now: dart.definiteFunctionType(core.int, [])
    }),
    names: ['_initTicker', '_now']
  });
  core.Stopwatch._frequency = null;
  core.Runes = class Runes extends core.Iterable$(core.int) {
    new(string) {
      this.string = string;
      super.new();
    }
    get iterator() {
      return new core.RuneIterator(this.string);
    }
    get last() {
      if (this.string[dartx.length] == 0) {
        dart.throw(new core.StateError('No elements.'));
      }
      let length = this.string[dartx.length];
      let code = this.string[dartx.codeUnitAt](dart.notNull(length) - 1);
      if (dart.test(core._isTrailSurrogate(code)) && dart.notNull(this.string[dartx.length]) > 1) {
        let previousCode = this.string[dartx.codeUnitAt](dart.notNull(length) - 2);
        if (dart.test(core._isLeadSurrogate(previousCode))) {
          return core._combineSurrogatePair(previousCode, code);
        }
      }
      return code;
    }
  };
  dart.addSimpleTypeTests(core.Runes);
  dart.setSignature(core.Runes, {
    constructors: () => ({new: dart.definiteFunctionType(core.Runes, [core.String])})
  });
  dart.defineExtensionMembers(core.Runes, ['iterator', 'last']);
  core._isLeadSurrogate = function(code) {
    return (dart.notNull(code) & 64512) == 55296;
  };
  dart.fn(core._isLeadSurrogate, intTobool());
  core._isTrailSurrogate = function(code) {
    return (dart.notNull(code) & 64512) == 56320;
  };
  dart.fn(core._isTrailSurrogate, intTobool());
  core._combineSurrogatePair = function(start, end) {
    return 65536 + ((dart.notNull(start) & 1023) << 10) + (dart.notNull(end) & 1023);
  };
  dart.fn(core._combineSurrogatePair, intAndintToint());
  const _position$ = Symbol('_position');
  const _nextPosition = Symbol('_nextPosition');
  const _currentCodePoint = Symbol('_currentCodePoint');
  const _checkSplitSurrogate = Symbol('_checkSplitSurrogate');
  core.RuneIterator = class RuneIterator extends core.Object {
    new(string) {
      this.string = string;
      this[_position$] = 0;
      this[_nextPosition] = 0;
      this[_currentCodePoint] = null;
    }
    at(string, index) {
      this.string = string;
      this[_position$] = index;
      this[_nextPosition] = index;
      this[_currentCodePoint] = null;
      core.RangeError.checkValueInInterval(index, 0, string[dartx.length]);
      this[_checkSplitSurrogate](index);
    }
    [_checkSplitSurrogate](index) {
      if (dart.notNull(index) > 0 && dart.notNull(index) < dart.notNull(this.string[dartx.length]) && dart.test(core._isLeadSurrogate(this.string[dartx.codeUnitAt](dart.notNull(index) - 1))) && dart.test(core._isTrailSurrogate(this.string[dartx.codeUnitAt](index)))) {
        dart.throw(new core.ArgumentError(dart.str`Index inside surrogate pair: ${index}`));
      }
    }
    get rawIndex() {
      return this[_position$] != this[_nextPosition] ? this[_position$] : null;
    }
    set rawIndex(rawIndex) {
      core.RangeError.checkValidIndex(rawIndex, this.string, "rawIndex");
      this.reset(rawIndex);
      this.moveNext();
    }
    reset(rawIndex) {
      if (rawIndex === void 0) rawIndex = 0;
      core.RangeError.checkValueInInterval(rawIndex, 0, this.string[dartx.length], "rawIndex");
      this[_checkSplitSurrogate](rawIndex);
      this[_position$] = this[_nextPosition] = rawIndex;
      this[_currentCodePoint] = null;
    }
    get current() {
      return this[_currentCodePoint];
    }
    get currentSize() {
      return dart.notNull(this[_nextPosition]) - dart.notNull(this[_position$]);
    }
    get currentAsString() {
      if (this[_position$] == this[_nextPosition]) return null;
      if (dart.notNull(this[_position$]) + 1 == this[_nextPosition]) return this.string[dartx.get](this[_position$]);
      return this.string[dartx.substring](this[_position$], this[_nextPosition]);
    }
    moveNext() {
      this[_position$] = this[_nextPosition];
      if (this[_position$] == this.string[dartx.length]) {
        this[_currentCodePoint] = null;
        return false;
      }
      let codeUnit = this.string[dartx.codeUnitAt](this[_position$]);
      let nextPosition = dart.notNull(this[_position$]) + 1;
      if (dart.test(core._isLeadSurrogate(codeUnit)) && nextPosition < dart.notNull(this.string[dartx.length])) {
        let nextCodeUnit = this.string[dartx.codeUnitAt](nextPosition);
        if (dart.test(core._isTrailSurrogate(nextCodeUnit))) {
          this[_nextPosition] = nextPosition + 1;
          this[_currentCodePoint] = core._combineSurrogatePair(codeUnit, nextCodeUnit);
          return true;
        }
      }
      this[_nextPosition] = nextPosition;
      this[_currentCodePoint] = codeUnit;
      return true;
    }
    movePrevious() {
      this[_nextPosition] = this[_position$];
      if (this[_position$] == 0) {
        this[_currentCodePoint] = null;
        return false;
      }
      let position = dart.notNull(this[_position$]) - 1;
      let codeUnit = this.string[dartx.codeUnitAt](position);
      if (dart.test(core._isTrailSurrogate(codeUnit)) && position > 0) {
        let prevCodeUnit = this.string[dartx.codeUnitAt](position - 1);
        if (dart.test(core._isLeadSurrogate(prevCodeUnit))) {
          this[_position$] = position - 1;
          this[_currentCodePoint] = core._combineSurrogatePair(prevCodeUnit, codeUnit);
          return true;
        }
      }
      this[_position$] = position;
      this[_currentCodePoint] = codeUnit;
      return true;
    }
  };
  dart.defineNamedConstructor(core.RuneIterator, 'at');
  core.RuneIterator[dart.implements] = () => [BidirectionalIteratorOfint()];
  dart.setSignature(core.RuneIterator, {
    constructors: () => ({
      new: dart.definiteFunctionType(core.RuneIterator, [core.String]),
      at: dart.definiteFunctionType(core.RuneIterator, [core.String, core.int])
    }),
    methods: () => ({
      [_checkSplitSurrogate]: dart.definiteFunctionType(dart.void, [core.int]),
      reset: dart.definiteFunctionType(dart.void, [], [core.int]),
      moveNext: dart.definiteFunctionType(core.bool, []),
      movePrevious: dart.definiteFunctionType(core.bool, [])
    })
  });
  const _contents = Symbol('_contents');
  const _writeString = Symbol('_writeString');
  core.StringBuffer = class StringBuffer extends core.Object {
    new(content) {
      if (content === void 0) content = "";
      this[_contents] = dart.str`${content}`;
    }
    get length() {
      return this[_contents][dartx.length];
    }
    get isEmpty() {
      return this.length == 0;
    }
    get isNotEmpty() {
      return !dart.test(this.isEmpty);
    }
    write(obj) {
      this[_writeString](dart.str`${obj}`);
    }
    writeCharCode(charCode) {
      this[_writeString](core.String.fromCharCode(charCode));
    }
    writeAll(objects, separator) {
      if (separator === void 0) separator = "";
      this[_contents] = core.StringBuffer._writeAll(this[_contents], objects, separator);
    }
    writeln(obj) {
      if (obj === void 0) obj = "";
      this[_writeString](dart.str`${obj}\n`);
    }
    clear() {
      this[_contents] = "";
    }
    toString() {
      return _js_helper.Primitives.flattenString(this[_contents]);
    }
    [_writeString](str) {
      this[_contents] = _js_helper.Primitives.stringConcatUnchecked(this[_contents], core.String._check(str));
    }
    static _writeAll(string, objects, separator) {
      let iterator = objects[dartx.iterator];
      if (!dart.test(iterator.moveNext())) return string;
      if (dart.test(separator[dartx.isEmpty])) {
        do {
          string = core.StringBuffer._writeOne(string, iterator.current);
        } while (dart.test(iterator.moveNext()));
      } else {
        string = core.StringBuffer._writeOne(string, iterator.current);
        while (dart.test(iterator.moveNext())) {
          string = core.StringBuffer._writeOne(string, separator);
          string = core.StringBuffer._writeOne(string, iterator.current);
        }
      }
      return string;
    }
    static _writeOne(string, obj) {
      return _js_helper.Primitives.stringConcatUnchecked(string, dart.str`${obj}`);
    }
  };
  core.StringBuffer[dart.implements] = () => [core.StringSink];
  dart.setSignature(core.StringBuffer, {
    constructors: () => ({new: dart.definiteFunctionType(core.StringBuffer, [], [core.Object])}),
    methods: () => ({
      write: dart.definiteFunctionType(dart.void, [core.Object]),
      writeCharCode: dart.definiteFunctionType(dart.void, [core.int]),
      writeAll: dart.definiteFunctionType(dart.void, [core.Iterable], [core.String]),
      writeln: dart.definiteFunctionType(dart.void, [], [core.Object]),
      clear: dart.definiteFunctionType(dart.void, []),
      [_writeString]: dart.definiteFunctionType(dart.void, [dart.dynamic])
    }),
    statics: () => ({
      _writeAll: dart.definiteFunctionType(core.String, [core.String, core.Iterable, core.String]),
      _writeOne: dart.definiteFunctionType(core.String, [core.String, core.Object])
    }),
    names: ['_writeAll', '_writeOne']
  });
  core.Symbol = class Symbol extends core.Object {
    static new(name) {
      return new _internal.Symbol(name);
    }
  };
  dart.setSignature(core.Symbol, {
    constructors: () => ({new: dart.definiteFunctionType(core.Symbol, [core.String])})
  });
  const _userInfo = Symbol('_userInfo');
  const _host = Symbol('_host');
  const _port = Symbol('_port');
  const _path = Symbol('_path');
  const _query = Symbol('_query');
  const _fragment = Symbol('_fragment');
  const _pathSegments = Symbol('_pathSegments');
  const _queryParameters = Symbol('_queryParameters');
  const _queryParameterLists = Symbol('_queryParameterLists');
  const _writeAuthority = Symbol('_writeAuthority');
  let const$46;
  const _mergePaths = Symbol('_mergePaths');
  const _toWindowsFilePath = Symbol('_toWindowsFilePath');
  const _toFilePath = Symbol('_toFilePath');
  const _isPathAbsolute = Symbol('_isPathAbsolute');
  core.Uri = class Uri extends core.Object {
    _internal(scheme, userInfo, host, port, path, query, fragment) {
      this.scheme = scheme;
      this[_userInfo] = userInfo;
      this[_host] = host;
      this[_port] = port;
      this[_path] = path;
      this[_query] = query;
      this[_fragment] = fragment;
      this[_pathSegments] = null;
      this[_queryParameters] = null;
      this[_queryParameterLists] = null;
    }
    static new(opts) {
      let scheme = opts && 'scheme' in opts ? opts.scheme : "";
      let userInfo = opts && 'userInfo' in opts ? opts.userInfo : "";
      let host = opts && 'host' in opts ? opts.host : null;
      let port = opts && 'port' in opts ? opts.port : null;
      let path = opts && 'path' in opts ? opts.path : null;
      let pathSegments = opts && 'pathSegments' in opts ? opts.pathSegments : null;
      let query = opts && 'query' in opts ? opts.query : null;
      let queryParameters = opts && 'queryParameters' in opts ? opts.queryParameters : null;
      let fragment = opts && 'fragment' in opts ? opts.fragment : null;
      scheme = core.Uri._makeScheme(scheme, 0, core.Uri._stringOrNullLength(scheme));
      userInfo = core.Uri._makeUserInfo(userInfo, 0, core.Uri._stringOrNullLength(userInfo));
      host = core.Uri._makeHost(host, 0, core.Uri._stringOrNullLength(host), false);
      if (query == "") query = null;
      query = core.Uri._makeQuery(query, 0, core.Uri._stringOrNullLength(query), queryParameters);
      fragment = core.Uri._makeFragment(fragment, 0, core.Uri._stringOrNullLength(fragment));
      port = core.Uri._makePort(port, scheme);
      let isFile = scheme == "file";
      if (host == null && (dart.test(userInfo[dartx.isNotEmpty]) || port != null || isFile)) {
        host = "";
      }
      let hasAuthority = host != null;
      path = core.Uri._makePath(path, 0, core.Uri._stringOrNullLength(path), pathSegments, scheme, hasAuthority);
      if (dart.test(scheme[dartx.isEmpty]) && host == null && !dart.test(path[dartx.startsWith]('/'))) {
        path = core.Uri._normalizeRelativePath(path);
      } else {
        path = core.Uri._removeDotSegments(path);
      }
      return new core.Uri._internal(scheme, userInfo, host, port, path, query, fragment);
    }
    static http(authority, unencodedPath, queryParameters) {
      if (queryParameters === void 0) queryParameters = null;
      return core.Uri._makeHttpUri("http", authority, unencodedPath, queryParameters);
    }
    static https(authority, unencodedPath, queryParameters) {
      if (queryParameters === void 0) queryParameters = null;
      return core.Uri._makeHttpUri("https", authority, unencodedPath, queryParameters);
    }
    get authority() {
      if (!dart.test(this.hasAuthority)) return "";
      let sb = new core.StringBuffer();
      this[_writeAuthority](sb);
      return sb.toString();
    }
    get userInfo() {
      return this[_userInfo];
    }
    get host() {
      if (this[_host] == null) return "";
      if (dart.test(this[_host][dartx.startsWith]('['))) {
        return this[_host][dartx.substring](1, dart.notNull(this[_host][dartx.length]) - 1);
      }
      return this[_host];
    }
    get port() {
      if (this[_port] == null) return core.Uri._defaultPort(this.scheme);
      return this[_port];
    }
    static _defaultPort(scheme) {
      if (scheme == "http") return 80;
      if (scheme == "https") return 443;
      return 0;
    }
    get path() {
      return this[_path];
    }
    get query() {
      return this[_query] == null ? "" : this[_query];
    }
    get fragment() {
      return this[_fragment] == null ? "" : this[_fragment];
    }
    static parse(uri, start, end) {
      if (start === void 0) start = 0;
      if (end === void 0) end = null;
      let EOI = -1;
      let scheme = "";
      let userinfo = "";
      let host = null;
      let port = null;
      let path = null;
      let query = null;
      let fragment = null;
      if (end == null) end = uri[dartx.length];
      let index = start;
      let pathStart = start;
      let char = EOI;
      function parseAuth() {
        if (index == end) {
          char = EOI;
          return;
        }
        let authStart = index;
        let lastColon = -1;
        let lastAt = -1;
        char = uri[dartx.codeUnitAt](index);
        while (dart.notNull(index) < dart.notNull(end)) {
          char = uri[dartx.codeUnitAt](index);
          if (char == core.Uri._SLASH || char == core.Uri._QUESTION || char == core.Uri._NUMBER_SIGN) {
            break;
          }
          if (char == core.Uri._AT_SIGN) {
            lastAt = index;
            lastColon = -1;
          } else if (char == core.Uri._COLON) {
            lastColon = index;
          } else if (char == core.Uri._LEFT_BRACKET) {
            lastColon = -1;
            let endBracket = uri[dartx.indexOf](']', dart.notNull(index) + 1);
            if (endBracket == -1) {
              index = end;
              char = EOI;
              break;
            } else {
              index = endBracket;
            }
          }
          index = dart.notNull(index) + 1;
          char = EOI;
        }
        let hostStart = authStart;
        let hostEnd = index;
        if (dart.notNull(lastAt) >= 0) {
          userinfo = core.Uri._makeUserInfo(uri, authStart, lastAt);
          hostStart = dart.notNull(lastAt) + 1;
        }
        if (dart.notNull(lastColon) >= 0) {
          let portNumber = null;
          if (dart.notNull(lastColon) + 1 < dart.notNull(index)) {
            portNumber = 0;
            for (let i = dart.notNull(lastColon) + 1; i < dart.notNull(index); i++) {
              let digit = uri[dartx.codeUnitAt](i);
              if (core.Uri._ZERO > dart.notNull(digit) || core.Uri._NINE < dart.notNull(digit)) {
                core.Uri._fail(uri, i, "Invalid port number");
              }
              portNumber = dart.notNull(portNumber) * 10 + (dart.notNull(digit) - core.Uri._ZERO);
            }
          }
          port = core.Uri._makePort(portNumber, scheme);
          hostEnd = lastColon;
        }
        host = core.Uri._makeHost(uri, hostStart, hostEnd, true);
        if (dart.notNull(index) < dart.notNull(end)) {
          char = uri[dartx.codeUnitAt](index);
        }
      }
      dart.fn(parseAuth, VoidTovoid$());
      let NOT_IN_PATH = 0;
      let IN_PATH = 1;
      let ALLOW_AUTH = 2;
      let state = NOT_IN_PATH;
      let i = index;
      while (dart.notNull(i) < dart.notNull(end)) {
        char = uri[dartx.codeUnitAt](i);
        if (char == core.Uri._QUESTION || char == core.Uri._NUMBER_SIGN) {
          state = NOT_IN_PATH;
          break;
        }
        if (char == core.Uri._SLASH) {
          state = i == start ? ALLOW_AUTH : IN_PATH;
          break;
        }
        if (char == core.Uri._COLON) {
          if (i == start) core.Uri._fail(uri, start, "Invalid empty scheme");
          scheme = core.Uri._makeScheme(uri, start, i);
          i = dart.notNull(i) + 1;
          pathStart = i;
          if (i == end) {
            char = EOI;
            state = NOT_IN_PATH;
          } else {
            char = uri[dartx.codeUnitAt](i);
            if (char == core.Uri._QUESTION || char == core.Uri._NUMBER_SIGN) {
              state = NOT_IN_PATH;
            } else if (char == core.Uri._SLASH) {
              state = ALLOW_AUTH;
            } else {
              state = IN_PATH;
            }
          }
          break;
        }
        i = dart.notNull(i) + 1;
        char = EOI;
      }
      index = i;
      if (state == ALLOW_AUTH) {
        dart.assert(char == core.Uri._SLASH);
        index = dart.notNull(index) + 1;
        if (index == end) {
          char = EOI;
          state = NOT_IN_PATH;
        } else {
          char = uri[dartx.codeUnitAt](index);
          if (char == core.Uri._SLASH) {
            index = dart.notNull(index) + 1;
            parseAuth();
            pathStart = index;
          }
          if (char == core.Uri._QUESTION || char == core.Uri._NUMBER_SIGN || char == EOI) {
            state = NOT_IN_PATH;
          } else {
            state = IN_PATH;
          }
        }
      }
      dart.assert(state == IN_PATH || state == NOT_IN_PATH);
      if (state == IN_PATH) {
        while ((index = dart.notNull(index) + 1) < dart.notNull(end)) {
          char = uri[dartx.codeUnitAt](index);
          if (char == core.Uri._QUESTION || char == core.Uri._NUMBER_SIGN) {
            break;
          }
          char = EOI;
        }
        state = NOT_IN_PATH;
      }
      dart.assert(state == NOT_IN_PATH);
      let hasAuthority = host != null;
      path = core.Uri._makePath(uri, pathStart, index, null, scheme, hasAuthority);
      if (char == core.Uri._QUESTION) {
        let numberSignIndex = -1;
        for (let i = dart.notNull(index) + 1; i < dart.notNull(end); i++) {
          if (uri[dartx.codeUnitAt](i) == core.Uri._NUMBER_SIGN) {
            numberSignIndex = i;
            break;
          }
        }
        if (numberSignIndex < 0) {
          query = core.Uri._makeQuery(uri, dart.notNull(index) + 1, end, null);
        } else {
          query = core.Uri._makeQuery(uri, dart.notNull(index) + 1, numberSignIndex, null);
          fragment = core.Uri._makeFragment(uri, numberSignIndex + 1, end);
        }
      } else if (char == core.Uri._NUMBER_SIGN) {
        fragment = core.Uri._makeFragment(uri, dart.notNull(index) + 1, end);
      }
      return new core.Uri._internal(scheme, userinfo, host, port, path, query, fragment);
    }
    static _fail(uri, index, message) {
      dart.throw(new core.FormatException(message, uri, index));
    }
    static _makeHttpUri(scheme, authority, unencodedPath, queryParameters) {
      let userInfo = "";
      let host = null;
      let port = null;
      if (authority != null && dart.test(authority[dartx.isNotEmpty])) {
        let hostStart = 0;
        let hasUserInfo = false;
        for (let i = 0; i < dart.notNull(authority[dartx.length]); i++) {
          if (authority[dartx.codeUnitAt](i) == core.Uri._AT_SIGN) {
            hasUserInfo = true;
            userInfo = authority[dartx.substring](0, i);
            hostStart = i + 1;
            break;
          }
        }
        let hostEnd = hostStart;
        if (hostStart < dart.notNull(authority[dartx.length]) && authority[dartx.codeUnitAt](hostStart) == core.Uri._LEFT_BRACKET) {
          for (; hostEnd < dart.notNull(authority[dartx.length]); hostEnd++) {
            if (authority[dartx.codeUnitAt](hostEnd) == core.Uri._RIGHT_BRACKET) break;
          }
          if (hostEnd == authority[dartx.length]) {
            dart.throw(new core.FormatException("Invalid IPv6 host entry.", authority, hostStart));
          }
          core.Uri.parseIPv6Address(authority, hostStart + 1, hostEnd);
          hostEnd++;
          if (hostEnd != authority[dartx.length] && authority[dartx.codeUnitAt](hostEnd) != core.Uri._COLON) {
            dart.throw(new core.FormatException("Invalid end of authority", authority, hostEnd));
          }
        }
        let hasPort = false;
        for (; hostEnd < dart.notNull(authority[dartx.length]); hostEnd++) {
          if (authority[dartx.codeUnitAt](hostEnd) == core.Uri._COLON) {
            let portString = authority[dartx.substring](hostEnd + 1);
            if (dart.test(portString[dartx.isNotEmpty])) port = core.int.parse(portString);
            break;
          }
        }
        host = authority[dartx.substring](hostStart, hostEnd);
      }
      return core.Uri.new({scheme: scheme, userInfo: userInfo, host: core.String._check(host), port: core.int._check(port), pathSegments: unencodedPath[dartx.split]("/"), queryParameters: queryParameters});
    }
    static file(path, opts) {
      let windows = opts && 'windows' in opts ? opts.windows : null;
      windows = windows == null ? core.Uri._isWindows : windows;
      return core.Uri._check(dart.test(windows) ? core.Uri._makeWindowsFileUrl(path, false) : core.Uri._makeFileUri(path, false));
    }
    static directory(path, opts) {
      let windows = opts && 'windows' in opts ? opts.windows : null;
      windows = windows == null ? core.Uri._isWindows : windows;
      return core.Uri._check(dart.test(windows) ? core.Uri._makeWindowsFileUrl(path, true) : core.Uri._makeFileUri(path, true));
    }
    static dataFromString(content, opts) {
      let mimeType = opts && 'mimeType' in opts ? opts.mimeType : null;
      let encoding = opts && 'encoding' in opts ? opts.encoding : null;
      let parameters = opts && 'parameters' in opts ? opts.parameters : null;
      let base64 = opts && 'base64' in opts ? opts.base64 : false;
      let data = core.UriData.fromString(content, {mimeType: mimeType, encoding: encoding, parameters: parameters, base64: base64});
      return data.uri;
    }
    static dataFromBytes(bytes, opts) {
      let mimeType = opts && 'mimeType' in opts ? opts.mimeType : "application/octet-stream";
      let parameters = opts && 'parameters' in opts ? opts.parameters : null;
      let percentEncoded = opts && 'percentEncoded' in opts ? opts.percentEncoded : false;
      let data = core.UriData.fromBytes(bytes, {mimeType: mimeType, parameters: parameters, percentEncoded: percentEncoded});
      return data.uri;
    }
    static get base() {
      let uri = _js_helper.Primitives.currentUri();
      if (uri != null) return core.Uri.parse(uri);
      dart.throw(new core.UnsupportedError("'Uri.base' is not supported"));
    }
    static get _isWindows() {
      return false;
    }
    static _checkNonWindowsPathReservedCharacters(segments, argumentError) {
      segments[dartx.forEach](dart.fn(segment => {
        if (dart.test(segment[dartx.contains]("/"))) {
          if (dart.test(argumentError)) {
            dart.throw(new core.ArgumentError(dart.str`Illegal path character ${segment}`));
          } else {
            dart.throw(new core.UnsupportedError(dart.str`Illegal path character ${segment}`));
          }
        }
      }, StringTovoid()));
    }
    static _checkWindowsPathReservedCharacters(segments, argumentError, firstSegment) {
      if (firstSegment === void 0) firstSegment = 0;
      for (let segment of segments[dartx.skip](firstSegment)) {
        if (dart.test(segment[dartx.contains](core.RegExp.new('["*/:<>?\\\\|]')))) {
          if (dart.test(argumentError)) {
            dart.throw(new core.ArgumentError("Illegal character in path"));
          } else {
            dart.throw(new core.UnsupportedError("Illegal character in path"));
          }
        }
      }
    }
    static _checkWindowsDriveLetter(charCode, argumentError) {
      if (core.Uri._UPPER_CASE_A <= dart.notNull(charCode) && dart.notNull(charCode) <= core.Uri._UPPER_CASE_Z || core.Uri._LOWER_CASE_A <= dart.notNull(charCode) && dart.notNull(charCode) <= core.Uri._LOWER_CASE_Z) {
        return;
      }
      if (dart.test(argumentError)) {
        dart.throw(new core.ArgumentError("Illegal drive letter " + core.String.fromCharCode(charCode)));
      } else {
        dart.throw(new core.UnsupportedError("Illegal drive letter " + core.String.fromCharCode(charCode)));
      }
    }
    static _makeFileUri(path, slashTerminated) {
      let sep = "/";
      let segments = path[dartx.split](sep);
      if (dart.test(slashTerminated) && dart.test(segments[dartx.isNotEmpty]) && dart.test(segments[dartx.last][dartx.isNotEmpty])) {
        segments[dartx.add]("");
      }
      if (dart.test(path[dartx.startsWith](sep))) {
        return core.Uri.new({scheme: "file", pathSegments: segments});
      } else {
        return core.Uri.new({pathSegments: segments});
      }
    }
    static _makeWindowsFileUrl(path, slashTerminated) {
      if (dart.test(path[dartx.startsWith]("\\\\?\\"))) {
        if (dart.test(path[dartx.startsWith]("UNC\\", 4))) {
          path = path[dartx.replaceRange](0, 7, '\\');
        } else {
          path = path[dartx.substring](4);
          if (dart.notNull(path[dartx.length]) < 3 || path[dartx.codeUnitAt](1) != core.Uri._COLON || path[dartx.codeUnitAt](2) != core.Uri._BACKSLASH) {
            dart.throw(new core.ArgumentError("Windows paths with \\\\?\\ prefix must be absolute"));
          }
        }
      } else {
        path = path[dartx.replaceAll]("/", '\\');
      }
      let sep = '\\';
      if (dart.notNull(path[dartx.length]) > 1 && path[dartx.codeUnitAt](1) == core.Uri._COLON) {
        core.Uri._checkWindowsDriveLetter(path[dartx.codeUnitAt](0), true);
        if (path[dartx.length] == 2 || path[dartx.codeUnitAt](2) != core.Uri._BACKSLASH) {
          dart.throw(new core.ArgumentError("Windows paths with drive letter must be absolute"));
        }
        let pathSegments = path[dartx.split](sep);
        if (dart.test(slashTerminated) && dart.test(pathSegments[dartx.last][dartx.isNotEmpty])) {
          pathSegments[dartx.add]("");
        }
        core.Uri._checkWindowsPathReservedCharacters(pathSegments, true, 1);
        return core.Uri.new({scheme: "file", pathSegments: pathSegments});
      }
      if (dart.test(path[dartx.startsWith](sep))) {
        if (dart.test(path[dartx.startsWith](sep, 1))) {
          let pathStart = path[dartx.indexOf]('\\', 2);
          let hostPart = dart.notNull(pathStart) < 0 ? path[dartx.substring](2) : path[dartx.substring](2, pathStart);
          let pathPart = dart.notNull(pathStart) < 0 ? "" : path[dartx.substring](dart.notNull(pathStart) + 1);
          let pathSegments = pathPart[dartx.split](sep);
          core.Uri._checkWindowsPathReservedCharacters(pathSegments, true);
          if (dart.test(slashTerminated) && dart.test(pathSegments[dartx.last][dartx.isNotEmpty])) {
            pathSegments[dartx.add]("");
          }
          return core.Uri.new({scheme: "file", host: hostPart, pathSegments: pathSegments});
        } else {
          let pathSegments = path[dartx.split](sep);
          if (dart.test(slashTerminated) && dart.test(pathSegments[dartx.last][dartx.isNotEmpty])) {
            pathSegments[dartx.add]("");
          }
          core.Uri._checkWindowsPathReservedCharacters(pathSegments, true);
          return core.Uri.new({scheme: "file", pathSegments: pathSegments});
        }
      } else {
        let pathSegments = path[dartx.split](sep);
        core.Uri._checkWindowsPathReservedCharacters(pathSegments, true);
        if (dart.test(slashTerminated) && dart.test(pathSegments[dartx.isNotEmpty]) && dart.test(pathSegments[dartx.last][dartx.isNotEmpty])) {
          pathSegments[dartx.add]("");
        }
        return core.Uri.new({pathSegments: pathSegments});
      }
    }
    replace(opts) {
      let scheme = opts && 'scheme' in opts ? opts.scheme : null;
      let userInfo = opts && 'userInfo' in opts ? opts.userInfo : null;
      let host = opts && 'host' in opts ? opts.host : null;
      let port = opts && 'port' in opts ? opts.port : null;
      let path = opts && 'path' in opts ? opts.path : null;
      let pathSegments = opts && 'pathSegments' in opts ? opts.pathSegments : null;
      let query = opts && 'query' in opts ? opts.query : null;
      let queryParameters = opts && 'queryParameters' in opts ? opts.queryParameters : null;
      let fragment = opts && 'fragment' in opts ? opts.fragment : null;
      let schemeChanged = false;
      if (scheme != null) {
        scheme = core.Uri._makeScheme(scheme, 0, scheme[dartx.length]);
        schemeChanged = true;
      } else {
        scheme = this.scheme;
      }
      let isFile = scheme == "file";
      if (userInfo != null) {
        userInfo = core.Uri._makeUserInfo(userInfo, 0, userInfo[dartx.length]);
      } else {
        userInfo = this[_userInfo];
      }
      if (port != null) {
        port = core.Uri._makePort(port, scheme);
      } else {
        port = this[_port];
        if (schemeChanged) {
          port = core.Uri._makePort(port, scheme);
        }
      }
      if (host != null) {
        host = core.Uri._makeHost(host, 0, host[dartx.length], false);
      } else if (dart.test(this.hasAuthority)) {
        host = this[_host];
      } else if (dart.test(userInfo[dartx.isNotEmpty]) || port != null || isFile) {
        host = "";
      }
      let hasAuthority = host != null;
      if (path != null || pathSegments != null) {
        path = core.Uri._makePath(path, 0, core.Uri._stringOrNullLength(path), pathSegments, scheme, hasAuthority);
      } else {
        path = this[_path];
        if ((isFile || hasAuthority && !dart.test(path[dartx.isEmpty])) && !dart.test(path[dartx.startsWith]('/'))) {
          path = "/" + dart.notNull(path);
        }
      }
      if (query != null || queryParameters != null) {
        query = core.Uri._makeQuery(query, 0, core.Uri._stringOrNullLength(query), queryParameters);
      } else {
        query = this[_query];
      }
      if (fragment != null) {
        fragment = core.Uri._makeFragment(fragment, 0, fragment[dartx.length]);
      } else {
        fragment = this[_fragment];
      }
      return new core.Uri._internal(scheme, userInfo, host, port, path, query, fragment);
    }
    removeFragment() {
      if (!dart.test(this.hasFragment)) return this;
      return new core.Uri._internal(this.scheme, this[_userInfo], this[_host], this[_port], this[_path], this[_query], null);
    }
    get pathSegments() {
      let result = this[_pathSegments];
      if (result != null) return result;
      let pathToSplit = this.path;
      if (dart.test(pathToSplit[dartx.isNotEmpty]) && pathToSplit[dartx.codeUnitAt](0) == core.Uri._SLASH) {
        pathToSplit = pathToSplit[dartx.substring](1);
      }
      result = pathToSplit == "" ? const$46 || (const$46 = dart.constList([], core.String)) : ListOfString().unmodifiable(pathToSplit[dartx.split]("/")[dartx.map](core.String)(core.Uri.decodeComponent));
      this[_pathSegments] = result;
      return result;
    }
    get queryParameters() {
      if (this[_queryParameters] == null) {
        this[_queryParameters] = new (UnmodifiableMapViewOfString$String())(core.Uri.splitQueryString(this.query));
      }
      return this[_queryParameters];
    }
    get queryParametersAll() {
      if (this[_queryParameterLists] == null) {
        let queryParameterLists = core.Uri._splitQueryStringAll(this.query);
        for (let key of queryParameterLists[dartx.keys]) {
          queryParameterLists[dartx.set](key, ListOfString().unmodifiable(core.Iterable._check(queryParameterLists[dartx.get](key))));
        }
        this[_queryParameterLists] = MapOfString$ListOfString().unmodifiable(queryParameterLists);
      }
      return this[_queryParameterLists];
    }
    normalizePath() {
      let path = core.Uri._normalizePath(this[_path], this.scheme, this.hasAuthority);
      if (core.identical(path, this[_path])) return this;
      return this.replace({path: path});
    }
    static _makePort(port, scheme) {
      if (port != null && port == core.Uri._defaultPort(scheme)) return null;
      return port;
    }
    static _makeHost(host, start, end, strictIPv6) {
      if (host == null) return null;
      if (start == end) return "";
      if (host[dartx.codeUnitAt](start) == core.Uri._LEFT_BRACKET) {
        if (host[dartx.codeUnitAt](dart.notNull(end) - 1) != core.Uri._RIGHT_BRACKET) {
          core.Uri._fail(host, start, 'Missing end `]` to match `[` in host');
        }
        core.Uri.parseIPv6Address(host, dart.notNull(start) + 1, dart.notNull(end) - 1);
        return host[dartx.substring](start, end)[dartx.toLowerCase]();
      }
      if (!dart.test(strictIPv6)) {
        for (let i = start; dart.notNull(i) < dart.notNull(end); i = dart.notNull(i) + 1) {
          if (host[dartx.codeUnitAt](i) == core.Uri._COLON) {
            core.Uri.parseIPv6Address(host, start, end);
            return dart.str`[${host}]`;
          }
        }
      }
      return core.Uri._normalizeRegName(host, start, end);
    }
    static _isRegNameChar(char) {
      return dart.notNull(char) < 127 && (dart.notNull(core.Uri._regNameTable[dartx.get](char[dartx['>>']](4))) & 1 << (dart.notNull(char) & 15)) != 0;
    }
    static _normalizeRegName(host, start, end) {
      let buffer = null;
      let sectionStart = start;
      let index = start;
      let isNormalized = true;
      while (dart.notNull(index) < dart.notNull(end)) {
        let char = host[dartx.codeUnitAt](index);
        if (char == core.Uri._PERCENT) {
          let replacement = core.Uri._normalizeEscape(host, index, true);
          if (replacement == null && isNormalized) {
            index = dart.notNull(index) + 3;
            continue;
          }
          if (buffer == null) buffer = new core.StringBuffer();
          let slice = host[dartx.substring](sectionStart, index);
          if (!isNormalized) slice = slice[dartx.toLowerCase]();
          buffer.write(slice);
          let sourceLength = 3;
          if (replacement == null) {
            replacement = host[dartx.substring](index, dart.notNull(index) + 3);
          } else if (replacement == "%") {
            replacement = "%25";
            sourceLength = 1;
          }
          buffer.write(replacement);
          index = dart.notNull(index) + sourceLength;
          sectionStart = index;
          isNormalized = true;
        } else if (dart.test(core.Uri._isRegNameChar(char))) {
          if (isNormalized && core.Uri._UPPER_CASE_A <= dart.notNull(char) && core.Uri._UPPER_CASE_Z >= dart.notNull(char)) {
            if (buffer == null) buffer = new core.StringBuffer();
            if (dart.notNull(sectionStart) < dart.notNull(index)) {
              buffer.write(host[dartx.substring](sectionStart, index));
              sectionStart = index;
            }
            isNormalized = false;
          }
          index = dart.notNull(index) + 1;
        } else if (dart.test(core.Uri._isGeneralDelimiter(char))) {
          core.Uri._fail(host, index, "Invalid character");
        } else {
          let sourceLength = 1;
          if ((dart.notNull(char) & 64512) == 55296 && dart.notNull(index) + 1 < dart.notNull(end)) {
            let tail = host[dartx.codeUnitAt](dart.notNull(index) + 1);
            if ((dart.notNull(tail) & 64512) == 56320) {
              char = 65536 | (dart.notNull(char) & 1023) << 10 | dart.notNull(tail) & 1023;
              sourceLength = 2;
            }
          }
          if (buffer == null) buffer = new core.StringBuffer();
          let slice = host[dartx.substring](sectionStart, index);
          if (!isNormalized) slice = slice[dartx.toLowerCase]();
          buffer.write(slice);
          buffer.write(core.Uri._escapeChar(char));
          index = dart.notNull(index) + sourceLength;
          sectionStart = index;
        }
      }
      if (buffer == null) return host[dartx.substring](start, end);
      if (dart.notNull(sectionStart) < dart.notNull(end)) {
        let slice = host[dartx.substring](sectionStart, end);
        if (!isNormalized) slice = slice[dartx.toLowerCase]();
        buffer.write(slice);
      }
      return dart.toString(buffer);
    }
    static _makeScheme(scheme, start, end) {
      if (start == end) return "";
      let firstCodeUnit = scheme[dartx.codeUnitAt](start);
      if (!dart.test(core.Uri._isAlphabeticCharacter(firstCodeUnit))) {
        core.Uri._fail(scheme, start, "Scheme not starting with alphabetic character");
      }
      let containsUpperCase = false;
      for (let i = start; dart.notNull(i) < dart.notNull(end); i = dart.notNull(i) + 1) {
        let codeUnit = scheme[dartx.codeUnitAt](i);
        if (!dart.test(core.Uri._isSchemeCharacter(codeUnit))) {
          core.Uri._fail(scheme, i, "Illegal scheme character");
        }
        if (core.Uri._UPPER_CASE_A <= dart.notNull(codeUnit) && dart.notNull(codeUnit) <= core.Uri._UPPER_CASE_Z) {
          containsUpperCase = true;
        }
      }
      scheme = scheme[dartx.substring](start, end);
      if (containsUpperCase) scheme = scheme[dartx.toLowerCase]();
      return scheme;
    }
    static _makeUserInfo(userInfo, start, end) {
      if (userInfo == null) return "";
      return core.Uri._normalize(userInfo, start, end, core.Uri._userinfoTable);
    }
    static _makePath(path, start, end, pathSegments, scheme, hasAuthority) {
      let isFile = scheme == "file";
      let ensureLeadingSlash = isFile || dart.test(hasAuthority);
      if (path == null && pathSegments == null) return isFile ? "/" : "";
      if (path != null && pathSegments != null) {
        dart.throw(new core.ArgumentError('Both path and pathSegments specified'));
      }
      let result = null;
      if (path != null) {
        result = core.Uri._normalize(path, start, end, core.Uri._pathCharOrSlashTable);
      } else {
        result = pathSegments[dartx.map](core.String)(dart.fn(s => core.Uri._uriEncode(core.Uri._pathCharTable, s, convert.UTF8, false), StringToString$()))[dartx.join]("/");
      }
      if (dart.test(dart.dload(result, 'isEmpty'))) {
        if (isFile) return "/";
      } else if (ensureLeadingSlash && !dart.test(dart.dsend(result, 'startsWith', '/'))) {
        result = "/" + dart.notNull(core.String._check(result));
      }
      result = core.Uri._normalizePath(core.String._check(result), scheme, hasAuthority);
      return core.String._check(result);
    }
    static _normalizePath(path, scheme, hasAuthority) {
      if (dart.test(scheme[dartx.isEmpty]) && !dart.test(hasAuthority) && !dart.test(path[dartx.startsWith]('/'))) {
        return core.Uri._normalizeRelativePath(path);
      }
      return core.Uri._removeDotSegments(path);
    }
    static _makeQuery(query, start, end, queryParameters) {
      if (query == null && queryParameters == null) return null;
      if (query != null && queryParameters != null) {
        dart.throw(new core.ArgumentError('Both query and queryParameters specified'));
      }
      if (query != null) return core.Uri._normalize(query, start, end, core.Uri._queryCharTable);
      let result = new core.StringBuffer();
      let separator = "";
      function writeParameter(key, value) {
        result.write(separator);
        separator = "&";
        result.write(core.Uri.encodeQueryComponent(key));
        if (value != null && dart.test(value[dartx.isNotEmpty])) {
          result.write("=");
          result.write(core.Uri.encodeQueryComponent(value));
        }
      }
      dart.fn(writeParameter, StringAndStringTovoid());
      queryParameters[dartx.forEach](dart.fn((key, value) => {
        if (value == null || typeof value == 'string') {
          writeParameter(key, core.String._check(value));
        } else {
          let values = core.Iterable._check(value);
          for (let value of values) {
            core.String._check(value);
            writeParameter(key, value);
          }
        }
      }, StringAnddynamicTovoid()));
      return result.toString();
    }
    static _makeFragment(fragment, start, end) {
      if (fragment == null) return null;
      return core.Uri._normalize(fragment, start, end, core.Uri._queryCharTable);
    }
    static _stringOrNullLength(s) {
      return s == null ? 0 : s[dartx.length];
    }
    static _normalizeEscape(source, index, lowerCase) {
      dart.assert(source[dartx.codeUnitAt](index) == core.Uri._PERCENT);
      if (dart.notNull(index) + 2 >= dart.notNull(source[dartx.length])) {
        return "%";
      }
      let firstDigit = source[dartx.codeUnitAt](dart.notNull(index) + 1);
      let secondDigit = source[dartx.codeUnitAt](dart.notNull(index) + 2);
      let firstDigitValue = core.Uri._parseHexDigit(firstDigit);
      let secondDigitValue = core.Uri._parseHexDigit(secondDigit);
      if (dart.notNull(firstDigitValue) < 0 || dart.notNull(secondDigitValue) < 0) {
        return "%";
      }
      let value = dart.notNull(firstDigitValue) * 16 + dart.notNull(secondDigitValue);
      if (dart.test(core.Uri._isUnreservedChar(value))) {
        if (dart.test(lowerCase) && core.Uri._UPPER_CASE_A <= value && core.Uri._UPPER_CASE_Z >= value) {
          value = (value | 32) >>> 0;
        }
        return core.String.fromCharCode(value);
      }
      if (dart.notNull(firstDigit) >= core.Uri._LOWER_CASE_A || dart.notNull(secondDigit) >= core.Uri._LOWER_CASE_A) {
        return source[dartx.substring](index, dart.notNull(index) + 3)[dartx.toUpperCase]();
      }
      return null;
    }
    static _parseHexDigit(char) {
      let digit = (dart.notNull(char) ^ core.Uri._ZERO) >>> 0;
      if (digit <= 9) return digit;
      let lowerCase = (dart.notNull(char) | 32) >>> 0;
      if (core.Uri._LOWER_CASE_A <= lowerCase && lowerCase <= core.Uri._LOWER_CASE_F) {
        return lowerCase - (core.Uri._LOWER_CASE_A - 10);
      }
      return -1;
    }
    static _escapeChar(char) {
      dart.assert(dart.notNull(char) <= 1114111);
      let codeUnits = null;
      if (dart.notNull(char) < 128) {
        codeUnits = ListOfint().new(3);
        codeUnits[dartx.set](0, core.Uri._PERCENT);
        codeUnits[dartx.set](1, core.Uri._hexDigits[dartx.codeUnitAt](char[dartx['>>']](4)));
        codeUnits[dartx.set](2, core.Uri._hexDigits[dartx.codeUnitAt](dart.notNull(char) & 15));
      } else {
        let flag = 192;
        let encodedBytes = 2;
        if (dart.notNull(char) > 2047) {
          flag = 224;
          encodedBytes = 3;
          if (dart.notNull(char) > 65535) {
            encodedBytes = 4;
            flag = 240;
          }
        }
        codeUnits = ListOfint().new(3 * encodedBytes);
        let index = 0;
        while (--encodedBytes >= 0) {
          let byte = (char[dartx['>>']](6 * encodedBytes) & 63 | flag) >>> 0;
          codeUnits[dartx.set](index, core.Uri._PERCENT);
          codeUnits[dartx.set](index + 1, core.Uri._hexDigits[dartx.codeUnitAt](byte[dartx['>>']](4)));
          codeUnits[dartx.set](index + 2, core.Uri._hexDigits[dartx.codeUnitAt](byte & 15));
          index = index + 3;
          flag = 128;
        }
      }
      return core.String.fromCharCodes(codeUnits);
    }
    static _normalize(component, start, end, charTable) {
      let buffer = null;
      let sectionStart = start;
      let index = start;
      while (dart.notNull(index) < dart.notNull(end)) {
        let char = component[dartx.codeUnitAt](index);
        if (dart.notNull(char) < 127 && (dart.notNull(charTable[dartx.get](char[dartx['>>']](4))) & 1 << (dart.notNull(char) & 15)) != 0) {
          index = dart.notNull(index) + 1;
        } else {
          let replacement = null;
          let sourceLength = null;
          if (char == core.Uri._PERCENT) {
            replacement = core.Uri._normalizeEscape(component, index, false);
            if (replacement == null) {
              index = dart.notNull(index) + 3;
              continue;
            }
            if ("%" == replacement) {
              replacement = "%25";
              sourceLength = 1;
            } else {
              sourceLength = 3;
            }
          } else if (dart.test(core.Uri._isGeneralDelimiter(char))) {
            core.Uri._fail(component, index, "Invalid character");
          } else {
            sourceLength = 1;
            if ((dart.notNull(char) & 64512) == 55296) {
              if (dart.notNull(index) + 1 < dart.notNull(end)) {
                let tail = component[dartx.codeUnitAt](dart.notNull(index) + 1);
                if ((dart.notNull(tail) & 64512) == 56320) {
                  sourceLength = 2;
                  char = 65536 | (dart.notNull(char) & 1023) << 10 | dart.notNull(tail) & 1023;
                }
              }
            }
            replacement = core.Uri._escapeChar(char);
          }
          if (buffer == null) buffer = new core.StringBuffer();
          buffer.write(component[dartx.substring](sectionStart, index));
          buffer.write(replacement);
          index = dart.notNull(index) + dart.notNull(sourceLength);
          sectionStart = index;
        }
      }
      if (buffer == null) {
        return component[dartx.substring](start, end);
      }
      if (dart.notNull(sectionStart) < dart.notNull(end)) {
        buffer.write(component[dartx.substring](sectionStart, end));
      }
      return dart.toString(buffer);
    }
    static _isSchemeCharacter(ch) {
      return dart.notNull(ch) < 128 && (dart.notNull(core.Uri._schemeTable[dartx.get](ch[dartx['>>']](4))) & 1 << (dart.notNull(ch) & 15)) != 0;
    }
    static _isGeneralDelimiter(ch) {
      return dart.notNull(ch) <= core.Uri._RIGHT_BRACKET && (dart.notNull(core.Uri._genDelimitersTable[dartx.get](ch[dartx['>>']](4))) & 1 << (dart.notNull(ch) & 15)) != 0;
    }
    get isAbsolute() {
      return this.scheme != "" && this.fragment == "";
    }
    [_mergePaths](base, reference) {
      let backCount = 0;
      let refStart = 0;
      while (dart.test(reference[dartx.startsWith]("../", refStart))) {
        refStart = refStart + 3;
        backCount++;
      }
      let baseEnd = base[dartx.lastIndexOf]('/');
      while (dart.notNull(baseEnd) > 0 && backCount > 0) {
        let newEnd = base[dartx.lastIndexOf]('/', dart.notNull(baseEnd) - 1);
        if (dart.notNull(newEnd) < 0) {
          break;
        }
        let delta = dart.notNull(baseEnd) - dart.notNull(newEnd);
        if ((delta == 2 || delta == 3) && base[dartx.codeUnitAt](dart.notNull(newEnd) + 1) == core.Uri._DOT && (delta == 2 || base[dartx.codeUnitAt](dart.notNull(newEnd) + 2) == core.Uri._DOT)) {
          break;
        }
        baseEnd = newEnd;
        backCount--;
      }
      return base[dartx.replaceRange](dart.notNull(baseEnd) + 1, null, reference[dartx.substring](refStart - 3 * backCount));
    }
    static _mayContainDotSegments(path) {
      if (dart.test(path[dartx.startsWith]('.'))) return true;
      let index = path[dartx.indexOf]("/.");
      return index != -1;
    }
    static _removeDotSegments(path) {
      if (!dart.test(core.Uri._mayContainDotSegments(path))) return path;
      dart.assert(path[dartx.isNotEmpty]);
      let output = JSArrayOfString().of([]);
      let appendSlash = false;
      for (let segment of path[dartx.split]("/")) {
        appendSlash = false;
        if (segment == "..") {
          if (dart.test(output[dartx.isNotEmpty])) {
            output[dartx.removeLast]();
            if (dart.test(output[dartx.isEmpty])) {
              output[dartx.add]("");
            }
          }
          appendSlash = true;
        } else if ("." == segment) {
          appendSlash = true;
        } else {
          output[dartx.add](segment);
        }
      }
      if (appendSlash) output[dartx.add]("");
      return output[dartx.join]("/");
    }
    static _normalizeRelativePath(path) {
      dart.assert(!dart.test(path[dartx.startsWith]('/')));
      if (!dart.test(core.Uri._mayContainDotSegments(path))) return path;
      dart.assert(path[dartx.isNotEmpty]);
      let output = JSArrayOfString().of([]);
      let appendSlash = false;
      for (let segment of path[dartx.split]("/")) {
        appendSlash = false;
        if (".." == segment) {
          if (!dart.test(output[dartx.isEmpty]) && output[dartx.last] != "..") {
            output[dartx.removeLast]();
            appendSlash = true;
          } else {
            output[dartx.add]("..");
          }
        } else if ("." == segment) {
          appendSlash = true;
        } else {
          output[dartx.add](segment);
        }
      }
      if (dart.test(output[dartx.isEmpty]) || output[dartx.length] == 1 && dart.test(output[dartx.get](0)[dartx.isEmpty])) {
        return "./";
      }
      if (appendSlash || output[dartx.last] == '..') output[dartx.add]("");
      return output[dartx.join]("/");
    }
    resolve(reference) {
      return this.resolveUri(core.Uri.parse(reference));
    }
    resolveUri(reference) {
      let targetScheme = null;
      let targetUserInfo = "";
      let targetHost = null;
      let targetPort = null;
      let targetPath = null;
      let targetQuery = null;
      if (dart.test(reference.scheme[dartx.isNotEmpty])) {
        targetScheme = reference.scheme;
        if (dart.test(reference.hasAuthority)) {
          targetUserInfo = reference.userInfo;
          targetHost = reference.host;
          targetPort = dart.test(reference.hasPort) ? reference.port : null;
        }
        targetPath = core.Uri._removeDotSegments(reference.path);
        if (dart.test(reference.hasQuery)) {
          targetQuery = reference.query;
        }
      } else {
        targetScheme = this.scheme;
        if (dart.test(reference.hasAuthority)) {
          targetUserInfo = reference.userInfo;
          targetHost = reference.host;
          targetPort = core.Uri._makePort(dart.test(reference.hasPort) ? reference.port : null, targetScheme);
          targetPath = core.Uri._removeDotSegments(reference.path);
          if (dart.test(reference.hasQuery)) targetQuery = reference.query;
        } else {
          targetUserInfo = this[_userInfo];
          targetHost = this[_host];
          targetPort = this[_port];
          if (reference.path == "") {
            targetPath = this[_path];
            if (dart.test(reference.hasQuery)) {
              targetQuery = reference.query;
            } else {
              targetQuery = this[_query];
            }
          } else {
            if (dart.test(reference.hasAbsolutePath)) {
              targetPath = core.Uri._removeDotSegments(reference.path);
            } else {
              if (dart.test(this.hasEmptyPath)) {
                if (!dart.test(this.hasScheme) && !dart.test(this.hasAuthority)) {
                  targetPath = reference.path;
                } else {
                  targetPath = core.Uri._removeDotSegments("/" + dart.notNull(reference.path));
                }
              } else {
                let mergedPath = this[_mergePaths](this[_path], reference.path);
                if (dart.test(this.hasScheme) || dart.test(this.hasAuthority) || dart.test(this.hasAbsolutePath)) {
                  targetPath = core.Uri._removeDotSegments(mergedPath);
                } else {
                  targetPath = core.Uri._normalizeRelativePath(mergedPath);
                }
              }
            }
            if (dart.test(reference.hasQuery)) targetQuery = reference.query;
          }
        }
      }
      let fragment = dart.test(reference.hasFragment) ? reference.fragment : null;
      return new core.Uri._internal(targetScheme, targetUserInfo, targetHost, targetPort, targetPath, targetQuery, fragment);
    }
    get hasScheme() {
      return this.scheme[dartx.isNotEmpty];
    }
    get hasAuthority() {
      return this[_host] != null;
    }
    get hasPort() {
      return this[_port] != null;
    }
    get hasQuery() {
      return this[_query] != null;
    }
    get hasFragment() {
      return this[_fragment] != null;
    }
    get hasEmptyPath() {
      return this[_path][dartx.isEmpty];
    }
    get hasAbsolutePath() {
      return this[_path][dartx.startsWith]('/');
    }
    get origin() {
      if (this.scheme == "" || this[_host] == null || this[_host] == "") {
        dart.throw(new core.StateError(dart.str`Cannot use origin without a scheme: ${this}`));
      }
      if (this.scheme != "http" && this.scheme != "https") {
        dart.throw(new core.StateError(dart.str`Origin is only applicable schemes http and https: ${this}`));
      }
      if (this[_port] == null) return dart.str`${this.scheme}://${this[_host]}`;
      return dart.str`${this.scheme}://${this[_host]}:${this[_port]}`;
    }
    toFilePath(opts) {
      let windows = opts && 'windows' in opts ? opts.windows : null;
      if (this.scheme != "" && this.scheme != "file") {
        dart.throw(new core.UnsupportedError(dart.str`Cannot extract a file path from a ${this.scheme} URI`));
      }
      if (this.query != "") {
        dart.throw(new core.UnsupportedError("Cannot extract a file path from a URI with a query component"));
      }
      if (this.fragment != "") {
        dart.throw(new core.UnsupportedError("Cannot extract a file path from a URI with a fragment component"));
      }
      if (windows == null) windows = core.Uri._isWindows;
      return dart.test(windows) ? this[_toWindowsFilePath]() : this[_toFilePath]();
    }
    [_toFilePath]() {
      if (this.host != "") {
        dart.throw(new core.UnsupportedError("Cannot extract a non-Windows file path from a file URI " + "with an authority"));
      }
      core.Uri._checkNonWindowsPathReservedCharacters(this.pathSegments, false);
      let result = new core.StringBuffer();
      if (dart.test(this[_isPathAbsolute])) result.write("/");
      result.writeAll(this.pathSegments, "/");
      return result.toString();
    }
    [_toWindowsFilePath]() {
      let hasDriveLetter = false;
      let segments = this.pathSegments;
      if (dart.notNull(segments[dartx.length]) > 0 && segments[dartx.get](0)[dartx.length] == 2 && segments[dartx.get](0)[dartx.codeUnitAt](1) == core.Uri._COLON) {
        core.Uri._checkWindowsDriveLetter(segments[dartx.get](0)[dartx.codeUnitAt](0), false);
        core.Uri._checkWindowsPathReservedCharacters(segments, false, 1);
        hasDriveLetter = true;
      } else {
        core.Uri._checkWindowsPathReservedCharacters(segments, false);
      }
      let result = new core.StringBuffer();
      if (dart.test(this[_isPathAbsolute]) && !hasDriveLetter) result.write("\\");
      if (this.host != "") {
        result.write("\\");
        result.write(this.host);
        result.write("\\");
      }
      result.writeAll(segments, "\\");
      if (hasDriveLetter && segments[dartx.length] == 1) result.write("\\");
      return result.toString();
    }
    get [_isPathAbsolute]() {
      if (this.path == null || dart.test(this.path[dartx.isEmpty])) return false;
      return this.path[dartx.startsWith]('/');
    }
    [_writeAuthority](ss) {
      if (dart.test(this[_userInfo][dartx.isNotEmpty])) {
        ss.write(this[_userInfo]);
        ss.write("@");
      }
      if (this[_host] != null) ss.write(this[_host]);
      if (this[_port] != null) {
        ss.write(":");
        ss.write(this[_port]);
      }
    }
    get data() {
      return this.scheme == "data" ? core.UriData.fromUri(this) : null;
    }
    toString() {
      let sb = new core.StringBuffer();
      core.Uri._addIfNonEmpty(sb, this.scheme, this.scheme, ':');
      if (dart.test(this.hasAuthority) || dart.test(this.path[dartx.startsWith]("//")) || this.scheme == "file") {
        sb.write("//");
        this[_writeAuthority](sb);
      }
      sb.write(this.path);
      if (this[_query] != null) {
        sb.write("?");
        sb.write(this[_query]);
      }
      if (this[_fragment] != null) {
        sb.write("#");
        sb.write(this[_fragment]);
      }
      return sb.toString();
    }
    ['=='](other) {
      if (!core.Uri.is(other)) return false;
      let uri = core.Uri._check(other);
      return this.scheme == uri.scheme && this.hasAuthority == uri.hasAuthority && this.userInfo == uri.userInfo && this.host == uri.host && this.port == uri.port && this.path == uri.path && this.hasQuery == uri.hasQuery && this.query == uri.query && this.hasFragment == uri.hasFragment && this.fragment == uri.fragment;
    }
    get hashCode() {
      function combine(part, current) {
        return core.int._check(dart.dsend(dart.dsend(dart.dsend(current, '*', 31), '+', dart.hashCode(part)), '&', 1073741823));
      }
      dart.fn(combine, dynamicAnddynamicToint());
      return combine(this.scheme, combine(this.userInfo, combine(this.host, combine(this.port, combine(this.path, combine(this.query, combine(this.fragment, 1)))))));
    }
    static _addIfNonEmpty(sb, test, first, second) {
      if ("" != test) {
        sb.write(first);
        sb.write(second);
      }
    }
    static encodeComponent(component) {
      return core.Uri._uriEncode(core.Uri._unreserved2396Table, component, convert.UTF8, false);
    }
    static encodeQueryComponent(component, opts) {
      let encoding = opts && 'encoding' in opts ? opts.encoding : convert.UTF8;
      return core.Uri._uriEncode(core.Uri._unreservedTable, component, encoding, true);
    }
    static decodeComponent(encodedComponent) {
      return core.Uri._uriDecode(encodedComponent, 0, encodedComponent[dartx.length], convert.UTF8, false);
    }
    static decodeQueryComponent(encodedComponent, opts) {
      let encoding = opts && 'encoding' in opts ? opts.encoding : convert.UTF8;
      return core.Uri._uriDecode(encodedComponent, 0, encodedComponent[dartx.length], encoding, true);
    }
    static encodeFull(uri) {
      return core.Uri._uriEncode(core.Uri._encodeFullTable, uri, convert.UTF8, false);
    }
    static decodeFull(uri) {
      return core.Uri._uriDecode(uri, 0, uri[dartx.length], convert.UTF8, false);
    }
    static splitQueryString(query, opts) {
      let encoding = opts && 'encoding' in opts ? opts.encoding : convert.UTF8;
      return query[dartx.split]("&")[dartx.fold](MapOfString$String())(dart.map(), dart.fn((map, element) => {
        let index = element[dartx.indexOf]("=");
        if (index == -1) {
          if (element != "") {
            map[dartx.set](core.Uri.decodeQueryComponent(element, {encoding: encoding}), "");
          }
        } else if (index != 0) {
          let key = element[dartx.substring](0, index);
          let value = element[dartx.substring](dart.notNull(index) + 1);
          map[dartx.set](core.Uri.decodeQueryComponent(key, {encoding: encoding}), core.Uri.decodeQueryComponent(value, {encoding: encoding}));
        }
        return map;
      }, MapOfString$StringAndStringToMapOfString$String()));
    }
    static _createList() {
      return [];
    }
    static _splitQueryStringAll(query, opts) {
      let encoding = opts && 'encoding' in opts ? opts.encoding : convert.UTF8;
      let result = dart.map();
      let i = 0;
      let start = 0;
      let equalsIndex = -1;
      function parsePair(start, equalsIndex, end) {
        let key = null;
        let value = null;
        if (start == end) return;
        if (dart.notNull(equalsIndex) < 0) {
          key = core.Uri._uriDecode(query, start, end, encoding, true);
          value = "";
        } else {
          key = core.Uri._uriDecode(query, start, equalsIndex, encoding, true);
          value = core.Uri._uriDecode(query, dart.notNull(equalsIndex) + 1, end, encoding, true);
        }
        dart.dsend(result[dartx.putIfAbsent](key, core.Uri._createList), 'add', value);
      }
      dart.fn(parsePair, intAndintAndintTovoid());
      let _equals = 61;
      let _ampersand = 38;
      while (i < dart.notNull(query[dartx.length])) {
        let char = query[dartx.codeUnitAt](i);
        if (char == _equals) {
          if (equalsIndex < 0) equalsIndex = i;
        } else if (char == _ampersand) {
          parsePair(start, equalsIndex, i);
          start = i + 1;
          equalsIndex = -1;
        }
        i++;
      }
      parsePair(start, equalsIndex, i);
      return result;
    }
    static parseIPv4Address(host) {
      function error(msg) {
        dart.throw(new core.FormatException(dart.str`Illegal IPv4 address, ${msg}`));
      }
      dart.fn(error, StringTovoid());
      let bytes = host[dartx.split]('.');
      if (bytes[dartx.length] != 4) {
        error('IPv4 address should contain exactly 4 parts');
      }
      return bytes[dartx.map](core.int)(dart.fn(byteString => {
        let byte = core.int.parse(byteString);
        if (dart.notNull(byte) < 0 || dart.notNull(byte) > 255) {
          error('each part must be in the range of `0..255`');
        }
        return byte;
      }, StringToint$()))[dartx.toList]();
    }
    static parseIPv6Address(host, start, end) {
      if (start === void 0) start = 0;
      if (end === void 0) end = null;
      if (end == null) end = host[dartx.length];
      function error(msg, position) {
        if (position === void 0) position = null;
        dart.throw(new core.FormatException(dart.str`Illegal IPv6 address, ${msg}`, host, core.int._check(position)));
      }
      dart.fn(error, String__Tovoid());
      function parseHex(start, end) {
        if (dart.notNull(end) - dart.notNull(start) > 4) {
          error('an IPv6 part can only contain a maximum of 4 hex digits', start);
        }
        let value = core.int.parse(host[dartx.substring](start, end), {radix: 16});
        if (dart.notNull(value) < 0 || dart.notNull(value) > (1 << 16) - 1) {
          error('each part must be in the range of `0x0..0xFFFF`', start);
        }
        return value;
      }
      dart.fn(parseHex, intAndintToint());
      if (dart.notNull(host[dartx.length]) < 2) error('address is too short');
      let parts = JSArrayOfint().of([]);
      let wildcardSeen = false;
      let partStart = start;
      for (let i = start; dart.notNull(i) < dart.notNull(end); i = dart.notNull(i) + 1) {
        if (host[dartx.codeUnitAt](i) == core.Uri._COLON) {
          if (i == start) {
            i = dart.notNull(i) + 1;
            if (host[dartx.codeUnitAt](i) != core.Uri._COLON) {
              error('invalid start colon.', i);
            }
            partStart = i;
          }
          if (i == partStart) {
            if (wildcardSeen) {
              error('only one wildcard `::` is allowed', i);
            }
            wildcardSeen = true;
            parts[dartx.add](-1);
          } else {
            parts[dartx.add](parseHex(partStart, i));
          }
          partStart = dart.notNull(i) + 1;
        }
      }
      if (parts[dartx.length] == 0) error('too few parts');
      let atEnd = partStart == end;
      let isLastWildcard = parts[dartx.last] == -1;
      if (atEnd && !isLastWildcard) {
        error('expected a part after last `:`', end);
      }
      if (!atEnd) {
        try {
          parts[dartx.add](parseHex(partStart, end));
        } catch (e) {
          try {
            let last = core.Uri.parseIPv4Address(host[dartx.substring](partStart, end));
            parts[dartx.add]((dart.notNull(last[dartx.get](0)) << 8 | dart.notNull(last[dartx.get](1))) >>> 0);
            parts[dartx.add]((dart.notNull(last[dartx.get](2)) << 8 | dart.notNull(last[dartx.get](3))) >>> 0);
          } catch (e) {
            error('invalid end of IPv6 address.', partStart);
          }

        }

      }
      if (wildcardSeen) {
        if (dart.notNull(parts[dartx.length]) > 7) {
          error('an address with a wildcard must have less than 7 parts');
        }
      } else if (parts[dartx.length] != 8) {
        error('an address without a wildcard must contain exactly 8 parts');
      }
      let bytes = typed_data.Uint8List.new(16);
      for (let i = 0, index = 0; i < dart.notNull(parts[dartx.length]); i++) {
        let value = parts[dartx.get](i);
        if (value == -1) {
          let wildCardLength = 9 - dart.notNull(parts[dartx.length]);
          for (let j = 0; j < wildCardLength; j++) {
            bytes[dartx.set](index, 0);
            bytes[dartx.set](index + 1, 0);
            index = index + 2;
          }
        } else {
          bytes[dartx.set](index, value[dartx['>>']](8));
          bytes[dartx.set](index + 1, dart.notNull(value) & 255);
          index = index + 2;
        }
      }
      return bytes;
    }
    static _uriEncode(canonicalTable, text, encoding, spaceToPlus) {
      if (core.identical(encoding, convert.UTF8) && dart.test(core.Uri._needsNoEncoding.hasMatch(text))) {
        return text;
      }
      let result = new core.StringBuffer();
      let bytes = encoding.encode(text);
      for (let i = 0; i < dart.notNull(bytes[dartx.length]); i++) {
        let byte = bytes[dartx.get](i);
        if (dart.notNull(byte) < 128 && (dart.notNull(canonicalTable[dartx.get](byte[dartx['>>']](4))) & 1 << (dart.notNull(byte) & 15)) != 0) {
          result.writeCharCode(byte);
        } else if (dart.test(spaceToPlus) && byte == core.Uri._SPACE) {
          result.write('+');
        } else {
          let hexDigits = '0123456789ABCDEF';
          result.write('%');
          result.write(hexDigits[dartx.get](dart.notNull(byte) >> 4 & 15));
          result.write(hexDigits[dartx.get](dart.notNull(byte) & 15));
        }
      }
      return result.toString();
    }
    static _hexCharPairToByte(s, pos) {
      let byte = 0;
      for (let i = 0; i < 2; i++) {
        let charCode = s[dartx.codeUnitAt](dart.notNull(pos) + i);
        if (48 <= dart.notNull(charCode) && dart.notNull(charCode) <= 57) {
          byte = byte * 16 + dart.notNull(charCode) - 48;
        } else {
          charCode = (dart.notNull(charCode) | 32) >>> 0;
          if (97 <= dart.notNull(charCode) && dart.notNull(charCode) <= 102) {
            byte = byte * 16 + dart.notNull(charCode) - 87;
          } else {
            dart.throw(new core.ArgumentError("Invalid URL encoding"));
          }
        }
      }
      return byte;
    }
    static _uriDecode(text, start, end, encoding, plusToSpace) {
      dart.assert(0 <= dart.notNull(start));
      dart.assert(dart.notNull(start) <= dart.notNull(end));
      dart.assert(dart.notNull(end) <= dart.notNull(text[dartx.length]));
      dart.assert(encoding != null);
      let simple = true;
      for (let i = start; dart.notNull(i) < dart.notNull(end); i = dart.notNull(i) + 1) {
        let codeUnit = text[dartx.codeUnitAt](i);
        if (dart.notNull(codeUnit) > 127 || codeUnit == core.Uri._PERCENT || dart.test(plusToSpace) && codeUnit == core.Uri._PLUS) {
          simple = false;
          break;
        }
      }
      let bytes = null;
      if (simple) {
        if (dart.equals(convert.UTF8, encoding) || dart.equals(convert.LATIN1, encoding) || dart.equals(convert.ASCII, encoding)) {
          return text[dartx.substring](start, end);
        } else {
          bytes = text[dartx.substring](start, end)[dartx.codeUnits];
        }
      } else {
        bytes = ListOfint().new();
        for (let i = start; dart.notNull(i) < dart.notNull(end); i = dart.notNull(i) + 1) {
          let codeUnit = text[dartx.codeUnitAt](i);
          if (dart.notNull(codeUnit) > 127) {
            dart.throw(new core.ArgumentError("Illegal percent encoding in URI"));
          }
          if (codeUnit == core.Uri._PERCENT) {
            if (dart.notNull(i) + 3 > dart.notNull(text[dartx.length])) {
              dart.throw(new core.ArgumentError('Truncated URI'));
            }
            bytes[dartx.add](core.Uri._hexCharPairToByte(text, dart.notNull(i) + 1));
            i = dart.notNull(i) + 2;
          } else if (dart.test(plusToSpace) && codeUnit == core.Uri._PLUS) {
            bytes[dartx.add](core.Uri._SPACE);
          } else {
            bytes[dartx.add](codeUnit);
          }
        }
      }
      return encoding.decode(bytes);
    }
    static _isAlphabeticCharacter(codeUnit) {
      let lowerCase = (dart.notNull(codeUnit) | 32) >>> 0;
      return core.Uri._LOWER_CASE_A <= lowerCase && lowerCase <= core.Uri._LOWER_CASE_Z;
    }
    static _isUnreservedChar(char) {
      return dart.notNull(char) < 127 && (dart.notNull(core.Uri._unreservedTable[dartx.get](char[dartx['>>']](4))) & 1 << (dart.notNull(char) & 15)) != 0;
    }
  };
  dart.defineNamedConstructor(core.Uri, '_internal');
  dart.setSignature(core.Uri, {
    constructors: () => ({
      _internal: dart.definiteFunctionType(core.Uri, [core.String, core.String, core.String, core.int, core.String, core.String, core.String]),
      new: dart.definiteFunctionType(core.Uri, [], {scheme: core.String, userInfo: core.String, host: core.String, port: core.int, path: core.String, pathSegments: IterableOfString(), query: core.String, queryParameters: MapOfString$dynamic(), fragment: core.String}),
      http: dart.definiteFunctionType(core.Uri, [core.String, core.String], [core.Map$(core.String, core.String)]),
      https: dart.definiteFunctionType(core.Uri, [core.String, core.String], [core.Map$(core.String, core.String)]),
      file: dart.definiteFunctionType(core.Uri, [core.String], {windows: core.bool}),
      directory: dart.definiteFunctionType(core.Uri, [core.String], {windows: core.bool}),
      dataFromString: dart.definiteFunctionType(core.Uri, [core.String], {mimeType: core.String, encoding: convert.Encoding, parameters: MapOfString$String(), base64: core.bool}),
      dataFromBytes: dart.definiteFunctionType(core.Uri, [core.List$(core.int)], {mimeType: dart.dynamic, parameters: MapOfString$String(), percentEncoded: dart.dynamic})
    }),
    methods: () => ({
      replace: dart.definiteFunctionType(core.Uri, [], {scheme: core.String, userInfo: core.String, host: core.String, port: core.int, path: core.String, pathSegments: IterableOfString(), query: core.String, queryParameters: MapOfString$dynamic(), fragment: core.String}),
      removeFragment: dart.definiteFunctionType(core.Uri, []),
      normalizePath: dart.definiteFunctionType(core.Uri, []),
      [_mergePaths]: dart.definiteFunctionType(core.String, [core.String, core.String]),
      resolve: dart.definiteFunctionType(core.Uri, [core.String]),
      resolveUri: dart.definiteFunctionType(core.Uri, [core.Uri]),
      toFilePath: dart.definiteFunctionType(core.String, [], {windows: core.bool}),
      [_toFilePath]: dart.definiteFunctionType(core.String, []),
      [_toWindowsFilePath]: dart.definiteFunctionType(core.String, []),
      [_writeAuthority]: dart.definiteFunctionType(dart.void, [core.StringSink])
    }),
    statics: () => ({
      _defaultPort: dart.definiteFunctionType(core.int, [core.String]),
      parse: dart.definiteFunctionType(core.Uri, [core.String], [core.int, core.int]),
      _fail: dart.definiteFunctionType(dart.void, [core.String, core.int, core.String]),
      _makeHttpUri: dart.definiteFunctionType(core.Uri, [core.String, core.String, core.String, core.Map$(core.String, core.String)]),
      _checkNonWindowsPathReservedCharacters: dart.definiteFunctionType(dart.dynamic, [core.List$(core.String), core.bool]),
      _checkWindowsPathReservedCharacters: dart.definiteFunctionType(dart.dynamic, [core.List$(core.String), core.bool], [core.int]),
      _checkWindowsDriveLetter: dart.definiteFunctionType(dart.dynamic, [core.int, core.bool]),
      _makeFileUri: dart.definiteFunctionType(dart.dynamic, [core.String, core.bool]),
      _makeWindowsFileUrl: dart.definiteFunctionType(dart.dynamic, [core.String, core.bool]),
      _makePort: dart.definiteFunctionType(core.int, [core.int, core.String]),
      _makeHost: dart.definiteFunctionType(core.String, [core.String, core.int, core.int, core.bool]),
      _isRegNameChar: dart.definiteFunctionType(core.bool, [core.int]),
      _normalizeRegName: dart.definiteFunctionType(core.String, [core.String, core.int, core.int]),
      _makeScheme: dart.definiteFunctionType(core.String, [core.String, core.int, core.int]),
      _makeUserInfo: dart.definiteFunctionType(core.String, [core.String, core.int, core.int]),
      _makePath: dart.definiteFunctionType(core.String, [core.String, core.int, core.int, core.Iterable$(core.String), core.String, core.bool]),
      _normalizePath: dart.definiteFunctionType(core.String, [core.String, core.String, core.bool]),
      _makeQuery: dart.definiteFunctionType(core.String, [core.String, core.int, core.int, core.Map$(core.String, dart.dynamic)]),
      _makeFragment: dart.definiteFunctionType(core.String, [core.String, core.int, core.int]),
      _stringOrNullLength: dart.definiteFunctionType(core.int, [core.String]),
      _normalizeEscape: dart.definiteFunctionType(core.String, [core.String, core.int, core.bool]),
      _parseHexDigit: dart.definiteFunctionType(core.int, [core.int]),
      _escapeChar: dart.definiteFunctionType(core.String, [core.int]),
      _normalize: dart.definiteFunctionType(core.String, [core.String, core.int, core.int, core.List$(core.int)]),
      _isSchemeCharacter: dart.definiteFunctionType(core.bool, [core.int]),
      _isGeneralDelimiter: dart.definiteFunctionType(core.bool, [core.int]),
      _mayContainDotSegments: dart.definiteFunctionType(core.bool, [core.String]),
      _removeDotSegments: dart.definiteFunctionType(core.String, [core.String]),
      _normalizeRelativePath: dart.definiteFunctionType(core.String, [core.String]),
      _addIfNonEmpty: dart.definiteFunctionType(dart.void, [core.StringBuffer, core.String, core.String, core.String]),
      encodeComponent: dart.definiteFunctionType(core.String, [core.String]),
      encodeQueryComponent: dart.definiteFunctionType(core.String, [core.String], {encoding: convert.Encoding}),
      decodeComponent: dart.definiteFunctionType(core.String, [core.String]),
      decodeQueryComponent: dart.definiteFunctionType(core.String, [core.String], {encoding: convert.Encoding}),
      encodeFull: dart.definiteFunctionType(core.String, [core.String]),
      decodeFull: dart.definiteFunctionType(core.String, [core.String]),
      splitQueryString: dart.definiteFunctionType(core.Map$(core.String, core.String), [core.String], {encoding: convert.Encoding}),
      _createList: dart.definiteFunctionType(core.List, []),
      _splitQueryStringAll: dart.definiteFunctionType(core.Map, [core.String], {encoding: convert.Encoding}),
      parseIPv4Address: dart.definiteFunctionType(core.List$(core.int), [core.String]),
      parseIPv6Address: dart.definiteFunctionType(core.List$(core.int), [core.String], [core.int, core.int]),
      _uriEncode: dart.definiteFunctionType(core.String, [core.List$(core.int), core.String, convert.Encoding, core.bool]),
      _hexCharPairToByte: dart.definiteFunctionType(core.int, [core.String, core.int]),
      _uriDecode: dart.definiteFunctionType(core.String, [core.String, core.int, core.int, convert.Encoding, core.bool]),
      _isAlphabeticCharacter: dart.definiteFunctionType(core.bool, [core.int]),
      _isUnreservedChar: dart.definiteFunctionType(core.bool, [core.int])
    }),
    names: ['_defaultPort', 'parse', '_fail', '_makeHttpUri', '_checkNonWindowsPathReservedCharacters', '_checkWindowsPathReservedCharacters', '_checkWindowsDriveLetter', '_makeFileUri', '_makeWindowsFileUrl', '_makePort', '_makeHost', '_isRegNameChar', '_normalizeRegName', '_makeScheme', '_makeUserInfo', '_makePath', '_normalizePath', '_makeQuery', '_makeFragment', '_stringOrNullLength', '_normalizeEscape', '_parseHexDigit', '_escapeChar', '_normalize', '_isSchemeCharacter', '_isGeneralDelimiter', '_mayContainDotSegments', '_removeDotSegments', '_normalizeRelativePath', '_addIfNonEmpty', 'encodeComponent', 'encodeQueryComponent', 'decodeComponent', 'decodeQueryComponent', 'encodeFull', 'decodeFull', 'splitQueryString', '_createList', '_splitQueryStringAll', 'parseIPv4Address', 'parseIPv6Address', '_uriEncode', '_hexCharPairToByte', '_uriDecode', '_isAlphabeticCharacter', '_isUnreservedChar']
  });
  core.Uri._SPACE = 32;
  core.Uri._DOUBLE_QUOTE = 34;
  core.Uri._NUMBER_SIGN = 35;
  core.Uri._PERCENT = 37;
  core.Uri._ASTERISK = 42;
  core.Uri._PLUS = 43;
  core.Uri._DOT = 46;
  core.Uri._SLASH = 47;
  core.Uri._ZERO = 48;
  core.Uri._NINE = 57;
  core.Uri._COLON = 58;
  core.Uri._LESS = 60;
  core.Uri._GREATER = 62;
  core.Uri._QUESTION = 63;
  core.Uri._AT_SIGN = 64;
  core.Uri._UPPER_CASE_A = 65;
  core.Uri._UPPER_CASE_F = 70;
  core.Uri._UPPER_CASE_Z = 90;
  core.Uri._LEFT_BRACKET = 91;
  core.Uri._BACKSLASH = 92;
  core.Uri._RIGHT_BRACKET = 93;
  core.Uri._LOWER_CASE_A = 97;
  core.Uri._LOWER_CASE_F = 102;
  core.Uri._LOWER_CASE_Z = 122;
  core.Uri._BAR = 124;
  core.Uri._hexDigits = "0123456789ABCDEF";
  core.Uri._unreservedTable = dart.constList([0, 0, 24576, 1023, 65534, 34815, 65534, 18431], core.int);
  core.Uri._unreserved2396Table = dart.constList([0, 0, 26498, 1023, 65534, 34815, 65534, 18431], core.int);
  core.Uri._encodeFullTable = dart.constList([0, 0, 65498, 45055, 65535, 34815, 65534, 18431], core.int);
  core.Uri._schemeTable = dart.constList([0, 0, 26624, 1023, 65534, 2047, 65534, 2047], core.int);
  core.Uri._schemeLowerTable = dart.constList([0, 0, 26624, 1023, 0, 0, 65534, 2047], core.int);
  core.Uri._subDelimitersTable = dart.constList([0, 0, 32722, 11263, 65534, 34815, 65534, 18431], core.int);
  core.Uri._genDelimitersTable = dart.constList([0, 0, 32776, 33792, 1, 10240, 0, 0], core.int);
  core.Uri._userinfoTable = dart.constList([0, 0, 32722, 12287, 65534, 34815, 65534, 18431], core.int);
  core.Uri._regNameTable = dart.constList([0, 0, 32754, 11263, 65534, 34815, 65534, 18431], core.int);
  core.Uri._pathCharTable = dart.constList([0, 0, 32722, 12287, 65535, 34815, 65534, 18431], core.int);
  core.Uri._pathCharOrSlashTable = dart.constList([0, 0, 65490, 12287, 65535, 34815, 65534, 18431], core.int);
  core.Uri._queryCharTable = dart.constList([0, 0, 65490, 45055, 65535, 34815, 65534, 18431], core.int);
  dart.defineLazy(core.Uri, {
    get _needsNoEncoding() {
      return core.RegExp.new('^[\\-\\.0-9A-Z_a-z~]*$');
    }
  });
  const _text = Symbol('_text');
  const _separatorIndices = Symbol('_separatorIndices');
  const _uriCache = Symbol('_uriCache');
  core.UriData = class UriData extends core.Object {
    _(text, separatorIndices, uriCache) {
      this[_text] = text;
      this[_separatorIndices] = separatorIndices;
      this[_uriCache] = uriCache;
    }
    static fromString(content, opts) {
      let mimeType = opts && 'mimeType' in opts ? opts.mimeType : null;
      let encoding = opts && 'encoding' in opts ? opts.encoding : null;
      let parameters = opts && 'parameters' in opts ? opts.parameters : null;
      let base64 = opts && 'base64' in opts ? opts.base64 : false;
      let buffer = new core.StringBuffer();
      let indices = JSArrayOfint().of([core.UriData._noScheme]);
      let charsetName = null;
      let encodingName = null;
      if (parameters != null) charsetName = parameters[dartx.get]("charset");
      if (encoding == null) {
        if (charsetName != null) {
          encoding = convert.Encoding.getByName(charsetName);
        }
      } else if (charsetName == null) {
        encodingName = encoding.name;
      }
      let t = encoding;
      t == null ? encoding = convert.ASCII : t;
      core.UriData._writeUri(mimeType, encodingName, parameters, buffer, indices);
      indices[dartx.add](buffer.length);
      if (dart.test(base64)) {
        buffer.write(';base64,');
        indices[dartx.add](dart.notNull(buffer.length) - 1);
        buffer.write(encoding.fuse(convert.BASE64).encode(content));
      } else {
        buffer.write(',');
        core.UriData._uriEncodeBytes(core.UriData._uricTable, encoding.encode(content), buffer);
      }
      return new core.UriData._(buffer.toString(), indices, null);
    }
    static fromBytes(bytes, opts) {
      let mimeType = opts && 'mimeType' in opts ? opts.mimeType : "application/octet-stream";
      let parameters = opts && 'parameters' in opts ? opts.parameters : null;
      let percentEncoded = opts && 'percentEncoded' in opts ? opts.percentEncoded : false;
      let buffer = new core.StringBuffer();
      let indices = JSArrayOfint().of([core.UriData._noScheme]);
      core.UriData._writeUri(core.String._check(mimeType), null, parameters, buffer, indices);
      indices[dartx.add](buffer.length);
      if (dart.test(percentEncoded)) {
        buffer.write(',');
        core.UriData._uriEncodeBytes(core.UriData._uricTable, bytes, buffer);
      } else {
        buffer.write(';base64,');
        indices[dartx.add](dart.notNull(buffer.length) - 1);
        convert.BASE64.encoder.startChunkedConversion(convert.StringConversionSink.fromStringSink(buffer)).addSlice(bytes, 0, bytes[dartx.length], true);
      }
      return new core.UriData._(buffer.toString(), indices, null);
    }
    static fromUri(uri) {
      if (uri.scheme != "data") {
        dart.throw(new core.ArgumentError.value(uri, "uri", "Scheme must be 'data'"));
      }
      if (dart.test(uri.hasAuthority)) {
        dart.throw(new core.ArgumentError.value(uri, "uri", "Data uri must not have authority"));
      }
      if (dart.test(uri.hasFragment)) {
        dart.throw(new core.ArgumentError.value(uri, "uri", "Data uri must not have a fragment part"));
      }
      if (!dart.test(uri.hasQuery)) {
        return core.UriData._parse(uri.path, 0, uri);
      }
      return core.UriData._parse(dart.str`${uri}`, 5, uri);
    }
    static _writeUri(mimeType, charsetName, parameters, buffer, indices) {
      if (mimeType == null || mimeType == "text/plain") {
        mimeType = "";
      }
      if (dart.test(mimeType[dartx.isEmpty]) || core.identical(mimeType, "application/octet-stream")) {
        buffer.write(mimeType);
      } else {
        let slashIndex = core.UriData._validateMimeType(mimeType);
        if (dart.notNull(slashIndex) < 0) {
          dart.throw(new core.ArgumentError.value(mimeType, "mimeType", "Invalid MIME type"));
        }
        buffer.write(core.Uri._uriEncode(core.UriData._tokenCharTable, mimeType[dartx.substring](0, slashIndex), convert.UTF8, false));
        buffer.write("/");
        buffer.write(core.Uri._uriEncode(core.UriData._tokenCharTable, mimeType[dartx.substring](dart.notNull(slashIndex) + 1), convert.UTF8, false));
      }
      if (charsetName != null) {
        if (indices != null) {
          indices[dartx.add](buffer.length);
          indices[dartx.add](dart.notNull(buffer.length) + 8);
        }
        buffer.write(";charset=");
        buffer.write(core.Uri._uriEncode(core.UriData._tokenCharTable, charsetName, convert.UTF8, false));
      }
      dart.nullSafe(parameters, _ => _[dartx.forEach](dart.fn((key, value) => {
        if (dart.test(key[dartx.isEmpty])) {
          dart.throw(new core.ArgumentError.value("", "Parameter names must not be empty"));
        }
        if (dart.test(value[dartx.isEmpty])) {
          dart.throw(new core.ArgumentError.value("", "Parameter values must not be empty", dart.str`parameters["${key}"]`));
        }
        if (indices != null) indices[dartx.add](buffer.length);
        buffer.write(';');
        buffer.write(core.Uri._uriEncode(core.UriData._tokenCharTable, key, convert.UTF8, false));
        if (indices != null) indices[dartx.add](buffer.length);
        buffer.write('=');
        buffer.write(core.Uri._uriEncode(core.UriData._tokenCharTable, value, convert.UTF8, false));
      }, StringAndStringTovoid())));
    }
    static _validateMimeType(mimeType) {
      let slashIndex = -1;
      for (let i = 0; i < dart.notNull(mimeType[dartx.length]); i++) {
        let char = mimeType[dartx.codeUnitAt](i);
        if (char != core.Uri._SLASH) continue;
        if (slashIndex < 0) {
          slashIndex = i;
          continue;
        }
        return -1;
      }
      return slashIndex;
    }
    static parse(uri) {
      if (!dart.test(uri[dartx.startsWith]("data:"))) {
        dart.throw(new core.FormatException("Does not start with 'data:'", uri, 0));
      }
      return core.UriData._parse(uri, 5, null);
    }
    get uri() {
      if (this[_uriCache] != null) return this[_uriCache];
      let path = this[_text];
      let query = null;
      let colonIndex = this[_separatorIndices][dartx.get](0);
      let queryIndex = this[_text][dartx.indexOf]('?', dart.notNull(colonIndex) + 1);
      let end = null;
      if (dart.notNull(queryIndex) >= 0) {
        query = this[_text][dartx.substring](dart.notNull(queryIndex) + 1);
        end = queryIndex;
      }
      path = this[_text][dartx.substring](dart.notNull(colonIndex) + 1, end);
      this[_uriCache] = new core.Uri._internal("data", "", null, null, path, query, null);
      return this[_uriCache];
    }
    get mimeType() {
      let start = dart.notNull(this[_separatorIndices][dartx.get](0)) + 1;
      let end = this[_separatorIndices][dartx.get](1);
      if (start == end) return "text/plain";
      return core.Uri._uriDecode(this[_text], start, end, convert.UTF8, false);
    }
    get charset() {
      let parameterStart = 1;
      let parameterEnd = dart.notNull(this[_separatorIndices][dartx.length]) - 1;
      if (dart.test(this.isBase64)) {
        parameterEnd = parameterEnd - 1;
      }
      for (let i = parameterStart; i < parameterEnd; i = i + 2) {
        let keyStart = dart.notNull(this[_separatorIndices][dartx.get](i)) + 1;
        let keyEnd = this[_separatorIndices][dartx.get](i + 1);
        if (keyEnd == keyStart + 7 && dart.test(this[_text][dartx.startsWith]("charset", keyStart))) {
          return core.Uri._uriDecode(this[_text], dart.notNull(keyEnd) + 1, this[_separatorIndices][dartx.get](i + 2), convert.UTF8, false);
        }
      }
      return "US-ASCII";
    }
    get isBase64() {
      return this[_separatorIndices][dartx.length][dartx.isOdd];
    }
    get contentText() {
      return this[_text][dartx.substring](dart.notNull(this[_separatorIndices][dartx.last]) + 1);
    }
    contentAsBytes() {
      let text = this[_text];
      let start = dart.notNull(this[_separatorIndices][dartx.last]) + 1;
      if (dart.test(this.isBase64)) {
        return convert.BASE64.decoder.convert(text, start);
      }
      let percent = 37;
      let length = dart.notNull(text[dartx.length]) - start;
      for (let i = start; i < dart.notNull(text[dartx.length]); i++) {
        let codeUnit = text[dartx.codeUnitAt](i);
        if (codeUnit == percent) {
          i = i + 2;
          length = length - 2;
        }
      }
      let result = typed_data.Uint8List.new(length);
      if (length == text[dartx.length]) {
        result[dartx.setRange](0, length, text[dartx.codeUnits], start);
        return result;
      }
      let index = 0;
      for (let i = start; i < dart.notNull(text[dartx.length]); i++) {
        let codeUnit = text[dartx.codeUnitAt](i);
        if (codeUnit != percent) {
          result[dartx.set](index++, codeUnit);
        } else {
          if (i + 2 < dart.notNull(text[dartx.length])) {
            let digit1 = core.Uri._parseHexDigit(text[dartx.codeUnitAt](i + 1));
            let digit2 = core.Uri._parseHexDigit(text[dartx.codeUnitAt](i + 2));
            if (dart.notNull(digit1) >= 0 && dart.notNull(digit2) >= 0) {
              let byte = dart.notNull(digit1) * 16 + dart.notNull(digit2);
              result[dartx.set](index++, byte);
              i = i + 2;
              continue;
            }
          }
          dart.throw(new core.FormatException("Invalid percent escape", text, i));
        }
      }
      dart.assert(index == result[dartx.length]);
      return result;
    }
    contentAsString(opts) {
      let encoding = opts && 'encoding' in opts ? opts.encoding : null;
      if (encoding == null) {
        let charset = this.charset;
        encoding = convert.Encoding.getByName(charset);
        if (encoding == null) {
          dart.throw(new core.UnsupportedError(dart.str`Unknown charset: ${charset}`));
        }
      }
      let text = this[_text];
      let start = dart.notNull(this[_separatorIndices][dartx.last]) + 1;
      if (dart.test(this.isBase64)) {
        let converter = convert.BASE64.decoder.fuse(core.String)(encoding.decoder);
        return converter.convert(text[dartx.substring](start));
      }
      return core.Uri._uriDecode(text, start, text[dartx.length], encoding, false);
    }
    get parameters() {
      let result = dart.map({}, core.String, core.String);
      for (let i = 3; i < dart.notNull(this[_separatorIndices][dartx.length]); i = i + 2) {
        let start = dart.notNull(this[_separatorIndices][dartx.get](i - 2)) + 1;
        let equals = this[_separatorIndices][dartx.get](i - 1);
        let end = this[_separatorIndices][dartx.get](i);
        let key = core.Uri._uriDecode(this[_text], start, equals, convert.UTF8, false);
        let value = core.Uri._uriDecode(this[_text], dart.notNull(equals) + 1, end, convert.UTF8, false);
        result[dartx.set](key, value);
      }
      return result;
    }
    static _parse(text, start, sourceUri) {
      dart.assert(start == 0 || start == 5);
      dart.assert(start == 5 == text[dartx.startsWith]("data:"));
      let comma = 44;
      let slash = 47;
      let semicolon = 59;
      let equals = 61;
      let indices = JSArrayOfint().of([dart.notNull(start) - 1]);
      let slashIndex = -1;
      let char = null;
      let i = start;
      for (; dart.notNull(i) < dart.notNull(text[dartx.length]); i = dart.notNull(i) + 1) {
        char = text[dartx.codeUnitAt](i);
        if (dart.equals(char, comma) || dart.equals(char, semicolon)) break;
        if (dart.equals(char, slash)) {
          if (dart.notNull(slashIndex) < 0) {
            slashIndex = i;
            continue;
          }
          dart.throw(new core.FormatException("Invalid MIME type", text, i));
        }
      }
      if (dart.notNull(slashIndex) < 0 && dart.notNull(i) > dart.notNull(start)) {
        dart.throw(new core.FormatException("Invalid MIME type", text, i));
      }
      while (!dart.equals(char, comma)) {
        indices[dartx.add](i);
        i = dart.notNull(i) + 1;
        let equalsIndex = -1;
        for (; dart.notNull(i) < dart.notNull(text[dartx.length]); i = dart.notNull(i) + 1) {
          char = text[dartx.codeUnitAt](i);
          if (dart.equals(char, equals)) {
            if (dart.notNull(equalsIndex) < 0) equalsIndex = i;
          } else if (dart.equals(char, semicolon) || dart.equals(char, comma)) {
            break;
          }
        }
        if (dart.notNull(equalsIndex) >= 0) {
          indices[dartx.add](equalsIndex);
        } else {
          let lastSeparator = indices[dartx.last];
          if (!dart.equals(char, comma) || i != dart.notNull(lastSeparator) + 7 || !dart.test(text[dartx.startsWith]("base64", dart.notNull(lastSeparator) + 1))) {
            dart.throw(new core.FormatException("Expecting '='", text, i));
          }
          break;
        }
      }
      indices[dartx.add](i);
      return new core.UriData._(text, indices, sourceUri);
    }
    static _uriEncodeBytes(canonicalTable, bytes, buffer) {
      let byteOr = 0;
      for (let i = 0; i < dart.notNull(bytes[dartx.length]); i++) {
        let byte = bytes[dartx.get](i);
        byteOr = (dart.notNull(byteOr) | dart.notNull(byte)) >>> 0;
        if (dart.notNull(byte) < 128 && (dart.notNull(canonicalTable[dartx.get](byte[dartx['>>']](4))) & 1 << (dart.notNull(byte) & 15)) != 0) {
          buffer.writeCharCode(byte);
        } else {
          buffer.writeCharCode(core.Uri._PERCENT);
          buffer.writeCharCode(core.Uri._hexDigits[dartx.codeUnitAt](byte[dartx['>>']](4)));
          buffer.writeCharCode(core.Uri._hexDigits[dartx.codeUnitAt](dart.notNull(byte) & 15));
        }
      }
      if ((dart.notNull(byteOr) & ~255) != 0) {
        for (let i = 0; i < dart.notNull(bytes[dartx.length]); i++) {
          let byte = bytes[dartx.get](i);
          if (dart.notNull(byte) < 0 || dart.notNull(byte) > 255) {
            dart.throw(new core.ArgumentError.value(byte, "non-byte value"));
          }
        }
      }
    }
    toString() {
      return this[_separatorIndices][dartx.get](0) == core.UriData._noScheme ? dart.str`data:${this[_text]}` : this[_text];
    }
  };
  dart.defineNamedConstructor(core.UriData, '_');
  dart.setSignature(core.UriData, {
    constructors: () => ({
      _: dart.definiteFunctionType(core.UriData, [core.String, core.List$(core.int), core.Uri]),
      fromString: dart.definiteFunctionType(core.UriData, [core.String], {mimeType: core.String, encoding: convert.Encoding, parameters: MapOfString$String(), base64: core.bool}),
      fromBytes: dart.definiteFunctionType(core.UriData, [core.List$(core.int)], {mimeType: dart.dynamic, parameters: MapOfString$String(), percentEncoded: dart.dynamic}),
      fromUri: dart.definiteFunctionType(core.UriData, [core.Uri])
    }),
    methods: () => ({
      contentAsBytes: dart.definiteFunctionType(core.List$(core.int), []),
      contentAsString: dart.definiteFunctionType(core.String, [], {encoding: convert.Encoding})
    }),
    statics: () => ({
      _writeUri: dart.definiteFunctionType(dart.void, [core.String, core.String, core.Map$(core.String, core.String), core.StringBuffer, core.List]),
      _validateMimeType: dart.definiteFunctionType(core.int, [core.String]),
      parse: dart.definiteFunctionType(core.UriData, [core.String]),
      _parse: dart.definiteFunctionType(core.UriData, [core.String, core.int, core.Uri]),
      _uriEncodeBytes: dart.definiteFunctionType(dart.void, [core.List$(core.int), core.List$(core.int), core.StringSink])
    }),
    names: ['_writeUri', '_validateMimeType', 'parse', '_parse', '_uriEncodeBytes']
  });
  core.UriData._noScheme = -1;
  core.UriData._tokenCharTable = dart.constList([0, 0, 27858, 1023, 65534, 51199, 65535, 32767], core.int);
  core.UriData._uricTable = core.Uri._queryCharTable;
  isolate.IsolateSpawnException = class IsolateSpawnException extends core.Object {
    new(message) {
      this.message = message;
    }
    toString() {
      return dart.str`IsolateSpawnException: ${this.message}`;
    }
  };
  isolate.IsolateSpawnException[dart.implements] = () => [core.Exception];
  dart.setSignature(isolate.IsolateSpawnException, {
    constructors: () => ({new: dart.definiteFunctionType(isolate.IsolateSpawnException, [core.String])})
  });
  const _pause = Symbol('_pause');
  isolate.Isolate = class Isolate extends core.Object {
    new(controlPort, opts) {
      let pauseCapability = opts && 'pauseCapability' in opts ? opts.pauseCapability : null;
      let terminateCapability = opts && 'terminateCapability' in opts ? opts.terminateCapability : null;
      this.controlPort = controlPort;
      this.pauseCapability = pauseCapability;
      this.terminateCapability = terminateCapability;
    }
    static get current() {
      return isolate.Isolate._currentIsolateCache;
    }
    static spawn(entryPoint, message, opts) {
      let paused = opts && 'paused' in opts ? opts.paused : false;
      try {
        return _isolate_helper.IsolateNatives.spawnFunction(entryPoint, message, paused).then(isolate.Isolate)(dart.fn(msg => new isolate.Isolate(isolate.SendPort._check(msg[dartx.get](1)), {pauseCapability: isolate.Capability._check(msg[dartx.get](2)), terminateCapability: isolate.Capability._check(msg[dartx.get](3))}), ListToIsolate()));
      } catch (e) {
        let st = dart.stackTrace(e);
        return FutureOfIsolate().error(e, st);
      }

    }
    static spawnUri(uri, args, message, opts) {
      let paused = opts && 'paused' in opts ? opts.paused : false;
      let packageRoot = opts && 'packageRoot' in opts ? opts.packageRoot : null;
      if (packageRoot != null) dart.throw(new core.UnimplementedError("packageRoot"));
      try {
        if (core.List.is(args)) {
          for (let i = 0; i < dart.notNull(args[dartx.length]); i++) {
            if (!(typeof args[dartx.get](i) == 'string')) {
              dart.throw(new core.ArgumentError(dart.str`Args must be a list of Strings ${args}`));
            }
          }
        } else if (args != null) {
          dart.throw(new core.ArgumentError(dart.str`Args must be a list of Strings ${args}`));
        }
        return _isolate_helper.IsolateNatives.spawnUri(uri, args, message, paused).then(isolate.Isolate)(dart.fn(msg => new isolate.Isolate(isolate.SendPort._check(msg[dartx.get](1)), {pauseCapability: isolate.Capability._check(msg[dartx.get](2)), terminateCapability: isolate.Capability._check(msg[dartx.get](3))}), ListToIsolate()));
      } catch (e) {
        let st = dart.stackTrace(e);
        return FutureOfIsolate().error(e, st);
      }

    }
    pause(resumeCapability) {
      if (resumeCapability === void 0) resumeCapability = null;
      if (resumeCapability == null) resumeCapability = isolate.Capability.new();
      this[_pause](resumeCapability);
      return resumeCapability;
    }
    [_pause](resumeCapability) {
      let message = core.List.new(3);
      message[dartx.set](0, "pause");
      message[dartx.set](1, this.pauseCapability);
      message[dartx.set](2, resumeCapability);
      this.controlPort.send(message);
    }
    resume(resumeCapability) {
      let message = core.List.new(2);
      message[dartx.set](0, "resume");
      message[dartx.set](1, resumeCapability);
      this.controlPort.send(message);
    }
    addOnExitListener(responsePort) {
      let message = core.List.new(2);
      message[dartx.set](0, "add-ondone");
      message[dartx.set](1, responsePort);
      this.controlPort.send(message);
    }
    removeOnExitListener(responsePort) {
      let message = core.List.new(2);
      message[dartx.set](0, "remove-ondone");
      message[dartx.set](1, responsePort);
      this.controlPort.send(message);
    }
    setErrorsFatal(errorsAreFatal) {
      let message = core.List.new(3);
      message[dartx.set](0, "set-errors-fatal");
      message[dartx.set](1, this.terminateCapability);
      message[dartx.set](2, errorsAreFatal);
      this.controlPort.send(message);
    }
    kill(priority) {
      if (priority === void 0) priority = isolate.Isolate.BEFORE_NEXT_EVENT;
      this.controlPort.send(JSArrayOfObject().of(["kill", this.terminateCapability, priority]));
    }
    ping(responsePort, pingType) {
      if (pingType === void 0) pingType = isolate.Isolate.IMMEDIATE;
      let message = core.List.new(3);
      message[dartx.set](0, "ping");
      message[dartx.set](1, responsePort);
      message[dartx.set](2, pingType);
      this.controlPort.send(message);
    }
    addErrorListener(port) {
      let message = core.List.new(2);
      message[dartx.set](0, "getErrors");
      message[dartx.set](1, port);
      this.controlPort.send(message);
    }
    removeErrorListener(port) {
      let message = core.List.new(2);
      message[dartx.set](0, "stopErrors");
      message[dartx.set](1, port);
      this.controlPort.send(message);
    }
    get errors() {
      let controller = null;
      let port = null;
      function handleError(message) {
        let errorDescription = core.String._check(dart.dindex(message, 0));
        let stackDescription = core.String._check(dart.dindex(message, 1));
        let error = new isolate.RemoteError(errorDescription, stackDescription);
        controller.addError(error, error.stackTrace);
      }
      dart.fn(handleError, dynamicTovoid$());
      controller = async.StreamController.broadcast({sync: true, onListen: dart.fn(() => {
          port = isolate.RawReceivePort.new(handleError);
          this.addErrorListener(port.sendPort);
        }, VoidTovoid$()), onCancel: dart.fn(() => {
          this.removeErrorListener(port.sendPort);
          port.close();
          port = null;
        }, VoidTovoid$())});
      return controller.stream;
    }
  };
  dart.setSignature(isolate.Isolate, {
    constructors: () => ({new: dart.definiteFunctionType(isolate.Isolate, [isolate.SendPort], {pauseCapability: isolate.Capability, terminateCapability: isolate.Capability})}),
    methods: () => ({
      pause: dart.definiteFunctionType(isolate.Capability, [], [isolate.Capability]),
      [_pause]: dart.definiteFunctionType(dart.void, [isolate.Capability]),
      resume: dart.definiteFunctionType(dart.void, [isolate.Capability]),
      addOnExitListener: dart.definiteFunctionType(dart.void, [isolate.SendPort]),
      removeOnExitListener: dart.definiteFunctionType(dart.void, [isolate.SendPort]),
      setErrorsFatal: dart.definiteFunctionType(dart.void, [core.bool]),
      kill: dart.definiteFunctionType(dart.void, [], [core.int]),
      ping: dart.definiteFunctionType(dart.void, [isolate.SendPort], [core.int]),
      addErrorListener: dart.definiteFunctionType(dart.void, [isolate.SendPort]),
      removeErrorListener: dart.definiteFunctionType(dart.void, [isolate.SendPort])
    }),
    statics: () => ({
      spawn: dart.definiteFunctionType(async.Future$(isolate.Isolate), [dart.functionType(dart.void, [dart.dynamic]), dart.dynamic], {paused: core.bool}),
      spawnUri: dart.definiteFunctionType(async.Future$(isolate.Isolate), [core.Uri, core.List$(core.String), dart.dynamic], {paused: core.bool, packageRoot: core.Uri})
    }),
    names: ['spawn', 'spawnUri']
  });
  isolate.Isolate.IMMEDIATE = 0;
  isolate.Isolate.BEFORE_NEXT_EVENT = 1;
  isolate.Isolate.AS_EVENT = 2;
  dart.defineLazy(isolate.Isolate, {
    get _currentIsolateCache() {
      return _isolate_helper.IsolateNatives.currentIsolate;
    }
  });
  isolate.SendPort = class SendPort extends core.Object {};
  isolate.SendPort[dart.implements] = () => [isolate.Capability];
  isolate.ReceivePort = class ReceivePort extends core.Object {
    static new() {
      return new _isolate_helper.ReceivePortImpl();
    }
    static fromRawReceivePort(rawPort) {
      return new _isolate_helper.ReceivePortImpl.fromRawReceivePort(rawPort);
    }
  };
  isolate.ReceivePort[dart.implements] = () => [async.Stream];
  dart.setSignature(isolate.ReceivePort, {
    constructors: () => ({
      new: dart.definiteFunctionType(isolate.ReceivePort, []),
      fromRawReceivePort: dart.definiteFunctionType(isolate.ReceivePort, [isolate.RawReceivePort])
    })
  });
  isolate.RawReceivePort = class RawReceivePort extends core.Object {
    static new(handler) {
      if (handler === void 0) handler = null;
      return new _isolate_helper.RawReceivePortImpl(handler);
    }
  };
  dart.setSignature(isolate.RawReceivePort, {
    constructors: () => ({new: dart.definiteFunctionType(isolate.RawReceivePort, [], [dart.functionType(dart.void, [dart.dynamic])])})
  });
  isolate._IsolateUnhandledException = class _IsolateUnhandledException extends core.Object {
    new(message, source, stackTrace) {
      this.message = message;
      this.source = source;
      this.stackTrace = stackTrace;
    }
    toString() {
      return 'IsolateUnhandledException: exception while handling message: ' + dart.str`${this.message} \n  ` + dart.str`${dart.toString(this.source)[dartx.replaceAll]("\n", "\n  ")}\n` + 'original stack trace:\n  ' + dart.str`${dart.toString(this.stackTrace)[dartx.replaceAll]("\n", "\n  ")}`;
    }
  };
  isolate._IsolateUnhandledException[dart.implements] = () => [core.Exception];
  dart.setSignature(isolate._IsolateUnhandledException, {
    constructors: () => ({new: dart.definiteFunctionType(isolate._IsolateUnhandledException, [dart.dynamic, dart.dynamic, core.StackTrace])})
  });
  const _description = Symbol('_description');
  isolate.RemoteError = class RemoteError extends core.Object {
    new(description, stackDescription) {
      this[_description] = description;
      this.stackTrace = new isolate._RemoteStackTrace(stackDescription);
    }
    toString() {
      return this[_description];
    }
  };
  isolate.RemoteError[dart.implements] = () => [core.Error];
  dart.setSignature(isolate.RemoteError, {
    constructors: () => ({new: dart.definiteFunctionType(isolate.RemoteError, [core.String, core.String])})
  });
  const _trace$ = Symbol('_trace');
  isolate._RemoteStackTrace = class _RemoteStackTrace extends core.Object {
    new(trace) {
      this[_trace$] = trace;
    }
    toString() {
      return this[_trace$];
    }
  };
  isolate._RemoteStackTrace[dart.implements] = () => [core.StackTrace];
  dart.setSignature(isolate._RemoteStackTrace, {
    constructors: () => ({new: dart.definiteFunctionType(isolate._RemoteStackTrace, [core.String])})
  });
  isolate.Capability = class Capability extends core.Object {
    static new() {
      return new _isolate_helper.CapabilityImpl();
    }
  };
  dart.setSignature(isolate.Capability, {
    constructors: () => ({new: dart.definiteFunctionType(isolate.Capability, [])})
  });
  dart.defineLazy(js, {
    get _global() {
      return dart.global;
    }
  });
  dart.defineLazy(js, {
    get context() {
      return js._wrapToDart(js._global);
    }
  });
  const _jsObject = Symbol('_jsObject');
  js.JsObject = class JsObject extends core.Object {
    _fromJs(jsObject) {
      this[_jsObject] = jsObject;
      dart.assert(this[_jsObject] != null);
    }
    static new(constructor, arguments$) {
      if (arguments$ === void 0) arguments$ = null;
      let ctor = constructor[_jsObject];
      if (arguments$ == null) {
        return js._wrapToDart(new ctor());
      }
      let unwrapped = core.List.from(arguments$[dartx.map](dart.dynamic)(js._convertToJS));
      return js._wrapToDart(new ctor(...unwrapped));
    }
    static fromBrowserObject(object) {
      if (typeof object == 'number' || typeof object == 'string' || typeof object == 'boolean' || object == null) {
        dart.throw(new core.ArgumentError("object cannot be a num, string, bool, or null"));
      }
      return js._wrapToDart(js._convertToJS(object));
    }
    static jsify(object) {
      if (!core.Map.is(object) && !core.Iterable.is(object)) {
        dart.throw(new core.ArgumentError("object must be a Map or Iterable"));
      }
      return js._wrapToDart(js.JsObject._convertDataTree(object));
    }
    static _convertDataTree(data) {
      let _convertedObjects = collection.HashMap.identity();
      function _convert(o) {
        if (dart.test(_convertedObjects.containsKey(o))) {
          return _convertedObjects.get(o);
        }
        if (core.Map.is(o)) {
          let convertedMap = {};
          _convertedObjects.set(o, convertedMap);
          for (let key of o[dartx.keys]) {
            convertedMap[key] = _convert(o[dartx.get](key));
          }
          return convertedMap;
        } else if (core.Iterable.is(o)) {
          let convertedList = [];
          _convertedObjects.set(o, convertedList);
          convertedList[dartx.addAll](o[dartx.map](dart.dynamic)(_convert));
          return convertedList;
        } else {
          return js._convertToJS(o);
        }
      }
      dart.fn(_convert, dynamicTodynamic$());
      return _convert(data);
    }
    get(property) {
      if (!(typeof property == 'string') && !(typeof property == 'number')) {
        dart.throw(new core.ArgumentError("property is not a String or num"));
      }
      return js._convertToDart(this[_jsObject][property]);
    }
    set(property, value) {
      if (!(typeof property == 'string') && !(typeof property == 'number')) {
        dart.throw(new core.ArgumentError("property is not a String or num"));
      }
      this[_jsObject][property] = js._convertToJS(value);
      return value;
    }
    get hashCode() {
      return 0;
    }
    ['=='](other) {
      return js.JsObject.is(other) && this[_jsObject] === other[_jsObject];
    }
    hasProperty(property) {
      if (!(typeof property == 'string') && !(typeof property == 'number')) {
        dart.throw(new core.ArgumentError("property is not a String or num"));
      }
      return property in this[_jsObject];
    }
    deleteProperty(property) {
      if (!(typeof property == 'string') && !(typeof property == 'number')) {
        dart.throw(new core.ArgumentError("property is not a String or num"));
      }
      delete this[_jsObject][property];
    }
    instanceof(type) {
      return this[_jsObject] instanceof js._convertToJS(type);
    }
    toString() {
      try {
        return String(this[_jsObject]);
      } catch (e) {
        return super.toString();
      }

    }
    callMethod(method, args) {
      if (args === void 0) args = null;
      if (!(typeof method == 'string') && !(typeof method == 'number')) {
        dart.throw(new core.ArgumentError("method is not a String or num"));
      }
      if (args != null) args = core.List.from(args[dartx.map](dart.dynamic)(js._convertToJS));
      let fn = this[_jsObject][method];
      if (!(fn instanceof Function)) {
        dart.throw(new core.NoSuchMethodError(this[_jsObject], core.Symbol.new(core.String._check(method)), args, dart.map()));
      }
      return js._convertToDart(fn.apply(this[_jsObject], args));
    }
  };
  dart.defineNamedConstructor(js.JsObject, '_fromJs');
  dart.setSignature(js.JsObject, {
    constructors: () => ({
      _fromJs: dart.definiteFunctionType(js.JsObject, [dart.dynamic]),
      new: dart.definiteFunctionType(js.JsObject, [js.JsFunction], [core.List]),
      fromBrowserObject: dart.definiteFunctionType(js.JsObject, [dart.dynamic]),
      jsify: dart.definiteFunctionType(js.JsObject, [dart.dynamic])
    }),
    methods: () => ({
      get: dart.definiteFunctionType(dart.dynamic, [core.Object]),
      set: dart.definiteFunctionType(dart.dynamic, [core.Object, dart.dynamic]),
      hasProperty: dart.definiteFunctionType(core.bool, [dart.dynamic]),
      deleteProperty: dart.definiteFunctionType(dart.void, [dart.dynamic]),
      instanceof: dart.definiteFunctionType(core.bool, [js.JsFunction]),
      callMethod: dart.definiteFunctionType(dart.dynamic, [dart.dynamic], [core.List])
    }),
    statics: () => ({_convertDataTree: dart.definiteFunctionType(dart.dynamic, [dart.dynamic])}),
    names: ['_convertDataTree']
  });
  js.JsFunction = class JsFunction extends js.JsObject {
    static withThis(f) {
      return new js.JsFunction._fromJs(function() {
        let args = [js._convertToDart(this)];
        for (let arg of arguments) {
          args.push(js._convertToDart(arg));
        }
        return js._convertToJS(f(...args));
      });
    }
    _fromJs(jsObject) {
      super._fromJs(jsObject);
    }
    apply(args, opts) {
      let thisArg = opts && 'thisArg' in opts ? opts.thisArg : null;
      return js._convertToDart(this[_jsObject].apply(js._convertToJS(thisArg), args == null ? null : core.List.from(args[dartx.map](dart.dynamic)(js._convertToJS))));
    }
  };
  dart.defineNamedConstructor(js.JsFunction, '_fromJs');
  dart.setSignature(js.JsFunction, {
    constructors: () => ({
      withThis: dart.definiteFunctionType(js.JsFunction, [core.Function]),
      _fromJs: dart.definiteFunctionType(js.JsFunction, [dart.dynamic])
    }),
    methods: () => ({apply: dart.definiteFunctionType(dart.dynamic, [core.List], {thisArg: dart.dynamic})})
  });
  const _checkIndex = Symbol('_checkIndex');
  const _checkInsertIndex = Symbol('_checkInsertIndex');
  js.JsArray$ = dart.generic(E => {
    let JSArrayOfE = () => (JSArrayOfE = dart.constFn(_interceptors.JSArray$(E)))();
    let IterableOfE = () => (IterableOfE = dart.constFn(core.Iterable$(E)))();
    let EAndEToint = () => (EAndEToint = dart.constFn(dart.functionType(core.int, [E, E])))();
    let JSArrayOfEAndEToint = () => (JSArrayOfEAndEToint = dart.constFn(_interceptors.JSArray$(EAndEToint())))();
    class JsArray extends dart.mixin(js.JsObject, collection.ListMixin$(E)) {
      new() {
        super._fromJs([]);
      }
      from(other) {
        super._fromJs((() => {
          let _ = [];
          _[dartx.addAll](other[dartx.map](dart.dynamic)(js._convertToJS));
          return _;
        })());
      }
      _fromJs(jsObject) {
        super._fromJs(jsObject);
      }
      [_checkIndex](index) {
        if (typeof index == 'number' && (dart.notNull(index) < 0 || dart.notNull(index) >= dart.notNull(this.length))) {
          dart.throw(new core.RangeError.range(index, 0, this.length));
        }
      }
      [_checkInsertIndex](index) {
        if (typeof index == 'number' && (dart.notNull(index) < 0 || dart.notNull(index) >= dart.notNull(this.length) + 1)) {
          dart.throw(new core.RangeError.range(index, 0, this.length));
        }
      }
      static _checkRange(start, end, length) {
        if (dart.notNull(start) < 0 || dart.notNull(start) > dart.notNull(length)) {
          dart.throw(new core.RangeError.range(start, 0, length));
        }
        if (dart.notNull(end) < dart.notNull(start) || dart.notNull(end) > dart.notNull(length)) {
          dart.throw(new core.RangeError.range(end, start, length));
        }
      }
      get(index) {
        if (typeof index == 'number' && index == index[dartx.toInt]()) {
          this[_checkIndex](dart.asInt(index));
        }
        return E.as(super.get(index));
      }
      set(index, value) {
        E._check(value);
        if (typeof index == 'number' && index == index[dartx.toInt]()) {
          this[_checkIndex](dart.asInt(index));
        }
        super.set(index, value);
        return value;
      }
      get length() {
        let len = this[_jsObject].length;
        if (typeof len === "number" && len >>> 0 === len) {
          return len;
        }
        dart.throw(new core.StateError('Bad JsArray length'));
      }
      set length(length) {
        super.set('length', length);
      }
      add(value) {
        E._check(value);
        this.callMethod('push', JSArrayOfE().of([value]));
      }
      addAll(iterable) {
        IterableOfE()._check(iterable);
        let list = iterable instanceof Array ? iterable : core.List.from(iterable);
        this.callMethod('push', core.List._check(list));
      }
      insert(index, element) {
        E._check(element);
        this[_checkInsertIndex](index);
        this.callMethod('splice', JSArrayOfObject().of([index, 0, element]));
      }
      removeAt(index) {
        this[_checkIndex](index);
        return E.as(dart.dindex(this.callMethod('splice', JSArrayOfint().of([index, 1])), 0));
      }
      removeLast() {
        if (this.length == 0) dart.throw(new core.RangeError(-1));
        return E.as(this.callMethod('pop'));
      }
      removeRange(start, end) {
        js.JsArray._checkRange(start, end, this.length);
        this.callMethod('splice', JSArrayOfint().of([start, dart.notNull(end) - dart.notNull(start)]));
      }
      setRange(start, end, iterable, skipCount) {
        IterableOfE()._check(iterable);
        if (skipCount === void 0) skipCount = 0;
        js.JsArray._checkRange(start, end, this.length);
        let length = dart.notNull(end) - dart.notNull(start);
        if (length == 0) return;
        if (dart.notNull(skipCount) < 0) dart.throw(new core.ArgumentError(skipCount));
        let args = JSArrayOfObject().of([start, length]);
        args[dartx.addAll](iterable[dartx.skip](skipCount)[dartx.take](length));
        this.callMethod('splice', args);
      }
      sort(compare) {
        if (compare === void 0) compare = null;
        this.callMethod('sort', compare == null ? [] : JSArrayOfEAndEToint().of([compare]));
      }
    }
    dart.addTypeTests(JsArray);
    dart.defineNamedConstructor(JsArray, 'from');
    dart.defineNamedConstructor(JsArray, '_fromJs');
    dart.setSignature(JsArray, {
      constructors: () => ({
        new: dart.definiteFunctionType(js.JsArray$(E), []),
        from: dart.definiteFunctionType(js.JsArray$(E), [core.Iterable$(E)]),
        _fromJs: dart.definiteFunctionType(js.JsArray$(E), [dart.dynamic])
      }),
      methods: () => ({
        [_checkIndex]: dart.definiteFunctionType(dart.dynamic, [core.int]),
        [_checkInsertIndex]: dart.definiteFunctionType(dart.dynamic, [core.int]),
        get: dart.definiteFunctionType(E, [core.Object]),
        set: dart.definiteFunctionType(dart.void, [core.Object, E]),
        add: dart.definiteFunctionType(dart.void, [E]),
        addAll: dart.definiteFunctionType(dart.void, [core.Iterable$(E)]),
        insert: dart.definiteFunctionType(dart.void, [core.int, E]),
        removeAt: dart.definiteFunctionType(E, [core.int]),
        removeLast: dart.definiteFunctionType(E, []),
        setRange: dart.definiteFunctionType(dart.void, [core.int, core.int, core.Iterable$(E)], [core.int]),
        sort: dart.definiteFunctionType(dart.void, [], [dart.functionType(core.int, [E, E])])
      }),
      statics: () => ({_checkRange: dart.definiteFunctionType(dart.dynamic, [core.int, core.int, core.int])}),
      names: ['_checkRange']
    });
    dart.defineExtensionMembers(JsArray, [
      'get',
      'set',
      'add',
      'addAll',
      'insert',
      'removeAt',
      'removeLast',
      'removeRange',
      'setRange',
      'sort',
      'length',
      'length'
    ]);
    return JsArray;
  });
  js.JsArray = JsArray();
  js._isBrowserType = function(o) {
    return o instanceof Blob || o instanceof Event || window.KeyRange && o instanceof KeyRange || o instanceof ImageData || o instanceof Node || window.TypedData && o instanceof TypedData || o instanceof Window;
  };
  dart.fn(js._isBrowserType, dynamicTobool$());
  const _dartObj = Symbol('_dartObj');
  js._DartObject = class _DartObject extends core.Object {
    new(dartObj) {
      this[_dartObj] = dartObj;
    }
  };
  dart.setSignature(js._DartObject, {
    constructors: () => ({new: dart.definiteFunctionType(js._DartObject, [dart.dynamic])})
  });
  js._convertToJS = function(o) {
    if (o == null || typeof o == 'string' || typeof o == 'number' || typeof o == 'boolean' || dart.test(js._isBrowserType(o))) {
      return o;
    } else if (core.DateTime.is(o)) {
      return _js_helper.Primitives.lazyAsJsDate(o);
    } else if (js.JsObject.is(o)) {
      return o[_jsObject];
    } else if (core.Function.is(o)) {
      return js._putIfAbsent(js._jsProxies, o, js._wrapDartFunction);
    } else {
      return js._putIfAbsent(js._jsProxies, o, dart.fn(o => new js._DartObject(o), dynamicTo_DartObject()));
    }
  };
  dart.fn(js._convertToJS, dynamicTodynamic$());
  js._wrapDartFunction = function(f) {
    let wrapper = function() {
      let args = Array.prototype.map.call(arguments, js._convertToDart);
      return js._convertToJS(f(...args));
    };
    dart.dsetindex(js._dartProxies, wrapper, f);
    return wrapper;
  };
  dart.fn(js._wrapDartFunction, dynamicTodynamic$());
  js._convertToDart = function(o) {
    if (o == null || typeof o == "string" || typeof o == "number" || typeof o == "boolean" || dart.test(js._isBrowserType(o))) {
      return o;
    } else if (o instanceof Date) {
      let ms = o.getTime();
      return new core.DateTime.fromMillisecondsSinceEpoch(dart.asInt(ms));
    } else if (js._DartObject.is(o) && dart.jsobject != dart.getReifiedType(o)) {
      return o[_dartObj];
    } else {
      return js._putIfAbsent(js._dartProxies, o, js._wrapToDart);
    }
  };
  dart.fn(js._convertToDart, dynamicToObject());
  js._wrapToDart = function(o) {
    if (typeof o == "function") {
      return new js.JsFunction._fromJs(o);
    }
    if (o instanceof Array) {
      return new js.JsArray._fromJs(o);
    }
    return new js.JsObject._fromJs(o);
  };
  dart.fn(js._wrapToDart, dynamicToJsObject());
  dart.defineLazy(js, {
    get _dartProxies() {
      return new WeakMap();
    }
  });
  dart.defineLazy(js, {
    get _jsProxies() {
      return new WeakMap();
    }
  });
  js._putIfAbsent = function(weakMap, o, getValue) {
    let value = weakMap.get(o);
    if (value == null) {
      value = dart.dcall(getValue, o);
      weakMap.set(o, value);
    }
    return value;
  };
  dart.fn(js._putIfAbsent, dynamicAnddynamicAndFnToObject());
  js.allowInterop = function(f) {
    return f;
  };
  dart.fn(js.allowInterop, FunctionToFunction());
  dart.defineLazy(js, {
    get _interopCaptureThisExpando() {
      return new (ExpandoOfFunction())();
    },
    set _interopCaptureThisExpando(_) {}
  });
  js.allowInteropCaptureThis = function(f) {
    let ret = js._interopCaptureThisExpando.get(f);
    if (ret == null) {
      ret = function() {
        let args = [this];
        for (let arg of arguments) {
          args.push(arg);
        }
        return f(...args);
      };
      js._interopCaptureThisExpando.set(f, ret);
    }
    return ret;
  };
  dart.fn(js.allowInteropCaptureThis, FunctionToFunction());
  math.E = 2.718281828459045;
  math.LN10 = 2.302585092994046;
  math.LN2 = 0.6931471805599453;
  math.LOG2E = 1.4426950408889634;
  math.LOG10E = 0.4342944819032518;
  math.PI = 3.141592653589793;
  math.SQRT1_2 = 0.7071067811865476;
  math.SQRT2 = 1.4142135623730951;
  math.min = function(T) {
    return (a, b) => {
      if (!(typeof a == 'number')) dart.throw(new core.ArgumentError(a));
      if (!(typeof b == 'number')) dart.throw(new core.ArgumentError(b));
      if (dart.notNull(a) > dart.notNull(b)) return b;
      if (dart.notNull(a) < dart.notNull(b)) return a;
      if (typeof b == 'number') {
        if (typeof a == 'number') {
          if (a == 0.0) {
            return (dart.notNull(a) + dart.notNull(b)) * dart.notNull(a) * dart.notNull(b);
          }
        }
        if (a == 0 && dart.test(b[dartx.isNegative]) || dart.test(b[dartx.isNaN])) return b;
        return a;
      }
      return a;
    };
  };
  dart.fn(math.min, TAndTToT());
  math.max = function(T) {
    return (a, b) => {
      if (!(typeof a == 'number')) dart.throw(new core.ArgumentError(a));
      if (!(typeof b == 'number')) dart.throw(new core.ArgumentError(b));
      if (dart.notNull(a) > dart.notNull(b)) return a;
      if (dart.notNull(a) < dart.notNull(b)) return b;
      if (typeof b == 'number') {
        if (typeof a == 'number') {
          if (a == 0.0) {
            return dart.notNull(a) + dart.notNull(b);
          }
        }
        if (dart.test(b[dartx.isNaN])) return b;
        return a;
      }
      if (b == 0 && dart.test(a[dartx.isNegative])) return b;
      return a;
    };
  };
  dart.fn(math.max, TAndTToT$());
  math.atan2 = function(a, b) {
    return Math.atan2(_js_helper.checkNum(a), _js_helper.checkNum(b));
  };
  dart.fn(math.atan2, numAndnumTodouble());
  math.pow = function(x, exponent) {
    _js_helper.checkNum(x);
    _js_helper.checkNum(exponent);
    return Math.pow(x, exponent);
  };
  dart.fn(math.pow, numAndnumTonum());
  math.sin = function(x) {
    return Math.sin(_js_helper.checkNum(x));
  };
  dart.fn(math.sin, numTodouble());
  math.cos = function(x) {
    return Math.cos(_js_helper.checkNum(x));
  };
  dart.fn(math.cos, numTodouble());
  math.tan = function(x) {
    return Math.tan(_js_helper.checkNum(x));
  };
  dart.fn(math.tan, numTodouble());
  math.acos = function(x) {
    return Math.acos(_js_helper.checkNum(x));
  };
  dart.fn(math.acos, numTodouble());
  math.asin = function(x) {
    return Math.asin(_js_helper.checkNum(x));
  };
  dart.fn(math.asin, numTodouble());
  math.atan = function(x) {
    return Math.atan(_js_helper.checkNum(x));
  };
  dart.fn(math.atan, numTodouble());
  math.sqrt = function(x) {
    return Math.sqrt(_js_helper.checkNum(x));
  };
  dart.fn(math.sqrt, numTodouble());
  math.exp = function(x) {
    return Math.exp(_js_helper.checkNum(x));
  };
  dart.fn(math.exp, numTodouble());
  math.log = function(x) {
    return Math.log(_js_helper.checkNum(x));
  };
  dart.fn(math.log, numTodouble());
  math._POW2_32 = 4294967296;
  math._JSRandom = class _JSRandom extends core.Object {
    new() {
    }
    nextInt(max) {
      if (dart.notNull(max) <= 0 || dart.notNull(max) > math._POW2_32) {
        dart.throw(new core.RangeError(dart.str`max must be in range 0 < max  2^32, was ${max}`));
      }
      return Math.random() * max >>> 0;
    }
    nextDouble() {
      return Math.random();
    }
    nextBool() {
      return Math.random() < 0.5;
    }
  };
  math._JSRandom[dart.implements] = () => [math.Random];
  dart.setSignature(math._JSRandom, {
    constructors: () => ({new: dart.definiteFunctionType(math._JSRandom, [])}),
    methods: () => ({
      nextInt: dart.definiteFunctionType(core.int, [core.int]),
      nextDouble: dart.definiteFunctionType(core.double, []),
      nextBool: dart.definiteFunctionType(core.bool, [])
    })
  });
  const _lo = Symbol('_lo');
  const _hi = Symbol('_hi');
  const _nextState = Symbol('_nextState');
  math._Random = class _Random extends core.Object {
    new(seed) {
      this[_lo] = 0;
      this[_hi] = 0;
      let empty_seed = 0;
      if (dart.notNull(seed) < 0) {
        empty_seed = -1;
      }
      do {
        let low = (dart.notNull(seed) & math._Random._MASK32) >>> 0;
        seed = ((dart.notNull(seed) - low) / math._POW2_32)[dartx.truncate]();
        let high = (dart.notNull(seed) & math._Random._MASK32) >>> 0;
        seed = ((dart.notNull(seed) - high) / math._POW2_32)[dartx.truncate]();
        let tmplow = low << 21 >>> 0;
        let tmphigh = (high << 21 | low[dartx['>>']](11)) >>> 0;
        tmplow = ((~low & math._Random._MASK32) >>> 0) + tmplow;
        low = (tmplow & math._Random._MASK32) >>> 0;
        high = ((~high >>> 0) + tmphigh + ((tmplow - low) / 4294967296)[dartx.truncate]() & math._Random._MASK32) >>> 0;
        tmphigh = high[dartx['>>']](24);
        tmplow = (low[dartx['>>']](24) | high << 8) >>> 0;
        low = (low ^ tmplow) >>> 0;
        high = (high ^ tmphigh) >>> 0;
        tmplow = low * 265;
        low = (tmplow & math._Random._MASK32) >>> 0;
        high = (high * 265 + ((tmplow - low) / 4294967296)[dartx.truncate]() & math._Random._MASK32) >>> 0;
        tmphigh = high[dartx['>>']](14);
        tmplow = (low[dartx['>>']](14) | high << 18) >>> 0;
        low = (low ^ tmplow) >>> 0;
        high = (high ^ tmphigh) >>> 0;
        tmplow = low * 21;
        low = (tmplow & math._Random._MASK32) >>> 0;
        high = (high * 21 + ((tmplow - low) / 4294967296)[dartx.truncate]() & math._Random._MASK32) >>> 0;
        tmphigh = high[dartx['>>']](28);
        tmplow = (low[dartx['>>']](28) | high << 4) >>> 0;
        low = (low ^ tmplow) >>> 0;
        high = (high ^ tmphigh) >>> 0;
        tmplow = low << 31 >>> 0;
        tmphigh = (high << 31 | low[dartx['>>']](1)) >>> 0;
        tmplow = tmplow + low;
        low = (tmplow & math._Random._MASK32) >>> 0;
        high = (high + tmphigh + ((tmplow - low) / 4294967296)[dartx.truncate]() & math._Random._MASK32) >>> 0;
        tmplow = dart.notNull(this[_lo]) * 1037;
        this[_lo] = (tmplow & math._Random._MASK32) >>> 0;
        this[_hi] = (dart.notNull(this[_hi]) * 1037 + ((tmplow - dart.notNull(this[_lo])) / 4294967296)[dartx.truncate]() & math._Random._MASK32) >>> 0;
        this[_lo] = (dart.notNull(this[_lo]) ^ low) >>> 0;
        this[_hi] = (dart.notNull(this[_hi]) ^ high) >>> 0;
      } while (seed != empty_seed);
      if (this[_hi] == 0 && this[_lo] == 0) {
        this[_lo] = 23063;
      }
      this[_nextState]();
      this[_nextState]();
      this[_nextState]();
      this[_nextState]();
    }
    [_nextState]() {
      let tmpHi = 4294901760 * dart.notNull(this[_lo]);
      let tmpHiLo = (tmpHi & math._Random._MASK32) >>> 0;
      let tmpHiHi = tmpHi - tmpHiLo;
      let tmpLo = 55905 * dart.notNull(this[_lo]);
      let tmpLoLo = (tmpLo & math._Random._MASK32) >>> 0;
      let tmpLoHi = tmpLo - tmpLoLo;
      let newLo = tmpLoLo + tmpHiLo + dart.notNull(this[_hi]);
      this[_lo] = (newLo & math._Random._MASK32) >>> 0;
      let newLoHi = newLo - dart.notNull(this[_lo]);
      this[_hi] = (((tmpLoHi + tmpHiHi + newLoHi) / math._POW2_32)[dartx.truncate]() & math._Random._MASK32) >>> 0;
      dart.assert(dart.notNull(this[_lo]) < math._POW2_32);
      dart.assert(dart.notNull(this[_hi]) < math._POW2_32);
    }
    nextInt(max) {
      if (dart.notNull(max) <= 0 || dart.notNull(max) > math._POW2_32) {
        dart.throw(new core.RangeError(dart.str`max must be in range 0 < max  2^32, was ${max}`));
      }
      if ((dart.notNull(max) & dart.notNull(max) - 1) == 0) {
        this[_nextState]();
        return (dart.notNull(this[_lo]) & dart.notNull(max) - 1) >>> 0;
      }
      let rnd32 = null;
      let result = null;
      do {
        this[_nextState]();
        rnd32 = this[_lo];
        result = dart.asInt(rnd32[dartx.remainder](max));
      } while (dart.notNull(rnd32) - dart.notNull(result) + dart.notNull(max) >= math._POW2_32);
      return result;
    }
    nextDouble() {
      this[_nextState]();
      let bits26 = (dart.notNull(this[_lo]) & (1 << 26) - 1) >>> 0;
      this[_nextState]();
      let bits27 = (dart.notNull(this[_lo]) & (1 << 27) - 1) >>> 0;
      return (bits26 * math._Random._POW2_27_D + bits27) / math._Random._POW2_53_D;
    }
    nextBool() {
      this[_nextState]();
      return (dart.notNull(this[_lo]) & 1) == 0;
    }
  };
  math._Random[dart.implements] = () => [math.Random];
  dart.setSignature(math._Random, {
    constructors: () => ({new: dart.definiteFunctionType(math._Random, [core.int])}),
    methods: () => ({
      [_nextState]: dart.definiteFunctionType(dart.void, []),
      nextInt: dart.definiteFunctionType(core.int, [core.int]),
      nextDouble: dart.definiteFunctionType(core.double, []),
      nextBool: dart.definiteFunctionType(core.bool, [])
    })
  });
  math._Random._POW2_53_D = 1.0 * 9007199254740992;
  math._Random._POW2_27_D = 1.0 * (1 << 27);
  math._Random._MASK32 = 4294967295;
  const _buffer$ = Symbol('_buffer');
  const _getRandomBytes = Symbol('_getRandomBytes');
  math._JSSecureRandom = class _JSSecureRandom extends core.Object {
    new() {
      this[_buffer$] = typed_data.ByteData.new(8);
      let crypto = self.crypto;
      if (crypto != null) {
        let getRandomValues = crypto.getRandomValues;
        if (getRandomValues != null) {
          return;
        }
      }
      dart.throw(new core.UnsupportedError("No source of cryptographically secure random numbers available."));
    }
    [_getRandomBytes](start, length) {
      crypto.getRandomValues(this[_buffer$][dartx.buffer][dartx.asUint8List](start, length));
    }
    nextBool() {
      this[_getRandomBytes](0, 1);
      return this[_buffer$][dartx.getUint8](0)[dartx.isOdd];
    }
    nextDouble() {
      this[_getRandomBytes](1, 7);
      this[_buffer$][dartx.setUint8](0, 63);
      let highByte = this[_buffer$][dartx.getUint8](1);
      this[_buffer$][dartx.setUint8](1, (dart.notNull(highByte) | 240) >>> 0);
      let result = dart.notNull(this[_buffer$][dartx.getFloat64](0)) - 1.0;
      if ((dart.notNull(highByte) & 16) != 0) {
        result = result + 1.1102230246251565e-16;
      }
      return result;
    }
    nextInt(max) {
      if (dart.notNull(max) <= 0 || dart.notNull(max) > math._POW2_32) {
        dart.throw(new core.RangeError(dart.str`max must be in range 0 < max  2^32, was ${max}`));
      }
      let byteCount = 1;
      if (dart.notNull(max) > 255) {
        byteCount++;
        if (dart.notNull(max) > 65535) {
          byteCount++;
          if (dart.notNull(max) > 16777215) {
            byteCount++;
          }
        }
      }
      this[_buffer$][dartx.setUint32](0, 0);
      let start = 4 - byteCount;
      let randomLimit = dart.asInt(math.pow(256, byteCount));
      while (true) {
        this[_getRandomBytes](start, byteCount);
        let random = this[_buffer$][dartx.getUint32](0);
        if ((dart.notNull(max) & dart.notNull(max) - 1) == 0) {
          return (dart.notNull(random) & dart.notNull(max) - 1) >>> 0;
        }
        let result = dart.asInt(random[dartx.remainder](max));
        if (dart.notNull(random) - dart.notNull(result) + dart.notNull(max) < dart.notNull(randomLimit)) {
          return result;
        }
      }
    }
  };
  math._JSSecureRandom[dart.implements] = () => [math.Random];
  dart.setSignature(math._JSSecureRandom, {
    constructors: () => ({new: dart.definiteFunctionType(math._JSSecureRandom, [])}),
    methods: () => ({
      [_getRandomBytes]: dart.definiteFunctionType(dart.void, [core.int, core.int]),
      nextBool: dart.definiteFunctionType(core.bool, []),
      nextDouble: dart.definiteFunctionType(core.double, []),
      nextInt: dart.definiteFunctionType(core.int, [core.int])
    })
  });
  math._JenkinsSmiHash = class _JenkinsSmiHash extends core.Object {
    static combine(hash, value) {
      hash = 536870911 & dart.notNull(hash) + dart.notNull(value);
      hash = 536870911 & dart.notNull(hash) + ((524287 & dart.notNull(hash)) << 10);
      return (dart.notNull(hash) ^ hash[dartx['>>']](6)) >>> 0;
    }
    static finish(hash) {
      hash = 536870911 & dart.notNull(hash) + ((67108863 & dart.notNull(hash)) << 3);
      hash = (dart.notNull(hash) ^ hash[dartx['>>']](11)) >>> 0;
      return 536870911 & dart.notNull(hash) + ((16383 & dart.notNull(hash)) << 15);
    }
    static hash2(a, b) {
      return math._JenkinsSmiHash.finish(math._JenkinsSmiHash.combine(math._JenkinsSmiHash.combine(0, core.int._check(a)), core.int._check(b)));
    }
    static hash4(a, b, c, d) {
      return math._JenkinsSmiHash.finish(math._JenkinsSmiHash.combine(math._JenkinsSmiHash.combine(math._JenkinsSmiHash.combine(math._JenkinsSmiHash.combine(0, core.int._check(a)), core.int._check(b)), core.int._check(c)), core.int._check(d)));
    }
  };
  dart.setSignature(math._JenkinsSmiHash, {
    statics: () => ({
      combine: dart.definiteFunctionType(core.int, [core.int, core.int]),
      finish: dart.definiteFunctionType(core.int, [core.int]),
      hash2: dart.definiteFunctionType(core.int, [dart.dynamic, dart.dynamic]),
      hash4: dart.definiteFunctionType(core.int, [dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic])
    }),
    names: ['combine', 'finish', 'hash2', 'hash4']
  });
  math.Point$ = dart.generic(T => {
    let PointOfT = () => (PointOfT = dart.constFn(math.Point$(T)))();
    class Point extends core.Object {
      new(x, y) {
        this.x = x;
        this.y = y;
      }
      toString() {
        return dart.str`Point(${this.x}, ${this.y})`;
      }
      ['=='](other) {
        if (!PointOfnum().is(other)) return false;
        return dart.equals(this.x, dart.dload(other, 'x')) && dart.equals(this.y, dart.dload(other, 'y'));
      }
      get hashCode() {
        return math._JenkinsSmiHash.hash2(dart.hashCode(this.x), dart.hashCode(this.y));
      }
      ['+'](other) {
        PointOfT()._check(other);
        return new (PointOfT())(dart.notNull(this.x) + dart.notNull(other.x), dart.notNull(this.y) + dart.notNull(other.y));
      }
      ['-'](other) {
        PointOfT()._check(other);
        return new (PointOfT())(dart.notNull(this.x) - dart.notNull(other.x), dart.notNull(this.y) - dart.notNull(other.y));
      }
      ['*'](factor) {
        return new (PointOfT())(dart.notNull(this.x) * dart.notNull(factor), dart.notNull(this.y) * dart.notNull(factor));
      }
      get magnitude() {
        return math.sqrt(dart.notNull(this.x) * dart.notNull(this.x) + dart.notNull(this.y) * dart.notNull(this.y));
      }
      distanceTo(other) {
        PointOfT()._check(other);
        let dx = dart.notNull(this.x) - dart.notNull(other.x);
        let dy = dart.notNull(this.y) - dart.notNull(other.y);
        return math.sqrt(dx * dx + dy * dy);
      }
      squaredDistanceTo(other) {
        PointOfT()._check(other);
        let dx = dart.notNull(this.x) - dart.notNull(other.x);
        let dy = dart.notNull(this.y) - dart.notNull(other.y);
        return dx * dx + dy * dy;
      }
    }
    dart.addTypeTests(Point);
    dart.setSignature(Point, {
      constructors: () => ({new: dart.definiteFunctionType(math.Point$(T), [T, T])}),
      methods: () => ({
        '+': dart.definiteFunctionType(math.Point$(T), [math.Point$(T)]),
        '-': dart.definiteFunctionType(math.Point$(T), [math.Point$(T)]),
        '*': dart.definiteFunctionType(math.Point$(T), [core.num]),
        distanceTo: dart.definiteFunctionType(core.double, [math.Point$(T)]),
        squaredDistanceTo: dart.definiteFunctionType(T, [math.Point$(T)])
      })
    });
    return Point;
  });
  math.Point = Point$();
  let const$47;
  math.Random = class Random extends core.Object {
    static new(seed) {
      if (seed === void 0) seed = null;
      return seed == null ? const$47 || (const$47 = dart.const(new math._JSRandom())) : new math._Random(seed);
    }
    static secure() {
      return math.Random._secureRandom;
    }
  };
  dart.setSignature(math.Random, {
    constructors: () => ({
      new: dart.definiteFunctionType(math.Random, [], [core.int]),
      secure: dart.definiteFunctionType(math.Random, [])
    })
  });
  dart.defineLazy(math.Random, {
    get _secureRandom() {
      return new math._JSSecureRandom();
    }
  });
  math._RectangleBase$ = dart.generic(T => {
    let RectangleOfT = () => (RectangleOfT = dart.constFn(math.Rectangle$(T)))();
    let PointOfT = () => (PointOfT = dart.constFn(math.Point$(T)))();
    dart.defineExtensionNames([
      'right',
      'bottom',
      'toString',
      '==',
      'hashCode',
      'intersection',
      'intersects',
      'boundingBox',
      'containsRectangle',
      'containsPoint',
      'topLeft',
      'topRight',
      'bottomRight',
      'bottomLeft'
    ]);
    class _RectangleBase extends core.Object {
      new() {
      }
      get right() {
        return dart.notNull(this[dartx.left]) + dart.notNull(this[dartx.width]);
      }
      get bottom() {
        return dart.notNull(this[dartx.top]) + dart.notNull(this[dartx.height]);
      }
      toString() {
        return dart.str`Rectangle (${this[dartx.left]}, ${this[dartx.top]}) ${this[dartx.width]} x ${this[dartx.height]}`;
      }
      ['=='](other) {
        if (!RectangleOfnum().is(other)) return false;
        return dart.equals(this[dartx.left], dart.dload(other, 'left')) && dart.equals(this[dartx.top], dart.dload(other, 'top')) && dart.equals(this[dartx.right], dart.dload(other, 'right')) && dart.equals(this[dartx.bottom], dart.dload(other, 'bottom'));
      }
      get hashCode() {
        return math._JenkinsSmiHash.hash4(dart.hashCode(this[dartx.left]), dart.hashCode(this[dartx.top]), dart.hashCode(this[dartx.right]), dart.hashCode(this[dartx.bottom]));
      }
      intersection(other) {
        RectangleOfT()._check(other);
        let x0 = math.max(T)(this[dartx.left], other[dartx.left]);
        let x1 = math.min(T)(dart.notNull(this[dartx.left]) + dart.notNull(this[dartx.width]), dart.notNull(other[dartx.left]) + dart.notNull(other[dartx.width]));
        if (dart.notNull(x0) <= dart.notNull(x1)) {
          let y0 = math.max(T)(this[dartx.top], other[dartx.top]);
          let y1 = math.min(T)(dart.notNull(this[dartx.top]) + dart.notNull(this[dartx.height]), dart.notNull(other[dartx.top]) + dart.notNull(other[dartx.height]));
          if (dart.notNull(y0) <= dart.notNull(y1)) {
            return new (RectangleOfT())(x0, y0, dart.notNull(x1) - dart.notNull(x0), dart.notNull(y1) - dart.notNull(y0));
          }
        }
        return null;
      }
      intersects(other) {
        return dart.notNull(this[dartx.left]) <= dart.notNull(other[dartx.left]) + dart.notNull(other[dartx.width]) && dart.notNull(other[dartx.left]) <= dart.notNull(this[dartx.left]) + dart.notNull(this[dartx.width]) && dart.notNull(this[dartx.top]) <= dart.notNull(other[dartx.top]) + dart.notNull(other[dartx.height]) && dart.notNull(other[dartx.top]) <= dart.notNull(this[dartx.top]) + dart.notNull(this[dartx.height]);
      }
      boundingBox(other) {
        RectangleOfT()._check(other);
        let right = math.max(T)(dart.notNull(this[dartx.left]) + dart.notNull(this[dartx.width]), dart.notNull(other[dartx.left]) + dart.notNull(other[dartx.width]));
        let bottom = math.max(T)(dart.notNull(this[dartx.top]) + dart.notNull(this[dartx.height]), dart.notNull(other[dartx.top]) + dart.notNull(other[dartx.height]));
        let left = math.min(T)(this[dartx.left], other[dartx.left]);
        let top = math.min(T)(this[dartx.top], other[dartx.top]);
        return new (RectangleOfT())(left, top, dart.notNull(right) - dart.notNull(left), dart.notNull(bottom) - dart.notNull(top));
      }
      containsRectangle(another) {
        return dart.notNull(this[dartx.left]) <= dart.notNull(another[dartx.left]) && dart.notNull(this[dartx.left]) + dart.notNull(this[dartx.width]) >= dart.notNull(another[dartx.left]) + dart.notNull(another[dartx.width]) && dart.notNull(this[dartx.top]) <= dart.notNull(another[dartx.top]) && dart.notNull(this[dartx.top]) + dart.notNull(this[dartx.height]) >= dart.notNull(another[dartx.top]) + dart.notNull(another[dartx.height]);
      }
      containsPoint(another) {
        return dart.notNull(another.x) >= dart.notNull(this[dartx.left]) && dart.notNull(another.x) <= dart.notNull(this[dartx.left]) + dart.notNull(this[dartx.width]) && dart.notNull(another.y) >= dart.notNull(this[dartx.top]) && dart.notNull(another.y) <= dart.notNull(this[dartx.top]) + dart.notNull(this[dartx.height]);
      }
      get topLeft() {
        return new (PointOfT())(this[dartx.left], this[dartx.top]);
      }
      get topRight() {
        return new (PointOfT())(dart.notNull(this[dartx.left]) + dart.notNull(this[dartx.width]), this[dartx.top]);
      }
      get bottomRight() {
        return new (PointOfT())(dart.notNull(this[dartx.left]) + dart.notNull(this[dartx.width]), dart.notNull(this[dartx.top]) + dart.notNull(this[dartx.height]));
      }
      get bottomLeft() {
        return new (PointOfT())(this[dartx.left], dart.notNull(this[dartx.top]) + dart.notNull(this[dartx.height]));
      }
    }
    dart.addTypeTests(_RectangleBase);
    dart.setSignature(_RectangleBase, {
      constructors: () => ({new: dart.definiteFunctionType(math._RectangleBase$(T), [])}),
      methods: () => ({
        intersection: dart.definiteFunctionType(math.Rectangle$(T), [math.Rectangle$(T)]),
        intersects: dart.definiteFunctionType(core.bool, [math.Rectangle$(core.num)]),
        boundingBox: dart.definiteFunctionType(math.Rectangle$(T), [math.Rectangle$(T)]),
        containsRectangle: dart.definiteFunctionType(core.bool, [math.Rectangle$(core.num)]),
        containsPoint: dart.definiteFunctionType(core.bool, [math.Point$(core.num)])
      })
    });
    dart.defineExtensionMembers(_RectangleBase, [
      'toString',
      '==',
      'intersection',
      'intersects',
      'boundingBox',
      'containsRectangle',
      'containsPoint',
      'right',
      'bottom',
      'hashCode',
      'topLeft',
      'topRight',
      'bottomRight',
      'bottomLeft'
    ]);
    return _RectangleBase;
  });
  math._RectangleBase = _RectangleBase();
  math.Rectangle$ = dart.generic(T => {
    let RectangleOfT = () => (RectangleOfT = dart.constFn(math.Rectangle$(T)))();
    dart.defineExtensionNames([
      'left',
      'top',
      'width',
      'height'
    ]);
    class Rectangle extends math._RectangleBase$(T) {
      new(left, top, width, height) {
        this[dartx.left] = left;
        this[dartx.top] = top;
        this[dartx.width] = dart.notNull(width) < 0 ? -dart.notNull(width) * 0 : width;
        this[dartx.height] = dart.notNull(height) < 0 ? -dart.notNull(height) * 0 : height;
        super.new();
      }
      static fromPoints(a, b) {
        let left = math.min(T)(a.x, b.x);
        let width = dart.notNull(math.max(T)(a.x, b.x)) - dart.notNull(left);
        let top = math.min(T)(a.y, b.y);
        let height = dart.notNull(math.max(T)(a.y, b.y)) - dart.notNull(top);
        return new (RectangleOfT())(left, top, width, height);
      }
    }
    dart.setSignature(Rectangle, {
      constructors: () => ({
        new: dart.definiteFunctionType(math.Rectangle$(T), [T, T, T, T]),
        fromPoints: dart.definiteFunctionType(math.Rectangle$(T), [math.Point$(T), math.Point$(T)])
      })
    });
    dart.defineExtensionMembers(Rectangle, ['left', 'top', 'width', 'height']);
    return Rectangle;
  });
  math.Rectangle = Rectangle();
  const _width = Symbol('_width');
  const _height = Symbol('_height');
  math.MutableRectangle$ = dart.generic(T => {
    let MutableRectangleOfT = () => (MutableRectangleOfT = dart.constFn(math.MutableRectangle$(T)))();
    let RectangleOfT = () => (RectangleOfT = dart.constFn(math.Rectangle$(T)))();
    class MutableRectangle extends math._RectangleBase$(T) {
      new(left, top, width, height) {
        this.left = left;
        this.top = top;
        this[_width] = dart.notNull(width) < 0 ? math._clampToZero(T)(width) : width;
        this[_height] = dart.notNull(height) < 0 ? math._clampToZero(T)(height) : height;
        super.new();
      }
      static fromPoints(a, b) {
        let left = math.min(T)(a.x, b.x);
        let width = dart.notNull(math.max(T)(a.x, b.x)) - dart.notNull(left);
        let top = math.min(T)(a.y, b.y);
        let height = dart.notNull(math.max(T)(a.y, b.y)) - dart.notNull(top);
        return new (MutableRectangleOfT())(left, top, width, height);
      }
      get width() {
        return this[_width];
      }
      set width(width) {
        T._check(width);
        if (dart.notNull(width) < 0) width = math._clampToZero(T)(width);
        this[_width] = width;
      }
      get height() {
        return this[_height];
      }
      set height(height) {
        T._check(height);
        if (dart.notNull(height) < 0) height = math._clampToZero(T)(height);
        this[_height] = height;
      }
    }
    MutableRectangle[dart.implements] = () => [RectangleOfT()];
    dart.setSignature(MutableRectangle, {
      constructors: () => ({
        new: dart.definiteFunctionType(math.MutableRectangle$(T), [T, T, T, T]),
        fromPoints: dart.definiteFunctionType(math.MutableRectangle$(T), [math.Point$(T), math.Point$(T)])
      })
    });
    dart.defineExtensionMembers(MutableRectangle, ['left', 'top', 'width', 'height']);
    return MutableRectangle;
  });
  math.MutableRectangle = MutableRectangle();
  math._clampToZero = function(T) {
    return value => {
      dart.assert(dart.notNull(value) < 0);
      return -dart.notNull(value) * 0;
    };
  };
  dart.fn(math._clampToZero, TToT());
  mirrors.MirrorSystem = class MirrorSystem extends core.Object {
    findLibrary(libraryName) {
      return this.libraries[dartx.values][dartx.singleWhere](dart.fn(library => dart.equals(library.simpleName, libraryName), LibraryMirrorTobool()));
    }
    static getName(symbol) {
      return _js_mirrors.getName(symbol);
    }
    static getSymbol(name, library) {
      if (library === void 0) library = null;
      return _js_mirrors.getSymbol(name, library);
    }
  };
  dart.setSignature(mirrors.MirrorSystem, {
    methods: () => ({findLibrary: dart.definiteFunctionType(mirrors.LibraryMirror, [core.Symbol])}),
    statics: () => ({
      getName: dart.definiteFunctionType(core.String, [core.Symbol]),
      getSymbol: dart.definiteFunctionType(core.Symbol, [core.String], [mirrors.LibraryMirror])
    }),
    names: ['getName', 'getSymbol']
  });
  mirrors.currentMirrorSystem = function() {
    return mirrors.MirrorSystem._check(_js_mirrors.currentJsMirrorSystem);
  };
  dart.fn(mirrors.currentMirrorSystem, VoidToMirrorSystem());
  mirrors.reflect = function(reflectee) {
    return _js_mirrors.reflect(reflectee);
  };
  dart.lazyFn(mirrors.reflect, () => ObjectToInstanceMirror());
  mirrors.reflectClass = function(key) {
    if (!core.Type.is(key) || dart.equals(key, dart.wrapType(dart.dynamic))) {
      dart.throw(new core.ArgumentError(dart.str`${key} does not denote a class`));
    }
    let tm = mirrors.reflectType(key);
    if (!mirrors.ClassMirror.is(tm)) {
      dart.throw(new core.ArgumentError(dart.str`${key} does not denote a class`));
    }
    return mirrors.ClassMirror._check(mirrors.ClassMirror.as(tm).originalDeclaration);
  };
  dart.lazyFn(mirrors.reflectClass, () => TypeToClassMirror());
  mirrors.reflectType = function(key) {
    if (dart.equals(key, dart.wrapType(dart.dynamic))) {
      return mirrors.currentMirrorSystem().dynamicType;
    }
    return _js_mirrors.reflectType(key);
  };
  dart.lazyFn(mirrors.reflectType, () => TypeToTypeMirror());
  mirrors.Mirror = class Mirror extends core.Object {};
  mirrors.IsolateMirror = class IsolateMirror extends core.Object {};
  mirrors.IsolateMirror[dart.implements] = () => [mirrors.Mirror];
  mirrors.DeclarationMirror = class DeclarationMirror extends core.Object {};
  mirrors.DeclarationMirror[dart.implements] = () => [mirrors.Mirror];
  mirrors.ObjectMirror = class ObjectMirror extends core.Object {};
  mirrors.ObjectMirror[dart.implements] = () => [mirrors.Mirror];
  mirrors.InstanceMirror = class InstanceMirror extends core.Object {};
  mirrors.InstanceMirror[dart.implements] = () => [mirrors.ObjectMirror];
  mirrors.ClosureMirror = class ClosureMirror extends core.Object {};
  mirrors.ClosureMirror[dart.implements] = () => [mirrors.InstanceMirror];
  mirrors.LibraryMirror = class LibraryMirror extends core.Object {};
  mirrors.LibraryMirror[dart.implements] = () => [mirrors.DeclarationMirror, mirrors.ObjectMirror];
  mirrors.LibraryDependencyMirror = class LibraryDependencyMirror extends core.Object {};
  mirrors.LibraryDependencyMirror[dart.implements] = () => [mirrors.Mirror];
  mirrors.CombinatorMirror = class CombinatorMirror extends core.Object {};
  mirrors.CombinatorMirror[dart.implements] = () => [mirrors.Mirror];
  mirrors.TypeMirror = class TypeMirror extends core.Object {};
  mirrors.TypeMirror[dart.implements] = () => [mirrors.DeclarationMirror];
  mirrors.ClassMirror = class ClassMirror extends core.Object {};
  mirrors.ClassMirror[dart.implements] = () => [mirrors.TypeMirror, mirrors.ObjectMirror];
  mirrors.FunctionTypeMirror = class FunctionTypeMirror extends core.Object {};
  mirrors.FunctionTypeMirror[dart.implements] = () => [mirrors.ClassMirror];
  mirrors.TypeVariableMirror = class TypeVariableMirror extends mirrors.TypeMirror {};
  mirrors.TypedefMirror = class TypedefMirror extends core.Object {};
  mirrors.TypedefMirror[dart.implements] = () => [mirrors.TypeMirror];
  mirrors.MethodMirror = class MethodMirror extends core.Object {};
  mirrors.MethodMirror[dart.implements] = () => [mirrors.DeclarationMirror];
  mirrors.VariableMirror = class VariableMirror extends core.Object {};
  mirrors.VariableMirror[dart.implements] = () => [mirrors.DeclarationMirror];
  mirrors.ParameterMirror = class ParameterMirror extends core.Object {};
  mirrors.ParameterMirror[dart.implements] = () => [mirrors.VariableMirror];
  mirrors.SourceLocation = class SourceLocation extends core.Object {};
  mirrors.Comment = class Comment extends core.Object {
    new(text, trimmedText, isDocComment) {
      this.text = text;
      this.trimmedText = trimmedText;
      this.isDocComment = isDocComment;
    }
  };
  dart.setSignature(mirrors.Comment, {
    constructors: () => ({new: dart.definiteFunctionType(mirrors.Comment, [core.String, core.String, core.bool])})
  });
  mirrors.MirrorsUsed = class MirrorsUsed extends core.Object {
    new(opts) {
      let symbols = opts && 'symbols' in opts ? opts.symbols : null;
      let targets = opts && 'targets' in opts ? opts.targets : null;
      let metaTargets = opts && 'metaTargets' in opts ? opts.metaTargets : null;
      let override = opts && 'override' in opts ? opts.override : null;
      this.symbols = symbols;
      this.targets = targets;
      this.metaTargets = metaTargets;
      this.override = override;
    }
  };
  dart.setSignature(mirrors.MirrorsUsed, {
    constructors: () => ({new: dart.definiteFunctionType(mirrors.MirrorsUsed, [], {symbols: dart.dynamic, targets: dart.dynamic, metaTargets: dart.dynamic, override: dart.dynamic})})
  });
  typed_data.ByteBuffer = class ByteBuffer extends core.Object {};
  typed_data.TypedData = class TypedData extends core.Object {};
  const _littleEndian = Symbol('_littleEndian');
  typed_data.Endianness = class Endianness extends core.Object {
    _(littleEndian) {
      this[_littleEndian] = littleEndian;
    }
  };
  dart.defineNamedConstructor(typed_data.Endianness, '_');
  dart.setSignature(typed_data.Endianness, {
    constructors: () => ({_: dart.definiteFunctionType(typed_data.Endianness, [core.bool])})
  });
  dart.defineLazy(typed_data.Endianness, {
    get BIG_ENDIAN() {
      return dart.const(new typed_data.Endianness._(false));
    },
    get LITTLE_ENDIAN() {
      return dart.const(new typed_data.Endianness._(true));
    },
    get HOST_ENDIAN() {
      return typed_data.ByteData.view(typed_data.Uint16List.fromList(JSArrayOfint().of([1]))[dartx.buffer])[dartx.getInt8](0) == 1 ? typed_data.Endianness.LITTLE_ENDIAN : typed_data.Endianness.BIG_ENDIAN;
    }
  });
  typed_data.ByteData = class ByteData extends core.Object {
    static new(length) {
      return _native_typed_data.NativeByteData.new(length);
    }
    static view(buffer, offsetInBytes, length) {
      if (offsetInBytes === void 0) offsetInBytes = 0;
      if (length === void 0) length = null;
      return buffer[dartx.asByteData](offsetInBytes, length);
    }
  };
  typed_data.ByteData[dart.implements] = () => [typed_data.TypedData];
  dart.setSignature(typed_data.ByteData, {
    constructors: () => ({
      new: dart.definiteFunctionType(typed_data.ByteData, [core.int]),
      view: dart.definiteFunctionType(typed_data.ByteData, [typed_data.ByteBuffer], [core.int, core.int])
    })
  });
  typed_data.Int8List = class Int8List extends core.Object {
    static new(length) {
      return _native_typed_data.NativeInt8List.new(length);
    }
    static fromList(elements) {
      return _native_typed_data.NativeInt8List.fromList(elements);
    }
    static view(buffer, offsetInBytes, length) {
      if (offsetInBytes === void 0) offsetInBytes = 0;
      if (length === void 0) length = null;
      return buffer[dartx.asInt8List](offsetInBytes, length);
    }
  };
  typed_data.Int8List[dart.implements] = () => [ListOfint(), typed_data.TypedData];
  dart.setSignature(typed_data.Int8List, {
    constructors: () => ({
      new: dart.definiteFunctionType(typed_data.Int8List, [core.int]),
      fromList: dart.definiteFunctionType(typed_data.Int8List, [core.List$(core.int)]),
      view: dart.definiteFunctionType(typed_data.Int8List, [typed_data.ByteBuffer], [core.int, core.int])
    })
  });
  typed_data.Int8List.BYTES_PER_ELEMENT = 1;
  typed_data.Uint8List = class Uint8List extends core.Object {
    static new(length) {
      return _native_typed_data.NativeUint8List.new(length);
    }
    static fromList(elements) {
      return _native_typed_data.NativeUint8List.fromList(elements);
    }
    static view(buffer, offsetInBytes, length) {
      if (offsetInBytes === void 0) offsetInBytes = 0;
      if (length === void 0) length = null;
      return buffer[dartx.asUint8List](offsetInBytes, length);
    }
  };
  typed_data.Uint8List[dart.implements] = () => [ListOfint(), typed_data.TypedData];
  dart.setSignature(typed_data.Uint8List, {
    constructors: () => ({
      new: dart.definiteFunctionType(typed_data.Uint8List, [core.int]),
      fromList: dart.definiteFunctionType(typed_data.Uint8List, [core.List$(core.int)]),
      view: dart.definiteFunctionType(typed_data.Uint8List, [typed_data.ByteBuffer], [core.int, core.int])
    })
  });
  typed_data.Uint8List.BYTES_PER_ELEMENT = 1;
  typed_data.Uint8ClampedList = class Uint8ClampedList extends core.Object {
    static new(length) {
      return _native_typed_data.NativeUint8ClampedList.new(length);
    }
    static fromList(elements) {
      return _native_typed_data.NativeUint8ClampedList.fromList(elements);
    }
    static view(buffer, offsetInBytes, length) {
      if (offsetInBytes === void 0) offsetInBytes = 0;
      if (length === void 0) length = null;
      return buffer[dartx.asUint8ClampedList](offsetInBytes, length);
    }
  };
  typed_data.Uint8ClampedList[dart.implements] = () => [ListOfint(), typed_data.TypedData];
  dart.setSignature(typed_data.Uint8ClampedList, {
    constructors: () => ({
      new: dart.definiteFunctionType(typed_data.Uint8ClampedList, [core.int]),
      fromList: dart.definiteFunctionType(typed_data.Uint8ClampedList, [core.List$(core.int)]),
      view: dart.definiteFunctionType(typed_data.Uint8ClampedList, [typed_data.ByteBuffer], [core.int, core.int])
    })
  });
  typed_data.Uint8ClampedList.BYTES_PER_ELEMENT = 1;
  typed_data.Int16List = class Int16List extends core.Object {
    static new(length) {
      return _native_typed_data.NativeInt16List.new(length);
    }
    static fromList(elements) {
      return _native_typed_data.NativeInt16List.fromList(elements);
    }
    static view(buffer, offsetInBytes, length) {
      if (offsetInBytes === void 0) offsetInBytes = 0;
      if (length === void 0) length = null;
      return buffer[dartx.asInt16List](offsetInBytes, length);
    }
  };
  typed_data.Int16List[dart.implements] = () => [ListOfint(), typed_data.TypedData];
  dart.setSignature(typed_data.Int16List, {
    constructors: () => ({
      new: dart.definiteFunctionType(typed_data.Int16List, [core.int]),
      fromList: dart.definiteFunctionType(typed_data.Int16List, [core.List$(core.int)]),
      view: dart.definiteFunctionType(typed_data.Int16List, [typed_data.ByteBuffer], [core.int, core.int])
    })
  });
  typed_data.Int16List.BYTES_PER_ELEMENT = 2;
  typed_data.Uint16List = class Uint16List extends core.Object {
    static new(length) {
      return _native_typed_data.NativeUint16List.new(length);
    }
    static fromList(elements) {
      return _native_typed_data.NativeUint16List.fromList(elements);
    }
    static view(buffer, offsetInBytes, length) {
      if (offsetInBytes === void 0) offsetInBytes = 0;
      if (length === void 0) length = null;
      return buffer[dartx.asUint16List](offsetInBytes, length);
    }
  };
  typed_data.Uint16List[dart.implements] = () => [ListOfint(), typed_data.TypedData];
  dart.setSignature(typed_data.Uint16List, {
    constructors: () => ({
      new: dart.definiteFunctionType(typed_data.Uint16List, [core.int]),
      fromList: dart.definiteFunctionType(typed_data.Uint16List, [core.List$(core.int)]),
      view: dart.definiteFunctionType(typed_data.Uint16List, [typed_data.ByteBuffer], [core.int, core.int])
    })
  });
  typed_data.Uint16List.BYTES_PER_ELEMENT = 2;
  typed_data.Int32List = class Int32List extends core.Object {
    static new(length) {
      return _native_typed_data.NativeInt32List.new(length);
    }
    static fromList(elements) {
      return _native_typed_data.NativeInt32List.fromList(elements);
    }
    static view(buffer, offsetInBytes, length) {
      if (offsetInBytes === void 0) offsetInBytes = 0;
      if (length === void 0) length = null;
      return buffer[dartx.asInt32List](offsetInBytes, length);
    }
  };
  typed_data.Int32List[dart.implements] = () => [ListOfint(), typed_data.TypedData];
  dart.setSignature(typed_data.Int32List, {
    constructors: () => ({
      new: dart.definiteFunctionType(typed_data.Int32List, [core.int]),
      fromList: dart.definiteFunctionType(typed_data.Int32List, [core.List$(core.int)]),
      view: dart.definiteFunctionType(typed_data.Int32List, [typed_data.ByteBuffer], [core.int, core.int])
    })
  });
  typed_data.Int32List.BYTES_PER_ELEMENT = 4;
  typed_data.Uint32List = class Uint32List extends core.Object {
    static new(length) {
      return _native_typed_data.NativeUint32List.new(length);
    }
    static fromList(elements) {
      return _native_typed_data.NativeUint32List.fromList(elements);
    }
    static view(buffer, offsetInBytes, length) {
      if (offsetInBytes === void 0) offsetInBytes = 0;
      if (length === void 0) length = null;
      return buffer[dartx.asUint32List](offsetInBytes, length);
    }
  };
  typed_data.Uint32List[dart.implements] = () => [ListOfint(), typed_data.TypedData];
  dart.setSignature(typed_data.Uint32List, {
    constructors: () => ({
      new: dart.definiteFunctionType(typed_data.Uint32List, [core.int]),
      fromList: dart.definiteFunctionType(typed_data.Uint32List, [core.List$(core.int)]),
      view: dart.definiteFunctionType(typed_data.Uint32List, [typed_data.ByteBuffer], [core.int, core.int])
    })
  });
  typed_data.Uint32List.BYTES_PER_ELEMENT = 4;
  typed_data.Int64List = class Int64List extends core.Object {
    static new(length) {
      dart.throw(new core.UnsupportedError("Int64List not supported by dart2js."));
    }
    static fromList(elements) {
      dart.throw(new core.UnsupportedError("Int64List not supported by dart2js."));
    }
    static view(buffer, offsetInBytes, length) {
      if (offsetInBytes === void 0) offsetInBytes = 0;
      if (length === void 0) length = null;
      return buffer[dartx.asInt64List](offsetInBytes, length);
    }
  };
  typed_data.Int64List[dart.implements] = () => [ListOfint(), typed_data.TypedData];
  dart.setSignature(typed_data.Int64List, {
    constructors: () => ({
      new: dart.definiteFunctionType(typed_data.Int64List, [core.int]),
      fromList: dart.definiteFunctionType(typed_data.Int64List, [core.List$(core.int)]),
      view: dart.definiteFunctionType(typed_data.Int64List, [typed_data.ByteBuffer], [core.int, core.int])
    })
  });
  typed_data.Int64List.BYTES_PER_ELEMENT = 8;
  typed_data.Uint64List = class Uint64List extends core.Object {
    static new(length) {
      dart.throw(new core.UnsupportedError("Uint64List not supported by dart2js."));
    }
    static fromList(elements) {
      dart.throw(new core.UnsupportedError("Uint64List not supported by dart2js."));
    }
    static view(buffer, offsetInBytes, length) {
      if (offsetInBytes === void 0) offsetInBytes = 0;
      if (length === void 0) length = null;
      return buffer[dartx.asUint64List](offsetInBytes, length);
    }
  };
  typed_data.Uint64List[dart.implements] = () => [ListOfint(), typed_data.TypedData];
  dart.setSignature(typed_data.Uint64List, {
    constructors: () => ({
      new: dart.definiteFunctionType(typed_data.Uint64List, [core.int]),
      fromList: dart.definiteFunctionType(typed_data.Uint64List, [core.List$(core.int)]),
      view: dart.definiteFunctionType(typed_data.Uint64List, [typed_data.ByteBuffer], [core.int, core.int])
    })
  });
  typed_data.Uint64List.BYTES_PER_ELEMENT = 8;
  typed_data.Float32List = class Float32List extends core.Object {
    static new(length) {
      return _native_typed_data.NativeFloat32List.new(length);
    }
    static fromList(elements) {
      return _native_typed_data.NativeFloat32List.fromList(elements);
    }
    static view(buffer, offsetInBytes, length) {
      if (offsetInBytes === void 0) offsetInBytes = 0;
      if (length === void 0) length = null;
      return buffer[dartx.asFloat32List](offsetInBytes, length);
    }
  };
  typed_data.Float32List[dart.implements] = () => [ListOfdouble(), typed_data.TypedData];
  dart.setSignature(typed_data.Float32List, {
    constructors: () => ({
      new: dart.definiteFunctionType(typed_data.Float32List, [core.int]),
      fromList: dart.definiteFunctionType(typed_data.Float32List, [core.List$(core.double)]),
      view: dart.definiteFunctionType(typed_data.Float32List, [typed_data.ByteBuffer], [core.int, core.int])
    })
  });
  typed_data.Float32List.BYTES_PER_ELEMENT = 4;
  typed_data.Float64List = class Float64List extends core.Object {
    static new(length) {
      return _native_typed_data.NativeFloat64List.new(length);
    }
    static fromList(elements) {
      return _native_typed_data.NativeFloat64List.fromList(elements);
    }
    static view(buffer, offsetInBytes, length) {
      if (offsetInBytes === void 0) offsetInBytes = 0;
      if (length === void 0) length = null;
      return buffer[dartx.asFloat64List](offsetInBytes, length);
    }
  };
  typed_data.Float64List[dart.implements] = () => [ListOfdouble(), typed_data.TypedData];
  dart.setSignature(typed_data.Float64List, {
    constructors: () => ({
      new: dart.definiteFunctionType(typed_data.Float64List, [core.int]),
      fromList: dart.definiteFunctionType(typed_data.Float64List, [core.List$(core.double)]),
      view: dart.definiteFunctionType(typed_data.Float64List, [typed_data.ByteBuffer], [core.int, core.int])
    })
  });
  typed_data.Float64List.BYTES_PER_ELEMENT = 8;
  typed_data.Float32x4List = class Float32x4List extends core.Object {
    static new(length) {
      return new _native_typed_data.NativeFloat32x4List(length);
    }
    static fromList(elements) {
      return _native_typed_data.NativeFloat32x4List.fromList(elements);
    }
    static view(buffer, offsetInBytes, length) {
      if (offsetInBytes === void 0) offsetInBytes = 0;
      if (length === void 0) length = null;
      return buffer[dartx.asFloat32x4List](offsetInBytes, length);
    }
  };
  typed_data.Float32x4List[dart.implements] = () => [ListOfFloat32x4(), typed_data.TypedData];
  dart.setSignature(typed_data.Float32x4List, {
    constructors: () => ({
      new: dart.definiteFunctionType(typed_data.Float32x4List, [core.int]),
      fromList: dart.definiteFunctionType(typed_data.Float32x4List, [core.List$(typed_data.Float32x4)]),
      view: dart.definiteFunctionType(typed_data.Float32x4List, [typed_data.ByteBuffer], [core.int, core.int])
    })
  });
  typed_data.Float32x4List.BYTES_PER_ELEMENT = 16;
  typed_data.Int32x4List = class Int32x4List extends core.Object {
    static new(length) {
      return new _native_typed_data.NativeInt32x4List(length);
    }
    static fromList(elements) {
      return _native_typed_data.NativeInt32x4List.fromList(elements);
    }
    static view(buffer, offsetInBytes, length) {
      if (offsetInBytes === void 0) offsetInBytes = 0;
      if (length === void 0) length = null;
      return buffer[dartx.asInt32x4List](offsetInBytes, length);
    }
  };
  typed_data.Int32x4List[dart.implements] = () => [ListOfInt32x4(), typed_data.TypedData];
  dart.setSignature(typed_data.Int32x4List, {
    constructors: () => ({
      new: dart.definiteFunctionType(typed_data.Int32x4List, [core.int]),
      fromList: dart.definiteFunctionType(typed_data.Int32x4List, [core.List$(typed_data.Int32x4)]),
      view: dart.definiteFunctionType(typed_data.Int32x4List, [typed_data.ByteBuffer], [core.int, core.int])
    })
  });
  typed_data.Int32x4List.BYTES_PER_ELEMENT = 16;
  typed_data.Float64x2List = class Float64x2List extends core.Object {
    static new(length) {
      return new _native_typed_data.NativeFloat64x2List(length);
    }
    static fromList(elements) {
      return _native_typed_data.NativeFloat64x2List.fromList(elements);
    }
    static view(buffer, offsetInBytes, length) {
      if (offsetInBytes === void 0) offsetInBytes = 0;
      if (length === void 0) length = null;
      return buffer[dartx.asFloat64x2List](offsetInBytes, length);
    }
  };
  typed_data.Float64x2List[dart.implements] = () => [ListOfFloat64x2(), typed_data.TypedData];
  dart.setSignature(typed_data.Float64x2List, {
    constructors: () => ({
      new: dart.definiteFunctionType(typed_data.Float64x2List, [core.int]),
      fromList: dart.definiteFunctionType(typed_data.Float64x2List, [core.List$(typed_data.Float64x2)]),
      view: dart.definiteFunctionType(typed_data.Float64x2List, [typed_data.ByteBuffer], [core.int, core.int])
    })
  });
  typed_data.Float64x2List.BYTES_PER_ELEMENT = 16;
  indexed_db._KeyRangeFactoryProvider = class _KeyRangeFactoryProvider extends core.Object {
    static createKeyRange_only(value) {
      return indexed_db._KeyRangeFactoryProvider._only(indexed_db._KeyRangeFactoryProvider._class(), indexed_db._KeyRangeFactoryProvider._translateKey(value));
    }
    static createKeyRange_lowerBound(bound, open) {
      if (open === void 0) open = false;
      return indexed_db._KeyRangeFactoryProvider._lowerBound(indexed_db._KeyRangeFactoryProvider._class(), indexed_db._KeyRangeFactoryProvider._translateKey(bound), open);
    }
    static createKeyRange_upperBound(bound, open) {
      if (open === void 0) open = false;
      return indexed_db._KeyRangeFactoryProvider._upperBound(indexed_db._KeyRangeFactoryProvider._class(), indexed_db._KeyRangeFactoryProvider._translateKey(bound), open);
    }
    static createKeyRange_bound(lower, upper, lowerOpen, upperOpen) {
      if (lowerOpen === void 0) lowerOpen = false;
      if (upperOpen === void 0) upperOpen = false;
      return indexed_db._KeyRangeFactoryProvider._bound(indexed_db._KeyRangeFactoryProvider._class(), indexed_db._KeyRangeFactoryProvider._translateKey(lower), indexed_db._KeyRangeFactoryProvider._translateKey(upper), lowerOpen, upperOpen);
    }
    static _class() {
      if (indexed_db._KeyRangeFactoryProvider._cachedClass != null) return indexed_db._KeyRangeFactoryProvider._cachedClass;
      return indexed_db._KeyRangeFactoryProvider._cachedClass = indexed_db._KeyRangeFactoryProvider._uncachedClass();
    }
    static _uncachedClass() {
      return window.webkitIDBKeyRange || window.mozIDBKeyRange || window.msIDBKeyRange || window.IDBKeyRange;
    }
    static _translateKey(idbkey) {
      return idbkey;
    }
    static _only(cls, value) {
      return cls.only(value);
    }
    static _lowerBound(cls, bound, open) {
      return cls.lowerBound(bound, open);
    }
    static _upperBound(cls, bound, open) {
      return cls.upperBound(bound, open);
    }
    static _bound(cls, lower, upper, lowerOpen, upperOpen) {
      return cls.bound(lower, upper, lowerOpen, upperOpen);
    }
  };
  dart.setSignature(indexed_db._KeyRangeFactoryProvider, {
    statics: () => ({
      createKeyRange_only: dart.definiteFunctionType(indexed_db.KeyRange, [dart.dynamic]),
      createKeyRange_lowerBound: dart.definiteFunctionType(indexed_db.KeyRange, [dart.dynamic], [core.bool]),
      createKeyRange_upperBound: dart.definiteFunctionType(indexed_db.KeyRange, [dart.dynamic], [core.bool]),
      createKeyRange_bound: dart.definiteFunctionType(indexed_db.KeyRange, [dart.dynamic, dart.dynamic], [core.bool, core.bool]),
      _class: dart.definiteFunctionType(dart.dynamic, []),
      _uncachedClass: dart.definiteFunctionType(dart.dynamic, []),
      _translateKey: dart.definiteFunctionType(dart.dynamic, [dart.dynamic]),
      _only: dart.definiteFunctionType(indexed_db.KeyRange, [dart.dynamic, dart.dynamic]),
      _lowerBound: dart.definiteFunctionType(indexed_db.KeyRange, [dart.dynamic, dart.dynamic, dart.dynamic]),
      _upperBound: dart.definiteFunctionType(indexed_db.KeyRange, [dart.dynamic, dart.dynamic, dart.dynamic]),
      _bound: dart.definiteFunctionType(indexed_db.KeyRange, [dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic])
    }),
    names: ['createKeyRange_only', 'createKeyRange_lowerBound', 'createKeyRange_upperBound', 'createKeyRange_bound', '_class', '_uncachedClass', '_translateKey', '_only', '_lowerBound', '_upperBound', '_bound']
  });
  indexed_db._KeyRangeFactoryProvider._cachedClass = null;
  indexed_db._convertNativeToDart_IDBKey = function(nativeKey) {
    function containsDate(object) {
      if (dart.test(html_common.isJavaScriptDate(object))) return true;
      if (core.List.is(object)) {
        for (let i = 0; i < dart.notNull(object[dartx.length]); i++) {
          if (dart.test(containsDate(object[dartx.get](i)))) return true;
        }
      }
      return false;
    }
    dart.fn(containsDate, dynamicTodynamic$());
    if (dart.test(containsDate(nativeKey))) {
      dart.throw(new core.UnimplementedError('Key containing DateTime'));
    }
    return nativeKey;
  };
  dart.fn(indexed_db._convertNativeToDart_IDBKey, dynamicTodynamic$());
  indexed_db._convertDartToNative_IDBKey = function(dartKey) {
    return dartKey;
  };
  dart.fn(indexed_db._convertDartToNative_IDBKey, dynamicTodynamic$());
  indexed_db._convertNativeToDart_IDBAny = function(object) {
    return html_common.convertNativeToDart_AcceptStructuredClone(object, {mustCopy: false});
  };
  dart.fn(indexed_db._convertNativeToDart_IDBAny, dynamicTodynamic$());
  indexed_db._idbKey = 'JSExtendableArray|=Object|num|String';
  indexed_db._annotation_Creates_IDBKey = dart.const(new _js_helper.Creates(indexed_db._idbKey));
  indexed_db._annotation_Returns_IDBKey = dart.const(new _js_helper.Returns(indexed_db._idbKey));
  const _delete = Symbol('_delete');
  const _update = Symbol('_update');
  const _update_1 = Symbol('_update_1');
  dart.defineExtensionNames([
    'delete',
    'update',
    'next',
    'advance',
    'continuePrimaryKey',
    'direction',
    'key',
    'primaryKey',
    'source'
  ]);
  indexed_db.Cursor = class Cursor extends _interceptors.Interceptor {
    [dartx.delete]() {
      try {
        return indexed_db._completeRequest(dart.dynamic)(this[_delete]());
      } catch (e) {
        let stacktrace = dart.stackTrace(e);
        return async.Future.error(e, stacktrace);
      }

    }
    [dartx.update](value) {
      try {
        return indexed_db._completeRequest(dart.dynamic)(this[_update](value));
      } catch (e) {
        let stacktrace = dart.stackTrace(e);
        return async.Future.error(e, stacktrace);
      }

    }
    [dartx.next](key) {
      if (key === void 0) key = null;
      if (key == null) {
        this.continue();
      } else {
        this.continue(key);
      }
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.direction]() {
      return this.direction;
    }
    get [dartx.key]() {
      return this.key;
    }
    get [dartx.primaryKey]() {
      return this.primaryKey;
    }
    get [dartx.source]() {
      return this.source;
    }
    [dartx.advance](count) {
      return this.advance(count);
    }
    [dartx.continuePrimaryKey](key, primaryKey) {
      return this.continuePrimaryKey(key, primaryKey);
    }
    [_delete]() {
      return this.delete();
    }
    [_update](value) {
      let value_1 = html_common.convertDartToNative_SerializedScriptValue(value);
      return this[_update_1](value_1);
    }
    [_update_1](value) {
      return this.update(value);
    }
  };
  dart.setSignature(indexed_db.Cursor, {
    constructors: () => ({_: dart.definiteFunctionType(indexed_db.Cursor, [])}),
    methods: () => ({
      [dartx.delete]: dart.definiteFunctionType(async.Future, []),
      [dartx.update]: dart.definiteFunctionType(async.Future, [dart.dynamic]),
      [dartx.next]: dart.definiteFunctionType(dart.void, [], [core.Object]),
      [dartx.advance]: dart.definiteFunctionType(dart.void, [core.int]),
      [dartx.continuePrimaryKey]: dart.definiteFunctionType(dart.void, [core.Object, core.Object]),
      [_delete]: dart.definiteFunctionType(indexed_db.Request, []),
      [_update]: dart.definiteFunctionType(indexed_db.Request, [dart.dynamic]),
      [_update_1]: dart.definiteFunctionType(indexed_db.Request, [dart.dynamic])
    })
  });
  dart.registerExtension(dart.global.IDBCursor, indexed_db.Cursor);
  const _get_value = Symbol('_get_value');
  dart.defineExtensionNames([
    'value'
  ]);
  indexed_db.CursorWithValue = class CursorWithValue extends indexed_db.Cursor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.value]() {
      return indexed_db._convertNativeToDart_IDBAny(this[_get_value]);
    }
    get [_get_value]() {
      return this.value;
    }
  };
  dart.setSignature(indexed_db.CursorWithValue, {
    constructors: () => ({_: dart.definiteFunctionType(indexed_db.CursorWithValue, [])})
  });
  dart.registerExtension(dart.global.IDBCursorWithValue, indexed_db.CursorWithValue);
  const _createObjectStore = Symbol('_createObjectStore');
  const _transaction = Symbol('_transaction');
  const _createObjectStore_1 = Symbol('_createObjectStore_1');
  const _createObjectStore_2 = Symbol('_createObjectStore_2');
  const _addEventListener = Symbol('_addEventListener');
  const _removeEventListener = Symbol('_removeEventListener');
  dart.defineExtensionNames([
    'on',
    'addEventListener',
    'removeEventListener',
    'dispatchEvent'
  ]);
  html$.EventTarget = class EventTarget extends _interceptors.Interceptor {
    _created() {
      super.new();
    }
    get [dartx.on]() {
      return new html$.Events(this);
    }
    [dartx.addEventListener](type, listener, useCapture) {
      if (useCapture === void 0) useCapture = null;
      if (listener != null) {
        this[_addEventListener](type, listener, useCapture);
      }
    }
    [dartx.removeEventListener](type, listener, useCapture) {
      if (useCapture === void 0) useCapture = null;
      if (listener != null) {
        this[_removeEventListener](type, listener, useCapture);
      }
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [_addEventListener](type, listener, capture) {
      return this.addEventListener(type, listener, capture);
    }
    [dartx.dispatchEvent](event) {
      return this.dispatchEvent(event);
    }
    [_removeEventListener](type, listener, capture) {
      return this.removeEventListener(type, listener, capture);
    }
  };
  dart.defineNamedConstructor(html$.EventTarget, '_created');
  dart.setSignature(html$.EventTarget, {
    constructors: () => ({
      _created: dart.definiteFunctionType(html$.EventTarget, []),
      _: dart.definiteFunctionType(html$.EventTarget, [])
    }),
    methods: () => ({
      [dartx.addEventListener]: dart.definiteFunctionType(dart.void, [core.String, html$.EventListener], [core.bool]),
      [dartx.removeEventListener]: dart.definiteFunctionType(dart.void, [core.String, html$.EventListener], [core.bool]),
      [_addEventListener]: dart.definiteFunctionType(dart.void, [core.String, html$.EventListener], [core.bool]),
      [dartx.dispatchEvent]: dart.definiteFunctionType(core.bool, [html$.Event]),
      [_removeEventListener]: dart.definiteFunctionType(dart.void, [core.String, html$.EventListener], [core.bool])
    })
  });
  dart.registerExtension(dart.global.EventTarget, html$.EventTarget);
  dart.defineExtensionNames([
    'createObjectStore',
    'transaction',
    'transactionStore',
    'transactionList',
    'transactionStores',
    'close',
    'deleteObjectStore',
    'onAbort',
    'onClose',
    'onError',
    'onVersionChange',
    'name',
    'objectStoreNames',
    'version'
  ]);
  indexed_db.Database = class Database extends html$.EventTarget {
    [dartx.createObjectStore](name, opts) {
      let keyPath = opts && 'keyPath' in opts ? opts.keyPath : null;
      let autoIncrement = opts && 'autoIncrement' in opts ? opts.autoIncrement : null;
      let options = dart.map();
      if (keyPath != null) {
        options[dartx.set]('keyPath', keyPath);
      }
      if (autoIncrement != null) {
        options[dartx.set]('autoIncrement', autoIncrement);
      }
      return this[_createObjectStore](name, options);
    }
    [dartx.transaction](storeName_OR_storeNames, mode) {
      if (mode != 'readonly' && mode != 'readwrite') {
        dart.throw(new core.ArgumentError(mode));
      }
      return this[_transaction](storeName_OR_storeNames, mode);
    }
    [dartx.transactionStore](storeName, mode) {
      if (mode != 'readonly' && mode != 'readwrite') {
        dart.throw(new core.ArgumentError(mode));
      }
      return this[_transaction](storeName, mode);
    }
    [dartx.transactionList](storeNames, mode) {
      if (mode != 'readonly' && mode != 'readwrite') {
        dart.throw(new core.ArgumentError(mode));
      }
      let storeNames_1 = html_common.convertDartToNative_StringArray(storeNames);
      return this[_transaction](storeNames_1, mode);
    }
    [dartx.transactionStores](storeNames, mode) {
      if (mode != 'readonly' && mode != 'readwrite') {
        dart.throw(new core.ArgumentError(mode));
      }
      return this[_transaction](storeNames, mode);
    }
    [_transaction](stores, mode) {
      return this.transaction(stores, mode);
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.name]() {
      return this.name;
    }
    get [dartx.objectStoreNames]() {
      return this.objectStoreNames;
    }
    get [dartx.version]() {
      return this.version;
    }
    [dartx.close]() {
      return this.close();
    }
    [_createObjectStore](name, options) {
      if (options === void 0) options = null;
      if (options != null) {
        let options_1 = html_common.convertDartToNative_Dictionary(options);
        return this[_createObjectStore_1](name, options_1);
      }
      return this[_createObjectStore_2](name);
    }
    [_createObjectStore_1](name, options) {
      return this.createObjectStore(name, options);
    }
    [_createObjectStore_2](name) {
      return this.createObjectStore(name);
    }
    [dartx.deleteObjectStore](name) {
      return this.deleteObjectStore(name);
    }
    get [dartx.onAbort]() {
      return indexed_db.Database.abortEvent.forTarget(this);
    }
    get [dartx.onClose]() {
      return indexed_db.Database.closeEvent.forTarget(this);
    }
    get [dartx.onError]() {
      return indexed_db.Database.errorEvent.forTarget(this);
    }
    get [dartx.onVersionChange]() {
      return indexed_db.Database.versionChangeEvent.forTarget(this);
    }
  };
  dart.setSignature(indexed_db.Database, {
    constructors: () => ({_: dart.definiteFunctionType(indexed_db.Database, [])}),
    methods: () => ({
      [dartx.createObjectStore]: dart.definiteFunctionType(indexed_db.ObjectStore, [core.String], {keyPath: core.String, autoIncrement: core.bool}),
      [dartx.transaction]: dart.definiteFunctionType(indexed_db.Transaction, [dart.dynamic, core.String]),
      [dartx.transactionStore]: dart.definiteFunctionType(indexed_db.Transaction, [core.String, core.String]),
      [dartx.transactionList]: dart.definiteFunctionType(indexed_db.Transaction, [core.List$(core.String), core.String]),
      [dartx.transactionStores]: dart.definiteFunctionType(indexed_db.Transaction, [html$.DomStringList, core.String]),
      [_transaction]: dart.definiteFunctionType(indexed_db.Transaction, [dart.dynamic, dart.dynamic]),
      [dartx.close]: dart.definiteFunctionType(dart.void, []),
      [_createObjectStore]: dart.definiteFunctionType(indexed_db.ObjectStore, [core.String], [core.Map]),
      [_createObjectStore_1]: dart.definiteFunctionType(indexed_db.ObjectStore, [dart.dynamic, dart.dynamic]),
      [_createObjectStore_2]: dart.definiteFunctionType(indexed_db.ObjectStore, [dart.dynamic]),
      [dartx.deleteObjectStore]: dart.definiteFunctionType(dart.void, [core.String])
    })
  });
  dart.defineLazy(indexed_db.Database, {
    get abortEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('abort'));
    },
    get closeEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('close'));
    },
    get errorEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('error'));
    },
    get versionChangeEvent() {
      return dart.const(new (EventStreamProviderOfVersionChangeEvent())('versionchange'));
    }
  });
  dart.registerExtension(dart.global.IDBDatabase, indexed_db.Database);
  const _open = Symbol('_open');
  const _deleteDatabase = Symbol('_deleteDatabase');
  const _webkitGetDatabaseNames = Symbol('_webkitGetDatabaseNames');
  dart.defineExtensionNames([
    'open',
    'deleteDatabase',
    'getDatabaseNames',
    'supportsDatabaseNames',
    'cmp'
  ]);
  indexed_db.IdbFactory = class IdbFactory extends _interceptors.Interceptor {
    static get supported() {
      return !!(window.indexedDB || window.webkitIndexedDB || window.mozIndexedDB);
    }
    [dartx.open](name, opts) {
      let version = opts && 'version' in opts ? opts.version : null;
      let onUpgradeNeeded = opts && 'onUpgradeNeeded' in opts ? opts.onUpgradeNeeded : null;
      let onBlocked = opts && 'onBlocked' in opts ? opts.onBlocked : null;
      if (version == null != (onUpgradeNeeded == null)) {
        return FutureOfDatabase().error(new core.ArgumentError('version and onUpgradeNeeded must be specified together'));
      }
      try {
        let request = null;
        if (version != null) {
          request = this[_open](name, version);
        } else {
          request = this[_open](name);
        }
        if (onUpgradeNeeded != null) {
          dart.dsend(dart.dload(request, 'onUpgradeNeeded'), 'listen', onUpgradeNeeded);
        }
        if (onBlocked != null) {
          dart.dsend(dart.dload(request, 'onBlocked'), 'listen', onBlocked);
        }
        return indexed_db._completeRequest(indexed_db.Database)(indexed_db.Request._check(request));
      } catch (e) {
        let stacktrace = dart.stackTrace(e);
        return FutureOfDatabase().error(e, stacktrace);
      }

    }
    [dartx.deleteDatabase](name, opts) {
      let onBlocked = opts && 'onBlocked' in opts ? opts.onBlocked : null;
      try {
        let request = this[_deleteDatabase](name);
        if (onBlocked != null) {
          request[dartx.onBlocked].listen(onBlocked);
        }
        let completer = CompleterOfIdbFactory().sync();
        request[dartx.onSuccess].listen(dart.fn(e => {
          completer.complete(this);
        }, EventTovoid$()));
        request[dartx.onError].listen(dart.bind(completer, 'completeError'));
        return completer.future;
      } catch (e) {
        let stacktrace = dart.stackTrace(e);
        return FutureOfIdbFactory().error(e, stacktrace);
      }

    }
    [dartx.getDatabaseNames]() {
      try {
        let request = this[_webkitGetDatabaseNames]();
        return indexed_db._completeRequest(ListOfString())(request);
      } catch (e) {
        let stacktrace = dart.stackTrace(e);
        return FutureOfListOfString().error(e, stacktrace);
      }

    }
    get [dartx.supportsDatabaseNames]() {
      return dart.test(indexed_db.IdbFactory.supported) && !!(this.getDatabaseNames || this.webkitGetDatabaseNames);
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [dartx.cmp](first, second) {
      return this.cmp(first, second);
    }
    [_deleteDatabase](name) {
      return this.deleteDatabase(name);
    }
    [_open](name, version) {
      return this.open(name, version);
    }
    [_webkitGetDatabaseNames]() {
      return this.webkitGetDatabaseNames();
    }
  };
  dart.setSignature(indexed_db.IdbFactory, {
    constructors: () => ({_: dart.definiteFunctionType(indexed_db.IdbFactory, [])}),
    methods: () => ({
      [dartx.open]: dart.definiteFunctionType(async.Future$(indexed_db.Database), [core.String], {version: core.int, onUpgradeNeeded: dynamicTovoid(), onBlocked: dynamicTovoid()}),
      [dartx.deleteDatabase]: dart.definiteFunctionType(async.Future$(indexed_db.IdbFactory), [core.String], {onBlocked: EventTovoid()}),
      [dartx.getDatabaseNames]: dart.definiteFunctionType(async.Future$(core.List$(core.String)), []),
      [dartx.cmp]: dart.definiteFunctionType(core.int, [core.Object, core.Object]),
      [_deleteDatabase]: dart.definiteFunctionType(indexed_db.OpenDBRequest, [core.String]),
      [_open]: dart.definiteFunctionType(indexed_db.OpenDBRequest, [core.String], [core.int]),
      [_webkitGetDatabaseNames]: dart.definiteFunctionType(indexed_db.Request, [])
    })
  });
  dart.registerExtension(dart.global.IDBFactory, indexed_db.IdbFactory);
  indexed_db._completeRequest = function(T) {
    return request => {
      let completer = async.Completer$(T).sync();
      request[dartx.onSuccess].listen(dart.fn(e => {
        let result = indexed_db._cast(T)(request[dartx.result]);
        completer.complete(result);
      }, EventTovoid$()));
      request[dartx.onError].listen(dart.bind(completer, 'completeError'));
      return completer.future;
    };
  };
  dart.lazyFn(indexed_db._completeRequest, () => RequestToFutureOfT());
  const _count$0 = Symbol('_count');
  const _get$ = Symbol('_get');
  const _getKey$ = Symbol('_getKey');
  const _openCursor = Symbol('_openCursor');
  const _openKeyCursor = Symbol('_openKeyCursor');
  dart.defineExtensionNames([
    'count',
    'get',
    'getKey',
    'openCursor',
    'openKeyCursor',
    'getAll',
    'getAllKeys',
    'keyPath',
    'multiEntry',
    'name',
    'objectStore',
    'unique'
  ]);
  indexed_db.Index = class Index extends _interceptors.Interceptor {
    [dartx.count](key_OR_range) {
      if (key_OR_range === void 0) key_OR_range = null;
      try {
        let request = this[_count$0](key_OR_range);
        return indexed_db._completeRequest(core.int)(request);
      } catch (e) {
        let stacktrace = dart.stackTrace(e);
        return FutureOfint().error(e, stacktrace);
      }

    }
    [dartx.get](key) {
      try {
        let request = this[_get$](key);
        return indexed_db._completeRequest(dart.dynamic)(request);
      } catch (e) {
        let stacktrace = dart.stackTrace(e);
        return async.Future.error(e, stacktrace);
      }

    }
    [dartx.getKey](key) {
      try {
        let request = this[_getKey$](key);
        return indexed_db._completeRequest(dart.dynamic)(request);
      } catch (e) {
        let stacktrace = dart.stackTrace(e);
        return async.Future.error(e, stacktrace);
      }

    }
    [dartx.openCursor](opts) {
      let key = opts && 'key' in opts ? opts.key : null;
      let range = opts && 'range' in opts ? opts.range : null;
      let direction = opts && 'direction' in opts ? opts.direction : null;
      let autoAdvance = opts && 'autoAdvance' in opts ? opts.autoAdvance : null;
      let key_OR_range = null;
      if (key != null) {
        if (range != null) {
          dart.throw(new core.ArgumentError('Cannot specify both key and range.'));
        }
        key_OR_range = key;
      } else {
        key_OR_range = range;
      }
      let request = null;
      if (direction == null) {
        request = this[_openCursor](key_OR_range, "next");
      } else {
        request = this[_openCursor](key_OR_range, direction);
      }
      return indexed_db.ObjectStore._cursorStreamFromResult(indexed_db.CursorWithValue)(indexed_db.Request._check(request), autoAdvance);
    }
    [dartx.openKeyCursor](opts) {
      let key = opts && 'key' in opts ? opts.key : null;
      let range = opts && 'range' in opts ? opts.range : null;
      let direction = opts && 'direction' in opts ? opts.direction : null;
      let autoAdvance = opts && 'autoAdvance' in opts ? opts.autoAdvance : null;
      let key_OR_range = null;
      if (key != null) {
        if (range != null) {
          dart.throw(new core.ArgumentError('Cannot specify both key and range.'));
        }
        key_OR_range = key;
      } else {
        key_OR_range = range;
      }
      let request = null;
      if (direction == null) {
        request = this[_openKeyCursor](key_OR_range, "next");
      } else {
        request = this[_openKeyCursor](key_OR_range, direction);
      }
      return indexed_db.ObjectStore._cursorStreamFromResult(indexed_db.Cursor)(indexed_db.Request._check(request), autoAdvance);
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.keyPath]() {
      return this.keyPath;
    }
    get [dartx.multiEntry]() {
      return this.multiEntry;
    }
    get [dartx.name]() {
      return this.name;
    }
    get [dartx.objectStore]() {
      return this.objectStore;
    }
    get [dartx.unique]() {
      return this.unique;
    }
    [_count$0](key) {
      return this.count(key);
    }
    [_get$](key) {
      return this.get(key);
    }
    [dartx.getAll](range, maxCount) {
      return this.getAll(range, maxCount);
    }
    [dartx.getAllKeys](range, maxCount) {
      return this.getAllKeys(range, maxCount);
    }
    [_getKey$](key) {
      return this.getKey(key);
    }
    [_openCursor](range, direction) {
      return this.openCursor(range, direction);
    }
    [_openKeyCursor](range, direction) {
      return this.openKeyCursor(range, direction);
    }
  };
  dart.setSignature(indexed_db.Index, {
    constructors: () => ({_: dart.definiteFunctionType(indexed_db.Index, [])}),
    methods: () => ({
      [dartx.count]: dart.definiteFunctionType(async.Future$(core.int), [], [dart.dynamic]),
      [dartx.get]: dart.definiteFunctionType(async.Future, [dart.dynamic]),
      [dartx.getKey]: dart.definiteFunctionType(async.Future, [dart.dynamic]),
      [dartx.openCursor]: dart.definiteFunctionType(async.Stream$(indexed_db.CursorWithValue), [], {key: dart.dynamic, range: indexed_db.KeyRange, direction: core.String, autoAdvance: core.bool}),
      [dartx.openKeyCursor]: dart.definiteFunctionType(async.Stream$(indexed_db.Cursor), [], {key: dart.dynamic, range: indexed_db.KeyRange, direction: core.String, autoAdvance: core.bool}),
      [_count$0]: dart.definiteFunctionType(indexed_db.Request, [core.Object]),
      [_get$]: dart.definiteFunctionType(indexed_db.Request, [core.Object]),
      [dartx.getAll]: dart.definiteFunctionType(indexed_db.Request, [core.Object], [core.int]),
      [dartx.getAllKeys]: dart.definiteFunctionType(indexed_db.Request, [core.Object], [core.int]),
      [_getKey$]: dart.definiteFunctionType(indexed_db.Request, [core.Object]),
      [_openCursor]: dart.definiteFunctionType(indexed_db.Request, [core.Object], [core.String]),
      [_openKeyCursor]: dart.definiteFunctionType(indexed_db.Request, [core.Object], [core.String])
    })
  });
  dart.registerExtension(dart.global.IDBIndex, indexed_db.Index);
  dart.defineExtensionNames([
    'lower',
    'lowerOpen',
    'upper',
    'upperOpen'
  ]);
  indexed_db.KeyRange = class KeyRange extends _interceptors.Interceptor {
    static only(value) {
      return indexed_db._KeyRangeFactoryProvider.createKeyRange_only(value);
    }
    static lowerBound(bound, open) {
      if (open === void 0) open = false;
      return indexed_db._KeyRangeFactoryProvider.createKeyRange_lowerBound(bound, open);
    }
    static upperBound(bound, open) {
      if (open === void 0) open = false;
      return indexed_db._KeyRangeFactoryProvider.createKeyRange_upperBound(bound, open);
    }
    static bound(lower, upper, lowerOpen, upperOpen) {
      if (lowerOpen === void 0) lowerOpen = false;
      if (upperOpen === void 0) upperOpen = false;
      return indexed_db._KeyRangeFactoryProvider.createKeyRange_bound(lower, upper, lowerOpen, upperOpen);
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.lower]() {
      return this.lower;
    }
    get [dartx.lowerOpen]() {
      return this.lowerOpen;
    }
    get [dartx.upper]() {
      return this.upper;
    }
    get [dartx.upperOpen]() {
      return this.upperOpen;
    }
  };
  dart.setSignature(indexed_db.KeyRange, {
    constructors: () => ({
      only: dart.definiteFunctionType(indexed_db.KeyRange, [dart.dynamic]),
      lowerBound: dart.definiteFunctionType(indexed_db.KeyRange, [dart.dynamic], [core.bool]),
      upperBound: dart.definiteFunctionType(indexed_db.KeyRange, [dart.dynamic], [core.bool]),
      bound: dart.definiteFunctionType(indexed_db.KeyRange, [dart.dynamic, dart.dynamic], [core.bool, core.bool]),
      _: dart.definiteFunctionType(indexed_db.KeyRange, [])
    }),
    statics: () => ({
      bound_: dart.definiteFunctionType(indexed_db.KeyRange, [core.Object, core.Object], [core.bool, core.bool]),
      lowerBound_: dart.definiteFunctionType(indexed_db.KeyRange, [core.Object], [core.bool]),
      only_: dart.definiteFunctionType(indexed_db.KeyRange, [core.Object]),
      upperBound_: dart.definiteFunctionType(indexed_db.KeyRange, [core.Object], [core.bool])
    }),
    names: ['bound_', 'lowerBound_', 'only_', 'upperBound_']
  });
  dart.registerExtension(dart.global.IDBKeyRange, indexed_db.KeyRange);
  const _add$2 = Symbol('_add');
  const _clear$0 = Symbol('_clear');
  const _put = Symbol('_put');
  const _createIndex = Symbol('_createIndex');
  const _add_1 = Symbol('_add_1');
  const _add_2 = Symbol('_add_2');
  const _createIndex_1 = Symbol('_createIndex_1');
  const _createIndex_2 = Symbol('_createIndex_2');
  const _put_1 = Symbol('_put_1');
  const _put_2 = Symbol('_put_2');
  dart.defineExtensionNames([
    'add',
    'clear',
    'delete',
    'count',
    'put',
    'getObject',
    'openCursor',
    'createIndex',
    'deleteIndex',
    'getAll',
    'getAllKeys',
    'index',
    'openKeyCursor',
    'autoIncrement',
    'indexNames',
    'keyPath',
    'name',
    'transaction'
  ]);
  indexed_db.ObjectStore = class ObjectStore extends _interceptors.Interceptor {
    [dartx.add](value, key) {
      if (key === void 0) key = null;
      try {
        let request = null;
        if (key != null) {
          request = this[_add$2](value, key);
        } else {
          request = this[_add$2](value);
        }
        return indexed_db._completeRequest(dart.dynamic)(indexed_db.Request._check(request));
      } catch (e) {
        let stacktrace = dart.stackTrace(e);
        return async.Future.error(e, stacktrace);
      }

    }
    [dartx.clear]() {
      try {
        return indexed_db._completeRequest(dart.dynamic)(this[_clear$0]());
      } catch (e) {
        let stacktrace = dart.stackTrace(e);
        return async.Future.error(e, stacktrace);
      }

    }
    [dartx.delete](key_OR_keyRange) {
      try {
        return indexed_db._completeRequest(dart.dynamic)(this[_delete](key_OR_keyRange));
      } catch (e) {
        let stacktrace = dart.stackTrace(e);
        return async.Future.error(e, stacktrace);
      }

    }
    [dartx.count](key_OR_range) {
      if (key_OR_range === void 0) key_OR_range = null;
      try {
        let request = this[_count$0](key_OR_range);
        return indexed_db._completeRequest(core.int)(request);
      } catch (e) {
        let stacktrace = dart.stackTrace(e);
        return FutureOfint().error(e, stacktrace);
      }

    }
    [dartx.put](value, key) {
      if (key === void 0) key = null;
      try {
        let request = null;
        if (key != null) {
          request = this[_put](value, key);
        } else {
          request = this[_put](value);
        }
        return indexed_db._completeRequest(dart.dynamic)(indexed_db.Request._check(request));
      } catch (e) {
        let stacktrace = dart.stackTrace(e);
        return async.Future.error(e, stacktrace);
      }

    }
    [dartx.getObject](key) {
      try {
        let request = this[_get$](key);
        return indexed_db._completeRequest(dart.dynamic)(request);
      } catch (e) {
        let stacktrace = dart.stackTrace(e);
        return async.Future.error(e, stacktrace);
      }

    }
    [dartx.openCursor](opts) {
      let key = opts && 'key' in opts ? opts.key : null;
      let range = opts && 'range' in opts ? opts.range : null;
      let direction = opts && 'direction' in opts ? opts.direction : null;
      let autoAdvance = opts && 'autoAdvance' in opts ? opts.autoAdvance : null;
      let key_OR_range = null;
      if (key != null) {
        if (range != null) {
          dart.throw(new core.ArgumentError('Cannot specify both key and range.'));
        }
        key_OR_range = key;
      } else {
        key_OR_range = range;
      }
      let request = null;
      if (direction == null) {
        request = this[_openCursor](key_OR_range);
      } else {
        request = this[_openCursor](key_OR_range, direction);
      }
      return indexed_db.ObjectStore._cursorStreamFromResult(indexed_db.CursorWithValue)(indexed_db.Request._check(request), autoAdvance);
    }
    [dartx.createIndex](name, keyPath, opts) {
      let unique = opts && 'unique' in opts ? opts.unique : null;
      let multiEntry = opts && 'multiEntry' in opts ? opts.multiEntry : null;
      let options = dart.map();
      if (unique != null) {
        options[dartx.set]('unique', unique);
      }
      if (multiEntry != null) {
        options[dartx.set]('multiEntry', multiEntry);
      }
      return this[_createIndex](name, keyPath, options);
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.autoIncrement]() {
      return this.autoIncrement;
    }
    get [dartx.indexNames]() {
      return this.indexNames;
    }
    get [dartx.keyPath]() {
      return this.keyPath;
    }
    get [dartx.name]() {
      return this.name;
    }
    get [dartx.transaction]() {
      return this.transaction;
    }
    [_add$2](value, key) {
      if (key === void 0) key = null;
      if (key != null) {
        let value_1 = html_common.convertDartToNative_SerializedScriptValue(value);
        let key_2 = html_common.convertDartToNative_SerializedScriptValue(key);
        return this[_add_1](value_1, key_2);
      }
      let value_1 = html_common.convertDartToNative_SerializedScriptValue(value);
      return this[_add_2](value_1);
    }
    [_add_1](value, key) {
      return this.add(value, key);
    }
    [_add_2](value) {
      return this.add(value);
    }
    [_clear$0]() {
      return this.clear();
    }
    [_count$0](key) {
      return this.count(key);
    }
    [_createIndex](name, keyPath, options) {
      if (options === void 0) options = null;
      if (options != null) {
        let options_1 = html_common.convertDartToNative_Dictionary(options);
        return this[_createIndex_1](name, keyPath, options_1);
      }
      return this[_createIndex_2](name, keyPath);
    }
    [_createIndex_1](name, keyPath, options) {
      return this.createIndex(name, keyPath, options);
    }
    [_createIndex_2](name, keyPath) {
      return this.createIndex(name, keyPath);
    }
    [_delete](key) {
      return this.delete(key);
    }
    [dartx.deleteIndex](name) {
      return this.deleteIndex(name);
    }
    [_get$](key) {
      return this.get(key);
    }
    [dartx.getAll](range, maxCount) {
      return this.getAll(range, maxCount);
    }
    [dartx.getAllKeys](range, maxCount) {
      return this.getAllKeys(range, maxCount);
    }
    [dartx.index](name) {
      return this.index(name);
    }
    [_openCursor](range, direction) {
      return this.openCursor(range, direction);
    }
    [dartx.openKeyCursor](range, direction) {
      return this.openKeyCursor(range, direction);
    }
    [_put](value, key) {
      if (key === void 0) key = null;
      if (key != null) {
        let value_1 = html_common.convertDartToNative_SerializedScriptValue(value);
        let key_2 = html_common.convertDartToNative_SerializedScriptValue(key);
        return this[_put_1](value_1, key_2);
      }
      let value_1 = html_common.convertDartToNative_SerializedScriptValue(value);
      return this[_put_2](value_1);
    }
    [_put_1](value, key) {
      return this.put(value, key);
    }
    [_put_2](value) {
      return this.put(value);
    }
    static _cursorStreamFromResult(T) {
      return (request, autoAdvance) => {
        let controller = async.StreamController$(T).new({sync: true});
        request[dartx.onError].listen(dart.bind(controller, 'addError'));
        request[dartx.onSuccess].listen(dart.fn(e => {
          let cursor = indexed_db._cast(T)(request[dartx.result]);
          if (cursor == null) {
            controller.close();
          } else {
            controller.add(cursor);
            if (autoAdvance == true && dart.test(controller.hasListener)) {
              cursor[dartx.next]();
            }
          }
        }, EventTovoid$()));
        return controller.stream;
      };
    }
  };
  dart.setSignature(indexed_db.ObjectStore, {
    constructors: () => ({_: dart.definiteFunctionType(indexed_db.ObjectStore, [])}),
    methods: () => ({
      [dartx.add]: dart.definiteFunctionType(async.Future, [dart.dynamic], [dart.dynamic]),
      [dartx.clear]: dart.definiteFunctionType(async.Future, []),
      [dartx.delete]: dart.definiteFunctionType(async.Future, [dart.dynamic]),
      [dartx.count]: dart.definiteFunctionType(async.Future$(core.int), [], [dart.dynamic]),
      [dartx.put]: dart.definiteFunctionType(async.Future, [dart.dynamic], [dart.dynamic]),
      [dartx.getObject]: dart.definiteFunctionType(async.Future, [dart.dynamic]),
      [dartx.openCursor]: dart.definiteFunctionType(async.Stream$(indexed_db.CursorWithValue), [], {key: dart.dynamic, range: indexed_db.KeyRange, direction: core.String, autoAdvance: core.bool}),
      [dartx.createIndex]: dart.definiteFunctionType(indexed_db.Index, [core.String, dart.dynamic], {unique: core.bool, multiEntry: core.bool}),
      [_add$2]: dart.definiteFunctionType(indexed_db.Request, [dart.dynamic], [dart.dynamic]),
      [_add_1]: dart.definiteFunctionType(indexed_db.Request, [dart.dynamic, dart.dynamic]),
      [_add_2]: dart.definiteFunctionType(indexed_db.Request, [dart.dynamic]),
      [_clear$0]: dart.definiteFunctionType(indexed_db.Request, []),
      [_count$0]: dart.definiteFunctionType(indexed_db.Request, [core.Object]),
      [_createIndex]: dart.definiteFunctionType(indexed_db.Index, [core.String, core.Object], [core.Map]),
      [_createIndex_1]: dart.definiteFunctionType(indexed_db.Index, [dart.dynamic, dart.dynamic, dart.dynamic]),
      [_createIndex_2]: dart.definiteFunctionType(indexed_db.Index, [dart.dynamic, dart.dynamic]),
      [_delete]: dart.definiteFunctionType(indexed_db.Request, [core.Object]),
      [dartx.deleteIndex]: dart.definiteFunctionType(dart.void, [core.String]),
      [_get$]: dart.definiteFunctionType(indexed_db.Request, [core.Object]),
      [dartx.getAll]: dart.definiteFunctionType(indexed_db.Request, [core.Object], [core.int]),
      [dartx.getAllKeys]: dart.definiteFunctionType(indexed_db.Request, [core.Object], [core.int]),
      [dartx.index]: dart.definiteFunctionType(indexed_db.Index, [core.String]),
      [_openCursor]: dart.definiteFunctionType(indexed_db.Request, [core.Object], [core.String]),
      [dartx.openKeyCursor]: dart.definiteFunctionType(indexed_db.Request, [core.Object], [core.String]),
      [_put]: dart.definiteFunctionType(indexed_db.Request, [dart.dynamic], [dart.dynamic]),
      [_put_1]: dart.definiteFunctionType(indexed_db.Request, [dart.dynamic, dart.dynamic]),
      [_put_2]: dart.definiteFunctionType(indexed_db.Request, [dart.dynamic])
    }),
    statics: () => ({_cursorStreamFromResult: dart.definiteFunctionType(T => [async.Stream$(T), [indexed_db.Request, core.bool]])}),
    names: ['_cursorStreamFromResult']
  });
  dart.registerExtension(dart.global.IDBObjectStore, indexed_db.ObjectStore);
  indexed_db._cast = function(To) {
    return x => {
      return To._check(x);
    };
  };
  dart.fn(indexed_db._cast, dynamicToTo());
  const _get_result = Symbol('_get_result');
  dart.defineExtensionNames([
    'result',
    'onError',
    'onSuccess',
    'error',
    'readyState',
    'source',
    'transaction'
  ]);
  indexed_db.Request = class Request extends html$.EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.error]() {
      return this.error;
    }
    get [dartx.readyState]() {
      return this.readyState;
    }
    get [dartx.result]() {
      return indexed_db._convertNativeToDart_IDBAny(this[_get_result]);
    }
    get [_get_result]() {
      return this.result;
    }
    get [dartx.source]() {
      return this.source;
    }
    get [dartx.transaction]() {
      return this.transaction;
    }
    get [dartx.onError]() {
      return indexed_db.Request.errorEvent.forTarget(this);
    }
    get [dartx.onSuccess]() {
      return indexed_db.Request.successEvent.forTarget(this);
    }
  };
  dart.setSignature(indexed_db.Request, {
    constructors: () => ({_: dart.definiteFunctionType(indexed_db.Request, [])})
  });
  dart.defineLazy(indexed_db.Request, {
    get errorEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('error'));
    },
    get successEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('success'));
    }
  });
  dart.registerExtension(dart.global.IDBRequest, indexed_db.Request);
  dart.defineExtensionNames([
    'onBlocked',
    'onUpgradeNeeded'
  ]);
  indexed_db.OpenDBRequest = class OpenDBRequest extends indexed_db.Request {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.onBlocked]() {
      return indexed_db.OpenDBRequest.blockedEvent.forTarget(this);
    }
    get [dartx.onUpgradeNeeded]() {
      return indexed_db.OpenDBRequest.upgradeNeededEvent.forTarget(this);
    }
  };
  dart.setSignature(indexed_db.OpenDBRequest, {
    constructors: () => ({_: dart.definiteFunctionType(indexed_db.OpenDBRequest, [])})
  });
  dart.defineLazy(indexed_db.OpenDBRequest, {
    get blockedEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('blocked'));
    },
    get upgradeNeededEvent() {
      return dart.const(new (EventStreamProviderOfVersionChangeEvent())('upgradeneeded'));
    }
  });
  dart.registerExtension(dart.global.IDBOpenDBRequest, indexed_db.OpenDBRequest);
  dart.defineExtensionNames([
    'completed',
    'abort',
    'objectStore',
    'onAbort',
    'onComplete',
    'onError',
    'db',
    'error',
    'mode',
    'objectStoreNames'
  ]);
  indexed_db.Transaction = class Transaction extends html$.EventTarget {
    get [dartx.completed]() {
      let completer = CompleterOfDatabase().new();
      this[dartx.onComplete].first.then(dart.dynamic)(dart.fn(_ => {
        completer.complete(this[dartx.db]);
      }, EventTodynamic()));
      this[dartx.onError].first.then(dart.dynamic)(dart.fn(e => {
        completer.completeError(e);
      }, EventTodynamic()));
      this[dartx.onAbort].first.then(dart.dynamic)(dart.fn(e => {
        if (!dart.test(completer.isCompleted)) {
          completer.completeError(e);
        }
      }, EventTodynamic()));
      return completer.future;
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.db]() {
      return this.db;
    }
    get [dartx.error]() {
      return this.error;
    }
    get [dartx.mode]() {
      return this.mode;
    }
    get [dartx.objectStoreNames]() {
      return this.objectStoreNames;
    }
    [dartx.abort]() {
      return this.abort();
    }
    [dartx.objectStore](name) {
      return this.objectStore(name);
    }
    get [dartx.onAbort]() {
      return indexed_db.Transaction.abortEvent.forTarget(this);
    }
    get [dartx.onComplete]() {
      return indexed_db.Transaction.completeEvent.forTarget(this);
    }
    get [dartx.onError]() {
      return indexed_db.Transaction.errorEvent.forTarget(this);
    }
  };
  dart.setSignature(indexed_db.Transaction, {
    constructors: () => ({_: dart.definiteFunctionType(indexed_db.Transaction, [])}),
    methods: () => ({
      [dartx.abort]: dart.definiteFunctionType(dart.void, []),
      [dartx.objectStore]: dart.definiteFunctionType(indexed_db.ObjectStore, [core.String])
    })
  });
  dart.defineLazy(indexed_db.Transaction, {
    get abortEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('abort'));
    },
    get completeEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('complete'));
    },
    get errorEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('error'));
    }
  });
  dart.registerExtension(dart.global.IDBTransaction, indexed_db.Transaction);
  const _createEvent = Symbol('_createEvent');
  const _initEvent = Symbol('_initEvent');
  const _selector = Symbol('_selector');
  const _get_currentTarget = Symbol('_get_currentTarget');
  const _get_target = Symbol('_get_target');
  dart.defineExtensionNames([
    'matchingTarget',
    'currentTarget',
    'target',
    'preventDefault',
    'stopImmediatePropagation',
    'stopPropagation',
    'bubbles',
    'cancelable',
    'defaultPrevented',
    'eventPhase',
    'path',
    'timeStamp',
    'type'
  ]);
  html$.Event = class Event extends _interceptors.Interceptor {
    static new(type, opts) {
      let canBubble = opts && 'canBubble' in opts ? opts.canBubble : true;
      let cancelable = opts && 'cancelable' in opts ? opts.cancelable : true;
      return html$.Event.eventType('Event', type, {canBubble: canBubble, cancelable: cancelable});
    }
    static eventType(type, name, opts) {
      let canBubble = opts && 'canBubble' in opts ? opts.canBubble : true;
      let cancelable = opts && 'cancelable' in opts ? opts.cancelable : true;
      let e = html$.document[_createEvent](type);
      e[_initEvent](name, canBubble, cancelable);
      return e;
    }
    get [_selector]() {
      return this._selector;
    }
    set [_selector](value) {
      this._selector = value;
    }
    get [dartx.matchingTarget]() {
      if (this[_selector] == null) {
        dart.throw(new core.UnsupportedError('Cannot call matchingTarget if this Event did' + ' not arise as a result of event delegation.'));
      }
      let currentTarget = html$.Element._check(this[dartx.currentTarget]);
      let target = html$.Element._check(this[dartx.target]);
      let matchedTarget = null;
      do {
        if (dart.test(target[dartx.matches](this[_selector]))) return target;
        target = target[dartx.parent];
      } while (target != null && !dart.equals(target, currentTarget[dartx.parent]));
      dart.throw(new core.StateError('No selector matched for populating matchedTarget.'));
    }
    static _(type, eventInitDict) {
      if (eventInitDict === void 0) eventInitDict = null;
      if (eventInitDict != null) {
        let eventInitDict_1 = html_common.convertDartToNative_Dictionary(eventInitDict);
        return html$.Event._create_1(type, eventInitDict_1);
      }
      return html$.Event._create_2(type);
    }
    static _create_1(type, eventInitDict) {
      return new Event(type, eventInitDict);
    }
    static _create_2(type) {
      return new Event(type);
    }
    get [dartx.bubbles]() {
      return this.bubbles;
    }
    get [dartx.cancelable]() {
      return this.cancelable;
    }
    get [dartx.currentTarget]() {
      return html$._convertNativeToDart_EventTarget(this[_get_currentTarget]);
    }
    get [_get_currentTarget]() {
      return this.currentTarget;
    }
    get [dartx.defaultPrevented]() {
      return this.defaultPrevented;
    }
    get [dartx.eventPhase]() {
      return this.eventPhase;
    }
    get [dartx.path]() {
      return this.path;
    }
    get [dartx.target]() {
      return html$._convertNativeToDart_EventTarget(this[_get_target]);
    }
    get [_get_target]() {
      return this.target;
    }
    get [dartx.timeStamp]() {
      return this.timeStamp;
    }
    get [dartx.type]() {
      return this.type;
    }
    [_initEvent](type, bubbles, cancelable) {
      return this.initEvent(type, bubbles, cancelable);
    }
    [dartx.preventDefault]() {
      return this.preventDefault();
    }
    [dartx.stopImmediatePropagation]() {
      return this.stopImmediatePropagation();
    }
    [dartx.stopPropagation]() {
      return this.stopPropagation();
    }
  };
  dart.setSignature(html$.Event, {
    constructors: () => ({
      new: dart.definiteFunctionType(html$.Event, [core.String], {canBubble: core.bool, cancelable: core.bool}),
      eventType: dart.definiteFunctionType(html$.Event, [core.String, core.String], {canBubble: core.bool, cancelable: core.bool}),
      _: dart.definiteFunctionType(html$.Event, [core.String], [core.Map])
    }),
    methods: () => ({
      [_initEvent]: dart.definiteFunctionType(dart.void, [core.String, core.bool, core.bool]),
      [dartx.preventDefault]: dart.definiteFunctionType(dart.void, []),
      [dartx.stopImmediatePropagation]: dart.definiteFunctionType(dart.void, []),
      [dartx.stopPropagation]: dart.definiteFunctionType(dart.void, [])
    }),
    statics: () => ({
      _create_1: dart.definiteFunctionType(html$.Event, [dart.dynamic, dart.dynamic]),
      _create_2: dart.definiteFunctionType(html$.Event, [dart.dynamic])
    }),
    names: ['_create_1', '_create_2']
  });
  html$.Event.AT_TARGET = 2;
  html$.Event.BUBBLING_PHASE = 3;
  html$.Event.CAPTURING_PHASE = 1;
  dart.registerExtension(dart.global.Event, html$.Event);
  dart.defineExtensionNames([
    'dataLoss',
    'dataLossMessage',
    'newVersion',
    'oldVersion'
  ]);
  indexed_db.VersionChangeEvent = class VersionChangeEvent extends html$.Event {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(type, eventInitDict) {
      if (eventInitDict === void 0) eventInitDict = null;
      if (eventInitDict != null) {
        let eventInitDict_1 = html_common.convertDartToNative_Dictionary(eventInitDict);
        return indexed_db.VersionChangeEvent._create_1(type, eventInitDict_1);
      }
      return indexed_db.VersionChangeEvent._create_2(type);
    }
    static _create_1(type, eventInitDict) {
      return new IDBVersionChangeEvent(type, eventInitDict);
    }
    static _create_2(type) {
      return new IDBVersionChangeEvent(type);
    }
    get [dartx.dataLoss]() {
      return this.dataLoss;
    }
    get [dartx.dataLossMessage]() {
      return this.dataLossMessage;
    }
    get [dartx.newVersion]() {
      return this.newVersion;
    }
    get [dartx.oldVersion]() {
      return this.oldVersion;
    }
  };
  dart.setSignature(indexed_db.VersionChangeEvent, {
    constructors: () => ({
      _: dart.definiteFunctionType(indexed_db.VersionChangeEvent, []),
      new: dart.definiteFunctionType(indexed_db.VersionChangeEvent, [core.String], [core.Map])
    }),
    statics: () => ({
      _create_1: dart.definiteFunctionType(indexed_db.VersionChangeEvent, [dart.dynamic, dart.dynamic]),
      _create_2: dart.definiteFunctionType(indexed_db.VersionChangeEvent, [dart.dynamic])
    }),
    names: ['_create_1', '_create_2']
  });
  dart.registerExtension(dart.global.IDBVersionChangeEvent, indexed_db.VersionChangeEvent);
  dart.copyProperties(html$, {
    get window() {
      return window;
    }
  });
  dart.copyProperties(html$, {
    get document() {
      return document;
    }
  });
  const _xtag = Symbol('_xtag');
  const _attributes$ = Symbol('_attributes');
  const _innerHtml = Symbol('_innerHtml');
  const _scrollHeight = Symbol('_scrollHeight');
  const _scrollLeft = Symbol('_scrollLeft');
  const _scrollTop = Symbol('_scrollTop');
  const _scrollWidth = Symbol('_scrollWidth');
  const _childElementCount = Symbol('_childElementCount');
  const _children = Symbol('_children');
  const _firstElementChild = Symbol('_firstElementChild');
  const _lastElementChild = Symbol('_lastElementChild');
  const _querySelectorAll = Symbol('_querySelectorAll');
  const _getComputedStyle = Symbol('_getComputedStyle');
  const _animate = Symbol('_animate');
  const _localName = Symbol('_localName');
  const _namespaceUri = Symbol('_namespaceUri');
  const _scrollIntoView = Symbol('_scrollIntoView');
  const _scrollIntoViewIfNeeded = Symbol('_scrollIntoViewIfNeeded');
  const _insertAdjacentText = Symbol('_insertAdjacentText');
  const _insertAdjacentNode = Symbol('_insertAdjacentNode');
  const _insertAdjacentHtml = Symbol('_insertAdjacentHtml');
  const _insertAdjacentElement = Symbol('_insertAdjacentElement');
  const _canBeUsedToCreateContextualFragment = Symbol('_canBeUsedToCreateContextualFragment');
  const _cannotBeUsedToCreateContextualFragment = Symbol('_cannotBeUsedToCreateContextualFragment');
  const _getElementsByTagName = Symbol('_getElementsByTagName');
  const _hasAttribute = Symbol('_hasAttribute');
  const _hasAttributeNS = Symbol('_hasAttributeNS');
  const _removeAttribute = Symbol('_removeAttribute');
  const _removeAttributeNS = Symbol('_removeAttributeNS');
  const _scroll_1 = Symbol('_scroll_1');
  const _scroll_2 = Symbol('_scroll_2');
  const _scroll_3 = Symbol('_scroll_3');
  const _scrollBy_1 = Symbol('_scrollBy_1');
  const _scrollBy_2 = Symbol('_scrollBy_2');
  const _scrollBy_3 = Symbol('_scrollBy_3');
  const _scrollTo_1 = Symbol('_scrollTo_1');
  const _scrollTo_2 = Symbol('_scrollTo_2');
  const _scrollTo_3 = Symbol('_scrollTo_3');
  const _removeChild = Symbol('_removeChild');
  const _replaceChild = Symbol('_replaceChild');
  const _this = Symbol('_this');
  const _clearChildren = Symbol('_clearChildren');
  dart.defineExtensionNames([
    'nodes',
    'nodes',
    'remove',
    'replaceWith',
    'insertAllBefore',
    'toString',
    'append',
    'clone',
    'contains',
    'hasChildNodes',
    'insertBefore',
    'childNodes',
    'baseUri',
    'firstChild',
    'lastChild',
    'nextNode',
    'nodeName',
    'nodeType',
    'nodeValue',
    'ownerDocument',
    'parent',
    'parentNode',
    'previousNode',
    'text'
  ]);
  html$.Node = class Node extends html$.EventTarget {
    _created() {
      this[dartx.childNodes] = null;
      this[dartx.baseUri] = null;
      this[dartx.firstChild] = null;
      this[dartx.lastChild] = null;
      this[_localName] = null;
      this[_namespaceUri] = null;
      this[dartx.nextNode] = null;
      this[dartx.nodeName] = null;
      this[dartx.nodeType] = null;
      this[dartx.nodeValue] = null;
      this[dartx.ownerDocument] = null;
      this[dartx.parent] = null;
      this[dartx.parentNode] = null;
      this[dartx.previousNode] = null;
      this[dartx.text] = null;
      super._created();
    }
    get [dartx.nodes]() {
      return new html$._ChildNodeListLazy(this);
    }
    set [dartx.nodes](value) {
      let copy = value[dartx.toList]();
      this[dartx.text] = '';
      for (let node of copy) {
        this[dartx.append](node);
      }
    }
    [dartx.remove]() {
      if (this[dartx.parentNode] != null) {
        let parent = this[dartx.parentNode];
        this[dartx.parentNode][_removeChild](this);
      }
    }
    [dartx.replaceWith](otherNode) {
      try {
        let parent = this[dartx.parentNode];
        parent[_replaceChild](otherNode, this);
      } catch (e) {
      }

      ;
      return this;
    }
    [dartx.insertAllBefore](newNodes, refChild) {
      if (html$._ChildNodeListLazy.is(newNodes)) {
        let otherList = newNodes;
        if (core.identical(otherList[_this], this)) {
          dart.throw(new core.ArgumentError(newNodes));
        }
        for (let i = 0, len = otherList.length; i < dart.notNull(len); ++i) {
          this[dartx.insertBefore](otherList[_this][dartx.firstChild], refChild);
        }
      } else {
        for (let node of newNodes) {
          this[dartx.insertBefore](node, refChild);
        }
      }
    }
    [_clearChildren]() {
      while (this[dartx.firstChild] != null) {
        this[_removeChild](this[dartx.firstChild]);
      }
    }
    [dartx.toString]() {
      let value = this[dartx.nodeValue];
      return value == null ? super.toString() : value;
    }
    get [dartx.childNodes]() {
      return this.childNodes;
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.baseUri]() {
      return this.baseURI;
    }
    get [dartx.firstChild]() {
      return this.firstChild;
    }
    get [dartx.lastChild]() {
      return this.lastChild;
    }
    get [_localName]() {
      return this.localName;
    }
    get [_namespaceUri]() {
      return this.namespaceURI;
    }
    get [dartx.nextNode]() {
      return this.nextSibling;
    }
    get [dartx.nodeName]() {
      return this.nodeName;
    }
    get [dartx.nodeType]() {
      return this.nodeType;
    }
    get [dartx.nodeValue]() {
      return this.nodeValue;
    }
    get [dartx.ownerDocument]() {
      return this.ownerDocument;
    }
    get [dartx.parent]() {
      return this.parentElement;
    }
    get [dartx.parentNode]() {
      return this.parentNode;
    }
    get [dartx.previousNode]() {
      return this.previousSibling;
    }
    get [dartx.text]() {
      return this.textContent;
    }
    set [dartx.text](value) {
      this.textContent = value;
    }
    [dartx.append](node) {
      return this.appendChild(node);
    }
    [dartx.clone](deep) {
      return this.cloneNode(deep);
    }
    [dartx.contains](other) {
      return this.contains(other);
    }
    [dartx.hasChildNodes]() {
      return this.hasChildNodes();
    }
    [dartx.insertBefore](node, child) {
      return this.insertBefore(node, child);
    }
    [_removeChild](child) {
      return this.removeChild(child);
    }
    [_replaceChild](node, child) {
      return this.replaceChild(node, child);
    }
  };
  dart.defineNamedConstructor(html$.Node, '_created');
  dart.setSignature(html$.Node, {
    constructors: () => ({
      _created: dart.definiteFunctionType(html$.Node, []),
      _: dart.definiteFunctionType(html$.Node, [])
    }),
    methods: () => ({
      [dartx.remove]: dart.definiteFunctionType(dart.void, []),
      [dartx.replaceWith]: dart.definiteFunctionType(html$.Node, [html$.Node]),
      [dartx.insertAllBefore]: dart.definiteFunctionType(html$.Node, [core.Iterable$(html$.Node), html$.Node]),
      [_clearChildren]: dart.definiteFunctionType(dart.void, []),
      [dartx.append]: dart.definiteFunctionType(html$.Node, [html$.Node]),
      [dartx.clone]: dart.definiteFunctionType(html$.Node, [core.bool]),
      [dartx.contains]: dart.definiteFunctionType(core.bool, [html$.Node]),
      [dartx.hasChildNodes]: dart.definiteFunctionType(core.bool, []),
      [dartx.insertBefore]: dart.definiteFunctionType(html$.Node, [html$.Node, html$.Node]),
      [_removeChild]: dart.definiteFunctionType(html$.Node, [html$.Node]),
      [_replaceChild]: dart.definiteFunctionType(html$.Node, [html$.Node, html$.Node])
    })
  });
  html$.Node.ATTRIBUTE_NODE = 2;
  html$.Node.CDATA_SECTION_NODE = 4;
  html$.Node.COMMENT_NODE = 8;
  html$.Node.DOCUMENT_FRAGMENT_NODE = 11;
  html$.Node.DOCUMENT_NODE = 9;
  html$.Node.DOCUMENT_TYPE_NODE = 10;
  html$.Node.ELEMENT_NODE = 1;
  html$.Node.ENTITY_NODE = 6;
  html$.Node.ENTITY_REFERENCE_NODE = 5;
  html$.Node.NOTATION_NODE = 12;
  html$.Node.PROCESSING_INSTRUCTION_NODE = 7;
  html$.Node.TEXT_NODE = 3;
  dart.registerExtension(dart.global.Node, html$.Node);
  dart.defineExtensionNames([
    'attributes',
    'attributes',
    'children',
    'children',
    'querySelectorAll',
    'query',
    'queryAll',
    'classes',
    'classes',
    'dataset',
    'dataset',
    'getNamespacedAttributes',
    'getComputedStyle',
    'client',
    'offset',
    'appendText',
    'appendHtml',
    'attached',
    'detached',
    'enteredView',
    'leftView',
    'animate',
    'attributeChanged',
    'xtag',
    'xtag',
    'localName',
    'namespaceUri',
    'toString',
    'scrollIntoView',
    'insertAdjacentText',
    'insertAdjacentHtml',
    'insertAdjacentElement',
    'matches',
    'matchesWithAncestors',
    'createShadowRoot',
    'shadowRoot',
    'contentEdge',
    'paddingEdge',
    'borderEdge',
    'marginEdge',
    'documentOffset',
    'offsetTo',
    'createFragment',
    'innerHtml',
    'setInnerHtml',
    'innerHtml',
    'on',
    'offsetHeight',
    'offsetLeft',
    'offsetTop',
    'offsetWidth',
    'scrollHeight',
    'scrollLeft',
    'scrollLeft',
    'scrollTop',
    'scrollTop',
    'scrollWidth',
    'isContentEditable',
    'blur',
    'click',
    'focus',
    'outerHtml',
    'closest',
    'getAnimations',
    'getAttribute',
    'getAttributeNS',
    'getBoundingClientRect',
    'getClientRects',
    'getDestinationInsertionPoints',
    'getElementsByClassName',
    'requestFullscreen',
    'requestPointerLock',
    'scroll',
    'scrollBy',
    'scrollTo',
    'setAttribute',
    'setAttributeNS',
    'after',
    'before',
    'querySelector',
    'onAbort',
    'onBeforeCopy',
    'onBeforeCut',
    'onBeforePaste',
    'onBlur',
    'onCanPlay',
    'onCanPlayThrough',
    'onChange',
    'onClick',
    'onContextMenu',
    'onCopy',
    'onCut',
    'onDoubleClick',
    'onDrag',
    'onDragEnd',
    'onDragEnter',
    'onDragLeave',
    'onDragOver',
    'onDragStart',
    'onDrop',
    'onDurationChange',
    'onEmptied',
    'onEnded',
    'onError',
    'onFocus',
    'onInput',
    'onInvalid',
    'onKeyDown',
    'onKeyPress',
    'onKeyUp',
    'onLoad',
    'onLoadedData',
    'onLoadedMetadata',
    'onMouseDown',
    'onMouseEnter',
    'onMouseLeave',
    'onMouseMove',
    'onMouseOut',
    'onMouseOver',
    'onMouseUp',
    'onMouseWheel',
    'onPaste',
    'onPause',
    'onPlay',
    'onPlaying',
    'onRateChange',
    'onReset',
    'onResize',
    'onScroll',
    'onSearch',
    'onSeeked',
    'onSeeking',
    'onSelect',
    'onSelectStart',
    'onStalled',
    'onSubmit',
    'onSuspend',
    'onTimeUpdate',
    'onTouchCancel',
    'onTouchEnd',
    'onTouchEnter',
    'onTouchLeave',
    'onTouchMove',
    'onTouchStart',
    'onTransitionEnd',
    'onVolumeChange',
    'onWaiting',
    'onFullscreenChange',
    'onFullscreenError',
    'offsetParent',
    'contentEditable',
    'contextMenu',
    'dir',
    'draggable',
    'hidden',
    'lang',
    'spellcheck',
    'style',
    'tabIndex',
    'title',
    'translate',
    'dropzone',
    'className',
    'clientHeight',
    'clientLeft',
    'clientTop',
    'clientWidth',
    'computedName',
    'computedRole',
    'id',
    'tagName',
    'nextElementSibling',
    'previousElementSibling'
  ]);
  html$.Element = class Element extends html$.Node {
    static html(html, opts) {
      let validator = opts && 'validator' in opts ? opts.validator : null;
      let treeSanitizer = opts && 'treeSanitizer' in opts ? opts.treeSanitizer : null;
      let fragment = html$.document[dartx.body][dartx.createFragment](html, {validator: validator, treeSanitizer: treeSanitizer});
      return html$.Element._check(fragment[dartx.nodes][dartx.where](dart.fn(e => html$.Element.is(e), NodeTobool()))[dartx.single]);
    }
    created() {
      this[_xtag] = null;
      this[dartx.offsetParent] = null;
      this[dartx.contentEditable] = null;
      this[dartx.contextMenu] = null;
      this[dartx.dir] = null;
      this[dartx.draggable] = null;
      this[dartx.hidden] = null;
      this[dartx.lang] = null;
      this[dartx.spellcheck] = null;
      this[dartx.style] = null;
      this[dartx.tabIndex] = null;
      this[dartx.title] = null;
      this[dartx.translate] = null;
      this[dartx.dropzone] = null;
      this[_attributes$] = null;
      this[dartx.className] = null;
      this[dartx.clientHeight] = null;
      this[dartx.clientLeft] = null;
      this[dartx.clientTop] = null;
      this[dartx.clientWidth] = null;
      this[dartx.computedName] = null;
      this[dartx.computedRole] = null;
      this[dartx.id] = null;
      this[_innerHtml] = null;
      this[_scrollHeight] = null;
      this[_scrollLeft] = null;
      this[_scrollTop] = null;
      this[_scrollWidth] = null;
      this[dartx.tagName] = null;
      this[dartx.nextElementSibling] = null;
      this[dartx.previousElementSibling] = null;
      this[_childElementCount] = null;
      this[_children] = null;
      this[_firstElementChild] = null;
      this[_lastElementChild] = null;
      super._created();
    }
    static tag(tag, typeExtention) {
      if (typeExtention === void 0) typeExtention = null;
      return html$.Element._check(html$._ElementFactoryProvider.createElement_tag(tag, typeExtention));
    }
    static a() {
      return html$.Element.tag('a');
    }
    static article() {
      return html$.Element.tag('article');
    }
    static aside() {
      return html$.Element.tag('aside');
    }
    static audio() {
      return html$.Element.tag('audio');
    }
    static br() {
      return html$.Element.tag('br');
    }
    static canvas() {
      return html$.Element.tag('canvas');
    }
    static div() {
      return html$.Element.tag('div');
    }
    static footer() {
      return html$.Element.tag('footer');
    }
    static header() {
      return html$.Element.tag('header');
    }
    static hr() {
      return html$.Element.tag('hr');
    }
    static iframe() {
      return html$.Element.tag('iframe');
    }
    static img() {
      return html$.Element.tag('img');
    }
    static li() {
      return html$.Element.tag('li');
    }
    static nav() {
      return html$.Element.tag('nav');
    }
    static ol() {
      return html$.Element.tag('ol');
    }
    static option() {
      return html$.Element.tag('option');
    }
    static p() {
      return html$.Element.tag('p');
    }
    static pre() {
      return html$.Element.tag('pre');
    }
    static section() {
      return html$.Element.tag('section');
    }
    static select() {
      return html$.Element.tag('select');
    }
    static span() {
      return html$.Element.tag('span');
    }
    static svg() {
      return html$.Element.tag('svg');
    }
    static table() {
      return html$.Element.tag('table');
    }
    static td() {
      return html$.Element.tag('td');
    }
    static textarea() {
      return html$.Element.tag('textarea');
    }
    static th() {
      return html$.Element.tag('th');
    }
    static tr() {
      return html$.Element.tag('tr');
    }
    static ul() {
      return html$.Element.tag('ul');
    }
    static video() {
      return html$.Element.tag('video');
    }
    get [dartx.attributes]() {
      return new html$._ElementAttributeMap(this);
    }
    set [dartx.attributes](value) {
      let attributes = this[dartx.attributes];
      attributes[dartx.clear]();
      for (let key of value[dartx.keys]) {
        attributes[dartx.set](key, value[dartx.get](key));
      }
    }
    get [dartx.children]() {
      return new html$._ChildrenElementList._wrap(this);
    }
    set [dartx.children](value) {
      let copy = value[dartx.toList]();
      let children = this[dartx.children];
      children[dartx.clear]();
      children[dartx.addAll](copy);
    }
    [dartx.querySelectorAll](T) {
      return selectors => {
        return new (html$._FrozenElementList$(T))._wrap(this[_querySelectorAll](selectors));
      };
    }
    [dartx.query](relativeSelectors) {
      return this[dartx.querySelector](relativeSelectors);
    }
    [dartx.queryAll](T) {
      return relativeSelectors => {
        return this[dartx.querySelectorAll](T)(relativeSelectors);
      };
    }
    get [dartx.classes]() {
      return new html$._ElementCssClassSet(this);
    }
    set [dartx.classes](value) {
      let classSet = this[dartx.classes];
      classSet.clear();
      classSet.addAll(value);
    }
    get [dartx.dataset]() {
      return new html$._DataAttributeMap(this[dartx.attributes]);
    }
    set [dartx.dataset](value) {
      let data = this[dartx.dataset];
      data[dartx.clear]();
      for (let key of value[dartx.keys]) {
        data[dartx.set](key, value[dartx.get](key));
      }
    }
    [dartx.getNamespacedAttributes](namespace) {
      return new html$._NamespacedAttributeMap(this, namespace);
    }
    [dartx.getComputedStyle](pseudoElement) {
      if (pseudoElement === void 0) pseudoElement = null;
      if (pseudoElement == null) {
        pseudoElement = '';
      }
      return html$.window[_getComputedStyle](this, pseudoElement);
    }
    get [dartx.client]() {
      return new (RectangleOfnum())(this[dartx.clientLeft], this[dartx.clientTop], this[dartx.clientWidth], this[dartx.clientHeight]);
    }
    get [dartx.offset]() {
      return new (RectangleOfnum())(this[dartx.offsetLeft], this[dartx.offsetTop], this[dartx.offsetWidth], this[dartx.offsetHeight]);
    }
    [dartx.appendText](text) {
      this[dartx.append](html$.Text.new(text));
    }
    [dartx.appendHtml](text, opts) {
      let validator = opts && 'validator' in opts ? opts.validator : null;
      let treeSanitizer = opts && 'treeSanitizer' in opts ? opts.treeSanitizer : null;
      this[dartx.insertAdjacentHtml]('beforeend', text, {validator: validator, treeSanitizer: treeSanitizer});
    }
    static isTagSupported(tag) {
      let e = html$._ElementFactoryProvider.createElement_tag(tag, null);
      return html$.Element.is(e) && !html$.UnknownElement.is(e);
    }
    [dartx.attached]() {
      this[dartx.enteredView]();
    }
    [dartx.detached]() {
      this[dartx.leftView]();
    }
    [dartx.enteredView]() {}
    [dartx.leftView]() {}
    [dartx.animate](frames, timing) {
      if (timing === void 0) timing = null;
      if (!core.Iterable.is(frames) || !dart.test(frames[dartx.every](dart.fn(x => core.Map.is(x), MapOfString$dynamicTobool())))) {
        dart.throw(new core.ArgumentError("The frames parameter should be a List of Maps " + "with frame information"));
      }
      let convertedFrames = null;
      if (core.Iterable.is(frames)) {
        convertedFrames = frames[dartx.map](dart.dynamic)(html_common.convertDartToNative_Dictionary)[dartx.toList]();
      } else {
        convertedFrames = frames;
      }
      let convertedTiming = core.Map.is(timing) ? html_common.convertDartToNative_Dictionary(timing) : timing;
      return convertedTiming == null ? this[_animate](convertedFrames) : this[_animate](convertedFrames, convertedTiming);
    }
    [_animate](effect, timing) {
      return this.animate(effect, timing);
    }
    [dartx.attributeChanged](name, oldValue, newValue) {}
    get [_xtag]() {
      return this._xtag;
    }
    set [_xtag](value) {
      this._xtag = value;
    }
    get [dartx.xtag]() {
      return this[_xtag] != null ? this[_xtag] : this;
    }
    set [dartx.xtag](value) {
      this[_xtag] = value;
    }
    get [dartx.localName]() {
      return this[_localName];
    }
    get [dartx.namespaceUri]() {
      return this[_namespaceUri];
    }
    [dartx.toString]() {
      return this[dartx.localName];
    }
    [dartx.scrollIntoView](alignment) {
      if (alignment === void 0) alignment = null;
      let hasScrollIntoViewIfNeeded = true;
      hasScrollIntoViewIfNeeded = !!this.scrollIntoViewIfNeeded;
      if (dart.equals(alignment, html$.ScrollAlignment.TOP)) {
        this[_scrollIntoView](true);
      } else if (dart.equals(alignment, html$.ScrollAlignment.BOTTOM)) {
        this[_scrollIntoView](false);
      } else if (hasScrollIntoViewIfNeeded) {
        if (dart.equals(alignment, html$.ScrollAlignment.CENTER)) {
          this[_scrollIntoViewIfNeeded](true);
        } else {
          this[_scrollIntoViewIfNeeded]();
        }
      } else {
        this[_scrollIntoView]();
      }
    }
    static _determineMouseWheelEventType(e) {
      return 'wheel';
    }
    static _determineTransitionEventType(e) {
      if (dart.test(html_common.Device.isWebKit)) {
        return 'webkitTransitionEnd';
      } else if (dart.test(html_common.Device.isOpera)) {
        return 'oTransitionEnd';
      }
      return 'transitionend';
    }
    [dartx.insertAdjacentText](where, text) {
      if (!!this.insertAdjacentText) {
        this[_insertAdjacentText](where, text);
      } else {
        this[_insertAdjacentNode](where, html$.Text.new(text));
      }
    }
    [_insertAdjacentText](where, text) {
      return this.insertAdjacentText(where, text);
    }
    [dartx.insertAdjacentHtml](where, html, opts) {
      let validator = opts && 'validator' in opts ? opts.validator : null;
      let treeSanitizer = opts && 'treeSanitizer' in opts ? opts.treeSanitizer : null;
      if (html$._TrustedHtmlTreeSanitizer.is(treeSanitizer)) {
        this[_insertAdjacentHtml](where, html);
      } else {
        this[_insertAdjacentNode](where, this[dartx.createFragment](html, {validator: validator, treeSanitizer: treeSanitizer}));
      }
    }
    [_insertAdjacentHtml](where, text) {
      return this.insertAdjacentHTML(where, text);
    }
    [dartx.insertAdjacentElement](where, element) {
      if (!!this.insertAdjacentElement) {
        this[_insertAdjacentElement](where, element);
      } else {
        this[_insertAdjacentNode](where, element);
      }
      return element;
    }
    [_insertAdjacentElement](where, element) {
      return this.insertAdjacentElement(where, element);
    }
    [_insertAdjacentNode](where, node) {
      switch (where[dartx.toLowerCase]()) {
        case 'beforebegin':
        {
          this[dartx.parentNode][dartx.insertBefore](node, this);
          break;
        }
        case 'afterbegin':
        {
          let first = dart.notNull(this[dartx.nodes][dartx.length]) > 0 ? this[dartx.nodes][dartx.get](0) : null;
          this[dartx.insertBefore](node, first);
          break;
        }
        case 'beforeend':
        {
          this[dartx.append](node);
          break;
        }
        case 'afterend':
        {
          this[dartx.parentNode][dartx.insertBefore](node, this[dartx.nextNode]);
          break;
        }
        default:
        {
          dart.throw(new core.ArgumentError(dart.str`Invalid position ${where}`));
        }
      }
    }
    [dartx.matches](selectors) {
      if (!!this.matches) {
        return this.matches(selectors);
      } else if (!!this.webkitMatchesSelector) {
        return this.webkitMatchesSelector(selectors);
      } else if (!!this.mozMatchesSelector) {
        return this.mozMatchesSelector(selectors);
      } else if (!!this.msMatchesSelector) {
        return this.msMatchesSelector(selectors);
      } else if (!!this.oMatchesSelector) {
        return this.oMatchesSelector(selectors);
      } else {
        dart.throw(new core.UnsupportedError("Not supported on this platform"));
      }
    }
    [dartx.matchesWithAncestors](selectors) {
      let elem = this;
      do {
        if (dart.test(elem[dartx.matches](selectors))) return true;
        elem = elem[dartx.parent];
      } while (elem != null);
      return false;
    }
    [dartx.createShadowRoot]() {
      return (this.createShadowRoot || this.webkitCreateShadowRoot).call(this);
    }
    get [dartx.shadowRoot]() {
      return this.shadowRoot || this.webkitShadowRoot;
    }
    get [dartx.contentEdge]() {
      return new html$._ContentCssRect(this);
    }
    get [dartx.paddingEdge]() {
      return new html$._PaddingCssRect(this);
    }
    get [dartx.borderEdge]() {
      return new html$._BorderCssRect(this);
    }
    get [dartx.marginEdge]() {
      return new html$._MarginCssRect(this);
    }
    get [dartx.documentOffset]() {
      return this[dartx.offsetTo](html$.document[dartx.documentElement]);
    }
    [dartx.offsetTo](parent) {
      return html$.Element._offsetToHelper(this, parent);
    }
    static _offsetToHelper(current, parent) {
      let sameAsParent = core.identical(current, parent);
      let foundAsParent = sameAsParent || parent[dartx.tagName] == 'HTML';
      if (current == null || sameAsParent) {
        if (foundAsParent) return new (PointOfnum())(0, 0);
        dart.throw(new core.ArgumentError("Specified element is not a transitive offset " + "parent of this element."));
      }
      let parentOffset = current[dartx.offsetParent];
      let p = html$.Element._offsetToHelper(parentOffset, parent);
      return new (PointOfnum())(dart.notNull(p.x) + dart.notNull(current[dartx.offsetLeft]), dart.notNull(p.y) + dart.notNull(current[dartx.offsetTop]));
    }
    [dartx.createFragment](html, opts) {
      let validator = opts && 'validator' in opts ? opts.validator : null;
      let treeSanitizer = opts && 'treeSanitizer' in opts ? opts.treeSanitizer : null;
      if (treeSanitizer == null) {
        if (validator == null) {
          if (html$.Element._defaultValidator == null) {
            html$.Element._defaultValidator = new html$.NodeValidatorBuilder.common();
          }
          validator = html$.Element._defaultValidator;
        }
        if (html$.Element._defaultSanitizer == null) {
          html$.Element._defaultSanitizer = new html$._ValidatingTreeSanitizer(validator);
        } else {
          html$.Element._defaultSanitizer.validator = validator;
        }
        treeSanitizer = html$.Element._defaultSanitizer;
      } else if (validator != null) {
        dart.throw(new core.ArgumentError('validator can only be passed if treeSanitizer is null'));
      }
      if (html$.Element._parseDocument == null) {
        html$.Element._parseDocument = html$.document[dartx.implementation][dartx.createHtmlDocument]('');
        html$.Element._parseRange = html$.Element._parseDocument[dartx.createRange]();
        let base = html$.BaseElement._check(html$.Element._parseDocument[dartx.createElement]('base'));
        base[dartx.href] = html$.document[dartx.baseUri];
        html$.Element._parseDocument[dartx.head][dartx.append](base);
      }
      let contextElement = null;
      if (html$.BodyElement.is(this)) {
        contextElement = html$.Element._parseDocument[dartx.body];
      } else {
        contextElement = html$.Element._parseDocument[dartx.createElement](this[dartx.tagName]);
        html$.Element._parseDocument[dartx.body][dartx.append](html$.Node._check(contextElement));
      }
      let fragment = null;
      if (dart.test(html$.Range.supportsCreateContextualFragment) && dart.test(this[_canBeUsedToCreateContextualFragment])) {
        html$.Element._parseRange[dartx.selectNodeContents](html$.Node._check(contextElement));
        fragment = html$.Element._parseRange[dartx.createContextualFragment](html);
      } else {
        dart.dput(contextElement, _innerHtml, html);
        fragment = html$.Element._parseDocument[dartx.createDocumentFragment]();
        while (dart.dload(contextElement, 'firstChild') != null) {
          dart.dsend(fragment, 'append', dart.dload(contextElement, 'firstChild'));
        }
      }
      if (!dart.equals(contextElement, html$.Element._parseDocument[dartx.body])) {
        dart.dsend(contextElement, 'remove');
      }
      treeSanitizer.sanitizeTree(html$.Node._check(fragment));
      html$.document[dartx.adoptNode](html$.Node._check(fragment));
      return html$.DocumentFragment._check(fragment);
    }
    get [_canBeUsedToCreateContextualFragment]() {
      return !dart.test(this[_cannotBeUsedToCreateContextualFragment]);
    }
    get [_cannotBeUsedToCreateContextualFragment]() {
      return html$.Element._tagsForWhichCreateContextualFragmentIsNotSupported[dartx.contains](this[dartx.tagName]);
    }
    set [dartx.innerHtml](html) {
      this[dartx.setInnerHtml](html);
    }
    [dartx.setInnerHtml](html, opts) {
      let validator = opts && 'validator' in opts ? opts.validator : null;
      let treeSanitizer = opts && 'treeSanitizer' in opts ? opts.treeSanitizer : null;
      this[dartx.text] = null;
      if (html$._TrustedHtmlTreeSanitizer.is(treeSanitizer)) {
        this[_innerHtml] = html;
      } else {
        this[dartx.append](this[dartx.createFragment](html, {validator: validator, treeSanitizer: treeSanitizer}));
      }
    }
    get [dartx.innerHtml]() {
      return this[_innerHtml];
    }
    get [dartx.on]() {
      return new html$.ElementEvents(this);
    }
    static _hasCorruptedAttributes(element) {
      return (function(element) {
        if (!(element.attributes instanceof NamedNodeMap)) {
          return true;
        }
        var childNodes = element.childNodes;
        if (element.lastChild && element.lastChild !== childNodes[childNodes.length - 1]) {
          return true;
        }
        if (element.children) {
          if (!(element.children instanceof HTMLCollection || element.children instanceof NodeList)) {
            return true;
          }
        }
        var length = 0;
        if (element.children) {
          length = element.children.length;
        }
        for (var i = 0; i < length; i++) {
          var child = element.children[i];
          if (child.id == 'attributes' || child.name == 'attributes' || child.id == 'lastChild' || child.name == 'lastChild' || child.id == 'children' || child.name == 'children') {
            return true;
          }
        }
        return false;
      })(element);
    }
    static _hasCorruptedAttributesAdditionalCheck(element) {
      return !(element.attributes instanceof NamedNodeMap);
    }
    static _safeTagName(element) {
      let result = 'element tag unavailable';
      try {
        if (typeof dart.dload(element, 'tagName') == 'string') {
          result = core.String._check(dart.dload(element, 'tagName'));
        }
      } catch (e) {
      }

      return result;
    }
    get [dartx.offsetParent]() {
      return this.offsetParent;
    }
    get [dartx.offsetHeight]() {
      return this.offsetHeight[dartx.round]();
    }
    get [dartx.offsetLeft]() {
      return this.offsetLeft[dartx.round]();
    }
    get [dartx.offsetTop]() {
      return this.offsetTop[dartx.round]();
    }
    get [dartx.offsetWidth]() {
      return this.offsetWidth[dartx.round]();
    }
    get [dartx.scrollHeight]() {
      return this.scrollHeight[dartx.round]();
    }
    get [dartx.scrollLeft]() {
      return this.scrollLeft[dartx.round]();
    }
    set [dartx.scrollLeft](value) {
      this.scrollLeft = value[dartx.round]();
    }
    get [dartx.scrollTop]() {
      return this.scrollTop[dartx.round]();
    }
    set [dartx.scrollTop](value) {
      this.scrollTop = value[dartx.round]();
    }
    get [dartx.scrollWidth]() {
      return this.scrollWidth[dartx.round]();
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.contentEditable]() {
      return this.contentEditable;
    }
    set [dartx.contentEditable](value) {
      this.contentEditable = value;
    }
    get [dartx.contextMenu]() {
      return this.contextMenu;
    }
    set [dartx.contextMenu](value) {
      this.contextMenu = value;
    }
    get [dartx.dir]() {
      return this.dir;
    }
    set [dartx.dir](value) {
      this.dir = value;
    }
    get [dartx.draggable]() {
      return this.draggable;
    }
    set [dartx.draggable](value) {
      this.draggable = value;
    }
    get [dartx.hidden]() {
      return this.hidden;
    }
    set [dartx.hidden](value) {
      this.hidden = value;
    }
    get [dartx.isContentEditable]() {
      return this.isContentEditable;
    }
    get [dartx.lang]() {
      return this.lang;
    }
    set [dartx.lang](value) {
      this.lang = value;
    }
    get [dartx.spellcheck]() {
      return this.spellcheck;
    }
    set [dartx.spellcheck](value) {
      this.spellcheck = value;
    }
    get [dartx.style]() {
      return this.style;
    }
    get [dartx.tabIndex]() {
      return this.tabIndex;
    }
    set [dartx.tabIndex](value) {
      this.tabIndex = value;
    }
    get [dartx.title]() {
      return this.title;
    }
    set [dartx.title](value) {
      this.title = value;
    }
    get [dartx.translate]() {
      return this.translate;
    }
    set [dartx.translate](value) {
      this.translate = value;
    }
    get [dartx.dropzone]() {
      return this.webkitdropzone;
    }
    set [dartx.dropzone](value) {
      this.webkitdropzone = value;
    }
    [dartx.blur]() {
      return this.blur();
    }
    [dartx.click]() {
      return this.click();
    }
    [dartx.focus]() {
      return this.focus();
    }
    get [_attributes$]() {
      return this.attributes;
    }
    get [dartx.className]() {
      return this.className;
    }
    set [dartx.className](value) {
      this.className = value;
    }
    get [dartx.clientHeight]() {
      return this.clientHeight;
    }
    get [dartx.clientLeft]() {
      return this.clientLeft;
    }
    get [dartx.clientTop]() {
      return this.clientTop;
    }
    get [dartx.clientWidth]() {
      return this.clientWidth;
    }
    get [dartx.computedName]() {
      return this.computedName;
    }
    get [dartx.computedRole]() {
      return this.computedRole;
    }
    get [dartx.id]() {
      return this.id;
    }
    set [dartx.id](value) {
      this.id = value;
    }
    get [_innerHtml]() {
      return this.innerHTML;
    }
    set [_innerHtml](value) {
      this.innerHTML = value;
    }
    get [dartx.outerHtml]() {
      return this.outerHTML;
    }
    get [_scrollHeight]() {
      return this.scrollHeight;
    }
    get [_scrollLeft]() {
      return this.scrollLeft;
    }
    set [_scrollLeft](value) {
      this.scrollLeft = value;
    }
    get [_scrollTop]() {
      return this.scrollTop;
    }
    set [_scrollTop](value) {
      this.scrollTop = value;
    }
    get [_scrollWidth]() {
      return this.scrollWidth;
    }
    get [dartx.tagName]() {
      return this.tagName;
    }
    [dartx.closest](selectors) {
      return this.closest(selectors);
    }
    [dartx.getAnimations]() {
      return this.getAnimations();
    }
    [dartx.getAttribute](name) {
      return this.getAttribute(name);
    }
    [dartx.getAttributeNS](namespaceURI, localName) {
      return this.getAttributeNS(namespaceURI, localName);
    }
    [dartx.getBoundingClientRect]() {
      return this.getBoundingClientRect();
    }
    [dartx.getClientRects]() {
      return this.getClientRects();
    }
    [dartx.getDestinationInsertionPoints]() {
      return this.getDestinationInsertionPoints();
    }
    [dartx.getElementsByClassName](classNames) {
      return this.getElementsByClassName(classNames);
    }
    [_getElementsByTagName](localName) {
      return this.getElementsByTagName(localName);
    }
    [_hasAttribute](name) {
      return this.hasAttribute(name);
    }
    [_hasAttributeNS](namespaceURI, localName) {
      return this.hasAttributeNS(namespaceURI, localName);
    }
    [_removeAttribute](name) {
      return this.removeAttribute(name);
    }
    [_removeAttributeNS](namespaceURI, localName) {
      return this.removeAttributeNS(namespaceURI, localName);
    }
    [dartx.requestFullscreen]() {
      return this.requestFullscreen();
    }
    [dartx.requestPointerLock]() {
      return this.requestPointerLock();
    }
    [dartx.scroll](options_OR_x, y) {
      if (options_OR_x === void 0) options_OR_x = null;
      if (y === void 0) y = null;
      if (options_OR_x == null && y == null) {
        this[_scroll_1]();
        return;
      }
      if (core.Map.is(options_OR_x) && y == null) {
        let options_1 = html_common.convertDartToNative_Dictionary(options_OR_x);
        this[_scroll_2](options_1);
        return;
      }
      if (y != null && typeof options_OR_x == 'number') {
        this[_scroll_3](options_OR_x, y);
        return;
      }
      dart.throw(new core.ArgumentError("Incorrect number or type of arguments"));
    }
    [_scroll_1]() {
      return this.scroll();
    }
    [_scroll_2](options) {
      return this.scroll(options);
    }
    [_scroll_3](x, y) {
      return this.scroll(x, y);
    }
    [dartx.scrollBy](options_OR_x, y) {
      if (options_OR_x === void 0) options_OR_x = null;
      if (y === void 0) y = null;
      if (options_OR_x == null && y == null) {
        this[_scrollBy_1]();
        return;
      }
      if (core.Map.is(options_OR_x) && y == null) {
        let options_1 = html_common.convertDartToNative_Dictionary(options_OR_x);
        this[_scrollBy_2](options_1);
        return;
      }
      if (y != null && typeof options_OR_x == 'number') {
        this[_scrollBy_3](options_OR_x, y);
        return;
      }
      dart.throw(new core.ArgumentError("Incorrect number or type of arguments"));
    }
    [_scrollBy_1]() {
      return this.scrollBy();
    }
    [_scrollBy_2](options) {
      return this.scrollBy(options);
    }
    [_scrollBy_3](x, y) {
      return this.scrollBy(x, y);
    }
    [_scrollIntoView](alignWithTop) {
      return this.scrollIntoView(alignWithTop);
    }
    [_scrollIntoViewIfNeeded](centerIfNeeded) {
      return this.scrollIntoViewIfNeeded(centerIfNeeded);
    }
    [dartx.scrollTo](options_OR_x, y) {
      if (options_OR_x === void 0) options_OR_x = null;
      if (y === void 0) y = null;
      if (options_OR_x == null && y == null) {
        this[_scrollTo_1]();
        return;
      }
      if (core.Map.is(options_OR_x) && y == null) {
        let options_1 = html_common.convertDartToNative_Dictionary(options_OR_x);
        this[_scrollTo_2](options_1);
        return;
      }
      if (y != null && typeof options_OR_x == 'number') {
        this[_scrollTo_3](options_OR_x, y);
        return;
      }
      dart.throw(new core.ArgumentError("Incorrect number or type of arguments"));
    }
    [_scrollTo_1]() {
      return this.scrollTo();
    }
    [_scrollTo_2](options) {
      return this.scrollTo(options);
    }
    [_scrollTo_3](x, y) {
      return this.scrollTo(x, y);
    }
    [dartx.setAttribute](name, value) {
      return this.setAttribute(name, value);
    }
    [dartx.setAttributeNS](namespaceURI, name, value) {
      return this.setAttributeNS(namespaceURI, name, value);
    }
    [dartx.after](nodes) {
      return this.after(nodes);
    }
    [dartx.before](nodes) {
      return this.before(nodes);
    }
    get [dartx.nextElementSibling]() {
      return this.nextElementSibling;
    }
    get [dartx.previousElementSibling]() {
      return this.previousElementSibling;
    }
    get [_childElementCount]() {
      return this.childElementCount;
    }
    get [_children]() {
      return this.children;
    }
    get [_firstElementChild]() {
      return this.firstElementChild;
    }
    get [_lastElementChild]() {
      return this.lastElementChild;
    }
    [dartx.querySelector](selectors) {
      return this.querySelector(selectors);
    }
    [_querySelectorAll](selectors) {
      return this.querySelectorAll(selectors);
    }
    get [dartx.onAbort]() {
      return html$.Element.abortEvent.forElement(this);
    }
    get [dartx.onBeforeCopy]() {
      return html$.Element.beforeCopyEvent.forElement(this);
    }
    get [dartx.onBeforeCut]() {
      return html$.Element.beforeCutEvent.forElement(this);
    }
    get [dartx.onBeforePaste]() {
      return html$.Element.beforePasteEvent.forElement(this);
    }
    get [dartx.onBlur]() {
      return html$.Element.blurEvent.forElement(this);
    }
    get [dartx.onCanPlay]() {
      return html$.Element.canPlayEvent.forElement(this);
    }
    get [dartx.onCanPlayThrough]() {
      return html$.Element.canPlayThroughEvent.forElement(this);
    }
    get [dartx.onChange]() {
      return html$.Element.changeEvent.forElement(this);
    }
    get [dartx.onClick]() {
      return html$.Element.clickEvent.forElement(this);
    }
    get [dartx.onContextMenu]() {
      return html$.Element.contextMenuEvent.forElement(this);
    }
    get [dartx.onCopy]() {
      return html$.Element.copyEvent.forElement(this);
    }
    get [dartx.onCut]() {
      return html$.Element.cutEvent.forElement(this);
    }
    get [dartx.onDoubleClick]() {
      return html$.Element.doubleClickEvent.forElement(this);
    }
    get [dartx.onDrag]() {
      return html$.Element.dragEvent.forElement(this);
    }
    get [dartx.onDragEnd]() {
      return html$.Element.dragEndEvent.forElement(this);
    }
    get [dartx.onDragEnter]() {
      return html$.Element.dragEnterEvent.forElement(this);
    }
    get [dartx.onDragLeave]() {
      return html$.Element.dragLeaveEvent.forElement(this);
    }
    get [dartx.onDragOver]() {
      return html$.Element.dragOverEvent.forElement(this);
    }
    get [dartx.onDragStart]() {
      return html$.Element.dragStartEvent.forElement(this);
    }
    get [dartx.onDrop]() {
      return html$.Element.dropEvent.forElement(this);
    }
    get [dartx.onDurationChange]() {
      return html$.Element.durationChangeEvent.forElement(this);
    }
    get [dartx.onEmptied]() {
      return html$.Element.emptiedEvent.forElement(this);
    }
    get [dartx.onEnded]() {
      return html$.Element.endedEvent.forElement(this);
    }
    get [dartx.onError]() {
      return html$.Element.errorEvent.forElement(this);
    }
    get [dartx.onFocus]() {
      return html$.Element.focusEvent.forElement(this);
    }
    get [dartx.onInput]() {
      return html$.Element.inputEvent.forElement(this);
    }
    get [dartx.onInvalid]() {
      return html$.Element.invalidEvent.forElement(this);
    }
    get [dartx.onKeyDown]() {
      return html$.Element.keyDownEvent.forElement(this);
    }
    get [dartx.onKeyPress]() {
      return html$.Element.keyPressEvent.forElement(this);
    }
    get [dartx.onKeyUp]() {
      return html$.Element.keyUpEvent.forElement(this);
    }
    get [dartx.onLoad]() {
      return html$.Element.loadEvent.forElement(this);
    }
    get [dartx.onLoadedData]() {
      return html$.Element.loadedDataEvent.forElement(this);
    }
    get [dartx.onLoadedMetadata]() {
      return html$.Element.loadedMetadataEvent.forElement(this);
    }
    get [dartx.onMouseDown]() {
      return html$.Element.mouseDownEvent.forElement(this);
    }
    get [dartx.onMouseEnter]() {
      return html$.Element.mouseEnterEvent.forElement(this);
    }
    get [dartx.onMouseLeave]() {
      return html$.Element.mouseLeaveEvent.forElement(this);
    }
    get [dartx.onMouseMove]() {
      return html$.Element.mouseMoveEvent.forElement(this);
    }
    get [dartx.onMouseOut]() {
      return html$.Element.mouseOutEvent.forElement(this);
    }
    get [dartx.onMouseOver]() {
      return html$.Element.mouseOverEvent.forElement(this);
    }
    get [dartx.onMouseUp]() {
      return html$.Element.mouseUpEvent.forElement(this);
    }
    get [dartx.onMouseWheel]() {
      return html$.Element.mouseWheelEvent.forElement(this);
    }
    get [dartx.onPaste]() {
      return html$.Element.pasteEvent.forElement(this);
    }
    get [dartx.onPause]() {
      return html$.Element.pauseEvent.forElement(this);
    }
    get [dartx.onPlay]() {
      return html$.Element.playEvent.forElement(this);
    }
    get [dartx.onPlaying]() {
      return html$.Element.playingEvent.forElement(this);
    }
    get [dartx.onRateChange]() {
      return html$.Element.rateChangeEvent.forElement(this);
    }
    get [dartx.onReset]() {
      return html$.Element.resetEvent.forElement(this);
    }
    get [dartx.onResize]() {
      return html$.Element.resizeEvent.forElement(this);
    }
    get [dartx.onScroll]() {
      return html$.Element.scrollEvent.forElement(this);
    }
    get [dartx.onSearch]() {
      return html$.Element.searchEvent.forElement(this);
    }
    get [dartx.onSeeked]() {
      return html$.Element.seekedEvent.forElement(this);
    }
    get [dartx.onSeeking]() {
      return html$.Element.seekingEvent.forElement(this);
    }
    get [dartx.onSelect]() {
      return html$.Element.selectEvent.forElement(this);
    }
    get [dartx.onSelectStart]() {
      return html$.Element.selectStartEvent.forElement(this);
    }
    get [dartx.onStalled]() {
      return html$.Element.stalledEvent.forElement(this);
    }
    get [dartx.onSubmit]() {
      return html$.Element.submitEvent.forElement(this);
    }
    get [dartx.onSuspend]() {
      return html$.Element.suspendEvent.forElement(this);
    }
    get [dartx.onTimeUpdate]() {
      return html$.Element.timeUpdateEvent.forElement(this);
    }
    get [dartx.onTouchCancel]() {
      return html$.Element.touchCancelEvent.forElement(this);
    }
    get [dartx.onTouchEnd]() {
      return html$.Element.touchEndEvent.forElement(this);
    }
    get [dartx.onTouchEnter]() {
      return html$.Element.touchEnterEvent.forElement(this);
    }
    get [dartx.onTouchLeave]() {
      return html$.Element.touchLeaveEvent.forElement(this);
    }
    get [dartx.onTouchMove]() {
      return html$.Element.touchMoveEvent.forElement(this);
    }
    get [dartx.onTouchStart]() {
      return html$.Element.touchStartEvent.forElement(this);
    }
    get [dartx.onTransitionEnd]() {
      return html$.Element.transitionEndEvent.forElement(this);
    }
    get [dartx.onVolumeChange]() {
      return html$.Element.volumeChangeEvent.forElement(this);
    }
    get [dartx.onWaiting]() {
      return html$.Element.waitingEvent.forElement(this);
    }
    get [dartx.onFullscreenChange]() {
      return html$.Element.fullscreenChangeEvent.forElement(this);
    }
    get [dartx.onFullscreenError]() {
      return html$.Element.fullscreenErrorEvent.forElement(this);
    }
  };
  dart.defineNamedConstructor(html$.Element, 'created');
  html$.Element[dart.implements] = () => [html$.NonDocumentTypeChildNode, html$.GlobalEventHandlers, html$.ParentNode, html$.ChildNode];
  dart.setSignature(html$.Element, {
    constructors: () => ({
      html: dart.definiteFunctionType(html$.Element, [core.String], {validator: html$.NodeValidator, treeSanitizer: html$.NodeTreeSanitizer}),
      created: dart.definiteFunctionType(html$.Element, []),
      tag: dart.definiteFunctionType(html$.Element, [core.String], [core.String]),
      a: dart.definiteFunctionType(html$.Element, []),
      article: dart.definiteFunctionType(html$.Element, []),
      aside: dart.definiteFunctionType(html$.Element, []),
      audio: dart.definiteFunctionType(html$.Element, []),
      br: dart.definiteFunctionType(html$.Element, []),
      canvas: dart.definiteFunctionType(html$.Element, []),
      div: dart.definiteFunctionType(html$.Element, []),
      footer: dart.definiteFunctionType(html$.Element, []),
      header: dart.definiteFunctionType(html$.Element, []),
      hr: dart.definiteFunctionType(html$.Element, []),
      iframe: dart.definiteFunctionType(html$.Element, []),
      img: dart.definiteFunctionType(html$.Element, []),
      li: dart.definiteFunctionType(html$.Element, []),
      nav: dart.definiteFunctionType(html$.Element, []),
      ol: dart.definiteFunctionType(html$.Element, []),
      option: dart.definiteFunctionType(html$.Element, []),
      p: dart.definiteFunctionType(html$.Element, []),
      pre: dart.definiteFunctionType(html$.Element, []),
      section: dart.definiteFunctionType(html$.Element, []),
      select: dart.definiteFunctionType(html$.Element, []),
      span: dart.definiteFunctionType(html$.Element, []),
      svg: dart.definiteFunctionType(html$.Element, []),
      table: dart.definiteFunctionType(html$.Element, []),
      td: dart.definiteFunctionType(html$.Element, []),
      textarea: dart.definiteFunctionType(html$.Element, []),
      th: dart.definiteFunctionType(html$.Element, []),
      tr: dart.definiteFunctionType(html$.Element, []),
      ul: dart.definiteFunctionType(html$.Element, []),
      video: dart.definiteFunctionType(html$.Element, []),
      _: dart.definiteFunctionType(html$.Element, [])
    }),
    methods: () => ({
      [dartx.querySelectorAll]: dart.definiteFunctionType(T => [html$.ElementList$(T), [core.String]]),
      [dartx.query]: dart.definiteFunctionType(html$.Element, [core.String]),
      [dartx.queryAll]: dart.definiteFunctionType(T => [html$.ElementList$(T), [core.String]]),
      [dartx.getNamespacedAttributes]: dart.definiteFunctionType(core.Map$(core.String, core.String), [core.String]),
      [dartx.getComputedStyle]: dart.definiteFunctionType(html$.CssStyleDeclaration, [], [core.String]),
      [dartx.appendText]: dart.definiteFunctionType(dart.void, [core.String]),
      [dartx.appendHtml]: dart.definiteFunctionType(dart.void, [core.String], {validator: html$.NodeValidator, treeSanitizer: html$.NodeTreeSanitizer}),
      [dartx.attached]: dart.definiteFunctionType(dart.void, []),
      [dartx.detached]: dart.definiteFunctionType(dart.void, []),
      [dartx.enteredView]: dart.definiteFunctionType(dart.void, []),
      [dartx.leftView]: dart.definiteFunctionType(dart.void, []),
      [dartx.animate]: dart.definiteFunctionType(html$.Animation, [core.Iterable$(core.Map$(core.String, dart.dynamic))], [dart.dynamic]),
      [_animate]: dart.definiteFunctionType(html$.Animation, [core.Object], [dart.dynamic]),
      [dartx.attributeChanged]: dart.definiteFunctionType(dart.void, [core.String, core.String, core.String]),
      [dartx.scrollIntoView]: dart.definiteFunctionType(dart.void, [], [html$.ScrollAlignment]),
      [dartx.insertAdjacentText]: dart.definiteFunctionType(dart.void, [core.String, core.String]),
      [_insertAdjacentText]: dart.definiteFunctionType(dart.void, [core.String, core.String]),
      [dartx.insertAdjacentHtml]: dart.definiteFunctionType(dart.void, [core.String, core.String], {validator: html$.NodeValidator, treeSanitizer: html$.NodeTreeSanitizer}),
      [_insertAdjacentHtml]: dart.definiteFunctionType(dart.void, [core.String, core.String]),
      [dartx.insertAdjacentElement]: dart.definiteFunctionType(html$.Element, [core.String, html$.Element]),
      [_insertAdjacentElement]: dart.definiteFunctionType(dart.void, [core.String, html$.Element]),
      [_insertAdjacentNode]: dart.definiteFunctionType(dart.void, [core.String, html$.Node]),
      [dartx.matches]: dart.definiteFunctionType(core.bool, [core.String]),
      [dartx.matchesWithAncestors]: dart.definiteFunctionType(core.bool, [core.String]),
      [dartx.createShadowRoot]: dart.definiteFunctionType(html$.ShadowRoot, []),
      [dartx.offsetTo]: dart.definiteFunctionType(math.Point$(core.num), [html$.Element]),
      [dartx.createFragment]: dart.definiteFunctionType(html$.DocumentFragment, [core.String], {validator: html$.NodeValidator, treeSanitizer: html$.NodeTreeSanitizer}),
      [dartx.setInnerHtml]: dart.definiteFunctionType(dart.void, [core.String], {validator: html$.NodeValidator, treeSanitizer: html$.NodeTreeSanitizer}),
      [dartx.blur]: dart.definiteFunctionType(dart.void, []),
      [dartx.click]: dart.definiteFunctionType(dart.void, []),
      [dartx.focus]: dart.definiteFunctionType(dart.void, []),
      [dartx.closest]: dart.definiteFunctionType(html$.Element, [core.String]),
      [dartx.getAnimations]: dart.definiteFunctionType(core.List$(html$.Animation), []),
      [dartx.getAttribute]: dart.definiteFunctionType(core.String, [core.String]),
      [dartx.getAttributeNS]: dart.definiteFunctionType(core.String, [core.String, core.String]),
      [dartx.getBoundingClientRect]: dart.definiteFunctionType(math.Rectangle$(core.num), []),
      [dartx.getClientRects]: dart.definiteFunctionType(core.List$(math.Rectangle$(core.num)), []),
      [dartx.getDestinationInsertionPoints]: dart.definiteFunctionType(core.List$(html$.Node), []),
      [dartx.getElementsByClassName]: dart.definiteFunctionType(core.List$(html$.Node), [core.String]),
      [_getElementsByTagName]: dart.definiteFunctionType(core.List$(html$.Node), [core.String]),
      [_hasAttribute]: dart.definiteFunctionType(core.bool, [core.String]),
      [_hasAttributeNS]: dart.definiteFunctionType(core.bool, [core.String, core.String]),
      [_removeAttribute]: dart.definiteFunctionType(dart.void, [core.String]),
      [_removeAttributeNS]: dart.definiteFunctionType(dart.void, [core.String, core.String]),
      [dartx.requestFullscreen]: dart.definiteFunctionType(dart.void, []),
      [dartx.requestPointerLock]: dart.definiteFunctionType(dart.void, []),
      [dartx.scroll]: dart.definiteFunctionType(dart.void, [], [dart.dynamic, core.num]),
      [_scroll_1]: dart.definiteFunctionType(dart.void, []),
      [_scroll_2]: dart.definiteFunctionType(dart.void, [dart.dynamic]),
      [_scroll_3]: dart.definiteFunctionType(dart.void, [core.num, dart.dynamic]),
      [dartx.scrollBy]: dart.definiteFunctionType(dart.void, [], [dart.dynamic, core.num]),
      [_scrollBy_1]: dart.definiteFunctionType(dart.void, []),
      [_scrollBy_2]: dart.definiteFunctionType(dart.void, [dart.dynamic]),
      [_scrollBy_3]: dart.definiteFunctionType(dart.void, [core.num, dart.dynamic]),
      [_scrollIntoView]: dart.definiteFunctionType(dart.void, [], [core.bool]),
      [_scrollIntoViewIfNeeded]: dart.definiteFunctionType(dart.void, [], [core.bool]),
      [dartx.scrollTo]: dart.definiteFunctionType(dart.void, [], [dart.dynamic, core.num]),
      [_scrollTo_1]: dart.definiteFunctionType(dart.void, []),
      [_scrollTo_2]: dart.definiteFunctionType(dart.void, [dart.dynamic]),
      [_scrollTo_3]: dart.definiteFunctionType(dart.void, [core.num, dart.dynamic]),
      [dartx.setAttribute]: dart.definiteFunctionType(dart.void, [core.String, core.String]),
      [dartx.setAttributeNS]: dart.definiteFunctionType(dart.void, [core.String, core.String, core.String]),
      [dartx.after]: dart.definiteFunctionType(dart.void, [core.Object]),
      [dartx.before]: dart.definiteFunctionType(dart.void, [core.Object]),
      [dartx.querySelector]: dart.definiteFunctionType(html$.Element, [core.String]),
      [_querySelectorAll]: dart.definiteFunctionType(core.List$(html$.Node), [core.String])
    }),
    statics: () => ({
      isTagSupported: dart.definiteFunctionType(core.bool, [core.String]),
      _determineMouseWheelEventType: dart.definiteFunctionType(core.String, [html$.EventTarget]),
      _determineTransitionEventType: dart.definiteFunctionType(core.String, [html$.EventTarget]),
      _offsetToHelper: dart.definiteFunctionType(math.Point$(core.num), [html$.Element, html$.Element]),
      _hasCorruptedAttributes: dart.definiteFunctionType(core.bool, [html$.Element]),
      _hasCorruptedAttributesAdditionalCheck: dart.definiteFunctionType(core.bool, [html$.Element]),
      _safeTagName: dart.definiteFunctionType(core.String, [dart.dynamic])
    }),
    names: ['isTagSupported', '_determineMouseWheelEventType', '_determineTransitionEventType', '_offsetToHelper', '_hasCorruptedAttributes', '_hasCorruptedAttributesAdditionalCheck', '_safeTagName']
  });
  html$.Element._parseDocument = null;
  html$.Element._parseRange = null;
  html$.Element._defaultValidator = null;
  html$.Element._defaultSanitizer = null;
  html$.Element._tagsForWhichCreateContextualFragmentIsNotSupported = dart.constList(['HEAD', 'AREA', 'BASE', 'BASEFONT', 'BR', 'COL', 'COLGROUP', 'EMBED', 'FRAME', 'FRAMESET', 'HR', 'IMAGE', 'IMG', 'INPUT', 'ISINDEX', 'LINK', 'META', 'PARAM', 'SOURCE', 'STYLE', 'TITLE', 'WBR'], core.String);
  dart.defineLazy(html$.Element, {
    get mouseWheelEvent() {
      return dart.const(new (_CustomEventStreamProviderOfWheelEvent())(html$.Element._determineMouseWheelEventType));
    },
    get transitionEndEvent() {
      return dart.const(new (_CustomEventStreamProviderOfTransitionEvent())(html$.Element._determineTransitionEventType));
    },
    get abortEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('abort'));
    },
    get beforeCopyEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('beforecopy'));
    },
    get beforeCutEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('beforecut'));
    },
    get beforePasteEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('beforepaste'));
    },
    get blurEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('blur'));
    },
    get canPlayEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('canplay'));
    },
    get canPlayThroughEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('canplaythrough'));
    },
    get changeEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('change'));
    },
    get clickEvent() {
      return dart.const(new (EventStreamProviderOfMouseEvent())('click'));
    },
    get contextMenuEvent() {
      return dart.const(new (EventStreamProviderOfMouseEvent())('contextmenu'));
    },
    get copyEvent() {
      return dart.const(new (EventStreamProviderOfClipboardEvent())('copy'));
    },
    get cutEvent() {
      return dart.const(new (EventStreamProviderOfClipboardEvent())('cut'));
    },
    get doubleClickEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('dblclick'));
    },
    get dragEvent() {
      return dart.const(new (EventStreamProviderOfMouseEvent())('drag'));
    },
    get dragEndEvent() {
      return dart.const(new (EventStreamProviderOfMouseEvent())('dragend'));
    },
    get dragEnterEvent() {
      return dart.const(new (EventStreamProviderOfMouseEvent())('dragenter'));
    },
    get dragLeaveEvent() {
      return dart.const(new (EventStreamProviderOfMouseEvent())('dragleave'));
    },
    get dragOverEvent() {
      return dart.const(new (EventStreamProviderOfMouseEvent())('dragover'));
    },
    get dragStartEvent() {
      return dart.const(new (EventStreamProviderOfMouseEvent())('dragstart'));
    },
    get dropEvent() {
      return dart.const(new (EventStreamProviderOfMouseEvent())('drop'));
    },
    get durationChangeEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('durationchange'));
    },
    get emptiedEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('emptied'));
    },
    get endedEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('ended'));
    },
    get errorEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('error'));
    },
    get focusEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('focus'));
    },
    get inputEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('input'));
    },
    get invalidEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('invalid'));
    },
    get keyDownEvent() {
      return dart.const(new (EventStreamProviderOfKeyboardEvent())('keydown'));
    },
    get keyPressEvent() {
      return dart.const(new (EventStreamProviderOfKeyboardEvent())('keypress'));
    },
    get keyUpEvent() {
      return dart.const(new (EventStreamProviderOfKeyboardEvent())('keyup'));
    },
    get loadEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('load'));
    },
    get loadedDataEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('loadeddata'));
    },
    get loadedMetadataEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('loadedmetadata'));
    },
    get mouseDownEvent() {
      return dart.const(new (EventStreamProviderOfMouseEvent())('mousedown'));
    },
    get mouseEnterEvent() {
      return dart.const(new (EventStreamProviderOfMouseEvent())('mouseenter'));
    },
    get mouseLeaveEvent() {
      return dart.const(new (EventStreamProviderOfMouseEvent())('mouseleave'));
    },
    get mouseMoveEvent() {
      return dart.const(new (EventStreamProviderOfMouseEvent())('mousemove'));
    },
    get mouseOutEvent() {
      return dart.const(new (EventStreamProviderOfMouseEvent())('mouseout'));
    },
    get mouseOverEvent() {
      return dart.const(new (EventStreamProviderOfMouseEvent())('mouseover'));
    },
    get mouseUpEvent() {
      return dart.const(new (EventStreamProviderOfMouseEvent())('mouseup'));
    },
    get pasteEvent() {
      return dart.const(new (EventStreamProviderOfClipboardEvent())('paste'));
    },
    get pauseEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('pause'));
    },
    get playEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('play'));
    },
    get playingEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('playing'));
    },
    get rateChangeEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('ratechange'));
    },
    get resetEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('reset'));
    },
    get resizeEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('resize'));
    },
    get scrollEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('scroll'));
    },
    get searchEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('search'));
    },
    get seekedEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('seeked'));
    },
    get seekingEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('seeking'));
    },
    get selectEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('select'));
    },
    get selectStartEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('selectstart'));
    },
    get stalledEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('stalled'));
    },
    get submitEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('submit'));
    },
    get suspendEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('suspend'));
    },
    get timeUpdateEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('timeupdate'));
    },
    get touchCancelEvent() {
      return dart.const(new (EventStreamProviderOfTouchEvent())('touchcancel'));
    },
    get touchEndEvent() {
      return dart.const(new (EventStreamProviderOfTouchEvent())('touchend'));
    },
    get touchEnterEvent() {
      return dart.const(new (EventStreamProviderOfTouchEvent())('touchenter'));
    },
    get touchLeaveEvent() {
      return dart.const(new (EventStreamProviderOfTouchEvent())('touchleave'));
    },
    get touchMoveEvent() {
      return dart.const(new (EventStreamProviderOfTouchEvent())('touchmove'));
    },
    get touchStartEvent() {
      return dart.const(new (EventStreamProviderOfTouchEvent())('touchstart'));
    },
    get volumeChangeEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('volumechange'));
    },
    get waitingEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('waiting'));
    },
    get fullscreenChangeEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('webkitfullscreenchange'));
    },
    get fullscreenErrorEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('webkitfullscreenerror'));
    }
  });
  dart.registerExtension(dart.global.Element, html$.Element);
  html$.HtmlElement = class HtmlElement extends html$.Element {
    static new() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    created() {
      super.created();
    }
  };
  dart.defineNamedConstructor(html$.HtmlElement, 'created');
  dart.setSignature(html$.HtmlElement, {
    constructors: () => ({
      new: dart.definiteFunctionType(html$.HtmlElement, []),
      created: dart.definiteFunctionType(html$.HtmlElement, [])
    })
  });
  dart.registerExtension(dart.global.HTMLElement, html$.HtmlElement);
  html$._EntryArray = class _EntryArray extends core.Object {};
  html$._EntryArray[dart.implements] = () => [ListOfEntry()];
  dart.registerExtension(dart.global.EntryArray, html$._EntryArray);
  html$.spawnDomUri = function(uri, args, message) {
    dart.throw(new core.UnimplementedError());
  };
  dart.fn(html$.spawnDomUri, UriAndListOfStringAnddynamicToFutureOfIsolate());
  html$.createCustomUpgrader = function(customElementClass, $this) {
    return $this;
  };
  dart.fn(html$.createCustomUpgrader, TypeAnddynamicTodynamic());
  dart.defineExtensionNames([
    'onError'
  ]);
  html$.AbstractWorker = class AbstractWorker extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get onError() {
      return html$.AbstractWorker.errorEvent.forTarget(this);
    }
  };
  html$.AbstractWorker[dart.implements] = () => [html$.EventTarget];
  dart.setSignature(html$.AbstractWorker, {
    constructors: () => ({_: dart.definiteFunctionType(html$.AbstractWorker, [])})
  });
  dart.defineExtensionMembers(html$.AbstractWorker, ['onError']);
  dart.defineLazy(html$.AbstractWorker, {
    get errorEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('error'));
    }
  });
  dart.defineExtensionNames([
    'toString',
    'download',
    'hreflang',
    'rel',
    'target',
    'type',
    'hash',
    'host',
    'hostname',
    'href',
    'origin',
    'password',
    'pathname',
    'port',
    'protocol',
    'search',
    'username'
  ]);
  html$.AnchorElement = class AnchorElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(opts) {
      let href = opts && 'href' in opts ? opts.href : null;
      let e = html$.AnchorElement._check(html$.document[dartx.createElement]("a"));
      if (href != null) e[dartx.href] = href;
      return e;
    }
    created() {
      this[dartx.download] = null;
      this[dartx.hreflang] = null;
      this[dartx.rel] = null;
      this[dartx.target] = null;
      this[dartx.type] = null;
      this[dartx.hash] = null;
      this[dartx.host] = null;
      this[dartx.hostname] = null;
      this[dartx.href] = null;
      this[dartx.origin] = null;
      this[dartx.password] = null;
      this[dartx.pathname] = null;
      this[dartx.port] = null;
      this[dartx.protocol] = null;
      this[dartx.search] = null;
      this[dartx.username] = null;
      super.created();
    }
    get [dartx.download]() {
      return this.download;
    }
    set [dartx.download](value) {
      this.download = value;
    }
    get [dartx.hreflang]() {
      return this.hreflang;
    }
    set [dartx.hreflang](value) {
      this.hreflang = value;
    }
    get [dartx.rel]() {
      return this.rel;
    }
    set [dartx.rel](value) {
      this.rel = value;
    }
    get [dartx.target]() {
      return this.target;
    }
    set [dartx.target](value) {
      this.target = value;
    }
    get [dartx.type]() {
      return this.type;
    }
    set [dartx.type](value) {
      this.type = value;
    }
    get [dartx.hash]() {
      return this.hash;
    }
    set [dartx.hash](value) {
      this.hash = value;
    }
    get [dartx.host]() {
      return this.host;
    }
    set [dartx.host](value) {
      this.host = value;
    }
    get [dartx.hostname]() {
      return this.hostname;
    }
    set [dartx.hostname](value) {
      this.hostname = value;
    }
    get [dartx.href]() {
      return this.href;
    }
    set [dartx.href](value) {
      this.href = value;
    }
    get [dartx.origin]() {
      return this.origin;
    }
    get [dartx.password]() {
      return this.password;
    }
    set [dartx.password](value) {
      this.password = value;
    }
    get [dartx.pathname]() {
      return this.pathname;
    }
    set [dartx.pathname](value) {
      this.pathname = value;
    }
    get [dartx.port]() {
      return this.port;
    }
    set [dartx.port](value) {
      this.port = value;
    }
    get [dartx.protocol]() {
      return this.protocol;
    }
    set [dartx.protocol](value) {
      this.protocol = value;
    }
    get [dartx.search]() {
      return this.search;
    }
    set [dartx.search](value) {
      this.search = value;
    }
    get [dartx.username]() {
      return this.username;
    }
    set [dartx.username](value) {
      this.username = value;
    }
    [dartx.toString]() {
      return String(this);
    }
  };
  dart.defineNamedConstructor(html$.AnchorElement, 'created');
  html$.AnchorElement[dart.implements] = () => [html$.UrlUtils];
  dart.setSignature(html$.AnchorElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.AnchorElement, []),
      new: dart.definiteFunctionType(html$.AnchorElement, [], {href: core.String}),
      created: dart.definiteFunctionType(html$.AnchorElement, [])
    })
  });
  dart.registerExtension(dart.global.HTMLAnchorElement, html$.AnchorElement);
  dart.defineExtensionNames([
    'cancel',
    'finish',
    'pause',
    'play',
    'reverse',
    'currentTime',
    'effect',
    'endClip',
    'finished',
    'playState',
    'playbackRate',
    'ready',
    'startClip',
    'startTime'
  ]);
  html$.Animation = class Animation extends html$.EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static get supported() {
      return !!document.body.animate;
    }
    get [dartx.currentTime]() {
      return this.currentTime;
    }
    set [dartx.currentTime](value) {
      this.currentTime = value;
    }
    get [dartx.effect]() {
      return this.effect;
    }
    set [dartx.effect](value) {
      this.effect = value;
    }
    get [dartx.endClip]() {
      return this.endClip;
    }
    set [dartx.endClip](value) {
      this.endClip = value;
    }
    get [dartx.finished]() {
      return this.finished;
    }
    get [dartx.playState]() {
      return this.playState;
    }
    get [dartx.playbackRate]() {
      return this.playbackRate;
    }
    set [dartx.playbackRate](value) {
      this.playbackRate = value;
    }
    get [dartx.ready]() {
      return this.ready;
    }
    get [dartx.startClip]() {
      return this.startClip;
    }
    set [dartx.startClip](value) {
      this.startClip = value;
    }
    get [dartx.startTime]() {
      return this.startTime;
    }
    set [dartx.startTime](value) {
      this.startTime = value;
    }
    [dartx.cancel]() {
      return this.cancel();
    }
    [dartx.finish]() {
      return this.finish();
    }
    [dartx.pause]() {
      return this.pause();
    }
    [dartx.play]() {
      return this.play();
    }
    [dartx.reverse]() {
      return this.reverse();
    }
  };
  dart.setSignature(html$.Animation, {
    constructors: () => ({_: dart.definiteFunctionType(html$.Animation, [])}),
    methods: () => ({
      [dartx.cancel]: dart.definiteFunctionType(dart.void, []),
      [dartx.finish]: dart.definiteFunctionType(dart.void, []),
      [dartx.pause]: dart.definiteFunctionType(dart.void, []),
      [dartx.play]: dart.definiteFunctionType(dart.void, []),
      [dartx.reverse]: dart.definiteFunctionType(dart.void, [])
    })
  });
  dart.registerExtension(dart.global.Animation, html$.Animation);
  const _get_computedTiming = Symbol('_get_computedTiming');
  dart.defineExtensionNames([
    'computedTiming',
    'timing'
  ]);
  html$.AnimationEffectReadOnly = class AnimationEffectReadOnly extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.computedTiming]() {
      return html_common.convertNativeToDart_Dictionary(this[_get_computedTiming]);
    }
    get [_get_computedTiming]() {
      return this.computedTiming;
    }
    get [dartx.timing]() {
      return this.timing;
    }
  };
  dart.setSignature(html$.AnimationEffectReadOnly, {
    constructors: () => ({_: dart.definiteFunctionType(html$.AnimationEffectReadOnly, [])})
  });
  dart.registerExtension(dart.global.AnimationEffectReadOnly, html$.AnimationEffectReadOnly);
  dart.defineExtensionNames([
    'delay',
    'direction',
    'duration',
    'easing',
    'endDelay',
    'fill',
    'iterationStart',
    'iterations',
    'playbackRate'
  ]);
  html$.AnimationEffectTiming = class AnimationEffectTiming extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.delay]() {
      return this.delay;
    }
    set [dartx.delay](value) {
      this.delay = value;
    }
    get [dartx.direction]() {
      return this.direction;
    }
    set [dartx.direction](value) {
      this.direction = value;
    }
    get [dartx.duration]() {
      return this.duration;
    }
    set [dartx.duration](value) {
      this.duration = value;
    }
    get [dartx.easing]() {
      return this.easing;
    }
    set [dartx.easing](value) {
      this.easing = value;
    }
    get [dartx.endDelay]() {
      return this.endDelay;
    }
    set [dartx.endDelay](value) {
      this.endDelay = value;
    }
    get [dartx.fill]() {
      return this.fill;
    }
    set [dartx.fill](value) {
      this.fill = value;
    }
    get [dartx.iterationStart]() {
      return this.iterationStart;
    }
    set [dartx.iterationStart](value) {
      this.iterationStart = value;
    }
    get [dartx.iterations]() {
      return this.iterations;
    }
    set [dartx.iterations](value) {
      this.iterations = value;
    }
    get [dartx.playbackRate]() {
      return this.playbackRate;
    }
    set [dartx.playbackRate](value) {
      this.playbackRate = value;
    }
  };
  dart.setSignature(html$.AnimationEffectTiming, {
    constructors: () => ({_: dart.definiteFunctionType(html$.AnimationEffectTiming, [])})
  });
  dart.registerExtension(dart.global.AnimationEffectTiming, html$.AnimationEffectTiming);
  dart.defineExtensionNames([
    'animationName',
    'elapsedTime'
  ]);
  html$.AnimationEvent = class AnimationEvent extends html$.Event {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(type, eventInitDict) {
      if (eventInitDict === void 0) eventInitDict = null;
      if (eventInitDict != null) {
        let eventInitDict_1 = html_common.convertDartToNative_Dictionary(eventInitDict);
        return html$.AnimationEvent._create_1(type, eventInitDict_1);
      }
      return html$.AnimationEvent._create_2(type);
    }
    static _create_1(type, eventInitDict) {
      return new AnimationEvent(type, eventInitDict);
    }
    static _create_2(type) {
      return new AnimationEvent(type);
    }
    get [dartx.animationName]() {
      return this.animationName;
    }
    get [dartx.elapsedTime]() {
      return this.elapsedTime;
    }
  };
  dart.setSignature(html$.AnimationEvent, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.AnimationEvent, []),
      new: dart.definiteFunctionType(html$.AnimationEvent, [core.String], [core.Map])
    }),
    statics: () => ({
      _create_1: dart.definiteFunctionType(html$.AnimationEvent, [dart.dynamic, dart.dynamic]),
      _create_2: dart.definiteFunctionType(html$.AnimationEvent, [dart.dynamic])
    }),
    names: ['_create_1', '_create_2']
  });
  dart.registerExtension(dart.global.AnimationEvent, html$.AnimationEvent);
  dart.defineExtensionNames([
    'currentTime',
    'timelineTime'
  ]);
  html$.AnimationPlayerEvent = class AnimationPlayerEvent extends html$.Event {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(type, eventInitDict) {
      if (eventInitDict === void 0) eventInitDict = null;
      if (eventInitDict != null) {
        let eventInitDict_1 = html_common.convertDartToNative_Dictionary(eventInitDict);
        return html$.AnimationPlayerEvent._create_1(type, eventInitDict_1);
      }
      return html$.AnimationPlayerEvent._create_2(type);
    }
    static _create_1(type, eventInitDict) {
      return new AnimationPlayerEvent(type, eventInitDict);
    }
    static _create_2(type) {
      return new AnimationPlayerEvent(type);
    }
    get [dartx.currentTime]() {
      return this.currentTime;
    }
    get [dartx.timelineTime]() {
      return this.timelineTime;
    }
  };
  dart.setSignature(html$.AnimationPlayerEvent, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.AnimationPlayerEvent, []),
      new: dart.definiteFunctionType(html$.AnimationPlayerEvent, [core.String], [core.Map])
    }),
    statics: () => ({
      _create_1: dart.definiteFunctionType(html$.AnimationPlayerEvent, [dart.dynamic, dart.dynamic]),
      _create_2: dart.definiteFunctionType(html$.AnimationPlayerEvent, [dart.dynamic])
    }),
    names: ['_create_1', '_create_2']
  });
  dart.registerExtension(dart.global.AnimationPlayerEvent, html$.AnimationPlayerEvent);
  dart.defineExtensionNames([
    'getAnimations',
    'play',
    'currentTime',
    'playbackRate'
  ]);
  html$.AnimationTimeline = class AnimationTimeline extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.currentTime]() {
      return this.currentTime;
    }
    set [dartx.currentTime](value) {
      this.currentTime = value;
    }
    get [dartx.playbackRate]() {
      return this.playbackRate;
    }
    set [dartx.playbackRate](value) {
      this.playbackRate = value;
    }
    [dartx.getAnimations]() {
      return this.getAnimations();
    }
    [dartx.play](source) {
      return this.play(source);
    }
  };
  dart.setSignature(html$.AnimationTimeline, {
    constructors: () => ({_: dart.definiteFunctionType(html$.AnimationTimeline, [])}),
    methods: () => ({
      [dartx.getAnimations]: dart.definiteFunctionType(core.List$(html$.Animation), []),
      [dartx.play]: dart.definiteFunctionType(html$.Animation, [html$.AnimationEffectReadOnly])
    })
  });
  dart.registerExtension(dart.global.AnimationTimeline, html$.AnimationTimeline);
  dart.defineExtensionNames([
    'outcome',
    'platform'
  ]);
  html$.AppBannerPromptResult = class AppBannerPromptResult extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.outcome]() {
      return this.outcome;
    }
    get [dartx.platform]() {
      return this.platform;
    }
  };
  dart.setSignature(html$.AppBannerPromptResult, {
    constructors: () => ({_: dart.definiteFunctionType(html$.AppBannerPromptResult, [])})
  });
  dart.registerExtension(dart.global.AppBannerPromptResult, html$.AppBannerPromptResult);
  dart.defineExtensionNames([
    'abort',
    'swapCache',
    'update',
    'onCached',
    'onChecking',
    'onDownloading',
    'onError',
    'onNoUpdate',
    'onObsolete',
    'onProgress',
    'onUpdateReady',
    'status'
  ]);
  html$.ApplicationCache = class ApplicationCache extends html$.EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static get supported() {
      return !!window.applicationCache;
    }
    get [dartx.status]() {
      return this.status;
    }
    [dartx.abort]() {
      return this.abort();
    }
    [dartx.swapCache]() {
      return this.swapCache();
    }
    [dartx.update]() {
      return this.update();
    }
    get [dartx.onCached]() {
      return html$.ApplicationCache.cachedEvent.forTarget(this);
    }
    get [dartx.onChecking]() {
      return html$.ApplicationCache.checkingEvent.forTarget(this);
    }
    get [dartx.onDownloading]() {
      return html$.ApplicationCache.downloadingEvent.forTarget(this);
    }
    get [dartx.onError]() {
      return html$.ApplicationCache.errorEvent.forTarget(this);
    }
    get [dartx.onNoUpdate]() {
      return html$.ApplicationCache.noUpdateEvent.forTarget(this);
    }
    get [dartx.onObsolete]() {
      return html$.ApplicationCache.obsoleteEvent.forTarget(this);
    }
    get [dartx.onProgress]() {
      return html$.ApplicationCache.progressEvent.forTarget(this);
    }
    get [dartx.onUpdateReady]() {
      return html$.ApplicationCache.updateReadyEvent.forTarget(this);
    }
  };
  dart.setSignature(html$.ApplicationCache, {
    constructors: () => ({_: dart.definiteFunctionType(html$.ApplicationCache, [])}),
    methods: () => ({
      [dartx.abort]: dart.definiteFunctionType(dart.void, []),
      [dartx.swapCache]: dart.definiteFunctionType(dart.void, []),
      [dartx.update]: dart.definiteFunctionType(dart.void, [])
    })
  });
  html$.ApplicationCache.CHECKING = 2;
  html$.ApplicationCache.DOWNLOADING = 3;
  html$.ApplicationCache.IDLE = 1;
  html$.ApplicationCache.OBSOLETE = 5;
  html$.ApplicationCache.UNCACHED = 0;
  html$.ApplicationCache.UPDATEREADY = 4;
  dart.defineLazy(html$.ApplicationCache, {
    get cachedEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('cached'));
    },
    get checkingEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('checking'));
    },
    get downloadingEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('downloading'));
    },
    get errorEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('error'));
    },
    get noUpdateEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('noupdate'));
    },
    get obsoleteEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('obsolete'));
    },
    get progressEvent() {
      return dart.const(new (EventStreamProviderOfProgressEvent())('progress'));
    },
    get updateReadyEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('updateready'));
    }
  });
  dart.registerExtension(dart.global.ApplicationCache, html$.ApplicationCache);
  dart.defineExtensionNames([
    'message',
    'reason',
    'status',
    'url'
  ]);
  html$.ApplicationCacheErrorEvent = class ApplicationCacheErrorEvent extends html$.Event {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(type, eventInitDict) {
      if (eventInitDict === void 0) eventInitDict = null;
      if (eventInitDict != null) {
        let eventInitDict_1 = html_common.convertDartToNative_Dictionary(eventInitDict);
        return html$.ApplicationCacheErrorEvent._create_1(type, eventInitDict_1);
      }
      return html$.ApplicationCacheErrorEvent._create_2(type);
    }
    static _create_1(type, eventInitDict) {
      return new ApplicationCacheErrorEvent(type, eventInitDict);
    }
    static _create_2(type) {
      return new ApplicationCacheErrorEvent(type);
    }
    get [dartx.message]() {
      return this.message;
    }
    get [dartx.reason]() {
      return this.reason;
    }
    get [dartx.status]() {
      return this.status;
    }
    get [dartx.url]() {
      return this.url;
    }
  };
  dart.setSignature(html$.ApplicationCacheErrorEvent, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.ApplicationCacheErrorEvent, []),
      new: dart.definiteFunctionType(html$.ApplicationCacheErrorEvent, [core.String], [core.Map])
    }),
    statics: () => ({
      _create_1: dart.definiteFunctionType(html$.ApplicationCacheErrorEvent, [dart.dynamic, dart.dynamic]),
      _create_2: dart.definiteFunctionType(html$.ApplicationCacheErrorEvent, [dart.dynamic])
    }),
    names: ['_create_1', '_create_2']
  });
  dart.registerExtension(dart.global.ApplicationCacheErrorEvent, html$.ApplicationCacheErrorEvent);
  dart.defineExtensionNames([
    'toString',
    'alt',
    'coords',
    'shape',
    'target',
    'hash',
    'host',
    'hostname',
    'href',
    'origin',
    'password',
    'pathname',
    'port',
    'protocol',
    'search',
    'username'
  ]);
  html$.AreaElement = class AreaElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return html$.AreaElement._check(html$.document[dartx.createElement]("area"));
    }
    created() {
      this[dartx.alt] = null;
      this[dartx.coords] = null;
      this[dartx.shape] = null;
      this[dartx.target] = null;
      this[dartx.hash] = null;
      this[dartx.host] = null;
      this[dartx.hostname] = null;
      this[dartx.href] = null;
      this[dartx.origin] = null;
      this[dartx.password] = null;
      this[dartx.pathname] = null;
      this[dartx.port] = null;
      this[dartx.protocol] = null;
      this[dartx.search] = null;
      this[dartx.username] = null;
      super.created();
    }
    get [dartx.alt]() {
      return this.alt;
    }
    set [dartx.alt](value) {
      this.alt = value;
    }
    get [dartx.coords]() {
      return this.coords;
    }
    set [dartx.coords](value) {
      this.coords = value;
    }
    get [dartx.shape]() {
      return this.shape;
    }
    set [dartx.shape](value) {
      this.shape = value;
    }
    get [dartx.target]() {
      return this.target;
    }
    set [dartx.target](value) {
      this.target = value;
    }
    get [dartx.hash]() {
      return this.hash;
    }
    set [dartx.hash](value) {
      this.hash = value;
    }
    get [dartx.host]() {
      return this.host;
    }
    set [dartx.host](value) {
      this.host = value;
    }
    get [dartx.hostname]() {
      return this.hostname;
    }
    set [dartx.hostname](value) {
      this.hostname = value;
    }
    get [dartx.href]() {
      return this.href;
    }
    set [dartx.href](value) {
      this.href = value;
    }
    get [dartx.origin]() {
      return this.origin;
    }
    get [dartx.password]() {
      return this.password;
    }
    set [dartx.password](value) {
      this.password = value;
    }
    get [dartx.pathname]() {
      return this.pathname;
    }
    set [dartx.pathname](value) {
      this.pathname = value;
    }
    get [dartx.port]() {
      return this.port;
    }
    set [dartx.port](value) {
      this.port = value;
    }
    get [dartx.protocol]() {
      return this.protocol;
    }
    set [dartx.protocol](value) {
      this.protocol = value;
    }
    get [dartx.search]() {
      return this.search;
    }
    set [dartx.search](value) {
      this.search = value;
    }
    get [dartx.username]() {
      return this.username;
    }
    set [dartx.username](value) {
      this.username = value;
    }
    [dartx.toString]() {
      return String(this);
    }
  };
  dart.defineNamedConstructor(html$.AreaElement, 'created');
  html$.AreaElement[dart.implements] = () => [html$.UrlUtils];
  dart.setSignature(html$.AreaElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.AreaElement, []),
      new: dart.definiteFunctionType(html$.AreaElement, []),
      created: dart.definiteFunctionType(html$.AreaElement, [])
    })
  });
  dart.registerExtension(dart.global.HTMLAreaElement, html$.AreaElement);
  dart.defineExtensionNames([
    'addTextTrack',
    'canPlayType',
    'load',
    'pause',
    'play',
    'setMediaKeys',
    'setSinkId',
    'addKey',
    'cancelKeyRequest',
    'generateKeyRequest',
    'onKeyAdded',
    'onKeyError',
    'onKeyMessage',
    'onNeedKey',
    'audioTracks',
    'autoplay',
    'buffered',
    'controller',
    'controls',
    'crossOrigin',
    'currentSrc',
    'currentTime',
    'defaultMuted',
    'defaultPlaybackRate',
    'duration',
    'ended',
    'error',
    'loop',
    'mediaGroup',
    'mediaKeys',
    'muted',
    'networkState',
    'paused',
    'playbackRate',
    'played',
    'preload',
    'readyState',
    'seekable',
    'seeking',
    'session',
    'sinkId',
    'src',
    'textTracks',
    'videoTracks',
    'volume',
    'audioDecodedByteCount',
    'videoDecodedByteCount'
  ]);
  html$.MediaElement = class MediaElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    created() {
      this[dartx.audioTracks] = null;
      this[dartx.autoplay] = null;
      this[dartx.buffered] = null;
      this[dartx.controller] = null;
      this[dartx.controls] = null;
      this[dartx.crossOrigin] = null;
      this[dartx.currentSrc] = null;
      this[dartx.currentTime] = null;
      this[dartx.defaultMuted] = null;
      this[dartx.defaultPlaybackRate] = null;
      this[dartx.duration] = null;
      this[dartx.ended] = null;
      this[dartx.error] = null;
      this[dartx.loop] = null;
      this[dartx.mediaGroup] = null;
      this[dartx.mediaKeys] = null;
      this[dartx.muted] = null;
      this[dartx.networkState] = null;
      this[dartx.paused] = null;
      this[dartx.playbackRate] = null;
      this[dartx.played] = null;
      this[dartx.preload] = null;
      this[dartx.readyState] = null;
      this[dartx.seekable] = null;
      this[dartx.seeking] = null;
      this[dartx.session] = null;
      this[dartx.sinkId] = null;
      this[dartx.src] = null;
      this[dartx.textTracks] = null;
      this[dartx.videoTracks] = null;
      this[dartx.volume] = null;
      this[dartx.audioDecodedByteCount] = null;
      this[dartx.videoDecodedByteCount] = null;
      super.created();
    }
    get [dartx.audioTracks]() {
      return this.audioTracks;
    }
    get [dartx.autoplay]() {
      return this.autoplay;
    }
    set [dartx.autoplay](value) {
      this.autoplay = value;
    }
    get [dartx.buffered]() {
      return this.buffered;
    }
    get [dartx.controller]() {
      return this.controller;
    }
    set [dartx.controller](value) {
      this.controller = value;
    }
    get [dartx.controls]() {
      return this.controls;
    }
    set [dartx.controls](value) {
      this.controls = value;
    }
    get [dartx.crossOrigin]() {
      return this.crossOrigin;
    }
    set [dartx.crossOrigin](value) {
      this.crossOrigin = value;
    }
    get [dartx.currentSrc]() {
      return this.currentSrc;
    }
    get [dartx.currentTime]() {
      return this.currentTime;
    }
    set [dartx.currentTime](value) {
      this.currentTime = value;
    }
    get [dartx.defaultMuted]() {
      return this.defaultMuted;
    }
    set [dartx.defaultMuted](value) {
      this.defaultMuted = value;
    }
    get [dartx.defaultPlaybackRate]() {
      return this.defaultPlaybackRate;
    }
    set [dartx.defaultPlaybackRate](value) {
      this.defaultPlaybackRate = value;
    }
    get [dartx.duration]() {
      return this.duration;
    }
    get [dartx.ended]() {
      return this.ended;
    }
    get [dartx.error]() {
      return this.error;
    }
    get [dartx.loop]() {
      return this.loop;
    }
    set [dartx.loop](value) {
      this.loop = value;
    }
    get [dartx.mediaGroup]() {
      return this.mediaGroup;
    }
    set [dartx.mediaGroup](value) {
      this.mediaGroup = value;
    }
    get [dartx.mediaKeys]() {
      return this.mediaKeys;
    }
    get [dartx.muted]() {
      return this.muted;
    }
    set [dartx.muted](value) {
      this.muted = value;
    }
    get [dartx.networkState]() {
      return this.networkState;
    }
    get [dartx.paused]() {
      return this.paused;
    }
    get [dartx.playbackRate]() {
      return this.playbackRate;
    }
    set [dartx.playbackRate](value) {
      this.playbackRate = value;
    }
    get [dartx.played]() {
      return this.played;
    }
    get [dartx.preload]() {
      return this.preload;
    }
    set [dartx.preload](value) {
      this.preload = value;
    }
    get [dartx.readyState]() {
      return this.readyState;
    }
    get [dartx.seekable]() {
      return this.seekable;
    }
    get [dartx.seeking]() {
      return this.seeking;
    }
    get [dartx.session]() {
      return this.session;
    }
    set [dartx.session](value) {
      this.session = value;
    }
    get [dartx.sinkId]() {
      return this.sinkId;
    }
    get [dartx.src]() {
      return this.src;
    }
    set [dartx.src](value) {
      this.src = value;
    }
    get [dartx.textTracks]() {
      return this.textTracks;
    }
    get [dartx.videoTracks]() {
      return this.videoTracks;
    }
    get [dartx.volume]() {
      return this.volume;
    }
    set [dartx.volume](value) {
      this.volume = value;
    }
    get [dartx.audioDecodedByteCount]() {
      return this.webkitAudioDecodedByteCount;
    }
    get [dartx.videoDecodedByteCount]() {
      return this.webkitVideoDecodedByteCount;
    }
    [dartx.addTextTrack](kind, label, language) {
      return this.addTextTrack(kind, label, language);
    }
    [dartx.canPlayType](type, keySystem) {
      return this.canPlayType(type, keySystem);
    }
    [dartx.load]() {
      return this.load();
    }
    [dartx.pause]() {
      return this.pause();
    }
    [dartx.play]() {
      return this.play();
    }
    [dartx.setMediaKeys](mediaKeys) {
      return this.setMediaKeys(mediaKeys);
    }
    [dartx.setSinkId](sinkId) {
      return this.setSinkId(sinkId);
    }
    [dartx.addKey](keySystem, key, initData, sessionId) {
      return this.webkitAddKey(keySystem, key, initData, sessionId);
    }
    [dartx.cancelKeyRequest](keySystem, sessionId) {
      return this.webkitCancelKeyRequest(keySystem, sessionId);
    }
    [dartx.generateKeyRequest](keySystem, initData) {
      return this.webkitGenerateKeyRequest(keySystem, initData);
    }
    get [dartx.onKeyAdded]() {
      return html$.MediaElement.keyAddedEvent.forElement(this);
    }
    get [dartx.onKeyError]() {
      return html$.MediaElement.keyErrorEvent.forElement(this);
    }
    get [dartx.onKeyMessage]() {
      return html$.MediaElement.keyMessageEvent.forElement(this);
    }
    get [dartx.onNeedKey]() {
      return html$.MediaElement.needKeyEvent.forElement(this);
    }
  };
  dart.defineNamedConstructor(html$.MediaElement, 'created');
  dart.setSignature(html$.MediaElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.MediaElement, []),
      created: dart.definiteFunctionType(html$.MediaElement, [])
    }),
    methods: () => ({
      [dartx.addTextTrack]: dart.definiteFunctionType(html$.TextTrack, [core.String], [core.String, core.String]),
      [dartx.canPlayType]: dart.definiteFunctionType(core.String, [core.String], [core.String]),
      [dartx.load]: dart.definiteFunctionType(dart.void, []),
      [dartx.pause]: dart.definiteFunctionType(dart.void, []),
      [dartx.play]: dart.definiteFunctionType(dart.void, []),
      [dartx.setMediaKeys]: dart.definiteFunctionType(async.Future, [html$.MediaKeys]),
      [dartx.setSinkId]: dart.definiteFunctionType(async.Future, [core.String]),
      [dartx.addKey]: dart.definiteFunctionType(dart.void, [core.String, typed_data.Uint8List], [typed_data.Uint8List, core.String]),
      [dartx.cancelKeyRequest]: dart.definiteFunctionType(dart.void, [core.String, core.String]),
      [dartx.generateKeyRequest]: dart.definiteFunctionType(dart.void, [core.String], [typed_data.Uint8List])
    })
  });
  html$.MediaElement.HAVE_CURRENT_DATA = 2;
  html$.MediaElement.HAVE_ENOUGH_DATA = 4;
  html$.MediaElement.HAVE_FUTURE_DATA = 3;
  html$.MediaElement.HAVE_METADATA = 1;
  html$.MediaElement.HAVE_NOTHING = 0;
  html$.MediaElement.NETWORK_EMPTY = 0;
  html$.MediaElement.NETWORK_IDLE = 1;
  html$.MediaElement.NETWORK_LOADING = 2;
  html$.MediaElement.NETWORK_NO_SOURCE = 3;
  dart.defineLazy(html$.MediaElement, {
    get keyAddedEvent() {
      return dart.const(new (EventStreamProviderOfMediaKeyEvent())('webkitkeyadded'));
    },
    get keyErrorEvent() {
      return dart.const(new (EventStreamProviderOfMediaKeyEvent())('webkitkeyerror'));
    },
    get keyMessageEvent() {
      return dart.const(new (EventStreamProviderOfMediaKeyEvent())('webkitkeymessage'));
    },
    get needKeyEvent() {
      return dart.const(new (EventStreamProviderOfMediaKeyEvent())('webkitneedkey'));
    }
  });
  dart.registerExtension(dart.global.HTMLMediaElement, html$.MediaElement);
  html$.AudioElement = class AudioElement extends html$.MediaElement {
    static _(src) {
      if (src === void 0) src = null;
      if (src != null) {
        return html$.AudioElement._create_1(src);
      }
      return html$.AudioElement._create_2();
    }
    static _create_1(src) {
      return new Audio(src);
    }
    static _create_2() {
      return new Audio();
    }
    created() {
      super.created();
    }
    static new(src) {
      if (src === void 0) src = null;
      return html$.AudioElement._(src);
    }
  };
  dart.defineNamedConstructor(html$.AudioElement, 'created');
  dart.setSignature(html$.AudioElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.AudioElement, [], [core.String]),
      created: dart.definiteFunctionType(html$.AudioElement, []),
      new: dart.definiteFunctionType(html$.AudioElement, [], [core.String])
    }),
    statics: () => ({
      _create_1: dart.definiteFunctionType(html$.AudioElement, [dart.dynamic]),
      _create_2: dart.definiteFunctionType(html$.AudioElement, [])
    }),
    names: ['_create_1', '_create_2']
  });
  dart.registerExtension(dart.global.HTMLAudioElement, html$.AudioElement);
  dart.defineExtensionNames([
    'enabled',
    'id',
    'kind',
    'label',
    'language'
  ]);
  html$.AudioTrack = class AudioTrack extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.enabled]() {
      return this.enabled;
    }
    set [dartx.enabled](value) {
      this.enabled = value;
    }
    get [dartx.id]() {
      return this.id;
    }
    get [dartx.kind]() {
      return this.kind;
    }
    get [dartx.label]() {
      return this.label;
    }
    get [dartx.language]() {
      return this.language;
    }
  };
  dart.setSignature(html$.AudioTrack, {
    constructors: () => ({_: dart.definiteFunctionType(html$.AudioTrack, [])})
  });
  dart.registerExtension(dart.global.AudioTrack, html$.AudioTrack);
  const __getter__ = Symbol('__getter__');
  dart.defineExtensionNames([
    'getTrackById',
    'onChange',
    'length'
  ]);
  html$.AudioTrackList = class AudioTrackList extends html$.EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.length]() {
      return this.length;
    }
    [__getter__](index) {
      return this.__getter__(index);
    }
    [dartx.getTrackById](id) {
      return this.getTrackById(id);
    }
    get [dartx.onChange]() {
      return html$.AudioTrackList.changeEvent.forTarget(this);
    }
  };
  dart.setSignature(html$.AudioTrackList, {
    constructors: () => ({_: dart.definiteFunctionType(html$.AudioTrackList, [])}),
    methods: () => ({
      [__getter__]: dart.definiteFunctionType(html$.AudioTrack, [core.int]),
      [dartx.getTrackById]: dart.definiteFunctionType(html$.AudioTrack, [core.String])
    })
  });
  dart.defineLazy(html$.AudioTrackList, {
    get changeEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('change'));
    }
  });
  dart.registerExtension(dart.global.AudioTrackList, html$.AudioTrackList);
  dart.defineExtensionNames([
    'reason'
  ]);
  html$.AutocompleteErrorEvent = class AutocompleteErrorEvent extends html$.Event {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(type, eventInitDict) {
      if (eventInitDict === void 0) eventInitDict = null;
      if (eventInitDict != null) {
        let eventInitDict_1 = html_common.convertDartToNative_Dictionary(eventInitDict);
        return html$.AutocompleteErrorEvent._create_1(type, eventInitDict_1);
      }
      return html$.AutocompleteErrorEvent._create_2(type);
    }
    static _create_1(type, eventInitDict) {
      return new AutocompleteErrorEvent(type, eventInitDict);
    }
    static _create_2(type) {
      return new AutocompleteErrorEvent(type);
    }
    get [dartx.reason]() {
      return this.reason;
    }
  };
  dart.setSignature(html$.AutocompleteErrorEvent, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.AutocompleteErrorEvent, []),
      new: dart.definiteFunctionType(html$.AutocompleteErrorEvent, [core.String], [core.Map])
    }),
    statics: () => ({
      _create_1: dart.definiteFunctionType(html$.AutocompleteErrorEvent, [dart.dynamic, dart.dynamic]),
      _create_2: dart.definiteFunctionType(html$.AutocompleteErrorEvent, [dart.dynamic])
    }),
    names: ['_create_1', '_create_2']
  });
  dart.registerExtension(dart.global.AutocompleteErrorEvent, html$.AutocompleteErrorEvent);
  html$.BRElement = class BRElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return html$.BRElement._check(html$.document[dartx.createElement]("br"));
    }
    created() {
      super.created();
    }
  };
  dart.defineNamedConstructor(html$.BRElement, 'created');
  dart.setSignature(html$.BRElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.BRElement, []),
      new: dart.definiteFunctionType(html$.BRElement, []),
      created: dart.definiteFunctionType(html$.BRElement, [])
    })
  });
  dart.registerExtension(dart.global.HTMLBRElement, html$.BRElement);
  dart.defineExtensionNames([
    'visible'
  ]);
  html$.BarProp = class BarProp extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.visible]() {
      return this.visible;
    }
  };
  dart.setSignature(html$.BarProp, {
    constructors: () => ({_: dart.definiteFunctionType(html$.BarProp, [])})
  });
  dart.registerExtension(dart.global.BarProp, html$.BarProp);
  dart.defineExtensionNames([
    'href',
    'target'
  ]);
  html$.BaseElement = class BaseElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return html$.BaseElement._check(html$.document[dartx.createElement]("base"));
    }
    created() {
      this[dartx.href] = null;
      this[dartx.target] = null;
      super.created();
    }
    get [dartx.href]() {
      return this.href;
    }
    set [dartx.href](value) {
      this.href = value;
    }
    get [dartx.target]() {
      return this.target;
    }
    set [dartx.target](value) {
      this.target = value;
    }
  };
  dart.defineNamedConstructor(html$.BaseElement, 'created');
  dart.setSignature(html$.BaseElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.BaseElement, []),
      new: dart.definiteFunctionType(html$.BaseElement, []),
      created: dart.definiteFunctionType(html$.BaseElement, [])
    })
  });
  dart.registerExtension(dart.global.HTMLBaseElement, html$.BaseElement);
  dart.defineExtensionNames([
    'charging',
    'chargingTime',
    'dischargingTime',
    'level'
  ]);
  html$.BatteryManager = class BatteryManager extends html$.EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.charging]() {
      return this.charging;
    }
    get [dartx.chargingTime]() {
      return this.chargingTime;
    }
    get [dartx.dischargingTime]() {
      return this.dischargingTime;
    }
    get [dartx.level]() {
      return this.level;
    }
  };
  dart.setSignature(html$.BatteryManager, {
    constructors: () => ({_: dart.definiteFunctionType(html$.BatteryManager, [])})
  });
  dart.registerExtension(dart.global.BatteryManager, html$.BatteryManager);
  dart.defineExtensionNames([
    'platforms',
    'prompt',
    'userChoice'
  ]);
  html$.BeforeInstallPromptEvent = class BeforeInstallPromptEvent extends html$.Event {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(type, eventInitDict) {
      if (eventInitDict === void 0) eventInitDict = null;
      if (eventInitDict != null) {
        let eventInitDict_1 = html_common.convertDartToNative_Dictionary(eventInitDict);
        return html$.BeforeInstallPromptEvent._create_1(type, eventInitDict_1);
      }
      return html$.BeforeInstallPromptEvent._create_2(type);
    }
    static _create_1(type, eventInitDict) {
      return new BeforeInstallPromptEvent(type, eventInitDict);
    }
    static _create_2(type) {
      return new BeforeInstallPromptEvent(type);
    }
    get [dartx.platforms]() {
      return this.platforms;
    }
    get [dartx.userChoice]() {
      return this.userChoice;
    }
    [dartx.prompt]() {
      return this.prompt();
    }
  };
  dart.setSignature(html$.BeforeInstallPromptEvent, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.BeforeInstallPromptEvent, []),
      new: dart.definiteFunctionType(html$.BeforeInstallPromptEvent, [core.String], [core.Map])
    }),
    methods: () => ({[dartx.prompt]: dart.definiteFunctionType(async.Future, [])}),
    statics: () => ({
      _create_1: dart.definiteFunctionType(html$.BeforeInstallPromptEvent, [dart.dynamic, dart.dynamic]),
      _create_2: dart.definiteFunctionType(html$.BeforeInstallPromptEvent, [dart.dynamic])
    }),
    names: ['_create_1', '_create_2']
  });
  dart.registerExtension(dart.global.BeforeInstallPromptEvent, html$.BeforeInstallPromptEvent);
  dart.defineExtensionNames([
    'returnValue',
    'returnValue'
  ]);
  html$.BeforeUnloadEvent = class BeforeUnloadEvent extends html$.Event {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.returnValue]() {
      return this.returnValue;
    }
    set [dartx.returnValue](value) {
      this.returnValue = value;
    }
  };
  dart.setSignature(html$.BeforeUnloadEvent, {
    constructors: () => ({_: dart.definiteFunctionType(html$.BeforeUnloadEvent, [])})
  });
  dart.registerExtension(dart.global.BeforeUnloadEvent, html$.BeforeUnloadEvent);
  dart.defineExtensionNames([
    'close',
    'slice',
    'size',
    'type'
  ]);
  html$.Blob = class Blob extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.size]() {
      return this.size;
    }
    get [dartx.type]() {
      return this.type;
    }
    [dartx.close]() {
      return this.close();
    }
    [dartx.slice](start, end, contentType) {
      return this.slice(start, end, contentType);
    }
    static new(blobParts, type, endings) {
      if (type === void 0) type = null;
      if (endings === void 0) endings = null;
      if (type == null && endings == null) {
        return html$.Blob._check(html$.Blob._create_1(blobParts));
      }
      let bag = html$.Blob._create_bag();
      if (type != null) html$.Blob._bag_set(bag, 'type', type);
      if (endings != null) html$.Blob._bag_set(bag, 'endings', endings);
      return html$.Blob._check(html$.Blob._create_2(blobParts, bag));
    }
    static _create_1(parts) {
      return new Blob(parts);
    }
    static _create_2(parts, bag) {
      return new Blob(parts, bag);
    }
    static _create_bag() {
      return {};
    }
    static _bag_set(bag, key, value) {
      bag[key] = value;
    }
  };
  dart.setSignature(html$.Blob, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.Blob, []),
      new: dart.definiteFunctionType(html$.Blob, [core.List], [core.String, core.String])
    }),
    methods: () => ({
      [dartx.close]: dart.definiteFunctionType(dart.void, []),
      [dartx.slice]: dart.definiteFunctionType(html$.Blob, [], [core.int, core.int, core.String])
    }),
    statics: () => ({
      _create_1: dart.definiteFunctionType(dart.dynamic, [dart.dynamic]),
      _create_2: dart.definiteFunctionType(dart.dynamic, [dart.dynamic, dart.dynamic]),
      _create_bag: dart.definiteFunctionType(dart.dynamic, []),
      _bag_set: dart.definiteFunctionType(dart.dynamic, [dart.dynamic, dart.dynamic, dart.dynamic])
    }),
    names: ['_create_1', '_create_2', '_create_bag', '_bag_set']
  });
  dart.registerExtension(dart.global.Blob, html$.Blob);
  const _requestDevice_1 = Symbol('_requestDevice_1');
  dart.defineExtensionNames([
    'requestDevice'
  ]);
  html$.Bluetooth = class Bluetooth extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [dartx.requestDevice](options) {
      let options_1 = html_common.convertDartToNative_Dictionary(options);
      return this[_requestDevice_1](options_1);
    }
    [_requestDevice_1](options) {
      return this.requestDevice(options);
    }
  };
  dart.setSignature(html$.Bluetooth, {
    constructors: () => ({_: dart.definiteFunctionType(html$.Bluetooth, [])}),
    methods: () => ({
      [dartx.requestDevice]: dart.definiteFunctionType(async.Future, [core.Map]),
      [_requestDevice_1]: dart.definiteFunctionType(async.Future, [dart.dynamic])
    })
  });
  dart.registerExtension(dart.global.Bluetooth, html$.Bluetooth);
  dart.defineExtensionNames([
    'connectGatt',
    'deviceClass',
    'instanceID',
    'name',
    'paired',
    'productID',
    'productVersion',
    'vendorID',
    'vendorIDSource'
  ]);
  html$.BluetoothDevice = class BluetoothDevice extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.deviceClass]() {
      return this.deviceClass;
    }
    get [dartx.instanceID]() {
      return this.instanceID;
    }
    get [dartx.name]() {
      return this.name;
    }
    get [dartx.paired]() {
      return this.paired;
    }
    get [dartx.productID]() {
      return this.productID;
    }
    get [dartx.productVersion]() {
      return this.productVersion;
    }
    get [dartx.vendorID]() {
      return this.vendorID;
    }
    get [dartx.vendorIDSource]() {
      return this.vendorIDSource;
    }
    [dartx.connectGatt]() {
      return this.connectGATT();
    }
  };
  dart.setSignature(html$.BluetoothDevice, {
    constructors: () => ({_: dart.definiteFunctionType(html$.BluetoothDevice, [])}),
    methods: () => ({[dartx.connectGatt]: dart.definiteFunctionType(async.Future, [])})
  });
  dart.registerExtension(dart.global.BluetoothDevice, html$.BluetoothDevice);
  dart.defineExtensionNames([
    'readValue',
    'writeValue',
    'uuid'
  ]);
  html$.BluetoothGattCharacteristic = class BluetoothGattCharacteristic extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.uuid]() {
      return this.uuid;
    }
    [dartx.readValue]() {
      return this.readValue();
    }
    [dartx.writeValue](value) {
      return this.writeValue(value);
    }
  };
  dart.setSignature(html$.BluetoothGattCharacteristic, {
    constructors: () => ({_: dart.definiteFunctionType(html$.BluetoothGattCharacteristic, [])}),
    methods: () => ({
      [dartx.readValue]: dart.definiteFunctionType(async.Future, []),
      [dartx.writeValue]: dart.definiteFunctionType(async.Future, [dart.dynamic])
    })
  });
  dart.registerExtension(dart.global.BluetoothGATTCharacteristic, html$.BluetoothGattCharacteristic);
  dart.defineExtensionNames([
    'getPrimaryService',
    'connected'
  ]);
  html$.BluetoothGattRemoteServer = class BluetoothGattRemoteServer extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.connected]() {
      return this.connected;
    }
    [dartx.getPrimaryService](service) {
      return this.getPrimaryService(service);
    }
  };
  dart.setSignature(html$.BluetoothGattRemoteServer, {
    constructors: () => ({_: dart.definiteFunctionType(html$.BluetoothGattRemoteServer, [])}),
    methods: () => ({[dartx.getPrimaryService]: dart.definiteFunctionType(async.Future, [dart.dynamic])})
  });
  dart.registerExtension(dart.global.BluetoothGATTRemoteServer, html$.BluetoothGattRemoteServer);
  dart.defineExtensionNames([
    'getCharacteristic',
    'isPrimary',
    'uuid'
  ]);
  html$.BluetoothGattService = class BluetoothGattService extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.isPrimary]() {
      return this.isPrimary;
    }
    get [dartx.uuid]() {
      return this.uuid;
    }
    [dartx.getCharacteristic](characteristic) {
      return this.getCharacteristic(characteristic);
    }
  };
  dart.setSignature(html$.BluetoothGattService, {
    constructors: () => ({_: dart.definiteFunctionType(html$.BluetoothGattService, [])}),
    methods: () => ({[dartx.getCharacteristic]: dart.definiteFunctionType(async.Future, [dart.dynamic])})
  });
  dart.registerExtension(dart.global.BluetoothGATTService, html$.BluetoothGattService);
  html$.BluetoothUuid = class BluetoothUuid extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(html$.BluetoothUuid, {
    constructors: () => ({_: dart.definiteFunctionType(html$.BluetoothUuid, [])}),
    statics: () => ({
      canonicalUuid: dart.definiteFunctionType(core.String, [core.int]),
      getCharacteristic: dart.definiteFunctionType(core.String, [core.Object]),
      getDescriptor: dart.definiteFunctionType(core.String, [core.Object]),
      getService: dart.definiteFunctionType(core.String, [core.Object])
    }),
    names: ['canonicalUuid', 'getCharacteristic', 'getDescriptor', 'getService']
  });
  dart.registerExtension(dart.global.BluetoothUUID, html$.BluetoothUuid);
  dart.defineExtensionNames([
    'arrayBuffer',
    'blob',
    'json',
    'text',
    'bodyUsed'
  ]);
  html$.Body = class Body extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.bodyUsed]() {
      return this.bodyUsed;
    }
    [dartx.arrayBuffer]() {
      return this.arrayBuffer();
    }
    [dartx.blob]() {
      return this.blob();
    }
    [dartx.json]() {
      return this.json();
    }
    [dartx.text]() {
      return this.text();
    }
  };
  dart.setSignature(html$.Body, {
    constructors: () => ({_: dart.definiteFunctionType(html$.Body, [])}),
    methods: () => ({
      [dartx.arrayBuffer]: dart.definiteFunctionType(async.Future, []),
      [dartx.blob]: dart.definiteFunctionType(async.Future, []),
      [dartx.json]: dart.definiteFunctionType(async.Future, []),
      [dartx.text]: dart.definiteFunctionType(async.Future, [])
    })
  });
  dart.registerExtension(dart.global.Body, html$.Body);
  dart.defineExtensionNames([
    'onBlur',
    'onError',
    'onFocus',
    'onHashChange',
    'onLoad',
    'onMessage',
    'onOffline',
    'onOnline',
    'onPopState',
    'onResize',
    'onScroll',
    'onStorage',
    'onUnload'
  ]);
  html$.BodyElement = class BodyElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return html$.BodyElement._check(html$.document[dartx.createElement]("body"));
    }
    created() {
      super.created();
    }
    get [dartx.onBlur]() {
      return html$.BodyElement.blurEvent.forElement(this);
    }
    get [dartx.onError]() {
      return html$.BodyElement.errorEvent.forElement(this);
    }
    get [dartx.onFocus]() {
      return html$.BodyElement.focusEvent.forElement(this);
    }
    get [dartx.onHashChange]() {
      return html$.BodyElement.hashChangeEvent.forElement(this);
    }
    get [dartx.onLoad]() {
      return html$.BodyElement.loadEvent.forElement(this);
    }
    get [dartx.onMessage]() {
      return html$.BodyElement.messageEvent.forElement(this);
    }
    get [dartx.onOffline]() {
      return html$.BodyElement.offlineEvent.forElement(this);
    }
    get [dartx.onOnline]() {
      return html$.BodyElement.onlineEvent.forElement(this);
    }
    get [dartx.onPopState]() {
      return html$.BodyElement.popStateEvent.forElement(this);
    }
    get [dartx.onResize]() {
      return html$.BodyElement.resizeEvent.forElement(this);
    }
    get [dartx.onScroll]() {
      return html$.BodyElement.scrollEvent.forElement(this);
    }
    get [dartx.onStorage]() {
      return html$.BodyElement.storageEvent.forElement(this);
    }
    get [dartx.onUnload]() {
      return html$.BodyElement.unloadEvent.forElement(this);
    }
  };
  dart.defineNamedConstructor(html$.BodyElement, 'created');
  html$.BodyElement[dart.implements] = () => [html$.WindowEventHandlers];
  dart.setSignature(html$.BodyElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.BodyElement, []),
      new: dart.definiteFunctionType(html$.BodyElement, []),
      created: dart.definiteFunctionType(html$.BodyElement, [])
    })
  });
  dart.defineLazy(html$.BodyElement, {
    get blurEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('blur'));
    },
    get errorEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('error'));
    },
    get focusEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('focus'));
    },
    get hashChangeEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('hashchange'));
    },
    get loadEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('load'));
    },
    get messageEvent() {
      return dart.const(new (EventStreamProviderOfMessageEvent())('message'));
    },
    get offlineEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('offline'));
    },
    get onlineEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('online'));
    },
    get popStateEvent() {
      return dart.const(new (EventStreamProviderOfPopStateEvent())('popstate'));
    },
    get resizeEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('resize'));
    },
    get scrollEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('scroll'));
    },
    get storageEvent() {
      return dart.const(new (EventStreamProviderOfStorageEvent())('storage'));
    },
    get unloadEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('unload'));
    }
  });
  dart.registerExtension(dart.global.HTMLBodyElement, html$.BodyElement);
  dart.defineExtensionNames([
    'checkValidity',
    'reportValidity',
    'setCustomValidity',
    'autofocus',
    'disabled',
    'form',
    'formAction',
    'formEnctype',
    'formMethod',
    'formNoValidate',
    'formTarget',
    'labels',
    'name',
    'type',
    'validationMessage',
    'validity',
    'value',
    'willValidate'
  ]);
  html$.ButtonElement = class ButtonElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return html$.ButtonElement._check(html$.document[dartx.createElement]("button"));
    }
    created() {
      this[dartx.autofocus] = null;
      this[dartx.disabled] = null;
      this[dartx.form] = null;
      this[dartx.formAction] = null;
      this[dartx.formEnctype] = null;
      this[dartx.formMethod] = null;
      this[dartx.formNoValidate] = null;
      this[dartx.formTarget] = null;
      this[dartx.labels] = null;
      this[dartx.name] = null;
      this[dartx.type] = null;
      this[dartx.validationMessage] = null;
      this[dartx.validity] = null;
      this[dartx.value] = null;
      this[dartx.willValidate] = null;
      super.created();
    }
    get [dartx.autofocus]() {
      return this.autofocus;
    }
    set [dartx.autofocus](value) {
      this.autofocus = value;
    }
    get [dartx.disabled]() {
      return this.disabled;
    }
    set [dartx.disabled](value) {
      this.disabled = value;
    }
    get [dartx.form]() {
      return this.form;
    }
    get [dartx.formAction]() {
      return this.formAction;
    }
    set [dartx.formAction](value) {
      this.formAction = value;
    }
    get [dartx.formEnctype]() {
      return this.formEnctype;
    }
    set [dartx.formEnctype](value) {
      this.formEnctype = value;
    }
    get [dartx.formMethod]() {
      return this.formMethod;
    }
    set [dartx.formMethod](value) {
      this.formMethod = value;
    }
    get [dartx.formNoValidate]() {
      return this.formNoValidate;
    }
    set [dartx.formNoValidate](value) {
      this.formNoValidate = value;
    }
    get [dartx.formTarget]() {
      return this.formTarget;
    }
    set [dartx.formTarget](value) {
      this.formTarget = value;
    }
    get [dartx.labels]() {
      return this.labels;
    }
    get [dartx.name]() {
      return this.name;
    }
    set [dartx.name](value) {
      this.name = value;
    }
    get [dartx.type]() {
      return this.type;
    }
    set [dartx.type](value) {
      this.type = value;
    }
    get [dartx.validationMessage]() {
      return this.validationMessage;
    }
    get [dartx.validity]() {
      return this.validity;
    }
    get [dartx.value]() {
      return this.value;
    }
    set [dartx.value](value) {
      this.value = value;
    }
    get [dartx.willValidate]() {
      return this.willValidate;
    }
    [dartx.checkValidity]() {
      return this.checkValidity();
    }
    [dartx.reportValidity]() {
      return this.reportValidity();
    }
    [dartx.setCustomValidity](error) {
      return this.setCustomValidity(error);
    }
  };
  dart.defineNamedConstructor(html$.ButtonElement, 'created');
  dart.setSignature(html$.ButtonElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.ButtonElement, []),
      new: dart.definiteFunctionType(html$.ButtonElement, []),
      created: dart.definiteFunctionType(html$.ButtonElement, [])
    }),
    methods: () => ({
      [dartx.checkValidity]: dart.definiteFunctionType(core.bool, []),
      [dartx.reportValidity]: dart.definiteFunctionType(core.bool, []),
      [dartx.setCustomValidity]: dart.definiteFunctionType(dart.void, [core.String])
    })
  });
  dart.registerExtension(dart.global.HTMLButtonElement, html$.ButtonElement);
  const _createTextNode = Symbol('_createTextNode');
  dart.defineExtensionNames([
    'appendData',
    'deleteData',
    'insertData',
    'replaceData',
    'substringData',
    'after',
    'before',
    'data',
    'length',
    'nextElementSibling',
    'previousElementSibling'
  ]);
  html$.CharacterData = class CharacterData extends html$.Node {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.data]() {
      return this.data;
    }
    set [dartx.data](value) {
      this.data = value;
    }
    get [dartx.length]() {
      return this.length;
    }
    [dartx.appendData](data) {
      return this.appendData(data);
    }
    [dartx.deleteData](offset, count) {
      return this.deleteData(offset, count);
    }
    [dartx.insertData](offset, data) {
      return this.insertData(offset, data);
    }
    [dartx.replaceData](offset, count, data) {
      return this.replaceData(offset, count, data);
    }
    [dartx.substringData](offset, count) {
      return this.substringData(offset, count);
    }
    [dartx.after](nodes) {
      return this.after(nodes);
    }
    [dartx.before](nodes) {
      return this.before(nodes);
    }
    get [dartx.nextElementSibling]() {
      return this.nextElementSibling;
    }
    get [dartx.previousElementSibling]() {
      return this.previousElementSibling;
    }
  };
  html$.CharacterData[dart.implements] = () => [html$.NonDocumentTypeChildNode, html$.ChildNode];
  dart.setSignature(html$.CharacterData, {
    constructors: () => ({_: dart.definiteFunctionType(html$.CharacterData, [])}),
    methods: () => ({
      [dartx.appendData]: dart.definiteFunctionType(dart.void, [core.String]),
      [dartx.deleteData]: dart.definiteFunctionType(dart.void, [core.int, core.int]),
      [dartx.insertData]: dart.definiteFunctionType(dart.void, [core.int, core.String]),
      [dartx.replaceData]: dart.definiteFunctionType(dart.void, [core.int, core.int, core.String]),
      [dartx.substringData]: dart.definiteFunctionType(core.String, [core.int, core.int]),
      [dartx.after]: dart.definiteFunctionType(dart.void, [core.Object]),
      [dartx.before]: dart.definiteFunctionType(dart.void, [core.Object])
    })
  });
  dart.registerExtension(dart.global.CharacterData, html$.CharacterData);
  dart.defineExtensionNames([
    'getDestinationInsertionPoints',
    'splitText',
    'wholeText'
  ]);
  html$.Text = class Text extends html$.CharacterData {
    static new(data) {
      return html$.document[_createTextNode](data);
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.wholeText]() {
      return this.wholeText;
    }
    [dartx.getDestinationInsertionPoints]() {
      return this.getDestinationInsertionPoints();
    }
    [dartx.splitText](offset) {
      return this.splitText(offset);
    }
  };
  dart.setSignature(html$.Text, {
    constructors: () => ({
      new: dart.definiteFunctionType(html$.Text, [core.String]),
      _: dart.definiteFunctionType(html$.Text, [])
    }),
    methods: () => ({
      [dartx.getDestinationInsertionPoints]: dart.definiteFunctionType(core.List$(html$.Node), []),
      [dartx.splitText]: dart.definiteFunctionType(html$.Text, [core.int])
    })
  });
  dart.registerExtension(dart.global.Text, html$.Text);
  html$.CDataSection = class CDataSection extends html$.Text {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(html$.CDataSection, {
    constructors: () => ({_: dart.definiteFunctionType(html$.CDataSection, [])})
  });
  dart.registerExtension(dart.global.CDATASection, html$.CDataSection);
  const _match_1 = Symbol('_match_1');
  const _match_2 = Symbol('_match_2');
  dart.defineExtensionNames([
    'delete',
    'has',
    'keys',
    'match',
    'open'
  ]);
  html$.CacheStorage = class CacheStorage extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [dartx.delete](cacheName) {
      return this.delete(cacheName);
    }
    [dartx.has](cacheName) {
      return this.has(cacheName);
    }
    [dartx.keys]() {
      return this.keys();
    }
    [dartx.match](request, options) {
      if (options === void 0) options = null;
      if (options != null) {
        let options_1 = html_common.convertDartToNative_Dictionary(options);
        return this[_match_1](request, options_1);
      }
      return this[_match_2](request);
    }
    [_match_1](request, options) {
      return this.match(request, options);
    }
    [_match_2](request) {
      return this.match(request);
    }
    [dartx.open](cacheName) {
      return this.open(cacheName);
    }
  };
  dart.setSignature(html$.CacheStorage, {
    constructors: () => ({_: dart.definiteFunctionType(html$.CacheStorage, [])}),
    methods: () => ({
      [dartx.delete]: dart.definiteFunctionType(async.Future, [core.String]),
      [dartx.has]: dart.definiteFunctionType(async.Future, [core.String]),
      [dartx.keys]: dart.definiteFunctionType(async.Future, []),
      [dartx.match]: dart.definiteFunctionType(async.Future, [dart.dynamic], [core.Map]),
      [_match_1]: dart.definiteFunctionType(async.Future, [dart.dynamic, dart.dynamic]),
      [_match_2]: dart.definiteFunctionType(async.Future, [dart.dynamic]),
      [dartx.open]: dart.definiteFunctionType(async.Future, [core.String])
    })
  });
  dart.registerExtension(dart.global.CacheStorage, html$.CacheStorage);
  const _getContext_1 = Symbol('_getContext_1');
  const _getContext_2 = Symbol('_getContext_2');
  const _toDataUrl = Symbol('_toDataUrl');
  dart.defineExtensionNames([
    'getContext',
    'onWebGlContextLost',
    'onWebGlContextRestored',
    'context2D',
    'getContext3d',
    'toDataUrl',
    'height',
    'width'
  ]);
  html$.CanvasElement = class CanvasElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(opts) {
      let width = opts && 'width' in opts ? opts.width : null;
      let height = opts && 'height' in opts ? opts.height : null;
      let e = html$.CanvasElement._check(html$.document[dartx.createElement]("canvas"));
      if (width != null) e[dartx.width] = width;
      if (height != null) e[dartx.height] = height;
      return e;
    }
    created() {
      this[dartx.height] = null;
      this[dartx.width] = null;
      super.created();
    }
    get [dartx.height]() {
      return this.height;
    }
    set [dartx.height](value) {
      this.height = value;
    }
    get [dartx.width]() {
      return this.width;
    }
    set [dartx.width](value) {
      this.width = value;
    }
    [dartx.getContext](contextId, attributes) {
      if (attributes === void 0) attributes = null;
      if (attributes != null) {
        let attributes_1 = html_common.convertDartToNative_Dictionary(attributes);
        return this[_getContext_1](contextId, attributes_1);
      }
      return this[_getContext_2](contextId);
    }
    [_getContext_1](contextId, attributes) {
      return this.getContext(contextId, attributes);
    }
    [_getContext_2](contextId) {
      return this.getContext(contextId);
    }
    [_toDataUrl](type, arguments_OR_quality) {
      return this.toDataURL(type, arguments_OR_quality);
    }
    get [dartx.onWebGlContextLost]() {
      return html$.CanvasElement.webGlContextLostEvent.forElement(this);
    }
    get [dartx.onWebGlContextRestored]() {
      return html$.CanvasElement.webGlContextRestoredEvent.forElement(this);
    }
    get [dartx.context2D]() {
      return this.getContext('2d');
    }
    [dartx.getContext3d](opts) {
      let alpha = opts && 'alpha' in opts ? opts.alpha : true;
      let depth = opts && 'depth' in opts ? opts.depth : true;
      let stencil = opts && 'stencil' in opts ? opts.stencil : false;
      let antialias = opts && 'antialias' in opts ? opts.antialias : true;
      let premultipliedAlpha = opts && 'premultipliedAlpha' in opts ? opts.premultipliedAlpha : true;
      let preserveDrawingBuffer = opts && 'preserveDrawingBuffer' in opts ? opts.preserveDrawingBuffer : false;
      let options = dart.map({alpha: alpha, depth: depth, stencil: stencil, antialias: antialias, premultipliedAlpha: premultipliedAlpha, preserveDrawingBuffer: preserveDrawingBuffer});
      let context = this[dartx.getContext]('webgl', options);
      if (context == null) {
        context = this[dartx.getContext]('experimental-webgl', options);
      }
      return web_gl.RenderingContext._check(context);
    }
    [dartx.toDataUrl](type, quality) {
      if (type === void 0) type = 'image/png';
      if (quality === void 0) quality = null;
      return this[_toDataUrl](type, quality);
    }
  };
  dart.defineNamedConstructor(html$.CanvasElement, 'created');
  html$.CanvasElement[dart.implements] = () => [html$.CanvasImageSource];
  dart.setSignature(html$.CanvasElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.CanvasElement, []),
      new: dart.definiteFunctionType(html$.CanvasElement, [], {width: core.int, height: core.int}),
      created: dart.definiteFunctionType(html$.CanvasElement, [])
    }),
    methods: () => ({
      [dartx.getContext]: dart.definiteFunctionType(core.Object, [core.String], [core.Map]),
      [_getContext_1]: dart.definiteFunctionType(core.Object, [dart.dynamic, dart.dynamic]),
      [_getContext_2]: dart.definiteFunctionType(core.Object, [dart.dynamic]),
      [_toDataUrl]: dart.definiteFunctionType(core.String, [core.String], [dart.dynamic]),
      [dartx.getContext3d]: dart.definiteFunctionType(web_gl.RenderingContext, [], {alpha: dart.dynamic, depth: dart.dynamic, stencil: dart.dynamic, antialias: dart.dynamic, premultipliedAlpha: dart.dynamic, preserveDrawingBuffer: dart.dynamic}),
      [dartx.toDataUrl]: dart.definiteFunctionType(core.String, [], [core.String, core.num])
    })
  });
  dart.defineLazy(html$.CanvasElement, {
    get webGlContextLostEvent() {
      return dart.const(new (EventStreamProviderOfContextEvent())('webglcontextlost'));
    },
    get webGlContextRestoredEvent() {
      return dart.const(new (EventStreamProviderOfContextEvent())('webglcontextrestored'));
    }
  });
  dart.registerExtension(dart.global.HTMLCanvasElement, html$.CanvasElement);
  dart.defineExtensionNames([
    'addColorStop'
  ]);
  html$.CanvasGradient = class CanvasGradient extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [dartx.addColorStop](offset, color) {
      return this.addColorStop(offset, color);
    }
  };
  dart.setSignature(html$.CanvasGradient, {
    constructors: () => ({_: dart.definiteFunctionType(html$.CanvasGradient, [])}),
    methods: () => ({[dartx.addColorStop]: dart.definiteFunctionType(dart.void, [core.num, core.String])})
  });
  dart.registerExtension(dart.global.CanvasGradient, html$.CanvasGradient);
  dart.defineExtensionNames([
    'setTransform'
  ]);
  html$.CanvasPattern = class CanvasPattern extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [dartx.setTransform](transform) {
      return this.setTransform(transform);
    }
  };
  dart.setSignature(html$.CanvasPattern, {
    constructors: () => ({_: dart.definiteFunctionType(html$.CanvasPattern, [])}),
    methods: () => ({[dartx.setTransform]: dart.definiteFunctionType(dart.void, [svg$.Matrix])})
  });
  dart.registerExtension(dart.global.CanvasPattern, html$.CanvasPattern);
  html$.CanvasRenderingContext = class CanvasRenderingContext extends core.Object {};
  const _addHitRegion_1 = Symbol('_addHitRegion_1');
  const _addHitRegion_2 = Symbol('_addHitRegion_2');
  const _createImageData_1 = Symbol('_createImageData_1');
  const _createImageData_2 = Symbol('_createImageData_2');
  const _getContextAttributes_1 = Symbol('_getContextAttributes_1');
  const _getImageData_1 = Symbol('_getImageData_1');
  const _getLineDash = Symbol('_getLineDash');
  const _putImageData_1 = Symbol('_putImageData_1');
  const _putImageData_2 = Symbol('_putImageData_2');
  const _arc = Symbol('_arc');
  dart.defineExtensionNames([
    'addHitRegion',
    'beginPath',
    'clearHitRegions',
    'clearRect',
    'clip',
    'createImageData',
    'createLinearGradient',
    'createPattern',
    'createRadialGradient',
    'drawFocusIfNeeded',
    'fillRect',
    'getContextAttributes',
    'getImageData',
    'isContextLost',
    'isPointInPath',
    'isPointInStroke',
    'measureText',
    'putImageData',
    'removeHitRegion',
    'resetTransform',
    'restore',
    'rotate',
    'save',
    'scale',
    'scrollPathIntoView',
    'setTransform',
    'stroke',
    'strokeRect',
    'strokeText',
    'transform',
    'translate',
    'arcTo',
    'bezierCurveTo',
    'closePath',
    'ellipse',
    'lineTo',
    'moveTo',
    'quadraticCurveTo',
    'rect',
    'createImageDataFromImageData',
    'setFillColorRgb',
    'setFillColorHsl',
    'setStrokeColorRgb',
    'setStrokeColorHsl',
    'arc',
    'createPatternFromImage',
    'drawImageToRect',
    'drawImage',
    'drawImageScaled',
    'drawImageScaledFromSource',
    'lineDashOffset',
    'lineDashOffset',
    'getLineDash',
    'setLineDash',
    'fillText',
    'fill',
    'backingStorePixelRatio',
    'canvas',
    'currentTransform',
    'direction',
    'fillStyle',
    'filter',
    'font',
    'globalAlpha',
    'globalCompositeOperation',
    'imageSmoothingEnabled',
    'lineCap',
    'lineJoin',
    'lineWidth',
    'miterLimit',
    'shadowBlur',
    'shadowColor',
    'shadowOffsetX',
    'shadowOffsetY',
    'strokeStyle',
    'textAlign',
    'textBaseline'
  ]);
  html$.CanvasRenderingContext2D = class CanvasRenderingContext2D extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.canvas]() {
      return this.canvas;
    }
    get [dartx.currentTransform]() {
      return this.currentTransform;
    }
    set [dartx.currentTransform](value) {
      this.currentTransform = value;
    }
    get [dartx.direction]() {
      return this.direction;
    }
    set [dartx.direction](value) {
      this.direction = value;
    }
    get [dartx.fillStyle]() {
      return this.fillStyle;
    }
    set [dartx.fillStyle](value) {
      this.fillStyle = value;
    }
    get [dartx.filter]() {
      return this.filter;
    }
    set [dartx.filter](value) {
      this.filter = value;
    }
    get [dartx.font]() {
      return this.font;
    }
    set [dartx.font](value) {
      this.font = value;
    }
    get [dartx.globalAlpha]() {
      return this.globalAlpha;
    }
    set [dartx.globalAlpha](value) {
      this.globalAlpha = value;
    }
    get [dartx.globalCompositeOperation]() {
      return this.globalCompositeOperation;
    }
    set [dartx.globalCompositeOperation](value) {
      this.globalCompositeOperation = value;
    }
    get [dartx.imageSmoothingEnabled]() {
      return this.imageSmoothingEnabled;
    }
    set [dartx.imageSmoothingEnabled](value) {
      this.imageSmoothingEnabled = value;
    }
    get [dartx.lineCap]() {
      return this.lineCap;
    }
    set [dartx.lineCap](value) {
      this.lineCap = value;
    }
    get [dartx.lineJoin]() {
      return this.lineJoin;
    }
    set [dartx.lineJoin](value) {
      this.lineJoin = value;
    }
    get [dartx.lineWidth]() {
      return this.lineWidth;
    }
    set [dartx.lineWidth](value) {
      this.lineWidth = value;
    }
    get [dartx.miterLimit]() {
      return this.miterLimit;
    }
    set [dartx.miterLimit](value) {
      this.miterLimit = value;
    }
    get [dartx.shadowBlur]() {
      return this.shadowBlur;
    }
    set [dartx.shadowBlur](value) {
      this.shadowBlur = value;
    }
    get [dartx.shadowColor]() {
      return this.shadowColor;
    }
    set [dartx.shadowColor](value) {
      this.shadowColor = value;
    }
    get [dartx.shadowOffsetX]() {
      return this.shadowOffsetX;
    }
    set [dartx.shadowOffsetX](value) {
      this.shadowOffsetX = value;
    }
    get [dartx.shadowOffsetY]() {
      return this.shadowOffsetY;
    }
    set [dartx.shadowOffsetY](value) {
      this.shadowOffsetY = value;
    }
    get [dartx.strokeStyle]() {
      return this.strokeStyle;
    }
    set [dartx.strokeStyle](value) {
      this.strokeStyle = value;
    }
    get [dartx.textAlign]() {
      return this.textAlign;
    }
    set [dartx.textAlign](value) {
      this.textAlign = value;
    }
    get [dartx.textBaseline]() {
      return this.textBaseline;
    }
    set [dartx.textBaseline](value) {
      this.textBaseline = value;
    }
    [dartx.addHitRegion](options) {
      if (options === void 0) options = null;
      if (options != null) {
        let options_1 = html_common.convertDartToNative_Dictionary(options);
        this[_addHitRegion_1](options_1);
        return;
      }
      this[_addHitRegion_2]();
      return;
    }
    [_addHitRegion_1](options) {
      return this.addHitRegion(options);
    }
    [_addHitRegion_2]() {
      return this.addHitRegion();
    }
    [dartx.beginPath]() {
      return this.beginPath();
    }
    [dartx.clearHitRegions]() {
      return this.clearHitRegions();
    }
    [dartx.clearRect](x, y, width, height) {
      return this.clearRect(x, y, width, height);
    }
    [dartx.clip](path_OR_winding, winding) {
      return this.clip(path_OR_winding, winding);
    }
    [dartx.createImageData](imagedata_OR_sw, sh) {
      if (sh === void 0) sh = null;
      if (html$.ImageData.is(imagedata_OR_sw) && sh == null) {
        let imagedata_1 = html_common.convertDartToNative_ImageData(imagedata_OR_sw);
        return html_common.convertNativeToDart_ImageData(this[_createImageData_1](imagedata_1));
      }
      if (sh != null && typeof imagedata_OR_sw == 'number') {
        return html_common.convertNativeToDart_ImageData(this[_createImageData_2](imagedata_OR_sw, sh));
      }
      dart.throw(new core.ArgumentError("Incorrect number or type of arguments"));
    }
    [_createImageData_1](imagedata) {
      return this.createImageData(imagedata);
    }
    [_createImageData_2](sw, sh) {
      return this.createImageData(sw, sh);
    }
    [dartx.createLinearGradient](x0, y0, x1, y1) {
      return this.createLinearGradient(x0, y0, x1, y1);
    }
    [dartx.createPattern](image, repetitionType) {
      return this.createPattern(image, repetitionType);
    }
    [dartx.createRadialGradient](x0, y0, r0, x1, y1, r1) {
      return this.createRadialGradient(x0, y0, r0, x1, y1, r1);
    }
    [dartx.drawFocusIfNeeded](element_OR_path, element) {
      return this.drawFocusIfNeeded(element_OR_path, element);
    }
    [dartx.fillRect](x, y, width, height) {
      return this.fillRect(x, y, width, height);
    }
    [dartx.getContextAttributes]() {
      return html_common.convertNativeToDart_Dictionary(this[_getContextAttributes_1]());
    }
    [_getContextAttributes_1]() {
      return this.getContextAttributes();
    }
    [dartx.getImageData](sx, sy, sw, sh) {
      return html_common.convertNativeToDart_ImageData(this[_getImageData_1](sx, sy, sw, sh));
    }
    [_getImageData_1](sx, sy, sw, sh) {
      return this.getImageData(sx, sy, sw, sh);
    }
    [_getLineDash]() {
      return this.getLineDash();
    }
    [dartx.isContextLost]() {
      return this.isContextLost();
    }
    [dartx.isPointInPath](path_OR_x, x_OR_y, winding_OR_y, winding) {
      return this.isPointInPath(path_OR_x, x_OR_y, winding_OR_y, winding);
    }
    [dartx.isPointInStroke](path_OR_x, x_OR_y, y) {
      return this.isPointInStroke(path_OR_x, x_OR_y, y);
    }
    [dartx.measureText](text) {
      return this.measureText(text);
    }
    [dartx.putImageData](imagedata, dx, dy, dirtyX, dirtyY, dirtyWidth, dirtyHeight) {
      if (dirtyX === void 0) dirtyX = null;
      if (dirtyY === void 0) dirtyY = null;
      if (dirtyWidth === void 0) dirtyWidth = null;
      if (dirtyHeight === void 0) dirtyHeight = null;
      if (dirtyX == null && dirtyY == null && dirtyWidth == null && dirtyHeight == null) {
        let imagedata_1 = html_common.convertDartToNative_ImageData(imagedata);
        this[_putImageData_1](imagedata_1, dx, dy);
        return;
      }
      if (dirtyHeight != null && dirtyWidth != null && dirtyY != null && dirtyX != null) {
        let imagedata_1 = html_common.convertDartToNative_ImageData(imagedata);
        this[_putImageData_2](imagedata_1, dx, dy, dirtyX, dirtyY, dirtyWidth, dirtyHeight);
        return;
      }
      dart.throw(new core.ArgumentError("Incorrect number or type of arguments"));
    }
    [_putImageData_1](imagedata, dx, dy) {
      return this.putImageData(imagedata, dx, dy);
    }
    [_putImageData_2](imagedata, dx, dy, dirtyX, dirtyY, dirtyWidth, dirtyHeight) {
      return this.putImageData(imagedata, dx, dy, dirtyX, dirtyY, dirtyWidth, dirtyHeight);
    }
    [dartx.removeHitRegion](id) {
      return this.removeHitRegion(id);
    }
    [dartx.resetTransform]() {
      return this.resetTransform();
    }
    [dartx.restore]() {
      return this.restore();
    }
    [dartx.rotate](angle) {
      return this.rotate(angle);
    }
    [dartx.save]() {
      return this.save();
    }
    [dartx.scale](x, y) {
      return this.scale(x, y);
    }
    [dartx.scrollPathIntoView](path) {
      return this.scrollPathIntoView(path);
    }
    [dartx.setTransform](a, b, c, d, e, f) {
      return this.setTransform(a, b, c, d, e, f);
    }
    [dartx.stroke](path) {
      return this.stroke(path);
    }
    [dartx.strokeRect](x, y, width, height) {
      return this.strokeRect(x, y, width, height);
    }
    [dartx.strokeText](text, x, y, maxWidth) {
      return this.strokeText(text, x, y, maxWidth);
    }
    [dartx.transform](a, b, c, d, e, f) {
      return this.transform(a, b, c, d, e, f);
    }
    [dartx.translate](x, y) {
      return this.translate(x, y);
    }
    [_arc](x, y, radius, startAngle, endAngle, anticlockwise) {
      return this.arc(x, y, radius, startAngle, endAngle, anticlockwise);
    }
    [dartx.arcTo](x1, y1, x2, y2, radius) {
      return this.arcTo(x1, y1, x2, y2, radius);
    }
    [dartx.bezierCurveTo](cp1x, cp1y, cp2x, cp2y, x, y) {
      return this.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
    }
    [dartx.closePath]() {
      return this.closePath();
    }
    [dartx.ellipse](x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise) {
      return this.ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise);
    }
    [dartx.lineTo](x, y) {
      return this.lineTo(x, y);
    }
    [dartx.moveTo](x, y) {
      return this.moveTo(x, y);
    }
    [dartx.quadraticCurveTo](cpx, cpy, x, y) {
      return this.quadraticCurveTo(cpx, cpy, x, y);
    }
    [dartx.rect](x, y, width, height) {
      return this.rect(x, y, width, height);
    }
    [dartx.createImageDataFromImageData](imagedata) {
      return this.createImageData(imagedata);
    }
    [dartx.setFillColorRgb](r, g, b, a) {
      if (a === void 0) a = 1;
      this[dartx.fillStyle] = dart.str`rgba(${r}, ${g}, ${b}, ${a})`;
    }
    [dartx.setFillColorHsl](h, s, l, a) {
      if (a === void 0) a = 1;
      this[dartx.fillStyle] = dart.str`hsla(${h}, ${s}%, ${l}%, ${a})`;
    }
    [dartx.setStrokeColorRgb](r, g, b, a) {
      if (a === void 0) a = 1;
      this[dartx.strokeStyle] = dart.str`rgba(${r}, ${g}, ${b}, ${a})`;
    }
    [dartx.setStrokeColorHsl](h, s, l, a) {
      if (a === void 0) a = 1;
      this[dartx.strokeStyle] = dart.str`hsla(${h}, ${s}%, ${l}%, ${a})`;
    }
    [dartx.arc](x, y, radius, startAngle, endAngle, anticlockwise) {
      if (anticlockwise === void 0) anticlockwise = false;
      this.arc(x, y, radius, startAngle, endAngle, anticlockwise);
    }
    [dartx.createPatternFromImage](image, repetitionType) {
      return this.createPattern(image, repetitionType);
    }
    [dartx.drawImageToRect](source, destRect, opts) {
      let sourceRect = opts && 'sourceRect' in opts ? opts.sourceRect : null;
      if (sourceRect == null) {
        this[dartx.drawImageScaled](source, destRect[dartx.left], destRect[dartx.top], destRect[dartx.width], destRect[dartx.height]);
      } else {
        this[dartx.drawImageScaledFromSource](source, sourceRect[dartx.left], sourceRect[dartx.top], sourceRect[dartx.width], sourceRect[dartx.height], destRect[dartx.left], destRect[dartx.top], destRect[dartx.width], destRect[dartx.height]);
      }
    }
    [dartx.drawImage](source, destX, destY) {
      return this.drawImage(source, destX, destY);
    }
    [dartx.drawImageScaled](source, destX, destY, destWidth, destHeight) {
      return this.drawImage(source, destX, destY, destWidth, destHeight);
    }
    [dartx.drawImageScaledFromSource](source, sourceX, sourceY, sourceWidth, sourceHeight, destX, destY, destWidth, destHeight) {
      return this.drawImage(source, sourceX, sourceY, sourceWidth, sourceHeight, destX, destY, destWidth, destHeight);
    }
    get [dartx.lineDashOffset]() {
      return this.lineDashOffset || this.webkitLineDashOffset;
    }
    set [dartx.lineDashOffset](value) {
      typeof this.lineDashOffset != "undefined" ? this.lineDashOffset = value : this.webkitLineDashOffset = value;
    }
    [dartx.getLineDash]() {
      if (!!this.getLineDash) {
        return this.getLineDash();
      } else if (!!this.webkitLineDash) {
        return this.webkitLineDash;
      }
    }
    [dartx.setLineDash](dash) {
      if (!!this.setLineDash) {
        this.setLineDash(dash);
      } else if (!!this.webkitLineDash) {
        this.webkitLineDash = dash;
      }
    }
    [dartx.fillText](text, x, y, maxWidth) {
      if (maxWidth === void 0) maxWidth = null;
      if (maxWidth != null) {
        this.fillText(text, x, y, maxWidth);
      } else {
        this.fillText(text, x, y);
      }
    }
    [dartx.fill](winding) {
      if (winding === void 0) winding = 'nonzero';
      this.fill(winding);
    }
    get [dartx.backingStorePixelRatio]() {
      return 1.0;
    }
  };
  html$.CanvasRenderingContext2D[dart.implements] = () => [html$.CanvasRenderingContext];
  dart.setSignature(html$.CanvasRenderingContext2D, {
    constructors: () => ({_: dart.definiteFunctionType(html$.CanvasRenderingContext2D, [])}),
    methods: () => ({
      [dartx.addHitRegion]: dart.definiteFunctionType(dart.void, [], [core.Map]),
      [_addHitRegion_1]: dart.definiteFunctionType(dart.void, [dart.dynamic]),
      [_addHitRegion_2]: dart.definiteFunctionType(dart.void, []),
      [dartx.beginPath]: dart.definiteFunctionType(dart.void, []),
      [dartx.clearHitRegions]: dart.definiteFunctionType(dart.void, []),
      [dartx.clearRect]: dart.definiteFunctionType(dart.void, [core.num, core.num, core.num, core.num]),
      [dartx.clip]: dart.definiteFunctionType(dart.void, [], [dart.dynamic, core.String]),
      [dartx.createImageData]: dart.definiteFunctionType(html$.ImageData, [dart.dynamic], [core.num]),
      [_createImageData_1]: dart.definiteFunctionType(dart.dynamic, [dart.dynamic]),
      [_createImageData_2]: dart.definiteFunctionType(dart.dynamic, [core.num, dart.dynamic]),
      [dartx.createLinearGradient]: dart.definiteFunctionType(html$.CanvasGradient, [core.num, core.num, core.num, core.num]),
      [dartx.createPattern]: dart.definiteFunctionType(html$.CanvasPattern, [core.Object, core.String]),
      [dartx.createRadialGradient]: dart.definiteFunctionType(html$.CanvasGradient, [core.num, core.num, core.num, core.num, core.num, core.num]),
      [dartx.drawFocusIfNeeded]: dart.definiteFunctionType(dart.void, [dart.dynamic], [html$.Element]),
      [dartx.fillRect]: dart.definiteFunctionType(dart.void, [core.num, core.num, core.num, core.num]),
      [dartx.getContextAttributes]: dart.definiteFunctionType(core.Map, []),
      [_getContextAttributes_1]: dart.definiteFunctionType(dart.dynamic, []),
      [dartx.getImageData]: dart.definiteFunctionType(html$.ImageData, [core.num, core.num, core.num, core.num]),
      [_getImageData_1]: dart.definiteFunctionType(dart.dynamic, [dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic]),
      [_getLineDash]: dart.definiteFunctionType(core.List$(core.num), []),
      [dartx.isContextLost]: dart.definiteFunctionType(core.bool, []),
      [dartx.isPointInPath]: dart.definiteFunctionType(core.bool, [dart.dynamic, core.num], [dart.dynamic, core.String]),
      [dartx.isPointInStroke]: dart.definiteFunctionType(core.bool, [dart.dynamic, core.num], [core.num]),
      [dartx.measureText]: dart.definiteFunctionType(html$.TextMetrics, [core.String]),
      [dartx.putImageData]: dart.definiteFunctionType(dart.void, [html$.ImageData, core.num, core.num], [core.num, core.num, core.num, core.num]),
      [_putImageData_1]: dart.definiteFunctionType(dart.void, [dart.dynamic, dart.dynamic, dart.dynamic]),
      [_putImageData_2]: dart.definiteFunctionType(dart.void, [dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic]),
      [dartx.removeHitRegion]: dart.definiteFunctionType(dart.void, [core.String]),
      [dartx.resetTransform]: dart.definiteFunctionType(dart.void, []),
      [dartx.restore]: dart.definiteFunctionType(dart.void, []),
      [dartx.rotate]: dart.definiteFunctionType(dart.void, [core.num]),
      [dartx.save]: dart.definiteFunctionType(dart.void, []),
      [dartx.scale]: dart.definiteFunctionType(dart.void, [core.num, core.num]),
      [dartx.scrollPathIntoView]: dart.definiteFunctionType(dart.void, [], [html$.Path2D]),
      [dartx.setTransform]: dart.definiteFunctionType(dart.void, [core.num, core.num, core.num, core.num, core.num, core.num]),
      [dartx.stroke]: dart.definiteFunctionType(dart.void, [], [html$.Path2D]),
      [dartx.strokeRect]: dart.definiteFunctionType(dart.void, [core.num, core.num, core.num, core.num]),
      [dartx.strokeText]: dart.definiteFunctionType(dart.void, [core.String, core.num, core.num], [core.num]),
      [dartx.transform]: dart.definiteFunctionType(dart.void, [core.num, core.num, core.num, core.num, core.num, core.num]),
      [dartx.translate]: dart.definiteFunctionType(dart.void, [core.num, core.num]),
      [_arc]: dart.definiteFunctionType(dart.void, [core.num, core.num, core.num, core.num, core.num, core.bool]),
      [dartx.arcTo]: dart.definiteFunctionType(dart.void, [core.num, core.num, core.num, core.num, core.num]),
      [dartx.bezierCurveTo]: dart.definiteFunctionType(dart.void, [core.num, core.num, core.num, core.num, core.num, core.num]),
      [dartx.closePath]: dart.definiteFunctionType(dart.void, []),
      [dartx.ellipse]: dart.definiteFunctionType(dart.void, [core.num, core.num, core.num, core.num, core.num, core.num, core.num, core.bool]),
      [dartx.lineTo]: dart.definiteFunctionType(dart.void, [core.num, core.num]),
      [dartx.moveTo]: dart.definiteFunctionType(dart.void, [core.num, core.num]),
      [dartx.quadraticCurveTo]: dart.definiteFunctionType(dart.void, [core.num, core.num, core.num, core.num]),
      [dartx.rect]: dart.definiteFunctionType(dart.void, [core.num, core.num, core.num, core.num]),
      [dartx.createImageDataFromImageData]: dart.definiteFunctionType(html$.ImageData, [html$.ImageData]),
      [dartx.setFillColorRgb]: dart.definiteFunctionType(dart.void, [core.int, core.int, core.int], [core.num]),
      [dartx.setFillColorHsl]: dart.definiteFunctionType(dart.void, [core.int, core.num, core.num], [core.num]),
      [dartx.setStrokeColorRgb]: dart.definiteFunctionType(dart.void, [core.int, core.int, core.int], [core.num]),
      [dartx.setStrokeColorHsl]: dart.definiteFunctionType(dart.void, [core.int, core.num, core.num], [core.num]),
      [dartx.arc]: dart.definiteFunctionType(dart.void, [core.num, core.num, core.num, core.num, core.num], [core.bool]),
      [dartx.createPatternFromImage]: dart.definiteFunctionType(html$.CanvasPattern, [html$.ImageElement, core.String]),
      [dartx.drawImageToRect]: dart.definiteFunctionType(dart.void, [html$.CanvasImageSource, math.Rectangle$(core.num)], {sourceRect: RectangleOfnum()}),
      [dartx.drawImage]: dart.definiteFunctionType(dart.void, [html$.CanvasImageSource, core.num, core.num]),
      [dartx.drawImageScaled]: dart.definiteFunctionType(dart.void, [html$.CanvasImageSource, core.num, core.num, core.num, core.num]),
      [dartx.drawImageScaledFromSource]: dart.definiteFunctionType(dart.void, [html$.CanvasImageSource, core.num, core.num, core.num, core.num, core.num, core.num, core.num, core.num]),
      [dartx.getLineDash]: dart.definiteFunctionType(core.List$(core.num), []),
      [dartx.setLineDash]: dart.definiteFunctionType(dart.void, [core.List$(core.num)]),
      [dartx.fillText]: dart.definiteFunctionType(dart.void, [core.String, core.num, core.num], [core.num]),
      [dartx.fill]: dart.definiteFunctionType(dart.void, [], [core.String])
    })
  });
  dart.registerExtension(dart.global.CanvasRenderingContext2D, html$.CanvasRenderingContext2D);
  html$.ChildNode = class ChildNode extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(html$.ChildNode, {
    constructors: () => ({_: dart.definiteFunctionType(html$.ChildNode, [])})
  });
  html$.ChromiumValuebuffer = class ChromiumValuebuffer extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(html$.ChromiumValuebuffer, {
    constructors: () => ({_: dart.definiteFunctionType(html$.ChromiumValuebuffer, [])})
  });
  dart.registerExtension(dart.global.CHROMIUMValuebuffer, html$.ChromiumValuebuffer);
  dart.defineExtensionNames([
    'id'
  ]);
  html$.GeofencingRegion = class GeofencingRegion extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.id]() {
      return this.id;
    }
  };
  dart.setSignature(html$.GeofencingRegion, {
    constructors: () => ({_: dart.definiteFunctionType(html$.GeofencingRegion, [])})
  });
  dart.registerExtension(dart.global.GeofencingRegion, html$.GeofencingRegion);
  dart.defineExtensionNames([
    'latitude',
    'longitude',
    'radius'
  ]);
  html$.CircularGeofencingRegion = class CircularGeofencingRegion extends html$.GeofencingRegion {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(init) {
      let init_1 = html_common.convertDartToNative_Dictionary(init);
      return html$.CircularGeofencingRegion._create_1(init_1);
    }
    static _create_1(init) {
      return new CircularGeofencingRegion(init);
    }
    get [dartx.latitude]() {
      return this.latitude;
    }
    get [dartx.longitude]() {
      return this.longitude;
    }
    get [dartx.radius]() {
      return this.radius;
    }
  };
  dart.setSignature(html$.CircularGeofencingRegion, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.CircularGeofencingRegion, []),
      new: dart.definiteFunctionType(html$.CircularGeofencingRegion, [core.Map])
    }),
    statics: () => ({_create_1: dart.definiteFunctionType(html$.CircularGeofencingRegion, [dart.dynamic])}),
    names: ['_create_1']
  });
  html$.CircularGeofencingRegion.MAX_RADIUS = 100.0;
  html$.CircularGeofencingRegion.MIN_RADIUS = 1.0;
  dart.registerExtension(dart.global.CircularGeofencingRegion, html$.CircularGeofencingRegion);
  const _postMessage_1 = Symbol('_postMessage_1');
  const _postMessage_2 = Symbol('_postMessage_2');
  dart.defineExtensionNames([
    'postMessage',
    'frameType',
    'id',
    'url'
  ]);
  html$.Client = class Client extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.frameType]() {
      return this.frameType;
    }
    get [dartx.id]() {
      return this.id;
    }
    get [dartx.url]() {
      return this.url;
    }
    [dartx.postMessage](message, transfer) {
      if (transfer === void 0) transfer = null;
      if (transfer != null) {
        let message_1 = html_common.convertDartToNative_SerializedScriptValue(message);
        this[_postMessage_1](message_1, transfer);
        return;
      }
      let message_1 = html_common.convertDartToNative_SerializedScriptValue(message);
      this[_postMessage_2](message_1);
      return;
    }
    [_postMessage_1](message, transfer) {
      return this.postMessage(message, transfer);
    }
    [_postMessage_2](message) {
      return this.postMessage(message);
    }
  };
  dart.setSignature(html$.Client, {
    constructors: () => ({_: dart.definiteFunctionType(html$.Client, [])}),
    methods: () => ({
      [dartx.postMessage]: dart.definiteFunctionType(dart.void, [dart.dynamic], [core.List$(html$.MessagePort)]),
      [_postMessage_1]: dart.definiteFunctionType(dart.void, [dart.dynamic, core.List$(html$.MessagePort)]),
      [_postMessage_2]: dart.definiteFunctionType(dart.void, [dart.dynamic])
    })
  });
  dart.registerExtension(dart.global.Client, html$.Client);
  const _matchAll_1 = Symbol('_matchAll_1');
  const _matchAll_2 = Symbol('_matchAll_2');
  dart.defineExtensionNames([
    'claim',
    'matchAll',
    'openWindow'
  ]);
  html$.Clients = class Clients extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [dartx.claim]() {
      return this.claim();
    }
    [dartx.matchAll](options) {
      if (options === void 0) options = null;
      if (options != null) {
        let options_1 = html_common.convertDartToNative_Dictionary(options);
        return this[_matchAll_1](options_1);
      }
      return this[_matchAll_2]();
    }
    [_matchAll_1](options) {
      return this.matchAll(options);
    }
    [_matchAll_2]() {
      return this.matchAll();
    }
    [dartx.openWindow](url) {
      return this.openWindow(url);
    }
  };
  dart.setSignature(html$.Clients, {
    constructors: () => ({_: dart.definiteFunctionType(html$.Clients, [])}),
    methods: () => ({
      [dartx.claim]: dart.definiteFunctionType(async.Future, []),
      [dartx.matchAll]: dart.definiteFunctionType(async.Future, [], [core.Map]),
      [_matchAll_1]: dart.definiteFunctionType(async.Future, [dart.dynamic]),
      [_matchAll_2]: dart.definiteFunctionType(async.Future, []),
      [dartx.openWindow]: dart.definiteFunctionType(async.Future, [core.String])
    })
  });
  dart.registerExtension(dart.global.Clients, html$.Clients);
  dart.defineExtensionNames([
    'clipboardData'
  ]);
  html$.ClipboardEvent = class ClipboardEvent extends html$.Event {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.clipboardData]() {
      return this.clipboardData;
    }
  };
  dart.setSignature(html$.ClipboardEvent, {
    constructors: () => ({_: dart.definiteFunctionType(html$.ClipboardEvent, [])})
  });
  dart.registerExtension(dart.global.ClipboardEvent, html$.ClipboardEvent);
  dart.defineExtensionNames([
    'code',
    'reason',
    'wasClean'
  ]);
  html$.CloseEvent = class CloseEvent extends html$.Event {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(type, eventInitDict) {
      if (eventInitDict === void 0) eventInitDict = null;
      if (eventInitDict != null) {
        let eventInitDict_1 = html_common.convertDartToNative_Dictionary(eventInitDict);
        return html$.CloseEvent._create_1(type, eventInitDict_1);
      }
      return html$.CloseEvent._create_2(type);
    }
    static _create_1(type, eventInitDict) {
      return new CloseEvent(type, eventInitDict);
    }
    static _create_2(type) {
      return new CloseEvent(type);
    }
    get [dartx.code]() {
      return this.code;
    }
    get [dartx.reason]() {
      return this.reason;
    }
    get [dartx.wasClean]() {
      return this.wasClean;
    }
  };
  dart.setSignature(html$.CloseEvent, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.CloseEvent, []),
      new: dart.definiteFunctionType(html$.CloseEvent, [core.String], [core.Map])
    }),
    statics: () => ({
      _create_1: dart.definiteFunctionType(html$.CloseEvent, [dart.dynamic, dart.dynamic]),
      _create_2: dart.definiteFunctionType(html$.CloseEvent, [dart.dynamic])
    }),
    names: ['_create_1', '_create_2']
  });
  dart.registerExtension(dart.global.CloseEvent, html$.CloseEvent);
  html$.Comment = class Comment extends html$.CharacterData {
    static new(data) {
      if (data === void 0) data = null;
      if (data != null) {
        return html$.document.createComment(data);
      }
      return html$.document.createComment("");
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(html$.Comment, {
    constructors: () => ({
      new: dart.definiteFunctionType(html$.Comment, [], [core.String]),
      _: dart.definiteFunctionType(html$.Comment, [])
    })
  });
  dart.registerExtension(dart.global.Comment, html$.Comment);
  const _initCompositionEvent = Symbol('_initCompositionEvent');
  const _initUIEvent = Symbol('_initUIEvent');
  const _charCode = Symbol('_charCode');
  const _keyCode = Symbol('_keyCode');
  const _get_view = Symbol('_get_view');
  const _which = Symbol('_which');
  dart.defineExtensionNames([
    'view',
    'detail',
    'sourceDevice'
  ]);
  html$.UIEvent = class UIEvent extends html$.Event {
    static new(type, opts) {
      let view = opts && 'view' in opts ? opts.view : null;
      let detail = opts && 'detail' in opts ? opts.detail : 0;
      let canBubble = opts && 'canBubble' in opts ? opts.canBubble : true;
      let cancelable = opts && 'cancelable' in opts ? opts.cancelable : true;
      if (view == null) {
        view = html$.window;
      }
      let e = html$.UIEvent._check(html$.document[_createEvent]("UIEvent"));
      e[_initUIEvent](type, canBubble, cancelable, view, detail);
      return e;
    }
    static _(type, eventInitDict) {
      if (eventInitDict === void 0) eventInitDict = null;
      if (eventInitDict != null) {
        let eventInitDict_1 = html_common.convertDartToNative_Dictionary(eventInitDict);
        return html$.UIEvent._create_1(type, eventInitDict_1);
      }
      return html$.UIEvent._create_2(type);
    }
    static _create_1(type, eventInitDict) {
      return new UIEvent(type, eventInitDict);
    }
    static _create_2(type) {
      return new UIEvent(type);
    }
    get [_charCode]() {
      return this.charCode;
    }
    get [dartx.detail]() {
      return this.detail;
    }
    get [_keyCode]() {
      return this.keyCode;
    }
    get [dartx.sourceDevice]() {
      return this.sourceDevice;
    }
    get [dartx.view]() {
      return html$._convertNativeToDart_Window(this[_get_view]);
    }
    get [_get_view]() {
      return this.view;
    }
    get [_which]() {
      return this.which;
    }
    [_initUIEvent](type, bubbles, cancelable, view, detail) {
      return this.initUIEvent(type, bubbles, cancelable, view, detail);
    }
  };
  dart.setSignature(html$.UIEvent, {
    constructors: () => ({
      new: dart.definiteFunctionType(html$.UIEvent, [core.String], {view: html$.Window, detail: core.int, canBubble: core.bool, cancelable: core.bool}),
      _: dart.definiteFunctionType(html$.UIEvent, [core.String], [core.Map])
    }),
    methods: () => ({[_initUIEvent]: dart.definiteFunctionType(dart.void, [core.String, core.bool, core.bool, html$.Window, core.int])}),
    statics: () => ({
      _create_1: dart.definiteFunctionType(html$.UIEvent, [dart.dynamic, dart.dynamic]),
      _create_2: dart.definiteFunctionType(html$.UIEvent, [dart.dynamic])
    }),
    names: ['_create_1', '_create_2']
  });
  dart.registerExtension(dart.global.UIEvent, html$.UIEvent);
  dart.defineExtensionNames([
    'data'
  ]);
  html$.CompositionEvent = class CompositionEvent extends html$.UIEvent {
    static new(type, opts) {
      let canBubble = opts && 'canBubble' in opts ? opts.canBubble : false;
      let cancelable = opts && 'cancelable' in opts ? opts.cancelable : false;
      let view = opts && 'view' in opts ? opts.view : null;
      let data = opts && 'data' in opts ? opts.data : null;
      let locale = opts && 'locale' in opts ? opts.locale : null;
      if (view == null) {
        view = html$.window;
      }
      let e = html$.CompositionEvent._check(html$.document[_createEvent]("CompositionEvent"));
      if (dart.test(html_common.Device.isFirefox)) {
        e.initCompositionEvent(type, canBubble, cancelable, view, data, locale);
      } else {
        e[_initCompositionEvent](type, canBubble, cancelable, view, data);
      }
      return e;
    }
    static _(type, eventInitDict) {
      if (eventInitDict === void 0) eventInitDict = null;
      if (eventInitDict != null) {
        let eventInitDict_1 = html_common.convertDartToNative_Dictionary(eventInitDict);
        return html$.CompositionEvent._create_1(type, eventInitDict_1);
      }
      return html$.CompositionEvent._create_2(type);
    }
    static _create_1(type, eventInitDict) {
      return new CompositionEvent(type, eventInitDict);
    }
    static _create_2(type) {
      return new CompositionEvent(type);
    }
    get [dartx.data]() {
      return this.data;
    }
    [_initCompositionEvent](type, bubbles, cancelable, view, data) {
      return this.initCompositionEvent(type, bubbles, cancelable, view, data);
    }
  };
  dart.setSignature(html$.CompositionEvent, {
    constructors: () => ({
      new: dart.definiteFunctionType(html$.CompositionEvent, [core.String], {canBubble: core.bool, cancelable: core.bool, view: html$.Window, data: core.String, locale: core.String}),
      _: dart.definiteFunctionType(html$.CompositionEvent, [core.String], [core.Map])
    }),
    methods: () => ({[_initCompositionEvent]: dart.definiteFunctionType(dart.void, [core.String, core.bool, core.bool, html$.Window, core.String])}),
    statics: () => ({
      _create_1: dart.definiteFunctionType(html$.CompositionEvent, [dart.dynamic, dart.dynamic]),
      _create_2: dart.definiteFunctionType(html$.CompositionEvent, [dart.dynamic])
    }),
    names: ['_create_1', '_create_2']
  });
  dart.registerExtension(dart.global.CompositionEvent, html$.CompositionEvent);
  dart.defineExtensionNames([
    'disconnect',
    'supports',
    'opacity',
    'scrollLeft',
    'scrollTop',
    'transform'
  ]);
  html$.CompositorProxy = class CompositorProxy extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(element, attributeArray) {
      return html$.CompositorProxy._create_1(element, attributeArray);
    }
    static _create_1(element, attributeArray) {
      return new CompositorProxy(element, attributeArray);
    }
    get [dartx.opacity]() {
      return this.opacity;
    }
    set [dartx.opacity](value) {
      this.opacity = value;
    }
    get [dartx.scrollLeft]() {
      return this.scrollLeft;
    }
    set [dartx.scrollLeft](value) {
      this.scrollLeft = value;
    }
    get [dartx.scrollTop]() {
      return this.scrollTop;
    }
    set [dartx.scrollTop](value) {
      this.scrollTop = value;
    }
    get [dartx.transform]() {
      return this.transform;
    }
    set [dartx.transform](value) {
      this.transform = value;
    }
    [dartx.disconnect]() {
      return this.disconnect();
    }
    [dartx.supports](attribute) {
      return this.supports(attribute);
    }
  };
  dart.setSignature(html$.CompositorProxy, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.CompositorProxy, []),
      new: dart.definiteFunctionType(html$.CompositorProxy, [html$.Element, core.List$(core.String)])
    }),
    methods: () => ({
      [dartx.disconnect]: dart.definiteFunctionType(dart.void, []),
      [dartx.supports]: dart.definiteFunctionType(core.bool, [core.String])
    }),
    statics: () => ({_create_1: dart.definiteFunctionType(html$.CompositorProxy, [dart.dynamic, dart.dynamic])}),
    names: ['_create_1']
  });
  dart.registerExtension(dart.global.CompositorProxy, html$.CompositorProxy);
  dart.defineExtensionNames([
    'postMessage',
    'terminate',
    'onError',
    'onMessage'
  ]);
  html$.CompositorWorker = class CompositorWorker extends html$.EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(scriptUrl) {
      return html$.CompositorWorker._create_1(scriptUrl);
    }
    static _create_1(scriptUrl) {
      return new CompositorWorker(scriptUrl);
    }
    [dartx.postMessage](message, transfer) {
      if (transfer === void 0) transfer = null;
      if (transfer != null) {
        let message_1 = html_common.convertDartToNative_SerializedScriptValue(message);
        this[_postMessage_1](message_1, transfer);
        return;
      }
      let message_1 = html_common.convertDartToNative_SerializedScriptValue(message);
      this[_postMessage_2](message_1);
      return;
    }
    [_postMessage_1](message, transfer) {
      return this.postMessage(message, transfer);
    }
    [_postMessage_2](message) {
      return this.postMessage(message);
    }
    [dartx.terminate]() {
      return this.terminate();
    }
    get [dartx.onError]() {
      return html$.CompositorWorker.errorEvent.forTarget(this);
    }
    get [dartx.onMessage]() {
      return html$.CompositorWorker.messageEvent.forTarget(this);
    }
  };
  html$.CompositorWorker[dart.implements] = () => [html$.AbstractWorker];
  dart.setSignature(html$.CompositorWorker, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.CompositorWorker, []),
      new: dart.definiteFunctionType(html$.CompositorWorker, [core.String])
    }),
    methods: () => ({
      [dartx.postMessage]: dart.definiteFunctionType(dart.void, [dart.dynamic], [core.List$(html$.MessagePort)]),
      [_postMessage_1]: dart.definiteFunctionType(dart.void, [dart.dynamic, core.List$(html$.MessagePort)]),
      [_postMessage_2]: dart.definiteFunctionType(dart.void, [dart.dynamic]),
      [dartx.terminate]: dart.definiteFunctionType(dart.void, [])
    }),
    statics: () => ({_create_1: dart.definiteFunctionType(html$.CompositorWorker, [dart.dynamic])}),
    names: ['_create_1']
  });
  dart.defineLazy(html$.CompositorWorker, {
    get errorEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('error'));
    },
    get messageEvent() {
      return dart.const(new (EventStreamProviderOfMessageEvent())('message'));
    }
  });
  dart.registerExtension(dart.global.CompositorWorker, html$.CompositorWorker);
  const _fetch_1 = Symbol('_fetch_1');
  const _fetch_2 = Symbol('_fetch_2');
  const _webkitRequestFileSystem = Symbol('_webkitRequestFileSystem');
  const _webkitResolveLocalFileSystemUrl = Symbol('_webkitResolveLocalFileSystemUrl');
  const _setInterval_String = Symbol('_setInterval_String');
  const _setTimeout_String = Symbol('_setTimeout_String');
  const _clearInterval = Symbol('_clearInterval');
  const _clearTimeout = Symbol('_clearTimeout');
  const _setInterval = Symbol('_setInterval');
  const _setTimeout = Symbol('_setTimeout');
  dart.defineExtensionNames([
    'close',
    'fetch',
    'importScripts',
    'webkitRequestFileSystem',
    'requestFileSystemSync',
    'resolveLocalFileSystemSyncUrl',
    'webkitResolveLocalFileSystemUrl',
    'atob',
    'btoa',
    'onError',
    'caches',
    'console',
    'crypto',
    'indexedDB',
    'location',
    'navigator',
    'performance',
    'self'
  ]);
  html$.WorkerGlobalScope = class WorkerGlobalScope extends html$.EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.caches]() {
      return this.caches;
    }
    get [dartx.console]() {
      return this.console;
    }
    get [dartx.crypto]() {
      return this.crypto;
    }
    get [dartx.indexedDB]() {
      return this.indexedDB;
    }
    get [dartx.location]() {
      return this.location;
    }
    get [dartx.navigator]() {
      return this.navigator;
    }
    get [dartx.performance]() {
      return this.performance;
    }
    get [dartx.self]() {
      return this.self;
    }
    [dartx.close]() {
      return this.close();
    }
    [dartx.fetch](input, init) {
      if (init === void 0) init = null;
      if (init != null) {
        let init_1 = html_common.convertDartToNative_Dictionary(init);
        return this[_fetch_1](input, init_1);
      }
      return this[_fetch_2](input);
    }
    [_fetch_1](input, init) {
      return this.fetch(input, init);
    }
    [_fetch_2](input) {
      return this.fetch(input);
    }
    [dartx.importScripts](urls) {
      return this.importScripts(urls);
    }
    [_webkitRequestFileSystem](type, size, successCallback, errorCallback) {
      return this.webkitRequestFileSystem(type, size, successCallback, errorCallback);
    }
    [dartx.webkitRequestFileSystem](type, size) {
      let completer = CompleterOfFileSystem().new();
      this[_webkitRequestFileSystem](type, size, dart.fn(value => {
        completer.complete(value);
      }, FileSystemTovoid()), dart.fn(error => {
        completer.completeError(error);
      }, FileErrorTovoid()));
      return completer.future;
    }
    [dartx.requestFileSystemSync](type, size) {
      return this.webkitRequestFileSystemSync(type, size);
    }
    [dartx.resolveLocalFileSystemSyncUrl](url) {
      return this.webkitResolveLocalFileSystemSyncURL(url);
    }
    [_webkitResolveLocalFileSystemUrl](url, successCallback, errorCallback) {
      return this.webkitResolveLocalFileSystemURL(url, successCallback, errorCallback);
    }
    [dartx.webkitResolveLocalFileSystemUrl](url) {
      let completer = CompleterOfEntry().new();
      this[_webkitResolveLocalFileSystemUrl](url, dart.fn(value => {
        completer.complete(value);
      }, EntryTovoid()), dart.fn(error => {
        completer.completeError(error);
      }, FileErrorTovoid()));
      return completer.future;
    }
    [dartx.atob](atob) {
      return this.atob(atob);
    }
    [dartx.btoa](btoa) {
      return this.btoa(btoa);
    }
    [_setInterval_String](handler, timeout, arguments$) {
      return this.setInterval(handler, timeout, arguments$);
    }
    [_setTimeout_String](handler, timeout, arguments$) {
      return this.setTimeout(handler, timeout, arguments$);
    }
    [_clearInterval](handle) {
      return this.clearInterval(handle);
    }
    [_clearTimeout](handle) {
      return this.clearTimeout(handle);
    }
    [_setInterval](handler, timeout) {
      return this.setInterval(handler, timeout);
    }
    [_setTimeout](handler, timeout) {
      return this.setTimeout(handler, timeout);
    }
    get [dartx.onError]() {
      return html$.WorkerGlobalScope.errorEvent.forTarget(this);
    }
  };
  html$.WorkerGlobalScope[dart.implements] = () => [html$._WindowTimers, html$.WindowBase64];
  dart.setSignature(html$.WorkerGlobalScope, {
    constructors: () => ({_: dart.definiteFunctionType(html$.WorkerGlobalScope, [])}),
    methods: () => ({
      [dartx.close]: dart.definiteFunctionType(dart.void, []),
      [dartx.fetch]: dart.definiteFunctionType(async.Future, [dart.dynamic], [core.Map]),
      [_fetch_1]: dart.definiteFunctionType(async.Future, [dart.dynamic, dart.dynamic]),
      [_fetch_2]: dart.definiteFunctionType(async.Future, [dart.dynamic]),
      [dartx.importScripts]: dart.definiteFunctionType(dart.void, [core.String]),
      [_webkitRequestFileSystem]: dart.definiteFunctionType(dart.void, [core.int, core.int], [html$._FileSystemCallback, html$._ErrorCallback]),
      [dartx.webkitRequestFileSystem]: dart.definiteFunctionType(async.Future$(html$.FileSystem), [core.int, core.int]),
      [dartx.requestFileSystemSync]: dart.definiteFunctionType(html$._DOMFileSystemSync, [core.int, core.int]),
      [dartx.resolveLocalFileSystemSyncUrl]: dart.definiteFunctionType(html$._EntrySync, [core.String]),
      [_webkitResolveLocalFileSystemUrl]: dart.definiteFunctionType(dart.void, [core.String, html$._EntryCallback], [html$._ErrorCallback]),
      [dartx.webkitResolveLocalFileSystemUrl]: dart.definiteFunctionType(async.Future$(html$.Entry), [core.String]),
      [dartx.atob]: dart.definiteFunctionType(core.String, [core.String]),
      [dartx.btoa]: dart.definiteFunctionType(core.String, [core.String]),
      [_setInterval_String]: dart.definiteFunctionType(core.int, [core.String], [core.int, core.Object]),
      [_setTimeout_String]: dart.definiteFunctionType(core.int, [core.String], [core.int, core.Object]),
      [_clearInterval]: dart.definiteFunctionType(dart.void, [], [core.int]),
      [_clearTimeout]: dart.definiteFunctionType(dart.void, [], [core.int]),
      [_setInterval]: dart.definiteFunctionType(core.int, [core.Object], [core.int]),
      [_setTimeout]: dart.definiteFunctionType(core.int, [core.Object], [core.int])
    })
  });
  html$.WorkerGlobalScope.PERSISTENT = 1;
  html$.WorkerGlobalScope.TEMPORARY = 0;
  dart.defineLazy(html$.WorkerGlobalScope, {
    get errorEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('error'));
    }
  });
  dart.registerExtension(dart.global.WorkerGlobalScope, html$.WorkerGlobalScope);
  dart.defineExtensionNames([
    'cancelAnimationFrame',
    'postMessage',
    'requestAnimationFrame',
    'onMessage'
  ]);
  html$.CompositorWorkerGlobalScope = class CompositorWorkerGlobalScope extends html$.WorkerGlobalScope {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [dartx.cancelAnimationFrame](handle) {
      return this.cancelAnimationFrame(handle);
    }
    [dartx.postMessage](message, transfer) {
      if (transfer === void 0) transfer = null;
      if (transfer != null) {
        let message_1 = html_common.convertDartToNative_SerializedScriptValue(message);
        this[_postMessage_1](message_1, transfer);
        return;
      }
      let message_1 = html_common.convertDartToNative_SerializedScriptValue(message);
      this[_postMessage_2](message_1);
      return;
    }
    [_postMessage_1](message, transfer) {
      return this.postMessage(message, transfer);
    }
    [_postMessage_2](message) {
      return this.postMessage(message);
    }
    [dartx.requestAnimationFrame](callback) {
      return this.requestAnimationFrame(callback);
    }
    get [dartx.onMessage]() {
      return html$.CompositorWorkerGlobalScope.messageEvent.forTarget(this);
    }
  };
  dart.setSignature(html$.CompositorWorkerGlobalScope, {
    constructors: () => ({_: dart.definiteFunctionType(html$.CompositorWorkerGlobalScope, [])}),
    methods: () => ({
      [dartx.cancelAnimationFrame]: dart.definiteFunctionType(dart.void, [core.int]),
      [dartx.postMessage]: dart.definiteFunctionType(dart.void, [dart.dynamic], [core.List$(html$.MessagePort)]),
      [_postMessage_1]: dart.definiteFunctionType(dart.void, [dart.dynamic, core.List$(html$.MessagePort)]),
      [_postMessage_2]: dart.definiteFunctionType(dart.void, [dart.dynamic]),
      [dartx.requestAnimationFrame]: dart.definiteFunctionType(core.int, [html$.FrameRequestCallback])
    })
  });
  dart.defineLazy(html$.CompositorWorkerGlobalScope, {
    get messageEvent() {
      return dart.const(new (EventStreamProviderOfMessageEvent())('message'));
    }
  });
  dart.registerExtension(dart.global.CompositorWorkerGlobalScope, html$.CompositorWorkerGlobalScope);
  const _isConsoleDefined = Symbol('_isConsoleDefined');
  html$.Console = class Console extends core.Object {
    _safe() {
    }
    get [_isConsoleDefined]() {
      return typeof console != "undefined";
    }
    get memory() {
      return html$.MemoryInfo._check(dart.test(this[_isConsoleDefined]) ? console.memory : null);
    }
    assertCondition(condition, arg) {
      return dart.test(this[_isConsoleDefined]) ? console.assertCondition(condition, arg) : null;
    }
    clear(arg) {
      return dart.test(this[_isConsoleDefined]) ? console.clear(arg) : null;
    }
    count(arg) {
      return dart.test(this[_isConsoleDefined]) ? console.count(arg) : null;
    }
    debug(arg) {
      return dart.test(this[_isConsoleDefined]) ? console.debug(arg) : null;
    }
    dir(arg) {
      return dart.test(this[_isConsoleDefined]) ? console.dir(arg) : null;
    }
    dirxml(arg) {
      return dart.test(this[_isConsoleDefined]) ? console.dirxml(arg) : null;
    }
    error(arg) {
      return dart.test(this[_isConsoleDefined]) ? console.error(arg) : null;
    }
    group(arg) {
      return dart.test(this[_isConsoleDefined]) ? console.group(arg) : null;
    }
    groupCollapsed(arg) {
      return dart.test(this[_isConsoleDefined]) ? console.groupCollapsed(arg) : null;
    }
    groupEnd() {
      return dart.test(this[_isConsoleDefined]) ? console.groupEnd() : null;
    }
    info(arg) {
      return dart.test(this[_isConsoleDefined]) ? console.info(arg) : null;
    }
    log(arg) {
      return dart.test(this[_isConsoleDefined]) ? console.log(arg) : null;
    }
    markTimeline(arg) {
      return dart.test(this[_isConsoleDefined]) ? console.markTimeline(arg) : null;
    }
    profile(title) {
      return dart.test(this[_isConsoleDefined]) ? console.profile(title) : null;
    }
    profileEnd(title) {
      return dart.test(this[_isConsoleDefined]) ? console.profileEnd(title) : null;
    }
    table(arg) {
      return dart.test(this[_isConsoleDefined]) ? console.table(arg) : null;
    }
    time(title) {
      return dart.test(this[_isConsoleDefined]) ? console.time(title) : null;
    }
    timeEnd(title) {
      return dart.test(this[_isConsoleDefined]) ? console.timeEnd(title) : null;
    }
    timeStamp(arg) {
      return dart.test(this[_isConsoleDefined]) ? console.timeStamp(arg) : null;
    }
    trace(arg) {
      return dart.test(this[_isConsoleDefined]) ? console.trace(arg) : null;
    }
    warn(arg) {
      return dart.test(this[_isConsoleDefined]) ? console.warn(arg) : null;
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.defineNamedConstructor(html$.Console, '_safe');
  dart.setSignature(html$.Console, {
    constructors: () => ({
      _safe: dart.definiteFunctionType(html$.Console, []),
      _: dart.definiteFunctionType(html$.Console, [])
    }),
    methods: () => ({
      assertCondition: dart.definiteFunctionType(dart.void, [core.bool, core.Object]),
      clear: dart.definiteFunctionType(dart.void, [core.Object]),
      count: dart.definiteFunctionType(dart.void, [core.Object]),
      debug: dart.definiteFunctionType(dart.void, [core.Object]),
      dir: dart.definiteFunctionType(dart.void, [core.Object]),
      dirxml: dart.definiteFunctionType(dart.void, [core.Object]),
      error: dart.definiteFunctionType(dart.void, [core.Object]),
      group: dart.definiteFunctionType(dart.void, [core.Object]),
      groupCollapsed: dart.definiteFunctionType(dart.void, [core.Object]),
      groupEnd: dart.definiteFunctionType(dart.void, []),
      info: dart.definiteFunctionType(dart.void, [core.Object]),
      log: dart.definiteFunctionType(dart.void, [core.Object]),
      markTimeline: dart.definiteFunctionType(dart.void, [core.Object]),
      profile: dart.definiteFunctionType(dart.void, [core.String]),
      profileEnd: dart.definiteFunctionType(dart.void, [core.String]),
      table: dart.definiteFunctionType(dart.void, [core.Object]),
      time: dart.definiteFunctionType(dart.void, [core.String]),
      timeEnd: dart.definiteFunctionType(dart.void, [core.String]),
      timeStamp: dart.definiteFunctionType(dart.void, [core.Object]),
      trace: dart.definiteFunctionType(dart.void, [core.Object]),
      warn: dart.definiteFunctionType(dart.void, [core.Object])
    })
  });
  dart.defineLazy(html$.Console, {
    get _safeConsole() {
      return dart.const(new html$.Console._safe());
    }
  });
  dart.defineExtensionNames([
    'assertCondition',
    'timeline',
    'timelineEnd'
  ]);
  html$.ConsoleBase = class ConsoleBase extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [dartx.assertCondition](condition, arg) {
      return this.assert(condition, arg);
    }
    [dartx.timeline](title) {
      return this.timeline(title);
    }
    [dartx.timelineEnd](title) {
      return this.timelineEnd(title);
    }
  };
  dart.setSignature(html$.ConsoleBase, {
    constructors: () => ({_: dart.definiteFunctionType(html$.ConsoleBase, [])}),
    methods: () => ({
      [dartx.assertCondition]: dart.definiteFunctionType(dart.void, [core.bool, core.Object]),
      [dartx.timeline]: dart.definiteFunctionType(dart.void, [core.String]),
      [dartx.timelineEnd]: dart.definiteFunctionType(dart.void, [core.String])
    })
  });
  dart.registerExtension(dart.global.ConsoleBase, html$.ConsoleBase);
  dart.defineExtensionNames([
    'getDistributedNodes',
    'select'
  ]);
  html$.ContentElement = class ContentElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return html$.ContentElement._check(html$.document[dartx.createElement]("content"));
    }
    created() {
      this[dartx.select] = null;
      super.created();
    }
    static get supported() {
      return html$.Element.isTagSupported('content');
    }
    get [dartx.select]() {
      return this.select;
    }
    set [dartx.select](value) {
      this.select = value;
    }
    [dartx.getDistributedNodes]() {
      return this.getDistributedNodes();
    }
  };
  dart.defineNamedConstructor(html$.ContentElement, 'created');
  dart.setSignature(html$.ContentElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.ContentElement, []),
      new: dart.definiteFunctionType(html$.ContentElement, []),
      created: dart.definiteFunctionType(html$.ContentElement, [])
    }),
    methods: () => ({[dartx.getDistributedNodes]: dart.definiteFunctionType(core.List$(html$.Node), [])})
  });
  dart.registerExtension(dart.global.HTMLContentElement, html$.ContentElement);
  dart.defineExtensionNames([
    'accuracy',
    'altitude',
    'altitudeAccuracy',
    'heading',
    'latitude',
    'longitude',
    'speed'
  ]);
  html$.Coordinates = class Coordinates extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.accuracy]() {
      return this.accuracy;
    }
    get [dartx.altitude]() {
      return this.altitude;
    }
    get [dartx.altitudeAccuracy]() {
      return this.altitudeAccuracy;
    }
    get [dartx.heading]() {
      return this.heading;
    }
    get [dartx.latitude]() {
      return this.latitude;
    }
    get [dartx.longitude]() {
      return this.longitude;
    }
    get [dartx.speed]() {
      return this.speed;
    }
  };
  dart.setSignature(html$.Coordinates, {
    constructors: () => ({_: dart.definiteFunctionType(html$.Coordinates, [])})
  });
  dart.registerExtension(dart.global.Coordinates, html$.Coordinates);
  dart.defineExtensionNames([
    'iconUrl',
    'id',
    'name',
    'type'
  ]);
  html$.Credential = class Credential extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.iconUrl]() {
      return this.iconURL;
    }
    get [dartx.id]() {
      return this.id;
    }
    get [dartx.name]() {
      return this.name;
    }
    get [dartx.type]() {
      return this.type;
    }
  };
  dart.setSignature(html$.Credential, {
    constructors: () => ({_: dart.definiteFunctionType(html$.Credential, [])})
  });
  dart.registerExtension(dart.global.Credential, html$.Credential);
  const _request_1 = Symbol('_request_1');
  const _request_2 = Symbol('_request_2');
  dart.defineExtensionNames([
    'notifySignedIn',
    'request',
    'requireUserMediation'
  ]);
  html$.CredentialsContainer = class CredentialsContainer extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [dartx.notifySignedIn](credential) {
      return this.notifySignedIn(credential);
    }
    [dartx.request](options) {
      if (options === void 0) options = null;
      if (options != null) {
        let options_1 = html_common.convertDartToNative_Dictionary(options);
        return this[_request_1](options_1);
      }
      return this[_request_2]();
    }
    [_request_1](options) {
      return this.request(options);
    }
    [_request_2]() {
      return this.request();
    }
    [dartx.requireUserMediation]() {
      return this.requireUserMediation();
    }
  };
  dart.setSignature(html$.CredentialsContainer, {
    constructors: () => ({_: dart.definiteFunctionType(html$.CredentialsContainer, [])}),
    methods: () => ({
      [dartx.notifySignedIn]: dart.definiteFunctionType(async.Future, [html$.Credential]),
      [dartx.request]: dart.definiteFunctionType(async.Future, [], [core.Map]),
      [_request_1]: dart.definiteFunctionType(async.Future, [dart.dynamic]),
      [_request_2]: dart.definiteFunctionType(async.Future, []),
      [dartx.requireUserMediation]: dart.definiteFunctionType(async.Future, [])
    })
  });
  dart.registerExtension(dart.global.CredentialsContainer, html$.CredentialsContainer);
  dart.defineExtensionNames([
    'acceptConnection',
    'client'
  ]);
  html$.CrossOriginConnectEvent = class CrossOriginConnectEvent extends html$.Event {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.client]() {
      return this.client;
    }
    [dartx.acceptConnection](shouldAccept) {
      return this.acceptConnection(shouldAccept);
    }
  };
  dart.setSignature(html$.CrossOriginConnectEvent, {
    constructors: () => ({_: dart.definiteFunctionType(html$.CrossOriginConnectEvent, [])}),
    methods: () => ({[dartx.acceptConnection]: dart.definiteFunctionType(dart.void, [async.Future])})
  });
  dart.registerExtension(dart.global.CrossOriginConnectEvent, html$.CrossOriginConnectEvent);
  dart.defineExtensionNames([
    'postMessage',
    'origin',
    'targetUrl'
  ]);
  html$.CrossOriginServiceWorkerClient = class CrossOriginServiceWorkerClient extends html$.EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.origin]() {
      return this.origin;
    }
    get [dartx.targetUrl]() {
      return this.targetUrl;
    }
    [dartx.postMessage](message, transfer) {
      if (transfer === void 0) transfer = null;
      if (transfer != null) {
        let message_1 = html_common.convertDartToNative_SerializedScriptValue(message);
        this[_postMessage_1](message_1, transfer);
        return;
      }
      let message_1 = html_common.convertDartToNative_SerializedScriptValue(message);
      this[_postMessage_2](message_1);
      return;
    }
    [_postMessage_1](message, transfer) {
      return this.postMessage(message, transfer);
    }
    [_postMessage_2](message) {
      return this.postMessage(message);
    }
  };
  dart.setSignature(html$.CrossOriginServiceWorkerClient, {
    constructors: () => ({_: dart.definiteFunctionType(html$.CrossOriginServiceWorkerClient, [])}),
    methods: () => ({
      [dartx.postMessage]: dart.definiteFunctionType(dart.void, [dart.dynamic], [core.List$(html$.MessagePort)]),
      [_postMessage_1]: dart.definiteFunctionType(dart.void, [dart.dynamic, core.List$(html$.MessagePort)]),
      [_postMessage_2]: dart.definiteFunctionType(dart.void, [dart.dynamic])
    })
  });
  dart.registerExtension(dart.global.CrossOriginServiceWorkerClient, html$.CrossOriginServiceWorkerClient);
  const _getRandomValues = Symbol('_getRandomValues');
  dart.defineExtensionNames([
    'getRandomValues',
    'subtle'
  ]);
  html$.Crypto = class Crypto extends _interceptors.Interceptor {
    [dartx.getRandomValues](array) {
      return this[_getRandomValues](array);
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static get supported() {
      return !!(window.crypto && window.crypto.getRandomValues);
    }
    get [dartx.subtle]() {
      return this.subtle;
    }
    [_getRandomValues](array) {
      return this.getRandomValues(array);
    }
  };
  dart.setSignature(html$.Crypto, {
    constructors: () => ({_: dart.definiteFunctionType(html$.Crypto, [])}),
    methods: () => ({
      [dartx.getRandomValues]: dart.definiteFunctionType(typed_data.TypedData, [typed_data.TypedData]),
      [_getRandomValues]: dart.definiteFunctionType(typed_data.TypedData, [typed_data.TypedData])
    })
  });
  dart.registerExtension(dart.global.Crypto, html$.Crypto);
  dart.defineExtensionNames([
    'algorithm',
    'extractable',
    'type',
    'usages'
  ]);
  html$.CryptoKey = class CryptoKey extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.algorithm]() {
      return this.algorithm;
    }
    get [dartx.extractable]() {
      return this.extractable;
    }
    get [dartx.type]() {
      return this.type;
    }
    get [dartx.usages]() {
      return this.usages;
    }
  };
  dart.setSignature(html$.CryptoKey, {
    constructors: () => ({_: dart.definiteFunctionType(html$.CryptoKey, [])})
  });
  dart.registerExtension(dart.global.CryptoKey, html$.CryptoKey);
  html$.Css = class Css extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(html$.Css, {
    constructors: () => ({_: dart.definiteFunctionType(html$.Css, [])}),
    statics: () => ({
      supports: dart.definiteFunctionType(core.bool, [core.String, core.String]),
      supportsCondition: dart.definiteFunctionType(core.bool, [core.String])
    }),
    names: ['supports', 'supportsCondition']
  });
  dart.registerExtension(dart.global.CSS, html$.Css);
  dart.defineExtensionNames([
    'cssText',
    'parentRule',
    'parentStyleSheet',
    'type'
  ]);
  html$.CssRule = class CssRule extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.cssText]() {
      return this.cssText;
    }
    set [dartx.cssText](value) {
      this.cssText = value;
    }
    get [dartx.parentRule]() {
      return this.parentRule;
    }
    get [dartx.parentStyleSheet]() {
      return this.parentStyleSheet;
    }
    get [dartx.type]() {
      return this.type;
    }
  };
  dart.setSignature(html$.CssRule, {
    constructors: () => ({_: dart.definiteFunctionType(html$.CssRule, [])})
  });
  html$.CssRule.CHARSET_RULE = 2;
  html$.CssRule.FONT_FACE_RULE = 5;
  html$.CssRule.IMPORT_RULE = 3;
  html$.CssRule.KEYFRAMES_RULE = 7;
  html$.CssRule.KEYFRAME_RULE = 8;
  html$.CssRule.MEDIA_RULE = 4;
  html$.CssRule.PAGE_RULE = 6;
  html$.CssRule.STYLE_RULE = 1;
  html$.CssRule.SUPPORTS_RULE = 12;
  html$.CssRule.VIEWPORT_RULE = 15;
  html$.CssRule.WEBKIT_KEYFRAMES_RULE = 7;
  html$.CssRule.WEBKIT_KEYFRAME_RULE = 8;
  dart.registerExtension(dart.global.CSSRule, html$.CssRule);
  dart.defineExtensionNames([
    'encoding'
  ]);
  html$.CssCharsetRule = class CssCharsetRule extends html$.CssRule {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.encoding]() {
      return this.encoding;
    }
    set [dartx.encoding](value) {
      this.encoding = value;
    }
  };
  dart.setSignature(html$.CssCharsetRule, {
    constructors: () => ({_: dart.definiteFunctionType(html$.CssCharsetRule, [])})
  });
  dart.registerExtension(dart.global.CSSCharsetRule, html$.CssCharsetRule);
  dart.defineExtensionNames([
    'style'
  ]);
  html$.CssFontFaceRule = class CssFontFaceRule extends html$.CssRule {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.style]() {
      return this.style;
    }
  };
  dart.setSignature(html$.CssFontFaceRule, {
    constructors: () => ({_: dart.definiteFunctionType(html$.CssFontFaceRule, [])})
  });
  dart.registerExtension(dart.global.CSSFontFaceRule, html$.CssFontFaceRule);
  dart.defineExtensionNames([
    'deleteRule',
    'insertRule',
    'cssRules'
  ]);
  html$.CssGroupingRule = class CssGroupingRule extends html$.CssRule {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.cssRules]() {
      return this.cssRules;
    }
    [dartx.deleteRule](index) {
      return this.deleteRule(index);
    }
    [dartx.insertRule](rule, index) {
      return this.insertRule(rule, index);
    }
  };
  dart.setSignature(html$.CssGroupingRule, {
    constructors: () => ({_: dart.definiteFunctionType(html$.CssGroupingRule, [])}),
    methods: () => ({
      [dartx.deleteRule]: dart.definiteFunctionType(dart.void, [core.int]),
      [dartx.insertRule]: dart.definiteFunctionType(core.int, [core.String, core.int])
    })
  });
  dart.registerExtension(dart.global.CSSGroupingRule, html$.CssGroupingRule);
  dart.defineExtensionNames([
    'href',
    'media',
    'styleSheet'
  ]);
  html$.CssImportRule = class CssImportRule extends html$.CssRule {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.href]() {
      return this.href;
    }
    get [dartx.media]() {
      return this.media;
    }
    get [dartx.styleSheet]() {
      return this.styleSheet;
    }
  };
  dart.setSignature(html$.CssImportRule, {
    constructors: () => ({_: dart.definiteFunctionType(html$.CssImportRule, [])})
  });
  dart.registerExtension(dart.global.CSSImportRule, html$.CssImportRule);
  dart.defineExtensionNames([
    'keyText',
    'style'
  ]);
  html$.CssKeyframeRule = class CssKeyframeRule extends html$.CssRule {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.keyText]() {
      return this.keyText;
    }
    set [dartx.keyText](value) {
      this.keyText = value;
    }
    get [dartx.style]() {
      return this.style;
    }
  };
  dart.setSignature(html$.CssKeyframeRule, {
    constructors: () => ({_: dart.definiteFunctionType(html$.CssKeyframeRule, [])})
  });
  dart.registerExtension(dart.global.CSSKeyframeRule, html$.CssKeyframeRule);
  dart.defineExtensionNames([
    'appendRule',
    'deleteRule',
    'findRule',
    'cssRules',
    'name'
  ]);
  html$.CssKeyframesRule = class CssKeyframesRule extends html$.CssRule {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.cssRules]() {
      return this.cssRules;
    }
    get [dartx.name]() {
      return this.name;
    }
    set [dartx.name](value) {
      this.name = value;
    }
    [__getter__](index) {
      return this.__getter__(index);
    }
    [dartx.appendRule](rule) {
      return this.appendRule(rule);
    }
    [dartx.deleteRule](select) {
      return this.deleteRule(select);
    }
    [dartx.findRule](select) {
      return this.findRule(select);
    }
  };
  dart.setSignature(html$.CssKeyframesRule, {
    constructors: () => ({_: dart.definiteFunctionType(html$.CssKeyframesRule, [])}),
    methods: () => ({
      [__getter__]: dart.definiteFunctionType(html$.CssKeyframeRule, [core.int]),
      [dartx.appendRule]: dart.definiteFunctionType(dart.void, [core.String]),
      [dartx.deleteRule]: dart.definiteFunctionType(dart.void, [core.String]),
      [dartx.findRule]: dart.definiteFunctionType(html$.CssKeyframeRule, [core.String])
    })
  });
  dart.registerExtension(dart.global.CSSKeyframesRule, html$.CssKeyframesRule);
  dart.defineExtensionNames([
    'media'
  ]);
  html$.CssMediaRule = class CssMediaRule extends html$.CssGroupingRule {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.media]() {
      return this.media;
    }
  };
  dart.setSignature(html$.CssMediaRule, {
    constructors: () => ({_: dart.definiteFunctionType(html$.CssMediaRule, [])})
  });
  dart.registerExtension(dart.global.CSSMediaRule, html$.CssMediaRule);
  dart.defineExtensionNames([
    'selectorText',
    'style'
  ]);
  html$.CssPageRule = class CssPageRule extends html$.CssRule {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.selectorText]() {
      return this.selectorText;
    }
    set [dartx.selectorText](value) {
      this.selectorText = value;
    }
    get [dartx.style]() {
      return this.style;
    }
  };
  dart.setSignature(html$.CssPageRule, {
    constructors: () => ({_: dart.definiteFunctionType(html$.CssPageRule, [])})
  });
  dart.registerExtension(dart.global.CSSPageRule, html$.CssPageRule);
  const _getPropertyValueHelper = Symbol('_getPropertyValueHelper');
  const _supportsProperty = Symbol('_supportsProperty');
  const _getPropertyValue = Symbol('_getPropertyValue');
  const _setPropertyHelper = Symbol('_setPropertyHelper');
  const _browserPropertyName = Symbol('_browserPropertyName');
  let const$48;
  const _background = Symbol('_background');
  const _backgroundAttachment = Symbol('_backgroundAttachment');
  const _backgroundColor = Symbol('_backgroundColor');
  const _backgroundImage = Symbol('_backgroundImage');
  const _backgroundPosition = Symbol('_backgroundPosition');
  const _backgroundRepeat = Symbol('_backgroundRepeat');
  const _border = Symbol('_border');
  const _borderBottom = Symbol('_borderBottom');
  const _borderBottomColor = Symbol('_borderBottomColor');
  const _borderBottomStyle = Symbol('_borderBottomStyle');
  const _borderBottomWidth = Symbol('_borderBottomWidth');
  const _borderCollapse = Symbol('_borderCollapse');
  const _borderColor = Symbol('_borderColor');
  const _borderLeft = Symbol('_borderLeft');
  const _borderLeftColor = Symbol('_borderLeftColor');
  const _borderLeftStyle = Symbol('_borderLeftStyle');
  const _borderLeftWidth = Symbol('_borderLeftWidth');
  const _borderRight = Symbol('_borderRight');
  const _borderRightColor = Symbol('_borderRightColor');
  const _borderRightStyle = Symbol('_borderRightStyle');
  const _borderRightWidth = Symbol('_borderRightWidth');
  const _borderSpacing = Symbol('_borderSpacing');
  const _borderStyle = Symbol('_borderStyle');
  const _borderTop = Symbol('_borderTop');
  const _borderTopColor = Symbol('_borderTopColor');
  const _borderTopStyle = Symbol('_borderTopStyle');
  const _borderTopWidth = Symbol('_borderTopWidth');
  const _borderWidth = Symbol('_borderWidth');
  const _bottom = Symbol('_bottom');
  const _captionSide = Symbol('_captionSide');
  const _clear$1 = Symbol('_clear');
  const _clip = Symbol('_clip');
  const _color = Symbol('_color');
  const _content = Symbol('_content');
  const _cursor = Symbol('_cursor');
  const _direction = Symbol('_direction');
  const _display = Symbol('_display');
  const _emptyCells = Symbol('_emptyCells');
  const _font = Symbol('_font');
  const _fontFamily = Symbol('_fontFamily');
  const _fontSize = Symbol('_fontSize');
  const _fontStyle = Symbol('_fontStyle');
  const _fontVariant = Symbol('_fontVariant');
  const _fontWeight = Symbol('_fontWeight');
  const _height$ = Symbol('_height');
  const _left = Symbol('_left');
  const _letterSpacing = Symbol('_letterSpacing');
  const _lineHeight = Symbol('_lineHeight');
  const _listStyle = Symbol('_listStyle');
  const _listStyleImage = Symbol('_listStyleImage');
  const _listStylePosition = Symbol('_listStylePosition');
  const _listStyleType = Symbol('_listStyleType');
  const _margin = Symbol('_margin');
  const _marginBottom = Symbol('_marginBottom');
  const _marginLeft = Symbol('_marginLeft');
  const _marginRight = Symbol('_marginRight');
  const _marginTop = Symbol('_marginTop');
  const _maxHeight = Symbol('_maxHeight');
  const _maxWidth = Symbol('_maxWidth');
  const _minHeight = Symbol('_minHeight');
  const _minWidth = Symbol('_minWidth');
  const _outline = Symbol('_outline');
  const _outlineColor = Symbol('_outlineColor');
  const _outlineStyle = Symbol('_outlineStyle');
  const _outlineWidth = Symbol('_outlineWidth');
  const _overflow = Symbol('_overflow');
  const _padding = Symbol('_padding');
  const _paddingBottom = Symbol('_paddingBottom');
  const _paddingLeft = Symbol('_paddingLeft');
  const _paddingRight = Symbol('_paddingRight');
  const _paddingTop = Symbol('_paddingTop');
  const _pageBreakAfter = Symbol('_pageBreakAfter');
  const _pageBreakBefore = Symbol('_pageBreakBefore');
  const _pageBreakInside = Symbol('_pageBreakInside');
  const _position$0 = Symbol('_position');
  const _quotes = Symbol('_quotes');
  const _right = Symbol('_right');
  const _tableLayout = Symbol('_tableLayout');
  const _textAlign = Symbol('_textAlign');
  const _textDecoration = Symbol('_textDecoration');
  const _textIndent = Symbol('_textIndent');
  const _textTransform = Symbol('_textTransform');
  const _top = Symbol('_top');
  const _unicodeBidi = Symbol('_unicodeBidi');
  const _verticalAlign = Symbol('_verticalAlign');
  const _visibility = Symbol('_visibility');
  const _whiteSpace = Symbol('_whiteSpace');
  const _width$ = Symbol('_width');
  const _wordSpacing = Symbol('_wordSpacing');
  const _zIndex = Symbol('_zIndex');
  dart.defineExtensionNames([
    'alignContent',
    'alignContent',
    'alignItems',
    'alignItems',
    'alignSelf',
    'alignSelf',
    'animation',
    'animation',
    'animationDelay',
    'animationDelay',
    'animationDirection',
    'animationDirection',
    'animationDuration',
    'animationDuration',
    'animationFillMode',
    'animationFillMode',
    'animationIterationCount',
    'animationIterationCount',
    'animationName',
    'animationName',
    'animationPlayState',
    'animationPlayState',
    'animationTimingFunction',
    'animationTimingFunction',
    'appRegion',
    'appRegion',
    'appearance',
    'appearance',
    'aspectRatio',
    'aspectRatio',
    'backfaceVisibility',
    'backfaceVisibility',
    'background',
    'background',
    'backgroundAttachment',
    'backgroundAttachment',
    'backgroundBlendMode',
    'backgroundBlendMode',
    'backgroundClip',
    'backgroundClip',
    'backgroundColor',
    'backgroundColor',
    'backgroundComposite',
    'backgroundComposite',
    'backgroundImage',
    'backgroundImage',
    'backgroundOrigin',
    'backgroundOrigin',
    'backgroundPosition',
    'backgroundPosition',
    'backgroundPositionX',
    'backgroundPositionX',
    'backgroundPositionY',
    'backgroundPositionY',
    'backgroundRepeat',
    'backgroundRepeat',
    'backgroundRepeatX',
    'backgroundRepeatX',
    'backgroundRepeatY',
    'backgroundRepeatY',
    'backgroundSize',
    'backgroundSize',
    'border',
    'border',
    'borderAfter',
    'borderAfter',
    'borderAfterColor',
    'borderAfterColor',
    'borderAfterStyle',
    'borderAfterStyle',
    'borderAfterWidth',
    'borderAfterWidth',
    'borderBefore',
    'borderBefore',
    'borderBeforeColor',
    'borderBeforeColor',
    'borderBeforeStyle',
    'borderBeforeStyle',
    'borderBeforeWidth',
    'borderBeforeWidth',
    'borderBottom',
    'borderBottom',
    'borderBottomColor',
    'borderBottomColor',
    'borderBottomLeftRadius',
    'borderBottomLeftRadius',
    'borderBottomRightRadius',
    'borderBottomRightRadius',
    'borderBottomStyle',
    'borderBottomStyle',
    'borderBottomWidth',
    'borderBottomWidth',
    'borderCollapse',
    'borderCollapse',
    'borderColor',
    'borderColor',
    'borderEnd',
    'borderEnd',
    'borderEndColor',
    'borderEndColor',
    'borderEndStyle',
    'borderEndStyle',
    'borderEndWidth',
    'borderEndWidth',
    'borderFit',
    'borderFit',
    'borderHorizontalSpacing',
    'borderHorizontalSpacing',
    'borderImage',
    'borderImage',
    'borderImageOutset',
    'borderImageOutset',
    'borderImageRepeat',
    'borderImageRepeat',
    'borderImageSlice',
    'borderImageSlice',
    'borderImageSource',
    'borderImageSource',
    'borderImageWidth',
    'borderImageWidth',
    'borderLeft',
    'borderLeft',
    'borderLeftColor',
    'borderLeftColor',
    'borderLeftStyle',
    'borderLeftStyle',
    'borderLeftWidth',
    'borderLeftWidth',
    'borderRadius',
    'borderRadius',
    'borderRight',
    'borderRight',
    'borderRightColor',
    'borderRightColor',
    'borderRightStyle',
    'borderRightStyle',
    'borderRightWidth',
    'borderRightWidth',
    'borderSpacing',
    'borderSpacing',
    'borderStart',
    'borderStart',
    'borderStartColor',
    'borderStartColor',
    'borderStartStyle',
    'borderStartStyle',
    'borderStartWidth',
    'borderStartWidth',
    'borderStyle',
    'borderStyle',
    'borderTop',
    'borderTop',
    'borderTopColor',
    'borderTopColor',
    'borderTopLeftRadius',
    'borderTopLeftRadius',
    'borderTopRightRadius',
    'borderTopRightRadius',
    'borderTopStyle',
    'borderTopStyle',
    'borderTopWidth',
    'borderTopWidth',
    'borderVerticalSpacing',
    'borderVerticalSpacing',
    'borderWidth',
    'borderWidth',
    'bottom',
    'bottom',
    'boxAlign',
    'boxAlign',
    'boxDecorationBreak',
    'boxDecorationBreak',
    'boxDirection',
    'boxDirection',
    'boxFlex',
    'boxFlex',
    'boxFlexGroup',
    'boxFlexGroup',
    'boxLines',
    'boxLines',
    'boxOrdinalGroup',
    'boxOrdinalGroup',
    'boxOrient',
    'boxOrient',
    'boxPack',
    'boxPack',
    'boxReflect',
    'boxReflect',
    'boxShadow',
    'boxShadow',
    'boxSizing',
    'boxSizing',
    'captionSide',
    'captionSide',
    'clear',
    'clear',
    'clip',
    'clip',
    'clipPath',
    'clipPath',
    'color',
    'color',
    'columnBreakAfter',
    'columnBreakAfter',
    'columnBreakBefore',
    'columnBreakBefore',
    'columnBreakInside',
    'columnBreakInside',
    'columnCount',
    'columnCount',
    'columnFill',
    'columnFill',
    'columnGap',
    'columnGap',
    'columnRule',
    'columnRule',
    'columnRuleColor',
    'columnRuleColor',
    'columnRuleStyle',
    'columnRuleStyle',
    'columnRuleWidth',
    'columnRuleWidth',
    'columnSpan',
    'columnSpan',
    'columnWidth',
    'columnWidth',
    'columns',
    'columns',
    'content',
    'content',
    'counterIncrement',
    'counterIncrement',
    'counterReset',
    'counterReset',
    'cursor',
    'cursor',
    'direction',
    'direction',
    'display',
    'display',
    'emptyCells',
    'emptyCells',
    'filter',
    'filter',
    'flex',
    'flex',
    'flexBasis',
    'flexBasis',
    'flexDirection',
    'flexDirection',
    'flexFlow',
    'flexFlow',
    'flexGrow',
    'flexGrow',
    'flexShrink',
    'flexShrink',
    'flexWrap',
    'flexWrap',
    'float',
    'float',
    'font',
    'font',
    'fontFamily',
    'fontFamily',
    'fontFeatureSettings',
    'fontFeatureSettings',
    'fontKerning',
    'fontKerning',
    'fontSize',
    'fontSize',
    'fontSizeDelta',
    'fontSizeDelta',
    'fontSmoothing',
    'fontSmoothing',
    'fontStretch',
    'fontStretch',
    'fontStyle',
    'fontStyle',
    'fontVariant',
    'fontVariant',
    'fontVariantLigatures',
    'fontVariantLigatures',
    'fontWeight',
    'fontWeight',
    'grid',
    'grid',
    'gridArea',
    'gridArea',
    'gridAutoColumns',
    'gridAutoColumns',
    'gridAutoFlow',
    'gridAutoFlow',
    'gridAutoRows',
    'gridAutoRows',
    'gridColumn',
    'gridColumn',
    'gridColumnEnd',
    'gridColumnEnd',
    'gridColumnStart',
    'gridColumnStart',
    'gridRow',
    'gridRow',
    'gridRowEnd',
    'gridRowEnd',
    'gridRowStart',
    'gridRowStart',
    'gridTemplate',
    'gridTemplate',
    'gridTemplateAreas',
    'gridTemplateAreas',
    'gridTemplateColumns',
    'gridTemplateColumns',
    'gridTemplateRows',
    'gridTemplateRows',
    'height',
    'height',
    'highlight',
    'highlight',
    'hyphenateCharacter',
    'hyphenateCharacter',
    'imageRendering',
    'imageRendering',
    'isolation',
    'isolation',
    'justifyContent',
    'justifyContent',
    'justifySelf',
    'justifySelf',
    'left',
    'left',
    'letterSpacing',
    'letterSpacing',
    'lineBoxContain',
    'lineBoxContain',
    'lineBreak',
    'lineBreak',
    'lineClamp',
    'lineClamp',
    'lineHeight',
    'lineHeight',
    'listStyle',
    'listStyle',
    'listStyleImage',
    'listStyleImage',
    'listStylePosition',
    'listStylePosition',
    'listStyleType',
    'listStyleType',
    'locale',
    'locale',
    'logicalHeight',
    'logicalHeight',
    'logicalWidth',
    'logicalWidth',
    'margin',
    'margin',
    'marginAfter',
    'marginAfter',
    'marginAfterCollapse',
    'marginAfterCollapse',
    'marginBefore',
    'marginBefore',
    'marginBeforeCollapse',
    'marginBeforeCollapse',
    'marginBottom',
    'marginBottom',
    'marginBottomCollapse',
    'marginBottomCollapse',
    'marginCollapse',
    'marginCollapse',
    'marginEnd',
    'marginEnd',
    'marginLeft',
    'marginLeft',
    'marginRight',
    'marginRight',
    'marginStart',
    'marginStart',
    'marginTop',
    'marginTop',
    'marginTopCollapse',
    'marginTopCollapse',
    'mask',
    'mask',
    'maskBoxImage',
    'maskBoxImage',
    'maskBoxImageOutset',
    'maskBoxImageOutset',
    'maskBoxImageRepeat',
    'maskBoxImageRepeat',
    'maskBoxImageSlice',
    'maskBoxImageSlice',
    'maskBoxImageSource',
    'maskBoxImageSource',
    'maskBoxImageWidth',
    'maskBoxImageWidth',
    'maskClip',
    'maskClip',
    'maskComposite',
    'maskComposite',
    'maskImage',
    'maskImage',
    'maskOrigin',
    'maskOrigin',
    'maskPosition',
    'maskPosition',
    'maskPositionX',
    'maskPositionX',
    'maskPositionY',
    'maskPositionY',
    'maskRepeat',
    'maskRepeat',
    'maskRepeatX',
    'maskRepeatX',
    'maskRepeatY',
    'maskRepeatY',
    'maskSize',
    'maskSize',
    'maskSourceType',
    'maskSourceType',
    'maxHeight',
    'maxHeight',
    'maxLogicalHeight',
    'maxLogicalHeight',
    'maxLogicalWidth',
    'maxLogicalWidth',
    'maxWidth',
    'maxWidth',
    'maxZoom',
    'maxZoom',
    'minHeight',
    'minHeight',
    'minLogicalHeight',
    'minLogicalHeight',
    'minLogicalWidth',
    'minLogicalWidth',
    'minWidth',
    'minWidth',
    'minZoom',
    'minZoom',
    'mixBlendMode',
    'mixBlendMode',
    'objectFit',
    'objectFit',
    'objectPosition',
    'objectPosition',
    'opacity',
    'opacity',
    'order',
    'order',
    'orientation',
    'orientation',
    'orphans',
    'orphans',
    'outline',
    'outline',
    'outlineColor',
    'outlineColor',
    'outlineOffset',
    'outlineOffset',
    'outlineStyle',
    'outlineStyle',
    'outlineWidth',
    'outlineWidth',
    'overflow',
    'overflow',
    'overflowWrap',
    'overflowWrap',
    'overflowX',
    'overflowX',
    'overflowY',
    'overflowY',
    'padding',
    'padding',
    'paddingAfter',
    'paddingAfter',
    'paddingBefore',
    'paddingBefore',
    'paddingBottom',
    'paddingBottom',
    'paddingEnd',
    'paddingEnd',
    'paddingLeft',
    'paddingLeft',
    'paddingRight',
    'paddingRight',
    'paddingStart',
    'paddingStart',
    'paddingTop',
    'paddingTop',
    'page',
    'page',
    'pageBreakAfter',
    'pageBreakAfter',
    'pageBreakBefore',
    'pageBreakBefore',
    'pageBreakInside',
    'pageBreakInside',
    'perspective',
    'perspective',
    'perspectiveOrigin',
    'perspectiveOrigin',
    'perspectiveOriginX',
    'perspectiveOriginX',
    'perspectiveOriginY',
    'perspectiveOriginY',
    'pointerEvents',
    'pointerEvents',
    'position',
    'position',
    'printColorAdjust',
    'printColorAdjust',
    'quotes',
    'quotes',
    'resize',
    'resize',
    'right',
    'right',
    'rtlOrdering',
    'rtlOrdering',
    'rubyPosition',
    'rubyPosition',
    'scrollBehavior',
    'scrollBehavior',
    'shapeImageThreshold',
    'shapeImageThreshold',
    'shapeMargin',
    'shapeMargin',
    'shapeOutside',
    'shapeOutside',
    'size',
    'size',
    'speak',
    'speak',
    'src',
    'src',
    'tabSize',
    'tabSize',
    'tableLayout',
    'tableLayout',
    'tapHighlightColor',
    'tapHighlightColor',
    'textAlign',
    'textAlign',
    'textAlignLast',
    'textAlignLast',
    'textCombine',
    'textCombine',
    'textDecoration',
    'textDecoration',
    'textDecorationColor',
    'textDecorationColor',
    'textDecorationLine',
    'textDecorationLine',
    'textDecorationStyle',
    'textDecorationStyle',
    'textDecorationsInEffect',
    'textDecorationsInEffect',
    'textEmphasis',
    'textEmphasis',
    'textEmphasisColor',
    'textEmphasisColor',
    'textEmphasisPosition',
    'textEmphasisPosition',
    'textEmphasisStyle',
    'textEmphasisStyle',
    'textFillColor',
    'textFillColor',
    'textIndent',
    'textIndent',
    'textJustify',
    'textJustify',
    'textLineThroughColor',
    'textLineThroughColor',
    'textLineThroughMode',
    'textLineThroughMode',
    'textLineThroughStyle',
    'textLineThroughStyle',
    'textLineThroughWidth',
    'textLineThroughWidth',
    'textOrientation',
    'textOrientation',
    'textOverflow',
    'textOverflow',
    'textOverlineColor',
    'textOverlineColor',
    'textOverlineMode',
    'textOverlineMode',
    'textOverlineStyle',
    'textOverlineStyle',
    'textOverlineWidth',
    'textOverlineWidth',
    'textRendering',
    'textRendering',
    'textSecurity',
    'textSecurity',
    'textShadow',
    'textShadow',
    'textStroke',
    'textStroke',
    'textStrokeColor',
    'textStrokeColor',
    'textStrokeWidth',
    'textStrokeWidth',
    'textTransform',
    'textTransform',
    'textUnderlineColor',
    'textUnderlineColor',
    'textUnderlineMode',
    'textUnderlineMode',
    'textUnderlinePosition',
    'textUnderlinePosition',
    'textUnderlineStyle',
    'textUnderlineStyle',
    'textUnderlineWidth',
    'textUnderlineWidth',
    'top',
    'top',
    'touchAction',
    'touchAction',
    'touchActionDelay',
    'touchActionDelay',
    'transform',
    'transform',
    'transformOrigin',
    'transformOrigin',
    'transformOriginX',
    'transformOriginX',
    'transformOriginY',
    'transformOriginY',
    'transformOriginZ',
    'transformOriginZ',
    'transformStyle',
    'transformStyle',
    'transition',
    'transition',
    'transitionDelay',
    'transitionDelay',
    'transitionDuration',
    'transitionDuration',
    'transitionProperty',
    'transitionProperty',
    'transitionTimingFunction',
    'transitionTimingFunction',
    'unicodeBidi',
    'unicodeBidi',
    'unicodeRange',
    'unicodeRange',
    'userDrag',
    'userDrag',
    'userModify',
    'userModify',
    'userSelect',
    'userSelect',
    'userZoom',
    'userZoom',
    'verticalAlign',
    'verticalAlign',
    'visibility',
    'visibility',
    'whiteSpace',
    'whiteSpace',
    'widows',
    'widows',
    'width',
    'width',
    'willChange',
    'willChange',
    'wordBreak',
    'wordBreak',
    'wordSpacing',
    'wordSpacing',
    'wordWrap',
    'wordWrap',
    'wrapFlow',
    'wrapFlow',
    'wrapThrough',
    'wrapThrough',
    'writingMode',
    'writingMode',
    'zIndex',
    'zIndex',
    'zoom',
    'zoom'
  ]);
  html$.CssStyleDeclarationBase = class CssStyleDeclarationBase extends core.Object {
    get alignContent() {
      return this[dartx.getPropertyValue]('align-content');
    }
    set alignContent(value) {
      this[dartx.setProperty]('align-content', value, '');
    }
    get alignItems() {
      return this[dartx.getPropertyValue]('align-items');
    }
    set alignItems(value) {
      this[dartx.setProperty]('align-items', value, '');
    }
    get alignSelf() {
      return this[dartx.getPropertyValue]('align-self');
    }
    set alignSelf(value) {
      this[dartx.setProperty]('align-self', value, '');
    }
    get animation() {
      return this[dartx.getPropertyValue]('animation');
    }
    set animation(value) {
      this[dartx.setProperty]('animation', value, '');
    }
    get animationDelay() {
      return this[dartx.getPropertyValue]('animation-delay');
    }
    set animationDelay(value) {
      this[dartx.setProperty]('animation-delay', value, '');
    }
    get animationDirection() {
      return this[dartx.getPropertyValue]('animation-direction');
    }
    set animationDirection(value) {
      this[dartx.setProperty]('animation-direction', value, '');
    }
    get animationDuration() {
      return this[dartx.getPropertyValue]('animation-duration');
    }
    set animationDuration(value) {
      this[dartx.setProperty]('animation-duration', value, '');
    }
    get animationFillMode() {
      return this[dartx.getPropertyValue]('animation-fill-mode');
    }
    set animationFillMode(value) {
      this[dartx.setProperty]('animation-fill-mode', value, '');
    }
    get animationIterationCount() {
      return this[dartx.getPropertyValue]('animation-iteration-count');
    }
    set animationIterationCount(value) {
      this[dartx.setProperty]('animation-iteration-count', value, '');
    }
    get animationName() {
      return this[dartx.getPropertyValue]('animation-name');
    }
    set animationName(value) {
      this[dartx.setProperty]('animation-name', value, '');
    }
    get animationPlayState() {
      return this[dartx.getPropertyValue]('animation-play-state');
    }
    set animationPlayState(value) {
      this[dartx.setProperty]('animation-play-state', value, '');
    }
    get animationTimingFunction() {
      return this[dartx.getPropertyValue]('animation-timing-function');
    }
    set animationTimingFunction(value) {
      this[dartx.setProperty]('animation-timing-function', value, '');
    }
    get appRegion() {
      return this[dartx.getPropertyValue]('app-region');
    }
    set appRegion(value) {
      this[dartx.setProperty]('app-region', value, '');
    }
    get appearance() {
      return this[dartx.getPropertyValue]('appearance');
    }
    set appearance(value) {
      this[dartx.setProperty]('appearance', value, '');
    }
    get aspectRatio() {
      return this[dartx.getPropertyValue]('aspect-ratio');
    }
    set aspectRatio(value) {
      this[dartx.setProperty]('aspect-ratio', value, '');
    }
    get backfaceVisibility() {
      return this[dartx.getPropertyValue]('backface-visibility');
    }
    set backfaceVisibility(value) {
      this[dartx.setProperty]('backface-visibility', value, '');
    }
    get background() {
      return this[dartx.getPropertyValue]('background');
    }
    set background(value) {
      this[dartx.setProperty]('background', value, '');
    }
    get backgroundAttachment() {
      return this[dartx.getPropertyValue]('background-attachment');
    }
    set backgroundAttachment(value) {
      this[dartx.setProperty]('background-attachment', value, '');
    }
    get backgroundBlendMode() {
      return this[dartx.getPropertyValue]('background-blend-mode');
    }
    set backgroundBlendMode(value) {
      this[dartx.setProperty]('background-blend-mode', value, '');
    }
    get backgroundClip() {
      return this[dartx.getPropertyValue]('background-clip');
    }
    set backgroundClip(value) {
      this[dartx.setProperty]('background-clip', value, '');
    }
    get backgroundColor() {
      return this[dartx.getPropertyValue]('background-color');
    }
    set backgroundColor(value) {
      this[dartx.setProperty]('background-color', value, '');
    }
    get backgroundComposite() {
      return this[dartx.getPropertyValue]('background-composite');
    }
    set backgroundComposite(value) {
      this[dartx.setProperty]('background-composite', value, '');
    }
    get backgroundImage() {
      return this[dartx.getPropertyValue]('background-image');
    }
    set backgroundImage(value) {
      this[dartx.setProperty]('background-image', value, '');
    }
    get backgroundOrigin() {
      return this[dartx.getPropertyValue]('background-origin');
    }
    set backgroundOrigin(value) {
      this[dartx.setProperty]('background-origin', value, '');
    }
    get backgroundPosition() {
      return this[dartx.getPropertyValue]('background-position');
    }
    set backgroundPosition(value) {
      this[dartx.setProperty]('background-position', value, '');
    }
    get backgroundPositionX() {
      return this[dartx.getPropertyValue]('background-position-x');
    }
    set backgroundPositionX(value) {
      this[dartx.setProperty]('background-position-x', value, '');
    }
    get backgroundPositionY() {
      return this[dartx.getPropertyValue]('background-position-y');
    }
    set backgroundPositionY(value) {
      this[dartx.setProperty]('background-position-y', value, '');
    }
    get backgroundRepeat() {
      return this[dartx.getPropertyValue]('background-repeat');
    }
    set backgroundRepeat(value) {
      this[dartx.setProperty]('background-repeat', value, '');
    }
    get backgroundRepeatX() {
      return this[dartx.getPropertyValue]('background-repeat-x');
    }
    set backgroundRepeatX(value) {
      this[dartx.setProperty]('background-repeat-x', value, '');
    }
    get backgroundRepeatY() {
      return this[dartx.getPropertyValue]('background-repeat-y');
    }
    set backgroundRepeatY(value) {
      this[dartx.setProperty]('background-repeat-y', value, '');
    }
    get backgroundSize() {
      return this[dartx.getPropertyValue]('background-size');
    }
    set backgroundSize(value) {
      this[dartx.setProperty]('background-size', value, '');
    }
    get border() {
      return this[dartx.getPropertyValue]('border');
    }
    set border(value) {
      this[dartx.setProperty]('border', value, '');
    }
    get borderAfter() {
      return this[dartx.getPropertyValue]('border-after');
    }
    set borderAfter(value) {
      this[dartx.setProperty]('border-after', value, '');
    }
    get borderAfterColor() {
      return this[dartx.getPropertyValue]('border-after-color');
    }
    set borderAfterColor(value) {
      this[dartx.setProperty]('border-after-color', value, '');
    }
    get borderAfterStyle() {
      return this[dartx.getPropertyValue]('border-after-style');
    }
    set borderAfterStyle(value) {
      this[dartx.setProperty]('border-after-style', value, '');
    }
    get borderAfterWidth() {
      return this[dartx.getPropertyValue]('border-after-width');
    }
    set borderAfterWidth(value) {
      this[dartx.setProperty]('border-after-width', value, '');
    }
    get borderBefore() {
      return this[dartx.getPropertyValue]('border-before');
    }
    set borderBefore(value) {
      this[dartx.setProperty]('border-before', value, '');
    }
    get borderBeforeColor() {
      return this[dartx.getPropertyValue]('border-before-color');
    }
    set borderBeforeColor(value) {
      this[dartx.setProperty]('border-before-color', value, '');
    }
    get borderBeforeStyle() {
      return this[dartx.getPropertyValue]('border-before-style');
    }
    set borderBeforeStyle(value) {
      this[dartx.setProperty]('border-before-style', value, '');
    }
    get borderBeforeWidth() {
      return this[dartx.getPropertyValue]('border-before-width');
    }
    set borderBeforeWidth(value) {
      this[dartx.setProperty]('border-before-width', value, '');
    }
    get borderBottom() {
      return this[dartx.getPropertyValue]('border-bottom');
    }
    set borderBottom(value) {
      this[dartx.setProperty]('border-bottom', value, '');
    }
    get borderBottomColor() {
      return this[dartx.getPropertyValue]('border-bottom-color');
    }
    set borderBottomColor(value) {
      this[dartx.setProperty]('border-bottom-color', value, '');
    }
    get borderBottomLeftRadius() {
      return this[dartx.getPropertyValue]('border-bottom-left-radius');
    }
    set borderBottomLeftRadius(value) {
      this[dartx.setProperty]('border-bottom-left-radius', value, '');
    }
    get borderBottomRightRadius() {
      return this[dartx.getPropertyValue]('border-bottom-right-radius');
    }
    set borderBottomRightRadius(value) {
      this[dartx.setProperty]('border-bottom-right-radius', value, '');
    }
    get borderBottomStyle() {
      return this[dartx.getPropertyValue]('border-bottom-style');
    }
    set borderBottomStyle(value) {
      this[dartx.setProperty]('border-bottom-style', value, '');
    }
    get borderBottomWidth() {
      return this[dartx.getPropertyValue]('border-bottom-width');
    }
    set borderBottomWidth(value) {
      this[dartx.setProperty]('border-bottom-width', value, '');
    }
    get borderCollapse() {
      return this[dartx.getPropertyValue]('border-collapse');
    }
    set borderCollapse(value) {
      this[dartx.setProperty]('border-collapse', value, '');
    }
    get borderColor() {
      return this[dartx.getPropertyValue]('border-color');
    }
    set borderColor(value) {
      this[dartx.setProperty]('border-color', value, '');
    }
    get borderEnd() {
      return this[dartx.getPropertyValue]('border-end');
    }
    set borderEnd(value) {
      this[dartx.setProperty]('border-end', value, '');
    }
    get borderEndColor() {
      return this[dartx.getPropertyValue]('border-end-color');
    }
    set borderEndColor(value) {
      this[dartx.setProperty]('border-end-color', value, '');
    }
    get borderEndStyle() {
      return this[dartx.getPropertyValue]('border-end-style');
    }
    set borderEndStyle(value) {
      this[dartx.setProperty]('border-end-style', value, '');
    }
    get borderEndWidth() {
      return this[dartx.getPropertyValue]('border-end-width');
    }
    set borderEndWidth(value) {
      this[dartx.setProperty]('border-end-width', value, '');
    }
    get borderFit() {
      return this[dartx.getPropertyValue]('border-fit');
    }
    set borderFit(value) {
      this[dartx.setProperty]('border-fit', value, '');
    }
    get borderHorizontalSpacing() {
      return this[dartx.getPropertyValue]('border-horizontal-spacing');
    }
    set borderHorizontalSpacing(value) {
      this[dartx.setProperty]('border-horizontal-spacing', value, '');
    }
    get borderImage() {
      return this[dartx.getPropertyValue]('border-image');
    }
    set borderImage(value) {
      this[dartx.setProperty]('border-image', value, '');
    }
    get borderImageOutset() {
      return this[dartx.getPropertyValue]('border-image-outset');
    }
    set borderImageOutset(value) {
      this[dartx.setProperty]('border-image-outset', value, '');
    }
    get borderImageRepeat() {
      return this[dartx.getPropertyValue]('border-image-repeat');
    }
    set borderImageRepeat(value) {
      this[dartx.setProperty]('border-image-repeat', value, '');
    }
    get borderImageSlice() {
      return this[dartx.getPropertyValue]('border-image-slice');
    }
    set borderImageSlice(value) {
      this[dartx.setProperty]('border-image-slice', value, '');
    }
    get borderImageSource() {
      return this[dartx.getPropertyValue]('border-image-source');
    }
    set borderImageSource(value) {
      this[dartx.setProperty]('border-image-source', value, '');
    }
    get borderImageWidth() {
      return this[dartx.getPropertyValue]('border-image-width');
    }
    set borderImageWidth(value) {
      this[dartx.setProperty]('border-image-width', value, '');
    }
    get borderLeft() {
      return this[dartx.getPropertyValue]('border-left');
    }
    set borderLeft(value) {
      this[dartx.setProperty]('border-left', value, '');
    }
    get borderLeftColor() {
      return this[dartx.getPropertyValue]('border-left-color');
    }
    set borderLeftColor(value) {
      this[dartx.setProperty]('border-left-color', value, '');
    }
    get borderLeftStyle() {
      return this[dartx.getPropertyValue]('border-left-style');
    }
    set borderLeftStyle(value) {
      this[dartx.setProperty]('border-left-style', value, '');
    }
    get borderLeftWidth() {
      return this[dartx.getPropertyValue]('border-left-width');
    }
    set borderLeftWidth(value) {
      this[dartx.setProperty]('border-left-width', value, '');
    }
    get borderRadius() {
      return this[dartx.getPropertyValue]('border-radius');
    }
    set borderRadius(value) {
      this[dartx.setProperty]('border-radius', value, '');
    }
    get borderRight() {
      return this[dartx.getPropertyValue]('border-right');
    }
    set borderRight(value) {
      this[dartx.setProperty]('border-right', value, '');
    }
    get borderRightColor() {
      return this[dartx.getPropertyValue]('border-right-color');
    }
    set borderRightColor(value) {
      this[dartx.setProperty]('border-right-color', value, '');
    }
    get borderRightStyle() {
      return this[dartx.getPropertyValue]('border-right-style');
    }
    set borderRightStyle(value) {
      this[dartx.setProperty]('border-right-style', value, '');
    }
    get borderRightWidth() {
      return this[dartx.getPropertyValue]('border-right-width');
    }
    set borderRightWidth(value) {
      this[dartx.setProperty]('border-right-width', value, '');
    }
    get borderSpacing() {
      return this[dartx.getPropertyValue]('border-spacing');
    }
    set borderSpacing(value) {
      this[dartx.setProperty]('border-spacing', value, '');
    }
    get borderStart() {
      return this[dartx.getPropertyValue]('border-start');
    }
    set borderStart(value) {
      this[dartx.setProperty]('border-start', value, '');
    }
    get borderStartColor() {
      return this[dartx.getPropertyValue]('border-start-color');
    }
    set borderStartColor(value) {
      this[dartx.setProperty]('border-start-color', value, '');
    }
    get borderStartStyle() {
      return this[dartx.getPropertyValue]('border-start-style');
    }
    set borderStartStyle(value) {
      this[dartx.setProperty]('border-start-style', value, '');
    }
    get borderStartWidth() {
      return this[dartx.getPropertyValue]('border-start-width');
    }
    set borderStartWidth(value) {
      this[dartx.setProperty]('border-start-width', value, '');
    }
    get borderStyle() {
      return this[dartx.getPropertyValue]('border-style');
    }
    set borderStyle(value) {
      this[dartx.setProperty]('border-style', value, '');
    }
    get borderTop() {
      return this[dartx.getPropertyValue]('border-top');
    }
    set borderTop(value) {
      this[dartx.setProperty]('border-top', value, '');
    }
    get borderTopColor() {
      return this[dartx.getPropertyValue]('border-top-color');
    }
    set borderTopColor(value) {
      this[dartx.setProperty]('border-top-color', value, '');
    }
    get borderTopLeftRadius() {
      return this[dartx.getPropertyValue]('border-top-left-radius');
    }
    set borderTopLeftRadius(value) {
      this[dartx.setProperty]('border-top-left-radius', value, '');
    }
    get borderTopRightRadius() {
      return this[dartx.getPropertyValue]('border-top-right-radius');
    }
    set borderTopRightRadius(value) {
      this[dartx.setProperty]('border-top-right-radius', value, '');
    }
    get borderTopStyle() {
      return this[dartx.getPropertyValue]('border-top-style');
    }
    set borderTopStyle(value) {
      this[dartx.setProperty]('border-top-style', value, '');
    }
    get borderTopWidth() {
      return this[dartx.getPropertyValue]('border-top-width');
    }
    set borderTopWidth(value) {
      this[dartx.setProperty]('border-top-width', value, '');
    }
    get borderVerticalSpacing() {
      return this[dartx.getPropertyValue]('border-vertical-spacing');
    }
    set borderVerticalSpacing(value) {
      this[dartx.setProperty]('border-vertical-spacing', value, '');
    }
    get borderWidth() {
      return this[dartx.getPropertyValue]('border-width');
    }
    set borderWidth(value) {
      this[dartx.setProperty]('border-width', value, '');
    }
    get bottom() {
      return this[dartx.getPropertyValue]('bottom');
    }
    set bottom(value) {
      this[dartx.setProperty]('bottom', value, '');
    }
    get boxAlign() {
      return this[dartx.getPropertyValue]('box-align');
    }
    set boxAlign(value) {
      this[dartx.setProperty]('box-align', value, '');
    }
    get boxDecorationBreak() {
      return this[dartx.getPropertyValue]('box-decoration-break');
    }
    set boxDecorationBreak(value) {
      this[dartx.setProperty]('box-decoration-break', value, '');
    }
    get boxDirection() {
      return this[dartx.getPropertyValue]('box-direction');
    }
    set boxDirection(value) {
      this[dartx.setProperty]('box-direction', value, '');
    }
    get boxFlex() {
      return this[dartx.getPropertyValue]('box-flex');
    }
    set boxFlex(value) {
      this[dartx.setProperty]('box-flex', value, '');
    }
    get boxFlexGroup() {
      return this[dartx.getPropertyValue]('box-flex-group');
    }
    set boxFlexGroup(value) {
      this[dartx.setProperty]('box-flex-group', value, '');
    }
    get boxLines() {
      return this[dartx.getPropertyValue]('box-lines');
    }
    set boxLines(value) {
      this[dartx.setProperty]('box-lines', value, '');
    }
    get boxOrdinalGroup() {
      return this[dartx.getPropertyValue]('box-ordinal-group');
    }
    set boxOrdinalGroup(value) {
      this[dartx.setProperty]('box-ordinal-group', value, '');
    }
    get boxOrient() {
      return this[dartx.getPropertyValue]('box-orient');
    }
    set boxOrient(value) {
      this[dartx.setProperty]('box-orient', value, '');
    }
    get boxPack() {
      return this[dartx.getPropertyValue]('box-pack');
    }
    set boxPack(value) {
      this[dartx.setProperty]('box-pack', value, '');
    }
    get boxReflect() {
      return this[dartx.getPropertyValue]('box-reflect');
    }
    set boxReflect(value) {
      this[dartx.setProperty]('box-reflect', value, '');
    }
    get boxShadow() {
      return this[dartx.getPropertyValue]('box-shadow');
    }
    set boxShadow(value) {
      this[dartx.setProperty]('box-shadow', value, '');
    }
    get boxSizing() {
      return this[dartx.getPropertyValue]('box-sizing');
    }
    set boxSizing(value) {
      this[dartx.setProperty]('box-sizing', value, '');
    }
    get captionSide() {
      return this[dartx.getPropertyValue]('caption-side');
    }
    set captionSide(value) {
      this[dartx.setProperty]('caption-side', value, '');
    }
    get clear() {
      return this[dartx.getPropertyValue]('clear');
    }
    set clear(value) {
      this[dartx.setProperty]('clear', value, '');
    }
    get clip() {
      return this[dartx.getPropertyValue]('clip');
    }
    set clip(value) {
      this[dartx.setProperty]('clip', value, '');
    }
    get clipPath() {
      return this[dartx.getPropertyValue]('clip-path');
    }
    set clipPath(value) {
      this[dartx.setProperty]('clip-path', value, '');
    }
    get color() {
      return this[dartx.getPropertyValue]('color');
    }
    set color(value) {
      this[dartx.setProperty]('color', value, '');
    }
    get columnBreakAfter() {
      return this[dartx.getPropertyValue]('column-break-after');
    }
    set columnBreakAfter(value) {
      this[dartx.setProperty]('column-break-after', value, '');
    }
    get columnBreakBefore() {
      return this[dartx.getPropertyValue]('column-break-before');
    }
    set columnBreakBefore(value) {
      this[dartx.setProperty]('column-break-before', value, '');
    }
    get columnBreakInside() {
      return this[dartx.getPropertyValue]('column-break-inside');
    }
    set columnBreakInside(value) {
      this[dartx.setProperty]('column-break-inside', value, '');
    }
    get columnCount() {
      return this[dartx.getPropertyValue]('column-count');
    }
    set columnCount(value) {
      this[dartx.setProperty]('column-count', value, '');
    }
    get columnFill() {
      return this[dartx.getPropertyValue]('column-fill');
    }
    set columnFill(value) {
      this[dartx.setProperty]('column-fill', value, '');
    }
    get columnGap() {
      return this[dartx.getPropertyValue]('column-gap');
    }
    set columnGap(value) {
      this[dartx.setProperty]('column-gap', value, '');
    }
    get columnRule() {
      return this[dartx.getPropertyValue]('column-rule');
    }
    set columnRule(value) {
      this[dartx.setProperty]('column-rule', value, '');
    }
    get columnRuleColor() {
      return this[dartx.getPropertyValue]('column-rule-color');
    }
    set columnRuleColor(value) {
      this[dartx.setProperty]('column-rule-color', value, '');
    }
    get columnRuleStyle() {
      return this[dartx.getPropertyValue]('column-rule-style');
    }
    set columnRuleStyle(value) {
      this[dartx.setProperty]('column-rule-style', value, '');
    }
    get columnRuleWidth() {
      return this[dartx.getPropertyValue]('column-rule-width');
    }
    set columnRuleWidth(value) {
      this[dartx.setProperty]('column-rule-width', value, '');
    }
    get columnSpan() {
      return this[dartx.getPropertyValue]('column-span');
    }
    set columnSpan(value) {
      this[dartx.setProperty]('column-span', value, '');
    }
    get columnWidth() {
      return this[dartx.getPropertyValue]('column-width');
    }
    set columnWidth(value) {
      this[dartx.setProperty]('column-width', value, '');
    }
    get columns() {
      return this[dartx.getPropertyValue]('columns');
    }
    set columns(value) {
      this[dartx.setProperty]('columns', value, '');
    }
    get content() {
      return this[dartx.getPropertyValue]('content');
    }
    set content(value) {
      this[dartx.setProperty]('content', value, '');
    }
    get counterIncrement() {
      return this[dartx.getPropertyValue]('counter-increment');
    }
    set counterIncrement(value) {
      this[dartx.setProperty]('counter-increment', value, '');
    }
    get counterReset() {
      return this[dartx.getPropertyValue]('counter-reset');
    }
    set counterReset(value) {
      this[dartx.setProperty]('counter-reset', value, '');
    }
    get cursor() {
      return this[dartx.getPropertyValue]('cursor');
    }
    set cursor(value) {
      this[dartx.setProperty]('cursor', value, '');
    }
    get direction() {
      return this[dartx.getPropertyValue]('direction');
    }
    set direction(value) {
      this[dartx.setProperty]('direction', value, '');
    }
    get display() {
      return this[dartx.getPropertyValue]('display');
    }
    set display(value) {
      this[dartx.setProperty]('display', value, '');
    }
    get emptyCells() {
      return this[dartx.getPropertyValue]('empty-cells');
    }
    set emptyCells(value) {
      this[dartx.setProperty]('empty-cells', value, '');
    }
    get filter() {
      return this[dartx.getPropertyValue]('filter');
    }
    set filter(value) {
      this[dartx.setProperty]('filter', value, '');
    }
    get flex() {
      return this[dartx.getPropertyValue]('flex');
    }
    set flex(value) {
      this[dartx.setProperty]('flex', value, '');
    }
    get flexBasis() {
      return this[dartx.getPropertyValue]('flex-basis');
    }
    set flexBasis(value) {
      this[dartx.setProperty]('flex-basis', value, '');
    }
    get flexDirection() {
      return this[dartx.getPropertyValue]('flex-direction');
    }
    set flexDirection(value) {
      this[dartx.setProperty]('flex-direction', value, '');
    }
    get flexFlow() {
      return this[dartx.getPropertyValue]('flex-flow');
    }
    set flexFlow(value) {
      this[dartx.setProperty]('flex-flow', value, '');
    }
    get flexGrow() {
      return this[dartx.getPropertyValue]('flex-grow');
    }
    set flexGrow(value) {
      this[dartx.setProperty]('flex-grow', value, '');
    }
    get flexShrink() {
      return this[dartx.getPropertyValue]('flex-shrink');
    }
    set flexShrink(value) {
      this[dartx.setProperty]('flex-shrink', value, '');
    }
    get flexWrap() {
      return this[dartx.getPropertyValue]('flex-wrap');
    }
    set flexWrap(value) {
      this[dartx.setProperty]('flex-wrap', value, '');
    }
    get float() {
      return this[dartx.getPropertyValue]('float');
    }
    set float(value) {
      this[dartx.setProperty]('float', value, '');
    }
    get font() {
      return this[dartx.getPropertyValue]('font');
    }
    set font(value) {
      this[dartx.setProperty]('font', value, '');
    }
    get fontFamily() {
      return this[dartx.getPropertyValue]('font-family');
    }
    set fontFamily(value) {
      this[dartx.setProperty]('font-family', value, '');
    }
    get fontFeatureSettings() {
      return this[dartx.getPropertyValue]('font-feature-settings');
    }
    set fontFeatureSettings(value) {
      this[dartx.setProperty]('font-feature-settings', value, '');
    }
    get fontKerning() {
      return this[dartx.getPropertyValue]('font-kerning');
    }
    set fontKerning(value) {
      this[dartx.setProperty]('font-kerning', value, '');
    }
    get fontSize() {
      return this[dartx.getPropertyValue]('font-size');
    }
    set fontSize(value) {
      this[dartx.setProperty]('font-size', value, '');
    }
    get fontSizeDelta() {
      return this[dartx.getPropertyValue]('font-size-delta');
    }
    set fontSizeDelta(value) {
      this[dartx.setProperty]('font-size-delta', value, '');
    }
    get fontSmoothing() {
      return this[dartx.getPropertyValue]('font-smoothing');
    }
    set fontSmoothing(value) {
      this[dartx.setProperty]('font-smoothing', value, '');
    }
    get fontStretch() {
      return this[dartx.getPropertyValue]('font-stretch');
    }
    set fontStretch(value) {
      this[dartx.setProperty]('font-stretch', value, '');
    }
    get fontStyle() {
      return this[dartx.getPropertyValue]('font-style');
    }
    set fontStyle(value) {
      this[dartx.setProperty]('font-style', value, '');
    }
    get fontVariant() {
      return this[dartx.getPropertyValue]('font-variant');
    }
    set fontVariant(value) {
      this[dartx.setProperty]('font-variant', value, '');
    }
    get fontVariantLigatures() {
      return this[dartx.getPropertyValue]('font-variant-ligatures');
    }
    set fontVariantLigatures(value) {
      this[dartx.setProperty]('font-variant-ligatures', value, '');
    }
    get fontWeight() {
      return this[dartx.getPropertyValue]('font-weight');
    }
    set fontWeight(value) {
      this[dartx.setProperty]('font-weight', value, '');
    }
    get grid() {
      return this[dartx.getPropertyValue]('grid');
    }
    set grid(value) {
      this[dartx.setProperty]('grid', value, '');
    }
    get gridArea() {
      return this[dartx.getPropertyValue]('grid-area');
    }
    set gridArea(value) {
      this[dartx.setProperty]('grid-area', value, '');
    }
    get gridAutoColumns() {
      return this[dartx.getPropertyValue]('grid-auto-columns');
    }
    set gridAutoColumns(value) {
      this[dartx.setProperty]('grid-auto-columns', value, '');
    }
    get gridAutoFlow() {
      return this[dartx.getPropertyValue]('grid-auto-flow');
    }
    set gridAutoFlow(value) {
      this[dartx.setProperty]('grid-auto-flow', value, '');
    }
    get gridAutoRows() {
      return this[dartx.getPropertyValue]('grid-auto-rows');
    }
    set gridAutoRows(value) {
      this[dartx.setProperty]('grid-auto-rows', value, '');
    }
    get gridColumn() {
      return this[dartx.getPropertyValue]('grid-column');
    }
    set gridColumn(value) {
      this[dartx.setProperty]('grid-column', value, '');
    }
    get gridColumnEnd() {
      return this[dartx.getPropertyValue]('grid-column-end');
    }
    set gridColumnEnd(value) {
      this[dartx.setProperty]('grid-column-end', value, '');
    }
    get gridColumnStart() {
      return this[dartx.getPropertyValue]('grid-column-start');
    }
    set gridColumnStart(value) {
      this[dartx.setProperty]('grid-column-start', value, '');
    }
    get gridRow() {
      return this[dartx.getPropertyValue]('grid-row');
    }
    set gridRow(value) {
      this[dartx.setProperty]('grid-row', value, '');
    }
    get gridRowEnd() {
      return this[dartx.getPropertyValue]('grid-row-end');
    }
    set gridRowEnd(value) {
      this[dartx.setProperty]('grid-row-end', value, '');
    }
    get gridRowStart() {
      return this[dartx.getPropertyValue]('grid-row-start');
    }
    set gridRowStart(value) {
      this[dartx.setProperty]('grid-row-start', value, '');
    }
    get gridTemplate() {
      return this[dartx.getPropertyValue]('grid-template');
    }
    set gridTemplate(value) {
      this[dartx.setProperty]('grid-template', value, '');
    }
    get gridTemplateAreas() {
      return this[dartx.getPropertyValue]('grid-template-areas');
    }
    set gridTemplateAreas(value) {
      this[dartx.setProperty]('grid-template-areas', value, '');
    }
    get gridTemplateColumns() {
      return this[dartx.getPropertyValue]('grid-template-columns');
    }
    set gridTemplateColumns(value) {
      this[dartx.setProperty]('grid-template-columns', value, '');
    }
    get gridTemplateRows() {
      return this[dartx.getPropertyValue]('grid-template-rows');
    }
    set gridTemplateRows(value) {
      this[dartx.setProperty]('grid-template-rows', value, '');
    }
    get height() {
      return this[dartx.getPropertyValue]('height');
    }
    set height(value) {
      this[dartx.setProperty]('height', value, '');
    }
    get highlight() {
      return this[dartx.getPropertyValue]('highlight');
    }
    set highlight(value) {
      this[dartx.setProperty]('highlight', value, '');
    }
    get hyphenateCharacter() {
      return this[dartx.getPropertyValue]('hyphenate-character');
    }
    set hyphenateCharacter(value) {
      this[dartx.setProperty]('hyphenate-character', value, '');
    }
    get imageRendering() {
      return this[dartx.getPropertyValue]('image-rendering');
    }
    set imageRendering(value) {
      this[dartx.setProperty]('image-rendering', value, '');
    }
    get isolation() {
      return this[dartx.getPropertyValue]('isolation');
    }
    set isolation(value) {
      this[dartx.setProperty]('isolation', value, '');
    }
    get justifyContent() {
      return this[dartx.getPropertyValue]('justify-content');
    }
    set justifyContent(value) {
      this[dartx.setProperty]('justify-content', value, '');
    }
    get justifySelf() {
      return this[dartx.getPropertyValue]('justify-self');
    }
    set justifySelf(value) {
      this[dartx.setProperty]('justify-self', value, '');
    }
    get left() {
      return this[dartx.getPropertyValue]('left');
    }
    set left(value) {
      this[dartx.setProperty]('left', value, '');
    }
    get letterSpacing() {
      return this[dartx.getPropertyValue]('letter-spacing');
    }
    set letterSpacing(value) {
      this[dartx.setProperty]('letter-spacing', value, '');
    }
    get lineBoxContain() {
      return this[dartx.getPropertyValue]('line-box-contain');
    }
    set lineBoxContain(value) {
      this[dartx.setProperty]('line-box-contain', value, '');
    }
    get lineBreak() {
      return this[dartx.getPropertyValue]('line-break');
    }
    set lineBreak(value) {
      this[dartx.setProperty]('line-break', value, '');
    }
    get lineClamp() {
      return this[dartx.getPropertyValue]('line-clamp');
    }
    set lineClamp(value) {
      this[dartx.setProperty]('line-clamp', value, '');
    }
    get lineHeight() {
      return this[dartx.getPropertyValue]('line-height');
    }
    set lineHeight(value) {
      this[dartx.setProperty]('line-height', value, '');
    }
    get listStyle() {
      return this[dartx.getPropertyValue]('list-style');
    }
    set listStyle(value) {
      this[dartx.setProperty]('list-style', value, '');
    }
    get listStyleImage() {
      return this[dartx.getPropertyValue]('list-style-image');
    }
    set listStyleImage(value) {
      this[dartx.setProperty]('list-style-image', value, '');
    }
    get listStylePosition() {
      return this[dartx.getPropertyValue]('list-style-position');
    }
    set listStylePosition(value) {
      this[dartx.setProperty]('list-style-position', value, '');
    }
    get listStyleType() {
      return this[dartx.getPropertyValue]('list-style-type');
    }
    set listStyleType(value) {
      this[dartx.setProperty]('list-style-type', value, '');
    }
    get locale() {
      return this[dartx.getPropertyValue]('locale');
    }
    set locale(value) {
      this[dartx.setProperty]('locale', value, '');
    }
    get logicalHeight() {
      return this[dartx.getPropertyValue]('logical-height');
    }
    set logicalHeight(value) {
      this[dartx.setProperty]('logical-height', value, '');
    }
    get logicalWidth() {
      return this[dartx.getPropertyValue]('logical-width');
    }
    set logicalWidth(value) {
      this[dartx.setProperty]('logical-width', value, '');
    }
    get margin() {
      return this[dartx.getPropertyValue]('margin');
    }
    set margin(value) {
      this[dartx.setProperty]('margin', value, '');
    }
    get marginAfter() {
      return this[dartx.getPropertyValue]('margin-after');
    }
    set marginAfter(value) {
      this[dartx.setProperty]('margin-after', value, '');
    }
    get marginAfterCollapse() {
      return this[dartx.getPropertyValue]('margin-after-collapse');
    }
    set marginAfterCollapse(value) {
      this[dartx.setProperty]('margin-after-collapse', value, '');
    }
    get marginBefore() {
      return this[dartx.getPropertyValue]('margin-before');
    }
    set marginBefore(value) {
      this[dartx.setProperty]('margin-before', value, '');
    }
    get marginBeforeCollapse() {
      return this[dartx.getPropertyValue]('margin-before-collapse');
    }
    set marginBeforeCollapse(value) {
      this[dartx.setProperty]('margin-before-collapse', value, '');
    }
    get marginBottom() {
      return this[dartx.getPropertyValue]('margin-bottom');
    }
    set marginBottom(value) {
      this[dartx.setProperty]('margin-bottom', value, '');
    }
    get marginBottomCollapse() {
      return this[dartx.getPropertyValue]('margin-bottom-collapse');
    }
    set marginBottomCollapse(value) {
      this[dartx.setProperty]('margin-bottom-collapse', value, '');
    }
    get marginCollapse() {
      return this[dartx.getPropertyValue]('margin-collapse');
    }
    set marginCollapse(value) {
      this[dartx.setProperty]('margin-collapse', value, '');
    }
    get marginEnd() {
      return this[dartx.getPropertyValue]('margin-end');
    }
    set marginEnd(value) {
      this[dartx.setProperty]('margin-end', value, '');
    }
    get marginLeft() {
      return this[dartx.getPropertyValue]('margin-left');
    }
    set marginLeft(value) {
      this[dartx.setProperty]('margin-left', value, '');
    }
    get marginRight() {
      return this[dartx.getPropertyValue]('margin-right');
    }
    set marginRight(value) {
      this[dartx.setProperty]('margin-right', value, '');
    }
    get marginStart() {
      return this[dartx.getPropertyValue]('margin-start');
    }
    set marginStart(value) {
      this[dartx.setProperty]('margin-start', value, '');
    }
    get marginTop() {
      return this[dartx.getPropertyValue]('margin-top');
    }
    set marginTop(value) {
      this[dartx.setProperty]('margin-top', value, '');
    }
    get marginTopCollapse() {
      return this[dartx.getPropertyValue]('margin-top-collapse');
    }
    set marginTopCollapse(value) {
      this[dartx.setProperty]('margin-top-collapse', value, '');
    }
    get mask() {
      return this[dartx.getPropertyValue]('mask');
    }
    set mask(value) {
      this[dartx.setProperty]('mask', value, '');
    }
    get maskBoxImage() {
      return this[dartx.getPropertyValue]('mask-box-image');
    }
    set maskBoxImage(value) {
      this[dartx.setProperty]('mask-box-image', value, '');
    }
    get maskBoxImageOutset() {
      return this[dartx.getPropertyValue]('mask-box-image-outset');
    }
    set maskBoxImageOutset(value) {
      this[dartx.setProperty]('mask-box-image-outset', value, '');
    }
    get maskBoxImageRepeat() {
      return this[dartx.getPropertyValue]('mask-box-image-repeat');
    }
    set maskBoxImageRepeat(value) {
      this[dartx.setProperty]('mask-box-image-repeat', value, '');
    }
    get maskBoxImageSlice() {
      return this[dartx.getPropertyValue]('mask-box-image-slice');
    }
    set maskBoxImageSlice(value) {
      this[dartx.setProperty]('mask-box-image-slice', value, '');
    }
    get maskBoxImageSource() {
      return this[dartx.getPropertyValue]('mask-box-image-source');
    }
    set maskBoxImageSource(value) {
      this[dartx.setProperty]('mask-box-image-source', value, '');
    }
    get maskBoxImageWidth() {
      return this[dartx.getPropertyValue]('mask-box-image-width');
    }
    set maskBoxImageWidth(value) {
      this[dartx.setProperty]('mask-box-image-width', value, '');
    }
    get maskClip() {
      return this[dartx.getPropertyValue]('mask-clip');
    }
    set maskClip(value) {
      this[dartx.setProperty]('mask-clip', value, '');
    }
    get maskComposite() {
      return this[dartx.getPropertyValue]('mask-composite');
    }
    set maskComposite(value) {
      this[dartx.setProperty]('mask-composite', value, '');
    }
    get maskImage() {
      return this[dartx.getPropertyValue]('mask-image');
    }
    set maskImage(value) {
      this[dartx.setProperty]('mask-image', value, '');
    }
    get maskOrigin() {
      return this[dartx.getPropertyValue]('mask-origin');
    }
    set maskOrigin(value) {
      this[dartx.setProperty]('mask-origin', value, '');
    }
    get maskPosition() {
      return this[dartx.getPropertyValue]('mask-position');
    }
    set maskPosition(value) {
      this[dartx.setProperty]('mask-position', value, '');
    }
    get maskPositionX() {
      return this[dartx.getPropertyValue]('mask-position-x');
    }
    set maskPositionX(value) {
      this[dartx.setProperty]('mask-position-x', value, '');
    }
    get maskPositionY() {
      return this[dartx.getPropertyValue]('mask-position-y');
    }
    set maskPositionY(value) {
      this[dartx.setProperty]('mask-position-y', value, '');
    }
    get maskRepeat() {
      return this[dartx.getPropertyValue]('mask-repeat');
    }
    set maskRepeat(value) {
      this[dartx.setProperty]('mask-repeat', value, '');
    }
    get maskRepeatX() {
      return this[dartx.getPropertyValue]('mask-repeat-x');
    }
    set maskRepeatX(value) {
      this[dartx.setProperty]('mask-repeat-x', value, '');
    }
    get maskRepeatY() {
      return this[dartx.getPropertyValue]('mask-repeat-y');
    }
    set maskRepeatY(value) {
      this[dartx.setProperty]('mask-repeat-y', value, '');
    }
    get maskSize() {
      return this[dartx.getPropertyValue]('mask-size');
    }
    set maskSize(value) {
      this[dartx.setProperty]('mask-size', value, '');
    }
    get maskSourceType() {
      return this[dartx.getPropertyValue]('mask-source-type');
    }
    set maskSourceType(value) {
      this[dartx.setProperty]('mask-source-type', value, '');
    }
    get maxHeight() {
      return this[dartx.getPropertyValue]('max-height');
    }
    set maxHeight(value) {
      this[dartx.setProperty]('max-height', value, '');
    }
    get maxLogicalHeight() {
      return this[dartx.getPropertyValue]('max-logical-height');
    }
    set maxLogicalHeight(value) {
      this[dartx.setProperty]('max-logical-height', value, '');
    }
    get maxLogicalWidth() {
      return this[dartx.getPropertyValue]('max-logical-width');
    }
    set maxLogicalWidth(value) {
      this[dartx.setProperty]('max-logical-width', value, '');
    }
    get maxWidth() {
      return this[dartx.getPropertyValue]('max-width');
    }
    set maxWidth(value) {
      this[dartx.setProperty]('max-width', value, '');
    }
    get maxZoom() {
      return this[dartx.getPropertyValue]('max-zoom');
    }
    set maxZoom(value) {
      this[dartx.setProperty]('max-zoom', value, '');
    }
    get minHeight() {
      return this[dartx.getPropertyValue]('min-height');
    }
    set minHeight(value) {
      this[dartx.setProperty]('min-height', value, '');
    }
    get minLogicalHeight() {
      return this[dartx.getPropertyValue]('min-logical-height');
    }
    set minLogicalHeight(value) {
      this[dartx.setProperty]('min-logical-height', value, '');
    }
    get minLogicalWidth() {
      return this[dartx.getPropertyValue]('min-logical-width');
    }
    set minLogicalWidth(value) {
      this[dartx.setProperty]('min-logical-width', value, '');
    }
    get minWidth() {
      return this[dartx.getPropertyValue]('min-width');
    }
    set minWidth(value) {
      this[dartx.setProperty]('min-width', value, '');
    }
    get minZoom() {
      return this[dartx.getPropertyValue]('min-zoom');
    }
    set minZoom(value) {
      this[dartx.setProperty]('min-zoom', value, '');
    }
    get mixBlendMode() {
      return this[dartx.getPropertyValue]('mix-blend-mode');
    }
    set mixBlendMode(value) {
      this[dartx.setProperty]('mix-blend-mode', value, '');
    }
    get objectFit() {
      return this[dartx.getPropertyValue]('object-fit');
    }
    set objectFit(value) {
      this[dartx.setProperty]('object-fit', value, '');
    }
    get objectPosition() {
      return this[dartx.getPropertyValue]('object-position');
    }
    set objectPosition(value) {
      this[dartx.setProperty]('object-position', value, '');
    }
    get opacity() {
      return this[dartx.getPropertyValue]('opacity');
    }
    set opacity(value) {
      this[dartx.setProperty]('opacity', value, '');
    }
    get order() {
      return this[dartx.getPropertyValue]('order');
    }
    set order(value) {
      this[dartx.setProperty]('order', value, '');
    }
    get orientation() {
      return this[dartx.getPropertyValue]('orientation');
    }
    set orientation(value) {
      this[dartx.setProperty]('orientation', value, '');
    }
    get orphans() {
      return this[dartx.getPropertyValue]('orphans');
    }
    set orphans(value) {
      this[dartx.setProperty]('orphans', value, '');
    }
    get outline() {
      return this[dartx.getPropertyValue]('outline');
    }
    set outline(value) {
      this[dartx.setProperty]('outline', value, '');
    }
    get outlineColor() {
      return this[dartx.getPropertyValue]('outline-color');
    }
    set outlineColor(value) {
      this[dartx.setProperty]('outline-color', value, '');
    }
    get outlineOffset() {
      return this[dartx.getPropertyValue]('outline-offset');
    }
    set outlineOffset(value) {
      this[dartx.setProperty]('outline-offset', value, '');
    }
    get outlineStyle() {
      return this[dartx.getPropertyValue]('outline-style');
    }
    set outlineStyle(value) {
      this[dartx.setProperty]('outline-style', value, '');
    }
    get outlineWidth() {
      return this[dartx.getPropertyValue]('outline-width');
    }
    set outlineWidth(value) {
      this[dartx.setProperty]('outline-width', value, '');
    }
    get overflow() {
      return this[dartx.getPropertyValue]('overflow');
    }
    set overflow(value) {
      this[dartx.setProperty]('overflow', value, '');
    }
    get overflowWrap() {
      return this[dartx.getPropertyValue]('overflow-wrap');
    }
    set overflowWrap(value) {
      this[dartx.setProperty]('overflow-wrap', value, '');
    }
    get overflowX() {
      return this[dartx.getPropertyValue]('overflow-x');
    }
    set overflowX(value) {
      this[dartx.setProperty]('overflow-x', value, '');
    }
    get overflowY() {
      return this[dartx.getPropertyValue]('overflow-y');
    }
    set overflowY(value) {
      this[dartx.setProperty]('overflow-y', value, '');
    }
    get padding() {
      return this[dartx.getPropertyValue]('padding');
    }
    set padding(value) {
      this[dartx.setProperty]('padding', value, '');
    }
    get paddingAfter() {
      return this[dartx.getPropertyValue]('padding-after');
    }
    set paddingAfter(value) {
      this[dartx.setProperty]('padding-after', value, '');
    }
    get paddingBefore() {
      return this[dartx.getPropertyValue]('padding-before');
    }
    set paddingBefore(value) {
      this[dartx.setProperty]('padding-before', value, '');
    }
    get paddingBottom() {
      return this[dartx.getPropertyValue]('padding-bottom');
    }
    set paddingBottom(value) {
      this[dartx.setProperty]('padding-bottom', value, '');
    }
    get paddingEnd() {
      return this[dartx.getPropertyValue]('padding-end');
    }
    set paddingEnd(value) {
      this[dartx.setProperty]('padding-end', value, '');
    }
    get paddingLeft() {
      return this[dartx.getPropertyValue]('padding-left');
    }
    set paddingLeft(value) {
      this[dartx.setProperty]('padding-left', value, '');
    }
    get paddingRight() {
      return this[dartx.getPropertyValue]('padding-right');
    }
    set paddingRight(value) {
      this[dartx.setProperty]('padding-right', value, '');
    }
    get paddingStart() {
      return this[dartx.getPropertyValue]('padding-start');
    }
    set paddingStart(value) {
      this[dartx.setProperty]('padding-start', value, '');
    }
    get paddingTop() {
      return this[dartx.getPropertyValue]('padding-top');
    }
    set paddingTop(value) {
      this[dartx.setProperty]('padding-top', value, '');
    }
    get page() {
      return this[dartx.getPropertyValue]('page');
    }
    set page(value) {
      this[dartx.setProperty]('page', value, '');
    }
    get pageBreakAfter() {
      return this[dartx.getPropertyValue]('page-break-after');
    }
    set pageBreakAfter(value) {
      this[dartx.setProperty]('page-break-after', value, '');
    }
    get pageBreakBefore() {
      return this[dartx.getPropertyValue]('page-break-before');
    }
    set pageBreakBefore(value) {
      this[dartx.setProperty]('page-break-before', value, '');
    }
    get pageBreakInside() {
      return this[dartx.getPropertyValue]('page-break-inside');
    }
    set pageBreakInside(value) {
      this[dartx.setProperty]('page-break-inside', value, '');
    }
    get perspective() {
      return this[dartx.getPropertyValue]('perspective');
    }
    set perspective(value) {
      this[dartx.setProperty]('perspective', value, '');
    }
    get perspectiveOrigin() {
      return this[dartx.getPropertyValue]('perspective-origin');
    }
    set perspectiveOrigin(value) {
      this[dartx.setProperty]('perspective-origin', value, '');
    }
    get perspectiveOriginX() {
      return this[dartx.getPropertyValue]('perspective-origin-x');
    }
    set perspectiveOriginX(value) {
      this[dartx.setProperty]('perspective-origin-x', value, '');
    }
    get perspectiveOriginY() {
      return this[dartx.getPropertyValue]('perspective-origin-y');
    }
    set perspectiveOriginY(value) {
      this[dartx.setProperty]('perspective-origin-y', value, '');
    }
    get pointerEvents() {
      return this[dartx.getPropertyValue]('pointer-events');
    }
    set pointerEvents(value) {
      this[dartx.setProperty]('pointer-events', value, '');
    }
    get position() {
      return this[dartx.getPropertyValue]('position');
    }
    set position(value) {
      this[dartx.setProperty]('position', value, '');
    }
    get printColorAdjust() {
      return this[dartx.getPropertyValue]('print-color-adjust');
    }
    set printColorAdjust(value) {
      this[dartx.setProperty]('print-color-adjust', value, '');
    }
    get quotes() {
      return this[dartx.getPropertyValue]('quotes');
    }
    set quotes(value) {
      this[dartx.setProperty]('quotes', value, '');
    }
    get resize() {
      return this[dartx.getPropertyValue]('resize');
    }
    set resize(value) {
      this[dartx.setProperty]('resize', value, '');
    }
    get right() {
      return this[dartx.getPropertyValue]('right');
    }
    set right(value) {
      this[dartx.setProperty]('right', value, '');
    }
    get rtlOrdering() {
      return this[dartx.getPropertyValue]('rtl-ordering');
    }
    set rtlOrdering(value) {
      this[dartx.setProperty]('rtl-ordering', value, '');
    }
    get rubyPosition() {
      return this[dartx.getPropertyValue]('ruby-position');
    }
    set rubyPosition(value) {
      this[dartx.setProperty]('ruby-position', value, '');
    }
    get scrollBehavior() {
      return this[dartx.getPropertyValue]('scroll-behavior');
    }
    set scrollBehavior(value) {
      this[dartx.setProperty]('scroll-behavior', value, '');
    }
    get shapeImageThreshold() {
      return this[dartx.getPropertyValue]('shape-image-threshold');
    }
    set shapeImageThreshold(value) {
      this[dartx.setProperty]('shape-image-threshold', value, '');
    }
    get shapeMargin() {
      return this[dartx.getPropertyValue]('shape-margin');
    }
    set shapeMargin(value) {
      this[dartx.setProperty]('shape-margin', value, '');
    }
    get shapeOutside() {
      return this[dartx.getPropertyValue]('shape-outside');
    }
    set shapeOutside(value) {
      this[dartx.setProperty]('shape-outside', value, '');
    }
    get size() {
      return this[dartx.getPropertyValue]('size');
    }
    set size(value) {
      this[dartx.setProperty]('size', value, '');
    }
    get speak() {
      return this[dartx.getPropertyValue]('speak');
    }
    set speak(value) {
      this[dartx.setProperty]('speak', value, '');
    }
    get src() {
      return this[dartx.getPropertyValue]('src');
    }
    set src(value) {
      this[dartx.setProperty]('src', value, '');
    }
    get tabSize() {
      return this[dartx.getPropertyValue]('tab-size');
    }
    set tabSize(value) {
      this[dartx.setProperty]('tab-size', value, '');
    }
    get tableLayout() {
      return this[dartx.getPropertyValue]('table-layout');
    }
    set tableLayout(value) {
      this[dartx.setProperty]('table-layout', value, '');
    }
    get tapHighlightColor() {
      return this[dartx.getPropertyValue]('tap-highlight-color');
    }
    set tapHighlightColor(value) {
      this[dartx.setProperty]('tap-highlight-color', value, '');
    }
    get textAlign() {
      return this[dartx.getPropertyValue]('text-align');
    }
    set textAlign(value) {
      this[dartx.setProperty]('text-align', value, '');
    }
    get textAlignLast() {
      return this[dartx.getPropertyValue]('text-align-last');
    }
    set textAlignLast(value) {
      this[dartx.setProperty]('text-align-last', value, '');
    }
    get textCombine() {
      return this[dartx.getPropertyValue]('text-combine');
    }
    set textCombine(value) {
      this[dartx.setProperty]('text-combine', value, '');
    }
    get textDecoration() {
      return this[dartx.getPropertyValue]('text-decoration');
    }
    set textDecoration(value) {
      this[dartx.setProperty]('text-decoration', value, '');
    }
    get textDecorationColor() {
      return this[dartx.getPropertyValue]('text-decoration-color');
    }
    set textDecorationColor(value) {
      this[dartx.setProperty]('text-decoration-color', value, '');
    }
    get textDecorationLine() {
      return this[dartx.getPropertyValue]('text-decoration-line');
    }
    set textDecorationLine(value) {
      this[dartx.setProperty]('text-decoration-line', value, '');
    }
    get textDecorationStyle() {
      return this[dartx.getPropertyValue]('text-decoration-style');
    }
    set textDecorationStyle(value) {
      this[dartx.setProperty]('text-decoration-style', value, '');
    }
    get textDecorationsInEffect() {
      return this[dartx.getPropertyValue]('text-decorations-in-effect');
    }
    set textDecorationsInEffect(value) {
      this[dartx.setProperty]('text-decorations-in-effect', value, '');
    }
    get textEmphasis() {
      return this[dartx.getPropertyValue]('text-emphasis');
    }
    set textEmphasis(value) {
      this[dartx.setProperty]('text-emphasis', value, '');
    }
    get textEmphasisColor() {
      return this[dartx.getPropertyValue]('text-emphasis-color');
    }
    set textEmphasisColor(value) {
      this[dartx.setProperty]('text-emphasis-color', value, '');
    }
    get textEmphasisPosition() {
      return this[dartx.getPropertyValue]('text-emphasis-position');
    }
    set textEmphasisPosition(value) {
      this[dartx.setProperty]('text-emphasis-position', value, '');
    }
    get textEmphasisStyle() {
      return this[dartx.getPropertyValue]('text-emphasis-style');
    }
    set textEmphasisStyle(value) {
      this[dartx.setProperty]('text-emphasis-style', value, '');
    }
    get textFillColor() {
      return this[dartx.getPropertyValue]('text-fill-color');
    }
    set textFillColor(value) {
      this[dartx.setProperty]('text-fill-color', value, '');
    }
    get textIndent() {
      return this[dartx.getPropertyValue]('text-indent');
    }
    set textIndent(value) {
      this[dartx.setProperty]('text-indent', value, '');
    }
    get textJustify() {
      return this[dartx.getPropertyValue]('text-justify');
    }
    set textJustify(value) {
      this[dartx.setProperty]('text-justify', value, '');
    }
    get textLineThroughColor() {
      return this[dartx.getPropertyValue]('text-line-through-color');
    }
    set textLineThroughColor(value) {
      this[dartx.setProperty]('text-line-through-color', value, '');
    }
    get textLineThroughMode() {
      return this[dartx.getPropertyValue]('text-line-through-mode');
    }
    set textLineThroughMode(value) {
      this[dartx.setProperty]('text-line-through-mode', value, '');
    }
    get textLineThroughStyle() {
      return this[dartx.getPropertyValue]('text-line-through-style');
    }
    set textLineThroughStyle(value) {
      this[dartx.setProperty]('text-line-through-style', value, '');
    }
    get textLineThroughWidth() {
      return this[dartx.getPropertyValue]('text-line-through-width');
    }
    set textLineThroughWidth(value) {
      this[dartx.setProperty]('text-line-through-width', value, '');
    }
    get textOrientation() {
      return this[dartx.getPropertyValue]('text-orientation');
    }
    set textOrientation(value) {
      this[dartx.setProperty]('text-orientation', value, '');
    }
    get textOverflow() {
      return this[dartx.getPropertyValue]('text-overflow');
    }
    set textOverflow(value) {
      this[dartx.setProperty]('text-overflow', value, '');
    }
    get textOverlineColor() {
      return this[dartx.getPropertyValue]('text-overline-color');
    }
    set textOverlineColor(value) {
      this[dartx.setProperty]('text-overline-color', value, '');
    }
    get textOverlineMode() {
      return this[dartx.getPropertyValue]('text-overline-mode');
    }
    set textOverlineMode(value) {
      this[dartx.setProperty]('text-overline-mode', value, '');
    }
    get textOverlineStyle() {
      return this[dartx.getPropertyValue]('text-overline-style');
    }
    set textOverlineStyle(value) {
      this[dartx.setProperty]('text-overline-style', value, '');
    }
    get textOverlineWidth() {
      return this[dartx.getPropertyValue]('text-overline-width');
    }
    set textOverlineWidth(value) {
      this[dartx.setProperty]('text-overline-width', value, '');
    }
    get textRendering() {
      return this[dartx.getPropertyValue]('text-rendering');
    }
    set textRendering(value) {
      this[dartx.setProperty]('text-rendering', value, '');
    }
    get textSecurity() {
      return this[dartx.getPropertyValue]('text-security');
    }
    set textSecurity(value) {
      this[dartx.setProperty]('text-security', value, '');
    }
    get textShadow() {
      return this[dartx.getPropertyValue]('text-shadow');
    }
    set textShadow(value) {
      this[dartx.setProperty]('text-shadow', value, '');
    }
    get textStroke() {
      return this[dartx.getPropertyValue]('text-stroke');
    }
    set textStroke(value) {
      this[dartx.setProperty]('text-stroke', value, '');
    }
    get textStrokeColor() {
      return this[dartx.getPropertyValue]('text-stroke-color');
    }
    set textStrokeColor(value) {
      this[dartx.setProperty]('text-stroke-color', value, '');
    }
    get textStrokeWidth() {
      return this[dartx.getPropertyValue]('text-stroke-width');
    }
    set textStrokeWidth(value) {
      this[dartx.setProperty]('text-stroke-width', value, '');
    }
    get textTransform() {
      return this[dartx.getPropertyValue]('text-transform');
    }
    set textTransform(value) {
      this[dartx.setProperty]('text-transform', value, '');
    }
    get textUnderlineColor() {
      return this[dartx.getPropertyValue]('text-underline-color');
    }
    set textUnderlineColor(value) {
      this[dartx.setProperty]('text-underline-color', value, '');
    }
    get textUnderlineMode() {
      return this[dartx.getPropertyValue]('text-underline-mode');
    }
    set textUnderlineMode(value) {
      this[dartx.setProperty]('text-underline-mode', value, '');
    }
    get textUnderlinePosition() {
      return this[dartx.getPropertyValue]('text-underline-position');
    }
    set textUnderlinePosition(value) {
      this[dartx.setProperty]('text-underline-position', value, '');
    }
    get textUnderlineStyle() {
      return this[dartx.getPropertyValue]('text-underline-style');
    }
    set textUnderlineStyle(value) {
      this[dartx.setProperty]('text-underline-style', value, '');
    }
    get textUnderlineWidth() {
      return this[dartx.getPropertyValue]('text-underline-width');
    }
    set textUnderlineWidth(value) {
      this[dartx.setProperty]('text-underline-width', value, '');
    }
    get top() {
      return this[dartx.getPropertyValue]('top');
    }
    set top(value) {
      this[dartx.setProperty]('top', value, '');
    }
    get touchAction() {
      return this[dartx.getPropertyValue]('touch-action');
    }
    set touchAction(value) {
      this[dartx.setProperty]('touch-action', value, '');
    }
    get touchActionDelay() {
      return this[dartx.getPropertyValue]('touch-action-delay');
    }
    set touchActionDelay(value) {
      this[dartx.setProperty]('touch-action-delay', value, '');
    }
    get transform() {
      return this[dartx.getPropertyValue]('transform');
    }
    set transform(value) {
      this[dartx.setProperty]('transform', value, '');
    }
    get transformOrigin() {
      return this[dartx.getPropertyValue]('transform-origin');
    }
    set transformOrigin(value) {
      this[dartx.setProperty]('transform-origin', value, '');
    }
    get transformOriginX() {
      return this[dartx.getPropertyValue]('transform-origin-x');
    }
    set transformOriginX(value) {
      this[dartx.setProperty]('transform-origin-x', value, '');
    }
    get transformOriginY() {
      return this[dartx.getPropertyValue]('transform-origin-y');
    }
    set transformOriginY(value) {
      this[dartx.setProperty]('transform-origin-y', value, '');
    }
    get transformOriginZ() {
      return this[dartx.getPropertyValue]('transform-origin-z');
    }
    set transformOriginZ(value) {
      this[dartx.setProperty]('transform-origin-z', value, '');
    }
    get transformStyle() {
      return this[dartx.getPropertyValue]('transform-style');
    }
    set transformStyle(value) {
      this[dartx.setProperty]('transform-style', value, '');
    }
    get transition() {
      return this[dartx.getPropertyValue]('transition');
    }
    set transition(value) {
      this[dartx.setProperty]('transition', value, '');
    }
    get transitionDelay() {
      return this[dartx.getPropertyValue]('transition-delay');
    }
    set transitionDelay(value) {
      this[dartx.setProperty]('transition-delay', value, '');
    }
    get transitionDuration() {
      return this[dartx.getPropertyValue]('transition-duration');
    }
    set transitionDuration(value) {
      this[dartx.setProperty]('transition-duration', value, '');
    }
    get transitionProperty() {
      return this[dartx.getPropertyValue]('transition-property');
    }
    set transitionProperty(value) {
      this[dartx.setProperty]('transition-property', value, '');
    }
    get transitionTimingFunction() {
      return this[dartx.getPropertyValue]('transition-timing-function');
    }
    set transitionTimingFunction(value) {
      this[dartx.setProperty]('transition-timing-function', value, '');
    }
    get unicodeBidi() {
      return this[dartx.getPropertyValue]('unicode-bidi');
    }
    set unicodeBidi(value) {
      this[dartx.setProperty]('unicode-bidi', value, '');
    }
    get unicodeRange() {
      return this[dartx.getPropertyValue]('unicode-range');
    }
    set unicodeRange(value) {
      this[dartx.setProperty]('unicode-range', value, '');
    }
    get userDrag() {
      return this[dartx.getPropertyValue]('user-drag');
    }
    set userDrag(value) {
      this[dartx.setProperty]('user-drag', value, '');
    }
    get userModify() {
      return this[dartx.getPropertyValue]('user-modify');
    }
    set userModify(value) {
      this[dartx.setProperty]('user-modify', value, '');
    }
    get userSelect() {
      return this[dartx.getPropertyValue]('user-select');
    }
    set userSelect(value) {
      this[dartx.setProperty]('user-select', value, '');
    }
    get userZoom() {
      return this[dartx.getPropertyValue]('user-zoom');
    }
    set userZoom(value) {
      this[dartx.setProperty]('user-zoom', value, '');
    }
    get verticalAlign() {
      return this[dartx.getPropertyValue]('vertical-align');
    }
    set verticalAlign(value) {
      this[dartx.setProperty]('vertical-align', value, '');
    }
    get visibility() {
      return this[dartx.getPropertyValue]('visibility');
    }
    set visibility(value) {
      this[dartx.setProperty]('visibility', value, '');
    }
    get whiteSpace() {
      return this[dartx.getPropertyValue]('white-space');
    }
    set whiteSpace(value) {
      this[dartx.setProperty]('white-space', value, '');
    }
    get widows() {
      return this[dartx.getPropertyValue]('widows');
    }
    set widows(value) {
      this[dartx.setProperty]('widows', value, '');
    }
    get width() {
      return this[dartx.getPropertyValue]('width');
    }
    set width(value) {
      this[dartx.setProperty]('width', value, '');
    }
    get willChange() {
      return this[dartx.getPropertyValue]('will-change');
    }
    set willChange(value) {
      this[dartx.setProperty]('will-change', value, '');
    }
    get wordBreak() {
      return this[dartx.getPropertyValue]('word-break');
    }
    set wordBreak(value) {
      this[dartx.setProperty]('word-break', value, '');
    }
    get wordSpacing() {
      return this[dartx.getPropertyValue]('word-spacing');
    }
    set wordSpacing(value) {
      this[dartx.setProperty]('word-spacing', value, '');
    }
    get wordWrap() {
      return this[dartx.getPropertyValue]('word-wrap');
    }
    set wordWrap(value) {
      this[dartx.setProperty]('word-wrap', value, '');
    }
    get wrapFlow() {
      return this[dartx.getPropertyValue]('wrap-flow');
    }
    set wrapFlow(value) {
      this[dartx.setProperty]('wrap-flow', value, '');
    }
    get wrapThrough() {
      return this[dartx.getPropertyValue]('wrap-through');
    }
    set wrapThrough(value) {
      this[dartx.setProperty]('wrap-through', value, '');
    }
    get writingMode() {
      return this[dartx.getPropertyValue]('writing-mode');
    }
    set writingMode(value) {
      this[dartx.setProperty]('writing-mode', value, '');
    }
    get zIndex() {
      return this[dartx.getPropertyValue]('z-index');
    }
    set zIndex(value) {
      this[dartx.setProperty]('z-index', value, '');
    }
    get zoom() {
      return this[dartx.getPropertyValue]('zoom');
    }
    set zoom(value) {
      this[dartx.setProperty]('zoom', value, '');
    }
  };
  dart.setSignature(html$.CssStyleDeclarationBase, {});
  dart.defineExtensionMembers(html$.CssStyleDeclarationBase, [
    'alignContent',
    'alignContent',
    'alignItems',
    'alignItems',
    'alignSelf',
    'alignSelf',
    'animation',
    'animation',
    'animationDelay',
    'animationDelay',
    'animationDirection',
    'animationDirection',
    'animationDuration',
    'animationDuration',
    'animationFillMode',
    'animationFillMode',
    'animationIterationCount',
    'animationIterationCount',
    'animationName',
    'animationName',
    'animationPlayState',
    'animationPlayState',
    'animationTimingFunction',
    'animationTimingFunction',
    'appRegion',
    'appRegion',
    'appearance',
    'appearance',
    'aspectRatio',
    'aspectRatio',
    'backfaceVisibility',
    'backfaceVisibility',
    'background',
    'background',
    'backgroundAttachment',
    'backgroundAttachment',
    'backgroundBlendMode',
    'backgroundBlendMode',
    'backgroundClip',
    'backgroundClip',
    'backgroundColor',
    'backgroundColor',
    'backgroundComposite',
    'backgroundComposite',
    'backgroundImage',
    'backgroundImage',
    'backgroundOrigin',
    'backgroundOrigin',
    'backgroundPosition',
    'backgroundPosition',
    'backgroundPositionX',
    'backgroundPositionX',
    'backgroundPositionY',
    'backgroundPositionY',
    'backgroundRepeat',
    'backgroundRepeat',
    'backgroundRepeatX',
    'backgroundRepeatX',
    'backgroundRepeatY',
    'backgroundRepeatY',
    'backgroundSize',
    'backgroundSize',
    'border',
    'border',
    'borderAfter',
    'borderAfter',
    'borderAfterColor',
    'borderAfterColor',
    'borderAfterStyle',
    'borderAfterStyle',
    'borderAfterWidth',
    'borderAfterWidth',
    'borderBefore',
    'borderBefore',
    'borderBeforeColor',
    'borderBeforeColor',
    'borderBeforeStyle',
    'borderBeforeStyle',
    'borderBeforeWidth',
    'borderBeforeWidth',
    'borderBottom',
    'borderBottom',
    'borderBottomColor',
    'borderBottomColor',
    'borderBottomLeftRadius',
    'borderBottomLeftRadius',
    'borderBottomRightRadius',
    'borderBottomRightRadius',
    'borderBottomStyle',
    'borderBottomStyle',
    'borderBottomWidth',
    'borderBottomWidth',
    'borderCollapse',
    'borderCollapse',
    'borderColor',
    'borderColor',
    'borderEnd',
    'borderEnd',
    'borderEndColor',
    'borderEndColor',
    'borderEndStyle',
    'borderEndStyle',
    'borderEndWidth',
    'borderEndWidth',
    'borderFit',
    'borderFit',
    'borderHorizontalSpacing',
    'borderHorizontalSpacing',
    'borderImage',
    'borderImage',
    'borderImageOutset',
    'borderImageOutset',
    'borderImageRepeat',
    'borderImageRepeat',
    'borderImageSlice',
    'borderImageSlice',
    'borderImageSource',
    'borderImageSource',
    'borderImageWidth',
    'borderImageWidth',
    'borderLeft',
    'borderLeft',
    'borderLeftColor',
    'borderLeftColor',
    'borderLeftStyle',
    'borderLeftStyle',
    'borderLeftWidth',
    'borderLeftWidth',
    'borderRadius',
    'borderRadius',
    'borderRight',
    'borderRight',
    'borderRightColor',
    'borderRightColor',
    'borderRightStyle',
    'borderRightStyle',
    'borderRightWidth',
    'borderRightWidth',
    'borderSpacing',
    'borderSpacing',
    'borderStart',
    'borderStart',
    'borderStartColor',
    'borderStartColor',
    'borderStartStyle',
    'borderStartStyle',
    'borderStartWidth',
    'borderStartWidth',
    'borderStyle',
    'borderStyle',
    'borderTop',
    'borderTop',
    'borderTopColor',
    'borderTopColor',
    'borderTopLeftRadius',
    'borderTopLeftRadius',
    'borderTopRightRadius',
    'borderTopRightRadius',
    'borderTopStyle',
    'borderTopStyle',
    'borderTopWidth',
    'borderTopWidth',
    'borderVerticalSpacing',
    'borderVerticalSpacing',
    'borderWidth',
    'borderWidth',
    'bottom',
    'bottom',
    'boxAlign',
    'boxAlign',
    'boxDecorationBreak',
    'boxDecorationBreak',
    'boxDirection',
    'boxDirection',
    'boxFlex',
    'boxFlex',
    'boxFlexGroup',
    'boxFlexGroup',
    'boxLines',
    'boxLines',
    'boxOrdinalGroup',
    'boxOrdinalGroup',
    'boxOrient',
    'boxOrient',
    'boxPack',
    'boxPack',
    'boxReflect',
    'boxReflect',
    'boxShadow',
    'boxShadow',
    'boxSizing',
    'boxSizing',
    'captionSide',
    'captionSide',
    'clear',
    'clear',
    'clip',
    'clip',
    'clipPath',
    'clipPath',
    'color',
    'color',
    'columnBreakAfter',
    'columnBreakAfter',
    'columnBreakBefore',
    'columnBreakBefore',
    'columnBreakInside',
    'columnBreakInside',
    'columnCount',
    'columnCount',
    'columnFill',
    'columnFill',
    'columnGap',
    'columnGap',
    'columnRule',
    'columnRule',
    'columnRuleColor',
    'columnRuleColor',
    'columnRuleStyle',
    'columnRuleStyle',
    'columnRuleWidth',
    'columnRuleWidth',
    'columnSpan',
    'columnSpan',
    'columnWidth',
    'columnWidth',
    'columns',
    'columns',
    'content',
    'content',
    'counterIncrement',
    'counterIncrement',
    'counterReset',
    'counterReset',
    'cursor',
    'cursor',
    'direction',
    'direction',
    'display',
    'display',
    'emptyCells',
    'emptyCells',
    'filter',
    'filter',
    'flex',
    'flex',
    'flexBasis',
    'flexBasis',
    'flexDirection',
    'flexDirection',
    'flexFlow',
    'flexFlow',
    'flexGrow',
    'flexGrow',
    'flexShrink',
    'flexShrink',
    'flexWrap',
    'flexWrap',
    'float',
    'float',
    'font',
    'font',
    'fontFamily',
    'fontFamily',
    'fontFeatureSettings',
    'fontFeatureSettings',
    'fontKerning',
    'fontKerning',
    'fontSize',
    'fontSize',
    'fontSizeDelta',
    'fontSizeDelta',
    'fontSmoothing',
    'fontSmoothing',
    'fontStretch',
    'fontStretch',
    'fontStyle',
    'fontStyle',
    'fontVariant',
    'fontVariant',
    'fontVariantLigatures',
    'fontVariantLigatures',
    'fontWeight',
    'fontWeight',
    'grid',
    'grid',
    'gridArea',
    'gridArea',
    'gridAutoColumns',
    'gridAutoColumns',
    'gridAutoFlow',
    'gridAutoFlow',
    'gridAutoRows',
    'gridAutoRows',
    'gridColumn',
    'gridColumn',
    'gridColumnEnd',
    'gridColumnEnd',
    'gridColumnStart',
    'gridColumnStart',
    'gridRow',
    'gridRow',
    'gridRowEnd',
    'gridRowEnd',
    'gridRowStart',
    'gridRowStart',
    'gridTemplate',
    'gridTemplate',
    'gridTemplateAreas',
    'gridTemplateAreas',
    'gridTemplateColumns',
    'gridTemplateColumns',
    'gridTemplateRows',
    'gridTemplateRows',
    'height',
    'height',
    'highlight',
    'highlight',
    'hyphenateCharacter',
    'hyphenateCharacter',
    'imageRendering',
    'imageRendering',
    'isolation',
    'isolation',
    'justifyContent',
    'justifyContent',
    'justifySelf',
    'justifySelf',
    'left',
    'left',
    'letterSpacing',
    'letterSpacing',
    'lineBoxContain',
    'lineBoxContain',
    'lineBreak',
    'lineBreak',
    'lineClamp',
    'lineClamp',
    'lineHeight',
    'lineHeight',
    'listStyle',
    'listStyle',
    'listStyleImage',
    'listStyleImage',
    'listStylePosition',
    'listStylePosition',
    'listStyleType',
    'listStyleType',
    'locale',
    'locale',
    'logicalHeight',
    'logicalHeight',
    'logicalWidth',
    'logicalWidth',
    'margin',
    'margin',
    'marginAfter',
    'marginAfter',
    'marginAfterCollapse',
    'marginAfterCollapse',
    'marginBefore',
    'marginBefore',
    'marginBeforeCollapse',
    'marginBeforeCollapse',
    'marginBottom',
    'marginBottom',
    'marginBottomCollapse',
    'marginBottomCollapse',
    'marginCollapse',
    'marginCollapse',
    'marginEnd',
    'marginEnd',
    'marginLeft',
    'marginLeft',
    'marginRight',
    'marginRight',
    'marginStart',
    'marginStart',
    'marginTop',
    'marginTop',
    'marginTopCollapse',
    'marginTopCollapse',
    'mask',
    'mask',
    'maskBoxImage',
    'maskBoxImage',
    'maskBoxImageOutset',
    'maskBoxImageOutset',
    'maskBoxImageRepeat',
    'maskBoxImageRepeat',
    'maskBoxImageSlice',
    'maskBoxImageSlice',
    'maskBoxImageSource',
    'maskBoxImageSource',
    'maskBoxImageWidth',
    'maskBoxImageWidth',
    'maskClip',
    'maskClip',
    'maskComposite',
    'maskComposite',
    'maskImage',
    'maskImage',
    'maskOrigin',
    'maskOrigin',
    'maskPosition',
    'maskPosition',
    'maskPositionX',
    'maskPositionX',
    'maskPositionY',
    'maskPositionY',
    'maskRepeat',
    'maskRepeat',
    'maskRepeatX',
    'maskRepeatX',
    'maskRepeatY',
    'maskRepeatY',
    'maskSize',
    'maskSize',
    'maskSourceType',
    'maskSourceType',
    'maxHeight',
    'maxHeight',
    'maxLogicalHeight',
    'maxLogicalHeight',
    'maxLogicalWidth',
    'maxLogicalWidth',
    'maxWidth',
    'maxWidth',
    'maxZoom',
    'maxZoom',
    'minHeight',
    'minHeight',
    'minLogicalHeight',
    'minLogicalHeight',
    'minLogicalWidth',
    'minLogicalWidth',
    'minWidth',
    'minWidth',
    'minZoom',
    'minZoom',
    'mixBlendMode',
    'mixBlendMode',
    'objectFit',
    'objectFit',
    'objectPosition',
    'objectPosition',
    'opacity',
    'opacity',
    'order',
    'order',
    'orientation',
    'orientation',
    'orphans',
    'orphans',
    'outline',
    'outline',
    'outlineColor',
    'outlineColor',
    'outlineOffset',
    'outlineOffset',
    'outlineStyle',
    'outlineStyle',
    'outlineWidth',
    'outlineWidth',
    'overflow',
    'overflow',
    'overflowWrap',
    'overflowWrap',
    'overflowX',
    'overflowX',
    'overflowY',
    'overflowY',
    'padding',
    'padding',
    'paddingAfter',
    'paddingAfter',
    'paddingBefore',
    'paddingBefore',
    'paddingBottom',
    'paddingBottom',
    'paddingEnd',
    'paddingEnd',
    'paddingLeft',
    'paddingLeft',
    'paddingRight',
    'paddingRight',
    'paddingStart',
    'paddingStart',
    'paddingTop',
    'paddingTop',
    'page',
    'page',
    'pageBreakAfter',
    'pageBreakAfter',
    'pageBreakBefore',
    'pageBreakBefore',
    'pageBreakInside',
    'pageBreakInside',
    'perspective',
    'perspective',
    'perspectiveOrigin',
    'perspectiveOrigin',
    'perspectiveOriginX',
    'perspectiveOriginX',
    'perspectiveOriginY',
    'perspectiveOriginY',
    'pointerEvents',
    'pointerEvents',
    'position',
    'position',
    'printColorAdjust',
    'printColorAdjust',
    'quotes',
    'quotes',
    'resize',
    'resize',
    'right',
    'right',
    'rtlOrdering',
    'rtlOrdering',
    'rubyPosition',
    'rubyPosition',
    'scrollBehavior',
    'scrollBehavior',
    'shapeImageThreshold',
    'shapeImageThreshold',
    'shapeMargin',
    'shapeMargin',
    'shapeOutside',
    'shapeOutside',
    'size',
    'size',
    'speak',
    'speak',
    'src',
    'src',
    'tabSize',
    'tabSize',
    'tableLayout',
    'tableLayout',
    'tapHighlightColor',
    'tapHighlightColor',
    'textAlign',
    'textAlign',
    'textAlignLast',
    'textAlignLast',
    'textCombine',
    'textCombine',
    'textDecoration',
    'textDecoration',
    'textDecorationColor',
    'textDecorationColor',
    'textDecorationLine',
    'textDecorationLine',
    'textDecorationStyle',
    'textDecorationStyle',
    'textDecorationsInEffect',
    'textDecorationsInEffect',
    'textEmphasis',
    'textEmphasis',
    'textEmphasisColor',
    'textEmphasisColor',
    'textEmphasisPosition',
    'textEmphasisPosition',
    'textEmphasisStyle',
    'textEmphasisStyle',
    'textFillColor',
    'textFillColor',
    'textIndent',
    'textIndent',
    'textJustify',
    'textJustify',
    'textLineThroughColor',
    'textLineThroughColor',
    'textLineThroughMode',
    'textLineThroughMode',
    'textLineThroughStyle',
    'textLineThroughStyle',
    'textLineThroughWidth',
    'textLineThroughWidth',
    'textOrientation',
    'textOrientation',
    'textOverflow',
    'textOverflow',
    'textOverlineColor',
    'textOverlineColor',
    'textOverlineMode',
    'textOverlineMode',
    'textOverlineStyle',
    'textOverlineStyle',
    'textOverlineWidth',
    'textOverlineWidth',
    'textRendering',
    'textRendering',
    'textSecurity',
    'textSecurity',
    'textShadow',
    'textShadow',
    'textStroke',
    'textStroke',
    'textStrokeColor',
    'textStrokeColor',
    'textStrokeWidth',
    'textStrokeWidth',
    'textTransform',
    'textTransform',
    'textUnderlineColor',
    'textUnderlineColor',
    'textUnderlineMode',
    'textUnderlineMode',
    'textUnderlinePosition',
    'textUnderlinePosition',
    'textUnderlineStyle',
    'textUnderlineStyle',
    'textUnderlineWidth',
    'textUnderlineWidth',
    'top',
    'top',
    'touchAction',
    'touchAction',
    'touchActionDelay',
    'touchActionDelay',
    'transform',
    'transform',
    'transformOrigin',
    'transformOrigin',
    'transformOriginX',
    'transformOriginX',
    'transformOriginY',
    'transformOriginY',
    'transformOriginZ',
    'transformOriginZ',
    'transformStyle',
    'transformStyle',
    'transition',
    'transition',
    'transitionDelay',
    'transitionDelay',
    'transitionDuration',
    'transitionDuration',
    'transitionProperty',
    'transitionProperty',
    'transitionTimingFunction',
    'transitionTimingFunction',
    'unicodeBidi',
    'unicodeBidi',
    'unicodeRange',
    'unicodeRange',
    'userDrag',
    'userDrag',
    'userModify',
    'userModify',
    'userSelect',
    'userSelect',
    'userZoom',
    'userZoom',
    'verticalAlign',
    'verticalAlign',
    'visibility',
    'visibility',
    'whiteSpace',
    'whiteSpace',
    'widows',
    'widows',
    'width',
    'width',
    'willChange',
    'willChange',
    'wordBreak',
    'wordBreak',
    'wordSpacing',
    'wordSpacing',
    'wordWrap',
    'wordWrap',
    'wrapFlow',
    'wrapFlow',
    'wrapThrough',
    'wrapThrough',
    'writingMode',
    'writingMode',
    'zIndex',
    'zIndex',
    'zoom',
    'zoom'
  ]);
  dart.defineExtensionNames([
    'getPropertyValue',
    'supportsProperty',
    'setProperty',
    'getPropertyPriority',
    'item',
    'removeProperty',
    'background',
    'background',
    'backgroundAttachment',
    'backgroundAttachment',
    'backgroundColor',
    'backgroundColor',
    'backgroundImage',
    'backgroundImage',
    'backgroundPosition',
    'backgroundPosition',
    'backgroundRepeat',
    'backgroundRepeat',
    'border',
    'border',
    'borderBottom',
    'borderBottom',
    'borderBottomColor',
    'borderBottomColor',
    'borderBottomStyle',
    'borderBottomStyle',
    'borderBottomWidth',
    'borderBottomWidth',
    'borderCollapse',
    'borderCollapse',
    'borderColor',
    'borderColor',
    'borderLeft',
    'borderLeft',
    'borderLeftColor',
    'borderLeftColor',
    'borderLeftStyle',
    'borderLeftStyle',
    'borderLeftWidth',
    'borderLeftWidth',
    'borderRight',
    'borderRight',
    'borderRightColor',
    'borderRightColor',
    'borderRightStyle',
    'borderRightStyle',
    'borderRightWidth',
    'borderRightWidth',
    'borderSpacing',
    'borderSpacing',
    'borderStyle',
    'borderStyle',
    'borderTop',
    'borderTop',
    'borderTopColor',
    'borderTopColor',
    'borderTopStyle',
    'borderTopStyle',
    'borderTopWidth',
    'borderTopWidth',
    'borderWidth',
    'borderWidth',
    'bottom',
    'bottom',
    'captionSide',
    'captionSide',
    'clear',
    'clear',
    'clip',
    'clip',
    'color',
    'color',
    'content',
    'content',
    'cursor',
    'cursor',
    'direction',
    'direction',
    'display',
    'display',
    'emptyCells',
    'emptyCells',
    'font',
    'font',
    'fontFamily',
    'fontFamily',
    'fontSize',
    'fontSize',
    'fontStyle',
    'fontStyle',
    'fontVariant',
    'fontVariant',
    'fontWeight',
    'fontWeight',
    'height',
    'height',
    'left',
    'left',
    'letterSpacing',
    'letterSpacing',
    'lineHeight',
    'lineHeight',
    'listStyle',
    'listStyle',
    'listStyleImage',
    'listStyleImage',
    'listStylePosition',
    'listStylePosition',
    'listStyleType',
    'listStyleType',
    'margin',
    'margin',
    'marginBottom',
    'marginBottom',
    'marginLeft',
    'marginLeft',
    'marginRight',
    'marginRight',
    'marginTop',
    'marginTop',
    'maxHeight',
    'maxHeight',
    'maxWidth',
    'maxWidth',
    'minHeight',
    'minHeight',
    'minWidth',
    'minWidth',
    'outline',
    'outline',
    'outlineColor',
    'outlineColor',
    'outlineStyle',
    'outlineStyle',
    'outlineWidth',
    'outlineWidth',
    'overflow',
    'overflow',
    'padding',
    'padding',
    'paddingBottom',
    'paddingBottom',
    'paddingLeft',
    'paddingLeft',
    'paddingRight',
    'paddingRight',
    'paddingTop',
    'paddingTop',
    'pageBreakAfter',
    'pageBreakAfter',
    'pageBreakBefore',
    'pageBreakBefore',
    'pageBreakInside',
    'pageBreakInside',
    'position',
    'position',
    'quotes',
    'quotes',
    'right',
    'right',
    'tableLayout',
    'tableLayout',
    'textAlign',
    'textAlign',
    'textDecoration',
    'textDecoration',
    'textIndent',
    'textIndent',
    'textTransform',
    'textTransform',
    'top',
    'top',
    'unicodeBidi',
    'unicodeBidi',
    'verticalAlign',
    'verticalAlign',
    'visibility',
    'visibility',
    'whiteSpace',
    'whiteSpace',
    'width',
    'width',
    'wordSpacing',
    'wordSpacing',
    'zIndex',
    'zIndex',
    'cssText',
    'length',
    'parentRule'
  ]);
  html$.CssStyleDeclaration = class CssStyleDeclaration extends dart.mixin(_interceptors.Interceptor, html$.CssStyleDeclarationBase) {
    static new() {
      return html$.CssStyleDeclaration.css('');
    }
    static css(css) {
      let style = html$.Element.tag('div')[dartx.style];
      style[dartx.cssText] = css;
      return style;
    }
    [dartx.getPropertyValue](propertyName) {
      let propValue = this[_getPropertyValueHelper](propertyName);
      return propValue != null ? propValue : '';
    }
    [_getPropertyValueHelper](propertyName) {
      if (dart.test(this[_supportsProperty](html$.CssStyleDeclaration._camelCase(propertyName)))) {
        return this[_getPropertyValue](propertyName);
      } else {
        return this[_getPropertyValue](dart.notNull(html_common.Device.cssPrefix) + dart.notNull(propertyName));
      }
    }
    [dartx.supportsProperty](propertyName) {
      return dart.test(this[_supportsProperty](propertyName)) || dart.test(this[_supportsProperty](html$.CssStyleDeclaration._camelCase(dart.notNull(html_common.Device.cssPrefix) + dart.notNull(propertyName))));
    }
    [_supportsProperty](propertyName) {
      return propertyName in this;
    }
    [dartx.setProperty](propertyName, value, priority) {
      if (priority === void 0) priority = null;
      return this[_setPropertyHelper](this[_browserPropertyName](propertyName), value, priority);
    }
    [_browserPropertyName](propertyName) {
      let name = html$.CssStyleDeclaration._readCache(propertyName);
      if (typeof name == 'string') return name;
      if (dart.test(this[_supportsProperty](html$.CssStyleDeclaration._camelCase(propertyName)))) {
        name = propertyName;
      } else {
        name = dart.notNull(html_common.Device.cssPrefix) + dart.notNull(propertyName);
      }
      html$.CssStyleDeclaration._writeCache(propertyName, name);
      return name;
    }
    static _readCache(key) {
      return html$.CssStyleDeclaration._propertyCache[key];
    }
    static _writeCache(key, value) {
      html$.CssStyleDeclaration._propertyCache[key] = value;
    }
    static _camelCase(hyphenated) {
      let replacedMs = hyphenated.replace(/^-ms-/, "ms-");
      let fToUpper = const$48 || (const$48 = dart.const(new _foreign_helper.JS_CONST('function(_, letter) { return letter.toUpperCase(); }')));
      return replacedMs.replace(/-([\da-z])/ig, fToUpper);
    }
    [_setPropertyHelper](propertyName, value, priority) {
      if (priority === void 0) priority = null;
      if (value == null) value = '';
      if (priority == null) priority = '';
      this.setProperty(propertyName, value, priority);
    }
    static get supportsTransitions() {
      return html$.document[dartx.body][dartx.style][dartx.supportsProperty]('transition');
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.cssText]() {
      return this.cssText;
    }
    set [dartx.cssText](value) {
      this.cssText = value;
    }
    get [dartx.length]() {
      return this.length;
    }
    get [dartx.parentRule]() {
      return this.parentRule;
    }
    [dartx.getPropertyPriority](property) {
      return this.getPropertyPriority(property);
    }
    [_getPropertyValue](property) {
      return this.getPropertyValue(property);
    }
    [dartx.item](index) {
      return this.item(index);
    }
    [dartx.removeProperty](property) {
      return this.removeProperty(property);
    }
    get [dartx.background]() {
      return this[_background];
    }
    set [dartx.background](value) {
      this[_background] = value == null ? '' : value;
    }
    get [_background]() {
      return this.background;
    }
    set [_background](value) {
      this.background = value;
    }
    get [dartx.backgroundAttachment]() {
      return this[_backgroundAttachment];
    }
    set [dartx.backgroundAttachment](value) {
      this[_backgroundAttachment] = value == null ? '' : value;
    }
    get [_backgroundAttachment]() {
      return this.backgroundAttachment;
    }
    set [_backgroundAttachment](value) {
      this.backgroundAttachment = value;
    }
    get [dartx.backgroundColor]() {
      return this[_backgroundColor];
    }
    set [dartx.backgroundColor](value) {
      this[_backgroundColor] = value == null ? '' : value;
    }
    get [_backgroundColor]() {
      return this.backgroundColor;
    }
    set [_backgroundColor](value) {
      this.backgroundColor = value;
    }
    get [dartx.backgroundImage]() {
      return this[_backgroundImage];
    }
    set [dartx.backgroundImage](value) {
      this[_backgroundImage] = value == null ? '' : value;
    }
    get [_backgroundImage]() {
      return this.backgroundImage;
    }
    set [_backgroundImage](value) {
      this.backgroundImage = value;
    }
    get [dartx.backgroundPosition]() {
      return this[_backgroundPosition];
    }
    set [dartx.backgroundPosition](value) {
      this[_backgroundPosition] = value == null ? '' : value;
    }
    get [_backgroundPosition]() {
      return this.backgroundPosition;
    }
    set [_backgroundPosition](value) {
      this.backgroundPosition = value;
    }
    get [dartx.backgroundRepeat]() {
      return this[_backgroundRepeat];
    }
    set [dartx.backgroundRepeat](value) {
      this[_backgroundRepeat] = value == null ? '' : value;
    }
    get [_backgroundRepeat]() {
      return this.backgroundRepeat;
    }
    set [_backgroundRepeat](value) {
      this.backgroundRepeat = value;
    }
    get [dartx.border]() {
      return this[_border];
    }
    set [dartx.border](value) {
      this[_border] = value == null ? '' : value;
    }
    get [_border]() {
      return this.border;
    }
    set [_border](value) {
      this.border = value;
    }
    get [dartx.borderBottom]() {
      return this[_borderBottom];
    }
    set [dartx.borderBottom](value) {
      this[_borderBottom] = value == null ? '' : value;
    }
    get [_borderBottom]() {
      return this.borderBottom;
    }
    set [_borderBottom](value) {
      this.borderBottom = value;
    }
    get [dartx.borderBottomColor]() {
      return this[_borderBottomColor];
    }
    set [dartx.borderBottomColor](value) {
      this[_borderBottomColor] = value == null ? '' : value;
    }
    get [_borderBottomColor]() {
      return this.borderBottomColor;
    }
    set [_borderBottomColor](value) {
      this.borderBottomColor = value;
    }
    get [dartx.borderBottomStyle]() {
      return this[_borderBottomStyle];
    }
    set [dartx.borderBottomStyle](value) {
      this[_borderBottomStyle] = value == null ? '' : value;
    }
    get [_borderBottomStyle]() {
      return this.borderBottomStyle;
    }
    set [_borderBottomStyle](value) {
      this.borderBottomStyle = value;
    }
    get [dartx.borderBottomWidth]() {
      return this[_borderBottomWidth];
    }
    set [dartx.borderBottomWidth](value) {
      this[_borderBottomWidth] = value == null ? '' : value;
    }
    get [_borderBottomWidth]() {
      return this.borderBottomWidth;
    }
    set [_borderBottomWidth](value) {
      this.borderBottomWidth = value;
    }
    get [dartx.borderCollapse]() {
      return this[_borderCollapse];
    }
    set [dartx.borderCollapse](value) {
      this[_borderCollapse] = value == null ? '' : value;
    }
    get [_borderCollapse]() {
      return this.borderCollapse;
    }
    set [_borderCollapse](value) {
      this.borderCollapse = value;
    }
    get [dartx.borderColor]() {
      return this[_borderColor];
    }
    set [dartx.borderColor](value) {
      this[_borderColor] = value == null ? '' : value;
    }
    get [_borderColor]() {
      return this.borderColor;
    }
    set [_borderColor](value) {
      this.borderColor = value;
    }
    get [dartx.borderLeft]() {
      return this[_borderLeft];
    }
    set [dartx.borderLeft](value) {
      this[_borderLeft] = value == null ? '' : value;
    }
    get [_borderLeft]() {
      return this.borderLeft;
    }
    set [_borderLeft](value) {
      this.borderLeft = value;
    }
    get [dartx.borderLeftColor]() {
      return this[_borderLeftColor];
    }
    set [dartx.borderLeftColor](value) {
      this[_borderLeftColor] = value == null ? '' : value;
    }
    get [_borderLeftColor]() {
      return this.borderLeftColor;
    }
    set [_borderLeftColor](value) {
      this.borderLeftColor = value;
    }
    get [dartx.borderLeftStyle]() {
      return this[_borderLeftStyle];
    }
    set [dartx.borderLeftStyle](value) {
      this[_borderLeftStyle] = value == null ? '' : value;
    }
    get [_borderLeftStyle]() {
      return this.borderLeftStyle;
    }
    set [_borderLeftStyle](value) {
      this.borderLeftStyle = value;
    }
    get [dartx.borderLeftWidth]() {
      return this[_borderLeftWidth];
    }
    set [dartx.borderLeftWidth](value) {
      this[_borderLeftWidth] = value == null ? '' : value;
    }
    get [_borderLeftWidth]() {
      return this.borderLeftWidth;
    }
    set [_borderLeftWidth](value) {
      this.borderLeftWidth = value;
    }
    get [dartx.borderRight]() {
      return this[_borderRight];
    }
    set [dartx.borderRight](value) {
      this[_borderRight] = value == null ? '' : value;
    }
    get [_borderRight]() {
      return this.borderRight;
    }
    set [_borderRight](value) {
      this.borderRight = value;
    }
    get [dartx.borderRightColor]() {
      return this[_borderRightColor];
    }
    set [dartx.borderRightColor](value) {
      this[_borderRightColor] = value == null ? '' : value;
    }
    get [_borderRightColor]() {
      return this.borderRightColor;
    }
    set [_borderRightColor](value) {
      this.borderRightColor = value;
    }
    get [dartx.borderRightStyle]() {
      return this[_borderRightStyle];
    }
    set [dartx.borderRightStyle](value) {
      this[_borderRightStyle] = value == null ? '' : value;
    }
    get [_borderRightStyle]() {
      return this.borderRightStyle;
    }
    set [_borderRightStyle](value) {
      this.borderRightStyle = value;
    }
    get [dartx.borderRightWidth]() {
      return this[_borderRightWidth];
    }
    set [dartx.borderRightWidth](value) {
      this[_borderRightWidth] = value == null ? '' : value;
    }
    get [_borderRightWidth]() {
      return this.borderRightWidth;
    }
    set [_borderRightWidth](value) {
      this.borderRightWidth = value;
    }
    get [dartx.borderSpacing]() {
      return this[_borderSpacing];
    }
    set [dartx.borderSpacing](value) {
      this[_borderSpacing] = value == null ? '' : value;
    }
    get [_borderSpacing]() {
      return this.borderSpacing;
    }
    set [_borderSpacing](value) {
      this.borderSpacing = value;
    }
    get [dartx.borderStyle]() {
      return this[_borderStyle];
    }
    set [dartx.borderStyle](value) {
      this[_borderStyle] = value == null ? '' : value;
    }
    get [_borderStyle]() {
      return this.borderStyle;
    }
    set [_borderStyle](value) {
      this.borderStyle = value;
    }
    get [dartx.borderTop]() {
      return this[_borderTop];
    }
    set [dartx.borderTop](value) {
      this[_borderTop] = value == null ? '' : value;
    }
    get [_borderTop]() {
      return this.borderTop;
    }
    set [_borderTop](value) {
      this.borderTop = value;
    }
    get [dartx.borderTopColor]() {
      return this[_borderTopColor];
    }
    set [dartx.borderTopColor](value) {
      this[_borderTopColor] = value == null ? '' : value;
    }
    get [_borderTopColor]() {
      return this.borderTopColor;
    }
    set [_borderTopColor](value) {
      this.borderTopColor = value;
    }
    get [dartx.borderTopStyle]() {
      return this[_borderTopStyle];
    }
    set [dartx.borderTopStyle](value) {
      this[_borderTopStyle] = value == null ? '' : value;
    }
    get [_borderTopStyle]() {
      return this.borderTopStyle;
    }
    set [_borderTopStyle](value) {
      this.borderTopStyle = value;
    }
    get [dartx.borderTopWidth]() {
      return this[_borderTopWidth];
    }
    set [dartx.borderTopWidth](value) {
      this[_borderTopWidth] = value == null ? '' : value;
    }
    get [_borderTopWidth]() {
      return this.borderTopWidth;
    }
    set [_borderTopWidth](value) {
      this.borderTopWidth = value;
    }
    get [dartx.borderWidth]() {
      return this[_borderWidth];
    }
    set [dartx.borderWidth](value) {
      this[_borderWidth] = value == null ? '' : value;
    }
    get [_borderWidth]() {
      return this.borderWidth;
    }
    set [_borderWidth](value) {
      this.borderWidth = value;
    }
    get [dartx.bottom]() {
      return this[_bottom];
    }
    set [dartx.bottom](value) {
      this[_bottom] = value == null ? '' : value;
    }
    get [_bottom]() {
      return this.bottom;
    }
    set [_bottom](value) {
      this.bottom = value;
    }
    get [dartx.captionSide]() {
      return this[_captionSide];
    }
    set [dartx.captionSide](value) {
      this[_captionSide] = value == null ? '' : value;
    }
    get [_captionSide]() {
      return this.captionSide;
    }
    set [_captionSide](value) {
      this.captionSide = value;
    }
    get [dartx.clear]() {
      return this[_clear$1];
    }
    set [dartx.clear](value) {
      this[_clear$1] = value == null ? '' : value;
    }
    get [_clear$1]() {
      return this.clear;
    }
    set [_clear$1](value) {
      this.clear = value;
    }
    get [dartx.clip]() {
      return this[_clip];
    }
    set [dartx.clip](value) {
      this[_clip] = value == null ? '' : value;
    }
    get [_clip]() {
      return this.clip;
    }
    set [_clip](value) {
      this.clip = value;
    }
    get [dartx.color]() {
      return this[_color];
    }
    set [dartx.color](value) {
      this[_color] = value == null ? '' : value;
    }
    get [_color]() {
      return this.color;
    }
    set [_color](value) {
      this.color = value;
    }
    get [dartx.content]() {
      return this[_content];
    }
    set [dartx.content](value) {
      this[_content] = value == null ? '' : value;
    }
    get [_content]() {
      return this.content;
    }
    set [_content](value) {
      this.content = value;
    }
    get [dartx.cursor]() {
      return this[_cursor];
    }
    set [dartx.cursor](value) {
      this[_cursor] = value == null ? '' : value;
    }
    get [_cursor]() {
      return this.cursor;
    }
    set [_cursor](value) {
      this.cursor = value;
    }
    get [dartx.direction]() {
      return this[_direction];
    }
    set [dartx.direction](value) {
      this[_direction] = value == null ? '' : value;
    }
    get [_direction]() {
      return this.direction;
    }
    set [_direction](value) {
      this.direction = value;
    }
    get [dartx.display]() {
      return this[_display];
    }
    set [dartx.display](value) {
      this[_display] = value == null ? '' : value;
    }
    get [_display]() {
      return this.display;
    }
    set [_display](value) {
      this.display = value;
    }
    get [dartx.emptyCells]() {
      return this[_emptyCells];
    }
    set [dartx.emptyCells](value) {
      this[_emptyCells] = value == null ? '' : value;
    }
    get [_emptyCells]() {
      return this.emptyCells;
    }
    set [_emptyCells](value) {
      this.emptyCells = value;
    }
    get [dartx.font]() {
      return this[_font];
    }
    set [dartx.font](value) {
      this[_font] = value == null ? '' : value;
    }
    get [_font]() {
      return this.font;
    }
    set [_font](value) {
      this.font = value;
    }
    get [dartx.fontFamily]() {
      return this[_fontFamily];
    }
    set [dartx.fontFamily](value) {
      this[_fontFamily] = value == null ? '' : value;
    }
    get [_fontFamily]() {
      return this.fontFamily;
    }
    set [_fontFamily](value) {
      this.fontFamily = value;
    }
    get [dartx.fontSize]() {
      return this[_fontSize];
    }
    set [dartx.fontSize](value) {
      this[_fontSize] = value == null ? '' : value;
    }
    get [_fontSize]() {
      return this.fontSize;
    }
    set [_fontSize](value) {
      this.fontSize = value;
    }
    get [dartx.fontStyle]() {
      return this[_fontStyle];
    }
    set [dartx.fontStyle](value) {
      this[_fontStyle] = value == null ? '' : value;
    }
    get [_fontStyle]() {
      return this.fontStyle;
    }
    set [_fontStyle](value) {
      this.fontStyle = value;
    }
    get [dartx.fontVariant]() {
      return this[_fontVariant];
    }
    set [dartx.fontVariant](value) {
      this[_fontVariant] = value == null ? '' : value;
    }
    get [_fontVariant]() {
      return this.fontVariant;
    }
    set [_fontVariant](value) {
      this.fontVariant = value;
    }
    get [dartx.fontWeight]() {
      return this[_fontWeight];
    }
    set [dartx.fontWeight](value) {
      this[_fontWeight] = value == null ? '' : value;
    }
    get [_fontWeight]() {
      return this.fontWeight;
    }
    set [_fontWeight](value) {
      this.fontWeight = value;
    }
    get [dartx.height]() {
      return this[_height$];
    }
    set [dartx.height](value) {
      this[_height$] = value == null ? '' : value;
    }
    get [_height$]() {
      return this.height;
    }
    set [_height$](value) {
      this.height = value;
    }
    get [dartx.left]() {
      return this[_left];
    }
    set [dartx.left](value) {
      this[_left] = value == null ? '' : value;
    }
    get [_left]() {
      return this.left;
    }
    set [_left](value) {
      this.left = value;
    }
    get [dartx.letterSpacing]() {
      return this[_letterSpacing];
    }
    set [dartx.letterSpacing](value) {
      this[_letterSpacing] = value == null ? '' : value;
    }
    get [_letterSpacing]() {
      return this.letterSpacing;
    }
    set [_letterSpacing](value) {
      this.letterSpacing = value;
    }
    get [dartx.lineHeight]() {
      return this[_lineHeight];
    }
    set [dartx.lineHeight](value) {
      this[_lineHeight] = value == null ? '' : value;
    }
    get [_lineHeight]() {
      return this.lineHeight;
    }
    set [_lineHeight](value) {
      this.lineHeight = value;
    }
    get [dartx.listStyle]() {
      return this[_listStyle];
    }
    set [dartx.listStyle](value) {
      this[_listStyle] = value == null ? '' : value;
    }
    get [_listStyle]() {
      return this.listStyle;
    }
    set [_listStyle](value) {
      this.listStyle = value;
    }
    get [dartx.listStyleImage]() {
      return this[_listStyleImage];
    }
    set [dartx.listStyleImage](value) {
      this[_listStyleImage] = value == null ? '' : value;
    }
    get [_listStyleImage]() {
      return this.listStyleImage;
    }
    set [_listStyleImage](value) {
      this.listStyleImage = value;
    }
    get [dartx.listStylePosition]() {
      return this[_listStylePosition];
    }
    set [dartx.listStylePosition](value) {
      this[_listStylePosition] = value == null ? '' : value;
    }
    get [_listStylePosition]() {
      return this.listStylePosition;
    }
    set [_listStylePosition](value) {
      this.listStylePosition = value;
    }
    get [dartx.listStyleType]() {
      return this[_listStyleType];
    }
    set [dartx.listStyleType](value) {
      this[_listStyleType] = value == null ? '' : value;
    }
    get [_listStyleType]() {
      return this.listStyleType;
    }
    set [_listStyleType](value) {
      this.listStyleType = value;
    }
    get [dartx.margin]() {
      return this[_margin];
    }
    set [dartx.margin](value) {
      this[_margin] = value == null ? '' : value;
    }
    get [_margin]() {
      return this.margin;
    }
    set [_margin](value) {
      this.margin = value;
    }
    get [dartx.marginBottom]() {
      return this[_marginBottom];
    }
    set [dartx.marginBottom](value) {
      this[_marginBottom] = value == null ? '' : value;
    }
    get [_marginBottom]() {
      return this.marginBottom;
    }
    set [_marginBottom](value) {
      this.marginBottom = value;
    }
    get [dartx.marginLeft]() {
      return this[_marginLeft];
    }
    set [dartx.marginLeft](value) {
      this[_marginLeft] = value == null ? '' : value;
    }
    get [_marginLeft]() {
      return this.marginLeft;
    }
    set [_marginLeft](value) {
      this.marginLeft = value;
    }
    get [dartx.marginRight]() {
      return this[_marginRight];
    }
    set [dartx.marginRight](value) {
      this[_marginRight] = value == null ? '' : value;
    }
    get [_marginRight]() {
      return this.marginRight;
    }
    set [_marginRight](value) {
      this.marginRight = value;
    }
    get [dartx.marginTop]() {
      return this[_marginTop];
    }
    set [dartx.marginTop](value) {
      this[_marginTop] = value == null ? '' : value;
    }
    get [_marginTop]() {
      return this.marginTop;
    }
    set [_marginTop](value) {
      this.marginTop = value;
    }
    get [dartx.maxHeight]() {
      return this[_maxHeight];
    }
    set [dartx.maxHeight](value) {
      this[_maxHeight] = value == null ? '' : value;
    }
    get [_maxHeight]() {
      return this.maxHeight;
    }
    set [_maxHeight](value) {
      this.maxHeight = value;
    }
    get [dartx.maxWidth]() {
      return this[_maxWidth];
    }
    set [dartx.maxWidth](value) {
      this[_maxWidth] = value == null ? '' : value;
    }
    get [_maxWidth]() {
      return this.maxWidth;
    }
    set [_maxWidth](value) {
      this.maxWidth = value;
    }
    get [dartx.minHeight]() {
      return this[_minHeight];
    }
    set [dartx.minHeight](value) {
      this[_minHeight] = value == null ? '' : value;
    }
    get [_minHeight]() {
      return this.minHeight;
    }
    set [_minHeight](value) {
      this.minHeight = value;
    }
    get [dartx.minWidth]() {
      return this[_minWidth];
    }
    set [dartx.minWidth](value) {
      this[_minWidth] = value == null ? '' : value;
    }
    get [_minWidth]() {
      return this.minWidth;
    }
    set [_minWidth](value) {
      this.minWidth = value;
    }
    get [dartx.outline]() {
      return this[_outline];
    }
    set [dartx.outline](value) {
      this[_outline] = value == null ? '' : value;
    }
    get [_outline]() {
      return this.outline;
    }
    set [_outline](value) {
      this.outline = value;
    }
    get [dartx.outlineColor]() {
      return this[_outlineColor];
    }
    set [dartx.outlineColor](value) {
      this[_outlineColor] = value == null ? '' : value;
    }
    get [_outlineColor]() {
      return this.outlineColor;
    }
    set [_outlineColor](value) {
      this.outlineColor = value;
    }
    get [dartx.outlineStyle]() {
      return this[_outlineStyle];
    }
    set [dartx.outlineStyle](value) {
      this[_outlineStyle] = value == null ? '' : value;
    }
    get [_outlineStyle]() {
      return this.outlineStyle;
    }
    set [_outlineStyle](value) {
      this.outlineStyle = value;
    }
    get [dartx.outlineWidth]() {
      return this[_outlineWidth];
    }
    set [dartx.outlineWidth](value) {
      this[_outlineWidth] = value == null ? '' : value;
    }
    get [_outlineWidth]() {
      return this.outlineWidth;
    }
    set [_outlineWidth](value) {
      this.outlineWidth = value;
    }
    get [dartx.overflow]() {
      return this[_overflow];
    }
    set [dartx.overflow](value) {
      this[_overflow] = value == null ? '' : value;
    }
    get [_overflow]() {
      return this.overflow;
    }
    set [_overflow](value) {
      this.overflow = value;
    }
    get [dartx.padding]() {
      return this[_padding];
    }
    set [dartx.padding](value) {
      this[_padding] = value == null ? '' : value;
    }
    get [_padding]() {
      return this.padding;
    }
    set [_padding](value) {
      this.padding = value;
    }
    get [dartx.paddingBottom]() {
      return this[_paddingBottom];
    }
    set [dartx.paddingBottom](value) {
      this[_paddingBottom] = value == null ? '' : value;
    }
    get [_paddingBottom]() {
      return this.paddingBottom;
    }
    set [_paddingBottom](value) {
      this.paddingBottom = value;
    }
    get [dartx.paddingLeft]() {
      return this[_paddingLeft];
    }
    set [dartx.paddingLeft](value) {
      this[_paddingLeft] = value == null ? '' : value;
    }
    get [_paddingLeft]() {
      return this.paddingLeft;
    }
    set [_paddingLeft](value) {
      this.paddingLeft = value;
    }
    get [dartx.paddingRight]() {
      return this[_paddingRight];
    }
    set [dartx.paddingRight](value) {
      this[_paddingRight] = value == null ? '' : value;
    }
    get [_paddingRight]() {
      return this.paddingRight;
    }
    set [_paddingRight](value) {
      this.paddingRight = value;
    }
    get [dartx.paddingTop]() {
      return this[_paddingTop];
    }
    set [dartx.paddingTop](value) {
      this[_paddingTop] = value == null ? '' : value;
    }
    get [_paddingTop]() {
      return this.paddingTop;
    }
    set [_paddingTop](value) {
      this.paddingTop = value;
    }
    get [dartx.pageBreakAfter]() {
      return this[_pageBreakAfter];
    }
    set [dartx.pageBreakAfter](value) {
      this[_pageBreakAfter] = value == null ? '' : value;
    }
    get [_pageBreakAfter]() {
      return this.pageBreakAfter;
    }
    set [_pageBreakAfter](value) {
      this.pageBreakAfter = value;
    }
    get [dartx.pageBreakBefore]() {
      return this[_pageBreakBefore];
    }
    set [dartx.pageBreakBefore](value) {
      this[_pageBreakBefore] = value == null ? '' : value;
    }
    get [_pageBreakBefore]() {
      return this.pageBreakBefore;
    }
    set [_pageBreakBefore](value) {
      this.pageBreakBefore = value;
    }
    get [dartx.pageBreakInside]() {
      return this[_pageBreakInside];
    }
    set [dartx.pageBreakInside](value) {
      this[_pageBreakInside] = value == null ? '' : value;
    }
    get [_pageBreakInside]() {
      return this.pageBreakInside;
    }
    set [_pageBreakInside](value) {
      this.pageBreakInside = value;
    }
    get [dartx.position]() {
      return this[_position$0];
    }
    set [dartx.position](value) {
      this[_position$0] = value == null ? '' : value;
    }
    get [_position$0]() {
      return this.position;
    }
    set [_position$0](value) {
      this.position = value;
    }
    get [dartx.quotes]() {
      return this[_quotes];
    }
    set [dartx.quotes](value) {
      this[_quotes] = value == null ? '' : value;
    }
    get [_quotes]() {
      return this.quotes;
    }
    set [_quotes](value) {
      this.quotes = value;
    }
    get [dartx.right]() {
      return this[_right];
    }
    set [dartx.right](value) {
      this[_right] = value == null ? '' : value;
    }
    get [_right]() {
      return this.right;
    }
    set [_right](value) {
      this.right = value;
    }
    get [dartx.tableLayout]() {
      return this[_tableLayout];
    }
    set [dartx.tableLayout](value) {
      this[_tableLayout] = value == null ? '' : value;
    }
    get [_tableLayout]() {
      return this.tableLayout;
    }
    set [_tableLayout](value) {
      this.tableLayout = value;
    }
    get [dartx.textAlign]() {
      return this[_textAlign];
    }
    set [dartx.textAlign](value) {
      this[_textAlign] = value == null ? '' : value;
    }
    get [_textAlign]() {
      return this.textAlign;
    }
    set [_textAlign](value) {
      this.textAlign = value;
    }
    get [dartx.textDecoration]() {
      return this[_textDecoration];
    }
    set [dartx.textDecoration](value) {
      this[_textDecoration] = value == null ? '' : value;
    }
    get [_textDecoration]() {
      return this.textDecoration;
    }
    set [_textDecoration](value) {
      this.textDecoration = value;
    }
    get [dartx.textIndent]() {
      return this[_textIndent];
    }
    set [dartx.textIndent](value) {
      this[_textIndent] = value == null ? '' : value;
    }
    get [_textIndent]() {
      return this.textIndent;
    }
    set [_textIndent](value) {
      this.textIndent = value;
    }
    get [dartx.textTransform]() {
      return this[_textTransform];
    }
    set [dartx.textTransform](value) {
      this[_textTransform] = value == null ? '' : value;
    }
    get [_textTransform]() {
      return this.textTransform;
    }
    set [_textTransform](value) {
      this.textTransform = value;
    }
    get [dartx.top]() {
      return this[_top];
    }
    set [dartx.top](value) {
      this[_top] = value == null ? '' : value;
    }
    get [_top]() {
      return this.top;
    }
    set [_top](value) {
      this.top = value;
    }
    get [dartx.unicodeBidi]() {
      return this[_unicodeBidi];
    }
    set [dartx.unicodeBidi](value) {
      this[_unicodeBidi] = value == null ? '' : value;
    }
    get [_unicodeBidi]() {
      return this.unicodeBidi;
    }
    set [_unicodeBidi](value) {
      this.unicodeBidi = value;
    }
    get [dartx.verticalAlign]() {
      return this[_verticalAlign];
    }
    set [dartx.verticalAlign](value) {
      this[_verticalAlign] = value == null ? '' : value;
    }
    get [_verticalAlign]() {
      return this.verticalAlign;
    }
    set [_verticalAlign](value) {
      this.verticalAlign = value;
    }
    get [dartx.visibility]() {
      return this[_visibility];
    }
    set [dartx.visibility](value) {
      this[_visibility] = value == null ? '' : value;
    }
    get [_visibility]() {
      return this.visibility;
    }
    set [_visibility](value) {
      this.visibility = value;
    }
    get [dartx.whiteSpace]() {
      return this[_whiteSpace];
    }
    set [dartx.whiteSpace](value) {
      this[_whiteSpace] = value == null ? '' : value;
    }
    get [_whiteSpace]() {
      return this.whiteSpace;
    }
    set [_whiteSpace](value) {
      this.whiteSpace = value;
    }
    get [dartx.width]() {
      return this[_width$];
    }
    set [dartx.width](value) {
      this[_width$] = value == null ? '' : value;
    }
    get [_width$]() {
      return this.width;
    }
    set [_width$](value) {
      this.width = value;
    }
    get [dartx.wordSpacing]() {
      return this[_wordSpacing];
    }
    set [dartx.wordSpacing](value) {
      this[_wordSpacing] = value == null ? '' : value;
    }
    get [_wordSpacing]() {
      return this.wordSpacing;
    }
    set [_wordSpacing](value) {
      this.wordSpacing = value;
    }
    get [dartx.zIndex]() {
      return this[_zIndex];
    }
    set [dartx.zIndex](value) {
      this[_zIndex] = value == null ? '' : value;
    }
    get [_zIndex]() {
      return this.zIndex;
    }
    set [_zIndex](value) {
      this.zIndex = value;
    }
  };
  dart.setSignature(html$.CssStyleDeclaration, {
    constructors: () => ({
      new: dart.definiteFunctionType(html$.CssStyleDeclaration, []),
      css: dart.definiteFunctionType(html$.CssStyleDeclaration, [core.String]),
      _: dart.definiteFunctionType(html$.CssStyleDeclaration, [])
    }),
    methods: () => ({
      [dartx.getPropertyValue]: dart.definiteFunctionType(core.String, [core.String]),
      [_getPropertyValueHelper]: dart.definiteFunctionType(core.String, [core.String]),
      [dartx.supportsProperty]: dart.definiteFunctionType(core.bool, [core.String]),
      [_supportsProperty]: dart.definiteFunctionType(core.bool, [core.String]),
      [dartx.setProperty]: dart.definiteFunctionType(dart.void, [core.String, core.String], [core.String]),
      [_browserPropertyName]: dart.definiteFunctionType(core.String, [core.String]),
      [_setPropertyHelper]: dart.definiteFunctionType(dart.void, [core.String, core.String], [core.String]),
      [dartx.getPropertyPriority]: dart.definiteFunctionType(core.String, [core.String]),
      [_getPropertyValue]: dart.definiteFunctionType(core.String, [core.String]),
      [dartx.item]: dart.definiteFunctionType(core.String, [core.int]),
      [dartx.removeProperty]: dart.definiteFunctionType(core.String, [core.String])
    }),
    statics: () => ({
      _readCache: dart.definiteFunctionType(core.String, [core.String]),
      _writeCache: dart.definiteFunctionType(dart.void, [core.String, core.String]),
      _camelCase: dart.definiteFunctionType(core.String, [core.String])
    }),
    names: ['_readCache', '_writeCache', '_camelCase']
  });
  dart.defineLazy(html$.CssStyleDeclaration, {
    get _propertyCache() {
      return {};
    }
  });
  dart.registerExtension(dart.global.CSSStyleDeclaration, html$.CssStyleDeclaration);
  const _elementIterable = Symbol('_elementIterable');
  const _elementCssStyleDeclarationSetIterable = Symbol('_elementCssStyleDeclarationSetIterable');
  const _setAll = Symbol('_setAll');
  html$._CssStyleDeclarationSet = class _CssStyleDeclarationSet extends dart.mixin(core.Object, html$.CssStyleDeclarationBase) {
    new(elementIterable) {
      this[_elementIterable] = elementIterable;
      this[_elementCssStyleDeclarationSetIterable] = null;
      this[_elementCssStyleDeclarationSetIterable] = core.List.from(this[_elementIterable])[dartx.map](html$.CssStyleDeclaration)(dart.fn(e => html$.CssStyleDeclaration._check(dart.dload(e, 'style')), dynamicToCssStyleDeclaration()));
    }
    getPropertyValue(propertyName) {
      return this[_elementCssStyleDeclarationSetIterable][dartx.first][dartx.getPropertyValue](propertyName);
    }
    setProperty(propertyName, value, priority) {
      if (priority === void 0) priority = null;
      this[_elementCssStyleDeclarationSetIterable][dartx.forEach](dart.fn(e => e[dartx.setProperty](propertyName, value, priority), CssStyleDeclarationTovoid()));
    }
    [_setAll](propertyName, value) {
      value = value == null ? '' : value;
      for (let element of this[_elementIterable]) {
        element.style[propertyName] = value;
      }
    }
    set background(value) {
      this[_setAll]('background', value);
    }
    get background() {
      return super.background;
    }
    set backgroundAttachment(value) {
      this[_setAll]('backgroundAttachment', value);
    }
    get backgroundAttachment() {
      return super.backgroundAttachment;
    }
    set backgroundColor(value) {
      this[_setAll]('backgroundColor', value);
    }
    get backgroundColor() {
      return super.backgroundColor;
    }
    set backgroundImage(value) {
      this[_setAll]('backgroundImage', value);
    }
    get backgroundImage() {
      return super.backgroundImage;
    }
    set backgroundPosition(value) {
      this[_setAll]('backgroundPosition', value);
    }
    get backgroundPosition() {
      return super.backgroundPosition;
    }
    set backgroundRepeat(value) {
      this[_setAll]('backgroundRepeat', value);
    }
    get backgroundRepeat() {
      return super.backgroundRepeat;
    }
    set border(value) {
      this[_setAll]('border', value);
    }
    get border() {
      return super.border;
    }
    set borderBottom(value) {
      this[_setAll]('borderBottom', value);
    }
    get borderBottom() {
      return super.borderBottom;
    }
    set borderBottomColor(value) {
      this[_setAll]('borderBottomColor', value);
    }
    get borderBottomColor() {
      return super.borderBottomColor;
    }
    set borderBottomStyle(value) {
      this[_setAll]('borderBottomStyle', value);
    }
    get borderBottomStyle() {
      return super.borderBottomStyle;
    }
    set borderBottomWidth(value) {
      this[_setAll]('borderBottomWidth', value);
    }
    get borderBottomWidth() {
      return super.borderBottomWidth;
    }
    set borderCollapse(value) {
      this[_setAll]('borderCollapse', value);
    }
    get borderCollapse() {
      return super.borderCollapse;
    }
    set borderColor(value) {
      this[_setAll]('borderColor', value);
    }
    get borderColor() {
      return super.borderColor;
    }
    set borderLeft(value) {
      this[_setAll]('borderLeft', value);
    }
    get borderLeft() {
      return super.borderLeft;
    }
    set borderLeftColor(value) {
      this[_setAll]('borderLeftColor', value);
    }
    get borderLeftColor() {
      return super.borderLeftColor;
    }
    set borderLeftStyle(value) {
      this[_setAll]('borderLeftStyle', value);
    }
    get borderLeftStyle() {
      return super.borderLeftStyle;
    }
    set borderLeftWidth(value) {
      this[_setAll]('borderLeftWidth', value);
    }
    get borderLeftWidth() {
      return super.borderLeftWidth;
    }
    set borderRight(value) {
      this[_setAll]('borderRight', value);
    }
    get borderRight() {
      return super.borderRight;
    }
    set borderRightColor(value) {
      this[_setAll]('borderRightColor', value);
    }
    get borderRightColor() {
      return super.borderRightColor;
    }
    set borderRightStyle(value) {
      this[_setAll]('borderRightStyle', value);
    }
    get borderRightStyle() {
      return super.borderRightStyle;
    }
    set borderRightWidth(value) {
      this[_setAll]('borderRightWidth', value);
    }
    get borderRightWidth() {
      return super.borderRightWidth;
    }
    set borderSpacing(value) {
      this[_setAll]('borderSpacing', value);
    }
    get borderSpacing() {
      return super.borderSpacing;
    }
    set borderStyle(value) {
      this[_setAll]('borderStyle', value);
    }
    get borderStyle() {
      return super.borderStyle;
    }
    set borderTop(value) {
      this[_setAll]('borderTop', value);
    }
    get borderTop() {
      return super.borderTop;
    }
    set borderTopColor(value) {
      this[_setAll]('borderTopColor', value);
    }
    get borderTopColor() {
      return super.borderTopColor;
    }
    set borderTopStyle(value) {
      this[_setAll]('borderTopStyle', value);
    }
    get borderTopStyle() {
      return super.borderTopStyle;
    }
    set borderTopWidth(value) {
      this[_setAll]('borderTopWidth', value);
    }
    get borderTopWidth() {
      return super.borderTopWidth;
    }
    set borderWidth(value) {
      this[_setAll]('borderWidth', value);
    }
    get borderWidth() {
      return super.borderWidth;
    }
    set bottom(value) {
      this[_setAll]('bottom', value);
    }
    get bottom() {
      return super.bottom;
    }
    set captionSide(value) {
      this[_setAll]('captionSide', value);
    }
    get captionSide() {
      return super.captionSide;
    }
    set clear(value) {
      this[_setAll]('clear', value);
    }
    get clear() {
      return super.clear;
    }
    set clip(value) {
      this[_setAll]('clip', value);
    }
    get clip() {
      return super.clip;
    }
    set color(value) {
      this[_setAll]('color', value);
    }
    get color() {
      return super.color;
    }
    set content(value) {
      this[_setAll]('content', value);
    }
    get content() {
      return super.content;
    }
    set cursor(value) {
      this[_setAll]('cursor', value);
    }
    get cursor() {
      return super.cursor;
    }
    set direction(value) {
      this[_setAll]('direction', value);
    }
    get direction() {
      return super.direction;
    }
    set display(value) {
      this[_setAll]('display', value);
    }
    get display() {
      return super.display;
    }
    set emptyCells(value) {
      this[_setAll]('emptyCells', value);
    }
    get emptyCells() {
      return super.emptyCells;
    }
    set font(value) {
      this[_setAll]('font', value);
    }
    get font() {
      return super.font;
    }
    set fontFamily(value) {
      this[_setAll]('fontFamily', value);
    }
    get fontFamily() {
      return super.fontFamily;
    }
    set fontSize(value) {
      this[_setAll]('fontSize', value);
    }
    get fontSize() {
      return super.fontSize;
    }
    set fontStyle(value) {
      this[_setAll]('fontStyle', value);
    }
    get fontStyle() {
      return super.fontStyle;
    }
    set fontVariant(value) {
      this[_setAll]('fontVariant', value);
    }
    get fontVariant() {
      return super.fontVariant;
    }
    set fontWeight(value) {
      this[_setAll]('fontWeight', value);
    }
    get fontWeight() {
      return super.fontWeight;
    }
    set height(value) {
      this[_setAll]('height', value);
    }
    get height() {
      return super.height;
    }
    set left(value) {
      this[_setAll]('left', value);
    }
    get left() {
      return super.left;
    }
    set letterSpacing(value) {
      this[_setAll]('letterSpacing', value);
    }
    get letterSpacing() {
      return super.letterSpacing;
    }
    set lineHeight(value) {
      this[_setAll]('lineHeight', value);
    }
    get lineHeight() {
      return super.lineHeight;
    }
    set listStyle(value) {
      this[_setAll]('listStyle', value);
    }
    get listStyle() {
      return super.listStyle;
    }
    set listStyleImage(value) {
      this[_setAll]('listStyleImage', value);
    }
    get listStyleImage() {
      return super.listStyleImage;
    }
    set listStylePosition(value) {
      this[_setAll]('listStylePosition', value);
    }
    get listStylePosition() {
      return super.listStylePosition;
    }
    set listStyleType(value) {
      this[_setAll]('listStyleType', value);
    }
    get listStyleType() {
      return super.listStyleType;
    }
    set margin(value) {
      this[_setAll]('margin', value);
    }
    get margin() {
      return super.margin;
    }
    set marginBottom(value) {
      this[_setAll]('marginBottom', value);
    }
    get marginBottom() {
      return super.marginBottom;
    }
    set marginLeft(value) {
      this[_setAll]('marginLeft', value);
    }
    get marginLeft() {
      return super.marginLeft;
    }
    set marginRight(value) {
      this[_setAll]('marginRight', value);
    }
    get marginRight() {
      return super.marginRight;
    }
    set marginTop(value) {
      this[_setAll]('marginTop', value);
    }
    get marginTop() {
      return super.marginTop;
    }
    set maxHeight(value) {
      this[_setAll]('maxHeight', value);
    }
    get maxHeight() {
      return super.maxHeight;
    }
    set maxWidth(value) {
      this[_setAll]('maxWidth', value);
    }
    get maxWidth() {
      return super.maxWidth;
    }
    set minHeight(value) {
      this[_setAll]('minHeight', value);
    }
    get minHeight() {
      return super.minHeight;
    }
    set minWidth(value) {
      this[_setAll]('minWidth', value);
    }
    get minWidth() {
      return super.minWidth;
    }
    set outline(value) {
      this[_setAll]('outline', value);
    }
    get outline() {
      return super.outline;
    }
    set outlineColor(value) {
      this[_setAll]('outlineColor', value);
    }
    get outlineColor() {
      return super.outlineColor;
    }
    set outlineStyle(value) {
      this[_setAll]('outlineStyle', value);
    }
    get outlineStyle() {
      return super.outlineStyle;
    }
    set outlineWidth(value) {
      this[_setAll]('outlineWidth', value);
    }
    get outlineWidth() {
      return super.outlineWidth;
    }
    set overflow(value) {
      this[_setAll]('overflow', value);
    }
    get overflow() {
      return super.overflow;
    }
    set padding(value) {
      this[_setAll]('padding', value);
    }
    get padding() {
      return super.padding;
    }
    set paddingBottom(value) {
      this[_setAll]('paddingBottom', value);
    }
    get paddingBottom() {
      return super.paddingBottom;
    }
    set paddingLeft(value) {
      this[_setAll]('paddingLeft', value);
    }
    get paddingLeft() {
      return super.paddingLeft;
    }
    set paddingRight(value) {
      this[_setAll]('paddingRight', value);
    }
    get paddingRight() {
      return super.paddingRight;
    }
    set paddingTop(value) {
      this[_setAll]('paddingTop', value);
    }
    get paddingTop() {
      return super.paddingTop;
    }
    set pageBreakAfter(value) {
      this[_setAll]('pageBreakAfter', value);
    }
    get pageBreakAfter() {
      return super.pageBreakAfter;
    }
    set pageBreakBefore(value) {
      this[_setAll]('pageBreakBefore', value);
    }
    get pageBreakBefore() {
      return super.pageBreakBefore;
    }
    set pageBreakInside(value) {
      this[_setAll]('pageBreakInside', value);
    }
    get pageBreakInside() {
      return super.pageBreakInside;
    }
    set position(value) {
      this[_setAll]('position', value);
    }
    get position() {
      return super.position;
    }
    set quotes(value) {
      this[_setAll]('quotes', value);
    }
    get quotes() {
      return super.quotes;
    }
    set right(value) {
      this[_setAll]('right', value);
    }
    get right() {
      return super.right;
    }
    set tableLayout(value) {
      this[_setAll]('tableLayout', value);
    }
    get tableLayout() {
      return super.tableLayout;
    }
    set textAlign(value) {
      this[_setAll]('textAlign', value);
    }
    get textAlign() {
      return super.textAlign;
    }
    set textDecoration(value) {
      this[_setAll]('textDecoration', value);
    }
    get textDecoration() {
      return super.textDecoration;
    }
    set textIndent(value) {
      this[_setAll]('textIndent', value);
    }
    get textIndent() {
      return super.textIndent;
    }
    set textTransform(value) {
      this[_setAll]('textTransform', value);
    }
    get textTransform() {
      return super.textTransform;
    }
    set top(value) {
      this[_setAll]('top', value);
    }
    get top() {
      return super.top;
    }
    set unicodeBidi(value) {
      this[_setAll]('unicodeBidi', value);
    }
    get unicodeBidi() {
      return super.unicodeBidi;
    }
    set verticalAlign(value) {
      this[_setAll]('verticalAlign', value);
    }
    get verticalAlign() {
      return super.verticalAlign;
    }
    set visibility(value) {
      this[_setAll]('visibility', value);
    }
    get visibility() {
      return super.visibility;
    }
    set whiteSpace(value) {
      this[_setAll]('whiteSpace', value);
    }
    get whiteSpace() {
      return super.whiteSpace;
    }
    set width(value) {
      this[_setAll]('width', value);
    }
    get width() {
      return super.width;
    }
    set wordSpacing(value) {
      this[_setAll]('wordSpacing', value);
    }
    get wordSpacing() {
      return super.wordSpacing;
    }
    set zIndex(value) {
      this[_setAll]('zIndex', value);
    }
    get zIndex() {
      return super.zIndex;
    }
  };
  dart.setSignature(html$._CssStyleDeclarationSet, {
    constructors: () => ({new: dart.definiteFunctionType(html$._CssStyleDeclarationSet, [core.Iterable$(html$.Element)])}),
    methods: () => ({
      getPropertyValue: dart.definiteFunctionType(core.String, [core.String]),
      setProperty: dart.definiteFunctionType(dart.void, [core.String, core.String], [core.String]),
      [_setAll]: dart.definiteFunctionType(dart.void, [core.String, core.String])
    })
  });
  dart.defineExtensionMembers(html$._CssStyleDeclarationSet, [
    'getPropertyValue',
    'setProperty',
    'background',
    'backgroundAttachment',
    'backgroundColor',
    'backgroundImage',
    'backgroundPosition',
    'backgroundRepeat',
    'border',
    'borderBottom',
    'borderBottomColor',
    'borderBottomStyle',
    'borderBottomWidth',
    'borderCollapse',
    'borderColor',
    'borderLeft',
    'borderLeftColor',
    'borderLeftStyle',
    'borderLeftWidth',
    'borderRight',
    'borderRightColor',
    'borderRightStyle',
    'borderRightWidth',
    'borderSpacing',
    'borderStyle',
    'borderTop',
    'borderTopColor',
    'borderTopStyle',
    'borderTopWidth',
    'borderWidth',
    'bottom',
    'captionSide',
    'clear',
    'clip',
    'color',
    'content',
    'cursor',
    'direction',
    'display',
    'emptyCells',
    'font',
    'fontFamily',
    'fontSize',
    'fontStyle',
    'fontVariant',
    'fontWeight',
    'height',
    'left',
    'letterSpacing',
    'lineHeight',
    'listStyle',
    'listStyleImage',
    'listStylePosition',
    'listStyleType',
    'margin',
    'marginBottom',
    'marginLeft',
    'marginRight',
    'marginTop',
    'maxHeight',
    'maxWidth',
    'minHeight',
    'minWidth',
    'outline',
    'outlineColor',
    'outlineStyle',
    'outlineWidth',
    'overflow',
    'padding',
    'paddingBottom',
    'paddingLeft',
    'paddingRight',
    'paddingTop',
    'pageBreakAfter',
    'pageBreakBefore',
    'pageBreakInside',
    'position',
    'quotes',
    'right',
    'tableLayout',
    'textAlign',
    'textDecoration',
    'textIndent',
    'textTransform',
    'top',
    'unicodeBidi',
    'verticalAlign',
    'visibility',
    'whiteSpace',
    'width',
    'wordSpacing',
    'zIndex'
  ]);
  dart.defineExtensionNames([
    'selectorText',
    'style'
  ]);
  html$.CssStyleRule = class CssStyleRule extends html$.CssRule {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.selectorText]() {
      return this.selectorText;
    }
    set [dartx.selectorText](value) {
      this.selectorText = value;
    }
    get [dartx.style]() {
      return this.style;
    }
  };
  dart.setSignature(html$.CssStyleRule, {
    constructors: () => ({_: dart.definiteFunctionType(html$.CssStyleRule, [])})
  });
  dart.registerExtension(dart.global.CSSStyleRule, html$.CssStyleRule);
  dart.defineExtensionNames([
    'disabled',
    'href',
    'media',
    'ownerNode',
    'parentStyleSheet',
    'title',
    'type'
  ]);
  html$.StyleSheet = class StyleSheet extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.disabled]() {
      return this.disabled;
    }
    set [dartx.disabled](value) {
      this.disabled = value;
    }
    get [dartx.href]() {
      return this.href;
    }
    get [dartx.media]() {
      return this.media;
    }
    get [dartx.ownerNode]() {
      return this.ownerNode;
    }
    get [dartx.parentStyleSheet]() {
      return this.parentStyleSheet;
    }
    get [dartx.title]() {
      return this.title;
    }
    get [dartx.type]() {
      return this.type;
    }
  };
  dart.setSignature(html$.StyleSheet, {
    constructors: () => ({_: dart.definiteFunctionType(html$.StyleSheet, [])})
  });
  dart.registerExtension(dart.global.StyleSheet, html$.StyleSheet);
  dart.defineExtensionNames([
    'addRule',
    'deleteRule',
    'insertRule',
    'removeRule',
    'cssRules',
    'ownerRule',
    'rules'
  ]);
  html$.CssStyleSheet = class CssStyleSheet extends html$.StyleSheet {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.cssRules]() {
      return this.cssRules;
    }
    get [dartx.ownerRule]() {
      return this.ownerRule;
    }
    get [dartx.rules]() {
      return this.rules;
    }
    [dartx.addRule](selector, style, index) {
      return this.addRule(selector, style, index);
    }
    [dartx.deleteRule](index) {
      return this.deleteRule(index);
    }
    [dartx.insertRule](rule, index) {
      return this.insertRule(rule, index);
    }
    [dartx.removeRule](index) {
      return this.removeRule(index);
    }
  };
  dart.setSignature(html$.CssStyleSheet, {
    constructors: () => ({_: dart.definiteFunctionType(html$.CssStyleSheet, [])}),
    methods: () => ({
      [dartx.addRule]: dart.definiteFunctionType(core.int, [core.String, core.String], [core.int]),
      [dartx.deleteRule]: dart.definiteFunctionType(dart.void, [core.int]),
      [dartx.insertRule]: dart.definiteFunctionType(core.int, [core.String], [core.int]),
      [dartx.removeRule]: dart.definiteFunctionType(dart.void, [core.int])
    })
  });
  dart.registerExtension(dart.global.CSSStyleSheet, html$.CssStyleSheet);
  dart.defineExtensionNames([
    'deleteRule',
    'insertRule',
    'conditionText',
    'cssRules'
  ]);
  html$.CssSupportsRule = class CssSupportsRule extends html$.CssRule {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.conditionText]() {
      return this.conditionText;
    }
    get [dartx.cssRules]() {
      return this.cssRules;
    }
    [dartx.deleteRule](index) {
      return this.deleteRule(index);
    }
    [dartx.insertRule](rule, index) {
      return this.insertRule(rule, index);
    }
  };
  dart.setSignature(html$.CssSupportsRule, {
    constructors: () => ({_: dart.definiteFunctionType(html$.CssSupportsRule, [])}),
    methods: () => ({
      [dartx.deleteRule]: dart.definiteFunctionType(dart.void, [core.int]),
      [dartx.insertRule]: dart.definiteFunctionType(core.int, [core.String, core.int])
    })
  });
  dart.registerExtension(dart.global.CSSSupportsRule, html$.CssSupportsRule);
  dart.defineExtensionNames([
    'style'
  ]);
  html$.CssViewportRule = class CssViewportRule extends html$.CssRule {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.style]() {
      return this.style;
    }
  };
  dart.setSignature(html$.CssViewportRule, {
    constructors: () => ({_: dart.definiteFunctionType(html$.CssViewportRule, [])})
  });
  dart.registerExtension(dart.global.CSSViewportRule, html$.CssViewportRule);
  const _dartDetail = Symbol('_dartDetail');
  const _initCustomEvent = Symbol('_initCustomEvent');
  const _detail = Symbol('_detail');
  const _get__detail = Symbol('_get__detail');
  dart.defineExtensionNames([
    'detail'
  ]);
  html$.CustomEvent = class CustomEvent extends html$.Event {
    get [_dartDetail]() {
      return this._dartDetail;
    }
    set [_dartDetail](value) {
      this._dartDetail = value;
    }
    static new(type, opts) {
      let canBubble = opts && 'canBubble' in opts ? opts.canBubble : true;
      let cancelable = opts && 'cancelable' in opts ? opts.cancelable : true;
      let detail = opts && 'detail' in opts ? opts.detail : null;
      let e = html$.CustomEvent._check(html$.document[_createEvent]('CustomEvent'));
      e[_dartDetail] = detail;
      if (core.List.is(detail) || core.Map.is(detail) || typeof detail == 'string' || typeof detail == 'number') {
        try {
          detail = html_common.convertDartToNative_SerializedScriptValue(detail);
          e[_initCustomEvent](type, canBubble, cancelable, detail);
        } catch (_) {
          e[_initCustomEvent](type, canBubble, cancelable, null);
        }

      } else {
        e[_initCustomEvent](type, canBubble, cancelable, null);
      }
      return e;
    }
    get [dartx.detail]() {
      if (this[_dartDetail] != null) {
        return this[_dartDetail];
      }
      return this[_detail];
    }
    static _(type, eventInitDict) {
      if (eventInitDict === void 0) eventInitDict = null;
      if (eventInitDict != null) {
        let eventInitDict_1 = html_common.convertDartToNative_Dictionary(eventInitDict);
        return html$.CustomEvent._create_1(type, eventInitDict_1);
      }
      return html$.CustomEvent._create_2(type);
    }
    static _create_1(type, eventInitDict) {
      return new CustomEvent(type, eventInitDict);
    }
    static _create_2(type) {
      return new CustomEvent(type);
    }
    get [_detail]() {
      return html_common.convertNativeToDart_SerializedScriptValue(this[_get__detail]);
    }
    get [_get__detail]() {
      return this.detail;
    }
    [_initCustomEvent](type, bubbles, cancelable, detail) {
      return this.initCustomEvent(type, bubbles, cancelable, detail);
    }
  };
  dart.setSignature(html$.CustomEvent, {
    constructors: () => ({
      new: dart.definiteFunctionType(html$.CustomEvent, [core.String], {canBubble: core.bool, cancelable: core.bool, detail: core.Object}),
      _: dart.definiteFunctionType(html$.CustomEvent, [core.String], [core.Map])
    }),
    methods: () => ({[_initCustomEvent]: dart.definiteFunctionType(dart.void, [core.String, core.bool, core.bool, core.Object])}),
    statics: () => ({
      _create_1: dart.definiteFunctionType(html$.CustomEvent, [dart.dynamic, dart.dynamic]),
      _create_2: dart.definiteFunctionType(html$.CustomEvent, [dart.dynamic])
    }),
    names: ['_create_1', '_create_2']
  });
  dart.registerExtension(dart.global.CustomEvent, html$.CustomEvent);
  html$.DListElement = class DListElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return html$.DListElement._check(html$.document[dartx.createElement]("dl"));
    }
    created() {
      super.created();
    }
  };
  dart.defineNamedConstructor(html$.DListElement, 'created');
  dart.setSignature(html$.DListElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.DListElement, []),
      new: dart.definiteFunctionType(html$.DListElement, []),
      created: dart.definiteFunctionType(html$.DListElement, [])
    })
  });
  dart.registerExtension(dart.global.HTMLDListElement, html$.DListElement);
  dart.defineExtensionNames([
    'options'
  ]);
  html$.DataListElement = class DataListElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return html$.DataListElement._check(html$.document[dartx.createElement]("datalist"));
    }
    created() {
      this[dartx.options] = null;
      super.created();
    }
    static get supported() {
      return html$.Element.isTagSupported('datalist');
    }
    get [dartx.options]() {
      return this.options;
    }
  };
  dart.defineNamedConstructor(html$.DataListElement, 'created');
  dart.setSignature(html$.DataListElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.DataListElement, []),
      new: dart.definiteFunctionType(html$.DataListElement, []),
      created: dart.definiteFunctionType(html$.DataListElement, [])
    })
  });
  dart.registerExtension(dart.global.HTMLDataListElement, html$.DataListElement);
  dart.defineExtensionNames([
    'clearData',
    'getData',
    'setData',
    'setDragImage',
    'dropEffect',
    'effectAllowed',
    'files',
    'items',
    'types'
  ]);
  html$.DataTransfer = class DataTransfer extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.dropEffect]() {
      return this.dropEffect;
    }
    set [dartx.dropEffect](value) {
      this.dropEffect = value;
    }
    get [dartx.effectAllowed]() {
      return this.effectAllowed;
    }
    set [dartx.effectAllowed](value) {
      this.effectAllowed = value;
    }
    get [dartx.files]() {
      return this.files;
    }
    get [dartx.items]() {
      return this.items;
    }
    get [dartx.types]() {
      return this.types;
    }
    [dartx.clearData](format) {
      return this.clearData(format);
    }
    [dartx.getData](format) {
      return this.getData(format);
    }
    [dartx.setData](format, data) {
      return this.setData(format, data);
    }
    [dartx.setDragImage](image, x, y) {
      return this.setDragImage(image, x, y);
    }
  };
  dart.setSignature(html$.DataTransfer, {
    constructors: () => ({_: dart.definiteFunctionType(html$.DataTransfer, [])}),
    methods: () => ({
      [dartx.clearData]: dart.definiteFunctionType(dart.void, [], [core.String]),
      [dartx.getData]: dart.definiteFunctionType(core.String, [core.String]),
      [dartx.setData]: dart.definiteFunctionType(dart.void, [core.String, core.String]),
      [dartx.setDragImage]: dart.definiteFunctionType(dart.void, [html$.Element, core.int, core.int])
    })
  });
  dart.registerExtension(dart.global.DataTransfer, html$.DataTransfer);
  const _getAsString = Symbol('_getAsString');
  dart.defineExtensionNames([
    'getAsFile',
    'getAsString',
    'getAsEntry',
    'kind',
    'type'
  ]);
  html$.DataTransferItem = class DataTransferItem extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.kind]() {
      return this.kind;
    }
    get [dartx.type]() {
      return this.type;
    }
    [dartx.getAsFile]() {
      return this.getAsFile();
    }
    [_getAsString](callback) {
      return this.getAsString(callback);
    }
    [dartx.getAsString]() {
      let completer = CompleterOfString().new();
      this[_getAsString](dart.fn(value => {
        completer.complete(value);
      }, StringTovoid()));
      return completer.future;
    }
    [dartx.getAsEntry]() {
      return this.webkitGetAsEntry();
    }
  };
  dart.setSignature(html$.DataTransferItem, {
    constructors: () => ({_: dart.definiteFunctionType(html$.DataTransferItem, [])}),
    methods: () => ({
      [dartx.getAsFile]: dart.definiteFunctionType(html$.Blob, []),
      [_getAsString]: dart.definiteFunctionType(dart.void, [html$._StringCallback]),
      [dartx.getAsString]: dart.definiteFunctionType(async.Future$(core.String), []),
      [dartx.getAsEntry]: dart.definiteFunctionType(html$.Entry, [])
    })
  });
  dart.registerExtension(dart.global.DataTransferItem, html$.DataTransferItem);
  dart.defineExtensionNames([
    'add',
    'addData',
    'addFile',
    'clear',
    'item',
    'remove',
    'get',
    'length'
  ]);
  html$.DataTransferItemList = class DataTransferItemList extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.length]() {
      return this.length;
    }
    [dartx.add](data_OR_file, type) {
      return this.add(data_OR_file, type);
    }
    [dartx.addData](data, type) {
      return this.add(data, type);
    }
    [dartx.addFile](file) {
      return this.add(file);
    }
    [dartx.clear]() {
      return this.clear();
    }
    [dartx.item](index) {
      return this.item(index);
    }
    [dartx.remove](index) {
      return this.remove(index);
    }
    [dartx.get](index) {
      return this[index];
    }
  };
  dart.setSignature(html$.DataTransferItemList, {
    constructors: () => ({_: dart.definiteFunctionType(html$.DataTransferItemList, [])}),
    methods: () => ({
      [dartx.add]: dart.definiteFunctionType(html$.DataTransferItem, [dart.dynamic], [core.String]),
      [dartx.addData]: dart.definiteFunctionType(html$.DataTransferItem, [core.String, core.String]),
      [dartx.addFile]: dart.definiteFunctionType(html$.DataTransferItem, [html$.File]),
      [dartx.clear]: dart.definiteFunctionType(dart.void, []),
      [dartx.item]: dart.definiteFunctionType(html$.DataTransferItem, [core.int]),
      [dartx.remove]: dart.definiteFunctionType(dart.void, [core.int]),
      [dartx.get]: dart.definiteFunctionType(html$.DataTransferItem, [core.int])
    })
  });
  dart.registerExtension(dart.global.DataTransferItemList, html$.DataTransferItemList);
  html$.DatabaseCallback = dart.typedef('DatabaseCallback', () => dart.functionType(dart.void, [web_sql.SqlDatabase]));
  dart.defineExtensionNames([
    'postMessage',
    'onMessage'
  ]);
  html$.DedicatedWorkerGlobalScope = class DedicatedWorkerGlobalScope extends html$.WorkerGlobalScope {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [dartx.postMessage](message, transfer) {
      if (transfer === void 0) transfer = null;
      if (transfer != null) {
        let message_1 = html_common.convertDartToNative_SerializedScriptValue(message);
        this[_postMessage_1](message_1, transfer);
        return;
      }
      let message_1 = html_common.convertDartToNative_SerializedScriptValue(message);
      this[_postMessage_2](message_1);
      return;
    }
    [_postMessage_1](message, transfer) {
      return this.postMessage(message, transfer);
    }
    [_postMessage_2](message) {
      return this.postMessage(message);
    }
    get [dartx.onMessage]() {
      return html$.DedicatedWorkerGlobalScope.messageEvent.forTarget(this);
    }
  };
  dart.setSignature(html$.DedicatedWorkerGlobalScope, {
    constructors: () => ({_: dart.definiteFunctionType(html$.DedicatedWorkerGlobalScope, [])}),
    methods: () => ({
      [dartx.postMessage]: dart.definiteFunctionType(dart.void, [dart.dynamic], [core.List$(html$.MessagePort)]),
      [_postMessage_1]: dart.definiteFunctionType(dart.void, [dart.dynamic, core.List$(html$.MessagePort)]),
      [_postMessage_2]: dart.definiteFunctionType(dart.void, [dart.dynamic])
    })
  });
  dart.defineLazy(html$.DedicatedWorkerGlobalScope, {
    get messageEvent() {
      return dart.const(new (EventStreamProviderOfMessageEvent())('message'));
    }
  });
  dart.registerExtension(dart.global.DedicatedWorkerGlobalScope, html$.DedicatedWorkerGlobalScope);
  dart.defineExtensionNames([
    'session'
  ]);
  html$.DefaultSessionStartEvent = class DefaultSessionStartEvent extends html$.Event {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(type, eventInitDict) {
      if (eventInitDict === void 0) eventInitDict = null;
      if (eventInitDict != null) {
        let eventInitDict_1 = html_common.convertDartToNative_Dictionary(eventInitDict);
        return html$.DefaultSessionStartEvent._create_1(type, eventInitDict_1);
      }
      return html$.DefaultSessionStartEvent._create_2(type);
    }
    static _create_1(type, eventInitDict) {
      return new DefaultSessionStartEvent(type, eventInitDict);
    }
    static _create_2(type) {
      return new DefaultSessionStartEvent(type);
    }
    get [dartx.session]() {
      return this.session;
    }
  };
  dart.setSignature(html$.DefaultSessionStartEvent, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.DefaultSessionStartEvent, []),
      new: dart.definiteFunctionType(html$.DefaultSessionStartEvent, [core.String], [core.Map])
    }),
    statics: () => ({
      _create_1: dart.definiteFunctionType(html$.DefaultSessionStartEvent, [dart.dynamic, dart.dynamic]),
      _create_2: dart.definiteFunctionType(html$.DefaultSessionStartEvent, [dart.dynamic])
    }),
    names: ['_create_1', '_create_2']
  });
  dart.registerExtension(dart.global.DefaultSessionStartEvent, html$.DefaultSessionStartEvent);
  dart.defineExtensionNames([
    'queryUsageAndQuota',
    'requestQuota'
  ]);
  html$.DeprecatedStorageInfo = class DeprecatedStorageInfo extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [dartx.queryUsageAndQuota](storageType, usageCallback, errorCallback) {
      return this.queryUsageAndQuota(storageType, usageCallback, errorCallback);
    }
    [dartx.requestQuota](storageType, newQuotaInBytes, quotaCallback, errorCallback) {
      return this.requestQuota(storageType, newQuotaInBytes, quotaCallback, errorCallback);
    }
  };
  dart.setSignature(html$.DeprecatedStorageInfo, {
    constructors: () => ({_: dart.definiteFunctionType(html$.DeprecatedStorageInfo, [])}),
    methods: () => ({
      [dartx.queryUsageAndQuota]: dart.definiteFunctionType(dart.void, [core.int], [html$.StorageUsageCallback, html$.StorageErrorCallback]),
      [dartx.requestQuota]: dart.definiteFunctionType(dart.void, [core.int, core.int], [html$.StorageQuotaCallback, html$.StorageErrorCallback])
    })
  });
  html$.DeprecatedStorageInfo.PERSISTENT = 1;
  html$.DeprecatedStorageInfo.TEMPORARY = 0;
  dart.registerExtension(dart.global.DeprecatedStorageInfo, html$.DeprecatedStorageInfo);
  dart.defineExtensionNames([
    'queryUsageAndQuota',
    'requestQuota'
  ]);
  html$.DeprecatedStorageQuota = class DeprecatedStorageQuota extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [dartx.queryUsageAndQuota](usageCallback, errorCallback) {
      return this.queryUsageAndQuota(usageCallback, errorCallback);
    }
    [dartx.requestQuota](newQuotaInBytes, quotaCallback, errorCallback) {
      return this.requestQuota(newQuotaInBytes, quotaCallback, errorCallback);
    }
  };
  dart.setSignature(html$.DeprecatedStorageQuota, {
    constructors: () => ({_: dart.definiteFunctionType(html$.DeprecatedStorageQuota, [])}),
    methods: () => ({
      [dartx.queryUsageAndQuota]: dart.definiteFunctionType(dart.void, [html$.StorageUsageCallback], [html$.StorageErrorCallback]),
      [dartx.requestQuota]: dart.definiteFunctionType(dart.void, [core.int], [html$.StorageQuotaCallback, html$.StorageErrorCallback])
    })
  });
  dart.registerExtension(dart.global.DeprecatedStorageQuota, html$.DeprecatedStorageQuota);
  dart.defineExtensionNames([
    'open'
  ]);
  html$.DetailsElement = class DetailsElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return html$.DetailsElement._check(html$.document[dartx.createElement]("details"));
    }
    created() {
      this[dartx.open] = null;
      super.created();
    }
    static get supported() {
      return html$.Element.isTagSupported('details');
    }
    get [dartx.open]() {
      return this.open;
    }
    set [dartx.open](value) {
      this.open = value;
    }
  };
  dart.defineNamedConstructor(html$.DetailsElement, 'created');
  dart.setSignature(html$.DetailsElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.DetailsElement, []),
      new: dart.definiteFunctionType(html$.DetailsElement, []),
      created: dart.definiteFunctionType(html$.DetailsElement, [])
    })
  });
  dart.registerExtension(dart.global.HTMLDetailsElement, html$.DetailsElement);
  dart.defineExtensionNames([
    'x',
    'y',
    'z'
  ]);
  html$.DeviceAcceleration = class DeviceAcceleration extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.x]() {
      return this.x;
    }
    get [dartx.y]() {
      return this.y;
    }
    get [dartx.z]() {
      return this.z;
    }
  };
  dart.setSignature(html$.DeviceAcceleration, {
    constructors: () => ({_: dart.definiteFunctionType(html$.DeviceAcceleration, [])})
  });
  dart.registerExtension(dart.global.DeviceAcceleration, html$.DeviceAcceleration);
  dart.defineExtensionNames([
    'value'
  ]);
  html$.DeviceLightEvent = class DeviceLightEvent extends html$.Event {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(type, eventInitDict) {
      if (eventInitDict === void 0) eventInitDict = null;
      if (eventInitDict != null) {
        let eventInitDict_1 = html_common.convertDartToNative_Dictionary(eventInitDict);
        return html$.DeviceLightEvent._create_1(type, eventInitDict_1);
      }
      return html$.DeviceLightEvent._create_2(type);
    }
    static _create_1(type, eventInitDict) {
      return new DeviceLightEvent(type, eventInitDict);
    }
    static _create_2(type) {
      return new DeviceLightEvent(type);
    }
    get [dartx.value]() {
      return this.value;
    }
  };
  dart.setSignature(html$.DeviceLightEvent, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.DeviceLightEvent, []),
      new: dart.definiteFunctionType(html$.DeviceLightEvent, [core.String], [core.Map])
    }),
    statics: () => ({
      _create_1: dart.definiteFunctionType(html$.DeviceLightEvent, [dart.dynamic, dart.dynamic]),
      _create_2: dart.definiteFunctionType(html$.DeviceLightEvent, [dart.dynamic])
    }),
    names: ['_create_1', '_create_2']
  });
  dart.registerExtension(dart.global.DeviceLightEvent, html$.DeviceLightEvent);
  dart.defineExtensionNames([
    'initDeviceMotionEvent',
    'acceleration',
    'accelerationIncludingGravity',
    'interval',
    'rotationRate'
  ]);
  html$.DeviceMotionEvent = class DeviceMotionEvent extends html$.Event {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.acceleration]() {
      return this.acceleration;
    }
    get [dartx.accelerationIncludingGravity]() {
      return this.accelerationIncludingGravity;
    }
    get [dartx.interval]() {
      return this.interval;
    }
    get [dartx.rotationRate]() {
      return this.rotationRate;
    }
    [dartx.initDeviceMotionEvent](type, bubbles, cancelable, acceleration, accelerationIncludingGravity, rotationRate, interval) {
      return this.initDeviceMotionEvent(type, bubbles, cancelable, acceleration, accelerationIncludingGravity, rotationRate, interval);
    }
  };
  dart.setSignature(html$.DeviceMotionEvent, {
    constructors: () => ({_: dart.definiteFunctionType(html$.DeviceMotionEvent, [])}),
    methods: () => ({[dartx.initDeviceMotionEvent]: dart.definiteFunctionType(dart.void, [core.String, core.bool, core.bool, html$.DeviceAcceleration, html$.DeviceAcceleration, html$.DeviceRotationRate, core.num])})
  });
  dart.registerExtension(dart.global.DeviceMotionEvent, html$.DeviceMotionEvent);
  const _initDeviceOrientationEvent = Symbol('_initDeviceOrientationEvent');
  dart.defineExtensionNames([
    'absolute',
    'alpha',
    'beta',
    'gamma'
  ]);
  html$.DeviceOrientationEvent = class DeviceOrientationEvent extends html$.Event {
    static new(type, opts) {
      let canBubble = opts && 'canBubble' in opts ? opts.canBubble : true;
      let cancelable = opts && 'cancelable' in opts ? opts.cancelable : true;
      let alpha = opts && 'alpha' in opts ? opts.alpha : 0;
      let beta = opts && 'beta' in opts ? opts.beta : 0;
      let gamma = opts && 'gamma' in opts ? opts.gamma : 0;
      let absolute = opts && 'absolute' in opts ? opts.absolute : false;
      let e = html$.DeviceOrientationEvent._check(html$.document[_createEvent]("DeviceOrientationEvent"));
      e[_initDeviceOrientationEvent](type, canBubble, cancelable, alpha, beta, gamma, absolute);
      return e;
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.absolute]() {
      return this.absolute;
    }
    get [dartx.alpha]() {
      return this.alpha;
    }
    get [dartx.beta]() {
      return this.beta;
    }
    get [dartx.gamma]() {
      return this.gamma;
    }
    [_initDeviceOrientationEvent](type, bubbles, cancelable, alpha, beta, gamma, absolute) {
      return this.initDeviceOrientationEvent(type, bubbles, cancelable, alpha, beta, gamma, absolute);
    }
  };
  dart.setSignature(html$.DeviceOrientationEvent, {
    constructors: () => ({
      new: dart.definiteFunctionType(html$.DeviceOrientationEvent, [core.String], {canBubble: core.bool, cancelable: core.bool, alpha: core.num, beta: core.num, gamma: core.num, absolute: core.bool}),
      _: dart.definiteFunctionType(html$.DeviceOrientationEvent, [])
    }),
    methods: () => ({[_initDeviceOrientationEvent]: dart.definiteFunctionType(dart.void, [core.String, core.bool, core.bool, core.num, core.num, core.num, core.bool])})
  });
  dart.registerExtension(dart.global.DeviceOrientationEvent, html$.DeviceOrientationEvent);
  dart.defineExtensionNames([
    'alpha',
    'beta',
    'gamma'
  ]);
  html$.DeviceRotationRate = class DeviceRotationRate extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.alpha]() {
      return this.alpha;
    }
    get [dartx.beta]() {
      return this.beta;
    }
    get [dartx.gamma]() {
      return this.gamma;
    }
  };
  dart.setSignature(html$.DeviceRotationRate, {
    constructors: () => ({_: dart.definiteFunctionType(html$.DeviceRotationRate, [])})
  });
  dart.registerExtension(dart.global.DeviceRotationRate, html$.DeviceRotationRate);
  dart.defineExtensionNames([
    'close',
    'show',
    'showModal',
    'open',
    'returnValue'
  ]);
  html$.DialogElement = class DialogElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    created() {
      this[dartx.open] = null;
      this[dartx.returnValue] = null;
      super.created();
    }
    get [dartx.open]() {
      return this.open;
    }
    set [dartx.open](value) {
      this.open = value;
    }
    get [dartx.returnValue]() {
      return this.returnValue;
    }
    set [dartx.returnValue](value) {
      this.returnValue = value;
    }
    [dartx.close](returnValue) {
      return this.close(returnValue);
    }
    [dartx.show]() {
      return this.show();
    }
    [dartx.showModal]() {
      return this.showModal();
    }
  };
  dart.defineNamedConstructor(html$.DialogElement, 'created');
  dart.setSignature(html$.DialogElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.DialogElement, []),
      created: dart.definiteFunctionType(html$.DialogElement, [])
    }),
    methods: () => ({
      [dartx.close]: dart.definiteFunctionType(dart.void, [core.String]),
      [dartx.show]: dart.definiteFunctionType(dart.void, []),
      [dartx.showModal]: dart.definiteFunctionType(dart.void, [])
    })
  });
  dart.registerExtension(dart.global.HTMLDialogElement, html$.DialogElement);
  const _getDirectory = Symbol('_getDirectory');
  const _getFile = Symbol('_getFile');
  const __getDirectory_1 = Symbol('__getDirectory_1');
  const __getDirectory_2 = Symbol('__getDirectory_2');
  const __getDirectory_3 = Symbol('__getDirectory_3');
  const __getDirectory_4 = Symbol('__getDirectory_4');
  const __getDirectory = Symbol('__getDirectory');
  const __getFile_1 = Symbol('__getFile_1');
  const __getFile_2 = Symbol('__getFile_2');
  const __getFile_3 = Symbol('__getFile_3');
  const __getFile_4 = Symbol('__getFile_4');
  const __getFile = Symbol('__getFile');
  const _removeRecursively = Symbol('_removeRecursively');
  const _copyTo = Symbol('_copyTo');
  const _getMetadata = Symbol('_getMetadata');
  const _getParent = Symbol('_getParent');
  const _moveTo = Symbol('_moveTo');
  const _remove$ = Symbol('_remove');
  dart.defineExtensionNames([
    'copyTo',
    'getMetadata',
    'getParent',
    'moveTo',
    'remove',
    'toUrl',
    'filesystem',
    'fullPath',
    'isDirectory',
    'isFile',
    'name'
  ]);
  html$.Entry = class Entry extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.filesystem]() {
      return this.filesystem;
    }
    get [dartx.fullPath]() {
      return this.fullPath;
    }
    get [dartx.isDirectory]() {
      return this.isDirectory;
    }
    get [dartx.isFile]() {
      return this.isFile;
    }
    get [dartx.name]() {
      return this.name;
    }
    [_copyTo](parent, opts) {
      return this.copyTo(parent, opts);
    }
    [dartx.copyTo](parent, opts) {
      let name = opts && 'name' in opts ? opts.name : null;
      let completer = CompleterOfEntry().new();
      this[_copyTo](parent, {name: name, successCallback: dart.fn(value => {
          completer.complete(value);
        }, EntryTovoid()), errorCallback: dart.fn(error => {
          completer.completeError(error);
        }, FileErrorTovoid())});
      return completer.future;
    }
    [_getMetadata](successCallback, errorCallback) {
      return this.getMetadata(successCallback, errorCallback);
    }
    [dartx.getMetadata]() {
      let completer = CompleterOfMetadata().new();
      this[_getMetadata](dart.fn(value => {
        completer.complete(value);
      }, MetadataTovoid()), dart.fn(error => {
        completer.completeError(error);
      }, FileErrorTovoid()));
      return completer.future;
    }
    [_getParent](successCallback, errorCallback) {
      return this.getParent(successCallback, errorCallback);
    }
    [dartx.getParent]() {
      let completer = CompleterOfEntry().new();
      this[_getParent](dart.fn(value => {
        completer.complete(value);
      }, EntryTovoid()), dart.fn(error => {
        completer.completeError(error);
      }, FileErrorTovoid()));
      return completer.future;
    }
    [_moveTo](parent, opts) {
      return this.moveTo(parent, opts);
    }
    [dartx.moveTo](parent, opts) {
      let name = opts && 'name' in opts ? opts.name : null;
      let completer = CompleterOfEntry().new();
      this[_moveTo](parent, {name: name, successCallback: dart.fn(value => {
          completer.complete(value);
        }, EntryTovoid()), errorCallback: dart.fn(error => {
          completer.completeError(error);
        }, FileErrorTovoid())});
      return completer.future;
    }
    [_remove$](successCallback, errorCallback) {
      return this.remove(successCallback, errorCallback);
    }
    [dartx.remove]() {
      let completer = async.Completer.new();
      this[_remove$](dart.fn(() => {
        completer.complete();
      }, VoidTovoid$()), dart.fn(error => {
        completer.completeError(error);
      }, FileErrorTovoid()));
      return completer.future;
    }
    [dartx.toUrl]() {
      return this.toURL();
    }
  };
  dart.setSignature(html$.Entry, {
    constructors: () => ({_: dart.definiteFunctionType(html$.Entry, [])}),
    methods: () => ({
      [_copyTo]: dart.definiteFunctionType(dart.void, [html$.DirectoryEntry], {name: core.String, successCallback: html$._EntryCallback, errorCallback: html$._ErrorCallback}),
      [dartx.copyTo]: dart.definiteFunctionType(async.Future$(html$.Entry), [html$.DirectoryEntry], {name: core.String}),
      [_getMetadata]: dart.definiteFunctionType(dart.void, [html$.MetadataCallback], [html$._ErrorCallback]),
      [dartx.getMetadata]: dart.definiteFunctionType(async.Future$(html$.Metadata), []),
      [_getParent]: dart.definiteFunctionType(dart.void, [], [html$._EntryCallback, html$._ErrorCallback]),
      [dartx.getParent]: dart.definiteFunctionType(async.Future$(html$.Entry), []),
      [_moveTo]: dart.definiteFunctionType(dart.void, [html$.DirectoryEntry], {name: core.String, successCallback: html$._EntryCallback, errorCallback: html$._ErrorCallback}),
      [dartx.moveTo]: dart.definiteFunctionType(async.Future$(html$.Entry), [html$.DirectoryEntry], {name: core.String}),
      [_remove$]: dart.definiteFunctionType(dart.void, [html$.VoidCallback], [html$._ErrorCallback]),
      [dartx.remove]: dart.definiteFunctionType(async.Future, []),
      [dartx.toUrl]: dart.definiteFunctionType(core.String, [])
    })
  });
  dart.registerExtension(dart.global.Entry, html$.Entry);
  dart.defineExtensionNames([
    'createDirectory',
    'getDirectory',
    'createFile',
    'getFile',
    'createReader',
    'removeRecursively'
  ]);
  html$.DirectoryEntry = class DirectoryEntry extends html$.Entry {
    [dartx.createDirectory](path, opts) {
      let exclusive = opts && 'exclusive' in opts ? opts.exclusive : false;
      return this[_getDirectory](path, {options: dart.map({create: true, exclusive: exclusive})});
    }
    [dartx.getDirectory](path) {
      return this[_getDirectory](path);
    }
    [dartx.createFile](path, opts) {
      let exclusive = opts && 'exclusive' in opts ? opts.exclusive : false;
      return this[_getFile](path, {options: dart.map({create: true, exclusive: exclusive})});
    }
    [dartx.getFile](path) {
      return this[_getFile](path);
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [dartx.createReader]() {
      return this.createReader();
    }
    [__getDirectory](path, opts) {
      let options = opts && 'options' in opts ? opts.options : null;
      let successCallback = opts && 'successCallback' in opts ? opts.successCallback : null;
      let errorCallback = opts && 'errorCallback' in opts ? opts.errorCallback : null;
      if (errorCallback != null) {
        let options_1 = html_common.convertDartToNative_Dictionary(options);
        this[__getDirectory_1](path, options_1, successCallback, errorCallback);
        return;
      }
      if (successCallback != null) {
        let options_1 = html_common.convertDartToNative_Dictionary(options);
        this[__getDirectory_2](path, options_1, successCallback);
        return;
      }
      if (options != null) {
        let options_1 = html_common.convertDartToNative_Dictionary(options);
        this[__getDirectory_3](path, options_1);
        return;
      }
      this[__getDirectory_4](path);
      return;
    }
    [__getDirectory_1](path, options, successCallback, errorCallback) {
      return this.getDirectory(path, options, successCallback, errorCallback);
    }
    [__getDirectory_2](path, options, successCallback) {
      return this.getDirectory(path, options, successCallback);
    }
    [__getDirectory_3](path, options) {
      return this.getDirectory(path, options);
    }
    [__getDirectory_4](path) {
      return this.getDirectory(path);
    }
    [_getDirectory](path, opts) {
      let options = opts && 'options' in opts ? opts.options : null;
      let completer = CompleterOfEntry().new();
      this[__getDirectory](path, {options: options, successCallback: dart.fn(value => {
          completer.complete(value);
        }, EntryTovoid()), errorCallback: dart.fn(error => {
          completer.completeError(error);
        }, FileErrorTovoid())});
      return completer.future;
    }
    [__getFile](path, opts) {
      let options = opts && 'options' in opts ? opts.options : null;
      let successCallback = opts && 'successCallback' in opts ? opts.successCallback : null;
      let errorCallback = opts && 'errorCallback' in opts ? opts.errorCallback : null;
      if (errorCallback != null) {
        let options_1 = html_common.convertDartToNative_Dictionary(options);
        this[__getFile_1](path, options_1, successCallback, errorCallback);
        return;
      }
      if (successCallback != null) {
        let options_1 = html_common.convertDartToNative_Dictionary(options);
        this[__getFile_2](path, options_1, successCallback);
        return;
      }
      if (options != null) {
        let options_1 = html_common.convertDartToNative_Dictionary(options);
        this[__getFile_3](path, options_1);
        return;
      }
      this[__getFile_4](path);
      return;
    }
    [__getFile_1](path, options, successCallback, errorCallback) {
      return this.getFile(path, options, successCallback, errorCallback);
    }
    [__getFile_2](path, options, successCallback) {
      return this.getFile(path, options, successCallback);
    }
    [__getFile_3](path, options) {
      return this.getFile(path, options);
    }
    [__getFile_4](path) {
      return this.getFile(path);
    }
    [_getFile](path, opts) {
      let options = opts && 'options' in opts ? opts.options : null;
      let completer = CompleterOfEntry().new();
      this[__getFile](path, {options: options, successCallback: dart.fn(value => {
          completer.complete(value);
        }, EntryTovoid()), errorCallback: dart.fn(error => {
          completer.completeError(error);
        }, FileErrorTovoid())});
      return completer.future;
    }
    [_removeRecursively](successCallback, errorCallback) {
      return this.removeRecursively(successCallback, errorCallback);
    }
    [dartx.removeRecursively]() {
      let completer = async.Completer.new();
      this[_removeRecursively](dart.fn(() => {
        completer.complete();
      }, VoidTovoid$()), dart.fn(error => {
        completer.completeError(error);
      }, FileErrorTovoid()));
      return completer.future;
    }
  };
  dart.setSignature(html$.DirectoryEntry, {
    constructors: () => ({_: dart.definiteFunctionType(html$.DirectoryEntry, [])}),
    methods: () => ({
      [dartx.createDirectory]: dart.definiteFunctionType(async.Future$(html$.Entry), [core.String], {exclusive: core.bool}),
      [dartx.getDirectory]: dart.definiteFunctionType(async.Future$(html$.Entry), [core.String]),
      [dartx.createFile]: dart.definiteFunctionType(async.Future$(html$.Entry), [core.String], {exclusive: core.bool}),
      [dartx.getFile]: dart.definiteFunctionType(async.Future$(html$.Entry), [core.String]),
      [dartx.createReader]: dart.definiteFunctionType(html$.DirectoryReader, []),
      [__getDirectory]: dart.definiteFunctionType(dart.void, [core.String], {options: core.Map, successCallback: html$._EntryCallback, errorCallback: html$._ErrorCallback}),
      [__getDirectory_1]: dart.definiteFunctionType(dart.void, [dart.dynamic, dart.dynamic, html$._EntryCallback, html$._ErrorCallback]),
      [__getDirectory_2]: dart.definiteFunctionType(dart.void, [dart.dynamic, dart.dynamic, html$._EntryCallback]),
      [__getDirectory_3]: dart.definiteFunctionType(dart.void, [dart.dynamic, dart.dynamic]),
      [__getDirectory_4]: dart.definiteFunctionType(dart.void, [dart.dynamic]),
      [_getDirectory]: dart.definiteFunctionType(async.Future$(html$.Entry), [core.String], {options: core.Map}),
      [__getFile]: dart.definiteFunctionType(dart.void, [core.String], {options: core.Map, successCallback: html$._EntryCallback, errorCallback: html$._ErrorCallback}),
      [__getFile_1]: dart.definiteFunctionType(dart.void, [dart.dynamic, dart.dynamic, html$._EntryCallback, html$._ErrorCallback]),
      [__getFile_2]: dart.definiteFunctionType(dart.void, [dart.dynamic, dart.dynamic, html$._EntryCallback]),
      [__getFile_3]: dart.definiteFunctionType(dart.void, [dart.dynamic, dart.dynamic]),
      [__getFile_4]: dart.definiteFunctionType(dart.void, [dart.dynamic]),
      [_getFile]: dart.definiteFunctionType(async.Future$(html$.Entry), [core.String], {options: core.Map}),
      [_removeRecursively]: dart.definiteFunctionType(dart.void, [html$.VoidCallback], [html$._ErrorCallback]),
      [dartx.removeRecursively]: dart.definiteFunctionType(async.Future, [])
    })
  });
  dart.registerExtension(dart.global.DirectoryEntry, html$.DirectoryEntry);
  const _readEntries = Symbol('_readEntries');
  dart.defineExtensionNames([
    'readEntries'
  ]);
  html$.DirectoryReader = class DirectoryReader extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [_readEntries](successCallback, errorCallback) {
      return this.readEntries(successCallback, errorCallback);
    }
    [dartx.readEntries]() {
      let completer = CompleterOfListOfEntry().new();
      this[_readEntries](dart.fn(value => {
        completer.complete(value);
      }, ListOfEntryTovoid()), dart.fn(error => {
        completer.completeError(error);
      }, FileErrorTovoid()));
      return completer.future;
    }
  };
  dart.setSignature(html$.DirectoryReader, {
    constructors: () => ({_: dart.definiteFunctionType(html$.DirectoryReader, [])}),
    methods: () => ({
      [_readEntries]: dart.definiteFunctionType(dart.void, [html$._EntriesCallback], [html$._ErrorCallback]),
      [dartx.readEntries]: dart.definiteFunctionType(async.Future$(core.List$(html$.Entry)), [])
    })
  });
  dart.registerExtension(dart.global.DirectoryReader, html$.DirectoryReader);
  html$.DivElement = class DivElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return html$.DivElement._check(html$.document[dartx.createElement]("div"));
    }
    created() {
      super.created();
    }
  };
  dart.defineNamedConstructor(html$.DivElement, 'created');
  dart.setSignature(html$.DivElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.DivElement, []),
      new: dart.definiteFunctionType(html$.DivElement, []),
      created: dart.definiteFunctionType(html$.DivElement, [])
    })
  });
  dart.registerExtension(dart.global.HTMLDivElement, html$.DivElement);
  const _body = Symbol('_body');
  const _get_window = Symbol('_get_window');
  const _head$ = Symbol('_head');
  const _lastModified = Symbol('_lastModified');
  const _preferredStylesheetSet = Symbol('_preferredStylesheetSet');
  const _referrer = Symbol('_referrer');
  const _selectedStylesheetSet = Symbol('_selectedStylesheetSet');
  const _styleSheets = Symbol('_styleSheets');
  const _title = Symbol('_title');
  const _visibilityState = Symbol('_visibilityState');
  const _webkitFullscreenElement = Symbol('_webkitFullscreenElement');
  const _webkitFullscreenEnabled = Symbol('_webkitFullscreenEnabled');
  const _webkitHidden = Symbol('_webkitHidden');
  const _webkitVisibilityState = Symbol('_webkitVisibilityState');
  const _caretRangeFromPoint = Symbol('_caretRangeFromPoint');
  const _createElement = Symbol('_createElement');
  const _createElementNS = Symbol('_createElementNS');
  const _createTouch_1 = Symbol('_createTouch_1');
  const _createTouch = Symbol('_createTouch');
  const _createTouchList = Symbol('_createTouchList');
  const _elementFromPoint = Symbol('_elementFromPoint');
  const _getCssCanvasContext = Symbol('_getCssCanvasContext');
  const _webkitExitFullscreen = Symbol('_webkitExitFullscreen');
  const _createElement_2 = Symbol('_createElement_2');
  const _createElementNS_2 = Symbol('_createElementNS_2');
  const _createNodeIterator = Symbol('_createNodeIterator');
  const _createTreeWalker = Symbol('_createTreeWalker');
  dart.defineExtensionNames([
    'window',
    'adoptNode',
    'createDocumentFragment',
    'createRange',
    'elementsFromPoint',
    'execCommand',
    'exitFullscreen',
    'exitPointerLock',
    'getElementsByClassName',
    'getElementsByName',
    'getElementsByTagName',
    'importNode',
    'queryCommandEnabled',
    'queryCommandIndeterm',
    'queryCommandState',
    'queryCommandSupported',
    'queryCommandValue',
    'transformDocumentToTreeView',
    'getElementById',
    'querySelector',
    'onAbort',
    'onBeforeCopy',
    'onBeforeCut',
    'onBeforePaste',
    'onBlur',
    'onCanPlay',
    'onCanPlayThrough',
    'onChange',
    'onClick',
    'onContextMenu',
    'onCopy',
    'onCut',
    'onDoubleClick',
    'onDrag',
    'onDragEnd',
    'onDragEnter',
    'onDragLeave',
    'onDragOver',
    'onDragStart',
    'onDrop',
    'onDurationChange',
    'onEmptied',
    'onEnded',
    'onError',
    'onFocus',
    'onInput',
    'onInvalid',
    'onKeyDown',
    'onKeyPress',
    'onKeyUp',
    'onLoad',
    'onLoadedData',
    'onLoadedMetadata',
    'onMouseDown',
    'onMouseEnter',
    'onMouseLeave',
    'onMouseMove',
    'onMouseOut',
    'onMouseOver',
    'onMouseUp',
    'onMouseWheel',
    'onPaste',
    'onPause',
    'onPlay',
    'onPlaying',
    'onPointerLockChange',
    'onPointerLockError',
    'onRateChange',
    'onReadyStateChange',
    'onReset',
    'onResize',
    'onScroll',
    'onSearch',
    'onSecurityPolicyViolation',
    'onSeeked',
    'onSeeking',
    'onSelect',
    'onSelectionChange',
    'onSelectStart',
    'onStalled',
    'onSubmit',
    'onSuspend',
    'onTimeUpdate',
    'onTouchCancel',
    'onTouchEnd',
    'onTouchMove',
    'onTouchStart',
    'onVolumeChange',
    'onWaiting',
    'onFullscreenChange',
    'onFullscreenError',
    'querySelectorAll',
    'query',
    'queryAll',
    'supportsRegisterElement',
    'supportsRegister',
    'createElement',
    'createElementNS',
    'visibilityState',
    'activeElement',
    'contentType',
    'cookie',
    'currentScript',
    'documentElement',
    'domain',
    'fonts',
    'fullscreenElement',
    'fullscreenEnabled',
    'hidden',
    'implementation',
    'origin',
    'pointerLockElement',
    'readyState',
    'rootElement',
    'scrollingElement',
    'timeline'
  ]);
  html$.Document = class Document extends html$.Node {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.activeElement]() {
      return this.activeElement;
    }
    get [_body]() {
      return this.body;
    }
    set [_body](value) {
      this.body = value;
    }
    get [dartx.contentType]() {
      return this.contentType;
    }
    get [dartx.cookie]() {
      return this.cookie;
    }
    set [dartx.cookie](value) {
      this.cookie = value;
    }
    get [dartx.currentScript]() {
      return this.currentScript;
    }
    get [dartx.window]() {
      return html$._convertNativeToDart_Window(this[_get_window]);
    }
    get [_get_window]() {
      return this.defaultView;
    }
    get [dartx.documentElement]() {
      return this.documentElement;
    }
    get [dartx.domain]() {
      return this.domain;
    }
    get [dartx.fonts]() {
      return this.fonts;
    }
    get [dartx.fullscreenElement]() {
      return this.fullscreenElement;
    }
    get [dartx.fullscreenEnabled]() {
      return this.fullscreenEnabled;
    }
    get [_head$]() {
      return this.head;
    }
    get [dartx.hidden]() {
      return this.hidden;
    }
    get [dartx.implementation]() {
      return this.implementation;
    }
    get [_lastModified]() {
      return this.lastModified;
    }
    get [dartx.origin]() {
      return this.origin;
    }
    get [dartx.pointerLockElement]() {
      return this.pointerLockElement;
    }
    get [_preferredStylesheetSet]() {
      return this.preferredStylesheetSet;
    }
    get [dartx.readyState]() {
      return this.readyState;
    }
    get [_referrer]() {
      return this.referrer;
    }
    get [dartx.rootElement]() {
      return this.rootElement;
    }
    get [dartx.scrollingElement]() {
      return this.scrollingElement;
    }
    get [_selectedStylesheetSet]() {
      return this.selectedStylesheetSet;
    }
    set [_selectedStylesheetSet](value) {
      this.selectedStylesheetSet = value;
    }
    get [_styleSheets]() {
      return this.styleSheets;
    }
    get [dartx.timeline]() {
      return this.timeline;
    }
    get [_title]() {
      return this.title;
    }
    set [_title](value) {
      this.title = value;
    }
    get [_visibilityState]() {
      return this.visibilityState;
    }
    get [_webkitFullscreenElement]() {
      return this.webkitFullscreenElement;
    }
    get [_webkitFullscreenEnabled]() {
      return this.webkitFullscreenEnabled;
    }
    get [_webkitHidden]() {
      return this.webkitHidden;
    }
    get [_webkitVisibilityState]() {
      return this.webkitVisibilityState;
    }
    [dartx.adoptNode](node) {
      return this.adoptNode(node);
    }
    [_caretRangeFromPoint](x, y) {
      return this.caretRangeFromPoint(x, y);
    }
    [dartx.createDocumentFragment]() {
      return this.createDocumentFragment();
    }
    [_createElement](localName_OR_tagName, typeExtension) {
      return this.createElement(localName_OR_tagName, typeExtension);
    }
    [_createElementNS](namespaceURI, qualifiedName, typeExtension) {
      return this.createElementNS(namespaceURI, qualifiedName, typeExtension);
    }
    [_createEvent](eventType) {
      return this.createEvent(eventType);
    }
    [dartx.createRange]() {
      return this.createRange();
    }
    [_createTextNode](data) {
      return this.createTextNode(data);
    }
    [_createTouch](window, target, identifier, pageX, pageY, screenX, screenY, radiusX, radiusY, rotationAngle, force) {
      let target_1 = html$._convertDartToNative_EventTarget(target);
      return this[_createTouch_1](window, target_1, identifier, pageX, pageY, screenX, screenY, radiusX, radiusY, rotationAngle, force);
    }
    [_createTouch_1](window, target, identifier, pageX, pageY, screenX, screenY, radiusX, radiusY, rotationAngle, force) {
      return this.createTouch(window, target, identifier, pageX, pageY, screenX, screenY, radiusX, radiusY, rotationAngle, force);
    }
    [_createTouchList](touches) {
      return this.createTouchList(touches);
    }
    [_elementFromPoint](x, y) {
      return this.elementFromPoint(x, y);
    }
    [dartx.elementsFromPoint](x, y) {
      return this.elementsFromPoint(x, y);
    }
    [dartx.execCommand](commandId, showUI, value) {
      return this.execCommand(commandId, showUI, value);
    }
    [dartx.exitFullscreen]() {
      return this.exitFullscreen();
    }
    [dartx.exitPointerLock]() {
      return this.exitPointerLock();
    }
    [_getCssCanvasContext](contextId, name, width, height) {
      return this.getCSSCanvasContext(contextId, name, width, height);
    }
    [dartx.getElementsByClassName](classNames) {
      return this.getElementsByClassName(classNames);
    }
    [dartx.getElementsByName](elementName) {
      return this.getElementsByName(elementName);
    }
    [dartx.getElementsByTagName](localName) {
      return this.getElementsByTagName(localName);
    }
    [dartx.importNode](node, deep) {
      return this.importNode(node, deep);
    }
    [dartx.queryCommandEnabled](commandId) {
      return this.queryCommandEnabled(commandId);
    }
    [dartx.queryCommandIndeterm](commandId) {
      return this.queryCommandIndeterm(commandId);
    }
    [dartx.queryCommandState](commandId) {
      return this.queryCommandState(commandId);
    }
    [dartx.queryCommandSupported](commandId) {
      return this.queryCommandSupported(commandId);
    }
    [dartx.queryCommandValue](commandId) {
      return this.queryCommandValue(commandId);
    }
    [dartx.transformDocumentToTreeView](noStyleMessage) {
      return this.transformDocumentToTreeView(noStyleMessage);
    }
    [_webkitExitFullscreen]() {
      return this.webkitExitFullscreen();
    }
    [dartx.getElementById](elementId) {
      return this.getElementById(elementId);
    }
    get [_childElementCount]() {
      return this.childElementCount;
    }
    get [_children]() {
      return this.children;
    }
    get [_firstElementChild]() {
      return this.firstElementChild;
    }
    get [_lastElementChild]() {
      return this.lastElementChild;
    }
    [dartx.querySelector](selectors) {
      return this.querySelector(selectors);
    }
    [_querySelectorAll](selectors) {
      return this.querySelectorAll(selectors);
    }
    get [dartx.onAbort]() {
      return html$.Element.abortEvent.forTarget(this);
    }
    get [dartx.onBeforeCopy]() {
      return html$.Element.beforeCopyEvent.forTarget(this);
    }
    get [dartx.onBeforeCut]() {
      return html$.Element.beforeCutEvent.forTarget(this);
    }
    get [dartx.onBeforePaste]() {
      return html$.Element.beforePasteEvent.forTarget(this);
    }
    get [dartx.onBlur]() {
      return html$.Element.blurEvent.forTarget(this);
    }
    get [dartx.onCanPlay]() {
      return html$.Element.canPlayEvent.forTarget(this);
    }
    get [dartx.onCanPlayThrough]() {
      return html$.Element.canPlayThroughEvent.forTarget(this);
    }
    get [dartx.onChange]() {
      return html$.Element.changeEvent.forTarget(this);
    }
    get [dartx.onClick]() {
      return html$.Element.clickEvent.forTarget(this);
    }
    get [dartx.onContextMenu]() {
      return html$.Element.contextMenuEvent.forTarget(this);
    }
    get [dartx.onCopy]() {
      return html$.Element.copyEvent.forTarget(this);
    }
    get [dartx.onCut]() {
      return html$.Element.cutEvent.forTarget(this);
    }
    get [dartx.onDoubleClick]() {
      return html$.Element.doubleClickEvent.forTarget(this);
    }
    get [dartx.onDrag]() {
      return html$.Element.dragEvent.forTarget(this);
    }
    get [dartx.onDragEnd]() {
      return html$.Element.dragEndEvent.forTarget(this);
    }
    get [dartx.onDragEnter]() {
      return html$.Element.dragEnterEvent.forTarget(this);
    }
    get [dartx.onDragLeave]() {
      return html$.Element.dragLeaveEvent.forTarget(this);
    }
    get [dartx.onDragOver]() {
      return html$.Element.dragOverEvent.forTarget(this);
    }
    get [dartx.onDragStart]() {
      return html$.Element.dragStartEvent.forTarget(this);
    }
    get [dartx.onDrop]() {
      return html$.Element.dropEvent.forTarget(this);
    }
    get [dartx.onDurationChange]() {
      return html$.Element.durationChangeEvent.forTarget(this);
    }
    get [dartx.onEmptied]() {
      return html$.Element.emptiedEvent.forTarget(this);
    }
    get [dartx.onEnded]() {
      return html$.Element.endedEvent.forTarget(this);
    }
    get [dartx.onError]() {
      return html$.Element.errorEvent.forTarget(this);
    }
    get [dartx.onFocus]() {
      return html$.Element.focusEvent.forTarget(this);
    }
    get [dartx.onInput]() {
      return html$.Element.inputEvent.forTarget(this);
    }
    get [dartx.onInvalid]() {
      return html$.Element.invalidEvent.forTarget(this);
    }
    get [dartx.onKeyDown]() {
      return html$.Element.keyDownEvent.forTarget(this);
    }
    get [dartx.onKeyPress]() {
      return html$.Element.keyPressEvent.forTarget(this);
    }
    get [dartx.onKeyUp]() {
      return html$.Element.keyUpEvent.forTarget(this);
    }
    get [dartx.onLoad]() {
      return html$.Element.loadEvent.forTarget(this);
    }
    get [dartx.onLoadedData]() {
      return html$.Element.loadedDataEvent.forTarget(this);
    }
    get [dartx.onLoadedMetadata]() {
      return html$.Element.loadedMetadataEvent.forTarget(this);
    }
    get [dartx.onMouseDown]() {
      return html$.Element.mouseDownEvent.forTarget(this);
    }
    get [dartx.onMouseEnter]() {
      return html$.Element.mouseEnterEvent.forTarget(this);
    }
    get [dartx.onMouseLeave]() {
      return html$.Element.mouseLeaveEvent.forTarget(this);
    }
    get [dartx.onMouseMove]() {
      return html$.Element.mouseMoveEvent.forTarget(this);
    }
    get [dartx.onMouseOut]() {
      return html$.Element.mouseOutEvent.forTarget(this);
    }
    get [dartx.onMouseOver]() {
      return html$.Element.mouseOverEvent.forTarget(this);
    }
    get [dartx.onMouseUp]() {
      return html$.Element.mouseUpEvent.forTarget(this);
    }
    get [dartx.onMouseWheel]() {
      return html$.Element.mouseWheelEvent.forTarget(this);
    }
    get [dartx.onPaste]() {
      return html$.Element.pasteEvent.forTarget(this);
    }
    get [dartx.onPause]() {
      return html$.Element.pauseEvent.forTarget(this);
    }
    get [dartx.onPlay]() {
      return html$.Element.playEvent.forTarget(this);
    }
    get [dartx.onPlaying]() {
      return html$.Element.playingEvent.forTarget(this);
    }
    get [dartx.onPointerLockChange]() {
      return html$.Document.pointerLockChangeEvent.forTarget(this);
    }
    get [dartx.onPointerLockError]() {
      return html$.Document.pointerLockErrorEvent.forTarget(this);
    }
    get [dartx.onRateChange]() {
      return html$.Element.rateChangeEvent.forTarget(this);
    }
    get [dartx.onReadyStateChange]() {
      return html$.Document.readyStateChangeEvent.forTarget(this);
    }
    get [dartx.onReset]() {
      return html$.Element.resetEvent.forTarget(this);
    }
    get [dartx.onResize]() {
      return html$.Element.resizeEvent.forTarget(this);
    }
    get [dartx.onScroll]() {
      return html$.Element.scrollEvent.forTarget(this);
    }
    get [dartx.onSearch]() {
      return html$.Element.searchEvent.forTarget(this);
    }
    get [dartx.onSecurityPolicyViolation]() {
      return html$.Document.securityPolicyViolationEvent.forTarget(this);
    }
    get [dartx.onSeeked]() {
      return html$.Element.seekedEvent.forTarget(this);
    }
    get [dartx.onSeeking]() {
      return html$.Element.seekingEvent.forTarget(this);
    }
    get [dartx.onSelect]() {
      return html$.Element.selectEvent.forTarget(this);
    }
    get [dartx.onSelectionChange]() {
      return html$.Document.selectionChangeEvent.forTarget(this);
    }
    get [dartx.onSelectStart]() {
      return html$.Element.selectStartEvent.forTarget(this);
    }
    get [dartx.onStalled]() {
      return html$.Element.stalledEvent.forTarget(this);
    }
    get [dartx.onSubmit]() {
      return html$.Element.submitEvent.forTarget(this);
    }
    get [dartx.onSuspend]() {
      return html$.Element.suspendEvent.forTarget(this);
    }
    get [dartx.onTimeUpdate]() {
      return html$.Element.timeUpdateEvent.forTarget(this);
    }
    get [dartx.onTouchCancel]() {
      return html$.Element.touchCancelEvent.forTarget(this);
    }
    get [dartx.onTouchEnd]() {
      return html$.Element.touchEndEvent.forTarget(this);
    }
    get [dartx.onTouchMove]() {
      return html$.Element.touchMoveEvent.forTarget(this);
    }
    get [dartx.onTouchStart]() {
      return html$.Element.touchStartEvent.forTarget(this);
    }
    get [dartx.onVolumeChange]() {
      return html$.Element.volumeChangeEvent.forTarget(this);
    }
    get [dartx.onWaiting]() {
      return html$.Element.waitingEvent.forTarget(this);
    }
    get [dartx.onFullscreenChange]() {
      return html$.Element.fullscreenChangeEvent.forTarget(this);
    }
    get [dartx.onFullscreenError]() {
      return html$.Element.fullscreenErrorEvent.forTarget(this);
    }
    [dartx.querySelectorAll](T) {
      return selectors => {
        return new (html$._FrozenElementList$(T))._wrap(this[_querySelectorAll](selectors));
      };
    }
    [dartx.query](relativeSelectors) {
      return this[dartx.querySelector](relativeSelectors);
    }
    [dartx.queryAll](T) {
      return relativeSelectors => {
        return this[dartx.querySelectorAll](T)(relativeSelectors);
      };
    }
    get [dartx.supportsRegisterElement]() {
      return "registerElement" in this;
    }
    get [dartx.supportsRegister]() {
      return this[dartx.supportsRegisterElement];
    }
    [dartx.createElement](tagName, typeExtension) {
      if (typeExtension === void 0) typeExtension = null;
      return html$.Element._check(typeExtension == null ? this[_createElement_2](tagName) : this[_createElement](tagName, typeExtension));
    }
    [_createElement_2](tagName) {
      return this.createElement(tagName);
    }
    [_createElementNS_2](namespaceURI, qualifiedName) {
      return this.createElementNS(namespaceURI, qualifiedName);
    }
    [dartx.createElementNS](namespaceURI, qualifiedName, typeExtension) {
      if (typeExtension === void 0) typeExtension = null;
      return html$.Element._check(typeExtension == null ? this[_createElementNS_2](namespaceURI, qualifiedName) : this[_createElementNS](namespaceURI, qualifiedName, typeExtension));
    }
    [_createNodeIterator](root, whatToShow, filter) {
      if (whatToShow === void 0) whatToShow = null;
      if (filter === void 0) filter = null;
      return this.createNodeIterator(root, whatToShow, filter, false);
    }
    [_createTreeWalker](root, whatToShow, filter) {
      if (whatToShow === void 0) whatToShow = null;
      if (filter === void 0) filter = null;
      return this.createTreeWalker(root, whatToShow, filter, false);
    }
    get [dartx.visibilityState]() {
      return this.visibilityState || this.mozVisibilityState || this.msVisibilityState || this.webkitVisibilityState;
    }
  };
  dart.setSignature(html$.Document, {
    constructors: () => ({_: dart.definiteFunctionType(html$.Document, [])}),
    methods: () => ({
      [dartx.adoptNode]: dart.definiteFunctionType(html$.Node, [html$.Node]),
      [_caretRangeFromPoint]: dart.definiteFunctionType(html$.Range, [core.int, core.int]),
      [dartx.createDocumentFragment]: dart.definiteFunctionType(html$.DocumentFragment, []),
      [_createElement]: dart.definiteFunctionType(html$.Element, [core.String], [core.String]),
      [_createElementNS]: dart.definiteFunctionType(html$.Element, [core.String, core.String], [core.String]),
      [_createEvent]: dart.definiteFunctionType(html$.Event, [core.String]),
      [dartx.createRange]: dart.definiteFunctionType(html$.Range, []),
      [_createTextNode]: dart.definiteFunctionType(html$.Text, [core.String]),
      [_createTouch]: dart.definiteFunctionType(html$.Touch, [html$.Window, html$.EventTarget, core.int, core.num, core.num, core.num, core.num, core.num, core.num, core.num, core.num]),
      [_createTouch_1]: dart.definiteFunctionType(html$.Touch, [html$.Window, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic]),
      [_createTouchList]: dart.definiteFunctionType(html$.TouchList, [html$.Touch]),
      [_elementFromPoint]: dart.definiteFunctionType(html$.Element, [core.int, core.int]),
      [dartx.elementsFromPoint]: dart.definiteFunctionType(core.List$(html$.Element), [core.int, core.int]),
      [dartx.execCommand]: dart.definiteFunctionType(core.bool, [core.String], [core.bool, core.String]),
      [dartx.exitFullscreen]: dart.definiteFunctionType(dart.void, []),
      [dartx.exitPointerLock]: dart.definiteFunctionType(dart.void, []),
      [_getCssCanvasContext]: dart.definiteFunctionType(core.Object, [core.String, core.String, core.int, core.int]),
      [dartx.getElementsByClassName]: dart.definiteFunctionType(core.List$(html$.Node), [core.String]),
      [dartx.getElementsByName]: dart.definiteFunctionType(core.List$(html$.Node), [core.String]),
      [dartx.getElementsByTagName]: dart.definiteFunctionType(core.List$(html$.Node), [core.String]),
      [dartx.importNode]: dart.definiteFunctionType(html$.Node, [html$.Node], [core.bool]),
      [dartx.queryCommandEnabled]: dart.definiteFunctionType(core.bool, [core.String]),
      [dartx.queryCommandIndeterm]: dart.definiteFunctionType(core.bool, [core.String]),
      [dartx.queryCommandState]: dart.definiteFunctionType(core.bool, [core.String]),
      [dartx.queryCommandSupported]: dart.definiteFunctionType(core.bool, [core.String]),
      [dartx.queryCommandValue]: dart.definiteFunctionType(core.String, [core.String]),
      [dartx.transformDocumentToTreeView]: dart.definiteFunctionType(dart.void, [core.String]),
      [_webkitExitFullscreen]: dart.definiteFunctionType(dart.void, []),
      [dartx.getElementById]: dart.definiteFunctionType(html$.Element, [core.String]),
      [dartx.querySelector]: dart.definiteFunctionType(html$.Element, [core.String]),
      [_querySelectorAll]: dart.definiteFunctionType(core.List$(html$.Node), [core.String]),
      [dartx.querySelectorAll]: dart.definiteFunctionType(T => [html$.ElementList$(T), [core.String]]),
      [dartx.query]: dart.definiteFunctionType(html$.Element, [core.String]),
      [dartx.queryAll]: dart.definiteFunctionType(T => [html$.ElementList$(T), [core.String]]),
      [dartx.createElement]: dart.definiteFunctionType(html$.Element, [core.String], [core.String]),
      [_createElement_2]: dart.definiteFunctionType(dart.dynamic, [core.String]),
      [_createElementNS_2]: dart.definiteFunctionType(dart.dynamic, [core.String, core.String]),
      [dartx.createElementNS]: dart.definiteFunctionType(html$.Element, [core.String, core.String], [core.String]),
      [_createNodeIterator]: dart.definiteFunctionType(html$.NodeIterator, [html$.Node], [core.int, html$.NodeFilter]),
      [_createTreeWalker]: dart.definiteFunctionType(html$.TreeWalker, [html$.Node], [core.int, html$.NodeFilter])
    })
  });
  dart.defineLazy(html$.Document, {
    get pointerLockChangeEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('pointerlockchange'));
    },
    get pointerLockErrorEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('pointerlockerror'));
    },
    get readyStateChangeEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('readystatechange'));
    },
    get securityPolicyViolationEvent() {
      return dart.const(new (EventStreamProviderOfSecurityPolicyViolationEvent())('securitypolicyviolation'));
    },
    get selectionChangeEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('selectionchange'));
    }
  });
  dart.registerExtension(dart.global.Document, html$.Document);
  const _docChildren = Symbol('_docChildren');
  dart.defineExtensionNames([
    'children',
    'children',
    'querySelectorAll',
    'innerHtml',
    'innerHtml',
    'setInnerHtml',
    'appendText',
    'appendHtml',
    'query',
    'queryAll',
    'getElementById',
    'querySelector'
  ]);
  html$.DocumentFragment = class DocumentFragment extends html$.Node {
    static new() {
      return html$.document[dartx.createDocumentFragment]();
    }
    static html(html, opts) {
      let validator = opts && 'validator' in opts ? opts.validator : null;
      let treeSanitizer = opts && 'treeSanitizer' in opts ? opts.treeSanitizer : null;
      return html$.document[dartx.body][dartx.createFragment](html, {validator: validator, treeSanitizer: treeSanitizer});
    }
    static svg(svgContent, opts) {
      let validator = opts && 'validator' in opts ? opts.validator : null;
      let treeSanitizer = opts && 'treeSanitizer' in opts ? opts.treeSanitizer : null;
      return svg$.SvgSvgElement.new()[dartx.createFragment](svgContent, {validator: validator, treeSanitizer: treeSanitizer});
    }
    get [_children]() {
      return dart.throw(new core.UnimplementedError('Use _docChildren instead'));
    }
    get [_docChildren]() {
      return this._docChildren;
    }
    set [_docChildren](value) {
      this._docChildren = value;
    }
    get [dartx.children]() {
      if (this[_docChildren] == null) {
        this[_docChildren] = new html_common.FilteredElementList(this);
      }
      return this[_docChildren];
    }
    set [dartx.children](value) {
      let copy = value[dartx.toList]();
      let children = this[dartx.children];
      children[dartx.clear]();
      children[dartx.addAll](copy);
    }
    [dartx.querySelectorAll](T) {
      return selectors => {
        return new (html$._FrozenElementList$(T))._wrap(this[_querySelectorAll](selectors));
      };
    }
    get [dartx.innerHtml]() {
      let e = html$.Element.tag("div");
      e[dartx.append](this[dartx.clone](true));
      return e[dartx.innerHtml];
    }
    set [dartx.innerHtml](value) {
      this[dartx.setInnerHtml](value);
    }
    [dartx.setInnerHtml](html, opts) {
      let validator = opts && 'validator' in opts ? opts.validator : null;
      let treeSanitizer = opts && 'treeSanitizer' in opts ? opts.treeSanitizer : null;
      this[dartx.nodes][dartx.clear]();
      this[dartx.append](html$.document[dartx.body][dartx.createFragment](html, {validator: validator, treeSanitizer: treeSanitizer}));
    }
    [dartx.appendText](text) {
      this[dartx.append](html$.Text.new(text));
    }
    [dartx.appendHtml](text, opts) {
      let validator = opts && 'validator' in opts ? opts.validator : null;
      let NodeTreeSanitizer = opts && 'NodeTreeSanitizer' in opts ? opts.NodeTreeSanitizer : null;
      let treeSanitizer = opts && 'treeSanitizer' in opts ? opts.treeSanitizer : null;
      this[dartx.append](html$.DocumentFragment.html(text, {validator: validator, treeSanitizer: html$.NodeTreeSanitizer._check(treeSanitizer)}));
    }
    [dartx.query](relativeSelectors) {
      return this[dartx.querySelector](relativeSelectors);
    }
    [dartx.queryAll](T) {
      return relativeSelectors => {
        return this[dartx.querySelectorAll](T)(relativeSelectors);
      };
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [dartx.getElementById](elementId) {
      return this.getElementById(elementId);
    }
    get [_childElementCount]() {
      return this.childElementCount;
    }
    get [_firstElementChild]() {
      return this.firstElementChild;
    }
    get [_lastElementChild]() {
      return this.lastElementChild;
    }
    [dartx.querySelector](selectors) {
      return this.querySelector(selectors);
    }
    [_querySelectorAll](selectors) {
      return this.querySelectorAll(selectors);
    }
  };
  html$.DocumentFragment[dart.implements] = () => [html$.NonElementParentNode, html$.ParentNode];
  dart.setSignature(html$.DocumentFragment, {
    constructors: () => ({
      new: dart.definiteFunctionType(html$.DocumentFragment, []),
      html: dart.definiteFunctionType(html$.DocumentFragment, [core.String], {validator: html$.NodeValidator, treeSanitizer: html$.NodeTreeSanitizer}),
      svg: dart.definiteFunctionType(html$.DocumentFragment, [core.String], {validator: html$.NodeValidator, treeSanitizer: html$.NodeTreeSanitizer}),
      _: dart.definiteFunctionType(html$.DocumentFragment, [])
    }),
    methods: () => ({
      [dartx.querySelectorAll]: dart.definiteFunctionType(T => [html$.ElementList$(T), [core.String]]),
      [dartx.setInnerHtml]: dart.definiteFunctionType(dart.void, [core.String], {validator: html$.NodeValidator, treeSanitizer: html$.NodeTreeSanitizer}),
      [dartx.appendText]: dart.definiteFunctionType(dart.void, [core.String]),
      [dartx.appendHtml]: dart.definiteFunctionType(dart.void, [core.String], {validator: html$.NodeValidator, NodeTreeSanitizer: dart.dynamic, treeSanitizer: dart.dynamic}),
      [dartx.query]: dart.definiteFunctionType(html$.Element, [core.String]),
      [dartx.queryAll]: dart.definiteFunctionType(T => [html$.ElementList$(T), [core.String]]),
      [dartx.getElementById]: dart.definiteFunctionType(html$.Element, [core.String]),
      [dartx.querySelector]: dart.definiteFunctionType(html$.Element, [core.String]),
      [_querySelectorAll]: dart.definiteFunctionType(core.List$(html$.Node), [core.String])
    })
  });
  dart.registerExtension(dart.global.DocumentFragment, html$.DocumentFragment);
  dart.defineExtensionNames([
    'message',
    'name'
  ]);
  html$.DomError = class DomError extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(name, message) {
      if (message === void 0) message = null;
      if (message != null) {
        return html$.DomError._create_1(name, message);
      }
      return html$.DomError._create_2(name);
    }
    static _create_1(name, message) {
      return new DOMError(name, message);
    }
    static _create_2(name) {
      return new DOMError(name);
    }
    get [dartx.message]() {
      return this.message;
    }
    get [dartx.name]() {
      return this.name;
    }
  };
  dart.setSignature(html$.DomError, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.DomError, []),
      new: dart.definiteFunctionType(html$.DomError, [core.String], [core.String])
    }),
    statics: () => ({
      _create_1: dart.definiteFunctionType(html$.DomError, [dart.dynamic, dart.dynamic]),
      _create_2: dart.definiteFunctionType(html$.DomError, [dart.dynamic])
    }),
    names: ['_create_1', '_create_2']
  });
  dart.registerExtension(dart.global.DOMError, html$.DomError);
  dart.defineExtensionNames([
    'name',
    'toString',
    'message'
  ]);
  html$.DomException = class DomException extends _interceptors.Interceptor {
    get [dartx.name]() {
      let errorName = this.name;
      if (dart.test(html_common.Device.isWebKit) && errorName == 'SECURITY_ERR') return 'SecurityError';
      if (dart.test(html_common.Device.isWebKit) && errorName == 'SYNTAX_ERR') return 'SyntaxError';
      return errorName;
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.message]() {
      return this.message;
    }
    [dartx.toString]() {
      return String(this);
    }
  };
  dart.setSignature(html$.DomException, {
    constructors: () => ({_: dart.definiteFunctionType(html$.DomException, [])})
  });
  html$.DomException.INDEX_SIZE = 'IndexSizeError';
  html$.DomException.HIERARCHY_REQUEST = 'HierarchyRequestError';
  html$.DomException.WRONG_DOCUMENT = 'WrongDocumentError';
  html$.DomException.INVALID_CHARACTER = 'InvalidCharacterError';
  html$.DomException.NO_MODIFICATION_ALLOWED = 'NoModificationAllowedError';
  html$.DomException.NOT_FOUND = 'NotFoundError';
  html$.DomException.NOT_SUPPORTED = 'NotSupportedError';
  html$.DomException.INVALID_STATE = 'InvalidStateError';
  html$.DomException.SYNTAX = 'SyntaxError';
  html$.DomException.INVALID_MODIFICATION = 'InvalidModificationError';
  html$.DomException.NAMESPACE = 'NamespaceError';
  html$.DomException.INVALID_ACCESS = 'InvalidAccessError';
  html$.DomException.TYPE_MISMATCH = 'TypeMismatchError';
  html$.DomException.SECURITY = 'SecurityError';
  html$.DomException.NETWORK = 'NetworkError';
  html$.DomException.ABORT = 'AbortError';
  html$.DomException.URL_MISMATCH = 'URLMismatchError';
  html$.DomException.QUOTA_EXCEEDED = 'QuotaExceededError';
  html$.DomException.TIMEOUT = 'TimeoutError';
  html$.DomException.INVALID_NODE_TYPE = 'InvalidNodeTypeError';
  html$.DomException.DATA_CLONE = 'DataCloneError';
  dart.registerExtension(dart.global.DOMException, html$.DomException);
  dart.defineExtensionNames([
    'createDocument',
    'createDocumentType',
    'createHtmlDocument',
    'hasFeature'
  ]);
  html$.DomImplementation = class DomImplementation extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [dartx.createDocument](namespaceURI, qualifiedName, doctype) {
      return this.createDocument(namespaceURI, qualifiedName, doctype);
    }
    [dartx.createDocumentType](qualifiedName, publicId, systemId) {
      return this.createDocumentType(qualifiedName, publicId, systemId);
    }
    [dartx.createHtmlDocument](title) {
      return this.createHTMLDocument(title);
    }
    [dartx.hasFeature]() {
      return this.hasFeature();
    }
  };
  dart.setSignature(html$.DomImplementation, {
    constructors: () => ({_: dart.definiteFunctionType(html$.DomImplementation, [])}),
    methods: () => ({
      [dartx.createDocument]: dart.definiteFunctionType(html$.XmlDocument, [core.String, core.String, html$._DocumentType]),
      [dartx.createDocumentType]: dart.definiteFunctionType(html$._DocumentType, [core.String, core.String, core.String]),
      [dartx.createHtmlDocument]: dart.definiteFunctionType(html$.HtmlDocument, [core.String]),
      [dartx.hasFeature]: dart.definiteFunctionType(core.bool, [])
    })
  });
  dart.registerExtension(dart.global.DOMImplementation, html$.DomImplementation);
  dart.defineExtensionNames([
    'next'
  ]);
  html$.DomIterator = class DomIterator extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [dartx.next](value) {
      return this.next(value);
    }
  };
  dart.setSignature(html$.DomIterator, {
    constructors: () => ({_: dart.definiteFunctionType(html$.DomIterator, [])}),
    methods: () => ({[dartx.next]: dart.definiteFunctionType(core.Object, [], [core.Object])})
  });
  dart.registerExtension(dart.global.Iterator, html$.DomIterator);
  dart.defineExtensionNames([
    'a',
    'b',
    'c',
    'd',
    'e',
    'f',
    'is2D',
    'isIdentity',
    'm11',
    'm12',
    'm13',
    'm14',
    'm21',
    'm22',
    'm23',
    'm24',
    'm31',
    'm32',
    'm33',
    'm34',
    'm41',
    'm42',
    'm43',
    'm44',
    'multiply',
    'scale',
    'scale3d',
    'scaleNonUniform',
    'toFloat32Array',
    'toFloat64Array',
    'translate'
  ]);
  html$.DomMatrixReadOnly = class DomMatrixReadOnly extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.a]() {
      return this.a;
    }
    get [dartx.b]() {
      return this.b;
    }
    get [dartx.c]() {
      return this.c;
    }
    get [dartx.d]() {
      return this.d;
    }
    get [dartx.e]() {
      return this.e;
    }
    get [dartx.f]() {
      return this.f;
    }
    get [dartx.is2D]() {
      return this.is2D;
    }
    get [dartx.isIdentity]() {
      return this.isIdentity;
    }
    get [dartx.m11]() {
      return this.m11;
    }
    get [dartx.m12]() {
      return this.m12;
    }
    get [dartx.m13]() {
      return this.m13;
    }
    get [dartx.m14]() {
      return this.m14;
    }
    get [dartx.m21]() {
      return this.m21;
    }
    get [dartx.m22]() {
      return this.m22;
    }
    get [dartx.m23]() {
      return this.m23;
    }
    get [dartx.m24]() {
      return this.m24;
    }
    get [dartx.m31]() {
      return this.m31;
    }
    get [dartx.m32]() {
      return this.m32;
    }
    get [dartx.m33]() {
      return this.m33;
    }
    get [dartx.m34]() {
      return this.m34;
    }
    get [dartx.m41]() {
      return this.m41;
    }
    get [dartx.m42]() {
      return this.m42;
    }
    get [dartx.m43]() {
      return this.m43;
    }
    get [dartx.m44]() {
      return this.m44;
    }
    [dartx.multiply](other) {
      return this.multiply(other);
    }
    [dartx.scale](scale, originX, originY) {
      return this.scale(scale, originX, originY);
    }
    [dartx.scale3d](scale, originX, originY, originZ) {
      return this.scale3d(scale, originX, originY, originZ);
    }
    [dartx.scaleNonUniform](scaleX, scaleY, scaleZn, originX, originY, originZ) {
      return this.scaleNonUniform(scaleX, scaleY, scaleZn, originX, originY, originZ);
    }
    [dartx.toFloat32Array]() {
      return this.toFloat32Array();
    }
    [dartx.toFloat64Array]() {
      return this.toFloat64Array();
    }
    [dartx.translate](tx, ty, tz) {
      return this.translate(tx, ty, tz);
    }
  };
  dart.setSignature(html$.DomMatrixReadOnly, {
    constructors: () => ({_: dart.definiteFunctionType(html$.DomMatrixReadOnly, [])}),
    methods: () => ({
      [dartx.multiply]: dart.definiteFunctionType(html$.DomMatrix, [html$.DomMatrix]),
      [dartx.scale]: dart.definiteFunctionType(html$.DomMatrix, [core.num], [core.num, core.num]),
      [dartx.scale3d]: dart.definiteFunctionType(html$.DomMatrix, [core.num], [core.num, core.num, core.num]),
      [dartx.scaleNonUniform]: dart.definiteFunctionType(html$.DomMatrix, [core.num], [core.num, core.num, core.num, core.num, core.num]),
      [dartx.toFloat32Array]: dart.definiteFunctionType(typed_data.Float32List, []),
      [dartx.toFloat64Array]: dart.definiteFunctionType(typed_data.Float64List, []),
      [dartx.translate]: dart.definiteFunctionType(html$.DomMatrix, [core.num, core.num], [core.num])
    })
  });
  dart.registerExtension(dart.global.DOMMatrixReadOnly, html$.DomMatrixReadOnly);
  dart.defineExtensionNames([
    'a',
    'a',
    'b',
    'b',
    'c',
    'c',
    'd',
    'd',
    'e',
    'e',
    'f',
    'f',
    'm11',
    'm11',
    'm12',
    'm12',
    'm13',
    'm13',
    'm14',
    'm14',
    'm21',
    'm21',
    'm22',
    'm22',
    'm23',
    'm23',
    'm24',
    'm24',
    'm31',
    'm31',
    'm32',
    'm32',
    'm33',
    'm33',
    'm34',
    'm34',
    'm41',
    'm41',
    'm42',
    'm42',
    'm43',
    'm43',
    'm44',
    'm44',
    'multiplySelf',
    'preMultiplySelf',
    'scale3dSelf',
    'scaleNonUniformSelf',
    'scaleSelf',
    'translateSelf'
  ]);
  html$.DomMatrix = class DomMatrix extends html$.DomMatrixReadOnly {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(other) {
      if (other === void 0) other = null;
      if (other == null) {
        return html$.DomMatrix._create_1();
      }
      if (html$.DomMatrixReadOnly.is(other) || other == null) {
        return html$.DomMatrix._create_2(other);
      }
      dart.throw(new core.ArgumentError("Incorrect number or type of arguments"));
    }
    static _create_1() {
      return new DOMMatrix();
    }
    static _create_2(other) {
      return new DOMMatrix(other);
    }
    get [dartx.a]() {
      return this.a;
    }
    set [dartx.a](value) {
      this.a = value;
    }
    get [dartx.b]() {
      return this.b;
    }
    set [dartx.b](value) {
      this.b = value;
    }
    get [dartx.c]() {
      return this.c;
    }
    set [dartx.c](value) {
      this.c = value;
    }
    get [dartx.d]() {
      return this.d;
    }
    set [dartx.d](value) {
      this.d = value;
    }
    get [dartx.e]() {
      return this.e;
    }
    set [dartx.e](value) {
      this.e = value;
    }
    get [dartx.f]() {
      return this.f;
    }
    set [dartx.f](value) {
      this.f = value;
    }
    get [dartx.m11]() {
      return this.m11;
    }
    set [dartx.m11](value) {
      this.m11 = value;
    }
    get [dartx.m12]() {
      return this.m12;
    }
    set [dartx.m12](value) {
      this.m12 = value;
    }
    get [dartx.m13]() {
      return this.m13;
    }
    set [dartx.m13](value) {
      this.m13 = value;
    }
    get [dartx.m14]() {
      return this.m14;
    }
    set [dartx.m14](value) {
      this.m14 = value;
    }
    get [dartx.m21]() {
      return this.m21;
    }
    set [dartx.m21](value) {
      this.m21 = value;
    }
    get [dartx.m22]() {
      return this.m22;
    }
    set [dartx.m22](value) {
      this.m22 = value;
    }
    get [dartx.m23]() {
      return this.m23;
    }
    set [dartx.m23](value) {
      this.m23 = value;
    }
    get [dartx.m24]() {
      return this.m24;
    }
    set [dartx.m24](value) {
      this.m24 = value;
    }
    get [dartx.m31]() {
      return this.m31;
    }
    set [dartx.m31](value) {
      this.m31 = value;
    }
    get [dartx.m32]() {
      return this.m32;
    }
    set [dartx.m32](value) {
      this.m32 = value;
    }
    get [dartx.m33]() {
      return this.m33;
    }
    set [dartx.m33](value) {
      this.m33 = value;
    }
    get [dartx.m34]() {
      return this.m34;
    }
    set [dartx.m34](value) {
      this.m34 = value;
    }
    get [dartx.m41]() {
      return this.m41;
    }
    set [dartx.m41](value) {
      this.m41 = value;
    }
    get [dartx.m42]() {
      return this.m42;
    }
    set [dartx.m42](value) {
      this.m42 = value;
    }
    get [dartx.m43]() {
      return this.m43;
    }
    set [dartx.m43](value) {
      this.m43 = value;
    }
    get [dartx.m44]() {
      return this.m44;
    }
    set [dartx.m44](value) {
      this.m44 = value;
    }
    [dartx.multiplySelf](other) {
      return this.multiplySelf(other);
    }
    [dartx.preMultiplySelf](other) {
      return this.preMultiplySelf(other);
    }
    [dartx.scale3dSelf](scale, originX, originY, originZ) {
      return this.scale3dSelf(scale, originX, originY, originZ);
    }
    [dartx.scaleNonUniformSelf](scaleX, scaleY, scaleZ, originX, originY, originZ) {
      return this.scaleNonUniformSelf(scaleX, scaleY, scaleZ, originX, originY, originZ);
    }
    [dartx.scaleSelf](scale, originX, originY) {
      return this.scaleSelf(scale, originX, originY);
    }
    [dartx.translateSelf](tx, ty, tz) {
      return this.translateSelf(tx, ty, tz);
    }
  };
  dart.setSignature(html$.DomMatrix, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.DomMatrix, []),
      new: dart.definiteFunctionType(html$.DomMatrix, [], [html$.DomMatrixReadOnly])
    }),
    methods: () => ({
      [dartx.multiplySelf]: dart.definiteFunctionType(html$.DomMatrix, [html$.DomMatrix]),
      [dartx.preMultiplySelf]: dart.definiteFunctionType(html$.DomMatrix, [html$.DomMatrix]),
      [dartx.scale3dSelf]: dart.definiteFunctionType(html$.DomMatrix, [core.num], [core.num, core.num, core.num]),
      [dartx.scaleNonUniformSelf]: dart.definiteFunctionType(html$.DomMatrix, [core.num], [core.num, core.num, core.num, core.num, core.num]),
      [dartx.scaleSelf]: dart.definiteFunctionType(html$.DomMatrix, [core.num], [core.num, core.num]),
      [dartx.translateSelf]: dart.definiteFunctionType(html$.DomMatrix, [core.num, core.num], [core.num])
    }),
    statics: () => ({
      _create_1: dart.definiteFunctionType(html$.DomMatrix, []),
      _create_2: dart.definiteFunctionType(html$.DomMatrix, [dart.dynamic])
    }),
    names: ['_create_1', '_create_2']
  });
  dart.registerExtension(dart.global.DOMMatrix, html$.DomMatrix);
  dart.defineExtensionNames([
    'parseFromString'
  ]);
  html$.DomParser = class DomParser extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return html$.DomParser._create_1();
    }
    static _create_1() {
      return new DOMParser();
    }
    [dartx.parseFromString](str, type) {
      return this.parseFromString(str, type);
    }
  };
  dart.setSignature(html$.DomParser, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.DomParser, []),
      new: dart.definiteFunctionType(html$.DomParser, [])
    }),
    methods: () => ({[dartx.parseFromString]: dart.definiteFunctionType(html$.Document, [core.String, core.String])}),
    statics: () => ({_create_1: dart.definiteFunctionType(html$.DomParser, [])}),
    names: ['_create_1']
  });
  dart.registerExtension(dart.global.DOMParser, html$.DomParser);
  dart.defineExtensionNames([
    'w',
    'x',
    'y',
    'z'
  ]);
  html$.DomPointReadOnly = class DomPointReadOnly extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(x, y, z, w) {
      return html$.DomPointReadOnly._create_1(x, y, z, w);
    }
    static _create_1(x, y, z, w) {
      return new DOMPointReadOnly(x, y, z, w);
    }
    get [dartx.w]() {
      return this.w;
    }
    get [dartx.x]() {
      return this.x;
    }
    get [dartx.y]() {
      return this.y;
    }
    get [dartx.z]() {
      return this.z;
    }
  };
  dart.setSignature(html$.DomPointReadOnly, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.DomPointReadOnly, []),
      new: dart.definiteFunctionType(html$.DomPointReadOnly, [core.num, core.num, core.num, core.num])
    }),
    statics: () => ({_create_1: dart.definiteFunctionType(html$.DomPointReadOnly, [dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic])}),
    names: ['_create_1']
  });
  dart.registerExtension(dart.global.DOMPointReadOnly, html$.DomPointReadOnly);
  dart.defineExtensionNames([
    'w',
    'w',
    'x',
    'x',
    'y',
    'y',
    'z',
    'z'
  ]);
  html$.DomPoint = class DomPoint extends html$.DomPointReadOnly {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(point_OR_x, y, z, w) {
      if (point_OR_x === void 0) point_OR_x = null;
      if (y === void 0) y = null;
      if (z === void 0) z = null;
      if (w === void 0) w = null;
      if ((core.Map.is(point_OR_x) || point_OR_x == null) && y == null && z == null && w == null) {
        let point_1 = html_common.convertDartToNative_Dictionary(core.Map._check(point_OR_x));
        return html$.DomPoint._create_1(point_1);
      }
      if (point_OR_x == null && y == null && z == null && w == null) {
        return html$.DomPoint._create_2();
      }
      if ((typeof point_OR_x == 'number' || point_OR_x == null) && y == null && z == null && w == null) {
        return html$.DomPoint._create_3(point_OR_x);
      }
      if ((typeof y == 'number' || y == null) && (typeof point_OR_x == 'number' || point_OR_x == null) && z == null && w == null) {
        return html$.DomPoint._create_4(point_OR_x, y);
      }
      if ((typeof z == 'number' || z == null) && (typeof y == 'number' || y == null) && (typeof point_OR_x == 'number' || point_OR_x == null) && w == null) {
        return html$.DomPoint._create_5(point_OR_x, y, z);
      }
      if ((typeof w == 'number' || w == null) && (typeof z == 'number' || z == null) && (typeof y == 'number' || y == null) && (typeof point_OR_x == 'number' || point_OR_x == null)) {
        return html$.DomPoint._create_6(point_OR_x, y, z, w);
      }
      dart.throw(new core.ArgumentError("Incorrect number or type of arguments"));
    }
    static _create_1(point_OR_x) {
      return new DOMPoint(point_OR_x);
    }
    static _create_2() {
      return new DOMPoint();
    }
    static _create_3(point_OR_x) {
      return new DOMPoint(point_OR_x);
    }
    static _create_4(point_OR_x, y) {
      return new DOMPoint(point_OR_x, y);
    }
    static _create_5(point_OR_x, y, z) {
      return new DOMPoint(point_OR_x, y, z);
    }
    static _create_6(point_OR_x, y, z, w) {
      return new DOMPoint(point_OR_x, y, z, w);
    }
    static get supported() {
      return !!window.DOMPoint || !!window.WebKitPoint;
    }
    get [dartx.w]() {
      return this.w;
    }
    set [dartx.w](value) {
      this.w = value;
    }
    get [dartx.x]() {
      return this.x;
    }
    set [dartx.x](value) {
      this.x = value;
    }
    get [dartx.y]() {
      return this.y;
    }
    set [dartx.y](value) {
      this.y = value;
    }
    get [dartx.z]() {
      return this.z;
    }
    set [dartx.z](value) {
      this.z = value;
    }
  };
  dart.setSignature(html$.DomPoint, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.DomPoint, []),
      new: dart.definiteFunctionType(html$.DomPoint, [], [dart.dynamic, core.num, core.num, core.num])
    }),
    statics: () => ({
      _create_1: dart.definiteFunctionType(html$.DomPoint, [dart.dynamic]),
      _create_2: dart.definiteFunctionType(html$.DomPoint, []),
      _create_3: dart.definiteFunctionType(html$.DomPoint, [dart.dynamic]),
      _create_4: dart.definiteFunctionType(html$.DomPoint, [dart.dynamic, dart.dynamic]),
      _create_5: dart.definiteFunctionType(html$.DomPoint, [dart.dynamic, dart.dynamic, dart.dynamic]),
      _create_6: dart.definiteFunctionType(html$.DomPoint, [dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic])
    }),
    names: ['_create_1', '_create_2', '_create_3', '_create_4', '_create_5', '_create_6']
  });
  dart.registerExtension(dart.global.DOMPoint, html$.DomPoint);
  dart.defineExtensionNames([
    'toString',
    '==',
    'hashCode',
    'intersection',
    'intersects',
    'boundingBox',
    'containsRectangle',
    'containsPoint',
    'topLeft',
    'topRight',
    'bottomRight',
    'bottomLeft',
    'bottom',
    'height',
    'left',
    'right',
    'top',
    'width',
    'x',
    'y'
  ]);
  html$.DomRectReadOnly = class DomRectReadOnly extends _interceptors.Interceptor {
    [dartx.toString]() {
      return dart.str`Rectangle (${this[dartx.left]}, ${this[dartx.top]}) ${this[dartx.width]} x ${this[dartx.height]}`;
    }
    [dartx['==']](other) {
      if (!RectangleOfnum().is(other)) return false;
      return dart.equals(this[dartx.left], dart.dload(other, 'left')) && dart.equals(this[dartx.top], dart.dload(other, 'top')) && dart.equals(this[dartx.width], dart.dload(other, 'width')) && dart.equals(this[dartx.height], dart.dload(other, 'height'));
    }
    get [dartx.hashCode]() {
      return html$._JenkinsSmiHash.hash4(dart.hashCode(this[dartx.left]), dart.hashCode(this[dartx.top]), dart.hashCode(this[dartx.width]), dart.hashCode(this[dartx.height]));
    }
    [dartx.intersection](other) {
      let x0 = math.max(core.num)(this[dartx.left], other[dartx.left]);
      let x1 = math.min(core.num)(dart.notNull(this[dartx.left]) + dart.notNull(this[dartx.width]), dart.notNull(other[dartx.left]) + dart.notNull(other[dartx.width]));
      if (dart.notNull(x0) <= dart.notNull(x1)) {
        let y0 = math.max(core.num)(this[dartx.top], other[dartx.top]);
        let y1 = math.min(core.num)(dart.notNull(this[dartx.top]) + dart.notNull(this[dartx.height]), dart.notNull(other[dartx.top]) + dart.notNull(other[dartx.height]));
        if (dart.notNull(y0) <= dart.notNull(y1)) {
          return new (RectangleOfnum())(x0, y0, dart.notNull(x1) - dart.notNull(x0), dart.notNull(y1) - dart.notNull(y0));
        }
      }
      return null;
    }
    [dartx.intersects](other) {
      return dart.notNull(this[dartx.left]) <= dart.notNull(other[dartx.left]) + dart.notNull(other[dartx.width]) && dart.notNull(other[dartx.left]) <= dart.notNull(this[dartx.left]) + dart.notNull(this[dartx.width]) && dart.notNull(this[dartx.top]) <= dart.notNull(other[dartx.top]) + dart.notNull(other[dartx.height]) && dart.notNull(other[dartx.top]) <= dart.notNull(this[dartx.top]) + dart.notNull(this[dartx.height]);
    }
    [dartx.boundingBox](other) {
      let right = math.max(core.num)(dart.notNull(this[dartx.left]) + dart.notNull(this[dartx.width]), dart.notNull(other[dartx.left]) + dart.notNull(other[dartx.width]));
      let bottom = math.max(core.num)(dart.notNull(this[dartx.top]) + dart.notNull(this[dartx.height]), dart.notNull(other[dartx.top]) + dart.notNull(other[dartx.height]));
      let left = math.min(core.num)(this[dartx.left], other[dartx.left]);
      let top = math.min(core.num)(this[dartx.top], other[dartx.top]);
      return new (RectangleOfnum())(left, top, dart.notNull(right) - dart.notNull(left), dart.notNull(bottom) - dart.notNull(top));
    }
    [dartx.containsRectangle](another) {
      return dart.notNull(this[dartx.left]) <= dart.notNull(another[dartx.left]) && dart.notNull(this[dartx.left]) + dart.notNull(this[dartx.width]) >= dart.notNull(another[dartx.left]) + dart.notNull(another[dartx.width]) && dart.notNull(this[dartx.top]) <= dart.notNull(another[dartx.top]) && dart.notNull(this[dartx.top]) + dart.notNull(this[dartx.height]) >= dart.notNull(another[dartx.top]) + dart.notNull(another[dartx.height]);
    }
    [dartx.containsPoint](another) {
      return dart.notNull(another.x) >= dart.notNull(this[dartx.left]) && dart.notNull(another.x) <= dart.notNull(this[dartx.left]) + dart.notNull(this[dartx.width]) && dart.notNull(another.y) >= dart.notNull(this[dartx.top]) && dart.notNull(another.y) <= dart.notNull(this[dartx.top]) + dart.notNull(this[dartx.height]);
    }
    get [dartx.topLeft]() {
      return new (PointOfnum())(this[dartx.left], this[dartx.top]);
    }
    get [dartx.topRight]() {
      return new (PointOfnum())(dart.notNull(this[dartx.left]) + dart.notNull(this[dartx.width]), this[dartx.top]);
    }
    get [dartx.bottomRight]() {
      return new (PointOfnum())(dart.notNull(this[dartx.left]) + dart.notNull(this[dartx.width]), dart.notNull(this[dartx.top]) + dart.notNull(this[dartx.height]));
    }
    get [dartx.bottomLeft]() {
      return new (PointOfnum())(this[dartx.left], dart.notNull(this[dartx.top]) + dart.notNull(this[dartx.height]));
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(x, y, width, height) {
      return html$.DomRectReadOnly._create_1(x, y, width, height);
    }
    static _create_1(x, y, width, height) {
      return new DOMRectReadOnly(x, y, width, height);
    }
    get [dartx.bottom]() {
      return this.bottom;
    }
    get [dartx.height]() {
      return this.height;
    }
    get [dartx.left]() {
      return this.left;
    }
    get [dartx.right]() {
      return this.right;
    }
    get [dartx.top]() {
      return this.top;
    }
    get [dartx.width]() {
      return this.width;
    }
    get [dartx.x]() {
      return this.x;
    }
    get [dartx.y]() {
      return this.y;
    }
  };
  html$.DomRectReadOnly[dart.implements] = () => [RectangleOfnum()];
  dart.setSignature(html$.DomRectReadOnly, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.DomRectReadOnly, []),
      new: dart.definiteFunctionType(html$.DomRectReadOnly, [core.num, core.num, core.num, core.num])
    }),
    methods: () => ({
      [dartx.intersection]: dart.definiteFunctionType(math.Rectangle$(core.num), [math.Rectangle$(core.num)]),
      [dartx.intersects]: dart.definiteFunctionType(core.bool, [math.Rectangle$(core.num)]),
      [dartx.boundingBox]: dart.definiteFunctionType(math.Rectangle$(core.num), [math.Rectangle$(core.num)]),
      [dartx.containsRectangle]: dart.definiteFunctionType(core.bool, [math.Rectangle$(core.num)]),
      [dartx.containsPoint]: dart.definiteFunctionType(core.bool, [math.Point$(core.num)])
    }),
    statics: () => ({_create_1: dart.definiteFunctionType(html$.DomRectReadOnly, [dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic])}),
    names: ['_create_1']
  });
  dart.registerExtension(dart.global.DOMRectReadOnly, html$.DomRectReadOnly);
  dart.defineExtensionNames([
    'add',
    'contains',
    'item',
    'remove',
    'toggle',
    'length'
  ]);
  html$.DomTokenList = class DomTokenList extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.length]() {
      return this.length;
    }
    [dartx.add](tokens) {
      return this.add(tokens);
    }
    [dartx.contains](token) {
      return this.contains(token);
    }
    [dartx.item](index) {
      return this.item(index);
    }
    [dartx.remove](tokens) {
      return this.remove(tokens);
    }
    [dartx.toggle](token, force) {
      return this.toggle(token, force);
    }
  };
  dart.setSignature(html$.DomTokenList, {
    constructors: () => ({_: dart.definiteFunctionType(html$.DomTokenList, [])}),
    methods: () => ({
      [dartx.add]: dart.definiteFunctionType(dart.void, [core.String]),
      [dartx.contains]: dart.definiteFunctionType(core.bool, [core.String]),
      [dartx.item]: dart.definiteFunctionType(core.String, [core.int]),
      [dartx.remove]: dart.definiteFunctionType(dart.void, [core.String]),
      [dartx.toggle]: dart.definiteFunctionType(core.bool, [core.String], [core.bool])
    })
  });
  dart.registerExtension(dart.global.DOMTokenList, html$.DomTokenList);
  dart.defineExtensionNames([
    'value'
  ]);
  html$.DomSettableTokenList = class DomSettableTokenList extends html$.DomTokenList {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.value]() {
      return this.value;
    }
    set [dartx.value](value) {
      this.value = value;
    }
  };
  dart.setSignature(html$.DomSettableTokenList, {
    constructors: () => ({_: dart.definiteFunctionType(html$.DomSettableTokenList, [])})
  });
  dart.registerExtension(dart.global.DOMSettableTokenList, html$.DomSettableTokenList);
  html$.ImmutableListMixin$ = dart.generic(E => {
    let FixedSizeListIteratorOfE = () => (FixedSizeListIteratorOfE = dart.constFn(html$.FixedSizeListIterator$(E)))();
    let IterableOfE = () => (IterableOfE = dart.constFn(core.Iterable$(E)))();
    let ListOfE = () => (ListOfE = dart.constFn(core.List$(E)))();
    dart.defineExtensionNames([
      'iterator',
      'add',
      'addAll',
      'sort',
      'shuffle',
      'insert',
      'insertAll',
      'setAll',
      'removeAt',
      'removeLast',
      'remove',
      'removeWhere',
      'retainWhere',
      'setRange',
      'removeRange',
      'replaceRange',
      'fillRange'
    ]);
    class ImmutableListMixin extends core.Object {
      get iterator() {
        return new (FixedSizeListIteratorOfE())(this);
      }
      [Symbol.iterator]() {
        return new dart.JsIterator(this[dartx.iterator]);
      }
      add(value) {
        E._check(value);
        dart.throw(new core.UnsupportedError("Cannot add to immutable List."));
      }
      addAll(iterable) {
        IterableOfE()._check(iterable);
        dart.throw(new core.UnsupportedError("Cannot add to immutable List."));
      }
      sort(compare) {
        if (compare === void 0) compare = null;
        dart.throw(new core.UnsupportedError("Cannot sort immutable List."));
      }
      shuffle(random) {
        if (random === void 0) random = null;
        dart.throw(new core.UnsupportedError("Cannot shuffle immutable List."));
      }
      insert(index, element) {
        E._check(element);
        dart.throw(new core.UnsupportedError("Cannot add to immutable List."));
      }
      insertAll(index, iterable) {
        IterableOfE()._check(iterable);
        dart.throw(new core.UnsupportedError("Cannot add to immutable List."));
      }
      setAll(index, iterable) {
        IterableOfE()._check(iterable);
        dart.throw(new core.UnsupportedError("Cannot modify an immutable List."));
      }
      removeAt(pos) {
        dart.throw(new core.UnsupportedError("Cannot remove from immutable List."));
      }
      removeLast() {
        dart.throw(new core.UnsupportedError("Cannot remove from immutable List."));
      }
      remove(object) {
        dart.throw(new core.UnsupportedError("Cannot remove from immutable List."));
      }
      removeWhere(test) {
        dart.throw(new core.UnsupportedError("Cannot remove from immutable List."));
      }
      retainWhere(test) {
        dart.throw(new core.UnsupportedError("Cannot remove from immutable List."));
      }
      setRange(start, end, iterable, skipCount) {
        IterableOfE()._check(iterable);
        if (skipCount === void 0) skipCount = 0;
        dart.throw(new core.UnsupportedError("Cannot setRange on immutable List."));
      }
      removeRange(start, end) {
        dart.throw(new core.UnsupportedError("Cannot removeRange on immutable List."));
      }
      replaceRange(start, end, iterable) {
        IterableOfE()._check(iterable);
        dart.throw(new core.UnsupportedError("Cannot modify an immutable List."));
      }
      fillRange(start, end, fillValue) {
        if (fillValue === void 0) fillValue = null;
        E._check(fillValue);
        dart.throw(new core.UnsupportedError("Cannot modify an immutable List."));
      }
    }
    dart.addTypeTests(ImmutableListMixin);
    ImmutableListMixin[dart.implements] = () => [ListOfE()];
    dart.setSignature(ImmutableListMixin, {
      methods: () => ({
        add: dart.definiteFunctionType(dart.void, [E]),
        addAll: dart.definiteFunctionType(dart.void, [core.Iterable$(E)]),
        sort: dart.definiteFunctionType(dart.void, [], [dart.functionType(core.int, [E, E])]),
        shuffle: dart.definiteFunctionType(dart.void, [], [math.Random]),
        insert: dart.definiteFunctionType(dart.void, [core.int, E]),
        insertAll: dart.definiteFunctionType(dart.void, [core.int, core.Iterable$(E)]),
        setAll: dart.definiteFunctionType(dart.void, [core.int, core.Iterable$(E)]),
        removeAt: dart.definiteFunctionType(E, [core.int]),
        removeLast: dart.definiteFunctionType(E, []),
        remove: dart.definiteFunctionType(core.bool, [core.Object]),
        removeWhere: dart.definiteFunctionType(dart.void, [dart.functionType(core.bool, [E])]),
        retainWhere: dart.definiteFunctionType(dart.void, [dart.functionType(core.bool, [E])]),
        setRange: dart.definiteFunctionType(dart.void, [core.int, core.int, core.Iterable$(E)], [core.int]),
        removeRange: dart.definiteFunctionType(dart.void, [core.int, core.int]),
        replaceRange: dart.definiteFunctionType(dart.void, [core.int, core.int, core.Iterable$(E)]),
        fillRange: dart.definiteFunctionType(dart.void, [core.int, core.int], [E])
      })
    });
    dart.defineExtensionMembers(ImmutableListMixin, [
      'add',
      'addAll',
      'sort',
      'shuffle',
      'insert',
      'insertAll',
      'setAll',
      'removeAt',
      'removeLast',
      'remove',
      'removeWhere',
      'retainWhere',
      'setRange',
      'removeRange',
      'replaceRange',
      'fillRange',
      'iterator'
    ]);
    return ImmutableListMixin;
  });
  html$.ImmutableListMixin = ImmutableListMixin();
  dart.defineExtensionNames([
    'length',
    'get',
    'set',
    'length',
    'first',
    'last',
    'single',
    'elementAt',
    'item'
  ]);
  html$.DomStringList = class DomStringList extends dart.mixin(_interceptors.Interceptor, collection.ListMixin$(core.String), html$.ImmutableListMixin$(core.String)) {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.length]() {
      return this.length;
    }
    [dartx.get](index) {
      if (index >>> 0 !== index || index >= this[dartx.length]) dart.throw(core.RangeError.index(index, this));
      return this[dartx.item](index);
    }
    [dartx.set](index, value) {
      dart.throw(new core.UnsupportedError("Cannot assign element of immutable List."));
      return value;
    }
    set [dartx.length](value) {
      dart.throw(new core.UnsupportedError("Cannot resize immutable List."));
    }
    get [dartx.first]() {
      if (dart.notNull(this[dartx.length]) > 0) {
        return this[0];
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.last]() {
      let len = this[dartx.length];
      if (dart.notNull(len) > 0) {
        return this[dart.notNull(len) - 1];
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.single]() {
      let len = this[dartx.length];
      if (len == 1) {
        return this[0];
      }
      if (len == 0) dart.throw(new core.StateError("No elements"));
      dart.throw(new core.StateError("More than one element"));
    }
    [dartx.elementAt](index) {
      return this[dartx.get](index);
    }
    [__getter__](index) {
      return this.__getter__(index);
    }
    [dartx.item](index) {
      return this.item(index);
    }
  };
  html$.DomStringList[dart.implements] = () => [ListOfString()];
  dart.setSignature(html$.DomStringList, {
    constructors: () => ({_: dart.definiteFunctionType(html$.DomStringList, [])}),
    methods: () => ({
      [dartx.get]: dart.definiteFunctionType(core.String, [core.int]),
      [dartx.set]: dart.definiteFunctionType(dart.void, [core.int, core.String]),
      [dartx.elementAt]: dart.definiteFunctionType(core.String, [core.int]),
      [__getter__]: dart.definiteFunctionType(core.String, [core.int]),
      [dartx.item]: dart.definiteFunctionType(core.String, [core.int])
    })
  });
  dart.registerExtension(dart.global.DOMStringList, html$.DomStringList);
  html$.DomStringMap = class DomStringMap extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(html$.DomStringMap, {
    constructors: () => ({_: dart.definiteFunctionType(html$.DomStringMap, [])})
  });
  html$.EffectModel = class EffectModel extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(html$.EffectModel, {
    constructors: () => ({_: dart.definiteFunctionType(html$.EffectModel, [])})
  });
  dart.registerExtension(dart.global.EffectModel, html$.EffectModel);
  const _childElements = Symbol('_childElements');
  const _element$ = Symbol('_element');
  const _filter$ = Symbol('_filter');
  html$._ChildrenElementList = class _ChildrenElementList extends collection.ListBase$(html$.Element) {
    _wrap(element) {
      this[_childElements] = html$.HtmlCollection._check(element[_children]);
      this[_element$] = element;
    }
    contains(element) {
      return this[_childElements][dartx.contains](element);
    }
    get isEmpty() {
      return this[_element$][_firstElementChild] == null;
    }
    get length() {
      return this[_childElements][dartx.length];
    }
    get(index) {
      return html$.Element._check(this[_childElements][dartx.get](index));
    }
    set(index, value) {
      this[_element$][_replaceChild](value, this[_childElements][dartx.get](index));
      return value;
    }
    set length(newLength) {
      dart.throw(new core.UnsupportedError('Cannot resize element lists'));
    }
    add(value) {
      this[_element$][dartx.append](value);
      return value;
    }
    get iterator() {
      return this[dartx.toList]()[dartx.iterator];
    }
    addAll(iterable) {
      if (html$._ChildNodeListLazy.is(iterable)) {
        iterable = ListOfElement().from(iterable);
      }
      for (let element of iterable) {
        this[_element$][dartx.append](element);
      }
    }
    sort(compare) {
      if (compare === void 0) compare = null;
      dart.throw(new core.UnsupportedError('Cannot sort element lists'));
    }
    shuffle(random) {
      if (random === void 0) random = null;
      dart.throw(new core.UnsupportedError('Cannot shuffle element lists'));
    }
    removeWhere(test) {
      this[_filter$](test, false);
    }
    retainWhere(test) {
      this[_filter$](test, true);
    }
    [_filter$](test, retainMatching) {
      let removed = null;
      if (dart.test(retainMatching)) {
        removed = this[_element$][dartx.children][dartx.where](dart.fn(e => !dart.test(test(e)), ElementTobool()));
      } else {
        removed = this[_element$][dartx.children][dartx.where](test);
      }
      for (let e of core.Iterable._check(removed))
        dart.dsend(e, 'remove');
    }
    setRange(start, end, iterable, skipCount) {
      if (skipCount === void 0) skipCount = 0;
      dart.throw(new core.UnimplementedError());
    }
    replaceRange(start, end, iterable) {
      dart.throw(new core.UnimplementedError());
    }
    fillRange(start, end, fillValue) {
      if (fillValue === void 0) fillValue = null;
      dart.throw(new core.UnimplementedError());
    }
    remove(object) {
      if (html$.Element.is(object)) {
        let element = object;
        if (core.identical(element[dartx.parentNode], this[_element$])) {
          this[_element$][_removeChild](element);
          return true;
        }
      }
      return false;
    }
    insert(index, element) {
      if (dart.notNull(index) < 0 || dart.notNull(index) > dart.notNull(this.length)) {
        dart.throw(new core.RangeError.range(index, 0, this.length));
      }
      if (index == this.length) {
        this[_element$][dartx.append](element);
      } else {
        this[_element$][dartx.insertBefore](element, this.get(index));
      }
    }
    setAll(index, iterable) {
      dart.throw(new core.UnimplementedError());
    }
    clear() {
      this[_element$][_clearChildren]();
    }
    removeAt(index) {
      let result = this.get(index);
      if (result != null) {
        this[_element$][_removeChild](result);
      }
      return result;
    }
    removeLast() {
      let result = this.last;
      if (result != null) {
        this[_element$][_removeChild](result);
      }
      return result;
    }
    get first() {
      let result = this[_element$][_firstElementChild];
      if (result == null) dart.throw(new core.StateError("No elements"));
      return result;
    }
    get last() {
      let result = this[_element$][_lastElementChild];
      if (result == null) dart.throw(new core.StateError("No elements"));
      return result;
    }
    get single() {
      if (dart.notNull(this.length) > 1) dart.throw(new core.StateError("More than one element"));
      return this.first;
    }
    get rawList() {
      return this[_childElements];
    }
  };
  dart.addSimpleTypeTests(html$._ChildrenElementList);
  dart.defineNamedConstructor(html$._ChildrenElementList, '_wrap');
  html$._ChildrenElementList[dart.implements] = () => [html_common.NodeListWrapper];
  dart.setSignature(html$._ChildrenElementList, {
    constructors: () => ({_wrap: dart.definiteFunctionType(html$._ChildrenElementList, [html$.Element])}),
    methods: () => ({
      get: dart.definiteFunctionType(html$.Element, [core.int]),
      set: dart.definiteFunctionType(dart.void, [core.int, html$.Element]),
      add: dart.definiteFunctionType(html$.Element, [html$.Element]),
      addAll: dart.definiteFunctionType(dart.void, [core.Iterable$(html$.Element)]),
      sort: dart.definiteFunctionType(dart.void, [], [dart.functionType(core.int, [html$.Element, html$.Element])]),
      removeWhere: dart.definiteFunctionType(dart.void, [dart.functionType(core.bool, [html$.Element])]),
      retainWhere: dart.definiteFunctionType(dart.void, [dart.functionType(core.bool, [html$.Element])]),
      [_filter$]: dart.definiteFunctionType(dart.void, [dart.functionType(core.bool, [html$.Element]), core.bool]),
      setRange: dart.definiteFunctionType(dart.void, [core.int, core.int, core.Iterable$(html$.Element)], [core.int]),
      replaceRange: dart.definiteFunctionType(dart.void, [core.int, core.int, core.Iterable$(html$.Element)]),
      fillRange: dart.definiteFunctionType(dart.void, [core.int, core.int], [html$.Element]),
      insert: dart.definiteFunctionType(dart.void, [core.int, html$.Element]),
      setAll: dart.definiteFunctionType(dart.void, [core.int, core.Iterable$(html$.Element)]),
      removeAt: dart.definiteFunctionType(html$.Element, [core.int]),
      removeLast: dart.definiteFunctionType(html$.Element, [])
    })
  });
  dart.defineExtensionMembers(html$._ChildrenElementList, [
    'contains',
    'get',
    'set',
    'add',
    'addAll',
    'sort',
    'shuffle',
    'removeWhere',
    'retainWhere',
    'setRange',
    'replaceRange',
    'fillRange',
    'remove',
    'insert',
    'setAll',
    'clear',
    'removeAt',
    'removeLast',
    'isEmpty',
    'length',
    'length',
    'iterator',
    'first',
    'last',
    'single'
  ]);
  html$.ElementList$ = dart.generic(T => {
    class ElementList extends collection.ListBase$(T) {}
    return ElementList;
  });
  html$.ElementList = ElementList();
  const _nodeList = Symbol('_nodeList');
  const _forElementList = Symbol('_forElementList');
  html$._FrozenElementList$ = dart.generic(E => {
    let ElementListOfE = () => (ElementListOfE = dart.constFn(html$.ElementList$(E)))();
    let EToIterableOfString = () => (EToIterableOfString = dart.constFn(dart.definiteFunctionType(IterableOfString(), [E])))();
    class _FrozenElementList extends collection.ListBase$(E) {
      _wrap(nodeList) {
        this[_nodeList] = nodeList;
      }
      get length() {
        return this[_nodeList][dartx.length];
      }
      get(index) {
        return html$._downcast(html$.Node, E)(this[_nodeList][dartx.get](index));
      }
      set(index, value) {
        E._check(value);
        dart.throw(new core.UnsupportedError('Cannot modify list'));
        return value;
      }
      set length(newLength) {
        dart.throw(new core.UnsupportedError('Cannot modify list'));
      }
      sort(compare) {
        if (compare === void 0) compare = null;
        dart.throw(new core.UnsupportedError('Cannot sort list'));
      }
      shuffle(random) {
        if (random === void 0) random = null;
        dart.throw(new core.UnsupportedError('Cannot shuffle list'));
      }
      get first() {
        return html$._downcast(html$.Node, E)(this[_nodeList][dartx.first]);
      }
      get last() {
        return html$._downcast(html$.Node, E)(this[_nodeList][dartx.last]);
      }
      get single() {
        return html$._downcast(html$.Node, E)(this[_nodeList][dartx.single]);
      }
      get classes() {
        return html$._MultiElementCssClassSet.new(this);
      }
      get style() {
        return new html$._CssStyleDeclarationSet(this);
      }
      set classes(value) {
        this[dartx.forEach](dart.fn(e => e[dartx.classes] = value, EToIterableOfString()));
      }
      get contentEdge() {
        return new html$._ContentCssListRect(this);
      }
      get paddingEdge() {
        return this.first[dartx.paddingEdge];
      }
      get borderEdge() {
        return this.first[dartx.borderEdge];
      }
      get marginEdge() {
        return this.first[dartx.marginEdge];
      }
      get rawList() {
        return this[_nodeList];
      }
      get onAbort() {
        return html$.Element.abortEvent[_forElementList](this);
      }
      get onBeforeCopy() {
        return html$.Element.beforeCopyEvent[_forElementList](this);
      }
      get onBeforeCut() {
        return html$.Element.beforeCutEvent[_forElementList](this);
      }
      get onBeforePaste() {
        return html$.Element.beforePasteEvent[_forElementList](this);
      }
      get onBlur() {
        return html$.Element.blurEvent[_forElementList](this);
      }
      get onCanPlay() {
        return html$.Element.canPlayEvent[_forElementList](this);
      }
      get onCanPlayThrough() {
        return html$.Element.canPlayThroughEvent[_forElementList](this);
      }
      get onChange() {
        return html$.Element.changeEvent[_forElementList](this);
      }
      get onClick() {
        return html$.Element.clickEvent[_forElementList](this);
      }
      get onContextMenu() {
        return html$.Element.contextMenuEvent[_forElementList](this);
      }
      get onCopy() {
        return html$.Element.copyEvent[_forElementList](this);
      }
      get onCut() {
        return html$.Element.cutEvent[_forElementList](this);
      }
      get onDoubleClick() {
        return html$.Element.doubleClickEvent[_forElementList](this);
      }
      get onDrag() {
        return html$.Element.dragEvent[_forElementList](this);
      }
      get onDragEnd() {
        return html$.Element.dragEndEvent[_forElementList](this);
      }
      get onDragEnter() {
        return html$.Element.dragEnterEvent[_forElementList](this);
      }
      get onDragLeave() {
        return html$.Element.dragLeaveEvent[_forElementList](this);
      }
      get onDragOver() {
        return html$.Element.dragOverEvent[_forElementList](this);
      }
      get onDragStart() {
        return html$.Element.dragStartEvent[_forElementList](this);
      }
      get onDrop() {
        return html$.Element.dropEvent[_forElementList](this);
      }
      get onDurationChange() {
        return html$.Element.durationChangeEvent[_forElementList](this);
      }
      get onEmptied() {
        return html$.Element.emptiedEvent[_forElementList](this);
      }
      get onEnded() {
        return html$.Element.endedEvent[_forElementList](this);
      }
      get onError() {
        return html$.Element.errorEvent[_forElementList](this);
      }
      get onFocus() {
        return html$.Element.focusEvent[_forElementList](this);
      }
      get onInput() {
        return html$.Element.inputEvent[_forElementList](this);
      }
      get onInvalid() {
        return html$.Element.invalidEvent[_forElementList](this);
      }
      get onKeyDown() {
        return html$.Element.keyDownEvent[_forElementList](this);
      }
      get onKeyPress() {
        return html$.Element.keyPressEvent[_forElementList](this);
      }
      get onKeyUp() {
        return html$.Element.keyUpEvent[_forElementList](this);
      }
      get onLoad() {
        return html$.Element.loadEvent[_forElementList](this);
      }
      get onLoadedData() {
        return html$.Element.loadedDataEvent[_forElementList](this);
      }
      get onLoadedMetadata() {
        return html$.Element.loadedMetadataEvent[_forElementList](this);
      }
      get onMouseDown() {
        return html$.Element.mouseDownEvent[_forElementList](this);
      }
      get onMouseEnter() {
        return html$.Element.mouseEnterEvent[_forElementList](this);
      }
      get onMouseLeave() {
        return html$.Element.mouseLeaveEvent[_forElementList](this);
      }
      get onMouseMove() {
        return html$.Element.mouseMoveEvent[_forElementList](this);
      }
      get onMouseOut() {
        return html$.Element.mouseOutEvent[_forElementList](this);
      }
      get onMouseOver() {
        return html$.Element.mouseOverEvent[_forElementList](this);
      }
      get onMouseUp() {
        return html$.Element.mouseUpEvent[_forElementList](this);
      }
      get onMouseWheel() {
        return html$.Element.mouseWheelEvent[_forElementList](this);
      }
      get onPaste() {
        return html$.Element.pasteEvent[_forElementList](this);
      }
      get onPause() {
        return html$.Element.pauseEvent[_forElementList](this);
      }
      get onPlay() {
        return html$.Element.playEvent[_forElementList](this);
      }
      get onPlaying() {
        return html$.Element.playingEvent[_forElementList](this);
      }
      get onRateChange() {
        return html$.Element.rateChangeEvent[_forElementList](this);
      }
      get onReset() {
        return html$.Element.resetEvent[_forElementList](this);
      }
      get onResize() {
        return html$.Element.resizeEvent[_forElementList](this);
      }
      get onScroll() {
        return html$.Element.scrollEvent[_forElementList](this);
      }
      get onSearch() {
        return html$.Element.searchEvent[_forElementList](this);
      }
      get onSeeked() {
        return html$.Element.seekedEvent[_forElementList](this);
      }
      get onSeeking() {
        return html$.Element.seekingEvent[_forElementList](this);
      }
      get onSelect() {
        return html$.Element.selectEvent[_forElementList](this);
      }
      get onSelectStart() {
        return html$.Element.selectStartEvent[_forElementList](this);
      }
      get onStalled() {
        return html$.Element.stalledEvent[_forElementList](this);
      }
      get onSubmit() {
        return html$.Element.submitEvent[_forElementList](this);
      }
      get onSuspend() {
        return html$.Element.suspendEvent[_forElementList](this);
      }
      get onTimeUpdate() {
        return html$.Element.timeUpdateEvent[_forElementList](this);
      }
      get onTouchCancel() {
        return html$.Element.touchCancelEvent[_forElementList](this);
      }
      get onTouchEnd() {
        return html$.Element.touchEndEvent[_forElementList](this);
      }
      get onTouchEnter() {
        return html$.Element.touchEnterEvent[_forElementList](this);
      }
      get onTouchLeave() {
        return html$.Element.touchLeaveEvent[_forElementList](this);
      }
      get onTouchMove() {
        return html$.Element.touchMoveEvent[_forElementList](this);
      }
      get onTouchStart() {
        return html$.Element.touchStartEvent[_forElementList](this);
      }
      get onTransitionEnd() {
        return html$.Element.transitionEndEvent[_forElementList](this);
      }
      get onVolumeChange() {
        return html$.Element.volumeChangeEvent[_forElementList](this);
      }
      get onWaiting() {
        return html$.Element.waitingEvent[_forElementList](this);
      }
      get onFullscreenChange() {
        return html$.Element.fullscreenChangeEvent[_forElementList](this);
      }
      get onFullscreenError() {
        return html$.Element.fullscreenErrorEvent[_forElementList](this);
      }
    }
    dart.defineNamedConstructor(_FrozenElementList, '_wrap');
    _FrozenElementList[dart.implements] = () => [ElementListOfE(), html_common.NodeListWrapper];
    dart.setSignature(_FrozenElementList, {
      constructors: () => ({_wrap: dart.definiteFunctionType(html$._FrozenElementList$(E), [core.List$(html$.Node)])}),
      methods: () => ({
        get: dart.definiteFunctionType(E, [core.int]),
        set: dart.definiteFunctionType(dart.void, [core.int, E]),
        sort: dart.definiteFunctionType(dart.void, [], [core.Comparator$(E)])
      })
    });
    dart.defineExtensionMembers(_FrozenElementList, [
      'get',
      'set',
      'sort',
      'shuffle',
      'length',
      'length',
      'first',
      'last',
      'single'
    ]);
    return _FrozenElementList;
  });
  html$._FrozenElementList = _FrozenElementList();
  html$._ElementFactoryProvider = class _ElementFactoryProvider extends core.Object {
    static createElement_tag(tag, typeExtension) {
      if (typeExtension != null) {
        return document.createElement(tag, typeExtension);
      }
      return document.createElement(tag);
    }
  };
  dart.setSignature(html$._ElementFactoryProvider, {
    statics: () => ({createElement_tag: dart.definiteFunctionType(dart.dynamic, [core.String, core.String])}),
    names: ['createElement_tag']
  });
  const _value$0 = Symbol('_value');
  html$.ScrollAlignment = class ScrollAlignment extends core.Object {
    _internal(value) {
      this[_value$0] = value;
    }
    toString() {
      return dart.str`ScrollAlignment.${this[_value$0]}`;
    }
  };
  dart.defineNamedConstructor(html$.ScrollAlignment, '_internal');
  dart.setSignature(html$.ScrollAlignment, {
    constructors: () => ({_internal: dart.definiteFunctionType(html$.ScrollAlignment, [dart.dynamic])})
  });
  dart.defineLazy(html$.ScrollAlignment, {
    get TOP() {
      return dart.const(new html$.ScrollAlignment._internal('TOP'));
    },
    get CENTER() {
      return dart.const(new html$.ScrollAlignment._internal('CENTER'));
    },
    get BOTTOM() {
      return dart.const(new html$.ScrollAlignment._internal('BOTTOM'));
    }
  });
  const __setter__ = Symbol('__setter__');
  dart.defineExtensionNames([
    'height',
    'name',
    'src',
    'type',
    'width'
  ]);
  html$.EmbedElement = class EmbedElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return html$.EmbedElement._check(html$.document[dartx.createElement]("embed"));
    }
    created() {
      this[dartx.height] = null;
      this[dartx.name] = null;
      this[dartx.src] = null;
      this[dartx.type] = null;
      this[dartx.width] = null;
      super.created();
    }
    static get supported() {
      return html$.Element.isTagSupported('embed');
    }
    get [dartx.height]() {
      return this.height;
    }
    set [dartx.height](value) {
      this.height = value;
    }
    get [dartx.name]() {
      return this.name;
    }
    set [dartx.name](value) {
      this.name = value;
    }
    get [dartx.src]() {
      return this.src;
    }
    set [dartx.src](value) {
      this.src = value;
    }
    get [dartx.type]() {
      return this.type;
    }
    set [dartx.type](value) {
      this.type = value;
    }
    get [dartx.width]() {
      return this.width;
    }
    set [dartx.width](value) {
      this.width = value;
    }
    [__getter__](index_OR_name) {
      return this.__getter__(index_OR_name);
    }
    [__setter__](index_OR_name, value) {
      return this.__setter__(index_OR_name, value);
    }
  };
  dart.defineNamedConstructor(html$.EmbedElement, 'created');
  dart.setSignature(html$.EmbedElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.EmbedElement, []),
      new: dart.definiteFunctionType(html$.EmbedElement, []),
      created: dart.definiteFunctionType(html$.EmbedElement, [])
    }),
    methods: () => ({
      [__getter__]: dart.definiteFunctionType(core.bool, [dart.dynamic]),
      [__setter__]: dart.definiteFunctionType(dart.void, [dart.dynamic, html$.Node])
    })
  });
  dart.registerExtension(dart.global.HTMLEmbedElement, html$.EmbedElement);
  html$._EntriesCallback = dart.typedef('_EntriesCallback', () => dart.functionType(dart.void, [core.List$(html$.Entry)]));
  html$._EntryCallback = dart.typedef('_EntryCallback', () => dart.functionType(dart.void, [html$.Entry]));
  html$._ErrorCallback = dart.typedef('_ErrorCallback', () => dart.functionType(dart.void, [html$.FileError]));
  dart.defineExtensionNames([
    'colno',
    'error',
    'filename',
    'lineno',
    'message'
  ]);
  html$.ErrorEvent = class ErrorEvent extends html$.Event {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(type, eventInitDict) {
      if (eventInitDict === void 0) eventInitDict = null;
      if (eventInitDict != null) {
        let eventInitDict_1 = html_common.convertDartToNative_Dictionary(eventInitDict);
        return html$.ErrorEvent._create_1(type, eventInitDict_1);
      }
      return html$.ErrorEvent._create_2(type);
    }
    static _create_1(type, eventInitDict) {
      return new ErrorEvent(type, eventInitDict);
    }
    static _create_2(type) {
      return new ErrorEvent(type);
    }
    get [dartx.colno]() {
      return this.colno;
    }
    get [dartx.error]() {
      return this.error;
    }
    get [dartx.filename]() {
      return this.filename;
    }
    get [dartx.lineno]() {
      return this.lineno;
    }
    get [dartx.message]() {
      return this.message;
    }
  };
  dart.setSignature(html$.ErrorEvent, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.ErrorEvent, []),
      new: dart.definiteFunctionType(html$.ErrorEvent, [core.String], [core.Map])
    }),
    statics: () => ({
      _create_1: dart.definiteFunctionType(html$.ErrorEvent, [dart.dynamic, dart.dynamic]),
      _create_2: dart.definiteFunctionType(html$.ErrorEvent, [dart.dynamic])
    }),
    names: ['_create_1', '_create_2']
  });
  dart.registerExtension(dart.global.ErrorEvent, html$.ErrorEvent);
  dart.defineExtensionNames([
    'close',
    'onError',
    'onMessage',
    'onOpen',
    'readyState',
    'url',
    'withCredentials'
  ]);
  html$.EventSource = class EventSource extends html$.EventTarget {
    static new(url, opts) {
      let withCredentials = opts && 'withCredentials' in opts ? opts.withCredentials : false;
      let parsedOptions = dart.map({withCredentials: withCredentials});
      return html$.EventSource._factoryEventSource(url, parsedOptions);
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static _factoryEventSource(url, eventSourceInitDict) {
      if (eventSourceInitDict === void 0) eventSourceInitDict = null;
      if (eventSourceInitDict != null) {
        let eventSourceInitDict_1 = html_common.convertDartToNative_Dictionary(eventSourceInitDict);
        return html$.EventSource._create_1(url, eventSourceInitDict_1);
      }
      return html$.EventSource._create_2(url);
    }
    static _create_1(url, eventSourceInitDict) {
      return new EventSource(url, eventSourceInitDict);
    }
    static _create_2(url) {
      return new EventSource(url);
    }
    get [dartx.readyState]() {
      return this.readyState;
    }
    get [dartx.url]() {
      return this.url;
    }
    get [dartx.withCredentials]() {
      return this.withCredentials;
    }
    [dartx.close]() {
      return this.close();
    }
    get [dartx.onError]() {
      return html$.EventSource.errorEvent.forTarget(this);
    }
    get [dartx.onMessage]() {
      return html$.EventSource.messageEvent.forTarget(this);
    }
    get [dartx.onOpen]() {
      return html$.EventSource.openEvent.forTarget(this);
    }
  };
  dart.setSignature(html$.EventSource, {
    constructors: () => ({
      new: dart.definiteFunctionType(html$.EventSource, [core.String], {withCredentials: dart.dynamic}),
      _: dart.definiteFunctionType(html$.EventSource, [])
    }),
    methods: () => ({[dartx.close]: dart.definiteFunctionType(dart.void, [])}),
    statics: () => ({
      _factoryEventSource: dart.definiteFunctionType(html$.EventSource, [core.String], [core.Map]),
      _create_1: dart.definiteFunctionType(html$.EventSource, [dart.dynamic, dart.dynamic]),
      _create_2: dart.definiteFunctionType(html$.EventSource, [dart.dynamic])
    }),
    names: ['_factoryEventSource', '_create_1', '_create_2']
  });
  html$.EventSource.CLOSED = 2;
  html$.EventSource.CONNECTING = 0;
  html$.EventSource.OPEN = 1;
  dart.defineLazy(html$.EventSource, {
    get errorEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('error'));
    },
    get messageEvent() {
      return dart.const(new (EventStreamProviderOfMessageEvent())('message'));
    },
    get openEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('open'));
    }
  });
  dart.registerExtension(dart.global.EventSource, html$.EventSource);
  const _ptr = Symbol('_ptr');
  html$.Events = class Events extends core.Object {
    new(ptr) {
      this[_ptr] = ptr;
    }
    get(type) {
      return new (_EventStreamOfEvent())(this[_ptr], type, false);
    }
  };
  dart.setSignature(html$.Events, {
    constructors: () => ({new: dart.definiteFunctionType(html$.Events, [html$.EventTarget])}),
    methods: () => ({get: dart.definiteFunctionType(async.Stream, [core.String])})
  });
  html$.ElementEvents = class ElementEvents extends html$.Events {
    new(ptr) {
      super.new(ptr);
    }
    get(type) {
      if (dart.test(html$.ElementEvents.webkitEvents[dartx.keys][dartx.contains](type[dartx.toLowerCase]()))) {
        if (dart.test(html_common.Device.isWebKit)) {
          return new (_ElementEventStreamImplOfEvent())(this[_ptr], html$.ElementEvents.webkitEvents[dartx.get](type[dartx.toLowerCase]()), false);
        }
      }
      return new (_ElementEventStreamImplOfEvent())(this[_ptr], type, false);
    }
  };
  dart.setSignature(html$.ElementEvents, {
    constructors: () => ({new: dart.definiteFunctionType(html$.ElementEvents, [html$.Element])})
  });
  dart.defineLazy(html$.ElementEvents, {
    get webkitEvents() {
      return dart.map({animationend: 'webkitAnimationEnd', animationiteration: 'webkitAnimationIteration', animationstart: 'webkitAnimationStart', fullscreenchange: 'webkitfullscreenchange', fullscreenerror: 'webkitfullscreenerror', keyadded: 'webkitkeyadded', keyerror: 'webkitkeyerror', keymessage: 'webkitkeymessage', needkey: 'webkitneedkey', pointerlockchange: 'webkitpointerlockchange', pointerlockerror: 'webkitpointerlockerror', resourcetimingbufferfull: 'webkitresourcetimingbufferfull', transitionend: 'webkitTransitionEnd', speechchange: 'webkitSpeechChange'});
    }
  });
  dart.defineExtensionNames([
    'waitUntil'
  ]);
  html$.ExtendableEvent = class ExtendableEvent extends html$.Event {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(type, eventInitDict) {
      if (eventInitDict === void 0) eventInitDict = null;
      if (eventInitDict != null) {
        let eventInitDict_1 = html_common.convertDartToNative_Dictionary(eventInitDict);
        return html$.ExtendableEvent._create_1(type, eventInitDict_1);
      }
      return html$.ExtendableEvent._create_2(type);
    }
    static _create_1(type, eventInitDict) {
      return new ExtendableEvent(type, eventInitDict);
    }
    static _create_2(type) {
      return new ExtendableEvent(type);
    }
    [dartx.waitUntil](value) {
      return this.waitUntil(value);
    }
  };
  dart.setSignature(html$.ExtendableEvent, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.ExtendableEvent, []),
      new: dart.definiteFunctionType(html$.ExtendableEvent, [core.String], [core.Map])
    }),
    methods: () => ({[dartx.waitUntil]: dart.definiteFunctionType(dart.void, [core.Object])}),
    statics: () => ({
      _create_1: dart.definiteFunctionType(html$.ExtendableEvent, [dart.dynamic, dart.dynamic]),
      _create_2: dart.definiteFunctionType(html$.ExtendableEvent, [dart.dynamic])
    }),
    names: ['_create_1', '_create_2']
  });
  dart.registerExtension(dart.global.ExtendableEvent, html$.ExtendableEvent);
  dart.defineExtensionNames([
    'protocol',
    'provider'
  ]);
  html$.FederatedCredential = class FederatedCredential extends html$.Credential {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(data) {
      let data_1 = html_common.convertDartToNative_Dictionary(data);
      return html$.FederatedCredential._create_1(data_1);
    }
    static _create_1(data) {
      return new FederatedCredential(data);
    }
    get [dartx.protocol]() {
      return this.protocol;
    }
    get [dartx.provider]() {
      return this.provider;
    }
  };
  dart.setSignature(html$.FederatedCredential, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.FederatedCredential, []),
      new: dart.definiteFunctionType(html$.FederatedCredential, [core.Map])
    }),
    statics: () => ({_create_1: dart.definiteFunctionType(html$.FederatedCredential, [dart.dynamic])}),
    names: ['_create_1']
  });
  dart.registerExtension(dart.global.FederatedCredential, html$.FederatedCredential);
  dart.defineExtensionNames([
    'respondWith',
    'isReload',
    'request'
  ]);
  html$.FetchEvent = class FetchEvent extends html$.ExtendableEvent {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(type, eventInitDict) {
      if (eventInitDict === void 0) eventInitDict = null;
      if (eventInitDict != null) {
        let eventInitDict_1 = html_common.convertDartToNative_Dictionary(eventInitDict);
        return html$.FetchEvent._create_1(type, eventInitDict_1);
      }
      return html$.FetchEvent._create_2(type);
    }
    static _create_1(type, eventInitDict) {
      return new FetchEvent(type, eventInitDict);
    }
    static _create_2(type) {
      return new FetchEvent(type);
    }
    get [dartx.isReload]() {
      return this.isReload;
    }
    get [dartx.request]() {
      return this.request;
    }
    [dartx.respondWith](value) {
      return this.respondWith(value);
    }
  };
  dart.setSignature(html$.FetchEvent, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.FetchEvent, []),
      new: dart.definiteFunctionType(html$.FetchEvent, [core.String], [core.Map])
    }),
    methods: () => ({[dartx.respondWith]: dart.definiteFunctionType(dart.void, [core.Object])}),
    statics: () => ({
      _create_1: dart.definiteFunctionType(html$.FetchEvent, [dart.dynamic, dart.dynamic]),
      _create_2: dart.definiteFunctionType(html$.FetchEvent, [dart.dynamic])
    }),
    names: ['_create_1', '_create_2']
  });
  dart.registerExtension(dart.global.FetchEvent, html$.FetchEvent);
  dart.defineExtensionNames([
    'checkValidity',
    'reportValidity',
    'setCustomValidity',
    'disabled',
    'elements',
    'form',
    'name',
    'type',
    'validationMessage',
    'validity',
    'willValidate'
  ]);
  html$.FieldSetElement = class FieldSetElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return html$.FieldSetElement._check(html$.document[dartx.createElement]("fieldset"));
    }
    created() {
      this[dartx.disabled] = null;
      this[dartx.elements] = null;
      this[dartx.form] = null;
      this[dartx.name] = null;
      this[dartx.type] = null;
      this[dartx.validationMessage] = null;
      this[dartx.validity] = null;
      this[dartx.willValidate] = null;
      super.created();
    }
    get [dartx.disabled]() {
      return this.disabled;
    }
    set [dartx.disabled](value) {
      this.disabled = value;
    }
    get [dartx.elements]() {
      return this.elements;
    }
    get [dartx.form]() {
      return this.form;
    }
    get [dartx.name]() {
      return this.name;
    }
    set [dartx.name](value) {
      this.name = value;
    }
    get [dartx.type]() {
      return this.type;
    }
    get [dartx.validationMessage]() {
      return this.validationMessage;
    }
    get [dartx.validity]() {
      return this.validity;
    }
    get [dartx.willValidate]() {
      return this.willValidate;
    }
    [dartx.checkValidity]() {
      return this.checkValidity();
    }
    [dartx.reportValidity]() {
      return this.reportValidity();
    }
    [dartx.setCustomValidity](error) {
      return this.setCustomValidity(error);
    }
  };
  dart.defineNamedConstructor(html$.FieldSetElement, 'created');
  dart.setSignature(html$.FieldSetElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.FieldSetElement, []),
      new: dart.definiteFunctionType(html$.FieldSetElement, []),
      created: dart.definiteFunctionType(html$.FieldSetElement, [])
    }),
    methods: () => ({
      [dartx.checkValidity]: dart.definiteFunctionType(core.bool, []),
      [dartx.reportValidity]: dart.definiteFunctionType(core.bool, []),
      [dartx.setCustomValidity]: dart.definiteFunctionType(dart.void, [core.String])
    })
  });
  dart.registerExtension(dart.global.HTMLFieldSetElement, html$.FieldSetElement);
  const _get_lastModifiedDate = Symbol('_get_lastModifiedDate');
  dart.defineExtensionNames([
    'lastModifiedDate',
    'lastModified',
    'name',
    'relativePath'
  ]);
  html$.File = class File extends html$.Blob {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(fileBits, fileName, options) {
      if (options === void 0) options = null;
      if (options != null) {
        let options_1 = html_common.convertDartToNative_Dictionary(options);
        return html$.File._create_1(fileBits, fileName, options_1);
      }
      return html$.File._create_2(fileBits, fileName);
    }
    static _create_1(fileBits, fileName, options) {
      return new File(fileBits, fileName, options);
    }
    static _create_2(fileBits, fileName) {
      return new File(fileBits, fileName);
    }
    get [dartx.lastModified]() {
      return this.lastModified;
    }
    get [dartx.lastModifiedDate]() {
      return html_common.convertNativeToDart_DateTime(this[_get_lastModifiedDate]);
    }
    get [_get_lastModifiedDate]() {
      return this.lastModifiedDate;
    }
    get [dartx.name]() {
      return this.name;
    }
    get [dartx.relativePath]() {
      return this.webkitRelativePath;
    }
  };
  dart.setSignature(html$.File, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.File, []),
      new: dart.definiteFunctionType(html$.File, [core.List$(core.Object), core.String], [core.Map])
    }),
    statics: () => ({
      _create_1: dart.definiteFunctionType(html$.File, [dart.dynamic, dart.dynamic, dart.dynamic]),
      _create_2: dart.definiteFunctionType(html$.File, [dart.dynamic, dart.dynamic])
    }),
    names: ['_create_1', '_create_2']
  });
  dart.registerExtension(dart.global.File, html$.File);
  html$._FileCallback = dart.typedef('_FileCallback', () => dart.functionType(dart.void, [html$.File]));
  const _createWriter = Symbol('_createWriter');
  const _file = Symbol('_file');
  dart.defineExtensionNames([
    'createWriter',
    'file'
  ]);
  html$.FileEntry = class FileEntry extends html$.Entry {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [_createWriter](successCallback, errorCallback) {
      return this.createWriter(successCallback, errorCallback);
    }
    [dartx.createWriter]() {
      let completer = CompleterOfFileWriter().new();
      this[_createWriter](dart.fn(value => {
        completer.complete(value);
      }, FileWriterTovoid()), dart.fn(error => {
        completer.completeError(error);
      }, FileErrorTovoid()));
      return completer.future;
    }
    [_file](successCallback, errorCallback) {
      return this.file(successCallback, errorCallback);
    }
    [dartx.file]() {
      let completer = CompleterOfFile().new();
      this[_file](dart.fn(value => {
        completer.complete(value);
      }, FileTovoid()), dart.fn(error => {
        completer.completeError(error);
      }, FileErrorTovoid()));
      return completer.future;
    }
  };
  dart.setSignature(html$.FileEntry, {
    constructors: () => ({_: dart.definiteFunctionType(html$.FileEntry, [])}),
    methods: () => ({
      [_createWriter]: dart.definiteFunctionType(dart.void, [html$._FileWriterCallback], [html$._ErrorCallback]),
      [dartx.createWriter]: dart.definiteFunctionType(async.Future$(html$.FileWriter), []),
      [_file]: dart.definiteFunctionType(dart.void, [html$._FileCallback], [html$._ErrorCallback]),
      [dartx.file]: dart.definiteFunctionType(async.Future$(html$.File), [])
    })
  });
  dart.registerExtension(dart.global.FileEntry, html$.FileEntry);
  dart.defineExtensionNames([
    'code'
  ]);
  html$.FileError = class FileError extends html$.DomError {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.code]() {
      return this.code;
    }
  };
  dart.setSignature(html$.FileError, {
    constructors: () => ({_: dart.definiteFunctionType(html$.FileError, [])})
  });
  html$.FileError.ABORT_ERR = 3;
  html$.FileError.ENCODING_ERR = 5;
  html$.FileError.INVALID_MODIFICATION_ERR = 9;
  html$.FileError.INVALID_STATE_ERR = 7;
  html$.FileError.NOT_FOUND_ERR = 1;
  html$.FileError.NOT_READABLE_ERR = 4;
  html$.FileError.NO_MODIFICATION_ALLOWED_ERR = 6;
  html$.FileError.PATH_EXISTS_ERR = 12;
  html$.FileError.QUOTA_EXCEEDED_ERR = 10;
  html$.FileError.SECURITY_ERR = 2;
  html$.FileError.SYNTAX_ERR = 8;
  html$.FileError.TYPE_MISMATCH_ERR = 11;
  dart.registerExtension(dart.global.FileError, html$.FileError);
  dart.defineExtensionNames([
    'length',
    'get',
    'set',
    'length',
    'first',
    'last',
    'single',
    'elementAt',
    'item'
  ]);
  html$.FileList = class FileList extends dart.mixin(_interceptors.Interceptor, collection.ListMixin$(html$.File), html$.ImmutableListMixin$(html$.File)) {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.length]() {
      return this.length;
    }
    [dartx.get](index) {
      if (index >>> 0 !== index || index >= this[dartx.length]) dart.throw(core.RangeError.index(index, this));
      return this[index];
    }
    [dartx.set](index, value) {
      dart.throw(new core.UnsupportedError("Cannot assign element of immutable List."));
      return value;
    }
    set [dartx.length](value) {
      dart.throw(new core.UnsupportedError("Cannot resize immutable List."));
    }
    get [dartx.first]() {
      if (dart.notNull(this[dartx.length]) > 0) {
        return this[0];
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.last]() {
      let len = this[dartx.length];
      if (dart.notNull(len) > 0) {
        return this[dart.notNull(len) - 1];
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.single]() {
      let len = this[dartx.length];
      if (len == 1) {
        return this[0];
      }
      if (len == 0) dart.throw(new core.StateError("No elements"));
      dart.throw(new core.StateError("More than one element"));
    }
    [dartx.elementAt](index) {
      return this[dartx.get](index);
    }
    [dartx.item](index) {
      return this.item(index);
    }
  };
  html$.FileList[dart.implements] = () => [_js_helper.JavaScriptIndexingBehavior, ListOfFile()];
  dart.setSignature(html$.FileList, {
    constructors: () => ({_: dart.definiteFunctionType(html$.FileList, [])}),
    methods: () => ({
      [dartx.get]: dart.definiteFunctionType(html$.File, [core.int]),
      [dartx.set]: dart.definiteFunctionType(dart.void, [core.int, html$.File]),
      [dartx.elementAt]: dart.definiteFunctionType(html$.File, [core.int]),
      [dartx.item]: dart.definiteFunctionType(html$.File, [core.int])
    })
  });
  dart.registerExtension(dart.global.FileList, html$.FileList);
  dart.defineExtensionNames([
    'result',
    'abort',
    'readAsArrayBuffer',
    'readAsDataUrl',
    'readAsText',
    'onAbort',
    'onError',
    'onLoad',
    'onLoadEnd',
    'onLoadStart',
    'onProgress',
    'error',
    'readyState'
  ]);
  html$.FileReader = class FileReader extends html$.EventTarget {
    get [dartx.result]() {
      let res = this.result;
      if (typed_data.ByteBuffer.is(res)) {
        return typed_data.Uint8List.view(res);
      }
      return res;
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return html$.FileReader._create_1();
    }
    static _create_1() {
      return new FileReader();
    }
    get [dartx.error]() {
      return this.error;
    }
    get [dartx.readyState]() {
      return this.readyState;
    }
    [dartx.abort]() {
      return this.abort();
    }
    [dartx.readAsArrayBuffer](blob) {
      return this.readAsArrayBuffer(blob);
    }
    [dartx.readAsDataUrl](blob) {
      return this.readAsDataURL(blob);
    }
    [dartx.readAsText](blob, label) {
      return this.readAsText(blob, label);
    }
    get [dartx.onAbort]() {
      return html$.FileReader.abortEvent.forTarget(this);
    }
    get [dartx.onError]() {
      return html$.FileReader.errorEvent.forTarget(this);
    }
    get [dartx.onLoad]() {
      return html$.FileReader.loadEvent.forTarget(this);
    }
    get [dartx.onLoadEnd]() {
      return html$.FileReader.loadEndEvent.forTarget(this);
    }
    get [dartx.onLoadStart]() {
      return html$.FileReader.loadStartEvent.forTarget(this);
    }
    get [dartx.onProgress]() {
      return html$.FileReader.progressEvent.forTarget(this);
    }
  };
  dart.setSignature(html$.FileReader, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.FileReader, []),
      new: dart.definiteFunctionType(html$.FileReader, [])
    }),
    methods: () => ({
      [dartx.abort]: dart.definiteFunctionType(dart.void, []),
      [dartx.readAsArrayBuffer]: dart.definiteFunctionType(dart.void, [html$.Blob]),
      [dartx.readAsDataUrl]: dart.definiteFunctionType(dart.void, [html$.Blob]),
      [dartx.readAsText]: dart.definiteFunctionType(dart.void, [html$.Blob], [core.String])
    }),
    statics: () => ({_create_1: dart.definiteFunctionType(html$.FileReader, [])}),
    names: ['_create_1']
  });
  html$.FileReader.DONE = 2;
  html$.FileReader.EMPTY = 0;
  html$.FileReader.LOADING = 1;
  dart.defineLazy(html$.FileReader, {
    get abortEvent() {
      return dart.const(new (EventStreamProviderOfProgressEvent())('abort'));
    },
    get errorEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('error'));
    },
    get loadEvent() {
      return dart.const(new (EventStreamProviderOfProgressEvent())('load'));
    },
    get loadEndEvent() {
      return dart.const(new (EventStreamProviderOfProgressEvent())('loadend'));
    },
    get loadStartEvent() {
      return dart.const(new (EventStreamProviderOfProgressEvent())('loadstart'));
    },
    get progressEvent() {
      return dart.const(new (EventStreamProviderOfProgressEvent())('progress'));
    }
  });
  dart.registerExtension(dart.global.FileReader, html$.FileReader);
  dart.defineExtensionNames([
    'type'
  ]);
  html$.FileStream = class FileStream extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.type]() {
      return this.type;
    }
  };
  dart.setSignature(html$.FileStream, {
    constructors: () => ({_: dart.definiteFunctionType(html$.FileStream, [])})
  });
  dart.registerExtension(dart.global.Stream, html$.FileStream);
  dart.defineExtensionNames([
    'name',
    'root'
  ]);
  html$.FileSystem = class FileSystem extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static get supported() {
      return !!window.webkitRequestFileSystem;
    }
    get [dartx.name]() {
      return this.name;
    }
    get [dartx.root]() {
      return this.root;
    }
  };
  dart.setSignature(html$.FileSystem, {
    constructors: () => ({_: dart.definiteFunctionType(html$.FileSystem, [])})
  });
  dart.registerExtension(dart.global.DOMFileSystem, html$.FileSystem);
  html$._FileSystemCallback = dart.typedef('_FileSystemCallback', () => dart.functionType(dart.void, [html$.FileSystem]));
  dart.defineExtensionNames([
    'abort',
    'seek',
    'truncate',
    'write',
    'onAbort',
    'onError',
    'onProgress',
    'onWrite',
    'onWriteEnd',
    'onWriteStart',
    'error',
    'length',
    'position',
    'readyState'
  ]);
  html$.FileWriter = class FileWriter extends html$.EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.error]() {
      return this.error;
    }
    get [dartx.length]() {
      return this.length;
    }
    get [dartx.position]() {
      return this.position;
    }
    get [dartx.readyState]() {
      return this.readyState;
    }
    [dartx.abort]() {
      return this.abort();
    }
    [dartx.seek](position) {
      return this.seek(position);
    }
    [dartx.truncate](size) {
      return this.truncate(size);
    }
    [dartx.write](data) {
      return this.write(data);
    }
    get [dartx.onAbort]() {
      return html$.FileWriter.abortEvent.forTarget(this);
    }
    get [dartx.onError]() {
      return html$.FileWriter.errorEvent.forTarget(this);
    }
    get [dartx.onProgress]() {
      return html$.FileWriter.progressEvent.forTarget(this);
    }
    get [dartx.onWrite]() {
      return html$.FileWriter.writeEvent.forTarget(this);
    }
    get [dartx.onWriteEnd]() {
      return html$.FileWriter.writeEndEvent.forTarget(this);
    }
    get [dartx.onWriteStart]() {
      return html$.FileWriter.writeStartEvent.forTarget(this);
    }
  };
  dart.setSignature(html$.FileWriter, {
    constructors: () => ({_: dart.definiteFunctionType(html$.FileWriter, [])}),
    methods: () => ({
      [dartx.abort]: dart.definiteFunctionType(dart.void, []),
      [dartx.seek]: dart.definiteFunctionType(dart.void, [core.int]),
      [dartx.truncate]: dart.definiteFunctionType(dart.void, [core.int]),
      [dartx.write]: dart.definiteFunctionType(dart.void, [html$.Blob])
    })
  });
  html$.FileWriter.DONE = 2;
  html$.FileWriter.INIT = 0;
  html$.FileWriter.WRITING = 1;
  dart.defineLazy(html$.FileWriter, {
    get abortEvent() {
      return dart.const(new (EventStreamProviderOfProgressEvent())('abort'));
    },
    get errorEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('error'));
    },
    get progressEvent() {
      return dart.const(new (EventStreamProviderOfProgressEvent())('progress'));
    },
    get writeEvent() {
      return dart.const(new (EventStreamProviderOfProgressEvent())('write'));
    },
    get writeEndEvent() {
      return dart.const(new (EventStreamProviderOfProgressEvent())('writeend'));
    },
    get writeStartEvent() {
      return dart.const(new (EventStreamProviderOfProgressEvent())('writestart'));
    }
  });
  dart.registerExtension(dart.global.FileWriter, html$.FileWriter);
  html$._FileWriterCallback = dart.typedef('_FileWriterCallback', () => dart.functionType(dart.void, [html$.FileWriter]));
  const _get_relatedTarget = Symbol('_get_relatedTarget');
  dart.defineExtensionNames([
    'relatedTarget'
  ]);
  html$.FocusEvent = class FocusEvent extends html$.UIEvent {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(type, eventInitDict) {
      if (eventInitDict === void 0) eventInitDict = null;
      if (eventInitDict != null) {
        let eventInitDict_1 = html_common.convertDartToNative_Dictionary(eventInitDict);
        return html$.FocusEvent._create_1(type, eventInitDict_1);
      }
      return html$.FocusEvent._create_2(type);
    }
    static _create_1(type, eventInitDict) {
      return new FocusEvent(type, eventInitDict);
    }
    static _create_2(type) {
      return new FocusEvent(type);
    }
    get [dartx.relatedTarget]() {
      return html$._convertNativeToDart_EventTarget(this[_get_relatedTarget]);
    }
    get [_get_relatedTarget]() {
      return this.relatedTarget;
    }
  };
  dart.setSignature(html$.FocusEvent, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.FocusEvent, []),
      new: dart.definiteFunctionType(html$.FocusEvent, [core.String], [core.Map])
    }),
    statics: () => ({
      _create_1: dart.definiteFunctionType(html$.FocusEvent, [dart.dynamic, dart.dynamic]),
      _create_2: dart.definiteFunctionType(html$.FocusEvent, [dart.dynamic])
    }),
    names: ['_create_1', '_create_2']
  });
  dart.registerExtension(dart.global.FocusEvent, html$.FocusEvent);
  dart.defineExtensionNames([
    'load',
    'family',
    'featureSettings',
    'loaded',
    'status',
    'stretch',
    'style',
    'unicodeRange',
    'variant',
    'weight'
  ]);
  html$.FontFace = class FontFace extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(family, source, descriptors) {
      if (descriptors === void 0) descriptors = null;
      if (descriptors != null) {
        let descriptors_1 = html_common.convertDartToNative_Dictionary(descriptors);
        return html$.FontFace._create_1(family, source, descriptors_1);
      }
      return html$.FontFace._create_2(family, source);
    }
    static _create_1(family, source, descriptors) {
      return new FontFace(family, source, descriptors);
    }
    static _create_2(family, source) {
      return new FontFace(family, source);
    }
    get [dartx.family]() {
      return this.family;
    }
    set [dartx.family](value) {
      this.family = value;
    }
    get [dartx.featureSettings]() {
      return this.featureSettings;
    }
    set [dartx.featureSettings](value) {
      this.featureSettings = value;
    }
    get [dartx.loaded]() {
      return this.loaded;
    }
    get [dartx.status]() {
      return this.status;
    }
    get [dartx.stretch]() {
      return this.stretch;
    }
    set [dartx.stretch](value) {
      this.stretch = value;
    }
    get [dartx.style]() {
      return this.style;
    }
    set [dartx.style](value) {
      this.style = value;
    }
    get [dartx.unicodeRange]() {
      return this.unicodeRange;
    }
    set [dartx.unicodeRange](value) {
      this.unicodeRange = value;
    }
    get [dartx.variant]() {
      return this.variant;
    }
    set [dartx.variant](value) {
      this.variant = value;
    }
    get [dartx.weight]() {
      return this.weight;
    }
    set [dartx.weight](value) {
      this.weight = value;
    }
    [dartx.load]() {
      return this.load();
    }
  };
  dart.setSignature(html$.FontFace, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.FontFace, []),
      new: dart.definiteFunctionType(html$.FontFace, [core.String, core.Object], [core.Map])
    }),
    methods: () => ({[dartx.load]: dart.definiteFunctionType(async.Future, [])}),
    statics: () => ({
      _create_1: dart.definiteFunctionType(html$.FontFace, [dart.dynamic, dart.dynamic, dart.dynamic]),
      _create_2: dart.definiteFunctionType(html$.FontFace, [dart.dynamic, dart.dynamic])
    }),
    names: ['_create_1', '_create_2']
  });
  dart.registerExtension(dart.global.FontFace, html$.FontFace);
  dart.defineExtensionNames([
    'add',
    'check',
    'clear',
    'delete',
    'forEach',
    'has',
    'size',
    'status'
  ]);
  html$.FontFaceSet = class FontFaceSet extends html$.EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.size]() {
      return this.size;
    }
    get [dartx.status]() {
      return this.status;
    }
    [dartx.add](fontFace) {
      return this.add(fontFace);
    }
    [dartx.check](font, text) {
      return this.check(font, text);
    }
    [dartx.clear]() {
      return this.clear();
    }
    [dartx.delete](fontFace) {
      return this.delete(fontFace);
    }
    [dartx.forEach](callback, thisArg) {
      return this.forEach(callback, thisArg);
    }
    [dartx.has](fontFace) {
      return this.has(fontFace);
    }
  };
  dart.setSignature(html$.FontFaceSet, {
    constructors: () => ({_: dart.definiteFunctionType(html$.FontFaceSet, [])}),
    methods: () => ({
      [dartx.add]: dart.definiteFunctionType(dart.void, [html$.FontFace]),
      [dartx.check]: dart.definiteFunctionType(core.bool, [core.String], [core.String]),
      [dartx.clear]: dart.definiteFunctionType(dart.void, []),
      [dartx.delete]: dart.definiteFunctionType(core.bool, [html$.FontFace]),
      [dartx.forEach]: dart.definiteFunctionType(dart.void, [html$.FontFaceSetForEachCallback], [core.Object]),
      [dartx.has]: dart.definiteFunctionType(core.bool, [html$.FontFace])
    })
  });
  dart.registerExtension(dart.global.FontFaceSet, html$.FontFaceSet);
  html$.FontFaceSetForEachCallback = dart.typedef('FontFaceSetForEachCallback', () => dart.functionType(dart.void, [html$.FontFace, html$.FontFace, html$.FontFaceSet]));
  dart.defineExtensionNames([
    'fontfaces'
  ]);
  html$.FontFaceSetLoadEvent = class FontFaceSetLoadEvent extends html$.Event {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.fontfaces]() {
      return this.fontfaces;
    }
  };
  dart.setSignature(html$.FontFaceSetLoadEvent, {
    constructors: () => ({_: dart.definiteFunctionType(html$.FontFaceSetLoadEvent, [])})
  });
  dart.registerExtension(dart.global.FontFaceSetLoadEvent, html$.FontFaceSetLoadEvent);
  dart.defineExtensionNames([
    'append',
    'appendBlob',
    'delete',
    'get',
    'getAll',
    'has',
    'set'
  ]);
  html$.FormData = class FormData extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(form) {
      if (form === void 0) form = null;
      if (form != null) {
        return html$.FormData._create_1(form);
      }
      return html$.FormData._create_2();
    }
    static _create_1(form) {
      return new FormData(form);
    }
    static _create_2() {
      return new FormData();
    }
    static get supported() {
      return !!window.FormData;
    }
    [dartx.append](name, value) {
      return this.append(name, value);
    }
    [dartx.appendBlob](name, value, filename) {
      return this.append(name, value, filename);
    }
    [dartx.delete](name) {
      return this.delete(name);
    }
    [dartx.get](name) {
      return this.get(name);
    }
    [dartx.getAll](name) {
      return this.getAll(name);
    }
    [dartx.has](name) {
      return this.has(name);
    }
    [dartx.set](name, value, filename) {
      return this.set(name, value, filename);
    }
  };
  dart.setSignature(html$.FormData, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.FormData, []),
      new: dart.definiteFunctionType(html$.FormData, [], [html$.FormElement])
    }),
    methods: () => ({
      [dartx.append]: dart.definiteFunctionType(dart.void, [core.String, core.String]),
      [dartx.appendBlob]: dart.definiteFunctionType(dart.void, [core.String, html$.Blob], [core.String]),
      [dartx.delete]: dart.definiteFunctionType(dart.void, [core.String]),
      [dartx.get]: dart.definiteFunctionType(core.Object, [core.String]),
      [dartx.getAll]: dart.definiteFunctionType(core.List$(core.Object), [core.String]),
      [dartx.has]: dart.definiteFunctionType(core.bool, [core.String]),
      [dartx.set]: dart.definiteFunctionType(dart.void, [core.String, dart.dynamic], [core.String])
    }),
    statics: () => ({
      _create_1: dart.definiteFunctionType(html$.FormData, [dart.dynamic]),
      _create_2: dart.definiteFunctionType(html$.FormData, [])
    }),
    names: ['_create_1', '_create_2']
  });
  dart.registerExtension(dart.global.FormData, html$.FormData);
  const _requestAutocomplete_1 = Symbol('_requestAutocomplete_1');
  dart.defineExtensionNames([
    'checkValidity',
    'item',
    'reportValidity',
    'requestAutocomplete',
    'reset',
    'submit',
    'acceptCharset',
    'action',
    'autocomplete',
    'encoding',
    'enctype',
    'length',
    'method',
    'name',
    'noValidate',
    'target'
  ]);
  html$.FormElement = class FormElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return html$.FormElement._check(html$.document[dartx.createElement]("form"));
    }
    created() {
      this[dartx.acceptCharset] = null;
      this[dartx.action] = null;
      this[dartx.autocomplete] = null;
      this[dartx.encoding] = null;
      this[dartx.enctype] = null;
      this[dartx.length] = null;
      this[dartx.method] = null;
      this[dartx.name] = null;
      this[dartx.noValidate] = null;
      this[dartx.target] = null;
      super.created();
    }
    get [dartx.acceptCharset]() {
      return this.acceptCharset;
    }
    set [dartx.acceptCharset](value) {
      this.acceptCharset = value;
    }
    get [dartx.action]() {
      return this.action;
    }
    set [dartx.action](value) {
      this.action = value;
    }
    get [dartx.autocomplete]() {
      return this.autocomplete;
    }
    set [dartx.autocomplete](value) {
      this.autocomplete = value;
    }
    get [dartx.encoding]() {
      return this.encoding;
    }
    set [dartx.encoding](value) {
      this.encoding = value;
    }
    get [dartx.enctype]() {
      return this.enctype;
    }
    set [dartx.enctype](value) {
      this.enctype = value;
    }
    get [dartx.length]() {
      return this.length;
    }
    get [dartx.method]() {
      return this.method;
    }
    set [dartx.method](value) {
      this.method = value;
    }
    get [dartx.name]() {
      return this.name;
    }
    set [dartx.name](value) {
      this.name = value;
    }
    get [dartx.noValidate]() {
      return this.noValidate;
    }
    set [dartx.noValidate](value) {
      this.noValidate = value;
    }
    get [dartx.target]() {
      return this.target;
    }
    set [dartx.target](value) {
      this.target = value;
    }
    [__getter__](name) {
      return this.__getter__(name);
    }
    [dartx.checkValidity]() {
      return this.checkValidity();
    }
    [dartx.item](index) {
      return this.item(index);
    }
    [dartx.reportValidity]() {
      return this.reportValidity();
    }
    [dartx.requestAutocomplete](details) {
      let details_1 = html_common.convertDartToNative_Dictionary(details);
      this[_requestAutocomplete_1](details_1);
      return;
    }
    [_requestAutocomplete_1](details) {
      return this.requestAutocomplete(details);
    }
    [dartx.reset]() {
      return this.reset();
    }
    [dartx.submit]() {
      return this.submit();
    }
  };
  dart.defineNamedConstructor(html$.FormElement, 'created');
  dart.setSignature(html$.FormElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.FormElement, []),
      new: dart.definiteFunctionType(html$.FormElement, []),
      created: dart.definiteFunctionType(html$.FormElement, [])
    }),
    methods: () => ({
      [__getter__]: dart.definiteFunctionType(core.Object, [core.String]),
      [dartx.checkValidity]: dart.definiteFunctionType(core.bool, []),
      [dartx.item]: dart.definiteFunctionType(html$.Element, [core.int]),
      [dartx.reportValidity]: dart.definiteFunctionType(core.bool, []),
      [dartx.requestAutocomplete]: dart.definiteFunctionType(dart.void, [core.Map]),
      [_requestAutocomplete_1]: dart.definiteFunctionType(dart.void, [dart.dynamic]),
      [dartx.reset]: dart.definiteFunctionType(dart.void, []),
      [dartx.submit]: dart.definiteFunctionType(dart.void, [])
    })
  });
  dart.registerExtension(dart.global.HTMLFormElement, html$.FormElement);
  html$.FrameRequestCallback = dart.typedef('FrameRequestCallback', () => dart.functionType(dart.void, [core.num]));
  dart.defineExtensionNames([
    'axes',
    'buttons',
    'connected',
    'id',
    'index',
    'mapping',
    'timestamp'
  ]);
  html$.Gamepad = class Gamepad extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.axes]() {
      return this.axes;
    }
    get [dartx.buttons]() {
      return this.buttons;
    }
    get [dartx.connected]() {
      return this.connected;
    }
    get [dartx.id]() {
      return this.id;
    }
    get [dartx.index]() {
      return this.index;
    }
    get [dartx.mapping]() {
      return this.mapping;
    }
    get [dartx.timestamp]() {
      return this.timestamp;
    }
  };
  dart.setSignature(html$.Gamepad, {
    constructors: () => ({_: dart.definiteFunctionType(html$.Gamepad, [])})
  });
  dart.registerExtension(dart.global.Gamepad, html$.Gamepad);
  dart.defineExtensionNames([
    'pressed',
    'value'
  ]);
  html$.GamepadButton = class GamepadButton extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.pressed]() {
      return this.pressed;
    }
    get [dartx.value]() {
      return this.value;
    }
  };
  dart.setSignature(html$.GamepadButton, {
    constructors: () => ({_: dart.definiteFunctionType(html$.GamepadButton, [])})
  });
  dart.registerExtension(dart.global.GamepadButton, html$.GamepadButton);
  dart.defineExtensionNames([
    'gamepad'
  ]);
  html$.GamepadEvent = class GamepadEvent extends html$.Event {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(type, eventInitDict) {
      if (eventInitDict === void 0) eventInitDict = null;
      if (eventInitDict != null) {
        let eventInitDict_1 = html_common.convertDartToNative_Dictionary(eventInitDict);
        return html$.GamepadEvent._create_1(type, eventInitDict_1);
      }
      return html$.GamepadEvent._create_2(type);
    }
    static _create_1(type, eventInitDict) {
      return new GamepadEvent(type, eventInitDict);
    }
    static _create_2(type) {
      return new GamepadEvent(type);
    }
    get [dartx.gamepad]() {
      return this.gamepad;
    }
  };
  dart.setSignature(html$.GamepadEvent, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.GamepadEvent, []),
      new: dart.definiteFunctionType(html$.GamepadEvent, [core.String], [core.Map])
    }),
    statics: () => ({
      _create_1: dart.definiteFunctionType(html$.GamepadEvent, [dart.dynamic, dart.dynamic]),
      _create_2: dart.definiteFunctionType(html$.GamepadEvent, [dart.dynamic])
    }),
    names: ['_create_1', '_create_2']
  });
  dart.registerExtension(dart.global.GamepadEvent, html$.GamepadEvent);
  dart.defineExtensionNames([
    'getRegisteredRegions',
    'registerRegion',
    'unregisterRegion'
  ]);
  html$.Geofencing = class Geofencing extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [dartx.getRegisteredRegions]() {
      return this.getRegisteredRegions();
    }
    [dartx.registerRegion](region) {
      return this.registerRegion(region);
    }
    [dartx.unregisterRegion](regionId) {
      return this.unregisterRegion(regionId);
    }
  };
  dart.setSignature(html$.Geofencing, {
    constructors: () => ({_: dart.definiteFunctionType(html$.Geofencing, [])}),
    methods: () => ({
      [dartx.getRegisteredRegions]: dart.definiteFunctionType(async.Future, []),
      [dartx.registerRegion]: dart.definiteFunctionType(async.Future, [html$.GeofencingRegion]),
      [dartx.unregisterRegion]: dart.definiteFunctionType(async.Future, [core.String])
    })
  });
  dart.registerExtension(dart.global.Geofencing, html$.Geofencing);
  dart.defineExtensionNames([
    'id',
    'region'
  ]);
  html$.GeofencingEvent = class GeofencingEvent extends html$.Event {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.id]() {
      return this.id;
    }
    get [dartx.region]() {
      return this.region;
    }
  };
  dart.setSignature(html$.GeofencingEvent, {
    constructors: () => ({_: dart.definiteFunctionType(html$.GeofencingEvent, [])})
  });
  dart.registerExtension(dart.global.GeofencingEvent, html$.GeofencingEvent);
  const _getCurrentPosition = Symbol('_getCurrentPosition');
  const _ensurePosition = Symbol('_ensurePosition');
  const _watchPosition = Symbol('_watchPosition');
  const _clearWatch = Symbol('_clearWatch');
  const _getCurrentPosition_1 = Symbol('_getCurrentPosition_1');
  const _getCurrentPosition_2 = Symbol('_getCurrentPosition_2');
  const _getCurrentPosition_3 = Symbol('_getCurrentPosition_3');
  const _watchPosition_1 = Symbol('_watchPosition_1');
  const _watchPosition_2 = Symbol('_watchPosition_2');
  const _watchPosition_3 = Symbol('_watchPosition_3');
  dart.defineExtensionNames([
    'getCurrentPosition',
    'watchPosition'
  ]);
  html$.Geolocation = class Geolocation extends _interceptors.Interceptor {
    [dartx.getCurrentPosition](opts) {
      let enableHighAccuracy = opts && 'enableHighAccuracy' in opts ? opts.enableHighAccuracy : null;
      let timeout = opts && 'timeout' in opts ? opts.timeout : null;
      let maximumAge = opts && 'maximumAge' in opts ? opts.maximumAge : null;
      let options = dart.map();
      if (enableHighAccuracy != null) {
        options[dartx.set]('enableHighAccuracy', enableHighAccuracy);
      }
      if (timeout != null) {
        options[dartx.set]('timeout', timeout.inMilliseconds);
      }
      if (maximumAge != null) {
        options[dartx.set]('maximumAge', maximumAge.inMilliseconds);
      }
      let completer = CompleterOfGeoposition().new();
      try {
        this[_getCurrentPosition](dart.fn(position => {
          completer.complete(this[_ensurePosition](position));
        }, GeopositionTovoid()), dart.fn(error => {
          completer.completeError(error);
        }, PositionErrorTovoid()), options);
      } catch (e) {
        let stacktrace = dart.stackTrace(e);
        completer.completeError(e, stacktrace);
      }

      return completer.future;
    }
    [dartx.watchPosition](opts) {
      let enableHighAccuracy = opts && 'enableHighAccuracy' in opts ? opts.enableHighAccuracy : null;
      let timeout = opts && 'timeout' in opts ? opts.timeout : null;
      let maximumAge = opts && 'maximumAge' in opts ? opts.maximumAge : null;
      let options = dart.map();
      if (enableHighAccuracy != null) {
        options[dartx.set]('enableHighAccuracy', enableHighAccuracy);
      }
      if (timeout != null) {
        options[dartx.set]('timeout', timeout.inMilliseconds);
      }
      if (maximumAge != null) {
        options[dartx.set]('maximumAge', maximumAge.inMilliseconds);
      }
      let watchId = null;
      let controller = null;
      controller = StreamControllerOfGeoposition().new({sync: true, onListen: dart.fn(() => {
          dart.assert(watchId == null);
          watchId = this[_watchPosition](dart.fn(position => {
            controller.add(this[_ensurePosition](position));
          }, GeopositionTovoid()), dart.fn(error => {
            controller.addError(error);
          }, PositionErrorTovoid()), options);
        }, VoidTovoid$()), onCancel: dart.fn(() => {
          dart.assert(watchId != null);
          this[_clearWatch](watchId);
        }, VoidTodynamic$())});
      return controller.stream;
    }
    [_ensurePosition](domPosition) {
      try {
        if (html$.Geoposition.is(domPosition)) {
          return domPosition;
        }
      } catch (e) {
      }

      return new html$._GeopositionWrapper(domPosition);
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [_clearWatch](watchID) {
      return this.clearWatch(watchID);
    }
    [_getCurrentPosition](successCallback, errorCallback, options) {
      if (errorCallback === void 0) errorCallback = null;
      if (options === void 0) options = null;
      if (options != null) {
        let options_1 = html_common.convertDartToNative_Dictionary(options);
        this[_getCurrentPosition_1](successCallback, errorCallback, options_1);
        return;
      }
      if (errorCallback != null) {
        this[_getCurrentPosition_2](successCallback, errorCallback);
        return;
      }
      this[_getCurrentPosition_3](successCallback);
      return;
    }
    [_getCurrentPosition_1](successCallback, errorCallback, options) {
      return this.getCurrentPosition(successCallback, errorCallback, options);
    }
    [_getCurrentPosition_2](successCallback, errorCallback) {
      return this.getCurrentPosition(successCallback, errorCallback);
    }
    [_getCurrentPosition_3](successCallback) {
      return this.getCurrentPosition(successCallback);
    }
    [_watchPosition](successCallback, errorCallback, options) {
      if (errorCallback === void 0) errorCallback = null;
      if (options === void 0) options = null;
      if (options != null) {
        let options_1 = html_common.convertDartToNative_Dictionary(options);
        return this[_watchPosition_1](successCallback, errorCallback, options_1);
      }
      if (errorCallback != null) {
        return this[_watchPosition_2](successCallback, errorCallback);
      }
      return this[_watchPosition_3](successCallback);
    }
    [_watchPosition_1](successCallback, errorCallback, options) {
      return this.watchPosition(successCallback, errorCallback, options);
    }
    [_watchPosition_2](successCallback, errorCallback) {
      return this.watchPosition(successCallback, errorCallback);
    }
    [_watchPosition_3](successCallback) {
      return this.watchPosition(successCallback);
    }
  };
  dart.setSignature(html$.Geolocation, {
    constructors: () => ({_: dart.definiteFunctionType(html$.Geolocation, [])}),
    methods: () => ({
      [dartx.getCurrentPosition]: dart.definiteFunctionType(async.Future$(html$.Geoposition), [], {enableHighAccuracy: core.bool, timeout: core.Duration, maximumAge: core.Duration}),
      [dartx.watchPosition]: dart.definiteFunctionType(async.Stream$(html$.Geoposition), [], {enableHighAccuracy: core.bool, timeout: core.Duration, maximumAge: core.Duration}),
      [_ensurePosition]: dart.definiteFunctionType(html$.Geoposition, [dart.dynamic]),
      [_clearWatch]: dart.definiteFunctionType(dart.void, [core.int]),
      [_getCurrentPosition]: dart.definiteFunctionType(dart.void, [html$._PositionCallback], [html$._PositionErrorCallback, core.Map]),
      [_getCurrentPosition_1]: dart.definiteFunctionType(dart.void, [html$._PositionCallback, html$._PositionErrorCallback, dart.dynamic]),
      [_getCurrentPosition_2]: dart.definiteFunctionType(dart.void, [html$._PositionCallback, html$._PositionErrorCallback]),
      [_getCurrentPosition_3]: dart.definiteFunctionType(dart.void, [html$._PositionCallback]),
      [_watchPosition]: dart.definiteFunctionType(core.int, [html$._PositionCallback], [html$._PositionErrorCallback, core.Map]),
      [_watchPosition_1]: dart.definiteFunctionType(core.int, [html$._PositionCallback, html$._PositionErrorCallback, dart.dynamic]),
      [_watchPosition_2]: dart.definiteFunctionType(core.int, [html$._PositionCallback, html$._PositionErrorCallback]),
      [_watchPosition_3]: dart.definiteFunctionType(core.int, [html$._PositionCallback])
    })
  });
  dart.registerExtension(dart.global.Geolocation, html$.Geolocation);
  html$._GeopositionWrapper = class _GeopositionWrapper extends core.Object {
    new(ptr) {
      this[_ptr] = ptr;
    }
    get coords() {
      return this[_ptr].coords;
    }
    get timestamp() {
      return this[_ptr].timestamp;
    }
  };
  html$._GeopositionWrapper[dart.implements] = () => [html$.Geoposition];
  dart.setSignature(html$._GeopositionWrapper, {
    constructors: () => ({new: dart.definiteFunctionType(html$._GeopositionWrapper, [dart.dynamic])})
  });
  dart.defineExtensionNames([
    'coords',
    'timestamp'
  ]);
  html$.Geoposition = class Geoposition extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.coords]() {
      return this.coords;
    }
    get [dartx.timestamp]() {
      return this.timestamp;
    }
  };
  dart.setSignature(html$.Geoposition, {
    constructors: () => ({_: dart.definiteFunctionType(html$.Geoposition, [])})
  });
  dart.registerExtension(dart.global.Geoposition, html$.Geoposition);
  dart.defineExtensionNames([
    'onAbort',
    'onBlur',
    'onCanPlay',
    'onCanPlayThrough',
    'onChange',
    'onClick',
    'onContextMenu',
    'onDoubleClick',
    'onDrag',
    'onDragEnd',
    'onDragEnter',
    'onDragLeave',
    'onDragOver',
    'onDragStart',
    'onDrop',
    'onDurationChange',
    'onEmptied',
    'onEnded',
    'onError',
    'onFocus',
    'onInput',
    'onInvalid',
    'onKeyDown',
    'onKeyPress',
    'onKeyUp',
    'onLoad',
    'onLoadedData',
    'onLoadedMetadata',
    'onMouseDown',
    'onMouseEnter',
    'onMouseLeave',
    'onMouseMove',
    'onMouseOut',
    'onMouseOver',
    'onMouseUp',
    'onMouseWheel',
    'onPause',
    'onPlay',
    'onPlaying',
    'onRateChange',
    'onReset',
    'onResize',
    'onScroll',
    'onSeeked',
    'onSeeking',
    'onSelect',
    'onStalled',
    'onSubmit',
    'onSuspend',
    'onTimeUpdate',
    'onVolumeChange',
    'onWaiting'
  ]);
  html$.GlobalEventHandlers = class GlobalEventHandlers extends core.Object {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get onAbort() {
      return html$.GlobalEventHandlers.abortEvent.forTarget(this);
    }
    get onBlur() {
      return html$.GlobalEventHandlers.blurEvent.forTarget(this);
    }
    get onCanPlay() {
      return html$.GlobalEventHandlers.canPlayEvent.forTarget(this);
    }
    get onCanPlayThrough() {
      return html$.GlobalEventHandlers.canPlayThroughEvent.forTarget(this);
    }
    get onChange() {
      return html$.GlobalEventHandlers.changeEvent.forTarget(this);
    }
    get onClick() {
      return html$.GlobalEventHandlers.clickEvent.forTarget(this);
    }
    get onContextMenu() {
      return html$.GlobalEventHandlers.contextMenuEvent.forTarget(this);
    }
    get onDoubleClick() {
      return html$.GlobalEventHandlers.doubleClickEvent.forTarget(this);
    }
    get onDrag() {
      return html$.GlobalEventHandlers.dragEvent.forTarget(this);
    }
    get onDragEnd() {
      return html$.GlobalEventHandlers.dragEndEvent.forTarget(this);
    }
    get onDragEnter() {
      return html$.GlobalEventHandlers.dragEnterEvent.forTarget(this);
    }
    get onDragLeave() {
      return html$.GlobalEventHandlers.dragLeaveEvent.forTarget(this);
    }
    get onDragOver() {
      return html$.GlobalEventHandlers.dragOverEvent.forTarget(this);
    }
    get onDragStart() {
      return html$.GlobalEventHandlers.dragStartEvent.forTarget(this);
    }
    get onDrop() {
      return html$.GlobalEventHandlers.dropEvent.forTarget(this);
    }
    get onDurationChange() {
      return html$.GlobalEventHandlers.durationChangeEvent.forTarget(this);
    }
    get onEmptied() {
      return html$.GlobalEventHandlers.emptiedEvent.forTarget(this);
    }
    get onEnded() {
      return html$.GlobalEventHandlers.endedEvent.forTarget(this);
    }
    get onError() {
      return html$.GlobalEventHandlers.errorEvent.forTarget(this);
    }
    get onFocus() {
      return html$.GlobalEventHandlers.focusEvent.forTarget(this);
    }
    get onInput() {
      return html$.GlobalEventHandlers.inputEvent.forTarget(this);
    }
    get onInvalid() {
      return html$.GlobalEventHandlers.invalidEvent.forTarget(this);
    }
    get onKeyDown() {
      return html$.GlobalEventHandlers.keyDownEvent.forTarget(this);
    }
    get onKeyPress() {
      return html$.GlobalEventHandlers.keyPressEvent.forTarget(this);
    }
    get onKeyUp() {
      return html$.GlobalEventHandlers.keyUpEvent.forTarget(this);
    }
    get onLoad() {
      return html$.GlobalEventHandlers.loadEvent.forTarget(this);
    }
    get onLoadedData() {
      return html$.GlobalEventHandlers.loadedDataEvent.forTarget(this);
    }
    get onLoadedMetadata() {
      return html$.GlobalEventHandlers.loadedMetadataEvent.forTarget(this);
    }
    get onMouseDown() {
      return html$.GlobalEventHandlers.mouseDownEvent.forTarget(this);
    }
    get onMouseEnter() {
      return html$.GlobalEventHandlers.mouseEnterEvent.forTarget(this);
    }
    get onMouseLeave() {
      return html$.GlobalEventHandlers.mouseLeaveEvent.forTarget(this);
    }
    get onMouseMove() {
      return html$.GlobalEventHandlers.mouseMoveEvent.forTarget(this);
    }
    get onMouseOut() {
      return html$.GlobalEventHandlers.mouseOutEvent.forTarget(this);
    }
    get onMouseOver() {
      return html$.GlobalEventHandlers.mouseOverEvent.forTarget(this);
    }
    get onMouseUp() {
      return html$.GlobalEventHandlers.mouseUpEvent.forTarget(this);
    }
    get onMouseWheel() {
      return html$.GlobalEventHandlers.mouseWheelEvent.forTarget(this);
    }
    get onPause() {
      return html$.GlobalEventHandlers.pauseEvent.forTarget(this);
    }
    get onPlay() {
      return html$.GlobalEventHandlers.playEvent.forTarget(this);
    }
    get onPlaying() {
      return html$.GlobalEventHandlers.playingEvent.forTarget(this);
    }
    get onRateChange() {
      return html$.GlobalEventHandlers.rateChangeEvent.forTarget(this);
    }
    get onReset() {
      return html$.GlobalEventHandlers.resetEvent.forTarget(this);
    }
    get onResize() {
      return html$.GlobalEventHandlers.resizeEvent.forTarget(this);
    }
    get onScroll() {
      return html$.GlobalEventHandlers.scrollEvent.forTarget(this);
    }
    get onSeeked() {
      return html$.GlobalEventHandlers.seekedEvent.forTarget(this);
    }
    get onSeeking() {
      return html$.GlobalEventHandlers.seekingEvent.forTarget(this);
    }
    get onSelect() {
      return html$.GlobalEventHandlers.selectEvent.forTarget(this);
    }
    get onStalled() {
      return html$.GlobalEventHandlers.stalledEvent.forTarget(this);
    }
    get onSubmit() {
      return html$.GlobalEventHandlers.submitEvent.forTarget(this);
    }
    get onSuspend() {
      return html$.GlobalEventHandlers.suspendEvent.forTarget(this);
    }
    get onTimeUpdate() {
      return html$.GlobalEventHandlers.timeUpdateEvent.forTarget(this);
    }
    get onVolumeChange() {
      return html$.GlobalEventHandlers.volumeChangeEvent.forTarget(this);
    }
    get onWaiting() {
      return html$.GlobalEventHandlers.waitingEvent.forTarget(this);
    }
  };
  html$.GlobalEventHandlers[dart.implements] = () => [html$.EventTarget];
  dart.setSignature(html$.GlobalEventHandlers, {
    constructors: () => ({_: dart.definiteFunctionType(html$.GlobalEventHandlers, [])})
  });
  dart.defineExtensionMembers(html$.GlobalEventHandlers, [
    'onAbort',
    'onBlur',
    'onCanPlay',
    'onCanPlayThrough',
    'onChange',
    'onClick',
    'onContextMenu',
    'onDoubleClick',
    'onDrag',
    'onDragEnd',
    'onDragEnter',
    'onDragLeave',
    'onDragOver',
    'onDragStart',
    'onDrop',
    'onDurationChange',
    'onEmptied',
    'onEnded',
    'onError',
    'onFocus',
    'onInput',
    'onInvalid',
    'onKeyDown',
    'onKeyPress',
    'onKeyUp',
    'onLoad',
    'onLoadedData',
    'onLoadedMetadata',
    'onMouseDown',
    'onMouseEnter',
    'onMouseLeave',
    'onMouseMove',
    'onMouseOut',
    'onMouseOver',
    'onMouseUp',
    'onMouseWheel',
    'onPause',
    'onPlay',
    'onPlaying',
    'onRateChange',
    'onReset',
    'onResize',
    'onScroll',
    'onSeeked',
    'onSeeking',
    'onSelect',
    'onStalled',
    'onSubmit',
    'onSuspend',
    'onTimeUpdate',
    'onVolumeChange',
    'onWaiting'
  ]);
  dart.defineLazy(html$.GlobalEventHandlers, {
    get abortEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('abort'));
    },
    get blurEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('blur'));
    },
    get canPlayEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('canplay'));
    },
    get canPlayThroughEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('canplaythrough'));
    },
    get changeEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('change'));
    },
    get clickEvent() {
      return dart.const(new (EventStreamProviderOfMouseEvent())('click'));
    },
    get contextMenuEvent() {
      return dart.const(new (EventStreamProviderOfMouseEvent())('contextmenu'));
    },
    get doubleClickEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('dblclick'));
    },
    get dragEvent() {
      return dart.const(new (EventStreamProviderOfMouseEvent())('drag'));
    },
    get dragEndEvent() {
      return dart.const(new (EventStreamProviderOfMouseEvent())('dragend'));
    },
    get dragEnterEvent() {
      return dart.const(new (EventStreamProviderOfMouseEvent())('dragenter'));
    },
    get dragLeaveEvent() {
      return dart.const(new (EventStreamProviderOfMouseEvent())('dragleave'));
    },
    get dragOverEvent() {
      return dart.const(new (EventStreamProviderOfMouseEvent())('dragover'));
    },
    get dragStartEvent() {
      return dart.const(new (EventStreamProviderOfMouseEvent())('dragstart'));
    },
    get dropEvent() {
      return dart.const(new (EventStreamProviderOfMouseEvent())('drop'));
    },
    get durationChangeEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('durationchange'));
    },
    get emptiedEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('emptied'));
    },
    get endedEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('ended'));
    },
    get errorEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('error'));
    },
    get focusEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('focus'));
    },
    get inputEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('input'));
    },
    get invalidEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('invalid'));
    },
    get keyDownEvent() {
      return dart.const(new (EventStreamProviderOfKeyboardEvent())('keydown'));
    },
    get keyPressEvent() {
      return dart.const(new (EventStreamProviderOfKeyboardEvent())('keypress'));
    },
    get keyUpEvent() {
      return dart.const(new (EventStreamProviderOfKeyboardEvent())('keyup'));
    },
    get loadEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('load'));
    },
    get loadedDataEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('loadeddata'));
    },
    get loadedMetadataEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('loadedmetadata'));
    },
    get mouseDownEvent() {
      return dart.const(new (EventStreamProviderOfMouseEvent())('mousedown'));
    },
    get mouseEnterEvent() {
      return dart.const(new (EventStreamProviderOfMouseEvent())('mouseenter'));
    },
    get mouseLeaveEvent() {
      return dart.const(new (EventStreamProviderOfMouseEvent())('mouseleave'));
    },
    get mouseMoveEvent() {
      return dart.const(new (EventStreamProviderOfMouseEvent())('mousemove'));
    },
    get mouseOutEvent() {
      return dart.const(new (EventStreamProviderOfMouseEvent())('mouseout'));
    },
    get mouseOverEvent() {
      return dart.const(new (EventStreamProviderOfMouseEvent())('mouseover'));
    },
    get mouseUpEvent() {
      return dart.const(new (EventStreamProviderOfMouseEvent())('mouseup'));
    },
    get mouseWheelEvent() {
      return dart.const(new (EventStreamProviderOfWheelEvent())('mousewheel'));
    },
    get pauseEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('pause'));
    },
    get playEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('play'));
    },
    get playingEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('playing'));
    },
    get rateChangeEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('ratechange'));
    },
    get resetEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('reset'));
    },
    get resizeEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('resize'));
    },
    get scrollEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('scroll'));
    },
    get seekedEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('seeked'));
    },
    get seekingEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('seeking'));
    },
    get selectEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('select'));
    },
    get stalledEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('stalled'));
    },
    get submitEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('submit'));
    },
    get suspendEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('suspend'));
    },
    get timeUpdateEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('timeupdate'));
    },
    get volumeChangeEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('volumechange'));
    },
    get waitingEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('waiting'));
    }
  });
  dart.defineExtensionNames([
    'color'
  ]);
  html$.HRElement = class HRElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return html$.HRElement._check(html$.document[dartx.createElement]("hr"));
    }
    created() {
      this[dartx.color] = null;
      super.created();
    }
    get [dartx.color]() {
      return this.color;
    }
    set [dartx.color](value) {
      this.color = value;
    }
  };
  dart.defineNamedConstructor(html$.HRElement, 'created');
  dart.setSignature(html$.HRElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.HRElement, []),
      new: dart.definiteFunctionType(html$.HRElement, []),
      created: dart.definiteFunctionType(html$.HRElement, [])
    })
  });
  dart.registerExtension(dart.global.HTMLHRElement, html$.HRElement);
  const _initHashChangeEvent = Symbol('_initHashChangeEvent');
  dart.defineExtensionNames([
    'newUrl',
    'oldUrl'
  ]);
  html$.HashChangeEvent = class HashChangeEvent extends html$.Event {
    static new(type, opts) {
      let canBubble = opts && 'canBubble' in opts ? opts.canBubble : true;
      let cancelable = opts && 'cancelable' in opts ? opts.cancelable : true;
      let oldUrl = opts && 'oldUrl' in opts ? opts.oldUrl : null;
      let newUrl = opts && 'newUrl' in opts ? opts.newUrl : null;
      let options = dart.map({canBubble: canBubble, cancelable: cancelable, oldURL: oldUrl, newURL: newUrl});
      return new HashChangeEvent(type, html_common.convertDartToNative_Dictionary(options));
    }
    static _(type, eventInitDict) {
      if (eventInitDict === void 0) eventInitDict = null;
      if (eventInitDict != null) {
        let eventInitDict_1 = html_common.convertDartToNative_Dictionary(eventInitDict);
        return html$.HashChangeEvent._create_1(type, eventInitDict_1);
      }
      return html$.HashChangeEvent._create_2(type);
    }
    static _create_1(type, eventInitDict) {
      return new HashChangeEvent(type, eventInitDict);
    }
    static _create_2(type) {
      return new HashChangeEvent(type);
    }
    static get supported() {
      return html_common.Device.isEventTypeSupported('HashChangeEvent');
    }
    get [dartx.newUrl]() {
      return this.newURL;
    }
    get [dartx.oldUrl]() {
      return this.oldURL;
    }
    [_initHashChangeEvent](type, canBubble, cancelable, oldURL, newURL) {
      return this.initHashChangeEvent(type, canBubble, cancelable, oldURL, newURL);
    }
  };
  dart.setSignature(html$.HashChangeEvent, {
    constructors: () => ({
      new: dart.definiteFunctionType(html$.HashChangeEvent, [core.String], {canBubble: core.bool, cancelable: core.bool, oldUrl: core.String, newUrl: core.String}),
      _: dart.definiteFunctionType(html$.HashChangeEvent, [core.String], [core.Map])
    }),
    methods: () => ({[_initHashChangeEvent]: dart.definiteFunctionType(dart.void, [core.String, core.bool, core.bool, core.String, core.String])}),
    statics: () => ({
      _create_1: dart.definiteFunctionType(html$.HashChangeEvent, [dart.dynamic, dart.dynamic]),
      _create_2: dart.definiteFunctionType(html$.HashChangeEvent, [dart.dynamic])
    }),
    names: ['_create_1', '_create_2']
  });
  dart.registerExtension(dart.global.HashChangeEvent, html$.HashChangeEvent);
  html$.HeadElement = class HeadElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return html$.HeadElement._check(html$.document[dartx.createElement]("head"));
    }
    created() {
      super.created();
    }
  };
  dart.defineNamedConstructor(html$.HeadElement, 'created');
  dart.setSignature(html$.HeadElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.HeadElement, []),
      new: dart.definiteFunctionType(html$.HeadElement, []),
      created: dart.definiteFunctionType(html$.HeadElement, [])
    })
  });
  dart.registerExtension(dart.global.HTMLHeadElement, html$.HeadElement);
  html$.Headers = class Headers extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(input) {
      if (input === void 0) input = null;
      if (input == null) {
        return html$.Headers._create_1();
      }
      if (html$.Headers.is(input)) {
        return html$.Headers._create_2(input);
      }
      if (core.Map.is(input)) {
        let input_1 = html_common.convertDartToNative_Dictionary(input);
        return html$.Headers._create_3(input_1);
      }
      if (ListOfObject().is(input)) {
        return html$.Headers._create_4(input);
      }
      dart.throw(new core.ArgumentError("Incorrect number or type of arguments"));
    }
    static _create_1() {
      return new Headers();
    }
    static _create_2(input) {
      return new Headers(input);
    }
    static _create_3(input) {
      return new Headers(input);
    }
    static _create_4(input) {
      return new Headers(input);
    }
  };
  dart.setSignature(html$.Headers, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.Headers, []),
      new: dart.definiteFunctionType(html$.Headers, [], [dart.dynamic])
    }),
    statics: () => ({
      _create_1: dart.definiteFunctionType(html$.Headers, []),
      _create_2: dart.definiteFunctionType(html$.Headers, [dart.dynamic]),
      _create_3: dart.definiteFunctionType(html$.Headers, [dart.dynamic]),
      _create_4: dart.definiteFunctionType(html$.Headers, [dart.dynamic])
    }),
    names: ['_create_1', '_create_2', '_create_3', '_create_4']
  });
  dart.registerExtension(dart.global.Headers, html$.Headers);
  html$.HeadingElement = class HeadingElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static h1() {
      return html$.HeadingElement._check(html$.document[dartx.createElement]("h1"));
    }
    static h2() {
      return html$.HeadingElement._check(html$.document[dartx.createElement]("h2"));
    }
    static h3() {
      return html$.HeadingElement._check(html$.document[dartx.createElement]("h3"));
    }
    static h4() {
      return html$.HeadingElement._check(html$.document[dartx.createElement]("h4"));
    }
    static h5() {
      return html$.HeadingElement._check(html$.document[dartx.createElement]("h5"));
    }
    static h6() {
      return html$.HeadingElement._check(html$.document[dartx.createElement]("h6"));
    }
    created() {
      super.created();
    }
  };
  dart.defineNamedConstructor(html$.HeadingElement, 'created');
  dart.setSignature(html$.HeadingElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.HeadingElement, []),
      h1: dart.definiteFunctionType(html$.HeadingElement, []),
      h2: dart.definiteFunctionType(html$.HeadingElement, []),
      h3: dart.definiteFunctionType(html$.HeadingElement, []),
      h4: dart.definiteFunctionType(html$.HeadingElement, []),
      h5: dart.definiteFunctionType(html$.HeadingElement, []),
      h6: dart.definiteFunctionType(html$.HeadingElement, []),
      created: dart.definiteFunctionType(html$.HeadingElement, [])
    })
  });
  dart.registerExtension(dart.global.HTMLHeadingElement, html$.HeadingElement);
  const _get_options = Symbol('_get_options');
  const _get_state = Symbol('_get_state');
  const _pushState_1 = Symbol('_pushState_1');
  const _pushState_2 = Symbol('_pushState_2');
  const _replaceState_1 = Symbol('_replaceState_1');
  const _replaceState_2 = Symbol('_replaceState_2');
  dart.defineExtensionNames([
    'options',
    'state',
    'back',
    'forward',
    'go',
    'pushState',
    'replaceState',
    'length'
  ]);
  html$.History = class History extends _interceptors.Interceptor {
    static get supportsState() {
      return !!window.history.pushState;
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.length]() {
      return this.length;
    }
    get [dartx.options]() {
      return html_common.convertNativeToDart_Dictionary(this[_get_options]);
    }
    get [_get_options]() {
      return this.options;
    }
    get [dartx.state]() {
      return html_common.convertNativeToDart_SerializedScriptValue(this[_get_state]);
    }
    get [_get_state]() {
      return this.state;
    }
    [dartx.back]() {
      return this.back();
    }
    [dartx.forward]() {
      return this.forward();
    }
    [dartx.go](delta) {
      return this.go(delta);
    }
    [dartx.pushState](data, title, url, options) {
      if (options === void 0) options = null;
      if (options != null) {
        let data_1 = html_common.convertDartToNative_SerializedScriptValue(data);
        let options_2 = html_common.convertDartToNative_Dictionary(options);
        this[_pushState_1](data_1, title, url, options_2);
        return;
      }
      let data_1 = html_common.convertDartToNative_SerializedScriptValue(data);
      this[_pushState_2](data_1, title, url);
      return;
    }
    [_pushState_1](data, title, url, options) {
      return this.pushState(data, title, url, options);
    }
    [_pushState_2](data, title, url) {
      return this.pushState(data, title, url);
    }
    [dartx.replaceState](data, title, url, options) {
      if (options === void 0) options = null;
      if (options != null) {
        let data_1 = html_common.convertDartToNative_SerializedScriptValue(data);
        let options_2 = html_common.convertDartToNative_Dictionary(options);
        this[_replaceState_1](data_1, title, url, options_2);
        return;
      }
      let data_1 = html_common.convertDartToNative_SerializedScriptValue(data);
      this[_replaceState_2](data_1, title, url);
      return;
    }
    [_replaceState_1](data, title, url, options) {
      return this.replaceState(data, title, url, options);
    }
    [_replaceState_2](data, title, url) {
      return this.replaceState(data, title, url);
    }
  };
  html$.History[dart.implements] = () => [html$.HistoryBase];
  dart.setSignature(html$.History, {
    constructors: () => ({_: dart.definiteFunctionType(html$.History, [])}),
    methods: () => ({
      [dartx.back]: dart.definiteFunctionType(dart.void, []),
      [dartx.forward]: dart.definiteFunctionType(dart.void, []),
      [dartx.go]: dart.definiteFunctionType(dart.void, [], [core.int]),
      [dartx.pushState]: dart.definiteFunctionType(dart.void, [dart.dynamic, core.String, core.String], [core.Map]),
      [_pushState_1]: dart.definiteFunctionType(dart.void, [dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic]),
      [_pushState_2]: dart.definiteFunctionType(dart.void, [dart.dynamic, dart.dynamic, dart.dynamic]),
      [dartx.replaceState]: dart.definiteFunctionType(dart.void, [dart.dynamic, core.String, core.String], [core.Map]),
      [_replaceState_1]: dart.definiteFunctionType(dart.void, [dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic]),
      [_replaceState_2]: dart.definiteFunctionType(dart.void, [dart.dynamic, dart.dynamic, dart.dynamic])
    })
  });
  dart.registerExtension(dart.global.History, html$.History);
  dart.defineExtensionNames([
    'deviceId',
    'deviceName',
    'hardwareUnitId'
  ]);
  html$.VRDevice = class VRDevice extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.deviceId]() {
      return this.deviceId;
    }
    get [dartx.deviceName]() {
      return this.deviceName;
    }
    get [dartx.hardwareUnitId]() {
      return this.hardwareUnitId;
    }
  };
  dart.setSignature(html$.VRDevice, {
    constructors: () => ({_: dart.definiteFunctionType(html$.VRDevice, [])})
  });
  dart.registerExtension(dart.global.VRDevice, html$.VRDevice);
  dart.defineExtensionNames([
    'getEyeParameters',
    'setFieldOfView'
  ]);
  html$.HmdvrDevice = class HmdvrDevice extends html$.VRDevice {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [dartx.getEyeParameters](whichEye) {
      return this.getEyeParameters(whichEye);
    }
    [dartx.setFieldOfView](leftFov, rightFov) {
      return this.setFieldOfView(leftFov, rightFov);
    }
  };
  dart.setSignature(html$.HmdvrDevice, {
    constructors: () => ({_: dart.definiteFunctionType(html$.HmdvrDevice, [])}),
    methods: () => ({
      [dartx.getEyeParameters]: dart.definiteFunctionType(html$.VREyeParameters, [core.String]),
      [dartx.setFieldOfView]: dart.definiteFunctionType(dart.void, [], [html$.VRFieldOfView, html$.VRFieldOfView])
    })
  });
  dart.registerExtension(dart.global.HMDVRDevice, html$.HmdvrDevice);
  dart.defineExtensionNames([
    'length',
    'get',
    'set',
    'length',
    'first',
    'last',
    'single',
    'elementAt',
    'item',
    'namedItem'
  ]);
  html$.HtmlCollection = class HtmlCollection extends dart.mixin(_interceptors.Interceptor, collection.ListMixin$(html$.Node), html$.ImmutableListMixin$(html$.Node)) {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.length]() {
      return this.length;
    }
    [dartx.get](index) {
      if (index >>> 0 !== index || index >= this[dartx.length]) dart.throw(core.RangeError.index(index, this));
      return this[index];
    }
    [dartx.set](index, value) {
      dart.throw(new core.UnsupportedError("Cannot assign element of immutable List."));
      return value;
    }
    set [dartx.length](value) {
      dart.throw(new core.UnsupportedError("Cannot resize immutable List."));
    }
    get [dartx.first]() {
      if (dart.notNull(this[dartx.length]) > 0) {
        return this[0];
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.last]() {
      let len = this[dartx.length];
      if (dart.notNull(len) > 0) {
        return this[dart.notNull(len) - 1];
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.single]() {
      let len = this[dartx.length];
      if (len == 1) {
        return this[0];
      }
      if (len == 0) dart.throw(new core.StateError("No elements"));
      dart.throw(new core.StateError("More than one element"));
    }
    [dartx.elementAt](index) {
      return this[dartx.get](index);
    }
    [dartx.item](index) {
      return this.item(index);
    }
    [dartx.namedItem](name) {
      return this.namedItem(name);
    }
  };
  html$.HtmlCollection[dart.implements] = () => [_js_helper.JavaScriptIndexingBehavior, ListOfNode()];
  dart.setSignature(html$.HtmlCollection, {
    constructors: () => ({_: dart.definiteFunctionType(html$.HtmlCollection, [])}),
    methods: () => ({
      [dartx.get]: dart.definiteFunctionType(html$.Node, [core.int]),
      [dartx.set]: dart.definiteFunctionType(dart.void, [core.int, html$.Node]),
      [dartx.elementAt]: dart.definiteFunctionType(html$.Node, [core.int]),
      [dartx.item]: dart.definiteFunctionType(html$.Node, [core.int]),
      [dartx.namedItem]: dart.definiteFunctionType(core.Object, [core.String])
    })
  });
  dart.registerExtension(dart.global.HTMLCollection, html$.HtmlCollection);
  dart.defineExtensionNames([
    'caretRangeFromPoint',
    'elementFromPoint',
    'getCssCanvasContext',
    'head',
    'lastModified',
    'preferredStylesheetSet',
    'referrer',
    'selectedStylesheetSet',
    'selectedStylesheetSet',
    'styleSheets',
    'title',
    'title',
    'exitFullscreen',
    'registerElement',
    'register',
    'onVisibilityChange',
    'createElementUpgrader',
    'body'
  ]);
  html$.HtmlDocument = class HtmlDocument extends html$.Document {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.body]() {
      return this.body;
    }
    set [dartx.body](value) {
      this.body = value;
    }
    [dartx.caretRangeFromPoint](x, y) {
      return this[_caretRangeFromPoint](x, y);
    }
    [dartx.elementFromPoint](x, y) {
      return this[_elementFromPoint](x, y);
    }
    static get supportsCssCanvasContext() {
      return !!document.getCSSCanvasContext;
    }
    [dartx.getCssCanvasContext](contextId, name, width, height) {
      return html$.CanvasRenderingContext._check(this[_getCssCanvasContext](contextId, name, width, height));
    }
    get [dartx.head]() {
      return this[_head$];
    }
    get [dartx.lastModified]() {
      return this[_lastModified];
    }
    get [dartx.preferredStylesheetSet]() {
      return this[_preferredStylesheetSet];
    }
    get [dartx.referrer]() {
      return this[_referrer];
    }
    get [dartx.selectedStylesheetSet]() {
      return this[_selectedStylesheetSet];
    }
    set [dartx.selectedStylesheetSet](value) {
      this[_selectedStylesheetSet] = value;
    }
    get [dartx.styleSheets]() {
      return this[_styleSheets];
    }
    get [dartx.title]() {
      return this[_title];
    }
    set [dartx.title](value) {
      this[_title] = value;
    }
    [dartx.exitFullscreen]() {
      this[_webkitExitFullscreen]();
    }
    [dartx.registerElement](tag, customElementClass, opts) {
      let extendsTag = opts && 'extendsTag' in opts ? opts.extendsTag : null;
      html$._registerCustomElement(window, this, tag, customElementClass, extendsTag);
    }
    [dartx.register](tag, customElementClass, opts) {
      let extendsTag = opts && 'extendsTag' in opts ? opts.extendsTag : null;
      return this[dartx.registerElement](tag, customElementClass, {extendsTag: extendsTag});
    }
    static _determineVisibilityChangeEventType(e) {
      if (typeof e.hidden !== "undefined") {
        return 'visibilitychange';
      } else if (typeof e.mozHidden !== "undefined") {
        return 'mozvisibilitychange';
      } else if (typeof e.msHidden !== "undefined") {
        return 'msvisibilitychange';
      } else if (typeof e.webkitHidden !== "undefined") {
        return 'webkitvisibilitychange';
      }
      return 'visibilitychange';
    }
    get [dartx.onVisibilityChange]() {
      return html$.HtmlDocument.visibilityChangeEvent.forTarget(this);
    }
    [dartx.createElementUpgrader](type, opts) {
      let extendsTag = opts && 'extendsTag' in opts ? opts.extendsTag : null;
      return new html$._JSElementUpgrader(this, type, extendsTag);
    }
  };
  dart.setSignature(html$.HtmlDocument, {
    constructors: () => ({_: dart.definiteFunctionType(html$.HtmlDocument, [])}),
    methods: () => ({
      [dartx.caretRangeFromPoint]: dart.definiteFunctionType(html$.Range, [core.int, core.int]),
      [dartx.elementFromPoint]: dart.definiteFunctionType(html$.Element, [core.int, core.int]),
      [dartx.getCssCanvasContext]: dart.definiteFunctionType(html$.CanvasRenderingContext, [core.String, core.String, core.int, core.int]),
      [dartx.registerElement]: dart.definiteFunctionType(dart.void, [core.String, core.Type], {extendsTag: core.String}),
      [dartx.register]: dart.definiteFunctionType(dart.void, [core.String, core.Type], {extendsTag: core.String}),
      [dartx.createElementUpgrader]: dart.definiteFunctionType(html$.ElementUpgrader, [core.Type], {extendsTag: core.String})
    }),
    statics: () => ({_determineVisibilityChangeEventType: dart.definiteFunctionType(core.String, [html$.EventTarget])}),
    names: ['_determineVisibilityChangeEventType']
  });
  dart.defineLazy(html$.HtmlDocument, {
    get visibilityChangeEvent() {
      return dart.const(new (_CustomEventStreamProviderOfEvent())(html$.HtmlDocument._determineVisibilityChangeEventType));
    }
  });
  dart.registerExtension(dart.global.HTMLDocument, html$.HtmlDocument);
  dart.defineExtensionNames([
    'item',
    'namedItem'
  ]);
  html$.HtmlFormControlsCollection = class HtmlFormControlsCollection extends html$.HtmlCollection {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [dartx.item](index) {
      return this.item(index);
    }
    [dartx.namedItem](name) {
      return this.namedItem(name);
    }
  };
  dart.setSignature(html$.HtmlFormControlsCollection, {
    constructors: () => ({_: dart.definiteFunctionType(html$.HtmlFormControlsCollection, [])})
  });
  dart.registerExtension(dart.global.HTMLFormControlsCollection, html$.HtmlFormControlsCollection);
  html$.HtmlHtmlElement = class HtmlHtmlElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return html$.HtmlHtmlElement._check(html$.document[dartx.createElement]("html"));
    }
    created() {
      super.created();
    }
  };
  dart.defineNamedConstructor(html$.HtmlHtmlElement, 'created');
  dart.setSignature(html$.HtmlHtmlElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.HtmlHtmlElement, []),
      new: dart.definiteFunctionType(html$.HtmlHtmlElement, []),
      created: dart.definiteFunctionType(html$.HtmlHtmlElement, [])
    })
  });
  dart.registerExtension(dart.global.HTMLHtmlElement, html$.HtmlHtmlElement);
  const _item = Symbol('_item');
  html$.HtmlOptionsCollection = class HtmlOptionsCollection extends html$.HtmlCollection {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [_item](index) {
      return this.item(index);
    }
  };
  dart.setSignature(html$.HtmlOptionsCollection, {
    constructors: () => ({_: dart.definiteFunctionType(html$.HtmlOptionsCollection, [])}),
    methods: () => ({[_item]: dart.definiteFunctionType(html$.Node, [core.int])})
  });
  dart.registerExtension(dart.global.HTMLOptionsCollection, html$.HtmlOptionsCollection);
  const _get_response = Symbol('_get_response');
  dart.defineExtensionNames([
    'onAbort',
    'onError',
    'onLoad',
    'onLoadEnd',
    'onLoadStart',
    'onProgress',
    'onTimeout'
  ]);
  html$.HttpRequestEventTarget = class HttpRequestEventTarget extends html$.EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.onAbort]() {
      return html$.HttpRequestEventTarget.abortEvent.forTarget(this);
    }
    get [dartx.onError]() {
      return html$.HttpRequestEventTarget.errorEvent.forTarget(this);
    }
    get [dartx.onLoad]() {
      return html$.HttpRequestEventTarget.loadEvent.forTarget(this);
    }
    get [dartx.onLoadEnd]() {
      return html$.HttpRequestEventTarget.loadEndEvent.forTarget(this);
    }
    get [dartx.onLoadStart]() {
      return html$.HttpRequestEventTarget.loadStartEvent.forTarget(this);
    }
    get [dartx.onProgress]() {
      return html$.HttpRequestEventTarget.progressEvent.forTarget(this);
    }
    get [dartx.onTimeout]() {
      return html$.HttpRequestEventTarget.timeoutEvent.forTarget(this);
    }
  };
  dart.setSignature(html$.HttpRequestEventTarget, {
    constructors: () => ({_: dart.definiteFunctionType(html$.HttpRequestEventTarget, [])})
  });
  dart.defineLazy(html$.HttpRequestEventTarget, {
    get abortEvent() {
      return dart.const(new (EventStreamProviderOfProgressEvent())('abort'));
    },
    get errorEvent() {
      return dart.const(new (EventStreamProviderOfProgressEvent())('error'));
    },
    get loadEvent() {
      return dart.const(new (EventStreamProviderOfProgressEvent())('load'));
    },
    get loadEndEvent() {
      return dart.const(new (EventStreamProviderOfProgressEvent())('loadend'));
    },
    get loadStartEvent() {
      return dart.const(new (EventStreamProviderOfProgressEvent())('loadstart'));
    },
    get progressEvent() {
      return dart.const(new (EventStreamProviderOfProgressEvent())('progress'));
    },
    get timeoutEvent() {
      return dart.const(new (EventStreamProviderOfProgressEvent())('timeout'));
    }
  });
  dart.registerExtension(dart.global.XMLHttpRequestEventTarget, html$.HttpRequestEventTarget);
  dart.defineExtensionNames([
    'responseHeaders',
    'open',
    'response',
    'abort',
    'getAllResponseHeaders',
    'getResponseHeader',
    'overrideMimeType',
    'send',
    'setRequestHeader',
    'onReadyStateChange',
    'readyState',
    'responseText',
    'responseType',
    'responseUrl',
    'responseXml',
    'status',
    'statusText',
    'timeout',
    'upload',
    'withCredentials'
  ]);
  html$.HttpRequest = class HttpRequest extends html$.HttpRequestEventTarget {
    static getString(url, opts) {
      let withCredentials = opts && 'withCredentials' in opts ? opts.withCredentials : null;
      let onProgress = opts && 'onProgress' in opts ? opts.onProgress : null;
      return html$.HttpRequest.request(url, {withCredentials: withCredentials, onProgress: onProgress}).then(core.String)(dart.fn(xhr => xhr[dartx.responseText], HttpRequestToString()));
    }
    static postFormData(url, data, opts) {
      let withCredentials = opts && 'withCredentials' in opts ? opts.withCredentials : null;
      let responseType = opts && 'responseType' in opts ? opts.responseType : null;
      let requestHeaders = opts && 'requestHeaders' in opts ? opts.requestHeaders : null;
      let onProgress = opts && 'onProgress' in opts ? opts.onProgress : null;
      let parts = [];
      data[dartx.forEach](dart.fn((key, value) => {
        parts[dartx.add](dart.str`${core.Uri.encodeQueryComponent(key)}=` + dart.str`${core.Uri.encodeQueryComponent(value)}`);
      }, StringAndStringTovoid()));
      let formData = parts[dartx.join]('&');
      if (requestHeaders == null) {
        requestHeaders = dart.map({}, core.String, core.String);
      }
      requestHeaders[dartx.putIfAbsent]('Content-Type', dart.fn(() => 'application/x-www-form-urlencoded; charset=UTF-8', VoidToString$()));
      return html$.HttpRequest.request(url, {method: 'POST', withCredentials: withCredentials, responseType: responseType, requestHeaders: requestHeaders, sendData: formData, onProgress: onProgress});
    }
    static request(url, opts) {
      let method = opts && 'method' in opts ? opts.method : null;
      let withCredentials = opts && 'withCredentials' in opts ? opts.withCredentials : null;
      let responseType = opts && 'responseType' in opts ? opts.responseType : null;
      let mimeType = opts && 'mimeType' in opts ? opts.mimeType : null;
      let requestHeaders = opts && 'requestHeaders' in opts ? opts.requestHeaders : null;
      let sendData = opts && 'sendData' in opts ? opts.sendData : null;
      let onProgress = opts && 'onProgress' in opts ? opts.onProgress : null;
      let completer = CompleterOfHttpRequest().new();
      let xhr = html$.HttpRequest.new();
      if (method == null) {
        method = 'GET';
      }
      xhr[dartx.open](method, url, {async: true});
      if (withCredentials != null) {
        xhr[dartx.withCredentials] = withCredentials;
      }
      if (responseType != null) {
        xhr[dartx.responseType] = responseType;
      }
      if (mimeType != null) {
        xhr[dartx.overrideMimeType](mimeType);
      }
      if (requestHeaders != null) {
        requestHeaders[dartx.forEach](dart.fn((header, value) => {
          xhr[dartx.setRequestHeader](header, value);
        }, StringAndStringTovoid()));
      }
      if (onProgress != null) {
        xhr[dartx.onProgress].listen(onProgress);
      }
      xhr[dartx.onLoad].listen(dart.fn(e => {
        let accepted = dart.notNull(xhr[dartx.status]) >= 200 && dart.notNull(xhr[dartx.status]) < 300;
        let fileUri = xhr[dartx.status] == 0;
        let notModified = xhr[dartx.status] == 304;
        let unknownRedirect = dart.notNull(xhr[dartx.status]) > 307 && dart.notNull(xhr[dartx.status]) < 400;
        if (accepted || fileUri || notModified || unknownRedirect) {
          completer.complete(xhr);
        } else {
          completer.completeError(e);
        }
      }, ProgressEventTovoid$()));
      xhr[dartx.onError].listen(dart.bind(completer, 'completeError'));
      if (sendData != null) {
        xhr[dartx.send](sendData);
      } else {
        xhr[dartx.send]();
      }
      return completer.future;
    }
    static get supportsProgressEvent() {
      let xhr = html$.HttpRequest.new();
      return "onprogress" in xhr;
    }
    static get supportsCrossOrigin() {
      let xhr = html$.HttpRequest.new();
      return "withCredentials" in xhr;
    }
    static get supportsLoadEndEvent() {
      let xhr = html$.HttpRequest.new();
      return "onloadend" in xhr;
    }
    static get supportsOverrideMimeType() {
      let xhr = html$.HttpRequest.new();
      return "overrideMimeType" in xhr;
    }
    static requestCrossOrigin(url, opts) {
      let method = opts && 'method' in opts ? opts.method : null;
      let sendData = opts && 'sendData' in opts ? opts.sendData : null;
      if (dart.test(html$.HttpRequest.supportsCrossOrigin)) {
        return html$.HttpRequest.request(url, {method: method, sendData: sendData}).then(core.String)(dart.fn(xhr => xhr[dartx.responseText], HttpRequestToString()));
      }
      let completer = CompleterOfString().new();
      if (method == null) {
        method = 'GET';
      }
      let xhr = new XDomainRequest();
      xhr.open(method, url);
      xhr.onload = _js_helper.convertDartClosureToJS(dynamicTodynamic())(dart.fn(e => {
        let response = xhr.responseText;
        completer.complete(response);
      }, dynamicTodynamic$()), 1);
      xhr.onerror = _js_helper.convertDartClosureToJS(dynamicTodynamic())(dart.fn(e => {
        completer.completeError(e);
      }, dynamicTodynamic$()), 1);
      xhr.onprogress = {};
      xhr.ontimeout = {};
      xhr.timeout = Number.MAX_VALUE;
      if (sendData != null) {
        xhr.send(sendData);
      } else {
        xhr.send();
      }
      return completer.future;
    }
    get [dartx.responseHeaders]() {
      let headers = dart.map({}, core.String, core.String);
      let headersString = this[dartx.getAllResponseHeaders]();
      if (headersString == null) {
        return headers;
      }
      let headersList = headersString[dartx.split]('\r\n');
      for (let header of headersList) {
        if (dart.test(header[dartx.isEmpty])) {
          continue;
        }
        let splitIdx = header[dartx.indexOf](': ');
        if (splitIdx == -1) {
          continue;
        }
        let key = header[dartx.substring](0, splitIdx)[dartx.toLowerCase]();
        let value = header[dartx.substring](dart.notNull(splitIdx) + 2);
        if (dart.test(headers[dartx.containsKey](key))) {
          headers[dartx.set](key, dart.str`${headers[dartx.get](key)}, ${value}`);
        } else {
          headers[dartx.set](key, value);
        }
      }
      return headers;
    }
    [dartx.open](method, url, opts) {
      return this.open(method, url, opts);
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return html$.HttpRequest._create_1();
    }
    static _create_1() {
      return new XMLHttpRequest();
    }
    get [dartx.readyState]() {
      return this.readyState;
    }
    get [dartx.response]() {
      return html$._convertNativeToDart_XHR_Response(this[_get_response]);
    }
    get [_get_response]() {
      return this.response;
    }
    get [dartx.responseText]() {
      return this.responseText;
    }
    get [dartx.responseType]() {
      return this.responseType;
    }
    set [dartx.responseType](value) {
      this.responseType = value;
    }
    get [dartx.responseUrl]() {
      return this.responseURL;
    }
    get [dartx.responseXml]() {
      return this.responseXML;
    }
    get [dartx.status]() {
      return this.status;
    }
    get [dartx.statusText]() {
      return this.statusText;
    }
    get [dartx.timeout]() {
      return this.timeout;
    }
    set [dartx.timeout](value) {
      this.timeout = value;
    }
    get [dartx.upload]() {
      return this.upload;
    }
    get [dartx.withCredentials]() {
      return this.withCredentials;
    }
    set [dartx.withCredentials](value) {
      this.withCredentials = value;
    }
    [dartx.abort]() {
      return this.abort();
    }
    [dartx.getAllResponseHeaders]() {
      return this.getAllResponseHeaders();
    }
    [dartx.getResponseHeader](name) {
      return this.getResponseHeader(name);
    }
    [dartx.overrideMimeType](mime) {
      return this.overrideMimeType(mime);
    }
    [dartx.send](body_OR_data) {
      return this.send(body_OR_data);
    }
    [dartx.setRequestHeader](name, value) {
      return this.setRequestHeader(name, value);
    }
    get [dartx.onReadyStateChange]() {
      return html$.HttpRequest.readyStateChangeEvent.forTarget(this);
    }
  };
  dart.setSignature(html$.HttpRequest, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.HttpRequest, []),
      new: dart.definiteFunctionType(html$.HttpRequest, [])
    }),
    methods: () => ({
      [dartx.open]: dart.definiteFunctionType(dart.void, [core.String, core.String], {async: core.bool, user: core.String, password: core.String}),
      [dartx.abort]: dart.definiteFunctionType(dart.void, []),
      [dartx.getAllResponseHeaders]: dart.definiteFunctionType(core.String, []),
      [dartx.getResponseHeader]: dart.definiteFunctionType(core.String, [core.String]),
      [dartx.overrideMimeType]: dart.definiteFunctionType(dart.void, [core.String]),
      [dartx.send]: dart.definiteFunctionType(dart.void, [], [dart.dynamic]),
      [dartx.setRequestHeader]: dart.definiteFunctionType(dart.void, [core.String, core.String])
    }),
    statics: () => ({
      getString: dart.definiteFunctionType(async.Future$(core.String), [core.String], {withCredentials: core.bool, onProgress: ProgressEventTovoid()}),
      postFormData: dart.definiteFunctionType(async.Future$(html$.HttpRequest), [core.String, core.Map$(core.String, core.String)], {withCredentials: core.bool, responseType: core.String, requestHeaders: MapOfString$String(), onProgress: ProgressEventTovoid()}),
      request: dart.definiteFunctionType(async.Future$(html$.HttpRequest), [core.String], {method: core.String, withCredentials: core.bool, responseType: core.String, mimeType: core.String, requestHeaders: MapOfString$String(), sendData: dart.dynamic, onProgress: ProgressEventTovoid()}),
      requestCrossOrigin: dart.definiteFunctionType(async.Future$(core.String), [core.String], {method: core.String, sendData: core.String}),
      _create_1: dart.definiteFunctionType(html$.HttpRequest, [])
    }),
    names: ['getString', 'postFormData', 'request', 'requestCrossOrigin', '_create_1']
  });
  html$.HttpRequest.DONE = 4;
  html$.HttpRequest.HEADERS_RECEIVED = 2;
  html$.HttpRequest.LOADING = 3;
  html$.HttpRequest.OPENED = 1;
  html$.HttpRequest.UNSENT = 0;
  dart.defineLazy(html$.HttpRequest, {
    get readyStateChangeEvent() {
      return dart.const(new (EventStreamProviderOfProgressEvent())('readystatechange'));
    }
  });
  dart.registerExtension(dart.global.XMLHttpRequest, html$.HttpRequest);
  html$.HttpRequestUpload = class HttpRequestUpload extends html$.HttpRequestEventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(html$.HttpRequestUpload, {
    constructors: () => ({_: dart.definiteFunctionType(html$.HttpRequestUpload, [])})
  });
  dart.registerExtension(dart.global.XMLHttpRequestUpload, html$.HttpRequestUpload);
  const _get_contentWindow = Symbol('_get_contentWindow');
  dart.defineExtensionNames([
    'contentWindow',
    'allowFullscreen',
    'height',
    'name',
    'sandbox',
    'src',
    'srcdoc',
    'width'
  ]);
  html$.IFrameElement = class IFrameElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return html$.IFrameElement._check(html$.document[dartx.createElement]("iframe"));
    }
    created() {
      this[dartx.allowFullscreen] = null;
      this[_get_contentWindow] = null;
      this[dartx.height] = null;
      this[dartx.name] = null;
      this[dartx.sandbox] = null;
      this[dartx.src] = null;
      this[dartx.srcdoc] = null;
      this[dartx.width] = null;
      super.created();
    }
    get [dartx.allowFullscreen]() {
      return this.allowFullscreen;
    }
    set [dartx.allowFullscreen](value) {
      this.allowFullscreen = value;
    }
    get [dartx.contentWindow]() {
      return html$._convertNativeToDart_Window(this[_get_contentWindow]);
    }
    get [_get_contentWindow]() {
      return this.contentWindow;
    }
    get [dartx.height]() {
      return this.height;
    }
    set [dartx.height](value) {
      this.height = value;
    }
    get [dartx.name]() {
      return this.name;
    }
    set [dartx.name](value) {
      this.name = value;
    }
    get [dartx.sandbox]() {
      return this.sandbox;
    }
    get [dartx.src]() {
      return this.src;
    }
    set [dartx.src](value) {
      this.src = value;
    }
    get [dartx.srcdoc]() {
      return this.srcdoc;
    }
    set [dartx.srcdoc](value) {
      this.srcdoc = value;
    }
    get [dartx.width]() {
      return this.width;
    }
    set [dartx.width](value) {
      this.width = value;
    }
  };
  dart.defineNamedConstructor(html$.IFrameElement, 'created');
  dart.setSignature(html$.IFrameElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.IFrameElement, []),
      new: dart.definiteFunctionType(html$.IFrameElement, []),
      created: dart.definiteFunctionType(html$.IFrameElement, [])
    })
  });
  dart.registerExtension(dart.global.HTMLIFrameElement, html$.IFrameElement);
  dart.defineExtensionNames([
    'height',
    'width'
  ]);
  html$.ImageBitmap = class ImageBitmap extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.height]() {
      return this.height;
    }
    get [dartx.width]() {
      return this.width;
    }
  };
  dart.setSignature(html$.ImageBitmap, {
    constructors: () => ({_: dart.definiteFunctionType(html$.ImageBitmap, [])})
  });
  dart.registerExtension(dart.global.ImageBitmap, html$.ImageBitmap);
  dart.defineExtensionNames([
    'data',
    'height',
    'width'
  ]);
  html$.ImageData = class ImageData extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(data_OR_sw, sh_OR_sw, sh) {
      if (sh === void 0) sh = null;
      if (typeof sh_OR_sw == 'number' && typeof data_OR_sw == 'number' && sh == null) {
        return html$.ImageData._create_1(data_OR_sw, sh_OR_sw);
      }
      if (typeof sh_OR_sw == 'number' && typed_data.Uint8ClampedList.is(data_OR_sw) && sh == null) {
        return html$.ImageData._create_2(data_OR_sw, sh_OR_sw);
      }
      if (typeof sh == 'number' && typeof sh_OR_sw == 'number' && typed_data.Uint8ClampedList.is(data_OR_sw)) {
        return html$.ImageData._create_3(data_OR_sw, sh_OR_sw, sh);
      }
      dart.throw(new core.ArgumentError("Incorrect number or type of arguments"));
    }
    static _create_1(data_OR_sw, sh_OR_sw) {
      return new ImageData(data_OR_sw, sh_OR_sw);
    }
    static _create_2(data_OR_sw, sh_OR_sw) {
      return new ImageData(data_OR_sw, sh_OR_sw);
    }
    static _create_3(data_OR_sw, sh_OR_sw, sh) {
      return new ImageData(data_OR_sw, sh_OR_sw, sh);
    }
    get [dartx.data]() {
      return this.data;
    }
    get [dartx.height]() {
      return this.height;
    }
    get [dartx.width]() {
      return this.width;
    }
  };
  dart.setSignature(html$.ImageData, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.ImageData, []),
      new: dart.definiteFunctionType(html$.ImageData, [dart.dynamic, core.int], [core.int])
    }),
    statics: () => ({
      _create_1: dart.definiteFunctionType(html$.ImageData, [dart.dynamic, dart.dynamic]),
      _create_2: dart.definiteFunctionType(html$.ImageData, [dart.dynamic, dart.dynamic]),
      _create_3: dart.definiteFunctionType(html$.ImageData, [dart.dynamic, dart.dynamic, dart.dynamic])
    }),
    names: ['_create_1', '_create_2', '_create_3']
  });
  dart.registerExtension(dart.global.ImageData, html$.ImageData);
  dart.defineExtensionNames([
    'alt',
    'complete',
    'crossOrigin',
    'currentSrc',
    'height',
    'isMap',
    'naturalHeight',
    'naturalWidth',
    'sizes',
    'src',
    'srcset',
    'useMap',
    'width'
  ]);
  html$.ImageElement = class ImageElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(opts) {
      let src = opts && 'src' in opts ? opts.src : null;
      let width = opts && 'width' in opts ? opts.width : null;
      let height = opts && 'height' in opts ? opts.height : null;
      let e = html$.ImageElement._check(html$.document[dartx.createElement]("img"));
      if (src != null) e[dartx.src] = src;
      if (width != null) e[dartx.width] = width;
      if (height != null) e[dartx.height] = height;
      return e;
    }
    created() {
      this[dartx.alt] = null;
      this[dartx.complete] = null;
      this[dartx.crossOrigin] = null;
      this[dartx.currentSrc] = null;
      this[dartx.height] = null;
      this[dartx.isMap] = null;
      this[dartx.naturalHeight] = null;
      this[dartx.naturalWidth] = null;
      this[dartx.sizes] = null;
      this[dartx.src] = null;
      this[dartx.srcset] = null;
      this[dartx.useMap] = null;
      this[dartx.width] = null;
      super.created();
    }
    get [dartx.alt]() {
      return this.alt;
    }
    set [dartx.alt](value) {
      this.alt = value;
    }
    get [dartx.complete]() {
      return this.complete;
    }
    get [dartx.crossOrigin]() {
      return this.crossOrigin;
    }
    set [dartx.crossOrigin](value) {
      this.crossOrigin = value;
    }
    get [dartx.currentSrc]() {
      return this.currentSrc;
    }
    get [dartx.height]() {
      return this.height;
    }
    set [dartx.height](value) {
      this.height = value;
    }
    get [dartx.isMap]() {
      return this.isMap;
    }
    set [dartx.isMap](value) {
      this.isMap = value;
    }
    get [dartx.naturalHeight]() {
      return this.naturalHeight;
    }
    get [dartx.naturalWidth]() {
      return this.naturalWidth;
    }
    get [dartx.sizes]() {
      return this.sizes;
    }
    set [dartx.sizes](value) {
      this.sizes = value;
    }
    get [dartx.src]() {
      return this.src;
    }
    set [dartx.src](value) {
      this.src = value;
    }
    get [dartx.srcset]() {
      return this.srcset;
    }
    set [dartx.srcset](value) {
      this.srcset = value;
    }
    get [dartx.useMap]() {
      return this.useMap;
    }
    set [dartx.useMap](value) {
      this.useMap = value;
    }
    get [dartx.width]() {
      return this.width;
    }
    set [dartx.width](value) {
      this.width = value;
    }
  };
  dart.defineNamedConstructor(html$.ImageElement, 'created');
  html$.ImageElement[dart.implements] = () => [html$.CanvasImageSource];
  dart.setSignature(html$.ImageElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.ImageElement, []),
      new: dart.definiteFunctionType(html$.ImageElement, [], {src: core.String, width: core.int, height: core.int}),
      created: dart.definiteFunctionType(html$.ImageElement, [])
    })
  });
  dart.registerExtension(dart.global.HTMLImageElement, html$.ImageElement);
  dart.defineExtensionNames([
    'inspect'
  ]);
  html$.InjectedScriptHost = class InjectedScriptHost extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [dartx.inspect](objectId, hints) {
      return this.inspect(objectId, hints);
    }
  };
  dart.setSignature(html$.InjectedScriptHost, {
    constructors: () => ({_: dart.definiteFunctionType(html$.InjectedScriptHost, [])}),
    methods: () => ({[dartx.inspect]: dart.definiteFunctionType(dart.void, [core.Object, core.Object])})
  });
  dart.registerExtension(dart.global.InjectedScriptHost, html$.InjectedScriptHost);
  dart.defineExtensionNames([
    'firesTouchEvents'
  ]);
  html$.InputDevice = class InputDevice extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(deviceInitDict) {
      if (deviceInitDict === void 0) deviceInitDict = null;
      if (deviceInitDict != null) {
        let deviceInitDict_1 = html_common.convertDartToNative_Dictionary(deviceInitDict);
        return html$.InputDevice._create_1(deviceInitDict_1);
      }
      return html$.InputDevice._create_2();
    }
    static _create_1(deviceInitDict) {
      return new InputDevice(deviceInitDict);
    }
    static _create_2() {
      return new InputDevice();
    }
    get [dartx.firesTouchEvents]() {
      return this.firesTouchEvents;
    }
  };
  dart.setSignature(html$.InputDevice, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.InputDevice, []),
      new: dart.definiteFunctionType(html$.InputDevice, [], [core.Map])
    }),
    statics: () => ({
      _create_1: dart.definiteFunctionType(html$.InputDevice, [dart.dynamic]),
      _create_2: dart.definiteFunctionType(html$.InputDevice, [])
    }),
    names: ['_create_1', '_create_2']
  });
  dart.registerExtension(dart.global.InputDevice, html$.InputDevice);
  const _get_valueAsDate = Symbol('_get_valueAsDate');
  const _set_valueAsDate = Symbol('_set_valueAsDate');
  dart.defineExtensionNames([
    'valueAsDate',
    'valueAsDate',
    'checkValidity',
    'reportValidity',
    'select',
    'setCustomValidity',
    'setRangeText',
    'setSelectionRange',
    'stepDown',
    'stepUp',
    'accept',
    'alt',
    'autocapitalize',
    'autocomplete',
    'autofocus',
    'capture',
    'checked',
    'defaultChecked',
    'defaultValue',
    'dirName',
    'disabled',
    'files',
    'form',
    'formAction',
    'formEnctype',
    'formMethod',
    'formNoValidate',
    'formTarget',
    'height',
    'incremental',
    'indeterminate',
    'inputMode',
    'labels',
    'list',
    'max',
    'maxLength',
    'min',
    'minLength',
    'multiple',
    'name',
    'pattern',
    'placeholder',
    'readOnly',
    'required',
    'selectionDirection',
    'selectionEnd',
    'selectionStart',
    'size',
    'src',
    'step',
    'type',
    'validationMessage',
    'validity',
    'value',
    'valueAsNumber',
    'entries',
    'directory',
    'width',
    'willValidate'
  ]);
  html$.InputElement = class InputElement extends html$.HtmlElement {
    static new(opts) {
      let type = opts && 'type' in opts ? opts.type : null;
      let e = html$.InputElement._check(html$.document[dartx.createElement]("input"));
      if (type != null) {
        try {
          e[dartx.type] = type;
        } catch (_) {
        }

      }
      return e;
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    created() {
      this[dartx.accept] = null;
      this[dartx.alt] = null;
      this[dartx.autocapitalize] = null;
      this[dartx.autocomplete] = null;
      this[dartx.autofocus] = null;
      this[dartx.capture] = null;
      this[dartx.checked] = null;
      this[dartx.defaultChecked] = null;
      this[dartx.defaultValue] = null;
      this[dartx.dirName] = null;
      this[dartx.disabled] = null;
      this[dartx.files] = null;
      this[dartx.form] = null;
      this[dartx.formAction] = null;
      this[dartx.formEnctype] = null;
      this[dartx.formMethod] = null;
      this[dartx.formNoValidate] = null;
      this[dartx.formTarget] = null;
      this[dartx.height] = null;
      this[dartx.incremental] = null;
      this[dartx.indeterminate] = null;
      this[dartx.inputMode] = null;
      this[dartx.labels] = null;
      this[dartx.list] = null;
      this[dartx.max] = null;
      this[dartx.maxLength] = null;
      this[dartx.min] = null;
      this[dartx.minLength] = null;
      this[dartx.multiple] = null;
      this[dartx.name] = null;
      this[dartx.pattern] = null;
      this[dartx.placeholder] = null;
      this[dartx.readOnly] = null;
      this[dartx.required] = null;
      this[dartx.selectionDirection] = null;
      this[dartx.selectionEnd] = null;
      this[dartx.selectionStart] = null;
      this[dartx.size] = null;
      this[dartx.src] = null;
      this[dartx.step] = null;
      this[dartx.type] = null;
      this[dartx.validationMessage] = null;
      this[dartx.validity] = null;
      this[dartx.value] = null;
      this[_get_valueAsDate] = null;
      this[dartx.valueAsNumber] = null;
      this[dartx.entries] = null;
      this[dartx.directory] = null;
      this[dartx.width] = null;
      this[dartx.willValidate] = null;
      super.created();
    }
    get [dartx.accept]() {
      return this.accept;
    }
    set [dartx.accept](value) {
      this.accept = value;
    }
    get [dartx.alt]() {
      return this.alt;
    }
    set [dartx.alt](value) {
      this.alt = value;
    }
    get [dartx.autocapitalize]() {
      return this.autocapitalize;
    }
    set [dartx.autocapitalize](value) {
      this.autocapitalize = value;
    }
    get [dartx.autocomplete]() {
      return this.autocomplete;
    }
    set [dartx.autocomplete](value) {
      this.autocomplete = value;
    }
    get [dartx.autofocus]() {
      return this.autofocus;
    }
    set [dartx.autofocus](value) {
      this.autofocus = value;
    }
    get [dartx.capture]() {
      return this.capture;
    }
    set [dartx.capture](value) {
      this.capture = value;
    }
    get [dartx.checked]() {
      return this.checked;
    }
    set [dartx.checked](value) {
      this.checked = value;
    }
    get [dartx.defaultChecked]() {
      return this.defaultChecked;
    }
    set [dartx.defaultChecked](value) {
      this.defaultChecked = value;
    }
    get [dartx.defaultValue]() {
      return this.defaultValue;
    }
    set [dartx.defaultValue](value) {
      this.defaultValue = value;
    }
    get [dartx.dirName]() {
      return this.dirName;
    }
    set [dartx.dirName](value) {
      this.dirName = value;
    }
    get [dartx.disabled]() {
      return this.disabled;
    }
    set [dartx.disabled](value) {
      this.disabled = value;
    }
    get [dartx.files]() {
      return this.files;
    }
    set [dartx.files](value) {
      this.files = value;
    }
    get [dartx.form]() {
      return this.form;
    }
    get [dartx.formAction]() {
      return this.formAction;
    }
    set [dartx.formAction](value) {
      this.formAction = value;
    }
    get [dartx.formEnctype]() {
      return this.formEnctype;
    }
    set [dartx.formEnctype](value) {
      this.formEnctype = value;
    }
    get [dartx.formMethod]() {
      return this.formMethod;
    }
    set [dartx.formMethod](value) {
      this.formMethod = value;
    }
    get [dartx.formNoValidate]() {
      return this.formNoValidate;
    }
    set [dartx.formNoValidate](value) {
      this.formNoValidate = value;
    }
    get [dartx.formTarget]() {
      return this.formTarget;
    }
    set [dartx.formTarget](value) {
      this.formTarget = value;
    }
    get [dartx.height]() {
      return this.height;
    }
    set [dartx.height](value) {
      this.height = value;
    }
    get [dartx.incremental]() {
      return this.incremental;
    }
    set [dartx.incremental](value) {
      this.incremental = value;
    }
    get [dartx.indeterminate]() {
      return this.indeterminate;
    }
    set [dartx.indeterminate](value) {
      this.indeterminate = value;
    }
    get [dartx.inputMode]() {
      return this.inputMode;
    }
    set [dartx.inputMode](value) {
      this.inputMode = value;
    }
    get [dartx.labels]() {
      return this.labels;
    }
    get [dartx.list]() {
      return this.list;
    }
    get [dartx.max]() {
      return this.max;
    }
    set [dartx.max](value) {
      this.max = value;
    }
    get [dartx.maxLength]() {
      return this.maxLength;
    }
    set [dartx.maxLength](value) {
      this.maxLength = value;
    }
    get [dartx.min]() {
      return this.min;
    }
    set [dartx.min](value) {
      this.min = value;
    }
    get [dartx.minLength]() {
      return this.minLength;
    }
    set [dartx.minLength](value) {
      this.minLength = value;
    }
    get [dartx.multiple]() {
      return this.multiple;
    }
    set [dartx.multiple](value) {
      this.multiple = value;
    }
    get [dartx.name]() {
      return this.name;
    }
    set [dartx.name](value) {
      this.name = value;
    }
    get [dartx.pattern]() {
      return this.pattern;
    }
    set [dartx.pattern](value) {
      this.pattern = value;
    }
    get [dartx.placeholder]() {
      return this.placeholder;
    }
    set [dartx.placeholder](value) {
      this.placeholder = value;
    }
    get [dartx.readOnly]() {
      return this.readOnly;
    }
    set [dartx.readOnly](value) {
      this.readOnly = value;
    }
    get [dartx.required]() {
      return this.required;
    }
    set [dartx.required](value) {
      this.required = value;
    }
    get [dartx.selectionDirection]() {
      return this.selectionDirection;
    }
    set [dartx.selectionDirection](value) {
      this.selectionDirection = value;
    }
    get [dartx.selectionEnd]() {
      return this.selectionEnd;
    }
    set [dartx.selectionEnd](value) {
      this.selectionEnd = value;
    }
    get [dartx.selectionStart]() {
      return this.selectionStart;
    }
    set [dartx.selectionStart](value) {
      this.selectionStart = value;
    }
    get [dartx.size]() {
      return this.size;
    }
    set [dartx.size](value) {
      this.size = value;
    }
    get [dartx.src]() {
      return this.src;
    }
    set [dartx.src](value) {
      this.src = value;
    }
    get [dartx.step]() {
      return this.step;
    }
    set [dartx.step](value) {
      this.step = value;
    }
    get [dartx.type]() {
      return this.type;
    }
    set [dartx.type](value) {
      this.type = value;
    }
    get [dartx.validationMessage]() {
      return this.validationMessage;
    }
    get [dartx.validity]() {
      return this.validity;
    }
    get [dartx.value]() {
      return this.value;
    }
    set [dartx.value](value) {
      this.value = value;
    }
    get [dartx.valueAsDate]() {
      return html_common.convertNativeToDart_DateTime(this[_get_valueAsDate]);
    }
    get [_get_valueAsDate]() {
      return this.valueAsDate;
    }
    set [dartx.valueAsDate](value) {
      this[_set_valueAsDate] = html_common.convertDartToNative_DateTime(value);
    }
    set [_set_valueAsDate](value) {
      this.valueAsDate = value;
    }
    get [dartx.valueAsNumber]() {
      return this.valueAsNumber;
    }
    set [dartx.valueAsNumber](value) {
      this.valueAsNumber = value;
    }
    get [dartx.entries]() {
      return this.webkitEntries;
    }
    get [dartx.directory]() {
      return this.webkitdirectory;
    }
    set [dartx.directory](value) {
      this.webkitdirectory = value;
    }
    get [dartx.width]() {
      return this.width;
    }
    set [dartx.width](value) {
      this.width = value;
    }
    get [dartx.willValidate]() {
      return this.willValidate;
    }
    [dartx.checkValidity]() {
      return this.checkValidity();
    }
    [dartx.reportValidity]() {
      return this.reportValidity();
    }
    [dartx.select]() {
      return this.select();
    }
    [dartx.setCustomValidity](error) {
      return this.setCustomValidity(error);
    }
    [dartx.setRangeText](replacement, opts) {
      return this.setRangeText(replacement, opts);
    }
    [dartx.setSelectionRange](start, end, direction) {
      return this.setSelectionRange(start, end, direction);
    }
    [dartx.stepDown](n) {
      return this.stepDown(n);
    }
    [dartx.stepUp](n) {
      return this.stepUp(n);
    }
  };
  dart.defineNamedConstructor(html$.InputElement, 'created');
  html$.InputElement[dart.implements] = () => [html$.HiddenInputElement, html$.SearchInputElement, html$.TextInputElement, html$.UrlInputElement, html$.TelephoneInputElement, html$.EmailInputElement, html$.PasswordInputElement, html$.DateInputElement, html$.MonthInputElement, html$.WeekInputElement, html$.TimeInputElement, html$.LocalDateTimeInputElement, html$.NumberInputElement, html$.RangeInputElement, html$.CheckboxInputElement, html$.RadioButtonInputElement, html$.FileUploadInputElement, html$.SubmitButtonInputElement, html$.ImageButtonInputElement, html$.ResetButtonInputElement, html$.ButtonInputElement];
  dart.setSignature(html$.InputElement, {
    constructors: () => ({
      new: dart.definiteFunctionType(html$.InputElement, [], {type: core.String}),
      _: dart.definiteFunctionType(html$.InputElement, []),
      created: dart.definiteFunctionType(html$.InputElement, [])
    }),
    methods: () => ({
      [dartx.checkValidity]: dart.definiteFunctionType(core.bool, []),
      [dartx.reportValidity]: dart.definiteFunctionType(core.bool, []),
      [dartx.select]: dart.definiteFunctionType(dart.void, []),
      [dartx.setCustomValidity]: dart.definiteFunctionType(dart.void, [core.String]),
      [dartx.setRangeText]: dart.definiteFunctionType(dart.void, [core.String], {start: core.int, end: core.int, selectionMode: core.String}),
      [dartx.setSelectionRange]: dart.definiteFunctionType(dart.void, [core.int, core.int], [core.String]),
      [dartx.stepDown]: dart.definiteFunctionType(dart.void, [], [core.int]),
      [dartx.stepUp]: dart.definiteFunctionType(dart.void, [], [core.int])
    })
  });
  dart.registerExtension(dart.global.HTMLInputElement, html$.InputElement);
  dart.defineExtensionNames([
    'autofocus',
    'disabled',
    'incremental',
    'indeterminate',
    'name',
    'value'
  ]);
  html$.InputElementBase = class InputElementBase extends core.Object {
    new() {
      this[dartx.autofocus] = null;
      this[dartx.disabled] = null;
      this[dartx.incremental] = null;
      this[dartx.indeterminate] = null;
      this[dartx.name] = null;
      this[dartx.value] = null;
    }
  };
  html$.InputElementBase[dart.implements] = () => [html$.Element];
  dart.setSignature(html$.InputElementBase, {});
  dart.defineExtensionMembers(html$.InputElementBase, [
    'autofocus',
    'autofocus',
    'disabled',
    'disabled',
    'incremental',
    'incremental',
    'indeterminate',
    'indeterminate',
    'name',
    'name',
    'value',
    'value'
  ]);
  html$.HiddenInputElement = class HiddenInputElement extends core.Object {
    static new() {
      return html$.InputElement.new({type: 'hidden'});
    }
  };
  html$.HiddenInputElement[dart.implements] = () => [html$.InputElementBase];
  dart.setSignature(html$.HiddenInputElement, {
    constructors: () => ({new: dart.definiteFunctionType(html$.HiddenInputElement, [])})
  });
  dart.defineExtensionNames([
    'autocomplete',
    'maxLength',
    'pattern',
    'placeholder',
    'readOnly',
    'required',
    'size',
    'selectionDirection',
    'selectionEnd',
    'selectionStart'
  ]);
  html$.TextInputElementBase = class TextInputElementBase extends core.Object {
    new() {
      this[dartx.autocomplete] = null;
      this[dartx.maxLength] = null;
      this[dartx.pattern] = null;
      this[dartx.placeholder] = null;
      this[dartx.readOnly] = null;
      this[dartx.required] = null;
      this[dartx.size] = null;
      this[dartx.selectionDirection] = null;
      this[dartx.selectionEnd] = null;
      this[dartx.selectionStart] = null;
    }
  };
  html$.TextInputElementBase[dart.implements] = () => [html$.InputElementBase];
  dart.setSignature(html$.TextInputElementBase, {});
  dart.defineExtensionMembers(html$.TextInputElementBase, [
    'autocomplete',
    'autocomplete',
    'maxLength',
    'maxLength',
    'pattern',
    'pattern',
    'placeholder',
    'placeholder',
    'readOnly',
    'readOnly',
    'required',
    'required',
    'size',
    'size',
    'selectionDirection',
    'selectionDirection',
    'selectionEnd',
    'selectionEnd',
    'selectionStart',
    'selectionStart'
  ]);
  dart.defineExtensionNames([
    'dirName'
  ]);
  html$.SearchInputElement = class SearchInputElement extends core.Object {
    static new() {
      return html$.InputElement.new({type: 'search'});
    }
    static get supported() {
      return html$.InputElement.new({type: 'search'})[dartx.type] == 'search';
    }
  };
  html$.SearchInputElement[dart.implements] = () => [html$.TextInputElementBase];
  dart.setSignature(html$.SearchInputElement, {
    constructors: () => ({new: dart.definiteFunctionType(html$.SearchInputElement, [])})
  });
  dart.defineExtensionMembers(html$.SearchInputElement, ['dirName', 'dirName']);
  dart.defineExtensionNames([
    'dirName'
  ]);
  html$.TextInputElement = class TextInputElement extends core.Object {
    static new() {
      return html$.InputElement.new({type: 'text'});
    }
  };
  html$.TextInputElement[dart.implements] = () => [html$.TextInputElementBase];
  dart.setSignature(html$.TextInputElement, {
    constructors: () => ({new: dart.definiteFunctionType(html$.TextInputElement, [])})
  });
  dart.defineExtensionMembers(html$.TextInputElement, ['dirName', 'dirName']);
  html$.UrlInputElement = class UrlInputElement extends core.Object {
    static new() {
      return html$.InputElement.new({type: 'url'});
    }
    static get supported() {
      return html$.InputElement.new({type: 'url'})[dartx.type] == 'url';
    }
  };
  html$.UrlInputElement[dart.implements] = () => [html$.TextInputElementBase];
  dart.setSignature(html$.UrlInputElement, {
    constructors: () => ({new: dart.definiteFunctionType(html$.UrlInputElement, [])})
  });
  html$.TelephoneInputElement = class TelephoneInputElement extends core.Object {
    static new() {
      return html$.InputElement.new({type: 'tel'});
    }
    static get supported() {
      return html$.InputElement.new({type: 'tel'})[dartx.type] == 'tel';
    }
  };
  html$.TelephoneInputElement[dart.implements] = () => [html$.TextInputElementBase];
  dart.setSignature(html$.TelephoneInputElement, {
    constructors: () => ({new: dart.definiteFunctionType(html$.TelephoneInputElement, [])})
  });
  dart.defineExtensionNames([
    'autocomplete',
    'autofocus',
    'maxLength',
    'multiple',
    'pattern',
    'placeholder',
    'readOnly',
    'required',
    'size'
  ]);
  html$.EmailInputElement = class EmailInputElement extends core.Object {
    static new() {
      return html$.InputElement.new({type: 'email'});
    }
    static get supported() {
      return html$.InputElement.new({type: 'email'})[dartx.type] == 'email';
    }
  };
  html$.EmailInputElement[dart.implements] = () => [html$.TextInputElementBase];
  dart.setSignature(html$.EmailInputElement, {
    constructors: () => ({new: dart.definiteFunctionType(html$.EmailInputElement, [])})
  });
  dart.defineExtensionMembers(html$.EmailInputElement, [
    'autocomplete',
    'autocomplete',
    'autofocus',
    'autofocus',
    'maxLength',
    'maxLength',
    'multiple',
    'multiple',
    'pattern',
    'pattern',
    'placeholder',
    'placeholder',
    'readOnly',
    'readOnly',
    'required',
    'required',
    'size',
    'size'
  ]);
  html$.PasswordInputElement = class PasswordInputElement extends core.Object {
    static new() {
      return html$.InputElement.new({type: 'password'});
    }
  };
  html$.PasswordInputElement[dart.implements] = () => [html$.TextInputElementBase];
  dart.setSignature(html$.PasswordInputElement, {
    constructors: () => ({new: dart.definiteFunctionType(html$.PasswordInputElement, [])})
  });
  dart.defineExtensionNames([
    'max',
    'min',
    'step',
    'valueAsNumber'
  ]);
  html$.RangeInputElementBase = class RangeInputElementBase extends core.Object {
    new() {
      this[dartx.max] = null;
      this[dartx.min] = null;
      this[dartx.step] = null;
      this[dartx.valueAsNumber] = null;
    }
  };
  html$.RangeInputElementBase[dart.implements] = () => [html$.InputElementBase];
  dart.setSignature(html$.RangeInputElementBase, {});
  dart.defineExtensionMembers(html$.RangeInputElementBase, [
    'max',
    'max',
    'min',
    'min',
    'step',
    'step',
    'valueAsNumber',
    'valueAsNumber'
  ]);
  dart.defineExtensionNames([
    'valueAsDate',
    'readOnly',
    'required'
  ]);
  html$.DateInputElement = class DateInputElement extends core.Object {
    static new() {
      return html$.InputElement.new({type: 'date'});
    }
    static get supported() {
      return html$.InputElement.new({type: 'date'})[dartx.type] == 'date';
    }
  };
  html$.DateInputElement[dart.implements] = () => [html$.RangeInputElementBase];
  dart.setSignature(html$.DateInputElement, {
    constructors: () => ({new: dart.definiteFunctionType(html$.DateInputElement, [])})
  });
  dart.defineExtensionMembers(html$.DateInputElement, [
    'valueAsDate',
    'valueAsDate',
    'readOnly',
    'readOnly',
    'required',
    'required'
  ]);
  dart.defineExtensionNames([
    'valueAsDate',
    'readOnly',
    'required'
  ]);
  html$.MonthInputElement = class MonthInputElement extends core.Object {
    static new() {
      return html$.InputElement.new({type: 'month'});
    }
    static get supported() {
      return html$.InputElement.new({type: 'month'})[dartx.type] == 'month';
    }
  };
  html$.MonthInputElement[dart.implements] = () => [html$.RangeInputElementBase];
  dart.setSignature(html$.MonthInputElement, {
    constructors: () => ({new: dart.definiteFunctionType(html$.MonthInputElement, [])})
  });
  dart.defineExtensionMembers(html$.MonthInputElement, [
    'valueAsDate',
    'valueAsDate',
    'readOnly',
    'readOnly',
    'required',
    'required'
  ]);
  dart.defineExtensionNames([
    'valueAsDate',
    'readOnly',
    'required'
  ]);
  html$.WeekInputElement = class WeekInputElement extends core.Object {
    static new() {
      return html$.InputElement.new({type: 'week'});
    }
    static get supported() {
      return html$.InputElement.new({type: 'week'})[dartx.type] == 'week';
    }
  };
  html$.WeekInputElement[dart.implements] = () => [html$.RangeInputElementBase];
  dart.setSignature(html$.WeekInputElement, {
    constructors: () => ({new: dart.definiteFunctionType(html$.WeekInputElement, [])})
  });
  dart.defineExtensionMembers(html$.WeekInputElement, [
    'valueAsDate',
    'valueAsDate',
    'readOnly',
    'readOnly',
    'required',
    'required'
  ]);
  dart.defineExtensionNames([
    'valueAsDate',
    'readOnly',
    'required'
  ]);
  html$.TimeInputElement = class TimeInputElement extends core.Object {
    static new() {
      return html$.InputElement.new({type: 'time'});
    }
    static get supported() {
      return html$.InputElement.new({type: 'time'})[dartx.type] == 'time';
    }
  };
  html$.TimeInputElement[dart.implements] = () => [html$.RangeInputElementBase];
  dart.setSignature(html$.TimeInputElement, {
    constructors: () => ({new: dart.definiteFunctionType(html$.TimeInputElement, [])})
  });
  dart.defineExtensionMembers(html$.TimeInputElement, [
    'valueAsDate',
    'valueAsDate',
    'readOnly',
    'readOnly',
    'required',
    'required'
  ]);
  dart.defineExtensionNames([
    'readOnly',
    'required'
  ]);
  html$.LocalDateTimeInputElement = class LocalDateTimeInputElement extends core.Object {
    static new() {
      return html$.InputElement.new({type: 'datetime-local'});
    }
    static get supported() {
      return html$.InputElement.new({type: 'datetime-local'})[dartx.type] == 'datetime-local';
    }
  };
  html$.LocalDateTimeInputElement[dart.implements] = () => [html$.RangeInputElementBase];
  dart.setSignature(html$.LocalDateTimeInputElement, {
    constructors: () => ({new: dart.definiteFunctionType(html$.LocalDateTimeInputElement, [])})
  });
  dart.defineExtensionMembers(html$.LocalDateTimeInputElement, ['readOnly', 'readOnly', 'required', 'required']);
  dart.defineExtensionNames([
    'placeholder',
    'readOnly',
    'required'
  ]);
  html$.NumberInputElement = class NumberInputElement extends core.Object {
    static new() {
      return html$.InputElement.new({type: 'number'});
    }
    static get supported() {
      return html$.InputElement.new({type: 'number'})[dartx.type] == 'number';
    }
  };
  html$.NumberInputElement[dart.implements] = () => [html$.RangeInputElementBase];
  dart.setSignature(html$.NumberInputElement, {
    constructors: () => ({new: dart.definiteFunctionType(html$.NumberInputElement, [])})
  });
  dart.defineExtensionMembers(html$.NumberInputElement, [
    'placeholder',
    'placeholder',
    'readOnly',
    'readOnly',
    'required',
    'required'
  ]);
  html$.RangeInputElement = class RangeInputElement extends core.Object {
    static new() {
      return html$.InputElement.new({type: 'range'});
    }
    static get supported() {
      return html$.InputElement.new({type: 'range'})[dartx.type] == 'range';
    }
  };
  html$.RangeInputElement[dart.implements] = () => [html$.RangeInputElementBase];
  dart.setSignature(html$.RangeInputElement, {
    constructors: () => ({new: dart.definiteFunctionType(html$.RangeInputElement, [])})
  });
  dart.defineExtensionNames([
    'checked',
    'required'
  ]);
  html$.CheckboxInputElement = class CheckboxInputElement extends core.Object {
    static new() {
      return html$.InputElement.new({type: 'checkbox'});
    }
  };
  html$.CheckboxInputElement[dart.implements] = () => [html$.InputElementBase];
  dart.setSignature(html$.CheckboxInputElement, {
    constructors: () => ({new: dart.definiteFunctionType(html$.CheckboxInputElement, [])})
  });
  dart.defineExtensionMembers(html$.CheckboxInputElement, ['checked', 'checked', 'required', 'required']);
  dart.defineExtensionNames([
    'checked',
    'required'
  ]);
  html$.RadioButtonInputElement = class RadioButtonInputElement extends core.Object {
    static new() {
      return html$.InputElement.new({type: 'radio'});
    }
  };
  html$.RadioButtonInputElement[dart.implements] = () => [html$.InputElementBase];
  dart.setSignature(html$.RadioButtonInputElement, {
    constructors: () => ({new: dart.definiteFunctionType(html$.RadioButtonInputElement, [])})
  });
  dart.defineExtensionMembers(html$.RadioButtonInputElement, ['checked', 'checked', 'required', 'required']);
  dart.defineExtensionNames([
    'accept',
    'multiple',
    'required',
    'files'
  ]);
  html$.FileUploadInputElement = class FileUploadInputElement extends core.Object {
    static new() {
      return html$.InputElement.new({type: 'file'});
    }
  };
  html$.FileUploadInputElement[dart.implements] = () => [html$.InputElementBase];
  dart.setSignature(html$.FileUploadInputElement, {
    constructors: () => ({new: dart.definiteFunctionType(html$.FileUploadInputElement, [])})
  });
  dart.defineExtensionMembers(html$.FileUploadInputElement, [
    'accept',
    'accept',
    'multiple',
    'multiple',
    'required',
    'required',
    'files',
    'files'
  ]);
  dart.defineExtensionNames([
    'formAction',
    'formEnctype',
    'formMethod',
    'formNoValidate',
    'formTarget'
  ]);
  html$.SubmitButtonInputElement = class SubmitButtonInputElement extends core.Object {
    static new() {
      return html$.InputElement.new({type: 'submit'});
    }
  };
  html$.SubmitButtonInputElement[dart.implements] = () => [html$.InputElementBase];
  dart.setSignature(html$.SubmitButtonInputElement, {
    constructors: () => ({new: dart.definiteFunctionType(html$.SubmitButtonInputElement, [])})
  });
  dart.defineExtensionMembers(html$.SubmitButtonInputElement, [
    'formAction',
    'formAction',
    'formEnctype',
    'formEnctype',
    'formMethod',
    'formMethod',
    'formNoValidate',
    'formNoValidate',
    'formTarget',
    'formTarget'
  ]);
  dart.defineExtensionNames([
    'alt',
    'formAction',
    'formEnctype',
    'formMethod',
    'formNoValidate',
    'formTarget',
    'height',
    'src',
    'width'
  ]);
  html$.ImageButtonInputElement = class ImageButtonInputElement extends core.Object {
    static new() {
      return html$.InputElement.new({type: 'image'});
    }
  };
  html$.ImageButtonInputElement[dart.implements] = () => [html$.InputElementBase];
  dart.setSignature(html$.ImageButtonInputElement, {
    constructors: () => ({new: dart.definiteFunctionType(html$.ImageButtonInputElement, [])})
  });
  dart.defineExtensionMembers(html$.ImageButtonInputElement, [
    'alt',
    'alt',
    'formAction',
    'formAction',
    'formEnctype',
    'formEnctype',
    'formMethod',
    'formMethod',
    'formNoValidate',
    'formNoValidate',
    'formTarget',
    'formTarget',
    'height',
    'height',
    'src',
    'src',
    'width',
    'width'
  ]);
  html$.ResetButtonInputElement = class ResetButtonInputElement extends core.Object {
    static new() {
      return html$.InputElement.new({type: 'reset'});
    }
  };
  html$.ResetButtonInputElement[dart.implements] = () => [html$.InputElementBase];
  dart.setSignature(html$.ResetButtonInputElement, {
    constructors: () => ({new: dart.definiteFunctionType(html$.ResetButtonInputElement, [])})
  });
  html$.ButtonInputElement = class ButtonInputElement extends core.Object {
    static new() {
      return html$.InputElement.new({type: 'button'});
    }
  };
  html$.ButtonInputElement[dart.implements] = () => [html$.InputElementBase];
  dart.setSignature(html$.ButtonInputElement, {
    constructors: () => ({new: dart.definiteFunctionType(html$.ButtonInputElement, [])})
  });
  const _initKeyboardEvent = Symbol('_initKeyboardEvent');
  const _keyIdentifier = Symbol('_keyIdentifier');
  dart.defineExtensionNames([
    'keyCode',
    'charCode',
    'which',
    'getModifierState',
    'altKey',
    'code',
    'ctrlKey',
    'key',
    'keyLocation',
    'location',
    'metaKey',
    'repeat',
    'shiftKey'
  ]);
  html$.KeyboardEvent = class KeyboardEvent extends html$.UIEvent {
    static new(type, opts) {
      let view = opts && 'view' in opts ? opts.view : null;
      let canBubble = opts && 'canBubble' in opts ? opts.canBubble : true;
      let cancelable = opts && 'cancelable' in opts ? opts.cancelable : true;
      let keyLocation = opts && 'keyLocation' in opts ? opts.keyLocation : 1;
      let ctrlKey = opts && 'ctrlKey' in opts ? opts.ctrlKey : false;
      let altKey = opts && 'altKey' in opts ? opts.altKey : false;
      let shiftKey = opts && 'shiftKey' in opts ? opts.shiftKey : false;
      let metaKey = opts && 'metaKey' in opts ? opts.metaKey : false;
      if (view == null) {
        view = html$.window;
      }
      let e = html$.KeyboardEvent._check(html$.document[_createEvent]("KeyboardEvent"));
      e[_initKeyboardEvent](type, canBubble, cancelable, view, "", keyLocation, ctrlKey, altKey, shiftKey, metaKey);
      return e;
    }
    [_initKeyboardEvent](type, canBubble, cancelable, view, keyIdentifier, keyLocation, ctrlKey, altKey, shiftKey, metaKey) {
      if (typeof this.initKeyEvent == "function") {
        this.initKeyEvent(type, canBubble, cancelable, view, ctrlKey, altKey, shiftKey, metaKey, 0, 0);
      } else {
        this.initKeyboardEvent(type, canBubble, cancelable, view, keyIdentifier, keyLocation, ctrlKey, altKey, shiftKey, metaKey);
      }
    }
    get [dartx.keyCode]() {
      return this[_keyCode];
    }
    get [dartx.charCode]() {
      return this[_charCode];
    }
    get [dartx.which]() {
      return this[_which];
    }
    static _(type, eventInitDict) {
      if (eventInitDict === void 0) eventInitDict = null;
      if (eventInitDict != null) {
        let eventInitDict_1 = html_common.convertDartToNative_Dictionary(eventInitDict);
        return html$.KeyboardEvent._create_1(type, eventInitDict_1);
      }
      return html$.KeyboardEvent._create_2(type);
    }
    static _create_1(type, eventInitDict) {
      return new KeyboardEvent(type, eventInitDict);
    }
    static _create_2(type) {
      return new KeyboardEvent(type);
    }
    get [dartx.altKey]() {
      return this.altKey;
    }
    get [dartx.code]() {
      return this.code;
    }
    get [dartx.ctrlKey]() {
      return this.ctrlKey;
    }
    get [dartx.key]() {
      return this.key;
    }
    get [_keyIdentifier]() {
      return this.keyIdentifier;
    }
    get [dartx.keyLocation]() {
      return this.keyLocation;
    }
    get [dartx.location]() {
      return this.location;
    }
    get [dartx.metaKey]() {
      return this.metaKey;
    }
    get [dartx.repeat]() {
      return this.repeat;
    }
    get [dartx.shiftKey]() {
      return this.shiftKey;
    }
    [dartx.getModifierState](keyArg) {
      return this.getModifierState(keyArg);
    }
  };
  dart.setSignature(html$.KeyboardEvent, {
    constructors: () => ({
      new: dart.definiteFunctionType(html$.KeyboardEvent, [core.String], {view: html$.Window, canBubble: core.bool, cancelable: core.bool, keyLocation: core.int, ctrlKey: core.bool, altKey: core.bool, shiftKey: core.bool, metaKey: core.bool}),
      _: dart.definiteFunctionType(html$.KeyboardEvent, [core.String], [core.Map])
    }),
    methods: () => ({
      [_initKeyboardEvent]: dart.definiteFunctionType(dart.void, [core.String, core.bool, core.bool, html$.Window, core.String, core.int, core.bool, core.bool, core.bool, core.bool]),
      [dartx.getModifierState]: dart.definiteFunctionType(core.bool, [core.String])
    }),
    statics: () => ({
      _create_1: dart.definiteFunctionType(html$.KeyboardEvent, [dart.dynamic, dart.dynamic]),
      _create_2: dart.definiteFunctionType(html$.KeyboardEvent, [dart.dynamic])
    }),
    names: ['_create_1', '_create_2']
  });
  html$.KeyboardEvent.DOM_KEY_LOCATION_LEFT = 1;
  html$.KeyboardEvent.DOM_KEY_LOCATION_NUMPAD = 3;
  html$.KeyboardEvent.DOM_KEY_LOCATION_RIGHT = 2;
  html$.KeyboardEvent.DOM_KEY_LOCATION_STANDARD = 0;
  dart.registerExtension(dart.global.KeyboardEvent, html$.KeyboardEvent);
  html$.KeyframeEffect = class KeyframeEffect extends html$.AnimationEffectReadOnly {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(target, keyframes, timing) {
      if (timing === void 0) timing = null;
      if (ListOfMap().is(keyframes) && (html$.Element.is(target) || target == null) && timing == null) {
        return html$.KeyframeEffect._create_1(target, keyframes);
      }
      if (typeof timing == 'number' && ListOfMap().is(keyframes) && (html$.Element.is(target) || target == null)) {
        return html$.KeyframeEffect._create_2(target, keyframes, timing);
      }
      if (core.Map.is(timing) && ListOfMap().is(keyframes) && (html$.Element.is(target) || target == null)) {
        let timing_1 = html_common.convertDartToNative_Dictionary(timing);
        return html$.KeyframeEffect._create_3(target, keyframes, timing_1);
      }
      dart.throw(new core.ArgumentError("Incorrect number or type of arguments"));
    }
    static _create_1(target, keyframes) {
      return new KeyframeEffect(target, keyframes);
    }
    static _create_2(target, keyframes, timing) {
      return new KeyframeEffect(target, keyframes, timing);
    }
    static _create_3(target, keyframes, timing) {
      return new KeyframeEffect(target, keyframes, timing);
    }
  };
  dart.setSignature(html$.KeyframeEffect, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.KeyframeEffect, []),
      new: dart.definiteFunctionType(html$.KeyframeEffect, [html$.Element, core.List$(core.Map)], [dart.dynamic])
    }),
    statics: () => ({
      _create_1: dart.definiteFunctionType(html$.KeyframeEffect, [dart.dynamic, dart.dynamic]),
      _create_2: dart.definiteFunctionType(html$.KeyframeEffect, [dart.dynamic, dart.dynamic, dart.dynamic]),
      _create_3: dart.definiteFunctionType(html$.KeyframeEffect, [dart.dynamic, dart.dynamic, dart.dynamic])
    }),
    names: ['_create_1', '_create_2', '_create_3']
  });
  dart.registerExtension(dart.global.KeyframeEffect, html$.KeyframeEffect);
  dart.defineExtensionNames([
    'checkValidity',
    'reportValidity',
    'setCustomValidity',
    'autofocus',
    'challenge',
    'disabled',
    'form',
    'keytype',
    'labels',
    'name',
    'type',
    'validationMessage',
    'validity',
    'willValidate'
  ]);
  html$.KeygenElement = class KeygenElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return html$.KeygenElement._check(html$.document[dartx.createElement]("keygen"));
    }
    created() {
      this[dartx.autofocus] = null;
      this[dartx.challenge] = null;
      this[dartx.disabled] = null;
      this[dartx.form] = null;
      this[dartx.keytype] = null;
      this[dartx.labels] = null;
      this[dartx.name] = null;
      this[dartx.type] = null;
      this[dartx.validationMessage] = null;
      this[dartx.validity] = null;
      this[dartx.willValidate] = null;
      super.created();
    }
    static get supported() {
      return dart.test(html$.Element.isTagSupported('keygen')) && html$.KeygenElement.is(html$.Element.tag('keygen'));
    }
    get [dartx.autofocus]() {
      return this.autofocus;
    }
    set [dartx.autofocus](value) {
      this.autofocus = value;
    }
    get [dartx.challenge]() {
      return this.challenge;
    }
    set [dartx.challenge](value) {
      this.challenge = value;
    }
    get [dartx.disabled]() {
      return this.disabled;
    }
    set [dartx.disabled](value) {
      this.disabled = value;
    }
    get [dartx.form]() {
      return this.form;
    }
    get [dartx.keytype]() {
      return this.keytype;
    }
    set [dartx.keytype](value) {
      this.keytype = value;
    }
    get [dartx.labels]() {
      return this.labels;
    }
    get [dartx.name]() {
      return this.name;
    }
    set [dartx.name](value) {
      this.name = value;
    }
    get [dartx.type]() {
      return this.type;
    }
    get [dartx.validationMessage]() {
      return this.validationMessage;
    }
    get [dartx.validity]() {
      return this.validity;
    }
    get [dartx.willValidate]() {
      return this.willValidate;
    }
    [dartx.checkValidity]() {
      return this.checkValidity();
    }
    [dartx.reportValidity]() {
      return this.reportValidity();
    }
    [dartx.setCustomValidity](error) {
      return this.setCustomValidity(error);
    }
  };
  dart.defineNamedConstructor(html$.KeygenElement, 'created');
  dart.setSignature(html$.KeygenElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.KeygenElement, []),
      new: dart.definiteFunctionType(html$.KeygenElement, []),
      created: dart.definiteFunctionType(html$.KeygenElement, [])
    }),
    methods: () => ({
      [dartx.checkValidity]: dart.definiteFunctionType(core.bool, []),
      [dartx.reportValidity]: dart.definiteFunctionType(core.bool, []),
      [dartx.setCustomValidity]: dart.definiteFunctionType(dart.void, [core.String])
    })
  });
  dart.registerExtension(dart.global.HTMLKeygenElement, html$.KeygenElement);
  dart.defineExtensionNames([
    'value'
  ]);
  html$.LIElement = class LIElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return html$.LIElement._check(html$.document[dartx.createElement]("li"));
    }
    created() {
      this[dartx.value] = null;
      super.created();
    }
    get [dartx.value]() {
      return this.value;
    }
    set [dartx.value](value) {
      this.value = value;
    }
  };
  dart.defineNamedConstructor(html$.LIElement, 'created');
  dart.setSignature(html$.LIElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.LIElement, []),
      new: dart.definiteFunctionType(html$.LIElement, []),
      created: dart.definiteFunctionType(html$.LIElement, [])
    })
  });
  dart.registerExtension(dart.global.HTMLLIElement, html$.LIElement);
  dart.defineExtensionNames([
    'control',
    'form',
    'htmlFor'
  ]);
  html$.LabelElement = class LabelElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return html$.LabelElement._check(html$.document[dartx.createElement]("label"));
    }
    created() {
      this[dartx.control] = null;
      this[dartx.form] = null;
      this[dartx.htmlFor] = null;
      super.created();
    }
    get [dartx.control]() {
      return this.control;
    }
    get [dartx.form]() {
      return this.form;
    }
    get [dartx.htmlFor]() {
      return this.htmlFor;
    }
    set [dartx.htmlFor](value) {
      this.htmlFor = value;
    }
  };
  dart.defineNamedConstructor(html$.LabelElement, 'created');
  dart.setSignature(html$.LabelElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.LabelElement, []),
      new: dart.definiteFunctionType(html$.LabelElement, []),
      created: dart.definiteFunctionType(html$.LabelElement, [])
    })
  });
  dart.registerExtension(dart.global.HTMLLabelElement, html$.LabelElement);
  dart.defineExtensionNames([
    'form'
  ]);
  html$.LegendElement = class LegendElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return html$.LegendElement._check(html$.document[dartx.createElement]("legend"));
    }
    created() {
      this[dartx.form] = null;
      super.created();
    }
    get [dartx.form]() {
      return this.form;
    }
  };
  dart.defineNamedConstructor(html$.LegendElement, 'created');
  dart.setSignature(html$.LegendElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.LegendElement, []),
      new: dart.definiteFunctionType(html$.LegendElement, []),
      created: dart.definiteFunctionType(html$.LegendElement, [])
    })
  });
  dart.registerExtension(dart.global.HTMLLegendElement, html$.LegendElement);
  dart.defineExtensionNames([
    'supportsImport',
    'crossOrigin',
    'disabled',
    'href',
    'hreflang',
    'import',
    'integrity',
    'media',
    'rel',
    'sheet',
    'sizes',
    'type'
  ]);
  html$.LinkElement = class LinkElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return html$.LinkElement._check(html$.document[dartx.createElement]("link"));
    }
    created() {
      this[dartx.crossOrigin] = null;
      this[dartx.disabled] = null;
      this[dartx.href] = null;
      this[dartx.hreflang] = null;
      this[dartx.import] = null;
      this[dartx.integrity] = null;
      this[dartx.media] = null;
      this[dartx.rel] = null;
      this[dartx.sheet] = null;
      this[dartx.sizes] = null;
      this[dartx.type] = null;
      super.created();
    }
    get [dartx.crossOrigin]() {
      return this.crossOrigin;
    }
    set [dartx.crossOrigin](value) {
      this.crossOrigin = value;
    }
    get [dartx.disabled]() {
      return this.disabled;
    }
    set [dartx.disabled](value) {
      this.disabled = value;
    }
    get [dartx.href]() {
      return this.href;
    }
    set [dartx.href](value) {
      this.href = value;
    }
    get [dartx.hreflang]() {
      return this.hreflang;
    }
    set [dartx.hreflang](value) {
      this.hreflang = value;
    }
    get [dartx.import]() {
      return this.import;
    }
    get [dartx.integrity]() {
      return this.integrity;
    }
    set [dartx.integrity](value) {
      this.integrity = value;
    }
    get [dartx.media]() {
      return this.media;
    }
    set [dartx.media](value) {
      this.media = value;
    }
    get [dartx.rel]() {
      return this.rel;
    }
    set [dartx.rel](value) {
      this.rel = value;
    }
    get [dartx.sheet]() {
      return this.sheet;
    }
    get [dartx.sizes]() {
      return this.sizes;
    }
    get [dartx.type]() {
      return this.type;
    }
    set [dartx.type](value) {
      this.type = value;
    }
    get [dartx.supportsImport]() {
      return "import" in this;
    }
  };
  dart.defineNamedConstructor(html$.LinkElement, 'created');
  dart.setSignature(html$.LinkElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.LinkElement, []),
      new: dart.definiteFunctionType(html$.LinkElement, []),
      created: dart.definiteFunctionType(html$.LinkElement, [])
    })
  });
  dart.registerExtension(dart.global.HTMLLinkElement, html$.LinkElement);
  dart.defineExtensionNames([
    'assign',
    'reload',
    'replace',
    'origin',
    'toString',
    'ancestorOrigins',
    'hash',
    'host',
    'hostname',
    'href',
    'pathname',
    'port',
    'protocol',
    'search'
  ]);
  html$.Location = class Location extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.ancestorOrigins]() {
      return this.ancestorOrigins;
    }
    get [dartx.hash]() {
      return this.hash;
    }
    set [dartx.hash](value) {
      this.hash = value;
    }
    get [dartx.host]() {
      return this.host;
    }
    set [dartx.host](value) {
      this.host = value;
    }
    get [dartx.hostname]() {
      return this.hostname;
    }
    set [dartx.hostname](value) {
      this.hostname = value;
    }
    get [dartx.href]() {
      return this.href;
    }
    set [dartx.href](value) {
      this.href = value;
    }
    get [dartx.pathname]() {
      return this.pathname;
    }
    set [dartx.pathname](value) {
      this.pathname = value;
    }
    get [dartx.port]() {
      return this.port;
    }
    set [dartx.port](value) {
      this.port = value;
    }
    get [dartx.protocol]() {
      return this.protocol;
    }
    set [dartx.protocol](value) {
      this.protocol = value;
    }
    get [dartx.search]() {
      return this.search;
    }
    set [dartx.search](value) {
      this.search = value;
    }
    [dartx.assign](url) {
      return this.assign(url);
    }
    [dartx.reload]() {
      return this.reload();
    }
    [dartx.replace](url) {
      return this.replace(url);
    }
    get [dartx.origin]() {
      if ("origin" in this) {
        return this.origin;
      }
      return dart.str`${this[dartx.protocol]}//${this[dartx.host]}`;
    }
    [dartx.toString]() {
      return String(this);
    }
  };
  html$.Location[dart.implements] = () => [html$.LocationBase];
  dart.setSignature(html$.Location, {
    constructors: () => ({_: dart.definiteFunctionType(html$.Location, [])}),
    methods: () => ({
      [dartx.assign]: dart.definiteFunctionType(dart.void, [], [core.String]),
      [dartx.reload]: dart.definiteFunctionType(dart.void, []),
      [dartx.replace]: dart.definiteFunctionType(dart.void, [core.String])
    })
  });
  dart.registerExtension(dart.global.Location, html$.Location);
  dart.defineExtensionNames([
    'areas',
    'name'
  ]);
  html$.MapElement = class MapElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return html$.MapElement._check(html$.document[dartx.createElement]("map"));
    }
    created() {
      this[dartx.areas] = null;
      this[dartx.name] = null;
      super.created();
    }
    get [dartx.areas]() {
      return this.areas;
    }
    get [dartx.name]() {
      return this.name;
    }
    set [dartx.name](value) {
      this.name = value;
    }
  };
  dart.defineNamedConstructor(html$.MapElement, 'created');
  dart.setSignature(html$.MapElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.MapElement, []),
      new: dart.definiteFunctionType(html$.MapElement, []),
      created: dart.definiteFunctionType(html$.MapElement, [])
    })
  });
  dart.registerExtension(dart.global.HTMLMapElement, html$.MapElement);
  dart.defineExtensionNames([
    'pause',
    'play',
    'unpause',
    'buffered',
    'currentTime',
    'defaultPlaybackRate',
    'duration',
    'muted',
    'paused',
    'playbackRate',
    'playbackState',
    'played',
    'seekable',
    'volume'
  ]);
  html$.MediaController = class MediaController extends html$.EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return html$.MediaController._create_1();
    }
    static _create_1() {
      return new MediaController();
    }
    get [dartx.buffered]() {
      return this.buffered;
    }
    get [dartx.currentTime]() {
      return this.currentTime;
    }
    set [dartx.currentTime](value) {
      this.currentTime = value;
    }
    get [dartx.defaultPlaybackRate]() {
      return this.defaultPlaybackRate;
    }
    set [dartx.defaultPlaybackRate](value) {
      this.defaultPlaybackRate = value;
    }
    get [dartx.duration]() {
      return this.duration;
    }
    get [dartx.muted]() {
      return this.muted;
    }
    set [dartx.muted](value) {
      this.muted = value;
    }
    get [dartx.paused]() {
      return this.paused;
    }
    get [dartx.playbackRate]() {
      return this.playbackRate;
    }
    set [dartx.playbackRate](value) {
      this.playbackRate = value;
    }
    get [dartx.playbackState]() {
      return this.playbackState;
    }
    get [dartx.played]() {
      return this.played;
    }
    get [dartx.seekable]() {
      return this.seekable;
    }
    get [dartx.volume]() {
      return this.volume;
    }
    set [dartx.volume](value) {
      this.volume = value;
    }
    [dartx.pause]() {
      return this.pause();
    }
    [dartx.play]() {
      return this.play();
    }
    [dartx.unpause]() {
      return this.unpause();
    }
  };
  dart.setSignature(html$.MediaController, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.MediaController, []),
      new: dart.definiteFunctionType(html$.MediaController, [])
    }),
    methods: () => ({
      [dartx.pause]: dart.definiteFunctionType(dart.void, []),
      [dartx.play]: dart.definiteFunctionType(dart.void, []),
      [dartx.unpause]: dart.definiteFunctionType(dart.void, [])
    }),
    statics: () => ({_create_1: dart.definiteFunctionType(html$.MediaController, [])}),
    names: ['_create_1']
  });
  dart.registerExtension(dart.global.MediaController, html$.MediaController);
  dart.defineExtensionNames([
    'deviceId',
    'groupId',
    'kind',
    'label'
  ]);
  html$.MediaDeviceInfo = class MediaDeviceInfo extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.deviceId]() {
      return this.deviceId;
    }
    get [dartx.groupId]() {
      return this.groupId;
    }
    get [dartx.kind]() {
      return this.kind;
    }
    get [dartx.label]() {
      return this.label;
    }
  };
  dart.setSignature(html$.MediaDeviceInfo, {
    constructors: () => ({_: dart.definiteFunctionType(html$.MediaDeviceInfo, [])})
  });
  dart.registerExtension(dart.global.MediaDeviceInfo, html$.MediaDeviceInfo);
  const _getUserMedia_1 = Symbol('_getUserMedia_1');
  dart.defineExtensionNames([
    'enumerateDevices',
    'getUserMedia'
  ]);
  html$.MediaDevices = class MediaDevices extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [dartx.enumerateDevices]() {
      return this.enumerateDevices();
    }
    [dartx.getUserMedia](options) {
      let options_1 = html_common.convertDartToNative_Dictionary(options);
      return this[_getUserMedia_1](options_1);
    }
    [_getUserMedia_1](options) {
      return this.getUserMedia(options);
    }
  };
  dart.setSignature(html$.MediaDevices, {
    constructors: () => ({_: dart.definiteFunctionType(html$.MediaDevices, [])}),
    methods: () => ({
      [dartx.enumerateDevices]: dart.definiteFunctionType(async.Future, []),
      [dartx.getUserMedia]: dart.definiteFunctionType(async.Future, [core.Map]),
      [_getUserMedia_1]: dart.definiteFunctionType(async.Future, [dart.dynamic])
    })
  });
  dart.registerExtension(dart.global.MediaDevices, html$.MediaDevices);
  dart.defineExtensionNames([
    'initData',
    'initDataType'
  ]);
  html$.MediaEncryptedEvent = class MediaEncryptedEvent extends html$.Event {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(type, eventInitDict) {
      if (eventInitDict === void 0) eventInitDict = null;
      if (eventInitDict != null) {
        let eventInitDict_1 = html_common.convertDartToNative_Dictionary(eventInitDict);
        return html$.MediaEncryptedEvent._create_1(type, eventInitDict_1);
      }
      return html$.MediaEncryptedEvent._create_2(type);
    }
    static _create_1(type, eventInitDict) {
      return new MediaEncryptedEvent(type, eventInitDict);
    }
    static _create_2(type) {
      return new MediaEncryptedEvent(type);
    }
    get [dartx.initData]() {
      return this.initData;
    }
    get [dartx.initDataType]() {
      return this.initDataType;
    }
  };
  dart.setSignature(html$.MediaEncryptedEvent, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.MediaEncryptedEvent, []),
      new: dart.definiteFunctionType(html$.MediaEncryptedEvent, [core.String], [core.Map])
    }),
    statics: () => ({
      _create_1: dart.definiteFunctionType(html$.MediaEncryptedEvent, [dart.dynamic, dart.dynamic]),
      _create_2: dart.definiteFunctionType(html$.MediaEncryptedEvent, [dart.dynamic])
    }),
    names: ['_create_1', '_create_2']
  });
  dart.registerExtension(dart.global.MediaEncryptedEvent, html$.MediaEncryptedEvent);
  dart.defineExtensionNames([
    'code'
  ]);
  html$.MediaError = class MediaError extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.code]() {
      return this.code;
    }
  };
  dart.setSignature(html$.MediaError, {
    constructors: () => ({_: dart.definiteFunctionType(html$.MediaError, [])})
  });
  html$.MediaError.MEDIA_ERR_ABORTED = 1;
  html$.MediaError.MEDIA_ERR_DECODE = 3;
  html$.MediaError.MEDIA_ERR_NETWORK = 2;
  html$.MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED = 4;
  dart.registerExtension(dart.global.MediaError, html$.MediaError);
  dart.defineExtensionNames([
    'code',
    'systemCode'
  ]);
  html$.MediaKeyError = class MediaKeyError extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.code]() {
      return this.code;
    }
    get [dartx.systemCode]() {
      return this.systemCode;
    }
  };
  dart.setSignature(html$.MediaKeyError, {
    constructors: () => ({_: dart.definiteFunctionType(html$.MediaKeyError, [])})
  });
  html$.MediaKeyError.MEDIA_KEYERR_CLIENT = 2;
  html$.MediaKeyError.MEDIA_KEYERR_DOMAIN = 6;
  html$.MediaKeyError.MEDIA_KEYERR_HARDWARECHANGE = 5;
  html$.MediaKeyError.MEDIA_KEYERR_OUTPUT = 4;
  html$.MediaKeyError.MEDIA_KEYERR_SERVICE = 3;
  html$.MediaKeyError.MEDIA_KEYERR_UNKNOWN = 1;
  dart.registerExtension(dart.global.MediaKeyError, html$.MediaKeyError);
  dart.defineExtensionNames([
    'defaultUrl',
    'errorCode',
    'initData',
    'keySystem',
    'message',
    'sessionId',
    'systemCode'
  ]);
  html$.MediaKeyEvent = class MediaKeyEvent extends html$.Event {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(type, eventInitDict) {
      if (eventInitDict === void 0) eventInitDict = null;
      if (eventInitDict != null) {
        let eventInitDict_1 = html_common.convertDartToNative_Dictionary(eventInitDict);
        return html$.MediaKeyEvent._create_1(type, eventInitDict_1);
      }
      return html$.MediaKeyEvent._create_2(type);
    }
    static _create_1(type, eventInitDict) {
      return new MediaKeyEvent(type, eventInitDict);
    }
    static _create_2(type) {
      return new MediaKeyEvent(type);
    }
    get [dartx.defaultUrl]() {
      return this.defaultURL;
    }
    get [dartx.errorCode]() {
      return this.errorCode;
    }
    get [dartx.initData]() {
      return this.initData;
    }
    get [dartx.keySystem]() {
      return this.keySystem;
    }
    get [dartx.message]() {
      return this.message;
    }
    get [dartx.sessionId]() {
      return this.sessionId;
    }
    get [dartx.systemCode]() {
      return this.systemCode;
    }
  };
  dart.setSignature(html$.MediaKeyEvent, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.MediaKeyEvent, []),
      new: dart.definiteFunctionType(html$.MediaKeyEvent, [core.String], [core.Map])
    }),
    statics: () => ({
      _create_1: dart.definiteFunctionType(html$.MediaKeyEvent, [dart.dynamic, dart.dynamic]),
      _create_2: dart.definiteFunctionType(html$.MediaKeyEvent, [dart.dynamic])
    }),
    names: ['_create_1', '_create_2']
  });
  dart.registerExtension(dart.global.MediaKeyEvent, html$.MediaKeyEvent);
  dart.defineExtensionNames([
    'message',
    'messageType'
  ]);
  html$.MediaKeyMessageEvent = class MediaKeyMessageEvent extends html$.Event {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(type, eventInitDict) {
      if (eventInitDict === void 0) eventInitDict = null;
      if (eventInitDict != null) {
        let eventInitDict_1 = html_common.convertDartToNative_Dictionary(eventInitDict);
        return html$.MediaKeyMessageEvent._create_1(type, eventInitDict_1);
      }
      return html$.MediaKeyMessageEvent._create_2(type);
    }
    static _create_1(type, eventInitDict) {
      return new MediaKeyMessageEvent(type, eventInitDict);
    }
    static _create_2(type) {
      return new MediaKeyMessageEvent(type);
    }
    get [dartx.message]() {
      return this.message;
    }
    get [dartx.messageType]() {
      return this.messageType;
    }
  };
  dart.setSignature(html$.MediaKeyMessageEvent, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.MediaKeyMessageEvent, []),
      new: dart.definiteFunctionType(html$.MediaKeyMessageEvent, [core.String], [core.Map])
    }),
    statics: () => ({
      _create_1: dart.definiteFunctionType(html$.MediaKeyMessageEvent, [dart.dynamic, dart.dynamic]),
      _create_2: dart.definiteFunctionType(html$.MediaKeyMessageEvent, [dart.dynamic])
    }),
    names: ['_create_1', '_create_2']
  });
  dart.registerExtension(dart.global.MediaKeyMessageEvent, html$.MediaKeyMessageEvent);
  const _update$ = Symbol('_update');
  dart.defineExtensionNames([
    'close',
    'generateRequest',
    'load',
    'remove',
    'closed',
    'expiration',
    'keyStatuses',
    'sessionId'
  ]);
  html$.MediaKeySession = class MediaKeySession extends html$.EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.closed]() {
      return this.closed;
    }
    get [dartx.expiration]() {
      return this.expiration;
    }
    get [dartx.keyStatuses]() {
      return this.keyStatuses;
    }
    get [dartx.sessionId]() {
      return this.sessionId;
    }
    [dartx.close]() {
      return this.close();
    }
    [dartx.generateRequest](initDataType, initData) {
      return this.generateRequest(initDataType, initData);
    }
    [dartx.load](sessionId) {
      return this.load(sessionId);
    }
    [dartx.remove]() {
      return this.remove();
    }
    [_update$](response) {
      return this.update(response);
    }
  };
  dart.setSignature(html$.MediaKeySession, {
    constructors: () => ({_: dart.definiteFunctionType(html$.MediaKeySession, [])}),
    methods: () => ({
      [dartx.close]: dart.definiteFunctionType(async.Future, []),
      [dartx.generateRequest]: dart.definiteFunctionType(async.Future, [core.String, dart.dynamic]),
      [dartx.load]: dart.definiteFunctionType(async.Future, [core.String]),
      [dartx.remove]: dart.definiteFunctionType(async.Future, []),
      [_update$]: dart.definiteFunctionType(async.Future, [dart.dynamic])
    })
  });
  dart.registerExtension(dart.global.MediaKeySession, html$.MediaKeySession);
  dart.defineExtensionNames([
    'size'
  ]);
  html$.MediaKeyStatusMap = class MediaKeyStatusMap extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.size]() {
      return this.size;
    }
  };
  dart.setSignature(html$.MediaKeyStatusMap, {
    constructors: () => ({_: dart.definiteFunctionType(html$.MediaKeyStatusMap, [])})
  });
  dart.registerExtension(dart.global.MediaKeyStatusMap, html$.MediaKeyStatusMap);
  const _getConfiguration_1 = Symbol('_getConfiguration_1');
  dart.defineExtensionNames([
    'createMediaKeys',
    'getConfiguration',
    'keySystem'
  ]);
  html$.MediaKeySystemAccess = class MediaKeySystemAccess extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.keySystem]() {
      return this.keySystem;
    }
    [dartx.createMediaKeys]() {
      return this.createMediaKeys();
    }
    [dartx.getConfiguration]() {
      return html_common.convertNativeToDart_Dictionary(this[_getConfiguration_1]());
    }
    [_getConfiguration_1]() {
      return this.getConfiguration();
    }
  };
  dart.setSignature(html$.MediaKeySystemAccess, {
    constructors: () => ({_: dart.definiteFunctionType(html$.MediaKeySystemAccess, [])}),
    methods: () => ({
      [dartx.createMediaKeys]: dart.definiteFunctionType(async.Future, []),
      [dartx.getConfiguration]: dart.definiteFunctionType(core.Map, []),
      [_getConfiguration_1]: dart.definiteFunctionType(dart.dynamic, [])
    })
  });
  dart.registerExtension(dart.global.MediaKeySystemAccess, html$.MediaKeySystemAccess);
  const _createSession = Symbol('_createSession');
  dart.defineExtensionNames([
    'setServerCertificate'
  ]);
  html$.MediaKeys = class MediaKeys extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [_createSession](sessionType) {
      return this.createSession(sessionType);
    }
    [dartx.setServerCertificate](serverCertificate) {
      return this.setServerCertificate(serverCertificate);
    }
  };
  dart.setSignature(html$.MediaKeys, {
    constructors: () => ({_: dart.definiteFunctionType(html$.MediaKeys, [])}),
    methods: () => ({
      [_createSession]: dart.definiteFunctionType(html$.MediaKeySession, [], [core.String]),
      [dartx.setServerCertificate]: dart.definiteFunctionType(async.Future, [dart.dynamic])
    })
  });
  dart.registerExtension(dart.global.MediaKeys, html$.MediaKeys);
  dart.defineExtensionNames([
    'appendMedium',
    'deleteMedium',
    'item',
    'length',
    'mediaText'
  ]);
  html$.MediaList = class MediaList extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.length]() {
      return this.length;
    }
    get [dartx.mediaText]() {
      return this.mediaText;
    }
    set [dartx.mediaText](value) {
      this.mediaText = value;
    }
    [dartx.appendMedium](medium) {
      return this.appendMedium(medium);
    }
    [dartx.deleteMedium](medium) {
      return this.deleteMedium(medium);
    }
    [dartx.item](index) {
      return this.item(index);
    }
  };
  dart.setSignature(html$.MediaList, {
    constructors: () => ({_: dart.definiteFunctionType(html$.MediaList, [])}),
    methods: () => ({
      [dartx.appendMedium]: dart.definiteFunctionType(dart.void, [core.String]),
      [dartx.deleteMedium]: dart.definiteFunctionType(dart.void, [core.String]),
      [dartx.item]: dart.definiteFunctionType(core.String, [core.int])
    })
  });
  dart.registerExtension(dart.global.MediaList, html$.MediaList);
  dart.defineExtensionNames([
    'addListener',
    'removeListener',
    'onChange',
    'matches',
    'media'
  ]);
  html$.MediaQueryList = class MediaQueryList extends html$.EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.matches]() {
      return this.matches;
    }
    get [dartx.media]() {
      return this.media;
    }
    [dartx.addListener](listener) {
      return this.addListener(listener);
    }
    [dartx.removeListener](listener) {
      return this.removeListener(listener);
    }
    get [dartx.onChange]() {
      return html$.MediaQueryList.changeEvent.forTarget(this);
    }
  };
  dart.setSignature(html$.MediaQueryList, {
    constructors: () => ({_: dart.definiteFunctionType(html$.MediaQueryList, [])}),
    methods: () => ({
      [dartx.addListener]: dart.definiteFunctionType(dart.void, [html$.EventListener]),
      [dartx.removeListener]: dart.definiteFunctionType(dart.void, [html$.EventListener])
    })
  });
  dart.defineLazy(html$.MediaQueryList, {
    get changeEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('change'));
    }
  });
  dart.registerExtension(dart.global.MediaQueryList, html$.MediaQueryList);
  dart.defineExtensionNames([
    'matches',
    'media'
  ]);
  html$.MediaQueryListEvent = class MediaQueryListEvent extends html$.Event {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(type, eventInitDict) {
      if (eventInitDict === void 0) eventInitDict = null;
      if (eventInitDict != null) {
        let eventInitDict_1 = html_common.convertDartToNative_Dictionary(eventInitDict);
        return html$.MediaQueryListEvent._create_1(type, eventInitDict_1);
      }
      return html$.MediaQueryListEvent._create_2(type);
    }
    static _create_1(type, eventInitDict) {
      return new MediaQueryListEvent(type, eventInitDict);
    }
    static _create_2(type) {
      return new MediaQueryListEvent(type);
    }
    get [dartx.matches]() {
      return this.matches;
    }
    get [dartx.media]() {
      return this.media;
    }
  };
  dart.setSignature(html$.MediaQueryListEvent, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.MediaQueryListEvent, []),
      new: dart.definiteFunctionType(html$.MediaQueryListEvent, [core.String], [core.Map])
    }),
    statics: () => ({
      _create_1: dart.definiteFunctionType(html$.MediaQueryListEvent, [dart.dynamic, dart.dynamic]),
      _create_2: dart.definiteFunctionType(html$.MediaQueryListEvent, [dart.dynamic])
    }),
    names: ['_create_1', '_create_2']
  });
  dart.registerExtension(dart.global.MediaQueryListEvent, html$.MediaQueryListEvent);
  dart.defineExtensionNames([
    'activate',
    'deactivate'
  ]);
  html$.MediaSession = class MediaSession extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return html$.MediaSession._create_1();
    }
    static _create_1() {
      return new MediaSession();
    }
    [dartx.activate]() {
      return this.activate();
    }
    [dartx.deactivate]() {
      return this.deactivate();
    }
  };
  dart.setSignature(html$.MediaSession, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.MediaSession, []),
      new: dart.definiteFunctionType(html$.MediaSession, [])
    }),
    methods: () => ({
      [dartx.activate]: dart.definiteFunctionType(dart.void, []),
      [dartx.deactivate]: dart.definiteFunctionType(dart.void, [])
    }),
    statics: () => ({_create_1: dart.definiteFunctionType(html$.MediaSession, [])}),
    names: ['_create_1']
  });
  dart.registerExtension(dart.global.MediaSession, html$.MediaSession);
  dart.defineExtensionNames([
    'addSourceBuffer',
    'endOfStream',
    'removeSourceBuffer',
    'activeSourceBuffers',
    'duration',
    'readyState',
    'sourceBuffers'
  ]);
  html$.MediaSource = class MediaSource extends html$.EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return html$.MediaSource._create_1();
    }
    static _create_1() {
      return new MediaSource();
    }
    static get supported() {
      return !!window.MediaSource;
    }
    get [dartx.activeSourceBuffers]() {
      return this.activeSourceBuffers;
    }
    get [dartx.duration]() {
      return this.duration;
    }
    set [dartx.duration](value) {
      this.duration = value;
    }
    get [dartx.readyState]() {
      return this.readyState;
    }
    get [dartx.sourceBuffers]() {
      return this.sourceBuffers;
    }
    [dartx.addSourceBuffer](type) {
      return this.addSourceBuffer(type);
    }
    [dartx.endOfStream](error) {
      return this.endOfStream(error);
    }
    [dartx.removeSourceBuffer](buffer) {
      return this.removeSourceBuffer(buffer);
    }
  };
  dart.setSignature(html$.MediaSource, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.MediaSource, []),
      new: dart.definiteFunctionType(html$.MediaSource, [])
    }),
    methods: () => ({
      [dartx.addSourceBuffer]: dart.definiteFunctionType(html$.SourceBuffer, [core.String]),
      [dartx.endOfStream]: dart.definiteFunctionType(dart.void, [], [core.String]),
      [dartx.removeSourceBuffer]: dart.definiteFunctionType(dart.void, [html$.SourceBuffer])
    }),
    statics: () => ({
      _create_1: dart.definiteFunctionType(html$.MediaSource, []),
      isTypeSupported: dart.definiteFunctionType(core.bool, [core.String])
    }),
    names: ['_create_1', 'isTypeSupported']
  });
  dart.registerExtension(dart.global.MediaSource, html$.MediaSource);
  dart.defineExtensionNames([
    'addTrack',
    'clone',
    'getAudioTracks',
    'getTrackById',
    'getTracks',
    'getVideoTracks',
    'removeTrack',
    'stop',
    'onAddTrack',
    'onEnded',
    'onRemoveTrack',
    'active',
    'ended',
    'id',
    'label'
  ]);
  html$.MediaStream = class MediaStream extends html$.EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(stream_OR_tracks) {
      if (stream_OR_tracks === void 0) stream_OR_tracks = null;
      if (stream_OR_tracks == null) {
        return html$.MediaStream._create_1();
      }
      if (html$.MediaStream.is(stream_OR_tracks) || stream_OR_tracks == null) {
        return html$.MediaStream._create_2(stream_OR_tracks);
      }
      if (ListOfMediaStreamTrack().is(stream_OR_tracks) || stream_OR_tracks == null) {
        return html$.MediaStream._create_3(stream_OR_tracks);
      }
      dart.throw(new core.ArgumentError("Incorrect number or type of arguments"));
    }
    static _create_1() {
      return new MediaStream();
    }
    static _create_2(stream_OR_tracks) {
      return new MediaStream(stream_OR_tracks);
    }
    static _create_3(stream_OR_tracks) {
      return new MediaStream(stream_OR_tracks);
    }
    get [dartx.active]() {
      return this.active;
    }
    get [dartx.ended]() {
      return this.ended;
    }
    get [dartx.id]() {
      return this.id;
    }
    get [dartx.label]() {
      return this.label;
    }
    [dartx.addTrack](track) {
      return this.addTrack(track);
    }
    [dartx.clone]() {
      return this.clone();
    }
    [dartx.getAudioTracks]() {
      return this.getAudioTracks();
    }
    [dartx.getTrackById](trackId) {
      return this.getTrackById(trackId);
    }
    [dartx.getTracks]() {
      return this.getTracks();
    }
    [dartx.getVideoTracks]() {
      return this.getVideoTracks();
    }
    [dartx.removeTrack](track) {
      return this.removeTrack(track);
    }
    [dartx.stop]() {
      return this.stop();
    }
    get [dartx.onAddTrack]() {
      return html$.MediaStream.addTrackEvent.forTarget(this);
    }
    get [dartx.onEnded]() {
      return html$.MediaStream.endedEvent.forTarget(this);
    }
    get [dartx.onRemoveTrack]() {
      return html$.MediaStream.removeTrackEvent.forTarget(this);
    }
    static get supported() {
      return !!(html$.window[dartx.navigator].getUserMedia || html$.window[dartx.navigator].webkitGetUserMedia || html$.window[dartx.navigator].mozGetUserMedia || html$.window[dartx.navigator].msGetUserMedia);
    }
  };
  dart.setSignature(html$.MediaStream, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.MediaStream, []),
      new: dart.definiteFunctionType(html$.MediaStream, [], [dart.dynamic])
    }),
    methods: () => ({
      [dartx.addTrack]: dart.definiteFunctionType(dart.void, [html$.MediaStreamTrack]),
      [dartx.clone]: dart.definiteFunctionType(html$.MediaStream, []),
      [dartx.getAudioTracks]: dart.definiteFunctionType(core.List$(html$.MediaStreamTrack), []),
      [dartx.getTrackById]: dart.definiteFunctionType(html$.MediaStreamTrack, [core.String]),
      [dartx.getTracks]: dart.definiteFunctionType(core.List$(html$.MediaStreamTrack), []),
      [dartx.getVideoTracks]: dart.definiteFunctionType(core.List$(html$.MediaStreamTrack), []),
      [dartx.removeTrack]: dart.definiteFunctionType(dart.void, [html$.MediaStreamTrack]),
      [dartx.stop]: dart.definiteFunctionType(dart.void, [])
    }),
    statics: () => ({
      _create_1: dart.definiteFunctionType(html$.MediaStream, []),
      _create_2: dart.definiteFunctionType(html$.MediaStream, [dart.dynamic]),
      _create_3: dart.definiteFunctionType(html$.MediaStream, [dart.dynamic])
    }),
    names: ['_create_1', '_create_2', '_create_3']
  });
  dart.defineLazy(html$.MediaStream, {
    get addTrackEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('addtrack'));
    },
    get endedEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('ended'));
    },
    get removeTrackEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('removetrack'));
    }
  });
  dart.registerExtension(dart.global.MediaStream, html$.MediaStream);
  dart.defineExtensionNames([
    'stream'
  ]);
  html$.MediaStreamEvent = class MediaStreamEvent extends html$.Event {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(type, eventInitDict) {
      if (eventInitDict === void 0) eventInitDict = null;
      if (eventInitDict != null) {
        let eventInitDict_1 = html_common.convertDartToNative_Dictionary(eventInitDict);
        return html$.MediaStreamEvent._create_1(type, eventInitDict_1);
      }
      return html$.MediaStreamEvent._create_2(type);
    }
    static _create_1(type, eventInitDict) {
      return new MediaStreamEvent(type, eventInitDict);
    }
    static _create_2(type) {
      return new MediaStreamEvent(type);
    }
    static get supported() {
      return html_common.Device.isEventTypeSupported('MediaStreamEvent');
    }
    get [dartx.stream]() {
      return this.stream;
    }
  };
  dart.setSignature(html$.MediaStreamEvent, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.MediaStreamEvent, []),
      new: dart.definiteFunctionType(html$.MediaStreamEvent, [core.String], [core.Map])
    }),
    statics: () => ({
      _create_1: dart.definiteFunctionType(html$.MediaStreamEvent, [dart.dynamic, dart.dynamic]),
      _create_2: dart.definiteFunctionType(html$.MediaStreamEvent, [dart.dynamic])
    }),
    names: ['_create_1', '_create_2']
  });
  dart.registerExtension(dart.global.MediaStreamEvent, html$.MediaStreamEvent);
  dart.defineExtensionNames([
    'clone',
    'stop',
    'onEnded',
    'onMute',
    'onUnmute',
    'enabled',
    'id',
    'kind',
    'label',
    'muted',
    'readyState'
  ]);
  html$.MediaStreamTrack = class MediaStreamTrack extends html$.EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.enabled]() {
      return this.enabled;
    }
    set [dartx.enabled](value) {
      this.enabled = value;
    }
    get [dartx.id]() {
      return this.id;
    }
    get [dartx.kind]() {
      return this.kind;
    }
    get [dartx.label]() {
      return this.label;
    }
    get [dartx.muted]() {
      return this.muted;
    }
    get [dartx.readyState]() {
      return this.readyState;
    }
    [dartx.clone]() {
      return this.clone();
    }
    static getSources() {
      let completer = CompleterOfListOfSourceInfo().new();
      html$.MediaStreamTrack._getSources(dart.fn(value => {
        completer.complete(value);
      }, ListOfSourceInfoTovoid()));
      return completer.future;
    }
    [dartx.stop]() {
      return this.stop();
    }
    get [dartx.onEnded]() {
      return html$.MediaStreamTrack.endedEvent.forTarget(this);
    }
    get [dartx.onMute]() {
      return html$.MediaStreamTrack.muteEvent.forTarget(this);
    }
    get [dartx.onUnmute]() {
      return html$.MediaStreamTrack.unmuteEvent.forTarget(this);
    }
  };
  dart.setSignature(html$.MediaStreamTrack, {
    constructors: () => ({_: dart.definiteFunctionType(html$.MediaStreamTrack, [])}),
    methods: () => ({
      [dartx.clone]: dart.definiteFunctionType(html$.MediaStreamTrack, []),
      [dartx.stop]: dart.definiteFunctionType(dart.void, [])
    }),
    statics: () => ({
      _getSources: dart.definiteFunctionType(dart.void, [html$.MediaStreamTrackSourcesCallback]),
      getSources: dart.definiteFunctionType(async.Future$(core.List$(html$.SourceInfo)), [])
    }),
    names: ['_getSources', 'getSources']
  });
  dart.defineLazy(html$.MediaStreamTrack, {
    get endedEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('ended'));
    },
    get muteEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('mute'));
    },
    get unmuteEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('unmute'));
    }
  });
  dart.registerExtension(dart.global.MediaStreamTrack, html$.MediaStreamTrack);
  dart.defineExtensionNames([
    'track'
  ]);
  html$.MediaStreamTrackEvent = class MediaStreamTrackEvent extends html$.Event {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static get supported() {
      return html_common.Device.isEventTypeSupported('MediaStreamTrackEvent');
    }
    get [dartx.track]() {
      return this.track;
    }
  };
  dart.setSignature(html$.MediaStreamTrackEvent, {
    constructors: () => ({_: dart.definiteFunctionType(html$.MediaStreamTrackEvent, [])})
  });
  dart.registerExtension(dart.global.MediaStreamTrackEvent, html$.MediaStreamTrackEvent);
  html$.MediaStreamTrackSourcesCallback = dart.typedef('MediaStreamTrackSourcesCallback', () => dart.functionType(dart.void, [core.List$(html$.SourceInfo)]));
  dart.defineExtensionNames([
    'jsHeapSizeLimit',
    'totalJSHeapSize',
    'usedJSHeapSize'
  ]);
  html$.MemoryInfo = class MemoryInfo extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.jsHeapSizeLimit]() {
      return this.jsHeapSizeLimit;
    }
    get [dartx.totalJSHeapSize]() {
      return this.totalJSHeapSize;
    }
    get [dartx.usedJSHeapSize]() {
      return this.usedJSHeapSize;
    }
  };
  dart.setSignature(html$.MemoryInfo, {
    constructors: () => ({_: dart.definiteFunctionType(html$.MemoryInfo, [])})
  });
  dart.registerExtension(dart.global.MemoryInfo, html$.MemoryInfo);
  dart.defineExtensionNames([
    'label',
    'type'
  ]);
  html$.MenuElement = class MenuElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return html$.MenuElement._check(html$.document[dartx.createElement]("menu"));
    }
    created() {
      this[dartx.label] = null;
      this[dartx.type] = null;
      super.created();
    }
    get [dartx.label]() {
      return this.label;
    }
    set [dartx.label](value) {
      this.label = value;
    }
    get [dartx.type]() {
      return this.type;
    }
    set [dartx.type](value) {
      this.type = value;
    }
  };
  dart.defineNamedConstructor(html$.MenuElement, 'created');
  dart.setSignature(html$.MenuElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.MenuElement, []),
      new: dart.definiteFunctionType(html$.MenuElement, []),
      created: dart.definiteFunctionType(html$.MenuElement, [])
    })
  });
  dart.registerExtension(dart.global.HTMLMenuElement, html$.MenuElement);
  dart.defineExtensionNames([
    'checked',
    'defaultValue',
    'disabled',
    'icon',
    'label',
    'radiogroup',
    'type'
  ]);
  html$.MenuItemElement = class MenuItemElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    created() {
      this[dartx.checked] = null;
      this[dartx.defaultValue] = null;
      this[dartx.disabled] = null;
      this[dartx.icon] = null;
      this[dartx.label] = null;
      this[dartx.radiogroup] = null;
      this[dartx.type] = null;
      super.created();
    }
    get [dartx.checked]() {
      return this.checked;
    }
    set [dartx.checked](value) {
      this.checked = value;
    }
    get [dartx.defaultValue]() {
      return this.default;
    }
    set [dartx.defaultValue](value) {
      this.default = value;
    }
    get [dartx.disabled]() {
      return this.disabled;
    }
    set [dartx.disabled](value) {
      this.disabled = value;
    }
    get [dartx.icon]() {
      return this.icon;
    }
    set [dartx.icon](value) {
      this.icon = value;
    }
    get [dartx.label]() {
      return this.label;
    }
    set [dartx.label](value) {
      this.label = value;
    }
    get [dartx.radiogroup]() {
      return this.radiogroup;
    }
    set [dartx.radiogroup](value) {
      this.radiogroup = value;
    }
    get [dartx.type]() {
      return this.type;
    }
    set [dartx.type](value) {
      this.type = value;
    }
  };
  dart.defineNamedConstructor(html$.MenuItemElement, 'created');
  dart.setSignature(html$.MenuItemElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.MenuItemElement, []),
      created: dart.definiteFunctionType(html$.MenuItemElement, [])
    })
  });
  dart.registerExtension(dart.global.HTMLMenuItemElement, html$.MenuItemElement);
  dart.defineExtensionNames([
    'port1',
    'port2'
  ]);
  html$.MessageChannel = class MessageChannel extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.port1]() {
      return this.port1;
    }
    get [dartx.port2]() {
      return this.port2;
    }
  };
  dart.setSignature(html$.MessageChannel, {
    constructors: () => ({_: dart.definiteFunctionType(html$.MessageChannel, [])})
  });
  dart.registerExtension(dart.global.MessageChannel, html$.MessageChannel);
  const _initMessageEvent = Symbol('_initMessageEvent');
  const _get_data = Symbol('_get_data');
  const _get_source = Symbol('_get_source');
  dart.defineExtensionNames([
    'data',
    'source',
    'lastEventId',
    'origin'
  ]);
  html$.MessageEvent = class MessageEvent extends html$.Event {
    static new(type, opts) {
      let canBubble = opts && 'canBubble' in opts ? opts.canBubble : false;
      let cancelable = opts && 'cancelable' in opts ? opts.cancelable : false;
      let data = opts && 'data' in opts ? opts.data : null;
      let origin = opts && 'origin' in opts ? opts.origin : null;
      let lastEventId = opts && 'lastEventId' in opts ? opts.lastEventId : null;
      let source = opts && 'source' in opts ? opts.source : null;
      let messagePorts = opts && 'messagePorts' in opts ? opts.messagePorts : null;
      if (source == null) {
        source = html$.window;
      }
      if (!dart.test(html_common.Device.isIE)) {
        return new MessageEvent(type, {bubbles: canBubble, cancelable: cancelable, data: data, origin: origin, lastEventId: lastEventId, source: source, ports: messagePorts});
      }
      let event = html$.MessageEvent._check(html$.document[_createEvent]("MessageEvent"));
      event[_initMessageEvent](type, canBubble, cancelable, data, origin, lastEventId, source, messagePorts);
      return event;
    }
    get [dartx.data]() {
      return html_common.convertNativeToDart_SerializedScriptValue(this[_get_data]);
    }
    get [_get_data]() {
      return this.data;
    }
    static _(type, eventInitDict) {
      if (eventInitDict === void 0) eventInitDict = null;
      if (eventInitDict != null) {
        let eventInitDict_1 = html_common.convertDartToNative_Dictionary(eventInitDict);
        return html$.MessageEvent._create_1(type, eventInitDict_1);
      }
      return html$.MessageEvent._create_2(type);
    }
    static _create_1(type, eventInitDict) {
      return new MessageEvent(type, eventInitDict);
    }
    static _create_2(type) {
      return new MessageEvent(type);
    }
    get [dartx.lastEventId]() {
      return this.lastEventId;
    }
    get [dartx.origin]() {
      return this.origin;
    }
    get [dartx.source]() {
      return html$._convertNativeToDart_EventTarget(this[_get_source]);
    }
    get [_get_source]() {
      return this.source;
    }
    [_initMessageEvent](typeArg, canBubbleArg, cancelableArg, dataArg, originArg, lastEventIdArg, sourceArg, portsArg) {
      return this.initMessageEvent(typeArg, canBubbleArg, cancelableArg, dataArg, originArg, lastEventIdArg, sourceArg, portsArg);
    }
  };
  dart.setSignature(html$.MessageEvent, {
    constructors: () => ({
      new: dart.definiteFunctionType(html$.MessageEvent, [core.String], {canBubble: core.bool, cancelable: core.bool, data: core.Object, origin: core.String, lastEventId: core.String, source: html$.Window, messagePorts: ListOfMessagePort()}),
      _: dart.definiteFunctionType(html$.MessageEvent, [core.String], [core.Map])
    }),
    methods: () => ({[_initMessageEvent]: dart.definiteFunctionType(dart.void, [core.String, core.bool, core.bool, core.Object, core.String, core.String, html$.Window, core.List$(html$.MessagePort)])}),
    statics: () => ({
      _create_1: dart.definiteFunctionType(html$.MessageEvent, [dart.dynamic, dart.dynamic]),
      _create_2: dart.definiteFunctionType(html$.MessageEvent, [dart.dynamic])
    }),
    names: ['_create_1', '_create_2']
  });
  dart.registerExtension(dart.global.MessageEvent, html$.MessageEvent);
  dart.defineExtensionNames([
    'close',
    'postMessage',
    'start',
    'onMessage'
  ]);
  html$.MessagePort = class MessagePort extends html$.EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [dartx.close]() {
      return this.close();
    }
    [dartx.postMessage](message, transfer) {
      if (transfer === void 0) transfer = null;
      if (transfer != null) {
        let message_1 = html_common.convertDartToNative_SerializedScriptValue(message);
        this[_postMessage_1](message_1, transfer);
        return;
      }
      let message_1 = html_common.convertDartToNative_SerializedScriptValue(message);
      this[_postMessage_2](message_1);
      return;
    }
    [_postMessage_1](message, transfer) {
      return this.postMessage(message, transfer);
    }
    [_postMessage_2](message) {
      return this.postMessage(message);
    }
    [dartx.start]() {
      return this.start();
    }
    get [dartx.onMessage]() {
      return html$.MessagePort.messageEvent.forTarget(this);
    }
  };
  dart.setSignature(html$.MessagePort, {
    constructors: () => ({_: dart.definiteFunctionType(html$.MessagePort, [])}),
    methods: () => ({
      [dartx.close]: dart.definiteFunctionType(dart.void, []),
      [dartx.postMessage]: dart.definiteFunctionType(dart.void, [dart.dynamic], [core.List$(html$.MessagePort)]),
      [_postMessage_1]: dart.definiteFunctionType(dart.void, [dart.dynamic, core.List$(html$.MessagePort)]),
      [_postMessage_2]: dart.definiteFunctionType(dart.void, [dart.dynamic]),
      [dartx.start]: dart.definiteFunctionType(dart.void, [])
    })
  });
  dart.defineLazy(html$.MessagePort, {
    get messageEvent() {
      return dart.const(new (EventStreamProviderOfMessageEvent())('message'));
    }
  });
  dart.registerExtension(dart.global.MessagePort, html$.MessagePort);
  dart.defineExtensionNames([
    'content',
    'httpEquiv',
    'name'
  ]);
  html$.MetaElement = class MetaElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return html$.MetaElement._check(html$.document[dartx.createElement]("meta"));
    }
    created() {
      this[dartx.content] = null;
      this[dartx.httpEquiv] = null;
      this[dartx.name] = null;
      super.created();
    }
    get [dartx.content]() {
      return this.content;
    }
    set [dartx.content](value) {
      this.content = value;
    }
    get [dartx.httpEquiv]() {
      return this.httpEquiv;
    }
    set [dartx.httpEquiv](value) {
      this.httpEquiv = value;
    }
    get [dartx.name]() {
      return this.name;
    }
    set [dartx.name](value) {
      this.name = value;
    }
  };
  dart.defineNamedConstructor(html$.MetaElement, 'created');
  dart.setSignature(html$.MetaElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.MetaElement, []),
      new: dart.definiteFunctionType(html$.MetaElement, []),
      created: dart.definiteFunctionType(html$.MetaElement, [])
    })
  });
  dart.registerExtension(dart.global.HTMLMetaElement, html$.MetaElement);
  const _get_modificationTime = Symbol('_get_modificationTime');
  dart.defineExtensionNames([
    'modificationTime',
    'size'
  ]);
  html$.Metadata = class Metadata extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.modificationTime]() {
      return html_common.convertNativeToDart_DateTime(this[_get_modificationTime]);
    }
    get [_get_modificationTime]() {
      return this.modificationTime;
    }
    get [dartx.size]() {
      return this.size;
    }
  };
  dart.setSignature(html$.Metadata, {
    constructors: () => ({_: dart.definiteFunctionType(html$.Metadata, [])})
  });
  dart.registerExtension(dart.global.Metadata, html$.Metadata);
  html$.MetadataCallback = dart.typedef('MetadataCallback', () => dart.functionType(dart.void, [html$.Metadata]));
  dart.defineExtensionNames([
    'high',
    'labels',
    'low',
    'max',
    'min',
    'optimum',
    'value'
  ]);
  html$.MeterElement = class MeterElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return html$.MeterElement._check(html$.document[dartx.createElement]("meter"));
    }
    created() {
      this[dartx.high] = null;
      this[dartx.labels] = null;
      this[dartx.low] = null;
      this[dartx.max] = null;
      this[dartx.min] = null;
      this[dartx.optimum] = null;
      this[dartx.value] = null;
      super.created();
    }
    static get supported() {
      return html$.Element.isTagSupported('meter');
    }
    get [dartx.high]() {
      return this.high;
    }
    set [dartx.high](value) {
      this.high = value;
    }
    get [dartx.labels]() {
      return this.labels;
    }
    get [dartx.low]() {
      return this.low;
    }
    set [dartx.low](value) {
      this.low = value;
    }
    get [dartx.max]() {
      return this.max;
    }
    set [dartx.max](value) {
      this.max = value;
    }
    get [dartx.min]() {
      return this.min;
    }
    set [dartx.min](value) {
      this.min = value;
    }
    get [dartx.optimum]() {
      return this.optimum;
    }
    set [dartx.optimum](value) {
      this.optimum = value;
    }
    get [dartx.value]() {
      return this.value;
    }
    set [dartx.value](value) {
      this.value = value;
    }
  };
  dart.defineNamedConstructor(html$.MeterElement, 'created');
  dart.setSignature(html$.MeterElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.MeterElement, []),
      new: dart.definiteFunctionType(html$.MeterElement, []),
      created: dart.definiteFunctionType(html$.MeterElement, [])
    })
  });
  dart.registerExtension(dart.global.HTMLMeterElement, html$.MeterElement);
  dart.defineExtensionNames([
    'inputs',
    'outputs',
    'sysexEnabled'
  ]);
  html$.MidiAccess = class MidiAccess extends html$.EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.inputs]() {
      return this.inputs;
    }
    get [dartx.outputs]() {
      return this.outputs;
    }
    get [dartx.sysexEnabled]() {
      return this.sysexEnabled;
    }
  };
  dart.setSignature(html$.MidiAccess, {
    constructors: () => ({_: dart.definiteFunctionType(html$.MidiAccess, [])})
  });
  dart.registerExtension(dart.global.MIDIAccess, html$.MidiAccess);
  dart.defineExtensionNames([
    'port'
  ]);
  html$.MidiConnectionEvent = class MidiConnectionEvent extends html$.Event {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(type, eventInitDict) {
      if (eventInitDict === void 0) eventInitDict = null;
      if (eventInitDict != null) {
        let eventInitDict_1 = html_common.convertDartToNative_Dictionary(eventInitDict);
        return html$.MidiConnectionEvent._create_1(type, eventInitDict_1);
      }
      return html$.MidiConnectionEvent._create_2(type);
    }
    static _create_1(type, eventInitDict) {
      return new MIDIConnectionEvent(type, eventInitDict);
    }
    static _create_2(type) {
      return new MIDIConnectionEvent(type);
    }
    get [dartx.port]() {
      return this.port;
    }
  };
  dart.setSignature(html$.MidiConnectionEvent, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.MidiConnectionEvent, []),
      new: dart.definiteFunctionType(html$.MidiConnectionEvent, [core.String], [core.Map])
    }),
    statics: () => ({
      _create_1: dart.definiteFunctionType(html$.MidiConnectionEvent, [dart.dynamic, dart.dynamic]),
      _create_2: dart.definiteFunctionType(html$.MidiConnectionEvent, [dart.dynamic])
    }),
    names: ['_create_1', '_create_2']
  });
  dart.registerExtension(dart.global.MIDIConnectionEvent, html$.MidiConnectionEvent);
  dart.defineExtensionNames([
    'close',
    'open',
    'connection',
    'id',
    'manufacturer',
    'name',
    'state',
    'type',
    'version'
  ]);
  html$.MidiPort = class MidiPort extends html$.EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.connection]() {
      return this.connection;
    }
    get [dartx.id]() {
      return this.id;
    }
    get [dartx.manufacturer]() {
      return this.manufacturer;
    }
    get [dartx.name]() {
      return this.name;
    }
    get [dartx.state]() {
      return this.state;
    }
    get [dartx.type]() {
      return this.type;
    }
    get [dartx.version]() {
      return this.version;
    }
    [dartx.close]() {
      return this.close();
    }
    [dartx.open]() {
      return this.open();
    }
  };
  dart.setSignature(html$.MidiPort, {
    constructors: () => ({_: dart.definiteFunctionType(html$.MidiPort, [])}),
    methods: () => ({
      [dartx.close]: dart.definiteFunctionType(async.Future, []),
      [dartx.open]: dart.definiteFunctionType(async.Future, [])
    })
  });
  dart.registerExtension(dart.global.MIDIPort, html$.MidiPort);
  dart.defineExtensionNames([
    'onMidiMessage'
  ]);
  html$.MidiInput = class MidiInput extends html$.MidiPort {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.onMidiMessage]() {
      return html$.MidiInput.midiMessageEvent.forTarget(this);
    }
  };
  dart.setSignature(html$.MidiInput, {
    constructors: () => ({_: dart.definiteFunctionType(html$.MidiInput, [])})
  });
  dart.defineLazy(html$.MidiInput, {
    get midiMessageEvent() {
      return dart.const(new (EventStreamProviderOfMidiMessageEvent())('midimessage'));
    }
  });
  dart.registerExtension(dart.global.MIDIInput, html$.MidiInput);
  dart.defineExtensionNames([
    'size'
  ]);
  html$.MidiInputMap = class MidiInputMap extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.size]() {
      return this.size;
    }
  };
  dart.setSignature(html$.MidiInputMap, {
    constructors: () => ({_: dart.definiteFunctionType(html$.MidiInputMap, [])})
  });
  dart.registerExtension(dart.global.MIDIInputMap, html$.MidiInputMap);
  dart.defineExtensionNames([
    'data',
    'receivedTime'
  ]);
  html$.MidiMessageEvent = class MidiMessageEvent extends html$.Event {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(type, eventInitDict) {
      if (eventInitDict === void 0) eventInitDict = null;
      if (eventInitDict != null) {
        let eventInitDict_1 = html_common.convertDartToNative_Dictionary(eventInitDict);
        return html$.MidiMessageEvent._create_1(type, eventInitDict_1);
      }
      return html$.MidiMessageEvent._create_2(type);
    }
    static _create_1(type, eventInitDict) {
      return new MIDIMessageEvent(type, eventInitDict);
    }
    static _create_2(type) {
      return new MIDIMessageEvent(type);
    }
    get [dartx.data]() {
      return this.data;
    }
    get [dartx.receivedTime]() {
      return this.receivedTime;
    }
  };
  dart.setSignature(html$.MidiMessageEvent, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.MidiMessageEvent, []),
      new: dart.definiteFunctionType(html$.MidiMessageEvent, [core.String], [core.Map])
    }),
    statics: () => ({
      _create_1: dart.definiteFunctionType(html$.MidiMessageEvent, [dart.dynamic, dart.dynamic]),
      _create_2: dart.definiteFunctionType(html$.MidiMessageEvent, [dart.dynamic])
    }),
    names: ['_create_1', '_create_2']
  });
  dart.registerExtension(dart.global.MIDIMessageEvent, html$.MidiMessageEvent);
  dart.defineExtensionNames([
    'send'
  ]);
  html$.MidiOutput = class MidiOutput extends html$.MidiPort {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [dartx.send](data, timestamp) {
      return this.send(data, timestamp);
    }
  };
  dart.setSignature(html$.MidiOutput, {
    constructors: () => ({_: dart.definiteFunctionType(html$.MidiOutput, [])}),
    methods: () => ({[dartx.send]: dart.definiteFunctionType(dart.void, [typed_data.Uint8List], [core.num])})
  });
  dart.registerExtension(dart.global.MIDIOutput, html$.MidiOutput);
  dart.defineExtensionNames([
    'size'
  ]);
  html$.MidiOutputMap = class MidiOutputMap extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.size]() {
      return this.size;
    }
  };
  dart.setSignature(html$.MidiOutputMap, {
    constructors: () => ({_: dart.definiteFunctionType(html$.MidiOutputMap, [])})
  });
  dart.registerExtension(dart.global.MIDIOutputMap, html$.MidiOutputMap);
  dart.defineExtensionNames([
    'description',
    'enabledPlugin',
    'suffixes',
    'type'
  ]);
  html$.MimeType = class MimeType extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.description]() {
      return this.description;
    }
    get [dartx.enabledPlugin]() {
      return this.enabledPlugin;
    }
    get [dartx.suffixes]() {
      return this.suffixes;
    }
    get [dartx.type]() {
      return this.type;
    }
  };
  dart.setSignature(html$.MimeType, {
    constructors: () => ({_: dart.definiteFunctionType(html$.MimeType, [])})
  });
  dart.registerExtension(dart.global.MimeType, html$.MimeType);
  dart.defineExtensionNames([
    'length',
    'get',
    'set',
    'length',
    'first',
    'last',
    'single',
    'elementAt',
    'item',
    'namedItem'
  ]);
  html$.MimeTypeArray = class MimeTypeArray extends dart.mixin(_interceptors.Interceptor, collection.ListMixin$(html$.MimeType), html$.ImmutableListMixin$(html$.MimeType)) {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.length]() {
      return this.length;
    }
    [dartx.get](index) {
      if (index >>> 0 !== index || index >= this[dartx.length]) dart.throw(core.RangeError.index(index, this));
      return this[index];
    }
    [dartx.set](index, value) {
      dart.throw(new core.UnsupportedError("Cannot assign element of immutable List."));
      return value;
    }
    set [dartx.length](value) {
      dart.throw(new core.UnsupportedError("Cannot resize immutable List."));
    }
    get [dartx.first]() {
      if (dart.notNull(this[dartx.length]) > 0) {
        return this[0];
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.last]() {
      let len = this[dartx.length];
      if (dart.notNull(len) > 0) {
        return this[dart.notNull(len) - 1];
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.single]() {
      let len = this[dartx.length];
      if (len == 1) {
        return this[0];
      }
      if (len == 0) dart.throw(new core.StateError("No elements"));
      dart.throw(new core.StateError("More than one element"));
    }
    [dartx.elementAt](index) {
      return this[dartx.get](index);
    }
    [dartx.item](index) {
      return this.item(index);
    }
    [dartx.namedItem](name) {
      return this.namedItem(name);
    }
  };
  html$.MimeTypeArray[dart.implements] = () => [_js_helper.JavaScriptIndexingBehavior, ListOfMimeType()];
  dart.setSignature(html$.MimeTypeArray, {
    constructors: () => ({_: dart.definiteFunctionType(html$.MimeTypeArray, [])}),
    methods: () => ({
      [dartx.get]: dart.definiteFunctionType(html$.MimeType, [core.int]),
      [dartx.set]: dart.definiteFunctionType(dart.void, [core.int, html$.MimeType]),
      [dartx.elementAt]: dart.definiteFunctionType(html$.MimeType, [core.int]),
      [dartx.item]: dart.definiteFunctionType(html$.MimeType, [core.int]),
      [dartx.namedItem]: dart.definiteFunctionType(html$.MimeType, [core.String])
    })
  });
  dart.registerExtension(dart.global.MimeTypeArray, html$.MimeTypeArray);
  dart.defineExtensionNames([
    'cite',
    'dateTime'
  ]);
  html$.ModElement = class ModElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    created() {
      this[dartx.cite] = null;
      this[dartx.dateTime] = null;
      super.created();
    }
    get [dartx.cite]() {
      return this.cite;
    }
    set [dartx.cite](value) {
      this.cite = value;
    }
    get [dartx.dateTime]() {
      return this.dateTime;
    }
    set [dartx.dateTime](value) {
      this.dateTime = value;
    }
  };
  dart.defineNamedConstructor(html$.ModElement, 'created');
  dart.setSignature(html$.ModElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.ModElement, []),
      created: dart.definiteFunctionType(html$.ModElement, [])
    })
  });
  dart.registerExtension(dart.global.HTMLModElement, html$.ModElement);
  const _initMouseEvent = Symbol('_initMouseEvent');
  const _clientX = Symbol('_clientX');
  const _clientY = Symbol('_clientY');
  const _layerX = Symbol('_layerX');
  const _layerY = Symbol('_layerY');
  const _movementX = Symbol('_movementX');
  const _movementY = Symbol('_movementY');
  const _pageX = Symbol('_pageX');
  const _pageY = Symbol('_pageY');
  const _screenX = Symbol('_screenX');
  const _screenY = Symbol('_screenY');
  const _webkitMovementX = Symbol('_webkitMovementX');
  const _webkitMovementY = Symbol('_webkitMovementY');
  const _initMouseEvent_1 = Symbol('_initMouseEvent_1');
  dart.defineExtensionNames([
    'relatedTarget',
    'client',
    'movement',
    'offset',
    'screen',
    'layer',
    'page',
    'altKey',
    'button',
    'buttons',
    'ctrlKey',
    'dataTransfer',
    'fromElement',
    'metaKey',
    'region',
    'shiftKey',
    'toElement'
  ]);
  html$.MouseEvent = class MouseEvent extends html$.UIEvent {
    static new(type, opts) {
      let view = opts && 'view' in opts ? opts.view : null;
      let detail = opts && 'detail' in opts ? opts.detail : 0;
      let screenX = opts && 'screenX' in opts ? opts.screenX : 0;
      let screenY = opts && 'screenY' in opts ? opts.screenY : 0;
      let clientX = opts && 'clientX' in opts ? opts.clientX : 0;
      let clientY = opts && 'clientY' in opts ? opts.clientY : 0;
      let button = opts && 'button' in opts ? opts.button : 0;
      let canBubble = opts && 'canBubble' in opts ? opts.canBubble : true;
      let cancelable = opts && 'cancelable' in opts ? opts.cancelable : true;
      let ctrlKey = opts && 'ctrlKey' in opts ? opts.ctrlKey : false;
      let altKey = opts && 'altKey' in opts ? opts.altKey : false;
      let shiftKey = opts && 'shiftKey' in opts ? opts.shiftKey : false;
      let metaKey = opts && 'metaKey' in opts ? opts.metaKey : false;
      let relatedTarget = opts && 'relatedTarget' in opts ? opts.relatedTarget : null;
      if (view == null) {
        view = html$.window;
      }
      let event = html$.MouseEvent._check(html$.document[_createEvent]('MouseEvent'));
      event[_initMouseEvent](type, canBubble, cancelable, view, detail, screenX, screenY, clientX, clientY, ctrlKey, altKey, shiftKey, metaKey, button, relatedTarget);
      return event;
    }
    static _(type, eventInitDict) {
      if (eventInitDict === void 0) eventInitDict = null;
      if (eventInitDict != null) {
        let eventInitDict_1 = html_common.convertDartToNative_Dictionary(eventInitDict);
        return html$.MouseEvent._create_1(type, eventInitDict_1);
      }
      return html$.MouseEvent._create_2(type);
    }
    static _create_1(type, eventInitDict) {
      return new MouseEvent(type, eventInitDict);
    }
    static _create_2(type) {
      return new MouseEvent(type);
    }
    get [dartx.altKey]() {
      return this.altKey;
    }
    get [dartx.button]() {
      return this.button;
    }
    get [dartx.buttons]() {
      return this.buttons;
    }
    get [_clientX]() {
      return this.clientX;
    }
    get [_clientY]() {
      return this.clientY;
    }
    get [dartx.ctrlKey]() {
      return this.ctrlKey;
    }
    get [dartx.dataTransfer]() {
      return this.dataTransfer;
    }
    get [dartx.fromElement]() {
      return this.fromElement;
    }
    get [_layerX]() {
      return this.layerX;
    }
    get [_layerY]() {
      return this.layerY;
    }
    get [dartx.metaKey]() {
      return this.metaKey;
    }
    get [_movementX]() {
      return this.movementX;
    }
    get [_movementY]() {
      return this.movementY;
    }
    get [_pageX]() {
      return this.pageX;
    }
    get [_pageY]() {
      return this.pageY;
    }
    get [dartx.region]() {
      return this.region;
    }
    get [dartx.relatedTarget]() {
      return html$._convertNativeToDart_EventTarget(this[_get_relatedTarget]);
    }
    get [_get_relatedTarget]() {
      return this.relatedTarget;
    }
    get [_screenX]() {
      return this.screenX;
    }
    get [_screenY]() {
      return this.screenY;
    }
    get [dartx.shiftKey]() {
      return this.shiftKey;
    }
    get [dartx.toElement]() {
      return this.toElement;
    }
    get [_webkitMovementX]() {
      return this.webkitMovementX;
    }
    get [_webkitMovementY]() {
      return this.webkitMovementY;
    }
    [_initMouseEvent](type, bubbles, cancelable, view, detail, screenX, screenY, clientX, clientY, ctrlKey, altKey, shiftKey, metaKey, button, relatedTarget) {
      let relatedTarget_1 = html$._convertDartToNative_EventTarget(relatedTarget);
      this[_initMouseEvent_1](type, bubbles, cancelable, view, detail, screenX, screenY, clientX, clientY, ctrlKey, altKey, shiftKey, metaKey, button, relatedTarget_1);
      return;
    }
    [_initMouseEvent_1](type, bubbles, cancelable, view, detail, screenX, screenY, clientX, clientY, ctrlKey, altKey, shiftKey, metaKey, button, relatedTarget) {
      return this.initMouseEvent(type, bubbles, cancelable, view, detail, screenX, screenY, clientX, clientY, ctrlKey, altKey, shiftKey, metaKey, button, relatedTarget);
    }
    get [dartx.client]() {
      return new (PointOfnum())(this[_clientX], this[_clientY]);
    }
    get [dartx.movement]() {
      return new (PointOfnum())(this[_webkitMovementX], this[_webkitMovementY]);
    }
    get [dartx.offset]() {
      if (!!this.offsetX) {
        let x = this.offsetX;
        let y = this.offsetY;
        return new (PointOfnum())(x, y);
      } else {
        if (!html$.Element.is(this[dartx.target])) {
          dart.throw(new core.UnsupportedError('offsetX is only supported on elements'));
        }
        let target = html$.Element._check(this[dartx.target]);
        let point = this[dartx.client]['-'](target[dartx.getBoundingClientRect]()[dartx.topLeft]);
        return new (PointOfnum())(point.x[dartx.toInt](), point.y[dartx.toInt]());
      }
    }
    get [dartx.screen]() {
      return new (PointOfnum())(this[_screenX], this[_screenY]);
    }
    get [dartx.layer]() {
      return new (PointOfnum())(this[_layerX], this[_layerY]);
    }
    get [dartx.page]() {
      return new (PointOfnum())(this[_pageX], this[_pageY]);
    }
  };
  dart.setSignature(html$.MouseEvent, {
    constructors: () => ({
      new: dart.definiteFunctionType(html$.MouseEvent, [core.String], {view: html$.Window, detail: core.int, screenX: core.int, screenY: core.int, clientX: core.int, clientY: core.int, button: core.int, canBubble: core.bool, cancelable: core.bool, ctrlKey: core.bool, altKey: core.bool, shiftKey: core.bool, metaKey: core.bool, relatedTarget: html$.EventTarget}),
      _: dart.definiteFunctionType(html$.MouseEvent, [core.String], [core.Map])
    }),
    methods: () => ({
      [_initMouseEvent]: dart.definiteFunctionType(dart.void, [core.String, core.bool, core.bool, html$.Window, core.int, core.int, core.int, core.int, core.int, core.bool, core.bool, core.bool, core.bool, core.int, html$.EventTarget]),
      [_initMouseEvent_1]: dart.definiteFunctionType(dart.void, [dart.dynamic, dart.dynamic, dart.dynamic, html$.Window, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic])
    }),
    statics: () => ({
      _create_1: dart.definiteFunctionType(html$.MouseEvent, [dart.dynamic, dart.dynamic]),
      _create_2: dart.definiteFunctionType(html$.MouseEvent, [dart.dynamic])
    }),
    names: ['_create_1', '_create_2']
  });
  dart.registerExtension(dart.global.MouseEvent, html$.MouseEvent);
  html$.MutationCallback = dart.typedef('MutationCallback', () => dart.functionType(dart.void, [core.List$(html$.MutationRecord), html$.MutationObserver]));
  const _observe_1 = Symbol('_observe_1');
  const _observe = Symbol('_observe');
  const _call = Symbol('_call');
  dart.defineExtensionNames([
    'disconnect',
    'takeRecords',
    'observe'
  ]);
  html$.MutationObserver = class MutationObserver extends _interceptors.Interceptor {
    [dartx.disconnect]() {
      return this.disconnect();
    }
    [_observe](target, options) {
      let options_1 = html_common.convertDartToNative_Dictionary(options);
      this[_observe_1](target, options_1);
      return;
    }
    [_observe_1](target, options) {
      return this.observe(target, options);
    }
    [dartx.takeRecords]() {
      return this.takeRecords();
    }
    static get supported() {
      return !!(window.MutationObserver || window.WebKitMutationObserver);
    }
    [dartx.observe](target, opts) {
      let childList = opts && 'childList' in opts ? opts.childList : null;
      let attributes = opts && 'attributes' in opts ? opts.attributes : null;
      let characterData = opts && 'characterData' in opts ? opts.characterData : null;
      let subtree = opts && 'subtree' in opts ? opts.subtree : null;
      let attributeOldValue = opts && 'attributeOldValue' in opts ? opts.attributeOldValue : null;
      let characterDataOldValue = opts && 'characterDataOldValue' in opts ? opts.characterDataOldValue : null;
      let attributeFilter = opts && 'attributeFilter' in opts ? opts.attributeFilter : null;
      let parsedOptions = html$.MutationObserver._createDict();
      function override(key, value) {
        if (value != null) html$.MutationObserver._add(parsedOptions, core.String._check(key), value);
      }
      dart.fn(override, dynamicAnddynamicTodynamic$());
      override('childList', childList);
      override('attributes', attributes);
      override('characterData', characterData);
      override('subtree', subtree);
      override('attributeOldValue', attributeOldValue);
      override('characterDataOldValue', characterDataOldValue);
      if (attributeFilter != null) {
        override('attributeFilter', html$.MutationObserver._fixupList(attributeFilter));
      }
      this[_call](target, parsedOptions);
    }
    static _createDict() {
      return {};
    }
    static _add(m, key, value) {
      m[key] = value;
    }
    static _fixupList(list) {
      return list;
    }
    [_call](target, options) {
      return this.observe(target, options);
    }
    static new(callback) {
      0;
      return new (window.MutationObserver || window.WebKitMutationObserver || window.MozMutationObserver)(_js_helper.convertDartClosureToJS(html$._wrapZoneBinaryCallback)(html$._wrapBinaryZone(dart.dynamic, dart.dynamic, dart.dynamic)(callback), 2));
    }
  };
  dart.setSignature(html$.MutationObserver, {
    constructors: () => ({new: dart.definiteFunctionType(html$.MutationObserver, [html$.MutationCallback])}),
    methods: () => ({
      [dartx.disconnect]: dart.definiteFunctionType(dart.void, []),
      [_observe]: dart.definiteFunctionType(dart.void, [html$.Node, core.Map]),
      [_observe_1]: dart.definiteFunctionType(dart.void, [html$.Node, dart.dynamic]),
      [dartx.takeRecords]: dart.definiteFunctionType(core.List$(html$.MutationRecord), []),
      [dartx.observe]: dart.definiteFunctionType(dart.void, [html$.Node], {childList: core.bool, attributes: core.bool, characterData: core.bool, subtree: core.bool, attributeOldValue: core.bool, characterDataOldValue: core.bool, attributeFilter: ListOfString()}),
      [_call]: dart.definiteFunctionType(dart.void, [dart.dynamic, dart.dynamic])
    }),
    statics: () => ({
      _createDict: dart.definiteFunctionType(dart.dynamic, []),
      _add: dart.definiteFunctionType(dart.dynamic, [dart.dynamic, core.String, dart.dynamic]),
      _fixupList: dart.definiteFunctionType(dart.dynamic, [dart.dynamic])
    }),
    names: ['_createDict', '_add', '_fixupList']
  });
  html$.MutationObserver._boolKeys = dart.const(dart.map({childList: true, attributes: true, characterData: true, subtree: true, attributeOldValue: true, characterDataOldValue: true}));
  dart.registerExtension(dart.global.MutationObserver, html$.MutationObserver);
  dart.defineExtensionNames([
    'addedNodes',
    'attributeName',
    'attributeNamespace',
    'nextSibling',
    'oldValue',
    'previousSibling',
    'removedNodes',
    'target',
    'type'
  ]);
  html$.MutationRecord = class MutationRecord extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.addedNodes]() {
      return this.addedNodes;
    }
    get [dartx.attributeName]() {
      return this.attributeName;
    }
    get [dartx.attributeNamespace]() {
      return this.attributeNamespace;
    }
    get [dartx.nextSibling]() {
      return this.nextSibling;
    }
    get [dartx.oldValue]() {
      return this.oldValue;
    }
    get [dartx.previousSibling]() {
      return this.previousSibling;
    }
    get [dartx.removedNodes]() {
      return this.removedNodes;
    }
    get [dartx.target]() {
      return this.target;
    }
    get [dartx.type]() {
      return this.type;
    }
  };
  dart.setSignature(html$.MutationRecord, {
    constructors: () => ({_: dart.definiteFunctionType(html$.MutationRecord, [])})
  });
  dart.registerExtension(dart.global.MutationRecord, html$.MutationRecord);
  const _ensureGetUserMedia = Symbol('_ensureGetUserMedia');
  const _getUserMedia = Symbol('_getUserMedia');
  const _requestMidiAccess_1 = Symbol('_requestMidiAccess_1');
  const _requestMidiAccess_2 = Symbol('_requestMidiAccess_2');
  dart.defineExtensionNames([
    'language',
    'getUserMedia',
    'getBattery',
    'getGamepads',
    'getVRDevices',
    'registerProtocolHandler',
    'requestMidiAccess',
    'requestMediaKeySystemAccess',
    'sendBeacon',
    'getStorageUpdates',
    'bluetooth',
    'connection',
    'credentials',
    'doNotTrack',
    'geolocation',
    'maxTouchPoints',
    'mediaDevices',
    'mimeTypes',
    'permissions',
    'presentation',
    'productSub',
    'serviceWorker',
    'services',
    'storageQuota',
    'vendor',
    'vendorSub',
    'persistentStorage',
    'temporaryStorage',
    'hardwareConcurrency',
    'appCodeName',
    'appName',
    'appVersion',
    'dartEnabled',
    'platform',
    'product',
    'userAgent',
    'languages',
    'onLine',
    'cookieEnabled'
  ]);
  html$.Navigator = class Navigator extends _interceptors.Interceptor {
    get [dartx.language]() {
      return this.language || this.userLanguage;
    }
    [dartx.getUserMedia](opts) {
      let audio = opts && 'audio' in opts ? opts.audio : false;
      let video = opts && 'video' in opts ? opts.video : false;
      let completer = CompleterOfMediaStream().new();
      let options = dart.map({audio: audio, video: video});
      this[_ensureGetUserMedia]();
      this[_getUserMedia](html_common.convertDartToNative_SerializedScriptValue(options), dart.fn(stream => {
        completer.complete(stream);
      }, MediaStreamTovoid()), dart.fn(error => {
        completer.completeError(error);
      }, NavigatorUserMediaErrorTovoid()));
      return completer.future;
    }
    [_ensureGetUserMedia]() {
      if (!this.getUserMedia) {
        this.getUserMedia = this.getUserMedia || this.webkitGetUserMedia || this.mozGetUserMedia || this.msGetUserMedia;
      }
    }
    [_getUserMedia](options, success, error) {
      return this.getUserMedia(options, success, error);
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.bluetooth]() {
      return this.bluetooth;
    }
    get [dartx.connection]() {
      return this.connection;
    }
    get [dartx.credentials]() {
      return this.credentials;
    }
    get [dartx.doNotTrack]() {
      return this.doNotTrack;
    }
    get [dartx.geolocation]() {
      return this.geolocation;
    }
    get [dartx.maxTouchPoints]() {
      return this.maxTouchPoints;
    }
    get [dartx.mediaDevices]() {
      return this.mediaDevices;
    }
    get [dartx.mimeTypes]() {
      return this.mimeTypes;
    }
    get [dartx.permissions]() {
      return this.permissions;
    }
    get [dartx.presentation]() {
      return this.presentation;
    }
    get [dartx.productSub]() {
      return this.productSub;
    }
    get [dartx.serviceWorker]() {
      return this.serviceWorker;
    }
    get [dartx.services]() {
      return this.services;
    }
    get [dartx.storageQuota]() {
      return this.storageQuota;
    }
    get [dartx.vendor]() {
      return this.vendor;
    }
    get [dartx.vendorSub]() {
      return this.vendorSub;
    }
    get [dartx.persistentStorage]() {
      return this.webkitPersistentStorage;
    }
    get [dartx.temporaryStorage]() {
      return this.webkitTemporaryStorage;
    }
    [dartx.getBattery]() {
      return this.getBattery();
    }
    [dartx.getGamepads]() {
      return this.getGamepads();
    }
    [dartx.getVRDevices]() {
      return this.getVRDevices();
    }
    [dartx.registerProtocolHandler](scheme, url, title) {
      return this.registerProtocolHandler(scheme, url, title);
    }
    [dartx.requestMidiAccess](options) {
      if (options === void 0) options = null;
      if (options != null) {
        let options_1 = html_common.convertDartToNative_Dictionary(options);
        return this[_requestMidiAccess_1](options_1);
      }
      return this[_requestMidiAccess_2]();
    }
    [_requestMidiAccess_1](options) {
      return this.requestMIDIAccess(options);
    }
    [_requestMidiAccess_2]() {
      return this.requestMIDIAccess();
    }
    [dartx.requestMediaKeySystemAccess](keySystem, supportedConfigurations) {
      return this.requestMediaKeySystemAccess(keySystem, supportedConfigurations);
    }
    [dartx.sendBeacon](url, data) {
      return this.sendBeacon(url, data);
    }
    get [dartx.hardwareConcurrency]() {
      return this.hardwareConcurrency;
    }
    get [dartx.appCodeName]() {
      return this.appCodeName;
    }
    get [dartx.appName]() {
      return this.appName;
    }
    get [dartx.appVersion]() {
      return this.appVersion;
    }
    get [dartx.dartEnabled]() {
      return this.dartEnabled;
    }
    get [dartx.platform]() {
      return this.platform;
    }
    get [dartx.product]() {
      return this.product;
    }
    get [dartx.userAgent]() {
      return this.userAgent;
    }
    get [dartx.languages]() {
      return this.languages;
    }
    get [dartx.onLine]() {
      return this.onLine;
    }
    get [dartx.cookieEnabled]() {
      return this.cookieEnabled;
    }
    [dartx.getStorageUpdates]() {
      return this.getStorageUpdates();
    }
  };
  html$.Navigator[dart.implements] = () => [html$.NavigatorStorageUtils, html$.NavigatorCpu, html$.NavigatorLanguage, html$.NavigatorOnLine, html$.NavigatorID];
  dart.setSignature(html$.Navigator, {
    constructors: () => ({_: dart.definiteFunctionType(html$.Navigator, [])}),
    methods: () => ({
      [dartx.getUserMedia]: dart.definiteFunctionType(async.Future$(html$.MediaStream), [], {audio: dart.dynamic, video: dart.dynamic}),
      [_ensureGetUserMedia]: dart.definiteFunctionType(dart.dynamic, []),
      [_getUserMedia]: dart.definiteFunctionType(dart.void, [dart.dynamic, html$._NavigatorUserMediaSuccessCallback, html$._NavigatorUserMediaErrorCallback]),
      [dartx.getBattery]: dart.definiteFunctionType(async.Future, []),
      [dartx.getGamepads]: dart.definiteFunctionType(core.List$(html$.Gamepad), []),
      [dartx.getVRDevices]: dart.definiteFunctionType(async.Future, []),
      [dartx.registerProtocolHandler]: dart.definiteFunctionType(dart.void, [core.String, core.String, core.String]),
      [dartx.requestMidiAccess]: dart.definiteFunctionType(async.Future, [], [core.Map]),
      [_requestMidiAccess_1]: dart.definiteFunctionType(async.Future, [dart.dynamic]),
      [_requestMidiAccess_2]: dart.definiteFunctionType(async.Future, []),
      [dartx.requestMediaKeySystemAccess]: dart.definiteFunctionType(async.Future, [core.String, core.List$(core.Map)]),
      [dartx.sendBeacon]: dart.definiteFunctionType(core.bool, [core.String, core.Object]),
      [dartx.getStorageUpdates]: dart.definiteFunctionType(dart.void, [])
    })
  });
  dart.registerExtension(dart.global.Navigator, html$.Navigator);
  dart.defineExtensionNames([
    'hardwareConcurrency'
  ]);
  html$.NavigatorCpu = class NavigatorCpu extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(html$.NavigatorCpu, {
    constructors: () => ({_: dart.definiteFunctionType(html$.NavigatorCpu, [])})
  });
  dart.defineExtensionMembers(html$.NavigatorCpu, ['hardwareConcurrency']);
  dart.defineExtensionNames([
    'appCodeName',
    'appName',
    'appVersion',
    'dartEnabled',
    'platform',
    'product',
    'userAgent'
  ]);
  html$.NavigatorID = class NavigatorID extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(html$.NavigatorID, {
    constructors: () => ({_: dart.definiteFunctionType(html$.NavigatorID, [])})
  });
  dart.defineExtensionMembers(html$.NavigatorID, [
    'appCodeName',
    'appName',
    'appVersion',
    'dartEnabled',
    'platform',
    'product',
    'userAgent'
  ]);
  dart.defineExtensionNames([
    'language',
    'languages'
  ]);
  html$.NavigatorLanguage = class NavigatorLanguage extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(html$.NavigatorLanguage, {
    constructors: () => ({_: dart.definiteFunctionType(html$.NavigatorLanguage, [])})
  });
  dart.defineExtensionMembers(html$.NavigatorLanguage, ['language', 'languages']);
  dart.defineExtensionNames([
    'onLine'
  ]);
  html$.NavigatorOnLine = class NavigatorOnLine extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(html$.NavigatorOnLine, {
    constructors: () => ({_: dart.definiteFunctionType(html$.NavigatorOnLine, [])})
  });
  dart.defineExtensionMembers(html$.NavigatorOnLine, ['onLine']);
  dart.defineExtensionNames([
    'getStorageUpdates',
    'cookieEnabled'
  ]);
  html$.NavigatorStorageUtils = class NavigatorStorageUtils extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.cookieEnabled]() {
      return this.cookieEnabled;
    }
    [dartx.getStorageUpdates]() {
      return this.getStorageUpdates();
    }
  };
  dart.setSignature(html$.NavigatorStorageUtils, {
    constructors: () => ({_: dart.definiteFunctionType(html$.NavigatorStorageUtils, [])}),
    methods: () => ({[dartx.getStorageUpdates]: dart.definiteFunctionType(dart.void, [])})
  });
  dart.registerExtension(dart.global.NavigatorStorageUtils, html$.NavigatorStorageUtils);
  dart.defineExtensionNames([
    'constraintName',
    'message',
    'name'
  ]);
  html$.NavigatorUserMediaError = class NavigatorUserMediaError extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.constraintName]() {
      return this.constraintName;
    }
    get [dartx.message]() {
      return this.message;
    }
    get [dartx.name]() {
      return this.name;
    }
  };
  dart.setSignature(html$.NavigatorUserMediaError, {
    constructors: () => ({_: dart.definiteFunctionType(html$.NavigatorUserMediaError, [])})
  });
  dart.registerExtension(dart.global.NavigatorUserMediaError, html$.NavigatorUserMediaError);
  html$._NavigatorUserMediaErrorCallback = dart.typedef('_NavigatorUserMediaErrorCallback', () => dart.functionType(dart.void, [html$.NavigatorUserMediaError]));
  html$._NavigatorUserMediaSuccessCallback = dart.typedef('_NavigatorUserMediaSuccessCallback', () => dart.functionType(dart.void, [html$.MediaStream]));
  dart.defineExtensionNames([
    'type'
  ]);
  html$.NetworkInformation = class NetworkInformation extends html$.EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.type]() {
      return this.type;
    }
  };
  dart.setSignature(html$.NetworkInformation, {
    constructors: () => ({_: dart.definiteFunctionType(html$.NetworkInformation, [])})
  });
  dart.registerExtension(dart.global.NetworkInformation, html$.NetworkInformation);
  html$._ChildNodeListLazy = class _ChildNodeListLazy extends collection.ListBase$(html$.Node) {
    new(this$) {
      this[_this] = this$;
    }
    get first() {
      let result = this[_this].firstChild;
      if (result == null) dart.throw(new core.StateError("No elements"));
      return result;
    }
    get last() {
      let result = this[_this].lastChild;
      if (result == null) dart.throw(new core.StateError("No elements"));
      return result;
    }
    get single() {
      let l = this.length;
      if (l == 0) dart.throw(new core.StateError("No elements"));
      if (dart.notNull(l) > 1) dart.throw(new core.StateError("More than one element"));
      return this[_this].firstChild;
    }
    add(value) {
      this[_this][dartx.append](value);
    }
    addAll(iterable) {
      if (html$._ChildNodeListLazy.is(iterable)) {
        let otherList = iterable;
        if (!core.identical(otherList[_this], this[_this])) {
          for (let i = 0, len = otherList.length; i < dart.notNull(len); ++i) {
            this[_this][dartx.append](otherList[_this][dartx.firstChild]);
          }
        }
        return;
      }
      for (let node of iterable) {
        this[_this][dartx.append](node);
      }
    }
    insert(index, node) {
      if (dart.notNull(index) < 0 || dart.notNull(index) > dart.notNull(this.length)) {
        dart.throw(new core.RangeError.range(index, 0, this.length));
      }
      if (index == this.length) {
        this[_this][dartx.append](node);
      } else {
        this[_this][dartx.insertBefore](node, this.get(index));
      }
    }
    insertAll(index, iterable) {
      if (index == this.length) {
        this.addAll(iterable);
      } else {
        let item = this.get(index);
        this[_this][dartx.insertAllBefore](iterable, item);
      }
    }
    setAll(index, iterable) {
      dart.throw(new core.UnsupportedError("Cannot setAll on Node list"));
    }
    removeLast() {
      let result = this.last;
      if (result != null) {
        this[_this][_removeChild](result);
      }
      return result;
    }
    removeAt(index) {
      let result = this.get(index);
      if (result != null) {
        this[_this][_removeChild](result);
      }
      return result;
    }
    remove(object) {
      if (!html$.Node.is(object)) return false;
      let node = html$.Node._check(object);
      if (!core.identical(this[_this], node[dartx.parentNode])) return false;
      this[_this][_removeChild](node);
      return true;
    }
    [_filter$](test, removeMatching) {
      let child = this[_this][dartx.firstChild];
      while (child != null) {
        let nextChild = child[dartx.nextNode];
        if (test(child) == removeMatching) {
          this[_this][_removeChild](child);
        }
        child = nextChild;
      }
    }
    removeWhere(test) {
      this[_filter$](test, true);
    }
    retainWhere(test) {
      this[_filter$](test, false);
    }
    clear() {
      this[_this][_clearChildren]();
    }
    set(index, value) {
      this[_this][_replaceChild](value, this.get(index));
      return value;
    }
    get iterator() {
      return this[_this][dartx.childNodes][dartx.iterator];
    }
    sort(compare) {
      if (compare === void 0) compare = null;
      dart.throw(new core.UnsupportedError("Cannot sort Node list"));
    }
    shuffle(random) {
      if (random === void 0) random = null;
      dart.throw(new core.UnsupportedError("Cannot shuffle Node list"));
    }
    setRange(start, end, iterable, skipCount) {
      if (skipCount === void 0) skipCount = 0;
      dart.throw(new core.UnsupportedError("Cannot setRange on Node list"));
    }
    fillRange(start, end, fill) {
      if (fill === void 0) fill = null;
      dart.throw(new core.UnsupportedError("Cannot fillRange on Node list"));
    }
    get length() {
      return this[_this][dartx.childNodes][dartx.length];
    }
    set length(value) {
      dart.throw(new core.UnsupportedError("Cannot set length on immutable List."));
    }
    get(index) {
      return this[_this][dartx.childNodes][dartx.get](index);
    }
    get rawList() {
      return this[_this][dartx.childNodes];
    }
  };
  dart.addSimpleTypeTests(html$._ChildNodeListLazy);
  html$._ChildNodeListLazy[dart.implements] = () => [html_common.NodeListWrapper];
  dart.setSignature(html$._ChildNodeListLazy, {
    constructors: () => ({new: dart.definiteFunctionType(html$._ChildNodeListLazy, [html$.Node])}),
    methods: () => ({
      add: dart.definiteFunctionType(dart.void, [html$.Node]),
      addAll: dart.definiteFunctionType(dart.void, [core.Iterable$(html$.Node)]),
      insert: dart.definiteFunctionType(dart.void, [core.int, html$.Node]),
      insertAll: dart.definiteFunctionType(dart.void, [core.int, core.Iterable$(html$.Node)]),
      setAll: dart.definiteFunctionType(dart.void, [core.int, core.Iterable$(html$.Node)]),
      removeLast: dart.definiteFunctionType(html$.Node, []),
      removeAt: dart.definiteFunctionType(html$.Node, [core.int]),
      [_filter$]: dart.definiteFunctionType(dart.void, [dart.functionType(core.bool, [html$.Node]), core.bool]),
      removeWhere: dart.definiteFunctionType(dart.void, [dart.functionType(core.bool, [html$.Node])]),
      retainWhere: dart.definiteFunctionType(dart.void, [dart.functionType(core.bool, [html$.Node])]),
      set: dart.definiteFunctionType(dart.void, [core.int, html$.Node]),
      sort: dart.definiteFunctionType(dart.void, [], [core.Comparator$(html$.Node)]),
      setRange: dart.definiteFunctionType(dart.void, [core.int, core.int, core.Iterable$(html$.Node)], [core.int]),
      fillRange: dart.definiteFunctionType(dart.void, [core.int, core.int], [html$.Node]),
      get: dart.definiteFunctionType(html$.Node, [core.int])
    })
  });
  dart.defineExtensionMembers(html$._ChildNodeListLazy, [
    'add',
    'addAll',
    'insert',
    'insertAll',
    'setAll',
    'removeLast',
    'removeAt',
    'remove',
    'removeWhere',
    'retainWhere',
    'clear',
    'set',
    'sort',
    'shuffle',
    'setRange',
    'fillRange',
    'get',
    'first',
    'last',
    'single',
    'iterator',
    'length',
    'length'
  ]);
  html$.NodeFilter = class NodeFilter extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(html$.NodeFilter, {
    constructors: () => ({_: dart.definiteFunctionType(html$.NodeFilter, [])})
  });
  html$.NodeFilter.FILTER_ACCEPT = 1;
  html$.NodeFilter.FILTER_REJECT = 2;
  html$.NodeFilter.FILTER_SKIP = 3;
  html$.NodeFilter.SHOW_ALL = 4294967295;
  html$.NodeFilter.SHOW_COMMENT = 128;
  html$.NodeFilter.SHOW_DOCUMENT = 256;
  html$.NodeFilter.SHOW_DOCUMENT_FRAGMENT = 1024;
  html$.NodeFilter.SHOW_DOCUMENT_TYPE = 512;
  html$.NodeFilter.SHOW_ELEMENT = 1;
  html$.NodeFilter.SHOW_PROCESSING_INSTRUCTION = 64;
  html$.NodeFilter.SHOW_TEXT = 4;
  dart.registerExtension(dart.global.NodeFilter, html$.NodeFilter);
  dart.defineExtensionNames([
    'detach',
    'nextNode',
    'previousNode',
    'pointerBeforeReferenceNode',
    'referenceNode',
    'root',
    'whatToShow'
  ]);
  html$.NodeIterator = class NodeIterator extends _interceptors.Interceptor {
    static new(root, whatToShow) {
      return html$.document[_createNodeIterator](root, whatToShow, null);
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.pointerBeforeReferenceNode]() {
      return this.pointerBeforeReferenceNode;
    }
    get [dartx.referenceNode]() {
      return this.referenceNode;
    }
    get [dartx.root]() {
      return this.root;
    }
    get [dartx.whatToShow]() {
      return this.whatToShow;
    }
    [dartx.detach]() {
      return this.detach();
    }
    [dartx.nextNode]() {
      return this.nextNode();
    }
    [dartx.previousNode]() {
      return this.previousNode();
    }
  };
  dart.setSignature(html$.NodeIterator, {
    constructors: () => ({
      new: dart.definiteFunctionType(html$.NodeIterator, [html$.Node, core.int]),
      _: dart.definiteFunctionType(html$.NodeIterator, [])
    }),
    methods: () => ({
      [dartx.detach]: dart.definiteFunctionType(dart.void, []),
      [dartx.nextNode]: dart.definiteFunctionType(html$.Node, []),
      [dartx.previousNode]: dart.definiteFunctionType(html$.Node, [])
    })
  });
  dart.registerExtension(dart.global.NodeIterator, html$.NodeIterator);
  dart.defineExtensionNames([
    'length',
    'get',
    'set',
    'length',
    'first',
    'last',
    'single',
    'elementAt'
  ]);
  html$.NodeList = class NodeList extends dart.mixin(_interceptors.Interceptor, collection.ListMixin$(html$.Node), html$.ImmutableListMixin$(html$.Node)) {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.length]() {
      return this.length;
    }
    [dartx.get](index) {
      if (index >>> 0 !== index || index >= this[dartx.length]) dart.throw(core.RangeError.index(index, this));
      return this[index];
    }
    [dartx.set](index, value) {
      dart.throw(new core.UnsupportedError("Cannot assign element of immutable List."));
      return value;
    }
    set [dartx.length](value) {
      dart.throw(new core.UnsupportedError("Cannot resize immutable List."));
    }
    get [dartx.first]() {
      if (dart.notNull(this[dartx.length]) > 0) {
        return this[0];
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.last]() {
      let len = this[dartx.length];
      if (dart.notNull(len) > 0) {
        return this[dart.notNull(len) - 1];
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.single]() {
      let len = this[dartx.length];
      if (len == 1) {
        return this[0];
      }
      if (len == 0) dart.throw(new core.StateError("No elements"));
      dart.throw(new core.StateError("More than one element"));
    }
    [dartx.elementAt](index) {
      return this[dartx.get](index);
    }
    [_item](index) {
      return this.item(index);
    }
  };
  html$.NodeList[dart.implements] = () => [_js_helper.JavaScriptIndexingBehavior, ListOfNode()];
  dart.setSignature(html$.NodeList, {
    constructors: () => ({_: dart.definiteFunctionType(html$.NodeList, [])}),
    methods: () => ({
      [dartx.get]: dart.definiteFunctionType(html$.Node, [core.int]),
      [dartx.set]: dart.definiteFunctionType(dart.void, [core.int, html$.Node]),
      [dartx.elementAt]: dart.definiteFunctionType(html$.Node, [core.int]),
      [_item]: dart.definiteFunctionType(html$.Node, [core.int])
    })
  });
  dart.registerExtension(dart.global.NodeList, html$.NodeList);
  dart.defineExtensionNames([
    'nextElementSibling',
    'previousElementSibling'
  ]);
  html$.NonDocumentTypeChildNode = class NonDocumentTypeChildNode extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.nextElementSibling]() {
      return this.nextElementSibling;
    }
    get [dartx.previousElementSibling]() {
      return this.previousElementSibling;
    }
  };
  dart.setSignature(html$.NonDocumentTypeChildNode, {
    constructors: () => ({_: dart.definiteFunctionType(html$.NonDocumentTypeChildNode, [])})
  });
  dart.registerExtension(dart.global.NonDocumentTypeChildNode, html$.NonDocumentTypeChildNode);
  dart.defineExtensionNames([
    'getElementById'
  ]);
  html$.NonElementParentNode = class NonElementParentNode extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [dartx.getElementById](elementId) {
      return this.getElementById(elementId);
    }
  };
  dart.setSignature(html$.NonElementParentNode, {
    constructors: () => ({_: dart.definiteFunctionType(html$.NonElementParentNode, [])}),
    methods: () => ({[dartx.getElementById]: dart.definiteFunctionType(html$.Element, [core.String])})
  });
  dart.registerExtension(dart.global.NonElementParentNode, html$.NonElementParentNode);
  dart.defineExtensionNames([
    'close',
    'onClick',
    'onClose',
    'onError',
    'onShow',
    'body',
    'data',
    'dir',
    'icon',
    'lang',
    'permission',
    'silent',
    'tag',
    'title',
    'vibrate'
  ]);
  html$.Notification = class Notification extends html$.EventTarget {
    static new(title, opts) {
      let dir = opts && 'dir' in opts ? opts.dir : null;
      let body = opts && 'body' in opts ? opts.body : null;
      let lang = opts && 'lang' in opts ? opts.lang : null;
      let tag = opts && 'tag' in opts ? opts.tag : null;
      let icon = opts && 'icon' in opts ? opts.icon : null;
      let parsedOptions = dart.map();
      if (dir != null) parsedOptions[dartx.set]('dir', dir);
      if (body != null) parsedOptions[dartx.set]('body', body);
      if (lang != null) parsedOptions[dartx.set]('lang', lang);
      if (tag != null) parsedOptions[dartx.set]('tag', tag);
      if (icon != null) parsedOptions[dartx.set]('icon', icon);
      return html$.Notification._factoryNotification(title, parsedOptions);
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static _factoryNotification(title, options) {
      if (options === void 0) options = null;
      if (options != null) {
        let options_1 = html_common.convertDartToNative_Dictionary(options);
        return html$.Notification._create_1(title, options_1);
      }
      return html$.Notification._create_2(title);
    }
    static _create_1(title, options) {
      return new Notification(title, options);
    }
    static _create_2(title) {
      return new Notification(title);
    }
    static get supported() {
      return !!window.Notification;
    }
    get [dartx.body]() {
      return this.body;
    }
    get [dartx.data]() {
      return this.data;
    }
    get [dartx.dir]() {
      return this.dir;
    }
    get [dartx.icon]() {
      return this.icon;
    }
    get [dartx.lang]() {
      return this.lang;
    }
    get [dartx.permission]() {
      return this.permission;
    }
    get [dartx.silent]() {
      return this.silent;
    }
    get [dartx.tag]() {
      return this.tag;
    }
    get [dartx.title]() {
      return this.title;
    }
    get [dartx.vibrate]() {
      return this.vibrate;
    }
    [dartx.close]() {
      return this.close();
    }
    static requestPermission() {
      let completer = CompleterOfString().new();
      html$.Notification._requestPermission(dart.fn(value => {
        completer.complete(value);
      }, StringTovoid()));
      return completer.future;
    }
    get [dartx.onClick]() {
      return html$.Notification.clickEvent.forTarget(this);
    }
    get [dartx.onClose]() {
      return html$.Notification.closeEvent.forTarget(this);
    }
    get [dartx.onError]() {
      return html$.Notification.errorEvent.forTarget(this);
    }
    get [dartx.onShow]() {
      return html$.Notification.showEvent.forTarget(this);
    }
  };
  dart.setSignature(html$.Notification, {
    constructors: () => ({
      new: dart.definiteFunctionType(html$.Notification, [core.String], {dir: core.String, body: core.String, lang: core.String, tag: core.String, icon: core.String}),
      _: dart.definiteFunctionType(html$.Notification, [])
    }),
    methods: () => ({[dartx.close]: dart.definiteFunctionType(dart.void, [])}),
    statics: () => ({
      _factoryNotification: dart.definiteFunctionType(html$.Notification, [core.String], [core.Map]),
      _create_1: dart.definiteFunctionType(html$.Notification, [dart.dynamic, dart.dynamic]),
      _create_2: dart.definiteFunctionType(html$.Notification, [dart.dynamic]),
      _requestPermission: dart.definiteFunctionType(dart.void, [], [html$._NotificationPermissionCallback]),
      requestPermission: dart.definiteFunctionType(async.Future$(core.String), [])
    }),
    names: ['_factoryNotification', '_create_1', '_create_2', '_requestPermission', 'requestPermission']
  });
  dart.defineLazy(html$.Notification, {
    get clickEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('click'));
    },
    get closeEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('close'));
    },
    get errorEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('error'));
    },
    get showEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('show'));
    }
  });
  dart.registerExtension(dart.global.Notification, html$.Notification);
  dart.defineExtensionNames([
    'notification'
  ]);
  html$.NotificationEvent = class NotificationEvent extends html$.ExtendableEvent {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(type, eventInitDict) {
      if (eventInitDict === void 0) eventInitDict = null;
      if (eventInitDict != null) {
        let eventInitDict_1 = html_common.convertDartToNative_Dictionary(eventInitDict);
        return html$.NotificationEvent._create_1(type, eventInitDict_1);
      }
      return html$.NotificationEvent._create_2(type);
    }
    static _create_1(type, eventInitDict) {
      return new NotificationEvent(type, eventInitDict);
    }
    static _create_2(type) {
      return new NotificationEvent(type);
    }
    get [dartx.notification]() {
      return this.notification;
    }
  };
  dart.setSignature(html$.NotificationEvent, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.NotificationEvent, []),
      new: dart.definiteFunctionType(html$.NotificationEvent, [core.String], [core.Map])
    }),
    statics: () => ({
      _create_1: dart.definiteFunctionType(html$.NotificationEvent, [dart.dynamic, dart.dynamic]),
      _create_2: dart.definiteFunctionType(html$.NotificationEvent, [dart.dynamic])
    }),
    names: ['_create_1', '_create_2']
  });
  dart.registerExtension(dart.global.NotificationEvent, html$.NotificationEvent);
  html$._NotificationPermissionCallback = dart.typedef('_NotificationPermissionCallback', () => dart.functionType(dart.void, [core.String]));
  dart.defineExtensionNames([
    'reversed',
    'start',
    'type'
  ]);
  html$.OListElement = class OListElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return html$.OListElement._check(html$.document[dartx.createElement]("ol"));
    }
    created() {
      this[dartx.reversed] = null;
      this[dartx.start] = null;
      this[dartx.type] = null;
      super.created();
    }
    get [dartx.reversed]() {
      return this.reversed;
    }
    set [dartx.reversed](value) {
      this.reversed = value;
    }
    get [dartx.start]() {
      return this.start;
    }
    set [dartx.start](value) {
      this.start = value;
    }
    get [dartx.type]() {
      return this.type;
    }
    set [dartx.type](value) {
      this.type = value;
    }
  };
  dart.defineNamedConstructor(html$.OListElement, 'created');
  dart.setSignature(html$.OListElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.OListElement, []),
      new: dart.definiteFunctionType(html$.OListElement, []),
      created: dart.definiteFunctionType(html$.OListElement, [])
    })
  });
  dart.registerExtension(dart.global.HTMLOListElement, html$.OListElement);
  dart.defineExtensionNames([
    'checkValidity',
    'reportValidity',
    'setCustomValidity',
    'data',
    'form',
    'height',
    'name',
    'type',
    'useMap',
    'validationMessage',
    'validity',
    'width',
    'willValidate'
  ]);
  html$.ObjectElement = class ObjectElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return html$.ObjectElement._check(html$.document[dartx.createElement]("object"));
    }
    created() {
      this[dartx.data] = null;
      this[dartx.form] = null;
      this[dartx.height] = null;
      this[dartx.name] = null;
      this[dartx.type] = null;
      this[dartx.useMap] = null;
      this[dartx.validationMessage] = null;
      this[dartx.validity] = null;
      this[dartx.width] = null;
      this[dartx.willValidate] = null;
      super.created();
    }
    static get supported() {
      return html$.Element.isTagSupported('object');
    }
    get [dartx.data]() {
      return this.data;
    }
    set [dartx.data](value) {
      this.data = value;
    }
    get [dartx.form]() {
      return this.form;
    }
    get [dartx.height]() {
      return this.height;
    }
    set [dartx.height](value) {
      this.height = value;
    }
    get [dartx.name]() {
      return this.name;
    }
    set [dartx.name](value) {
      this.name = value;
    }
    get [dartx.type]() {
      return this.type;
    }
    set [dartx.type](value) {
      this.type = value;
    }
    get [dartx.useMap]() {
      return this.useMap;
    }
    set [dartx.useMap](value) {
      this.useMap = value;
    }
    get [dartx.validationMessage]() {
      return this.validationMessage;
    }
    get [dartx.validity]() {
      return this.validity;
    }
    get [dartx.width]() {
      return this.width;
    }
    set [dartx.width](value) {
      this.width = value;
    }
    get [dartx.willValidate]() {
      return this.willValidate;
    }
    [__getter__](index_OR_name) {
      return this.__getter__(index_OR_name);
    }
    [__setter__](index_OR_name, value) {
      return this.__setter__(index_OR_name, value);
    }
    [dartx.checkValidity]() {
      return this.checkValidity();
    }
    [dartx.reportValidity]() {
      return this.reportValidity();
    }
    [dartx.setCustomValidity](error) {
      return this.setCustomValidity(error);
    }
  };
  dart.defineNamedConstructor(html$.ObjectElement, 'created');
  dart.setSignature(html$.ObjectElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.ObjectElement, []),
      new: dart.definiteFunctionType(html$.ObjectElement, []),
      created: dart.definiteFunctionType(html$.ObjectElement, [])
    }),
    methods: () => ({
      [__getter__]: dart.definiteFunctionType(core.bool, [dart.dynamic]),
      [__setter__]: dart.definiteFunctionType(dart.void, [dart.dynamic, html$.Node]),
      [dartx.checkValidity]: dart.definiteFunctionType(core.bool, []),
      [dartx.reportValidity]: dart.definiteFunctionType(core.bool, []),
      [dartx.setCustomValidity]: dart.definiteFunctionType(dart.void, [core.String])
    })
  });
  dart.registerExtension(dart.global.HTMLObjectElement, html$.ObjectElement);
  dart.defineExtensionNames([
    'disabled',
    'label'
  ]);
  html$.OptGroupElement = class OptGroupElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return html$.OptGroupElement._check(html$.document[dartx.createElement]("optgroup"));
    }
    created() {
      this[dartx.disabled] = null;
      this[dartx.label] = null;
      super.created();
    }
    get [dartx.disabled]() {
      return this.disabled;
    }
    set [dartx.disabled](value) {
      this.disabled = value;
    }
    get [dartx.label]() {
      return this.label;
    }
    set [dartx.label](value) {
      this.label = value;
    }
  };
  dart.defineNamedConstructor(html$.OptGroupElement, 'created');
  dart.setSignature(html$.OptGroupElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.OptGroupElement, []),
      new: dart.definiteFunctionType(html$.OptGroupElement, []),
      created: dart.definiteFunctionType(html$.OptGroupElement, [])
    })
  });
  dart.registerExtension(dart.global.HTMLOptGroupElement, html$.OptGroupElement);
  dart.defineExtensionNames([
    'defaultSelected',
    'disabled',
    'form',
    'index',
    'label',
    'selected',
    'value'
  ]);
  html$.OptionElement = class OptionElement extends html$.HtmlElement {
    static new(opts) {
      let data = opts && 'data' in opts ? opts.data : '';
      let value = opts && 'value' in opts ? opts.value : '';
      let selected = opts && 'selected' in opts ? opts.selected : false;
      return html$.OptionElement._(data, value, null, selected);
    }
    static _(data, value, defaultSelected, selected) {
      if (data === void 0) data = null;
      if (value === void 0) value = null;
      if (defaultSelected === void 0) defaultSelected = null;
      if (selected === void 0) selected = null;
      if (selected != null) {
        return html$.OptionElement._create_1(data, value, defaultSelected, selected);
      }
      if (defaultSelected != null) {
        return html$.OptionElement._create_2(data, value, defaultSelected);
      }
      if (value != null) {
        return html$.OptionElement._create_3(data, value);
      }
      if (data != null) {
        return html$.OptionElement._create_4(data);
      }
      return html$.OptionElement._create_5();
    }
    static _create_1(data, value, defaultSelected, selected) {
      return new Option(data, value, defaultSelected, selected);
    }
    static _create_2(data, value, defaultSelected) {
      return new Option(data, value, defaultSelected);
    }
    static _create_3(data, value) {
      return new Option(data, value);
    }
    static _create_4(data) {
      return new Option(data);
    }
    static _create_5() {
      return new Option();
    }
    created() {
      this[dartx.defaultSelected] = null;
      this[dartx.disabled] = null;
      this[dartx.form] = null;
      this[dartx.index] = null;
      this[dartx.label] = null;
      this[dartx.selected] = null;
      this[dartx.value] = null;
      super.created();
    }
    get [dartx.defaultSelected]() {
      return this.defaultSelected;
    }
    set [dartx.defaultSelected](value) {
      this.defaultSelected = value;
    }
    get [dartx.disabled]() {
      return this.disabled;
    }
    set [dartx.disabled](value) {
      this.disabled = value;
    }
    get [dartx.form]() {
      return this.form;
    }
    get [dartx.index]() {
      return this.index;
    }
    get [dartx.label]() {
      return this.label;
    }
    set [dartx.label](value) {
      this.label = value;
    }
    get [dartx.selected]() {
      return this.selected;
    }
    set [dartx.selected](value) {
      this.selected = value;
    }
    get [dartx.value]() {
      return this.value;
    }
    set [dartx.value](value) {
      this.value = value;
    }
  };
  dart.defineNamedConstructor(html$.OptionElement, 'created');
  dart.setSignature(html$.OptionElement, {
    constructors: () => ({
      new: dart.definiteFunctionType(html$.OptionElement, [], {data: core.String, value: core.String, selected: core.bool}),
      _: dart.definiteFunctionType(html$.OptionElement, [], [core.String, core.String, core.bool, core.bool]),
      created: dart.definiteFunctionType(html$.OptionElement, [])
    }),
    statics: () => ({
      _create_1: dart.definiteFunctionType(html$.OptionElement, [dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic]),
      _create_2: dart.definiteFunctionType(html$.OptionElement, [dart.dynamic, dart.dynamic, dart.dynamic]),
      _create_3: dart.definiteFunctionType(html$.OptionElement, [dart.dynamic, dart.dynamic]),
      _create_4: dart.definiteFunctionType(html$.OptionElement, [dart.dynamic]),
      _create_5: dart.definiteFunctionType(html$.OptionElement, [])
    }),
    names: ['_create_1', '_create_2', '_create_3', '_create_4', '_create_5']
  });
  dart.registerExtension(dart.global.HTMLOptionElement, html$.OptionElement);
  dart.defineExtensionNames([
    'checkValidity',
    'reportValidity',
    'setCustomValidity',
    'defaultValue',
    'form',
    'htmlFor',
    'labels',
    'name',
    'type',
    'validationMessage',
    'validity',
    'value',
    'willValidate'
  ]);
  html$.OutputElement = class OutputElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return html$.OutputElement._check(html$.document[dartx.createElement]("output"));
    }
    created() {
      this[dartx.defaultValue] = null;
      this[dartx.form] = null;
      this[dartx.htmlFor] = null;
      this[dartx.labels] = null;
      this[dartx.name] = null;
      this[dartx.type] = null;
      this[dartx.validationMessage] = null;
      this[dartx.validity] = null;
      this[dartx.value] = null;
      this[dartx.willValidate] = null;
      super.created();
    }
    static get supported() {
      return html$.Element.isTagSupported('output');
    }
    get [dartx.defaultValue]() {
      return this.defaultValue;
    }
    set [dartx.defaultValue](value) {
      this.defaultValue = value;
    }
    get [dartx.form]() {
      return this.form;
    }
    get [dartx.htmlFor]() {
      return this.htmlFor;
    }
    get [dartx.labels]() {
      return this.labels;
    }
    get [dartx.name]() {
      return this.name;
    }
    set [dartx.name](value) {
      this.name = value;
    }
    get [dartx.type]() {
      return this.type;
    }
    get [dartx.validationMessage]() {
      return this.validationMessage;
    }
    get [dartx.validity]() {
      return this.validity;
    }
    get [dartx.value]() {
      return this.value;
    }
    set [dartx.value](value) {
      this.value = value;
    }
    get [dartx.willValidate]() {
      return this.willValidate;
    }
    [dartx.checkValidity]() {
      return this.checkValidity();
    }
    [dartx.reportValidity]() {
      return this.reportValidity();
    }
    [dartx.setCustomValidity](error) {
      return this.setCustomValidity(error);
    }
  };
  dart.defineNamedConstructor(html$.OutputElement, 'created');
  dart.setSignature(html$.OutputElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.OutputElement, []),
      new: dart.definiteFunctionType(html$.OutputElement, []),
      created: dart.definiteFunctionType(html$.OutputElement, [])
    }),
    methods: () => ({
      [dartx.checkValidity]: dart.definiteFunctionType(core.bool, []),
      [dartx.reportValidity]: dart.definiteFunctionType(core.bool, []),
      [dartx.setCustomValidity]: dart.definiteFunctionType(dart.void, [core.String])
    })
  });
  dart.registerExtension(dart.global.HTMLOutputElement, html$.OutputElement);
  dart.defineExtensionNames([
    'persisted'
  ]);
  html$.PageTransitionEvent = class PageTransitionEvent extends html$.Event {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(type, eventInitDict) {
      if (eventInitDict === void 0) eventInitDict = null;
      if (eventInitDict != null) {
        let eventInitDict_1 = html_common.convertDartToNative_Dictionary(eventInitDict);
        return html$.PageTransitionEvent._create_1(type, eventInitDict_1);
      }
      return html$.PageTransitionEvent._create_2(type);
    }
    static _create_1(type, eventInitDict) {
      return new PageTransitionEvent(type, eventInitDict);
    }
    static _create_2(type) {
      return new PageTransitionEvent(type);
    }
    get [dartx.persisted]() {
      return this.persisted;
    }
  };
  dart.setSignature(html$.PageTransitionEvent, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.PageTransitionEvent, []),
      new: dart.definiteFunctionType(html$.PageTransitionEvent, [core.String], [core.Map])
    }),
    statics: () => ({
      _create_1: dart.definiteFunctionType(html$.PageTransitionEvent, [dart.dynamic, dart.dynamic]),
      _create_2: dart.definiteFunctionType(html$.PageTransitionEvent, [dart.dynamic])
    }),
    names: ['_create_1', '_create_2']
  });
  dart.registerExtension(dart.global.PageTransitionEvent, html$.PageTransitionEvent);
  html$.ParagraphElement = class ParagraphElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return html$.ParagraphElement._check(html$.document[dartx.createElement]("p"));
    }
    created() {
      super.created();
    }
  };
  dart.defineNamedConstructor(html$.ParagraphElement, 'created');
  dart.setSignature(html$.ParagraphElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.ParagraphElement, []),
      new: dart.definiteFunctionType(html$.ParagraphElement, []),
      created: dart.definiteFunctionType(html$.ParagraphElement, [])
    })
  });
  dart.registerExtension(dart.global.HTMLParagraphElement, html$.ParagraphElement);
  dart.defineExtensionNames([
    'name',
    'value'
  ]);
  html$.ParamElement = class ParamElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return html$.ParamElement._check(html$.document[dartx.createElement]("param"));
    }
    created() {
      this[dartx.name] = null;
      this[dartx.value] = null;
      super.created();
    }
    get [dartx.name]() {
      return this.name;
    }
    set [dartx.name](value) {
      this.name = value;
    }
    get [dartx.value]() {
      return this.value;
    }
    set [dartx.value](value) {
      this.value = value;
    }
  };
  dart.defineNamedConstructor(html$.ParamElement, 'created');
  dart.setSignature(html$.ParamElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.ParamElement, []),
      new: dart.definiteFunctionType(html$.ParamElement, []),
      created: dart.definiteFunctionType(html$.ParamElement, [])
    })
  });
  dart.registerExtension(dart.global.HTMLParamElement, html$.ParamElement);
  html$.ParentNode = class ParentNode extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(html$.ParentNode, {
    constructors: () => ({_: dart.definiteFunctionType(html$.ParentNode, [])})
  });
  dart.defineExtensionNames([
    'formData',
    'password'
  ]);
  html$.PasswordCredential = class PasswordCredential extends html$.Credential {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(id, password, name, iconURL) {
      if (name === void 0) name = null;
      if (iconURL === void 0) iconURL = null;
      if (iconURL != null) {
        return html$.PasswordCredential._create_1(id, password, name, iconURL);
      }
      if (name != null) {
        return html$.PasswordCredential._create_2(id, password, name);
      }
      return html$.PasswordCredential._create_3(id, password);
    }
    static _create_1(id, password, name, iconURL) {
      return new PasswordCredential(id, password, name, iconURL);
    }
    static _create_2(id, password, name) {
      return new PasswordCredential(id, password, name);
    }
    static _create_3(id, password) {
      return new PasswordCredential(id, password);
    }
    get [dartx.formData]() {
      return this.formData;
    }
    get [dartx.password]() {
      return this.password;
    }
  };
  dart.setSignature(html$.PasswordCredential, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.PasswordCredential, []),
      new: dart.definiteFunctionType(html$.PasswordCredential, [core.String, core.String], [core.String, core.String])
    }),
    statics: () => ({
      _create_1: dart.definiteFunctionType(html$.PasswordCredential, [dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic]),
      _create_2: dart.definiteFunctionType(html$.PasswordCredential, [dart.dynamic, dart.dynamic, dart.dynamic]),
      _create_3: dart.definiteFunctionType(html$.PasswordCredential, [dart.dynamic, dart.dynamic])
    }),
    names: ['_create_1', '_create_2', '_create_3']
  });
  dart.registerExtension(dart.global.PasswordCredential, html$.PasswordCredential);
  dart.defineExtensionNames([
    'addPath',
    'arc',
    'arcTo',
    'bezierCurveTo',
    'closePath',
    'ellipse',
    'lineTo',
    'moveTo',
    'quadraticCurveTo',
    'rect'
  ]);
  html$.Path2D = class Path2D extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(path_OR_text) {
      if (path_OR_text === void 0) path_OR_text = null;
      if (path_OR_text == null) {
        return html$.Path2D._create_1();
      }
      if (html$.Path2D.is(path_OR_text) || path_OR_text == null) {
        return html$.Path2D._create_2(path_OR_text);
      }
      if (typeof path_OR_text == 'string' || path_OR_text == null) {
        return html$.Path2D._create_3(path_OR_text);
      }
      dart.throw(new core.ArgumentError("Incorrect number or type of arguments"));
    }
    static _create_1() {
      return new Path2D();
    }
    static _create_2(path_OR_text) {
      return new Path2D(path_OR_text);
    }
    static _create_3(path_OR_text) {
      return new Path2D(path_OR_text);
    }
    [dartx.addPath](path, transform) {
      return this.addPath(path, transform);
    }
    [dartx.arc](x, y, radius, startAngle, endAngle, anticlockwise) {
      return this.arc(x, y, radius, startAngle, endAngle, anticlockwise);
    }
    [dartx.arcTo](x1, y1, x2, y2, radius) {
      return this.arcTo(x1, y1, x2, y2, radius);
    }
    [dartx.bezierCurveTo](cp1x, cp1y, cp2x, cp2y, x, y) {
      return this.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
    }
    [dartx.closePath]() {
      return this.closePath();
    }
    [dartx.ellipse](x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise) {
      return this.ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise);
    }
    [dartx.lineTo](x, y) {
      return this.lineTo(x, y);
    }
    [dartx.moveTo](x, y) {
      return this.moveTo(x, y);
    }
    [dartx.quadraticCurveTo](cpx, cpy, x, y) {
      return this.quadraticCurveTo(cpx, cpy, x, y);
    }
    [dartx.rect](x, y, width, height) {
      return this.rect(x, y, width, height);
    }
  };
  html$.Path2D[dart.implements] = () => [html$._CanvasPathMethods];
  dart.setSignature(html$.Path2D, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.Path2D, []),
      new: dart.definiteFunctionType(html$.Path2D, [], [dart.dynamic])
    }),
    methods: () => ({
      [dartx.addPath]: dart.definiteFunctionType(dart.void, [html$.Path2D], [svg$.Matrix]),
      [dartx.arc]: dart.definiteFunctionType(dart.void, [core.num, core.num, core.num, core.num, core.num, core.bool]),
      [dartx.arcTo]: dart.definiteFunctionType(dart.void, [core.num, core.num, core.num, core.num, core.num]),
      [dartx.bezierCurveTo]: dart.definiteFunctionType(dart.void, [core.num, core.num, core.num, core.num, core.num, core.num]),
      [dartx.closePath]: dart.definiteFunctionType(dart.void, []),
      [dartx.ellipse]: dart.definiteFunctionType(dart.void, [core.num, core.num, core.num, core.num, core.num, core.num, core.num, core.bool]),
      [dartx.lineTo]: dart.definiteFunctionType(dart.void, [core.num, core.num]),
      [dartx.moveTo]: dart.definiteFunctionType(dart.void, [core.num, core.num]),
      [dartx.quadraticCurveTo]: dart.definiteFunctionType(dart.void, [core.num, core.num, core.num, core.num]),
      [dartx.rect]: dart.definiteFunctionType(dart.void, [core.num, core.num, core.num, core.num])
    }),
    statics: () => ({
      _create_1: dart.definiteFunctionType(html$.Path2D, []),
      _create_2: dart.definiteFunctionType(html$.Path2D, [dart.dynamic]),
      _create_3: dart.definiteFunctionType(html$.Path2D, [dart.dynamic])
    }),
    names: ['_create_1', '_create_2', '_create_3']
  });
  dart.registerExtension(dart.global.Path2D, html$.Path2D);
  dart.defineExtensionNames([
    'clearFrameTimings',
    'clearMarks',
    'clearMeasures',
    'getEntries',
    'getEntriesByName',
    'getEntriesByType',
    'mark',
    'measure',
    'now',
    'setFrameTimingBufferSize',
    'clearResourceTimings',
    'setResourceTimingBufferSize',
    'onResourceTimingBufferFull',
    'memory',
    'navigation',
    'timing'
  ]);
  html$.Performance = class Performance extends html$.EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static get supported() {
      return !!window.performance;
    }
    get [dartx.memory]() {
      return this.memory;
    }
    get [dartx.navigation]() {
      return this.navigation;
    }
    get [dartx.timing]() {
      return this.timing;
    }
    [dartx.clearFrameTimings]() {
      return this.clearFrameTimings();
    }
    [dartx.clearMarks](markName) {
      return this.clearMarks(markName);
    }
    [dartx.clearMeasures](measureName) {
      return this.clearMeasures(measureName);
    }
    [dartx.getEntries]() {
      return this.getEntries();
    }
    [dartx.getEntriesByName](name, entryType) {
      return this.getEntriesByName(name, entryType);
    }
    [dartx.getEntriesByType](entryType) {
      return this.getEntriesByType(entryType);
    }
    [dartx.mark](markName) {
      return this.mark(markName);
    }
    [dartx.measure](measureName, startMark, endMark) {
      return this.measure(measureName, startMark, endMark);
    }
    [dartx.now]() {
      return this.now();
    }
    [dartx.setFrameTimingBufferSize](maxSize) {
      return this.setFrameTimingBufferSize(maxSize);
    }
    [dartx.clearResourceTimings]() {
      return this.webkitClearResourceTimings();
    }
    [dartx.setResourceTimingBufferSize](maxSize) {
      return this.webkitSetResourceTimingBufferSize(maxSize);
    }
    get [dartx.onResourceTimingBufferFull]() {
      return html$.Performance.resourceTimingBufferFullEvent.forTarget(this);
    }
  };
  dart.setSignature(html$.Performance, {
    constructors: () => ({_: dart.definiteFunctionType(html$.Performance, [])}),
    methods: () => ({
      [dartx.clearFrameTimings]: dart.definiteFunctionType(dart.void, []),
      [dartx.clearMarks]: dart.definiteFunctionType(dart.void, [core.String]),
      [dartx.clearMeasures]: dart.definiteFunctionType(dart.void, [core.String]),
      [dartx.getEntries]: dart.definiteFunctionType(core.List$(html$.PerformanceEntry), []),
      [dartx.getEntriesByName]: dart.definiteFunctionType(core.List$(html$.PerformanceEntry), [core.String, core.String]),
      [dartx.getEntriesByType]: dart.definiteFunctionType(core.List$(html$.PerformanceEntry), [core.String]),
      [dartx.mark]: dart.definiteFunctionType(dart.void, [core.String]),
      [dartx.measure]: dart.definiteFunctionType(dart.void, [core.String, core.String, core.String]),
      [dartx.now]: dart.definiteFunctionType(core.double, []),
      [dartx.setFrameTimingBufferSize]: dart.definiteFunctionType(dart.void, [core.int]),
      [dartx.clearResourceTimings]: dart.definiteFunctionType(dart.void, []),
      [dartx.setResourceTimingBufferSize]: dart.definiteFunctionType(dart.void, [core.int])
    })
  });
  dart.defineLazy(html$.Performance, {
    get resourceTimingBufferFullEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('webkitresourcetimingbufferfull'));
    }
  });
  dart.registerExtension(dart.global.Performance, html$.Performance);
  dart.defineExtensionNames([
    'duration',
    'entryType',
    'name',
    'startTime'
  ]);
  html$.PerformanceEntry = class PerformanceEntry extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.duration]() {
      return this.duration;
    }
    get [dartx.entryType]() {
      return this.entryType;
    }
    get [dartx.name]() {
      return this.name;
    }
    get [dartx.startTime]() {
      return this.startTime;
    }
  };
  dart.setSignature(html$.PerformanceEntry, {
    constructors: () => ({_: dart.definiteFunctionType(html$.PerformanceEntry, [])})
  });
  dart.registerExtension(dart.global.PerformanceEntry, html$.PerformanceEntry);
  dart.defineExtensionNames([
    'sourceFrame'
  ]);
  html$.PerformanceCompositeTiming = class PerformanceCompositeTiming extends html$.PerformanceEntry {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.sourceFrame]() {
      return this.sourceFrame;
    }
  };
  dart.setSignature(html$.PerformanceCompositeTiming, {
    constructors: () => ({_: dart.definiteFunctionType(html$.PerformanceCompositeTiming, [])})
  });
  dart.registerExtension(dart.global.PerformanceCompositeTiming, html$.PerformanceCompositeTiming);
  html$.PerformanceMark = class PerformanceMark extends html$.PerformanceEntry {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(html$.PerformanceMark, {
    constructors: () => ({_: dart.definiteFunctionType(html$.PerformanceMark, [])})
  });
  dart.registerExtension(dart.global.PerformanceMark, html$.PerformanceMark);
  html$.PerformanceMeasure = class PerformanceMeasure extends html$.PerformanceEntry {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(html$.PerformanceMeasure, {
    constructors: () => ({_: dart.definiteFunctionType(html$.PerformanceMeasure, [])})
  });
  dart.registerExtension(dart.global.PerformanceMeasure, html$.PerformanceMeasure);
  dart.defineExtensionNames([
    'redirectCount',
    'type'
  ]);
  html$.PerformanceNavigation = class PerformanceNavigation extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.redirectCount]() {
      return this.redirectCount;
    }
    get [dartx.type]() {
      return this.type;
    }
  };
  dart.setSignature(html$.PerformanceNavigation, {
    constructors: () => ({_: dart.definiteFunctionType(html$.PerformanceNavigation, [])})
  });
  html$.PerformanceNavigation.TYPE_BACK_FORWARD = 2;
  html$.PerformanceNavigation.TYPE_NAVIGATE = 0;
  html$.PerformanceNavigation.TYPE_RELOAD = 1;
  html$.PerformanceNavigation.TYPE_RESERVED = 255;
  dart.registerExtension(dart.global.PerformanceNavigation, html$.PerformanceNavigation);
  dart.defineExtensionNames([
    'sourceFrame'
  ]);
  html$.PerformanceRenderTiming = class PerformanceRenderTiming extends html$.PerformanceEntry {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.sourceFrame]() {
      return this.sourceFrame;
    }
  };
  dart.setSignature(html$.PerformanceRenderTiming, {
    constructors: () => ({_: dart.definiteFunctionType(html$.PerformanceRenderTiming, [])})
  });
  dart.registerExtension(dart.global.PerformanceRenderTiming, html$.PerformanceRenderTiming);
  dart.defineExtensionNames([
    'connectEnd',
    'connectStart',
    'domainLookupEnd',
    'domainLookupStart',
    'fetchStart',
    'initiatorType',
    'redirectEnd',
    'redirectStart',
    'requestStart',
    'responseEnd',
    'responseStart',
    'secureConnectionStart',
    'workerStart'
  ]);
  html$.PerformanceResourceTiming = class PerformanceResourceTiming extends html$.PerformanceEntry {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.connectEnd]() {
      return this.connectEnd;
    }
    get [dartx.connectStart]() {
      return this.connectStart;
    }
    get [dartx.domainLookupEnd]() {
      return this.domainLookupEnd;
    }
    get [dartx.domainLookupStart]() {
      return this.domainLookupStart;
    }
    get [dartx.fetchStart]() {
      return this.fetchStart;
    }
    get [dartx.initiatorType]() {
      return this.initiatorType;
    }
    get [dartx.redirectEnd]() {
      return this.redirectEnd;
    }
    get [dartx.redirectStart]() {
      return this.redirectStart;
    }
    get [dartx.requestStart]() {
      return this.requestStart;
    }
    get [dartx.responseEnd]() {
      return this.responseEnd;
    }
    get [dartx.responseStart]() {
      return this.responseStart;
    }
    get [dartx.secureConnectionStart]() {
      return this.secureConnectionStart;
    }
    get [dartx.workerStart]() {
      return this.workerStart;
    }
  };
  dart.setSignature(html$.PerformanceResourceTiming, {
    constructors: () => ({_: dart.definiteFunctionType(html$.PerformanceResourceTiming, [])})
  });
  dart.registerExtension(dart.global.PerformanceResourceTiming, html$.PerformanceResourceTiming);
  dart.defineExtensionNames([
    'connectEnd',
    'connectStart',
    'domComplete',
    'domContentLoadedEventEnd',
    'domContentLoadedEventStart',
    'domInteractive',
    'domLoading',
    'domainLookupEnd',
    'domainLookupStart',
    'fetchStart',
    'loadEventEnd',
    'loadEventStart',
    'navigationStart',
    'redirectEnd',
    'redirectStart',
    'requestStart',
    'responseEnd',
    'responseStart',
    'secureConnectionStart',
    'unloadEventEnd',
    'unloadEventStart'
  ]);
  html$.PerformanceTiming = class PerformanceTiming extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.connectEnd]() {
      return this.connectEnd;
    }
    get [dartx.connectStart]() {
      return this.connectStart;
    }
    get [dartx.domComplete]() {
      return this.domComplete;
    }
    get [dartx.domContentLoadedEventEnd]() {
      return this.domContentLoadedEventEnd;
    }
    get [dartx.domContentLoadedEventStart]() {
      return this.domContentLoadedEventStart;
    }
    get [dartx.domInteractive]() {
      return this.domInteractive;
    }
    get [dartx.domLoading]() {
      return this.domLoading;
    }
    get [dartx.domainLookupEnd]() {
      return this.domainLookupEnd;
    }
    get [dartx.domainLookupStart]() {
      return this.domainLookupStart;
    }
    get [dartx.fetchStart]() {
      return this.fetchStart;
    }
    get [dartx.loadEventEnd]() {
      return this.loadEventEnd;
    }
    get [dartx.loadEventStart]() {
      return this.loadEventStart;
    }
    get [dartx.navigationStart]() {
      return this.navigationStart;
    }
    get [dartx.redirectEnd]() {
      return this.redirectEnd;
    }
    get [dartx.redirectStart]() {
      return this.redirectStart;
    }
    get [dartx.requestStart]() {
      return this.requestStart;
    }
    get [dartx.responseEnd]() {
      return this.responseEnd;
    }
    get [dartx.responseStart]() {
      return this.responseStart;
    }
    get [dartx.secureConnectionStart]() {
      return this.secureConnectionStart;
    }
    get [dartx.unloadEventEnd]() {
      return this.unloadEventEnd;
    }
    get [dartx.unloadEventStart]() {
      return this.unloadEventStart;
    }
  };
  dart.setSignature(html$.PerformanceTiming, {
    constructors: () => ({_: dart.definiteFunctionType(html$.PerformanceTiming, [])})
  });
  dart.registerExtension(dart.global.PerformanceTiming, html$.PerformanceTiming);
  dart.defineExtensionNames([
    'registration'
  ]);
  html$.PeriodicSyncEvent = class PeriodicSyncEvent extends html$.ExtendableEvent {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(type, init) {
      let init_1 = html_common.convertDartToNative_Dictionary(init);
      return html$.PeriodicSyncEvent._create_1(type, init_1);
    }
    static _create_1(type, init) {
      return new PeriodicSyncEvent(type, init);
    }
    get [dartx.registration]() {
      return this.registration;
    }
  };
  dart.setSignature(html$.PeriodicSyncEvent, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.PeriodicSyncEvent, []),
      new: dart.definiteFunctionType(html$.PeriodicSyncEvent, [core.String, core.Map])
    }),
    statics: () => ({_create_1: dart.definiteFunctionType(html$.PeriodicSyncEvent, [dart.dynamic, dart.dynamic])}),
    names: ['_create_1']
  });
  dart.registerExtension(dart.global.PeriodicSyncEvent, html$.PeriodicSyncEvent);
  const _register_1 = Symbol('_register_1');
  const _register_2 = Symbol('_register_2');
  dart.defineExtensionNames([
    'getRegistration',
    'getRegistrations',
    'permissionState',
    'register',
    'minPossiblePeriod'
  ]);
  html$.PeriodicSyncManager = class PeriodicSyncManager extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.minPossiblePeriod]() {
      return this.minPossiblePeriod;
    }
    [dartx.getRegistration](tag) {
      return this.getRegistration(tag);
    }
    [dartx.getRegistrations]() {
      return this.getRegistrations();
    }
    [dartx.permissionState]() {
      return this.permissionState();
    }
    [dartx.register](options) {
      if (options === void 0) options = null;
      if (options != null) {
        let options_1 = html_common.convertDartToNative_Dictionary(options);
        return this[_register_1](options_1);
      }
      return this[_register_2]();
    }
    [_register_1](options) {
      return this.register(options);
    }
    [_register_2]() {
      return this.register();
    }
  };
  dart.setSignature(html$.PeriodicSyncManager, {
    constructors: () => ({_: dart.definiteFunctionType(html$.PeriodicSyncManager, [])}),
    methods: () => ({
      [dartx.getRegistration]: dart.definiteFunctionType(async.Future, [core.String]),
      [dartx.getRegistrations]: dart.definiteFunctionType(async.Future, []),
      [dartx.permissionState]: dart.definiteFunctionType(async.Future, []),
      [dartx.register]: dart.definiteFunctionType(async.Future, [], [core.Map]),
      [_register_1]: dart.definiteFunctionType(async.Future, [dart.dynamic]),
      [_register_2]: dart.definiteFunctionType(async.Future, [])
    })
  });
  dart.registerExtension(dart.global.PeriodicSyncManager, html$.PeriodicSyncManager);
  dart.defineExtensionNames([
    'unregister',
    'minPeriod',
    'networkState',
    'powerState',
    'tag'
  ]);
  html$.PeriodicSyncRegistration = class PeriodicSyncRegistration extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.minPeriod]() {
      return this.minPeriod;
    }
    get [dartx.networkState]() {
      return this.networkState;
    }
    get [dartx.powerState]() {
      return this.powerState;
    }
    get [dartx.tag]() {
      return this.tag;
    }
    [dartx.unregister]() {
      return this.unregister();
    }
  };
  dart.setSignature(html$.PeriodicSyncRegistration, {
    constructors: () => ({_: dart.definiteFunctionType(html$.PeriodicSyncRegistration, [])}),
    methods: () => ({[dartx.unregister]: dart.definiteFunctionType(async.Future, [])})
  });
  dart.registerExtension(dart.global.PeriodicSyncRegistration, html$.PeriodicSyncRegistration);
  dart.defineExtensionNames([
    'onChange',
    'state',
    'status'
  ]);
  html$.PermissionStatus = class PermissionStatus extends html$.EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.state]() {
      return this.state;
    }
    get [dartx.status]() {
      return this.status;
    }
    get [dartx.onChange]() {
      return html$.PermissionStatus.changeEvent.forTarget(this);
    }
  };
  dart.setSignature(html$.PermissionStatus, {
    constructors: () => ({_: dart.definiteFunctionType(html$.PermissionStatus, [])})
  });
  dart.defineLazy(html$.PermissionStatus, {
    get changeEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('change'));
    }
  });
  dart.registerExtension(dart.global.PermissionStatus, html$.PermissionStatus);
  dart.defineExtensionNames([
    'query'
  ]);
  html$.Permissions = class Permissions extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [dartx.query](permission) {
      return this.query(permission);
    }
  };
  dart.setSignature(html$.Permissions, {
    constructors: () => ({_: dart.definiteFunctionType(html$.Permissions, [])}),
    methods: () => ({[dartx.query]: dart.definiteFunctionType(async.Future, [core.Object])})
  });
  dart.registerExtension(dart.global.Permissions, html$.Permissions);
  html$.PictureElement = class PictureElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    created() {
      super.created();
    }
  };
  dart.defineNamedConstructor(html$.PictureElement, 'created');
  dart.setSignature(html$.PictureElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.PictureElement, []),
      created: dart.definiteFunctionType(html$.PictureElement, [])
    })
  });
  dart.registerExtension(dart.global.HTMLPictureElement, html$.PictureElement);
  dart.defineExtensionNames([
    'item',
    'namedItem',
    'description',
    'filename',
    'length',
    'name'
  ]);
  html$.Plugin = class Plugin extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.description]() {
      return this.description;
    }
    get [dartx.filename]() {
      return this.filename;
    }
    get [dartx.length]() {
      return this.length;
    }
    get [dartx.name]() {
      return this.name;
    }
    [dartx.item](index) {
      return this.item(index);
    }
    [dartx.namedItem](name) {
      return this.namedItem(name);
    }
  };
  dart.setSignature(html$.Plugin, {
    constructors: () => ({_: dart.definiteFunctionType(html$.Plugin, [])}),
    methods: () => ({
      [dartx.item]: dart.definiteFunctionType(html$.MimeType, [core.int]),
      [dartx.namedItem]: dart.definiteFunctionType(html$.MimeType, [core.String])
    })
  });
  dart.registerExtension(dart.global.Plugin, html$.Plugin);
  dart.defineExtensionNames([
    'length',
    'get',
    'set',
    'length',
    'first',
    'last',
    'single',
    'elementAt',
    'item',
    'namedItem',
    'refresh'
  ]);
  html$.PluginArray = class PluginArray extends dart.mixin(_interceptors.Interceptor, collection.ListMixin$(html$.Plugin), html$.ImmutableListMixin$(html$.Plugin)) {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.length]() {
      return this.length;
    }
    [dartx.get](index) {
      if (index >>> 0 !== index || index >= this[dartx.length]) dart.throw(core.RangeError.index(index, this));
      return this[index];
    }
    [dartx.set](index, value) {
      dart.throw(new core.UnsupportedError("Cannot assign element of immutable List."));
      return value;
    }
    set [dartx.length](value) {
      dart.throw(new core.UnsupportedError("Cannot resize immutable List."));
    }
    get [dartx.first]() {
      if (dart.notNull(this[dartx.length]) > 0) {
        return this[0];
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.last]() {
      let len = this[dartx.length];
      if (dart.notNull(len) > 0) {
        return this[dart.notNull(len) - 1];
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.single]() {
      let len = this[dartx.length];
      if (len == 1) {
        return this[0];
      }
      if (len == 0) dart.throw(new core.StateError("No elements"));
      dart.throw(new core.StateError("More than one element"));
    }
    [dartx.elementAt](index) {
      return this[dartx.get](index);
    }
    [dartx.item](index) {
      return this.item(index);
    }
    [dartx.namedItem](name) {
      return this.namedItem(name);
    }
    [dartx.refresh](reload) {
      return this.refresh(reload);
    }
  };
  html$.PluginArray[dart.implements] = () => [_js_helper.JavaScriptIndexingBehavior, ListOfPlugin()];
  dart.setSignature(html$.PluginArray, {
    constructors: () => ({_: dart.definiteFunctionType(html$.PluginArray, [])}),
    methods: () => ({
      [dartx.get]: dart.definiteFunctionType(html$.Plugin, [core.int]),
      [dartx.set]: dart.definiteFunctionType(dart.void, [core.int, html$.Plugin]),
      [dartx.elementAt]: dart.definiteFunctionType(html$.Plugin, [core.int]),
      [dartx.item]: dart.definiteFunctionType(html$.Plugin, [core.int]),
      [dartx.namedItem]: dart.definiteFunctionType(html$.Plugin, [core.String]),
      [dartx.refresh]: dart.definiteFunctionType(dart.void, [core.bool])
    })
  });
  dart.registerExtension(dart.global.PluginArray, html$.PluginArray);
  dart.defineExtensionNames([
    'createdCallback',
    'closeable',
    'message'
  ]);
  html$.PluginPlaceholderElement = class PluginPlaceholderElement extends html$.DivElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    created() {
      this[dartx.closeable] = null;
      this[dartx.message] = null;
      super.created();
    }
    get [dartx.closeable]() {
      return this.closeable;
    }
    set [dartx.closeable](value) {
      this.closeable = value;
    }
    get [dartx.message]() {
      return this.message;
    }
    set [dartx.message](value) {
      this.message = value;
    }
    [dartx.createdCallback]() {
      return this.createdCallback();
    }
  };
  dart.defineNamedConstructor(html$.PluginPlaceholderElement, 'created');
  dart.setSignature(html$.PluginPlaceholderElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.PluginPlaceholderElement, []),
      created: dart.definiteFunctionType(html$.PluginPlaceholderElement, [])
    }),
    methods: () => ({[dartx.createdCallback]: dart.definiteFunctionType(dart.void, [])})
  });
  dart.registerExtension(dart.global.PluginPlaceholderElement, html$.PluginPlaceholderElement);
  dart.defineExtensionNames([
    'height',
    'isPrimary',
    'pointerId',
    'pointerType',
    'pressure',
    'tiltX',
    'tiltY',
    'width'
  ]);
  html$.PointerEvent = class PointerEvent extends html$.MouseEvent {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(type, eventInitDict) {
      if (eventInitDict === void 0) eventInitDict = null;
      if (eventInitDict != null) {
        let eventInitDict_1 = html_common.convertDartToNative_Dictionary(eventInitDict);
        return html$.PointerEvent._create_1(type, eventInitDict_1);
      }
      return html$.PointerEvent._create_2(type);
    }
    static _create_1(type, eventInitDict) {
      return new PointerEvent(type, eventInitDict);
    }
    static _create_2(type) {
      return new PointerEvent(type);
    }
    get [dartx.height]() {
      return this.height;
    }
    get [dartx.isPrimary]() {
      return this.isPrimary;
    }
    get [dartx.pointerId]() {
      return this.pointerId;
    }
    get [dartx.pointerType]() {
      return this.pointerType;
    }
    get [dartx.pressure]() {
      return this.pressure;
    }
    get [dartx.tiltX]() {
      return this.tiltX;
    }
    get [dartx.tiltY]() {
      return this.tiltY;
    }
    get [dartx.width]() {
      return this.width;
    }
  };
  dart.setSignature(html$.PointerEvent, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.PointerEvent, []),
      new: dart.definiteFunctionType(html$.PointerEvent, [core.String], [core.Map])
    }),
    statics: () => ({
      _create_1: dart.definiteFunctionType(html$.PointerEvent, [dart.dynamic, dart.dynamic]),
      _create_2: dart.definiteFunctionType(html$.PointerEvent, [dart.dynamic])
    }),
    names: ['_create_1', '_create_2']
  });
  dart.registerExtension(dart.global.PointerEvent, html$.PointerEvent);
  dart.defineExtensionNames([
    'state'
  ]);
  html$.PopStateEvent = class PopStateEvent extends html$.Event {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(type, eventInitDict) {
      if (eventInitDict === void 0) eventInitDict = null;
      if (eventInitDict != null) {
        let eventInitDict_1 = html_common.convertDartToNative_Dictionary(eventInitDict);
        return html$.PopStateEvent._create_1(type, eventInitDict_1);
      }
      return html$.PopStateEvent._create_2(type);
    }
    static _create_1(type, eventInitDict) {
      return new PopStateEvent(type, eventInitDict);
    }
    static _create_2(type) {
      return new PopStateEvent(type);
    }
    get [dartx.state]() {
      return html_common.convertNativeToDart_SerializedScriptValue(this[_get_state]);
    }
    get [_get_state]() {
      return this.state;
    }
  };
  dart.setSignature(html$.PopStateEvent, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.PopStateEvent, []),
      new: dart.definiteFunctionType(html$.PopStateEvent, [core.String], [core.Map])
    }),
    statics: () => ({
      _create_1: dart.definiteFunctionType(html$.PopStateEvent, [dart.dynamic, dart.dynamic]),
      _create_2: dart.definiteFunctionType(html$.PopStateEvent, [dart.dynamic])
    }),
    names: ['_create_1', '_create_2']
  });
  dart.registerExtension(dart.global.PopStateEvent, html$.PopStateEvent);
  html$._PositionCallback = dart.typedef('_PositionCallback', () => dart.functionType(dart.void, [html$.Geoposition]));
  dart.defineExtensionNames([
    'code',
    'message'
  ]);
  html$.PositionError = class PositionError extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.code]() {
      return this.code;
    }
    get [dartx.message]() {
      return this.message;
    }
  };
  dart.setSignature(html$.PositionError, {
    constructors: () => ({_: dart.definiteFunctionType(html$.PositionError, [])})
  });
  html$.PositionError.PERMISSION_DENIED = 1;
  html$.PositionError.POSITION_UNAVAILABLE = 2;
  html$.PositionError.TIMEOUT = 3;
  dart.registerExtension(dart.global.PositionError, html$.PositionError);
  html$._PositionErrorCallback = dart.typedef('_PositionErrorCallback', () => dart.functionType(dart.void, [html$.PositionError]));
  dart.defineExtensionNames([
    'getImmediateState',
    'getState',
    'resetSensor'
  ]);
  html$.PositionSensorVRDevice = class PositionSensorVRDevice extends html$.VRDevice {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [dartx.getImmediateState]() {
      return this.getImmediateState();
    }
    [dartx.getState]() {
      return this.getState();
    }
    [dartx.resetSensor]() {
      return this.resetSensor();
    }
  };
  dart.setSignature(html$.PositionSensorVRDevice, {
    constructors: () => ({_: dart.definiteFunctionType(html$.PositionSensorVRDevice, [])}),
    methods: () => ({
      [dartx.getImmediateState]: dart.definiteFunctionType(html$.VRPositionState, []),
      [dartx.getState]: dart.definiteFunctionType(html$.VRPositionState, []),
      [dartx.resetSensor]: dart.definiteFunctionType(dart.void, [])
    })
  });
  dart.registerExtension(dart.global.PositionSensorVRDevice, html$.PositionSensorVRDevice);
  html$.PreElement = class PreElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return html$.PreElement._check(html$.document[dartx.createElement]("pre"));
    }
    created() {
      super.created();
    }
  };
  dart.defineNamedConstructor(html$.PreElement, 'created');
  dart.setSignature(html$.PreElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.PreElement, []),
      new: dart.definiteFunctionType(html$.PreElement, []),
      created: dart.definiteFunctionType(html$.PreElement, [])
    })
  });
  dart.registerExtension(dart.global.HTMLPreElement, html$.PreElement);
  dart.defineExtensionNames([
    'getAvailability',
    'joinSession',
    'startSession',
    'session'
  ]);
  html$.Presentation = class Presentation extends html$.EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.session]() {
      return this.session;
    }
    [dartx.getAvailability](url) {
      return this.getAvailability(url);
    }
    [dartx.joinSession](url, presentationId) {
      return this.joinSession(url, presentationId);
    }
    [dartx.startSession](url) {
      return this.startSession(url);
    }
  };
  dart.setSignature(html$.Presentation, {
    constructors: () => ({_: dart.definiteFunctionType(html$.Presentation, [])}),
    methods: () => ({
      [dartx.getAvailability]: dart.definiteFunctionType(async.Future, [core.String]),
      [dartx.joinSession]: dart.definiteFunctionType(async.Future, [core.String, core.String]),
      [dartx.startSession]: dart.definiteFunctionType(async.Future, [core.String])
    })
  });
  dart.registerExtension(dart.global.Presentation, html$.Presentation);
  dart.defineExtensionNames([
    'onChange',
    'value'
  ]);
  html$.PresentationAvailability = class PresentationAvailability extends html$.EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.value]() {
      return this.value;
    }
    get [dartx.onChange]() {
      return html$.PresentationAvailability.changeEvent.forTarget(this);
    }
  };
  dart.setSignature(html$.PresentationAvailability, {
    constructors: () => ({_: dart.definiteFunctionType(html$.PresentationAvailability, [])})
  });
  dart.defineLazy(html$.PresentationAvailability, {
    get changeEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('change'));
    }
  });
  dart.registerExtension(dart.global.PresentationAvailability, html$.PresentationAvailability);
  dart.defineExtensionNames([
    'close',
    'send',
    'onMessage',
    'binaryType',
    'id',
    'state'
  ]);
  html$.PresentationSession = class PresentationSession extends html$.EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.binaryType]() {
      return this.binaryType;
    }
    set [dartx.binaryType](value) {
      this.binaryType = value;
    }
    get [dartx.id]() {
      return this.id;
    }
    get [dartx.state]() {
      return this.state;
    }
    [dartx.close]() {
      return this.close();
    }
    [dartx.send](data_OR_message) {
      return this.send(data_OR_message);
    }
    get [dartx.onMessage]() {
      return html$.PresentationSession.messageEvent.forTarget(this);
    }
  };
  dart.setSignature(html$.PresentationSession, {
    constructors: () => ({_: dart.definiteFunctionType(html$.PresentationSession, [])}),
    methods: () => ({
      [dartx.close]: dart.definiteFunctionType(dart.void, []),
      [dartx.send]: dart.definiteFunctionType(dart.void, [dart.dynamic])
    })
  });
  dart.defineLazy(html$.PresentationSession, {
    get messageEvent() {
      return dart.const(new (EventStreamProviderOfMessageEvent())('message'));
    }
  });
  dart.registerExtension(dart.global.PresentationSession, html$.PresentationSession);
  dart.defineExtensionNames([
    'sheet',
    'target'
  ]);
  html$.ProcessingInstruction = class ProcessingInstruction extends html$.CharacterData {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.sheet]() {
      return this.sheet;
    }
    get [dartx.target]() {
      return this.target;
    }
  };
  dart.setSignature(html$.ProcessingInstruction, {
    constructors: () => ({_: dart.definiteFunctionType(html$.ProcessingInstruction, [])})
  });
  dart.registerExtension(dart.global.ProcessingInstruction, html$.ProcessingInstruction);
  dart.defineExtensionNames([
    'labels',
    'max',
    'position',
    'value'
  ]);
  html$.ProgressElement = class ProgressElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return html$.ProgressElement._check(html$.document[dartx.createElement]("progress"));
    }
    created() {
      this[dartx.labels] = null;
      this[dartx.max] = null;
      this[dartx.position] = null;
      this[dartx.value] = null;
      super.created();
    }
    static get supported() {
      return html$.Element.isTagSupported('progress');
    }
    get [dartx.labels]() {
      return this.labels;
    }
    get [dartx.max]() {
      return this.max;
    }
    set [dartx.max](value) {
      this.max = value;
    }
    get [dartx.position]() {
      return this.position;
    }
    get [dartx.value]() {
      return this.value;
    }
    set [dartx.value](value) {
      this.value = value;
    }
  };
  dart.defineNamedConstructor(html$.ProgressElement, 'created');
  dart.setSignature(html$.ProgressElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.ProgressElement, []),
      new: dart.definiteFunctionType(html$.ProgressElement, []),
      created: dart.definiteFunctionType(html$.ProgressElement, [])
    })
  });
  dart.registerExtension(dart.global.HTMLProgressElement, html$.ProgressElement);
  dart.defineExtensionNames([
    'lengthComputable',
    'loaded',
    'total'
  ]);
  html$.ProgressEvent = class ProgressEvent extends html$.Event {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(type, eventInitDict) {
      if (eventInitDict === void 0) eventInitDict = null;
      if (eventInitDict != null) {
        let eventInitDict_1 = html_common.convertDartToNative_Dictionary(eventInitDict);
        return html$.ProgressEvent._create_1(type, eventInitDict_1);
      }
      return html$.ProgressEvent._create_2(type);
    }
    static _create_1(type, eventInitDict) {
      return new ProgressEvent(type, eventInitDict);
    }
    static _create_2(type) {
      return new ProgressEvent(type);
    }
    get [dartx.lengthComputable]() {
      return this.lengthComputable;
    }
    get [dartx.loaded]() {
      return this.loaded;
    }
    get [dartx.total]() {
      return this.total;
    }
  };
  dart.setSignature(html$.ProgressEvent, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.ProgressEvent, []),
      new: dart.definiteFunctionType(html$.ProgressEvent, [core.String], [core.Map])
    }),
    statics: () => ({
      _create_1: dart.definiteFunctionType(html$.ProgressEvent, [dart.dynamic, dart.dynamic]),
      _create_2: dart.definiteFunctionType(html$.ProgressEvent, [dart.dynamic])
    }),
    names: ['_create_1', '_create_2']
  });
  dart.registerExtension(dart.global.ProgressEvent, html$.ProgressEvent);
  dart.defineExtensionNames([
    'promise',
    'reason'
  ]);
  html$.PromiseRejectionEvent = class PromiseRejectionEvent extends html$.Event {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(type, eventInitDict) {
      if (eventInitDict === void 0) eventInitDict = null;
      if (eventInitDict != null) {
        let eventInitDict_1 = html_common.convertDartToNative_Dictionary(eventInitDict);
        return html$.PromiseRejectionEvent._create_1(type, eventInitDict_1);
      }
      return html$.PromiseRejectionEvent._create_2(type);
    }
    static _create_1(type, eventInitDict) {
      return new PromiseRejectionEvent(type, eventInitDict);
    }
    static _create_2(type) {
      return new PromiseRejectionEvent(type);
    }
    get [dartx.promise]() {
      return this.promise;
    }
    get [dartx.reason]() {
      return this.reason;
    }
  };
  dart.setSignature(html$.PromiseRejectionEvent, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.PromiseRejectionEvent, []),
      new: dart.definiteFunctionType(html$.PromiseRejectionEvent, [core.String], [core.Map])
    }),
    statics: () => ({
      _create_1: dart.definiteFunctionType(html$.PromiseRejectionEvent, [dart.dynamic, dart.dynamic]),
      _create_2: dart.definiteFunctionType(html$.PromiseRejectionEvent, [dart.dynamic])
    }),
    names: ['_create_1', '_create_2']
  });
  dart.registerExtension(dart.global.PromiseRejectionEvent, html$.PromiseRejectionEvent);
  dart.defineExtensionNames([
    'data'
  ]);
  html$.PushEvent = class PushEvent extends html$.ExtendableEvent {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(type, eventInitDict) {
      if (eventInitDict === void 0) eventInitDict = null;
      if (eventInitDict != null) {
        let eventInitDict_1 = html_common.convertDartToNative_Dictionary(eventInitDict);
        return html$.PushEvent._create_1(type, eventInitDict_1);
      }
      return html$.PushEvent._create_2(type);
    }
    static _create_1(type, eventInitDict) {
      return new PushEvent(type, eventInitDict);
    }
    static _create_2(type) {
      return new PushEvent(type);
    }
    get [dartx.data]() {
      return this.data;
    }
  };
  dart.setSignature(html$.PushEvent, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.PushEvent, []),
      new: dart.definiteFunctionType(html$.PushEvent, [core.String], [core.Map])
    }),
    statics: () => ({
      _create_1: dart.definiteFunctionType(html$.PushEvent, [dart.dynamic, dart.dynamic]),
      _create_2: dart.definiteFunctionType(html$.PushEvent, [dart.dynamic])
    }),
    names: ['_create_1', '_create_2']
  });
  dart.registerExtension(dart.global.PushEvent, html$.PushEvent);
  const _permissionState_1 = Symbol('_permissionState_1');
  const _permissionState_2 = Symbol('_permissionState_2');
  const _subscribe_1 = Symbol('_subscribe_1');
  const _subscribe_2 = Symbol('_subscribe_2');
  dart.defineExtensionNames([
    'getSubscription',
    'permissionState',
    'subscribe'
  ]);
  html$.PushManager = class PushManager extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [dartx.getSubscription]() {
      return this.getSubscription();
    }
    [dartx.permissionState](options) {
      if (options === void 0) options = null;
      if (options != null) {
        let options_1 = html_common.convertDartToNative_Dictionary(options);
        return this[_permissionState_1](options_1);
      }
      return this[_permissionState_2]();
    }
    [_permissionState_1](options) {
      return this.permissionState(options);
    }
    [_permissionState_2]() {
      return this.permissionState();
    }
    [dartx.subscribe](options) {
      if (options === void 0) options = null;
      if (options != null) {
        let options_1 = html_common.convertDartToNative_Dictionary(options);
        return this[_subscribe_1](options_1);
      }
      return this[_subscribe_2]();
    }
    [_subscribe_1](options) {
      return this.subscribe(options);
    }
    [_subscribe_2]() {
      return this.subscribe();
    }
  };
  dart.setSignature(html$.PushManager, {
    constructors: () => ({_: dart.definiteFunctionType(html$.PushManager, [])}),
    methods: () => ({
      [dartx.getSubscription]: dart.definiteFunctionType(async.Future, []),
      [dartx.permissionState]: dart.definiteFunctionType(async.Future, [], [core.Map]),
      [_permissionState_1]: dart.definiteFunctionType(async.Future, [dart.dynamic]),
      [_permissionState_2]: dart.definiteFunctionType(async.Future, []),
      [dartx.subscribe]: dart.definiteFunctionType(async.Future, [], [core.Map]),
      [_subscribe_1]: dart.definiteFunctionType(async.Future, [dart.dynamic]),
      [_subscribe_2]: dart.definiteFunctionType(async.Future, [])
    })
  });
  dart.registerExtension(dart.global.PushManager, html$.PushManager);
  dart.defineExtensionNames([
    'arrayBuffer',
    'blob',
    'json',
    'text'
  ]);
  html$.PushMessageData = class PushMessageData extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(message) {
      return html$.PushMessageData._create_1(message);
    }
    static _create_1(message) {
      return new PushMessageData(message);
    }
    [dartx.arrayBuffer]() {
      return this.arrayBuffer();
    }
    [dartx.blob]() {
      return this.blob();
    }
    [dartx.json]() {
      return this.json();
    }
    [dartx.text]() {
      return this.text();
    }
  };
  dart.setSignature(html$.PushMessageData, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.PushMessageData, []),
      new: dart.definiteFunctionType(html$.PushMessageData, [core.String])
    }),
    methods: () => ({
      [dartx.arrayBuffer]: dart.definiteFunctionType(typed_data.ByteBuffer, []),
      [dartx.blob]: dart.definiteFunctionType(html$.Blob, []),
      [dartx.json]: dart.definiteFunctionType(core.Object, []),
      [dartx.text]: dart.definiteFunctionType(core.String, [])
    }),
    statics: () => ({_create_1: dart.definiteFunctionType(html$.PushMessageData, [dart.dynamic])}),
    names: ['_create_1']
  });
  dart.registerExtension(dart.global.PushMessageData, html$.PushMessageData);
  dart.defineExtensionNames([
    'unsubscribe',
    'endpoint'
  ]);
  html$.PushSubscription = class PushSubscription extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.endpoint]() {
      return this.endpoint;
    }
    [dartx.unsubscribe]() {
      return this.unsubscribe();
    }
  };
  dart.setSignature(html$.PushSubscription, {
    constructors: () => ({_: dart.definiteFunctionType(html$.PushSubscription, [])}),
    methods: () => ({[dartx.unsubscribe]: dart.definiteFunctionType(async.Future, [])})
  });
  dart.registerExtension(dart.global.PushSubscription, html$.PushSubscription);
  dart.defineExtensionNames([
    'cite'
  ]);
  html$.QuoteElement = class QuoteElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return html$.QuoteElement._check(html$.document[dartx.createElement]("q"));
    }
    created() {
      this[dartx.cite] = null;
      super.created();
    }
    get [dartx.cite]() {
      return this.cite;
    }
    set [dartx.cite](value) {
      this.cite = value;
    }
  };
  dart.defineNamedConstructor(html$.QuoteElement, 'created');
  dart.setSignature(html$.QuoteElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.QuoteElement, []),
      new: dart.definiteFunctionType(html$.QuoteElement, []),
      created: dart.definiteFunctionType(html$.QuoteElement, [])
    })
  });
  dart.registerExtension(dart.global.HTMLQuoteElement, html$.QuoteElement);
  html$._RtcErrorCallback = dart.typedef('_RtcErrorCallback', () => dart.functionType(dart.void, [core.String]));
  html$._RtcSessionDescriptionCallback = dart.typedef('_RtcSessionDescriptionCallback', () => dart.functionType(dart.void, [html$.RtcSessionDescription]));
  html$.RtcStatsCallback = dart.typedef('RtcStatsCallback', () => dart.functionType(dart.void, [html$.RtcStatsResponse]));
  dart.defineExtensionNames([
    'cloneContents',
    'cloneRange',
    'collapse',
    'compareBoundaryPoints',
    'comparePoint',
    'createContextualFragment',
    'deleteContents',
    'detach',
    'expand',
    'extractContents',
    'getBoundingClientRect',
    'getClientRects',
    'insertNode',
    'isPointInRange',
    'selectNode',
    'selectNodeContents',
    'setEnd',
    'setEndAfter',
    'setEndBefore',
    'setStart',
    'setStartAfter',
    'setStartBefore',
    'surroundContents',
    'collapsed',
    'commonAncestorContainer',
    'endContainer',
    'endOffset',
    'startContainer',
    'startOffset'
  ]);
  html$.Range = class Range extends _interceptors.Interceptor {
    static new() {
      return html$.document[dartx.createRange]();
    }
    static fromPoint(point) {
      return html$.document[_caretRangeFromPoint](dart.asInt(point.x), dart.asInt(point.y));
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.collapsed]() {
      return this.collapsed;
    }
    get [dartx.commonAncestorContainer]() {
      return this.commonAncestorContainer;
    }
    get [dartx.endContainer]() {
      return this.endContainer;
    }
    get [dartx.endOffset]() {
      return this.endOffset;
    }
    get [dartx.startContainer]() {
      return this.startContainer;
    }
    get [dartx.startOffset]() {
      return this.startOffset;
    }
    [dartx.cloneContents]() {
      return this.cloneContents();
    }
    [dartx.cloneRange]() {
      return this.cloneRange();
    }
    [dartx.collapse](toStart) {
      return this.collapse(toStart);
    }
    [dartx.compareBoundaryPoints](how, sourceRange) {
      return this.compareBoundaryPoints(how, sourceRange);
    }
    [dartx.comparePoint](node, offset) {
      return this.comparePoint(node, offset);
    }
    [dartx.createContextualFragment](fragment) {
      return this.createContextualFragment(fragment);
    }
    [dartx.deleteContents]() {
      return this.deleteContents();
    }
    [dartx.detach]() {
      return this.detach();
    }
    [dartx.expand](unit) {
      return this.expand(unit);
    }
    [dartx.extractContents]() {
      return this.extractContents();
    }
    [dartx.getBoundingClientRect]() {
      return this.getBoundingClientRect();
    }
    [dartx.getClientRects]() {
      return this.getClientRects();
    }
    [dartx.insertNode](node) {
      return this.insertNode(node);
    }
    [dartx.isPointInRange](node, offset) {
      return this.isPointInRange(node, offset);
    }
    [dartx.selectNode](node) {
      return this.selectNode(node);
    }
    [dartx.selectNodeContents](node) {
      return this.selectNodeContents(node);
    }
    [dartx.setEnd](node, offset) {
      return this.setEnd(node, offset);
    }
    [dartx.setEndAfter](node) {
      return this.setEndAfter(node);
    }
    [dartx.setEndBefore](node) {
      return this.setEndBefore(node);
    }
    [dartx.setStart](node, offset) {
      return this.setStart(node, offset);
    }
    [dartx.setStartAfter](node) {
      return this.setStartAfter(node);
    }
    [dartx.setStartBefore](node) {
      return this.setStartBefore(node);
    }
    [dartx.surroundContents](newParent) {
      return this.surroundContents(newParent);
    }
    static get supportsCreateContextualFragment() {
      return "createContextualFragment" in window.Range.prototype;
    }
  };
  dart.setSignature(html$.Range, {
    constructors: () => ({
      new: dart.definiteFunctionType(html$.Range, []),
      fromPoint: dart.definiteFunctionType(html$.Range, [math.Point$(core.num)]),
      _: dart.definiteFunctionType(html$.Range, [])
    }),
    methods: () => ({
      [dartx.cloneContents]: dart.definiteFunctionType(html$.DocumentFragment, []),
      [dartx.cloneRange]: dart.definiteFunctionType(html$.Range, []),
      [dartx.collapse]: dart.definiteFunctionType(dart.void, [], [core.bool]),
      [dartx.compareBoundaryPoints]: dart.definiteFunctionType(core.int, [core.int, html$.Range]),
      [dartx.comparePoint]: dart.definiteFunctionType(core.int, [html$.Node, core.int]),
      [dartx.createContextualFragment]: dart.definiteFunctionType(html$.DocumentFragment, [core.String]),
      [dartx.deleteContents]: dart.definiteFunctionType(dart.void, []),
      [dartx.detach]: dart.definiteFunctionType(dart.void, []),
      [dartx.expand]: dart.definiteFunctionType(dart.void, [core.String]),
      [dartx.extractContents]: dart.definiteFunctionType(html$.DocumentFragment, []),
      [dartx.getBoundingClientRect]: dart.definiteFunctionType(math.Rectangle$(core.num), []),
      [dartx.getClientRects]: dart.definiteFunctionType(core.List$(math.Rectangle$(core.num)), []),
      [dartx.insertNode]: dart.definiteFunctionType(dart.void, [html$.Node]),
      [dartx.isPointInRange]: dart.definiteFunctionType(core.bool, [html$.Node, core.int]),
      [dartx.selectNode]: dart.definiteFunctionType(dart.void, [html$.Node]),
      [dartx.selectNodeContents]: dart.definiteFunctionType(dart.void, [html$.Node]),
      [dartx.setEnd]: dart.definiteFunctionType(dart.void, [html$.Node, core.int]),
      [dartx.setEndAfter]: dart.definiteFunctionType(dart.void, [html$.Node]),
      [dartx.setEndBefore]: dart.definiteFunctionType(dart.void, [html$.Node]),
      [dartx.setStart]: dart.definiteFunctionType(dart.void, [html$.Node, core.int]),
      [dartx.setStartAfter]: dart.definiteFunctionType(dart.void, [html$.Node]),
      [dartx.setStartBefore]: dart.definiteFunctionType(dart.void, [html$.Node]),
      [dartx.surroundContents]: dart.definiteFunctionType(dart.void, [html$.Node])
    })
  });
  html$.Range.END_TO_END = 2;
  html$.Range.END_TO_START = 3;
  html$.Range.START_TO_END = 1;
  html$.Range.START_TO_START = 0;
  dart.registerExtension(dart.global.Range, html$.Range);
  dart.defineExtensionNames([
    'cancel',
    'getReader'
  ]);
  html$.ReadableByteStream = class ReadableByteStream extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [dartx.cancel](reason) {
      return this.cancel(reason);
    }
    [dartx.getReader]() {
      return this.getReader();
    }
  };
  dart.setSignature(html$.ReadableByteStream, {
    constructors: () => ({_: dart.definiteFunctionType(html$.ReadableByteStream, [])}),
    methods: () => ({
      [dartx.cancel]: dart.definiteFunctionType(async.Future, [], [core.Object]),
      [dartx.getReader]: dart.definiteFunctionType(html$.ReadableByteStreamReader, [])
    })
  });
  dart.registerExtension(dart.global.ReadableByteStream, html$.ReadableByteStream);
  dart.defineExtensionNames([
    'cancel',
    'read',
    'releaseLock',
    'closed'
  ]);
  html$.ReadableByteStreamReader = class ReadableByteStreamReader extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.closed]() {
      return this.closed;
    }
    [dartx.cancel](reason) {
      return this.cancel(reason);
    }
    [dartx.read]() {
      return this.read();
    }
    [dartx.releaseLock]() {
      return this.releaseLock();
    }
  };
  dart.setSignature(html$.ReadableByteStreamReader, {
    constructors: () => ({_: dart.definiteFunctionType(html$.ReadableByteStreamReader, [])}),
    methods: () => ({
      [dartx.cancel]: dart.definiteFunctionType(async.Future, [], [core.Object]),
      [dartx.read]: dart.definiteFunctionType(async.Future, []),
      [dartx.releaseLock]: dart.definiteFunctionType(dart.void, [])
    })
  });
  dart.registerExtension(dart.global.ReadableByteStreamReader, html$.ReadableByteStreamReader);
  dart.defineExtensionNames([
    'cancel',
    'getReader'
  ]);
  html$.ReadableStream = class ReadableStream extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [dartx.cancel](reason) {
      return this.cancel(reason);
    }
    [dartx.getReader]() {
      return this.getReader();
    }
  };
  dart.setSignature(html$.ReadableStream, {
    constructors: () => ({_: dart.definiteFunctionType(html$.ReadableStream, [])}),
    methods: () => ({
      [dartx.cancel]: dart.definiteFunctionType(async.Future, [], [core.Object]),
      [dartx.getReader]: dart.definiteFunctionType(html$.ReadableStreamReader, [])
    })
  });
  dart.registerExtension(dart.global.ReadableStream, html$.ReadableStream);
  dart.defineExtensionNames([
    'cancel',
    'read',
    'releaseLock',
    'closed'
  ]);
  html$.ReadableStreamReader = class ReadableStreamReader extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.closed]() {
      return this.closed;
    }
    [dartx.cancel](reason) {
      return this.cancel(reason);
    }
    [dartx.read]() {
      return this.read();
    }
    [dartx.releaseLock]() {
      return this.releaseLock();
    }
  };
  dart.setSignature(html$.ReadableStreamReader, {
    constructors: () => ({_: dart.definiteFunctionType(html$.ReadableStreamReader, [])}),
    methods: () => ({
      [dartx.cancel]: dart.definiteFunctionType(async.Future, [], [core.Object]),
      [dartx.read]: dart.definiteFunctionType(async.Future, []),
      [dartx.releaseLock]: dart.definiteFunctionType(dart.void, [])
    })
  });
  dart.registerExtension(dart.global.ReadableStreamReader, html$.ReadableStreamReader);
  dart.defineExtensionNames([
    'relatedTarget'
  ]);
  html$.RelatedEvent = class RelatedEvent extends html$.Event {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(type, eventInitDict) {
      if (eventInitDict === void 0) eventInitDict = null;
      if (eventInitDict != null) {
        let eventInitDict_1 = html_common.convertDartToNative_Dictionary(eventInitDict);
        return html$.RelatedEvent._create_1(type, eventInitDict_1);
      }
      return html$.RelatedEvent._create_2(type);
    }
    static _create_1(type, eventInitDict) {
      return new RelatedEvent(type, eventInitDict);
    }
    static _create_2(type) {
      return new RelatedEvent(type);
    }
    get [dartx.relatedTarget]() {
      return html$._convertNativeToDart_EventTarget(this[_get_relatedTarget]);
    }
    get [_get_relatedTarget]() {
      return this.relatedTarget;
    }
  };
  dart.setSignature(html$.RelatedEvent, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.RelatedEvent, []),
      new: dart.definiteFunctionType(html$.RelatedEvent, [core.String], [core.Map])
    }),
    statics: () => ({
      _create_1: dart.definiteFunctionType(html$.RelatedEvent, [dart.dynamic, dart.dynamic]),
      _create_2: dart.definiteFunctionType(html$.RelatedEvent, [dart.dynamic])
    }),
    names: ['_create_1', '_create_2']
  });
  dart.registerExtension(dart.global.RelatedEvent, html$.RelatedEvent);
  html$.RequestAnimationFrameCallback = dart.typedef('RequestAnimationFrameCallback', () => dart.functionType(dart.void, [core.num]));
  dart.defineExtensionNames([
    'url'
  ]);
  html$.ResourceProgressEvent = class ResourceProgressEvent extends html$.ProgressEvent {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.url]() {
      return this.url;
    }
  };
  dart.setSignature(html$.ResourceProgressEvent, {
    constructors: () => ({_: dart.definiteFunctionType(html$.ResourceProgressEvent, [])})
  });
  dart.registerExtension(dart.global.ResourceProgressEvent, html$.ResourceProgressEvent);
  dart.defineExtensionNames([
    'close',
    'send',
    'sendBlob',
    'sendByteBuffer',
    'sendString',
    'sendTypedData',
    'onClose',
    'onError',
    'onMessage',
    'onOpen',
    'binaryType',
    'bufferedAmount',
    'id',
    'label',
    'maxRetransmitTime',
    'maxRetransmits',
    'negotiated',
    'ordered',
    'protocol',
    'readyState',
    'reliable'
  ]);
  html$.RtcDataChannel = class RtcDataChannel extends html$.EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.binaryType]() {
      return this.binaryType;
    }
    set [dartx.binaryType](value) {
      this.binaryType = value;
    }
    get [dartx.bufferedAmount]() {
      return this.bufferedAmount;
    }
    get [dartx.id]() {
      return this.id;
    }
    get [dartx.label]() {
      return this.label;
    }
    get [dartx.maxRetransmitTime]() {
      return this.maxRetransmitTime;
    }
    get [dartx.maxRetransmits]() {
      return this.maxRetransmits;
    }
    get [dartx.negotiated]() {
      return this.negotiated;
    }
    get [dartx.ordered]() {
      return this.ordered;
    }
    get [dartx.protocol]() {
      return this.protocol;
    }
    get [dartx.readyState]() {
      return this.readyState;
    }
    get [dartx.reliable]() {
      return this.reliable;
    }
    [dartx.close]() {
      return this.close();
    }
    [dartx.send](data) {
      return this.send(data);
    }
    [dartx.sendBlob](data) {
      return this.send(data);
    }
    [dartx.sendByteBuffer](data) {
      return this.send(data);
    }
    [dartx.sendString](data) {
      return this.send(data);
    }
    [dartx.sendTypedData](data) {
      return this.send(data);
    }
    get [dartx.onClose]() {
      return html$.RtcDataChannel.closeEvent.forTarget(this);
    }
    get [dartx.onError]() {
      return html$.RtcDataChannel.errorEvent.forTarget(this);
    }
    get [dartx.onMessage]() {
      return html$.RtcDataChannel.messageEvent.forTarget(this);
    }
    get [dartx.onOpen]() {
      return html$.RtcDataChannel.openEvent.forTarget(this);
    }
  };
  dart.setSignature(html$.RtcDataChannel, {
    constructors: () => ({_: dart.definiteFunctionType(html$.RtcDataChannel, [])}),
    methods: () => ({
      [dartx.close]: dart.definiteFunctionType(dart.void, []),
      [dartx.send]: dart.definiteFunctionType(dart.void, [dart.dynamic]),
      [dartx.sendBlob]: dart.definiteFunctionType(dart.void, [html$.Blob]),
      [dartx.sendByteBuffer]: dart.definiteFunctionType(dart.void, [typed_data.ByteBuffer]),
      [dartx.sendString]: dart.definiteFunctionType(dart.void, [core.String]),
      [dartx.sendTypedData]: dart.definiteFunctionType(dart.void, [typed_data.TypedData])
    })
  });
  dart.defineLazy(html$.RtcDataChannel, {
    get closeEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('close'));
    },
    get errorEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('error'));
    },
    get messageEvent() {
      return dart.const(new (EventStreamProviderOfMessageEvent())('message'));
    },
    get openEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('open'));
    }
  });
  dart.registerExtension(dart.global.RTCDataChannel, html$.RtcDataChannel);
  dart.defineExtensionNames([
    'channel'
  ]);
  html$.RtcDataChannelEvent = class RtcDataChannelEvent extends html$.Event {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.channel]() {
      return this.channel;
    }
  };
  dart.setSignature(html$.RtcDataChannelEvent, {
    constructors: () => ({_: dart.definiteFunctionType(html$.RtcDataChannelEvent, [])})
  });
  dart.registerExtension(dart.global.RTCDataChannelEvent, html$.RtcDataChannelEvent);
  dart.defineExtensionNames([
    'insertDtmf',
    'onToneChange',
    'canInsertDtmf',
    'duration',
    'interToneGap',
    'toneBuffer',
    'track'
  ]);
  html$.RtcDtmfSender = class RtcDtmfSender extends html$.EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.canInsertDtmf]() {
      return this.canInsertDTMF;
    }
    get [dartx.duration]() {
      return this.duration;
    }
    get [dartx.interToneGap]() {
      return this.interToneGap;
    }
    get [dartx.toneBuffer]() {
      return this.toneBuffer;
    }
    get [dartx.track]() {
      return this.track;
    }
    [dartx.insertDtmf](tones, duration, interToneGap) {
      return this.insertDTMF(tones, duration, interToneGap);
    }
    get [dartx.onToneChange]() {
      return html$.RtcDtmfSender.toneChangeEvent.forTarget(this);
    }
  };
  dart.setSignature(html$.RtcDtmfSender, {
    constructors: () => ({_: dart.definiteFunctionType(html$.RtcDtmfSender, [])}),
    methods: () => ({[dartx.insertDtmf]: dart.definiteFunctionType(dart.void, [core.String], [core.int, core.int])})
  });
  dart.defineLazy(html$.RtcDtmfSender, {
    get toneChangeEvent() {
      return dart.const(new (EventStreamProviderOfRtcDtmfToneChangeEvent())('tonechange'));
    }
  });
  dart.registerExtension(dart.global.RTCDTMFSender, html$.RtcDtmfSender);
  dart.defineExtensionNames([
    'tone'
  ]);
  html$.RtcDtmfToneChangeEvent = class RtcDtmfToneChangeEvent extends html$.Event {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(type, eventInitDict) {
      let eventInitDict_1 = html_common.convertDartToNative_Dictionary(eventInitDict);
      return html$.RtcDtmfToneChangeEvent._create_1(type, eventInitDict_1);
    }
    static _create_1(type, eventInitDict) {
      return new RTCDTMFToneChangeEvent(type, eventInitDict);
    }
    get [dartx.tone]() {
      return this.tone;
    }
  };
  dart.setSignature(html$.RtcDtmfToneChangeEvent, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.RtcDtmfToneChangeEvent, []),
      new: dart.definiteFunctionType(html$.RtcDtmfToneChangeEvent, [core.String, core.Map])
    }),
    statics: () => ({_create_1: dart.definiteFunctionType(html$.RtcDtmfToneChangeEvent, [dart.dynamic, dart.dynamic])}),
    names: ['_create_1']
  });
  dart.registerExtension(dart.global.RTCDTMFToneChangeEvent, html$.RtcDtmfToneChangeEvent);
  dart.defineExtensionNames([
    'candidate',
    'sdpMLineIndex',
    'sdpMid'
  ]);
  html$.RtcIceCandidate = class RtcIceCandidate extends _interceptors.Interceptor {
    static new(dictionary) {
      let constructorName = window[dart.test(html_common.Device.isFirefox) ? dart.str`${html_common.Device.propertyPrefix}RTCIceCandidate` : 'RTCIceCandidate'];
      return new constructorName(html_common.convertDartToNative_SerializedScriptValue(dictionary));
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.candidate]() {
      return this.candidate;
    }
    set [dartx.candidate](value) {
      this.candidate = value;
    }
    get [dartx.sdpMLineIndex]() {
      return this.sdpMLineIndex;
    }
    set [dartx.sdpMLineIndex](value) {
      this.sdpMLineIndex = value;
    }
    get [dartx.sdpMid]() {
      return this.sdpMid;
    }
    set [dartx.sdpMid](value) {
      this.sdpMid = value;
    }
  };
  dart.setSignature(html$.RtcIceCandidate, {
    constructors: () => ({
      new: dart.definiteFunctionType(html$.RtcIceCandidate, [core.Map]),
      _: dart.definiteFunctionType(html$.RtcIceCandidate, [])
    })
  });
  dart.registerExtension(dart.global.RTCIceCandidate, html$.RtcIceCandidate);
  dart.defineExtensionNames([
    'candidate'
  ]);
  html$.RtcIceCandidateEvent = class RtcIceCandidateEvent extends html$.Event {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.candidate]() {
      return this.candidate;
    }
  };
  dart.setSignature(html$.RtcIceCandidateEvent, {
    constructors: () => ({_: dart.definiteFunctionType(html$.RtcIceCandidateEvent, [])})
  });
  dart.registerExtension(dart.global.RTCIceCandidateEvent, html$.RtcIceCandidateEvent);
  const _createOffer = Symbol('_createOffer');
  const _createAnswer = Symbol('_createAnswer');
  const _getStats = Symbol('_getStats');
  const _addStream_1 = Symbol('_addStream_1');
  const _addStream_2 = Symbol('_addStream_2');
  const _createAnswer_1 = Symbol('_createAnswer_1');
  const _createAnswer_2 = Symbol('_createAnswer_2');
  const _createDataChannel_1 = Symbol('_createDataChannel_1');
  const _createDataChannel_2 = Symbol('_createDataChannel_2');
  const _createOffer_1 = Symbol('_createOffer_1');
  const _createOffer_2 = Symbol('_createOffer_2');
  const _setLocalDescription = Symbol('_setLocalDescription');
  const _setRemoteDescription = Symbol('_setRemoteDescription');
  const _updateIce_1 = Symbol('_updateIce_1');
  const _updateIce_2 = Symbol('_updateIce_2');
  const _updateIce_3 = Symbol('_updateIce_3');
  dart.defineExtensionNames([
    'createOffer',
    'createAnswer',
    'getStats',
    'addIceCandidate',
    'addStream',
    'close',
    'createDtmfSender',
    'createDataChannel',
    'getLocalStreams',
    'getRemoteStreams',
    'getStreamById',
    'removeStream',
    'setLocalDescription',
    'setRemoteDescription',
    'updateIce',
    'onAddStream',
    'onDataChannel',
    'onIceCandidate',
    'onIceConnectionStateChange',
    'onNegotiationNeeded',
    'onRemoveStream',
    'onSignalingStateChange',
    'iceConnectionState',
    'iceGatheringState',
    'localDescription',
    'remoteDescription',
    'signalingState'
  ]);
  html$.RtcPeerConnection = class RtcPeerConnection extends html$.EventTarget {
    static new(rtcIceServers, mediaConstraints) {
      if (mediaConstraints === void 0) mediaConstraints = null;
      let constructorName = window[dart.str`${html_common.Device.propertyPrefix}RTCPeerConnection`];
      if (mediaConstraints != null) {
        return new constructorName(html_common.convertDartToNative_SerializedScriptValue(rtcIceServers), html_common.convertDartToNative_SerializedScriptValue(mediaConstraints));
      } else {
        return new constructorName(html_common.convertDartToNative_SerializedScriptValue(rtcIceServers));
      }
    }
    static get supported() {
      try {
        html$.RtcPeerConnection.new(dart.map({iceServers: JSArrayOfMapOfString$String().of([dart.map({url: "stun:localhost"})])}));
        return true;
      } catch (_) {
        return false;
      }

      return false;
    }
    [dartx.createOffer](mediaConstraints) {
      if (mediaConstraints === void 0) mediaConstraints = null;
      let completer = CompleterOfRtcSessionDescription().new();
      this[_createOffer](dart.fn(value => {
        completer.complete(value);
      }, RtcSessionDescriptionTovoid()), dart.fn(error => {
        completer.completeError(error);
      }, StringTovoid()), mediaConstraints);
      return completer.future;
    }
    [dartx.createAnswer](mediaConstraints) {
      if (mediaConstraints === void 0) mediaConstraints = null;
      let completer = CompleterOfRtcSessionDescription().new();
      this[_createAnswer](dart.fn(value => {
        completer.complete(value);
      }, RtcSessionDescriptionTovoid()), dart.fn(error => {
        completer.completeError(error);
      }, StringTovoid()), mediaConstraints);
      return completer.future;
    }
    [dartx.getStats](selector) {
      let completer = CompleterOfRtcStatsResponse().new();
      this[_getStats](dart.fn(value => {
        completer.complete(value);
      }, RtcStatsResponseTovoid()), selector);
      return completer.future;
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.iceConnectionState]() {
      return this.iceConnectionState;
    }
    get [dartx.iceGatheringState]() {
      return this.iceGatheringState;
    }
    get [dartx.localDescription]() {
      return this.localDescription;
    }
    get [dartx.remoteDescription]() {
      return this.remoteDescription;
    }
    get [dartx.signalingState]() {
      return this.signalingState;
    }
    [dartx.addIceCandidate](candidate, successCallback, failureCallback) {
      return this.addIceCandidate(candidate, successCallback, failureCallback);
    }
    [dartx.addStream](stream, mediaConstraints) {
      if (mediaConstraints === void 0) mediaConstraints = null;
      if (mediaConstraints != null) {
        let mediaConstraints_1 = html_common.convertDartToNative_Dictionary(mediaConstraints);
        this[_addStream_1](stream, mediaConstraints_1);
        return;
      }
      this[_addStream_2](stream);
      return;
    }
    [_addStream_1](stream, mediaConstraints) {
      return this.addStream(stream, mediaConstraints);
    }
    [_addStream_2](stream) {
      return this.addStream(stream);
    }
    [dartx.close]() {
      return this.close();
    }
    [_createAnswer](successCallback, failureCallback, mediaConstraints) {
      if (failureCallback === void 0) failureCallback = null;
      if (mediaConstraints === void 0) mediaConstraints = null;
      if (mediaConstraints != null) {
        let mediaConstraints_1 = html_common.convertDartToNative_Dictionary(mediaConstraints);
        this[_createAnswer_1](successCallback, failureCallback, mediaConstraints_1);
        return;
      }
      this[_createAnswer_2](successCallback, failureCallback);
      return;
    }
    [_createAnswer_1](successCallback, failureCallback, mediaConstraints) {
      return this.createAnswer(successCallback, failureCallback, mediaConstraints);
    }
    [_createAnswer_2](successCallback, failureCallback) {
      return this.createAnswer(successCallback, failureCallback);
    }
    [dartx.createDtmfSender](track) {
      return this.createDTMFSender(track);
    }
    [dartx.createDataChannel](label, options) {
      if (options === void 0) options = null;
      if (options != null) {
        let options_1 = html_common.convertDartToNative_Dictionary(options);
        return this[_createDataChannel_1](label, options_1);
      }
      return this[_createDataChannel_2](label);
    }
    [_createDataChannel_1](label, options) {
      return this.createDataChannel(label, options);
    }
    [_createDataChannel_2](label) {
      return this.createDataChannel(label);
    }
    [_createOffer](successCallback, failureCallback, rtcOfferOptions) {
      if (failureCallback === void 0) failureCallback = null;
      if (rtcOfferOptions === void 0) rtcOfferOptions = null;
      if (rtcOfferOptions != null) {
        let rtcOfferOptions_1 = html_common.convertDartToNative_Dictionary(rtcOfferOptions);
        this[_createOffer_1](successCallback, failureCallback, rtcOfferOptions_1);
        return;
      }
      this[_createOffer_2](successCallback, failureCallback);
      return;
    }
    [_createOffer_1](successCallback, failureCallback, rtcOfferOptions) {
      return this.createOffer(successCallback, failureCallback, rtcOfferOptions);
    }
    [_createOffer_2](successCallback, failureCallback) {
      return this.createOffer(successCallback, failureCallback);
    }
    [dartx.getLocalStreams]() {
      return this.getLocalStreams();
    }
    [dartx.getRemoteStreams]() {
      return this.getRemoteStreams();
    }
    [_getStats](successCallback, selector) {
      return this.getStats(successCallback, selector);
    }
    [dartx.getStreamById](streamId) {
      return this.getStreamById(streamId);
    }
    [dartx.removeStream](stream) {
      return this.removeStream(stream);
    }
    [_setLocalDescription](description, successCallback, failureCallback) {
      return this.setLocalDescription(description, successCallback, failureCallback);
    }
    [dartx.setLocalDescription](description) {
      let completer = async.Completer.new();
      this[_setLocalDescription](description, dart.fn(() => {
        completer.complete();
      }, VoidTovoid$()), dart.fn(error => {
        completer.completeError(error);
      }, StringTovoid()));
      return completer.future;
    }
    [_setRemoteDescription](description, successCallback, failureCallback) {
      return this.setRemoteDescription(description, successCallback, failureCallback);
    }
    [dartx.setRemoteDescription](description) {
      let completer = async.Completer.new();
      this[_setRemoteDescription](description, dart.fn(() => {
        completer.complete();
      }, VoidTovoid$()), dart.fn(error => {
        completer.completeError(error);
      }, StringTovoid()));
      return completer.future;
    }
    [dartx.updateIce](configuration, mediaConstraints) {
      if (configuration === void 0) configuration = null;
      if (mediaConstraints === void 0) mediaConstraints = null;
      if (mediaConstraints != null) {
        let configuration_1 = html_common.convertDartToNative_Dictionary(configuration);
        let mediaConstraints_2 = html_common.convertDartToNative_Dictionary(mediaConstraints);
        this[_updateIce_1](configuration_1, mediaConstraints_2);
        return;
      }
      if (configuration != null) {
        let configuration_1 = html_common.convertDartToNative_Dictionary(configuration);
        this[_updateIce_2](configuration_1);
        return;
      }
      this[_updateIce_3]();
      return;
    }
    [_updateIce_1](configuration, mediaConstraints) {
      return this.updateIce(configuration, mediaConstraints);
    }
    [_updateIce_2](configuration) {
      return this.updateIce(configuration);
    }
    [_updateIce_3]() {
      return this.updateIce();
    }
    get [dartx.onAddStream]() {
      return html$.RtcPeerConnection.addStreamEvent.forTarget(this);
    }
    get [dartx.onDataChannel]() {
      return html$.RtcPeerConnection.dataChannelEvent.forTarget(this);
    }
    get [dartx.onIceCandidate]() {
      return html$.RtcPeerConnection.iceCandidateEvent.forTarget(this);
    }
    get [dartx.onIceConnectionStateChange]() {
      return html$.RtcPeerConnection.iceConnectionStateChangeEvent.forTarget(this);
    }
    get [dartx.onNegotiationNeeded]() {
      return html$.RtcPeerConnection.negotiationNeededEvent.forTarget(this);
    }
    get [dartx.onRemoveStream]() {
      return html$.RtcPeerConnection.removeStreamEvent.forTarget(this);
    }
    get [dartx.onSignalingStateChange]() {
      return html$.RtcPeerConnection.signalingStateChangeEvent.forTarget(this);
    }
  };
  dart.setSignature(html$.RtcPeerConnection, {
    constructors: () => ({
      new: dart.definiteFunctionType(html$.RtcPeerConnection, [core.Map], [core.Map]),
      _: dart.definiteFunctionType(html$.RtcPeerConnection, [])
    }),
    methods: () => ({
      [dartx.createOffer]: dart.definiteFunctionType(async.Future$(html$.RtcSessionDescription), [], [core.Map]),
      [dartx.createAnswer]: dart.definiteFunctionType(async.Future$(html$.RtcSessionDescription), [], [core.Map]),
      [dartx.getStats]: dart.definiteFunctionType(async.Future$(html$.RtcStatsResponse), [html$.MediaStreamTrack]),
      [dartx.addIceCandidate]: dart.definiteFunctionType(dart.void, [html$.RtcIceCandidate, html$.VoidCallback, html$._RtcErrorCallback]),
      [dartx.addStream]: dart.definiteFunctionType(dart.void, [html$.MediaStream], [core.Map]),
      [_addStream_1]: dart.definiteFunctionType(dart.void, [html$.MediaStream, dart.dynamic]),
      [_addStream_2]: dart.definiteFunctionType(dart.void, [html$.MediaStream]),
      [dartx.close]: dart.definiteFunctionType(dart.void, []),
      [_createAnswer]: dart.definiteFunctionType(dart.void, [html$._RtcSessionDescriptionCallback], [html$._RtcErrorCallback, core.Map]),
      [_createAnswer_1]: dart.definiteFunctionType(dart.void, [html$._RtcSessionDescriptionCallback, html$._RtcErrorCallback, dart.dynamic]),
      [_createAnswer_2]: dart.definiteFunctionType(dart.void, [html$._RtcSessionDescriptionCallback, html$._RtcErrorCallback]),
      [dartx.createDtmfSender]: dart.definiteFunctionType(html$.RtcDtmfSender, [html$.MediaStreamTrack]),
      [dartx.createDataChannel]: dart.definiteFunctionType(html$.RtcDataChannel, [core.String], [core.Map]),
      [_createDataChannel_1]: dart.definiteFunctionType(html$.RtcDataChannel, [dart.dynamic, dart.dynamic]),
      [_createDataChannel_2]: dart.definiteFunctionType(html$.RtcDataChannel, [dart.dynamic]),
      [_createOffer]: dart.definiteFunctionType(dart.void, [html$._RtcSessionDescriptionCallback], [html$._RtcErrorCallback, core.Map]),
      [_createOffer_1]: dart.definiteFunctionType(dart.void, [html$._RtcSessionDescriptionCallback, html$._RtcErrorCallback, dart.dynamic]),
      [_createOffer_2]: dart.definiteFunctionType(dart.void, [html$._RtcSessionDescriptionCallback, html$._RtcErrorCallback]),
      [dartx.getLocalStreams]: dart.definiteFunctionType(core.List$(html$.MediaStream), []),
      [dartx.getRemoteStreams]: dart.definiteFunctionType(core.List$(html$.MediaStream), []),
      [_getStats]: dart.definiteFunctionType(dart.void, [html$.RtcStatsCallback, html$.MediaStreamTrack]),
      [dartx.getStreamById]: dart.definiteFunctionType(html$.MediaStream, [core.String]),
      [dartx.removeStream]: dart.definiteFunctionType(dart.void, [html$.MediaStream]),
      [_setLocalDescription]: dart.definiteFunctionType(dart.void, [html$.RtcSessionDescription], [html$.VoidCallback, html$._RtcErrorCallback]),
      [dartx.setLocalDescription]: dart.definiteFunctionType(async.Future, [html$.RtcSessionDescription]),
      [_setRemoteDescription]: dart.definiteFunctionType(dart.void, [html$.RtcSessionDescription], [html$.VoidCallback, html$._RtcErrorCallback]),
      [dartx.setRemoteDescription]: dart.definiteFunctionType(async.Future, [html$.RtcSessionDescription]),
      [dartx.updateIce]: dart.definiteFunctionType(dart.void, [], [core.Map, core.Map]),
      [_updateIce_1]: dart.definiteFunctionType(dart.void, [dart.dynamic, dart.dynamic]),
      [_updateIce_2]: dart.definiteFunctionType(dart.void, [dart.dynamic]),
      [_updateIce_3]: dart.definiteFunctionType(dart.void, [])
    })
  });
  dart.defineLazy(html$.RtcPeerConnection, {
    get addStreamEvent() {
      return dart.const(new (EventStreamProviderOfMediaStreamEvent())('addstream'));
    },
    get dataChannelEvent() {
      return dart.const(new (EventStreamProviderOfRtcDataChannelEvent())('datachannel'));
    },
    get iceCandidateEvent() {
      return dart.const(new (EventStreamProviderOfRtcIceCandidateEvent())('icecandidate'));
    },
    get iceConnectionStateChangeEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('iceconnectionstatechange'));
    },
    get negotiationNeededEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('negotiationneeded'));
    },
    get removeStreamEvent() {
      return dart.const(new (EventStreamProviderOfMediaStreamEvent())('removestream'));
    },
    get signalingStateChangeEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('signalingstatechange'));
    }
  });
  dart.registerExtension(dart.global.RTCPeerConnection, html$.RtcPeerConnection);
  dart.defineExtensionNames([
    'sdp',
    'type'
  ]);
  html$.RtcSessionDescription = class RtcSessionDescription extends _interceptors.Interceptor {
    static new(dictionary) {
      let constructorName = window[dart.test(html_common.Device.isFirefox) ? dart.str`${html_common.Device.propertyPrefix}RTCSessionDescription` : 'RTCSessionDescription'];
      return new constructorName(html_common.convertDartToNative_SerializedScriptValue(dictionary));
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.sdp]() {
      return this.sdp;
    }
    set [dartx.sdp](value) {
      this.sdp = value;
    }
    get [dartx.type]() {
      return this.type;
    }
    set [dartx.type](value) {
      this.type = value;
    }
  };
  dart.setSignature(html$.RtcSessionDescription, {
    constructors: () => ({
      new: dart.definiteFunctionType(html$.RtcSessionDescription, [core.Map]),
      _: dart.definiteFunctionType(html$.RtcSessionDescription, [])
    })
  });
  dart.registerExtension(dart.global.RTCSessionDescription, html$.RtcSessionDescription);
  const _get_timestamp = Symbol('_get_timestamp');
  dart.defineExtensionNames([
    'timestamp',
    'names',
    'stat',
    'id',
    'type'
  ]);
  html$.RtcStatsReport = class RtcStatsReport extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.id]() {
      return this.id;
    }
    get [dartx.timestamp]() {
      return html_common.convertNativeToDart_DateTime(this[_get_timestamp]);
    }
    get [_get_timestamp]() {
      return this.timestamp;
    }
    get [dartx.type]() {
      return this.type;
    }
    [dartx.names]() {
      return this.names();
    }
    [dartx.stat](name) {
      return this.stat(name);
    }
  };
  dart.setSignature(html$.RtcStatsReport, {
    constructors: () => ({_: dart.definiteFunctionType(html$.RtcStatsReport, [])}),
    methods: () => ({
      [dartx.names]: dart.definiteFunctionType(core.List$(core.String), []),
      [dartx.stat]: dart.definiteFunctionType(core.String, [core.String])
    })
  });
  dart.registerExtension(dart.global.RTCStatsReport, html$.RtcStatsReport);
  dart.defineExtensionNames([
    'namedItem',
    'result'
  ]);
  html$.RtcStatsResponse = class RtcStatsResponse extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [dartx.namedItem](name) {
      return this.namedItem(name);
    }
    [dartx.result]() {
      return this.result();
    }
  };
  dart.setSignature(html$.RtcStatsResponse, {
    constructors: () => ({_: dart.definiteFunctionType(html$.RtcStatsResponse, [])}),
    methods: () => ({
      [dartx.namedItem]: dart.definiteFunctionType(html$.RtcStatsReport, [core.String]),
      [dartx.result]: dart.definiteFunctionType(core.List$(html$.RtcStatsReport), [])
    })
  });
  dart.registerExtension(dart.global.RTCStatsResponse, html$.RtcStatsResponse);
  const _availLeft = Symbol('_availLeft');
  const _availTop = Symbol('_availTop');
  const _availWidth = Symbol('_availWidth');
  const _availHeight = Symbol('_availHeight');
  dart.defineExtensionNames([
    'available',
    'colorDepth',
    'height',
    'orientation',
    'pixelDepth',
    'width'
  ]);
  html$.Screen = class Screen extends _interceptors.Interceptor {
    get [dartx.available]() {
      return new (RectangleOfnum())(this[_availLeft], this[_availTop], this[_availWidth], this[_availHeight]);
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [_availHeight]() {
      return this.availHeight;
    }
    get [_availLeft]() {
      return this.availLeft;
    }
    get [_availTop]() {
      return this.availTop;
    }
    get [_availWidth]() {
      return this.availWidth;
    }
    get [dartx.colorDepth]() {
      return this.colorDepth;
    }
    get [dartx.height]() {
      return this.height;
    }
    get [dartx.orientation]() {
      return this.orientation;
    }
    get [dartx.pixelDepth]() {
      return this.pixelDepth;
    }
    get [dartx.width]() {
      return this.width;
    }
  };
  dart.setSignature(html$.Screen, {
    constructors: () => ({_: dart.definiteFunctionType(html$.Screen, [])})
  });
  dart.registerExtension(dart.global.Screen, html$.Screen);
  dart.defineExtensionNames([
    'lock',
    'unlock',
    'onChange',
    'angle',
    'type'
  ]);
  html$.ScreenOrientation = class ScreenOrientation extends html$.EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.angle]() {
      return this.angle;
    }
    get [dartx.type]() {
      return this.type;
    }
    [dartx.lock](orientation) {
      return this.lock(orientation);
    }
    [dartx.unlock]() {
      return this.unlock();
    }
    get [dartx.onChange]() {
      return html$.ScreenOrientation.changeEvent.forTarget(this);
    }
  };
  dart.setSignature(html$.ScreenOrientation, {
    constructors: () => ({_: dart.definiteFunctionType(html$.ScreenOrientation, [])}),
    methods: () => ({
      [dartx.lock]: dart.definiteFunctionType(async.Future, [core.String]),
      [dartx.unlock]: dart.definiteFunctionType(dart.void, [])
    })
  });
  dart.defineLazy(html$.ScreenOrientation, {
    get changeEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('change'));
    }
  });
  dart.registerExtension(dart.global.ScreenOrientation, html$.ScreenOrientation);
  dart.defineExtensionNames([
    'async',
    'charset',
    'crossOrigin',
    'defer',
    'integrity',
    'nonce',
    'src',
    'type'
  ]);
  html$.ScriptElement = class ScriptElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return html$.ScriptElement._check(html$.document[dartx.createElement]("script"));
    }
    created() {
      this[dartx.async] = null;
      this[dartx.charset] = null;
      this[dartx.crossOrigin] = null;
      this[dartx.defer] = null;
      this[dartx.integrity] = null;
      this[dartx.nonce] = null;
      this[dartx.src] = null;
      this[dartx.type] = null;
      super.created();
    }
    get [dartx.async]() {
      return this.async;
    }
    set [dartx.async](value) {
      this.async = value;
    }
    get [dartx.charset]() {
      return this.charset;
    }
    set [dartx.charset](value) {
      this.charset = value;
    }
    get [dartx.crossOrigin]() {
      return this.crossOrigin;
    }
    set [dartx.crossOrigin](value) {
      this.crossOrigin = value;
    }
    get [dartx.defer]() {
      return this.defer;
    }
    set [dartx.defer](value) {
      this.defer = value;
    }
    get [dartx.integrity]() {
      return this.integrity;
    }
    set [dartx.integrity](value) {
      this.integrity = value;
    }
    get [dartx.nonce]() {
      return this.nonce;
    }
    set [dartx.nonce](value) {
      this.nonce = value;
    }
    get [dartx.src]() {
      return this.src;
    }
    set [dartx.src](value) {
      this.src = value;
    }
    get [dartx.type]() {
      return this.type;
    }
    set [dartx.type](value) {
      this.type = value;
    }
  };
  dart.defineNamedConstructor(html$.ScriptElement, 'created');
  dart.setSignature(html$.ScriptElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.ScriptElement, []),
      new: dart.definiteFunctionType(html$.ScriptElement, []),
      created: dart.definiteFunctionType(html$.ScriptElement, [])
    })
  });
  dart.registerExtension(dart.global.HTMLScriptElement, html$.ScriptElement);
  dart.defineExtensionNames([
    'consumeDelta',
    'deltaGranularity',
    'deltaX',
    'deltaY',
    'fromUserInput',
    'inInertialPhase',
    'isBeginning',
    'isEnding',
    'shouldPropagate',
    'velocityX',
    'velocityY'
  ]);
  html$.ScrollState = class ScrollState extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(deltaX, deltaY, deltaGranularity, velocityX, velocityY, inInertialPhase, isBeginning, isEnding) {
      if (deltaX === void 0) deltaX = null;
      if (deltaY === void 0) deltaY = null;
      if (deltaGranularity === void 0) deltaGranularity = null;
      if (velocityX === void 0) velocityX = null;
      if (velocityY === void 0) velocityY = null;
      if (inInertialPhase === void 0) inInertialPhase = null;
      if (isBeginning === void 0) isBeginning = null;
      if (isEnding === void 0) isEnding = null;
      if (isEnding != null) {
        return html$.ScrollState._create_1(deltaX, deltaY, deltaGranularity, velocityX, velocityY, inInertialPhase, isBeginning, isEnding);
      }
      if (isBeginning != null) {
        return html$.ScrollState._create_2(deltaX, deltaY, deltaGranularity, velocityX, velocityY, inInertialPhase, isBeginning);
      }
      if (inInertialPhase != null) {
        return html$.ScrollState._create_3(deltaX, deltaY, deltaGranularity, velocityX, velocityY, inInertialPhase);
      }
      if (velocityY != null) {
        return html$.ScrollState._create_4(deltaX, deltaY, deltaGranularity, velocityX, velocityY);
      }
      if (velocityX != null) {
        return html$.ScrollState._create_5(deltaX, deltaY, deltaGranularity, velocityX);
      }
      if (deltaGranularity != null) {
        return html$.ScrollState._create_6(deltaX, deltaY, deltaGranularity);
      }
      if (deltaY != null) {
        return html$.ScrollState._create_7(deltaX, deltaY);
      }
      if (deltaX != null) {
        return html$.ScrollState._create_8(deltaX);
      }
      return html$.ScrollState._create_9();
    }
    static _create_1(deltaX, deltaY, deltaGranularity, velocityX, velocityY, inInertialPhase, isBeginning, isEnding) {
      return new ScrollState(deltaX, deltaY, deltaGranularity, velocityX, velocityY, inInertialPhase, isBeginning, isEnding);
    }
    static _create_2(deltaX, deltaY, deltaGranularity, velocityX, velocityY, inInertialPhase, isBeginning) {
      return new ScrollState(deltaX, deltaY, deltaGranularity, velocityX, velocityY, inInertialPhase, isBeginning);
    }
    static _create_3(deltaX, deltaY, deltaGranularity, velocityX, velocityY, inInertialPhase) {
      return new ScrollState(deltaX, deltaY, deltaGranularity, velocityX, velocityY, inInertialPhase);
    }
    static _create_4(deltaX, deltaY, deltaGranularity, velocityX, velocityY) {
      return new ScrollState(deltaX, deltaY, deltaGranularity, velocityX, velocityY);
    }
    static _create_5(deltaX, deltaY, deltaGranularity, velocityX) {
      return new ScrollState(deltaX, deltaY, deltaGranularity, velocityX);
    }
    static _create_6(deltaX, deltaY, deltaGranularity) {
      return new ScrollState(deltaX, deltaY, deltaGranularity);
    }
    static _create_7(deltaX, deltaY) {
      return new ScrollState(deltaX, deltaY);
    }
    static _create_8(deltaX) {
      return new ScrollState(deltaX);
    }
    static _create_9() {
      return new ScrollState();
    }
    get [dartx.deltaGranularity]() {
      return this.deltaGranularity;
    }
    get [dartx.deltaX]() {
      return this.deltaX;
    }
    get [dartx.deltaY]() {
      return this.deltaY;
    }
    get [dartx.fromUserInput]() {
      return this.fromUserInput;
    }
    get [dartx.inInertialPhase]() {
      return this.inInertialPhase;
    }
    get [dartx.isBeginning]() {
      return this.isBeginning;
    }
    get [dartx.isEnding]() {
      return this.isEnding;
    }
    get [dartx.shouldPropagate]() {
      return this.shouldPropagate;
    }
    get [dartx.velocityX]() {
      return this.velocityX;
    }
    get [dartx.velocityY]() {
      return this.velocityY;
    }
    [dartx.consumeDelta](x, y) {
      return this.consumeDelta(x, y);
    }
  };
  dart.setSignature(html$.ScrollState, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.ScrollState, []),
      new: dart.definiteFunctionType(html$.ScrollState, [], [core.num, core.num, core.num, core.num, core.num, core.bool, core.bool, core.bool])
    }),
    methods: () => ({[dartx.consumeDelta]: dart.definiteFunctionType(dart.void, [core.num, core.num])}),
    statics: () => ({
      _create_1: dart.definiteFunctionType(html$.ScrollState, [dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic]),
      _create_2: dart.definiteFunctionType(html$.ScrollState, [dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic]),
      _create_3: dart.definiteFunctionType(html$.ScrollState, [dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic]),
      _create_4: dart.definiteFunctionType(html$.ScrollState, [dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic]),
      _create_5: dart.definiteFunctionType(html$.ScrollState, [dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic]),
      _create_6: dart.definiteFunctionType(html$.ScrollState, [dart.dynamic, dart.dynamic, dart.dynamic]),
      _create_7: dart.definiteFunctionType(html$.ScrollState, [dart.dynamic, dart.dynamic]),
      _create_8: dart.definiteFunctionType(html$.ScrollState, [dart.dynamic]),
      _create_9: dart.definiteFunctionType(html$.ScrollState, [])
    }),
    names: ['_create_1', '_create_2', '_create_3', '_create_4', '_create_5', '_create_6', '_create_7', '_create_8', '_create_9']
  });
  dart.registerExtension(dart.global.ScrollState, html$.ScrollState);
  dart.defineExtensionNames([
    'blockedUri',
    'columnNumber',
    'documentUri',
    'effectiveDirective',
    'lineNumber',
    'originalPolicy',
    'referrer',
    'sourceFile',
    'statusCode',
    'violatedDirective'
  ]);
  html$.SecurityPolicyViolationEvent = class SecurityPolicyViolationEvent extends html$.Event {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(type, eventInitDict) {
      if (eventInitDict === void 0) eventInitDict = null;
      if (eventInitDict != null) {
        let eventInitDict_1 = html_common.convertDartToNative_Dictionary(eventInitDict);
        return html$.SecurityPolicyViolationEvent._create_1(type, eventInitDict_1);
      }
      return html$.SecurityPolicyViolationEvent._create_2(type);
    }
    static _create_1(type, eventInitDict) {
      return new SecurityPolicyViolationEvent(type, eventInitDict);
    }
    static _create_2(type) {
      return new SecurityPolicyViolationEvent(type);
    }
    get [dartx.blockedUri]() {
      return this.blockedURI;
    }
    get [dartx.columnNumber]() {
      return this.columnNumber;
    }
    get [dartx.documentUri]() {
      return this.documentURI;
    }
    get [dartx.effectiveDirective]() {
      return this.effectiveDirective;
    }
    get [dartx.lineNumber]() {
      return this.lineNumber;
    }
    get [dartx.originalPolicy]() {
      return this.originalPolicy;
    }
    get [dartx.referrer]() {
      return this.referrer;
    }
    get [dartx.sourceFile]() {
      return this.sourceFile;
    }
    get [dartx.statusCode]() {
      return this.statusCode;
    }
    get [dartx.violatedDirective]() {
      return this.violatedDirective;
    }
  };
  dart.setSignature(html$.SecurityPolicyViolationEvent, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.SecurityPolicyViolationEvent, []),
      new: dart.definiteFunctionType(html$.SecurityPolicyViolationEvent, [core.String], [core.Map])
    }),
    statics: () => ({
      _create_1: dart.definiteFunctionType(html$.SecurityPolicyViolationEvent, [dart.dynamic, dart.dynamic]),
      _create_2: dart.definiteFunctionType(html$.SecurityPolicyViolationEvent, [dart.dynamic])
    }),
    names: ['_create_1', '_create_2']
  });
  dart.registerExtension(dart.global.SecurityPolicyViolationEvent, html$.SecurityPolicyViolationEvent);
  dart.defineExtensionNames([
    'add',
    'checkValidity',
    'item',
    'namedItem',
    'reportValidity',
    'setCustomValidity',
    'options',
    'selectedOptions',
    'autofocus',
    'disabled',
    'form',
    'labels',
    'length',
    'multiple',
    'name',
    'required',
    'selectedIndex',
    'size',
    'type',
    'validationMessage',
    'validity',
    'value',
    'willValidate'
  ]);
  html$.SelectElement = class SelectElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return html$.SelectElement._check(html$.document[dartx.createElement]("select"));
    }
    created() {
      this[dartx.autofocus] = null;
      this[dartx.disabled] = null;
      this[dartx.form] = null;
      this[dartx.labels] = null;
      this[dartx.length] = null;
      this[dartx.multiple] = null;
      this[dartx.name] = null;
      this[dartx.required] = null;
      this[dartx.selectedIndex] = null;
      this[dartx.size] = null;
      this[dartx.type] = null;
      this[dartx.validationMessage] = null;
      this[dartx.validity] = null;
      this[dartx.value] = null;
      this[dartx.willValidate] = null;
      super.created();
    }
    get [dartx.autofocus]() {
      return this.autofocus;
    }
    set [dartx.autofocus](value) {
      this.autofocus = value;
    }
    get [dartx.disabled]() {
      return this.disabled;
    }
    set [dartx.disabled](value) {
      this.disabled = value;
    }
    get [dartx.form]() {
      return this.form;
    }
    get [dartx.labels]() {
      return this.labels;
    }
    get [dartx.length]() {
      return this.length;
    }
    set [dartx.length](value) {
      this.length = value;
    }
    get [dartx.multiple]() {
      return this.multiple;
    }
    set [dartx.multiple](value) {
      this.multiple = value;
    }
    get [dartx.name]() {
      return this.name;
    }
    set [dartx.name](value) {
      this.name = value;
    }
    get [dartx.required]() {
      return this.required;
    }
    set [dartx.required](value) {
      this.required = value;
    }
    get [dartx.selectedIndex]() {
      return this.selectedIndex;
    }
    set [dartx.selectedIndex](value) {
      this.selectedIndex = value;
    }
    get [dartx.size]() {
      return this.size;
    }
    set [dartx.size](value) {
      this.size = value;
    }
    get [dartx.type]() {
      return this.type;
    }
    get [dartx.validationMessage]() {
      return this.validationMessage;
    }
    get [dartx.validity]() {
      return this.validity;
    }
    get [dartx.value]() {
      return this.value;
    }
    set [dartx.value](value) {
      this.value = value;
    }
    get [dartx.willValidate]() {
      return this.willValidate;
    }
    [__setter__](index, option) {
      return this.__setter__(index, option);
    }
    [dartx.add](element, before) {
      return this.add(element, before);
    }
    [dartx.checkValidity]() {
      return this.checkValidity();
    }
    [dartx.item](index) {
      return this.item(index);
    }
    [dartx.namedItem](name) {
      return this.namedItem(name);
    }
    [dartx.reportValidity]() {
      return this.reportValidity();
    }
    [dartx.setCustomValidity](error) {
      return this.setCustomValidity(error);
    }
    get [dartx.options]() {
      let options = ListOfOptionElement().from(this[dartx.querySelectorAll](html$.Element)('option'));
      return new (UnmodifiableListViewOfOptionElement())(options);
    }
    get [dartx.selectedOptions]() {
      if (dart.test(this[dartx.multiple])) {
        let options = this[dartx.options][dartx.where](dart.fn(o => o[dartx.selected], OptionElementTobool()))[dartx.toList]();
        return new (UnmodifiableListViewOfOptionElement())(options);
      } else {
        return JSArrayOfOptionElement().of([this[dartx.options][dartx.get](this[dartx.selectedIndex])]);
      }
    }
  };
  dart.defineNamedConstructor(html$.SelectElement, 'created');
  dart.setSignature(html$.SelectElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.SelectElement, []),
      new: dart.definiteFunctionType(html$.SelectElement, []),
      created: dart.definiteFunctionType(html$.SelectElement, [])
    }),
    methods: () => ({
      [__setter__]: dart.definiteFunctionType(dart.void, [core.int, html$.OptionElement]),
      [dartx.add]: dart.definiteFunctionType(dart.void, [core.Object, core.Object]),
      [dartx.checkValidity]: dart.definiteFunctionType(core.bool, []),
      [dartx.item]: dart.definiteFunctionType(html$.Element, [core.int]),
      [dartx.namedItem]: dart.definiteFunctionType(html$.OptionElement, [core.String]),
      [dartx.reportValidity]: dart.definiteFunctionType(core.bool, []),
      [dartx.setCustomValidity]: dart.definiteFunctionType(dart.void, [core.String])
    })
  });
  dart.registerExtension(dart.global.HTMLSelectElement, html$.SelectElement);
  dart.defineExtensionNames([
    'addRange',
    'collapse',
    'collapseToEnd',
    'collapseToStart',
    'containsNode',
    'deleteFromDocument',
    'empty',
    'extend',
    'getRangeAt',
    'modify',
    'removeAllRanges',
    'selectAllChildren',
    'setBaseAndExtent',
    'setPosition',
    'anchorNode',
    'anchorOffset',
    'baseNode',
    'baseOffset',
    'extentNode',
    'extentOffset',
    'focusNode',
    'focusOffset',
    'isCollapsed',
    'rangeCount',
    'type'
  ]);
  html$.Selection = class Selection extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.anchorNode]() {
      return this.anchorNode;
    }
    get [dartx.anchorOffset]() {
      return this.anchorOffset;
    }
    get [dartx.baseNode]() {
      return this.baseNode;
    }
    get [dartx.baseOffset]() {
      return this.baseOffset;
    }
    get [dartx.extentNode]() {
      return this.extentNode;
    }
    get [dartx.extentOffset]() {
      return this.extentOffset;
    }
    get [dartx.focusNode]() {
      return this.focusNode;
    }
    get [dartx.focusOffset]() {
      return this.focusOffset;
    }
    get [dartx.isCollapsed]() {
      return this.isCollapsed;
    }
    get [dartx.rangeCount]() {
      return this.rangeCount;
    }
    get [dartx.type]() {
      return this.type;
    }
    [dartx.addRange](range) {
      return this.addRange(range);
    }
    [dartx.collapse](node, offset) {
      return this.collapse(node, offset);
    }
    [dartx.collapseToEnd]() {
      return this.collapseToEnd();
    }
    [dartx.collapseToStart]() {
      return this.collapseToStart();
    }
    [dartx.containsNode](node, allowPartialContainment) {
      return this.containsNode(node, allowPartialContainment);
    }
    [dartx.deleteFromDocument]() {
      return this.deleteFromDocument();
    }
    [dartx.empty]() {
      return this.empty();
    }
    [dartx.extend](node, offset) {
      return this.extend(node, offset);
    }
    [dartx.getRangeAt](index) {
      return this.getRangeAt(index);
    }
    [dartx.modify](alter, direction, granularity) {
      return this.modify(alter, direction, granularity);
    }
    [dartx.removeAllRanges]() {
      return this.removeAllRanges();
    }
    [dartx.selectAllChildren](node) {
      return this.selectAllChildren(node);
    }
    [dartx.setBaseAndExtent](baseNode, baseOffset, extentNode, extentOffset) {
      return this.setBaseAndExtent(baseNode, baseOffset, extentNode, extentOffset);
    }
    [dartx.setPosition](node, offset) {
      return this.setPosition(node, offset);
    }
  };
  dart.setSignature(html$.Selection, {
    constructors: () => ({_: dart.definiteFunctionType(html$.Selection, [])}),
    methods: () => ({
      [dartx.addRange]: dart.definiteFunctionType(dart.void, [html$.Range]),
      [dartx.collapse]: dart.definiteFunctionType(dart.void, [html$.Node], [core.int]),
      [dartx.collapseToEnd]: dart.definiteFunctionType(dart.void, []),
      [dartx.collapseToStart]: dart.definiteFunctionType(dart.void, []),
      [dartx.containsNode]: dart.definiteFunctionType(core.bool, [html$.Node, core.bool]),
      [dartx.deleteFromDocument]: dart.definiteFunctionType(dart.void, []),
      [dartx.empty]: dart.definiteFunctionType(dart.void, []),
      [dartx.extend]: dart.definiteFunctionType(dart.void, [html$.Node], [core.int]),
      [dartx.getRangeAt]: dart.definiteFunctionType(html$.Range, [core.int]),
      [dartx.modify]: dart.definiteFunctionType(dart.void, [core.String, core.String, core.String]),
      [dartx.removeAllRanges]: dart.definiteFunctionType(dart.void, []),
      [dartx.selectAllChildren]: dart.definiteFunctionType(dart.void, [html$.Node]),
      [dartx.setBaseAndExtent]: dart.definiteFunctionType(dart.void, [html$.Node, core.int, html$.Node, core.int]),
      [dartx.setPosition]: dart.definiteFunctionType(dart.void, [html$.Node], [core.int])
    })
  });
  dart.registerExtension(dart.global.Selection, html$.Selection);
  dart.defineExtensionNames([
    'close',
    'postMessage',
    'data',
    'name',
    'targetUrl'
  ]);
  html$.ServicePort = class ServicePort extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.data]() {
      return this.data;
    }
    get [dartx.name]() {
      return this.name;
    }
    get [dartx.targetUrl]() {
      return this.targetURL;
    }
    [dartx.close]() {
      return this.close();
    }
    [dartx.postMessage](message, transfer) {
      if (transfer === void 0) transfer = null;
      if (transfer != null) {
        let message_1 = html_common.convertDartToNative_SerializedScriptValue(message);
        this[_postMessage_1](message_1, transfer);
        return;
      }
      let message_1 = html_common.convertDartToNative_SerializedScriptValue(message);
      this[_postMessage_2](message_1);
      return;
    }
    [_postMessage_1](message, transfer) {
      return this.postMessage(message, transfer);
    }
    [_postMessage_2](message) {
      return this.postMessage(message);
    }
  };
  dart.setSignature(html$.ServicePort, {
    constructors: () => ({_: dart.definiteFunctionType(html$.ServicePort, [])}),
    methods: () => ({
      [dartx.close]: dart.definiteFunctionType(dart.void, []),
      [dartx.postMessage]: dart.definiteFunctionType(dart.void, [dart.dynamic], [core.List$(html$.MessagePort)]),
      [_postMessage_1]: dart.definiteFunctionType(dart.void, [dart.dynamic, core.List$(html$.MessagePort)]),
      [_postMessage_2]: dart.definiteFunctionType(dart.void, [dart.dynamic])
    })
  });
  dart.registerExtension(dart.global.ServicePort, html$.ServicePort);
  const _connect_1 = Symbol('_connect_1');
  const _connect_2 = Symbol('_connect_2');
  dart.defineExtensionNames([
    'connect',
    'match',
    'matchAll',
    'onMessage'
  ]);
  html$.ServicePortCollection = class ServicePortCollection extends html$.EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [dartx.connect](url, options) {
      if (options === void 0) options = null;
      if (options != null) {
        let options_1 = html_common.convertDartToNative_Dictionary(options);
        return this[_connect_1](url, options_1);
      }
      return this[_connect_2](url);
    }
    [_connect_1](url, options) {
      return this.connect(url, options);
    }
    [_connect_2](url) {
      return this.connect(url);
    }
    [dartx.match](options) {
      let options_1 = html_common.convertDartToNative_Dictionary(options);
      return this[_match_1](options_1);
    }
    [_match_1](options) {
      return this.match(options);
    }
    [dartx.matchAll](options) {
      if (options === void 0) options = null;
      if (options != null) {
        let options_1 = html_common.convertDartToNative_Dictionary(options);
        return this[_matchAll_1](options_1);
      }
      return this[_matchAll_2]();
    }
    [_matchAll_1](options) {
      return this.matchAll(options);
    }
    [_matchAll_2]() {
      return this.matchAll();
    }
    get [dartx.onMessage]() {
      return html$.ServicePortCollection.messageEvent.forTarget(this);
    }
  };
  dart.setSignature(html$.ServicePortCollection, {
    constructors: () => ({_: dart.definiteFunctionType(html$.ServicePortCollection, [])}),
    methods: () => ({
      [dartx.connect]: dart.definiteFunctionType(async.Future, [core.String], [core.Map]),
      [_connect_1]: dart.definiteFunctionType(async.Future, [dart.dynamic, dart.dynamic]),
      [_connect_2]: dart.definiteFunctionType(async.Future, [dart.dynamic]),
      [dartx.match]: dart.definiteFunctionType(async.Future, [core.Map]),
      [_match_1]: dart.definiteFunctionType(async.Future, [dart.dynamic]),
      [dartx.matchAll]: dart.definiteFunctionType(async.Future, [], [core.Map]),
      [_matchAll_1]: dart.definiteFunctionType(async.Future, [dart.dynamic]),
      [_matchAll_2]: dart.definiteFunctionType(async.Future, [])
    })
  });
  dart.defineLazy(html$.ServicePortCollection, {
    get messageEvent() {
      return dart.const(new (EventStreamProviderOfMessageEvent())('message'));
    }
  });
  dart.registerExtension(dart.global.ServicePortCollection, html$.ServicePortCollection);
  dart.defineExtensionNames([
    'respondWith',
    'origin',
    'targetUrl'
  ]);
  html$.ServicePortConnectEvent = class ServicePortConnectEvent extends html$.ExtendableEvent {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(type, eventInitDict) {
      if (eventInitDict === void 0) eventInitDict = null;
      if (eventInitDict != null) {
        let eventInitDict_1 = html_common.convertDartToNative_Dictionary(eventInitDict);
        return html$.ServicePortConnectEvent._create_1(type, eventInitDict_1);
      }
      return html$.ServicePortConnectEvent._create_2(type);
    }
    static _create_1(type, eventInitDict) {
      return new ServicePortConnectEvent(type, eventInitDict);
    }
    static _create_2(type) {
      return new ServicePortConnectEvent(type);
    }
    get [dartx.origin]() {
      return this.origin;
    }
    get [dartx.targetUrl]() {
      return this.targetURL;
    }
    [dartx.respondWith](response) {
      return this.respondWith(response);
    }
  };
  dart.setSignature(html$.ServicePortConnectEvent, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.ServicePortConnectEvent, []),
      new: dart.definiteFunctionType(html$.ServicePortConnectEvent, [core.String], [core.Map])
    }),
    methods: () => ({[dartx.respondWith]: dart.definiteFunctionType(async.Future, [async.Future])}),
    statics: () => ({
      _create_1: dart.definiteFunctionType(html$.ServicePortConnectEvent, [dart.dynamic, dart.dynamic]),
      _create_2: dart.definiteFunctionType(html$.ServicePortConnectEvent, [dart.dynamic])
    }),
    names: ['_create_1', '_create_2']
  });
  dart.registerExtension(dart.global.ServicePortConnectEvent, html$.ServicePortConnectEvent);
  dart.defineExtensionNames([
    'getRegistration',
    'getRegistrations',
    'register',
    'onMessage',
    'controller',
    'ready'
  ]);
  html$.ServiceWorkerContainer = class ServiceWorkerContainer extends html$.EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.controller]() {
      return this.controller;
    }
    get [dartx.ready]() {
      return this.ready;
    }
    [dartx.getRegistration](documentURL) {
      return this.getRegistration(documentURL);
    }
    [dartx.getRegistrations]() {
      return this.getRegistrations();
    }
    [dartx.register](url, options) {
      if (options === void 0) options = null;
      if (options != null) {
        let options_1 = html_common.convertDartToNative_Dictionary(options);
        return this[_register_1](url, options_1);
      }
      return this[_register_2](url);
    }
    [_register_1](url, options) {
      return this.register(url, options);
    }
    [_register_2](url) {
      return this.register(url);
    }
    get [dartx.onMessage]() {
      return html$.ServiceWorkerContainer.messageEvent.forTarget(this);
    }
  };
  dart.setSignature(html$.ServiceWorkerContainer, {
    constructors: () => ({_: dart.definiteFunctionType(html$.ServiceWorkerContainer, [])}),
    methods: () => ({
      [dartx.getRegistration]: dart.definiteFunctionType(async.Future, [], [core.String]),
      [dartx.getRegistrations]: dart.definiteFunctionType(async.Future, []),
      [dartx.register]: dart.definiteFunctionType(async.Future, [core.String], [core.Map]),
      [_register_1]: dart.definiteFunctionType(async.Future, [dart.dynamic, dart.dynamic]),
      [_register_2]: dart.definiteFunctionType(async.Future, [dart.dynamic])
    })
  });
  dart.defineLazy(html$.ServiceWorkerContainer, {
    get messageEvent() {
      return dart.const(new (EventStreamProviderOfMessageEvent())('message'));
    }
  });
  dart.registerExtension(dart.global.ServiceWorkerContainer, html$.ServiceWorkerContainer);
  dart.defineExtensionNames([
    'skipWaiting',
    'onMessage',
    'clients',
    'ports',
    'registration'
  ]);
  html$.ServiceWorkerGlobalScope = class ServiceWorkerGlobalScope extends html$.WorkerGlobalScope {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.clients]() {
      return this.clients;
    }
    get [dartx.ports]() {
      return this.ports;
    }
    get [dartx.registration]() {
      return this.registration;
    }
    [dartx.skipWaiting]() {
      return this.skipWaiting();
    }
    get [dartx.onMessage]() {
      return html$.ServiceWorkerGlobalScope.messageEvent.forTarget(this);
    }
  };
  dart.setSignature(html$.ServiceWorkerGlobalScope, {
    constructors: () => ({_: dart.definiteFunctionType(html$.ServiceWorkerGlobalScope, [])}),
    methods: () => ({[dartx.skipWaiting]: dart.definiteFunctionType(async.Future, [])})
  });
  dart.defineLazy(html$.ServiceWorkerGlobalScope, {
    get messageEvent() {
      return dart.const(new (EventStreamProviderOfMessageEvent())('message'));
    }
  });
  dart.registerExtension(dart.global.ServiceWorkerGlobalScope, html$.ServiceWorkerGlobalScope);
  dart.defineExtensionNames([
    'data',
    'lastEventId',
    'origin',
    'ports',
    'source'
  ]);
  html$.ServiceWorkerMessageEvent = class ServiceWorkerMessageEvent extends html$.Event {
    get [dartx.data]() {
      return html_common.convertNativeToDart_SerializedScriptValue(this[_get_data]);
    }
    get [_get_data]() {
      return this.data;
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(type, eventInitDict) {
      if (eventInitDict === void 0) eventInitDict = null;
      if (eventInitDict != null) {
        let eventInitDict_1 = html_common.convertDartToNative_Dictionary(eventInitDict);
        return html$.ServiceWorkerMessageEvent._create_1(type, eventInitDict_1);
      }
      return html$.ServiceWorkerMessageEvent._create_2(type);
    }
    static _create_1(type, eventInitDict) {
      return new ServiceWorkerMessageEvent(type, eventInitDict);
    }
    static _create_2(type) {
      return new ServiceWorkerMessageEvent(type);
    }
    get [dartx.lastEventId]() {
      return this.lastEventId;
    }
    get [dartx.origin]() {
      return this.origin;
    }
    get [dartx.ports]() {
      return this.ports;
    }
    get [dartx.source]() {
      return this.source;
    }
  };
  dart.setSignature(html$.ServiceWorkerMessageEvent, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.ServiceWorkerMessageEvent, []),
      new: dart.definiteFunctionType(html$.ServiceWorkerMessageEvent, [core.String], [core.Map])
    }),
    statics: () => ({
      _create_1: dart.definiteFunctionType(html$.ServiceWorkerMessageEvent, [dart.dynamic, dart.dynamic]),
      _create_2: dart.definiteFunctionType(html$.ServiceWorkerMessageEvent, [dart.dynamic])
    }),
    names: ['_create_1', '_create_2']
  });
  dart.registerExtension(dart.global.ServiceWorkerMessageEvent, html$.ServiceWorkerMessageEvent);
  const _getNotifications_1 = Symbol('_getNotifications_1');
  const _getNotifications_2 = Symbol('_getNotifications_2');
  const _showNotification_1 = Symbol('_showNotification_1');
  const _showNotification_2 = Symbol('_showNotification_2');
  dart.defineExtensionNames([
    'getNotifications',
    'showNotification',
    'unregister',
    'update',
    'active',
    'geofencing',
    'installing',
    'periodicSync',
    'pushManager',
    'scope',
    'sync',
    'waiting'
  ]);
  html$.ServiceWorkerRegistration = class ServiceWorkerRegistration extends html$.EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.active]() {
      return this.active;
    }
    get [dartx.geofencing]() {
      return this.geofencing;
    }
    get [dartx.installing]() {
      return this.installing;
    }
    get [dartx.periodicSync]() {
      return this.periodicSync;
    }
    get [dartx.pushManager]() {
      return this.pushManager;
    }
    get [dartx.scope]() {
      return this.scope;
    }
    get [dartx.sync]() {
      return this.sync;
    }
    get [dartx.waiting]() {
      return this.waiting;
    }
    [dartx.getNotifications](filter) {
      if (filter === void 0) filter = null;
      if (filter != null) {
        let filter_1 = html_common.convertDartToNative_Dictionary(filter);
        return this[_getNotifications_1](filter_1);
      }
      return this[_getNotifications_2]();
    }
    [_getNotifications_1](filter) {
      return this.getNotifications(filter);
    }
    [_getNotifications_2]() {
      return this.getNotifications();
    }
    [dartx.showNotification](title, options) {
      if (options === void 0) options = null;
      if (options != null) {
        let options_1 = html_common.convertDartToNative_Dictionary(options);
        return this[_showNotification_1](title, options_1);
      }
      return this[_showNotification_2](title);
    }
    [_showNotification_1](title, options) {
      return this.showNotification(title, options);
    }
    [_showNotification_2](title) {
      return this.showNotification(title);
    }
    [dartx.unregister]() {
      return this.unregister();
    }
    [dartx.update]() {
      return this.update();
    }
  };
  dart.setSignature(html$.ServiceWorkerRegistration, {
    constructors: () => ({_: dart.definiteFunctionType(html$.ServiceWorkerRegistration, [])}),
    methods: () => ({
      [dartx.getNotifications]: dart.definiteFunctionType(async.Future, [], [core.Map]),
      [_getNotifications_1]: dart.definiteFunctionType(async.Future, [dart.dynamic]),
      [_getNotifications_2]: dart.definiteFunctionType(async.Future, []),
      [dartx.showNotification]: dart.definiteFunctionType(async.Future, [core.String], [core.Map]),
      [_showNotification_1]: dart.definiteFunctionType(async.Future, [dart.dynamic, dart.dynamic]),
      [_showNotification_2]: dart.definiteFunctionType(async.Future, [dart.dynamic]),
      [dartx.unregister]: dart.definiteFunctionType(async.Future, []),
      [dartx.update]: dart.definiteFunctionType(dart.void, [])
    })
  });
  dart.registerExtension(dart.global.ServiceWorkerRegistration, html$.ServiceWorkerRegistration);
  dart.defineExtensionNames([
    'getDistributedNodes'
  ]);
  html$.ShadowElement = class ShadowElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return html$.ShadowElement._check(html$.document[dartx.createElement]("shadow"));
    }
    created() {
      super.created();
    }
    static get supported() {
      return html$.Element.isTagSupported('shadow');
    }
    [dartx.getDistributedNodes]() {
      return this.getDistributedNodes();
    }
  };
  dart.defineNamedConstructor(html$.ShadowElement, 'created');
  dart.setSignature(html$.ShadowElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.ShadowElement, []),
      new: dart.definiteFunctionType(html$.ShadowElement, []),
      created: dart.definiteFunctionType(html$.ShadowElement, [])
    }),
    methods: () => ({[dartx.getDistributedNodes]: dart.definiteFunctionType(core.List$(html$.Node), [])})
  });
  dart.registerExtension(dart.global.HTMLShadowElement, html$.ShadowElement);
  dart.defineExtensionNames([
    'clone',
    'elementFromPoint',
    'elementsFromPoint',
    'getSelection',
    'resetStyleInheritance',
    'resetStyleInheritance',
    'applyAuthorStyles',
    'applyAuthorStyles',
    'activeElement',
    'delegatesFocus',
    'host',
    'innerHtml',
    'olderShadowRoot',
    'styleSheets'
  ]);
  html$.ShadowRoot = class ShadowRoot extends html$.DocumentFragment {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.activeElement]() {
      return this.activeElement;
    }
    get [dartx.delegatesFocus]() {
      return this.delegatesFocus;
    }
    get [dartx.host]() {
      return this.host;
    }
    get [dartx.innerHtml]() {
      return this.innerHTML;
    }
    set [dartx.innerHtml](value) {
      this.innerHTML = value;
    }
    get [dartx.olderShadowRoot]() {
      return this.olderShadowRoot;
    }
    get [dartx.styleSheets]() {
      return this.styleSheets;
    }
    [dartx.clone](deep) {
      return this.cloneNode(deep);
    }
    [dartx.elementFromPoint](x, y) {
      return this.elementFromPoint(x, y);
    }
    [dartx.elementsFromPoint](x, y) {
      return this.elementsFromPoint(x, y);
    }
    [dartx.getSelection]() {
      return this.getSelection();
    }
    static get supported() {
      return !!(Element.prototype.createShadowRoot || Element.prototype.webkitCreateShadowRoot);
    }
    static _shadowRootDeprecationReport() {
      if (!dart.test(html$.ShadowRoot._shadowRootDeprecationReported)) {
        html$.window[dartx.console].warn('ShadowRoot.resetStyleInheritance and ShadowRoot.applyAuthorStyles now deprecated in dart:html.\nPlease remove them from your code.\n');
        html$.ShadowRoot._shadowRootDeprecationReported = true;
      }
    }
    get [dartx.resetStyleInheritance]() {
      html$.ShadowRoot._shadowRootDeprecationReport();
      return false;
    }
    set [dartx.resetStyleInheritance](value) {
      html$.ShadowRoot._shadowRootDeprecationReport();
    }
    get [dartx.applyAuthorStyles]() {
      html$.ShadowRoot._shadowRootDeprecationReport();
      return false;
    }
    set [dartx.applyAuthorStyles](value) {
      html$.ShadowRoot._shadowRootDeprecationReport();
    }
  };
  const innerHtml = Symbol(html$.ShadowRoot.name + "." + dartx.innerHtml.toString());
  dart.setSignature(html$.ShadowRoot, {
    constructors: () => ({_: dart.definiteFunctionType(html$.ShadowRoot, [])}),
    methods: () => ({
      [dartx.elementFromPoint]: dart.definiteFunctionType(html$.Element, [core.int, core.int]),
      [dartx.elementsFromPoint]: dart.definiteFunctionType(core.List$(html$.Element), [core.int, core.int]),
      [dartx.getSelection]: dart.definiteFunctionType(html$.Selection, [])
    }),
    statics: () => ({_shadowRootDeprecationReport: dart.definiteFunctionType(dart.void, [])}),
    names: ['_shadowRootDeprecationReport']
  });
  html$.ShadowRoot._shadowRootDeprecationReported = false;
  dart.registerExtension(dart.global.ShadowRoot, html$.ShadowRoot);
  dart.defineExtensionNames([
    'byteLength'
  ]);
  html$.SharedArrayBuffer = class SharedArrayBuffer extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.byteLength]() {
      return this.byteLength;
    }
  };
  dart.setSignature(html$.SharedArrayBuffer, {
    constructors: () => ({_: dart.definiteFunctionType(html$.SharedArrayBuffer, [])})
  });
  dart.registerExtension(dart.global.SharedArrayBuffer, html$.SharedArrayBuffer);
  dart.defineExtensionNames([
    'onError',
    'port',
    'workerStart'
  ]);
  html$.SharedWorker = class SharedWorker extends html$.EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(scriptURL, name) {
      if (name === void 0) name = null;
      if (name != null) {
        return html$.SharedWorker._create_1(scriptURL, name);
      }
      return html$.SharedWorker._create_2(scriptURL);
    }
    static _create_1(scriptURL, name) {
      return new SharedWorker(scriptURL, name);
    }
    static _create_2(scriptURL) {
      return new SharedWorker(scriptURL);
    }
    get [dartx.port]() {
      return this.port;
    }
    get [dartx.workerStart]() {
      return this.workerStart;
    }
    get [dartx.onError]() {
      return html$.SharedWorker.errorEvent.forTarget(this);
    }
  };
  html$.SharedWorker[dart.implements] = () => [html$.AbstractWorker];
  dart.setSignature(html$.SharedWorker, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.SharedWorker, []),
      new: dart.definiteFunctionType(html$.SharedWorker, [core.String], [core.String])
    }),
    statics: () => ({
      _create_1: dart.definiteFunctionType(html$.SharedWorker, [dart.dynamic, dart.dynamic]),
      _create_2: dart.definiteFunctionType(html$.SharedWorker, [dart.dynamic])
    }),
    names: ['_create_1', '_create_2']
  });
  dart.defineLazy(html$.SharedWorker, {
    get errorEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('error'));
    }
  });
  dart.registerExtension(dart.global.SharedWorker, html$.SharedWorker);
  dart.defineExtensionNames([
    'onConnect',
    'name'
  ]);
  html$.SharedWorkerGlobalScope = class SharedWorkerGlobalScope extends html$.WorkerGlobalScope {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.name]() {
      return this.name;
    }
    get [dartx.onConnect]() {
      return html$.SharedWorkerGlobalScope.connectEvent.forTarget(this);
    }
  };
  dart.setSignature(html$.SharedWorkerGlobalScope, {
    constructors: () => ({_: dart.definiteFunctionType(html$.SharedWorkerGlobalScope, [])})
  });
  dart.defineLazy(html$.SharedWorkerGlobalScope, {
    get connectEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('connect'));
    }
  });
  dart.registerExtension(dart.global.SharedWorkerGlobalScope, html$.SharedWorkerGlobalScope);
  dart.defineExtensionNames([
    'abort',
    'appendBuffer',
    'appendStream',
    'appendTypedData',
    'remove',
    'appendWindowEnd',
    'appendWindowStart',
    'buffered',
    'mode',
    'timestampOffset',
    'trackDefaults',
    'updating'
  ]);
  html$.SourceBuffer = class SourceBuffer extends html$.EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.appendWindowEnd]() {
      return this.appendWindowEnd;
    }
    set [dartx.appendWindowEnd](value) {
      this.appendWindowEnd = value;
    }
    get [dartx.appendWindowStart]() {
      return this.appendWindowStart;
    }
    set [dartx.appendWindowStart](value) {
      this.appendWindowStart = value;
    }
    get [dartx.buffered]() {
      return this.buffered;
    }
    get [dartx.mode]() {
      return this.mode;
    }
    set [dartx.mode](value) {
      this.mode = value;
    }
    get [dartx.timestampOffset]() {
      return this.timestampOffset;
    }
    set [dartx.timestampOffset](value) {
      this.timestampOffset = value;
    }
    get [dartx.trackDefaults]() {
      return this.trackDefaults;
    }
    set [dartx.trackDefaults](value) {
      this.trackDefaults = value;
    }
    get [dartx.updating]() {
      return this.updating;
    }
    [dartx.abort]() {
      return this.abort();
    }
    [dartx.appendBuffer](data) {
      return this.appendBuffer(data);
    }
    [dartx.appendStream](stream, maxSize) {
      return this.appendStream(stream, maxSize);
    }
    [dartx.appendTypedData](data) {
      return this.appendBuffer(data);
    }
    [dartx.remove](start, end) {
      return this.remove(start, end);
    }
  };
  dart.setSignature(html$.SourceBuffer, {
    constructors: () => ({_: dart.definiteFunctionType(html$.SourceBuffer, [])}),
    methods: () => ({
      [dartx.abort]: dart.definiteFunctionType(dart.void, []),
      [dartx.appendBuffer]: dart.definiteFunctionType(dart.void, [typed_data.ByteBuffer]),
      [dartx.appendStream]: dart.definiteFunctionType(dart.void, [html$.FileStream], [core.int]),
      [dartx.appendTypedData]: dart.definiteFunctionType(dart.void, [typed_data.TypedData]),
      [dartx.remove]: dart.definiteFunctionType(dart.void, [core.num, core.num])
    })
  });
  dart.registerExtension(dart.global.SourceBuffer, html$.SourceBuffer);
  dart.defineExtensionNames([
    'length',
    'get',
    'set',
    'length',
    'first',
    'last',
    'single',
    'elementAt',
    'item'
  ]);
  html$.SourceBufferList = class SourceBufferList extends dart.mixin(html$.EventTarget, collection.ListMixin$(html$.SourceBuffer), html$.ImmutableListMixin$(html$.SourceBuffer)) {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.length]() {
      return this.length;
    }
    [dartx.get](index) {
      if (index >>> 0 !== index || index >= this[dartx.length]) dart.throw(core.RangeError.index(index, this));
      return this[index];
    }
    [dartx.set](index, value) {
      dart.throw(new core.UnsupportedError("Cannot assign element of immutable List."));
      return value;
    }
    set [dartx.length](value) {
      dart.throw(new core.UnsupportedError("Cannot resize immutable List."));
    }
    get [dartx.first]() {
      if (dart.notNull(this[dartx.length]) > 0) {
        return this[0];
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.last]() {
      let len = this[dartx.length];
      if (dart.notNull(len) > 0) {
        return this[dart.notNull(len) - 1];
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.single]() {
      let len = this[dartx.length];
      if (len == 1) {
        return this[0];
      }
      if (len == 0) dart.throw(new core.StateError("No elements"));
      dart.throw(new core.StateError("More than one element"));
    }
    [dartx.elementAt](index) {
      return this[dartx.get](index);
    }
    [dartx.item](index) {
      return this.item(index);
    }
  };
  html$.SourceBufferList[dart.implements] = () => [_js_helper.JavaScriptIndexingBehavior, ListOfSourceBuffer()];
  dart.setSignature(html$.SourceBufferList, {
    constructors: () => ({_: dart.definiteFunctionType(html$.SourceBufferList, [])}),
    methods: () => ({
      [dartx.get]: dart.definiteFunctionType(html$.SourceBuffer, [core.int]),
      [dartx.set]: dart.definiteFunctionType(dart.void, [core.int, html$.SourceBuffer]),
      [dartx.elementAt]: dart.definiteFunctionType(html$.SourceBuffer, [core.int]),
      [dartx.item]: dart.definiteFunctionType(html$.SourceBuffer, [core.int])
    })
  });
  dart.registerExtension(dart.global.SourceBufferList, html$.SourceBufferList);
  dart.defineExtensionNames([
    'media',
    'sizes',
    'src',
    'srcset',
    'type'
  ]);
  html$.SourceElement = class SourceElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return html$.SourceElement._check(html$.document[dartx.createElement]("source"));
    }
    created() {
      this[dartx.media] = null;
      this[dartx.sizes] = null;
      this[dartx.src] = null;
      this[dartx.srcset] = null;
      this[dartx.type] = null;
      super.created();
    }
    get [dartx.media]() {
      return this.media;
    }
    set [dartx.media](value) {
      this.media = value;
    }
    get [dartx.sizes]() {
      return this.sizes;
    }
    set [dartx.sizes](value) {
      this.sizes = value;
    }
    get [dartx.src]() {
      return this.src;
    }
    set [dartx.src](value) {
      this.src = value;
    }
    get [dartx.srcset]() {
      return this.srcset;
    }
    set [dartx.srcset](value) {
      this.srcset = value;
    }
    get [dartx.type]() {
      return this.type;
    }
    set [dartx.type](value) {
      this.type = value;
    }
  };
  dart.defineNamedConstructor(html$.SourceElement, 'created');
  dart.setSignature(html$.SourceElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.SourceElement, []),
      new: dart.definiteFunctionType(html$.SourceElement, []),
      created: dart.definiteFunctionType(html$.SourceElement, [])
    })
  });
  dart.registerExtension(dart.global.HTMLSourceElement, html$.SourceElement);
  dart.defineExtensionNames([
    'facing',
    'id',
    'kind',
    'label'
  ]);
  html$.SourceInfo = class SourceInfo extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.facing]() {
      return this.facing;
    }
    get [dartx.id]() {
      return this.id;
    }
    get [dartx.kind]() {
      return this.kind;
    }
    get [dartx.label]() {
      return this.label;
    }
  };
  dart.setSignature(html$.SourceInfo, {
    constructors: () => ({_: dart.definiteFunctionType(html$.SourceInfo, [])})
  });
  dart.registerExtension(dart.global.SourceInfo, html$.SourceInfo);
  html$.SpanElement = class SpanElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return html$.SpanElement._check(html$.document[dartx.createElement]("span"));
    }
    created() {
      super.created();
    }
  };
  dart.defineNamedConstructor(html$.SpanElement, 'created');
  dart.setSignature(html$.SpanElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.SpanElement, []),
      new: dart.definiteFunctionType(html$.SpanElement, []),
      created: dart.definiteFunctionType(html$.SpanElement, [])
    })
  });
  dart.registerExtension(dart.global.HTMLSpanElement, html$.SpanElement);
  dart.defineExtensionNames([
    'src',
    'weight'
  ]);
  html$.SpeechGrammar = class SpeechGrammar extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return html$.SpeechGrammar._create_1();
    }
    static _create_1() {
      return new SpeechGrammar();
    }
    get [dartx.src]() {
      return this.src;
    }
    set [dartx.src](value) {
      this.src = value;
    }
    get [dartx.weight]() {
      return this.weight;
    }
    set [dartx.weight](value) {
      this.weight = value;
    }
  };
  dart.setSignature(html$.SpeechGrammar, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.SpeechGrammar, []),
      new: dart.definiteFunctionType(html$.SpeechGrammar, [])
    }),
    statics: () => ({_create_1: dart.definiteFunctionType(html$.SpeechGrammar, [])}),
    names: ['_create_1']
  });
  dart.registerExtension(dart.global.SpeechGrammar, html$.SpeechGrammar);
  dart.defineExtensionNames([
    'length',
    'get',
    'set',
    'length',
    'first',
    'last',
    'single',
    'elementAt',
    'addFromString',
    'addFromUri',
    'item'
  ]);
  html$.SpeechGrammarList = class SpeechGrammarList extends dart.mixin(_interceptors.Interceptor, collection.ListMixin$(html$.SpeechGrammar), html$.ImmutableListMixin$(html$.SpeechGrammar)) {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return html$.SpeechGrammarList._create_1();
    }
    static _create_1() {
      return new SpeechGrammarList();
    }
    get [dartx.length]() {
      return this.length;
    }
    [dartx.get](index) {
      if (index >>> 0 !== index || index >= this[dartx.length]) dart.throw(core.RangeError.index(index, this));
      return this[index];
    }
    [dartx.set](index, value) {
      dart.throw(new core.UnsupportedError("Cannot assign element of immutable List."));
      return value;
    }
    set [dartx.length](value) {
      dart.throw(new core.UnsupportedError("Cannot resize immutable List."));
    }
    get [dartx.first]() {
      if (dart.notNull(this[dartx.length]) > 0) {
        return this[0];
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.last]() {
      let len = this[dartx.length];
      if (dart.notNull(len) > 0) {
        return this[dart.notNull(len) - 1];
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.single]() {
      let len = this[dartx.length];
      if (len == 1) {
        return this[0];
      }
      if (len == 0) dart.throw(new core.StateError("No elements"));
      dart.throw(new core.StateError("More than one element"));
    }
    [dartx.elementAt](index) {
      return this[dartx.get](index);
    }
    [dartx.addFromString](string, weight) {
      return this.addFromString(string, weight);
    }
    [dartx.addFromUri](src, weight) {
      return this.addFromUri(src, weight);
    }
    [dartx.item](index) {
      return this.item(index);
    }
  };
  html$.SpeechGrammarList[dart.implements] = () => [_js_helper.JavaScriptIndexingBehavior, ListOfSpeechGrammar()];
  dart.setSignature(html$.SpeechGrammarList, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.SpeechGrammarList, []),
      new: dart.definiteFunctionType(html$.SpeechGrammarList, [])
    }),
    methods: () => ({
      [dartx.get]: dart.definiteFunctionType(html$.SpeechGrammar, [core.int]),
      [dartx.set]: dart.definiteFunctionType(dart.void, [core.int, html$.SpeechGrammar]),
      [dartx.elementAt]: dart.definiteFunctionType(html$.SpeechGrammar, [core.int]),
      [dartx.addFromString]: dart.definiteFunctionType(dart.void, [core.String], [core.num]),
      [dartx.addFromUri]: dart.definiteFunctionType(dart.void, [core.String], [core.num]),
      [dartx.item]: dart.definiteFunctionType(html$.SpeechGrammar, [core.int])
    }),
    statics: () => ({_create_1: dart.definiteFunctionType(html$.SpeechGrammarList, [])}),
    names: ['_create_1']
  });
  dart.registerExtension(dart.global.SpeechGrammarList, html$.SpeechGrammarList);
  dart.defineExtensionNames([
    'abort',
    'start',
    'stop',
    'onAudioEnd',
    'onAudioStart',
    'onEnd',
    'onError',
    'onNoMatch',
    'onResult',
    'onSoundEnd',
    'onSoundStart',
    'onSpeechEnd',
    'onSpeechStart',
    'onStart',
    'audioTrack',
    'continuous',
    'grammars',
    'interimResults',
    'lang',
    'maxAlternatives',
    'serviceUri'
  ]);
  html$.SpeechRecognition = class SpeechRecognition extends html$.EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static get supported() {
      return !!(window.SpeechRecognition || window.webkitSpeechRecognition);
    }
    get [dartx.audioTrack]() {
      return this.audioTrack;
    }
    set [dartx.audioTrack](value) {
      this.audioTrack = value;
    }
    get [dartx.continuous]() {
      return this.continuous;
    }
    set [dartx.continuous](value) {
      this.continuous = value;
    }
    get [dartx.grammars]() {
      return this.grammars;
    }
    set [dartx.grammars](value) {
      this.grammars = value;
    }
    get [dartx.interimResults]() {
      return this.interimResults;
    }
    set [dartx.interimResults](value) {
      this.interimResults = value;
    }
    get [dartx.lang]() {
      return this.lang;
    }
    set [dartx.lang](value) {
      this.lang = value;
    }
    get [dartx.maxAlternatives]() {
      return this.maxAlternatives;
    }
    set [dartx.maxAlternatives](value) {
      this.maxAlternatives = value;
    }
    get [dartx.serviceUri]() {
      return this.serviceURI;
    }
    set [dartx.serviceUri](value) {
      this.serviceURI = value;
    }
    [dartx.abort]() {
      return this.abort();
    }
    [dartx.start]() {
      return this.start();
    }
    [dartx.stop]() {
      return this.stop();
    }
    get [dartx.onAudioEnd]() {
      return html$.SpeechRecognition.audioEndEvent.forTarget(this);
    }
    get [dartx.onAudioStart]() {
      return html$.SpeechRecognition.audioStartEvent.forTarget(this);
    }
    get [dartx.onEnd]() {
      return html$.SpeechRecognition.endEvent.forTarget(this);
    }
    get [dartx.onError]() {
      return html$.SpeechRecognition.errorEvent.forTarget(this);
    }
    get [dartx.onNoMatch]() {
      return html$.SpeechRecognition.noMatchEvent.forTarget(this);
    }
    get [dartx.onResult]() {
      return html$.SpeechRecognition.resultEvent.forTarget(this);
    }
    get [dartx.onSoundEnd]() {
      return html$.SpeechRecognition.soundEndEvent.forTarget(this);
    }
    get [dartx.onSoundStart]() {
      return html$.SpeechRecognition.soundStartEvent.forTarget(this);
    }
    get [dartx.onSpeechEnd]() {
      return html$.SpeechRecognition.speechEndEvent.forTarget(this);
    }
    get [dartx.onSpeechStart]() {
      return html$.SpeechRecognition.speechStartEvent.forTarget(this);
    }
    get [dartx.onStart]() {
      return html$.SpeechRecognition.startEvent.forTarget(this);
    }
    static new() {
      return new (window.SpeechRecognition || window.webkitSpeechRecognition)();
    }
  };
  dart.setSignature(html$.SpeechRecognition, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.SpeechRecognition, []),
      new: dart.definiteFunctionType(html$.SpeechRecognition, [])
    }),
    methods: () => ({
      [dartx.abort]: dart.definiteFunctionType(dart.void, []),
      [dartx.start]: dart.definiteFunctionType(dart.void, []),
      [dartx.stop]: dart.definiteFunctionType(dart.void, [])
    })
  });
  dart.defineLazy(html$.SpeechRecognition, {
    get audioEndEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('audioend'));
    },
    get audioStartEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('audiostart'));
    },
    get endEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('end'));
    },
    get errorEvent() {
      return dart.const(new (EventStreamProviderOfSpeechRecognitionError())('error'));
    },
    get noMatchEvent() {
      return dart.const(new (EventStreamProviderOfSpeechRecognitionEvent())('nomatch'));
    },
    get resultEvent() {
      return dart.const(new (EventStreamProviderOfSpeechRecognitionEvent())('result'));
    },
    get soundEndEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('soundend'));
    },
    get soundStartEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('soundstart'));
    },
    get speechEndEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('speechend'));
    },
    get speechStartEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('speechstart'));
    },
    get startEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('start'));
    }
  });
  dart.registerExtension(dart.global.SpeechRecognition, html$.SpeechRecognition);
  dart.defineExtensionNames([
    'confidence',
    'transcript'
  ]);
  html$.SpeechRecognitionAlternative = class SpeechRecognitionAlternative extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.confidence]() {
      return this.confidence;
    }
    get [dartx.transcript]() {
      return this.transcript;
    }
  };
  dart.setSignature(html$.SpeechRecognitionAlternative, {
    constructors: () => ({_: dart.definiteFunctionType(html$.SpeechRecognitionAlternative, [])})
  });
  dart.registerExtension(dart.global.SpeechRecognitionAlternative, html$.SpeechRecognitionAlternative);
  dart.defineExtensionNames([
    'error',
    'message'
  ]);
  html$.SpeechRecognitionError = class SpeechRecognitionError extends html$.Event {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(type, initDict) {
      if (initDict === void 0) initDict = null;
      if (initDict != null) {
        let initDict_1 = html_common.convertDartToNative_Dictionary(initDict);
        return html$.SpeechRecognitionError._create_1(type, initDict_1);
      }
      return html$.SpeechRecognitionError._create_2(type);
    }
    static _create_1(type, initDict) {
      return new SpeechRecognitionError(type, initDict);
    }
    static _create_2(type) {
      return new SpeechRecognitionError(type);
    }
    get [dartx.error]() {
      return this.error;
    }
    get [dartx.message]() {
      return this.message;
    }
  };
  dart.setSignature(html$.SpeechRecognitionError, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.SpeechRecognitionError, []),
      new: dart.definiteFunctionType(html$.SpeechRecognitionError, [core.String], [core.Map])
    }),
    statics: () => ({
      _create_1: dart.definiteFunctionType(html$.SpeechRecognitionError, [dart.dynamic, dart.dynamic]),
      _create_2: dart.definiteFunctionType(html$.SpeechRecognitionError, [dart.dynamic])
    }),
    names: ['_create_1', '_create_2']
  });
  dart.registerExtension(dart.global.SpeechRecognitionError, html$.SpeechRecognitionError);
  dart.defineExtensionNames([
    'emma',
    'interpretation',
    'resultIndex',
    'results'
  ]);
  html$.SpeechRecognitionEvent = class SpeechRecognitionEvent extends html$.Event {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(type, initDict) {
      if (initDict === void 0) initDict = null;
      if (initDict != null) {
        let initDict_1 = html_common.convertDartToNative_Dictionary(initDict);
        return html$.SpeechRecognitionEvent._create_1(type, initDict_1);
      }
      return html$.SpeechRecognitionEvent._create_2(type);
    }
    static _create_1(type, initDict) {
      return new SpeechRecognitionEvent(type, initDict);
    }
    static _create_2(type) {
      return new SpeechRecognitionEvent(type);
    }
    get [dartx.emma]() {
      return this.emma;
    }
    get [dartx.interpretation]() {
      return this.interpretation;
    }
    get [dartx.resultIndex]() {
      return this.resultIndex;
    }
    get [dartx.results]() {
      return this.results;
    }
  };
  dart.setSignature(html$.SpeechRecognitionEvent, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.SpeechRecognitionEvent, []),
      new: dart.definiteFunctionType(html$.SpeechRecognitionEvent, [core.String], [core.Map])
    }),
    statics: () => ({
      _create_1: dart.definiteFunctionType(html$.SpeechRecognitionEvent, [dart.dynamic, dart.dynamic]),
      _create_2: dart.definiteFunctionType(html$.SpeechRecognitionEvent, [dart.dynamic])
    }),
    names: ['_create_1', '_create_2']
  });
  dart.registerExtension(dart.global.SpeechRecognitionEvent, html$.SpeechRecognitionEvent);
  dart.defineExtensionNames([
    'item',
    'isFinal',
    'length'
  ]);
  html$.SpeechRecognitionResult = class SpeechRecognitionResult extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.isFinal]() {
      return this.isFinal;
    }
    get [dartx.length]() {
      return this.length;
    }
    [dartx.item](index) {
      return this.item(index);
    }
  };
  dart.setSignature(html$.SpeechRecognitionResult, {
    constructors: () => ({_: dart.definiteFunctionType(html$.SpeechRecognitionResult, [])}),
    methods: () => ({[dartx.item]: dart.definiteFunctionType(html$.SpeechRecognitionAlternative, [core.int])})
  });
  dart.registerExtension(dart.global.SpeechRecognitionResult, html$.SpeechRecognitionResult);
  dart.defineExtensionNames([
    'cancel',
    'getVoices',
    'pause',
    'resume',
    'speak',
    'paused',
    'pending',
    'speaking'
  ]);
  html$.SpeechSynthesis = class SpeechSynthesis extends html$.EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.paused]() {
      return this.paused;
    }
    get [dartx.pending]() {
      return this.pending;
    }
    get [dartx.speaking]() {
      return this.speaking;
    }
    [dartx.cancel]() {
      return this.cancel();
    }
    [dartx.getVoices]() {
      return this.getVoices();
    }
    [dartx.pause]() {
      return this.pause();
    }
    [dartx.resume]() {
      return this.resume();
    }
    [dartx.speak](utterance) {
      return this.speak(utterance);
    }
  };
  dart.setSignature(html$.SpeechSynthesis, {
    constructors: () => ({_: dart.definiteFunctionType(html$.SpeechSynthesis, [])}),
    methods: () => ({
      [dartx.cancel]: dart.definiteFunctionType(dart.void, []),
      [dartx.getVoices]: dart.definiteFunctionType(core.List$(html$.SpeechSynthesisVoice), []),
      [dartx.pause]: dart.definiteFunctionType(dart.void, []),
      [dartx.resume]: dart.definiteFunctionType(dart.void, []),
      [dartx.speak]: dart.definiteFunctionType(dart.void, [html$.SpeechSynthesisUtterance])
    })
  });
  dart.registerExtension(dart.global.SpeechSynthesis, html$.SpeechSynthesis);
  dart.defineExtensionNames([
    'charIndex',
    'elapsedTime',
    'name',
    'utterance'
  ]);
  html$.SpeechSynthesisEvent = class SpeechSynthesisEvent extends html$.Event {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.charIndex]() {
      return this.charIndex;
    }
    get [dartx.elapsedTime]() {
      return this.elapsedTime;
    }
    get [dartx.name]() {
      return this.name;
    }
    get [dartx.utterance]() {
      return this.utterance;
    }
  };
  dart.setSignature(html$.SpeechSynthesisEvent, {
    constructors: () => ({_: dart.definiteFunctionType(html$.SpeechSynthesisEvent, [])})
  });
  dart.registerExtension(dart.global.SpeechSynthesisEvent, html$.SpeechSynthesisEvent);
  dart.defineExtensionNames([
    'onBoundary',
    'onEnd',
    'onError',
    'onMark',
    'onPause',
    'onResume',
    'onStart',
    'lang',
    'pitch',
    'rate',
    'text',
    'voice',
    'volume'
  ]);
  html$.SpeechSynthesisUtterance = class SpeechSynthesisUtterance extends html$.EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(text) {
      if (text === void 0) text = null;
      if (text != null) {
        return html$.SpeechSynthesisUtterance._create_1(text);
      }
      return html$.SpeechSynthesisUtterance._create_2();
    }
    static _create_1(text) {
      return new SpeechSynthesisUtterance(text);
    }
    static _create_2() {
      return new SpeechSynthesisUtterance();
    }
    get [dartx.lang]() {
      return this.lang;
    }
    set [dartx.lang](value) {
      this.lang = value;
    }
    get [dartx.pitch]() {
      return this.pitch;
    }
    set [dartx.pitch](value) {
      this.pitch = value;
    }
    get [dartx.rate]() {
      return this.rate;
    }
    set [dartx.rate](value) {
      this.rate = value;
    }
    get [dartx.text]() {
      return this.text;
    }
    set [dartx.text](value) {
      this.text = value;
    }
    get [dartx.voice]() {
      return this.voice;
    }
    set [dartx.voice](value) {
      this.voice = value;
    }
    get [dartx.volume]() {
      return this.volume;
    }
    set [dartx.volume](value) {
      this.volume = value;
    }
    get [dartx.onBoundary]() {
      return html$.SpeechSynthesisUtterance.boundaryEvent.forTarget(this);
    }
    get [dartx.onEnd]() {
      return html$.SpeechSynthesisUtterance.endEvent.forTarget(this);
    }
    get [dartx.onError]() {
      return html$.SpeechSynthesisUtterance.errorEvent.forTarget(this);
    }
    get [dartx.onMark]() {
      return html$.SpeechSynthesisUtterance.markEvent.forTarget(this);
    }
    get [dartx.onPause]() {
      return html$.SpeechSynthesisUtterance.pauseEvent.forTarget(this);
    }
    get [dartx.onResume]() {
      return html$.SpeechSynthesisUtterance.resumeEvent.forTarget(this);
    }
    get [dartx.onStart]() {
      return html$.SpeechSynthesisUtterance.startEvent.forTarget(this);
    }
  };
  dart.setSignature(html$.SpeechSynthesisUtterance, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.SpeechSynthesisUtterance, []),
      new: dart.definiteFunctionType(html$.SpeechSynthesisUtterance, [], [core.String])
    }),
    statics: () => ({
      _create_1: dart.definiteFunctionType(html$.SpeechSynthesisUtterance, [dart.dynamic]),
      _create_2: dart.definiteFunctionType(html$.SpeechSynthesisUtterance, [])
    }),
    names: ['_create_1', '_create_2']
  });
  dart.defineLazy(html$.SpeechSynthesisUtterance, {
    get boundaryEvent() {
      return dart.const(new (EventStreamProviderOfSpeechSynthesisEvent())('boundary'));
    },
    get endEvent() {
      return dart.const(new (EventStreamProviderOfSpeechSynthesisEvent())('end'));
    },
    get errorEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('error'));
    },
    get markEvent() {
      return dart.const(new (EventStreamProviderOfSpeechSynthesisEvent())('mark'));
    },
    get pauseEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('pause'));
    },
    get resumeEvent() {
      return dart.const(new (EventStreamProviderOfSpeechSynthesisEvent())('resume'));
    },
    get startEvent() {
      return dart.const(new (EventStreamProviderOfSpeechSynthesisEvent())('start'));
    }
  });
  dart.registerExtension(dart.global.SpeechSynthesisUtterance, html$.SpeechSynthesisUtterance);
  dart.defineExtensionNames([
    'defaultValue',
    'lang',
    'localService',
    'name',
    'voiceUri'
  ]);
  html$.SpeechSynthesisVoice = class SpeechSynthesisVoice extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.defaultValue]() {
      return this.default;
    }
    get [dartx.lang]() {
      return this.lang;
    }
    get [dartx.localService]() {
      return this.localService;
    }
    get [dartx.name]() {
      return this.name;
    }
    get [dartx.voiceUri]() {
      return this.voiceURI;
    }
  };
  dart.setSignature(html$.SpeechSynthesisVoice, {
    constructors: () => ({_: dart.definiteFunctionType(html$.SpeechSynthesisVoice, [])})
  });
  dart.registerExtension(dart.global.SpeechSynthesisVoice, html$.SpeechSynthesisVoice);
  dart.defineExtensionNames([
    'name'
  ]);
  html$.StashedMessagePort = class StashedMessagePort extends html$.MessagePort {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.name]() {
      return this.name;
    }
  };
  dart.setSignature(html$.StashedMessagePort, {
    constructors: () => ({_: dart.definiteFunctionType(html$.StashedMessagePort, [])})
  });
  dart.registerExtension(dart.global.StashedMessagePort, html$.StashedMessagePort);
  dart.defineExtensionNames([
    'add',
    'onMessage'
  ]);
  html$.StashedPortCollection = class StashedPortCollection extends html$.EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [dartx.add](name, port) {
      return this.add(name, port);
    }
    get [dartx.onMessage]() {
      return html$.StashedPortCollection.messageEvent.forTarget(this);
    }
  };
  dart.setSignature(html$.StashedPortCollection, {
    constructors: () => ({_: dart.definiteFunctionType(html$.StashedPortCollection, [])}),
    methods: () => ({[dartx.add]: dart.definiteFunctionType(html$.StashedMessagePort, [core.String, html$.MessagePort])})
  });
  dart.defineLazy(html$.StashedPortCollection, {
    get messageEvent() {
      return dart.const(new (EventStreamProviderOfMessageEvent())('message'));
    }
  });
  dart.registerExtension(dart.global.StashedPortCollection, html$.StashedPortCollection);
  const _getItem = Symbol('_getItem');
  const _setItem = Symbol('_setItem');
  const _removeItem = Symbol('_removeItem');
  const _key = Symbol('_key');
  const _length$2 = Symbol('_length');
  const __delete__ = Symbol('__delete__');
  dart.defineExtensionNames([
    'addAll',
    'containsValue',
    'containsKey',
    'get',
    'set',
    'putIfAbsent',
    'remove',
    'clear',
    'forEach',
    'keys',
    'values',
    'length',
    'isEmpty',
    'isNotEmpty'
  ]);
  html$.Storage = class Storage extends _interceptors.Interceptor {
    [dartx.addAll](other) {
      other[dartx.forEach](dart.fn((k, v) => {
        this[dartx.set](k, v);
      }, StringAndStringTovoid()));
    }
    [dartx.containsValue](value) {
      return this[dartx.values][dartx.any](dart.fn(e => dart.equals(e, value), StringTobool()));
    }
    [dartx.containsKey](key) {
      return this[_getItem](core.String._check(key)) != null;
    }
    [dartx.get](key) {
      return this[_getItem](core.String._check(key));
    }
    [dartx.set](key, value) {
      this[_setItem](key, value);
      return value;
    }
    [dartx.putIfAbsent](key, ifAbsent) {
      if (!dart.test(this[dartx.containsKey](key))) this[dartx.set](key, ifAbsent());
      return this[dartx.get](key);
    }
    [dartx.remove](key) {
      let value = this[dartx.get](key);
      this[_removeItem](core.String._check(key));
      return value;
    }
    [dartx.clear]() {
      return this[_clear$1]();
    }
    [dartx.forEach](f) {
      for (let i = 0; true; i++) {
        let key = this[_key](i);
        if (key == null) return;
        f(key, this[dartx.get](key));
      }
    }
    get [dartx.keys]() {
      let keys = JSArrayOfString().of([]);
      this[dartx.forEach](dart.fn((k, v) => keys[dartx.add](k), StringAndStringTovoid()));
      return keys;
    }
    get [dartx.values]() {
      let values = JSArrayOfString().of([]);
      this[dartx.forEach](dart.fn((k, v) => values[dartx.add](v), StringAndStringTovoid()));
      return values;
    }
    get [dartx.length]() {
      return this[_length$2];
    }
    get [dartx.isEmpty]() {
      return this[_key](0) == null;
    }
    get [dartx.isNotEmpty]() {
      return !dart.test(this[dartx.isEmpty]);
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [_length$2]() {
      return this.length;
    }
    [__delete__](index_OR_name) {
      return this.__delete__(index_OR_name);
    }
    [__getter__](index_OR_name) {
      return this.__getter__(index_OR_name);
    }
    [__setter__](index_OR_name, value) {
      return this.__setter__(index_OR_name, value);
    }
    [_clear$1]() {
      return this.clear();
    }
    [_getItem](key) {
      return this.getItem(key);
    }
    [_key](index) {
      return this.key(index);
    }
    [_removeItem](key) {
      return this.removeItem(key);
    }
    [_setItem](key, data) {
      return this.setItem(key, data);
    }
  };
  html$.Storage[dart.implements] = () => [MapOfString$String()];
  dart.setSignature(html$.Storage, {
    constructors: () => ({_: dart.definiteFunctionType(html$.Storage, [])}),
    methods: () => ({
      [dartx.addAll]: dart.definiteFunctionType(dart.void, [core.Map$(core.String, core.String)]),
      [dartx.containsValue]: dart.definiteFunctionType(core.bool, [core.Object]),
      [dartx.containsKey]: dart.definiteFunctionType(core.bool, [core.Object]),
      [dartx.get]: dart.definiteFunctionType(core.String, [core.Object]),
      [dartx.set]: dart.definiteFunctionType(dart.void, [core.String, core.String]),
      [dartx.putIfAbsent]: dart.definiteFunctionType(core.String, [core.String, dart.functionType(core.String, [])]),
      [dartx.remove]: dart.definiteFunctionType(core.String, [core.Object]),
      [dartx.clear]: dart.definiteFunctionType(dart.void, []),
      [dartx.forEach]: dart.definiteFunctionType(dart.void, [dart.functionType(dart.void, [core.String, core.String])]),
      [__delete__]: dart.definiteFunctionType(core.bool, [dart.dynamic]),
      [__getter__]: dart.definiteFunctionType(core.String, [dart.dynamic]),
      [__setter__]: dart.definiteFunctionType(dart.void, [dart.dynamic, core.String]),
      [_clear$1]: dart.definiteFunctionType(dart.void, []),
      [_getItem]: dart.definiteFunctionType(core.String, [core.String]),
      [_key]: dart.definiteFunctionType(core.String, [core.int]),
      [_removeItem]: dart.definiteFunctionType(dart.void, [core.String]),
      [_setItem]: dart.definiteFunctionType(dart.void, [core.String, core.String])
    })
  });
  dart.registerExtension(dart.global.Storage, html$.Storage);
  html$.StorageErrorCallback = dart.typedef('StorageErrorCallback', () => dart.functionType(dart.void, [html$.DomError]));
  const _initStorageEvent = Symbol('_initStorageEvent');
  dart.defineExtensionNames([
    'key',
    'newValue',
    'oldValue',
    'storageArea',
    'url'
  ]);
  html$.StorageEvent = class StorageEvent extends html$.Event {
    static new(type, opts) {
      let canBubble = opts && 'canBubble' in opts ? opts.canBubble : false;
      let cancelable = opts && 'cancelable' in opts ? opts.cancelable : false;
      let key = opts && 'key' in opts ? opts.key : null;
      let oldValue = opts && 'oldValue' in opts ? opts.oldValue : null;
      let newValue = opts && 'newValue' in opts ? opts.newValue : null;
      let url = opts && 'url' in opts ? opts.url : null;
      let storageArea = opts && 'storageArea' in opts ? opts.storageArea : null;
      let e = html$.StorageEvent._check(html$.document[_createEvent]("StorageEvent"));
      e[_initStorageEvent](type, canBubble, cancelable, key, oldValue, newValue, url, storageArea);
      return e;
    }
    static _(type, eventInitDict) {
      if (eventInitDict === void 0) eventInitDict = null;
      if (eventInitDict != null) {
        let eventInitDict_1 = html_common.convertDartToNative_Dictionary(eventInitDict);
        return html$.StorageEvent._create_1(type, eventInitDict_1);
      }
      return html$.StorageEvent._create_2(type);
    }
    static _create_1(type, eventInitDict) {
      return new StorageEvent(type, eventInitDict);
    }
    static _create_2(type) {
      return new StorageEvent(type);
    }
    get [dartx.key]() {
      return this.key;
    }
    get [dartx.newValue]() {
      return this.newValue;
    }
    get [dartx.oldValue]() {
      return this.oldValue;
    }
    get [dartx.storageArea]() {
      return this.storageArea;
    }
    get [dartx.url]() {
      return this.url;
    }
    [_initStorageEvent](typeArg, canBubbleArg, cancelableArg, keyArg, oldValueArg, newValueArg, urlArg, storageAreaArg) {
      return this.initStorageEvent(typeArg, canBubbleArg, cancelableArg, keyArg, oldValueArg, newValueArg, urlArg, storageAreaArg);
    }
  };
  dart.setSignature(html$.StorageEvent, {
    constructors: () => ({
      new: dart.definiteFunctionType(html$.StorageEvent, [core.String], {canBubble: core.bool, cancelable: core.bool, key: core.String, oldValue: core.String, newValue: core.String, url: core.String, storageArea: html$.Storage}),
      _: dart.definiteFunctionType(html$.StorageEvent, [core.String], [core.Map])
    }),
    methods: () => ({[_initStorageEvent]: dart.definiteFunctionType(dart.void, [core.String, core.bool, core.bool, core.String, core.String, core.String, core.String, html$.Storage])}),
    statics: () => ({
      _create_1: dart.definiteFunctionType(html$.StorageEvent, [dart.dynamic, dart.dynamic]),
      _create_2: dart.definiteFunctionType(html$.StorageEvent, [dart.dynamic])
    }),
    names: ['_create_1', '_create_2']
  });
  dart.registerExtension(dart.global.StorageEvent, html$.StorageEvent);
  dart.defineExtensionNames([
    'quota',
    'usage'
  ]);
  html$.StorageInfo = class StorageInfo extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.quota]() {
      return this.quota;
    }
    get [dartx.usage]() {
      return this.usage;
    }
  };
  dart.setSignature(html$.StorageInfo, {
    constructors: () => ({_: dart.definiteFunctionType(html$.StorageInfo, [])})
  });
  dart.registerExtension(dart.global.StorageInfo, html$.StorageInfo);
  dart.defineExtensionNames([
    'queryInfo',
    'requestPersistentQuota',
    'supportedTypes'
  ]);
  html$.StorageQuota = class StorageQuota extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.supportedTypes]() {
      return this.supportedTypes;
    }
    [dartx.queryInfo](type) {
      return this.queryInfo(type);
    }
    [dartx.requestPersistentQuota](newQuota) {
      return this.requestPersistentQuota(newQuota);
    }
  };
  dart.setSignature(html$.StorageQuota, {
    constructors: () => ({_: dart.definiteFunctionType(html$.StorageQuota, [])}),
    methods: () => ({
      [dartx.queryInfo]: dart.definiteFunctionType(async.Future, [core.String]),
      [dartx.requestPersistentQuota]: dart.definiteFunctionType(async.Future, [core.int])
    })
  });
  dart.registerExtension(dart.global.StorageQuota, html$.StorageQuota);
  html$.StorageQuotaCallback = dart.typedef('StorageQuotaCallback', () => dart.functionType(dart.void, [core.int]));
  html$.StorageUsageCallback = dart.typedef('StorageUsageCallback', () => dart.functionType(dart.void, [core.int, core.int]));
  html$._StringCallback = dart.typedef('_StringCallback', () => dart.functionType(dart.void, [core.String]));
  dart.defineExtensionNames([
    'disabled',
    'media',
    'sheet',
    'type'
  ]);
  html$.StyleElement = class StyleElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return html$.StyleElement._check(html$.document[dartx.createElement]("style"));
    }
    created() {
      this[dartx.disabled] = null;
      this[dartx.media] = null;
      this[dartx.sheet] = null;
      this[dartx.type] = null;
      super.created();
    }
    get [dartx.disabled]() {
      return this.disabled;
    }
    set [dartx.disabled](value) {
      this.disabled = value;
    }
    get [dartx.media]() {
      return this.media;
    }
    set [dartx.media](value) {
      this.media = value;
    }
    get [dartx.sheet]() {
      return this.sheet;
    }
    get [dartx.type]() {
      return this.type;
    }
    set [dartx.type](value) {
      this.type = value;
    }
  };
  dart.defineNamedConstructor(html$.StyleElement, 'created');
  dart.setSignature(html$.StyleElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.StyleElement, []),
      new: dart.definiteFunctionType(html$.StyleElement, []),
      created: dart.definiteFunctionType(html$.StyleElement, [])
    })
  });
  dart.registerExtension(dart.global.HTMLStyleElement, html$.StyleElement);
  dart.defineExtensionNames([
    'matchMedium',
    'type'
  ]);
  html$.StyleMedia = class StyleMedia extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.type]() {
      return this.type;
    }
    [dartx.matchMedium](mediaquery) {
      return this.matchMedium(mediaquery);
    }
  };
  dart.setSignature(html$.StyleMedia, {
    constructors: () => ({_: dart.definiteFunctionType(html$.StyleMedia, [])}),
    methods: () => ({[dartx.matchMedium]: dart.definiteFunctionType(core.bool, [core.String])})
  });
  dart.registerExtension(dart.global.StyleMedia, html$.StyleMedia);
  dart.defineExtensionNames([
    'registration'
  ]);
  html$.SyncEvent = class SyncEvent extends html$.ExtendableEvent {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(type, init) {
      let init_1 = html_common.convertDartToNative_Dictionary(init);
      return html$.SyncEvent._create_1(type, init_1);
    }
    static _create_1(type, init) {
      return new SyncEvent(type, init);
    }
    get [dartx.registration]() {
      return this.registration;
    }
  };
  dart.setSignature(html$.SyncEvent, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.SyncEvent, []),
      new: dart.definiteFunctionType(html$.SyncEvent, [core.String, core.Map])
    }),
    statics: () => ({_create_1: dart.definiteFunctionType(html$.SyncEvent, [dart.dynamic, dart.dynamic])}),
    names: ['_create_1']
  });
  dart.registerExtension(dart.global.SyncEvent, html$.SyncEvent);
  dart.defineExtensionNames([
    'getRegistration',
    'getRegistrations',
    'permissionState',
    'register'
  ]);
  html$.SyncManager = class SyncManager extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [dartx.getRegistration](tag) {
      return this.getRegistration(tag);
    }
    [dartx.getRegistrations]() {
      return this.getRegistrations();
    }
    [dartx.permissionState]() {
      return this.permissionState();
    }
    [dartx.register](options) {
      if (options === void 0) options = null;
      if (options != null) {
        let options_1 = html_common.convertDartToNative_Dictionary(options);
        return this[_register_1](options_1);
      }
      return this[_register_2]();
    }
    [_register_1](options) {
      return this.register(options);
    }
    [_register_2]() {
      return this.register();
    }
  };
  dart.setSignature(html$.SyncManager, {
    constructors: () => ({_: dart.definiteFunctionType(html$.SyncManager, [])}),
    methods: () => ({
      [dartx.getRegistration]: dart.definiteFunctionType(async.Future, [core.String]),
      [dartx.getRegistrations]: dart.definiteFunctionType(async.Future, []),
      [dartx.permissionState]: dart.definiteFunctionType(async.Future, []),
      [dartx.register]: dart.definiteFunctionType(async.Future, [], [core.Map]),
      [_register_1]: dart.definiteFunctionType(async.Future, [dart.dynamic]),
      [_register_2]: dart.definiteFunctionType(async.Future, [])
    })
  });
  dart.registerExtension(dart.global.SyncManager, html$.SyncManager);
  dart.defineExtensionNames([
    'unregister',
    'tag'
  ]);
  html$.SyncRegistration = class SyncRegistration extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.tag]() {
      return this.tag;
    }
    [dartx.unregister]() {
      return this.unregister();
    }
  };
  dart.setSignature(html$.SyncRegistration, {
    constructors: () => ({_: dart.definiteFunctionType(html$.SyncRegistration, [])}),
    methods: () => ({[dartx.unregister]: dart.definiteFunctionType(async.Future, [])})
  });
  dart.registerExtension(dart.global.SyncRegistration, html$.SyncRegistration);
  html$.TableCaptionElement = class TableCaptionElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return html$.TableCaptionElement._check(html$.document[dartx.createElement]("caption"));
    }
    created() {
      super.created();
    }
  };
  dart.defineNamedConstructor(html$.TableCaptionElement, 'created');
  dart.setSignature(html$.TableCaptionElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.TableCaptionElement, []),
      new: dart.definiteFunctionType(html$.TableCaptionElement, []),
      created: dart.definiteFunctionType(html$.TableCaptionElement, [])
    })
  });
  dart.registerExtension(dart.global.HTMLTableCaptionElement, html$.TableCaptionElement);
  dart.defineExtensionNames([
    'cellIndex',
    'colSpan',
    'headers',
    'rowSpan'
  ]);
  html$.TableCellElement = class TableCellElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return html$.TableCellElement._check(html$.document[dartx.createElement]("td"));
    }
    created() {
      this[dartx.cellIndex] = null;
      this[dartx.colSpan] = null;
      this[dartx.headers] = null;
      this[dartx.rowSpan] = null;
      super.created();
    }
    get [dartx.cellIndex]() {
      return this.cellIndex;
    }
    get [dartx.colSpan]() {
      return this.colSpan;
    }
    set [dartx.colSpan](value) {
      this.colSpan = value;
    }
    get [dartx.headers]() {
      return this.headers;
    }
    set [dartx.headers](value) {
      this.headers = value;
    }
    get [dartx.rowSpan]() {
      return this.rowSpan;
    }
    set [dartx.rowSpan](value) {
      this.rowSpan = value;
    }
  };
  dart.defineNamedConstructor(html$.TableCellElement, 'created');
  dart.setSignature(html$.TableCellElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.TableCellElement, []),
      new: dart.definiteFunctionType(html$.TableCellElement, []),
      created: dart.definiteFunctionType(html$.TableCellElement, [])
    })
  });
  dart.registerExtension(dart.global.HTMLTableCellElement, html$.TableCellElement);
  dart.defineExtensionNames([
    'span'
  ]);
  html$.TableColElement = class TableColElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return html$.TableColElement._check(html$.document[dartx.createElement]("col"));
    }
    created() {
      this[dartx.span] = null;
      super.created();
    }
    get [dartx.span]() {
      return this.span;
    }
    set [dartx.span](value) {
      this.span = value;
    }
  };
  dart.defineNamedConstructor(html$.TableColElement, 'created');
  dart.setSignature(html$.TableColElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.TableColElement, []),
      new: dart.definiteFunctionType(html$.TableColElement, []),
      created: dart.definiteFunctionType(html$.TableColElement, [])
    })
  });
  dart.registerExtension(dart.global.HTMLTableColElement, html$.TableColElement);
  const _tBodies = Symbol('_tBodies');
  const _rows = Symbol('_rows');
  const _createCaption = Symbol('_createCaption');
  const _createTBody = Symbol('_createTBody');
  const _createTFoot = Symbol('_createTFoot');
  const _createTHead = Symbol('_createTHead');
  const _insertRow = Symbol('_insertRow');
  const _nativeCreateTBody = Symbol('_nativeCreateTBody');
  dart.defineExtensionNames([
    'tBodies',
    'rows',
    'addRow',
    'createCaption',
    'createTBody',
    'createTFoot',
    'createTHead',
    'insertRow',
    'createFragment',
    'deleteCaption',
    'deleteRow',
    'deleteTFoot',
    'deleteTHead',
    'caption',
    'tFoot',
    'tHead'
  ]);
  html$.TableElement = class TableElement extends html$.HtmlElement {
    get [dartx.tBodies]() {
      return new (_WrappedListOfTableSectionElement())(this[_tBodies]);
    }
    get [dartx.rows]() {
      return new (_WrappedListOfTableRowElement())(this[_rows]);
    }
    [dartx.addRow]() {
      return this[dartx.insertRow](-1);
    }
    [dartx.createCaption]() {
      return html$.TableCaptionElement._check(this[_createCaption]());
    }
    [dartx.createTBody]() {
      return this[_createTBody]();
    }
    [dartx.createTFoot]() {
      return html$.TableSectionElement._check(this[_createTFoot]());
    }
    [dartx.createTHead]() {
      return html$.TableSectionElement._check(this[_createTHead]());
    }
    [dartx.insertRow](index) {
      return html$.TableRowElement._check(this[_insertRow](index));
    }
    [_createTBody]() {
      if (!!this.createTBody) {
        return this[_nativeCreateTBody]();
      }
      let tbody = html$.Element.tag('tbody');
      this[dartx.children][dartx.add](tbody);
      return html$.TableSectionElement._check(tbody);
    }
    [_nativeCreateTBody]() {
      return this.createTBody();
    }
    [dartx.createFragment](html, opts) {
      let validator = opts && 'validator' in opts ? opts.validator : null;
      let treeSanitizer = opts && 'treeSanitizer' in opts ? opts.treeSanitizer : null;
      if (dart.test(html$.Range.supportsCreateContextualFragment)) {
        return super[dartx.createFragment](html, {validator: validator, treeSanitizer: treeSanitizer});
      }
      let contextualHtml = dart.str`<table>${html}</table>`;
      let table = html$.Element.html(contextualHtml, {validator: validator, treeSanitizer: treeSanitizer});
      let fragment = html$.DocumentFragment.new();
      fragment[dartx.nodes][dartx.addAll](table[dartx.nodes]);
      return fragment;
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return html$.TableElement._check(html$.document[dartx.createElement]("table"));
    }
    created() {
      this[dartx.caption] = null;
      this[_rows] = null;
      this[_tBodies] = null;
      this[dartx.tFoot] = null;
      this[dartx.tHead] = null;
      super.created();
    }
    get [dartx.caption]() {
      return this.caption;
    }
    set [dartx.caption](value) {
      this.caption = value;
    }
    get [_rows]() {
      return this.rows;
    }
    get [_tBodies]() {
      return this.tBodies;
    }
    get [dartx.tFoot]() {
      return this.tFoot;
    }
    set [dartx.tFoot](value) {
      this.tFoot = value;
    }
    get [dartx.tHead]() {
      return this.tHead;
    }
    set [dartx.tHead](value) {
      this.tHead = value;
    }
    [_createCaption]() {
      return this.createCaption();
    }
    [_createTFoot]() {
      return this.createTFoot();
    }
    [_createTHead]() {
      return this.createTHead();
    }
    [dartx.deleteCaption]() {
      return this.deleteCaption();
    }
    [dartx.deleteRow](index) {
      return this.deleteRow(index);
    }
    [dartx.deleteTFoot]() {
      return this.deleteTFoot();
    }
    [dartx.deleteTHead]() {
      return this.deleteTHead();
    }
    [_insertRow](index) {
      return this.insertRow(index);
    }
  };
  dart.defineNamedConstructor(html$.TableElement, 'created');
  dart.setSignature(html$.TableElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.TableElement, []),
      new: dart.definiteFunctionType(html$.TableElement, []),
      created: dart.definiteFunctionType(html$.TableElement, [])
    }),
    methods: () => ({
      [dartx.addRow]: dart.definiteFunctionType(html$.TableRowElement, []),
      [dartx.createCaption]: dart.definiteFunctionType(html$.TableCaptionElement, []),
      [dartx.createTBody]: dart.definiteFunctionType(html$.TableSectionElement, []),
      [dartx.createTFoot]: dart.definiteFunctionType(html$.TableSectionElement, []),
      [dartx.createTHead]: dart.definiteFunctionType(html$.TableSectionElement, []),
      [dartx.insertRow]: dart.definiteFunctionType(html$.TableRowElement, [core.int]),
      [_createTBody]: dart.definiteFunctionType(html$.TableSectionElement, []),
      [_nativeCreateTBody]: dart.definiteFunctionType(html$.TableSectionElement, []),
      [_createCaption]: dart.definiteFunctionType(html$.HtmlElement, []),
      [_createTFoot]: dart.definiteFunctionType(html$.HtmlElement, []),
      [_createTHead]: dart.definiteFunctionType(html$.HtmlElement, []),
      [dartx.deleteCaption]: dart.definiteFunctionType(dart.void, []),
      [dartx.deleteRow]: dart.definiteFunctionType(dart.void, [core.int]),
      [dartx.deleteTFoot]: dart.definiteFunctionType(dart.void, []),
      [dartx.deleteTHead]: dart.definiteFunctionType(dart.void, []),
      [_insertRow]: dart.definiteFunctionType(html$.HtmlElement, [], [core.int])
    })
  });
  dart.registerExtension(dart.global.HTMLTableElement, html$.TableElement);
  const _cells = Symbol('_cells');
  const _insertCell = Symbol('_insertCell');
  dart.defineExtensionNames([
    'cells',
    'addCell',
    'insertCell',
    'createFragment',
    'deleteCell',
    'rowIndex',
    'sectionRowIndex'
  ]);
  html$.TableRowElement = class TableRowElement extends html$.HtmlElement {
    get [dartx.cells]() {
      return new (_WrappedListOfTableCellElement())(this[_cells]);
    }
    [dartx.addCell]() {
      return this[dartx.insertCell](-1);
    }
    [dartx.insertCell](index) {
      return html$.TableCellElement._check(this[_insertCell](index));
    }
    [dartx.createFragment](html, opts) {
      let validator = opts && 'validator' in opts ? opts.validator : null;
      let treeSanitizer = opts && 'treeSanitizer' in opts ? opts.treeSanitizer : null;
      if (dart.test(html$.Range.supportsCreateContextualFragment)) {
        return super[dartx.createFragment](html, {validator: validator, treeSanitizer: treeSanitizer});
      }
      let fragment = html$.DocumentFragment.new();
      let section = html$.TableElement.new()[dartx.createFragment](html, {validator: validator, treeSanitizer: treeSanitizer})[dartx.nodes][dartx.single];
      let row = section[dartx.nodes][dartx.single];
      fragment[dartx.nodes][dartx.addAll](row[dartx.nodes]);
      return fragment;
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return html$.TableRowElement._check(html$.document[dartx.createElement]("tr"));
    }
    created() {
      this[_cells] = null;
      this[dartx.rowIndex] = null;
      this[dartx.sectionRowIndex] = null;
      super.created();
    }
    get [_cells]() {
      return this.cells;
    }
    get [dartx.rowIndex]() {
      return this.rowIndex;
    }
    get [dartx.sectionRowIndex]() {
      return this.sectionRowIndex;
    }
    [dartx.deleteCell](index) {
      return this.deleteCell(index);
    }
    [_insertCell](index) {
      return this.insertCell(index);
    }
  };
  dart.defineNamedConstructor(html$.TableRowElement, 'created');
  dart.setSignature(html$.TableRowElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.TableRowElement, []),
      new: dart.definiteFunctionType(html$.TableRowElement, []),
      created: dart.definiteFunctionType(html$.TableRowElement, [])
    }),
    methods: () => ({
      [dartx.addCell]: dart.definiteFunctionType(html$.TableCellElement, []),
      [dartx.insertCell]: dart.definiteFunctionType(html$.TableCellElement, [core.int]),
      [dartx.deleteCell]: dart.definiteFunctionType(dart.void, [core.int]),
      [_insertCell]: dart.definiteFunctionType(html$.HtmlElement, [], [core.int])
    })
  });
  dart.registerExtension(dart.global.HTMLTableRowElement, html$.TableRowElement);
  dart.defineExtensionNames([
    'rows',
    'addRow',
    'insertRow',
    'createFragment',
    'deleteRow'
  ]);
  html$.TableSectionElement = class TableSectionElement extends html$.HtmlElement {
    get [dartx.rows]() {
      return new (_WrappedListOfTableRowElement())(this[_rows]);
    }
    [dartx.addRow]() {
      return this[dartx.insertRow](-1);
    }
    [dartx.insertRow](index) {
      return html$.TableRowElement._check(this[_insertRow](index));
    }
    [dartx.createFragment](html, opts) {
      let validator = opts && 'validator' in opts ? opts.validator : null;
      let treeSanitizer = opts && 'treeSanitizer' in opts ? opts.treeSanitizer : null;
      if (dart.test(html$.Range.supportsCreateContextualFragment)) {
        return super[dartx.createFragment](html, {validator: validator, treeSanitizer: treeSanitizer});
      }
      let fragment = html$.DocumentFragment.new();
      let section = html$.TableElement.new()[dartx.createFragment](html, {validator: validator, treeSanitizer: treeSanitizer})[dartx.nodes][dartx.single];
      fragment[dartx.nodes][dartx.addAll](section[dartx.nodes]);
      return fragment;
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    created() {
      this[_rows] = null;
      super.created();
    }
    get [_rows]() {
      return this.rows;
    }
    [dartx.deleteRow](index) {
      return this.deleteRow(index);
    }
    [_insertRow](index) {
      return this.insertRow(index);
    }
  };
  dart.defineNamedConstructor(html$.TableSectionElement, 'created');
  dart.setSignature(html$.TableSectionElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.TableSectionElement, []),
      created: dart.definiteFunctionType(html$.TableSectionElement, [])
    }),
    methods: () => ({
      [dartx.addRow]: dart.definiteFunctionType(html$.TableRowElement, []),
      [dartx.insertRow]: dart.definiteFunctionType(html$.TableRowElement, [core.int]),
      [dartx.deleteRow]: dart.definiteFunctionType(dart.void, [core.int]),
      [_insertRow]: dart.definiteFunctionType(html$.HtmlElement, [], [core.int])
    })
  });
  dart.registerExtension(dart.global.HTMLTableSectionElement, html$.TableSectionElement);
  dart.defineExtensionNames([
    'setInnerHtml',
    'content'
  ]);
  html$.TemplateElement = class TemplateElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return html$.TemplateElement._check(html$.document[dartx.createElement]("template"));
    }
    created() {
      this[dartx.content] = null;
      super.created();
    }
    static get supported() {
      return html$.Element.isTagSupported('template');
    }
    get [dartx.content]() {
      return this.content;
    }
    [dartx.setInnerHtml](html, opts) {
      let validator = opts && 'validator' in opts ? opts.validator : null;
      let treeSanitizer = opts && 'treeSanitizer' in opts ? opts.treeSanitizer : null;
      this[dartx.text] = null;
      let fragment = this[dartx.createFragment](html, {validator: validator, treeSanitizer: treeSanitizer});
      this[dartx.content][dartx.append](fragment);
    }
  };
  dart.defineNamedConstructor(html$.TemplateElement, 'created');
  dart.setSignature(html$.TemplateElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.TemplateElement, []),
      new: dart.definiteFunctionType(html$.TemplateElement, []),
      created: dart.definiteFunctionType(html$.TemplateElement, [])
    })
  });
  dart.registerExtension(dart.global.HTMLTemplateElement, html$.TemplateElement);
  dart.defineExtensionNames([
    'checkValidity',
    'reportValidity',
    'select',
    'setCustomValidity',
    'setRangeText',
    'setSelectionRange',
    'autocapitalize',
    'autofocus',
    'cols',
    'defaultValue',
    'dirName',
    'disabled',
    'form',
    'inputMode',
    'labels',
    'maxLength',
    'minLength',
    'name',
    'placeholder',
    'readOnly',
    'required',
    'rows',
    'selectionDirection',
    'selectionEnd',
    'selectionStart',
    'textLength',
    'type',
    'validationMessage',
    'validity',
    'value',
    'willValidate',
    'wrap'
  ]);
  html$.TextAreaElement = class TextAreaElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return html$.TextAreaElement._check(html$.document[dartx.createElement]("textarea"));
    }
    created() {
      this[dartx.autocapitalize] = null;
      this[dartx.autofocus] = null;
      this[dartx.cols] = null;
      this[dartx.defaultValue] = null;
      this[dartx.dirName] = null;
      this[dartx.disabled] = null;
      this[dartx.form] = null;
      this[dartx.inputMode] = null;
      this[dartx.labels] = null;
      this[dartx.maxLength] = null;
      this[dartx.minLength] = null;
      this[dartx.name] = null;
      this[dartx.placeholder] = null;
      this[dartx.readOnly] = null;
      this[dartx.required] = null;
      this[dartx.rows] = null;
      this[dartx.selectionDirection] = null;
      this[dartx.selectionEnd] = null;
      this[dartx.selectionStart] = null;
      this[dartx.textLength] = null;
      this[dartx.type] = null;
      this[dartx.validationMessage] = null;
      this[dartx.validity] = null;
      this[dartx.value] = null;
      this[dartx.willValidate] = null;
      this[dartx.wrap] = null;
      super.created();
    }
    get [dartx.autocapitalize]() {
      return this.autocapitalize;
    }
    set [dartx.autocapitalize](value) {
      this.autocapitalize = value;
    }
    get [dartx.autofocus]() {
      return this.autofocus;
    }
    set [dartx.autofocus](value) {
      this.autofocus = value;
    }
    get [dartx.cols]() {
      return this.cols;
    }
    set [dartx.cols](value) {
      this.cols = value;
    }
    get [dartx.defaultValue]() {
      return this.defaultValue;
    }
    set [dartx.defaultValue](value) {
      this.defaultValue = value;
    }
    get [dartx.dirName]() {
      return this.dirName;
    }
    set [dartx.dirName](value) {
      this.dirName = value;
    }
    get [dartx.disabled]() {
      return this.disabled;
    }
    set [dartx.disabled](value) {
      this.disabled = value;
    }
    get [dartx.form]() {
      return this.form;
    }
    get [dartx.inputMode]() {
      return this.inputMode;
    }
    set [dartx.inputMode](value) {
      this.inputMode = value;
    }
    get [dartx.labels]() {
      return this.labels;
    }
    get [dartx.maxLength]() {
      return this.maxLength;
    }
    set [dartx.maxLength](value) {
      this.maxLength = value;
    }
    get [dartx.minLength]() {
      return this.minLength;
    }
    set [dartx.minLength](value) {
      this.minLength = value;
    }
    get [dartx.name]() {
      return this.name;
    }
    set [dartx.name](value) {
      this.name = value;
    }
    get [dartx.placeholder]() {
      return this.placeholder;
    }
    set [dartx.placeholder](value) {
      this.placeholder = value;
    }
    get [dartx.readOnly]() {
      return this.readOnly;
    }
    set [dartx.readOnly](value) {
      this.readOnly = value;
    }
    get [dartx.required]() {
      return this.required;
    }
    set [dartx.required](value) {
      this.required = value;
    }
    get [dartx.rows]() {
      return this.rows;
    }
    set [dartx.rows](value) {
      this.rows = value;
    }
    get [dartx.selectionDirection]() {
      return this.selectionDirection;
    }
    set [dartx.selectionDirection](value) {
      this.selectionDirection = value;
    }
    get [dartx.selectionEnd]() {
      return this.selectionEnd;
    }
    set [dartx.selectionEnd](value) {
      this.selectionEnd = value;
    }
    get [dartx.selectionStart]() {
      return this.selectionStart;
    }
    set [dartx.selectionStart](value) {
      this.selectionStart = value;
    }
    get [dartx.textLength]() {
      return this.textLength;
    }
    get [dartx.type]() {
      return this.type;
    }
    get [dartx.validationMessage]() {
      return this.validationMessage;
    }
    get [dartx.validity]() {
      return this.validity;
    }
    get [dartx.value]() {
      return this.value;
    }
    set [dartx.value](value) {
      this.value = value;
    }
    get [dartx.willValidate]() {
      return this.willValidate;
    }
    get [dartx.wrap]() {
      return this.wrap;
    }
    set [dartx.wrap](value) {
      this.wrap = value;
    }
    [dartx.checkValidity]() {
      return this.checkValidity();
    }
    [dartx.reportValidity]() {
      return this.reportValidity();
    }
    [dartx.select]() {
      return this.select();
    }
    [dartx.setCustomValidity](error) {
      return this.setCustomValidity(error);
    }
    [dartx.setRangeText](replacement, opts) {
      return this.setRangeText(replacement, opts);
    }
    [dartx.setSelectionRange](start, end, direction) {
      return this.setSelectionRange(start, end, direction);
    }
  };
  dart.defineNamedConstructor(html$.TextAreaElement, 'created');
  dart.setSignature(html$.TextAreaElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.TextAreaElement, []),
      new: dart.definiteFunctionType(html$.TextAreaElement, []),
      created: dart.definiteFunctionType(html$.TextAreaElement, [])
    }),
    methods: () => ({
      [dartx.checkValidity]: dart.definiteFunctionType(core.bool, []),
      [dartx.reportValidity]: dart.definiteFunctionType(core.bool, []),
      [dartx.select]: dart.definiteFunctionType(dart.void, []),
      [dartx.setCustomValidity]: dart.definiteFunctionType(dart.void, [core.String]),
      [dartx.setRangeText]: dart.definiteFunctionType(dart.void, [core.String], {start: core.int, end: core.int, selectionMode: core.String}),
      [dartx.setSelectionRange]: dart.definiteFunctionType(dart.void, [core.int, core.int], [core.String])
    })
  });
  dart.registerExtension(dart.global.HTMLTextAreaElement, html$.TextAreaElement);
  const _initTextEvent = Symbol('_initTextEvent');
  dart.defineExtensionNames([
    'data'
  ]);
  html$.TextEvent = class TextEvent extends html$.UIEvent {
    static new(type, opts) {
      let canBubble = opts && 'canBubble' in opts ? opts.canBubble : false;
      let cancelable = opts && 'cancelable' in opts ? opts.cancelable : false;
      let view = opts && 'view' in opts ? opts.view : null;
      let data = opts && 'data' in opts ? opts.data : null;
      if (view == null) {
        view = html$.window;
      }
      let e = html$.TextEvent._check(html$.document[_createEvent]("TextEvent"));
      e[_initTextEvent](type, canBubble, cancelable, view, data);
      return e;
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.data]() {
      return this.data;
    }
    [_initTextEvent](typeArg, canBubbleArg, cancelableArg, viewArg, dataArg) {
      return this.initTextEvent(typeArg, canBubbleArg, cancelableArg, viewArg, dataArg);
    }
  };
  dart.setSignature(html$.TextEvent, {
    constructors: () => ({
      new: dart.definiteFunctionType(html$.TextEvent, [core.String], {canBubble: core.bool, cancelable: core.bool, view: html$.Window, data: core.String}),
      _: dart.definiteFunctionType(html$.TextEvent, [])
    }),
    methods: () => ({[_initTextEvent]: dart.definiteFunctionType(dart.void, [core.String, core.bool, core.bool, html$.Window, core.String])})
  });
  dart.registerExtension(dart.global.TextEvent, html$.TextEvent);
  dart.defineExtensionNames([
    'actualBoundingBoxAscent',
    'actualBoundingBoxDescent',
    'actualBoundingBoxLeft',
    'actualBoundingBoxRight',
    'alphabeticBaseline',
    'emHeightAscent',
    'emHeightDescent',
    'fontBoundingBoxAscent',
    'fontBoundingBoxDescent',
    'hangingBaseline',
    'ideographicBaseline',
    'width'
  ]);
  html$.TextMetrics = class TextMetrics extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.actualBoundingBoxAscent]() {
      return this.actualBoundingBoxAscent;
    }
    get [dartx.actualBoundingBoxDescent]() {
      return this.actualBoundingBoxDescent;
    }
    get [dartx.actualBoundingBoxLeft]() {
      return this.actualBoundingBoxLeft;
    }
    get [dartx.actualBoundingBoxRight]() {
      return this.actualBoundingBoxRight;
    }
    get [dartx.alphabeticBaseline]() {
      return this.alphabeticBaseline;
    }
    get [dartx.emHeightAscent]() {
      return this.emHeightAscent;
    }
    get [dartx.emHeightDescent]() {
      return this.emHeightDescent;
    }
    get [dartx.fontBoundingBoxAscent]() {
      return this.fontBoundingBoxAscent;
    }
    get [dartx.fontBoundingBoxDescent]() {
      return this.fontBoundingBoxDescent;
    }
    get [dartx.hangingBaseline]() {
      return this.hangingBaseline;
    }
    get [dartx.ideographicBaseline]() {
      return this.ideographicBaseline;
    }
    get [dartx.width]() {
      return this.width;
    }
  };
  dart.setSignature(html$.TextMetrics, {
    constructors: () => ({_: dart.definiteFunctionType(html$.TextMetrics, [])})
  });
  dart.registerExtension(dart.global.TextMetrics, html$.TextMetrics);
  dart.defineExtensionNames([
    'addCue',
    'addRegion',
    'removeCue',
    'removeRegion',
    'onCueChange',
    'activeCues',
    'cues',
    'id',
    'kind',
    'label',
    'language',
    'mode',
    'regions'
  ]);
  html$.TextTrack = class TextTrack extends html$.EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.activeCues]() {
      return this.activeCues;
    }
    get [dartx.cues]() {
      return this.cues;
    }
    get [dartx.id]() {
      return this.id;
    }
    get [dartx.kind]() {
      return this.kind;
    }
    get [dartx.label]() {
      return this.label;
    }
    get [dartx.language]() {
      return this.language;
    }
    get [dartx.mode]() {
      return this.mode;
    }
    set [dartx.mode](value) {
      this.mode = value;
    }
    get [dartx.regions]() {
      return this.regions;
    }
    [dartx.addCue](cue) {
      return this.addCue(cue);
    }
    [dartx.addRegion](region) {
      return this.addRegion(region);
    }
    [dartx.removeCue](cue) {
      return this.removeCue(cue);
    }
    [dartx.removeRegion](region) {
      return this.removeRegion(region);
    }
    get [dartx.onCueChange]() {
      return html$.TextTrack.cueChangeEvent.forTarget(this);
    }
  };
  dart.setSignature(html$.TextTrack, {
    constructors: () => ({_: dart.definiteFunctionType(html$.TextTrack, [])}),
    methods: () => ({
      [dartx.addCue]: dart.definiteFunctionType(dart.void, [html$.TextTrackCue]),
      [dartx.addRegion]: dart.definiteFunctionType(dart.void, [html$.VttRegion]),
      [dartx.removeCue]: dart.definiteFunctionType(dart.void, [html$.TextTrackCue]),
      [dartx.removeRegion]: dart.definiteFunctionType(dart.void, [html$.VttRegion])
    })
  });
  dart.defineLazy(html$.TextTrack, {
    get cueChangeEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('cuechange'));
    }
  });
  dart.registerExtension(dart.global.TextTrack, html$.TextTrack);
  dart.defineExtensionNames([
    'onEnter',
    'onExit',
    'endTime',
    'id',
    'pauseOnExit',
    'startTime',
    'track'
  ]);
  html$.TextTrackCue = class TextTrackCue extends html$.EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.endTime]() {
      return this.endTime;
    }
    set [dartx.endTime](value) {
      this.endTime = value;
    }
    get [dartx.id]() {
      return this.id;
    }
    set [dartx.id](value) {
      this.id = value;
    }
    get [dartx.pauseOnExit]() {
      return this.pauseOnExit;
    }
    set [dartx.pauseOnExit](value) {
      this.pauseOnExit = value;
    }
    get [dartx.startTime]() {
      return this.startTime;
    }
    set [dartx.startTime](value) {
      this.startTime = value;
    }
    get [dartx.track]() {
      return this.track;
    }
    get [dartx.onEnter]() {
      return html$.TextTrackCue.enterEvent.forTarget(this);
    }
    get [dartx.onExit]() {
      return html$.TextTrackCue.exitEvent.forTarget(this);
    }
  };
  dart.setSignature(html$.TextTrackCue, {
    constructors: () => ({_: dart.definiteFunctionType(html$.TextTrackCue, [])})
  });
  dart.defineLazy(html$.TextTrackCue, {
    get enterEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('enter'));
    },
    get exitEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('exit'));
    }
  });
  dart.registerExtension(dart.global.TextTrackCue, html$.TextTrackCue);
  dart.defineExtensionNames([
    'length',
    'get',
    'set',
    'length',
    'first',
    'last',
    'single',
    'elementAt',
    'getCueById',
    'item'
  ]);
  html$.TextTrackCueList = class TextTrackCueList extends dart.mixin(_interceptors.Interceptor, collection.ListMixin$(html$.TextTrackCue), html$.ImmutableListMixin$(html$.TextTrackCue)) {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.length]() {
      return this.length;
    }
    [dartx.get](index) {
      if (index >>> 0 !== index || index >= this[dartx.length]) dart.throw(core.RangeError.index(index, this));
      return this[index];
    }
    [dartx.set](index, value) {
      dart.throw(new core.UnsupportedError("Cannot assign element of immutable List."));
      return value;
    }
    set [dartx.length](value) {
      dart.throw(new core.UnsupportedError("Cannot resize immutable List."));
    }
    get [dartx.first]() {
      if (dart.notNull(this[dartx.length]) > 0) {
        return this[0];
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.last]() {
      let len = this[dartx.length];
      if (dart.notNull(len) > 0) {
        return this[dart.notNull(len) - 1];
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.single]() {
      let len = this[dartx.length];
      if (len == 1) {
        return this[0];
      }
      if (len == 0) dart.throw(new core.StateError("No elements"));
      dart.throw(new core.StateError("More than one element"));
    }
    [dartx.elementAt](index) {
      return this[dartx.get](index);
    }
    [dartx.getCueById](id) {
      return this.getCueById(id);
    }
    [dartx.item](index) {
      return this.item(index);
    }
  };
  html$.TextTrackCueList[dart.implements] = () => [ListOfTextTrackCue(), _js_helper.JavaScriptIndexingBehavior];
  dart.setSignature(html$.TextTrackCueList, {
    constructors: () => ({_: dart.definiteFunctionType(html$.TextTrackCueList, [])}),
    methods: () => ({
      [dartx.get]: dart.definiteFunctionType(html$.TextTrackCue, [core.int]),
      [dartx.set]: dart.definiteFunctionType(dart.void, [core.int, html$.TextTrackCue]),
      [dartx.elementAt]: dart.definiteFunctionType(html$.TextTrackCue, [core.int]),
      [dartx.getCueById]: dart.definiteFunctionType(html$.TextTrackCue, [core.String]),
      [dartx.item]: dart.definiteFunctionType(html$.TextTrackCue, [core.int])
    })
  });
  dart.registerExtension(dart.global.TextTrackCueList, html$.TextTrackCueList);
  dart.defineExtensionNames([
    'length',
    'get',
    'set',
    'length',
    'first',
    'last',
    'single',
    'elementAt',
    'getTrackById',
    'item',
    'onAddTrack',
    'onChange'
  ]);
  html$.TextTrackList = class TextTrackList extends dart.mixin(html$.EventTarget, collection.ListMixin$(html$.TextTrack), html$.ImmutableListMixin$(html$.TextTrack)) {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.length]() {
      return this.length;
    }
    [dartx.get](index) {
      if (index >>> 0 !== index || index >= this[dartx.length]) dart.throw(core.RangeError.index(index, this));
      return this[index];
    }
    [dartx.set](index, value) {
      dart.throw(new core.UnsupportedError("Cannot assign element of immutable List."));
      return value;
    }
    set [dartx.length](value) {
      dart.throw(new core.UnsupportedError("Cannot resize immutable List."));
    }
    get [dartx.first]() {
      if (dart.notNull(this[dartx.length]) > 0) {
        return this[0];
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.last]() {
      let len = this[dartx.length];
      if (dart.notNull(len) > 0) {
        return this[dart.notNull(len) - 1];
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.single]() {
      let len = this[dartx.length];
      if (len == 1) {
        return this[0];
      }
      if (len == 0) dart.throw(new core.StateError("No elements"));
      dart.throw(new core.StateError("More than one element"));
    }
    [dartx.elementAt](index) {
      return this[dartx.get](index);
    }
    [dartx.getTrackById](id) {
      return this.getTrackById(id);
    }
    [dartx.item](index) {
      return this.item(index);
    }
    get [dartx.onAddTrack]() {
      return html$.TextTrackList.addTrackEvent.forTarget(this);
    }
    get [dartx.onChange]() {
      return html$.TextTrackList.changeEvent.forTarget(this);
    }
  };
  html$.TextTrackList[dart.implements] = () => [_js_helper.JavaScriptIndexingBehavior, ListOfTextTrack()];
  dart.setSignature(html$.TextTrackList, {
    constructors: () => ({_: dart.definiteFunctionType(html$.TextTrackList, [])}),
    methods: () => ({
      [dartx.get]: dart.definiteFunctionType(html$.TextTrack, [core.int]),
      [dartx.set]: dart.definiteFunctionType(dart.void, [core.int, html$.TextTrack]),
      [dartx.elementAt]: dart.definiteFunctionType(html$.TextTrack, [core.int]),
      [dartx.getTrackById]: dart.definiteFunctionType(html$.TextTrack, [core.String]),
      [dartx.item]: dart.definiteFunctionType(html$.TextTrack, [core.int])
    })
  });
  dart.defineLazy(html$.TextTrackList, {
    get addTrackEvent() {
      return dart.const(new (EventStreamProviderOfTrackEvent())('addtrack'));
    },
    get changeEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('change'));
    }
  });
  dart.registerExtension(dart.global.TextTrackList, html$.TextTrackList);
  dart.defineExtensionNames([
    'end',
    'start',
    'length'
  ]);
  html$.TimeRanges = class TimeRanges extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.length]() {
      return this.length;
    }
    [dartx.end](index) {
      return this.end(index);
    }
    [dartx.start](index) {
      return this.start(index);
    }
  };
  dart.setSignature(html$.TimeRanges, {
    constructors: () => ({_: dart.definiteFunctionType(html$.TimeRanges, [])}),
    methods: () => ({
      [dartx.end]: dart.definiteFunctionType(core.double, [core.int]),
      [dartx.start]: dart.definiteFunctionType(core.double, [core.int])
    })
  });
  dart.registerExtension(dart.global.TimeRanges, html$.TimeRanges);
  html$.TimeoutHandler = dart.typedef('TimeoutHandler', () => dart.functionType(dart.void, []));
  html$.TitleElement = class TitleElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return html$.TitleElement._check(html$.document[dartx.createElement]("title"));
    }
    created() {
      super.created();
    }
  };
  dart.defineNamedConstructor(html$.TitleElement, 'created');
  dart.setSignature(html$.TitleElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.TitleElement, []),
      new: dart.definiteFunctionType(html$.TitleElement, []),
      created: dart.definiteFunctionType(html$.TitleElement, [])
    })
  });
  dart.registerExtension(dart.global.HTMLTitleElement, html$.TitleElement);
  const _radiusX = Symbol('_radiusX');
  const _radiusY = Symbol('_radiusY');
  const __clientX = Symbol('__clientX');
  const __clientY = Symbol('__clientY');
  const __screenX = Symbol('__screenX');
  const __screenY = Symbol('__screenY');
  const __pageX = Symbol('__pageX');
  const __pageY = Symbol('__pageY');
  const __radiusX = Symbol('__radiusX');
  const __radiusY = Symbol('__radiusY');
  dart.defineExtensionNames([
    'target',
    'client',
    'page',
    'screen',
    'radiusX',
    'radiusY',
    'force',
    'identifier',
    'rotationAngle'
  ]);
  html$.Touch = class Touch extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [_clientX]() {
      return this.clientX;
    }
    get [_clientY]() {
      return this.clientY;
    }
    get [dartx.force]() {
      return this.force;
    }
    get [dartx.identifier]() {
      return this.identifier;
    }
    get [_pageX]() {
      return this.pageX;
    }
    get [_pageY]() {
      return this.pageY;
    }
    get [_radiusX]() {
      return this.radiusX;
    }
    get [_radiusY]() {
      return this.radiusY;
    }
    get [dartx.rotationAngle]() {
      return this.rotationAngle;
    }
    get [_screenX]() {
      return this.screenX;
    }
    get [_screenY]() {
      return this.screenY;
    }
    get [dartx.target]() {
      return html$._convertNativeToDart_EventTarget(this[_get_target]);
    }
    get [_get_target]() {
      return this.target;
    }
    get [__clientX]() {
      return this.clientX[dartx.round]();
    }
    get [__clientY]() {
      return this.clientY[dartx.round]();
    }
    get [__screenX]() {
      return this.screenX[dartx.round]();
    }
    get [__screenY]() {
      return this.screenY[dartx.round]();
    }
    get [__pageX]() {
      return this.pageX[dartx.round]();
    }
    get [__pageY]() {
      return this.pageY[dartx.round]();
    }
    get [__radiusX]() {
      return this.radiusX[dartx.round]();
    }
    get [__radiusY]() {
      return this.radiusY[dartx.round]();
    }
    get [dartx.client]() {
      return new (PointOfnum())(this[__clientX], this[__clientY]);
    }
    get [dartx.page]() {
      return new (PointOfnum())(this[__pageX], this[__pageY]);
    }
    get [dartx.screen]() {
      return new (PointOfnum())(this[__screenX], this[__screenY]);
    }
    get [dartx.radiusX]() {
      return this[__radiusX];
    }
    get [dartx.radiusY]() {
      return this[__radiusY];
    }
  };
  dart.setSignature(html$.Touch, {
    constructors: () => ({_: dart.definiteFunctionType(html$.Touch, [])})
  });
  dart.registerExtension(dart.global.Touch, html$.Touch);
  const _initTouchEvent = Symbol('_initTouchEvent');
  dart.defineExtensionNames([
    'altKey',
    'changedTouches',
    'ctrlKey',
    'metaKey',
    'shiftKey',
    'targetTouches',
    'touches'
  ]);
  html$.TouchEvent = class TouchEvent extends html$.UIEvent {
    static new(touches, targetTouches, changedTouches, type, opts) {
      let view = opts && 'view' in opts ? opts.view : null;
      let screenX = opts && 'screenX' in opts ? opts.screenX : 0;
      let screenY = opts && 'screenY' in opts ? opts.screenY : 0;
      let clientX = opts && 'clientX' in opts ? opts.clientX : 0;
      let clientY = opts && 'clientY' in opts ? opts.clientY : 0;
      let ctrlKey = opts && 'ctrlKey' in opts ? opts.ctrlKey : false;
      let altKey = opts && 'altKey' in opts ? opts.altKey : false;
      let shiftKey = opts && 'shiftKey' in opts ? opts.shiftKey : false;
      let metaKey = opts && 'metaKey' in opts ? opts.metaKey : false;
      if (view == null) {
        view = html$.window;
      }
      let e = html$.TouchEvent._check(html$.document[_createEvent]("TouchEvent"));
      e[_initTouchEvent](touches, targetTouches, changedTouches, type, view, screenX, screenY, clientX, clientY, ctrlKey, altKey, shiftKey, metaKey);
      return e;
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.altKey]() {
      return this.altKey;
    }
    get [dartx.changedTouches]() {
      return this.changedTouches;
    }
    get [dartx.ctrlKey]() {
      return this.ctrlKey;
    }
    get [dartx.metaKey]() {
      return this.metaKey;
    }
    get [dartx.shiftKey]() {
      return this.shiftKey;
    }
    get [dartx.targetTouches]() {
      return this.targetTouches;
    }
    get [dartx.touches]() {
      return this.touches;
    }
    [_initTouchEvent](touches, targetTouches, changedTouches, type, view, unused1, unused2, unused3, unused4, ctrlKey, altKey, shiftKey, metaKey) {
      return this.initTouchEvent(touches, targetTouches, changedTouches, type, view, unused1, unused2, unused3, unused4, ctrlKey, altKey, shiftKey, metaKey);
    }
    static get supported() {
      return html_common.Device.isEventTypeSupported('TouchEvent');
    }
  };
  dart.setSignature(html$.TouchEvent, {
    constructors: () => ({
      new: dart.definiteFunctionType(html$.TouchEvent, [html$.TouchList, html$.TouchList, html$.TouchList, core.String], {view: html$.Window, screenX: core.int, screenY: core.int, clientX: core.int, clientY: core.int, ctrlKey: core.bool, altKey: core.bool, shiftKey: core.bool, metaKey: core.bool}),
      _: dart.definiteFunctionType(html$.TouchEvent, [])
    }),
    methods: () => ({[_initTouchEvent]: dart.definiteFunctionType(dart.void, [html$.TouchList, html$.TouchList, html$.TouchList, core.String, html$.Window, core.int, core.int, core.int, core.int, core.bool, core.bool, core.bool, core.bool])})
  });
  dart.registerExtension(dart.global.TouchEvent, html$.TouchEvent);
  dart.defineExtensionNames([
    'length',
    'get',
    'set',
    'length',
    'first',
    'last',
    'single',
    'elementAt',
    'item'
  ]);
  html$.TouchList = class TouchList extends dart.mixin(_interceptors.Interceptor, collection.ListMixin$(html$.Touch), html$.ImmutableListMixin$(html$.Touch)) {
    static new() {
      return null;
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static get supported() {
      return !!document.createTouchList;
    }
    get [dartx.length]() {
      return this.length;
    }
    [dartx.get](index) {
      if (index >>> 0 !== index || index >= this[dartx.length]) dart.throw(core.RangeError.index(index, this));
      return this[index];
    }
    [dartx.set](index, value) {
      dart.throw(new core.UnsupportedError("Cannot assign element of immutable List."));
      return value;
    }
    set [dartx.length](value) {
      dart.throw(new core.UnsupportedError("Cannot resize immutable List."));
    }
    get [dartx.first]() {
      if (dart.notNull(this[dartx.length]) > 0) {
        return this[0];
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.last]() {
      let len = this[dartx.length];
      if (dart.notNull(len) > 0) {
        return this[dart.notNull(len) - 1];
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.single]() {
      let len = this[dartx.length];
      if (len == 1) {
        return this[0];
      }
      if (len == 0) dart.throw(new core.StateError("No elements"));
      dart.throw(new core.StateError("More than one element"));
    }
    [dartx.elementAt](index) {
      return this[dartx.get](index);
    }
    [dartx.item](index) {
      return this.item(index);
    }
  };
  html$.TouchList[dart.implements] = () => [_js_helper.JavaScriptIndexingBehavior, ListOfTouch()];
  dart.setSignature(html$.TouchList, {
    constructors: () => ({
      new: dart.definiteFunctionType(html$.TouchList, []),
      _: dart.definiteFunctionType(html$.TouchList, [])
    }),
    methods: () => ({
      [dartx.get]: dart.definiteFunctionType(html$.Touch, [core.int]),
      [dartx.set]: dart.definiteFunctionType(dart.void, [core.int, html$.Touch]),
      [dartx.elementAt]: dart.definiteFunctionType(html$.Touch, [core.int]),
      [dartx.item]: dart.definiteFunctionType(html$.Touch, [core.int])
    })
  });
  dart.registerExtension(dart.global.TouchList, html$.TouchList);
  dart.defineExtensionNames([
    'byteStreamTrackID',
    'kinds',
    'label',
    'language',
    'type'
  ]);
  html$.TrackDefault = class TrackDefault extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(type, language, label, kinds, byteStreamTrackID) {
      if (byteStreamTrackID === void 0) byteStreamTrackID = null;
      if (byteStreamTrackID != null) {
        let kinds_1 = html_common.convertDartToNative_StringArray(kinds);
        return html$.TrackDefault._create_1(type, language, label, kinds_1, byteStreamTrackID);
      }
      let kinds_1 = html_common.convertDartToNative_StringArray(kinds);
      return html$.TrackDefault._create_2(type, language, label, kinds_1);
    }
    static _create_1(type, language, label, kinds, byteStreamTrackID) {
      return new TrackDefault(type, language, label, kinds, byteStreamTrackID);
    }
    static _create_2(type, language, label, kinds) {
      return new TrackDefault(type, language, label, kinds);
    }
    get [dartx.byteStreamTrackID]() {
      return this.byteStreamTrackID;
    }
    get [dartx.kinds]() {
      return this.kinds;
    }
    get [dartx.label]() {
      return this.label;
    }
    get [dartx.language]() {
      return this.language;
    }
    get [dartx.type]() {
      return this.type;
    }
  };
  dart.setSignature(html$.TrackDefault, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.TrackDefault, []),
      new: dart.definiteFunctionType(html$.TrackDefault, [core.String, core.String, core.String, core.List$(core.String)], [core.String])
    }),
    statics: () => ({
      _create_1: dart.definiteFunctionType(html$.TrackDefault, [dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic]),
      _create_2: dart.definiteFunctionType(html$.TrackDefault, [dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic])
    }),
    names: ['_create_1', '_create_2']
  });
  dart.registerExtension(dart.global.TrackDefault, html$.TrackDefault);
  dart.defineExtensionNames([
    'item',
    'length'
  ]);
  html$.TrackDefaultList = class TrackDefaultList extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(trackDefaults) {
      if (trackDefaults === void 0) trackDefaults = null;
      if (trackDefaults != null) {
        return html$.TrackDefaultList._create_1(trackDefaults);
      }
      return html$.TrackDefaultList._create_2();
    }
    static _create_1(trackDefaults) {
      return new TrackDefaultList(trackDefaults);
    }
    static _create_2() {
      return new TrackDefaultList();
    }
    get [dartx.length]() {
      return this.length;
    }
    [dartx.item](index) {
      return this.item(index);
    }
  };
  dart.setSignature(html$.TrackDefaultList, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.TrackDefaultList, []),
      new: dart.definiteFunctionType(html$.TrackDefaultList, [], [core.List$(html$.TrackDefault)])
    }),
    methods: () => ({[dartx.item]: dart.definiteFunctionType(html$.TrackDefault, [core.int])}),
    statics: () => ({
      _create_1: dart.definiteFunctionType(html$.TrackDefaultList, [dart.dynamic]),
      _create_2: dart.definiteFunctionType(html$.TrackDefaultList, [])
    }),
    names: ['_create_1', '_create_2']
  });
  dart.registerExtension(dart.global.TrackDefaultList, html$.TrackDefaultList);
  dart.defineExtensionNames([
    'defaultValue',
    'kind',
    'label',
    'readyState',
    'src',
    'srclang',
    'track'
  ]);
  html$.TrackElement = class TrackElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return html$.TrackElement._check(html$.document[dartx.createElement]("track"));
    }
    created() {
      this[dartx.defaultValue] = null;
      this[dartx.kind] = null;
      this[dartx.label] = null;
      this[dartx.readyState] = null;
      this[dartx.src] = null;
      this[dartx.srclang] = null;
      this[dartx.track] = null;
      super.created();
    }
    static get supported() {
      return html$.Element.isTagSupported('track');
    }
    get [dartx.defaultValue]() {
      return this.default;
    }
    set [dartx.defaultValue](value) {
      this.default = value;
    }
    get [dartx.kind]() {
      return this.kind;
    }
    set [dartx.kind](value) {
      this.kind = value;
    }
    get [dartx.label]() {
      return this.label;
    }
    set [dartx.label](value) {
      this.label = value;
    }
    get [dartx.readyState]() {
      return this.readyState;
    }
    get [dartx.src]() {
      return this.src;
    }
    set [dartx.src](value) {
      this.src = value;
    }
    get [dartx.srclang]() {
      return this.srclang;
    }
    set [dartx.srclang](value) {
      this.srclang = value;
    }
    get [dartx.track]() {
      return this.track;
    }
  };
  dart.defineNamedConstructor(html$.TrackElement, 'created');
  dart.setSignature(html$.TrackElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.TrackElement, []),
      new: dart.definiteFunctionType(html$.TrackElement, []),
      created: dart.definiteFunctionType(html$.TrackElement, [])
    })
  });
  html$.TrackElement.ERROR = 3;
  html$.TrackElement.LOADED = 2;
  html$.TrackElement.LOADING = 1;
  html$.TrackElement.NONE = 0;
  dart.registerExtension(dart.global.HTMLTrackElement, html$.TrackElement);
  dart.defineExtensionNames([
    'track'
  ]);
  html$.TrackEvent = class TrackEvent extends html$.Event {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(type, eventInitDict) {
      if (eventInitDict === void 0) eventInitDict = null;
      if (eventInitDict != null) {
        let eventInitDict_1 = html_common.convertDartToNative_Dictionary(eventInitDict);
        return html$.TrackEvent._create_1(type, eventInitDict_1);
      }
      return html$.TrackEvent._create_2(type);
    }
    static _create_1(type, eventInitDict) {
      return new TrackEvent(type, eventInitDict);
    }
    static _create_2(type) {
      return new TrackEvent(type);
    }
    get [dartx.track]() {
      return this.track;
    }
  };
  dart.setSignature(html$.TrackEvent, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.TrackEvent, []),
      new: dart.definiteFunctionType(html$.TrackEvent, [core.String], [core.Map])
    }),
    statics: () => ({
      _create_1: dart.definiteFunctionType(html$.TrackEvent, [dart.dynamic, dart.dynamic]),
      _create_2: dart.definiteFunctionType(html$.TrackEvent, [dart.dynamic])
    }),
    names: ['_create_1', '_create_2']
  });
  dart.registerExtension(dart.global.TrackEvent, html$.TrackEvent);
  dart.defineExtensionNames([
    'elapsedTime',
    'propertyName',
    'pseudoElement'
  ]);
  html$.TransitionEvent = class TransitionEvent extends html$.Event {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(type, eventInitDict) {
      if (eventInitDict === void 0) eventInitDict = null;
      if (eventInitDict != null) {
        let eventInitDict_1 = html_common.convertDartToNative_Dictionary(eventInitDict);
        return html$.TransitionEvent._create_1(type, eventInitDict_1);
      }
      return html$.TransitionEvent._create_2(type);
    }
    static _create_1(type, eventInitDict) {
      return new TransitionEvent(type, eventInitDict);
    }
    static _create_2(type) {
      return new TransitionEvent(type);
    }
    get [dartx.elapsedTime]() {
      return this.elapsedTime;
    }
    get [dartx.propertyName]() {
      return this.propertyName;
    }
    get [dartx.pseudoElement]() {
      return this.pseudoElement;
    }
  };
  dart.setSignature(html$.TransitionEvent, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.TransitionEvent, []),
      new: dart.definiteFunctionType(html$.TransitionEvent, [core.String], [core.Map])
    }),
    statics: () => ({
      _create_1: dart.definiteFunctionType(html$.TransitionEvent, [dart.dynamic, dart.dynamic]),
      _create_2: dart.definiteFunctionType(html$.TransitionEvent, [dart.dynamic])
    }),
    names: ['_create_1', '_create_2']
  });
  dart.registerExtension(dart.global.TransitionEvent, html$.TransitionEvent);
  dart.defineExtensionNames([
    'firstChild',
    'lastChild',
    'nextNode',
    'nextSibling',
    'parentNode',
    'previousNode',
    'previousSibling',
    'currentNode',
    'filter',
    'root',
    'whatToShow'
  ]);
  html$.TreeWalker = class TreeWalker extends _interceptors.Interceptor {
    static new(root, whatToShow) {
      return html$.document[_createTreeWalker](root, whatToShow, null);
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.currentNode]() {
      return this.currentNode;
    }
    set [dartx.currentNode](value) {
      this.currentNode = value;
    }
    get [dartx.filter]() {
      return this.filter;
    }
    get [dartx.root]() {
      return this.root;
    }
    get [dartx.whatToShow]() {
      return this.whatToShow;
    }
    [dartx.firstChild]() {
      return this.firstChild();
    }
    [dartx.lastChild]() {
      return this.lastChild();
    }
    [dartx.nextNode]() {
      return this.nextNode();
    }
    [dartx.nextSibling]() {
      return this.nextSibling();
    }
    [dartx.parentNode]() {
      return this.parentNode();
    }
    [dartx.previousNode]() {
      return this.previousNode();
    }
    [dartx.previousSibling]() {
      return this.previousSibling();
    }
  };
  dart.setSignature(html$.TreeWalker, {
    constructors: () => ({
      new: dart.definiteFunctionType(html$.TreeWalker, [html$.Node, core.int]),
      _: dart.definiteFunctionType(html$.TreeWalker, [])
    }),
    methods: () => ({
      [dartx.firstChild]: dart.definiteFunctionType(html$.Node, []),
      [dartx.lastChild]: dart.definiteFunctionType(html$.Node, []),
      [dartx.nextNode]: dart.definiteFunctionType(html$.Node, []),
      [dartx.nextSibling]: dart.definiteFunctionType(html$.Node, []),
      [dartx.parentNode]: dart.definiteFunctionType(html$.Node, []),
      [dartx.previousNode]: dart.definiteFunctionType(html$.Node, []),
      [dartx.previousSibling]: dart.definiteFunctionType(html$.Node, [])
    })
  });
  dart.registerExtension(dart.global.TreeWalker, html$.TreeWalker);
  html$.UListElement = class UListElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return html$.UListElement._check(html$.document[dartx.createElement]("ul"));
    }
    created() {
      super.created();
    }
  };
  dart.defineNamedConstructor(html$.UListElement, 'created');
  dart.setSignature(html$.UListElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.UListElement, []),
      new: dart.definiteFunctionType(html$.UListElement, []),
      created: dart.definiteFunctionType(html$.UListElement, [])
    })
  });
  dart.registerExtension(dart.global.HTMLUListElement, html$.UListElement);
  html$.UnknownElement = class UnknownElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    created() {
      super.created();
    }
  };
  dart.defineNamedConstructor(html$.UnknownElement, 'created');
  dart.setSignature(html$.UnknownElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.UnknownElement, []),
      created: dart.definiteFunctionType(html$.UnknownElement, [])
    })
  });
  dart.registerExtension(dart.global.HTMLUnknownElement, html$.UnknownElement);
  dart.defineExtensionNames([
    'toString',
    'hash',
    'host',
    'hostname',
    'href',
    'origin',
    'password',
    'pathname',
    'port',
    'protocol',
    'search',
    'username'
  ]);
  html$.Url = class Url extends _interceptors.Interceptor {
    static createObjectUrl(blob_OR_source_OR_stream) {
      return (self.URL || self.webkitURL).createObjectURL(blob_OR_source_OR_stream);
    }
    static createObjectUrlFromSource(source) {
      return (self.URL || self.webkitURL).createObjectURL(source);
    }
    static createObjectUrlFromStream(stream) {
      return (self.URL || self.webkitURL).createObjectURL(stream);
    }
    static createObjectUrlFromBlob(blob) {
      return (self.URL || self.webkitURL).createObjectURL(blob);
    }
    static revokeObjectUrl(url) {
      return (self.URL || self.webkitURL).revokeObjectURL(url);
    }
    [dartx.toString]() {
      return String(this);
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.hash]() {
      return this.hash;
    }
    set [dartx.hash](value) {
      this.hash = value;
    }
    get [dartx.host]() {
      return this.host;
    }
    set [dartx.host](value) {
      this.host = value;
    }
    get [dartx.hostname]() {
      return this.hostname;
    }
    set [dartx.hostname](value) {
      this.hostname = value;
    }
    get [dartx.href]() {
      return this.href;
    }
    set [dartx.href](value) {
      this.href = value;
    }
    get [dartx.origin]() {
      return this.origin;
    }
    get [dartx.password]() {
      return this.password;
    }
    set [dartx.password](value) {
      this.password = value;
    }
    get [dartx.pathname]() {
      return this.pathname;
    }
    set [dartx.pathname](value) {
      this.pathname = value;
    }
    get [dartx.port]() {
      return this.port;
    }
    set [dartx.port](value) {
      this.port = value;
    }
    get [dartx.protocol]() {
      return this.protocol;
    }
    set [dartx.protocol](value) {
      this.protocol = value;
    }
    get [dartx.search]() {
      return this.search;
    }
    set [dartx.search](value) {
      this.search = value;
    }
    get [dartx.username]() {
      return this.username;
    }
    set [dartx.username](value) {
      this.username = value;
    }
  };
  html$.Url[dart.implements] = () => [html$.UrlUtils];
  dart.setSignature(html$.Url, {
    constructors: () => ({_: dart.definiteFunctionType(html$.Url, [])}),
    statics: () => ({
      createObjectUrl: dart.definiteFunctionType(core.String, [dart.dynamic]),
      createObjectUrlFromSource: dart.definiteFunctionType(core.String, [html$.MediaSource]),
      createObjectUrlFromStream: dart.definiteFunctionType(core.String, [html$.MediaStream]),
      createObjectUrlFromBlob: dart.definiteFunctionType(core.String, [html$.Blob]),
      revokeObjectUrl: dart.definiteFunctionType(dart.void, [core.String])
    }),
    names: ['createObjectUrl', 'createObjectUrlFromSource', 'createObjectUrlFromStream', 'createObjectUrlFromBlob', 'revokeObjectUrl']
  });
  dart.registerExtension(dart.global.URL, html$.Url);
  dart.defineExtensionNames([
    'hash',
    'host',
    'hostname',
    'href',
    'origin',
    'password',
    'pathname',
    'port',
    'protocol',
    'search',
    'username'
  ]);
  html$.UrlUtils = class UrlUtils extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(html$.UrlUtils, {
    constructors: () => ({_: dart.definiteFunctionType(html$.UrlUtils, [])})
  });
  dart.defineExtensionMembers(html$.UrlUtils, [
    'hash',
    'hash',
    'host',
    'host',
    'hostname',
    'hostname',
    'href',
    'href',
    'origin',
    'password',
    'password',
    'pathname',
    'pathname',
    'port',
    'port',
    'protocol',
    'protocol',
    'search',
    'search',
    'username',
    'username'
  ]);
  dart.defineExtensionNames([
    'hash',
    'host',
    'hostname',
    'href',
    'origin',
    'pathname',
    'port',
    'protocol',
    'search'
  ]);
  html$.UrlUtilsReadOnly = class UrlUtilsReadOnly extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(html$.UrlUtilsReadOnly, {
    constructors: () => ({_: dart.definiteFunctionType(html$.UrlUtilsReadOnly, [])})
  });
  dart.defineExtensionMembers(html$.UrlUtilsReadOnly, [
    'hash',
    'host',
    'hostname',
    'href',
    'origin',
    'pathname',
    'port',
    'protocol',
    'search'
  ]);
  dart.defineExtensionNames([
    'currentFieldOfView',
    'eyeTranslation',
    'maximumFieldOfView',
    'minimumFieldOfView',
    'recommendedFieldOfView',
    'renderRect'
  ]);
  html$.VREyeParameters = class VREyeParameters extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.currentFieldOfView]() {
      return this.currentFieldOfView;
    }
    get [dartx.eyeTranslation]() {
      return this.eyeTranslation;
    }
    get [dartx.maximumFieldOfView]() {
      return this.maximumFieldOfView;
    }
    get [dartx.minimumFieldOfView]() {
      return this.minimumFieldOfView;
    }
    get [dartx.recommendedFieldOfView]() {
      return this.recommendedFieldOfView;
    }
    get [dartx.renderRect]() {
      return this.renderRect;
    }
  };
  dart.setSignature(html$.VREyeParameters, {
    constructors: () => ({_: dart.definiteFunctionType(html$.VREyeParameters, [])})
  });
  dart.registerExtension(dart.global.VREyeParameters, html$.VREyeParameters);
  dart.defineExtensionNames([
    'downDegrees',
    'leftDegrees',
    'rightDegrees',
    'upDegrees'
  ]);
  html$.VRFieldOfView = class VRFieldOfView extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(fov) {
      if (fov === void 0) fov = null;
      if (fov != null) {
        let fov_1 = html_common.convertDartToNative_Dictionary(fov);
        return html$.VRFieldOfView._create_1(fov_1);
      }
      return html$.VRFieldOfView._create_2();
    }
    static _create_1(fov) {
      return new VRFieldOfView(fov);
    }
    static _create_2() {
      return new VRFieldOfView();
    }
    get [dartx.downDegrees]() {
      return this.downDegrees;
    }
    set [dartx.downDegrees](value) {
      this.downDegrees = value;
    }
    get [dartx.leftDegrees]() {
      return this.leftDegrees;
    }
    set [dartx.leftDegrees](value) {
      this.leftDegrees = value;
    }
    get [dartx.rightDegrees]() {
      return this.rightDegrees;
    }
    set [dartx.rightDegrees](value) {
      this.rightDegrees = value;
    }
    get [dartx.upDegrees]() {
      return this.upDegrees;
    }
    set [dartx.upDegrees](value) {
      this.upDegrees = value;
    }
  };
  dart.setSignature(html$.VRFieldOfView, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.VRFieldOfView, []),
      new: dart.definiteFunctionType(html$.VRFieldOfView, [], [core.Map])
    }),
    statics: () => ({
      _create_1: dart.definiteFunctionType(html$.VRFieldOfView, [dart.dynamic]),
      _create_2: dart.definiteFunctionType(html$.VRFieldOfView, [])
    }),
    names: ['_create_1', '_create_2']
  });
  dart.registerExtension(dart.global.VRFieldOfView, html$.VRFieldOfView);
  dart.defineExtensionNames([
    'angularAcceleration',
    'angularVelocity',
    'linearAcceleration',
    'linearVelocity',
    'orientation',
    'position',
    'timeStamp'
  ]);
  html$.VRPositionState = class VRPositionState extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.angularAcceleration]() {
      return this.angularAcceleration;
    }
    get [dartx.angularVelocity]() {
      return this.angularVelocity;
    }
    get [dartx.linearAcceleration]() {
      return this.linearAcceleration;
    }
    get [dartx.linearVelocity]() {
      return this.linearVelocity;
    }
    get [dartx.orientation]() {
      return this.orientation;
    }
    get [dartx.position]() {
      return this.position;
    }
    get [dartx.timeStamp]() {
      return this.timeStamp;
    }
  };
  dart.setSignature(html$.VRPositionState, {
    constructors: () => ({_: dart.definiteFunctionType(html$.VRPositionState, [])})
  });
  dart.registerExtension(dart.global.VRPositionState, html$.VRPositionState);
  dart.defineExtensionNames([
    'badInput',
    'customError',
    'patternMismatch',
    'rangeOverflow',
    'rangeUnderflow',
    'stepMismatch',
    'tooLong',
    'tooShort',
    'typeMismatch',
    'valid',
    'valueMissing'
  ]);
  html$.ValidityState = class ValidityState extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.badInput]() {
      return this.badInput;
    }
    get [dartx.customError]() {
      return this.customError;
    }
    get [dartx.patternMismatch]() {
      return this.patternMismatch;
    }
    get [dartx.rangeOverflow]() {
      return this.rangeOverflow;
    }
    get [dartx.rangeUnderflow]() {
      return this.rangeUnderflow;
    }
    get [dartx.stepMismatch]() {
      return this.stepMismatch;
    }
    get [dartx.tooLong]() {
      return this.tooLong;
    }
    get [dartx.tooShort]() {
      return this.tooShort;
    }
    get [dartx.typeMismatch]() {
      return this.typeMismatch;
    }
    get [dartx.valid]() {
      return this.valid;
    }
    get [dartx.valueMissing]() {
      return this.valueMissing;
    }
  };
  dart.setSignature(html$.ValidityState, {
    constructors: () => ({_: dart.definiteFunctionType(html$.ValidityState, [])})
  });
  dart.registerExtension(dart.global.ValidityState, html$.ValidityState);
  dart.defineExtensionNames([
    'getVideoPlaybackQuality',
    'enterFullscreen',
    'exitFullscreen',
    'height',
    'poster',
    'videoHeight',
    'videoWidth',
    'decodedFrameCount',
    'droppedFrameCount',
    'width'
  ]);
  html$.VideoElement = class VideoElement extends html$.MediaElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return html$.VideoElement._check(html$.document[dartx.createElement]("video"));
    }
    created() {
      this[dartx.height] = null;
      this[dartx.poster] = null;
      this[dartx.videoHeight] = null;
      this[dartx.videoWidth] = null;
      this[dartx.decodedFrameCount] = null;
      this[dartx.droppedFrameCount] = null;
      this[dartx.width] = null;
      super.created();
    }
    get [dartx.height]() {
      return this.height;
    }
    set [dartx.height](value) {
      this.height = value;
    }
    get [dartx.poster]() {
      return this.poster;
    }
    set [dartx.poster](value) {
      this.poster = value;
    }
    get [dartx.videoHeight]() {
      return this.videoHeight;
    }
    get [dartx.videoWidth]() {
      return this.videoWidth;
    }
    get [dartx.decodedFrameCount]() {
      return this.webkitDecodedFrameCount;
    }
    get [dartx.droppedFrameCount]() {
      return this.webkitDroppedFrameCount;
    }
    get [dartx.width]() {
      return this.width;
    }
    set [dartx.width](value) {
      this.width = value;
    }
    [dartx.getVideoPlaybackQuality]() {
      return this.getVideoPlaybackQuality();
    }
    [dartx.enterFullscreen]() {
      return this.webkitEnterFullscreen();
    }
    [dartx.exitFullscreen]() {
      return this.webkitExitFullscreen();
    }
  };
  dart.defineNamedConstructor(html$.VideoElement, 'created');
  html$.VideoElement[dart.implements] = () => [html$.CanvasImageSource];
  dart.setSignature(html$.VideoElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.VideoElement, []),
      new: dart.definiteFunctionType(html$.VideoElement, []),
      created: dart.definiteFunctionType(html$.VideoElement, [])
    }),
    methods: () => ({
      [dartx.getVideoPlaybackQuality]: dart.definiteFunctionType(html$.VideoPlaybackQuality, []),
      [dartx.enterFullscreen]: dart.definiteFunctionType(dart.void, []),
      [dartx.exitFullscreen]: dart.definiteFunctionType(dart.void, [])
    })
  });
  dart.registerExtension(dart.global.HTMLVideoElement, html$.VideoElement);
  dart.defineExtensionNames([
    'corruptedVideoFrames',
    'creationTime',
    'droppedVideoFrames',
    'totalVideoFrames'
  ]);
  html$.VideoPlaybackQuality = class VideoPlaybackQuality extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.corruptedVideoFrames]() {
      return this.corruptedVideoFrames;
    }
    get [dartx.creationTime]() {
      return this.creationTime;
    }
    get [dartx.droppedVideoFrames]() {
      return this.droppedVideoFrames;
    }
    get [dartx.totalVideoFrames]() {
      return this.totalVideoFrames;
    }
  };
  dart.setSignature(html$.VideoPlaybackQuality, {
    constructors: () => ({_: dart.definiteFunctionType(html$.VideoPlaybackQuality, [])})
  });
  dart.registerExtension(dart.global.VideoPlaybackQuality, html$.VideoPlaybackQuality);
  dart.defineExtensionNames([
    'id',
    'kind',
    'label',
    'language',
    'selected'
  ]);
  html$.VideoTrack = class VideoTrack extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.id]() {
      return this.id;
    }
    get [dartx.kind]() {
      return this.kind;
    }
    get [dartx.label]() {
      return this.label;
    }
    get [dartx.language]() {
      return this.language;
    }
    get [dartx.selected]() {
      return this.selected;
    }
    set [dartx.selected](value) {
      this.selected = value;
    }
  };
  dart.setSignature(html$.VideoTrack, {
    constructors: () => ({_: dart.definiteFunctionType(html$.VideoTrack, [])})
  });
  dart.registerExtension(dart.global.VideoTrack, html$.VideoTrack);
  dart.defineExtensionNames([
    'getTrackById',
    'onChange',
    'length',
    'selectedIndex'
  ]);
  html$.VideoTrackList = class VideoTrackList extends html$.EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.length]() {
      return this.length;
    }
    get [dartx.selectedIndex]() {
      return this.selectedIndex;
    }
    [__getter__](index) {
      return this.__getter__(index);
    }
    [dartx.getTrackById](id) {
      return this.getTrackById(id);
    }
    get [dartx.onChange]() {
      return html$.VideoTrackList.changeEvent.forTarget(this);
    }
  };
  dart.setSignature(html$.VideoTrackList, {
    constructors: () => ({_: dart.definiteFunctionType(html$.VideoTrackList, [])}),
    methods: () => ({
      [__getter__]: dart.definiteFunctionType(html$.VideoTrack, [core.int]),
      [dartx.getTrackById]: dart.definiteFunctionType(html$.VideoTrack, [core.String])
    })
  });
  dart.defineLazy(html$.VideoTrackList, {
    get changeEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('change'));
    }
  });
  dart.registerExtension(dart.global.VideoTrackList, html$.VideoTrackList);
  html$.VoidCallback = dart.typedef('VoidCallback', () => dart.functionType(dart.void, []));
  dart.defineExtensionNames([
    'getCueAsHtml',
    'align',
    'line',
    'position',
    'regionId',
    'size',
    'snapToLines',
    'text',
    'vertical'
  ]);
  html$.VttCue = class VttCue extends html$.TextTrackCue {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(startTime, endTime, text) {
      return html$.VttCue._create_1(startTime, endTime, text);
    }
    static _create_1(startTime, endTime, text) {
      return new VTTCue(startTime, endTime, text);
    }
    get [dartx.align]() {
      return this.align;
    }
    set [dartx.align](value) {
      this.align = value;
    }
    get [dartx.line]() {
      return this.line;
    }
    set [dartx.line](value) {
      this.line = value;
    }
    get [dartx.position]() {
      return this.position;
    }
    set [dartx.position](value) {
      this.position = value;
    }
    get [dartx.regionId]() {
      return this.regionId;
    }
    set [dartx.regionId](value) {
      this.regionId = value;
    }
    get [dartx.size]() {
      return this.size;
    }
    set [dartx.size](value) {
      this.size = value;
    }
    get [dartx.snapToLines]() {
      return this.snapToLines;
    }
    set [dartx.snapToLines](value) {
      this.snapToLines = value;
    }
    get [dartx.text]() {
      return this.text;
    }
    set [dartx.text](value) {
      this.text = value;
    }
    get [dartx.vertical]() {
      return this.vertical;
    }
    set [dartx.vertical](value) {
      this.vertical = value;
    }
    [dartx.getCueAsHtml]() {
      return this.getCueAsHTML();
    }
  };
  dart.setSignature(html$.VttCue, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.VttCue, []),
      new: dart.definiteFunctionType(html$.VttCue, [core.num, core.num, core.String])
    }),
    methods: () => ({[dartx.getCueAsHtml]: dart.definiteFunctionType(html$.DocumentFragment, [])}),
    statics: () => ({_create_1: dart.definiteFunctionType(html$.VttCue, [dart.dynamic, dart.dynamic, dart.dynamic])}),
    names: ['_create_1']
  });
  dart.registerExtension(dart.global.VTTCue, html$.VttCue);
  dart.defineExtensionNames([
    'height',
    'id',
    'regionAnchorX',
    'regionAnchorY',
    'scroll',
    'track',
    'viewportAnchorX',
    'viewportAnchorY',
    'width'
  ]);
  html$.VttRegion = class VttRegion extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return html$.VttRegion._create_1();
    }
    static _create_1() {
      return new VTTRegion();
    }
    get [dartx.height]() {
      return this.height;
    }
    set [dartx.height](value) {
      this.height = value;
    }
    get [dartx.id]() {
      return this.id;
    }
    set [dartx.id](value) {
      this.id = value;
    }
    get [dartx.regionAnchorX]() {
      return this.regionAnchorX;
    }
    set [dartx.regionAnchorX](value) {
      this.regionAnchorX = value;
    }
    get [dartx.regionAnchorY]() {
      return this.regionAnchorY;
    }
    set [dartx.regionAnchorY](value) {
      this.regionAnchorY = value;
    }
    get [dartx.scroll]() {
      return this.scroll;
    }
    set [dartx.scroll](value) {
      this.scroll = value;
    }
    get [dartx.track]() {
      return this.track;
    }
    get [dartx.viewportAnchorX]() {
      return this.viewportAnchorX;
    }
    set [dartx.viewportAnchorX](value) {
      this.viewportAnchorX = value;
    }
    get [dartx.viewportAnchorY]() {
      return this.viewportAnchorY;
    }
    set [dartx.viewportAnchorY](value) {
      this.viewportAnchorY = value;
    }
    get [dartx.width]() {
      return this.width;
    }
    set [dartx.width](value) {
      this.width = value;
    }
  };
  dart.setSignature(html$.VttRegion, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.VttRegion, []),
      new: dart.definiteFunctionType(html$.VttRegion, [])
    }),
    statics: () => ({_create_1: dart.definiteFunctionType(html$.VttRegion, [])}),
    names: ['_create_1']
  });
  dart.registerExtension(dart.global.VTTRegion, html$.VttRegion);
  dart.defineExtensionNames([
    'getRegionById',
    'item',
    'length'
  ]);
  html$.VttRegionList = class VttRegionList extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.length]() {
      return this.length;
    }
    [dartx.getRegionById](id) {
      return this.getRegionById(id);
    }
    [dartx.item](index) {
      return this.item(index);
    }
  };
  dart.setSignature(html$.VttRegionList, {
    constructors: () => ({_: dart.definiteFunctionType(html$.VttRegionList, [])}),
    methods: () => ({
      [dartx.getRegionById]: dart.definiteFunctionType(html$.VttRegion, [core.String]),
      [dartx.item]: dart.definiteFunctionType(html$.VttRegion, [core.int])
    })
  });
  dart.registerExtension(dart.global.VTTRegionList, html$.VttRegionList);
  dart.defineExtensionNames([
    'close',
    'send',
    'sendBlob',
    'sendByteBuffer',
    'sendString',
    'sendTypedData',
    'onClose',
    'onError',
    'onMessage',
    'onOpen',
    'binaryType',
    'bufferedAmount',
    'extensions',
    'protocol',
    'readyState',
    'url'
  ]);
  html$.WebSocket = class WebSocket extends html$.EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(url, protocols) {
      if (protocols === void 0) protocols = null;
      if (protocols != null) {
        return html$.WebSocket._create_1(url, protocols);
      }
      return html$.WebSocket._create_2(url);
    }
    static _create_1(url, protocols) {
      return new WebSocket(url, protocols);
    }
    static _create_2(url) {
      return new WebSocket(url);
    }
    static get supported() {
      return typeof window.WebSocket != "undefined";
    }
    get [dartx.binaryType]() {
      return this.binaryType;
    }
    set [dartx.binaryType](value) {
      this.binaryType = value;
    }
    get [dartx.bufferedAmount]() {
      return this.bufferedAmount;
    }
    get [dartx.extensions]() {
      return this.extensions;
    }
    get [dartx.protocol]() {
      return this.protocol;
    }
    get [dartx.readyState]() {
      return this.readyState;
    }
    get [dartx.url]() {
      return this.url;
    }
    [dartx.close](code, reason) {
      return this.close(code, reason);
    }
    [dartx.send](data) {
      return this.send(data);
    }
    [dartx.sendBlob](data) {
      return this.send(data);
    }
    [dartx.sendByteBuffer](data) {
      return this.send(data);
    }
    [dartx.sendString](data) {
      return this.send(data);
    }
    [dartx.sendTypedData](data) {
      return this.send(data);
    }
    get [dartx.onClose]() {
      return html$.WebSocket.closeEvent.forTarget(this);
    }
    get [dartx.onError]() {
      return html$.WebSocket.errorEvent.forTarget(this);
    }
    get [dartx.onMessage]() {
      return html$.WebSocket.messageEvent.forTarget(this);
    }
    get [dartx.onOpen]() {
      return html$.WebSocket.openEvent.forTarget(this);
    }
  };
  dart.setSignature(html$.WebSocket, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.WebSocket, []),
      new: dart.definiteFunctionType(html$.WebSocket, [core.String], [core.Object])
    }),
    methods: () => ({
      [dartx.close]: dart.definiteFunctionType(dart.void, [], [core.int, core.String]),
      [dartx.send]: dart.definiteFunctionType(dart.void, [dart.dynamic]),
      [dartx.sendBlob]: dart.definiteFunctionType(dart.void, [html$.Blob]),
      [dartx.sendByteBuffer]: dart.definiteFunctionType(dart.void, [typed_data.ByteBuffer]),
      [dartx.sendString]: dart.definiteFunctionType(dart.void, [core.String]),
      [dartx.sendTypedData]: dart.definiteFunctionType(dart.void, [typed_data.TypedData])
    }),
    statics: () => ({
      _create_1: dart.definiteFunctionType(html$.WebSocket, [dart.dynamic, dart.dynamic]),
      _create_2: dart.definiteFunctionType(html$.WebSocket, [dart.dynamic])
    }),
    names: ['_create_1', '_create_2']
  });
  html$.WebSocket.CLOSED = 3;
  html$.WebSocket.CLOSING = 2;
  html$.WebSocket.CONNECTING = 0;
  html$.WebSocket.OPEN = 1;
  dart.defineLazy(html$.WebSocket, {
    get closeEvent() {
      return dart.const(new (EventStreamProviderOfCloseEvent())('close'));
    },
    get errorEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('error'));
    },
    get messageEvent() {
      return dart.const(new (EventStreamProviderOfMessageEvent())('message'));
    },
    get openEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('open'));
    }
  });
  dart.registerExtension(dart.global.WebSocket, html$.WebSocket);
  const _deltaX = Symbol('_deltaX');
  const _deltaY = Symbol('_deltaY');
  const _wheelDelta = Symbol('_wheelDelta');
  const _wheelDeltaX = Symbol('_wheelDeltaX');
  const _hasInitMouseScrollEvent = Symbol('_hasInitMouseScrollEvent');
  const _initMouseScrollEvent = Symbol('_initMouseScrollEvent');
  const _hasInitWheelEvent = Symbol('_hasInitWheelEvent');
  const _initWheelEvent = Symbol('_initWheelEvent');
  dart.defineExtensionNames([
    'deltaY',
    'deltaX',
    'deltaMode',
    'deltaZ'
  ]);
  html$.WheelEvent = class WheelEvent extends html$.MouseEvent {
    static new(type, opts) {
      let view = opts && 'view' in opts ? opts.view : null;
      let deltaX = opts && 'deltaX' in opts ? opts.deltaX : 0;
      let deltaY = opts && 'deltaY' in opts ? opts.deltaY : 0;
      let deltaZ = opts && 'deltaZ' in opts ? opts.deltaZ : 0;
      let deltaMode = opts && 'deltaMode' in opts ? opts.deltaMode : 0;
      let detail = opts && 'detail' in opts ? opts.detail : 0;
      let screenX = opts && 'screenX' in opts ? opts.screenX : 0;
      let screenY = opts && 'screenY' in opts ? opts.screenY : 0;
      let clientX = opts && 'clientX' in opts ? opts.clientX : 0;
      let clientY = opts && 'clientY' in opts ? opts.clientY : 0;
      let button = opts && 'button' in opts ? opts.button : 0;
      let canBubble = opts && 'canBubble' in opts ? opts.canBubble : true;
      let cancelable = opts && 'cancelable' in opts ? opts.cancelable : true;
      let ctrlKey = opts && 'ctrlKey' in opts ? opts.ctrlKey : false;
      let altKey = opts && 'altKey' in opts ? opts.altKey : false;
      let shiftKey = opts && 'shiftKey' in opts ? opts.shiftKey : false;
      let metaKey = opts && 'metaKey' in opts ? opts.metaKey : false;
      let relatedTarget = opts && 'relatedTarget' in opts ? opts.relatedTarget : null;
      let options = dart.map({view: view, deltaMode: deltaMode, deltaX: deltaX, deltaY: deltaY, deltaZ: deltaZ, detail: detail, screenX: screenX, screenY: screenY, clientX: clientX, clientY: clientY, button: button, bubbles: canBubble, cancelable: cancelable, ctrlKey: ctrlKey, altKey: altKey, shiftKey: shiftKey, metaKey: metaKey, relatedTarget: relatedTarget});
      if (view == null) {
        view = html$.window;
      }
      return new WheelEvent(type, html_common.convertDartToNative_Dictionary(options));
    }
    static _(type, eventInitDict) {
      if (eventInitDict === void 0) eventInitDict = null;
      if (eventInitDict != null) {
        let eventInitDict_1 = html_common.convertDartToNative_Dictionary(eventInitDict);
        return html$.WheelEvent._create_1(type, eventInitDict_1);
      }
      return html$.WheelEvent._create_2(type);
    }
    static _create_1(type, eventInitDict) {
      return new WheelEvent(type, eventInitDict);
    }
    static _create_2(type) {
      return new WheelEvent(type);
    }
    get [_deltaX]() {
      return this.deltaX;
    }
    get [_deltaY]() {
      return this.deltaY;
    }
    get [dartx.deltaZ]() {
      return this.deltaZ;
    }
    get [dartx.deltaY]() {
      if (this.deltaY !== undefined) {
        return this[_deltaY];
      }
      dart.throw(new core.UnsupportedError('deltaY is not supported'));
    }
    get [dartx.deltaX]() {
      if (this.deltaX !== undefined) {
        return this[_deltaX];
      }
      dart.throw(new core.UnsupportedError('deltaX is not supported'));
    }
    get [dartx.deltaMode]() {
      if (!!this.deltaMode) {
        return this.deltaMode;
      }
      return 0;
    }
    get [_wheelDelta]() {
      return this.wheelDelta;
    }
    get [_wheelDeltaX]() {
      return this.wheelDeltaX;
    }
    get [_detail]() {
      return this.detail;
    }
    get [_hasInitMouseScrollEvent]() {
      return !!this.initMouseScrollEvent;
    }
    [_initMouseScrollEvent](type, canBubble, cancelable, view, detail, screenX, screenY, clientX, clientY, ctrlKey, altKey, shiftKey, metaKey, button, relatedTarget, axis) {
      return this.initMouseScrollEvent(type, canBubble, cancelable, view, detail, screenX, screenY, clientX, clientY, ctrlKey, altKey, shiftKey, metaKey, button, relatedTarget, axis);
    }
    get [_hasInitWheelEvent]() {
      return !!this.initWheelEvent;
    }
    [_initWheelEvent](eventType, canBubble, cancelable, view, detail, screenX, screenY, clientX, clientY, button, relatedTarget, modifiersList, deltaX, deltaY, deltaZ, deltaMode) {
      return this.initWheelEvent(eventType, canBubble, cancelable, view, detail, screenX, screenY, clientX, clientY, button, relatedTarget, modifiersList, deltaX, deltaY, deltaZ, deltaMode);
    }
  };
  dart.setSignature(html$.WheelEvent, {
    constructors: () => ({
      new: dart.definiteFunctionType(html$.WheelEvent, [core.String], {view: html$.Window, deltaX: core.num, deltaY: core.num, deltaZ: core.num, deltaMode: core.int, detail: core.int, screenX: core.int, screenY: core.int, clientX: core.int, clientY: core.int, button: core.int, canBubble: core.bool, cancelable: core.bool, ctrlKey: core.bool, altKey: core.bool, shiftKey: core.bool, metaKey: core.bool, relatedTarget: html$.EventTarget}),
      _: dart.definiteFunctionType(html$.WheelEvent, [core.String], [core.Map])
    }),
    methods: () => ({
      [_initMouseScrollEvent]: dart.definiteFunctionType(dart.void, [core.String, core.bool, core.bool, html$.Window, core.int, core.int, core.int, core.int, core.int, core.bool, core.bool, core.bool, core.bool, core.int, html$.EventTarget, core.int]),
      [_initWheelEvent]: dart.definiteFunctionType(dart.void, [core.String, core.bool, core.bool, html$.Window, core.int, core.int, core.int, core.int, core.int, core.int, html$.EventTarget, core.String, core.int, core.int, core.int, core.int])
    }),
    statics: () => ({
      _create_1: dart.definiteFunctionType(html$.WheelEvent, [dart.dynamic, dart.dynamic]),
      _create_2: dart.definiteFunctionType(html$.WheelEvent, [dart.dynamic])
    }),
    names: ['_create_1', '_create_2']
  });
  html$.WheelEvent.DOM_DELTA_LINE = 1;
  html$.WheelEvent.DOM_DELTA_PAGE = 2;
  html$.WheelEvent.DOM_DELTA_PIXEL = 0;
  dart.registerExtension(dart.global.WheelEvent, html$.WheelEvent);
  const _open2 = Symbol('_open2');
  const _open3 = Symbol('_open3');
  const _location = Symbol('_location');
  const _ensureRequestAnimationFrame = Symbol('_ensureRequestAnimationFrame');
  const _requestAnimationFrame = Symbol('_requestAnimationFrame');
  const _cancelAnimationFrame = Symbol('_cancelAnimationFrame');
  const _requestFileSystem = Symbol('_requestFileSystem');
  const _get_opener = Symbol('_get_opener');
  const _pageXOffset = Symbol('_pageXOffset');
  const _pageYOffset = Symbol('_pageYOffset');
  const _get_parent = Symbol('_get_parent');
  const _get_self = Symbol('_get_self');
  const _get_top = Symbol('_get_top');
  const __getter___1 = Symbol('__getter___1');
  const __getter___2 = Symbol('__getter___2');
  const _scroll_4 = Symbol('_scroll_4');
  const _scroll_5 = Symbol('_scroll_5');
  const _scrollBy_4 = Symbol('_scrollBy_4');
  const _scrollBy_5 = Symbol('_scrollBy_5');
  const _scrollTo_4 = Symbol('_scrollTo_4');
  const _scrollTo_5 = Symbol('_scrollTo_5');
  const __requestFileSystem = Symbol('__requestFileSystem');
  const _resolveLocalFileSystemUrl = Symbol('_resolveLocalFileSystemUrl');
  dart.defineExtensionNames([
    'animationFrame',
    'document',
    'open',
    'location',
    'location',
    'requestAnimationFrame',
    'cancelAnimationFrame',
    'indexedDB',
    'console',
    'requestFileSystem',
    'opener',
    'opener',
    'parent',
    'self',
    'top',
    'window',
    'alert',
    'close',
    'confirm',
    'fetch',
    'find',
    'getMatchedCssRules',
    'getSelection',
    'matchMedia',
    'moveBy',
    'openDatabase',
    'postMessage',
    'print',
    'resizeBy',
    'resizeTo',
    'scroll',
    'scrollBy',
    'scrollTo',
    'stop',
    'resolveLocalFileSystemUrl',
    'atob',
    'btoa',
    'onContentLoaded',
    'onAbort',
    'onBlur',
    'onCanPlay',
    'onCanPlayThrough',
    'onChange',
    'onClick',
    'onContextMenu',
    'onDoubleClick',
    'onDeviceMotion',
    'onDeviceOrientation',
    'onDrag',
    'onDragEnd',
    'onDragEnter',
    'onDragLeave',
    'onDragOver',
    'onDragStart',
    'onDrop',
    'onDurationChange',
    'onEmptied',
    'onEnded',
    'onError',
    'onFocus',
    'onHashChange',
    'onInput',
    'onInvalid',
    'onKeyDown',
    'onKeyPress',
    'onKeyUp',
    'onLoad',
    'onLoadedData',
    'onLoadedMetadata',
    'onLoadStart',
    'onMessage',
    'onMouseDown',
    'onMouseEnter',
    'onMouseLeave',
    'onMouseMove',
    'onMouseOut',
    'onMouseOver',
    'onMouseUp',
    'onMouseWheel',
    'onOffline',
    'onOnline',
    'onPageHide',
    'onPageShow',
    'onPause',
    'onPlay',
    'onPlaying',
    'onPopState',
    'onProgress',
    'onRateChange',
    'onReset',
    'onResize',
    'onScroll',
    'onSearch',
    'onSeeked',
    'onSeeking',
    'onSelect',
    'onStalled',
    'onStorage',
    'onSubmit',
    'onSuspend',
    'onTimeUpdate',
    'onTouchCancel',
    'onTouchEnd',
    'onTouchMove',
    'onTouchStart',
    'onTransitionEnd',
    'onUnload',
    'onVolumeChange',
    'onWaiting',
    'onAnimationEnd',
    'onAnimationIteration',
    'onAnimationStart',
    'onBeforeUnload',
    'moveTo',
    'pageXOffset',
    'pageYOffset',
    'scrollX',
    'scrollY',
    'applicationCache',
    'caches',
    'closed',
    'crypto',
    'defaultStatus',
    'defaultstatus',
    'devicePixelRatio',
    'history',
    'innerHeight',
    'innerWidth',
    'localStorage',
    'locationbar',
    'menubar',
    'name',
    'navigator',
    'offscreenBuffering',
    'orientation',
    'outerHeight',
    'outerWidth',
    'performance',
    'screen',
    'screenLeft',
    'screenTop',
    'screenX',
    'screenY',
    'scrollbars',
    'sessionStorage',
    'speechSynthesis',
    'status',
    'statusbar',
    'styleMedia',
    'toolbar'
  ]);
  html$.Window = class Window extends html$.EventTarget {
    get [dartx.animationFrame]() {
      let completer = CompleterOfnum().sync();
      this[dartx.requestAnimationFrame](dart.fn(time => {
        completer.complete(time);
      }, numTovoid()));
      return completer.future;
    }
    get [dartx.document]() {
      return this.document;
    }
    [_open2](url, name) {
      return this.open(url, name);
    }
    [_open3](url, name, options) {
      return this.open(url, name, options);
    }
    [dartx.open](url, name, options) {
      if (options === void 0) options = null;
      if (options == null) {
        return html$._DOMWindowCrossFrame._createSafe(this[_open2](url, name));
      } else {
        return html$._DOMWindowCrossFrame._createSafe(this[_open3](url, name, options));
      }
    }
    get [dartx.location]() {
      return html$.Location._check(this[_location]);
    }
    set [dartx.location](value) {
      this[_location] = value;
    }
    get [_location]() {
      return this.location;
    }
    set [_location](value) {
      this.location = value;
    }
    [dartx.requestAnimationFrame](callback) {
      this[_ensureRequestAnimationFrame]();
      return this[_requestAnimationFrame](html$._wrapZone(core.num, dart.dynamic)(callback));
    }
    [dartx.cancelAnimationFrame](id) {
      this[_ensureRequestAnimationFrame]();
      this[_cancelAnimationFrame](id);
    }
    [_requestAnimationFrame](callback) {
      return this.requestAnimationFrame(callback);
    }
    [_cancelAnimationFrame](id) {
      return this.cancelAnimationFrame(id);
    }
    [_ensureRequestAnimationFrame]() {
      if (!!(this.requestAnimationFrame && this.cancelAnimationFrame)) return;
      (function($this) {
        var vendors = ['ms', 'moz', 'webkit', 'o'];
        for (var i = 0; i < vendors.length && !$this.requestAnimationFrame; ++i) {
          $this.requestAnimationFrame = $this[vendors[i] + 'RequestAnimationFrame'];
          $this.cancelAnimationFrame = $this[vendors[i] + 'CancelAnimationFrame'] || $this[vendors[i] + 'CancelRequestAnimationFrame'];
        }
        if ($this.requestAnimationFrame && $this.cancelAnimationFrame) return;
        $this.requestAnimationFrame = function(callback) {
          return window.setTimeout(function() {
            callback(Date.now());
          }, 16);
        };
        $this.cancelAnimationFrame = function(id) {
          clearTimeout(id);
        };
      })(this);
    }
    get [dartx.indexedDB]() {
      return this.indexedDB || this.webkitIndexedDB || this.mozIndexedDB;
    }
    get [dartx.console]() {
      return html$.Console._safeConsole;
    }
    [dartx.requestFileSystem](size, opts) {
      let persistent = opts && 'persistent' in opts ? opts.persistent : false;
      return this[_requestFileSystem](dart.test(persistent) ? 1 : 0, size);
    }
    static get supportsPointConversions() {
      return html$.DomPoint.supported;
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.applicationCache]() {
      return this.applicationCache;
    }
    get [dartx.caches]() {
      return this.caches;
    }
    get [dartx.closed]() {
      return this.closed;
    }
    get [dartx.crypto]() {
      return this.crypto;
    }
    get [dartx.defaultStatus]() {
      return this.defaultStatus;
    }
    set [dartx.defaultStatus](value) {
      this.defaultStatus = value;
    }
    get [dartx.defaultstatus]() {
      return this.defaultstatus;
    }
    set [dartx.defaultstatus](value) {
      this.defaultstatus = value;
    }
    get [dartx.devicePixelRatio]() {
      return this.devicePixelRatio;
    }
    get [dartx.history]() {
      return this.history;
    }
    get [dartx.innerHeight]() {
      return this.innerHeight;
    }
    get [dartx.innerWidth]() {
      return this.innerWidth;
    }
    get [dartx.localStorage]() {
      return this.localStorage;
    }
    get [dartx.locationbar]() {
      return this.locationbar;
    }
    get [dartx.menubar]() {
      return this.menubar;
    }
    get [dartx.name]() {
      return this.name;
    }
    set [dartx.name](value) {
      this.name = value;
    }
    get [dartx.navigator]() {
      return this.navigator;
    }
    get [dartx.offscreenBuffering]() {
      return this.offscreenBuffering;
    }
    get [dartx.opener]() {
      return html$._convertNativeToDart_Window(this[_get_opener]);
    }
    get [_get_opener]() {
      return this.opener;
    }
    set [dartx.opener](value) {
      this.opener = value;
    }
    get [dartx.orientation]() {
      return this.orientation;
    }
    get [dartx.outerHeight]() {
      return this.outerHeight;
    }
    get [dartx.outerWidth]() {
      return this.outerWidth;
    }
    get [_pageXOffset]() {
      return this.pageXOffset;
    }
    get [_pageYOffset]() {
      return this.pageYOffset;
    }
    get [dartx.parent]() {
      return html$._convertNativeToDart_Window(this[_get_parent]);
    }
    get [_get_parent]() {
      return this.parent;
    }
    get [dartx.performance]() {
      return this.performance;
    }
    get [dartx.screen]() {
      return this.screen;
    }
    get [dartx.screenLeft]() {
      return this.screenLeft;
    }
    get [dartx.screenTop]() {
      return this.screenTop;
    }
    get [dartx.screenX]() {
      return this.screenX;
    }
    get [dartx.screenY]() {
      return this.screenY;
    }
    get [dartx.scrollbars]() {
      return this.scrollbars;
    }
    get [dartx.self]() {
      return html$._convertNativeToDart_Window(this[_get_self]);
    }
    get [_get_self]() {
      return this.self;
    }
    get [dartx.sessionStorage]() {
      return this.sessionStorage;
    }
    get [dartx.speechSynthesis]() {
      return this.speechSynthesis;
    }
    get [dartx.status]() {
      return this.status;
    }
    set [dartx.status](value) {
      this.status = value;
    }
    get [dartx.statusbar]() {
      return this.statusbar;
    }
    get [dartx.styleMedia]() {
      return this.styleMedia;
    }
    get [dartx.toolbar]() {
      return this.toolbar;
    }
    get [dartx.top]() {
      return html$._convertNativeToDart_Window(this[_get_top]);
    }
    get [_get_top]() {
      return this.top;
    }
    get [dartx.window]() {
      return html$._convertNativeToDart_Window(this[_get_window]);
    }
    get [_get_window]() {
      return this.window;
    }
    [__getter__](index_OR_name) {
      if (typeof index_OR_name == 'number') {
        return html$._convertNativeToDart_Window(this[__getter___1](index_OR_name));
      }
      if (typeof index_OR_name == 'string') {
        return html$._convertNativeToDart_Window(this[__getter___2](index_OR_name));
      }
      dart.throw(new core.ArgumentError("Incorrect number or type of arguments"));
    }
    [__getter___1](index) {
      return this.__getter__(index);
    }
    [__getter___2](name) {
      return this.__getter__(name);
    }
    [dartx.alert](message) {
      return this.alert(message);
    }
    [dartx.close]() {
      return this.close();
    }
    [dartx.confirm](message) {
      return this.confirm(message);
    }
    [dartx.fetch](input, init) {
      if (init === void 0) init = null;
      if (init != null) {
        let init_1 = html_common.convertDartToNative_Dictionary(init);
        return this[_fetch_1](input, init_1);
      }
      return this[_fetch_2](input);
    }
    [_fetch_1](input, init) {
      return this.fetch(input, init);
    }
    [_fetch_2](input) {
      return this.fetch(input);
    }
    [dartx.find](string, caseSensitive, backwards, wrap, wholeWord, searchInFrames, showDialog) {
      return this.find(string, caseSensitive, backwards, wrap, wholeWord, searchInFrames, showDialog);
    }
    [_getComputedStyle](elt, pseudoElt) {
      return this.getComputedStyle(elt, pseudoElt);
    }
    [dartx.getMatchedCssRules](element, pseudoElement) {
      return this.getMatchedCSSRules(element, pseudoElement);
    }
    [dartx.getSelection]() {
      return this.getSelection();
    }
    [dartx.matchMedia](query) {
      return this.matchMedia(query);
    }
    [dartx.moveBy](x, y) {
      return this.moveBy(x, y);
    }
    [_moveTo](x, y) {
      return this.moveTo(x, y);
    }
    [dartx.openDatabase](name, version, displayName, estimatedSize, creationCallback) {
      return this.openDatabase(name, version, displayName, estimatedSize, creationCallback);
    }
    [dartx.postMessage](message, targetOrigin, transfer) {
      if (transfer === void 0) transfer = null;
      if (transfer != null) {
        let message_1 = html_common.convertDartToNative_SerializedScriptValue(message);
        this[_postMessage_1](message_1, targetOrigin, transfer);
        return;
      }
      let message_1 = html_common.convertDartToNative_SerializedScriptValue(message);
      this[_postMessage_2](message_1, targetOrigin);
      return;
    }
    [_postMessage_1](message, targetOrigin, transfer) {
      return this.postMessage(message, targetOrigin, transfer);
    }
    [_postMessage_2](message, targetOrigin) {
      return this.postMessage(message, targetOrigin);
    }
    [dartx.print]() {
      return this.print();
    }
    [dartx.resizeBy](x, y) {
      return this.resizeBy(x, y);
    }
    [dartx.resizeTo](x, y) {
      return this.resizeTo(x, y);
    }
    [dartx.scroll](options_OR_x, y, scrollOptions) {
      if (options_OR_x === void 0) options_OR_x = null;
      if (y === void 0) y = null;
      if (scrollOptions === void 0) scrollOptions = null;
      if (options_OR_x == null && y == null && scrollOptions == null) {
        this[_scroll_1]();
        return;
      }
      if (core.Map.is(options_OR_x) && y == null && scrollOptions == null) {
        let options_1 = html_common.convertDartToNative_Dictionary(options_OR_x);
        this[_scroll_2](options_1);
        return;
      }
      if (typeof y == 'number' && typeof options_OR_x == 'number' && scrollOptions == null) {
        this[_scroll_3](options_OR_x, y);
        return;
      }
      if (typeof y == 'number' && typeof options_OR_x == 'number' && scrollOptions == null) {
        this[_scroll_4](options_OR_x, y);
        return;
      }
      if (scrollOptions != null && typeof y == 'number' && typeof options_OR_x == 'number') {
        let scrollOptions_1 = html_common.convertDartToNative_Dictionary(scrollOptions);
        this[_scroll_5](options_OR_x, y, scrollOptions_1);
        return;
      }
      dart.throw(new core.ArgumentError("Incorrect number or type of arguments"));
    }
    [_scroll_1]() {
      return this.scroll();
    }
    [_scroll_2](options) {
      return this.scroll(options);
    }
    [_scroll_3](x, y) {
      return this.scroll(x, y);
    }
    [_scroll_4](x, y) {
      return this.scroll(x, y);
    }
    [_scroll_5](x, y, scrollOptions) {
      return this.scroll(x, y, scrollOptions);
    }
    [dartx.scrollBy](options_OR_x, y, scrollOptions) {
      if (options_OR_x === void 0) options_OR_x = null;
      if (y === void 0) y = null;
      if (scrollOptions === void 0) scrollOptions = null;
      if (options_OR_x == null && y == null && scrollOptions == null) {
        this[_scrollBy_1]();
        return;
      }
      if (core.Map.is(options_OR_x) && y == null && scrollOptions == null) {
        let options_1 = html_common.convertDartToNative_Dictionary(options_OR_x);
        this[_scrollBy_2](options_1);
        return;
      }
      if (typeof y == 'number' && typeof options_OR_x == 'number' && scrollOptions == null) {
        this[_scrollBy_3](options_OR_x, y);
        return;
      }
      if (typeof y == 'number' && typeof options_OR_x == 'number' && scrollOptions == null) {
        this[_scrollBy_4](options_OR_x, y);
        return;
      }
      if (scrollOptions != null && typeof y == 'number' && typeof options_OR_x == 'number') {
        let scrollOptions_1 = html_common.convertDartToNative_Dictionary(scrollOptions);
        this[_scrollBy_5](options_OR_x, y, scrollOptions_1);
        return;
      }
      dart.throw(new core.ArgumentError("Incorrect number or type of arguments"));
    }
    [_scrollBy_1]() {
      return this.scrollBy();
    }
    [_scrollBy_2](options) {
      return this.scrollBy(options);
    }
    [_scrollBy_3](x, y) {
      return this.scrollBy(x, y);
    }
    [_scrollBy_4](x, y) {
      return this.scrollBy(x, y);
    }
    [_scrollBy_5](x, y, scrollOptions) {
      return this.scrollBy(x, y, scrollOptions);
    }
    [dartx.scrollTo](options_OR_x, y, scrollOptions) {
      if (options_OR_x === void 0) options_OR_x = null;
      if (y === void 0) y = null;
      if (scrollOptions === void 0) scrollOptions = null;
      if (options_OR_x == null && y == null && scrollOptions == null) {
        this[_scrollTo_1]();
        return;
      }
      if (core.Map.is(options_OR_x) && y == null && scrollOptions == null) {
        let options_1 = html_common.convertDartToNative_Dictionary(options_OR_x);
        this[_scrollTo_2](options_1);
        return;
      }
      if (typeof y == 'number' && typeof options_OR_x == 'number' && scrollOptions == null) {
        this[_scrollTo_3](options_OR_x, y);
        return;
      }
      if (typeof y == 'number' && typeof options_OR_x == 'number' && scrollOptions == null) {
        this[_scrollTo_4](options_OR_x, y);
        return;
      }
      if (scrollOptions != null && typeof y == 'number' && typeof options_OR_x == 'number') {
        let scrollOptions_1 = html_common.convertDartToNative_Dictionary(scrollOptions);
        this[_scrollTo_5](options_OR_x, y, scrollOptions_1);
        return;
      }
      dart.throw(new core.ArgumentError("Incorrect number or type of arguments"));
    }
    [_scrollTo_1]() {
      return this.scrollTo();
    }
    [_scrollTo_2](options) {
      return this.scrollTo(options);
    }
    [_scrollTo_3](x, y) {
      return this.scrollTo(x, y);
    }
    [_scrollTo_4](x, y) {
      return this.scrollTo(x, y);
    }
    [_scrollTo_5](x, y, scrollOptions) {
      return this.scrollTo(x, y, scrollOptions);
    }
    [dartx.stop]() {
      return this.stop();
    }
    [__requestFileSystem](type, size, successCallback, errorCallback) {
      return this.webkitRequestFileSystem(type, size, successCallback, errorCallback);
    }
    [_requestFileSystem](type, size) {
      let completer = CompleterOfFileSystem().new();
      this[__requestFileSystem](type, size, dart.fn(value => {
        completer.complete(value);
      }, FileSystemTovoid()), dart.fn(error => {
        completer.completeError(error);
      }, FileErrorTovoid()));
      return completer.future;
    }
    [_resolveLocalFileSystemUrl](url, successCallback, errorCallback) {
      return this.webkitResolveLocalFileSystemURL(url, successCallback, errorCallback);
    }
    [dartx.resolveLocalFileSystemUrl](url) {
      let completer = CompleterOfEntry().new();
      this[_resolveLocalFileSystemUrl](url, dart.fn(value => {
        completer.complete(value);
      }, EntryTovoid()), dart.fn(error => {
        completer.completeError(error);
      }, FileErrorTovoid()));
      return completer.future;
    }
    [dartx.atob](atob) {
      return this.atob(atob);
    }
    [dartx.btoa](btoa) {
      return this.btoa(btoa);
    }
    [_setInterval_String](handler, timeout, arguments$) {
      return this.setInterval(handler, timeout, arguments$);
    }
    [_setTimeout_String](handler, timeout, arguments$) {
      return this.setTimeout(handler, timeout, arguments$);
    }
    [_clearInterval](handle) {
      return this.clearInterval(handle);
    }
    [_clearTimeout](handle) {
      return this.clearTimeout(handle);
    }
    [_setInterval](handler, timeout) {
      return this.setInterval(handler, timeout);
    }
    [_setTimeout](handler, timeout) {
      return this.setTimeout(handler, timeout);
    }
    get [dartx.onContentLoaded]() {
      return html$.Window.contentLoadedEvent.forTarget(this);
    }
    get [dartx.onAbort]() {
      return html$.Element.abortEvent.forTarget(this);
    }
    get [dartx.onBlur]() {
      return html$.Element.blurEvent.forTarget(this);
    }
    get [dartx.onCanPlay]() {
      return html$.Element.canPlayEvent.forTarget(this);
    }
    get [dartx.onCanPlayThrough]() {
      return html$.Element.canPlayThroughEvent.forTarget(this);
    }
    get [dartx.onChange]() {
      return html$.Element.changeEvent.forTarget(this);
    }
    get [dartx.onClick]() {
      return html$.Element.clickEvent.forTarget(this);
    }
    get [dartx.onContextMenu]() {
      return html$.Element.contextMenuEvent.forTarget(this);
    }
    get [dartx.onDoubleClick]() {
      return html$.Element.doubleClickEvent.forTarget(this);
    }
    get [dartx.onDeviceMotion]() {
      return html$.Window.deviceMotionEvent.forTarget(this);
    }
    get [dartx.onDeviceOrientation]() {
      return html$.Window.deviceOrientationEvent.forTarget(this);
    }
    get [dartx.onDrag]() {
      return html$.Element.dragEvent.forTarget(this);
    }
    get [dartx.onDragEnd]() {
      return html$.Element.dragEndEvent.forTarget(this);
    }
    get [dartx.onDragEnter]() {
      return html$.Element.dragEnterEvent.forTarget(this);
    }
    get [dartx.onDragLeave]() {
      return html$.Element.dragLeaveEvent.forTarget(this);
    }
    get [dartx.onDragOver]() {
      return html$.Element.dragOverEvent.forTarget(this);
    }
    get [dartx.onDragStart]() {
      return html$.Element.dragStartEvent.forTarget(this);
    }
    get [dartx.onDrop]() {
      return html$.Element.dropEvent.forTarget(this);
    }
    get [dartx.onDurationChange]() {
      return html$.Element.durationChangeEvent.forTarget(this);
    }
    get [dartx.onEmptied]() {
      return html$.Element.emptiedEvent.forTarget(this);
    }
    get [dartx.onEnded]() {
      return html$.Element.endedEvent.forTarget(this);
    }
    get [dartx.onError]() {
      return html$.Element.errorEvent.forTarget(this);
    }
    get [dartx.onFocus]() {
      return html$.Element.focusEvent.forTarget(this);
    }
    get [dartx.onHashChange]() {
      return html$.Window.hashChangeEvent.forTarget(this);
    }
    get [dartx.onInput]() {
      return html$.Element.inputEvent.forTarget(this);
    }
    get [dartx.onInvalid]() {
      return html$.Element.invalidEvent.forTarget(this);
    }
    get [dartx.onKeyDown]() {
      return html$.Element.keyDownEvent.forTarget(this);
    }
    get [dartx.onKeyPress]() {
      return html$.Element.keyPressEvent.forTarget(this);
    }
    get [dartx.onKeyUp]() {
      return html$.Element.keyUpEvent.forTarget(this);
    }
    get [dartx.onLoad]() {
      return html$.Element.loadEvent.forTarget(this);
    }
    get [dartx.onLoadedData]() {
      return html$.Element.loadedDataEvent.forTarget(this);
    }
    get [dartx.onLoadedMetadata]() {
      return html$.Element.loadedMetadataEvent.forTarget(this);
    }
    get [dartx.onLoadStart]() {
      return html$.Window.loadStartEvent.forTarget(this);
    }
    get [dartx.onMessage]() {
      return html$.Window.messageEvent.forTarget(this);
    }
    get [dartx.onMouseDown]() {
      return html$.Element.mouseDownEvent.forTarget(this);
    }
    get [dartx.onMouseEnter]() {
      return html$.Element.mouseEnterEvent.forTarget(this);
    }
    get [dartx.onMouseLeave]() {
      return html$.Element.mouseLeaveEvent.forTarget(this);
    }
    get [dartx.onMouseMove]() {
      return html$.Element.mouseMoveEvent.forTarget(this);
    }
    get [dartx.onMouseOut]() {
      return html$.Element.mouseOutEvent.forTarget(this);
    }
    get [dartx.onMouseOver]() {
      return html$.Element.mouseOverEvent.forTarget(this);
    }
    get [dartx.onMouseUp]() {
      return html$.Element.mouseUpEvent.forTarget(this);
    }
    get [dartx.onMouseWheel]() {
      return html$.Element.mouseWheelEvent.forTarget(this);
    }
    get [dartx.onOffline]() {
      return html$.Window.offlineEvent.forTarget(this);
    }
    get [dartx.onOnline]() {
      return html$.Window.onlineEvent.forTarget(this);
    }
    get [dartx.onPageHide]() {
      return html$.Window.pageHideEvent.forTarget(this);
    }
    get [dartx.onPageShow]() {
      return html$.Window.pageShowEvent.forTarget(this);
    }
    get [dartx.onPause]() {
      return html$.Element.pauseEvent.forTarget(this);
    }
    get [dartx.onPlay]() {
      return html$.Element.playEvent.forTarget(this);
    }
    get [dartx.onPlaying]() {
      return html$.Element.playingEvent.forTarget(this);
    }
    get [dartx.onPopState]() {
      return html$.Window.popStateEvent.forTarget(this);
    }
    get [dartx.onProgress]() {
      return html$.Window.progressEvent.forTarget(this);
    }
    get [dartx.onRateChange]() {
      return html$.Element.rateChangeEvent.forTarget(this);
    }
    get [dartx.onReset]() {
      return html$.Element.resetEvent.forTarget(this);
    }
    get [dartx.onResize]() {
      return html$.Element.resizeEvent.forTarget(this);
    }
    get [dartx.onScroll]() {
      return html$.Element.scrollEvent.forTarget(this);
    }
    get [dartx.onSearch]() {
      return html$.Element.searchEvent.forTarget(this);
    }
    get [dartx.onSeeked]() {
      return html$.Element.seekedEvent.forTarget(this);
    }
    get [dartx.onSeeking]() {
      return html$.Element.seekingEvent.forTarget(this);
    }
    get [dartx.onSelect]() {
      return html$.Element.selectEvent.forTarget(this);
    }
    get [dartx.onStalled]() {
      return html$.Element.stalledEvent.forTarget(this);
    }
    get [dartx.onStorage]() {
      return html$.Window.storageEvent.forTarget(this);
    }
    get [dartx.onSubmit]() {
      return html$.Element.submitEvent.forTarget(this);
    }
    get [dartx.onSuspend]() {
      return html$.Element.suspendEvent.forTarget(this);
    }
    get [dartx.onTimeUpdate]() {
      return html$.Element.timeUpdateEvent.forTarget(this);
    }
    get [dartx.onTouchCancel]() {
      return html$.Element.touchCancelEvent.forTarget(this);
    }
    get [dartx.onTouchEnd]() {
      return html$.Element.touchEndEvent.forTarget(this);
    }
    get [dartx.onTouchMove]() {
      return html$.Element.touchMoveEvent.forTarget(this);
    }
    get [dartx.onTouchStart]() {
      return html$.Element.touchStartEvent.forTarget(this);
    }
    get [dartx.onTransitionEnd]() {
      return html$.Element.transitionEndEvent.forTarget(this);
    }
    get [dartx.onUnload]() {
      return html$.Window.unloadEvent.forTarget(this);
    }
    get [dartx.onVolumeChange]() {
      return html$.Element.volumeChangeEvent.forTarget(this);
    }
    get [dartx.onWaiting]() {
      return html$.Element.waitingEvent.forTarget(this);
    }
    get [dartx.onAnimationEnd]() {
      return html$.Window.animationEndEvent.forTarget(this);
    }
    get [dartx.onAnimationIteration]() {
      return html$.Window.animationIterationEvent.forTarget(this);
    }
    get [dartx.onAnimationStart]() {
      return html$.Window.animationStartEvent.forTarget(this);
    }
    get [dartx.onBeforeUnload]() {
      return html$.Window.beforeUnloadEvent.forTarget(this);
    }
    [dartx.moveTo](p) {
      this[_moveTo](dart.asInt(p.x), dart.asInt(p.y));
    }
    get [dartx.pageXOffset]() {
      return this.pageXOffset[dartx.round]();
    }
    get [dartx.pageYOffset]() {
      return this.pageYOffset[dartx.round]();
    }
    get [dartx.scrollX]() {
      return "scrollX" in this ? this.scrollX[dartx.round]() : this[dartx.document][dartx.documentElement][dartx.scrollLeft];
    }
    get [dartx.scrollY]() {
      return "scrollY" in this ? this.scrollY[dartx.round]() : this[dartx.document][dartx.documentElement][dartx.scrollTop];
    }
  };
  html$.Window[dart.implements] = () => [html$.WindowEventHandlers, html$.WindowBase, html$.GlobalEventHandlers, html$._WindowTimers, html$.WindowBase64];
  dart.setSignature(html$.Window, {
    constructors: () => ({_: dart.definiteFunctionType(html$.Window, [])}),
    methods: () => ({
      [_open2]: dart.definiteFunctionType(html$.WindowBase, [dart.dynamic, dart.dynamic]),
      [_open3]: dart.definiteFunctionType(html$.WindowBase, [dart.dynamic, dart.dynamic, dart.dynamic]),
      [dartx.open]: dart.definiteFunctionType(html$.WindowBase, [core.String, core.String], [core.String]),
      [dartx.requestAnimationFrame]: dart.definiteFunctionType(core.int, [html$.FrameRequestCallback]),
      [dartx.cancelAnimationFrame]: dart.definiteFunctionType(dart.void, [core.int]),
      [_requestAnimationFrame]: dart.definiteFunctionType(core.int, [html$.FrameRequestCallback]),
      [_cancelAnimationFrame]: dart.definiteFunctionType(dart.void, [core.int]),
      [_ensureRequestAnimationFrame]: dart.definiteFunctionType(dart.dynamic, []),
      [dartx.requestFileSystem]: dart.definiteFunctionType(async.Future$(html$.FileSystem), [core.int], {persistent: core.bool}),
      [__getter__]: dart.definiteFunctionType(html$.WindowBase, [dart.dynamic]),
      [__getter___1]: dart.definiteFunctionType(dart.dynamic, [core.int]),
      [__getter___2]: dart.definiteFunctionType(dart.dynamic, [core.String]),
      [dartx.alert]: dart.definiteFunctionType(dart.void, [], [core.String]),
      [dartx.close]: dart.definiteFunctionType(dart.void, []),
      [dartx.confirm]: dart.definiteFunctionType(core.bool, [], [core.String]),
      [dartx.fetch]: dart.definiteFunctionType(async.Future, [dart.dynamic], [core.Map]),
      [_fetch_1]: dart.definiteFunctionType(async.Future, [dart.dynamic, dart.dynamic]),
      [_fetch_2]: dart.definiteFunctionType(async.Future, [dart.dynamic]),
      [dartx.find]: dart.definiteFunctionType(core.bool, [core.String, core.bool, core.bool, core.bool, core.bool, core.bool, core.bool]),
      [_getComputedStyle]: dart.definiteFunctionType(html$.CssStyleDeclaration, [html$.Element, core.String]),
      [dartx.getMatchedCssRules]: dart.definiteFunctionType(core.List$(html$.CssRule), [html$.Element, core.String]),
      [dartx.getSelection]: dart.definiteFunctionType(html$.Selection, []),
      [dartx.matchMedia]: dart.definiteFunctionType(html$.MediaQueryList, [core.String]),
      [dartx.moveBy]: dart.definiteFunctionType(dart.void, [core.int, core.int]),
      [_moveTo]: dart.definiteFunctionType(dart.void, [core.int, core.int]),
      [dartx.openDatabase]: dart.definiteFunctionType(web_sql.SqlDatabase, [core.String, core.String, core.String, core.int], [html$.DatabaseCallback]),
      [dartx.postMessage]: dart.definiteFunctionType(dart.void, [dart.dynamic, core.String], [core.List$(html$.MessagePort)]),
      [_postMessage_1]: dart.definiteFunctionType(dart.void, [dart.dynamic, dart.dynamic, core.List$(html$.MessagePort)]),
      [_postMessage_2]: dart.definiteFunctionType(dart.void, [dart.dynamic, dart.dynamic]),
      [dartx.print]: dart.definiteFunctionType(dart.void, []),
      [dartx.resizeBy]: dart.definiteFunctionType(dart.void, [core.int, core.int]),
      [dartx.resizeTo]: dart.definiteFunctionType(dart.void, [core.int, core.int]),
      [dartx.scroll]: dart.definiteFunctionType(dart.void, [], [dart.dynamic, dart.dynamic, core.Map]),
      [_scroll_1]: dart.definiteFunctionType(dart.void, []),
      [_scroll_2]: dart.definiteFunctionType(dart.void, [dart.dynamic]),
      [_scroll_3]: dart.definiteFunctionType(dart.void, [core.num, core.num]),
      [_scroll_4]: dart.definiteFunctionType(dart.void, [core.int, core.int]),
      [_scroll_5]: dart.definiteFunctionType(dart.void, [core.int, core.int, dart.dynamic]),
      [dartx.scrollBy]: dart.definiteFunctionType(dart.void, [], [dart.dynamic, dart.dynamic, core.Map]),
      [_scrollBy_1]: dart.definiteFunctionType(dart.void, []),
      [_scrollBy_2]: dart.definiteFunctionType(dart.void, [dart.dynamic]),
      [_scrollBy_3]: dart.definiteFunctionType(dart.void, [core.num, core.num]),
      [_scrollBy_4]: dart.definiteFunctionType(dart.void, [core.int, core.int]),
      [_scrollBy_5]: dart.definiteFunctionType(dart.void, [core.int, core.int, dart.dynamic]),
      [dartx.scrollTo]: dart.definiteFunctionType(dart.void, [], [dart.dynamic, dart.dynamic, core.Map]),
      [_scrollTo_1]: dart.definiteFunctionType(dart.void, []),
      [_scrollTo_2]: dart.definiteFunctionType(dart.void, [dart.dynamic]),
      [_scrollTo_3]: dart.definiteFunctionType(dart.void, [core.num, core.num]),
      [_scrollTo_4]: dart.definiteFunctionType(dart.void, [core.int, core.int]),
      [_scrollTo_5]: dart.definiteFunctionType(dart.void, [core.int, core.int, dart.dynamic]),
      [dartx.stop]: dart.definiteFunctionType(dart.void, []),
      [__requestFileSystem]: dart.definiteFunctionType(dart.void, [core.int, core.int, html$._FileSystemCallback], [html$._ErrorCallback]),
      [_requestFileSystem]: dart.definiteFunctionType(async.Future$(html$.FileSystem), [core.int, core.int]),
      [_resolveLocalFileSystemUrl]: dart.definiteFunctionType(dart.void, [core.String, html$._EntryCallback], [html$._ErrorCallback]),
      [dartx.resolveLocalFileSystemUrl]: dart.definiteFunctionType(async.Future$(html$.Entry), [core.String]),
      [dartx.atob]: dart.definiteFunctionType(core.String, [core.String]),
      [dartx.btoa]: dart.definiteFunctionType(core.String, [core.String]),
      [_setInterval_String]: dart.definiteFunctionType(core.int, [core.String], [core.int, core.Object]),
      [_setTimeout_String]: dart.definiteFunctionType(core.int, [core.String], [core.int, core.Object]),
      [_clearInterval]: dart.definiteFunctionType(dart.void, [], [core.int]),
      [_clearTimeout]: dart.definiteFunctionType(dart.void, [], [core.int]),
      [_setInterval]: dart.definiteFunctionType(core.int, [core.Object], [core.int]),
      [_setTimeout]: dart.definiteFunctionType(core.int, [core.Object], [core.int]),
      [dartx.moveTo]: dart.definiteFunctionType(dart.void, [math.Point$(core.num)])
    })
  });
  html$.Window.PERSISTENT = 1;
  html$.Window.TEMPORARY = 0;
  dart.defineLazy(html$.Window, {
    get contentLoadedEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('DOMContentLoaded'));
    },
    get deviceMotionEvent() {
      return dart.const(new (EventStreamProviderOfDeviceMotionEvent())('devicemotion'));
    },
    get deviceOrientationEvent() {
      return dart.const(new (EventStreamProviderOfDeviceOrientationEvent())('deviceorientation'));
    },
    get hashChangeEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('hashchange'));
    },
    get loadStartEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('loadstart'));
    },
    get messageEvent() {
      return dart.const(new (EventStreamProviderOfMessageEvent())('message'));
    },
    get offlineEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('offline'));
    },
    get onlineEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('online'));
    },
    get pageHideEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('pagehide'));
    },
    get pageShowEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('pageshow'));
    },
    get popStateEvent() {
      return dart.const(new (EventStreamProviderOfPopStateEvent())('popstate'));
    },
    get progressEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('progress'));
    },
    get storageEvent() {
      return dart.const(new (EventStreamProviderOfStorageEvent())('storage'));
    },
    get unloadEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('unload'));
    },
    get animationEndEvent() {
      return dart.const(new (EventStreamProviderOfAnimationEvent())('webkitAnimationEnd'));
    },
    get animationIterationEvent() {
      return dart.const(new (EventStreamProviderOfAnimationEvent())('webkitAnimationIteration'));
    },
    get animationStartEvent() {
      return dart.const(new (EventStreamProviderOfAnimationEvent())('webkitAnimationStart'));
    },
    get beforeUnloadEvent() {
      return dart.const(new html$._BeforeUnloadEventStreamProvider('beforeunload'));
    }
  });
  dart.registerExtension(dart.global.Window, html$.Window);
  const _returnValue = Symbol('_returnValue');
  html$._WrappedEvent = class _WrappedEvent extends core.Object {
    new(wrapped) {
      this.wrapped = wrapped;
      this[_selector] = null;
    }
    get bubbles() {
      return this.wrapped[dartx.bubbles];
    }
    get cancelable() {
      return this.wrapped[dartx.cancelable];
    }
    get currentTarget() {
      return this.wrapped[dartx.currentTarget];
    }
    get defaultPrevented() {
      return this.wrapped[dartx.defaultPrevented];
    }
    get eventPhase() {
      return this.wrapped[dartx.eventPhase];
    }
    get target() {
      return this.wrapped[dartx.target];
    }
    get timeStamp() {
      return this.wrapped[dartx.timeStamp];
    }
    get type() {
      return this.wrapped[dartx.type];
    }
    [_initEvent](eventTypeArg, canBubbleArg, cancelableArg) {
      dart.throw(new core.UnsupportedError('Cannot initialize this Event.'));
    }
    preventDefault() {
      this.wrapped[dartx.preventDefault]();
    }
    stopImmediatePropagation() {
      this.wrapped[dartx.stopImmediatePropagation]();
    }
    stopPropagation() {
      this.wrapped[dartx.stopPropagation]();
    }
    get matchingTarget() {
      if (this[_selector] == null) {
        dart.throw(new core.UnsupportedError('Cannot call matchingTarget if this Event did' + ' not arise as a result of event delegation.'));
      }
      let currentTarget = html$.Element._check(this.currentTarget);
      let target = html$.Element._check(this.target);
      let matchedTarget = null;
      do {
        if (dart.test(target[dartx.matches](this[_selector]))) return target;
        target = target[dartx.parent];
      } while (target != null && !dart.equals(target, currentTarget[dartx.parent]));
      dart.throw(new core.StateError('No selector matched for populating matchedTarget.'));
    }
    get path() {
      return ListOfNode()._check(this.wrapped[dartx.path]);
    }
    get [_get_currentTarget]() {
      return this.wrapped[_get_currentTarget];
    }
    get [_get_target]() {
      return this.wrapped[_get_target];
    }
  };
  html$._WrappedEvent[dart.implements] = () => [html$.Event];
  dart.setSignature(html$._WrappedEvent, {
    constructors: () => ({new: dart.definiteFunctionType(html$._WrappedEvent, [html$.Event])}),
    methods: () => ({
      [_initEvent]: dart.definiteFunctionType(dart.void, [core.String, core.bool, core.bool]),
      preventDefault: dart.definiteFunctionType(dart.void, []),
      stopImmediatePropagation: dart.definiteFunctionType(dart.void, []),
      stopPropagation: dart.definiteFunctionType(dart.void, [])
    })
  });
  html$._BeforeUnloadEvent = class _BeforeUnloadEvent extends html$._WrappedEvent {
    new(base) {
      this[_returnValue] = null;
      super.new(base);
    }
    get returnValue() {
      return this[_returnValue];
    }
    set returnValue(value) {
      this[_returnValue] = value;
      if ("returnValue" in this.wrapped) {
        this.wrapped.returnValue = value;
      }
    }
  };
  html$._BeforeUnloadEvent[dart.implements] = () => [html$.BeforeUnloadEvent];
  dart.setSignature(html$._BeforeUnloadEvent, {
    constructors: () => ({new: dart.definiteFunctionType(html$._BeforeUnloadEvent, [html$.Event])})
  });
  const _eventType = Symbol('_eventType');
  html$._BeforeUnloadEventStreamProvider = class _BeforeUnloadEventStreamProvider extends core.Object {
    new(eventType) {
      this[_eventType] = eventType;
    }
    forTarget(e, opts) {
      let useCapture = opts && 'useCapture' in opts ? opts.useCapture : false;
      let stream = new (_EventStreamOfEvent())(e, this[_eventType], useCapture);
      let controller = StreamControllerOfBeforeUnloadEvent().new({sync: true});
      stream.listen(dart.fn(event => {
        let wrapped = new html$._BeforeUnloadEvent(event);
        controller.add(wrapped);
      }, EventTovoid$()));
      return controller.stream;
    }
    getEventType(target) {
      return this[_eventType];
    }
    forElement(e, opts) {
      let useCapture = opts && 'useCapture' in opts ? opts.useCapture : false;
      return new (_ElementEventStreamImplOfEvent())(e, this[_eventType], useCapture);
    }
    [_forElementList](e, opts) {
      let useCapture = opts && 'useCapture' in opts ? opts.useCapture : false;
      return new (_ElementListEventStreamImplOfEvent())(e, this[_eventType], useCapture);
    }
  };
  html$._BeforeUnloadEventStreamProvider[dart.implements] = () => [EventStreamProviderOfBeforeUnloadEvent()];
  dart.setSignature(html$._BeforeUnloadEventStreamProvider, {
    constructors: () => ({new: dart.definiteFunctionType(html$._BeforeUnloadEventStreamProvider, [core.String])}),
    methods: () => ({
      forTarget: dart.definiteFunctionType(async.Stream$(html$.BeforeUnloadEvent), [html$.EventTarget], {useCapture: core.bool}),
      getEventType: dart.definiteFunctionType(core.String, [html$.EventTarget]),
      forElement: dart.definiteFunctionType(html$.ElementStream$(html$.BeforeUnloadEvent), [html$.Element], {useCapture: core.bool}),
      [_forElementList]: dart.definiteFunctionType(html$.ElementStream$(html$.BeforeUnloadEvent), [html$.ElementList$(html$.Element)], {useCapture: core.bool})
    })
  });
  html$.WindowBase64 = class WindowBase64 extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(html$.WindowBase64, {
    constructors: () => ({_: dart.definiteFunctionType(html$.WindowBase64, [])})
  });
  dart.defineExtensionNames([
    'focus',
    'focused',
    'visibilityState'
  ]);
  html$.WindowClient = class WindowClient extends html$.Client {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.focused]() {
      return this.focused;
    }
    get [dartx.visibilityState]() {
      return this.visibilityState;
    }
    [dartx.focus]() {
      return this.focus();
    }
  };
  dart.setSignature(html$.WindowClient, {
    constructors: () => ({_: dart.definiteFunctionType(html$.WindowClient, [])}),
    methods: () => ({[dartx.focus]: dart.definiteFunctionType(async.Future, [])})
  });
  dart.registerExtension(dart.global.WindowClient, html$.WindowClient);
  dart.defineExtensionNames([
    'onHashChange',
    'onMessage',
    'onOffline',
    'onOnline',
    'onPopState',
    'onStorage',
    'onUnload'
  ]);
  html$.WindowEventHandlers = class WindowEventHandlers extends html$.EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get onHashChange() {
      return html$.WindowEventHandlers.hashChangeEvent.forTarget(this);
    }
    get onMessage() {
      return html$.WindowEventHandlers.messageEvent.forTarget(this);
    }
    get onOffline() {
      return html$.WindowEventHandlers.offlineEvent.forTarget(this);
    }
    get onOnline() {
      return html$.WindowEventHandlers.onlineEvent.forTarget(this);
    }
    get onPopState() {
      return html$.WindowEventHandlers.popStateEvent.forTarget(this);
    }
    get onStorage() {
      return html$.WindowEventHandlers.storageEvent.forTarget(this);
    }
    get onUnload() {
      return html$.WindowEventHandlers.unloadEvent.forTarget(this);
    }
  };
  dart.setSignature(html$.WindowEventHandlers, {
    constructors: () => ({_: dart.definiteFunctionType(html$.WindowEventHandlers, [])})
  });
  dart.defineExtensionMembers(html$.WindowEventHandlers, [
    'onHashChange',
    'onMessage',
    'onOffline',
    'onOnline',
    'onPopState',
    'onStorage',
    'onUnload'
  ]);
  dart.defineLazy(html$.WindowEventHandlers, {
    get hashChangeEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('hashchange'));
    },
    get messageEvent() {
      return dart.const(new (EventStreamProviderOfMessageEvent())('message'));
    },
    get offlineEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('offline'));
    },
    get onlineEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('online'));
    },
    get popStateEvent() {
      return dart.const(new (EventStreamProviderOfPopStateEvent())('popstate'));
    },
    get storageEvent() {
      return dart.const(new (EventStreamProviderOfStorageEvent())('storage'));
    },
    get unloadEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('unload'));
    }
  });
  dart.defineExtensionNames([
    'postMessage',
    'terminate',
    'onError',
    'onMessage'
  ]);
  html$.Worker = class Worker extends html$.EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(scriptUrl) {
      return html$.Worker._create_1(scriptUrl);
    }
    static _create_1(scriptUrl) {
      return new Worker(scriptUrl);
    }
    static get supported() {
      return typeof window.Worker != "undefined";
    }
    [dartx.postMessage](message, transfer) {
      if (transfer === void 0) transfer = null;
      if (transfer != null) {
        let message_1 = html_common.convertDartToNative_SerializedScriptValue(message);
        this[_postMessage_1](message_1, transfer);
        return;
      }
      let message_1 = html_common.convertDartToNative_SerializedScriptValue(message);
      this[_postMessage_2](message_1);
      return;
    }
    [_postMessage_1](message, transfer) {
      return this.postMessage(message, transfer);
    }
    [_postMessage_2](message) {
      return this.postMessage(message);
    }
    [dartx.terminate]() {
      return this.terminate();
    }
    get [dartx.onError]() {
      return html$.Worker.errorEvent.forTarget(this);
    }
    get [dartx.onMessage]() {
      return html$.Worker.messageEvent.forTarget(this);
    }
  };
  html$.Worker[dart.implements] = () => [html$.AbstractWorker];
  dart.setSignature(html$.Worker, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.Worker, []),
      new: dart.definiteFunctionType(html$.Worker, [core.String])
    }),
    methods: () => ({
      [dartx.postMessage]: dart.definiteFunctionType(dart.void, [dart.dynamic], [core.List$(html$.MessagePort)]),
      [_postMessage_1]: dart.definiteFunctionType(dart.void, [dart.dynamic, core.List$(html$.MessagePort)]),
      [_postMessage_2]: dart.definiteFunctionType(dart.void, [dart.dynamic]),
      [dartx.terminate]: dart.definiteFunctionType(dart.void, [])
    }),
    statics: () => ({_create_1: dart.definiteFunctionType(html$.Worker, [dart.dynamic])}),
    names: ['_create_1']
  });
  dart.defineLazy(html$.Worker, {
    get errorEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('error'));
    },
    get messageEvent() {
      return dart.const(new (EventStreamProviderOfMessageEvent())('message'));
    }
  });
  dart.registerExtension(dart.global.Worker, html$.Worker);
  html$.WorkerConsole = class WorkerConsole extends html$.ConsoleBase {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(html$.WorkerConsole, {
    constructors: () => ({_: dart.definiteFunctionType(html$.WorkerConsole, [])})
  });
  dart.registerExtension(dart.global.WorkerConsole, html$.WorkerConsole);
  dart.defineExtensionNames([
    'clearMarks',
    'clearMeasures',
    'getEntries',
    'getEntriesByName',
    'getEntriesByType',
    'mark',
    'measure',
    'now',
    'clearResourceTimings',
    'setResourceTimingBufferSize',
    'memory'
  ]);
  html$.WorkerPerformance = class WorkerPerformance extends html$.EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.memory]() {
      return this.memory;
    }
    [dartx.clearMarks](markName) {
      return this.clearMarks(markName);
    }
    [dartx.clearMeasures](measureName) {
      return this.clearMeasures(measureName);
    }
    [dartx.getEntries]() {
      return this.getEntries();
    }
    [dartx.getEntriesByName](name, entryType) {
      return this.getEntriesByName(name, entryType);
    }
    [dartx.getEntriesByType](entryType) {
      return this.getEntriesByType(entryType);
    }
    [dartx.mark](markName) {
      return this.mark(markName);
    }
    [dartx.measure](measureName, startMark, endMark) {
      return this.measure(measureName, startMark, endMark);
    }
    [dartx.now]() {
      return this.now();
    }
    [dartx.clearResourceTimings]() {
      return this.webkitClearResourceTimings();
    }
    [dartx.setResourceTimingBufferSize](maxSize) {
      return this.webkitSetResourceTimingBufferSize(maxSize);
    }
  };
  dart.setSignature(html$.WorkerPerformance, {
    constructors: () => ({_: dart.definiteFunctionType(html$.WorkerPerformance, [])}),
    methods: () => ({
      [dartx.clearMarks]: dart.definiteFunctionType(dart.void, [core.String]),
      [dartx.clearMeasures]: dart.definiteFunctionType(dart.void, [core.String]),
      [dartx.getEntries]: dart.definiteFunctionType(core.List$(html$.PerformanceEntry), []),
      [dartx.getEntriesByName]: dart.definiteFunctionType(core.List$(html$.PerformanceEntry), [core.String, core.String]),
      [dartx.getEntriesByType]: dart.definiteFunctionType(core.List$(html$.PerformanceEntry), [core.String]),
      [dartx.mark]: dart.definiteFunctionType(dart.void, [core.String]),
      [dartx.measure]: dart.definiteFunctionType(dart.void, [core.String, core.String, core.String]),
      [dartx.now]: dart.definiteFunctionType(core.double, []),
      [dartx.clearResourceTimings]: dart.definiteFunctionType(dart.void, []),
      [dartx.setResourceTimingBufferSize]: dart.definiteFunctionType(dart.void, [core.int])
    })
  });
  dart.registerExtension(dart.global.WorkerPerformance, html$.WorkerPerformance);
  dart.defineExtensionNames([
    'createExpression',
    'createNSResolver',
    'evaluate'
  ]);
  html$.XPathEvaluator = class XPathEvaluator extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return html$.XPathEvaluator._create_1();
    }
    static _create_1() {
      return new XPathEvaluator();
    }
    [dartx.createExpression](expression, resolver) {
      return this.createExpression(expression, resolver);
    }
    [dartx.createNSResolver](nodeResolver) {
      return this.createNSResolver(nodeResolver);
    }
    [dartx.evaluate](expression, contextNode, resolver, type, inResult) {
      return this.evaluate(expression, contextNode, resolver, type, inResult);
    }
  };
  dart.setSignature(html$.XPathEvaluator, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.XPathEvaluator, []),
      new: dart.definiteFunctionType(html$.XPathEvaluator, [])
    }),
    methods: () => ({
      [dartx.createExpression]: dart.definiteFunctionType(html$.XPathExpression, [core.String, html$.XPathNSResolver]),
      [dartx.createNSResolver]: dart.definiteFunctionType(html$.XPathNSResolver, [html$.Node]),
      [dartx.evaluate]: dart.definiteFunctionType(html$.XPathResult, [core.String, html$.Node, html$.XPathNSResolver], [core.int, core.Object])
    }),
    statics: () => ({_create_1: dart.definiteFunctionType(html$.XPathEvaluator, [])}),
    names: ['_create_1']
  });
  dart.registerExtension(dart.global.XPathEvaluator, html$.XPathEvaluator);
  dart.defineExtensionNames([
    'evaluate'
  ]);
  html$.XPathExpression = class XPathExpression extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [dartx.evaluate](contextNode, type, inResult) {
      return this.evaluate(contextNode, type, inResult);
    }
  };
  dart.setSignature(html$.XPathExpression, {
    constructors: () => ({_: dart.definiteFunctionType(html$.XPathExpression, [])}),
    methods: () => ({[dartx.evaluate]: dart.definiteFunctionType(html$.XPathResult, [html$.Node], [core.int, core.Object])})
  });
  dart.registerExtension(dart.global.XPathExpression, html$.XPathExpression);
  dart.defineExtensionNames([
    'lookupNamespaceUri'
  ]);
  html$.XPathNSResolver = class XPathNSResolver extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [dartx.lookupNamespaceUri](prefix) {
      return this.lookupNamespaceURI(prefix);
    }
  };
  dart.setSignature(html$.XPathNSResolver, {
    constructors: () => ({_: dart.definiteFunctionType(html$.XPathNSResolver, [])}),
    methods: () => ({[dartx.lookupNamespaceUri]: dart.definiteFunctionType(core.String, [core.String])})
  });
  dart.registerExtension(dart.global.XPathNSResolver, html$.XPathNSResolver);
  dart.defineExtensionNames([
    'iterateNext',
    'snapshotItem',
    'booleanValue',
    'invalidIteratorState',
    'numberValue',
    'resultType',
    'singleNodeValue',
    'snapshotLength',
    'stringValue'
  ]);
  html$.XPathResult = class XPathResult extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.booleanValue]() {
      return this.booleanValue;
    }
    get [dartx.invalidIteratorState]() {
      return this.invalidIteratorState;
    }
    get [dartx.numberValue]() {
      return this.numberValue;
    }
    get [dartx.resultType]() {
      return this.resultType;
    }
    get [dartx.singleNodeValue]() {
      return this.singleNodeValue;
    }
    get [dartx.snapshotLength]() {
      return this.snapshotLength;
    }
    get [dartx.stringValue]() {
      return this.stringValue;
    }
    [dartx.iterateNext]() {
      return this.iterateNext();
    }
    [dartx.snapshotItem](index) {
      return this.snapshotItem(index);
    }
  };
  dart.setSignature(html$.XPathResult, {
    constructors: () => ({_: dart.definiteFunctionType(html$.XPathResult, [])}),
    methods: () => ({
      [dartx.iterateNext]: dart.definiteFunctionType(html$.Node, []),
      [dartx.snapshotItem]: dart.definiteFunctionType(html$.Node, [core.int])
    })
  });
  html$.XPathResult.ANY_TYPE = 0;
  html$.XPathResult.ANY_UNORDERED_NODE_TYPE = 8;
  html$.XPathResult.BOOLEAN_TYPE = 3;
  html$.XPathResult.FIRST_ORDERED_NODE_TYPE = 9;
  html$.XPathResult.NUMBER_TYPE = 1;
  html$.XPathResult.ORDERED_NODE_ITERATOR_TYPE = 5;
  html$.XPathResult.ORDERED_NODE_SNAPSHOT_TYPE = 7;
  html$.XPathResult.STRING_TYPE = 2;
  html$.XPathResult.UNORDERED_NODE_ITERATOR_TYPE = 4;
  html$.XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE = 6;
  dart.registerExtension(dart.global.XPathResult, html$.XPathResult);
  html$.XmlDocument = class XmlDocument extends html$.Document {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(html$.XmlDocument, {
    constructors: () => ({_: dart.definiteFunctionType(html$.XmlDocument, [])})
  });
  dart.registerExtension(dart.global.XMLDocument, html$.XmlDocument);
  dart.defineExtensionNames([
    'serializeToString'
  ]);
  html$.XmlSerializer = class XmlSerializer extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return html$.XmlSerializer._create_1();
    }
    static _create_1() {
      return new XMLSerializer();
    }
    [dartx.serializeToString](root) {
      return this.serializeToString(root);
    }
  };
  dart.setSignature(html$.XmlSerializer, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.XmlSerializer, []),
      new: dart.definiteFunctionType(html$.XmlSerializer, [])
    }),
    methods: () => ({[dartx.serializeToString]: dart.definiteFunctionType(core.String, [html$.Node])}),
    statics: () => ({_create_1: dart.definiteFunctionType(html$.XmlSerializer, [])}),
    names: ['_create_1']
  });
  dart.registerExtension(dart.global.XMLSerializer, html$.XmlSerializer);
  dart.defineExtensionNames([
    'clearParameters',
    'getParameter',
    'importStylesheet',
    'removeParameter',
    'reset',
    'setParameter',
    'transformToDocument',
    'transformToFragment'
  ]);
  html$.XsltProcessor = class XsltProcessor extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return html$.XsltProcessor._create_1();
    }
    static _create_1() {
      return new XSLTProcessor();
    }
    static get supported() {
      return !!window.XSLTProcessor;
    }
    [dartx.clearParameters]() {
      return this.clearParameters();
    }
    [dartx.getParameter](namespaceURI, localName) {
      return this.getParameter(namespaceURI, localName);
    }
    [dartx.importStylesheet](style) {
      return this.importStylesheet(style);
    }
    [dartx.removeParameter](namespaceURI, localName) {
      return this.removeParameter(namespaceURI, localName);
    }
    [dartx.reset]() {
      return this.reset();
    }
    [dartx.setParameter](namespaceURI, localName, value) {
      return this.setParameter(namespaceURI, localName, value);
    }
    [dartx.transformToDocument](source) {
      return this.transformToDocument(source);
    }
    [dartx.transformToFragment](source, output) {
      return this.transformToFragment(source, output);
    }
  };
  dart.setSignature(html$.XsltProcessor, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$.XsltProcessor, []),
      new: dart.definiteFunctionType(html$.XsltProcessor, [])
    }),
    methods: () => ({
      [dartx.clearParameters]: dart.definiteFunctionType(dart.void, []),
      [dartx.getParameter]: dart.definiteFunctionType(core.String, [core.String, core.String]),
      [dartx.importStylesheet]: dart.definiteFunctionType(dart.void, [html$.Node]),
      [dartx.removeParameter]: dart.definiteFunctionType(dart.void, [core.String, core.String]),
      [dartx.reset]: dart.definiteFunctionType(dart.void, []),
      [dartx.setParameter]: dart.definiteFunctionType(dart.void, [core.String, core.String, core.String]),
      [dartx.transformToDocument]: dart.definiteFunctionType(html$.Document, [html$.Node]),
      [dartx.transformToFragment]: dart.definiteFunctionType(html$.DocumentFragment, [html$.Node, html$.Document])
    }),
    statics: () => ({_create_1: dart.definiteFunctionType(html$.XsltProcessor, [])}),
    names: ['_create_1']
  });
  dart.registerExtension(dart.global.XSLTProcessor, html$.XsltProcessor);
  dart.defineExtensionNames([
    'name',
    'value'
  ]);
  html$._Attr = class _Attr extends html$.Node {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.name]() {
      return this.name;
    }
    get [dartx.value]() {
      return this.value;
    }
    set [dartx.value](value) {
      this.value = value;
    }
  };
  dart.setSignature(html$._Attr, {
    constructors: () => ({_: dart.definiteFunctionType(html$._Attr, [])})
  });
  dart.registerExtension(dart.global.Attr, html$._Attr);
  html$._Cache = class _Cache extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(html$._Cache, {
    constructors: () => ({_: dart.definiteFunctionType(html$._Cache, [])})
  });
  dart.registerExtension(dart.global.Cache, html$._Cache);
  html$._CanvasPathMethods = class _CanvasPathMethods extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(html$._CanvasPathMethods, {
    constructors: () => ({_: dart.definiteFunctionType(html$._CanvasPathMethods, [])})
  });
  dart.defineExtensionNames([
    'toString',
    '==',
    'hashCode',
    'intersection',
    'intersects',
    'boundingBox',
    'containsRectangle',
    'containsPoint',
    'topLeft',
    'topRight',
    'bottomRight',
    'bottomLeft',
    'bottom',
    'height',
    'left',
    'right',
    'top',
    'width'
  ]);
  html$._ClientRect = class _ClientRect extends _interceptors.Interceptor {
    [dartx.toString]() {
      return dart.str`Rectangle (${this[dartx.left]}, ${this[dartx.top]}) ${this[dartx.width]} x ${this[dartx.height]}`;
    }
    [dartx['==']](other) {
      if (!RectangleOfnum().is(other)) return false;
      return dart.equals(this[dartx.left], dart.dload(other, 'left')) && dart.equals(this[dartx.top], dart.dload(other, 'top')) && dart.equals(this[dartx.width], dart.dload(other, 'width')) && dart.equals(this[dartx.height], dart.dload(other, 'height'));
    }
    get [dartx.hashCode]() {
      return html$._JenkinsSmiHash.hash4(dart.hashCode(this[dartx.left]), dart.hashCode(this[dartx.top]), dart.hashCode(this[dartx.width]), dart.hashCode(this[dartx.height]));
    }
    [dartx.intersection](other) {
      let x0 = math.max(core.num)(this[dartx.left], other[dartx.left]);
      let x1 = math.min(core.num)(dart.notNull(this[dartx.left]) + dart.notNull(this[dartx.width]), dart.notNull(other[dartx.left]) + dart.notNull(other[dartx.width]));
      if (dart.notNull(x0) <= dart.notNull(x1)) {
        let y0 = math.max(core.num)(this[dartx.top], other[dartx.top]);
        let y1 = math.min(core.num)(dart.notNull(this[dartx.top]) + dart.notNull(this[dartx.height]), dart.notNull(other[dartx.top]) + dart.notNull(other[dartx.height]));
        if (dart.notNull(y0) <= dart.notNull(y1)) {
          return new (RectangleOfnum())(x0, y0, dart.notNull(x1) - dart.notNull(x0), dart.notNull(y1) - dart.notNull(y0));
        }
      }
      return null;
    }
    [dartx.intersects](other) {
      return dart.notNull(this[dartx.left]) <= dart.notNull(other[dartx.left]) + dart.notNull(other[dartx.width]) && dart.notNull(other[dartx.left]) <= dart.notNull(this[dartx.left]) + dart.notNull(this[dartx.width]) && dart.notNull(this[dartx.top]) <= dart.notNull(other[dartx.top]) + dart.notNull(other[dartx.height]) && dart.notNull(other[dartx.top]) <= dart.notNull(this[dartx.top]) + dart.notNull(this[dartx.height]);
    }
    [dartx.boundingBox](other) {
      let right = math.max(core.num)(dart.notNull(this[dartx.left]) + dart.notNull(this[dartx.width]), dart.notNull(other[dartx.left]) + dart.notNull(other[dartx.width]));
      let bottom = math.max(core.num)(dart.notNull(this[dartx.top]) + dart.notNull(this[dartx.height]), dart.notNull(other[dartx.top]) + dart.notNull(other[dartx.height]));
      let left = math.min(core.num)(this[dartx.left], other[dartx.left]);
      let top = math.min(core.num)(this[dartx.top], other[dartx.top]);
      return new (RectangleOfnum())(left, top, dart.notNull(right) - dart.notNull(left), dart.notNull(bottom) - dart.notNull(top));
    }
    [dartx.containsRectangle](another) {
      return dart.notNull(this[dartx.left]) <= dart.notNull(another[dartx.left]) && dart.notNull(this[dartx.left]) + dart.notNull(this[dartx.width]) >= dart.notNull(another[dartx.left]) + dart.notNull(another[dartx.width]) && dart.notNull(this[dartx.top]) <= dart.notNull(another[dartx.top]) && dart.notNull(this[dartx.top]) + dart.notNull(this[dartx.height]) >= dart.notNull(another[dartx.top]) + dart.notNull(another[dartx.height]);
    }
    [dartx.containsPoint](another) {
      return dart.notNull(another.x) >= dart.notNull(this[dartx.left]) && dart.notNull(another.x) <= dart.notNull(this[dartx.left]) + dart.notNull(this[dartx.width]) && dart.notNull(another.y) >= dart.notNull(this[dartx.top]) && dart.notNull(another.y) <= dart.notNull(this[dartx.top]) + dart.notNull(this[dartx.height]);
    }
    get [dartx.topLeft]() {
      return new (PointOfnum())(this[dartx.left], this[dartx.top]);
    }
    get [dartx.topRight]() {
      return new (PointOfnum())(dart.notNull(this[dartx.left]) + dart.notNull(this[dartx.width]), this[dartx.top]);
    }
    get [dartx.bottomRight]() {
      return new (PointOfnum())(dart.notNull(this[dartx.left]) + dart.notNull(this[dartx.width]), dart.notNull(this[dartx.top]) + dart.notNull(this[dartx.height]));
    }
    get [dartx.bottomLeft]() {
      return new (PointOfnum())(this[dartx.left], dart.notNull(this[dartx.top]) + dart.notNull(this[dartx.height]));
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.bottom]() {
      return this.bottom;
    }
    get [dartx.height]() {
      return this.height;
    }
    get [dartx.left]() {
      return this.left;
    }
    get [dartx.right]() {
      return this.right;
    }
    get [dartx.top]() {
      return this.top;
    }
    get [dartx.width]() {
      return this.width;
    }
  };
  html$._ClientRect[dart.implements] = () => [RectangleOfnum()];
  dart.setSignature(html$._ClientRect, {
    constructors: () => ({_: dart.definiteFunctionType(html$._ClientRect, [])}),
    methods: () => ({
      [dartx.intersection]: dart.definiteFunctionType(math.Rectangle$(core.num), [math.Rectangle$(core.num)]),
      [dartx.intersects]: dart.definiteFunctionType(core.bool, [math.Rectangle$(core.num)]),
      [dartx.boundingBox]: dart.definiteFunctionType(math.Rectangle$(core.num), [math.Rectangle$(core.num)]),
      [dartx.containsRectangle]: dart.definiteFunctionType(core.bool, [math.Rectangle$(core.num)]),
      [dartx.containsPoint]: dart.definiteFunctionType(core.bool, [math.Point$(core.num)])
    })
  });
  dart.registerExtension(dart.global.ClientRect, html$._ClientRect);
  html$._JenkinsSmiHash = class _JenkinsSmiHash extends core.Object {
    static combine(hash, value) {
      hash = 536870911 & dart.notNull(hash) + dart.notNull(value);
      hash = 536870911 & dart.notNull(hash) + ((524287 & dart.notNull(hash)) << 10);
      return (dart.notNull(hash) ^ hash[dartx['>>']](6)) >>> 0;
    }
    static finish(hash) {
      hash = 536870911 & dart.notNull(hash) + ((67108863 & dart.notNull(hash)) << 3);
      hash = (dart.notNull(hash) ^ hash[dartx['>>']](11)) >>> 0;
      return 536870911 & dart.notNull(hash) + ((16383 & dart.notNull(hash)) << 15);
    }
    static hash2(a, b) {
      return html$._JenkinsSmiHash.finish(html$._JenkinsSmiHash.combine(html$._JenkinsSmiHash.combine(0, core.int._check(a)), core.int._check(b)));
    }
    static hash4(a, b, c, d) {
      return html$._JenkinsSmiHash.finish(html$._JenkinsSmiHash.combine(html$._JenkinsSmiHash.combine(html$._JenkinsSmiHash.combine(html$._JenkinsSmiHash.combine(0, core.int._check(a)), core.int._check(b)), core.int._check(c)), core.int._check(d)));
    }
  };
  dart.setSignature(html$._JenkinsSmiHash, {
    statics: () => ({
      combine: dart.definiteFunctionType(core.int, [core.int, core.int]),
      finish: dart.definiteFunctionType(core.int, [core.int]),
      hash2: dart.definiteFunctionType(core.int, [dart.dynamic, dart.dynamic]),
      hash4: dart.definiteFunctionType(core.int, [dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic])
    }),
    names: ['combine', 'finish', 'hash2', 'hash4']
  });
  dart.defineExtensionNames([
    'length',
    'get',
    'set',
    'length',
    'first',
    'last',
    'single',
    'elementAt',
    'item'
  ]);
  html$._ClientRectList = class _ClientRectList extends dart.mixin(_interceptors.Interceptor, collection.ListMixin$(math.Rectangle$(core.num)), html$.ImmutableListMixin$(math.Rectangle$(core.num))) {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.length]() {
      return this.length;
    }
    [dartx.get](index) {
      if (index >>> 0 !== index || index >= this[dartx.length]) dart.throw(core.RangeError.index(index, this));
      return this[dartx.item](index);
    }
    [dartx.set](index, value) {
      dart.throw(new core.UnsupportedError("Cannot assign element of immutable List."));
      return value;
    }
    set [dartx.length](value) {
      dart.throw(new core.UnsupportedError("Cannot resize immutable List."));
    }
    get [dartx.first]() {
      if (dart.notNull(this[dartx.length]) > 0) {
        return this[0];
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.last]() {
      let len = this[dartx.length];
      if (dart.notNull(len) > 0) {
        return this[dart.notNull(len) - 1];
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.single]() {
      let len = this[dartx.length];
      if (len == 1) {
        return this[0];
      }
      if (len == 0) dart.throw(new core.StateError("No elements"));
      dart.throw(new core.StateError("More than one element"));
    }
    [dartx.elementAt](index) {
      return this[dartx.get](index);
    }
    [__getter__](index) {
      return this.__getter__(index);
    }
    [dartx.item](index) {
      return this.item(index);
    }
  };
  html$._ClientRectList[dart.implements] = () => [ListOfRectangleOfnum()];
  dart.setSignature(html$._ClientRectList, {
    constructors: () => ({_: dart.definiteFunctionType(html$._ClientRectList, [])}),
    methods: () => ({
      [dartx.get]: dart.definiteFunctionType(math.Rectangle$(core.num), [core.int]),
      [dartx.set]: dart.definiteFunctionType(dart.void, [core.int, math.Rectangle$(core.num)]),
      [dartx.elementAt]: dart.definiteFunctionType(math.Rectangle$(core.num), [core.int]),
      [__getter__]: dart.definiteFunctionType(math.Rectangle$(core.num), [core.int]),
      [dartx.item]: dart.definiteFunctionType(math.Rectangle$(core.num), [core.int])
    })
  });
  dart.registerExtension(dart.global.ClientRectList, html$._ClientRectList);
  dart.defineExtensionNames([
    'length',
    'get',
    'set',
    'length',
    'first',
    'last',
    'single',
    'elementAt',
    'item'
  ]);
  html$._CssRuleList = class _CssRuleList extends dart.mixin(_interceptors.Interceptor, collection.ListMixin$(html$.CssRule), html$.ImmutableListMixin$(html$.CssRule)) {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.length]() {
      return this.length;
    }
    [dartx.get](index) {
      if (index >>> 0 !== index || index >= this[dartx.length]) dart.throw(core.RangeError.index(index, this));
      return this[index];
    }
    [dartx.set](index, value) {
      dart.throw(new core.UnsupportedError("Cannot assign element of immutable List."));
      return value;
    }
    set [dartx.length](value) {
      dart.throw(new core.UnsupportedError("Cannot resize immutable List."));
    }
    get [dartx.first]() {
      if (dart.notNull(this[dartx.length]) > 0) {
        return this[0];
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.last]() {
      let len = this[dartx.length];
      if (dart.notNull(len) > 0) {
        return this[dart.notNull(len) - 1];
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.single]() {
      let len = this[dartx.length];
      if (len == 1) {
        return this[0];
      }
      if (len == 0) dart.throw(new core.StateError("No elements"));
      dart.throw(new core.StateError("More than one element"));
    }
    [dartx.elementAt](index) {
      return this[dartx.get](index);
    }
    [dartx.item](index) {
      return this.item(index);
    }
  };
  html$._CssRuleList[dart.implements] = () => [_js_helper.JavaScriptIndexingBehavior, ListOfCssRule()];
  dart.setSignature(html$._CssRuleList, {
    constructors: () => ({_: dart.definiteFunctionType(html$._CssRuleList, [])}),
    methods: () => ({
      [dartx.get]: dart.definiteFunctionType(html$.CssRule, [core.int]),
      [dartx.set]: dart.definiteFunctionType(dart.void, [core.int, html$.CssRule]),
      [dartx.elementAt]: dart.definiteFunctionType(html$.CssRule, [core.int]),
      [dartx.item]: dart.definiteFunctionType(html$.CssRule, [core.int])
    })
  });
  dart.registerExtension(dart.global.CSSRuleList, html$._CssRuleList);
  html$._DOMFileSystemSync = class _DOMFileSystemSync extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(html$._DOMFileSystemSync, {
    constructors: () => ({_: dart.definiteFunctionType(html$._DOMFileSystemSync, [])})
  });
  dart.registerExtension(dart.global.DOMFileSystemSync, html$._DOMFileSystemSync);
  html$._EntrySync = class _EntrySync extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(html$._EntrySync, {
    constructors: () => ({_: dart.definiteFunctionType(html$._EntrySync, [])})
  });
  dart.registerExtension(dart.global.EntrySync, html$._EntrySync);
  html$._DirectoryEntrySync = class _DirectoryEntrySync extends html$._EntrySync {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(html$._DirectoryEntrySync, {
    constructors: () => ({_: dart.definiteFunctionType(html$._DirectoryEntrySync, [])})
  });
  dart.registerExtension(dart.global.DirectoryEntrySync, html$._DirectoryEntrySync);
  html$._DirectoryReaderSync = class _DirectoryReaderSync extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(html$._DirectoryReaderSync, {
    constructors: () => ({_: dart.definiteFunctionType(html$._DirectoryReaderSync, [])})
  });
  dart.registerExtension(dart.global.DirectoryReaderSync, html$._DirectoryReaderSync);
  html$._DocumentType = class _DocumentType extends html$.Node {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  html$._DocumentType[dart.implements] = () => [html$.ChildNode];
  dart.setSignature(html$._DocumentType, {
    constructors: () => ({_: dart.definiteFunctionType(html$._DocumentType, [])})
  });
  dart.registerExtension(dart.global.DocumentType, html$._DocumentType);
  dart.defineExtensionNames([
    'height',
    'height',
    'width',
    'width',
    'x',
    'x',
    'y',
    'y'
  ]);
  html$._DomRect = class _DomRect extends html$.DomRectReadOnly {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(x, y, width, height) {
      if (x === void 0) x = null;
      if (y === void 0) y = null;
      if (width === void 0) width = null;
      if (height === void 0) height = null;
      if (height != null) {
        return html$._DomRect._create_1(x, y, width, height);
      }
      if (width != null) {
        return html$._DomRect._create_2(x, y, width);
      }
      if (y != null) {
        return html$._DomRect._create_3(x, y);
      }
      if (x != null) {
        return html$._DomRect._create_4(x);
      }
      return html$._DomRect._create_5();
    }
    static _create_1(x, y, width, height) {
      return new DOMRect(x, y, width, height);
    }
    static _create_2(x, y, width) {
      return new DOMRect(x, y, width);
    }
    static _create_3(x, y) {
      return new DOMRect(x, y);
    }
    static _create_4(x) {
      return new DOMRect(x);
    }
    static _create_5() {
      return new DOMRect();
    }
    get [dartx.height]() {
      return this.height;
    }
    set [dartx.height](value) {
      this.height = value;
    }
    get [dartx.width]() {
      return this.width;
    }
    set [dartx.width](value) {
      this.width = value;
    }
    get [dartx.x]() {
      return this.x;
    }
    set [dartx.x](value) {
      this.x = value;
    }
    get [dartx.y]() {
      return this.y;
    }
    set [dartx.y](value) {
      this.y = value;
    }
  };
  dart.setSignature(html$._DomRect, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$._DomRect, []),
      new: dart.definiteFunctionType(html$._DomRect, [], [core.num, core.num, core.num, core.num])
    }),
    statics: () => ({
      _create_1: dart.definiteFunctionType(html$._DomRect, [dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic]),
      _create_2: dart.definiteFunctionType(html$._DomRect, [dart.dynamic, dart.dynamic, dart.dynamic]),
      _create_3: dart.definiteFunctionType(html$._DomRect, [dart.dynamic, dart.dynamic]),
      _create_4: dart.definiteFunctionType(html$._DomRect, [dart.dynamic]),
      _create_5: dart.definiteFunctionType(html$._DomRect, [])
    }),
    names: ['_create_1', '_create_2', '_create_3', '_create_4', '_create_5']
  });
  dart.registerExtension(dart.global.DOMRect, html$._DomRect);
  html$._FileEntrySync = class _FileEntrySync extends html$._EntrySync {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(html$._FileEntrySync, {
    constructors: () => ({_: dart.definiteFunctionType(html$._FileEntrySync, [])})
  });
  dart.registerExtension(dart.global.FileEntrySync, html$._FileEntrySync);
  html$._FileReaderSync = class _FileReaderSync extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return html$._FileReaderSync._create_1();
    }
    static _create_1() {
      return new FileReaderSync();
    }
  };
  dart.setSignature(html$._FileReaderSync, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$._FileReaderSync, []),
      new: dart.definiteFunctionType(html$._FileReaderSync, [])
    }),
    statics: () => ({_create_1: dart.definiteFunctionType(html$._FileReaderSync, [])}),
    names: ['_create_1']
  });
  dart.registerExtension(dart.global.FileReaderSync, html$._FileReaderSync);
  html$._FileWriterSync = class _FileWriterSync extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(html$._FileWriterSync, {
    constructors: () => ({_: dart.definiteFunctionType(html$._FileWriterSync, [])})
  });
  dart.registerExtension(dart.global.FileWriterSync, html$._FileWriterSync);
  dart.defineExtensionNames([
    'length',
    'get',
    'set',
    'length',
    'first',
    'last',
    'single',
    'elementAt',
    'item'
  ]);
  html$._GamepadList = class _GamepadList extends dart.mixin(_interceptors.Interceptor, collection.ListMixin$(html$.Gamepad), html$.ImmutableListMixin$(html$.Gamepad)) {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.length]() {
      return this.length;
    }
    [dartx.get](index) {
      if (index >>> 0 !== index || index >= this[dartx.length]) dart.throw(core.RangeError.index(index, this));
      return this[index];
    }
    [dartx.set](index, value) {
      dart.throw(new core.UnsupportedError("Cannot assign element of immutable List."));
      return value;
    }
    set [dartx.length](value) {
      dart.throw(new core.UnsupportedError("Cannot resize immutable List."));
    }
    get [dartx.first]() {
      if (dart.notNull(this[dartx.length]) > 0) {
        return this[0];
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.last]() {
      let len = this[dartx.length];
      if (dart.notNull(len) > 0) {
        return this[dart.notNull(len) - 1];
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.single]() {
      let len = this[dartx.length];
      if (len == 1) {
        return this[0];
      }
      if (len == 0) dart.throw(new core.StateError("No elements"));
      dart.throw(new core.StateError("More than one element"));
    }
    [dartx.elementAt](index) {
      return this[dartx.get](index);
    }
    [dartx.item](index) {
      return this.item(index);
    }
  };
  html$._GamepadList[dart.implements] = () => [_js_helper.JavaScriptIndexingBehavior, ListOfGamepad()];
  dart.setSignature(html$._GamepadList, {
    constructors: () => ({_: dart.definiteFunctionType(html$._GamepadList, [])}),
    methods: () => ({
      [dartx.get]: dart.definiteFunctionType(html$.Gamepad, [core.int]),
      [dartx.set]: dart.definiteFunctionType(dart.void, [core.int, html$.Gamepad]),
      [dartx.elementAt]: dart.definiteFunctionType(html$.Gamepad, [core.int]),
      [dartx.item]: dart.definiteFunctionType(html$.Gamepad, [core.int])
    })
  });
  dart.registerExtension(dart.global.GamepadList, html$._GamepadList);
  html$._HTMLAllCollection = class _HTMLAllCollection extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [_item](index) {
      return this.item(index);
    }
  };
  dart.setSignature(html$._HTMLAllCollection, {
    constructors: () => ({_: dart.definiteFunctionType(html$._HTMLAllCollection, [])}),
    methods: () => ({[_item]: dart.definiteFunctionType(html$.Element, [core.int])})
  });
  dart.registerExtension(dart.global.HTMLAllCollection, html$._HTMLAllCollection);
  html$._HTMLAppletElement = class _HTMLAppletElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    created() {
      super.created();
    }
  };
  dart.defineNamedConstructor(html$._HTMLAppletElement, 'created');
  dart.setSignature(html$._HTMLAppletElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$._HTMLAppletElement, []),
      created: dart.definiteFunctionType(html$._HTMLAppletElement, [])
    })
  });
  dart.registerExtension(dart.global.HTMLAppletElement, html$._HTMLAppletElement);
  html$._HTMLDirectoryElement = class _HTMLDirectoryElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    created() {
      super.created();
    }
  };
  dart.defineNamedConstructor(html$._HTMLDirectoryElement, 'created');
  dart.setSignature(html$._HTMLDirectoryElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$._HTMLDirectoryElement, []),
      created: dart.definiteFunctionType(html$._HTMLDirectoryElement, [])
    })
  });
  dart.registerExtension(dart.global.HTMLDirectoryElement, html$._HTMLDirectoryElement);
  html$._HTMLFontElement = class _HTMLFontElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    created() {
      super.created();
    }
  };
  dart.defineNamedConstructor(html$._HTMLFontElement, 'created');
  dart.setSignature(html$._HTMLFontElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$._HTMLFontElement, []),
      created: dart.definiteFunctionType(html$._HTMLFontElement, [])
    })
  });
  dart.registerExtension(dart.global.HTMLFontElement, html$._HTMLFontElement);
  html$._HTMLFrameElement = class _HTMLFrameElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    created() {
      super.created();
    }
  };
  dart.defineNamedConstructor(html$._HTMLFrameElement, 'created');
  dart.setSignature(html$._HTMLFrameElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$._HTMLFrameElement, []),
      created: dart.definiteFunctionType(html$._HTMLFrameElement, [])
    })
  });
  dart.registerExtension(dart.global.HTMLFrameElement, html$._HTMLFrameElement);
  html$._HTMLFrameSetElement = class _HTMLFrameSetElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    created() {
      super.created();
    }
  };
  dart.defineNamedConstructor(html$._HTMLFrameSetElement, 'created');
  html$._HTMLFrameSetElement[dart.implements] = () => [html$.WindowEventHandlers];
  dart.setSignature(html$._HTMLFrameSetElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$._HTMLFrameSetElement, []),
      created: dart.definiteFunctionType(html$._HTMLFrameSetElement, [])
    })
  });
  dart.registerExtension(dart.global.HTMLFrameSetElement, html$._HTMLFrameSetElement);
  html$._HTMLMarqueeElement = class _HTMLMarqueeElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    created() {
      super.created();
    }
  };
  dart.defineNamedConstructor(html$._HTMLMarqueeElement, 'created');
  dart.setSignature(html$._HTMLMarqueeElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$._HTMLMarqueeElement, []),
      created: dart.definiteFunctionType(html$._HTMLMarqueeElement, [])
    })
  });
  dart.registerExtension(dart.global.HTMLMarqueeElement, html$._HTMLMarqueeElement);
  dart.defineExtensionNames([
    'length',
    'get',
    'set',
    'length',
    'first',
    'last',
    'single',
    'elementAt',
    'getNamedItem',
    'getNamedItemNS',
    'item',
    'removeNamedItem',
    'removeNamedItemNS',
    'setNamedItem',
    'setNamedItemNS'
  ]);
  html$._NamedNodeMap = class _NamedNodeMap extends dart.mixin(_interceptors.Interceptor, collection.ListMixin$(html$.Node), html$.ImmutableListMixin$(html$.Node)) {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.length]() {
      return this.length;
    }
    [dartx.get](index) {
      if (index >>> 0 !== index || index >= this[dartx.length]) dart.throw(core.RangeError.index(index, this));
      return this[index];
    }
    [dartx.set](index, value) {
      dart.throw(new core.UnsupportedError("Cannot assign element of immutable List."));
      return value;
    }
    set [dartx.length](value) {
      dart.throw(new core.UnsupportedError("Cannot resize immutable List."));
    }
    get [dartx.first]() {
      if (dart.notNull(this[dartx.length]) > 0) {
        return this[0];
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.last]() {
      let len = this[dartx.length];
      if (dart.notNull(len) > 0) {
        return this[dart.notNull(len) - 1];
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.single]() {
      let len = this[dartx.length];
      if (len == 1) {
        return this[0];
      }
      if (len == 0) dart.throw(new core.StateError("No elements"));
      dart.throw(new core.StateError("More than one element"));
    }
    [dartx.elementAt](index) {
      return this[dartx.get](index);
    }
    [dartx.getNamedItem](name) {
      return this.getNamedItem(name);
    }
    [dartx.getNamedItemNS](namespaceURI, localName) {
      return this.getNamedItemNS(namespaceURI, localName);
    }
    [dartx.item](index) {
      return this.item(index);
    }
    [dartx.removeNamedItem](name) {
      return this.removeNamedItem(name);
    }
    [dartx.removeNamedItemNS](namespaceURI, localName) {
      return this.removeNamedItemNS(namespaceURI, localName);
    }
    [dartx.setNamedItem](attr) {
      return this.setNamedItem(attr);
    }
    [dartx.setNamedItemNS](attr) {
      return this.setNamedItemNS(attr);
    }
  };
  html$._NamedNodeMap[dart.implements] = () => [_js_helper.JavaScriptIndexingBehavior, ListOfNode()];
  dart.setSignature(html$._NamedNodeMap, {
    constructors: () => ({_: dart.definiteFunctionType(html$._NamedNodeMap, [])}),
    methods: () => ({
      [dartx.get]: dart.definiteFunctionType(html$.Node, [core.int]),
      [dartx.set]: dart.definiteFunctionType(dart.void, [core.int, html$.Node]),
      [dartx.elementAt]: dart.definiteFunctionType(html$.Node, [core.int]),
      [dartx.getNamedItem]: dart.definiteFunctionType(html$._Attr, [core.String]),
      [dartx.getNamedItemNS]: dart.definiteFunctionType(html$._Attr, [core.String, core.String]),
      [dartx.item]: dart.definiteFunctionType(html$._Attr, [core.int]),
      [dartx.removeNamedItem]: dart.definiteFunctionType(html$._Attr, [core.String]),
      [dartx.removeNamedItemNS]: dart.definiteFunctionType(html$._Attr, [core.String, core.String]),
      [dartx.setNamedItem]: dart.definiteFunctionType(html$._Attr, [html$._Attr]),
      [dartx.setNamedItemNS]: dart.definiteFunctionType(html$._Attr, [html$._Attr])
    })
  });
  dart.registerExtension(dart.global.NamedNodeMap, html$._NamedNodeMap);
  html$._PagePopupController = class _PagePopupController extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(html$._PagePopupController, {
    constructors: () => ({_: dart.definiteFunctionType(html$._PagePopupController, [])})
  });
  dart.registerExtension(dart.global.PagePopupController, html$._PagePopupController);
  dart.defineExtensionNames([
    'clone',
    'context',
    'credentials',
    'headers',
    'mode',
    'referrer',
    'url'
  ]);
  html$._Request = class _Request extends html$.Body {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(input, requestInitDict) {
      if (requestInitDict === void 0) requestInitDict = null;
      if (requestInitDict != null) {
        let requestInitDict_1 = html_common.convertDartToNative_Dictionary(requestInitDict);
        return html$._Request._create_1(input, requestInitDict_1);
      }
      return html$._Request._create_2(input);
    }
    static _create_1(input, requestInitDict) {
      return new Request(input, requestInitDict);
    }
    static _create_2(input) {
      return new Request(input);
    }
    get [dartx.context]() {
      return this.context;
    }
    get [dartx.credentials]() {
      return this.credentials;
    }
    get [dartx.headers]() {
      return this.headers;
    }
    get [dartx.mode]() {
      return this.mode;
    }
    get [dartx.referrer]() {
      return this.referrer;
    }
    get [dartx.url]() {
      return this.url;
    }
    [dartx.clone]() {
      return this.clone();
    }
  };
  dart.setSignature(html$._Request, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$._Request, []),
      new: dart.definiteFunctionType(html$._Request, [core.Object], [core.Map])
    }),
    methods: () => ({[dartx.clone]: dart.definiteFunctionType(html$._Request, [])}),
    statics: () => ({
      _create_1: dart.definiteFunctionType(html$._Request, [dart.dynamic, dart.dynamic]),
      _create_2: dart.definiteFunctionType(html$._Request, [dart.dynamic])
    }),
    names: ['_create_1', '_create_2']
  });
  dart.registerExtension(dart.global.Request, html$._Request);
  html$._Response = class _Response extends html$.Body {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(body, responseInitDict) {
      if (body === void 0) body = null;
      if (responseInitDict === void 0) responseInitDict = null;
      if (responseInitDict != null) {
        let responseInitDict_1 = html_common.convertDartToNative_Dictionary(responseInitDict);
        return html$._Response._create_1(body, responseInitDict_1);
      }
      if (body != null) {
        return html$._Response._create_2(body);
      }
      return html$._Response._create_3();
    }
    static _create_1(body, responseInitDict) {
      return new Response(body, responseInitDict);
    }
    static _create_2(body) {
      return new Response(body);
    }
    static _create_3() {
      return new Response();
    }
  };
  dart.setSignature(html$._Response, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$._Response, []),
      new: dart.definiteFunctionType(html$._Response, [], [core.Object, core.Map])
    }),
    statics: () => ({
      _create_1: dart.definiteFunctionType(html$._Response, [dart.dynamic, dart.dynamic]),
      _create_2: dart.definiteFunctionType(html$._Response, [dart.dynamic]),
      _create_3: dart.definiteFunctionType(html$._Response, [])
    }),
    names: ['_create_1', '_create_2', '_create_3']
  });
  dart.registerExtension(dart.global.Response, html$._Response);
  html$._ServiceWorker = class _ServiceWorker extends html$.EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  html$._ServiceWorker[dart.implements] = () => [html$.AbstractWorker];
  dart.setSignature(html$._ServiceWorker, {
    constructors: () => ({_: dart.definiteFunctionType(html$._ServiceWorker, [])})
  });
  dart.registerExtension(dart.global.ServiceWorker, html$._ServiceWorker);
  dart.defineExtensionNames([
    'length',
    'get',
    'set',
    'length',
    'first',
    'last',
    'single',
    'elementAt',
    'item'
  ]);
  html$._SpeechRecognitionResultList = class _SpeechRecognitionResultList extends dart.mixin(_interceptors.Interceptor, collection.ListMixin$(html$.SpeechRecognitionResult), html$.ImmutableListMixin$(html$.SpeechRecognitionResult)) {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.length]() {
      return this.length;
    }
    [dartx.get](index) {
      if (index >>> 0 !== index || index >= this[dartx.length]) dart.throw(core.RangeError.index(index, this));
      return this[index];
    }
    [dartx.set](index, value) {
      dart.throw(new core.UnsupportedError("Cannot assign element of immutable List."));
      return value;
    }
    set [dartx.length](value) {
      dart.throw(new core.UnsupportedError("Cannot resize immutable List."));
    }
    get [dartx.first]() {
      if (dart.notNull(this[dartx.length]) > 0) {
        return this[0];
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.last]() {
      let len = this[dartx.length];
      if (dart.notNull(len) > 0) {
        return this[dart.notNull(len) - 1];
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.single]() {
      let len = this[dartx.length];
      if (len == 1) {
        return this[0];
      }
      if (len == 0) dart.throw(new core.StateError("No elements"));
      dart.throw(new core.StateError("More than one element"));
    }
    [dartx.elementAt](index) {
      return this[dartx.get](index);
    }
    [dartx.item](index) {
      return this.item(index);
    }
  };
  html$._SpeechRecognitionResultList[dart.implements] = () => [_js_helper.JavaScriptIndexingBehavior, ListOfSpeechRecognitionResult()];
  dart.setSignature(html$._SpeechRecognitionResultList, {
    constructors: () => ({_: dart.definiteFunctionType(html$._SpeechRecognitionResultList, [])}),
    methods: () => ({
      [dartx.get]: dart.definiteFunctionType(html$.SpeechRecognitionResult, [core.int]),
      [dartx.set]: dart.definiteFunctionType(dart.void, [core.int, html$.SpeechRecognitionResult]),
      [dartx.elementAt]: dart.definiteFunctionType(html$.SpeechRecognitionResult, [core.int]),
      [dartx.item]: dart.definiteFunctionType(html$.SpeechRecognitionResult, [core.int])
    })
  });
  dart.registerExtension(dart.global.SpeechRecognitionResultList, html$._SpeechRecognitionResultList);
  dart.defineExtensionNames([
    'length',
    'get',
    'set',
    'length',
    'first',
    'last',
    'single',
    'elementAt',
    'item'
  ]);
  html$._StyleSheetList = class _StyleSheetList extends dart.mixin(_interceptors.Interceptor, collection.ListMixin$(html$.StyleSheet), html$.ImmutableListMixin$(html$.StyleSheet)) {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.length]() {
      return this.length;
    }
    [dartx.get](index) {
      if (index >>> 0 !== index || index >= this[dartx.length]) dart.throw(core.RangeError.index(index, this));
      return this[index];
    }
    [dartx.set](index, value) {
      dart.throw(new core.UnsupportedError("Cannot assign element of immutable List."));
      return value;
    }
    set [dartx.length](value) {
      dart.throw(new core.UnsupportedError("Cannot resize immutable List."));
    }
    get [dartx.first]() {
      if (dart.notNull(this[dartx.length]) > 0) {
        return this[0];
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.last]() {
      let len = this[dartx.length];
      if (dart.notNull(len) > 0) {
        return this[dart.notNull(len) - 1];
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.single]() {
      let len = this[dartx.length];
      if (len == 1) {
        return this[0];
      }
      if (len == 0) dart.throw(new core.StateError("No elements"));
      dart.throw(new core.StateError("More than one element"));
    }
    [dartx.elementAt](index) {
      return this[dartx.get](index);
    }
    [__getter__](name) {
      return this.__getter__(name);
    }
    [dartx.item](index) {
      return this.item(index);
    }
  };
  html$._StyleSheetList[dart.implements] = () => [_js_helper.JavaScriptIndexingBehavior, ListOfStyleSheet()];
  dart.setSignature(html$._StyleSheetList, {
    constructors: () => ({_: dart.definiteFunctionType(html$._StyleSheetList, [])}),
    methods: () => ({
      [dartx.get]: dart.definiteFunctionType(html$.StyleSheet, [core.int]),
      [dartx.set]: dart.definiteFunctionType(dart.void, [core.int, html$.StyleSheet]),
      [dartx.elementAt]: dart.definiteFunctionType(html$.StyleSheet, [core.int]),
      [__getter__]: dart.definiteFunctionType(html$.CssStyleSheet, [core.String]),
      [dartx.item]: dart.definiteFunctionType(html$.StyleSheet, [core.int])
    })
  });
  dart.registerExtension(dart.global.StyleSheetList, html$._StyleSheetList);
  html$._SubtleCrypto = class _SubtleCrypto extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(html$._SubtleCrypto, {
    constructors: () => ({_: dart.definiteFunctionType(html$._SubtleCrypto, [])})
  });
  dart.registerExtension(dart.global.SubtleCrypto, html$._SubtleCrypto);
  html$._WebKitCSSMatrix = class _WebKitCSSMatrix extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(cssValue) {
      if (cssValue === void 0) cssValue = null;
      if (cssValue != null) {
        return html$._WebKitCSSMatrix._create_1(cssValue);
      }
      return html$._WebKitCSSMatrix._create_2();
    }
    static _create_1(cssValue) {
      return new WebKitCSSMatrix(cssValue);
    }
    static _create_2() {
      return new WebKitCSSMatrix();
    }
  };
  dart.setSignature(html$._WebKitCSSMatrix, {
    constructors: () => ({
      _: dart.definiteFunctionType(html$._WebKitCSSMatrix, []),
      new: dart.definiteFunctionType(html$._WebKitCSSMatrix, [], [core.String])
    }),
    statics: () => ({
      _create_1: dart.definiteFunctionType(html$._WebKitCSSMatrix, [dart.dynamic]),
      _create_2: dart.definiteFunctionType(html$._WebKitCSSMatrix, [])
    }),
    names: ['_create_1', '_create_2']
  });
  dart.registerExtension(dart.global.WebKitCSSMatrix, html$._WebKitCSSMatrix);
  html$._WindowTimers = class _WindowTimers extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(html$._WindowTimers, {
    constructors: () => ({_: dart.definiteFunctionType(html$._WindowTimers, [])})
  });
  html$._WorkerLocation = class _WorkerLocation extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  html$._WorkerLocation[dart.implements] = () => [html$.UrlUtilsReadOnly];
  dart.setSignature(html$._WorkerLocation, {
    constructors: () => ({_: dart.definiteFunctionType(html$._WorkerLocation, [])})
  });
  dart.registerExtension(dart.global.WorkerLocation, html$._WorkerLocation);
  html$._WorkerNavigator = class _WorkerNavigator extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  html$._WorkerNavigator[dart.implements] = () => [html$.NavigatorCpu, html$.NavigatorOnLine, html$.NavigatorID];
  dart.setSignature(html$._WorkerNavigator, {
    constructors: () => ({_: dart.definiteFunctionType(html$._WorkerNavigator, [])})
  });
  dart.registerExtension(dart.global.WorkerNavigator, html$._WorkerNavigator);
  html$._XMLHttpRequestProgressEvent = class _XMLHttpRequestProgressEvent extends html$.ProgressEvent {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(html$._XMLHttpRequestProgressEvent, {
    constructors: () => ({_: dart.definiteFunctionType(html$._XMLHttpRequestProgressEvent, [])})
  });
  dart.registerExtension(dart.global.XMLHttpRequestProgressEvent, html$._XMLHttpRequestProgressEvent);
  const _matches = Symbol('_matches');
  html$._AttributeMap = class _AttributeMap extends core.Object {
    new(element) {
      this[_element$] = element;
    }
    addAll(other) {
      other[dartx.forEach](dart.fn((k, v) => {
        this.set(k, v);
      }, StringAndStringTovoid()));
    }
    containsValue(value) {
      for (let v of this.values) {
        if (dart.equals(value, v)) {
          return true;
        }
      }
      return false;
    }
    putIfAbsent(key, ifAbsent) {
      if (!dart.test(this[dartx.containsKey](key))) {
        this.set(key, ifAbsent());
      }
      return this.get(key);
    }
    clear() {
      for (let key of this.keys) {
        this[dartx.remove](key);
      }
    }
    forEach(f) {
      for (let key of this.keys) {
        let value = this.get(key);
        f(key, value);
      }
    }
    get keys() {
      let attributes = this[_element$][_attributes$];
      let keys = JSArrayOfString().of([]);
      for (let i = 0, len = attributes[dartx.length]; i < dart.notNull(len); i++) {
        let attr = html$._Attr._check(attributes[dartx.get](i));
        if (dart.test(this[_matches](attr))) {
          keys[dartx.add](attr[dartx.name]);
        }
      }
      return keys;
    }
    get values() {
      let attributes = this[_element$][_attributes$];
      let values = JSArrayOfString().of([]);
      for (let i = 0, len = attributes[dartx.length]; i < dart.notNull(len); i++) {
        let attr = html$._Attr._check(attributes[dartx.get](i));
        if (dart.test(this[_matches](attr))) {
          values[dartx.add](attr[dartx.value]);
        }
      }
      return values;
    }
    get isEmpty() {
      return this[dartx.length] == 0;
    }
    get isNotEmpty() {
      return !dart.test(this.isEmpty);
    }
  };
  html$._AttributeMap[dart.implements] = () => [MapOfString$String()];
  dart.setSignature(html$._AttributeMap, {
    constructors: () => ({new: dart.definiteFunctionType(html$._AttributeMap, [html$.Element])}),
    methods: () => ({
      addAll: dart.definiteFunctionType(dart.void, [core.Map$(core.String, core.String)]),
      containsValue: dart.definiteFunctionType(core.bool, [core.Object]),
      putIfAbsent: dart.definiteFunctionType(core.String, [core.String, dart.functionType(core.String, [])]),
      clear: dart.definiteFunctionType(dart.void, []),
      forEach: dart.definiteFunctionType(dart.void, [dart.functionType(dart.void, [core.String, core.String])])
    })
  });
  dart.defineExtensionMembers(html$._AttributeMap, [
    'addAll',
    'containsValue',
    'putIfAbsent',
    'clear',
    'forEach',
    'keys',
    'values',
    'isEmpty',
    'isNotEmpty'
  ]);
  html$._ElementAttributeMap = class _ElementAttributeMap extends html$._AttributeMap {
    new(element) {
      super.new(element);
    }
    containsKey(key) {
      return this[_element$][_hasAttribute](core.String._check(key));
    }
    get(key) {
      return this[_element$][dartx.getAttribute](core.String._check(key));
    }
    set(key, value) {
      this[_element$][dartx.setAttribute](key, value);
      return value;
    }
    remove(key) {
      let value = this[_element$][dartx.getAttribute](core.String._check(key));
      this[_element$][_removeAttribute](core.String._check(key));
      return value;
    }
    get length() {
      return this.keys[dartx.length];
    }
    [_matches](node) {
      return node[_namespaceUri] == null;
    }
  };
  dart.setSignature(html$._ElementAttributeMap, {
    constructors: () => ({new: dart.definiteFunctionType(html$._ElementAttributeMap, [html$.Element])}),
    methods: () => ({
      containsKey: dart.definiteFunctionType(core.bool, [core.Object]),
      get: dart.definiteFunctionType(core.String, [core.Object]),
      set: dart.definiteFunctionType(dart.void, [core.String, core.String]),
      remove: dart.definiteFunctionType(core.String, [core.Object]),
      [_matches]: dart.definiteFunctionType(core.bool, [html$.Node])
    })
  });
  dart.defineExtensionMembers(html$._ElementAttributeMap, [
    'containsKey',
    'get',
    'set',
    'remove',
    'length'
  ]);
  const _namespace = Symbol('_namespace');
  html$._NamespacedAttributeMap = class _NamespacedAttributeMap extends html$._AttributeMap {
    new(element, namespace) {
      this[_namespace] = namespace;
      super.new(element);
    }
    containsKey(key) {
      return this[_element$][_hasAttributeNS](this[_namespace], core.String._check(key));
    }
    get(key) {
      return this[_element$][dartx.getAttributeNS](this[_namespace], core.String._check(key));
    }
    set(key, value) {
      this[_element$][dartx.setAttributeNS](this[_namespace], key, value);
      return value;
    }
    remove(key) {
      let value = this.get(key);
      this[_element$][_removeAttributeNS](this[_namespace], core.String._check(key));
      return value;
    }
    get length() {
      return this.keys[dartx.length];
    }
    [_matches](node) {
      return node[_namespaceUri] == this[_namespace];
    }
  };
  dart.setSignature(html$._NamespacedAttributeMap, {
    constructors: () => ({new: dart.definiteFunctionType(html$._NamespacedAttributeMap, [html$.Element, core.String])}),
    methods: () => ({
      containsKey: dart.definiteFunctionType(core.bool, [core.Object]),
      get: dart.definiteFunctionType(core.String, [core.Object]),
      set: dart.definiteFunctionType(dart.void, [core.String, core.String]),
      remove: dart.definiteFunctionType(core.String, [core.Object]),
      [_matches]: dart.definiteFunctionType(core.bool, [html$.Node])
    })
  });
  dart.defineExtensionMembers(html$._NamespacedAttributeMap, [
    'containsKey',
    'get',
    'set',
    'remove',
    'length'
  ]);
  const _attr = Symbol('_attr');
  const _strip = Symbol('_strip');
  const _toHyphenedName = Symbol('_toHyphenedName');
  const _toCamelCase = Symbol('_toCamelCase');
  html$._DataAttributeMap = class _DataAttributeMap extends core.Object {
    new(attributes) {
      this[_attributes$] = attributes;
    }
    addAll(other) {
      other[dartx.forEach](dart.fn((k, v) => {
        this.set(k, v);
      }, StringAndStringTovoid()));
    }
    containsValue(value) {
      return this.values[dartx.any](dart.fn(v => dart.equals(v, value), StringTobool()));
    }
    containsKey(key) {
      return this[_attributes$][dartx.containsKey](this[_attr](core.String._check(key)));
    }
    get(key) {
      return this[_attributes$][dartx.get](this[_attr](core.String._check(key)));
    }
    set(key, value) {
      this[_attributes$][dartx.set](this[_attr](key), value);
      return value;
    }
    putIfAbsent(key, ifAbsent) {
      return this[_attributes$][dartx.putIfAbsent](this[_attr](key), ifAbsent);
    }
    remove(key) {
      return this[_attributes$][dartx.remove](this[_attr](core.String._check(key)));
    }
    clear() {
      for (let key of this.keys) {
        this.remove(key);
      }
    }
    forEach(f) {
      this[_attributes$][dartx.forEach](dart.fn((key, value) => {
        if (dart.test(this[_matches](key))) {
          f(this[_strip](key), value);
        }
      }, StringAndStringTovoid()));
    }
    get keys() {
      let keys = JSArrayOfString().of([]);
      this[_attributes$][dartx.forEach](dart.fn((key, value) => {
        if (dart.test(this[_matches](key))) {
          keys[dartx.add](this[_strip](key));
        }
      }, StringAndStringTovoid()));
      return keys;
    }
    get values() {
      let values = JSArrayOfString().of([]);
      this[_attributes$][dartx.forEach](dart.fn((key, value) => {
        if (dart.test(this[_matches](key))) {
          values[dartx.add](value);
        }
      }, StringAndStringTovoid()));
      return values;
    }
    get length() {
      return this.keys[dartx.length];
    }
    get isEmpty() {
      return this.length == 0;
    }
    get isNotEmpty() {
      return !dart.test(this.isEmpty);
    }
    [_attr](key) {
      return dart.str`data-${this[_toHyphenedName](key)}`;
    }
    [_matches](key) {
      return key[dartx.startsWith]('data-');
    }
    [_strip](key) {
      return this[_toCamelCase](key[dartx.substring](5));
    }
    [_toCamelCase](hyphenedName, opts) {
      let startUppercase = opts && 'startUppercase' in opts ? opts.startUppercase : false;
      let segments = hyphenedName[dartx.split]('-');
      let start = dart.test(startUppercase) ? 0 : 1;
      for (let i = start; i < dart.notNull(segments[dartx.length]); i++) {
        let segment = segments[dartx.get](i);
        if (dart.notNull(segment[dartx.length]) > 0) {
          segments[dartx.set](i, dart.str`${segment[dartx.get](0)[dartx.toUpperCase]()}${segment[dartx.substring](1)}`);
        }
      }
      return segments[dartx.join]('');
    }
    [_toHyphenedName](word) {
      let sb = new core.StringBuffer();
      for (let i = 0; i < dart.notNull(word[dartx.length]); i++) {
        let lower = word[dartx.get](i)[dartx.toLowerCase]();
        if (word[dartx.get](i) != lower && i > 0) sb.write('-');
        sb.write(lower);
      }
      return sb.toString();
    }
  };
  html$._DataAttributeMap[dart.implements] = () => [MapOfString$String()];
  dart.setSignature(html$._DataAttributeMap, {
    constructors: () => ({new: dart.definiteFunctionType(html$._DataAttributeMap, [core.Map$(core.String, core.String)])}),
    methods: () => ({
      addAll: dart.definiteFunctionType(dart.void, [core.Map$(core.String, core.String)]),
      containsValue: dart.definiteFunctionType(core.bool, [core.Object]),
      containsKey: dart.definiteFunctionType(core.bool, [core.Object]),
      get: dart.definiteFunctionType(core.String, [core.Object]),
      set: dart.definiteFunctionType(dart.void, [core.String, core.String]),
      putIfAbsent: dart.definiteFunctionType(core.String, [core.String, dart.functionType(core.String, [])]),
      remove: dart.definiteFunctionType(core.String, [core.Object]),
      clear: dart.definiteFunctionType(dart.void, []),
      forEach: dart.definiteFunctionType(dart.void, [dart.functionType(dart.void, [core.String, core.String])]),
      [_attr]: dart.definiteFunctionType(core.String, [core.String]),
      [_matches]: dart.definiteFunctionType(core.bool, [core.String]),
      [_strip]: dart.definiteFunctionType(core.String, [core.String]),
      [_toCamelCase]: dart.definiteFunctionType(core.String, [core.String], {startUppercase: core.bool}),
      [_toHyphenedName]: dart.definiteFunctionType(core.String, [core.String])
    })
  });
  dart.defineExtensionMembers(html$._DataAttributeMap, [
    'addAll',
    'containsValue',
    'containsKey',
    'get',
    'set',
    'putIfAbsent',
    'remove',
    'clear',
    'forEach',
    'keys',
    'values',
    'length',
    'isEmpty',
    'isNotEmpty'
  ]);
  html$.CanvasImageSource = class CanvasImageSource extends core.Object {};
  html$.WindowBase = class WindowBase extends core.Object {};
  html$.WindowBase[dart.implements] = () => [html$.EventTarget];
  html$.LocationBase = class LocationBase extends core.Object {};
  html$.HistoryBase = class HistoryBase extends core.Object {};
  html$.CssClassSet = class CssClassSet extends core.Object {};
  html$.CssClassSet[dart.implements] = () => [SetOfString()];
  const _addOrSubtractToBoxModel = Symbol('_addOrSubtractToBoxModel');
  html$.CssRect = class CssRect extends core.Object {
    new(element) {
      this[_element$] = element;
    }
    set height(newHeight) {
      dart.throw(new core.UnsupportedError("Can only set height for content rect."));
    }
    set width(newWidth) {
      dart.throw(new core.UnsupportedError("Can only set width for content rect."));
    }
    [_addOrSubtractToBoxModel](dimensions, augmentingMeasurement) {
      let styles = this[_element$][dartx.getComputedStyle]();
      let val = 0;
      for (let measurement of dimensions) {
        if (augmentingMeasurement == html$._MARGIN) {
          val = dart.notNull(val) + dart.notNull(dart.asInt(new html$.Dimension.css(styles[dartx.getPropertyValue](dart.str`${augmentingMeasurement}-${measurement}`)).value));
        }
        if (augmentingMeasurement == html$._CONTENT) {
          val = dart.notNull(val) - dart.notNull(dart.asInt(new html$.Dimension.css(styles[dartx.getPropertyValue](dart.str`${html$._PADDING}-${measurement}`)).value));
        }
        if (augmentingMeasurement != html$._MARGIN) {
          val = dart.notNull(val) - dart.notNull(dart.asInt(new html$.Dimension.css(styles[dartx.getPropertyValue](dart.str`border-${measurement}-width`)).value));
        }
      }
      return val;
    }
    get right() {
      return dart.notNull(this.left) + dart.notNull(this.width);
    }
    get bottom() {
      return dart.notNull(this.top) + dart.notNull(this.height);
    }
    toString() {
      return dart.str`Rectangle (${this.left}, ${this.top}) ${this.width} x ${this.height}`;
    }
    ['=='](other) {
      if (!RectangleOfnum().is(other)) return false;
      return dart.equals(this.left, dart.dload(other, 'left')) && dart.equals(this.top, dart.dload(other, 'top')) && dart.equals(this.right, dart.dload(other, 'right')) && dart.equals(this.bottom, dart.dload(other, 'bottom'));
    }
    get hashCode() {
      return html$._JenkinsSmiHash.hash4(dart.hashCode(this.left), dart.hashCode(this.top), dart.hashCode(this.right), dart.hashCode(this.bottom));
    }
    intersection(other) {
      let x0 = math.max(core.num)(this.left, other[dartx.left]);
      let x1 = math.min(core.num)(dart.notNull(this.left) + dart.notNull(this.width), dart.notNull(other[dartx.left]) + dart.notNull(other[dartx.width]));
      if (dart.notNull(x0) <= dart.notNull(x1)) {
        let y0 = math.max(core.num)(this.top, other[dartx.top]);
        let y1 = math.min(core.num)(dart.notNull(this.top) + dart.notNull(this.height), dart.notNull(other[dartx.top]) + dart.notNull(other[dartx.height]));
        if (dart.notNull(y0) <= dart.notNull(y1)) {
          return new (RectangleOfnum())(x0, y0, dart.notNull(x1) - dart.notNull(x0), dart.notNull(y1) - dart.notNull(y0));
        }
      }
      return null;
    }
    intersects(other) {
      return dart.notNull(this.left) <= dart.notNull(other[dartx.left]) + dart.notNull(other[dartx.width]) && dart.notNull(other[dartx.left]) <= dart.notNull(this.left) + dart.notNull(this.width) && dart.notNull(this.top) <= dart.notNull(other[dartx.top]) + dart.notNull(other[dartx.height]) && dart.notNull(other[dartx.top]) <= dart.notNull(this.top) + dart.notNull(this.height);
    }
    boundingBox(other) {
      let right = math.max(core.num)(dart.notNull(this.left) + dart.notNull(this.width), dart.notNull(other[dartx.left]) + dart.notNull(other[dartx.width]));
      let bottom = math.max(core.num)(dart.notNull(this.top) + dart.notNull(this.height), dart.notNull(other[dartx.top]) + dart.notNull(other[dartx.height]));
      let left = math.min(core.num)(this.left, other[dartx.left]);
      let top = math.min(core.num)(this.top, other[dartx.top]);
      return new (RectangleOfnum())(left, top, dart.notNull(right) - dart.notNull(left), dart.notNull(bottom) - dart.notNull(top));
    }
    containsRectangle(another) {
      return dart.notNull(this.left) <= dart.notNull(another[dartx.left]) && dart.notNull(this.left) + dart.notNull(this.width) >= dart.notNull(another[dartx.left]) + dart.notNull(another[dartx.width]) && dart.notNull(this.top) <= dart.notNull(another[dartx.top]) && dart.notNull(this.top) + dart.notNull(this.height) >= dart.notNull(another[dartx.top]) + dart.notNull(another[dartx.height]);
    }
    containsPoint(another) {
      return dart.notNull(another.x) >= dart.notNull(this.left) && dart.notNull(another.x) <= dart.notNull(this.left) + dart.notNull(this.width) && dart.notNull(another.y) >= dart.notNull(this.top) && dart.notNull(another.y) <= dart.notNull(this.top) + dart.notNull(this.height);
    }
    get topLeft() {
      return new (PointOfnum())(this.left, this.top);
    }
    get topRight() {
      return new (PointOfnum())(dart.notNull(this.left) + dart.notNull(this.width), this.top);
    }
    get bottomRight() {
      return new (PointOfnum())(dart.notNull(this.left) + dart.notNull(this.width), dart.notNull(this.top) + dart.notNull(this.height));
    }
    get bottomLeft() {
      return new (PointOfnum())(this.left, dart.notNull(this.top) + dart.notNull(this.height));
    }
  };
  html$.CssRect[dart.implements] = () => [RectangleOfnum()];
  dart.setSignature(html$.CssRect, {
    constructors: () => ({new: dart.definiteFunctionType(html$.CssRect, [html$.Element])}),
    methods: () => ({
      [_addOrSubtractToBoxModel]: dart.definiteFunctionType(core.num, [core.List$(core.String), core.String]),
      intersection: dart.definiteFunctionType(math.Rectangle$(core.num), [math.Rectangle$(core.num)]),
      intersects: dart.definiteFunctionType(core.bool, [math.Rectangle$(core.num)]),
      boundingBox: dart.definiteFunctionType(math.Rectangle$(core.num), [math.Rectangle$(core.num)]),
      containsRectangle: dart.definiteFunctionType(core.bool, [math.Rectangle$(core.num)]),
      containsPoint: dart.definiteFunctionType(core.bool, [math.Point$(core.num)])
    })
  });
  dart.defineExtensionMembers(html$.CssRect, [
    'toString',
    '==',
    'intersection',
    'intersects',
    'boundingBox',
    'containsRectangle',
    'containsPoint',
    'right',
    'bottom',
    'hashCode',
    'topLeft',
    'topRight',
    'bottomRight',
    'bottomLeft'
  ]);
  html$._ContentCssRect = class _ContentCssRect extends html$.CssRect {
    new(element) {
      super.new(element);
    }
    get height() {
      return dart.notNull(this[_element$][dartx.offsetHeight]) + dart.notNull(this[_addOrSubtractToBoxModel](html$._HEIGHT, html$._CONTENT));
    }
    get width() {
      return dart.notNull(this[_element$][dartx.offsetWidth]) + dart.notNull(this[_addOrSubtractToBoxModel](html$._WIDTH, html$._CONTENT));
    }
    set height(newHeight) {
      if (html$.Dimension.is(newHeight)) {
        if (dart.test(dart.dsend(dart.dload(newHeight, 'value'), '<', 0))) newHeight = new html$.Dimension.px(0);
        this[_element$][dartx.style][dartx.height] = dart.toString(newHeight);
      } else if (typeof newHeight == 'number') {
        if (dart.test(dart.dsend(newHeight, '<', 0))) newHeight = 0;
        this[_element$][dartx.style][dartx.height] = dart.str`${newHeight}px`;
      } else {
        dart.throw(new core.ArgumentError("newHeight is not a Dimension or num"));
      }
    }
    set width(newWidth) {
      if (html$.Dimension.is(newWidth)) {
        if (dart.test(dart.dsend(dart.dload(newWidth, 'value'), '<', 0))) newWidth = new html$.Dimension.px(0);
        this[_element$][dartx.style][dartx.width] = dart.toString(newWidth);
      } else if (typeof newWidth == 'number') {
        if (dart.test(dart.dsend(newWidth, '<', 0))) newWidth = 0;
        this[_element$][dartx.style][dartx.width] = dart.str`${newWidth}px`;
      } else {
        dart.throw(new core.ArgumentError("newWidth is not a Dimension or num"));
      }
    }
    get left() {
      return dart.notNull(this[_element$][dartx.getBoundingClientRect]()[dartx.left]) - dart.notNull(this[_addOrSubtractToBoxModel](JSArrayOfString().of(['left']), html$._CONTENT));
    }
    get top() {
      return dart.notNull(this[_element$][dartx.getBoundingClientRect]()[dartx.top]) - dart.notNull(this[_addOrSubtractToBoxModel](JSArrayOfString().of(['top']), html$._CONTENT));
    }
  };
  dart.setSignature(html$._ContentCssRect, {
    constructors: () => ({new: dart.definiteFunctionType(html$._ContentCssRect, [html$.Element])})
  });
  dart.defineExtensionMembers(html$._ContentCssRect, ['height', 'width', 'left', 'top']);
  const _elementList = Symbol('_elementList');
  html$._ContentCssListRect = class _ContentCssListRect extends html$._ContentCssRect {
    new(elementList) {
      this[_elementList] = null;
      super.new(elementList[dartx.first]);
      this[_elementList] = elementList;
    }
    set height(newHeight) {
      this[_elementList][dartx.forEach](dart.fn(e => e[dartx.contentEdge].height = newHeight, ElementTovoid()));
    }
    get height() {
      return super.height;
    }
    set width(newWidth) {
      this[_elementList][dartx.forEach](dart.fn(e => e[dartx.contentEdge].width = newWidth, ElementTovoid()));
    }
    get width() {
      return super.width;
    }
  };
  dart.setSignature(html$._ContentCssListRect, {
    constructors: () => ({new: dart.definiteFunctionType(html$._ContentCssListRect, [core.List$(html$.Element)])})
  });
  html$._PaddingCssRect = class _PaddingCssRect extends html$.CssRect {
    new(element) {
      super.new(html$.Element._check(element));
    }
    get height() {
      return dart.notNull(this[_element$][dartx.offsetHeight]) + dart.notNull(this[_addOrSubtractToBoxModel](html$._HEIGHT, html$._PADDING));
    }
    set height(value) {
      super.height = value;
    }
    get width() {
      return dart.notNull(this[_element$][dartx.offsetWidth]) + dart.notNull(this[_addOrSubtractToBoxModel](html$._WIDTH, html$._PADDING));
    }
    set width(value) {
      super.width = value;
    }
    get left() {
      return dart.notNull(this[_element$][dartx.getBoundingClientRect]()[dartx.left]) - dart.notNull(this[_addOrSubtractToBoxModel](JSArrayOfString().of(['left']), html$._PADDING));
    }
    get top() {
      return dart.notNull(this[_element$][dartx.getBoundingClientRect]()[dartx.top]) - dart.notNull(this[_addOrSubtractToBoxModel](JSArrayOfString().of(['top']), html$._PADDING));
    }
  };
  dart.setSignature(html$._PaddingCssRect, {
    constructors: () => ({new: dart.definiteFunctionType(html$._PaddingCssRect, [dart.dynamic])})
  });
  dart.defineExtensionMembers(html$._PaddingCssRect, ['height', 'width', 'left', 'top']);
  html$._BorderCssRect = class _BorderCssRect extends html$.CssRect {
    new(element) {
      super.new(html$.Element._check(element));
    }
    get height() {
      return this[_element$][dartx.offsetHeight];
    }
    set height(value) {
      super.height = value;
    }
    get width() {
      return this[_element$][dartx.offsetWidth];
    }
    set width(value) {
      super.width = value;
    }
    get left() {
      return this[_element$][dartx.getBoundingClientRect]()[dartx.left];
    }
    get top() {
      return this[_element$][dartx.getBoundingClientRect]()[dartx.top];
    }
  };
  dart.setSignature(html$._BorderCssRect, {
    constructors: () => ({new: dart.definiteFunctionType(html$._BorderCssRect, [dart.dynamic])})
  });
  dart.defineExtensionMembers(html$._BorderCssRect, ['height', 'width', 'left', 'top']);
  html$._MarginCssRect = class _MarginCssRect extends html$.CssRect {
    new(element) {
      super.new(html$.Element._check(element));
    }
    get height() {
      return dart.notNull(this[_element$][dartx.offsetHeight]) + dart.notNull(this[_addOrSubtractToBoxModel](html$._HEIGHT, html$._MARGIN));
    }
    set height(value) {
      super.height = value;
    }
    get width() {
      return dart.notNull(this[_element$][dartx.offsetWidth]) + dart.notNull(this[_addOrSubtractToBoxModel](html$._WIDTH, html$._MARGIN));
    }
    set width(value) {
      super.width = value;
    }
    get left() {
      return dart.notNull(this[_element$][dartx.getBoundingClientRect]()[dartx.left]) - dart.notNull(this[_addOrSubtractToBoxModel](JSArrayOfString().of(['left']), html$._MARGIN));
    }
    get top() {
      return dart.notNull(this[_element$][dartx.getBoundingClientRect]()[dartx.top]) - dart.notNull(this[_addOrSubtractToBoxModel](JSArrayOfString().of(['top']), html$._MARGIN));
    }
  };
  dart.setSignature(html$._MarginCssRect, {
    constructors: () => ({new: dart.definiteFunctionType(html$._MarginCssRect, [dart.dynamic])})
  });
  dart.defineExtensionMembers(html$._MarginCssRect, ['height', 'width', 'left', 'top']);
  dart.defineLazy(html$, {
    get _HEIGHT() {
      return JSArrayOfString().of(['top', 'bottom']);
    }
  });
  dart.defineLazy(html$, {
    get _WIDTH() {
      return JSArrayOfString().of(['right', 'left']);
    }
  });
  html$._CONTENT = 'content';
  html$._PADDING = 'padding';
  html$._MARGIN = 'margin';
  const _sets = Symbol('_sets');
  const _validateToken = Symbol('_validateToken');
  html_common.CssClassSetImpl = class CssClassSetImpl extends core.Object {
    [_validateToken](value) {
      if (dart.test(html_common.CssClassSetImpl._validTokenRE.hasMatch(value))) return value;
      dart.throw(new core.ArgumentError.value(value, 'value', 'Not a valid class token'));
    }
    toString() {
      return this.readClasses().join(' ');
    }
    toggle(value, shouldAdd) {
      if (shouldAdd === void 0) shouldAdd = null;
      this[_validateToken](value);
      let s = this.readClasses();
      let result = false;
      if (shouldAdd == null) shouldAdd = !dart.test(s.contains(value));
      if (dart.test(shouldAdd)) {
        s.add(value);
        result = true;
      } else {
        s.remove(value);
      }
      this.writeClasses(s);
      return result;
    }
    get frozen() {
      return false;
    }
    get iterator() {
      return this.readClasses().iterator;
    }
    [Symbol.iterator]() {
      return new dart.JsIterator(this.iterator);
    }
    forEach(f) {
      this.readClasses().forEach(f);
    }
    join(separator) {
      if (separator === void 0) separator = "";
      return this.readClasses().join(separator);
    }
    map(T) {
      return f => {
        return this.readClasses().map(T)(f);
      };
    }
    where(f) {
      return this.readClasses().where(f);
    }
    expand(T) {
      return f => {
        return this.readClasses().expand(T)(f);
      };
    }
    every(f) {
      return this.readClasses().every(f);
    }
    any(f) {
      return this.readClasses().any(f);
    }
    get isEmpty() {
      return this.readClasses().isEmpty;
    }
    get isNotEmpty() {
      return this.readClasses().isNotEmpty;
    }
    get length() {
      return this.readClasses().length;
    }
    reduce(combine) {
      return this.readClasses().reduce(combine);
    }
    fold(T) {
      return (initialValue, combine) => {
        return this.readClasses().fold(T)(initialValue, combine);
      };
    }
    contains(value) {
      if (!(typeof value == 'string')) return false;
      this[_validateToken](core.String._check(value));
      return this.readClasses().contains(value);
    }
    lookup(value) {
      return core.String._check(dart.test(this.contains(value)) ? value : null);
    }
    add(value) {
      this[_validateToken](value);
      return core.bool._check(this.modify(dart.fn(s => s.add(value), SetOfStringTobool())));
    }
    remove(value) {
      this[_validateToken](core.String._check(value));
      if (!(typeof value == 'string')) return false;
      let s = this.readClasses();
      let result = s.remove(value);
      this.writeClasses(s);
      return result;
    }
    addAll(iterable) {
      this.modify(dart.fn(s => s.addAll(iterable[dartx.map](core.String)(dart.bind(this, _validateToken))), SetOfStringTovoid()));
    }
    removeAll(iterable) {
      this.modify(dart.fn(s => s.removeAll(iterable), SetOfStringTovoid()));
    }
    toggleAll(iterable, shouldAdd) {
      if (shouldAdd === void 0) shouldAdd = null;
      iterable[dartx.forEach](dart.fn(e => this.toggle(e, shouldAdd), StringTobool()));
    }
    retainAll(iterable) {
      this.modify(dart.fn(s => s.retainAll(iterable), SetOfStringTovoid()));
    }
    removeWhere(test) {
      this.modify(dart.fn(s => s.removeWhere(test), SetOfStringTovoid()));
    }
    retainWhere(test) {
      this.modify(dart.fn(s => s.retainWhere(test), SetOfStringTovoid()));
    }
    containsAll(collection) {
      return this.readClasses().containsAll(collection);
    }
    intersection(other) {
      return this.readClasses().intersection(other);
    }
    union(other) {
      return this.readClasses().union(other);
    }
    difference(other) {
      return this.readClasses().difference(other);
    }
    get first() {
      return this.readClasses().first;
    }
    get last() {
      return this.readClasses().last;
    }
    get single() {
      return this.readClasses().single;
    }
    toList(opts) {
      let growable = opts && 'growable' in opts ? opts.growable : true;
      return this.readClasses().toList({growable: growable});
    }
    toSet() {
      return this.readClasses().toSet();
    }
    take(n) {
      return this.readClasses().take(n);
    }
    takeWhile(test) {
      return this.readClasses().takeWhile(test);
    }
    skip(n) {
      return this.readClasses().skip(n);
    }
    skipWhile(test) {
      return this.readClasses().skipWhile(test);
    }
    firstWhere(test, opts) {
      let orElse = opts && 'orElse' in opts ? opts.orElse : null;
      return this.readClasses().firstWhere(test, {orElse: orElse});
    }
    lastWhere(test, opts) {
      let orElse = opts && 'orElse' in opts ? opts.orElse : null;
      return this.readClasses().lastWhere(test, {orElse: orElse});
    }
    singleWhere(test) {
      return this.readClasses().singleWhere(test);
    }
    elementAt(index) {
      return this.readClasses().elementAt(index);
    }
    clear() {
      this.modify(dart.fn(s => s.clear(), SetOfStringTovoid()));
    }
    modify(f) {
      let s = this.readClasses();
      let ret = f(s);
      this.writeClasses(s);
      return ret;
    }
  };
  html_common.CssClassSetImpl[dart.implements] = () => [html$.CssClassSet];
  dart.setSignature(html_common.CssClassSetImpl, {
    methods: () => ({
      [_validateToken]: dart.definiteFunctionType(core.String, [core.String]),
      toggle: dart.definiteFunctionType(core.bool, [core.String], [core.bool]),
      forEach: dart.definiteFunctionType(dart.void, [dart.functionType(dart.void, [core.String])]),
      join: dart.definiteFunctionType(core.String, [], [core.String]),
      map: dart.definiteFunctionType(T => [core.Iterable$(T), [dart.functionType(T, [core.String])]]),
      where: dart.definiteFunctionType(core.Iterable$(core.String), [dart.functionType(core.bool, [core.String])]),
      expand: dart.definiteFunctionType(T => [core.Iterable$(T), [dart.functionType(core.Iterable$(T), [core.String])]]),
      every: dart.definiteFunctionType(core.bool, [dart.functionType(core.bool, [core.String])]),
      any: dart.definiteFunctionType(core.bool, [dart.functionType(core.bool, [core.String])]),
      reduce: dart.definiteFunctionType(core.String, [dart.functionType(core.String, [core.String, core.String])]),
      fold: dart.definiteFunctionType(T => [T, [T, dart.functionType(T, [T, core.String])]]),
      contains: dart.definiteFunctionType(core.bool, [core.Object]),
      lookup: dart.definiteFunctionType(core.String, [core.Object]),
      add: dart.definiteFunctionType(core.bool, [core.String]),
      remove: dart.definiteFunctionType(core.bool, [core.Object]),
      addAll: dart.definiteFunctionType(dart.void, [core.Iterable$(core.String)]),
      removeAll: dart.definiteFunctionType(dart.void, [core.Iterable$(core.Object)]),
      toggleAll: dart.definiteFunctionType(dart.void, [core.Iterable$(core.String)], [core.bool]),
      retainAll: dart.definiteFunctionType(dart.void, [core.Iterable$(core.Object)]),
      removeWhere: dart.definiteFunctionType(dart.void, [dart.functionType(core.bool, [core.String])]),
      retainWhere: dart.definiteFunctionType(dart.void, [dart.functionType(core.bool, [core.String])]),
      containsAll: dart.definiteFunctionType(core.bool, [core.Iterable$(core.Object)]),
      intersection: dart.definiteFunctionType(core.Set$(core.String), [core.Set$(core.Object)]),
      union: dart.definiteFunctionType(core.Set$(core.String), [core.Set$(core.String)]),
      difference: dart.definiteFunctionType(core.Set$(core.String), [core.Set$(core.Object)]),
      toList: dart.definiteFunctionType(core.List$(core.String), [], {growable: core.bool}),
      toSet: dart.definiteFunctionType(core.Set$(core.String), []),
      take: dart.definiteFunctionType(core.Iterable$(core.String), [core.int]),
      takeWhile: dart.definiteFunctionType(core.Iterable$(core.String), [dart.functionType(core.bool, [core.String])]),
      skip: dart.definiteFunctionType(core.Iterable$(core.String), [core.int]),
      skipWhile: dart.definiteFunctionType(core.Iterable$(core.String), [dart.functionType(core.bool, [core.String])]),
      firstWhere: dart.definiteFunctionType(core.String, [dart.functionType(core.bool, [core.String])], {orElse: VoidToString()}),
      lastWhere: dart.definiteFunctionType(core.String, [dart.functionType(core.bool, [core.String])], {orElse: VoidToString()}),
      singleWhere: dart.definiteFunctionType(core.String, [dart.functionType(core.bool, [core.String])]),
      elementAt: dart.definiteFunctionType(core.String, [core.int]),
      clear: dart.definiteFunctionType(dart.void, []),
      modify: dart.definiteFunctionType(dart.dynamic, [dart.functionType(dart.dynamic, [core.Set$(core.String)])])
    })
  });
  dart.defineExtensionMembers(html_common.CssClassSetImpl, [
    'toString',
    'forEach',
    'join',
    'map',
    'where',
    'expand',
    'every',
    'any',
    'reduce',
    'fold',
    'contains',
    'toList',
    'toSet',
    'take',
    'takeWhile',
    'skip',
    'skipWhile',
    'firstWhere',
    'lastWhere',
    'singleWhere',
    'elementAt',
    'iterator',
    'isEmpty',
    'isNotEmpty',
    'length',
    'first',
    'last',
    'single'
  ]);
  dart.defineLazy(html_common.CssClassSetImpl, {
    get _validTokenRE() {
      return core.RegExp.new('^\\S+$');
    }
  });
  html$._MultiElementCssClassSet = class _MultiElementCssClassSet extends html_common.CssClassSetImpl {
    static new(elements) {
      return new html$._MultiElementCssClassSet._(elements, ListOfCssClassSetImpl()._check(elements[dartx.map](html$.CssClassSet)(dart.fn(e => e[dartx.classes], ElementToCssClassSet()))[dartx.toList]()));
    }
    _(elementIterable, sets) {
      this[_elementIterable] = elementIterable;
      this[_sets] = sets;
    }
    readClasses() {
      let s = LinkedHashSetOfString().new();
      this[_sets][dartx.forEach](dart.fn(e => s.addAll(e.readClasses()), CssClassSetImplTovoid()));
      return s;
    }
    writeClasses(s) {
      let classes = s.join(' ');
      for (let e of this[_elementIterable]) {
        e[dartx.className] = classes;
      }
    }
    modify(f) {
      this[_sets][dartx.forEach](dart.fn(e => e.modify(f), CssClassSetImplTovoid()));
    }
    toggle(value, shouldAdd) {
      if (shouldAdd === void 0) shouldAdd = null;
      return this[_sets][dartx.fold](core.bool)(false, dart.fn((changed, e) => dart.test(e.toggle(value, shouldAdd)) || dart.test(changed), boolAndCssClassSetImplTobool()));
    }
    remove(value) {
      return this[_sets][dartx.fold](core.bool)(false, dart.fn((changed, e) => dart.test(e.remove(value)) || dart.test(changed), boolAndCssClassSetImplTobool()));
    }
  };
  dart.defineNamedConstructor(html$._MultiElementCssClassSet, '_');
  dart.setSignature(html$._MultiElementCssClassSet, {
    constructors: () => ({
      new: dart.definiteFunctionType(html$._MultiElementCssClassSet, [core.Iterable$(html$.Element)]),
      _: dart.definiteFunctionType(html$._MultiElementCssClassSet, [core.Iterable$(html$.Element), core.List$(html_common.CssClassSetImpl)])
    }),
    methods: () => ({
      readClasses: dart.definiteFunctionType(core.Set$(core.String), []),
      writeClasses: dart.definiteFunctionType(dart.void, [core.Set$(core.String)])
    })
  });
  html$._ElementCssClassSet = class _ElementCssClassSet extends html_common.CssClassSetImpl {
    new(element) {
      this[_element$] = element;
    }
    readClasses() {
      let s = LinkedHashSetOfString().new();
      let classname = this[_element$][dartx.className];
      for (let name of classname[dartx.split](' ')) {
        let trimmed = name[dartx.trim]();
        if (!dart.test(trimmed[dartx.isEmpty])) {
          s.add(trimmed);
        }
      }
      return s;
    }
    writeClasses(s) {
      this[_element$][dartx.className] = s.join(' ');
    }
    get length() {
      return html$._ElementCssClassSet._classListLength(html$._ElementCssClassSet._classListOf(this[_element$]));
    }
    get isEmpty() {
      return this.length == 0;
    }
    get isNotEmpty() {
      return this.length != 0;
    }
    clear() {
      this[_element$][dartx.className] = '';
    }
    contains(value) {
      return html$._ElementCssClassSet._contains(this[_element$], value);
    }
    add(value) {
      return html$._ElementCssClassSet._add(this[_element$], value);
    }
    remove(value) {
      return typeof value == 'string' && dart.test(html$._ElementCssClassSet._remove(this[_element$], value));
    }
    toggle(value, shouldAdd) {
      if (shouldAdd === void 0) shouldAdd = null;
      return html$._ElementCssClassSet._toggle(this[_element$], value, shouldAdd);
    }
    addAll(iterable) {
      html$._ElementCssClassSet._addAll(this[_element$], iterable);
    }
    removeAll(iterable) {
      html$._ElementCssClassSet._removeAll(this[_element$], IterableOfString()._check(iterable));
    }
    retainAll(iterable) {
      html$._ElementCssClassSet._removeWhere(this[_element$], dart.bind(iterable[dartx.toSet](), 'contains'), false);
    }
    removeWhere(test) {
      html$._ElementCssClassSet._removeWhere(this[_element$], test, true);
    }
    retainWhere(test) {
      html$._ElementCssClassSet._removeWhere(this[_element$], test, false);
    }
    static _contains(_element, value) {
      return typeof value == 'string' && dart.test(html$._ElementCssClassSet._classListContains(html$._ElementCssClassSet._classListOf(_element), value));
    }
    static _add(_element, value) {
      let list = html$._ElementCssClassSet._classListOf(_element);
      let added = !dart.test(html$._ElementCssClassSet._classListContainsBeforeAddOrRemove(list, value));
      html$._ElementCssClassSet._classListAdd(list, value);
      return added;
    }
    static _remove(_element, value) {
      let list = html$._ElementCssClassSet._classListOf(_element);
      let removed = html$._ElementCssClassSet._classListContainsBeforeAddOrRemove(list, value);
      html$._ElementCssClassSet._classListRemove(list, value);
      return removed;
    }
    static _toggle(_element, value, shouldAdd) {
      return shouldAdd == null ? html$._ElementCssClassSet._toggleDefault(_element, value) : html$._ElementCssClassSet._toggleOnOff(_element, value, shouldAdd);
    }
    static _toggleDefault(_element, value) {
      let list = html$._ElementCssClassSet._classListOf(_element);
      return html$._ElementCssClassSet._classListToggle1(list, value);
    }
    static _toggleOnOff(_element, value, shouldAdd) {
      let list = html$._ElementCssClassSet._classListOf(_element);
      if (dart.test(shouldAdd)) {
        html$._ElementCssClassSet._classListAdd(list, value);
        return true;
      } else {
        html$._ElementCssClassSet._classListRemove(list, value);
        return false;
      }
    }
    static _addAll(_element, iterable) {
      let list = html$._ElementCssClassSet._classListOf(_element);
      for (let value of iterable) {
        html$._ElementCssClassSet._classListAdd(list, value);
      }
    }
    static _removeAll(_element, iterable) {
      let list = html$._ElementCssClassSet._classListOf(_element);
      for (let value of iterable) {
        html$._ElementCssClassSet._classListRemove(list, value);
      }
    }
    static _removeWhere(_element, test, doRemove) {
      let list = html$._ElementCssClassSet._classListOf(_element);
      let i = 0;
      while (i < dart.notNull(html$._ElementCssClassSet._classListLength(list))) {
        let item = list[dartx.item](i);
        if (doRemove == test(item)) {
          html$._ElementCssClassSet._classListRemove(list, item);
        } else {
          ++i;
        }
      }
    }
    static _classListOf(e) {
      return e.classList;
    }
    static _classListLength(list) {
      return list.length;
    }
    static _classListContains(list, value) {
      return list.contains(value);
    }
    static _classListContainsBeforeAddOrRemove(list, value) {
      return list.contains(value);
    }
    static _classListAdd(list, value) {
      list.add(value);
    }
    static _classListRemove(list, value) {
      list.remove(value);
    }
    static _classListToggle1(list, value) {
      return list.toggle(value);
    }
    static _classListToggle2(list, value, shouldAdd) {
      return list.toggle(value, shouldAdd);
    }
  };
  dart.setSignature(html$._ElementCssClassSet, {
    constructors: () => ({new: dart.definiteFunctionType(html$._ElementCssClassSet, [html$.Element])}),
    methods: () => ({
      readClasses: dart.definiteFunctionType(core.Set$(core.String), []),
      writeClasses: dart.definiteFunctionType(dart.void, [core.Set$(core.String)])
    }),
    statics: () => ({
      _contains: dart.definiteFunctionType(core.bool, [html$.Element, core.Object]),
      _add: dart.definiteFunctionType(core.bool, [html$.Element, core.String]),
      _remove: dart.definiteFunctionType(core.bool, [html$.Element, core.String]),
      _toggle: dart.definiteFunctionType(core.bool, [html$.Element, core.String, core.bool]),
      _toggleDefault: dart.definiteFunctionType(core.bool, [html$.Element, core.String]),
      _toggleOnOff: dart.definiteFunctionType(core.bool, [html$.Element, core.String, core.bool]),
      _addAll: dart.definiteFunctionType(dart.void, [html$.Element, core.Iterable$(core.String)]),
      _removeAll: dart.definiteFunctionType(dart.void, [html$.Element, core.Iterable$(core.String)]),
      _removeWhere: dart.definiteFunctionType(dart.void, [html$.Element, dart.functionType(core.bool, [core.String]), core.bool]),
      _classListOf: dart.definiteFunctionType(html$.DomTokenList, [html$.Element]),
      _classListLength: dart.definiteFunctionType(core.int, [html$.DomTokenList]),
      _classListContains: dart.definiteFunctionType(core.bool, [html$.DomTokenList, core.String]),
      _classListContainsBeforeAddOrRemove: dart.definiteFunctionType(core.bool, [html$.DomTokenList, core.String]),
      _classListAdd: dart.definiteFunctionType(dart.void, [html$.DomTokenList, core.String]),
      _classListRemove: dart.definiteFunctionType(dart.void, [html$.DomTokenList, core.String]),
      _classListToggle1: dart.definiteFunctionType(core.bool, [html$.DomTokenList, core.String]),
      _classListToggle2: dart.definiteFunctionType(core.bool, [html$.DomTokenList, core.String, core.bool])
    }),
    names: ['_contains', '_add', '_remove', '_toggle', '_toggleDefault', '_toggleOnOff', '_addAll', '_removeAll', '_removeWhere', '_classListOf', '_classListLength', '_classListContains', '_classListContainsBeforeAddOrRemove', '_classListAdd', '_classListRemove', '_classListToggle1', '_classListToggle2']
  });
  dart.defineExtensionMembers(html$._ElementCssClassSet, ['contains', 'length', 'isEmpty', 'isNotEmpty']);
  const _unit = Symbol('_unit');
  html$.Dimension = class Dimension extends core.Object {
    percent(value) {
      this[_value$0] = value;
      this[_unit] = '%';
    }
    px(value) {
      this[_value$0] = value;
      this[_unit] = 'px';
    }
    pc(value) {
      this[_value$0] = value;
      this[_unit] = 'pc';
    }
    pt(value) {
      this[_value$0] = value;
      this[_unit] = 'pt';
    }
    inch(value) {
      this[_value$0] = value;
      this[_unit] = 'in';
    }
    cm(value) {
      this[_value$0] = value;
      this[_unit] = 'cm';
    }
    mm(value) {
      this[_value$0] = value;
      this[_unit] = 'mm';
    }
    em(value) {
      this[_value$0] = value;
      this[_unit] = 'em';
    }
    ex(value) {
      this[_value$0] = value;
      this[_unit] = 'ex';
    }
    css(cssValue) {
      this[_value$0] = null;
      this[_unit] = null;
      if (cssValue == '') cssValue = '0px';
      if (dart.test(cssValue[dartx.endsWith]('%'))) {
        this[_unit] = '%';
      } else {
        this[_unit] = cssValue[dartx.substring](dart.notNull(cssValue[dartx.length]) - 2);
      }
      if (dart.test(cssValue[dartx.contains]('.'))) {
        this[_value$0] = core.double.parse(cssValue[dartx.substring](0, dart.notNull(cssValue[dartx.length]) - dart.notNull(this[_unit][dartx.length])));
      } else {
        this[_value$0] = core.int.parse(cssValue[dartx.substring](0, dart.notNull(cssValue[dartx.length]) - dart.notNull(this[_unit][dartx.length])));
      }
    }
    toString() {
      return dart.str`${this[_value$0]}${this[_unit]}`;
    }
    get value() {
      return this[_value$0];
    }
  };
  dart.defineNamedConstructor(html$.Dimension, 'percent');
  dart.defineNamedConstructor(html$.Dimension, 'px');
  dart.defineNamedConstructor(html$.Dimension, 'pc');
  dart.defineNamedConstructor(html$.Dimension, 'pt');
  dart.defineNamedConstructor(html$.Dimension, 'inch');
  dart.defineNamedConstructor(html$.Dimension, 'cm');
  dart.defineNamedConstructor(html$.Dimension, 'mm');
  dart.defineNamedConstructor(html$.Dimension, 'em');
  dart.defineNamedConstructor(html$.Dimension, 'ex');
  dart.defineNamedConstructor(html$.Dimension, 'css');
  dart.setSignature(html$.Dimension, {
    constructors: () => ({
      percent: dart.definiteFunctionType(html$.Dimension, [core.num]),
      px: dart.definiteFunctionType(html$.Dimension, [core.num]),
      pc: dart.definiteFunctionType(html$.Dimension, [core.num]),
      pt: dart.definiteFunctionType(html$.Dimension, [core.num]),
      inch: dart.definiteFunctionType(html$.Dimension, [core.num]),
      cm: dart.definiteFunctionType(html$.Dimension, [core.num]),
      mm: dart.definiteFunctionType(html$.Dimension, [core.num]),
      em: dart.definiteFunctionType(html$.Dimension, [core.num]),
      ex: dart.definiteFunctionType(html$.Dimension, [core.num]),
      css: dart.definiteFunctionType(html$.Dimension, [core.String])
    })
  });
  html$.EventListener = dart.typedef('EventListener', () => dart.functionType(dart.dynamic, [html$.Event]));
  html$.EventStreamProvider$ = dart.generic(T => {
    let _EventStreamOfT = () => (_EventStreamOfT = dart.constFn(html$._EventStream$(T)))();
    let _ElementEventStreamImplOfT = () => (_ElementEventStreamImplOfT = dart.constFn(html$._ElementEventStreamImpl$(T)))();
    class EventStreamProvider extends core.Object {
      new(eventType) {
        this[_eventType] = eventType;
      }
      forTarget(e, opts) {
        let useCapture = opts && 'useCapture' in opts ? opts.useCapture : false;
        return new (_EventStreamOfT())(e, this[_eventType], useCapture);
      }
      forElement(e, opts) {
        let useCapture = opts && 'useCapture' in opts ? opts.useCapture : false;
        return new (_ElementEventStreamImplOfT())(e, this[_eventType], useCapture);
      }
      [_forElementList](e, opts) {
        let useCapture = opts && 'useCapture' in opts ? opts.useCapture : false;
        return new (_ElementListEventStreamImplOfEvent())(e, this[_eventType], useCapture);
      }
      getEventType(target) {
        return this[_eventType];
      }
    }
    dart.addTypeTests(EventStreamProvider);
    dart.setSignature(EventStreamProvider, {
      constructors: () => ({new: dart.definiteFunctionType(html$.EventStreamProvider$(T), [core.String])}),
      methods: () => ({
        forTarget: dart.definiteFunctionType(async.Stream$(T), [html$.EventTarget], {useCapture: core.bool}),
        forElement: dart.definiteFunctionType(html$.ElementStream$(T), [html$.Element], {useCapture: core.bool}),
        [_forElementList]: dart.definiteFunctionType(html$.ElementStream$(T), [html$.ElementList$(html$.Element)], {useCapture: core.bool}),
        getEventType: dart.definiteFunctionType(core.String, [html$.EventTarget])
      })
    });
    return EventStreamProvider;
  });
  html$.EventStreamProvider = EventStreamProvider();
  html$.ElementStream$ = dart.generic(T => {
    let StreamOfT = () => (StreamOfT = dart.constFn(async.Stream$(T)))();
    class ElementStream extends core.Object {}
    dart.addTypeTests(ElementStream);
    ElementStream[dart.implements] = () => [StreamOfT()];
    return ElementStream;
  });
  html$.ElementStream = ElementStream();
  const _target$ = Symbol('_target');
  const _useCapture = Symbol('_useCapture');
  html$._EventStream$ = dart.generic(T => {
    let _EventStreamSubscriptionOfT = () => (_EventStreamSubscriptionOfT = dart.constFn(html$._EventStreamSubscription$(T)))();
    let StreamSubscriptionOfT = () => (StreamSubscriptionOfT = dart.constFn(async.StreamSubscription$(T)))();
    let StreamSubscriptionOfTTovoid = () => (StreamSubscriptionOfTTovoid = dart.constFn(dart.functionType(dart.void, [StreamSubscriptionOfT()])))();
    class _EventStream extends async.Stream$(T) {
      new(target, eventType, useCapture) {
        this[_target$] = target;
        this[_eventType] = eventType;
        this[_useCapture] = useCapture;
        super.new();
      }
      asBroadcastStream(opts) {
        let onListen = opts && 'onListen' in opts ? opts.onListen : null;
        let onCancel = opts && 'onCancel' in opts ? opts.onCancel : null;
        return this;
      }
      get isBroadcast() {
        return true;
      }
      listen(onData, opts) {
        let onError = opts && 'onError' in opts ? opts.onError : null;
        let onDone = opts && 'onDone' in opts ? opts.onDone : null;
        let cancelOnError = opts && 'cancelOnError' in opts ? opts.cancelOnError : null;
        return new (_EventStreamSubscriptionOfT())(this[_target$], this[_eventType], onData, this[_useCapture]);
      }
    }
    dart.setSignature(_EventStream, {
      constructors: () => ({new: dart.definiteFunctionType(html$._EventStream$(T), [html$.EventTarget, core.String, core.bool])}),
      methods: () => ({
        asBroadcastStream: dart.definiteFunctionType(async.Stream$(T), [], {onListen: StreamSubscriptionOfTTovoid(), onCancel: StreamSubscriptionOfTTovoid()}),
        listen: dart.definiteFunctionType(async.StreamSubscription$(T), [dart.functionType(dart.void, [T])], {onError: core.Function, onDone: VoidTovoid(), cancelOnError: core.bool})
      })
    });
    return _EventStream;
  });
  html$._EventStream = _EventStream();
  html$._matchesWithAncestors = function(event, selector) {
    let target = event[dartx.target];
    return html$.Element.is(target) ? target[dartx.matchesWithAncestors](selector) : false;
  };
  dart.fn(html$._matchesWithAncestors, EventAndStringTobool());
  html$._ElementEventStreamImpl$ = dart.generic(T => {
    let _EventStreamSubscriptionOfT = () => (_EventStreamSubscriptionOfT = dart.constFn(html$._EventStreamSubscription$(T)))();
    let ElementStreamOfT = () => (ElementStreamOfT = dart.constFn(html$.ElementStream$(T)))();
    let TToT = () => (TToT = dart.constFn(dart.definiteFunctionType(T, [T])))();
    let TTobool = () => (TTobool = dart.constFn(dart.definiteFunctionType(core.bool, [T])))();
    class _ElementEventStreamImpl extends html$._EventStream$(T) {
      new(target, eventType, useCapture) {
        super.new(html$.EventTarget._check(target), core.String._check(eventType), core.bool._check(useCapture));
      }
      matches(selector) {
        return this.where(dart.fn(event => html$._matchesWithAncestors(event, selector), TTobool())).map(T)(dart.fn(e => {
          e[_selector] = selector;
          return e;
        }, TToT()));
      }
      capture(onData) {
        return new (_EventStreamSubscriptionOfT())(this[_target$], this[_eventType], onData, true);
      }
    }
    _ElementEventStreamImpl[dart.implements] = () => [ElementStreamOfT()];
    dart.setSignature(_ElementEventStreamImpl, {
      constructors: () => ({new: dart.definiteFunctionType(html$._ElementEventStreamImpl$(T), [dart.dynamic, dart.dynamic, dart.dynamic])}),
      methods: () => ({
        matches: dart.definiteFunctionType(async.Stream$(T), [core.String]),
        capture: dart.definiteFunctionType(async.StreamSubscription$(T), [dart.functionType(dart.void, [T])])
      })
    });
    return _ElementEventStreamImpl;
  });
  html$._ElementEventStreamImpl = _ElementEventStreamImpl();
  const _targetList = Symbol('_targetList');
  html$._ElementListEventStreamImpl$ = dart.generic(T => {
    let _StreamPoolOfT = () => (_StreamPoolOfT = dart.constFn(html$._StreamPool$(T)))();
    let _EventStreamOfT = () => (_EventStreamOfT = dart.constFn(html$._EventStream$(T)))();
    let ElementStreamOfT = () => (ElementStreamOfT = dart.constFn(html$.ElementStream$(T)))();
    let StreamSubscriptionOfT = () => (StreamSubscriptionOfT = dart.constFn(async.StreamSubscription$(T)))();
    let StreamSubscriptionOfTTovoid = () => (StreamSubscriptionOfTTovoid = dart.constFn(dart.functionType(dart.void, [StreamSubscriptionOfT()])))();
    let TToT = () => (TToT = dart.constFn(dart.definiteFunctionType(T, [T])))();
    let TTobool = () => (TTobool = dart.constFn(dart.definiteFunctionType(core.bool, [T])))();
    class _ElementListEventStreamImpl extends async.Stream$(T) {
      new(targetList, eventType, useCapture) {
        this[_targetList] = targetList;
        this[_eventType] = eventType;
        this[_useCapture] = useCapture;
        super.new();
      }
      matches(selector) {
        return this.where(dart.fn(event => html$._matchesWithAncestors(event, selector), TTobool())).map(T)(dart.fn(e => {
          e[_selector] = selector;
          return e;
        }, TToT()));
      }
      listen(onData, opts) {
        let onError = opts && 'onError' in opts ? opts.onError : null;
        let onDone = opts && 'onDone' in opts ? opts.onDone : null;
        let cancelOnError = opts && 'cancelOnError' in opts ? opts.cancelOnError : null;
        let pool = new (_StreamPoolOfT()).broadcast();
        for (let target of this[_targetList]) {
          pool.add(new (_EventStreamOfT())(target, this[_eventType], this[_useCapture]));
        }
        return pool.stream.listen(onData, {onError: onError, onDone: onDone, cancelOnError: cancelOnError});
      }
      capture(onData) {
        let pool = new (_StreamPoolOfT()).broadcast();
        for (let target of this[_targetList]) {
          pool.add(new (_EventStreamOfT())(target, this[_eventType], true));
        }
        return pool.stream.listen(onData);
      }
      asBroadcastStream(opts) {
        let onListen = opts && 'onListen' in opts ? opts.onListen : null;
        let onCancel = opts && 'onCancel' in opts ? opts.onCancel : null;
        return this;
      }
      get isBroadcast() {
        return true;
      }
    }
    _ElementListEventStreamImpl[dart.implements] = () => [ElementStreamOfT()];
    dart.setSignature(_ElementListEventStreamImpl, {
      constructors: () => ({new: dart.definiteFunctionType(html$._ElementListEventStreamImpl$(T), [core.Iterable$(html$.Element), core.String, core.bool])}),
      methods: () => ({
        matches: dart.definiteFunctionType(async.Stream$(T), [core.String]),
        listen: dart.definiteFunctionType(async.StreamSubscription$(T), [dart.functionType(dart.void, [T])], {onError: core.Function, onDone: VoidTovoid(), cancelOnError: core.bool}),
        capture: dart.definiteFunctionType(async.StreamSubscription$(T), [dart.functionType(dart.void, [T])]),
        asBroadcastStream: dart.definiteFunctionType(async.Stream$(T), [], {onListen: StreamSubscriptionOfTTovoid(), onCancel: StreamSubscriptionOfTTovoid()})
      })
    });
    return _ElementListEventStreamImpl;
  });
  html$._ElementListEventStreamImpl = _ElementListEventStreamImpl();
  html$._EventListener$ = dart.generic(T => {
    const _EventListener = dart.typedef('_EventListener', () => dart.functionType(dart.dynamic, [T]));
    return _EventListener;
  });
  html$._EventListener = _EventListener();
  const _onData$ = Symbol('_onData');
  const _pauseCount$ = Symbol('_pauseCount');
  const _tryResume = Symbol('_tryResume');
  const _canceled = Symbol('_canceled');
  const _unlisten = Symbol('_unlisten');
  html$._EventStreamSubscription$ = dart.generic(T => {
    class _EventStreamSubscription extends async.StreamSubscription$(T) {
      new(target, eventType, onData, useCapture) {
        this[_target$] = target;
        this[_eventType] = eventType;
        this[_useCapture] = useCapture;
        this[_onData$] = html$._wrapZone(html$.Event, dart.dynamic)(_wrapZoneCallbackOfEvent$dynamic()._check(onData));
        this[_pauseCount$] = 0;
        this[_tryResume]();
      }
      cancel() {
        if (dart.test(this[_canceled])) return null;
        this[_unlisten]();
        this[_target$] = null;
        this[_onData$] = null;
        return null;
      }
      get [_canceled]() {
        return this[_target$] == null;
      }
      onData(handleData) {
        if (dart.test(this[_canceled])) {
          dart.throw(new core.StateError("Subscription has been canceled."));
        }
        this[_unlisten]();
        this[_onData$] = html$._wrapZone(html$.Event, dart.dynamic)(_wrapZoneCallbackOfEvent$dynamic()._check(handleData));
        this[_tryResume]();
      }
      onError(handleError) {}
      onDone(handleDone) {}
      pause(resumeSignal) {
        if (resumeSignal === void 0) resumeSignal = null;
        if (dart.test(this[_canceled])) return;
        this[_pauseCount$] = dart.notNull(this[_pauseCount$]) + 1;
        this[_unlisten]();
        if (resumeSignal != null) {
          resumeSignal.whenComplete(dart.bind(this, 'resume'));
        }
      }
      get isPaused() {
        return dart.notNull(this[_pauseCount$]) > 0;
      }
      resume() {
        if (dart.test(this[_canceled]) || !dart.test(this.isPaused)) return;
        this[_pauseCount$] = dart.notNull(this[_pauseCount$]) - 1;
        this[_tryResume]();
      }
      [_tryResume]() {
        if (this[_onData$] != null && !dart.test(this.isPaused)) {
          this[_target$][dartx.addEventListener](this[_eventType], this[_onData$], this[_useCapture]);
        }
      }
      [_unlisten]() {
        if (this[_onData$] != null) {
          this[_target$][dartx.removeEventListener](this[_eventType], this[_onData$], this[_useCapture]);
        }
      }
      asFuture(futureValue) {
        if (futureValue === void 0) futureValue = null;
        let completer = async.Completer.new();
        return completer.future;
      }
    }
    dart.setSignature(_EventStreamSubscription, {
      constructors: () => ({new: dart.definiteFunctionType(html$._EventStreamSubscription$(T), [html$.EventTarget, core.String, dart.functionType(dart.void, [T]), core.bool])}),
      methods: () => ({
        cancel: dart.definiteFunctionType(async.Future, []),
        onData: dart.definiteFunctionType(dart.void, [dart.functionType(dart.void, [T])]),
        onError: dart.definiteFunctionType(dart.void, [core.Function]),
        onDone: dart.definiteFunctionType(dart.void, [dart.functionType(dart.void, [])]),
        pause: dart.definiteFunctionType(dart.void, [], [async.Future]),
        resume: dart.definiteFunctionType(dart.void, []),
        [_tryResume]: dart.definiteFunctionType(dart.void, []),
        [_unlisten]: dart.definiteFunctionType(dart.void, []),
        asFuture: dart.definiteFunctionType(async.Future, [], [dart.dynamic])
      })
    });
    return _EventStreamSubscription;
  });
  html$._EventStreamSubscription = _EventStreamSubscription();
  html$.CustomStream$ = dart.generic(T => {
    let StreamOfT = () => (StreamOfT = dart.constFn(async.Stream$(T)))();
    class CustomStream extends core.Object {}
    dart.addTypeTests(CustomStream);
    CustomStream[dart.implements] = () => [StreamOfT()];
    return CustomStream;
  });
  html$.CustomStream = CustomStream();
  const _streamController = Symbol('_streamController');
  const _type = Symbol('_type');
  html$._CustomEventStreamImpl$ = dart.generic(T => {
    let StreamControllerOfT = () => (StreamControllerOfT = dart.constFn(async.StreamController$(T)))();
    let CustomStreamOfT = () => (CustomStreamOfT = dart.constFn(html$.CustomStream$(T)))();
    let StreamSubscriptionOfT = () => (StreamSubscriptionOfT = dart.constFn(async.StreamSubscription$(T)))();
    let StreamSubscriptionOfTTovoid = () => (StreamSubscriptionOfTTovoid = dart.constFn(dart.functionType(dart.void, [StreamSubscriptionOfT()])))();
    class _CustomEventStreamImpl extends async.Stream$(T) {
      new(type) {
        this[_streamController] = null;
        this[_type] = null;
        super.new();
        this[_type] = type;
        this[_streamController] = StreamControllerOfT().broadcast({sync: true});
      }
      listen(onData, opts) {
        let onError = opts && 'onError' in opts ? opts.onError : null;
        let onDone = opts && 'onDone' in opts ? opts.onDone : null;
        let cancelOnError = opts && 'cancelOnError' in opts ? opts.cancelOnError : null;
        return this[_streamController].stream.listen(onData, {onError: onError, onDone: onDone, cancelOnError: cancelOnError});
      }
      asBroadcastStream(opts) {
        let onListen = opts && 'onListen' in opts ? opts.onListen : null;
        let onCancel = opts && 'onCancel' in opts ? opts.onCancel : null;
        return this[_streamController].stream;
      }
      get isBroadcast() {
        return true;
      }
      add(event) {
        T._check(event);
        if (event[dartx.type] == this[_type]) this[_streamController].add(event);
      }
    }
    _CustomEventStreamImpl[dart.implements] = () => [CustomStreamOfT()];
    dart.setSignature(_CustomEventStreamImpl, {
      constructors: () => ({new: dart.definiteFunctionType(html$._CustomEventStreamImpl$(T), [core.String])}),
      methods: () => ({
        listen: dart.definiteFunctionType(async.StreamSubscription$(T), [dart.functionType(dart.void, [T])], {onError: core.Function, onDone: VoidTovoid(), cancelOnError: core.bool}),
        asBroadcastStream: dart.definiteFunctionType(async.Stream$(T), [], {onListen: StreamSubscriptionOfTTovoid(), onCancel: StreamSubscriptionOfTTovoid()}),
        add: dart.definiteFunctionType(dart.void, [T])
      })
    });
    return _CustomEventStreamImpl;
  });
  html$._CustomEventStreamImpl = _CustomEventStreamImpl();
  const _parent$ = Symbol('_parent');
  const _shadowKeyCode = Symbol('_shadowKeyCode');
  const _shadowCharCode = Symbol('_shadowCharCode');
  const _shadowAltKey = Symbol('_shadowAltKey');
  const _realKeyCode = Symbol('_realKeyCode');
  const _realCharCode = Symbol('_realCharCode');
  const _realAltKey = Symbol('_realAltKey');
  const _currentTarget = Symbol('_currentTarget');
  const _shadowKeyIdentifier = Symbol('_shadowKeyIdentifier');
  html$.KeyEvent = class KeyEvent extends html$._WrappedEvent {
    get keyCode() {
      return this[_shadowKeyCode];
    }
    get charCode() {
      return this.type == 'keypress' ? this[_shadowCharCode] : 0;
    }
    get altKey() {
      return this[_shadowAltKey];
    }
    get which() {
      return this.keyCode;
    }
    get [_realKeyCode]() {
      return this[_parent$].keyCode;
    }
    get [_realCharCode]() {
      return this[_parent$].charCode;
    }
    get [_realAltKey]() {
      return this[_parent$].altKey;
    }
    static _makeRecord() {
      let interceptor = _foreign_helper.JS_INTERCEPTOR_CONSTANT(dart.wrapType(html$.KeyboardEvent));
      return _js_helper.makeLeafDispatchRecord(interceptor);
    }
    wrap(parent) {
      this[_parent$] = null;
      this[_shadowAltKey] = null;
      this[_shadowCharCode] = null;
      this[_shadowKeyCode] = null;
      this[_currentTarget] = null;
      super.new(parent);
      this[_parent$] = parent;
      this[_shadowAltKey] = this[_realAltKey];
      this[_shadowCharCode] = this[_realCharCode];
      this[_shadowKeyCode] = this[_realKeyCode];
      this[_currentTarget] = this[_parent$][dartx.currentTarget];
    }
    static new(type, opts) {
      let view = opts && 'view' in opts ? opts.view : null;
      let canBubble = opts && 'canBubble' in opts ? opts.canBubble : true;
      let cancelable = opts && 'cancelable' in opts ? opts.cancelable : true;
      let keyCode = opts && 'keyCode' in opts ? opts.keyCode : 0;
      let charCode = opts && 'charCode' in opts ? opts.charCode : 0;
      let keyLocation = opts && 'keyLocation' in opts ? opts.keyLocation : 1;
      let ctrlKey = opts && 'ctrlKey' in opts ? opts.ctrlKey : false;
      let altKey = opts && 'altKey' in opts ? opts.altKey : false;
      let shiftKey = opts && 'shiftKey' in opts ? opts.shiftKey : false;
      let metaKey = opts && 'metaKey' in opts ? opts.metaKey : false;
      let currentTarget = opts && 'currentTarget' in opts ? opts.currentTarget : null;
      if (view == null) {
        view = html$.window;
      }
      let eventObj = null;
      if (dart.test(html$.KeyEvent.canUseDispatchEvent)) {
        eventObj = html$.Event.eventType('Event', type, {canBubble: canBubble, cancelable: cancelable});
        eventObj.keyCode = keyCode;
        eventObj.which = keyCode;
        eventObj.charCode = charCode;
        eventObj.keyLocation = keyLocation;
        eventObj.ctrlKey = ctrlKey;
        eventObj.altKey = altKey;
        eventObj.shiftKey = shiftKey;
        eventObj.metaKey = metaKey;
      } else {
        eventObj = html$.Event.eventType('KeyboardEvent', type, {canBubble: canBubble, cancelable: cancelable});
        Object.defineProperty(eventObj, 'keyCode', {
          get: function() {
            return this.keyCodeVal;
          }
        });
        Object.defineProperty(eventObj, 'which', {
          get: function() {
            return this.keyCodeVal;
          }
        });
        Object.defineProperty(eventObj, 'charCode', {
          get: function() {
            return this.charCodeVal;
          }
        });
        let keyIdentifier = html$.KeyEvent._convertToHexString(charCode, keyCode);
        dart.dsend(eventObj, _initKeyboardEvent, type, canBubble, cancelable, view, keyIdentifier, keyLocation, ctrlKey, altKey, shiftKey, metaKey);
        eventObj.keyCodeVal = keyCode;
        eventObj.charCodeVal = charCode;
      }
      _interceptors.setDispatchProperty(eventObj, html$.KeyEvent._keyboardEventDispatchRecord);
      let keyEvent = new html$.KeyEvent.wrap(html$.KeyboardEvent._check(eventObj));
      if (keyEvent[_currentTarget] == null) {
        keyEvent[_currentTarget] = currentTarget == null ? html$.window : currentTarget;
      }
      return keyEvent;
    }
    static get canUseDispatchEvent() {
      return typeof document.body.dispatchEvent == "function" && document.body.dispatchEvent.length > 0;
    }
    get currentTarget() {
      return this[_currentTarget];
    }
    static _convertToHexString(charCode, keyCode) {
      if (charCode != -1) {
        let hex = charCode[dartx.toRadixString](16);
        let sb = new core.StringBuffer('U+');
        for (let i = 0; i < 4 - dart.notNull(hex[dartx.length]); i++)
          sb.write('0');
        sb.write(hex);
        return sb.toString();
      } else {
        return html$.KeyCode._convertKeyCodeToKeyName(keyCode);
      }
    }
    get code() {
      return this[_parent$][dartx.code];
    }
    get ctrlKey() {
      return this[_parent$][dartx.ctrlKey];
    }
    get detail() {
      return this[_parent$][dartx.detail];
    }
    get key() {
      return this[_parent$][dartx.key];
    }
    get keyLocation() {
      return this[_parent$][dartx.keyLocation];
    }
    get metaKey() {
      return this[_parent$][dartx.metaKey];
    }
    get shiftKey() {
      return this[_parent$][dartx.shiftKey];
    }
    get sourceDevice() {
      return this[_parent$][dartx.sourceDevice];
    }
    get view() {
      return html$.Window._check(this[_parent$][dartx.view]);
    }
    [_initUIEvent](type, canBubble, cancelable, view, detail) {
      dart.throw(new core.UnsupportedError("Cannot initialize a UI Event from a KeyEvent."));
    }
    get [_shadowKeyIdentifier]() {
      return this[_parent$].keyIdentifier;
    }
    get [_charCode]() {
      return this.charCode;
    }
    get [_keyCode]() {
      return this.keyCode;
    }
    get [_which]() {
      return this.which;
    }
    get [_keyIdentifier]() {
      dart.throw(new core.UnsupportedError("keyIdentifier is unsupported."));
    }
    [_initKeyboardEvent](type, canBubble, cancelable, view, keyIdentifier, keyLocation, ctrlKey, altKey, shiftKey, metaKey) {
      dart.throw(new core.UnsupportedError("Cannot initialize a KeyboardEvent from a KeyEvent."));
    }
    getModifierState(keyArgument) {
      return dart.throw(new core.UnimplementedError());
    }
    get location() {
      return dart.throw(new core.UnimplementedError());
    }
    get repeat() {
      return dart.throw(new core.UnimplementedError());
    }
    get [_get_view]() {
      return dart.throw(new core.UnimplementedError());
    }
  };
  dart.defineNamedConstructor(html$.KeyEvent, 'wrap');
  html$.KeyEvent[dart.implements] = () => [html$.KeyboardEvent];
  dart.setSignature(html$.KeyEvent, {
    constructors: () => ({
      wrap: dart.definiteFunctionType(html$.KeyEvent, [html$.KeyboardEvent]),
      new: dart.definiteFunctionType(html$.KeyEvent, [core.String], {view: html$.Window, canBubble: core.bool, cancelable: core.bool, keyCode: core.int, charCode: core.int, keyLocation: core.int, ctrlKey: core.bool, altKey: core.bool, shiftKey: core.bool, metaKey: core.bool, currentTarget: html$.EventTarget})
    }),
    methods: () => ({
      [_initUIEvent]: dart.definiteFunctionType(dart.void, [core.String, core.bool, core.bool, html$.Window, core.int]),
      [_initKeyboardEvent]: dart.definiteFunctionType(dart.void, [core.String, core.bool, core.bool, html$.Window, core.String, core.int, core.bool, core.bool, core.bool, core.bool]),
      getModifierState: dart.definiteFunctionType(core.bool, [core.String])
    }),
    statics: () => ({
      _makeRecord: dart.definiteFunctionType(dart.dynamic, []),
      _convertToHexString: dart.definiteFunctionType(core.String, [core.int, core.int])
    }),
    names: ['_makeRecord', '_convertToHexString']
  });
  dart.defineLazy(html$.KeyEvent, {
    get _keyboardEventDispatchRecord() {
      return html$.KeyEvent._makeRecord();
    },
    get keyDownEvent() {
      return new html$._KeyboardEventHandler('keydown');
    },
    set keyDownEvent(_) {},
    get keyUpEvent() {
      return new html$._KeyboardEventHandler('keyup');
    },
    set keyUpEvent(_) {},
    get keyPressEvent() {
      return new html$._KeyboardEventHandler('keypress');
    },
    set keyPressEvent(_) {}
  });
  html$._CustomKeyEventStreamImpl = class _CustomKeyEventStreamImpl extends html$._CustomEventStreamImpl$(html$.KeyEvent) {
    new(type) {
      super.new(type);
    }
    add(event) {
      if (event.type == this[_type]) {
        event.currentTarget[dartx.dispatchEvent](event[_parent$]);
        this[_streamController].add(event);
      }
    }
  };
  dart.addSimpleTypeTests(html$._CustomKeyEventStreamImpl);
  html$._CustomKeyEventStreamImpl[dart.implements] = () => [CustomStreamOfKeyEvent()];
  dart.setSignature(html$._CustomKeyEventStreamImpl, {
    constructors: () => ({new: dart.definiteFunctionType(html$._CustomKeyEventStreamImpl, [core.String])}),
    methods: () => ({add: dart.definiteFunctionType(dart.void, [html$.KeyEvent])})
  });
  const _subscriptions = Symbol('_subscriptions');
  const _controller$0 = Symbol('_controller');
  html$._StreamPool$ = dart.generic(T => {
    let StreamOfT = () => (StreamOfT = dart.constFn(async.Stream$(T)))();
    let StreamSubscriptionOfT = () => (StreamSubscriptionOfT = dart.constFn(async.StreamSubscription$(T)))();
    let MapOfStreamOfT$StreamSubscriptionOfT = () => (MapOfStreamOfT$StreamSubscriptionOfT = dart.constFn(core.Map$(StreamOfT(), StreamSubscriptionOfT())))();
    let StreamControllerOfT = () => (StreamControllerOfT = dart.constFn(async.StreamController$(T)))();
    class _StreamPool extends core.Object {
      broadcast() {
        this[_subscriptions] = MapOfStreamOfT$StreamSubscriptionOfT().new();
        this[_controller$0] = null;
        this[_controller$0] = StreamControllerOfT().broadcast({sync: true, onCancel: dart.bind(this, 'close')});
      }
      get stream() {
        return this[_controller$0].stream;
      }
      add(stream) {
        StreamOfT()._check(stream);
        if (dart.test(this[_subscriptions][dartx.containsKey](stream))) return;
        this[_subscriptions][dartx.set](stream, stream.listen(dart.bind(this[_controller$0], 'add'), {onError: dart.bind(this[_controller$0], 'addError'), onDone: dart.fn(() => this.remove(stream), VoidTovoid$())}));
      }
      remove(stream) {
        StreamOfT()._check(stream);
        let subscription = this[_subscriptions][dartx.remove](stream);
        if (subscription != null) subscription.cancel();
      }
      close() {
        for (let subscription of this[_subscriptions][dartx.values]) {
          subscription.cancel();
        }
        this[_subscriptions][dartx.clear]();
        this[_controller$0].close();
      }
    }
    dart.addTypeTests(_StreamPool);
    dart.defineNamedConstructor(_StreamPool, 'broadcast');
    dart.setSignature(_StreamPool, {
      constructors: () => ({broadcast: dart.definiteFunctionType(html$._StreamPool$(T), [])}),
      methods: () => ({
        add: dart.definiteFunctionType(dart.void, [async.Stream$(T)]),
        remove: dart.definiteFunctionType(dart.void, [async.Stream$(T)]),
        close: dart.definiteFunctionType(dart.void, [])
      })
    });
    return _StreamPool;
  });
  html$._StreamPool = _StreamPool();
  const _eventTypeGetter = Symbol('_eventTypeGetter');
  html$._CustomEventStreamProvider$ = dart.generic(T => {
    let _EventStreamOfT = () => (_EventStreamOfT = dart.constFn(html$._EventStream$(T)))();
    let _ElementEventStreamImplOfT = () => (_ElementEventStreamImplOfT = dart.constFn(html$._ElementEventStreamImpl$(T)))();
    let _ElementListEventStreamImplOfT = () => (_ElementListEventStreamImplOfT = dart.constFn(html$._ElementListEventStreamImpl$(T)))();
    let EventStreamProviderOfT = () => (EventStreamProviderOfT = dart.constFn(html$.EventStreamProvider$(T)))();
    class _CustomEventStreamProvider extends core.Object {
      new(eventTypeGetter) {
        this[_eventTypeGetter] = eventTypeGetter;
      }
      forTarget(e, opts) {
        let useCapture = opts && 'useCapture' in opts ? opts.useCapture : false;
        return new (_EventStreamOfT())(e, core.String._check(dart.dcall(this[_eventTypeGetter], e)), useCapture);
      }
      forElement(e, opts) {
        let useCapture = opts && 'useCapture' in opts ? opts.useCapture : false;
        return new (_ElementEventStreamImplOfT())(e, dart.dcall(this[_eventTypeGetter], e), useCapture);
      }
      [_forElementList](e, opts) {
        let useCapture = opts && 'useCapture' in opts ? opts.useCapture : false;
        return new (_ElementListEventStreamImplOfT())(e, core.String._check(dart.dcall(this[_eventTypeGetter], e)), useCapture);
      }
      getEventType(target) {
        return core.String._check(dart.dcall(this[_eventTypeGetter], target));
      }
      get [_eventType]() {
        return dart.throw(new core.UnsupportedError('Access type through getEventType method.'));
      }
    }
    dart.addTypeTests(_CustomEventStreamProvider);
    _CustomEventStreamProvider[dart.implements] = () => [EventStreamProviderOfT()];
    dart.setSignature(_CustomEventStreamProvider, {
      constructors: () => ({new: dart.definiteFunctionType(html$._CustomEventStreamProvider$(T), [dart.dynamic])}),
      methods: () => ({
        forTarget: dart.definiteFunctionType(async.Stream$(T), [html$.EventTarget], {useCapture: core.bool}),
        forElement: dart.definiteFunctionType(html$.ElementStream$(T), [html$.Element], {useCapture: core.bool}),
        [_forElementList]: dart.definiteFunctionType(html$.ElementStream$(T), [html$.ElementList$(html$.Element)], {useCapture: core.bool}),
        getEventType: dart.definiteFunctionType(core.String, [html$.EventTarget])
      })
    });
    return _CustomEventStreamProvider;
  });
  html$._CustomEventStreamProvider = _CustomEventStreamProvider();
  html$._Html5NodeValidator = class _Html5NodeValidator extends core.Object {
    new(opts) {
      let uriPolicy = opts && 'uriPolicy' in opts ? opts.uriPolicy : null;
      this.uriPolicy = uriPolicy != null ? uriPolicy : html$.UriPolicy.new();
      if (dart.test(html$._Html5NodeValidator._attributeValidators[dartx.isEmpty])) {
        for (let attr of html$._Html5NodeValidator._standardAttributes) {
          html$._Html5NodeValidator._attributeValidators[dartx.set](attr, html$._Html5NodeValidator._standardAttributeValidator);
        }
        for (let attr of html$._Html5NodeValidator._uriAttributes) {
          html$._Html5NodeValidator._attributeValidators[dartx.set](attr, html$._Html5NodeValidator._uriAttributeValidator);
        }
      }
    }
    allowsElement(element) {
      return html$._Html5NodeValidator._allowedElements.contains(html$.Element._safeTagName(element));
    }
    allowsAttribute(element, attributeName, value) {
      let tagName = html$.Element._safeTagName(element);
      let validator = html$._Html5NodeValidator._attributeValidators[dartx.get](dart.str`${tagName}::${attributeName}`);
      if (validator == null) {
        validator = html$._Html5NodeValidator._attributeValidators[dartx.get](dart.str`*::${attributeName}`);
      }
      if (validator == null) {
        return false;
      }
      return core.bool._check(dart.dcall(validator, element, attributeName, value, this));
    }
    static _standardAttributeValidator(element, attributeName, value, context) {
      return true;
    }
    static _uriAttributeValidator(element, attributeName, value, context) {
      return context.uriPolicy.allowsUri(value);
    }
  };
  html$._Html5NodeValidator[dart.implements] = () => [html$.NodeValidator];
  dart.setSignature(html$._Html5NodeValidator, {
    constructors: () => ({new: dart.definiteFunctionType(html$._Html5NodeValidator, [], {uriPolicy: html$.UriPolicy})}),
    methods: () => ({
      allowsElement: dart.definiteFunctionType(core.bool, [html$.Element]),
      allowsAttribute: dart.definiteFunctionType(core.bool, [html$.Element, core.String, core.String])
    }),
    statics: () => ({
      _standardAttributeValidator: dart.definiteFunctionType(core.bool, [html$.Element, core.String, core.String, html$._Html5NodeValidator]),
      _uriAttributeValidator: dart.definiteFunctionType(core.bool, [html$.Element, core.String, core.String, html$._Html5NodeValidator])
    }),
    names: ['_standardAttributeValidator', '_uriAttributeValidator']
  });
  html$._Html5NodeValidator._standardAttributes = dart.constList(['*::class', '*::dir', '*::draggable', '*::hidden', '*::id', '*::inert', '*::itemprop', '*::itemref', '*::itemscope', '*::lang', '*::spellcheck', '*::title', '*::translate', 'A::accesskey', 'A::coords', 'A::hreflang', 'A::name', 'A::shape', 'A::tabindex', 'A::target', 'A::type', 'AREA::accesskey', 'AREA::alt', 'AREA::coords', 'AREA::nohref', 'AREA::shape', 'AREA::tabindex', 'AREA::target', 'AUDIO::controls', 'AUDIO::loop', 'AUDIO::mediagroup', 'AUDIO::muted', 'AUDIO::preload', 'BDO::dir', 'BODY::alink', 'BODY::bgcolor', 'BODY::link', 'BODY::text', 'BODY::vlink', 'BR::clear', 'BUTTON::accesskey', 'BUTTON::disabled', 'BUTTON::name', 'BUTTON::tabindex', 'BUTTON::type', 'BUTTON::value', 'CANVAS::height', 'CANVAS::width', 'CAPTION::align', 'COL::align', 'COL::char', 'COL::charoff', 'COL::span', 'COL::valign', 'COL::width', 'COLGROUP::align', 'COLGROUP::char', 'COLGROUP::charoff', 'COLGROUP::span', 'COLGROUP::valign', 'COLGROUP::width', 'COMMAND::checked', 'COMMAND::command', 'COMMAND::disabled', 'COMMAND::label', 'COMMAND::radiogroup', 'COMMAND::type', 'DATA::value', 'DEL::datetime', 'DETAILS::open', 'DIR::compact', 'DIV::align', 'DL::compact', 'FIELDSET::disabled', 'FONT::color', 'FONT::face', 'FONT::size', 'FORM::accept', 'FORM::autocomplete', 'FORM::enctype', 'FORM::method', 'FORM::name', 'FORM::novalidate', 'FORM::target', 'FRAME::name', 'H1::align', 'H2::align', 'H3::align', 'H4::align', 'H5::align', 'H6::align', 'HR::align', 'HR::noshade', 'HR::size', 'HR::width', 'HTML::version', 'IFRAME::align', 'IFRAME::frameborder', 'IFRAME::height', 'IFRAME::marginheight', 'IFRAME::marginwidth', 'IFRAME::width', 'IMG::align', 'IMG::alt', 'IMG::border', 'IMG::height', 'IMG::hspace', 'IMG::ismap', 'IMG::name', 'IMG::usemap', 'IMG::vspace', 'IMG::width', 'INPUT::accept', 'INPUT::accesskey', 'INPUT::align', 'INPUT::alt', 'INPUT::autocomplete', 'INPUT::autofocus', 'INPUT::checked', 'INPUT::disabled', 'INPUT::inputmode', 'INPUT::ismap', 'INPUT::list', 'INPUT::max', 'INPUT::maxlength', 'INPUT::min', 'INPUT::multiple', 'INPUT::name', 'INPUT::placeholder', 'INPUT::readonly', 'INPUT::required', 'INPUT::size', 'INPUT::step', 'INPUT::tabindex', 'INPUT::type', 'INPUT::usemap', 'INPUT::value', 'INS::datetime', 'KEYGEN::disabled', 'KEYGEN::keytype', 'KEYGEN::name', 'LABEL::accesskey', 'LABEL::for', 'LEGEND::accesskey', 'LEGEND::align', 'LI::type', 'LI::value', 'LINK::sizes', 'MAP::name', 'MENU::compact', 'MENU::label', 'MENU::type', 'METER::high', 'METER::low', 'METER::max', 'METER::min', 'METER::value', 'OBJECT::typemustmatch', 'OL::compact', 'OL::reversed', 'OL::start', 'OL::type', 'OPTGROUP::disabled', 'OPTGROUP::label', 'OPTION::disabled', 'OPTION::label', 'OPTION::selected', 'OPTION::value', 'OUTPUT::for', 'OUTPUT::name', 'P::align', 'PRE::width', 'PROGRESS::max', 'PROGRESS::min', 'PROGRESS::value', 'SELECT::autocomplete', 'SELECT::disabled', 'SELECT::multiple', 'SELECT::name', 'SELECT::required', 'SELECT::size', 'SELECT::tabindex', 'SOURCE::type', 'TABLE::align', 'TABLE::bgcolor', 'TABLE::border', 'TABLE::cellpadding', 'TABLE::cellspacing', 'TABLE::frame', 'TABLE::rules', 'TABLE::summary', 'TABLE::width', 'TBODY::align', 'TBODY::char', 'TBODY::charoff', 'TBODY::valign', 'TD::abbr', 'TD::align', 'TD::axis', 'TD::bgcolor', 'TD::char', 'TD::charoff', 'TD::colspan', 'TD::headers', 'TD::height', 'TD::nowrap', 'TD::rowspan', 'TD::scope', 'TD::valign', 'TD::width', 'TEXTAREA::accesskey', 'TEXTAREA::autocomplete', 'TEXTAREA::cols', 'TEXTAREA::disabled', 'TEXTAREA::inputmode', 'TEXTAREA::name', 'TEXTAREA::placeholder', 'TEXTAREA::readonly', 'TEXTAREA::required', 'TEXTAREA::rows', 'TEXTAREA::tabindex', 'TEXTAREA::wrap', 'TFOOT::align', 'TFOOT::char', 'TFOOT::charoff', 'TFOOT::valign', 'TH::abbr', 'TH::align', 'TH::axis', 'TH::bgcolor', 'TH::char', 'TH::charoff', 'TH::colspan', 'TH::headers', 'TH::height', 'TH::nowrap', 'TH::rowspan', 'TH::scope', 'TH::valign', 'TH::width', 'THEAD::align', 'THEAD::char', 'THEAD::charoff', 'THEAD::valign', 'TR::align', 'TR::bgcolor', 'TR::char', 'TR::charoff', 'TR::valign', 'TRACK::default', 'TRACK::kind', 'TRACK::label', 'TRACK::srclang', 'UL::compact', 'UL::type', 'VIDEO::controls', 'VIDEO::height', 'VIDEO::loop', 'VIDEO::mediagroup', 'VIDEO::muted', 'VIDEO::preload', 'VIDEO::width'], core.String);
  html$._Html5NodeValidator._uriAttributes = dart.constList(['A::href', 'AREA::href', 'BLOCKQUOTE::cite', 'BODY::background', 'COMMAND::icon', 'DEL::cite', 'FORM::action', 'IMG::src', 'INPUT::src', 'INS::cite', 'Q::cite', 'VIDEO::poster'], core.String);
  dart.defineLazy(html$._Html5NodeValidator, {
    get _allowedElements() {
      return SetOfString().from(JSArrayOfString().of(['A', 'ABBR', 'ACRONYM', 'ADDRESS', 'AREA', 'ARTICLE', 'ASIDE', 'AUDIO', 'B', 'BDI', 'BDO', 'BIG', 'BLOCKQUOTE', 'BR', 'BUTTON', 'CANVAS', 'CAPTION', 'CENTER', 'CITE', 'CODE', 'COL', 'COLGROUP', 'COMMAND', 'DATA', 'DATALIST', 'DD', 'DEL', 'DETAILS', 'DFN', 'DIR', 'DIV', 'DL', 'DT', 'EM', 'FIELDSET', 'FIGCAPTION', 'FIGURE', 'FONT', 'FOOTER', 'FORM', 'H1', 'H2', 'H3', 'H4', 'H5', 'H6', 'HEADER', 'HGROUP', 'HR', 'I', 'IFRAME', 'IMG', 'INPUT', 'INS', 'KBD', 'LABEL', 'LEGEND', 'LI', 'MAP', 'MARK', 'MENU', 'METER', 'NAV', 'NOBR', 'OL', 'OPTGROUP', 'OPTION', 'OUTPUT', 'P', 'PRE', 'PROGRESS', 'Q', 'S', 'SAMP', 'SECTION', 'SELECT', 'SMALL', 'SOURCE', 'SPAN', 'STRIKE', 'STRONG', 'SUB', 'SUMMARY', 'SUP', 'TABLE', 'TBODY', 'TD', 'TEXTAREA', 'TFOOT', 'TH', 'THEAD', 'TIME', 'TR', 'TRACK', 'TT', 'U', 'UL', 'VAR', 'VIDEO', 'WBR']));
    },
    get _attributeValidators() {
      return dart.map();
    }
  });
  html$.KeyCode = class KeyCode extends core.Object {
    static isCharacterKey(keyCode) {
      if (dart.notNull(keyCode) >= html$.KeyCode.ZERO && dart.notNull(keyCode) <= html$.KeyCode.NINE || dart.notNull(keyCode) >= html$.KeyCode.NUM_ZERO && dart.notNull(keyCode) <= html$.KeyCode.NUM_MULTIPLY || dart.notNull(keyCode) >= html$.KeyCode.A && dart.notNull(keyCode) <= html$.KeyCode.Z) {
        return true;
      }
      if (dart.test(html_common.Device.isWebKit) && keyCode == 0) {
        return true;
      }
      return keyCode == html$.KeyCode.SPACE || keyCode == html$.KeyCode.QUESTION_MARK || keyCode == html$.KeyCode.NUM_PLUS || keyCode == html$.KeyCode.NUM_MINUS || keyCode == html$.KeyCode.NUM_PERIOD || keyCode == html$.KeyCode.NUM_DIVISION || keyCode == html$.KeyCode.SEMICOLON || keyCode == html$.KeyCode.FF_SEMICOLON || keyCode == html$.KeyCode.DASH || keyCode == html$.KeyCode.EQUALS || keyCode == html$.KeyCode.FF_EQUALS || keyCode == html$.KeyCode.COMMA || keyCode == html$.KeyCode.PERIOD || keyCode == html$.KeyCode.SLASH || keyCode == html$.KeyCode.APOSTROPHE || keyCode == html$.KeyCode.SINGLE_QUOTE || keyCode == html$.KeyCode.OPEN_SQUARE_BRACKET || keyCode == html$.KeyCode.BACKSLASH || keyCode == html$.KeyCode.CLOSE_SQUARE_BRACKET;
    }
    static _convertKeyCodeToKeyName(keyCode) {
      switch (keyCode) {
        case html$.KeyCode.ALT:
        {
          return html$._KeyName.ALT;
        }
        case html$.KeyCode.BACKSPACE:
        {
          return html$._KeyName.BACKSPACE;
        }
        case html$.KeyCode.CAPS_LOCK:
        {
          return html$._KeyName.CAPS_LOCK;
        }
        case html$.KeyCode.CTRL:
        {
          return html$._KeyName.CONTROL;
        }
        case html$.KeyCode.DELETE:
        {
          return html$._KeyName.DEL;
        }
        case html$.KeyCode.DOWN:
        {
          return html$._KeyName.DOWN;
        }
        case html$.KeyCode.END:
        {
          return html$._KeyName.END;
        }
        case html$.KeyCode.ENTER:
        {
          return html$._KeyName.ENTER;
        }
        case html$.KeyCode.ESC:
        {
          return html$._KeyName.ESC;
        }
        case html$.KeyCode.F1:
        {
          return html$._KeyName.F1;
        }
        case html$.KeyCode.F2:
        {
          return html$._KeyName.F2;
        }
        case html$.KeyCode.F3:
        {
          return html$._KeyName.F3;
        }
        case html$.KeyCode.F4:
        {
          return html$._KeyName.F4;
        }
        case html$.KeyCode.F5:
        {
          return html$._KeyName.F5;
        }
        case html$.KeyCode.F6:
        {
          return html$._KeyName.F6;
        }
        case html$.KeyCode.F7:
        {
          return html$._KeyName.F7;
        }
        case html$.KeyCode.F8:
        {
          return html$._KeyName.F8;
        }
        case html$.KeyCode.F9:
        {
          return html$._KeyName.F9;
        }
        case html$.KeyCode.F10:
        {
          return html$._KeyName.F10;
        }
        case html$.KeyCode.F11:
        {
          return html$._KeyName.F11;
        }
        case html$.KeyCode.F12:
        {
          return html$._KeyName.F12;
        }
        case html$.KeyCode.HOME:
        {
          return html$._KeyName.HOME;
        }
        case html$.KeyCode.INSERT:
        {
          return html$._KeyName.INSERT;
        }
        case html$.KeyCode.LEFT:
        {
          return html$._KeyName.LEFT;
        }
        case html$.KeyCode.META:
        {
          return html$._KeyName.META;
        }
        case html$.KeyCode.NUMLOCK:
        {
          return html$._KeyName.NUM_LOCK;
        }
        case html$.KeyCode.PAGE_DOWN:
        {
          return html$._KeyName.PAGE_DOWN;
        }
        case html$.KeyCode.PAGE_UP:
        {
          return html$._KeyName.PAGE_UP;
        }
        case html$.KeyCode.PAUSE:
        {
          return html$._KeyName.PAUSE;
        }
        case html$.KeyCode.PRINT_SCREEN:
        {
          return html$._KeyName.PRINT_SCREEN;
        }
        case html$.KeyCode.RIGHT:
        {
          return html$._KeyName.RIGHT;
        }
        case html$.KeyCode.SCROLL_LOCK:
        {
          return html$._KeyName.SCROLL;
        }
        case html$.KeyCode.SHIFT:
        {
          return html$._KeyName.SHIFT;
        }
        case html$.KeyCode.SPACE:
        {
          return html$._KeyName.SPACEBAR;
        }
        case html$.KeyCode.TAB:
        {
          return html$._KeyName.TAB;
        }
        case html$.KeyCode.UP:
        {
          return html$._KeyName.UP;
        }
        case html$.KeyCode.WIN_IME:
        case html$.KeyCode.WIN_KEY:
        case html$.KeyCode.WIN_KEY_LEFT:
        case html$.KeyCode.WIN_KEY_RIGHT:
        {
          return html$._KeyName.WIN;
        }
        default:
        {
          return html$._KeyName.UNIDENTIFIED;
        }
      }
      return html$._KeyName.UNIDENTIFIED;
    }
  };
  dart.setSignature(html$.KeyCode, {
    statics: () => ({
      isCharacterKey: dart.definiteFunctionType(core.bool, [core.int]),
      _convertKeyCodeToKeyName: dart.definiteFunctionType(core.String, [core.int])
    }),
    names: ['isCharacterKey', '_convertKeyCodeToKeyName']
  });
  html$.KeyCode.WIN_KEY_FF_LINUX = 0;
  html$.KeyCode.MAC_ENTER = 3;
  html$.KeyCode.BACKSPACE = 8;
  html$.KeyCode.TAB = 9;
  html$.KeyCode.NUM_CENTER = 12;
  html$.KeyCode.ENTER = 13;
  html$.KeyCode.SHIFT = 16;
  html$.KeyCode.CTRL = 17;
  html$.KeyCode.ALT = 18;
  html$.KeyCode.PAUSE = 19;
  html$.KeyCode.CAPS_LOCK = 20;
  html$.KeyCode.ESC = 27;
  html$.KeyCode.SPACE = 32;
  html$.KeyCode.PAGE_UP = 33;
  html$.KeyCode.PAGE_DOWN = 34;
  html$.KeyCode.END = 35;
  html$.KeyCode.HOME = 36;
  html$.KeyCode.LEFT = 37;
  html$.KeyCode.UP = 38;
  html$.KeyCode.RIGHT = 39;
  html$.KeyCode.DOWN = 40;
  html$.KeyCode.NUM_NORTH_EAST = 33;
  html$.KeyCode.NUM_SOUTH_EAST = 34;
  html$.KeyCode.NUM_SOUTH_WEST = 35;
  html$.KeyCode.NUM_NORTH_WEST = 36;
  html$.KeyCode.NUM_WEST = 37;
  html$.KeyCode.NUM_NORTH = 38;
  html$.KeyCode.NUM_EAST = 39;
  html$.KeyCode.NUM_SOUTH = 40;
  html$.KeyCode.PRINT_SCREEN = 44;
  html$.KeyCode.INSERT = 45;
  html$.KeyCode.NUM_INSERT = 45;
  html$.KeyCode.DELETE = 46;
  html$.KeyCode.NUM_DELETE = 46;
  html$.KeyCode.ZERO = 48;
  html$.KeyCode.ONE = 49;
  html$.KeyCode.TWO = 50;
  html$.KeyCode.THREE = 51;
  html$.KeyCode.FOUR = 52;
  html$.KeyCode.FIVE = 53;
  html$.KeyCode.SIX = 54;
  html$.KeyCode.SEVEN = 55;
  html$.KeyCode.EIGHT = 56;
  html$.KeyCode.NINE = 57;
  html$.KeyCode.FF_SEMICOLON = 59;
  html$.KeyCode.FF_EQUALS = 61;
  html$.KeyCode.QUESTION_MARK = 63;
  html$.KeyCode.A = 65;
  html$.KeyCode.B = 66;
  html$.KeyCode.C = 67;
  html$.KeyCode.D = 68;
  html$.KeyCode.E = 69;
  html$.KeyCode.F = 70;
  html$.KeyCode.G = 71;
  html$.KeyCode.H = 72;
  html$.KeyCode.I = 73;
  html$.KeyCode.J = 74;
  html$.KeyCode.K = 75;
  html$.KeyCode.L = 76;
  html$.KeyCode.M = 77;
  html$.KeyCode.N = 78;
  html$.KeyCode.O = 79;
  html$.KeyCode.P = 80;
  html$.KeyCode.Q = 81;
  html$.KeyCode.R = 82;
  html$.KeyCode.S = 83;
  html$.KeyCode.T = 84;
  html$.KeyCode.U = 85;
  html$.KeyCode.V = 86;
  html$.KeyCode.W = 87;
  html$.KeyCode.X = 88;
  html$.KeyCode.Y = 89;
  html$.KeyCode.Z = 90;
  html$.KeyCode.META = 91;
  html$.KeyCode.WIN_KEY_LEFT = 91;
  html$.KeyCode.WIN_KEY_RIGHT = 92;
  html$.KeyCode.CONTEXT_MENU = 93;
  html$.KeyCode.NUM_ZERO = 96;
  html$.KeyCode.NUM_ONE = 97;
  html$.KeyCode.NUM_TWO = 98;
  html$.KeyCode.NUM_THREE = 99;
  html$.KeyCode.NUM_FOUR = 100;
  html$.KeyCode.NUM_FIVE = 101;
  html$.KeyCode.NUM_SIX = 102;
  html$.KeyCode.NUM_SEVEN = 103;
  html$.KeyCode.NUM_EIGHT = 104;
  html$.KeyCode.NUM_NINE = 105;
  html$.KeyCode.NUM_MULTIPLY = 106;
  html$.KeyCode.NUM_PLUS = 107;
  html$.KeyCode.NUM_MINUS = 109;
  html$.KeyCode.NUM_PERIOD = 110;
  html$.KeyCode.NUM_DIVISION = 111;
  html$.KeyCode.F1 = 112;
  html$.KeyCode.F2 = 113;
  html$.KeyCode.F3 = 114;
  html$.KeyCode.F4 = 115;
  html$.KeyCode.F5 = 116;
  html$.KeyCode.F6 = 117;
  html$.KeyCode.F7 = 118;
  html$.KeyCode.F8 = 119;
  html$.KeyCode.F9 = 120;
  html$.KeyCode.F10 = 121;
  html$.KeyCode.F11 = 122;
  html$.KeyCode.F12 = 123;
  html$.KeyCode.NUMLOCK = 144;
  html$.KeyCode.SCROLL_LOCK = 145;
  html$.KeyCode.FIRST_MEDIA_KEY = 166;
  html$.KeyCode.LAST_MEDIA_KEY = 183;
  html$.KeyCode.SEMICOLON = 186;
  html$.KeyCode.DASH = 189;
  html$.KeyCode.EQUALS = 187;
  html$.KeyCode.COMMA = 188;
  html$.KeyCode.PERIOD = 190;
  html$.KeyCode.SLASH = 191;
  html$.KeyCode.APOSTROPHE = 192;
  html$.KeyCode.TILDE = 192;
  html$.KeyCode.SINGLE_QUOTE = 222;
  html$.KeyCode.OPEN_SQUARE_BRACKET = 219;
  html$.KeyCode.BACKSLASH = 220;
  html$.KeyCode.CLOSE_SQUARE_BRACKET = 221;
  html$.KeyCode.WIN_KEY = 224;
  html$.KeyCode.MAC_FF_META = 224;
  html$.KeyCode.WIN_IME = 229;
  html$.KeyCode.UNKNOWN = -1;
  html$.KeyLocation = class KeyLocation extends core.Object {};
  html$.KeyLocation.STANDARD = 0;
  html$.KeyLocation.LEFT = 1;
  html$.KeyLocation.RIGHT = 2;
  html$.KeyLocation.NUMPAD = 3;
  html$.KeyLocation.MOBILE = 4;
  html$.KeyLocation.JOYSTICK = 5;
  html$._KeyName = class _KeyName extends core.Object {};
  html$._KeyName.ACCEPT = "Accept";
  html$._KeyName.ADD = "Add";
  html$._KeyName.AGAIN = "Again";
  html$._KeyName.ALL_CANDIDATES = "AllCandidates";
  html$._KeyName.ALPHANUMERIC = "Alphanumeric";
  html$._KeyName.ALT = "Alt";
  html$._KeyName.ALT_GRAPH = "AltGraph";
  html$._KeyName.APPS = "Apps";
  html$._KeyName.ATTN = "Attn";
  html$._KeyName.BROWSER_BACK = "BrowserBack";
  html$._KeyName.BROWSER_FAVORTIES = "BrowserFavorites";
  html$._KeyName.BROWSER_FORWARD = "BrowserForward";
  html$._KeyName.BROWSER_NAME = "BrowserHome";
  html$._KeyName.BROWSER_REFRESH = "BrowserRefresh";
  html$._KeyName.BROWSER_SEARCH = "BrowserSearch";
  html$._KeyName.BROWSER_STOP = "BrowserStop";
  html$._KeyName.CAMERA = "Camera";
  html$._KeyName.CAPS_LOCK = "CapsLock";
  html$._KeyName.CLEAR = "Clear";
  html$._KeyName.CODE_INPUT = "CodeInput";
  html$._KeyName.COMPOSE = "Compose";
  html$._KeyName.CONTROL = "Control";
  html$._KeyName.CRSEL = "Crsel";
  html$._KeyName.CONVERT = "Convert";
  html$._KeyName.COPY = "Copy";
  html$._KeyName.CUT = "Cut";
  html$._KeyName.DECIMAL = "Decimal";
  html$._KeyName.DIVIDE = "Divide";
  html$._KeyName.DOWN = "Down";
  html$._KeyName.DOWN_LEFT = "DownLeft";
  html$._KeyName.DOWN_RIGHT = "DownRight";
  html$._KeyName.EJECT = "Eject";
  html$._KeyName.END = "End";
  html$._KeyName.ENTER = "Enter";
  html$._KeyName.ERASE_EOF = "EraseEof";
  html$._KeyName.EXECUTE = "Execute";
  html$._KeyName.EXSEL = "Exsel";
  html$._KeyName.FN = "Fn";
  html$._KeyName.F1 = "F1";
  html$._KeyName.F2 = "F2";
  html$._KeyName.F3 = "F3";
  html$._KeyName.F4 = "F4";
  html$._KeyName.F5 = "F5";
  html$._KeyName.F6 = "F6";
  html$._KeyName.F7 = "F7";
  html$._KeyName.F8 = "F8";
  html$._KeyName.F9 = "F9";
  html$._KeyName.F10 = "F10";
  html$._KeyName.F11 = "F11";
  html$._KeyName.F12 = "F12";
  html$._KeyName.F13 = "F13";
  html$._KeyName.F14 = "F14";
  html$._KeyName.F15 = "F15";
  html$._KeyName.F16 = "F16";
  html$._KeyName.F17 = "F17";
  html$._KeyName.F18 = "F18";
  html$._KeyName.F19 = "F19";
  html$._KeyName.F20 = "F20";
  html$._KeyName.F21 = "F21";
  html$._KeyName.F22 = "F22";
  html$._KeyName.F23 = "F23";
  html$._KeyName.F24 = "F24";
  html$._KeyName.FINAL_MODE = "FinalMode";
  html$._KeyName.FIND = "Find";
  html$._KeyName.FULL_WIDTH = "FullWidth";
  html$._KeyName.HALF_WIDTH = "HalfWidth";
  html$._KeyName.HANGUL_MODE = "HangulMode";
  html$._KeyName.HANJA_MODE = "HanjaMode";
  html$._KeyName.HELP = "Help";
  html$._KeyName.HIRAGANA = "Hiragana";
  html$._KeyName.HOME = "Home";
  html$._KeyName.INSERT = "Insert";
  html$._KeyName.JAPANESE_HIRAGANA = "JapaneseHiragana";
  html$._KeyName.JAPANESE_KATAKANA = "JapaneseKatakana";
  html$._KeyName.JAPANESE_ROMAJI = "JapaneseRomaji";
  html$._KeyName.JUNJA_MODE = "JunjaMode";
  html$._KeyName.KANA_MODE = "KanaMode";
  html$._KeyName.KANJI_MODE = "KanjiMode";
  html$._KeyName.KATAKANA = "Katakana";
  html$._KeyName.LAUNCH_APPLICATION_1 = "LaunchApplication1";
  html$._KeyName.LAUNCH_APPLICATION_2 = "LaunchApplication2";
  html$._KeyName.LAUNCH_MAIL = "LaunchMail";
  html$._KeyName.LEFT = "Left";
  html$._KeyName.MENU = "Menu";
  html$._KeyName.META = "Meta";
  html$._KeyName.MEDIA_NEXT_TRACK = "MediaNextTrack";
  html$._KeyName.MEDIA_PAUSE_PLAY = "MediaPlayPause";
  html$._KeyName.MEDIA_PREVIOUS_TRACK = "MediaPreviousTrack";
  html$._KeyName.MEDIA_STOP = "MediaStop";
  html$._KeyName.MODE_CHANGE = "ModeChange";
  html$._KeyName.NEXT_CANDIDATE = "NextCandidate";
  html$._KeyName.NON_CONVERT = "Nonconvert";
  html$._KeyName.NUM_LOCK = "NumLock";
  html$._KeyName.PAGE_DOWN = "PageDown";
  html$._KeyName.PAGE_UP = "PageUp";
  html$._KeyName.PASTE = "Paste";
  html$._KeyName.PAUSE = "Pause";
  html$._KeyName.PLAY = "Play";
  html$._KeyName.POWER = "Power";
  html$._KeyName.PREVIOUS_CANDIDATE = "PreviousCandidate";
  html$._KeyName.PRINT_SCREEN = "PrintScreen";
  html$._KeyName.PROCESS = "Process";
  html$._KeyName.PROPS = "Props";
  html$._KeyName.RIGHT = "Right";
  html$._KeyName.ROMAN_CHARACTERS = "RomanCharacters";
  html$._KeyName.SCROLL = "Scroll";
  html$._KeyName.SELECT = "Select";
  html$._KeyName.SELECT_MEDIA = "SelectMedia";
  html$._KeyName.SEPARATOR = "Separator";
  html$._KeyName.SHIFT = "Shift";
  html$._KeyName.SOFT_1 = "Soft1";
  html$._KeyName.SOFT_2 = "Soft2";
  html$._KeyName.SOFT_3 = "Soft3";
  html$._KeyName.SOFT_4 = "Soft4";
  html$._KeyName.STOP = "Stop";
  html$._KeyName.SUBTRACT = "Subtract";
  html$._KeyName.SYMBOL_LOCK = "SymbolLock";
  html$._KeyName.UP = "Up";
  html$._KeyName.UP_LEFT = "UpLeft";
  html$._KeyName.UP_RIGHT = "UpRight";
  html$._KeyName.UNDO = "Undo";
  html$._KeyName.VOLUME_DOWN = "VolumeDown";
  html$._KeyName.VOLUMN_MUTE = "VolumeMute";
  html$._KeyName.VOLUMN_UP = "VolumeUp";
  html$._KeyName.WIN = "Win";
  html$._KeyName.ZOOM = "Zoom";
  html$._KeyName.BACKSPACE = "Backspace";
  html$._KeyName.TAB = "Tab";
  html$._KeyName.CANCEL = "Cancel";
  html$._KeyName.ESC = "Esc";
  html$._KeyName.SPACEBAR = "Spacebar";
  html$._KeyName.DEL = "Del";
  html$._KeyName.DEAD_GRAVE = "DeadGrave";
  html$._KeyName.DEAD_EACUTE = "DeadEacute";
  html$._KeyName.DEAD_CIRCUMFLEX = "DeadCircumflex";
  html$._KeyName.DEAD_TILDE = "DeadTilde";
  html$._KeyName.DEAD_MACRON = "DeadMacron";
  html$._KeyName.DEAD_BREVE = "DeadBreve";
  html$._KeyName.DEAD_ABOVE_DOT = "DeadAboveDot";
  html$._KeyName.DEAD_UMLAUT = "DeadUmlaut";
  html$._KeyName.DEAD_ABOVE_RING = "DeadAboveRing";
  html$._KeyName.DEAD_DOUBLEACUTE = "DeadDoubleacute";
  html$._KeyName.DEAD_CARON = "DeadCaron";
  html$._KeyName.DEAD_CEDILLA = "DeadCedilla";
  html$._KeyName.DEAD_OGONEK = "DeadOgonek";
  html$._KeyName.DEAD_IOTA = "DeadIota";
  html$._KeyName.DEAD_VOICED_SOUND = "DeadVoicedSound";
  html$._KeyName.DEC_SEMIVOICED_SOUND = "DeadSemivoicedSound";
  html$._KeyName.UNIDENTIFIED = "Unidentified";
  const _stream$ = Symbol('_stream');
  const _keyDownList = Symbol('_keyDownList');
  const _capsLockOn = Symbol('_capsLockOn');
  const _determineKeyCodeForKeypress = Symbol('_determineKeyCodeForKeypress');
  const _findCharCodeKeyDown = Symbol('_findCharCodeKeyDown');
  const _firesKeyPressEvent = Symbol('_firesKeyPressEvent');
  const _normalizeKeyCodes = Symbol('_normalizeKeyCodes');
  html$._KeyboardEventHandler = class _KeyboardEventHandler extends html$.EventStreamProvider$(html$.KeyEvent) {
    forTarget(e, opts) {
      let useCapture = opts && 'useCapture' in opts ? opts.useCapture : false;
      let handler = new html$._KeyboardEventHandler.initializeAllEventListeners(this[_type], e);
      return handler[_stream$];
    }
    new(type) {
      this[_keyDownList] = JSArrayOfKeyEvent().of([]);
      this[_type] = type;
      this[_stream$] = new html$._CustomKeyEventStreamImpl('event');
      this[_target$] = null;
      super.new(html$._KeyboardEventHandler._EVENT_TYPE);
    }
    initializeAllEventListeners(type, target) {
      this[_keyDownList] = JSArrayOfKeyEvent().of([]);
      this[_type] = type;
      this[_target$] = target;
      this[_stream$] = null;
      super.new(html$._KeyboardEventHandler._EVENT_TYPE);
      html$.Element.keyDownEvent.forTarget(this[_target$], {useCapture: true}).listen(dart.bind(this, 'processKeyDown'));
      html$.Element.keyPressEvent.forTarget(this[_target$], {useCapture: true}).listen(dart.bind(this, 'processKeyPress'));
      html$.Element.keyUpEvent.forTarget(this[_target$], {useCapture: true}).listen(dart.bind(this, 'processKeyUp'));
      this[_stream$] = new html$._CustomKeyEventStreamImpl(this[_type]);
    }
    get [_capsLockOn]() {
      return this[_keyDownList][dartx.any](dart.fn(element => element.keyCode == html$.KeyCode.CAPS_LOCK, KeyEventTobool()));
    }
    [_determineKeyCodeForKeypress](event) {
      for (let prevEvent of this[_keyDownList]) {
        if (prevEvent[_shadowCharCode] == event[dartx.charCode]) {
          return prevEvent.keyCode;
        }
        if ((dart.test(event[dartx.shiftKey]) || dart.test(this[_capsLockOn])) && dart.notNull(event[dartx.charCode]) >= dart.notNull("A"[dartx.codeUnits][dartx.get](0)) && dart.notNull(event[dartx.charCode]) <= dart.notNull("Z"[dartx.codeUnits][dartx.get](0)) && dart.notNull(event[dartx.charCode]) + dart.notNull(html$._KeyboardEventHandler._ROMAN_ALPHABET_OFFSET) == prevEvent[_shadowCharCode]) {
          return prevEvent.keyCode;
        }
      }
      return html$.KeyCode.UNKNOWN;
    }
    [_findCharCodeKeyDown](event) {
      if (event[dartx.keyLocation] == 3) {
        switch (event[dartx.keyCode]) {
          case html$.KeyCode.NUM_ZERO:
          {
            return html$.KeyCode.ZERO;
          }
          case html$.KeyCode.NUM_ONE:
          {
            return html$.KeyCode.ONE;
          }
          case html$.KeyCode.NUM_TWO:
          {
            return html$.KeyCode.TWO;
          }
          case html$.KeyCode.NUM_THREE:
          {
            return html$.KeyCode.THREE;
          }
          case html$.KeyCode.NUM_FOUR:
          {
            return html$.KeyCode.FOUR;
          }
          case html$.KeyCode.NUM_FIVE:
          {
            return html$.KeyCode.FIVE;
          }
          case html$.KeyCode.NUM_SIX:
          {
            return html$.KeyCode.SIX;
          }
          case html$.KeyCode.NUM_SEVEN:
          {
            return html$.KeyCode.SEVEN;
          }
          case html$.KeyCode.NUM_EIGHT:
          {
            return html$.KeyCode.EIGHT;
          }
          case html$.KeyCode.NUM_NINE:
          {
            return html$.KeyCode.NINE;
          }
          case html$.KeyCode.NUM_MULTIPLY:
          {
            return 42;
          }
          case html$.KeyCode.NUM_PLUS:
          {
            return 43;
          }
          case html$.KeyCode.NUM_MINUS:
          {
            return 45;
          }
          case html$.KeyCode.NUM_PERIOD:
          {
            return 46;
          }
          case html$.KeyCode.NUM_DIVISION:
          {
            return 47;
          }
        }
      } else if (dart.notNull(event[dartx.keyCode]) >= 65 && dart.notNull(event[dartx.keyCode]) <= 90) {
        return dart.notNull(event[dartx.keyCode]) + dart.notNull(html$._KeyboardEventHandler._ROMAN_ALPHABET_OFFSET);
      }
      switch (event[dartx.keyCode]) {
        case html$.KeyCode.SEMICOLON:
        {
          return html$.KeyCode.FF_SEMICOLON;
        }
        case html$.KeyCode.EQUALS:
        {
          return html$.KeyCode.FF_EQUALS;
        }
        case html$.KeyCode.COMMA:
        {
          return 44;
        }
        case html$.KeyCode.DASH:
        {
          return 45;
        }
        case html$.KeyCode.PERIOD:
        {
          return 46;
        }
        case html$.KeyCode.SLASH:
        {
          return 47;
        }
        case html$.KeyCode.APOSTROPHE:
        {
          return 96;
        }
        case html$.KeyCode.OPEN_SQUARE_BRACKET:
        {
          return 91;
        }
        case html$.KeyCode.BACKSLASH:
        {
          return 92;
        }
        case html$.KeyCode.CLOSE_SQUARE_BRACKET:
        {
          return 93;
        }
        case html$.KeyCode.SINGLE_QUOTE:
        {
          return 39;
        }
      }
      return event[dartx.keyCode];
    }
    [_firesKeyPressEvent](event) {
      if (!dart.test(html_common.Device.isIE) && !dart.test(html_common.Device.isWebKit)) {
        return true;
      }
      if (dart.test(html_common.Device.userAgent[dartx.contains]('Mac')) && dart.test(event.altKey)) {
        return html$.KeyCode.isCharacterKey(event.keyCode);
      }
      if (dart.test(event.altKey) && !dart.test(event.ctrlKey)) {
        return false;
      }
      if (!dart.test(event.shiftKey) && (this[_keyDownList][dartx.last].keyCode == html$.KeyCode.CTRL || this[_keyDownList][dartx.last].keyCode == html$.KeyCode.ALT || dart.test(html_common.Device.userAgent[dartx.contains]('Mac')) && this[_keyDownList][dartx.last].keyCode == html$.KeyCode.META)) {
        return false;
      }
      if (dart.test(html_common.Device.isWebKit) && dart.test(event.ctrlKey) && dart.test(event.shiftKey) && (event.keyCode == html$.KeyCode.BACKSLASH || event.keyCode == html$.KeyCode.OPEN_SQUARE_BRACKET || event.keyCode == html$.KeyCode.CLOSE_SQUARE_BRACKET || event.keyCode == html$.KeyCode.TILDE || event.keyCode == html$.KeyCode.SEMICOLON || event.keyCode == html$.KeyCode.DASH || event.keyCode == html$.KeyCode.EQUALS || event.keyCode == html$.KeyCode.COMMA || event.keyCode == html$.KeyCode.PERIOD || event.keyCode == html$.KeyCode.SLASH || event.keyCode == html$.KeyCode.APOSTROPHE || event.keyCode == html$.KeyCode.SINGLE_QUOTE)) {
        return false;
      }
      switch (event.keyCode) {
        case html$.KeyCode.ENTER:
        {
          return !dart.test(html_common.Device.isIE);
        }
        case html$.KeyCode.ESC:
        {
          return !dart.test(html_common.Device.isWebKit);
        }
      }
      return html$.KeyCode.isCharacterKey(event.keyCode);
    }
    [_normalizeKeyCodes](event) {
      if (dart.test(html_common.Device.isFirefox)) {
        switch (event[dartx.keyCode]) {
          case html$.KeyCode.FF_EQUALS:
          {
            return html$.KeyCode.EQUALS;
          }
          case html$.KeyCode.FF_SEMICOLON:
          {
            return html$.KeyCode.SEMICOLON;
          }
          case html$.KeyCode.MAC_FF_META:
          {
            return html$.KeyCode.META;
          }
          case html$.KeyCode.WIN_KEY_FF_LINUX:
          {
            return html$.KeyCode.WIN_KEY;
          }
        }
      }
      return event[dartx.keyCode];
    }
    processKeyDown(e) {
      if (dart.notNull(this[_keyDownList][dartx.length]) > 0 && (this[_keyDownList][dartx.last].keyCode == html$.KeyCode.CTRL && !dart.test(e[dartx.ctrlKey]) || this[_keyDownList][dartx.last].keyCode == html$.KeyCode.ALT && !dart.test(e[dartx.altKey]) || dart.test(html_common.Device.userAgent[dartx.contains]('Mac')) && this[_keyDownList][dartx.last].keyCode == html$.KeyCode.META && !dart.test(e[dartx.metaKey]))) {
        this[_keyDownList][dartx.clear]();
      }
      let event = new html$.KeyEvent.wrap(e);
      event[_shadowKeyCode] = this[_normalizeKeyCodes](event);
      event[_shadowCharCode] = this[_findCharCodeKeyDown](event);
      if (dart.notNull(this[_keyDownList][dartx.length]) > 0 && event.keyCode != this[_keyDownList][dartx.last].keyCode && !dart.test(this[_firesKeyPressEvent](event))) {
        this.processKeyPress(e);
      }
      this[_keyDownList][dartx.add](event);
      this[_stream$].add(event);
    }
    processKeyPress(event) {
      let e = new html$.KeyEvent.wrap(event);
      if (dart.test(html_common.Device.isIE)) {
        if (e.keyCode == html$.KeyCode.ENTER || e.keyCode == html$.KeyCode.ESC) {
          e[_shadowCharCode] = 0;
        } else {
          e[_shadowCharCode] = e.keyCode;
        }
      } else if (dart.test(html_common.Device.isOpera)) {
        e[_shadowCharCode] = dart.test(html$.KeyCode.isCharacterKey(e.keyCode)) ? e.keyCode : 0;
      }
      e[_shadowKeyCode] = this[_determineKeyCodeForKeypress](e);
      if (e[_shadowKeyIdentifier] != null && dart.test(html$._KeyboardEventHandler._keyIdentifier[dartx.containsKey](e[_shadowKeyIdentifier]))) {
        e[_shadowKeyCode] = html$._KeyboardEventHandler._keyIdentifier[dartx.get](e[_shadowKeyIdentifier]);
      }
      e[_shadowAltKey] = this[_keyDownList][dartx.any](dart.fn(element => element.altKey, KeyEventTobool()));
      this[_stream$].add(e);
    }
    processKeyUp(event) {
      let e = new html$.KeyEvent.wrap(event);
      let toRemove = null;
      for (let key of this[_keyDownList]) {
        if (key.keyCode == e.keyCode) {
          toRemove = key;
        }
      }
      if (toRemove != null) {
        this[_keyDownList][dartx.removeWhere](dart.fn(element => dart.equals(element, toRemove), KeyEventTobool()));
      } else if (dart.notNull(this[_keyDownList][dartx.length]) > 0) {
        this[_keyDownList][dartx.removeLast]();
      }
      this[_stream$].add(e);
    }
  };
  dart.addSimpleTypeTests(html$._KeyboardEventHandler);
  dart.defineNamedConstructor(html$._KeyboardEventHandler, 'initializeAllEventListeners');
  dart.setSignature(html$._KeyboardEventHandler, {
    constructors: () => ({
      new: dart.definiteFunctionType(html$._KeyboardEventHandler, [core.String]),
      initializeAllEventListeners: dart.definiteFunctionType(html$._KeyboardEventHandler, [core.String, html$.EventTarget])
    }),
    methods: () => ({
      forTarget: dart.definiteFunctionType(html$.CustomStream$(html$.KeyEvent), [html$.EventTarget], {useCapture: core.bool}),
      [_determineKeyCodeForKeypress]: dart.definiteFunctionType(core.int, [html$.KeyboardEvent]),
      [_findCharCodeKeyDown]: dart.definiteFunctionType(core.int, [html$.KeyboardEvent]),
      [_firesKeyPressEvent]: dart.definiteFunctionType(core.bool, [html$.KeyEvent]),
      [_normalizeKeyCodes]: dart.definiteFunctionType(core.int, [html$.KeyboardEvent]),
      processKeyDown: dart.definiteFunctionType(dart.void, [html$.KeyboardEvent]),
      processKeyPress: dart.definiteFunctionType(dart.void, [html$.KeyboardEvent]),
      processKeyUp: dart.definiteFunctionType(dart.void, [html$.KeyboardEvent])
    })
  });
  html$._KeyboardEventHandler._EVENT_TYPE = 'KeyEvent';
  html$._KeyboardEventHandler._keyIdentifier = dart.const(dart.map({Up: html$.KeyCode.UP, Down: html$.KeyCode.DOWN, Left: html$.KeyCode.LEFT, Right: html$.KeyCode.RIGHT, Enter: html$.KeyCode.ENTER, F1: html$.KeyCode.F1, F2: html$.KeyCode.F2, F3: html$.KeyCode.F3, F4: html$.KeyCode.F4, F5: html$.KeyCode.F5, F6: html$.KeyCode.F6, F7: html$.KeyCode.F7, F8: html$.KeyCode.F8, F9: html$.KeyCode.F9, F10: html$.KeyCode.F10, F11: html$.KeyCode.F11, F12: html$.KeyCode.F12, 'U+007F': html$.KeyCode.DELETE, Home: html$.KeyCode.HOME, End: html$.KeyCode.END, PageUp: html$.KeyCode.PAGE_UP, PageDown: html$.KeyCode.PAGE_DOWN, Insert: html$.KeyCode.INSERT}));
  dart.defineLazy(html$._KeyboardEventHandler, {
    get _ROMAN_ALPHABET_OFFSET() {
      return dart.notNull("a"[dartx.codeUnits][dartx.get](0)) - dart.notNull("A"[dartx.codeUnits][dartx.get](0));
    }
  });
  html$.KeyboardEventStream = class KeyboardEventStream extends core.Object {
    static onKeyPress(target) {
      return new html$._KeyboardEventHandler('keypress').forTarget(target);
    }
    static onKeyUp(target) {
      return new html$._KeyboardEventHandler('keyup').forTarget(target);
    }
    static onKeyDown(target) {
      return new html$._KeyboardEventHandler('keydown').forTarget(target);
    }
  };
  dart.setSignature(html$.KeyboardEventStream, {
    statics: () => ({
      onKeyPress: dart.definiteFunctionType(html$.CustomStream$(html$.KeyEvent), [html$.EventTarget]),
      onKeyUp: dart.definiteFunctionType(html$.CustomStream$(html$.KeyEvent), [html$.EventTarget]),
      onKeyDown: dart.definiteFunctionType(html$.CustomStream$(html$.KeyEvent), [html$.EventTarget])
    }),
    names: ['onKeyPress', 'onKeyUp', 'onKeyDown']
  });
  const _validators = Symbol('_validators');
  html$.NodeValidatorBuilder = class NodeValidatorBuilder extends core.Object {
    new() {
      this[_validators] = JSArrayOfNodeValidator().of([]);
    }
    common() {
      this[_validators] = JSArrayOfNodeValidator().of([]);
      this.allowHtml5();
      this.allowTemplating();
    }
    allowNavigation(uriPolicy) {
      if (uriPolicy === void 0) uriPolicy = null;
      if (uriPolicy == null) {
        uriPolicy = html$.UriPolicy.new();
      }
      this.add(html$._SimpleNodeValidator.allowNavigation(uriPolicy));
    }
    allowImages(uriPolicy) {
      if (uriPolicy === void 0) uriPolicy = null;
      if (uriPolicy == null) {
        uriPolicy = html$.UriPolicy.new();
      }
      this.add(html$._SimpleNodeValidator.allowImages(uriPolicy));
    }
    allowTextElements() {
      this.add(html$._SimpleNodeValidator.allowTextElements());
    }
    allowInlineStyles(opts) {
      let tagName = opts && 'tagName' in opts ? opts.tagName : null;
      if (tagName == null) {
        tagName = '*';
      } else {
        tagName = tagName[dartx.toUpperCase]();
      }
      this.add(new html$._SimpleNodeValidator(null, {allowedAttributes: JSArrayOfString().of([dart.str`${tagName}::style`])}));
    }
    allowHtml5(opts) {
      let uriPolicy = opts && 'uriPolicy' in opts ? opts.uriPolicy : null;
      this.add(new html$._Html5NodeValidator({uriPolicy: uriPolicy}));
    }
    allowSvg() {
      this.add(new html$._SvgNodeValidator());
    }
    allowCustomElement(tagName, opts) {
      let uriPolicy = opts && 'uriPolicy' in opts ? opts.uriPolicy : null;
      let attributes = opts && 'attributes' in opts ? opts.attributes : null;
      let uriAttributes = opts && 'uriAttributes' in opts ? opts.uriAttributes : null;
      let tagNameUpper = tagName[dartx.toUpperCase]();
      let attrs = dart.nullSafe(attributes, _ => _[dartx.map](dart.fn(name => dart.str`${tagNameUpper}::${name[dartx.toLowerCase]()}`, StringToString$())));
      let uriAttrs = dart.nullSafe(uriAttributes, _ => _[dartx.map](dart.fn(name => dart.str`${tagNameUpper}::${name[dartx.toLowerCase]()}`, StringToString$())));
      if (uriPolicy == null) {
        uriPolicy = html$.UriPolicy.new();
      }
      this.add(new html$._CustomElementNodeValidator(uriPolicy, JSArrayOfString().of([tagNameUpper]), attrs, uriAttrs, false, true));
    }
    allowTagExtension(tagName, baseName, opts) {
      let uriPolicy = opts && 'uriPolicy' in opts ? opts.uriPolicy : null;
      let attributes = opts && 'attributes' in opts ? opts.attributes : null;
      let uriAttributes = opts && 'uriAttributes' in opts ? opts.uriAttributes : null;
      let baseNameUpper = baseName[dartx.toUpperCase]();
      let tagNameUpper = tagName[dartx.toUpperCase]();
      let attrs = dart.nullSafe(attributes, _ => _[dartx.map](dart.fn(name => dart.str`${baseNameUpper}::${name[dartx.toLowerCase]()}`, StringToString$())));
      let uriAttrs = dart.nullSafe(uriAttributes, _ => _[dartx.map](dart.fn(name => dart.str`${baseNameUpper}::${name[dartx.toLowerCase]()}`, StringToString$())));
      if (uriPolicy == null) {
        uriPolicy = html$.UriPolicy.new();
      }
      this.add(new html$._CustomElementNodeValidator(uriPolicy, JSArrayOfString().of([tagNameUpper, baseNameUpper]), attrs, uriAttrs, true, false));
    }
    allowElement(tagName, opts) {
      let uriPolicy = opts && 'uriPolicy' in opts ? opts.uriPolicy : null;
      let attributes = opts && 'attributes' in opts ? opts.attributes : null;
      let uriAttributes = opts && 'uriAttributes' in opts ? opts.uriAttributes : null;
      this.allowCustomElement(tagName, {uriPolicy: uriPolicy, attributes: attributes, uriAttributes: uriAttributes});
    }
    allowTemplating() {
      this.add(new html$._TemplatingNodeValidator());
    }
    add(validator) {
      this[_validators][dartx.add](validator);
    }
    allowsElement(element) {
      return this[_validators][dartx.any](dart.fn(v => v.allowsElement(element), NodeValidatorTobool()));
    }
    allowsAttribute(element, attributeName, value) {
      return this[_validators][dartx.any](dart.fn(v => v.allowsAttribute(element, attributeName, value), NodeValidatorTobool()));
    }
  };
  dart.defineNamedConstructor(html$.NodeValidatorBuilder, 'common');
  html$.NodeValidatorBuilder[dart.implements] = () => [html$.NodeValidator];
  dart.setSignature(html$.NodeValidatorBuilder, {
    constructors: () => ({
      new: dart.definiteFunctionType(html$.NodeValidatorBuilder, []),
      common: dart.definiteFunctionType(html$.NodeValidatorBuilder, [])
    }),
    methods: () => ({
      allowNavigation: dart.definiteFunctionType(dart.void, [], [html$.UriPolicy]),
      allowImages: dart.definiteFunctionType(dart.void, [], [html$.UriPolicy]),
      allowTextElements: dart.definiteFunctionType(dart.void, []),
      allowInlineStyles: dart.definiteFunctionType(dart.void, [], {tagName: core.String}),
      allowHtml5: dart.definiteFunctionType(dart.void, [], {uriPolicy: html$.UriPolicy}),
      allowSvg: dart.definiteFunctionType(dart.void, []),
      allowCustomElement: dart.definiteFunctionType(dart.void, [core.String], {uriPolicy: html$.UriPolicy, attributes: IterableOfString(), uriAttributes: IterableOfString()}),
      allowTagExtension: dart.definiteFunctionType(dart.void, [core.String, core.String], {uriPolicy: html$.UriPolicy, attributes: IterableOfString(), uriAttributes: IterableOfString()}),
      allowElement: dart.definiteFunctionType(dart.void, [core.String], {uriPolicy: html$.UriPolicy, attributes: IterableOfString(), uriAttributes: IterableOfString()}),
      allowTemplating: dart.definiteFunctionType(dart.void, []),
      add: dart.definiteFunctionType(dart.void, [html$.NodeValidator]),
      allowsElement: dart.definiteFunctionType(core.bool, [html$.Element]),
      allowsAttribute: dart.definiteFunctionType(core.bool, [html$.Element, core.String, core.String])
    })
  });
  let const$49;
  let const$50;
  let const$51;
  let const$52;
  let const$53;
  let const$54;
  let const$55;
  let const$56;
  let const$57;
  let const$58;
  html$._SimpleNodeValidator = class _SimpleNodeValidator extends core.Object {
    static allowNavigation(uriPolicy) {
      return new html$._SimpleNodeValidator(uriPolicy, {allowedElements: const$49 || (const$49 = dart.constList(['A', 'FORM'], core.String)), allowedAttributes: const$50 || (const$50 = dart.constList(['A::accesskey', 'A::coords', 'A::hreflang', 'A::name', 'A::shape', 'A::tabindex', 'A::target', 'A::type', 'FORM::accept', 'FORM::autocomplete', 'FORM::enctype', 'FORM::method', 'FORM::name', 'FORM::novalidate', 'FORM::target'], core.String)), allowedUriAttributes: const$51 || (const$51 = dart.constList(['A::href', 'FORM::action'], core.String))});
    }
    static allowImages(uriPolicy) {
      return new html$._SimpleNodeValidator(uriPolicy, {allowedElements: const$52 || (const$52 = dart.constList(['IMG'], core.String)), allowedAttributes: const$53 || (const$53 = dart.constList(['IMG::align', 'IMG::alt', 'IMG::border', 'IMG::height', 'IMG::hspace', 'IMG::ismap', 'IMG::name', 'IMG::usemap', 'IMG::vspace', 'IMG::width'], core.String)), allowedUriAttributes: const$54 || (const$54 = dart.constList(['IMG::src'], core.String))});
    }
    static allowTextElements() {
      return new html$._SimpleNodeValidator(null, {allowedElements: const$55 || (const$55 = dart.constList(['B', 'BLOCKQUOTE', 'BR', 'EM', 'H1', 'H2', 'H3', 'H4', 'H5', 'H6', 'HR', 'I', 'LI', 'OL', 'P', 'SPAN', 'UL'], core.String))});
    }
    new(uriPolicy, opts) {
      let allowedElements = opts && 'allowedElements' in opts ? opts.allowedElements : null;
      let allowedAttributes = opts && 'allowedAttributes' in opts ? opts.allowedAttributes : null;
      let allowedUriAttributes = opts && 'allowedUriAttributes' in opts ? opts.allowedUriAttributes : null;
      this.allowedElements = SetOfString().new();
      this.allowedAttributes = SetOfString().new();
      this.allowedUriAttributes = SetOfString().new();
      this.uriPolicy = uriPolicy;
      this.allowedElements.addAll((allowedElements != null ? allowedElements : const$56 || (const$56 = dart.constList([], core.String))));
      allowedAttributes = allowedAttributes != null ? allowedAttributes : const$57 || (const$57 = dart.constList([], core.String));
      allowedUriAttributes = allowedUriAttributes != null ? allowedUriAttributes : const$58 || (const$58 = dart.constList([], core.String));
      let legalAttributes = allowedAttributes[dartx.where](dart.fn(x => !dart.test(html$._Html5NodeValidator._uriAttributes[dartx.contains](x)), StringTobool()));
      let extraUriAttributes = allowedAttributes[dartx.where](dart.fn(x => html$._Html5NodeValidator._uriAttributes[dartx.contains](x), StringTobool()));
      this.allowedAttributes.addAll(legalAttributes);
      this.allowedUriAttributes.addAll(allowedUriAttributes);
      this.allowedUriAttributes.addAll(extraUriAttributes);
    }
    allowsElement(element) {
      return this.allowedElements.contains(html$.Element._safeTagName(element));
    }
    allowsAttribute(element, attributeName, value) {
      let tagName = html$.Element._safeTagName(element);
      if (dart.test(this.allowedUriAttributes.contains(dart.str`${tagName}::${attributeName}`))) {
        return this.uriPolicy.allowsUri(value);
      } else if (dart.test(this.allowedUriAttributes.contains(dart.str`*::${attributeName}`))) {
        return this.uriPolicy.allowsUri(value);
      } else if (dart.test(this.allowedAttributes.contains(dart.str`${tagName}::${attributeName}`))) {
        return true;
      } else if (dart.test(this.allowedAttributes.contains(dart.str`*::${attributeName}`))) {
        return true;
      } else if (dart.test(this.allowedAttributes.contains(dart.str`${tagName}::*`))) {
        return true;
      } else if (dart.test(this.allowedAttributes.contains('*::*'))) {
        return true;
      }
      return false;
    }
  };
  html$._SimpleNodeValidator[dart.implements] = () => [html$.NodeValidator];
  dart.setSignature(html$._SimpleNodeValidator, {
    constructors: () => ({
      allowNavigation: dart.definiteFunctionType(html$._SimpleNodeValidator, [html$.UriPolicy]),
      allowImages: dart.definiteFunctionType(html$._SimpleNodeValidator, [html$.UriPolicy]),
      allowTextElements: dart.definiteFunctionType(html$._SimpleNodeValidator, []),
      new: dart.definiteFunctionType(html$._SimpleNodeValidator, [html$.UriPolicy], {allowedElements: IterableOfString(), allowedAttributes: IterableOfString(), allowedUriAttributes: IterableOfString()})
    }),
    methods: () => ({
      allowsElement: dart.definiteFunctionType(core.bool, [html$.Element]),
      allowsAttribute: dart.definiteFunctionType(core.bool, [html$.Element, core.String, core.String])
    })
  });
  html$._CustomElementNodeValidator = class _CustomElementNodeValidator extends html$._SimpleNodeValidator {
    new(uriPolicy, allowedElements, allowedAttributes, allowedUriAttributes, allowTypeExtension, allowCustomTag) {
      this.allowTypeExtension = allowTypeExtension == true;
      this.allowCustomTag = allowCustomTag == true;
      super.new(uriPolicy, {allowedElements: allowedElements, allowedAttributes: allowedAttributes, allowedUriAttributes: allowedUriAttributes});
    }
    allowsElement(element) {
      if (dart.test(this.allowTypeExtension)) {
        let isAttr = element[dartx.attributes][dartx.get]('is');
        if (isAttr != null) {
          return dart.test(this.allowedElements.contains(isAttr[dartx.toUpperCase]())) && dart.test(this.allowedElements.contains(html$.Element._safeTagName(element)));
        }
      }
      return dart.test(this.allowCustomTag) && dart.test(this.allowedElements.contains(html$.Element._safeTagName(element)));
    }
    allowsAttribute(element, attributeName, value) {
      if (dart.test(this.allowsElement(element))) {
        if (dart.test(this.allowTypeExtension) && attributeName == 'is' && dart.test(this.allowedElements.contains(value[dartx.toUpperCase]()))) {
          return true;
        }
        return super.allowsAttribute(element, attributeName, value);
      }
      return false;
    }
  };
  dart.setSignature(html$._CustomElementNodeValidator, {
    constructors: () => ({new: dart.definiteFunctionType(html$._CustomElementNodeValidator, [html$.UriPolicy, core.Iterable$(core.String), core.Iterable$(core.String), core.Iterable$(core.String), core.bool, core.bool])})
  });
  const _templateAttrs = Symbol('_templateAttrs');
  html$._TemplatingNodeValidator = class _TemplatingNodeValidator extends html$._SimpleNodeValidator {
    new() {
      this[_templateAttrs] = SetOfString().from(html$._TemplatingNodeValidator._TEMPLATE_ATTRS);
      super.new(null, {allowedElements: JSArrayOfString().of(['TEMPLATE']), allowedAttributes: html$._TemplatingNodeValidator._TEMPLATE_ATTRS[dartx.map](core.String)(dart.fn(attr => dart.str`TEMPLATE::${attr}`, StringToString$()))});
    }
    allowsAttribute(element, attributeName, value) {
      if (dart.test(super.allowsAttribute(element, attributeName, value))) {
        return true;
      }
      if (attributeName == 'template' && value == "") {
        return true;
      }
      if (element[dartx.attributes][dartx.get]('template') == "") {
        return this[_templateAttrs].contains(attributeName);
      }
      return false;
    }
  };
  dart.setSignature(html$._TemplatingNodeValidator, {
    constructors: () => ({new: dart.definiteFunctionType(html$._TemplatingNodeValidator, [])})
  });
  html$._TemplatingNodeValidator._TEMPLATE_ATTRS = dart.constList(['bind', 'if', 'ref', 'repeat', 'syntax'], core.String);
  html$._SvgNodeValidator = class _SvgNodeValidator extends core.Object {
    allowsElement(element) {
      if (svg$.ScriptElement.is(element)) {
        return false;
      }
      if (svg$.SvgElement.is(element) && html$.Element._safeTagName(element) == 'foreignObject') {
        return false;
      }
      if (svg$.SvgElement.is(element)) {
        return true;
      }
      return false;
    }
    allowsAttribute(element, attributeName, value) {
      if (attributeName == 'is' || dart.test(attributeName[dartx.startsWith]('on'))) {
        return false;
      }
      return this.allowsElement(element);
    }
  };
  html$._SvgNodeValidator[dart.implements] = () => [html$.NodeValidator];
  dart.setSignature(html$._SvgNodeValidator, {
    methods: () => ({
      allowsElement: dart.definiteFunctionType(core.bool, [html$.Element]),
      allowsAttribute: dart.definiteFunctionType(core.bool, [html$.Element, core.String, core.String])
    })
  });
  html$.ReadyState = class ReadyState extends core.Object {};
  html$.ReadyState.LOADING = "loading";
  html$.ReadyState.INTERACTIVE = "interactive";
  html$.ReadyState.COMPLETE = "complete";
  const _list$ = Symbol('_list');
  html$._WrappedList$ = dart.generic(E => {
    let IterableOfE = () => (IterableOfE = dart.constFn(core.Iterable$(E)))();
    class _WrappedList extends collection.ListBase$(E) {
      new(list) {
        this[_list$] = list;
      }
      get iterator() {
        return new (_WrappedIteratorOfNode())(this[_list$][dartx.iterator]);
      }
      get length() {
        return this[_list$][dartx.length];
      }
      add(element) {
        E._check(element);
        this[_list$][dartx.add](element);
      }
      remove(element) {
        return this[_list$][dartx.remove](element);
      }
      clear() {
        this[_list$][dartx.clear]();
      }
      get(index) {
        return html$._downcast(html$.Node, E)(this[_list$][dartx.get](index));
      }
      set(index, value) {
        E._check(value);
        this[_list$][dartx.set](index, value);
        return value;
      }
      set length(newLength) {
        this[_list$][dartx.length] = newLength;
      }
      sort(compare) {
        if (compare === void 0) compare = null;
        this[_list$][dartx.sort](dart.fn((a, b) => compare(html$._downcast(html$.Node, E)(a), html$._downcast(html$.Node, E)(b)), NodeAndNodeToint()));
      }
      indexOf(element, start) {
        if (start === void 0) start = 0;
        return this[_list$][dartx.indexOf](html$.Node._check(element), start);
      }
      lastIndexOf(element, start) {
        if (start === void 0) start = null;
        return this[_list$][dartx.lastIndexOf](html$.Node._check(element), start);
      }
      insert(index, element) {
        E._check(element);
        return this[_list$][dartx.insert](index, element);
      }
      removeAt(index) {
        return html$._downcast(html$.Node, E)(this[_list$][dartx.removeAt](index));
      }
      setRange(start, end, iterable, skipCount) {
        IterableOfE()._check(iterable);
        if (skipCount === void 0) skipCount = 0;
        this[_list$][dartx.setRange](start, end, iterable, skipCount);
      }
      removeRange(start, end) {
        this[_list$][dartx.removeRange](start, end);
      }
      replaceRange(start, end, iterable) {
        IterableOfE()._check(iterable);
        this[_list$][dartx.replaceRange](start, end, iterable);
      }
      fillRange(start, end, fillValue) {
        if (fillValue === void 0) fillValue = null;
        E._check(fillValue);
        this[_list$][dartx.fillRange](start, end, fillValue);
      }
      get rawList() {
        return this[_list$];
      }
    }
    _WrappedList[dart.implements] = () => [html_common.NodeListWrapper];
    dart.setSignature(_WrappedList, {
      constructors: () => ({new: dart.definiteFunctionType(html$._WrappedList$(E), [core.List$(html$.Node)])}),
      methods: () => ({
        add: dart.definiteFunctionType(dart.void, [E]),
        get: dart.definiteFunctionType(E, [core.int]),
        set: dart.definiteFunctionType(dart.void, [core.int, E]),
        sort: dart.definiteFunctionType(dart.void, [], [dart.functionType(core.int, [E, E])]),
        insert: dart.definiteFunctionType(dart.void, [core.int, E]),
        removeAt: dart.definiteFunctionType(E, [core.int]),
        setRange: dart.definiteFunctionType(dart.void, [core.int, core.int, core.Iterable$(E)], [core.int]),
        replaceRange: dart.definiteFunctionType(dart.void, [core.int, core.int, core.Iterable$(E)]),
        fillRange: dart.definiteFunctionType(dart.void, [core.int, core.int], [E])
      })
    });
    dart.defineExtensionMembers(_WrappedList, [
      'add',
      'remove',
      'clear',
      'get',
      'set',
      'sort',
      'indexOf',
      'lastIndexOf',
      'insert',
      'removeAt',
      'setRange',
      'removeRange',
      'replaceRange',
      'fillRange',
      'iterator',
      'length',
      'length'
    ]);
    return _WrappedList;
  });
  html$._WrappedList = _WrappedList();
  const _iterator$1 = Symbol('_iterator');
  html$._WrappedIterator$ = dart.generic(E => {
    let IteratorOfE = () => (IteratorOfE = dart.constFn(core.Iterator$(E)))();
    class _WrappedIterator extends core.Object {
      new(iterator) {
        this[_iterator$1] = iterator;
      }
      moveNext() {
        return this[_iterator$1].moveNext();
      }
      get current() {
        return html$._downcast(html$.Node, E)(this[_iterator$1].current);
      }
    }
    dart.addTypeTests(_WrappedIterator);
    _WrappedIterator[dart.implements] = () => [IteratorOfE()];
    dart.setSignature(_WrappedIterator, {
      constructors: () => ({new: dart.definiteFunctionType(html$._WrappedIterator$(E), [core.Iterator$(html$.Node)])}),
      methods: () => ({moveNext: dart.definiteFunctionType(core.bool, [])})
    });
    return _WrappedIterator;
  });
  html$._WrappedIterator = _WrappedIterator();
  html$._downcast = function(From, To) {
    return x => {
      return To._check(x);
    };
  };
  dart.fn(html$._downcast, FromToTo());
  html$._HttpRequestUtils = class _HttpRequestUtils extends core.Object {
    static get(url, onComplete, withCredentials) {
      let request = html$.HttpRequest.new();
      request[dartx.open]('GET', url, {async: true});
      request[dartx.withCredentials] = withCredentials;
      request[dartx.onReadyStateChange].listen(dart.fn(e => {
        if (request[dartx.readyState] == html$.HttpRequest.DONE) {
          onComplete(request);
        }
      }, ProgressEventTovoid$()));
      request[dartx.send]();
      return request;
    }
  };
  dart.setSignature(html$._HttpRequestUtils, {
    statics: () => ({get: dart.definiteFunctionType(html$.HttpRequest, [core.String, dart.functionType(dart.dynamic, [html$.HttpRequest]), core.bool])}),
    names: ['get']
  });
  const _array = Symbol('_array');
  const _current$4 = Symbol('_current');
  html$.FixedSizeListIterator$ = dart.generic(T => {
    let IteratorOfT = () => (IteratorOfT = dart.constFn(core.Iterator$(T)))();
    class FixedSizeListIterator extends core.Object {
      new(array) {
        this[_array] = array;
        this[_position$0] = -1;
        this[_length$2] = array[dartx.length];
        this[_current$4] = null;
      }
      moveNext() {
        let nextPosition = dart.notNull(this[_position$0]) + 1;
        if (nextPosition < dart.notNull(this[_length$2])) {
          this[_current$4] = this[_array][dartx.get](nextPosition);
          this[_position$0] = nextPosition;
          return true;
        }
        this[_current$4] = null;
        this[_position$0] = this[_length$2];
        return false;
      }
      get current() {
        return this[_current$4];
      }
    }
    dart.addTypeTests(FixedSizeListIterator);
    FixedSizeListIterator[dart.implements] = () => [IteratorOfT()];
    dart.setSignature(FixedSizeListIterator, {
      constructors: () => ({new: dart.definiteFunctionType(html$.FixedSizeListIterator$(T), [core.List$(T)])}),
      methods: () => ({moveNext: dart.definiteFunctionType(core.bool, [])})
    });
    return FixedSizeListIterator;
  });
  html$.FixedSizeListIterator = FixedSizeListIterator();
  html$._VariableSizeListIterator$ = dart.generic(T => {
    let IteratorOfT = () => (IteratorOfT = dart.constFn(core.Iterator$(T)))();
    class _VariableSizeListIterator extends core.Object {
      new(array) {
        this[_array] = array;
        this[_position$0] = -1;
        this[_current$4] = null;
      }
      moveNext() {
        let nextPosition = dart.notNull(this[_position$0]) + 1;
        if (nextPosition < dart.notNull(this[_array][dartx.length])) {
          this[_current$4] = this[_array][dartx.get](nextPosition);
          this[_position$0] = nextPosition;
          return true;
        }
        this[_current$4] = null;
        this[_position$0] = this[_array][dartx.length];
        return false;
      }
      get current() {
        return this[_current$4];
      }
    }
    dart.addTypeTests(_VariableSizeListIterator);
    _VariableSizeListIterator[dart.implements] = () => [IteratorOfT()];
    dart.setSignature(_VariableSizeListIterator, {
      constructors: () => ({new: dart.definiteFunctionType(html$._VariableSizeListIterator$(T), [core.List$(T)])}),
      methods: () => ({moveNext: dart.definiteFunctionType(core.bool, [])})
    });
    return _VariableSizeListIterator;
  });
  html$._VariableSizeListIterator = _VariableSizeListIterator();
  html$._convertNativeToDart_Window = function(win) {
    if (win == null) return null;
    return html$._DOMWindowCrossFrame._createSafe(win);
  };
  dart.fn(html$._convertNativeToDart_Window, dynamicToWindowBase());
  html$._convertNativeToDart_EventTarget = function(e) {
    if (e == null) {
      return null;
    }
    if ("postMessage" in e) {
      let window = html$._DOMWindowCrossFrame._createSafe(e);
      if (html$.EventTarget.is(window)) {
        return window;
      }
      return null;
    } else
      return html$.EventTarget._check(e);
  };
  dart.fn(html$._convertNativeToDart_EventTarget, dynamicToEventTarget());
  const _window = Symbol('_window');
  html$._convertDartToNative_EventTarget = function(e) {
    if (html$._DOMWindowCrossFrame.is(e)) {
      return html$.EventTarget._check(e[_window]);
    } else {
      return html$.EventTarget._check(e);
    }
  };
  dart.fn(html$._convertDartToNative_EventTarget, dynamicToEventTarget());
  html$._convertNativeToDart_XHR_Response = function(o) {
    if (html$.Document.is(o)) {
      return o;
    }
    return html_common.convertNativeToDart_SerializedScriptValue(o);
  };
  dart.fn(html$._convertNativeToDart_XHR_Response, dynamicTodynamic$());
  html$._callConstructor = function(constructor, interceptor) {
    return dart.fn(receiver => {
      _js_helper.setNativeSubclassDispatchRecord(receiver, interceptor);
      receiver.constructor = receiver.__proto__.constructor;
      return constructor(receiver);
    }, dynamicTodynamic$());
  };
  dart.fn(html$._callConstructor, dynamicAnddynamicTodynamic$());
  html$._callAttached = function(receiver) {
    return dart.dsend(receiver, 'attached');
  };
  dart.fn(html$._callAttached, dynamicTodynamic$());
  html$._callDetached = function(receiver) {
    return dart.dsend(receiver, 'detached');
  };
  dart.fn(html$._callDetached, dynamicTodynamic$());
  html$._callAttributeChanged = function(receiver, name, oldValue, newValue) {
    return dart.dsend(receiver, 'attributeChanged', name, oldValue, newValue);
  };
  dart.fn(html$._callAttributeChanged, dynamicAnddynamicAnddynamic__Todynamic());
  html$._makeCallbackMethod = function(callback) {
    return (function(invokeCallback) {
      return function() {
        return invokeCallback(this);
      };
    })(_js_helper.convertDartClosureToJS(dart.dynamic)(callback, 1));
  };
  dart.fn(html$._makeCallbackMethod, dynamicTodynamic$());
  html$._makeCallbackMethod3 = function(callback) {
    return (function(invokeCallback) {
      return function(arg1, arg2, arg3) {
        return invokeCallback(this, arg1, arg2, arg3);
      };
    })(_js_helper.convertDartClosureToJS(dart.dynamic)(callback, 4));
  };
  dart.fn(html$._makeCallbackMethod3, dynamicTodynamic$());
  html$._registerCustomElement = function(context, document, tag, type, extendsTagName) {
    let interceptorClass = _interceptors.findInterceptorConstructorForType(type);
    if (interceptorClass == null) {
      dart.throw(new core.ArgumentError(type));
    }
    let interceptor = interceptorClass.prototype;
    let constructor = _interceptors.findConstructorForNativeSubclassType(type, 'created');
    if (constructor == null) {
      dart.throw(new core.ArgumentError(dart.str`${type} has no constructor called 'created'`));
    }
    _interceptors.getNativeInterceptor(html$.Element.tag('article'));
    let baseClassName = core.String._check(_js_helper.findDispatchTagForInterceptorClass(interceptorClass));
    if (baseClassName == null) {
      dart.throw(new core.ArgumentError(type));
    }
    if (extendsTagName == null) {
      if (baseClassName != 'HTMLElement') {
        dart.throw(new core.UnsupportedError('Class must provide extendsTag if base ' + 'native class is not HtmlElement'));
      }
    } else {
      if (!(document.createElement(extendsTagName) instanceof window[baseClassName])) {
        dart.throw(new core.UnsupportedError('extendsTag does not match base native class'));
      }
    }
    let baseConstructor = context[baseClassName];
    let properties = {};
    properties.createdCallback = {value: html$._makeCallbackMethod(html$._callConstructor(constructor, interceptor))};
    properties.attachedCallback = {value: html$._makeCallbackMethod(html$._callAttached)};
    properties.detachedCallback = {value: html$._makeCallbackMethod(html$._callDetached)};
    properties.attributeChangedCallback = {value: html$._makeCallbackMethod3(html$._callAttributeChanged)};
    let baseProto = baseConstructor.prototype;
    let proto = Object.create(baseProto, properties);
    _js_helper.setNativeSubclassDispatchRecord(proto, interceptor);
    let options = {prototype: proto};
    if (extendsTagName != null) {
      options.extends = extendsTagName;
    }
    document.registerElement(tag, options);
  };
  dart.fn(html$._registerCustomElement, dynamicAnddynamicAndString__Tovoid());
  html$._initializeCustomElement = function(e) {
  };
  dart.fn(html$._initializeCustomElement, ElementTovoid());
  const _interceptor = Symbol('_interceptor');
  const _constructor = Symbol('_constructor');
  const _nativeType = Symbol('_nativeType');
  html$._JSElementUpgrader = class _JSElementUpgrader extends core.Object {
    new(document, type, extendsTag) {
      this[_interceptor] = null;
      this[_constructor] = null;
      this[_nativeType] = null;
      let interceptorClass = _interceptors.findInterceptorConstructorForType(type);
      if (interceptorClass == null) {
        dart.throw(new core.ArgumentError(type));
      }
      this[_constructor] = _interceptors.findConstructorForNativeSubclassType(type, 'created');
      if (this[_constructor] == null) {
        dart.throw(new core.ArgumentError(dart.str`${type} has no constructor called 'created'`));
      }
      _interceptors.getNativeInterceptor(html$.Element.tag('article'));
      let baseClassName = _js_helper.findDispatchTagForInterceptorClass(interceptorClass);
      if (baseClassName == null) {
        dart.throw(new core.ArgumentError(type));
      }
      if (extendsTag == null) {
        if (!dart.equals(baseClassName, 'HTMLElement')) {
          dart.throw(new core.UnsupportedError('Class must provide extendsTag if base ' + 'native class is not HtmlElement'));
        }
        this[_nativeType] = dart.wrapType(html$.HtmlElement);
      } else {
        let element = document[dartx.createElement](extendsTag);
        if (!(element instanceof window[baseClassName])) {
          dart.throw(new core.UnsupportedError('extendsTag does not match base native class'));
        }
        this[_nativeType] = dart.runtimeType(element);
      }
      this[_interceptor] = interceptorClass.prototype;
    }
    upgrade(element) {
      if (!dart.equals(dart.runtimeType(element), this[_nativeType])) {
        dart.throw(new core.ArgumentError(dart.str`element is not subclass of ${this[_nativeType]}`));
      }
      _js_helper.setNativeSubclassDispatchRecord(element, this[_interceptor]);
      this[_constructor](element);
      return element;
    }
  };
  html$._JSElementUpgrader[dart.implements] = () => [html$.ElementUpgrader];
  dart.setSignature(html$._JSElementUpgrader, {
    constructors: () => ({new: dart.definiteFunctionType(html$._JSElementUpgrader, [html$.Document, core.Type, core.String])}),
    methods: () => ({upgrade: dart.definiteFunctionType(html$.Element, [html$.Element])})
  });
  html$._DOMWindowCrossFrame = class _DOMWindowCrossFrame extends core.Object {
    get history() {
      return html$._HistoryCrossFrame._createSafe(this[_window].history);
    }
    get location() {
      return html$._LocationCrossFrame._createSafe(this[_window].location);
    }
    get closed() {
      return this[_window].closed;
    }
    get opener() {
      return html$._DOMWindowCrossFrame._createSafe(this[_window].opener);
    }
    get parent() {
      return html$._DOMWindowCrossFrame._createSafe(this[_window].parent);
    }
    get top() {
      return html$._DOMWindowCrossFrame._createSafe(this[_window].top);
    }
    close() {
      return this[_window].close();
    }
    postMessage(message, targetOrigin, messagePorts) {
      if (messagePorts === void 0) messagePorts = null;
      if (messagePorts == null) {
        this[_window].postMessage(html_common.convertDartToNative_SerializedScriptValue(message), targetOrigin);
      } else {
        this[_window].postMessage(html_common.convertDartToNative_SerializedScriptValue(message), targetOrigin, messagePorts);
      }
    }
    new(window) {
      this[_window] = window;
    }
    static _createSafe(w) {
      if (core.identical(w, html$.window)) {
        return html$.WindowBase._check(w);
      } else {
        return new html$._DOMWindowCrossFrame(w);
      }
    }
    get on() {
      return dart.throw(new core.UnsupportedError('You can only attach EventListeners to your own window.'));
    }
    [_addEventListener](type, listener, useCapture) {
      if (useCapture === void 0) useCapture = null;
      return dart.throw(new core.UnsupportedError('You can only attach EventListeners to your own window.'));
    }
    addEventListener(type, listener, useCapture) {
      if (useCapture === void 0) useCapture = null;
      return dart.throw(new core.UnsupportedError('You can only attach EventListeners to your own window.'));
    }
    dispatchEvent(event) {
      return dart.throw(new core.UnsupportedError('You can only attach EventListeners to your own window.'));
    }
    [_removeEventListener](type, listener, useCapture) {
      if (useCapture === void 0) useCapture = null;
      return dart.throw(new core.UnsupportedError('You can only attach EventListeners to your own window.'));
    }
    removeEventListener(type, listener, useCapture) {
      if (useCapture === void 0) useCapture = null;
      return dart.throw(new core.UnsupportedError('You can only attach EventListeners to your own window.'));
    }
  };
  html$._DOMWindowCrossFrame[dart.implements] = () => [html$.WindowBase];
  dart.setSignature(html$._DOMWindowCrossFrame, {
    constructors: () => ({new: dart.definiteFunctionType(html$._DOMWindowCrossFrame, [dart.dynamic])}),
    methods: () => ({
      close: dart.definiteFunctionType(dart.void, []),
      postMessage: dart.definiteFunctionType(dart.void, [dart.dynamic, core.String], [core.List]),
      [_addEventListener]: dart.definiteFunctionType(dart.void, [core.String, html$.EventListener], [core.bool]),
      addEventListener: dart.definiteFunctionType(dart.void, [core.String, html$.EventListener], [core.bool]),
      dispatchEvent: dart.definiteFunctionType(core.bool, [html$.Event]),
      [_removeEventListener]: dart.definiteFunctionType(dart.void, [core.String, html$.EventListener], [core.bool]),
      removeEventListener: dart.definiteFunctionType(dart.void, [core.String, html$.EventListener], [core.bool])
    }),
    statics: () => ({_createSafe: dart.definiteFunctionType(html$.WindowBase, [dart.dynamic])}),
    names: ['_createSafe']
  });
  dart.defineExtensionMembers(html$._DOMWindowCrossFrame, [
    'close',
    'postMessage',
    'history',
    'location',
    'closed',
    'opener',
    'parent',
    'top'
  ]);
  html$._LocationCrossFrame = class _LocationCrossFrame extends core.Object {
    set href(val) {
      return html$._LocationCrossFrame._setHref(this[_location], val);
    }
    static _setHref(location, val) {
      location.href = val;
    }
    new(location) {
      this[_location] = location;
    }
    static _createSafe(location) {
      if (core.identical(location, html$.window[dartx.location])) {
        return html$.LocationBase._check(location);
      } else {
        return new html$._LocationCrossFrame(location);
      }
    }
  };
  html$._LocationCrossFrame[dart.implements] = () => [html$.LocationBase];
  dart.setSignature(html$._LocationCrossFrame, {
    constructors: () => ({new: dart.definiteFunctionType(html$._LocationCrossFrame, [dart.dynamic])}),
    statics: () => ({
      _setHref: dart.definiteFunctionType(dart.void, [dart.dynamic, dart.dynamic]),
      _createSafe: dart.definiteFunctionType(html$.LocationBase, [dart.dynamic])
    }),
    names: ['_setHref', '_createSafe']
  });
  dart.defineExtensionMembers(html$._LocationCrossFrame, ['href']);
  const _history = Symbol('_history');
  html$._HistoryCrossFrame = class _HistoryCrossFrame extends core.Object {
    back() {
      return this[_history].back();
    }
    forward() {
      return this[_history].forward();
    }
    go(distance) {
      return this[_history].go(distance);
    }
    new(history) {
      this[_history] = history;
    }
    static _createSafe(h) {
      if (core.identical(h, html$.window[dartx.history])) {
        return html$.HistoryBase._check(h);
      } else {
        return new html$._HistoryCrossFrame(h);
      }
    }
  };
  html$._HistoryCrossFrame[dart.implements] = () => [html$.HistoryBase];
  dart.setSignature(html$._HistoryCrossFrame, {
    constructors: () => ({new: dart.definiteFunctionType(html$._HistoryCrossFrame, [dart.dynamic])}),
    methods: () => ({
      back: dart.definiteFunctionType(dart.void, []),
      forward: dart.definiteFunctionType(dart.void, []),
      go: dart.definiteFunctionType(dart.void, [core.int])
    }),
    statics: () => ({_createSafe: dart.definiteFunctionType(html$.HistoryBase, [dart.dynamic])}),
    names: ['_createSafe']
  });
  dart.defineExtensionMembers(html$._HistoryCrossFrame, ['back', 'forward', 'go']);
  html$.Platform = class Platform extends core.Object {};
  html$.Platform.supportsSimd = false;
  dart.defineLazy(html$.Platform, {
    get supportsTypedData() {
      return !!window.ArrayBuffer;
    }
  });
  html$._wrapZoneCallback$ = dart.generic((A, R) => {
    const _wrapZoneCallback = dart.typedef('_wrapZoneCallback', () => dart.functionType(R, [A]));
    return _wrapZoneCallback;
  });
  html$._wrapZoneCallback = _wrapZoneCallback();
  html$._wrapZoneBinaryCallback$ = dart.generic((A, B, R) => {
    const _wrapZoneBinaryCallback = dart.typedef('_wrapZoneBinaryCallback', () => dart.functionType(R, [A, B]));
    return _wrapZoneBinaryCallback;
  });
  html$._wrapZoneBinaryCallback = _wrapZoneBinaryCallback();
  html$._wrapZone = function(A, R) {
    return callback => {
      if (dart.equals(async.Zone.current, async.Zone.ROOT)) return callback;
      if (callback == null) return null;
      return async.Zone.current.bindUnaryCallback(R, A)(callback, {runGuarded: true});
    };
  };
  dart.fn(html$._wrapZone, _wrapZoneCallbackOfA$RTo_wrapZoneCallbackOfA$R());
  html$._wrapBinaryZone = function(A, B, R) {
    return callback => {
      if (dart.equals(async.Zone.current, async.Zone.ROOT)) return callback;
      if (callback == null) return null;
      return async.Zone.current.bindBinaryCallback(R, A, B)(callback, {runGuarded: true});
    };
  };
  dart.fn(html$._wrapBinaryZone, _wrapZoneBinaryCallbackOfA$B$RTo_wrapZoneBinaryCallbackOfA$B$R());
  html$.query = function(relativeSelectors) {
    return html$.document[dartx.query](relativeSelectors);
  };
  dart.fn(html$.query, StringToElement());
  html$.queryAll = function(relativeSelectors) {
    return html$.document[dartx.queryAll](html$.Element)(relativeSelectors);
  };
  dart.fn(html$.queryAll, StringToElementListOfElement());
  html$.querySelector = function(selectors) {
    return html$.document[dartx.querySelector](selectors);
  };
  dart.fn(html$.querySelector, StringToElement());
  html$.querySelectorAll = function(selectors) {
    return html$.document[dartx.querySelectorAll](html$.Element)(selectors);
  };
  dart.fn(html$.querySelectorAll, StringToElementListOfElement());
  html$.ElementUpgrader = class ElementUpgrader extends core.Object {};
  html$.NodeValidator = class NodeValidator extends core.Object {
    static new(opts) {
      let uriPolicy = opts && 'uriPolicy' in opts ? opts.uriPolicy : null;
      return new html$._Html5NodeValidator({uriPolicy: uriPolicy});
    }
    static throws(base) {
      return new html$._ThrowsNodeValidator(base);
    }
  };
  dart.setSignature(html$.NodeValidator, {
    constructors: () => ({
      new: dart.definiteFunctionType(html$.NodeValidator, [], {uriPolicy: html$.UriPolicy}),
      throws: dart.definiteFunctionType(html$.NodeValidator, [html$.NodeValidator])
    })
  });
  html$.NodeTreeSanitizer = class NodeTreeSanitizer extends core.Object {
    static new(validator) {
      return new html$._ValidatingTreeSanitizer(validator);
    }
  };
  dart.setSignature(html$.NodeTreeSanitizer, {
    constructors: () => ({new: dart.definiteFunctionType(html$.NodeTreeSanitizer, [html$.NodeValidator])})
  });
  dart.defineLazy(html$.NodeTreeSanitizer, {
    get trusted() {
      return dart.const(new html$._TrustedHtmlTreeSanitizer());
    }
  });
  html$._TrustedHtmlTreeSanitizer = class _TrustedHtmlTreeSanitizer extends core.Object {
    new() {
    }
    sanitizeTree(node) {}
  };
  html$._TrustedHtmlTreeSanitizer[dart.implements] = () => [html$.NodeTreeSanitizer];
  dart.setSignature(html$._TrustedHtmlTreeSanitizer, {
    constructors: () => ({new: dart.definiteFunctionType(html$._TrustedHtmlTreeSanitizer, [])}),
    methods: () => ({sanitizeTree: dart.definiteFunctionType(dart.void, [html$.Node])})
  });
  html$.UriPolicy = class UriPolicy extends core.Object {
    static new() {
      return new html$._SameOriginUriPolicy();
    }
  };
  dart.setSignature(html$.UriPolicy, {
    constructors: () => ({new: dart.definiteFunctionType(html$.UriPolicy, [])})
  });
  const _hiddenAnchor = Symbol('_hiddenAnchor');
  const _loc = Symbol('_loc');
  html$._SameOriginUriPolicy = class _SameOriginUriPolicy extends core.Object {
    new() {
      this[_hiddenAnchor] = html$.AnchorElement.new();
      this[_loc] = html$.window[dartx.location];
    }
    allowsUri(uri) {
      this[_hiddenAnchor][dartx.href] = uri;
      return this[_hiddenAnchor][dartx.hostname] == this[_loc][dartx.hostname] && this[_hiddenAnchor][dartx.port] == this[_loc][dartx.port] && this[_hiddenAnchor][dartx.protocol] == this[_loc][dartx.protocol] || this[_hiddenAnchor][dartx.hostname] == '' && this[_hiddenAnchor][dartx.port] == '' && (this[_hiddenAnchor][dartx.protocol] == ':' || this[_hiddenAnchor][dartx.protocol] == '');
    }
  };
  html$._SameOriginUriPolicy[dart.implements] = () => [html$.UriPolicy];
  dart.setSignature(html$._SameOriginUriPolicy, {
    methods: () => ({allowsUri: dart.definiteFunctionType(core.bool, [core.String])})
  });
  html$._ThrowsNodeValidator = class _ThrowsNodeValidator extends core.Object {
    new(validator) {
      this.validator = validator;
    }
    allowsElement(element) {
      if (!dart.test(this.validator.allowsElement(element))) {
        dart.throw(new core.ArgumentError(html$.Element._safeTagName(element)));
      }
      return true;
    }
    allowsAttribute(element, attributeName, value) {
      if (!dart.test(this.validator.allowsAttribute(element, attributeName, value))) {
        dart.throw(new core.ArgumentError(dart.str`${html$.Element._safeTagName(element)}[${attributeName}="${value}"]`));
      }
    }
  };
  html$._ThrowsNodeValidator[dart.implements] = () => [html$.NodeValidator];
  dart.setSignature(html$._ThrowsNodeValidator, {
    constructors: () => ({new: dart.definiteFunctionType(html$._ThrowsNodeValidator, [html$.NodeValidator])}),
    methods: () => ({
      allowsElement: dart.definiteFunctionType(core.bool, [html$.Element]),
      allowsAttribute: dart.definiteFunctionType(core.bool, [html$.Element, core.String, core.String])
    })
  });
  const _removeNode = Symbol('_removeNode');
  const _sanitizeElement = Symbol('_sanitizeElement');
  const _sanitizeUntrustedElement = Symbol('_sanitizeUntrustedElement');
  html$._ValidatingTreeSanitizer = class _ValidatingTreeSanitizer extends core.Object {
    new(validator) {
      this.validator = validator;
    }
    sanitizeTree(node) {
      const walk = (function(node, parent) {
        this.sanitizeNode(node, parent);
        let child = node[dartx.lastChild];
        while (child != null) {
          let nextChild = child[dartx.previousNode];
          walk(child, node);
          child = nextChild;
        }
      }).bind(this);
      dart.fn(walk, NodeAndNodeTovoid());
      walk(node, null);
    }
    [_removeNode](node, parent) {
      if (parent == null) {
        node[dartx.remove]();
      } else {
        parent[_removeChild](node);
      }
    }
    [_sanitizeUntrustedElement](element, parent) {
      let corrupted = true;
      let attrs = null;
      let isAttr = null;
      try {
        attrs = dart.dload(element, 'attributes');
        isAttr = dart.dindex(attrs, 'is');
        let corruptedTest1 = html$.Element._hasCorruptedAttributes(html$.Element._check(element));
        corrupted = dart.test(corruptedTest1) ? true : html$.Element._hasCorruptedAttributesAdditionalCheck(html$.Element._check(element));
      } catch (e) {
      }

      let elementText = 'element unprintable';
      try {
        elementText = dart.toString(element);
      } catch (e) {
      }

      try {
        let elementTagName = html$.Element._safeTagName(element);
        this[_sanitizeElement](html$.Element._check(element), parent, corrupted, elementText, elementTagName, core.Map._check(attrs), core.String._check(isAttr));
      } catch (e$) {
        if (core.ArgumentError.is(e$)) {
          throw e$;
        } else {
          let e = e$;
          this[_removeNode](html$.Node._check(element), parent);
          html$.window[dartx.console].warn(dart.str`Removing corrupted element ${elementText}`);
        }
      }

    }
    [_sanitizeElement](element, parent, corrupted, text, tag, attrs, isAttr) {
      if (false != corrupted) {
        this[_removeNode](element, parent);
        html$.window[dartx.console].warn(dart.str`Removing element due to corrupted attributes on <${text}>`);
        return;
      }
      if (!dart.test(this.validator.allowsElement(element))) {
        this[_removeNode](element, parent);
        html$.window[dartx.console].warn(dart.str`Removing disallowed element <${tag}> from ${parent}`);
        return;
      }
      if (isAttr != null) {
        if (!dart.test(this.validator.allowsAttribute(element, 'is', isAttr))) {
          this[_removeNode](element, parent);
          html$.window[dartx.console].warn('Removing disallowed type extension ' + dart.str`<${tag} is="${isAttr}">`);
          return;
        }
      }
      let keys = attrs[dartx.keys][dartx.toList]();
      for (let i = dart.notNull(attrs[dartx.length]) - 1; i >= 0; --i) {
        let name = keys[dartx.get](i);
        if (!dart.test(this.validator.allowsAttribute(element, core.String._check(dart.dsend(name, 'toLowerCase')), core.String._check(attrs[dartx.get](name))))) {
          html$.window[dartx.console].warn('Removing disallowed attribute ' + dart.str`<${tag} ${name}="${attrs[dartx.get](name)}">`);
          attrs[dartx.remove](name);
        }
      }
      if (html$.TemplateElement.is(element)) {
        let template = element;
        this.sanitizeTree(template[dartx.content]);
      }
    }
    sanitizeNode(node, parent) {
      switch (node[dartx.nodeType]) {
        case html$.Node.ELEMENT_NODE:
        {
          this[_sanitizeUntrustedElement](node, parent);
          break;
        }
        case html$.Node.COMMENT_NODE:
        case html$.Node.DOCUMENT_FRAGMENT_NODE:
        case html$.Node.TEXT_NODE:
        case html$.Node.CDATA_SECTION_NODE:
        {
          break;
        }
        default:
        {
          this[_removeNode](node, parent);
        }
      }
    }
  };
  html$._ValidatingTreeSanitizer[dart.implements] = () => [html$.NodeTreeSanitizer];
  dart.setSignature(html$._ValidatingTreeSanitizer, {
    constructors: () => ({new: dart.definiteFunctionType(html$._ValidatingTreeSanitizer, [html$.NodeValidator])}),
    methods: () => ({
      sanitizeTree: dart.definiteFunctionType(dart.void, [html$.Node]),
      [_removeNode]: dart.definiteFunctionType(dart.void, [html$.Node, html$.Node]),
      [_sanitizeUntrustedElement]: dart.definiteFunctionType(dart.void, [dart.dynamic, html$.Node]),
      [_sanitizeElement]: dart.definiteFunctionType(dart.void, [html$.Element, html$.Node, core.bool, core.String, core.String, core.Map, core.String]),
      sanitizeNode: dart.definiteFunctionType(dart.void, [html$.Node, html$.Node])
    })
  });
  html$.Point$ = math.Point$;
  html$.Point = math.Point;
  html$.Rectangle$ = math.Rectangle$;
  html$.Rectangle = math.Rectangle;
  html_common.SupportedBrowser = _metadata.SupportedBrowser;
  html_common.Unstable = _metadata.Unstable;
  html_common.DocsEditable = _metadata.DocsEditable;
  html_common.Experimental = _metadata.Experimental;
  html_common.DomName = _metadata.DomName;
  html_common.convertDartToNative_SerializedScriptValue = function(value) {
    return html_common.convertDartToNative_PrepareForStructuredClone(value);
  };
  dart.fn(html_common.convertDartToNative_SerializedScriptValue, dynamicTodynamic$());
  html_common.convertNativeToDart_SerializedScriptValue = function(object) {
    return html_common.convertNativeToDart_AcceptStructuredClone(object, {mustCopy: true});
  };
  dart.fn(html_common.convertNativeToDart_SerializedScriptValue, dynamicTodynamic$());
  html_common._StructuredClone = class _StructuredClone extends core.Object {
    new() {
      this.values = [];
      this.copies = [];
    }
    findSlot(value) {
      let length = this.values[dartx.length];
      for (let i = 0; i < dart.notNull(length); i++) {
        if (core.identical(this.values[dartx.get](i), value)) return i;
      }
      this.values[dartx.add](value);
      this.copies[dartx.add](null);
      return length;
    }
    readSlot(i) {
      return this.copies[dartx.get](i);
    }
    writeSlot(i, x) {
      this.copies[dartx.set](i, x);
    }
    cleanupSlots() {}
    walk(e) {
      if (e == null) return e;
      if (typeof e == 'boolean') return e;
      if (typeof e == 'number') return e;
      if (typeof e == 'string') return e;
      if (core.DateTime.is(e)) {
        return html_common.convertDartToNative_DateTime(e);
      }
      if (core.RegExp.is(e)) {
        dart.throw(new core.UnimplementedError('structured clone of RegExp'));
      }
      if (html$.File.is(e)) return e;
      if (html$.Blob.is(e)) return e;
      if (html$.FileList.is(e)) return e;
      if (html$.ImageData.is(e)) return e;
      if (dart.test(this.cloneNotRequired(e))) return e;
      if (core.Map.is(e)) {
        let slot = this.findSlot(e);
        let copy = this.readSlot(slot);
        if (copy != null) return copy;
        copy = this.newJsMap();
        this.writeSlot(slot, copy);
        e[dartx.forEach](dart.fn((key, value) => {
          this.putIntoMap(copy, key, this.walk(value));
        }, dynamicAnddynamicTovoid()));
        return copy;
      }
      if (core.List.is(e)) {
        let slot = this.findSlot(e);
        let copy = this.readSlot(slot);
        if (copy != null) return copy;
        copy = this.copyList(e, slot);
        return copy;
      }
      dart.throw(new core.UnimplementedError('structured clone of other type'));
    }
    copyList(e, slot) {
      let i = 0;
      let length = e[dartx.length];
      let copy = this.newJsList(length);
      this.writeSlot(slot, copy);
      for (; i < dart.notNull(length); i++) {
        dart.dsetindex(copy, i, this.walk(e[dartx.get](i)));
      }
      return copy;
    }
    convertDartToNative_PrepareForStructuredClone(value) {
      let copy = this.walk(value);
      this.cleanupSlots();
      return copy;
    }
  };
  dart.setSignature(html_common._StructuredClone, {
    methods: () => ({
      findSlot: dart.definiteFunctionType(core.int, [dart.dynamic]),
      readSlot: dart.definiteFunctionType(dart.dynamic, [core.int]),
      writeSlot: dart.definiteFunctionType(dart.dynamic, [core.int, dart.dynamic]),
      cleanupSlots: dart.definiteFunctionType(dart.dynamic, []),
      walk: dart.definiteFunctionType(dart.dynamic, [dart.dynamic]),
      copyList: dart.definiteFunctionType(dart.dynamic, [core.List, core.int]),
      convertDartToNative_PrepareForStructuredClone: dart.definiteFunctionType(dart.dynamic, [dart.dynamic])
    })
  });
  html_common._AcceptStructuredClone = class _AcceptStructuredClone extends core.Object {
    new() {
      this.values = [];
      this.copies = [];
      this.mustCopy = false;
    }
    findSlot(value) {
      let length = this.values[dartx.length];
      for (let i = 0; i < dart.notNull(length); i++) {
        if (dart.test(this.identicalInJs(this.values[dartx.get](i), value))) return i;
      }
      this.values[dartx.add](value);
      this.copies[dartx.add](null);
      return length;
    }
    readSlot(i) {
      return this.copies[dartx.get](i);
    }
    writeSlot(i, x) {
      this.copies[dartx.set](i, x);
    }
    walk(e) {
      if (e == null) return e;
      if (typeof e == 'boolean') return e;
      if (typeof e == 'number') return e;
      if (typeof e == 'string') return e;
      if (dart.test(html_common.isJavaScriptDate(e))) {
        return html_common.convertNativeToDart_DateTime(e);
      }
      if (dart.test(html_common.isJavaScriptRegExp(e))) {
        dart.throw(new core.UnimplementedError('structured clone of RegExp'));
      }
      if (dart.test(html_common.isJavaScriptPromise(e))) {
        return html_common.convertNativePromiseToDartFuture(e);
      }
      if (dart.test(html_common.isJavaScriptSimpleObject(e))) {
        let slot = this.findSlot(e);
        let copy = this.readSlot(slot);
        if (copy != null) return copy;
        copy = dart.map();
        this.writeSlot(slot, copy);
        this.forEachJsField(e, dart.fn((key, value) => dart.dsetindex(copy, key, this.walk(value)), dynamicAnddynamicTodynamic$()));
        return copy;
      }
      if (dart.test(html_common.isJavaScriptArray(e))) {
        let slot = this.findSlot(e);
        let copy = this.readSlot(slot);
        if (copy != null) return copy;
        let length = core.int._check(dart.dload(e, 'length'));
        copy = dart.test(this.mustCopy) ? this.newDartList(length) : e;
        this.writeSlot(slot, copy);
        for (let i = 0; i < dart.notNull(length); i++) {
          dart.dsetindex(copy, i, this.walk(dart.dindex(e, i)));
        }
        return copy;
      }
      return e;
    }
    convertNativeToDart_AcceptStructuredClone(object, opts) {
      let mustCopy = opts && 'mustCopy' in opts ? opts.mustCopy : false;
      this.mustCopy = core.bool._check(mustCopy);
      let copy = this.walk(object);
      return copy;
    }
  };
  dart.setSignature(html_common._AcceptStructuredClone, {
    methods: () => ({
      findSlot: dart.definiteFunctionType(core.int, [dart.dynamic]),
      readSlot: dart.definiteFunctionType(dart.dynamic, [core.int]),
      writeSlot: dart.definiteFunctionType(dart.dynamic, [core.int, dart.dynamic]),
      walk: dart.definiteFunctionType(dart.dynamic, [dart.dynamic]),
      convertNativeToDart_AcceptStructuredClone: dart.definiteFunctionType(dart.dynamic, [dart.dynamic], {mustCopy: dart.dynamic})
    })
  });
  html_common.ContextAttributes = class ContextAttributes extends core.Object {
    new(alpha, antialias, depth, failIfMajorPerformanceCaveat, premultipliedAlpha, preserveDrawingBuffer, stencil) {
      this.alpha = alpha;
      this.antialias = antialias;
      this.depth = depth;
      this.failIfMajorPerformanceCaveat = failIfMajorPerformanceCaveat;
      this.premultipliedAlpha = premultipliedAlpha;
      this.preserveDrawingBuffer = preserveDrawingBuffer;
      this.stencil = stencil;
    }
  };
  dart.setSignature(html_common.ContextAttributes, {
    constructors: () => ({new: dart.definiteFunctionType(html_common.ContextAttributes, [core.bool, core.bool, core.bool, core.bool, core.bool, core.bool, core.bool])})
  });
  html_common.convertNativeToDart_ContextAttributes = function(nativeContextAttributes) {
    return new html_common.ContextAttributes(nativeContextAttributes.alpha, nativeContextAttributes.antialias, nativeContextAttributes.depth, nativeContextAttributes.failIfMajorPerformanceCaveat, nativeContextAttributes.premultipliedAlpha, nativeContextAttributes.preserveDrawingBuffer, nativeContextAttributes.stencil);
  };
  dart.fn(html_common.convertNativeToDart_ContextAttributes, dynamicTodynamic$());
  html_common._TypedImageData = class _TypedImageData extends core.Object {
    new(data, height, width) {
      this.data = data;
      this.height = height;
      this.width = width;
    }
  };
  html_common._TypedImageData[dart.implements] = () => [html$.ImageData];
  dart.setSignature(html_common._TypedImageData, {
    constructors: () => ({new: dart.definiteFunctionType(html_common._TypedImageData, [typed_data.Uint8ClampedList, core.int, core.int])})
  });
  html_common.convertNativeToDart_ImageData = function(nativeImageData) {
    0;
    if (html$.ImageData.is(nativeImageData)) {
      let data = nativeImageData[dartx.data];
      if (data.constructor === Array) {
        if (typeof CanvasPixelArray !== "undefined") {
          data.constructor = CanvasPixelArray;
          data.BYTES_PER_ELEMENT = 1;
        }
      }
      return nativeImageData;
    }
    return new html_common._TypedImageData(nativeImageData.data, nativeImageData.height, nativeImageData.width);
  };
  dart.fn(html_common.convertNativeToDart_ImageData, dynamicToImageData());
  html_common.convertDartToNative_ImageData = function(imageData) {
    if (html_common._TypedImageData.is(imageData)) {
      return {data: imageData.data, height: imageData.height, width: imageData.width};
    }
    return imageData;
  };
  dart.fn(html_common.convertDartToNative_ImageData, ImageDataTodynamic());
  html_common._serializedScriptValue = 'num|String|bool|' + 'JSExtendableArray|=Object|' + 'Blob|File|NativeByteBuffer|NativeTypedData';
  html_common.annotation_Creates_SerializedScriptValue = dart.const(new _js_helper.Creates(html_common._serializedScriptValue));
  html_common.annotation_Returns_SerializedScriptValue = dart.const(new _js_helper.Returns(html_common._serializedScriptValue));
  html_common.convertNativeToDart_Dictionary = function(object) {
    if (object == null) return null;
    let dict = dart.map();
    let keys = Object.getOwnPropertyNames(object);
    for (let key of core.Iterable._check(keys)) {
      dict[dartx.set](key, object[key]);
    }
    return dict;
  };
  dart.fn(html_common.convertNativeToDart_Dictionary, dynamicToMap());
  html_common.convertDartToNative_Dictionary = function(dict, postCreate) {
    if (postCreate === void 0) postCreate = null;
    if (dict == null) return null;
    let object = {};
    if (postCreate != null) {
      dart.dcall(postCreate, object);
    }
    dict[dartx.forEach](dart.fn((key, value) => {
      object[key] = value;
    }, StringAnddynamicTovoid()));
    return object;
  };
  dart.fn(html_common.convertDartToNative_Dictionary, Map__Todynamic());
  html_common.convertDartToNative_StringArray = function(input) {
    return input;
  };
  dart.fn(html_common.convertDartToNative_StringArray, ListOfStringToList());
  html_common.convertNativeToDart_DateTime = function(date) {
    let millisSinceEpoch = date.getTime();
    return new core.DateTime.fromMillisecondsSinceEpoch(millisSinceEpoch, {isUtc: true});
  };
  dart.fn(html_common.convertNativeToDart_DateTime, dynamicToDateTime());
  html_common.convertDartToNative_DateTime = function(date) {
    return new Date(date.millisecondsSinceEpoch);
  };
  dart.fn(html_common.convertDartToNative_DateTime, DateTimeTodynamic());
  html_common.convertDartToNative_PrepareForStructuredClone = function(value) {
    return new html_common._StructuredCloneDart2Js().convertDartToNative_PrepareForStructuredClone(value);
  };
  dart.fn(html_common.convertDartToNative_PrepareForStructuredClone, dynamicTodynamic$());
  html_common.convertNativeToDart_AcceptStructuredClone = function(object, opts) {
    let mustCopy = opts && 'mustCopy' in opts ? opts.mustCopy : false;
    return new html_common._AcceptStructuredCloneDart2Js().convertNativeToDart_AcceptStructuredClone(object, {mustCopy: mustCopy});
  };
  dart.fn(html_common.convertNativeToDart_AcceptStructuredClone, dynamic__Todynamic$());
  html_common._StructuredCloneDart2Js = class _StructuredCloneDart2Js extends html_common._StructuredClone {
    new() {
      super.new();
    }
    newJsMap() {
      return {};
    }
    putIntoMap(map, key, value) {
      return map[key] = value;
    }
    newJsList(length) {
      return new Array(length);
    }
    cloneNotRequired(e) {
      return _native_typed_data.NativeByteBuffer.is(e) || _native_typed_data.NativeTypedData.is(e);
    }
  };
  dart.setSignature(html_common._StructuredCloneDart2Js, {
    methods: () => ({
      newJsMap: dart.definiteFunctionType(dart.dynamic, []),
      putIntoMap: dart.definiteFunctionType(dart.void, [dart.dynamic, dart.dynamic, dart.dynamic]),
      newJsList: dart.definiteFunctionType(dart.dynamic, [dart.dynamic]),
      cloneNotRequired: dart.definiteFunctionType(core.bool, [dart.dynamic])
    })
  });
  html_common._AcceptStructuredCloneDart2Js = class _AcceptStructuredCloneDart2Js extends html_common._AcceptStructuredClone {
    new() {
      super.new();
    }
    newJsList(length) {
      return new Array(length);
    }
    newDartList(length) {
      return this.newJsList(length);
    }
    identicalInJs(a, b) {
      return core.identical(a, b);
    }
    forEachJsField(object, action) {
      for (let key of Object.keys(object)) {
        dart.dcall(action, key, object[key]);
      }
    }
  };
  dart.setSignature(html_common._AcceptStructuredCloneDart2Js, {
    methods: () => ({
      newJsList: dart.definiteFunctionType(dart.dynamic, [dart.dynamic]),
      newDartList: dart.definiteFunctionType(dart.dynamic, [dart.dynamic]),
      identicalInJs: dart.definiteFunctionType(core.bool, [dart.dynamic, dart.dynamic]),
      forEachJsField: dart.definiteFunctionType(dart.void, [dart.dynamic, dart.dynamic])
    })
  });
  html_common.isJavaScriptDate = function(value) {
    return value instanceof Date;
  };
  dart.fn(html_common.isJavaScriptDate, dynamicTobool$());
  html_common.isJavaScriptRegExp = function(value) {
    return value instanceof RegExp;
  };
  dart.fn(html_common.isJavaScriptRegExp, dynamicTobool$());
  html_common.isJavaScriptArray = function(value) {
    return value instanceof Array;
  };
  dart.fn(html_common.isJavaScriptArray, dynamicTobool$());
  html_common.isJavaScriptSimpleObject = function(value) {
    let proto = Object.getPrototypeOf(value);
    return proto === Object.prototype || proto === null;
  };
  dart.fn(html_common.isJavaScriptSimpleObject, dynamicTobool$());
  html_common.isImmutableJavaScriptArray = function(value) {
    return !!value.immutable$list;
  };
  dart.fn(html_common.isImmutableJavaScriptArray, dynamicTobool$());
  html_common.isJavaScriptPromise = function(value) {
    return typeof Promise != "undefined" && value instanceof Promise;
  };
  dart.fn(html_common.isJavaScriptPromise, dynamicTobool$());
  html_common.convertNativePromiseToDartFuture = function(promise) {
    let completer = async.Completer.new();
    let then = _js_helper.convertDartClosureToJS(dynamicTovoid())(dart.fn(result => completer.complete(result), dynamicTovoid$()), 1);
    let error = _js_helper.convertDartClosureToJS(dynamicTovoid())(dart.fn(result => completer.completeError(result), dynamicTovoid$()), 1);
    let newPromise = promise.then(then).catch(error);
    return completer.future;
  };
  dart.fn(html_common.convertNativePromiseToDartFuture, dynamicToFuture());
  html_common.Device = class Device extends core.Object {
    static get userAgent() {
      return html$.window[dartx.navigator][dartx.userAgent];
    }
    static get isOpera() {
      if (html_common.Device._isOpera == null) {
        html_common.Device._isOpera = html_common.Device.userAgent[dartx.contains]("Opera", 0);
      }
      return html_common.Device._isOpera;
    }
    static get isIE() {
      if (html_common.Device._isIE == null) {
        html_common.Device._isIE = !dart.test(html_common.Device.isOpera) && dart.test(html_common.Device.userAgent[dartx.contains]("Trident/", 0));
      }
      return html_common.Device._isIE;
    }
    static get isFirefox() {
      if (html_common.Device._isFirefox == null) {
        html_common.Device._isFirefox = html_common.Device.userAgent[dartx.contains]("Firefox", 0);
      }
      return html_common.Device._isFirefox;
    }
    static get isWebKit() {
      if (html_common.Device._isWebKit == null) {
        html_common.Device._isWebKit = !dart.test(html_common.Device.isOpera) && dart.test(html_common.Device.userAgent[dartx.contains]("WebKit", 0));
      }
      return html_common.Device._isWebKit;
    }
    static get cssPrefix() {
      let prefix = html_common.Device._cachedCssPrefix;
      if (prefix != null) return prefix;
      if (dart.test(html_common.Device.isFirefox)) {
        prefix = '-moz-';
      } else if (dart.test(html_common.Device.isIE)) {
        prefix = '-ms-';
      } else if (dart.test(html_common.Device.isOpera)) {
        prefix = '-o-';
      } else {
        prefix = '-webkit-';
      }
      return html_common.Device._cachedCssPrefix = prefix;
    }
    static get propertyPrefix() {
      let prefix = html_common.Device._cachedPropertyPrefix;
      if (prefix != null) return prefix;
      if (dart.test(html_common.Device.isFirefox)) {
        prefix = 'moz';
      } else if (dart.test(html_common.Device.isIE)) {
        prefix = 'ms';
      } else if (dart.test(html_common.Device.isOpera)) {
        prefix = 'o';
      } else {
        prefix = 'webkit';
      }
      return html_common.Device._cachedPropertyPrefix = prefix;
    }
    static isEventTypeSupported(eventType) {
      try {
        let e = html$.Event.eventType(eventType, '');
        return html$.Event.is(e);
      } catch (_) {
      }

      return false;
    }
  };
  dart.setSignature(html_common.Device, {
    statics: () => ({isEventTypeSupported: dart.definiteFunctionType(core.bool, [core.String])}),
    names: ['isEventTypeSupported']
  });
  html_common.Device._isOpera = null;
  html_common.Device._isIE = null;
  html_common.Device._isFirefox = null;
  html_common.Device._isWebKit = null;
  html_common.Device._cachedCssPrefix = null;
  html_common.Device._cachedPropertyPrefix = null;
  const _childNodes = Symbol('_childNodes');
  const _node = Symbol('_node');
  const _iterable$0 = Symbol('_iterable');
  const _filtered = Symbol('_filtered');
  html_common.FilteredElementList = class FilteredElementList extends collection.ListBase$(html$.Element) {
    new(node) {
      this[_childNodes] = node[dartx.nodes];
      this[_node] = node;
    }
    get [_iterable$0]() {
      return this[_childNodes][dartx.where](dart.fn(n => html$.Element.is(n), NodeTobool()))[dartx.map](html$.Element)(dart.fn(n => html$.Element.as(n), NodeToElement()));
    }
    get [_filtered]() {
      return ListOfElement().from(this[_iterable$0], {growable: false});
    }
    forEach(f) {
      this[_filtered][dartx.forEach](f);
    }
    set(index, value) {
      this.get(index)[dartx.replaceWith](value);
      return value;
    }
    set length(newLength) {
      let len = this.length;
      if (dart.notNull(newLength) >= dart.notNull(len)) {
        return;
      } else if (dart.notNull(newLength) < 0) {
        dart.throw(new core.ArgumentError("Invalid list length"));
      }
      this.removeRange(newLength, len);
    }
    add(value) {
      this[_childNodes][dartx.add](value);
    }
    addAll(iterable) {
      for (let element of iterable) {
        this.add(element);
      }
    }
    contains(needle) {
      if (!html$.Element.is(needle)) return false;
      let element = html$.Element._check(needle);
      return dart.equals(element[dartx.parentNode], this[_node]);
    }
    get reversed() {
      return this[_filtered][dartx.reversed];
    }
    sort(compare) {
      if (compare === void 0) compare = null;
      dart.throw(new core.UnsupportedError('Cannot sort filtered list'));
    }
    setRange(start, end, iterable, skipCount) {
      if (skipCount === void 0) skipCount = 0;
      dart.throw(new core.UnsupportedError('Cannot setRange on filtered list'));
    }
    fillRange(start, end, fillValue) {
      if (fillValue === void 0) fillValue = null;
      dart.throw(new core.UnsupportedError('Cannot fillRange on filtered list'));
    }
    replaceRange(start, end, iterable) {
      dart.throw(new core.UnsupportedError('Cannot replaceRange on filtered list'));
    }
    removeRange(start, end) {
      core.List.from(this[_iterable$0][dartx.skip](start)[dartx.take](dart.notNull(end) - dart.notNull(start)))[dartx.forEach](dart.fn(el => dart.dsend(el, 'remove'), dynamicTovoid$()));
    }
    clear() {
      this[_childNodes][dartx.clear]();
    }
    removeLast() {
      let result = this[_iterable$0][dartx.last];
      if (result != null) {
        result[dartx.remove]();
      }
      return result;
    }
    insert(index, value) {
      if (index == this.length) {
        this.add(value);
      } else {
        let element = this[_iterable$0][dartx.elementAt](index);
        element[dartx.parentNode][dartx.insertBefore](value, element);
      }
    }
    insertAll(index, iterable) {
      if (index == this.length) {
        this.addAll(iterable);
      } else {
        let element = this[_iterable$0][dartx.elementAt](index);
        element[dartx.parentNode][dartx.insertAllBefore](iterable, element);
      }
    }
    removeAt(index) {
      let result = this.get(index);
      result[dartx.remove]();
      return result;
    }
    remove(element) {
      if (!html$.Element.is(element)) return false;
      if (dart.test(this.contains(element))) {
        html$.Element.as(element)[dartx.remove]();
        return true;
      } else {
        return false;
      }
    }
    get length() {
      return this[_iterable$0][dartx.length];
    }
    get(index) {
      return this[_iterable$0][dartx.elementAt](index);
    }
    get iterator() {
      return this[_filtered][dartx.iterator];
    }
    get rawList() {
      return this[_node][dartx.childNodes];
    }
  };
  dart.addSimpleTypeTests(html_common.FilteredElementList);
  html_common.FilteredElementList[dart.implements] = () => [html_common.NodeListWrapper];
  dart.setSignature(html_common.FilteredElementList, {
    constructors: () => ({new: dart.definiteFunctionType(html_common.FilteredElementList, [html$.Node])}),
    methods: () => ({
      forEach: dart.definiteFunctionType(dart.void, [dart.functionType(dart.void, [html$.Element])]),
      set: dart.definiteFunctionType(dart.void, [core.int, html$.Element]),
      add: dart.definiteFunctionType(dart.void, [html$.Element]),
      addAll: dart.definiteFunctionType(dart.void, [core.Iterable$(html$.Element)]),
      sort: dart.definiteFunctionType(dart.void, [], [dart.functionType(core.int, [html$.Element, html$.Element])]),
      setRange: dart.definiteFunctionType(dart.void, [core.int, core.int, core.Iterable$(html$.Element)], [core.int]),
      fillRange: dart.definiteFunctionType(dart.void, [core.int, core.int], [html$.Element]),
      replaceRange: dart.definiteFunctionType(dart.void, [core.int, core.int, core.Iterable$(html$.Element)]),
      removeLast: dart.definiteFunctionType(html$.Element, []),
      insert: dart.definiteFunctionType(dart.void, [core.int, html$.Element]),
      insertAll: dart.definiteFunctionType(dart.void, [core.int, core.Iterable$(html$.Element)]),
      removeAt: dart.definiteFunctionType(html$.Element, [core.int]),
      get: dart.definiteFunctionType(html$.Element, [core.int])
    })
  });
  dart.defineExtensionMembers(html_common.FilteredElementList, [
    'forEach',
    'set',
    'add',
    'addAll',
    'contains',
    'sort',
    'setRange',
    'fillRange',
    'replaceRange',
    'removeRange',
    'clear',
    'removeLast',
    'insert',
    'insertAll',
    'removeAt',
    'remove',
    'get',
    'length',
    'reversed',
    'length',
    'iterator'
  ]);
  html_common.Lists = class Lists extends core.Object {
    static indexOf(a, element, startIndex, endIndex) {
      if (dart.notNull(startIndex) >= dart.notNull(a[dartx.length])) {
        return -1;
      }
      if (dart.notNull(startIndex) < 0) {
        startIndex = 0;
      }
      for (let i = startIndex; dart.notNull(i) < dart.notNull(endIndex); i = dart.notNull(i) + 1) {
        if (dart.equals(a[dartx.get](i), element)) {
          return i;
        }
      }
      return -1;
    }
    static lastIndexOf(a, element, startIndex) {
      if (dart.notNull(startIndex) < 0) {
        return -1;
      }
      if (dart.notNull(startIndex) >= dart.notNull(a[dartx.length])) {
        startIndex = dart.notNull(a[dartx.length]) - 1;
      }
      for (let i = startIndex; dart.notNull(i) >= 0; i = dart.notNull(i) - 1) {
        if (dart.equals(a[dartx.get](i), element)) {
          return i;
        }
      }
      return -1;
    }
    static getRange(a, start, end, accumulator) {
      if (dart.notNull(start) < 0) dart.throw(new core.RangeError.value(start));
      if (dart.notNull(end) < dart.notNull(start)) dart.throw(new core.RangeError.value(end));
      if (dart.notNull(end) > dart.notNull(a[dartx.length])) dart.throw(new core.RangeError.value(end));
      for (let i = start; dart.notNull(i) < dart.notNull(end); i = dart.notNull(i) + 1) {
        accumulator[dartx.add](a[dartx.get](i));
      }
      return accumulator;
    }
  };
  dart.setSignature(html_common.Lists, {
    statics: () => ({
      indexOf: dart.definiteFunctionType(core.int, [core.List, core.Object, core.int, core.int]),
      lastIndexOf: dart.definiteFunctionType(core.int, [core.List, core.Object, core.int]),
      getRange: dart.definiteFunctionType(core.List, [core.List, core.int, core.int, core.List])
    }),
    names: ['indexOf', 'lastIndexOf', 'getRange']
  });
  html_common.NodeListWrapper = class NodeListWrapper extends core.Object {};
  svg$._SvgElementFactoryProvider = class _SvgElementFactoryProvider extends core.Object {
    static createSvgElement_tag(tag) {
      let temp = html$.document[dartx.createElementNS]("http://www.w3.org/2000/svg", tag);
      return svg$.SvgElement._check(temp);
    }
  };
  dart.setSignature(svg$._SvgElementFactoryProvider, {
    statics: () => ({createSvgElement_tag: dart.definiteFunctionType(svg$.SvgElement, [core.String])}),
    names: ['createSvgElement_tag']
  });
  const _children$ = Symbol('_children');
  const _svgClassName = Symbol('_svgClassName');
  dart.defineExtensionNames([
    'classes',
    'children',
    'children',
    'outerHtml',
    'innerHtml',
    'innerHtml',
    'createFragment',
    'insertAdjacentText',
    'insertAdjacentHtml',
    'insertAdjacentElement',
    'isContentEditable',
    'click',
    'blur',
    'focus',
    'onAbort',
    'onBlur',
    'onCanPlay',
    'onCanPlayThrough',
    'onChange',
    'onClick',
    'onContextMenu',
    'onDoubleClick',
    'onDrag',
    'onDragEnd',
    'onDragEnter',
    'onDragLeave',
    'onDragOver',
    'onDragStart',
    'onDrop',
    'onDurationChange',
    'onEmptied',
    'onEnded',
    'onError',
    'onFocus',
    'onInput',
    'onInvalid',
    'onKeyDown',
    'onKeyPress',
    'onKeyUp',
    'onLoad',
    'onLoadedData',
    'onLoadedMetadata',
    'onMouseDown',
    'onMouseEnter',
    'onMouseLeave',
    'onMouseMove',
    'onMouseOut',
    'onMouseOver',
    'onMouseUp',
    'onMouseWheel',
    'onPause',
    'onPlay',
    'onPlaying',
    'onRateChange',
    'onReset',
    'onResize',
    'onScroll',
    'onSeeked',
    'onSeeking',
    'onSelect',
    'onStalled',
    'onSubmit',
    'onSuspend',
    'onTimeUpdate',
    'onVolumeChange',
    'onWaiting',
    'ownerSvgElement',
    'viewportElement'
  ]);
  svg$.SvgElement = class SvgElement extends html$.Element {
    static tag(tag) {
      return svg$.SvgElement._check(html$.document[dartx.createElementNS]("http://www.w3.org/2000/svg", tag));
    }
    static svg(svg, opts) {
      let validator = opts && 'validator' in opts ? opts.validator : null;
      let treeSanitizer = opts && 'treeSanitizer' in opts ? opts.treeSanitizer : null;
      if (validator == null && treeSanitizer == null) {
        validator = new html$.NodeValidatorBuilder.common();
        validator.allowSvg();
      }
      let match = svg$.SvgElement._START_TAG_REGEXP.firstMatch(svg);
      let parentElement = null;
      if (match != null && match.group(1)[dartx.toLowerCase]() == 'svg') {
        parentElement = html$.document[dartx.body];
      } else {
        parentElement = svg$.SvgSvgElement.new();
      }
      let fragment = dart.dsend(parentElement, 'createFragment', svg, {validator: validator, treeSanitizer: treeSanitizer});
      return svg$.SvgElement._check(dart.dload(dart.dsend(dart.dload(fragment, 'nodes'), 'where', dart.fn(e => svg$.SvgElement.is(e), dynamicTobool$())), 'single'));
    }
    get [dartx.classes]() {
      return new svg$._AttributeClassSet(this);
    }
    set [dartx.classes](value) {
      super[dartx.classes] = value;
    }
    get [dartx.children]() {
      return new html_common.FilteredElementList(this);
    }
    set [dartx.children](value) {
      let children = this[dartx.children];
      children[dartx.clear]();
      children[dartx.addAll](value);
    }
    get [dartx.outerHtml]() {
      let container = html$.Element.tag("div");
      let cloned = svg$.SvgElement._check(this[dartx.clone](true));
      container[dartx.children][dartx.add](cloned);
      return container[dartx.innerHtml];
    }
    get [dartx.innerHtml]() {
      let container = html$.Element.tag("div");
      let cloned = svg$.SvgElement._check(this[dartx.clone](true));
      container[dartx.children][dartx.addAll](cloned[dartx.children]);
      return container[dartx.innerHtml];
    }
    set [dartx.innerHtml](value) {
      this[dartx.setInnerHtml](value);
    }
    [dartx.createFragment](svg, opts) {
      let validator = opts && 'validator' in opts ? opts.validator : null;
      let treeSanitizer = opts && 'treeSanitizer' in opts ? opts.treeSanitizer : null;
      if (treeSanitizer == null) {
        if (validator == null) {
          validator = new html$.NodeValidatorBuilder.common();
          validator.allowSvg();
        }
        treeSanitizer = html$.NodeTreeSanitizer.new(validator);
      }
      let html = dart.str`<svg version="1.1">${svg}</svg>`;
      let fragment = html$.document[dartx.body][dartx.createFragment](html, {treeSanitizer: treeSanitizer});
      let svgFragment = html$.DocumentFragment.new();
      let root = fragment[dartx.nodes][dartx.single];
      while (root[dartx.firstChild] != null) {
        svgFragment[dartx.append](root[dartx.firstChild]);
      }
      return svgFragment;
    }
    [dartx.insertAdjacentText](where, text) {
      dart.throw(new core.UnsupportedError("Cannot invoke insertAdjacentText on SVG."));
    }
    [dartx.insertAdjacentHtml](where, text, opts) {
      let validator = opts && 'validator' in opts ? opts.validator : null;
      let treeSanitizer = opts && 'treeSanitizer' in opts ? opts.treeSanitizer : null;
      dart.throw(new core.UnsupportedError("Cannot invoke insertAdjacentHtml on SVG."));
    }
    [dartx.insertAdjacentElement](where, element) {
      dart.throw(new core.UnsupportedError("Cannot invoke insertAdjacentElement on SVG."));
    }
    get [_children$]() {
      dart.throw(new core.UnsupportedError("Cannot get _children on SVG."));
    }
    get [dartx.isContentEditable]() {
      return false;
    }
    [dartx.click]() {
      dart.throw(new core.UnsupportedError("Cannot invoke click SVG."));
    }
    static isTagSupported(tag) {
      let e = svg$.SvgElement.tag(tag);
      return svg$.SvgElement.is(e) && !html$.UnknownElement.is(e);
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    created() {
      this[dartx.ownerSvgElement] = null;
      this[dartx.viewportElement] = null;
      super.created();
    }
    get [_svgClassName]() {
      return this.className;
    }
    get [dartx.ownerSvgElement]() {
      return this.ownerSVGElement;
    }
    get [dartx.viewportElement]() {
      return this.viewportElement;
    }
    [dartx.blur]() {
      return this.blur();
    }
    [dartx.focus]() {
      return this.focus();
    }
    get [dartx.onAbort]() {
      return svg$.SvgElement.abortEvent.forElement(this);
    }
    get [dartx.onBlur]() {
      return svg$.SvgElement.blurEvent.forElement(this);
    }
    get [dartx.onCanPlay]() {
      return svg$.SvgElement.canPlayEvent.forElement(this);
    }
    get [dartx.onCanPlayThrough]() {
      return svg$.SvgElement.canPlayThroughEvent.forElement(this);
    }
    get [dartx.onChange]() {
      return svg$.SvgElement.changeEvent.forElement(this);
    }
    get [dartx.onClick]() {
      return svg$.SvgElement.clickEvent.forElement(this);
    }
    get [dartx.onContextMenu]() {
      return svg$.SvgElement.contextMenuEvent.forElement(this);
    }
    get [dartx.onDoubleClick]() {
      return svg$.SvgElement.doubleClickEvent.forElement(this);
    }
    get [dartx.onDrag]() {
      return svg$.SvgElement.dragEvent.forElement(this);
    }
    get [dartx.onDragEnd]() {
      return svg$.SvgElement.dragEndEvent.forElement(this);
    }
    get [dartx.onDragEnter]() {
      return svg$.SvgElement.dragEnterEvent.forElement(this);
    }
    get [dartx.onDragLeave]() {
      return svg$.SvgElement.dragLeaveEvent.forElement(this);
    }
    get [dartx.onDragOver]() {
      return svg$.SvgElement.dragOverEvent.forElement(this);
    }
    get [dartx.onDragStart]() {
      return svg$.SvgElement.dragStartEvent.forElement(this);
    }
    get [dartx.onDrop]() {
      return svg$.SvgElement.dropEvent.forElement(this);
    }
    get [dartx.onDurationChange]() {
      return svg$.SvgElement.durationChangeEvent.forElement(this);
    }
    get [dartx.onEmptied]() {
      return svg$.SvgElement.emptiedEvent.forElement(this);
    }
    get [dartx.onEnded]() {
      return svg$.SvgElement.endedEvent.forElement(this);
    }
    get [dartx.onError]() {
      return svg$.SvgElement.errorEvent.forElement(this);
    }
    get [dartx.onFocus]() {
      return svg$.SvgElement.focusEvent.forElement(this);
    }
    get [dartx.onInput]() {
      return svg$.SvgElement.inputEvent.forElement(this);
    }
    get [dartx.onInvalid]() {
      return svg$.SvgElement.invalidEvent.forElement(this);
    }
    get [dartx.onKeyDown]() {
      return svg$.SvgElement.keyDownEvent.forElement(this);
    }
    get [dartx.onKeyPress]() {
      return svg$.SvgElement.keyPressEvent.forElement(this);
    }
    get [dartx.onKeyUp]() {
      return svg$.SvgElement.keyUpEvent.forElement(this);
    }
    get [dartx.onLoad]() {
      return svg$.SvgElement.loadEvent.forElement(this);
    }
    get [dartx.onLoadedData]() {
      return svg$.SvgElement.loadedDataEvent.forElement(this);
    }
    get [dartx.onLoadedMetadata]() {
      return svg$.SvgElement.loadedMetadataEvent.forElement(this);
    }
    get [dartx.onMouseDown]() {
      return svg$.SvgElement.mouseDownEvent.forElement(this);
    }
    get [dartx.onMouseEnter]() {
      return svg$.SvgElement.mouseEnterEvent.forElement(this);
    }
    get [dartx.onMouseLeave]() {
      return svg$.SvgElement.mouseLeaveEvent.forElement(this);
    }
    get [dartx.onMouseMove]() {
      return svg$.SvgElement.mouseMoveEvent.forElement(this);
    }
    get [dartx.onMouseOut]() {
      return svg$.SvgElement.mouseOutEvent.forElement(this);
    }
    get [dartx.onMouseOver]() {
      return svg$.SvgElement.mouseOverEvent.forElement(this);
    }
    get [dartx.onMouseUp]() {
      return svg$.SvgElement.mouseUpEvent.forElement(this);
    }
    get [dartx.onMouseWheel]() {
      return svg$.SvgElement.mouseWheelEvent.forElement(this);
    }
    get [dartx.onPause]() {
      return svg$.SvgElement.pauseEvent.forElement(this);
    }
    get [dartx.onPlay]() {
      return svg$.SvgElement.playEvent.forElement(this);
    }
    get [dartx.onPlaying]() {
      return svg$.SvgElement.playingEvent.forElement(this);
    }
    get [dartx.onRateChange]() {
      return svg$.SvgElement.rateChangeEvent.forElement(this);
    }
    get [dartx.onReset]() {
      return svg$.SvgElement.resetEvent.forElement(this);
    }
    get [dartx.onResize]() {
      return svg$.SvgElement.resizeEvent.forElement(this);
    }
    get [dartx.onScroll]() {
      return svg$.SvgElement.scrollEvent.forElement(this);
    }
    get [dartx.onSeeked]() {
      return svg$.SvgElement.seekedEvent.forElement(this);
    }
    get [dartx.onSeeking]() {
      return svg$.SvgElement.seekingEvent.forElement(this);
    }
    get [dartx.onSelect]() {
      return svg$.SvgElement.selectEvent.forElement(this);
    }
    get [dartx.onStalled]() {
      return svg$.SvgElement.stalledEvent.forElement(this);
    }
    get [dartx.onSubmit]() {
      return svg$.SvgElement.submitEvent.forElement(this);
    }
    get [dartx.onSuspend]() {
      return svg$.SvgElement.suspendEvent.forElement(this);
    }
    get [dartx.onTimeUpdate]() {
      return svg$.SvgElement.timeUpdateEvent.forElement(this);
    }
    get [dartx.onVolumeChange]() {
      return svg$.SvgElement.volumeChangeEvent.forElement(this);
    }
    get [dartx.onWaiting]() {
      return svg$.SvgElement.waitingEvent.forElement(this);
    }
  };
  dart.defineNamedConstructor(svg$.SvgElement, 'created');
  svg$.SvgElement[dart.implements] = () => [html$.GlobalEventHandlers];
  dart.setSignature(svg$.SvgElement, {
    constructors: () => ({
      tag: dart.definiteFunctionType(svg$.SvgElement, [core.String]),
      svg: dart.definiteFunctionType(svg$.SvgElement, [core.String], {validator: html$.NodeValidator, treeSanitizer: html$.NodeTreeSanitizer}),
      _: dart.definiteFunctionType(svg$.SvgElement, []),
      created: dart.definiteFunctionType(svg$.SvgElement, [])
    })
  });
  dart.defineLazy(svg$.SvgElement, {
    get _START_TAG_REGEXP() {
      return core.RegExp.new('<(\\w+)');
    },
    get abortEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('abort'));
    },
    get blurEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('blur'));
    },
    get canPlayEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('canplay'));
    },
    get canPlayThroughEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('canplaythrough'));
    },
    get changeEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('change'));
    },
    get clickEvent() {
      return dart.const(new (EventStreamProviderOfMouseEvent())('click'));
    },
    get contextMenuEvent() {
      return dart.const(new (EventStreamProviderOfMouseEvent())('contextmenu'));
    },
    get doubleClickEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('dblclick'));
    },
    get dragEvent() {
      return dart.const(new (EventStreamProviderOfMouseEvent())('drag'));
    },
    get dragEndEvent() {
      return dart.const(new (EventStreamProviderOfMouseEvent())('dragend'));
    },
    get dragEnterEvent() {
      return dart.const(new (EventStreamProviderOfMouseEvent())('dragenter'));
    },
    get dragLeaveEvent() {
      return dart.const(new (EventStreamProviderOfMouseEvent())('dragleave'));
    },
    get dragOverEvent() {
      return dart.const(new (EventStreamProviderOfMouseEvent())('dragover'));
    },
    get dragStartEvent() {
      return dart.const(new (EventStreamProviderOfMouseEvent())('dragstart'));
    },
    get dropEvent() {
      return dart.const(new (EventStreamProviderOfMouseEvent())('drop'));
    },
    get durationChangeEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('durationchange'));
    },
    get emptiedEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('emptied'));
    },
    get endedEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('ended'));
    },
    get errorEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('error'));
    },
    get focusEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('focus'));
    },
    get inputEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('input'));
    },
    get invalidEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('invalid'));
    },
    get keyDownEvent() {
      return dart.const(new (EventStreamProviderOfKeyboardEvent())('keydown'));
    },
    get keyPressEvent() {
      return dart.const(new (EventStreamProviderOfKeyboardEvent())('keypress'));
    },
    get keyUpEvent() {
      return dart.const(new (EventStreamProviderOfKeyboardEvent())('keyup'));
    },
    get loadEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('load'));
    },
    get loadedDataEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('loadeddata'));
    },
    get loadedMetadataEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('loadedmetadata'));
    },
    get mouseDownEvent() {
      return dart.const(new (EventStreamProviderOfMouseEvent())('mousedown'));
    },
    get mouseEnterEvent() {
      return dart.const(new (EventStreamProviderOfMouseEvent())('mouseenter'));
    },
    get mouseLeaveEvent() {
      return dart.const(new (EventStreamProviderOfMouseEvent())('mouseleave'));
    },
    get mouseMoveEvent() {
      return dart.const(new (EventStreamProviderOfMouseEvent())('mousemove'));
    },
    get mouseOutEvent() {
      return dart.const(new (EventStreamProviderOfMouseEvent())('mouseout'));
    },
    get mouseOverEvent() {
      return dart.const(new (EventStreamProviderOfMouseEvent())('mouseover'));
    },
    get mouseUpEvent() {
      return dart.const(new (EventStreamProviderOfMouseEvent())('mouseup'));
    },
    get mouseWheelEvent() {
      return dart.const(new (EventStreamProviderOfWheelEvent())('mousewheel'));
    },
    get pauseEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('pause'));
    },
    get playEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('play'));
    },
    get playingEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('playing'));
    },
    get rateChangeEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('ratechange'));
    },
    get resetEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('reset'));
    },
    get resizeEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('resize'));
    },
    get scrollEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('scroll'));
    },
    get seekedEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('seeked'));
    },
    get seekingEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('seeking'));
    },
    get selectEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('select'));
    },
    get stalledEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('stalled'));
    },
    get submitEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('submit'));
    },
    get suspendEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('suspend'));
    },
    get timeUpdateEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('timeupdate'));
    },
    get volumeChangeEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('volumechange'));
    },
    get waitingEvent() {
      return dart.const(new (EventStreamProviderOfEvent())('waiting'));
    }
  });
  dart.registerExtension(dart.global.SVGElement, svg$.SvgElement);
  dart.defineExtensionNames([
    'getBBox',
    'getCtm',
    'getScreenCtm',
    'getTransformToElement',
    'hasExtension',
    'farthestViewportElement',
    'nearestViewportElement',
    'transform',
    'requiredExtensions',
    'requiredFeatures',
    'systemLanguage'
  ]);
  svg$.GraphicsElement = class GraphicsElement extends svg$.SvgElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    created() {
      this[dartx.farthestViewportElement] = null;
      this[dartx.nearestViewportElement] = null;
      this[dartx.transform] = null;
      this[dartx.requiredExtensions] = null;
      this[dartx.requiredFeatures] = null;
      this[dartx.systemLanguage] = null;
      super.created();
    }
    get [dartx.farthestViewportElement]() {
      return this.farthestViewportElement;
    }
    get [dartx.nearestViewportElement]() {
      return this.nearestViewportElement;
    }
    get [dartx.transform]() {
      return this.transform;
    }
    [dartx.getBBox]() {
      return this.getBBox();
    }
    [dartx.getCtm]() {
      return this.getCTM();
    }
    [dartx.getScreenCtm]() {
      return this.getScreenCTM();
    }
    [dartx.getTransformToElement](element) {
      return this.getTransformToElement(element);
    }
    get [dartx.requiredExtensions]() {
      return this.requiredExtensions;
    }
    get [dartx.requiredFeatures]() {
      return this.requiredFeatures;
    }
    get [dartx.systemLanguage]() {
      return this.systemLanguage;
    }
    [dartx.hasExtension](extension) {
      return this.hasExtension(extension);
    }
  };
  dart.defineNamedConstructor(svg$.GraphicsElement, 'created');
  svg$.GraphicsElement[dart.implements] = () => [svg$.Tests];
  dart.setSignature(svg$.GraphicsElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(svg$.GraphicsElement, []),
      created: dart.definiteFunctionType(svg$.GraphicsElement, [])
    }),
    methods: () => ({
      [dartx.getBBox]: dart.definiteFunctionType(svg$.Rect, []),
      [dartx.getCtm]: dart.definiteFunctionType(svg$.Matrix, []),
      [dartx.getScreenCtm]: dart.definiteFunctionType(svg$.Matrix, []),
      [dartx.getTransformToElement]: dart.definiteFunctionType(svg$.Matrix, [svg$.SvgElement]),
      [dartx.hasExtension]: dart.definiteFunctionType(core.bool, [core.String])
    })
  });
  dart.registerExtension(dart.global.SVGGraphicsElement, svg$.GraphicsElement);
  dart.defineExtensionNames([
    'target',
    'href'
  ]);
  svg$.AElement = class AElement extends svg$.GraphicsElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return svg$.AElement._check(svg$._SvgElementFactoryProvider.createSvgElement_tag("a"));
    }
    created() {
      this[dartx.target] = null;
      this[dartx.href] = null;
      super.created();
    }
    get [dartx.target]() {
      return this.target;
    }
    get [dartx.href]() {
      return this.href;
    }
  };
  dart.defineNamedConstructor(svg$.AElement, 'created');
  svg$.AElement[dart.implements] = () => [svg$.UriReference];
  dart.setSignature(svg$.AElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(svg$.AElement, []),
      new: dart.definiteFunctionType(svg$.AElement, []),
      created: dart.definiteFunctionType(svg$.AElement, [])
    })
  });
  dart.registerExtension(dart.global.SVGAElement, svg$.AElement);
  dart.defineExtensionNames([
    'convertToSpecifiedUnits',
    'newValueSpecifiedUnits',
    'unitType',
    'value',
    'valueAsString',
    'valueInSpecifiedUnits'
  ]);
  svg$.Angle = class Angle extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.unitType]() {
      return this.unitType;
    }
    get [dartx.value]() {
      return this.value;
    }
    set [dartx.value](value) {
      this.value = value;
    }
    get [dartx.valueAsString]() {
      return this.valueAsString;
    }
    set [dartx.valueAsString](value) {
      this.valueAsString = value;
    }
    get [dartx.valueInSpecifiedUnits]() {
      return this.valueInSpecifiedUnits;
    }
    set [dartx.valueInSpecifiedUnits](value) {
      this.valueInSpecifiedUnits = value;
    }
    [dartx.convertToSpecifiedUnits](unitType) {
      return this.convertToSpecifiedUnits(unitType);
    }
    [dartx.newValueSpecifiedUnits](unitType, valueInSpecifiedUnits) {
      return this.newValueSpecifiedUnits(unitType, valueInSpecifiedUnits);
    }
  };
  dart.setSignature(svg$.Angle, {
    constructors: () => ({_: dart.definiteFunctionType(svg$.Angle, [])}),
    methods: () => ({
      [dartx.convertToSpecifiedUnits]: dart.definiteFunctionType(dart.void, [core.int]),
      [dartx.newValueSpecifiedUnits]: dart.definiteFunctionType(dart.void, [core.int, core.num])
    })
  });
  svg$.Angle.SVG_ANGLETYPE_DEG = 2;
  svg$.Angle.SVG_ANGLETYPE_GRAD = 4;
  svg$.Angle.SVG_ANGLETYPE_RAD = 3;
  svg$.Angle.SVG_ANGLETYPE_UNKNOWN = 0;
  svg$.Angle.SVG_ANGLETYPE_UNSPECIFIED = 1;
  dart.registerExtension(dart.global.SVGAngle, svg$.Angle);
  dart.defineExtensionNames([
    'beginElement',
    'beginElementAt',
    'endElement',
    'endElementAt',
    'getCurrentTime',
    'getSimpleDuration',
    'getStartTime',
    'hasExtension',
    'targetElement',
    'requiredExtensions',
    'requiredFeatures',
    'systemLanguage'
  ]);
  svg$.AnimationElement = class AnimationElement extends svg$.SvgElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return svg$.AnimationElement._check(svg$._SvgElementFactoryProvider.createSvgElement_tag("animation"));
    }
    created() {
      this[dartx.targetElement] = null;
      this[dartx.requiredExtensions] = null;
      this[dartx.requiredFeatures] = null;
      this[dartx.systemLanguage] = null;
      super.created();
    }
    get [dartx.targetElement]() {
      return this.targetElement;
    }
    [dartx.beginElement]() {
      return this.beginElement();
    }
    [dartx.beginElementAt](offset) {
      return this.beginElementAt(offset);
    }
    [dartx.endElement]() {
      return this.endElement();
    }
    [dartx.endElementAt](offset) {
      return this.endElementAt(offset);
    }
    [dartx.getCurrentTime]() {
      return this.getCurrentTime();
    }
    [dartx.getSimpleDuration]() {
      return this.getSimpleDuration();
    }
    [dartx.getStartTime]() {
      return this.getStartTime();
    }
    get [dartx.requiredExtensions]() {
      return this.requiredExtensions;
    }
    get [dartx.requiredFeatures]() {
      return this.requiredFeatures;
    }
    get [dartx.systemLanguage]() {
      return this.systemLanguage;
    }
    [dartx.hasExtension](extension) {
      return this.hasExtension(extension);
    }
  };
  dart.defineNamedConstructor(svg$.AnimationElement, 'created');
  svg$.AnimationElement[dart.implements] = () => [svg$.Tests];
  dart.setSignature(svg$.AnimationElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(svg$.AnimationElement, []),
      new: dart.definiteFunctionType(svg$.AnimationElement, []),
      created: dart.definiteFunctionType(svg$.AnimationElement, [])
    }),
    methods: () => ({
      [dartx.beginElement]: dart.definiteFunctionType(dart.void, []),
      [dartx.beginElementAt]: dart.definiteFunctionType(dart.void, [core.num]),
      [dartx.endElement]: dart.definiteFunctionType(dart.void, []),
      [dartx.endElementAt]: dart.definiteFunctionType(dart.void, [core.num]),
      [dartx.getCurrentTime]: dart.definiteFunctionType(core.double, []),
      [dartx.getSimpleDuration]: dart.definiteFunctionType(core.double, []),
      [dartx.getStartTime]: dart.definiteFunctionType(core.double, []),
      [dartx.hasExtension]: dart.definiteFunctionType(core.bool, [core.String])
    })
  });
  dart.registerExtension(dart.global.SVGAnimationElement, svg$.AnimationElement);
  svg$.AnimateElement = class AnimateElement extends svg$.AnimationElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return svg$.AnimateElement._check(svg$._SvgElementFactoryProvider.createSvgElement_tag("animate"));
    }
    created() {
      super.created();
    }
    static get supported() {
      return dart.test(svg$.SvgElement.isTagSupported('animate')) && svg$.AnimateElement.is(svg$.SvgElement.tag('animate'));
    }
  };
  dart.defineNamedConstructor(svg$.AnimateElement, 'created');
  dart.setSignature(svg$.AnimateElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(svg$.AnimateElement, []),
      new: dart.definiteFunctionType(svg$.AnimateElement, []),
      created: dart.definiteFunctionType(svg$.AnimateElement, [])
    })
  });
  dart.registerExtension(dart.global.SVGAnimateElement, svg$.AnimateElement);
  svg$.AnimateMotionElement = class AnimateMotionElement extends svg$.AnimationElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return svg$.AnimateMotionElement._check(svg$._SvgElementFactoryProvider.createSvgElement_tag("animateMotion"));
    }
    created() {
      super.created();
    }
    static get supported() {
      return dart.test(svg$.SvgElement.isTagSupported('animateMotion')) && svg$.AnimateMotionElement.is(svg$.SvgElement.tag('animateMotion'));
    }
  };
  dart.defineNamedConstructor(svg$.AnimateMotionElement, 'created');
  dart.setSignature(svg$.AnimateMotionElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(svg$.AnimateMotionElement, []),
      new: dart.definiteFunctionType(svg$.AnimateMotionElement, []),
      created: dart.definiteFunctionType(svg$.AnimateMotionElement, [])
    })
  });
  dart.registerExtension(dart.global.SVGAnimateMotionElement, svg$.AnimateMotionElement);
  svg$.AnimateTransformElement = class AnimateTransformElement extends svg$.AnimationElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return svg$.AnimateTransformElement._check(svg$._SvgElementFactoryProvider.createSvgElement_tag("animateTransform"));
    }
    created() {
      super.created();
    }
    static get supported() {
      return dart.test(svg$.SvgElement.isTagSupported('animateTransform')) && svg$.AnimateTransformElement.is(svg$.SvgElement.tag('animateTransform'));
    }
  };
  dart.defineNamedConstructor(svg$.AnimateTransformElement, 'created');
  dart.setSignature(svg$.AnimateTransformElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(svg$.AnimateTransformElement, []),
      new: dart.definiteFunctionType(svg$.AnimateTransformElement, []),
      created: dart.definiteFunctionType(svg$.AnimateTransformElement, [])
    })
  });
  dart.registerExtension(dart.global.SVGAnimateTransformElement, svg$.AnimateTransformElement);
  dart.defineExtensionNames([
    'animVal',
    'baseVal'
  ]);
  svg$.AnimatedAngle = class AnimatedAngle extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.animVal]() {
      return this.animVal;
    }
    get [dartx.baseVal]() {
      return this.baseVal;
    }
  };
  dart.setSignature(svg$.AnimatedAngle, {
    constructors: () => ({_: dart.definiteFunctionType(svg$.AnimatedAngle, [])})
  });
  dart.registerExtension(dart.global.SVGAnimatedAngle, svg$.AnimatedAngle);
  dart.defineExtensionNames([
    'animVal',
    'baseVal'
  ]);
  svg$.AnimatedBoolean = class AnimatedBoolean extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.animVal]() {
      return this.animVal;
    }
    get [dartx.baseVal]() {
      return this.baseVal;
    }
    set [dartx.baseVal](value) {
      this.baseVal = value;
    }
  };
  dart.setSignature(svg$.AnimatedBoolean, {
    constructors: () => ({_: dart.definiteFunctionType(svg$.AnimatedBoolean, [])})
  });
  dart.registerExtension(dart.global.SVGAnimatedBoolean, svg$.AnimatedBoolean);
  dart.defineExtensionNames([
    'animVal',
    'baseVal'
  ]);
  svg$.AnimatedEnumeration = class AnimatedEnumeration extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.animVal]() {
      return this.animVal;
    }
    get [dartx.baseVal]() {
      return this.baseVal;
    }
    set [dartx.baseVal](value) {
      this.baseVal = value;
    }
  };
  dart.setSignature(svg$.AnimatedEnumeration, {
    constructors: () => ({_: dart.definiteFunctionType(svg$.AnimatedEnumeration, [])})
  });
  dart.registerExtension(dart.global.SVGAnimatedEnumeration, svg$.AnimatedEnumeration);
  dart.defineExtensionNames([
    'animVal',
    'baseVal'
  ]);
  svg$.AnimatedInteger = class AnimatedInteger extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.animVal]() {
      return this.animVal;
    }
    get [dartx.baseVal]() {
      return this.baseVal;
    }
    set [dartx.baseVal](value) {
      this.baseVal = value;
    }
  };
  dart.setSignature(svg$.AnimatedInteger, {
    constructors: () => ({_: dart.definiteFunctionType(svg$.AnimatedInteger, [])})
  });
  dart.registerExtension(dart.global.SVGAnimatedInteger, svg$.AnimatedInteger);
  dart.defineExtensionNames([
    'animVal',
    'baseVal'
  ]);
  svg$.AnimatedLength = class AnimatedLength extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.animVal]() {
      return this.animVal;
    }
    get [dartx.baseVal]() {
      return this.baseVal;
    }
  };
  dart.setSignature(svg$.AnimatedLength, {
    constructors: () => ({_: dart.definiteFunctionType(svg$.AnimatedLength, [])})
  });
  dart.registerExtension(dart.global.SVGAnimatedLength, svg$.AnimatedLength);
  dart.defineExtensionNames([
    'animVal',
    'baseVal'
  ]);
  svg$.AnimatedLengthList = class AnimatedLengthList extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.animVal]() {
      return this.animVal;
    }
    get [dartx.baseVal]() {
      return this.baseVal;
    }
  };
  dart.setSignature(svg$.AnimatedLengthList, {
    constructors: () => ({_: dart.definiteFunctionType(svg$.AnimatedLengthList, [])})
  });
  dart.registerExtension(dart.global.SVGAnimatedLengthList, svg$.AnimatedLengthList);
  dart.defineExtensionNames([
    'animVal',
    'baseVal'
  ]);
  svg$.AnimatedNumber = class AnimatedNumber extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.animVal]() {
      return this.animVal;
    }
    get [dartx.baseVal]() {
      return this.baseVal;
    }
    set [dartx.baseVal](value) {
      this.baseVal = value;
    }
  };
  dart.setSignature(svg$.AnimatedNumber, {
    constructors: () => ({_: dart.definiteFunctionType(svg$.AnimatedNumber, [])})
  });
  dart.registerExtension(dart.global.SVGAnimatedNumber, svg$.AnimatedNumber);
  dart.defineExtensionNames([
    'animVal',
    'baseVal'
  ]);
  svg$.AnimatedNumberList = class AnimatedNumberList extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.animVal]() {
      return this.animVal;
    }
    get [dartx.baseVal]() {
      return this.baseVal;
    }
  };
  dart.setSignature(svg$.AnimatedNumberList, {
    constructors: () => ({_: dart.definiteFunctionType(svg$.AnimatedNumberList, [])})
  });
  dart.registerExtension(dart.global.SVGAnimatedNumberList, svg$.AnimatedNumberList);
  dart.defineExtensionNames([
    'animVal',
    'baseVal'
  ]);
  svg$.AnimatedPreserveAspectRatio = class AnimatedPreserveAspectRatio extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.animVal]() {
      return this.animVal;
    }
    get [dartx.baseVal]() {
      return this.baseVal;
    }
  };
  dart.setSignature(svg$.AnimatedPreserveAspectRatio, {
    constructors: () => ({_: dart.definiteFunctionType(svg$.AnimatedPreserveAspectRatio, [])})
  });
  dart.registerExtension(dart.global.SVGAnimatedPreserveAspectRatio, svg$.AnimatedPreserveAspectRatio);
  dart.defineExtensionNames([
    'animVal',
    'baseVal'
  ]);
  svg$.AnimatedRect = class AnimatedRect extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.animVal]() {
      return this.animVal;
    }
    get [dartx.baseVal]() {
      return this.baseVal;
    }
  };
  dart.setSignature(svg$.AnimatedRect, {
    constructors: () => ({_: dart.definiteFunctionType(svg$.AnimatedRect, [])})
  });
  dart.registerExtension(dart.global.SVGAnimatedRect, svg$.AnimatedRect);
  dart.defineExtensionNames([
    'animVal',
    'baseVal'
  ]);
  svg$.AnimatedString = class AnimatedString extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.animVal]() {
      return this.animVal;
    }
    get [dartx.baseVal]() {
      return this.baseVal;
    }
    set [dartx.baseVal](value) {
      this.baseVal = value;
    }
  };
  dart.setSignature(svg$.AnimatedString, {
    constructors: () => ({_: dart.definiteFunctionType(svg$.AnimatedString, [])})
  });
  dart.registerExtension(dart.global.SVGAnimatedString, svg$.AnimatedString);
  dart.defineExtensionNames([
    'animVal',
    'baseVal'
  ]);
  svg$.AnimatedTransformList = class AnimatedTransformList extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.animVal]() {
      return this.animVal;
    }
    get [dartx.baseVal]() {
      return this.baseVal;
    }
  };
  dart.setSignature(svg$.AnimatedTransformList, {
    constructors: () => ({_: dart.definiteFunctionType(svg$.AnimatedTransformList, [])})
  });
  dart.registerExtension(dart.global.SVGAnimatedTransformList, svg$.AnimatedTransformList);
  dart.defineExtensionNames([
    'isPointInFill',
    'isPointInStroke'
  ]);
  svg$.GeometryElement = class GeometryElement extends svg$.GraphicsElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    created() {
      super.created();
    }
    [dartx.isPointInFill](point) {
      return this.isPointInFill(point);
    }
    [dartx.isPointInStroke](point) {
      return this.isPointInStroke(point);
    }
  };
  dart.defineNamedConstructor(svg$.GeometryElement, 'created');
  dart.setSignature(svg$.GeometryElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(svg$.GeometryElement, []),
      created: dart.definiteFunctionType(svg$.GeometryElement, [])
    }),
    methods: () => ({
      [dartx.isPointInFill]: dart.definiteFunctionType(core.bool, [svg$.Point]),
      [dartx.isPointInStroke]: dart.definiteFunctionType(core.bool, [svg$.Point])
    })
  });
  dart.registerExtension(dart.global.SVGGeometryElement, svg$.GeometryElement);
  dart.defineExtensionNames([
    'cx',
    'cy',
    'r'
  ]);
  svg$.CircleElement = class CircleElement extends svg$.GeometryElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return svg$.CircleElement._check(svg$._SvgElementFactoryProvider.createSvgElement_tag("circle"));
    }
    created() {
      this[dartx.cx] = null;
      this[dartx.cy] = null;
      this[dartx.r] = null;
      super.created();
    }
    get [dartx.cx]() {
      return this.cx;
    }
    get [dartx.cy]() {
      return this.cy;
    }
    get [dartx.r]() {
      return this.r;
    }
  };
  dart.defineNamedConstructor(svg$.CircleElement, 'created');
  dart.setSignature(svg$.CircleElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(svg$.CircleElement, []),
      new: dart.definiteFunctionType(svg$.CircleElement, []),
      created: dart.definiteFunctionType(svg$.CircleElement, [])
    })
  });
  dart.registerExtension(dart.global.SVGCircleElement, svg$.CircleElement);
  dart.defineExtensionNames([
    'clipPathUnits'
  ]);
  svg$.ClipPathElement = class ClipPathElement extends svg$.GraphicsElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return svg$.ClipPathElement._check(svg$._SvgElementFactoryProvider.createSvgElement_tag("clipPath"));
    }
    created() {
      this[dartx.clipPathUnits] = null;
      super.created();
    }
    get [dartx.clipPathUnits]() {
      return this.clipPathUnits;
    }
  };
  dart.defineNamedConstructor(svg$.ClipPathElement, 'created');
  dart.setSignature(svg$.ClipPathElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(svg$.ClipPathElement, []),
      new: dart.definiteFunctionType(svg$.ClipPathElement, []),
      created: dart.definiteFunctionType(svg$.ClipPathElement, [])
    })
  });
  dart.registerExtension(dart.global.SVGClipPathElement, svg$.ClipPathElement);
  svg$.DefsElement = class DefsElement extends svg$.GraphicsElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return svg$.DefsElement._check(svg$._SvgElementFactoryProvider.createSvgElement_tag("defs"));
    }
    created() {
      super.created();
    }
  };
  dart.defineNamedConstructor(svg$.DefsElement, 'created');
  dart.setSignature(svg$.DefsElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(svg$.DefsElement, []),
      new: dart.definiteFunctionType(svg$.DefsElement, []),
      created: dart.definiteFunctionType(svg$.DefsElement, [])
    })
  });
  dart.registerExtension(dart.global.SVGDefsElement, svg$.DefsElement);
  svg$.DescElement = class DescElement extends svg$.SvgElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return svg$.DescElement._check(svg$._SvgElementFactoryProvider.createSvgElement_tag("desc"));
    }
    created() {
      super.created();
    }
  };
  dart.defineNamedConstructor(svg$.DescElement, 'created');
  dart.setSignature(svg$.DescElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(svg$.DescElement, []),
      new: dart.definiteFunctionType(svg$.DescElement, []),
      created: dart.definiteFunctionType(svg$.DescElement, [])
    })
  });
  dart.registerExtension(dart.global.SVGDescElement, svg$.DescElement);
  svg$.DiscardElement = class DiscardElement extends svg$.SvgElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    created() {
      super.created();
    }
  };
  dart.defineNamedConstructor(svg$.DiscardElement, 'created');
  dart.setSignature(svg$.DiscardElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(svg$.DiscardElement, []),
      created: dart.definiteFunctionType(svg$.DiscardElement, [])
    })
  });
  dart.registerExtension(dart.global.SVGDiscardElement, svg$.DiscardElement);
  dart.defineExtensionNames([
    'cx',
    'cy',
    'rx',
    'ry'
  ]);
  svg$.EllipseElement = class EllipseElement extends svg$.GeometryElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return svg$.EllipseElement._check(svg$._SvgElementFactoryProvider.createSvgElement_tag("ellipse"));
    }
    created() {
      this[dartx.cx] = null;
      this[dartx.cy] = null;
      this[dartx.rx] = null;
      this[dartx.ry] = null;
      super.created();
    }
    get [dartx.cx]() {
      return this.cx;
    }
    get [dartx.cy]() {
      return this.cy;
    }
    get [dartx.rx]() {
      return this.rx;
    }
    get [dartx.ry]() {
      return this.ry;
    }
  };
  dart.defineNamedConstructor(svg$.EllipseElement, 'created');
  dart.setSignature(svg$.EllipseElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(svg$.EllipseElement, []),
      new: dart.definiteFunctionType(svg$.EllipseElement, []),
      created: dart.definiteFunctionType(svg$.EllipseElement, [])
    })
  });
  dart.registerExtension(dart.global.SVGEllipseElement, svg$.EllipseElement);
  dart.defineExtensionNames([
    'in1',
    'in2',
    'mode',
    'height',
    'result',
    'width',
    'x',
    'y'
  ]);
  svg$.FEBlendElement = class FEBlendElement extends svg$.SvgElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return svg$.FEBlendElement._check(svg$._SvgElementFactoryProvider.createSvgElement_tag("feBlend"));
    }
    created() {
      this[dartx.in1] = null;
      this[dartx.in2] = null;
      this[dartx.mode] = null;
      this[dartx.height] = null;
      this[dartx.result] = null;
      this[dartx.width] = null;
      this[dartx.x] = null;
      this[dartx.y] = null;
      super.created();
    }
    static get supported() {
      return dart.test(svg$.SvgElement.isTagSupported('feBlend')) && svg$.FEBlendElement.is(svg$.SvgElement.tag('feBlend'));
    }
    get [dartx.in1]() {
      return this.in1;
    }
    get [dartx.in2]() {
      return this.in2;
    }
    get [dartx.mode]() {
      return this.mode;
    }
    get [dartx.height]() {
      return this.height;
    }
    get [dartx.result]() {
      return this.result;
    }
    get [dartx.width]() {
      return this.width;
    }
    get [dartx.x]() {
      return this.x;
    }
    get [dartx.y]() {
      return this.y;
    }
  };
  dart.defineNamedConstructor(svg$.FEBlendElement, 'created');
  svg$.FEBlendElement[dart.implements] = () => [svg$.FilterPrimitiveStandardAttributes];
  dart.setSignature(svg$.FEBlendElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(svg$.FEBlendElement, []),
      new: dart.definiteFunctionType(svg$.FEBlendElement, []),
      created: dart.definiteFunctionType(svg$.FEBlendElement, [])
    })
  });
  svg$.FEBlendElement.SVG_FEBLEND_MODE_DARKEN = 4;
  svg$.FEBlendElement.SVG_FEBLEND_MODE_LIGHTEN = 5;
  svg$.FEBlendElement.SVG_FEBLEND_MODE_MULTIPLY = 2;
  svg$.FEBlendElement.SVG_FEBLEND_MODE_NORMAL = 1;
  svg$.FEBlendElement.SVG_FEBLEND_MODE_SCREEN = 3;
  svg$.FEBlendElement.SVG_FEBLEND_MODE_UNKNOWN = 0;
  dart.registerExtension(dart.global.SVGFEBlendElement, svg$.FEBlendElement);
  dart.defineExtensionNames([
    'in1',
    'type',
    'values',
    'height',
    'result',
    'width',
    'x',
    'y'
  ]);
  svg$.FEColorMatrixElement = class FEColorMatrixElement extends svg$.SvgElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return svg$.FEColorMatrixElement._check(svg$._SvgElementFactoryProvider.createSvgElement_tag("feColorMatrix"));
    }
    created() {
      this[dartx.in1] = null;
      this[dartx.type] = null;
      this[dartx.values] = null;
      this[dartx.height] = null;
      this[dartx.result] = null;
      this[dartx.width] = null;
      this[dartx.x] = null;
      this[dartx.y] = null;
      super.created();
    }
    static get supported() {
      return dart.test(svg$.SvgElement.isTagSupported('feColorMatrix')) && svg$.FEColorMatrixElement.is(svg$.SvgElement.tag('feColorMatrix'));
    }
    get [dartx.in1]() {
      return this.in1;
    }
    get [dartx.type]() {
      return this.type;
    }
    get [dartx.values]() {
      return this.values;
    }
    get [dartx.height]() {
      return this.height;
    }
    get [dartx.result]() {
      return this.result;
    }
    get [dartx.width]() {
      return this.width;
    }
    get [dartx.x]() {
      return this.x;
    }
    get [dartx.y]() {
      return this.y;
    }
  };
  dart.defineNamedConstructor(svg$.FEColorMatrixElement, 'created');
  svg$.FEColorMatrixElement[dart.implements] = () => [svg$.FilterPrimitiveStandardAttributes];
  dart.setSignature(svg$.FEColorMatrixElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(svg$.FEColorMatrixElement, []),
      new: dart.definiteFunctionType(svg$.FEColorMatrixElement, []),
      created: dart.definiteFunctionType(svg$.FEColorMatrixElement, [])
    })
  });
  svg$.FEColorMatrixElement.SVG_FECOLORMATRIX_TYPE_HUEROTATE = 3;
  svg$.FEColorMatrixElement.SVG_FECOLORMATRIX_TYPE_LUMINANCETOALPHA = 4;
  svg$.FEColorMatrixElement.SVG_FECOLORMATRIX_TYPE_MATRIX = 1;
  svg$.FEColorMatrixElement.SVG_FECOLORMATRIX_TYPE_SATURATE = 2;
  svg$.FEColorMatrixElement.SVG_FECOLORMATRIX_TYPE_UNKNOWN = 0;
  dart.registerExtension(dart.global.SVGFEColorMatrixElement, svg$.FEColorMatrixElement);
  dart.defineExtensionNames([
    'in1',
    'height',
    'result',
    'width',
    'x',
    'y'
  ]);
  svg$.FEComponentTransferElement = class FEComponentTransferElement extends svg$.SvgElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return svg$.FEComponentTransferElement._check(svg$._SvgElementFactoryProvider.createSvgElement_tag("feComponentTransfer"));
    }
    created() {
      this[dartx.in1] = null;
      this[dartx.height] = null;
      this[dartx.result] = null;
      this[dartx.width] = null;
      this[dartx.x] = null;
      this[dartx.y] = null;
      super.created();
    }
    static get supported() {
      return dart.test(svg$.SvgElement.isTagSupported('feComponentTransfer')) && svg$.FEComponentTransferElement.is(svg$.SvgElement.tag('feComponentTransfer'));
    }
    get [dartx.in1]() {
      return this.in1;
    }
    get [dartx.height]() {
      return this.height;
    }
    get [dartx.result]() {
      return this.result;
    }
    get [dartx.width]() {
      return this.width;
    }
    get [dartx.x]() {
      return this.x;
    }
    get [dartx.y]() {
      return this.y;
    }
  };
  dart.defineNamedConstructor(svg$.FEComponentTransferElement, 'created');
  svg$.FEComponentTransferElement[dart.implements] = () => [svg$.FilterPrimitiveStandardAttributes];
  dart.setSignature(svg$.FEComponentTransferElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(svg$.FEComponentTransferElement, []),
      new: dart.definiteFunctionType(svg$.FEComponentTransferElement, []),
      created: dart.definiteFunctionType(svg$.FEComponentTransferElement, [])
    })
  });
  dart.registerExtension(dart.global.SVGFEComponentTransferElement, svg$.FEComponentTransferElement);
  dart.defineExtensionNames([
    'in1',
    'in2',
    'k1',
    'k2',
    'k3',
    'k4',
    'operator',
    'height',
    'result',
    'width',
    'x',
    'y'
  ]);
  svg$.FECompositeElement = class FECompositeElement extends svg$.SvgElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    created() {
      this[dartx.in1] = null;
      this[dartx.in2] = null;
      this[dartx.k1] = null;
      this[dartx.k2] = null;
      this[dartx.k3] = null;
      this[dartx.k4] = null;
      this[dartx.operator] = null;
      this[dartx.height] = null;
      this[dartx.result] = null;
      this[dartx.width] = null;
      this[dartx.x] = null;
      this[dartx.y] = null;
      super.created();
    }
    get [dartx.in1]() {
      return this.in1;
    }
    get [dartx.in2]() {
      return this.in2;
    }
    get [dartx.k1]() {
      return this.k1;
    }
    get [dartx.k2]() {
      return this.k2;
    }
    get [dartx.k3]() {
      return this.k3;
    }
    get [dartx.k4]() {
      return this.k4;
    }
    get [dartx.operator]() {
      return this.operator;
    }
    get [dartx.height]() {
      return this.height;
    }
    get [dartx.result]() {
      return this.result;
    }
    get [dartx.width]() {
      return this.width;
    }
    get [dartx.x]() {
      return this.x;
    }
    get [dartx.y]() {
      return this.y;
    }
  };
  dart.defineNamedConstructor(svg$.FECompositeElement, 'created');
  svg$.FECompositeElement[dart.implements] = () => [svg$.FilterPrimitiveStandardAttributes];
  dart.setSignature(svg$.FECompositeElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(svg$.FECompositeElement, []),
      created: dart.definiteFunctionType(svg$.FECompositeElement, [])
    })
  });
  svg$.FECompositeElement.SVG_FECOMPOSITE_OPERATOR_ARITHMETIC = 6;
  svg$.FECompositeElement.SVG_FECOMPOSITE_OPERATOR_ATOP = 4;
  svg$.FECompositeElement.SVG_FECOMPOSITE_OPERATOR_IN = 2;
  svg$.FECompositeElement.SVG_FECOMPOSITE_OPERATOR_OUT = 3;
  svg$.FECompositeElement.SVG_FECOMPOSITE_OPERATOR_OVER = 1;
  svg$.FECompositeElement.SVG_FECOMPOSITE_OPERATOR_UNKNOWN = 0;
  svg$.FECompositeElement.SVG_FECOMPOSITE_OPERATOR_XOR = 5;
  dart.registerExtension(dart.global.SVGFECompositeElement, svg$.FECompositeElement);
  dart.defineExtensionNames([
    'bias',
    'divisor',
    'edgeMode',
    'in1',
    'kernelMatrix',
    'kernelUnitLengthX',
    'kernelUnitLengthY',
    'orderX',
    'orderY',
    'preserveAlpha',
    'targetX',
    'targetY',
    'height',
    'result',
    'width',
    'x',
    'y'
  ]);
  svg$.FEConvolveMatrixElement = class FEConvolveMatrixElement extends svg$.SvgElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return svg$.FEConvolveMatrixElement._check(svg$._SvgElementFactoryProvider.createSvgElement_tag("feConvolveMatrix"));
    }
    created() {
      this[dartx.bias] = null;
      this[dartx.divisor] = null;
      this[dartx.edgeMode] = null;
      this[dartx.in1] = null;
      this[dartx.kernelMatrix] = null;
      this[dartx.kernelUnitLengthX] = null;
      this[dartx.kernelUnitLengthY] = null;
      this[dartx.orderX] = null;
      this[dartx.orderY] = null;
      this[dartx.preserveAlpha] = null;
      this[dartx.targetX] = null;
      this[dartx.targetY] = null;
      this[dartx.height] = null;
      this[dartx.result] = null;
      this[dartx.width] = null;
      this[dartx.x] = null;
      this[dartx.y] = null;
      super.created();
    }
    static get supported() {
      return dart.test(svg$.SvgElement.isTagSupported('feConvolveMatrix')) && svg$.FEConvolveMatrixElement.is(svg$.SvgElement.tag('feConvolveMatrix'));
    }
    get [dartx.bias]() {
      return this.bias;
    }
    get [dartx.divisor]() {
      return this.divisor;
    }
    get [dartx.edgeMode]() {
      return this.edgeMode;
    }
    get [dartx.in1]() {
      return this.in1;
    }
    get [dartx.kernelMatrix]() {
      return this.kernelMatrix;
    }
    get [dartx.kernelUnitLengthX]() {
      return this.kernelUnitLengthX;
    }
    get [dartx.kernelUnitLengthY]() {
      return this.kernelUnitLengthY;
    }
    get [dartx.orderX]() {
      return this.orderX;
    }
    get [dartx.orderY]() {
      return this.orderY;
    }
    get [dartx.preserveAlpha]() {
      return this.preserveAlpha;
    }
    get [dartx.targetX]() {
      return this.targetX;
    }
    get [dartx.targetY]() {
      return this.targetY;
    }
    get [dartx.height]() {
      return this.height;
    }
    get [dartx.result]() {
      return this.result;
    }
    get [dartx.width]() {
      return this.width;
    }
    get [dartx.x]() {
      return this.x;
    }
    get [dartx.y]() {
      return this.y;
    }
  };
  dart.defineNamedConstructor(svg$.FEConvolveMatrixElement, 'created');
  svg$.FEConvolveMatrixElement[dart.implements] = () => [svg$.FilterPrimitiveStandardAttributes];
  dart.setSignature(svg$.FEConvolveMatrixElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(svg$.FEConvolveMatrixElement, []),
      new: dart.definiteFunctionType(svg$.FEConvolveMatrixElement, []),
      created: dart.definiteFunctionType(svg$.FEConvolveMatrixElement, [])
    })
  });
  svg$.FEConvolveMatrixElement.SVG_EDGEMODE_DUPLICATE = 1;
  svg$.FEConvolveMatrixElement.SVG_EDGEMODE_NONE = 3;
  svg$.FEConvolveMatrixElement.SVG_EDGEMODE_UNKNOWN = 0;
  svg$.FEConvolveMatrixElement.SVG_EDGEMODE_WRAP = 2;
  dart.registerExtension(dart.global.SVGFEConvolveMatrixElement, svg$.FEConvolveMatrixElement);
  dart.defineExtensionNames([
    'diffuseConstant',
    'in1',
    'kernelUnitLengthX',
    'kernelUnitLengthY',
    'surfaceScale',
    'height',
    'result',
    'width',
    'x',
    'y'
  ]);
  svg$.FEDiffuseLightingElement = class FEDiffuseLightingElement extends svg$.SvgElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return svg$.FEDiffuseLightingElement._check(svg$._SvgElementFactoryProvider.createSvgElement_tag("feDiffuseLighting"));
    }
    created() {
      this[dartx.diffuseConstant] = null;
      this[dartx.in1] = null;
      this[dartx.kernelUnitLengthX] = null;
      this[dartx.kernelUnitLengthY] = null;
      this[dartx.surfaceScale] = null;
      this[dartx.height] = null;
      this[dartx.result] = null;
      this[dartx.width] = null;
      this[dartx.x] = null;
      this[dartx.y] = null;
      super.created();
    }
    static get supported() {
      return dart.test(svg$.SvgElement.isTagSupported('feDiffuseLighting')) && svg$.FEDiffuseLightingElement.is(svg$.SvgElement.tag('feDiffuseLighting'));
    }
    get [dartx.diffuseConstant]() {
      return this.diffuseConstant;
    }
    get [dartx.in1]() {
      return this.in1;
    }
    get [dartx.kernelUnitLengthX]() {
      return this.kernelUnitLengthX;
    }
    get [dartx.kernelUnitLengthY]() {
      return this.kernelUnitLengthY;
    }
    get [dartx.surfaceScale]() {
      return this.surfaceScale;
    }
    get [dartx.height]() {
      return this.height;
    }
    get [dartx.result]() {
      return this.result;
    }
    get [dartx.width]() {
      return this.width;
    }
    get [dartx.x]() {
      return this.x;
    }
    get [dartx.y]() {
      return this.y;
    }
  };
  dart.defineNamedConstructor(svg$.FEDiffuseLightingElement, 'created');
  svg$.FEDiffuseLightingElement[dart.implements] = () => [svg$.FilterPrimitiveStandardAttributes];
  dart.setSignature(svg$.FEDiffuseLightingElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(svg$.FEDiffuseLightingElement, []),
      new: dart.definiteFunctionType(svg$.FEDiffuseLightingElement, []),
      created: dart.definiteFunctionType(svg$.FEDiffuseLightingElement, [])
    })
  });
  dart.registerExtension(dart.global.SVGFEDiffuseLightingElement, svg$.FEDiffuseLightingElement);
  dart.defineExtensionNames([
    'in1',
    'in2',
    'scale',
    'xChannelSelector',
    'yChannelSelector',
    'height',
    'result',
    'width',
    'x',
    'y'
  ]);
  svg$.FEDisplacementMapElement = class FEDisplacementMapElement extends svg$.SvgElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return svg$.FEDisplacementMapElement._check(svg$._SvgElementFactoryProvider.createSvgElement_tag("feDisplacementMap"));
    }
    created() {
      this[dartx.in1] = null;
      this[dartx.in2] = null;
      this[dartx.scale] = null;
      this[dartx.xChannelSelector] = null;
      this[dartx.yChannelSelector] = null;
      this[dartx.height] = null;
      this[dartx.result] = null;
      this[dartx.width] = null;
      this[dartx.x] = null;
      this[dartx.y] = null;
      super.created();
    }
    static get supported() {
      return dart.test(svg$.SvgElement.isTagSupported('feDisplacementMap')) && svg$.FEDisplacementMapElement.is(svg$.SvgElement.tag('feDisplacementMap'));
    }
    get [dartx.in1]() {
      return this.in1;
    }
    get [dartx.in2]() {
      return this.in2;
    }
    get [dartx.scale]() {
      return this.scale;
    }
    get [dartx.xChannelSelector]() {
      return this.xChannelSelector;
    }
    get [dartx.yChannelSelector]() {
      return this.yChannelSelector;
    }
    get [dartx.height]() {
      return this.height;
    }
    get [dartx.result]() {
      return this.result;
    }
    get [dartx.width]() {
      return this.width;
    }
    get [dartx.x]() {
      return this.x;
    }
    get [dartx.y]() {
      return this.y;
    }
  };
  dart.defineNamedConstructor(svg$.FEDisplacementMapElement, 'created');
  svg$.FEDisplacementMapElement[dart.implements] = () => [svg$.FilterPrimitiveStandardAttributes];
  dart.setSignature(svg$.FEDisplacementMapElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(svg$.FEDisplacementMapElement, []),
      new: dart.definiteFunctionType(svg$.FEDisplacementMapElement, []),
      created: dart.definiteFunctionType(svg$.FEDisplacementMapElement, [])
    })
  });
  svg$.FEDisplacementMapElement.SVG_CHANNEL_A = 4;
  svg$.FEDisplacementMapElement.SVG_CHANNEL_B = 3;
  svg$.FEDisplacementMapElement.SVG_CHANNEL_G = 2;
  svg$.FEDisplacementMapElement.SVG_CHANNEL_R = 1;
  svg$.FEDisplacementMapElement.SVG_CHANNEL_UNKNOWN = 0;
  dart.registerExtension(dart.global.SVGFEDisplacementMapElement, svg$.FEDisplacementMapElement);
  dart.defineExtensionNames([
    'azimuth',
    'elevation'
  ]);
  svg$.FEDistantLightElement = class FEDistantLightElement extends svg$.SvgElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return svg$.FEDistantLightElement._check(svg$._SvgElementFactoryProvider.createSvgElement_tag("feDistantLight"));
    }
    created() {
      this[dartx.azimuth] = null;
      this[dartx.elevation] = null;
      super.created();
    }
    static get supported() {
      return dart.test(svg$.SvgElement.isTagSupported('feDistantLight')) && svg$.FEDistantLightElement.is(svg$.SvgElement.tag('feDistantLight'));
    }
    get [dartx.azimuth]() {
      return this.azimuth;
    }
    get [dartx.elevation]() {
      return this.elevation;
    }
  };
  dart.defineNamedConstructor(svg$.FEDistantLightElement, 'created');
  dart.setSignature(svg$.FEDistantLightElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(svg$.FEDistantLightElement, []),
      new: dart.definiteFunctionType(svg$.FEDistantLightElement, []),
      created: dart.definiteFunctionType(svg$.FEDistantLightElement, [])
    })
  });
  dart.registerExtension(dart.global.SVGFEDistantLightElement, svg$.FEDistantLightElement);
  dart.defineExtensionNames([
    'height',
    'result',
    'width',
    'x',
    'y'
  ]);
  svg$.FEFloodElement = class FEFloodElement extends svg$.SvgElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return svg$.FEFloodElement._check(svg$._SvgElementFactoryProvider.createSvgElement_tag("feFlood"));
    }
    created() {
      this[dartx.height] = null;
      this[dartx.result] = null;
      this[dartx.width] = null;
      this[dartx.x] = null;
      this[dartx.y] = null;
      super.created();
    }
    static get supported() {
      return dart.test(svg$.SvgElement.isTagSupported('feFlood')) && svg$.FEFloodElement.is(svg$.SvgElement.tag('feFlood'));
    }
    get [dartx.height]() {
      return this.height;
    }
    get [dartx.result]() {
      return this.result;
    }
    get [dartx.width]() {
      return this.width;
    }
    get [dartx.x]() {
      return this.x;
    }
    get [dartx.y]() {
      return this.y;
    }
  };
  dart.defineNamedConstructor(svg$.FEFloodElement, 'created');
  svg$.FEFloodElement[dart.implements] = () => [svg$.FilterPrimitiveStandardAttributes];
  dart.setSignature(svg$.FEFloodElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(svg$.FEFloodElement, []),
      new: dart.definiteFunctionType(svg$.FEFloodElement, []),
      created: dart.definiteFunctionType(svg$.FEFloodElement, [])
    })
  });
  dart.registerExtension(dart.global.SVGFEFloodElement, svg$.FEFloodElement);
  svg$._SVGComponentTransferFunctionElement = class _SVGComponentTransferFunctionElement extends svg$.SvgElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    created() {
      super.created();
    }
  };
  dart.defineNamedConstructor(svg$._SVGComponentTransferFunctionElement, 'created');
  dart.setSignature(svg$._SVGComponentTransferFunctionElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(svg$._SVGComponentTransferFunctionElement, []),
      created: dart.definiteFunctionType(svg$._SVGComponentTransferFunctionElement, [])
    })
  });
  dart.registerExtension(dart.global.SVGComponentTransferFunctionElement, svg$._SVGComponentTransferFunctionElement);
  svg$.FEFuncAElement = class FEFuncAElement extends svg$._SVGComponentTransferFunctionElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return svg$.FEFuncAElement._check(svg$._SvgElementFactoryProvider.createSvgElement_tag("feFuncA"));
    }
    created() {
      super.created();
    }
    static get supported() {
      return dart.test(svg$.SvgElement.isTagSupported('feFuncA')) && svg$.FEFuncAElement.is(svg$.SvgElement.tag('feFuncA'));
    }
  };
  dart.defineNamedConstructor(svg$.FEFuncAElement, 'created');
  dart.setSignature(svg$.FEFuncAElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(svg$.FEFuncAElement, []),
      new: dart.definiteFunctionType(svg$.FEFuncAElement, []),
      created: dart.definiteFunctionType(svg$.FEFuncAElement, [])
    })
  });
  dart.registerExtension(dart.global.SVGFEFuncAElement, svg$.FEFuncAElement);
  svg$.FEFuncBElement = class FEFuncBElement extends svg$._SVGComponentTransferFunctionElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return svg$.FEFuncBElement._check(svg$._SvgElementFactoryProvider.createSvgElement_tag("feFuncB"));
    }
    created() {
      super.created();
    }
    static get supported() {
      return dart.test(svg$.SvgElement.isTagSupported('feFuncB')) && svg$.FEFuncBElement.is(svg$.SvgElement.tag('feFuncB'));
    }
  };
  dart.defineNamedConstructor(svg$.FEFuncBElement, 'created');
  dart.setSignature(svg$.FEFuncBElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(svg$.FEFuncBElement, []),
      new: dart.definiteFunctionType(svg$.FEFuncBElement, []),
      created: dart.definiteFunctionType(svg$.FEFuncBElement, [])
    })
  });
  dart.registerExtension(dart.global.SVGFEFuncBElement, svg$.FEFuncBElement);
  svg$.FEFuncGElement = class FEFuncGElement extends svg$._SVGComponentTransferFunctionElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return svg$.FEFuncGElement._check(svg$._SvgElementFactoryProvider.createSvgElement_tag("feFuncG"));
    }
    created() {
      super.created();
    }
    static get supported() {
      return dart.test(svg$.SvgElement.isTagSupported('feFuncG')) && svg$.FEFuncGElement.is(svg$.SvgElement.tag('feFuncG'));
    }
  };
  dart.defineNamedConstructor(svg$.FEFuncGElement, 'created');
  dart.setSignature(svg$.FEFuncGElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(svg$.FEFuncGElement, []),
      new: dart.definiteFunctionType(svg$.FEFuncGElement, []),
      created: dart.definiteFunctionType(svg$.FEFuncGElement, [])
    })
  });
  dart.registerExtension(dart.global.SVGFEFuncGElement, svg$.FEFuncGElement);
  svg$.FEFuncRElement = class FEFuncRElement extends svg$._SVGComponentTransferFunctionElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return svg$.FEFuncRElement._check(svg$._SvgElementFactoryProvider.createSvgElement_tag("feFuncR"));
    }
    created() {
      super.created();
    }
    static get supported() {
      return dart.test(svg$.SvgElement.isTagSupported('feFuncR')) && svg$.FEFuncRElement.is(svg$.SvgElement.tag('feFuncR'));
    }
  };
  dart.defineNamedConstructor(svg$.FEFuncRElement, 'created');
  dart.setSignature(svg$.FEFuncRElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(svg$.FEFuncRElement, []),
      new: dart.definiteFunctionType(svg$.FEFuncRElement, []),
      created: dart.definiteFunctionType(svg$.FEFuncRElement, [])
    })
  });
  dart.registerExtension(dart.global.SVGFEFuncRElement, svg$.FEFuncRElement);
  dart.defineExtensionNames([
    'setStdDeviation',
    'in1',
    'stdDeviationX',
    'stdDeviationY',
    'height',
    'result',
    'width',
    'x',
    'y'
  ]);
  svg$.FEGaussianBlurElement = class FEGaussianBlurElement extends svg$.SvgElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return svg$.FEGaussianBlurElement._check(svg$._SvgElementFactoryProvider.createSvgElement_tag("feGaussianBlur"));
    }
    created() {
      this[dartx.in1] = null;
      this[dartx.stdDeviationX] = null;
      this[dartx.stdDeviationY] = null;
      this[dartx.height] = null;
      this[dartx.result] = null;
      this[dartx.width] = null;
      this[dartx.x] = null;
      this[dartx.y] = null;
      super.created();
    }
    static get supported() {
      return dart.test(svg$.SvgElement.isTagSupported('feGaussianBlur')) && svg$.FEGaussianBlurElement.is(svg$.SvgElement.tag('feGaussianBlur'));
    }
    get [dartx.in1]() {
      return this.in1;
    }
    get [dartx.stdDeviationX]() {
      return this.stdDeviationX;
    }
    get [dartx.stdDeviationY]() {
      return this.stdDeviationY;
    }
    [dartx.setStdDeviation](stdDeviationX, stdDeviationY) {
      return this.setStdDeviation(stdDeviationX, stdDeviationY);
    }
    get [dartx.height]() {
      return this.height;
    }
    get [dartx.result]() {
      return this.result;
    }
    get [dartx.width]() {
      return this.width;
    }
    get [dartx.x]() {
      return this.x;
    }
    get [dartx.y]() {
      return this.y;
    }
  };
  dart.defineNamedConstructor(svg$.FEGaussianBlurElement, 'created');
  svg$.FEGaussianBlurElement[dart.implements] = () => [svg$.FilterPrimitiveStandardAttributes];
  dart.setSignature(svg$.FEGaussianBlurElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(svg$.FEGaussianBlurElement, []),
      new: dart.definiteFunctionType(svg$.FEGaussianBlurElement, []),
      created: dart.definiteFunctionType(svg$.FEGaussianBlurElement, [])
    }),
    methods: () => ({[dartx.setStdDeviation]: dart.definiteFunctionType(dart.void, [core.num, core.num])})
  });
  dart.registerExtension(dart.global.SVGFEGaussianBlurElement, svg$.FEGaussianBlurElement);
  dart.defineExtensionNames([
    'preserveAspectRatio',
    'height',
    'result',
    'width',
    'x',
    'y',
    'href'
  ]);
  svg$.FEImageElement = class FEImageElement extends svg$.SvgElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return svg$.FEImageElement._check(svg$._SvgElementFactoryProvider.createSvgElement_tag("feImage"));
    }
    created() {
      this[dartx.preserveAspectRatio] = null;
      this[dartx.height] = null;
      this[dartx.result] = null;
      this[dartx.width] = null;
      this[dartx.x] = null;
      this[dartx.y] = null;
      this[dartx.href] = null;
      super.created();
    }
    static get supported() {
      return dart.test(svg$.SvgElement.isTagSupported('feImage')) && svg$.FEImageElement.is(svg$.SvgElement.tag('feImage'));
    }
    get [dartx.preserveAspectRatio]() {
      return this.preserveAspectRatio;
    }
    get [dartx.height]() {
      return this.height;
    }
    get [dartx.result]() {
      return this.result;
    }
    get [dartx.width]() {
      return this.width;
    }
    get [dartx.x]() {
      return this.x;
    }
    get [dartx.y]() {
      return this.y;
    }
    get [dartx.href]() {
      return this.href;
    }
  };
  dart.defineNamedConstructor(svg$.FEImageElement, 'created');
  svg$.FEImageElement[dart.implements] = () => [svg$.FilterPrimitiveStandardAttributes, svg$.UriReference];
  dart.setSignature(svg$.FEImageElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(svg$.FEImageElement, []),
      new: dart.definiteFunctionType(svg$.FEImageElement, []),
      created: dart.definiteFunctionType(svg$.FEImageElement, [])
    })
  });
  dart.registerExtension(dart.global.SVGFEImageElement, svg$.FEImageElement);
  dart.defineExtensionNames([
    'height',
    'result',
    'width',
    'x',
    'y'
  ]);
  svg$.FEMergeElement = class FEMergeElement extends svg$.SvgElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return svg$.FEMergeElement._check(svg$._SvgElementFactoryProvider.createSvgElement_tag("feMerge"));
    }
    created() {
      this[dartx.height] = null;
      this[dartx.result] = null;
      this[dartx.width] = null;
      this[dartx.x] = null;
      this[dartx.y] = null;
      super.created();
    }
    static get supported() {
      return dart.test(svg$.SvgElement.isTagSupported('feMerge')) && svg$.FEMergeElement.is(svg$.SvgElement.tag('feMerge'));
    }
    get [dartx.height]() {
      return this.height;
    }
    get [dartx.result]() {
      return this.result;
    }
    get [dartx.width]() {
      return this.width;
    }
    get [dartx.x]() {
      return this.x;
    }
    get [dartx.y]() {
      return this.y;
    }
  };
  dart.defineNamedConstructor(svg$.FEMergeElement, 'created');
  svg$.FEMergeElement[dart.implements] = () => [svg$.FilterPrimitiveStandardAttributes];
  dart.setSignature(svg$.FEMergeElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(svg$.FEMergeElement, []),
      new: dart.definiteFunctionType(svg$.FEMergeElement, []),
      created: dart.definiteFunctionType(svg$.FEMergeElement, [])
    })
  });
  dart.registerExtension(dart.global.SVGFEMergeElement, svg$.FEMergeElement);
  dart.defineExtensionNames([
    'in1'
  ]);
  svg$.FEMergeNodeElement = class FEMergeNodeElement extends svg$.SvgElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return svg$.FEMergeNodeElement._check(svg$._SvgElementFactoryProvider.createSvgElement_tag("feMergeNode"));
    }
    created() {
      this[dartx.in1] = null;
      super.created();
    }
    static get supported() {
      return dart.test(svg$.SvgElement.isTagSupported('feMergeNode')) && svg$.FEMergeNodeElement.is(svg$.SvgElement.tag('feMergeNode'));
    }
    get [dartx.in1]() {
      return this.in1;
    }
  };
  dart.defineNamedConstructor(svg$.FEMergeNodeElement, 'created');
  dart.setSignature(svg$.FEMergeNodeElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(svg$.FEMergeNodeElement, []),
      new: dart.definiteFunctionType(svg$.FEMergeNodeElement, []),
      created: dart.definiteFunctionType(svg$.FEMergeNodeElement, [])
    })
  });
  dart.registerExtension(dart.global.SVGFEMergeNodeElement, svg$.FEMergeNodeElement);
  dart.defineExtensionNames([
    'in1',
    'operator',
    'radiusX',
    'radiusY',
    'height',
    'result',
    'width',
    'x',
    'y'
  ]);
  svg$.FEMorphologyElement = class FEMorphologyElement extends svg$.SvgElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    created() {
      this[dartx.in1] = null;
      this[dartx.operator] = null;
      this[dartx.radiusX] = null;
      this[dartx.radiusY] = null;
      this[dartx.height] = null;
      this[dartx.result] = null;
      this[dartx.width] = null;
      this[dartx.x] = null;
      this[dartx.y] = null;
      super.created();
    }
    get [dartx.in1]() {
      return this.in1;
    }
    get [dartx.operator]() {
      return this.operator;
    }
    get [dartx.radiusX]() {
      return this.radiusX;
    }
    get [dartx.radiusY]() {
      return this.radiusY;
    }
    get [dartx.height]() {
      return this.height;
    }
    get [dartx.result]() {
      return this.result;
    }
    get [dartx.width]() {
      return this.width;
    }
    get [dartx.x]() {
      return this.x;
    }
    get [dartx.y]() {
      return this.y;
    }
  };
  dart.defineNamedConstructor(svg$.FEMorphologyElement, 'created');
  svg$.FEMorphologyElement[dart.implements] = () => [svg$.FilterPrimitiveStandardAttributes];
  dart.setSignature(svg$.FEMorphologyElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(svg$.FEMorphologyElement, []),
      created: dart.definiteFunctionType(svg$.FEMorphologyElement, [])
    })
  });
  svg$.FEMorphologyElement.SVG_MORPHOLOGY_OPERATOR_DILATE = 2;
  svg$.FEMorphologyElement.SVG_MORPHOLOGY_OPERATOR_ERODE = 1;
  svg$.FEMorphologyElement.SVG_MORPHOLOGY_OPERATOR_UNKNOWN = 0;
  dart.registerExtension(dart.global.SVGFEMorphologyElement, svg$.FEMorphologyElement);
  dart.defineExtensionNames([
    'dx',
    'dy',
    'in1',
    'height',
    'result',
    'width',
    'x',
    'y'
  ]);
  svg$.FEOffsetElement = class FEOffsetElement extends svg$.SvgElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return svg$.FEOffsetElement._check(svg$._SvgElementFactoryProvider.createSvgElement_tag("feOffset"));
    }
    created() {
      this[dartx.dx] = null;
      this[dartx.dy] = null;
      this[dartx.in1] = null;
      this[dartx.height] = null;
      this[dartx.result] = null;
      this[dartx.width] = null;
      this[dartx.x] = null;
      this[dartx.y] = null;
      super.created();
    }
    static get supported() {
      return dart.test(svg$.SvgElement.isTagSupported('feOffset')) && svg$.FEOffsetElement.is(svg$.SvgElement.tag('feOffset'));
    }
    get [dartx.dx]() {
      return this.dx;
    }
    get [dartx.dy]() {
      return this.dy;
    }
    get [dartx.in1]() {
      return this.in1;
    }
    get [dartx.height]() {
      return this.height;
    }
    get [dartx.result]() {
      return this.result;
    }
    get [dartx.width]() {
      return this.width;
    }
    get [dartx.x]() {
      return this.x;
    }
    get [dartx.y]() {
      return this.y;
    }
  };
  dart.defineNamedConstructor(svg$.FEOffsetElement, 'created');
  svg$.FEOffsetElement[dart.implements] = () => [svg$.FilterPrimitiveStandardAttributes];
  dart.setSignature(svg$.FEOffsetElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(svg$.FEOffsetElement, []),
      new: dart.definiteFunctionType(svg$.FEOffsetElement, []),
      created: dart.definiteFunctionType(svg$.FEOffsetElement, [])
    })
  });
  dart.registerExtension(dart.global.SVGFEOffsetElement, svg$.FEOffsetElement);
  dart.defineExtensionNames([
    'x',
    'y',
    'z'
  ]);
  svg$.FEPointLightElement = class FEPointLightElement extends svg$.SvgElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return svg$.FEPointLightElement._check(svg$._SvgElementFactoryProvider.createSvgElement_tag("fePointLight"));
    }
    created() {
      this[dartx.x] = null;
      this[dartx.y] = null;
      this[dartx.z] = null;
      super.created();
    }
    static get supported() {
      return dart.test(svg$.SvgElement.isTagSupported('fePointLight')) && svg$.FEPointLightElement.is(svg$.SvgElement.tag('fePointLight'));
    }
    get [dartx.x]() {
      return this.x;
    }
    get [dartx.y]() {
      return this.y;
    }
    get [dartx.z]() {
      return this.z;
    }
  };
  dart.defineNamedConstructor(svg$.FEPointLightElement, 'created');
  dart.setSignature(svg$.FEPointLightElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(svg$.FEPointLightElement, []),
      new: dart.definiteFunctionType(svg$.FEPointLightElement, []),
      created: dart.definiteFunctionType(svg$.FEPointLightElement, [])
    })
  });
  dart.registerExtension(dart.global.SVGFEPointLightElement, svg$.FEPointLightElement);
  dart.defineExtensionNames([
    'in1',
    'kernelUnitLengthX',
    'kernelUnitLengthY',
    'specularConstant',
    'specularExponent',
    'surfaceScale',
    'height',
    'result',
    'width',
    'x',
    'y'
  ]);
  svg$.FESpecularLightingElement = class FESpecularLightingElement extends svg$.SvgElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return svg$.FESpecularLightingElement._check(svg$._SvgElementFactoryProvider.createSvgElement_tag("feSpecularLighting"));
    }
    created() {
      this[dartx.in1] = null;
      this[dartx.kernelUnitLengthX] = null;
      this[dartx.kernelUnitLengthY] = null;
      this[dartx.specularConstant] = null;
      this[dartx.specularExponent] = null;
      this[dartx.surfaceScale] = null;
      this[dartx.height] = null;
      this[dartx.result] = null;
      this[dartx.width] = null;
      this[dartx.x] = null;
      this[dartx.y] = null;
      super.created();
    }
    static get supported() {
      return dart.test(svg$.SvgElement.isTagSupported('feSpecularLighting')) && svg$.FESpecularLightingElement.is(svg$.SvgElement.tag('feSpecularLighting'));
    }
    get [dartx.in1]() {
      return this.in1;
    }
    get [dartx.kernelUnitLengthX]() {
      return this.kernelUnitLengthX;
    }
    get [dartx.kernelUnitLengthY]() {
      return this.kernelUnitLengthY;
    }
    get [dartx.specularConstant]() {
      return this.specularConstant;
    }
    get [dartx.specularExponent]() {
      return this.specularExponent;
    }
    get [dartx.surfaceScale]() {
      return this.surfaceScale;
    }
    get [dartx.height]() {
      return this.height;
    }
    get [dartx.result]() {
      return this.result;
    }
    get [dartx.width]() {
      return this.width;
    }
    get [dartx.x]() {
      return this.x;
    }
    get [dartx.y]() {
      return this.y;
    }
  };
  dart.defineNamedConstructor(svg$.FESpecularLightingElement, 'created');
  svg$.FESpecularLightingElement[dart.implements] = () => [svg$.FilterPrimitiveStandardAttributes];
  dart.setSignature(svg$.FESpecularLightingElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(svg$.FESpecularLightingElement, []),
      new: dart.definiteFunctionType(svg$.FESpecularLightingElement, []),
      created: dart.definiteFunctionType(svg$.FESpecularLightingElement, [])
    })
  });
  dart.registerExtension(dart.global.SVGFESpecularLightingElement, svg$.FESpecularLightingElement);
  dart.defineExtensionNames([
    'limitingConeAngle',
    'pointsAtX',
    'pointsAtY',
    'pointsAtZ',
    'specularExponent',
    'x',
    'y',
    'z'
  ]);
  svg$.FESpotLightElement = class FESpotLightElement extends svg$.SvgElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return svg$.FESpotLightElement._check(svg$._SvgElementFactoryProvider.createSvgElement_tag("feSpotLight"));
    }
    created() {
      this[dartx.limitingConeAngle] = null;
      this[dartx.pointsAtX] = null;
      this[dartx.pointsAtY] = null;
      this[dartx.pointsAtZ] = null;
      this[dartx.specularExponent] = null;
      this[dartx.x] = null;
      this[dartx.y] = null;
      this[dartx.z] = null;
      super.created();
    }
    static get supported() {
      return dart.test(svg$.SvgElement.isTagSupported('feSpotLight')) && svg$.FESpotLightElement.is(svg$.SvgElement.tag('feSpotLight'));
    }
    get [dartx.limitingConeAngle]() {
      return this.limitingConeAngle;
    }
    get [dartx.pointsAtX]() {
      return this.pointsAtX;
    }
    get [dartx.pointsAtY]() {
      return this.pointsAtY;
    }
    get [dartx.pointsAtZ]() {
      return this.pointsAtZ;
    }
    get [dartx.specularExponent]() {
      return this.specularExponent;
    }
    get [dartx.x]() {
      return this.x;
    }
    get [dartx.y]() {
      return this.y;
    }
    get [dartx.z]() {
      return this.z;
    }
  };
  dart.defineNamedConstructor(svg$.FESpotLightElement, 'created');
  dart.setSignature(svg$.FESpotLightElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(svg$.FESpotLightElement, []),
      new: dart.definiteFunctionType(svg$.FESpotLightElement, []),
      created: dart.definiteFunctionType(svg$.FESpotLightElement, [])
    })
  });
  dart.registerExtension(dart.global.SVGFESpotLightElement, svg$.FESpotLightElement);
  dart.defineExtensionNames([
    'in1',
    'height',
    'result',
    'width',
    'x',
    'y'
  ]);
  svg$.FETileElement = class FETileElement extends svg$.SvgElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return svg$.FETileElement._check(svg$._SvgElementFactoryProvider.createSvgElement_tag("feTile"));
    }
    created() {
      this[dartx.in1] = null;
      this[dartx.height] = null;
      this[dartx.result] = null;
      this[dartx.width] = null;
      this[dartx.x] = null;
      this[dartx.y] = null;
      super.created();
    }
    static get supported() {
      return dart.test(svg$.SvgElement.isTagSupported('feTile')) && svg$.FETileElement.is(svg$.SvgElement.tag('feTile'));
    }
    get [dartx.in1]() {
      return this.in1;
    }
    get [dartx.height]() {
      return this.height;
    }
    get [dartx.result]() {
      return this.result;
    }
    get [dartx.width]() {
      return this.width;
    }
    get [dartx.x]() {
      return this.x;
    }
    get [dartx.y]() {
      return this.y;
    }
  };
  dart.defineNamedConstructor(svg$.FETileElement, 'created');
  svg$.FETileElement[dart.implements] = () => [svg$.FilterPrimitiveStandardAttributes];
  dart.setSignature(svg$.FETileElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(svg$.FETileElement, []),
      new: dart.definiteFunctionType(svg$.FETileElement, []),
      created: dart.definiteFunctionType(svg$.FETileElement, [])
    })
  });
  dart.registerExtension(dart.global.SVGFETileElement, svg$.FETileElement);
  dart.defineExtensionNames([
    'baseFrequencyX',
    'baseFrequencyY',
    'numOctaves',
    'seed',
    'stitchTiles',
    'type',
    'height',
    'result',
    'width',
    'x',
    'y'
  ]);
  svg$.FETurbulenceElement = class FETurbulenceElement extends svg$.SvgElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return svg$.FETurbulenceElement._check(svg$._SvgElementFactoryProvider.createSvgElement_tag("feTurbulence"));
    }
    created() {
      this[dartx.baseFrequencyX] = null;
      this[dartx.baseFrequencyY] = null;
      this[dartx.numOctaves] = null;
      this[dartx.seed] = null;
      this[dartx.stitchTiles] = null;
      this[dartx.type] = null;
      this[dartx.height] = null;
      this[dartx.result] = null;
      this[dartx.width] = null;
      this[dartx.x] = null;
      this[dartx.y] = null;
      super.created();
    }
    static get supported() {
      return dart.test(svg$.SvgElement.isTagSupported('feTurbulence')) && svg$.FETurbulenceElement.is(svg$.SvgElement.tag('feTurbulence'));
    }
    get [dartx.baseFrequencyX]() {
      return this.baseFrequencyX;
    }
    get [dartx.baseFrequencyY]() {
      return this.baseFrequencyY;
    }
    get [dartx.numOctaves]() {
      return this.numOctaves;
    }
    get [dartx.seed]() {
      return this.seed;
    }
    get [dartx.stitchTiles]() {
      return this.stitchTiles;
    }
    get [dartx.type]() {
      return this.type;
    }
    get [dartx.height]() {
      return this.height;
    }
    get [dartx.result]() {
      return this.result;
    }
    get [dartx.width]() {
      return this.width;
    }
    get [dartx.x]() {
      return this.x;
    }
    get [dartx.y]() {
      return this.y;
    }
  };
  dart.defineNamedConstructor(svg$.FETurbulenceElement, 'created');
  svg$.FETurbulenceElement[dart.implements] = () => [svg$.FilterPrimitiveStandardAttributes];
  dart.setSignature(svg$.FETurbulenceElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(svg$.FETurbulenceElement, []),
      new: dart.definiteFunctionType(svg$.FETurbulenceElement, []),
      created: dart.definiteFunctionType(svg$.FETurbulenceElement, [])
    })
  });
  svg$.FETurbulenceElement.SVG_STITCHTYPE_NOSTITCH = 2;
  svg$.FETurbulenceElement.SVG_STITCHTYPE_STITCH = 1;
  svg$.FETurbulenceElement.SVG_STITCHTYPE_UNKNOWN = 0;
  svg$.FETurbulenceElement.SVG_TURBULENCE_TYPE_FRACTALNOISE = 1;
  svg$.FETurbulenceElement.SVG_TURBULENCE_TYPE_TURBULENCE = 2;
  svg$.FETurbulenceElement.SVG_TURBULENCE_TYPE_UNKNOWN = 0;
  dart.registerExtension(dart.global.SVGFETurbulenceElement, svg$.FETurbulenceElement);
  dart.defineExtensionNames([
    'filterUnits',
    'height',
    'primitiveUnits',
    'width',
    'x',
    'y',
    'href'
  ]);
  svg$.FilterElement = class FilterElement extends svg$.SvgElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return svg$.FilterElement._check(svg$._SvgElementFactoryProvider.createSvgElement_tag("filter"));
    }
    created() {
      this[dartx.filterUnits] = null;
      this[dartx.height] = null;
      this[dartx.primitiveUnits] = null;
      this[dartx.width] = null;
      this[dartx.x] = null;
      this[dartx.y] = null;
      this[dartx.href] = null;
      super.created();
    }
    static get supported() {
      return dart.test(svg$.SvgElement.isTagSupported('filter')) && svg$.FilterElement.is(svg$.SvgElement.tag('filter'));
    }
    get [dartx.filterUnits]() {
      return this.filterUnits;
    }
    get [dartx.height]() {
      return this.height;
    }
    get [dartx.primitiveUnits]() {
      return this.primitiveUnits;
    }
    get [dartx.width]() {
      return this.width;
    }
    get [dartx.x]() {
      return this.x;
    }
    get [dartx.y]() {
      return this.y;
    }
    get [dartx.href]() {
      return this.href;
    }
  };
  dart.defineNamedConstructor(svg$.FilterElement, 'created');
  svg$.FilterElement[dart.implements] = () => [svg$.UriReference];
  dart.setSignature(svg$.FilterElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(svg$.FilterElement, []),
      new: dart.definiteFunctionType(svg$.FilterElement, []),
      created: dart.definiteFunctionType(svg$.FilterElement, [])
    })
  });
  dart.registerExtension(dart.global.SVGFilterElement, svg$.FilterElement);
  dart.defineExtensionNames([
    'height',
    'result',
    'width',
    'x',
    'y'
  ]);
  svg$.FilterPrimitiveStandardAttributes = class FilterPrimitiveStandardAttributes extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(svg$.FilterPrimitiveStandardAttributes, {
    constructors: () => ({_: dart.definiteFunctionType(svg$.FilterPrimitiveStandardAttributes, [])})
  });
  dart.defineExtensionMembers(svg$.FilterPrimitiveStandardAttributes, [
    'height',
    'result',
    'width',
    'x',
    'y'
  ]);
  dart.defineExtensionNames([
    'preserveAspectRatio',
    'viewBox'
  ]);
  svg$.FitToViewBox = class FitToViewBox extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(svg$.FitToViewBox, {
    constructors: () => ({_: dart.definiteFunctionType(svg$.FitToViewBox, [])})
  });
  dart.defineExtensionMembers(svg$.FitToViewBox, ['preserveAspectRatio', 'viewBox']);
  dart.defineExtensionNames([
    'height',
    'width',
    'x',
    'y'
  ]);
  svg$.ForeignObjectElement = class ForeignObjectElement extends svg$.GraphicsElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return svg$.ForeignObjectElement._check(svg$._SvgElementFactoryProvider.createSvgElement_tag("foreignObject"));
    }
    created() {
      this[dartx.height] = null;
      this[dartx.width] = null;
      this[dartx.x] = null;
      this[dartx.y] = null;
      super.created();
    }
    static get supported() {
      return dart.test(svg$.SvgElement.isTagSupported('foreignObject')) && svg$.ForeignObjectElement.is(svg$.SvgElement.tag('foreignObject'));
    }
    get [dartx.height]() {
      return this.height;
    }
    get [dartx.width]() {
      return this.width;
    }
    get [dartx.x]() {
      return this.x;
    }
    get [dartx.y]() {
      return this.y;
    }
  };
  dart.defineNamedConstructor(svg$.ForeignObjectElement, 'created');
  dart.setSignature(svg$.ForeignObjectElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(svg$.ForeignObjectElement, []),
      new: dart.definiteFunctionType(svg$.ForeignObjectElement, []),
      created: dart.definiteFunctionType(svg$.ForeignObjectElement, [])
    })
  });
  dart.registerExtension(dart.global.SVGForeignObjectElement, svg$.ForeignObjectElement);
  svg$.GElement = class GElement extends svg$.GraphicsElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return svg$.GElement._check(svg$._SvgElementFactoryProvider.createSvgElement_tag("g"));
    }
    created() {
      super.created();
    }
  };
  dart.defineNamedConstructor(svg$.GElement, 'created');
  dart.setSignature(svg$.GElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(svg$.GElement, []),
      new: dart.definiteFunctionType(svg$.GElement, []),
      created: dart.definiteFunctionType(svg$.GElement, [])
    })
  });
  dart.registerExtension(dart.global.SVGGElement, svg$.GElement);
  dart.defineExtensionNames([
    'height',
    'preserveAspectRatio',
    'width',
    'x',
    'y',
    'href'
  ]);
  svg$.ImageElement = class ImageElement extends svg$.GraphicsElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return svg$.ImageElement._check(svg$._SvgElementFactoryProvider.createSvgElement_tag("image"));
    }
    created() {
      this[dartx.height] = null;
      this[dartx.preserveAspectRatio] = null;
      this[dartx.width] = null;
      this[dartx.x] = null;
      this[dartx.y] = null;
      this[dartx.href] = null;
      super.created();
    }
    get [dartx.height]() {
      return this.height;
    }
    get [dartx.preserveAspectRatio]() {
      return this.preserveAspectRatio;
    }
    get [dartx.width]() {
      return this.width;
    }
    get [dartx.x]() {
      return this.x;
    }
    get [dartx.y]() {
      return this.y;
    }
    get [dartx.href]() {
      return this.href;
    }
  };
  dart.defineNamedConstructor(svg$.ImageElement, 'created');
  svg$.ImageElement[dart.implements] = () => [svg$.UriReference];
  dart.setSignature(svg$.ImageElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(svg$.ImageElement, []),
      new: dart.definiteFunctionType(svg$.ImageElement, []),
      created: dart.definiteFunctionType(svg$.ImageElement, [])
    })
  });
  dart.registerExtension(dart.global.SVGImageElement, svg$.ImageElement);
  dart.defineExtensionNames([
    'convertToSpecifiedUnits',
    'newValueSpecifiedUnits',
    'unitType',
    'value',
    'valueAsString',
    'valueInSpecifiedUnits'
  ]);
  svg$.Length = class Length extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.unitType]() {
      return this.unitType;
    }
    get [dartx.value]() {
      return this.value;
    }
    set [dartx.value](value) {
      this.value = value;
    }
    get [dartx.valueAsString]() {
      return this.valueAsString;
    }
    set [dartx.valueAsString](value) {
      this.valueAsString = value;
    }
    get [dartx.valueInSpecifiedUnits]() {
      return this.valueInSpecifiedUnits;
    }
    set [dartx.valueInSpecifiedUnits](value) {
      this.valueInSpecifiedUnits = value;
    }
    [dartx.convertToSpecifiedUnits](unitType) {
      return this.convertToSpecifiedUnits(unitType);
    }
    [dartx.newValueSpecifiedUnits](unitType, valueInSpecifiedUnits) {
      return this.newValueSpecifiedUnits(unitType, valueInSpecifiedUnits);
    }
  };
  dart.setSignature(svg$.Length, {
    constructors: () => ({_: dart.definiteFunctionType(svg$.Length, [])}),
    methods: () => ({
      [dartx.convertToSpecifiedUnits]: dart.definiteFunctionType(dart.void, [core.int]),
      [dartx.newValueSpecifiedUnits]: dart.definiteFunctionType(dart.void, [core.int, core.num])
    })
  });
  svg$.Length.SVG_LENGTHTYPE_CM = 6;
  svg$.Length.SVG_LENGTHTYPE_EMS = 3;
  svg$.Length.SVG_LENGTHTYPE_EXS = 4;
  svg$.Length.SVG_LENGTHTYPE_IN = 8;
  svg$.Length.SVG_LENGTHTYPE_MM = 7;
  svg$.Length.SVG_LENGTHTYPE_NUMBER = 1;
  svg$.Length.SVG_LENGTHTYPE_PC = 10;
  svg$.Length.SVG_LENGTHTYPE_PERCENTAGE = 2;
  svg$.Length.SVG_LENGTHTYPE_PT = 9;
  svg$.Length.SVG_LENGTHTYPE_PX = 5;
  svg$.Length.SVG_LENGTHTYPE_UNKNOWN = 0;
  dart.registerExtension(dart.global.SVGLength, svg$.Length);
  const __setter__$ = Symbol('__setter__');
  dart.defineExtensionNames([
    'length',
    'get',
    'set',
    'length',
    'first',
    'last',
    'single',
    'elementAt',
    'appendItem',
    'clear',
    'getItem',
    'initialize',
    'insertItemBefore',
    'removeItem',
    'replaceItem',
    'numberOfItems'
  ]);
  svg$.LengthList = class LengthList extends dart.mixin(_interceptors.Interceptor, collection.ListMixin$(svg$.Length), html$.ImmutableListMixin$(svg$.Length)) {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.length]() {
      return this.length;
    }
    get [dartx.numberOfItems]() {
      return this.numberOfItems;
    }
    [dartx.get](index) {
      if (index >>> 0 !== index || index >= this[dartx.length]) dart.throw(core.RangeError.index(index, this));
      return this[dartx.getItem](index);
    }
    [dartx.set](index, value) {
      dart.throw(new core.UnsupportedError("Cannot assign element of immutable List."));
      return value;
    }
    set [dartx.length](value) {
      dart.throw(new core.UnsupportedError("Cannot resize immutable List."));
    }
    get [dartx.first]() {
      if (dart.notNull(this[dartx.length]) > 0) {
        return this[0];
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.last]() {
      let len = this[dartx.length];
      if (dart.notNull(len) > 0) {
        return this[dart.notNull(len) - 1];
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.single]() {
      let len = this[dartx.length];
      if (len == 1) {
        return this[0];
      }
      if (len == 0) dart.throw(new core.StateError("No elements"));
      dart.throw(new core.StateError("More than one element"));
    }
    [dartx.elementAt](index) {
      return this[dartx.get](index);
    }
    [__setter__$](index, newItem) {
      return this.__setter__(index, newItem);
    }
    [dartx.appendItem](newItem) {
      return this.appendItem(newItem);
    }
    [dartx.clear]() {
      return this.clear();
    }
    [dartx.getItem](index) {
      return this.getItem(index);
    }
    [dartx.initialize](newItem) {
      return this.initialize(newItem);
    }
    [dartx.insertItemBefore](newItem, index) {
      return this.insertItemBefore(newItem, index);
    }
    [dartx.removeItem](index) {
      return this.removeItem(index);
    }
    [dartx.replaceItem](newItem, index) {
      return this.replaceItem(newItem, index);
    }
  };
  svg$.LengthList[dart.implements] = () => [ListOfLength()];
  dart.setSignature(svg$.LengthList, {
    constructors: () => ({_: dart.definiteFunctionType(svg$.LengthList, [])}),
    methods: () => ({
      [dartx.get]: dart.definiteFunctionType(svg$.Length, [core.int]),
      [dartx.set]: dart.definiteFunctionType(dart.void, [core.int, svg$.Length]),
      [dartx.elementAt]: dart.definiteFunctionType(svg$.Length, [core.int]),
      [__setter__$]: dart.definiteFunctionType(dart.void, [core.int, svg$.Length]),
      [dartx.appendItem]: dart.definiteFunctionType(svg$.Length, [svg$.Length]),
      [dartx.getItem]: dart.definiteFunctionType(svg$.Length, [core.int]),
      [dartx.initialize]: dart.definiteFunctionType(svg$.Length, [svg$.Length]),
      [dartx.insertItemBefore]: dart.definiteFunctionType(svg$.Length, [svg$.Length, core.int]),
      [dartx.removeItem]: dart.definiteFunctionType(svg$.Length, [core.int]),
      [dartx.replaceItem]: dart.definiteFunctionType(svg$.Length, [svg$.Length, core.int])
    })
  });
  dart.registerExtension(dart.global.SVGLengthList, svg$.LengthList);
  dart.defineExtensionNames([
    'x1',
    'x2',
    'y1',
    'y2'
  ]);
  svg$.LineElement = class LineElement extends svg$.GeometryElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return svg$.LineElement._check(svg$._SvgElementFactoryProvider.createSvgElement_tag("line"));
    }
    created() {
      this[dartx.x1] = null;
      this[dartx.x2] = null;
      this[dartx.y1] = null;
      this[dartx.y2] = null;
      super.created();
    }
    get [dartx.x1]() {
      return this.x1;
    }
    get [dartx.x2]() {
      return this.x2;
    }
    get [dartx.y1]() {
      return this.y1;
    }
    get [dartx.y2]() {
      return this.y2;
    }
  };
  dart.defineNamedConstructor(svg$.LineElement, 'created');
  dart.setSignature(svg$.LineElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(svg$.LineElement, []),
      new: dart.definiteFunctionType(svg$.LineElement, []),
      created: dart.definiteFunctionType(svg$.LineElement, [])
    })
  });
  dart.registerExtension(dart.global.SVGLineElement, svg$.LineElement);
  dart.defineExtensionNames([
    'gradientTransform',
    'gradientUnits',
    'spreadMethod',
    'href'
  ]);
  svg$._GradientElement = class _GradientElement extends svg$.SvgElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    created() {
      this[dartx.gradientTransform] = null;
      this[dartx.gradientUnits] = null;
      this[dartx.spreadMethod] = null;
      this[dartx.href] = null;
      super.created();
    }
    get [dartx.gradientTransform]() {
      return this.gradientTransform;
    }
    get [dartx.gradientUnits]() {
      return this.gradientUnits;
    }
    get [dartx.spreadMethod]() {
      return this.spreadMethod;
    }
    get [dartx.href]() {
      return this.href;
    }
  };
  dart.defineNamedConstructor(svg$._GradientElement, 'created');
  svg$._GradientElement[dart.implements] = () => [svg$.UriReference];
  dart.setSignature(svg$._GradientElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(svg$._GradientElement, []),
      created: dart.definiteFunctionType(svg$._GradientElement, [])
    })
  });
  svg$._GradientElement.SVG_SPREADMETHOD_PAD = 1;
  svg$._GradientElement.SVG_SPREADMETHOD_REFLECT = 2;
  svg$._GradientElement.SVG_SPREADMETHOD_REPEAT = 3;
  svg$._GradientElement.SVG_SPREADMETHOD_UNKNOWN = 0;
  dart.registerExtension(dart.global.SVGGradientElement, svg$._GradientElement);
  dart.defineExtensionNames([
    'x1',
    'x2',
    'y1',
    'y2'
  ]);
  svg$.LinearGradientElement = class LinearGradientElement extends svg$._GradientElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return svg$.LinearGradientElement._check(svg$._SvgElementFactoryProvider.createSvgElement_tag("linearGradient"));
    }
    created() {
      this[dartx.x1] = null;
      this[dartx.x2] = null;
      this[dartx.y1] = null;
      this[dartx.y2] = null;
      super.created();
    }
    get [dartx.x1]() {
      return this.x1;
    }
    get [dartx.x2]() {
      return this.x2;
    }
    get [dartx.y1]() {
      return this.y1;
    }
    get [dartx.y2]() {
      return this.y2;
    }
  };
  dart.defineNamedConstructor(svg$.LinearGradientElement, 'created');
  dart.setSignature(svg$.LinearGradientElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(svg$.LinearGradientElement, []),
      new: dart.definiteFunctionType(svg$.LinearGradientElement, []),
      created: dart.definiteFunctionType(svg$.LinearGradientElement, [])
    })
  });
  dart.registerExtension(dart.global.SVGLinearGradientElement, svg$.LinearGradientElement);
  dart.defineExtensionNames([
    'setOrientToAngle',
    'setOrientToAuto',
    'markerHeight',
    'markerUnits',
    'markerWidth',
    'orientAngle',
    'orientType',
    'refX',
    'refY',
    'preserveAspectRatio',
    'viewBox'
  ]);
  svg$.MarkerElement = class MarkerElement extends svg$.SvgElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return svg$.MarkerElement._check(svg$._SvgElementFactoryProvider.createSvgElement_tag("marker"));
    }
    created() {
      this[dartx.markerHeight] = null;
      this[dartx.markerUnits] = null;
      this[dartx.markerWidth] = null;
      this[dartx.orientAngle] = null;
      this[dartx.orientType] = null;
      this[dartx.refX] = null;
      this[dartx.refY] = null;
      this[dartx.preserveAspectRatio] = null;
      this[dartx.viewBox] = null;
      super.created();
    }
    get [dartx.markerHeight]() {
      return this.markerHeight;
    }
    get [dartx.markerUnits]() {
      return this.markerUnits;
    }
    get [dartx.markerWidth]() {
      return this.markerWidth;
    }
    get [dartx.orientAngle]() {
      return this.orientAngle;
    }
    get [dartx.orientType]() {
      return this.orientType;
    }
    get [dartx.refX]() {
      return this.refX;
    }
    get [dartx.refY]() {
      return this.refY;
    }
    [dartx.setOrientToAngle](angle) {
      return this.setOrientToAngle(angle);
    }
    [dartx.setOrientToAuto]() {
      return this.setOrientToAuto();
    }
    get [dartx.preserveAspectRatio]() {
      return this.preserveAspectRatio;
    }
    get [dartx.viewBox]() {
      return this.viewBox;
    }
  };
  dart.defineNamedConstructor(svg$.MarkerElement, 'created');
  svg$.MarkerElement[dart.implements] = () => [svg$.FitToViewBox];
  dart.setSignature(svg$.MarkerElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(svg$.MarkerElement, []),
      new: dart.definiteFunctionType(svg$.MarkerElement, []),
      created: dart.definiteFunctionType(svg$.MarkerElement, [])
    }),
    methods: () => ({
      [dartx.setOrientToAngle]: dart.definiteFunctionType(dart.void, [svg$.Angle]),
      [dartx.setOrientToAuto]: dart.definiteFunctionType(dart.void, [])
    })
  });
  svg$.MarkerElement.SVG_MARKERUNITS_STROKEWIDTH = 2;
  svg$.MarkerElement.SVG_MARKERUNITS_UNKNOWN = 0;
  svg$.MarkerElement.SVG_MARKERUNITS_USERSPACEONUSE = 1;
  svg$.MarkerElement.SVG_MARKER_ORIENT_ANGLE = 2;
  svg$.MarkerElement.SVG_MARKER_ORIENT_AUTO = 1;
  svg$.MarkerElement.SVG_MARKER_ORIENT_UNKNOWN = 0;
  dart.registerExtension(dart.global.SVGMarkerElement, svg$.MarkerElement);
  dart.defineExtensionNames([
    'hasExtension',
    'height',
    'maskContentUnits',
    'maskUnits',
    'width',
    'x',
    'y',
    'requiredExtensions',
    'requiredFeatures',
    'systemLanguage'
  ]);
  svg$.MaskElement = class MaskElement extends svg$.SvgElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return svg$.MaskElement._check(svg$._SvgElementFactoryProvider.createSvgElement_tag("mask"));
    }
    created() {
      this[dartx.height] = null;
      this[dartx.maskContentUnits] = null;
      this[dartx.maskUnits] = null;
      this[dartx.width] = null;
      this[dartx.x] = null;
      this[dartx.y] = null;
      this[dartx.requiredExtensions] = null;
      this[dartx.requiredFeatures] = null;
      this[dartx.systemLanguage] = null;
      super.created();
    }
    get [dartx.height]() {
      return this.height;
    }
    get [dartx.maskContentUnits]() {
      return this.maskContentUnits;
    }
    get [dartx.maskUnits]() {
      return this.maskUnits;
    }
    get [dartx.width]() {
      return this.width;
    }
    get [dartx.x]() {
      return this.x;
    }
    get [dartx.y]() {
      return this.y;
    }
    get [dartx.requiredExtensions]() {
      return this.requiredExtensions;
    }
    get [dartx.requiredFeatures]() {
      return this.requiredFeatures;
    }
    get [dartx.systemLanguage]() {
      return this.systemLanguage;
    }
    [dartx.hasExtension](extension) {
      return this.hasExtension(extension);
    }
  };
  dart.defineNamedConstructor(svg$.MaskElement, 'created');
  svg$.MaskElement[dart.implements] = () => [svg$.Tests];
  dart.setSignature(svg$.MaskElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(svg$.MaskElement, []),
      new: dart.definiteFunctionType(svg$.MaskElement, []),
      created: dart.definiteFunctionType(svg$.MaskElement, [])
    }),
    methods: () => ({[dartx.hasExtension]: dart.definiteFunctionType(core.bool, [core.String])})
  });
  dart.registerExtension(dart.global.SVGMaskElement, svg$.MaskElement);
  dart.defineExtensionNames([
    'flipX',
    'flipY',
    'inverse',
    'multiply',
    'rotate',
    'rotateFromVector',
    'scale',
    'scaleNonUniform',
    'skewX',
    'skewY',
    'translate',
    'a',
    'b',
    'c',
    'd',
    'e',
    'f'
  ]);
  svg$.Matrix = class Matrix extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.a]() {
      return this.a;
    }
    set [dartx.a](value) {
      this.a = value;
    }
    get [dartx.b]() {
      return this.b;
    }
    set [dartx.b](value) {
      this.b = value;
    }
    get [dartx.c]() {
      return this.c;
    }
    set [dartx.c](value) {
      this.c = value;
    }
    get [dartx.d]() {
      return this.d;
    }
    set [dartx.d](value) {
      this.d = value;
    }
    get [dartx.e]() {
      return this.e;
    }
    set [dartx.e](value) {
      this.e = value;
    }
    get [dartx.f]() {
      return this.f;
    }
    set [dartx.f](value) {
      this.f = value;
    }
    [dartx.flipX]() {
      return this.flipX();
    }
    [dartx.flipY]() {
      return this.flipY();
    }
    [dartx.inverse]() {
      return this.inverse();
    }
    [dartx.multiply](secondMatrix) {
      return this.multiply(secondMatrix);
    }
    [dartx.rotate](angle) {
      return this.rotate(angle);
    }
    [dartx.rotateFromVector](x, y) {
      return this.rotateFromVector(x, y);
    }
    [dartx.scale](scaleFactor) {
      return this.scale(scaleFactor);
    }
    [dartx.scaleNonUniform](scaleFactorX, scaleFactorY) {
      return this.scaleNonUniform(scaleFactorX, scaleFactorY);
    }
    [dartx.skewX](angle) {
      return this.skewX(angle);
    }
    [dartx.skewY](angle) {
      return this.skewY(angle);
    }
    [dartx.translate](x, y) {
      return this.translate(x, y);
    }
  };
  dart.setSignature(svg$.Matrix, {
    constructors: () => ({_: dart.definiteFunctionType(svg$.Matrix, [])}),
    methods: () => ({
      [dartx.flipX]: dart.definiteFunctionType(svg$.Matrix, []),
      [dartx.flipY]: dart.definiteFunctionType(svg$.Matrix, []),
      [dartx.inverse]: dart.definiteFunctionType(svg$.Matrix, []),
      [dartx.multiply]: dart.definiteFunctionType(svg$.Matrix, [svg$.Matrix]),
      [dartx.rotate]: dart.definiteFunctionType(svg$.Matrix, [core.num]),
      [dartx.rotateFromVector]: dart.definiteFunctionType(svg$.Matrix, [core.num, core.num]),
      [dartx.scale]: dart.definiteFunctionType(svg$.Matrix, [core.num]),
      [dartx.scaleNonUniform]: dart.definiteFunctionType(svg$.Matrix, [core.num, core.num]),
      [dartx.skewX]: dart.definiteFunctionType(svg$.Matrix, [core.num]),
      [dartx.skewY]: dart.definiteFunctionType(svg$.Matrix, [core.num]),
      [dartx.translate]: dart.definiteFunctionType(svg$.Matrix, [core.num, core.num])
    })
  });
  dart.registerExtension(dart.global.SVGMatrix, svg$.Matrix);
  svg$.MetadataElement = class MetadataElement extends svg$.SvgElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    created() {
      super.created();
    }
  };
  dart.defineNamedConstructor(svg$.MetadataElement, 'created');
  dart.setSignature(svg$.MetadataElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(svg$.MetadataElement, []),
      created: dart.definiteFunctionType(svg$.MetadataElement, [])
    })
  });
  dart.registerExtension(dart.global.SVGMetadataElement, svg$.MetadataElement);
  dart.defineExtensionNames([
    'value'
  ]);
  svg$.Number = class Number extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.value]() {
      return this.value;
    }
    set [dartx.value](value) {
      this.value = value;
    }
  };
  dart.setSignature(svg$.Number, {
    constructors: () => ({_: dart.definiteFunctionType(svg$.Number, [])})
  });
  dart.registerExtension(dart.global.SVGNumber, svg$.Number);
  dart.defineExtensionNames([
    'length',
    'get',
    'set',
    'length',
    'first',
    'last',
    'single',
    'elementAt',
    'appendItem',
    'clear',
    'getItem',
    'initialize',
    'insertItemBefore',
    'removeItem',
    'replaceItem',
    'numberOfItems'
  ]);
  svg$.NumberList = class NumberList extends dart.mixin(_interceptors.Interceptor, collection.ListMixin$(svg$.Number), html$.ImmutableListMixin$(svg$.Number)) {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.length]() {
      return this.length;
    }
    get [dartx.numberOfItems]() {
      return this.numberOfItems;
    }
    [dartx.get](index) {
      if (index >>> 0 !== index || index >= this[dartx.length]) dart.throw(core.RangeError.index(index, this));
      return this[dartx.getItem](index);
    }
    [dartx.set](index, value) {
      dart.throw(new core.UnsupportedError("Cannot assign element of immutable List."));
      return value;
    }
    set [dartx.length](value) {
      dart.throw(new core.UnsupportedError("Cannot resize immutable List."));
    }
    get [dartx.first]() {
      if (dart.notNull(this[dartx.length]) > 0) {
        return this[0];
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.last]() {
      let len = this[dartx.length];
      if (dart.notNull(len) > 0) {
        return this[dart.notNull(len) - 1];
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.single]() {
      let len = this[dartx.length];
      if (len == 1) {
        return this[0];
      }
      if (len == 0) dart.throw(new core.StateError("No elements"));
      dart.throw(new core.StateError("More than one element"));
    }
    [dartx.elementAt](index) {
      return this[dartx.get](index);
    }
    [__setter__$](index, newItem) {
      return this.__setter__(index, newItem);
    }
    [dartx.appendItem](newItem) {
      return this.appendItem(newItem);
    }
    [dartx.clear]() {
      return this.clear();
    }
    [dartx.getItem](index) {
      return this.getItem(index);
    }
    [dartx.initialize](newItem) {
      return this.initialize(newItem);
    }
    [dartx.insertItemBefore](newItem, index) {
      return this.insertItemBefore(newItem, index);
    }
    [dartx.removeItem](index) {
      return this.removeItem(index);
    }
    [dartx.replaceItem](newItem, index) {
      return this.replaceItem(newItem, index);
    }
  };
  svg$.NumberList[dart.implements] = () => [ListOfNumber()];
  dart.setSignature(svg$.NumberList, {
    constructors: () => ({_: dart.definiteFunctionType(svg$.NumberList, [])}),
    methods: () => ({
      [dartx.get]: dart.definiteFunctionType(svg$.Number, [core.int]),
      [dartx.set]: dart.definiteFunctionType(dart.void, [core.int, svg$.Number]),
      [dartx.elementAt]: dart.definiteFunctionType(svg$.Number, [core.int]),
      [__setter__$]: dart.definiteFunctionType(dart.void, [core.int, svg$.Number]),
      [dartx.appendItem]: dart.definiteFunctionType(svg$.Number, [svg$.Number]),
      [dartx.getItem]: dart.definiteFunctionType(svg$.Number, [core.int]),
      [dartx.initialize]: dart.definiteFunctionType(svg$.Number, [svg$.Number]),
      [dartx.insertItemBefore]: dart.definiteFunctionType(svg$.Number, [svg$.Number, core.int]),
      [dartx.removeItem]: dart.definiteFunctionType(svg$.Number, [core.int]),
      [dartx.replaceItem]: dart.definiteFunctionType(svg$.Number, [svg$.Number, core.int])
    })
  });
  dart.registerExtension(dart.global.SVGNumberList, svg$.NumberList);
  dart.defineExtensionNames([
    'createSvgPathSegArcAbs',
    'createSvgPathSegArcRel',
    'createSvgPathSegClosePath',
    'createSvgPathSegCurvetoCubicAbs',
    'createSvgPathSegCurvetoCubicRel',
    'createSvgPathSegCurvetoCubicSmoothAbs',
    'createSvgPathSegCurvetoCubicSmoothRel',
    'createSvgPathSegCurvetoQuadraticAbs',
    'createSvgPathSegCurvetoQuadraticRel',
    'createSvgPathSegCurvetoQuadraticSmoothAbs',
    'createSvgPathSegCurvetoQuadraticSmoothRel',
    'createSvgPathSegLinetoAbs',
    'createSvgPathSegLinetoHorizontalAbs',
    'createSvgPathSegLinetoHorizontalRel',
    'createSvgPathSegLinetoRel',
    'createSvgPathSegLinetoVerticalAbs',
    'createSvgPathSegLinetoVerticalRel',
    'createSvgPathSegMovetoAbs',
    'createSvgPathSegMovetoRel',
    'getPathSegAtLength',
    'getPointAtLength',
    'getTotalLength',
    'animatedNormalizedPathSegList',
    'animatedPathSegList',
    'normalizedPathSegList',
    'pathLength',
    'pathSegList'
  ]);
  svg$.PathElement = class PathElement extends svg$.GeometryElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return svg$.PathElement._check(svg$._SvgElementFactoryProvider.createSvgElement_tag("path"));
    }
    created() {
      this[dartx.animatedNormalizedPathSegList] = null;
      this[dartx.animatedPathSegList] = null;
      this[dartx.normalizedPathSegList] = null;
      this[dartx.pathLength] = null;
      this[dartx.pathSegList] = null;
      super.created();
    }
    get [dartx.animatedNormalizedPathSegList]() {
      return this.animatedNormalizedPathSegList;
    }
    get [dartx.animatedPathSegList]() {
      return this.animatedPathSegList;
    }
    get [dartx.normalizedPathSegList]() {
      return this.normalizedPathSegList;
    }
    get [dartx.pathLength]() {
      return this.pathLength;
    }
    get [dartx.pathSegList]() {
      return this.pathSegList;
    }
    [dartx.createSvgPathSegArcAbs](x, y, r1, r2, angle, largeArcFlag, sweepFlag) {
      return this.createSVGPathSegArcAbs(x, y, r1, r2, angle, largeArcFlag, sweepFlag);
    }
    [dartx.createSvgPathSegArcRel](x, y, r1, r2, angle, largeArcFlag, sweepFlag) {
      return this.createSVGPathSegArcRel(x, y, r1, r2, angle, largeArcFlag, sweepFlag);
    }
    [dartx.createSvgPathSegClosePath]() {
      return this.createSVGPathSegClosePath();
    }
    [dartx.createSvgPathSegCurvetoCubicAbs](x, y, x1, y1, x2, y2) {
      return this.createSVGPathSegCurvetoCubicAbs(x, y, x1, y1, x2, y2);
    }
    [dartx.createSvgPathSegCurvetoCubicRel](x, y, x1, y1, x2, y2) {
      return this.createSVGPathSegCurvetoCubicRel(x, y, x1, y1, x2, y2);
    }
    [dartx.createSvgPathSegCurvetoCubicSmoothAbs](x, y, x2, y2) {
      return this.createSVGPathSegCurvetoCubicSmoothAbs(x, y, x2, y2);
    }
    [dartx.createSvgPathSegCurvetoCubicSmoothRel](x, y, x2, y2) {
      return this.createSVGPathSegCurvetoCubicSmoothRel(x, y, x2, y2);
    }
    [dartx.createSvgPathSegCurvetoQuadraticAbs](x, y, x1, y1) {
      return this.createSVGPathSegCurvetoQuadraticAbs(x, y, x1, y1);
    }
    [dartx.createSvgPathSegCurvetoQuadraticRel](x, y, x1, y1) {
      return this.createSVGPathSegCurvetoQuadraticRel(x, y, x1, y1);
    }
    [dartx.createSvgPathSegCurvetoQuadraticSmoothAbs](x, y) {
      return this.createSVGPathSegCurvetoQuadraticSmoothAbs(x, y);
    }
    [dartx.createSvgPathSegCurvetoQuadraticSmoothRel](x, y) {
      return this.createSVGPathSegCurvetoQuadraticSmoothRel(x, y);
    }
    [dartx.createSvgPathSegLinetoAbs](x, y) {
      return this.createSVGPathSegLinetoAbs(x, y);
    }
    [dartx.createSvgPathSegLinetoHorizontalAbs](x) {
      return this.createSVGPathSegLinetoHorizontalAbs(x);
    }
    [dartx.createSvgPathSegLinetoHorizontalRel](x) {
      return this.createSVGPathSegLinetoHorizontalRel(x);
    }
    [dartx.createSvgPathSegLinetoRel](x, y) {
      return this.createSVGPathSegLinetoRel(x, y);
    }
    [dartx.createSvgPathSegLinetoVerticalAbs](y) {
      return this.createSVGPathSegLinetoVerticalAbs(y);
    }
    [dartx.createSvgPathSegLinetoVerticalRel](y) {
      return this.createSVGPathSegLinetoVerticalRel(y);
    }
    [dartx.createSvgPathSegMovetoAbs](x, y) {
      return this.createSVGPathSegMovetoAbs(x, y);
    }
    [dartx.createSvgPathSegMovetoRel](x, y) {
      return this.createSVGPathSegMovetoRel(x, y);
    }
    [dartx.getPathSegAtLength](distance) {
      return this.getPathSegAtLength(distance);
    }
    [dartx.getPointAtLength](distance) {
      return this.getPointAtLength(distance);
    }
    [dartx.getTotalLength]() {
      return this.getTotalLength();
    }
  };
  dart.defineNamedConstructor(svg$.PathElement, 'created');
  dart.setSignature(svg$.PathElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(svg$.PathElement, []),
      new: dart.definiteFunctionType(svg$.PathElement, []),
      created: dart.definiteFunctionType(svg$.PathElement, [])
    }),
    methods: () => ({
      [dartx.createSvgPathSegArcAbs]: dart.definiteFunctionType(svg$.PathSegArcAbs, [core.num, core.num, core.num, core.num, core.num, core.bool, core.bool]),
      [dartx.createSvgPathSegArcRel]: dart.definiteFunctionType(svg$.PathSegArcRel, [core.num, core.num, core.num, core.num, core.num, core.bool, core.bool]),
      [dartx.createSvgPathSegClosePath]: dart.definiteFunctionType(svg$.PathSegClosePath, []),
      [dartx.createSvgPathSegCurvetoCubicAbs]: dart.definiteFunctionType(svg$.PathSegCurvetoCubicAbs, [core.num, core.num, core.num, core.num, core.num, core.num]),
      [dartx.createSvgPathSegCurvetoCubicRel]: dart.definiteFunctionType(svg$.PathSegCurvetoCubicRel, [core.num, core.num, core.num, core.num, core.num, core.num]),
      [dartx.createSvgPathSegCurvetoCubicSmoothAbs]: dart.definiteFunctionType(svg$.PathSegCurvetoCubicSmoothAbs, [core.num, core.num, core.num, core.num]),
      [dartx.createSvgPathSegCurvetoCubicSmoothRel]: dart.definiteFunctionType(svg$.PathSegCurvetoCubicSmoothRel, [core.num, core.num, core.num, core.num]),
      [dartx.createSvgPathSegCurvetoQuadraticAbs]: dart.definiteFunctionType(svg$.PathSegCurvetoQuadraticAbs, [core.num, core.num, core.num, core.num]),
      [dartx.createSvgPathSegCurvetoQuadraticRel]: dart.definiteFunctionType(svg$.PathSegCurvetoQuadraticRel, [core.num, core.num, core.num, core.num]),
      [dartx.createSvgPathSegCurvetoQuadraticSmoothAbs]: dart.definiteFunctionType(svg$.PathSegCurvetoQuadraticSmoothAbs, [core.num, core.num]),
      [dartx.createSvgPathSegCurvetoQuadraticSmoothRel]: dart.definiteFunctionType(svg$.PathSegCurvetoQuadraticSmoothRel, [core.num, core.num]),
      [dartx.createSvgPathSegLinetoAbs]: dart.definiteFunctionType(svg$.PathSegLinetoAbs, [core.num, core.num]),
      [dartx.createSvgPathSegLinetoHorizontalAbs]: dart.definiteFunctionType(svg$.PathSegLinetoHorizontalAbs, [core.num]),
      [dartx.createSvgPathSegLinetoHorizontalRel]: dart.definiteFunctionType(svg$.PathSegLinetoHorizontalRel, [core.num]),
      [dartx.createSvgPathSegLinetoRel]: dart.definiteFunctionType(svg$.PathSegLinetoRel, [core.num, core.num]),
      [dartx.createSvgPathSegLinetoVerticalAbs]: dart.definiteFunctionType(svg$.PathSegLinetoVerticalAbs, [core.num]),
      [dartx.createSvgPathSegLinetoVerticalRel]: dart.definiteFunctionType(svg$.PathSegLinetoVerticalRel, [core.num]),
      [dartx.createSvgPathSegMovetoAbs]: dart.definiteFunctionType(svg$.PathSegMovetoAbs, [core.num, core.num]),
      [dartx.createSvgPathSegMovetoRel]: dart.definiteFunctionType(svg$.PathSegMovetoRel, [core.num, core.num]),
      [dartx.getPathSegAtLength]: dart.definiteFunctionType(core.int, [core.num]),
      [dartx.getPointAtLength]: dart.definiteFunctionType(svg$.Point, [core.num]),
      [dartx.getTotalLength]: dart.definiteFunctionType(core.double, [])
    })
  });
  dart.registerExtension(dart.global.SVGPathElement, svg$.PathElement);
  dart.defineExtensionNames([
    'pathSegType',
    'pathSegTypeAsLetter'
  ]);
  svg$.PathSeg = class PathSeg extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.pathSegType]() {
      return this.pathSegType;
    }
    get [dartx.pathSegTypeAsLetter]() {
      return this.pathSegTypeAsLetter;
    }
  };
  dart.setSignature(svg$.PathSeg, {
    constructors: () => ({_: dart.definiteFunctionType(svg$.PathSeg, [])})
  });
  svg$.PathSeg.PATHSEG_ARC_ABS = 10;
  svg$.PathSeg.PATHSEG_ARC_REL = 11;
  svg$.PathSeg.PATHSEG_CLOSEPATH = 1;
  svg$.PathSeg.PATHSEG_CURVETO_CUBIC_ABS = 6;
  svg$.PathSeg.PATHSEG_CURVETO_CUBIC_REL = 7;
  svg$.PathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_ABS = 16;
  svg$.PathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_REL = 17;
  svg$.PathSeg.PATHSEG_CURVETO_QUADRATIC_ABS = 8;
  svg$.PathSeg.PATHSEG_CURVETO_QUADRATIC_REL = 9;
  svg$.PathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS = 18;
  svg$.PathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL = 19;
  svg$.PathSeg.PATHSEG_LINETO_ABS = 4;
  svg$.PathSeg.PATHSEG_LINETO_HORIZONTAL_ABS = 12;
  svg$.PathSeg.PATHSEG_LINETO_HORIZONTAL_REL = 13;
  svg$.PathSeg.PATHSEG_LINETO_REL = 5;
  svg$.PathSeg.PATHSEG_LINETO_VERTICAL_ABS = 14;
  svg$.PathSeg.PATHSEG_LINETO_VERTICAL_REL = 15;
  svg$.PathSeg.PATHSEG_MOVETO_ABS = 2;
  svg$.PathSeg.PATHSEG_MOVETO_REL = 3;
  svg$.PathSeg.PATHSEG_UNKNOWN = 0;
  dart.registerExtension(dart.global.SVGPathSeg, svg$.PathSeg);
  dart.defineExtensionNames([
    'angle',
    'largeArcFlag',
    'r1',
    'r2',
    'sweepFlag',
    'x',
    'y'
  ]);
  svg$.PathSegArcAbs = class PathSegArcAbs extends svg$.PathSeg {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.angle]() {
      return this.angle;
    }
    set [dartx.angle](value) {
      this.angle = value;
    }
    get [dartx.largeArcFlag]() {
      return this.largeArcFlag;
    }
    set [dartx.largeArcFlag](value) {
      this.largeArcFlag = value;
    }
    get [dartx.r1]() {
      return this.r1;
    }
    set [dartx.r1](value) {
      this.r1 = value;
    }
    get [dartx.r2]() {
      return this.r2;
    }
    set [dartx.r2](value) {
      this.r2 = value;
    }
    get [dartx.sweepFlag]() {
      return this.sweepFlag;
    }
    set [dartx.sweepFlag](value) {
      this.sweepFlag = value;
    }
    get [dartx.x]() {
      return this.x;
    }
    set [dartx.x](value) {
      this.x = value;
    }
    get [dartx.y]() {
      return this.y;
    }
    set [dartx.y](value) {
      this.y = value;
    }
  };
  dart.setSignature(svg$.PathSegArcAbs, {
    constructors: () => ({_: dart.definiteFunctionType(svg$.PathSegArcAbs, [])})
  });
  dart.registerExtension(dart.global.SVGPathSegArcAbs, svg$.PathSegArcAbs);
  dart.defineExtensionNames([
    'angle',
    'largeArcFlag',
    'r1',
    'r2',
    'sweepFlag',
    'x',
    'y'
  ]);
  svg$.PathSegArcRel = class PathSegArcRel extends svg$.PathSeg {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.angle]() {
      return this.angle;
    }
    set [dartx.angle](value) {
      this.angle = value;
    }
    get [dartx.largeArcFlag]() {
      return this.largeArcFlag;
    }
    set [dartx.largeArcFlag](value) {
      this.largeArcFlag = value;
    }
    get [dartx.r1]() {
      return this.r1;
    }
    set [dartx.r1](value) {
      this.r1 = value;
    }
    get [dartx.r2]() {
      return this.r2;
    }
    set [dartx.r2](value) {
      this.r2 = value;
    }
    get [dartx.sweepFlag]() {
      return this.sweepFlag;
    }
    set [dartx.sweepFlag](value) {
      this.sweepFlag = value;
    }
    get [dartx.x]() {
      return this.x;
    }
    set [dartx.x](value) {
      this.x = value;
    }
    get [dartx.y]() {
      return this.y;
    }
    set [dartx.y](value) {
      this.y = value;
    }
  };
  dart.setSignature(svg$.PathSegArcRel, {
    constructors: () => ({_: dart.definiteFunctionType(svg$.PathSegArcRel, [])})
  });
  dart.registerExtension(dart.global.SVGPathSegArcRel, svg$.PathSegArcRel);
  svg$.PathSegClosePath = class PathSegClosePath extends svg$.PathSeg {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(svg$.PathSegClosePath, {
    constructors: () => ({_: dart.definiteFunctionType(svg$.PathSegClosePath, [])})
  });
  dart.registerExtension(dart.global.SVGPathSegClosePath, svg$.PathSegClosePath);
  dart.defineExtensionNames([
    'x',
    'x1',
    'x2',
    'y',
    'y1',
    'y2'
  ]);
  svg$.PathSegCurvetoCubicAbs = class PathSegCurvetoCubicAbs extends svg$.PathSeg {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.x]() {
      return this.x;
    }
    set [dartx.x](value) {
      this.x = value;
    }
    get [dartx.x1]() {
      return this.x1;
    }
    set [dartx.x1](value) {
      this.x1 = value;
    }
    get [dartx.x2]() {
      return this.x2;
    }
    set [dartx.x2](value) {
      this.x2 = value;
    }
    get [dartx.y]() {
      return this.y;
    }
    set [dartx.y](value) {
      this.y = value;
    }
    get [dartx.y1]() {
      return this.y1;
    }
    set [dartx.y1](value) {
      this.y1 = value;
    }
    get [dartx.y2]() {
      return this.y2;
    }
    set [dartx.y2](value) {
      this.y2 = value;
    }
  };
  dart.setSignature(svg$.PathSegCurvetoCubicAbs, {
    constructors: () => ({_: dart.definiteFunctionType(svg$.PathSegCurvetoCubicAbs, [])})
  });
  dart.registerExtension(dart.global.SVGPathSegCurvetoCubicAbs, svg$.PathSegCurvetoCubicAbs);
  dart.defineExtensionNames([
    'x',
    'x1',
    'x2',
    'y',
    'y1',
    'y2'
  ]);
  svg$.PathSegCurvetoCubicRel = class PathSegCurvetoCubicRel extends svg$.PathSeg {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.x]() {
      return this.x;
    }
    set [dartx.x](value) {
      this.x = value;
    }
    get [dartx.x1]() {
      return this.x1;
    }
    set [dartx.x1](value) {
      this.x1 = value;
    }
    get [dartx.x2]() {
      return this.x2;
    }
    set [dartx.x2](value) {
      this.x2 = value;
    }
    get [dartx.y]() {
      return this.y;
    }
    set [dartx.y](value) {
      this.y = value;
    }
    get [dartx.y1]() {
      return this.y1;
    }
    set [dartx.y1](value) {
      this.y1 = value;
    }
    get [dartx.y2]() {
      return this.y2;
    }
    set [dartx.y2](value) {
      this.y2 = value;
    }
  };
  dart.setSignature(svg$.PathSegCurvetoCubicRel, {
    constructors: () => ({_: dart.definiteFunctionType(svg$.PathSegCurvetoCubicRel, [])})
  });
  dart.registerExtension(dart.global.SVGPathSegCurvetoCubicRel, svg$.PathSegCurvetoCubicRel);
  dart.defineExtensionNames([
    'x',
    'x2',
    'y',
    'y2'
  ]);
  svg$.PathSegCurvetoCubicSmoothAbs = class PathSegCurvetoCubicSmoothAbs extends svg$.PathSeg {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.x]() {
      return this.x;
    }
    set [dartx.x](value) {
      this.x = value;
    }
    get [dartx.x2]() {
      return this.x2;
    }
    set [dartx.x2](value) {
      this.x2 = value;
    }
    get [dartx.y]() {
      return this.y;
    }
    set [dartx.y](value) {
      this.y = value;
    }
    get [dartx.y2]() {
      return this.y2;
    }
    set [dartx.y2](value) {
      this.y2 = value;
    }
  };
  dart.setSignature(svg$.PathSegCurvetoCubicSmoothAbs, {
    constructors: () => ({_: dart.definiteFunctionType(svg$.PathSegCurvetoCubicSmoothAbs, [])})
  });
  dart.registerExtension(dart.global.SVGPathSegCurvetoCubicSmoothAbs, svg$.PathSegCurvetoCubicSmoothAbs);
  dart.defineExtensionNames([
    'x',
    'x2',
    'y',
    'y2'
  ]);
  svg$.PathSegCurvetoCubicSmoothRel = class PathSegCurvetoCubicSmoothRel extends svg$.PathSeg {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.x]() {
      return this.x;
    }
    set [dartx.x](value) {
      this.x = value;
    }
    get [dartx.x2]() {
      return this.x2;
    }
    set [dartx.x2](value) {
      this.x2 = value;
    }
    get [dartx.y]() {
      return this.y;
    }
    set [dartx.y](value) {
      this.y = value;
    }
    get [dartx.y2]() {
      return this.y2;
    }
    set [dartx.y2](value) {
      this.y2 = value;
    }
  };
  dart.setSignature(svg$.PathSegCurvetoCubicSmoothRel, {
    constructors: () => ({_: dart.definiteFunctionType(svg$.PathSegCurvetoCubicSmoothRel, [])})
  });
  dart.registerExtension(dart.global.SVGPathSegCurvetoCubicSmoothRel, svg$.PathSegCurvetoCubicSmoothRel);
  dart.defineExtensionNames([
    'x',
    'x1',
    'y',
    'y1'
  ]);
  svg$.PathSegCurvetoQuadraticAbs = class PathSegCurvetoQuadraticAbs extends svg$.PathSeg {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.x]() {
      return this.x;
    }
    set [dartx.x](value) {
      this.x = value;
    }
    get [dartx.x1]() {
      return this.x1;
    }
    set [dartx.x1](value) {
      this.x1 = value;
    }
    get [dartx.y]() {
      return this.y;
    }
    set [dartx.y](value) {
      this.y = value;
    }
    get [dartx.y1]() {
      return this.y1;
    }
    set [dartx.y1](value) {
      this.y1 = value;
    }
  };
  dart.setSignature(svg$.PathSegCurvetoQuadraticAbs, {
    constructors: () => ({_: dart.definiteFunctionType(svg$.PathSegCurvetoQuadraticAbs, [])})
  });
  dart.registerExtension(dart.global.SVGPathSegCurvetoQuadraticAbs, svg$.PathSegCurvetoQuadraticAbs);
  dart.defineExtensionNames([
    'x',
    'x1',
    'y',
    'y1'
  ]);
  svg$.PathSegCurvetoQuadraticRel = class PathSegCurvetoQuadraticRel extends svg$.PathSeg {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.x]() {
      return this.x;
    }
    set [dartx.x](value) {
      this.x = value;
    }
    get [dartx.x1]() {
      return this.x1;
    }
    set [dartx.x1](value) {
      this.x1 = value;
    }
    get [dartx.y]() {
      return this.y;
    }
    set [dartx.y](value) {
      this.y = value;
    }
    get [dartx.y1]() {
      return this.y1;
    }
    set [dartx.y1](value) {
      this.y1 = value;
    }
  };
  dart.setSignature(svg$.PathSegCurvetoQuadraticRel, {
    constructors: () => ({_: dart.definiteFunctionType(svg$.PathSegCurvetoQuadraticRel, [])})
  });
  dart.registerExtension(dart.global.SVGPathSegCurvetoQuadraticRel, svg$.PathSegCurvetoQuadraticRel);
  dart.defineExtensionNames([
    'x',
    'y'
  ]);
  svg$.PathSegCurvetoQuadraticSmoothAbs = class PathSegCurvetoQuadraticSmoothAbs extends svg$.PathSeg {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.x]() {
      return this.x;
    }
    set [dartx.x](value) {
      this.x = value;
    }
    get [dartx.y]() {
      return this.y;
    }
    set [dartx.y](value) {
      this.y = value;
    }
  };
  dart.setSignature(svg$.PathSegCurvetoQuadraticSmoothAbs, {
    constructors: () => ({_: dart.definiteFunctionType(svg$.PathSegCurvetoQuadraticSmoothAbs, [])})
  });
  dart.registerExtension(dart.global.SVGPathSegCurvetoQuadraticSmoothAbs, svg$.PathSegCurvetoQuadraticSmoothAbs);
  dart.defineExtensionNames([
    'x',
    'y'
  ]);
  svg$.PathSegCurvetoQuadraticSmoothRel = class PathSegCurvetoQuadraticSmoothRel extends svg$.PathSeg {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.x]() {
      return this.x;
    }
    set [dartx.x](value) {
      this.x = value;
    }
    get [dartx.y]() {
      return this.y;
    }
    set [dartx.y](value) {
      this.y = value;
    }
  };
  dart.setSignature(svg$.PathSegCurvetoQuadraticSmoothRel, {
    constructors: () => ({_: dart.definiteFunctionType(svg$.PathSegCurvetoQuadraticSmoothRel, [])})
  });
  dart.registerExtension(dart.global.SVGPathSegCurvetoQuadraticSmoothRel, svg$.PathSegCurvetoQuadraticSmoothRel);
  dart.defineExtensionNames([
    'x',
    'y'
  ]);
  svg$.PathSegLinetoAbs = class PathSegLinetoAbs extends svg$.PathSeg {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.x]() {
      return this.x;
    }
    set [dartx.x](value) {
      this.x = value;
    }
    get [dartx.y]() {
      return this.y;
    }
    set [dartx.y](value) {
      this.y = value;
    }
  };
  dart.setSignature(svg$.PathSegLinetoAbs, {
    constructors: () => ({_: dart.definiteFunctionType(svg$.PathSegLinetoAbs, [])})
  });
  dart.registerExtension(dart.global.SVGPathSegLinetoAbs, svg$.PathSegLinetoAbs);
  dart.defineExtensionNames([
    'x'
  ]);
  svg$.PathSegLinetoHorizontalAbs = class PathSegLinetoHorizontalAbs extends svg$.PathSeg {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.x]() {
      return this.x;
    }
    set [dartx.x](value) {
      this.x = value;
    }
  };
  dart.setSignature(svg$.PathSegLinetoHorizontalAbs, {
    constructors: () => ({_: dart.definiteFunctionType(svg$.PathSegLinetoHorizontalAbs, [])})
  });
  dart.registerExtension(dart.global.SVGPathSegLinetoHorizontalAbs, svg$.PathSegLinetoHorizontalAbs);
  dart.defineExtensionNames([
    'x'
  ]);
  svg$.PathSegLinetoHorizontalRel = class PathSegLinetoHorizontalRel extends svg$.PathSeg {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.x]() {
      return this.x;
    }
    set [dartx.x](value) {
      this.x = value;
    }
  };
  dart.setSignature(svg$.PathSegLinetoHorizontalRel, {
    constructors: () => ({_: dart.definiteFunctionType(svg$.PathSegLinetoHorizontalRel, [])})
  });
  dart.registerExtension(dart.global.SVGPathSegLinetoHorizontalRel, svg$.PathSegLinetoHorizontalRel);
  dart.defineExtensionNames([
    'x',
    'y'
  ]);
  svg$.PathSegLinetoRel = class PathSegLinetoRel extends svg$.PathSeg {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.x]() {
      return this.x;
    }
    set [dartx.x](value) {
      this.x = value;
    }
    get [dartx.y]() {
      return this.y;
    }
    set [dartx.y](value) {
      this.y = value;
    }
  };
  dart.setSignature(svg$.PathSegLinetoRel, {
    constructors: () => ({_: dart.definiteFunctionType(svg$.PathSegLinetoRel, [])})
  });
  dart.registerExtension(dart.global.SVGPathSegLinetoRel, svg$.PathSegLinetoRel);
  dart.defineExtensionNames([
    'y'
  ]);
  svg$.PathSegLinetoVerticalAbs = class PathSegLinetoVerticalAbs extends svg$.PathSeg {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.y]() {
      return this.y;
    }
    set [dartx.y](value) {
      this.y = value;
    }
  };
  dart.setSignature(svg$.PathSegLinetoVerticalAbs, {
    constructors: () => ({_: dart.definiteFunctionType(svg$.PathSegLinetoVerticalAbs, [])})
  });
  dart.registerExtension(dart.global.SVGPathSegLinetoVerticalAbs, svg$.PathSegLinetoVerticalAbs);
  dart.defineExtensionNames([
    'y'
  ]);
  svg$.PathSegLinetoVerticalRel = class PathSegLinetoVerticalRel extends svg$.PathSeg {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.y]() {
      return this.y;
    }
    set [dartx.y](value) {
      this.y = value;
    }
  };
  dart.setSignature(svg$.PathSegLinetoVerticalRel, {
    constructors: () => ({_: dart.definiteFunctionType(svg$.PathSegLinetoVerticalRel, [])})
  });
  dart.registerExtension(dart.global.SVGPathSegLinetoVerticalRel, svg$.PathSegLinetoVerticalRel);
  dart.defineExtensionNames([
    'length',
    'get',
    'set',
    'length',
    'first',
    'last',
    'single',
    'elementAt',
    'appendItem',
    'clear',
    'getItem',
    'initialize',
    'insertItemBefore',
    'removeItem',
    'replaceItem',
    'numberOfItems'
  ]);
  svg$.PathSegList = class PathSegList extends dart.mixin(_interceptors.Interceptor, collection.ListMixin$(svg$.PathSeg), html$.ImmutableListMixin$(svg$.PathSeg)) {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.length]() {
      return this.length;
    }
    get [dartx.numberOfItems]() {
      return this.numberOfItems;
    }
    [dartx.get](index) {
      if (index >>> 0 !== index || index >= this[dartx.length]) dart.throw(core.RangeError.index(index, this));
      return this[dartx.getItem](index);
    }
    [dartx.set](index, value) {
      dart.throw(new core.UnsupportedError("Cannot assign element of immutable List."));
      return value;
    }
    set [dartx.length](value) {
      dart.throw(new core.UnsupportedError("Cannot resize immutable List."));
    }
    get [dartx.first]() {
      if (dart.notNull(this[dartx.length]) > 0) {
        return this[0];
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.last]() {
      let len = this[dartx.length];
      if (dart.notNull(len) > 0) {
        return this[dart.notNull(len) - 1];
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.single]() {
      let len = this[dartx.length];
      if (len == 1) {
        return this[0];
      }
      if (len == 0) dart.throw(new core.StateError("No elements"));
      dart.throw(new core.StateError("More than one element"));
    }
    [dartx.elementAt](index) {
      return this[dartx.get](index);
    }
    [__setter__$](index, newItem) {
      return this.__setter__(index, newItem);
    }
    [dartx.appendItem](newItem) {
      return this.appendItem(newItem);
    }
    [dartx.clear]() {
      return this.clear();
    }
    [dartx.getItem](index) {
      return this.getItem(index);
    }
    [dartx.initialize](newItem) {
      return this.initialize(newItem);
    }
    [dartx.insertItemBefore](newItem, index) {
      return this.insertItemBefore(newItem, index);
    }
    [dartx.removeItem](index) {
      return this.removeItem(index);
    }
    [dartx.replaceItem](newItem, index) {
      return this.replaceItem(newItem, index);
    }
  };
  svg$.PathSegList[dart.implements] = () => [ListOfPathSeg()];
  dart.setSignature(svg$.PathSegList, {
    constructors: () => ({_: dart.definiteFunctionType(svg$.PathSegList, [])}),
    methods: () => ({
      [dartx.get]: dart.definiteFunctionType(svg$.PathSeg, [core.int]),
      [dartx.set]: dart.definiteFunctionType(dart.void, [core.int, svg$.PathSeg]),
      [dartx.elementAt]: dart.definiteFunctionType(svg$.PathSeg, [core.int]),
      [__setter__$]: dart.definiteFunctionType(dart.void, [core.int, svg$.PathSeg]),
      [dartx.appendItem]: dart.definiteFunctionType(svg$.PathSeg, [svg$.PathSeg]),
      [dartx.getItem]: dart.definiteFunctionType(svg$.PathSeg, [core.int]),
      [dartx.initialize]: dart.definiteFunctionType(svg$.PathSeg, [svg$.PathSeg]),
      [dartx.insertItemBefore]: dart.definiteFunctionType(svg$.PathSeg, [svg$.PathSeg, core.int]),
      [dartx.removeItem]: dart.definiteFunctionType(svg$.PathSeg, [core.int]),
      [dartx.replaceItem]: dart.definiteFunctionType(svg$.PathSeg, [svg$.PathSeg, core.int])
    })
  });
  dart.registerExtension(dart.global.SVGPathSegList, svg$.PathSegList);
  dart.defineExtensionNames([
    'x',
    'y'
  ]);
  svg$.PathSegMovetoAbs = class PathSegMovetoAbs extends svg$.PathSeg {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.x]() {
      return this.x;
    }
    set [dartx.x](value) {
      this.x = value;
    }
    get [dartx.y]() {
      return this.y;
    }
    set [dartx.y](value) {
      this.y = value;
    }
  };
  dart.setSignature(svg$.PathSegMovetoAbs, {
    constructors: () => ({_: dart.definiteFunctionType(svg$.PathSegMovetoAbs, [])})
  });
  dart.registerExtension(dart.global.SVGPathSegMovetoAbs, svg$.PathSegMovetoAbs);
  dart.defineExtensionNames([
    'x',
    'y'
  ]);
  svg$.PathSegMovetoRel = class PathSegMovetoRel extends svg$.PathSeg {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.x]() {
      return this.x;
    }
    set [dartx.x](value) {
      this.x = value;
    }
    get [dartx.y]() {
      return this.y;
    }
    set [dartx.y](value) {
      this.y = value;
    }
  };
  dart.setSignature(svg$.PathSegMovetoRel, {
    constructors: () => ({_: dart.definiteFunctionType(svg$.PathSegMovetoRel, [])})
  });
  dart.registerExtension(dart.global.SVGPathSegMovetoRel, svg$.PathSegMovetoRel);
  dart.defineExtensionNames([
    'hasExtension',
    'height',
    'patternContentUnits',
    'patternTransform',
    'patternUnits',
    'width',
    'x',
    'y',
    'preserveAspectRatio',
    'viewBox',
    'requiredExtensions',
    'requiredFeatures',
    'systemLanguage',
    'href'
  ]);
  svg$.PatternElement = class PatternElement extends svg$.SvgElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return svg$.PatternElement._check(svg$._SvgElementFactoryProvider.createSvgElement_tag("pattern"));
    }
    created() {
      this[dartx.height] = null;
      this[dartx.patternContentUnits] = null;
      this[dartx.patternTransform] = null;
      this[dartx.patternUnits] = null;
      this[dartx.width] = null;
      this[dartx.x] = null;
      this[dartx.y] = null;
      this[dartx.preserveAspectRatio] = null;
      this[dartx.viewBox] = null;
      this[dartx.requiredExtensions] = null;
      this[dartx.requiredFeatures] = null;
      this[dartx.systemLanguage] = null;
      this[dartx.href] = null;
      super.created();
    }
    get [dartx.height]() {
      return this.height;
    }
    get [dartx.patternContentUnits]() {
      return this.patternContentUnits;
    }
    get [dartx.patternTransform]() {
      return this.patternTransform;
    }
    get [dartx.patternUnits]() {
      return this.patternUnits;
    }
    get [dartx.width]() {
      return this.width;
    }
    get [dartx.x]() {
      return this.x;
    }
    get [dartx.y]() {
      return this.y;
    }
    get [dartx.preserveAspectRatio]() {
      return this.preserveAspectRatio;
    }
    get [dartx.viewBox]() {
      return this.viewBox;
    }
    get [dartx.requiredExtensions]() {
      return this.requiredExtensions;
    }
    get [dartx.requiredFeatures]() {
      return this.requiredFeatures;
    }
    get [dartx.systemLanguage]() {
      return this.systemLanguage;
    }
    [dartx.hasExtension](extension) {
      return this.hasExtension(extension);
    }
    get [dartx.href]() {
      return this.href;
    }
  };
  dart.defineNamedConstructor(svg$.PatternElement, 'created');
  svg$.PatternElement[dart.implements] = () => [svg$.FitToViewBox, svg$.UriReference, svg$.Tests];
  dart.setSignature(svg$.PatternElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(svg$.PatternElement, []),
      new: dart.definiteFunctionType(svg$.PatternElement, []),
      created: dart.definiteFunctionType(svg$.PatternElement, [])
    }),
    methods: () => ({[dartx.hasExtension]: dart.definiteFunctionType(core.bool, [core.String])})
  });
  dart.registerExtension(dart.global.SVGPatternElement, svg$.PatternElement);
  dart.defineExtensionNames([
    'matrixTransform',
    'x',
    'y'
  ]);
  svg$.Point = class Point extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.x]() {
      return this.x;
    }
    set [dartx.x](value) {
      this.x = value;
    }
    get [dartx.y]() {
      return this.y;
    }
    set [dartx.y](value) {
      this.y = value;
    }
    [dartx.matrixTransform](matrix) {
      return this.matrixTransform(matrix);
    }
  };
  dart.setSignature(svg$.Point, {
    constructors: () => ({_: dart.definiteFunctionType(svg$.Point, [])}),
    methods: () => ({[dartx.matrixTransform]: dart.definiteFunctionType(svg$.Point, [svg$.Matrix])})
  });
  dart.registerExtension(dart.global.SVGPoint, svg$.Point);
  dart.defineExtensionNames([
    'appendItem',
    'clear',
    'getItem',
    'initialize',
    'insertItemBefore',
    'removeItem',
    'replaceItem',
    'length',
    'numberOfItems'
  ]);
  svg$.PointList = class PointList extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.length]() {
      return this.length;
    }
    get [dartx.numberOfItems]() {
      return this.numberOfItems;
    }
    [__setter__$](index, newItem) {
      return this.__setter__(index, newItem);
    }
    [dartx.appendItem](newItem) {
      return this.appendItem(newItem);
    }
    [dartx.clear]() {
      return this.clear();
    }
    [dartx.getItem](index) {
      return this.getItem(index);
    }
    [dartx.initialize](newItem) {
      return this.initialize(newItem);
    }
    [dartx.insertItemBefore](newItem, index) {
      return this.insertItemBefore(newItem, index);
    }
    [dartx.removeItem](index) {
      return this.removeItem(index);
    }
    [dartx.replaceItem](newItem, index) {
      return this.replaceItem(newItem, index);
    }
  };
  dart.setSignature(svg$.PointList, {
    constructors: () => ({_: dart.definiteFunctionType(svg$.PointList, [])}),
    methods: () => ({
      [__setter__$]: dart.definiteFunctionType(dart.void, [core.int, svg$.Point]),
      [dartx.appendItem]: dart.definiteFunctionType(svg$.Point, [svg$.Point]),
      [dartx.clear]: dart.definiteFunctionType(dart.void, []),
      [dartx.getItem]: dart.definiteFunctionType(svg$.Point, [core.int]),
      [dartx.initialize]: dart.definiteFunctionType(svg$.Point, [svg$.Point]),
      [dartx.insertItemBefore]: dart.definiteFunctionType(svg$.Point, [svg$.Point, core.int]),
      [dartx.removeItem]: dart.definiteFunctionType(svg$.Point, [core.int]),
      [dartx.replaceItem]: dart.definiteFunctionType(svg$.Point, [svg$.Point, core.int])
    })
  });
  dart.registerExtension(dart.global.SVGPointList, svg$.PointList);
  dart.defineExtensionNames([
    'animatedPoints',
    'points'
  ]);
  svg$.PolygonElement = class PolygonElement extends svg$.GeometryElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return svg$.PolygonElement._check(svg$._SvgElementFactoryProvider.createSvgElement_tag("polygon"));
    }
    created() {
      this[dartx.animatedPoints] = null;
      this[dartx.points] = null;
      super.created();
    }
    get [dartx.animatedPoints]() {
      return this.animatedPoints;
    }
    get [dartx.points]() {
      return this.points;
    }
  };
  dart.defineNamedConstructor(svg$.PolygonElement, 'created');
  dart.setSignature(svg$.PolygonElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(svg$.PolygonElement, []),
      new: dart.definiteFunctionType(svg$.PolygonElement, []),
      created: dart.definiteFunctionType(svg$.PolygonElement, [])
    })
  });
  dart.registerExtension(dart.global.SVGPolygonElement, svg$.PolygonElement);
  dart.defineExtensionNames([
    'animatedPoints',
    'points'
  ]);
  svg$.PolylineElement = class PolylineElement extends svg$.GeometryElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return svg$.PolylineElement._check(svg$._SvgElementFactoryProvider.createSvgElement_tag("polyline"));
    }
    created() {
      this[dartx.animatedPoints] = null;
      this[dartx.points] = null;
      super.created();
    }
    get [dartx.animatedPoints]() {
      return this.animatedPoints;
    }
    get [dartx.points]() {
      return this.points;
    }
  };
  dart.defineNamedConstructor(svg$.PolylineElement, 'created');
  dart.setSignature(svg$.PolylineElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(svg$.PolylineElement, []),
      new: dart.definiteFunctionType(svg$.PolylineElement, []),
      created: dart.definiteFunctionType(svg$.PolylineElement, [])
    })
  });
  dart.registerExtension(dart.global.SVGPolylineElement, svg$.PolylineElement);
  dart.defineExtensionNames([
    'align',
    'meetOrSlice'
  ]);
  svg$.PreserveAspectRatio = class PreserveAspectRatio extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.align]() {
      return this.align;
    }
    set [dartx.align](value) {
      this.align = value;
    }
    get [dartx.meetOrSlice]() {
      return this.meetOrSlice;
    }
    set [dartx.meetOrSlice](value) {
      this.meetOrSlice = value;
    }
  };
  dart.setSignature(svg$.PreserveAspectRatio, {
    constructors: () => ({_: dart.definiteFunctionType(svg$.PreserveAspectRatio, [])})
  });
  svg$.PreserveAspectRatio.SVG_MEETORSLICE_MEET = 1;
  svg$.PreserveAspectRatio.SVG_MEETORSLICE_SLICE = 2;
  svg$.PreserveAspectRatio.SVG_MEETORSLICE_UNKNOWN = 0;
  svg$.PreserveAspectRatio.SVG_PRESERVEASPECTRATIO_NONE = 1;
  svg$.PreserveAspectRatio.SVG_PRESERVEASPECTRATIO_UNKNOWN = 0;
  svg$.PreserveAspectRatio.SVG_PRESERVEASPECTRATIO_XMAXYMAX = 10;
  svg$.PreserveAspectRatio.SVG_PRESERVEASPECTRATIO_XMAXYMID = 7;
  svg$.PreserveAspectRatio.SVG_PRESERVEASPECTRATIO_XMAXYMIN = 4;
  svg$.PreserveAspectRatio.SVG_PRESERVEASPECTRATIO_XMIDYMAX = 9;
  svg$.PreserveAspectRatio.SVG_PRESERVEASPECTRATIO_XMIDYMID = 6;
  svg$.PreserveAspectRatio.SVG_PRESERVEASPECTRATIO_XMIDYMIN = 3;
  svg$.PreserveAspectRatio.SVG_PRESERVEASPECTRATIO_XMINYMAX = 8;
  svg$.PreserveAspectRatio.SVG_PRESERVEASPECTRATIO_XMINYMID = 5;
  svg$.PreserveAspectRatio.SVG_PRESERVEASPECTRATIO_XMINYMIN = 2;
  dart.registerExtension(dart.global.SVGPreserveAspectRatio, svg$.PreserveAspectRatio);
  dart.defineExtensionNames([
    'cx',
    'cy',
    'fr',
    'fx',
    'fy',
    'r'
  ]);
  svg$.RadialGradientElement = class RadialGradientElement extends svg$._GradientElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return svg$.RadialGradientElement._check(svg$._SvgElementFactoryProvider.createSvgElement_tag("radialGradient"));
    }
    created() {
      this[dartx.cx] = null;
      this[dartx.cy] = null;
      this[dartx.fr] = null;
      this[dartx.fx] = null;
      this[dartx.fy] = null;
      this[dartx.r] = null;
      super.created();
    }
    get [dartx.cx]() {
      return this.cx;
    }
    get [dartx.cy]() {
      return this.cy;
    }
    get [dartx.fr]() {
      return this.fr;
    }
    get [dartx.fx]() {
      return this.fx;
    }
    get [dartx.fy]() {
      return this.fy;
    }
    get [dartx.r]() {
      return this.r;
    }
  };
  dart.defineNamedConstructor(svg$.RadialGradientElement, 'created');
  dart.setSignature(svg$.RadialGradientElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(svg$.RadialGradientElement, []),
      new: dart.definiteFunctionType(svg$.RadialGradientElement, []),
      created: dart.definiteFunctionType(svg$.RadialGradientElement, [])
    })
  });
  dart.registerExtension(dart.global.SVGRadialGradientElement, svg$.RadialGradientElement);
  dart.defineExtensionNames([
    'height',
    'width',
    'x',
    'y'
  ]);
  svg$.Rect = class Rect extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.height]() {
      return this.height;
    }
    set [dartx.height](value) {
      this.height = value;
    }
    get [dartx.width]() {
      return this.width;
    }
    set [dartx.width](value) {
      this.width = value;
    }
    get [dartx.x]() {
      return this.x;
    }
    set [dartx.x](value) {
      this.x = value;
    }
    get [dartx.y]() {
      return this.y;
    }
    set [dartx.y](value) {
      this.y = value;
    }
  };
  dart.setSignature(svg$.Rect, {
    constructors: () => ({_: dart.definiteFunctionType(svg$.Rect, [])})
  });
  dart.registerExtension(dart.global.SVGRect, svg$.Rect);
  dart.defineExtensionNames([
    'height',
    'rx',
    'ry',
    'width',
    'x',
    'y'
  ]);
  svg$.RectElement = class RectElement extends svg$.GeometryElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return svg$.RectElement._check(svg$._SvgElementFactoryProvider.createSvgElement_tag("rect"));
    }
    created() {
      this[dartx.height] = null;
      this[dartx.rx] = null;
      this[dartx.ry] = null;
      this[dartx.width] = null;
      this[dartx.x] = null;
      this[dartx.y] = null;
      super.created();
    }
    get [dartx.height]() {
      return this.height;
    }
    get [dartx.rx]() {
      return this.rx;
    }
    get [dartx.ry]() {
      return this.ry;
    }
    get [dartx.width]() {
      return this.width;
    }
    get [dartx.x]() {
      return this.x;
    }
    get [dartx.y]() {
      return this.y;
    }
  };
  dart.defineNamedConstructor(svg$.RectElement, 'created');
  dart.setSignature(svg$.RectElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(svg$.RectElement, []),
      new: dart.definiteFunctionType(svg$.RectElement, []),
      created: dart.definiteFunctionType(svg$.RectElement, [])
    })
  });
  dart.registerExtension(dart.global.SVGRectElement, svg$.RectElement);
  dart.defineExtensionNames([
    'type',
    'href'
  ]);
  svg$.ScriptElement = class ScriptElement extends svg$.SvgElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return svg$.ScriptElement._check(svg$._SvgElementFactoryProvider.createSvgElement_tag("script"));
    }
    created() {
      this[dartx.type] = null;
      this[dartx.href] = null;
      super.created();
    }
    get [dartx.type]() {
      return this.type;
    }
    set [dartx.type](value) {
      this.type = value;
    }
    get [dartx.href]() {
      return this.href;
    }
  };
  dart.defineNamedConstructor(svg$.ScriptElement, 'created');
  svg$.ScriptElement[dart.implements] = () => [svg$.UriReference];
  dart.setSignature(svg$.ScriptElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(svg$.ScriptElement, []),
      new: dart.definiteFunctionType(svg$.ScriptElement, []),
      created: dart.definiteFunctionType(svg$.ScriptElement, [])
    })
  });
  dart.registerExtension(dart.global.SVGScriptElement, svg$.ScriptElement);
  svg$.SetElement = class SetElement extends svg$.AnimationElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return svg$.SetElement._check(svg$._SvgElementFactoryProvider.createSvgElement_tag("set"));
    }
    created() {
      super.created();
    }
    static get supported() {
      return dart.test(svg$.SvgElement.isTagSupported('set')) && svg$.SetElement.is(svg$.SvgElement.tag('set'));
    }
  };
  dart.defineNamedConstructor(svg$.SetElement, 'created');
  dart.setSignature(svg$.SetElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(svg$.SetElement, []),
      new: dart.definiteFunctionType(svg$.SetElement, []),
      created: dart.definiteFunctionType(svg$.SetElement, [])
    })
  });
  dart.registerExtension(dart.global.SVGSetElement, svg$.SetElement);
  dart.defineExtensionNames([
    'gradientOffset'
  ]);
  svg$.StopElement = class StopElement extends svg$.SvgElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return svg$.StopElement._check(svg$._SvgElementFactoryProvider.createSvgElement_tag("stop"));
    }
    created() {
      this[dartx.gradientOffset] = null;
      super.created();
    }
    get [dartx.gradientOffset]() {
      return this.offset;
    }
  };
  dart.defineNamedConstructor(svg$.StopElement, 'created');
  dart.setSignature(svg$.StopElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(svg$.StopElement, []),
      new: dart.definiteFunctionType(svg$.StopElement, []),
      created: dart.definiteFunctionType(svg$.StopElement, [])
    })
  });
  dart.registerExtension(dart.global.SVGStopElement, svg$.StopElement);
  dart.defineExtensionNames([
    'length',
    'get',
    'set',
    'length',
    'first',
    'last',
    'single',
    'elementAt',
    'appendItem',
    'clear',
    'getItem',
    'initialize',
    'insertItemBefore',
    'removeItem',
    'replaceItem',
    'numberOfItems'
  ]);
  svg$.StringList = class StringList extends dart.mixin(_interceptors.Interceptor, collection.ListMixin$(core.String), html$.ImmutableListMixin$(core.String)) {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.length]() {
      return this.length;
    }
    get [dartx.numberOfItems]() {
      return this.numberOfItems;
    }
    [dartx.get](index) {
      if (index >>> 0 !== index || index >= this[dartx.length]) dart.throw(core.RangeError.index(index, this));
      return this[dartx.getItem](index);
    }
    [dartx.set](index, value) {
      dart.throw(new core.UnsupportedError("Cannot assign element of immutable List."));
      return value;
    }
    set [dartx.length](value) {
      dart.throw(new core.UnsupportedError("Cannot resize immutable List."));
    }
    get [dartx.first]() {
      if (dart.notNull(this[dartx.length]) > 0) {
        return this[0];
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.last]() {
      let len = this[dartx.length];
      if (dart.notNull(len) > 0) {
        return this[dart.notNull(len) - 1];
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.single]() {
      let len = this[dartx.length];
      if (len == 1) {
        return this[0];
      }
      if (len == 0) dart.throw(new core.StateError("No elements"));
      dart.throw(new core.StateError("More than one element"));
    }
    [dartx.elementAt](index) {
      return this[dartx.get](index);
    }
    [__setter__$](index, newItem) {
      return this.__setter__(index, newItem);
    }
    [dartx.appendItem](newItem) {
      return this.appendItem(newItem);
    }
    [dartx.clear]() {
      return this.clear();
    }
    [dartx.getItem](index) {
      return this.getItem(index);
    }
    [dartx.initialize](newItem) {
      return this.initialize(newItem);
    }
    [dartx.insertItemBefore](item, index) {
      return this.insertItemBefore(item, index);
    }
    [dartx.removeItem](index) {
      return this.removeItem(index);
    }
    [dartx.replaceItem](newItem, index) {
      return this.replaceItem(newItem, index);
    }
  };
  svg$.StringList[dart.implements] = () => [ListOfString()];
  dart.setSignature(svg$.StringList, {
    constructors: () => ({_: dart.definiteFunctionType(svg$.StringList, [])}),
    methods: () => ({
      [dartx.get]: dart.definiteFunctionType(core.String, [core.int]),
      [dartx.set]: dart.definiteFunctionType(dart.void, [core.int, core.String]),
      [dartx.elementAt]: dart.definiteFunctionType(core.String, [core.int]),
      [__setter__$]: dart.definiteFunctionType(dart.void, [core.int, core.String]),
      [dartx.appendItem]: dart.definiteFunctionType(core.String, [core.String]),
      [dartx.getItem]: dart.definiteFunctionType(core.String, [core.int]),
      [dartx.initialize]: dart.definiteFunctionType(core.String, [core.String]),
      [dartx.insertItemBefore]: dart.definiteFunctionType(core.String, [core.String, core.int]),
      [dartx.removeItem]: dart.definiteFunctionType(core.String, [core.int]),
      [dartx.replaceItem]: dart.definiteFunctionType(core.String, [core.String, core.int])
    })
  });
  dart.registerExtension(dart.global.SVGStringList, svg$.StringList);
  dart.defineExtensionNames([
    'disabled',
    'media',
    'sheet',
    'type'
  ]);
  svg$.StyleElement = class StyleElement extends svg$.SvgElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return svg$.StyleElement._check(svg$._SvgElementFactoryProvider.createSvgElement_tag("style"));
    }
    created() {
      this[dartx.disabled] = null;
      this[dartx.media] = null;
      this[dartx.sheet] = null;
      this[dartx.type] = null;
      super.created();
    }
    get [dartx.disabled]() {
      return this.disabled;
    }
    set [dartx.disabled](value) {
      this.disabled = value;
    }
    get [dartx.media]() {
      return this.media;
    }
    set [dartx.media](value) {
      this.media = value;
    }
    get [dartx.sheet]() {
      return this.sheet;
    }
    get [dartx.type]() {
      return this.type;
    }
    set [dartx.type](value) {
      this.type = value;
    }
  };
  dart.defineNamedConstructor(svg$.StyleElement, 'created');
  dart.setSignature(svg$.StyleElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(svg$.StyleElement, []),
      new: dart.definiteFunctionType(svg$.StyleElement, []),
      created: dart.definiteFunctionType(svg$.StyleElement, [])
    })
  });
  dart.registerExtension(dart.global.SVGStyleElement, svg$.StyleElement);
  const _element$0 = Symbol('_element');
  svg$._AttributeClassSet = class _AttributeClassSet extends html_common.CssClassSetImpl {
    new(element) {
      this[_element$0] = element;
    }
    readClasses() {
      let classname = this[_element$0][dartx.attributes][dartx.get]('class');
      let s = LinkedHashSetOfString().new();
      if (classname == null) {
        return s;
      }
      for (let name of classname[dartx.split](' ')) {
        let trimmed = name[dartx.trim]();
        if (!dart.test(trimmed[dartx.isEmpty])) {
          s.add(trimmed);
        }
      }
      return s;
    }
    writeClasses(s) {
      this[_element$0][dartx.attributes][dartx.set]('class', s.join(' '));
    }
  };
  dart.setSignature(svg$._AttributeClassSet, {
    constructors: () => ({new: dart.definiteFunctionType(svg$._AttributeClassSet, [html$.Element])}),
    methods: () => ({
      readClasses: dart.definiteFunctionType(core.Set$(core.String), []),
      writeClasses: dart.definiteFunctionType(dart.void, [core.Set])
    })
  });
  dart.defineExtensionNames([
    'animationsPaused',
    'checkEnclosure',
    'checkIntersection',
    'createSvgAngle',
    'createSvgLength',
    'createSvgMatrix',
    'createSvgNumber',
    'createSvgPoint',
    'createSvgRect',
    'createSvgTransform',
    'createSvgTransformFromMatrix',
    'deselectAll',
    'forceRedraw',
    'getCurrentTime',
    'getElementById',
    'getEnclosureList',
    'getIntersectionList',
    'pauseAnimations',
    'setCurrentTime',
    'suspendRedraw',
    'unpauseAnimations',
    'unsuspendRedraw',
    'unsuspendRedrawAll',
    'currentScale',
    'currentTranslate',
    'currentView',
    'height',
    'pixelUnitToMillimeterX',
    'pixelUnitToMillimeterY',
    'screenPixelToMillimeterX',
    'screenPixelToMillimeterY',
    'useCurrentView',
    'viewport',
    'width',
    'x',
    'y',
    'preserveAspectRatio',
    'viewBox',
    'zoomAndPan'
  ]);
  svg$.SvgSvgElement = class SvgSvgElement extends svg$.GraphicsElement {
    static new() {
      let el = svg$.SvgElement.tag("svg");
      el[dartx.attributes][dartx.set]('version', "1.1");
      return svg$.SvgSvgElement._check(el);
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    created() {
      this[dartx.currentScale] = null;
      this[dartx.currentTranslate] = null;
      this[dartx.currentView] = null;
      this[dartx.height] = null;
      this[dartx.pixelUnitToMillimeterX] = null;
      this[dartx.pixelUnitToMillimeterY] = null;
      this[dartx.screenPixelToMillimeterX] = null;
      this[dartx.screenPixelToMillimeterY] = null;
      this[dartx.useCurrentView] = null;
      this[dartx.viewport] = null;
      this[dartx.width] = null;
      this[dartx.x] = null;
      this[dartx.y] = null;
      this[dartx.preserveAspectRatio] = null;
      this[dartx.viewBox] = null;
      this[dartx.zoomAndPan] = null;
      super.created();
    }
    get [dartx.currentScale]() {
      return this.currentScale;
    }
    set [dartx.currentScale](value) {
      this.currentScale = value;
    }
    get [dartx.currentTranslate]() {
      return this.currentTranslate;
    }
    get [dartx.currentView]() {
      return this.currentView;
    }
    get [dartx.height]() {
      return this.height;
    }
    get [dartx.pixelUnitToMillimeterX]() {
      return this.pixelUnitToMillimeterX;
    }
    get [dartx.pixelUnitToMillimeterY]() {
      return this.pixelUnitToMillimeterY;
    }
    get [dartx.screenPixelToMillimeterX]() {
      return this.screenPixelToMillimeterX;
    }
    get [dartx.screenPixelToMillimeterY]() {
      return this.screenPixelToMillimeterY;
    }
    get [dartx.useCurrentView]() {
      return this.useCurrentView;
    }
    get [dartx.viewport]() {
      return this.viewport;
    }
    get [dartx.width]() {
      return this.width;
    }
    get [dartx.x]() {
      return this.x;
    }
    get [dartx.y]() {
      return this.y;
    }
    [dartx.animationsPaused]() {
      return this.animationsPaused();
    }
    [dartx.checkEnclosure](element, rect) {
      return this.checkEnclosure(element, rect);
    }
    [dartx.checkIntersection](element, rect) {
      return this.checkIntersection(element, rect);
    }
    [dartx.createSvgAngle]() {
      return this.createSVGAngle();
    }
    [dartx.createSvgLength]() {
      return this.createSVGLength();
    }
    [dartx.createSvgMatrix]() {
      return this.createSVGMatrix();
    }
    [dartx.createSvgNumber]() {
      return this.createSVGNumber();
    }
    [dartx.createSvgPoint]() {
      return this.createSVGPoint();
    }
    [dartx.createSvgRect]() {
      return this.createSVGRect();
    }
    [dartx.createSvgTransform]() {
      return this.createSVGTransform();
    }
    [dartx.createSvgTransformFromMatrix](matrix) {
      return this.createSVGTransformFromMatrix(matrix);
    }
    [dartx.deselectAll]() {
      return this.deselectAll();
    }
    [dartx.forceRedraw]() {
      return this.forceRedraw();
    }
    [dartx.getCurrentTime]() {
      return this.getCurrentTime();
    }
    [dartx.getElementById](elementId) {
      return this.getElementById(elementId);
    }
    [dartx.getEnclosureList](rect, referenceElement) {
      return this.getEnclosureList(rect, referenceElement);
    }
    [dartx.getIntersectionList](rect, referenceElement) {
      return this.getIntersectionList(rect, referenceElement);
    }
    [dartx.pauseAnimations]() {
      return this.pauseAnimations();
    }
    [dartx.setCurrentTime](seconds) {
      return this.setCurrentTime(seconds);
    }
    [dartx.suspendRedraw](maxWaitMilliseconds) {
      return this.suspendRedraw(maxWaitMilliseconds);
    }
    [dartx.unpauseAnimations]() {
      return this.unpauseAnimations();
    }
    [dartx.unsuspendRedraw](suspendHandleId) {
      return this.unsuspendRedraw(suspendHandleId);
    }
    [dartx.unsuspendRedrawAll]() {
      return this.unsuspendRedrawAll();
    }
    get [dartx.preserveAspectRatio]() {
      return this.preserveAspectRatio;
    }
    get [dartx.viewBox]() {
      return this.viewBox;
    }
    get [dartx.zoomAndPan]() {
      return this.zoomAndPan;
    }
    set [dartx.zoomAndPan](value) {
      this.zoomAndPan = value;
    }
  };
  dart.defineNamedConstructor(svg$.SvgSvgElement, 'created');
  svg$.SvgSvgElement[dart.implements] = () => [svg$.FitToViewBox, svg$.ZoomAndPan];
  dart.setSignature(svg$.SvgSvgElement, {
    constructors: () => ({
      new: dart.definiteFunctionType(svg$.SvgSvgElement, []),
      _: dart.definiteFunctionType(svg$.SvgSvgElement, []),
      created: dart.definiteFunctionType(svg$.SvgSvgElement, [])
    }),
    methods: () => ({
      [dartx.animationsPaused]: dart.definiteFunctionType(core.bool, []),
      [dartx.checkEnclosure]: dart.definiteFunctionType(core.bool, [svg$.SvgElement, svg$.Rect]),
      [dartx.checkIntersection]: dart.definiteFunctionType(core.bool, [svg$.SvgElement, svg$.Rect]),
      [dartx.createSvgAngle]: dart.definiteFunctionType(svg$.Angle, []),
      [dartx.createSvgLength]: dart.definiteFunctionType(svg$.Length, []),
      [dartx.createSvgMatrix]: dart.definiteFunctionType(svg$.Matrix, []),
      [dartx.createSvgNumber]: dart.definiteFunctionType(svg$.Number, []),
      [dartx.createSvgPoint]: dart.definiteFunctionType(svg$.Point, []),
      [dartx.createSvgRect]: dart.definiteFunctionType(svg$.Rect, []),
      [dartx.createSvgTransform]: dart.definiteFunctionType(svg$.Transform, []),
      [dartx.createSvgTransformFromMatrix]: dart.definiteFunctionType(svg$.Transform, [svg$.Matrix]),
      [dartx.deselectAll]: dart.definiteFunctionType(dart.void, []),
      [dartx.forceRedraw]: dart.definiteFunctionType(dart.void, []),
      [dartx.getCurrentTime]: dart.definiteFunctionType(core.double, []),
      [dartx.getElementById]: dart.definiteFunctionType(html$.Element, [core.String]),
      [dartx.getEnclosureList]: dart.definiteFunctionType(core.List$(html$.Node), [svg$.Rect, svg$.SvgElement]),
      [dartx.getIntersectionList]: dart.definiteFunctionType(core.List$(html$.Node), [svg$.Rect, svg$.SvgElement]),
      [dartx.pauseAnimations]: dart.definiteFunctionType(dart.void, []),
      [dartx.setCurrentTime]: dart.definiteFunctionType(dart.void, [core.num]),
      [dartx.suspendRedraw]: dart.definiteFunctionType(core.int, [core.int]),
      [dartx.unpauseAnimations]: dart.definiteFunctionType(dart.void, []),
      [dartx.unsuspendRedraw]: dart.definiteFunctionType(dart.void, [core.int]),
      [dartx.unsuspendRedrawAll]: dart.definiteFunctionType(dart.void, [])
    })
  });
  dart.registerExtension(dart.global.SVGSVGElement, svg$.SvgSvgElement);
  svg$.SwitchElement = class SwitchElement extends svg$.GraphicsElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return svg$.SwitchElement._check(svg$._SvgElementFactoryProvider.createSvgElement_tag("switch"));
    }
    created() {
      super.created();
    }
  };
  dart.defineNamedConstructor(svg$.SwitchElement, 'created');
  dart.setSignature(svg$.SwitchElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(svg$.SwitchElement, []),
      new: dart.definiteFunctionType(svg$.SwitchElement, []),
      created: dart.definiteFunctionType(svg$.SwitchElement, [])
    })
  });
  dart.registerExtension(dart.global.SVGSwitchElement, svg$.SwitchElement);
  dart.defineExtensionNames([
    'preserveAspectRatio',
    'viewBox'
  ]);
  svg$.SymbolElement = class SymbolElement extends svg$.SvgElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return svg$.SymbolElement._check(svg$._SvgElementFactoryProvider.createSvgElement_tag("symbol"));
    }
    created() {
      this[dartx.preserveAspectRatio] = null;
      this[dartx.viewBox] = null;
      super.created();
    }
    get [dartx.preserveAspectRatio]() {
      return this.preserveAspectRatio;
    }
    get [dartx.viewBox]() {
      return this.viewBox;
    }
  };
  dart.defineNamedConstructor(svg$.SymbolElement, 'created');
  svg$.SymbolElement[dart.implements] = () => [svg$.FitToViewBox];
  dart.setSignature(svg$.SymbolElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(svg$.SymbolElement, []),
      new: dart.definiteFunctionType(svg$.SymbolElement, []),
      created: dart.definiteFunctionType(svg$.SymbolElement, [])
    })
  });
  dart.registerExtension(dart.global.SVGSymbolElement, svg$.SymbolElement);
  dart.defineExtensionNames([
    'getCharNumAtPosition',
    'getComputedTextLength',
    'getEndPositionOfChar',
    'getExtentOfChar',
    'getNumberOfChars',
    'getRotationOfChar',
    'getStartPositionOfChar',
    'getSubStringLength',
    'selectSubString',
    'lengthAdjust',
    'textLength'
  ]);
  svg$.TextContentElement = class TextContentElement extends svg$.GraphicsElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    created() {
      this[dartx.lengthAdjust] = null;
      this[dartx.textLength] = null;
      super.created();
    }
    get [dartx.lengthAdjust]() {
      return this.lengthAdjust;
    }
    get [dartx.textLength]() {
      return this.textLength;
    }
    [dartx.getCharNumAtPosition](point) {
      return this.getCharNumAtPosition(point);
    }
    [dartx.getComputedTextLength]() {
      return this.getComputedTextLength();
    }
    [dartx.getEndPositionOfChar](charnum) {
      return this.getEndPositionOfChar(charnum);
    }
    [dartx.getExtentOfChar](charnum) {
      return this.getExtentOfChar(charnum);
    }
    [dartx.getNumberOfChars]() {
      return this.getNumberOfChars();
    }
    [dartx.getRotationOfChar](charnum) {
      return this.getRotationOfChar(charnum);
    }
    [dartx.getStartPositionOfChar](charnum) {
      return this.getStartPositionOfChar(charnum);
    }
    [dartx.getSubStringLength](charnum, nchars) {
      return this.getSubStringLength(charnum, nchars);
    }
    [dartx.selectSubString](charnum, nchars) {
      return this.selectSubString(charnum, nchars);
    }
  };
  dart.defineNamedConstructor(svg$.TextContentElement, 'created');
  dart.setSignature(svg$.TextContentElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(svg$.TextContentElement, []),
      created: dart.definiteFunctionType(svg$.TextContentElement, [])
    }),
    methods: () => ({
      [dartx.getCharNumAtPosition]: dart.definiteFunctionType(core.int, [svg$.Point]),
      [dartx.getComputedTextLength]: dart.definiteFunctionType(core.double, []),
      [dartx.getEndPositionOfChar]: dart.definiteFunctionType(svg$.Point, [core.int]),
      [dartx.getExtentOfChar]: dart.definiteFunctionType(svg$.Rect, [core.int]),
      [dartx.getNumberOfChars]: dart.definiteFunctionType(core.int, []),
      [dartx.getRotationOfChar]: dart.definiteFunctionType(core.double, [core.int]),
      [dartx.getStartPositionOfChar]: dart.definiteFunctionType(svg$.Point, [core.int]),
      [dartx.getSubStringLength]: dart.definiteFunctionType(core.double, [core.int, core.int]),
      [dartx.selectSubString]: dart.definiteFunctionType(dart.void, [core.int, core.int])
    })
  });
  svg$.TextContentElement.LENGTHADJUST_SPACING = 1;
  svg$.TextContentElement.LENGTHADJUST_SPACINGANDGLYPHS = 2;
  svg$.TextContentElement.LENGTHADJUST_UNKNOWN = 0;
  dart.registerExtension(dart.global.SVGTextContentElement, svg$.TextContentElement);
  dart.defineExtensionNames([
    'dx',
    'dy',
    'rotate',
    'x',
    'y'
  ]);
  svg$.TextPositioningElement = class TextPositioningElement extends svg$.TextContentElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    created() {
      this[dartx.dx] = null;
      this[dartx.dy] = null;
      this[dartx.rotate] = null;
      this[dartx.x] = null;
      this[dartx.y] = null;
      super.created();
    }
    get [dartx.dx]() {
      return this.dx;
    }
    get [dartx.dy]() {
      return this.dy;
    }
    get [dartx.rotate]() {
      return this.rotate;
    }
    get [dartx.x]() {
      return this.x;
    }
    get [dartx.y]() {
      return this.y;
    }
  };
  dart.defineNamedConstructor(svg$.TextPositioningElement, 'created');
  dart.setSignature(svg$.TextPositioningElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(svg$.TextPositioningElement, []),
      created: dart.definiteFunctionType(svg$.TextPositioningElement, [])
    })
  });
  dart.registerExtension(dart.global.SVGTextPositioningElement, svg$.TextPositioningElement);
  svg$.TSpanElement = class TSpanElement extends svg$.TextPositioningElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return svg$.TSpanElement._check(svg$._SvgElementFactoryProvider.createSvgElement_tag("tspan"));
    }
    created() {
      super.created();
    }
  };
  dart.defineNamedConstructor(svg$.TSpanElement, 'created');
  dart.setSignature(svg$.TSpanElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(svg$.TSpanElement, []),
      new: dart.definiteFunctionType(svg$.TSpanElement, []),
      created: dart.definiteFunctionType(svg$.TSpanElement, [])
    })
  });
  dart.registerExtension(dart.global.SVGTSpanElement, svg$.TSpanElement);
  dart.defineExtensionNames([
    'requiredExtensions',
    'requiredFeatures',
    'systemLanguage'
  ]);
  svg$.Tests = class Tests extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(svg$.Tests, {
    constructors: () => ({_: dart.definiteFunctionType(svg$.Tests, [])})
  });
  dart.defineExtensionMembers(svg$.Tests, ['requiredExtensions', 'requiredFeatures', 'systemLanguage']);
  svg$.TextElement = class TextElement extends svg$.TextPositioningElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return svg$.TextElement._check(svg$._SvgElementFactoryProvider.createSvgElement_tag("text"));
    }
    created() {
      super.created();
    }
  };
  dart.defineNamedConstructor(svg$.TextElement, 'created');
  dart.setSignature(svg$.TextElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(svg$.TextElement, []),
      new: dart.definiteFunctionType(svg$.TextElement, []),
      created: dart.definiteFunctionType(svg$.TextElement, [])
    })
  });
  dart.registerExtension(dart.global.SVGTextElement, svg$.TextElement);
  dart.defineExtensionNames([
    'method',
    'spacing',
    'startOffset',
    'href'
  ]);
  svg$.TextPathElement = class TextPathElement extends svg$.TextContentElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    created() {
      this[dartx.method] = null;
      this[dartx.spacing] = null;
      this[dartx.startOffset] = null;
      this[dartx.href] = null;
      super.created();
    }
    get [dartx.method]() {
      return this.method;
    }
    get [dartx.spacing]() {
      return this.spacing;
    }
    get [dartx.startOffset]() {
      return this.startOffset;
    }
    get [dartx.href]() {
      return this.href;
    }
  };
  dart.defineNamedConstructor(svg$.TextPathElement, 'created');
  svg$.TextPathElement[dart.implements] = () => [svg$.UriReference];
  dart.setSignature(svg$.TextPathElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(svg$.TextPathElement, []),
      created: dart.definiteFunctionType(svg$.TextPathElement, [])
    })
  });
  svg$.TextPathElement.TEXTPATH_METHODTYPE_ALIGN = 1;
  svg$.TextPathElement.TEXTPATH_METHODTYPE_STRETCH = 2;
  svg$.TextPathElement.TEXTPATH_METHODTYPE_UNKNOWN = 0;
  svg$.TextPathElement.TEXTPATH_SPACINGTYPE_AUTO = 1;
  svg$.TextPathElement.TEXTPATH_SPACINGTYPE_EXACT = 2;
  svg$.TextPathElement.TEXTPATH_SPACINGTYPE_UNKNOWN = 0;
  dart.registerExtension(dart.global.SVGTextPathElement, svg$.TextPathElement);
  svg$.TitleElement = class TitleElement extends svg$.SvgElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return svg$.TitleElement._check(svg$._SvgElementFactoryProvider.createSvgElement_tag("title"));
    }
    created() {
      super.created();
    }
  };
  dart.defineNamedConstructor(svg$.TitleElement, 'created');
  dart.setSignature(svg$.TitleElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(svg$.TitleElement, []),
      new: dart.definiteFunctionType(svg$.TitleElement, []),
      created: dart.definiteFunctionType(svg$.TitleElement, [])
    })
  });
  dart.registerExtension(dart.global.SVGTitleElement, svg$.TitleElement);
  dart.defineExtensionNames([
    'setMatrix',
    'setRotate',
    'setScale',
    'setSkewX',
    'setSkewY',
    'setTranslate',
    'angle',
    'matrix',
    'type'
  ]);
  svg$.Transform = class Transform extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.angle]() {
      return this.angle;
    }
    get [dartx.matrix]() {
      return this.matrix;
    }
    get [dartx.type]() {
      return this.type;
    }
    [dartx.setMatrix](matrix) {
      return this.setMatrix(matrix);
    }
    [dartx.setRotate](angle, cx, cy) {
      return this.setRotate(angle, cx, cy);
    }
    [dartx.setScale](sx, sy) {
      return this.setScale(sx, sy);
    }
    [dartx.setSkewX](angle) {
      return this.setSkewX(angle);
    }
    [dartx.setSkewY](angle) {
      return this.setSkewY(angle);
    }
    [dartx.setTranslate](tx, ty) {
      return this.setTranslate(tx, ty);
    }
  };
  dart.setSignature(svg$.Transform, {
    constructors: () => ({_: dart.definiteFunctionType(svg$.Transform, [])}),
    methods: () => ({
      [dartx.setMatrix]: dart.definiteFunctionType(dart.void, [svg$.Matrix]),
      [dartx.setRotate]: dart.definiteFunctionType(dart.void, [core.num, core.num, core.num]),
      [dartx.setScale]: dart.definiteFunctionType(dart.void, [core.num, core.num]),
      [dartx.setSkewX]: dart.definiteFunctionType(dart.void, [core.num]),
      [dartx.setSkewY]: dart.definiteFunctionType(dart.void, [core.num]),
      [dartx.setTranslate]: dart.definiteFunctionType(dart.void, [core.num, core.num])
    })
  });
  svg$.Transform.SVG_TRANSFORM_MATRIX = 1;
  svg$.Transform.SVG_TRANSFORM_ROTATE = 4;
  svg$.Transform.SVG_TRANSFORM_SCALE = 3;
  svg$.Transform.SVG_TRANSFORM_SKEWX = 5;
  svg$.Transform.SVG_TRANSFORM_SKEWY = 6;
  svg$.Transform.SVG_TRANSFORM_TRANSLATE = 2;
  svg$.Transform.SVG_TRANSFORM_UNKNOWN = 0;
  dart.registerExtension(dart.global.SVGTransform, svg$.Transform);
  dart.defineExtensionNames([
    'length',
    'get',
    'set',
    'length',
    'first',
    'last',
    'single',
    'elementAt',
    'appendItem',
    'clear',
    'consolidate',
    'createSvgTransformFromMatrix',
    'getItem',
    'initialize',
    'insertItemBefore',
    'removeItem',
    'replaceItem',
    'numberOfItems'
  ]);
  svg$.TransformList = class TransformList extends dart.mixin(_interceptors.Interceptor, collection.ListMixin$(svg$.Transform), html$.ImmutableListMixin$(svg$.Transform)) {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.length]() {
      return this.length;
    }
    get [dartx.numberOfItems]() {
      return this.numberOfItems;
    }
    [dartx.get](index) {
      if (index >>> 0 !== index || index >= this[dartx.length]) dart.throw(core.RangeError.index(index, this));
      return this[dartx.getItem](index);
    }
    [dartx.set](index, value) {
      dart.throw(new core.UnsupportedError("Cannot assign element of immutable List."));
      return value;
    }
    set [dartx.length](value) {
      dart.throw(new core.UnsupportedError("Cannot resize immutable List."));
    }
    get [dartx.first]() {
      if (dart.notNull(this[dartx.length]) > 0) {
        return this[0];
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.last]() {
      let len = this[dartx.length];
      if (dart.notNull(len) > 0) {
        return this[dart.notNull(len) - 1];
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.single]() {
      let len = this[dartx.length];
      if (len == 1) {
        return this[0];
      }
      if (len == 0) dart.throw(new core.StateError("No elements"));
      dart.throw(new core.StateError("More than one element"));
    }
    [dartx.elementAt](index) {
      return this[dartx.get](index);
    }
    [__setter__$](index, newItem) {
      return this.__setter__(index, newItem);
    }
    [dartx.appendItem](newItem) {
      return this.appendItem(newItem);
    }
    [dartx.clear]() {
      return this.clear();
    }
    [dartx.consolidate]() {
      return this.consolidate();
    }
    [dartx.createSvgTransformFromMatrix](matrix) {
      return this.createSVGTransformFromMatrix(matrix);
    }
    [dartx.getItem](index) {
      return this.getItem(index);
    }
    [dartx.initialize](newItem) {
      return this.initialize(newItem);
    }
    [dartx.insertItemBefore](newItem, index) {
      return this.insertItemBefore(newItem, index);
    }
    [dartx.removeItem](index) {
      return this.removeItem(index);
    }
    [dartx.replaceItem](newItem, index) {
      return this.replaceItem(newItem, index);
    }
  };
  svg$.TransformList[dart.implements] = () => [ListOfTransform()];
  dart.setSignature(svg$.TransformList, {
    constructors: () => ({_: dart.definiteFunctionType(svg$.TransformList, [])}),
    methods: () => ({
      [dartx.get]: dart.definiteFunctionType(svg$.Transform, [core.int]),
      [dartx.set]: dart.definiteFunctionType(dart.void, [core.int, svg$.Transform]),
      [dartx.elementAt]: dart.definiteFunctionType(svg$.Transform, [core.int]),
      [__setter__$]: dart.definiteFunctionType(dart.void, [core.int, svg$.Transform]),
      [dartx.appendItem]: dart.definiteFunctionType(svg$.Transform, [svg$.Transform]),
      [dartx.consolidate]: dart.definiteFunctionType(svg$.Transform, []),
      [dartx.createSvgTransformFromMatrix]: dart.definiteFunctionType(svg$.Transform, [svg$.Matrix]),
      [dartx.getItem]: dart.definiteFunctionType(svg$.Transform, [core.int]),
      [dartx.initialize]: dart.definiteFunctionType(svg$.Transform, [svg$.Transform]),
      [dartx.insertItemBefore]: dart.definiteFunctionType(svg$.Transform, [svg$.Transform, core.int]),
      [dartx.removeItem]: dart.definiteFunctionType(svg$.Transform, [core.int]),
      [dartx.replaceItem]: dart.definiteFunctionType(svg$.Transform, [svg$.Transform, core.int])
    })
  });
  dart.registerExtension(dart.global.SVGTransformList, svg$.TransformList);
  svg$.UnitTypes = class UnitTypes extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(svg$.UnitTypes, {
    constructors: () => ({_: dart.definiteFunctionType(svg$.UnitTypes, [])})
  });
  svg$.UnitTypes.SVG_UNIT_TYPE_OBJECTBOUNDINGBOX = 2;
  svg$.UnitTypes.SVG_UNIT_TYPE_UNKNOWN = 0;
  svg$.UnitTypes.SVG_UNIT_TYPE_USERSPACEONUSE = 1;
  dart.registerExtension(dart.global.SVGUnitTypes, svg$.UnitTypes);
  dart.defineExtensionNames([
    'href'
  ]);
  svg$.UriReference = class UriReference extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(svg$.UriReference, {
    constructors: () => ({_: dart.definiteFunctionType(svg$.UriReference, [])})
  });
  dart.defineExtensionMembers(svg$.UriReference, ['href']);
  dart.defineExtensionNames([
    'height',
    'width',
    'x',
    'y',
    'href'
  ]);
  svg$.UseElement = class UseElement extends svg$.GraphicsElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return svg$.UseElement._check(svg$._SvgElementFactoryProvider.createSvgElement_tag("use"));
    }
    created() {
      this[dartx.height] = null;
      this[dartx.width] = null;
      this[dartx.x] = null;
      this[dartx.y] = null;
      this[dartx.href] = null;
      super.created();
    }
    get [dartx.height]() {
      return this.height;
    }
    get [dartx.width]() {
      return this.width;
    }
    get [dartx.x]() {
      return this.x;
    }
    get [dartx.y]() {
      return this.y;
    }
    get [dartx.href]() {
      return this.href;
    }
  };
  dart.defineNamedConstructor(svg$.UseElement, 'created');
  svg$.UseElement[dart.implements] = () => [svg$.UriReference];
  dart.setSignature(svg$.UseElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(svg$.UseElement, []),
      new: dart.definiteFunctionType(svg$.UseElement, []),
      created: dart.definiteFunctionType(svg$.UseElement, [])
    })
  });
  dart.registerExtension(dart.global.SVGUseElement, svg$.UseElement);
  dart.defineExtensionNames([
    'viewTarget',
    'preserveAspectRatio',
    'viewBox',
    'zoomAndPan'
  ]);
  svg$.ViewElement = class ViewElement extends svg$.SvgElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return svg$.ViewElement._check(svg$._SvgElementFactoryProvider.createSvgElement_tag("view"));
    }
    created() {
      this[dartx.viewTarget] = null;
      this[dartx.preserveAspectRatio] = null;
      this[dartx.viewBox] = null;
      this[dartx.zoomAndPan] = null;
      super.created();
    }
    get [dartx.viewTarget]() {
      return this.viewTarget;
    }
    get [dartx.preserveAspectRatio]() {
      return this.preserveAspectRatio;
    }
    get [dartx.viewBox]() {
      return this.viewBox;
    }
    get [dartx.zoomAndPan]() {
      return this.zoomAndPan;
    }
    set [dartx.zoomAndPan](value) {
      this.zoomAndPan = value;
    }
  };
  dart.defineNamedConstructor(svg$.ViewElement, 'created');
  svg$.ViewElement[dart.implements] = () => [svg$.FitToViewBox, svg$.ZoomAndPan];
  dart.setSignature(svg$.ViewElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(svg$.ViewElement, []),
      new: dart.definiteFunctionType(svg$.ViewElement, []),
      created: dart.definiteFunctionType(svg$.ViewElement, [])
    })
  });
  dart.registerExtension(dart.global.SVGViewElement, svg$.ViewElement);
  dart.defineExtensionNames([
    'preserveAspectRatioString',
    'transform',
    'transformString',
    'viewBoxString',
    'viewTarget',
    'viewTargetString',
    'preserveAspectRatio',
    'viewBox',
    'zoomAndPan'
  ]);
  svg$.ViewSpec = class ViewSpec extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.preserveAspectRatioString]() {
      return this.preserveAspectRatioString;
    }
    get [dartx.transform]() {
      return this.transform;
    }
    get [dartx.transformString]() {
      return this.transformString;
    }
    get [dartx.viewBoxString]() {
      return this.viewBoxString;
    }
    get [dartx.viewTarget]() {
      return this.viewTarget;
    }
    get [dartx.viewTargetString]() {
      return this.viewTargetString;
    }
    get [dartx.preserveAspectRatio]() {
      return this.preserveAspectRatio;
    }
    get [dartx.viewBox]() {
      return this.viewBox;
    }
    get [dartx.zoomAndPan]() {
      return this.zoomAndPan;
    }
    set [dartx.zoomAndPan](value) {
      this.zoomAndPan = value;
    }
  };
  svg$.ViewSpec[dart.implements] = () => [svg$.FitToViewBox, svg$.ZoomAndPan];
  dart.setSignature(svg$.ViewSpec, {
    constructors: () => ({_: dart.definiteFunctionType(svg$.ViewSpec, [])})
  });
  dart.registerExtension(dart.global.SVGViewSpec, svg$.ViewSpec);
  dart.defineExtensionNames([
    'zoomAndPan'
  ]);
  svg$.ZoomAndPan = class ZoomAndPan extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(svg$.ZoomAndPan, {
    constructors: () => ({_: dart.definiteFunctionType(svg$.ZoomAndPan, [])})
  });
  dart.defineExtensionMembers(svg$.ZoomAndPan, ['zoomAndPan', 'zoomAndPan']);
  svg$.ZoomAndPan.SVG_ZOOMANDPAN_DISABLE = 1;
  svg$.ZoomAndPan.SVG_ZOOMANDPAN_MAGNIFY = 2;
  svg$.ZoomAndPan.SVG_ZOOMANDPAN_UNKNOWN = 0;
  dart.defineExtensionNames([
    'newScale',
    'newTranslate',
    'previousScale',
    'previousTranslate',
    'zoomRectScreen'
  ]);
  svg$.ZoomEvent = class ZoomEvent extends html$.UIEvent {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.newScale]() {
      return this.newScale;
    }
    get [dartx.newTranslate]() {
      return this.newTranslate;
    }
    get [dartx.previousScale]() {
      return this.previousScale;
    }
    get [dartx.previousTranslate]() {
      return this.previousTranslate;
    }
    get [dartx.zoomRectScreen]() {
      return this.zoomRectScreen;
    }
  };
  dart.setSignature(svg$.ZoomEvent, {
    constructors: () => ({_: dart.definiteFunctionType(svg$.ZoomEvent, [])})
  });
  dart.registerExtension(dart.global.SVGZoomEvent, svg$.ZoomEvent);
  svg$._SVGCursorElement = class _SVGCursorElement extends svg$.SvgElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return svg$._SVGCursorElement._check(svg$._SvgElementFactoryProvider.createSvgElement_tag("cursor"));
    }
    created() {
      super.created();
    }
    static get supported() {
      return dart.test(svg$.SvgElement.isTagSupported('cursor')) && svg$._SVGCursorElement.is(svg$.SvgElement.tag('cursor'));
    }
  };
  dart.defineNamedConstructor(svg$._SVGCursorElement, 'created');
  svg$._SVGCursorElement[dart.implements] = () => [svg$.UriReference, svg$.Tests];
  dart.setSignature(svg$._SVGCursorElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(svg$._SVGCursorElement, []),
      new: dart.definiteFunctionType(svg$._SVGCursorElement, []),
      created: dart.definiteFunctionType(svg$._SVGCursorElement, [])
    })
  });
  dart.registerExtension(dart.global.SVGCursorElement, svg$._SVGCursorElement);
  svg$._SVGFEDropShadowElement = class _SVGFEDropShadowElement extends svg$.SvgElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    created() {
      super.created();
    }
  };
  dart.defineNamedConstructor(svg$._SVGFEDropShadowElement, 'created');
  svg$._SVGFEDropShadowElement[dart.implements] = () => [svg$.FilterPrimitiveStandardAttributes];
  dart.setSignature(svg$._SVGFEDropShadowElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(svg$._SVGFEDropShadowElement, []),
      created: dart.definiteFunctionType(svg$._SVGFEDropShadowElement, [])
    })
  });
  dart.registerExtension(dart.global.SVGFEDropShadowElement, svg$._SVGFEDropShadowElement);
  svg$._SVGMPathElement = class _SVGMPathElement extends svg$.SvgElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return svg$._SVGMPathElement._check(svg$._SvgElementFactoryProvider.createSvgElement_tag("mpath"));
    }
    created() {
      super.created();
    }
  };
  dart.defineNamedConstructor(svg$._SVGMPathElement, 'created');
  svg$._SVGMPathElement[dart.implements] = () => [svg$.UriReference];
  dart.setSignature(svg$._SVGMPathElement, {
    constructors: () => ({
      _: dart.definiteFunctionType(svg$._SVGMPathElement, []),
      new: dart.definiteFunctionType(svg$._SVGMPathElement, []),
      created: dart.definiteFunctionType(svg$._SVGMPathElement, [])
    })
  });
  dart.registerExtension(dart.global.SVGMPathElement, svg$._SVGMPathElement);
  const _connect = Symbol('_connect');
  dart.defineExtensionNames([
    'disconnect',
    'connectNode',
    'connectParam',
    'channelCount',
    'channelCountMode',
    'channelInterpretation',
    'context',
    'numberOfInputs',
    'numberOfOutputs'
  ]);
  web_audio.AudioNode = class AudioNode extends html$.EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.channelCount]() {
      return this.channelCount;
    }
    set [dartx.channelCount](value) {
      this.channelCount = value;
    }
    get [dartx.channelCountMode]() {
      return this.channelCountMode;
    }
    set [dartx.channelCountMode](value) {
      this.channelCountMode = value;
    }
    get [dartx.channelInterpretation]() {
      return this.channelInterpretation;
    }
    set [dartx.channelInterpretation](value) {
      this.channelInterpretation = value;
    }
    get [dartx.context]() {
      return this.context;
    }
    get [dartx.numberOfInputs]() {
      return this.numberOfInputs;
    }
    get [dartx.numberOfOutputs]() {
      return this.numberOfOutputs;
    }
    [_connect](destination, output, input) {
      return this.connect(destination, output, input);
    }
    [dartx.disconnect](output) {
      return this.disconnect(output);
    }
    [dartx.connectNode](destination, output, input) {
      if (output === void 0) output = 0;
      if (input === void 0) input = 0;
      return this[_connect](destination, output, input);
    }
    [dartx.connectParam](destination, output) {
      if (output === void 0) output = 0;
      return this[_connect](destination, output);
    }
  };
  dart.setSignature(web_audio.AudioNode, {
    constructors: () => ({_: dart.definiteFunctionType(web_audio.AudioNode, [])}),
    methods: () => ({
      [_connect]: dart.definiteFunctionType(dart.void, [dart.dynamic, core.int], [core.int]),
      [dartx.disconnect]: dart.definiteFunctionType(dart.void, [core.int]),
      [dartx.connectNode]: dart.definiteFunctionType(dart.void, [web_audio.AudioNode], [core.int, core.int]),
      [dartx.connectParam]: dart.definiteFunctionType(dart.void, [web_audio.AudioParam], [core.int])
    })
  });
  dart.registerExtension(dart.global.AudioNode, web_audio.AudioNode);
  dart.defineExtensionNames([
    'getByteFrequencyData',
    'getByteTimeDomainData',
    'getFloatFrequencyData',
    'getFloatTimeDomainData',
    'fftSize',
    'frequencyBinCount',
    'maxDecibels',
    'minDecibels',
    'smoothingTimeConstant'
  ]);
  web_audio.AnalyserNode = class AnalyserNode extends web_audio.AudioNode {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.fftSize]() {
      return this.fftSize;
    }
    set [dartx.fftSize](value) {
      this.fftSize = value;
    }
    get [dartx.frequencyBinCount]() {
      return this.frequencyBinCount;
    }
    get [dartx.maxDecibels]() {
      return this.maxDecibels;
    }
    set [dartx.maxDecibels](value) {
      this.maxDecibels = value;
    }
    get [dartx.minDecibels]() {
      return this.minDecibels;
    }
    set [dartx.minDecibels](value) {
      this.minDecibels = value;
    }
    get [dartx.smoothingTimeConstant]() {
      return this.smoothingTimeConstant;
    }
    set [dartx.smoothingTimeConstant](value) {
      this.smoothingTimeConstant = value;
    }
    [dartx.getByteFrequencyData](array) {
      return this.getByteFrequencyData(array);
    }
    [dartx.getByteTimeDomainData](array) {
      return this.getByteTimeDomainData(array);
    }
    [dartx.getFloatFrequencyData](array) {
      return this.getFloatFrequencyData(array);
    }
    [dartx.getFloatTimeDomainData](array) {
      return this.getFloatTimeDomainData(array);
    }
  };
  dart.setSignature(web_audio.AnalyserNode, {
    constructors: () => ({_: dart.definiteFunctionType(web_audio.AnalyserNode, [])}),
    methods: () => ({
      [dartx.getByteFrequencyData]: dart.definiteFunctionType(dart.void, [typed_data.Uint8List]),
      [dartx.getByteTimeDomainData]: dart.definiteFunctionType(dart.void, [typed_data.Uint8List]),
      [dartx.getFloatFrequencyData]: dart.definiteFunctionType(dart.void, [typed_data.Float32List]),
      [dartx.getFloatTimeDomainData]: dart.definiteFunctionType(dart.void, [typed_data.Float32List])
    })
  });
  dart.registerExtension(dart.global.AnalyserNode, web_audio.AnalyserNode);
  dart.defineExtensionNames([
    'getChannelData',
    'duration',
    'length',
    'numberOfChannels',
    'sampleRate'
  ]);
  web_audio.AudioBuffer = class AudioBuffer extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.duration]() {
      return this.duration;
    }
    get [dartx.length]() {
      return this.length;
    }
    get [dartx.numberOfChannels]() {
      return this.numberOfChannels;
    }
    get [dartx.sampleRate]() {
      return this.sampleRate;
    }
    [dartx.getChannelData](channelIndex) {
      return this.getChannelData(channelIndex);
    }
  };
  dart.setSignature(web_audio.AudioBuffer, {
    constructors: () => ({_: dart.definiteFunctionType(web_audio.AudioBuffer, [])}),
    methods: () => ({[dartx.getChannelData]: dart.definiteFunctionType(typed_data.Float32List, [core.int])})
  });
  dart.registerExtension(dart.global.AudioBuffer, web_audio.AudioBuffer);
  web_audio.AudioBufferCallback = dart.typedef('AudioBufferCallback', () => dart.functionType(dart.void, [web_audio.AudioBuffer]));
  web_audio.AudioSourceNode = class AudioSourceNode extends web_audio.AudioNode {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(web_audio.AudioSourceNode, {
    constructors: () => ({_: dart.definiteFunctionType(web_audio.AudioSourceNode, [])})
  });
  dart.registerExtension(dart.global.AudioSourceNode, web_audio.AudioSourceNode);
  dart.defineExtensionNames([
    'start',
    'stop',
    'onEnded',
    'buffer',
    'loop',
    'loopEnd',
    'loopStart',
    'playbackRate'
  ]);
  web_audio.AudioBufferSourceNode = class AudioBufferSourceNode extends web_audio.AudioSourceNode {
    [dartx.start](when, grainOffset, grainDuration) {
      if (grainOffset === void 0) grainOffset = null;
      if (grainDuration === void 0) grainDuration = null;
      if (!!this.start) {
        if (grainDuration != null) {
          this.start(when, grainOffset, grainDuration);
        } else if (grainOffset != null) {
          this.start(when, grainOffset);
        } else {
          this.start(when);
        }
      } else {
        if (grainDuration != null) {
          this.noteOn(when, grainOffset, grainDuration);
        } else if (grainOffset != null) {
          this.noteOn(when, grainOffset);
        } else {
          this.noteOn(when);
        }
      }
    }
    [dartx.stop](when) {
      if (!!this.stop) {
        this.stop(when);
      } else {
        this.noteOff(when);
      }
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.buffer]() {
      return this.buffer;
    }
    set [dartx.buffer](value) {
      this.buffer = value;
    }
    get [dartx.loop]() {
      return this.loop;
    }
    set [dartx.loop](value) {
      this.loop = value;
    }
    get [dartx.loopEnd]() {
      return this.loopEnd;
    }
    set [dartx.loopEnd](value) {
      this.loopEnd = value;
    }
    get [dartx.loopStart]() {
      return this.loopStart;
    }
    set [dartx.loopStart](value) {
      this.loopStart = value;
    }
    get [dartx.playbackRate]() {
      return this.playbackRate;
    }
    get [dartx.onEnded]() {
      return web_audio.AudioBufferSourceNode.endedEvent.forTarget(this);
    }
  };
  dart.setSignature(web_audio.AudioBufferSourceNode, {
    constructors: () => ({_: dart.definiteFunctionType(web_audio.AudioBufferSourceNode, [])}),
    methods: () => ({
      [dartx.start]: dart.definiteFunctionType(dart.void, [core.num], [core.num, core.num]),
      [dartx.stop]: dart.definiteFunctionType(dart.void, [core.num])
    })
  });
  web_audio.AudioBufferSourceNode.endedEvent = dart.const(new (EventStreamProviderOfEvent())('ended'));
  dart.registerExtension(dart.global.AudioBufferSourceNode, web_audio.AudioBufferSourceNode);
  const _decodeAudioData = Symbol('_decodeAudioData');
  dart.defineExtensionNames([
    'createAnalyser',
    'createBiquadFilter',
    'createBuffer',
    'createBufferSource',
    'createChannelMerger',
    'createChannelSplitter',
    'createConvolver',
    'createDelay',
    'createDynamicsCompressor',
    'createMediaElementSource',
    'createMediaStreamDestination',
    'createMediaStreamSource',
    'createOscillator',
    'createPanner',
    'createPeriodicWave',
    'createWaveShaper',
    'startRendering',
    'onComplete',
    'createGain',
    'createScriptProcessor',
    'decodeAudioData',
    'currentTime',
    'destination',
    'listener',
    'sampleRate'
  ]);
  web_audio.AudioContext = class AudioContext extends html$.EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static get supported() {
      return !!(window.AudioContext || window.webkitAudioContext);
    }
    get [dartx.currentTime]() {
      return this.currentTime;
    }
    get [dartx.destination]() {
      return this.destination;
    }
    get [dartx.listener]() {
      return this.listener;
    }
    get [dartx.sampleRate]() {
      return this.sampleRate;
    }
    [dartx.createAnalyser]() {
      return this.createAnalyser();
    }
    [dartx.createBiquadFilter]() {
      return this.createBiquadFilter();
    }
    [dartx.createBuffer](numberOfChannels, numberOfFrames, sampleRate) {
      return this.createBuffer(numberOfChannels, numberOfFrames, sampleRate);
    }
    [dartx.createBufferSource]() {
      return this.createBufferSource();
    }
    [dartx.createChannelMerger](numberOfInputs) {
      return this.createChannelMerger(numberOfInputs);
    }
    [dartx.createChannelSplitter](numberOfOutputs) {
      return this.createChannelSplitter(numberOfOutputs);
    }
    [dartx.createConvolver]() {
      return this.createConvolver();
    }
    [dartx.createDelay](maxDelayTime) {
      return this.createDelay(maxDelayTime);
    }
    [dartx.createDynamicsCompressor]() {
      return this.createDynamicsCompressor();
    }
    [dartx.createMediaElementSource](mediaElement) {
      return this.createMediaElementSource(mediaElement);
    }
    [dartx.createMediaStreamDestination]() {
      return this.createMediaStreamDestination();
    }
    [dartx.createMediaStreamSource](mediaStream) {
      return this.createMediaStreamSource(mediaStream);
    }
    [dartx.createOscillator]() {
      return this.createOscillator();
    }
    [dartx.createPanner]() {
      return this.createPanner();
    }
    [dartx.createPeriodicWave](real, imag) {
      return this.createPeriodicWave(real, imag);
    }
    [dartx.createWaveShaper]() {
      return this.createWaveShaper();
    }
    [_decodeAudioData](audioData, successCallback, errorCallback) {
      return this.decodeAudioData(audioData, successCallback, errorCallback);
    }
    [dartx.startRendering]() {
      return this.startRendering();
    }
    get [dartx.onComplete]() {
      return web_audio.AudioContext.completeEvent.forTarget(this);
    }
    static new() {
      return new (window.AudioContext || window.webkitAudioContext)();
    }
    [dartx.createGain]() {
      if (this.createGain !== undefined) {
        return this.createGain();
      } else {
        return this.createGainNode();
      }
    }
    [dartx.createScriptProcessor](bufferSize, numberOfInputChannels, numberOfOutputChannels) {
      if (numberOfInputChannels === void 0) numberOfInputChannels = null;
      if (numberOfOutputChannels === void 0) numberOfOutputChannels = null;
      let func = this.createScriptProcessor || this.createJavaScriptNode;
      if (numberOfOutputChannels != null) {
        return func.call(this, bufferSize, numberOfInputChannels, numberOfOutputChannels);
      } else if (numberOfInputChannels != null) {
        return func.call(this, bufferSize, numberOfInputChannels);
      } else {
        return func.call(this, bufferSize);
      }
    }
    [dartx.decodeAudioData](audioData) {
      let completer = CompleterOfAudioBuffer().new();
      this[_decodeAudioData](audioData, dart.fn(value => {
        completer.complete(value);
      }, AudioBufferTovoid()), dart.fn(error => {
        if (error == null) {
          completer.completeError('');
        } else {
          completer.completeError(error);
        }
      }, AudioBufferTovoid()));
      return completer.future;
    }
  };
  dart.setSignature(web_audio.AudioContext, {
    constructors: () => ({
      _: dart.definiteFunctionType(web_audio.AudioContext, []),
      new: dart.definiteFunctionType(web_audio.AudioContext, [])
    }),
    methods: () => ({
      [dartx.createAnalyser]: dart.definiteFunctionType(web_audio.AnalyserNode, []),
      [dartx.createBiquadFilter]: dart.definiteFunctionType(web_audio.BiquadFilterNode, []),
      [dartx.createBuffer]: dart.definiteFunctionType(web_audio.AudioBuffer, [core.int, core.int, core.num]),
      [dartx.createBufferSource]: dart.definiteFunctionType(web_audio.AudioBufferSourceNode, []),
      [dartx.createChannelMerger]: dart.definiteFunctionType(web_audio.ChannelMergerNode, [], [core.int]),
      [dartx.createChannelSplitter]: dart.definiteFunctionType(web_audio.ChannelSplitterNode, [], [core.int]),
      [dartx.createConvolver]: dart.definiteFunctionType(web_audio.ConvolverNode, []),
      [dartx.createDelay]: dart.definiteFunctionType(web_audio.DelayNode, [], [core.num]),
      [dartx.createDynamicsCompressor]: dart.definiteFunctionType(web_audio.DynamicsCompressorNode, []),
      [dartx.createMediaElementSource]: dart.definiteFunctionType(web_audio.MediaElementAudioSourceNode, [html$.MediaElement]),
      [dartx.createMediaStreamDestination]: dart.definiteFunctionType(web_audio.MediaStreamAudioDestinationNode, []),
      [dartx.createMediaStreamSource]: dart.definiteFunctionType(web_audio.MediaStreamAudioSourceNode, [html$.MediaStream]),
      [dartx.createOscillator]: dart.definiteFunctionType(web_audio.OscillatorNode, []),
      [dartx.createPanner]: dart.definiteFunctionType(web_audio.PannerNode, []),
      [dartx.createPeriodicWave]: dart.definiteFunctionType(web_audio.PeriodicWave, [typed_data.Float32List, typed_data.Float32List]),
      [dartx.createWaveShaper]: dart.definiteFunctionType(web_audio.WaveShaperNode, []),
      [_decodeAudioData]: dart.definiteFunctionType(dart.void, [typed_data.ByteBuffer, web_audio.AudioBufferCallback], [web_audio.AudioBufferCallback]),
      [dartx.startRendering]: dart.definiteFunctionType(dart.void, []),
      [dartx.createGain]: dart.definiteFunctionType(web_audio.GainNode, []),
      [dartx.createScriptProcessor]: dart.definiteFunctionType(web_audio.ScriptProcessorNode, [core.int], [core.int, core.int]),
      [dartx.decodeAudioData]: dart.definiteFunctionType(async.Future$(web_audio.AudioBuffer), [typed_data.ByteBuffer])
    })
  });
  web_audio.AudioContext.completeEvent = dart.const(new (EventStreamProviderOfEvent())('complete'));
  dart.registerExtension(dart.global.AudioContext, web_audio.AudioContext);
  dart.defineExtensionNames([
    'maxChannelCount'
  ]);
  web_audio.AudioDestinationNode = class AudioDestinationNode extends web_audio.AudioNode {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.maxChannelCount]() {
      return this.maxChannelCount;
    }
  };
  dart.setSignature(web_audio.AudioDestinationNode, {
    constructors: () => ({_: dart.definiteFunctionType(web_audio.AudioDestinationNode, [])})
  });
  dart.registerExtension(dart.global.AudioDestinationNode, web_audio.AudioDestinationNode);
  dart.defineExtensionNames([
    'setOrientation',
    'setPosition',
    'setVelocity',
    'dopplerFactor',
    'speedOfSound'
  ]);
  web_audio.AudioListener = class AudioListener extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.dopplerFactor]() {
      return this.dopplerFactor;
    }
    set [dartx.dopplerFactor](value) {
      this.dopplerFactor = value;
    }
    get [dartx.speedOfSound]() {
      return this.speedOfSound;
    }
    set [dartx.speedOfSound](value) {
      this.speedOfSound = value;
    }
    [dartx.setOrientation](x, y, z, xUp, yUp, zUp) {
      return this.setOrientation(x, y, z, xUp, yUp, zUp);
    }
    [dartx.setPosition](x, y, z) {
      return this.setPosition(x, y, z);
    }
    [dartx.setVelocity](x, y, z) {
      return this.setVelocity(x, y, z);
    }
  };
  dart.setSignature(web_audio.AudioListener, {
    constructors: () => ({_: dart.definiteFunctionType(web_audio.AudioListener, [])}),
    methods: () => ({
      [dartx.setOrientation]: dart.definiteFunctionType(dart.void, [core.num, core.num, core.num, core.num, core.num, core.num]),
      [dartx.setPosition]: dart.definiteFunctionType(dart.void, [core.num, core.num, core.num]),
      [dartx.setVelocity]: dart.definiteFunctionType(dart.void, [core.num, core.num, core.num])
    })
  });
  dart.registerExtension(dart.global.AudioListener, web_audio.AudioListener);
  dart.defineExtensionNames([
    'cancelScheduledValues',
    'exponentialRampToValueAtTime',
    'linearRampToValueAtTime',
    'setTargetAtTime',
    'setValueAtTime',
    'setValueCurveAtTime',
    'defaultValue',
    'value'
  ]);
  web_audio.AudioParam = class AudioParam extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.defaultValue]() {
      return this.defaultValue;
    }
    get [dartx.value]() {
      return this.value;
    }
    set [dartx.value](value) {
      this.value = value;
    }
    [dartx.cancelScheduledValues](startTime) {
      return this.cancelScheduledValues(startTime);
    }
    [dartx.exponentialRampToValueAtTime](value, time) {
      return this.exponentialRampToValueAtTime(value, time);
    }
    [dartx.linearRampToValueAtTime](value, time) {
      return this.linearRampToValueAtTime(value, time);
    }
    [dartx.setTargetAtTime](target, time, timeConstant) {
      return this.setTargetAtTime(target, time, timeConstant);
    }
    [dartx.setValueAtTime](value, time) {
      return this.setValueAtTime(value, time);
    }
    [dartx.setValueCurveAtTime](values, time, duration) {
      return this.setValueCurveAtTime(values, time, duration);
    }
  };
  dart.setSignature(web_audio.AudioParam, {
    constructors: () => ({_: dart.definiteFunctionType(web_audio.AudioParam, [])}),
    methods: () => ({
      [dartx.cancelScheduledValues]: dart.definiteFunctionType(dart.void, [core.num]),
      [dartx.exponentialRampToValueAtTime]: dart.definiteFunctionType(dart.void, [core.num, core.num]),
      [dartx.linearRampToValueAtTime]: dart.definiteFunctionType(dart.void, [core.num, core.num]),
      [dartx.setTargetAtTime]: dart.definiteFunctionType(dart.void, [core.num, core.num, core.num]),
      [dartx.setValueAtTime]: dart.definiteFunctionType(dart.void, [core.num, core.num]),
      [dartx.setValueCurveAtTime]: dart.definiteFunctionType(dart.void, [typed_data.Float32List, core.num, core.num])
    })
  });
  dart.registerExtension(dart.global.AudioParam, web_audio.AudioParam);
  dart.defineExtensionNames([
    'inputBuffer',
    'outputBuffer',
    'playbackTime'
  ]);
  web_audio.AudioProcessingEvent = class AudioProcessingEvent extends html$.Event {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.inputBuffer]() {
      return this.inputBuffer;
    }
    get [dartx.outputBuffer]() {
      return this.outputBuffer;
    }
    get [dartx.playbackTime]() {
      return this.playbackTime;
    }
  };
  dart.setSignature(web_audio.AudioProcessingEvent, {
    constructors: () => ({_: dart.definiteFunctionType(web_audio.AudioProcessingEvent, [])})
  });
  dart.registerExtension(dart.global.AudioProcessingEvent, web_audio.AudioProcessingEvent);
  dart.defineExtensionNames([
    'getFrequencyResponse',
    'Q',
    'detune',
    'frequency',
    'gain',
    'type'
  ]);
  web_audio.BiquadFilterNode = class BiquadFilterNode extends web_audio.AudioNode {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.Q]() {
      return this.Q;
    }
    get [dartx.detune]() {
      return this.detune;
    }
    get [dartx.frequency]() {
      return this.frequency;
    }
    get [dartx.gain]() {
      return this.gain;
    }
    get [dartx.type]() {
      return this.type;
    }
    set [dartx.type](value) {
      this.type = value;
    }
    [dartx.getFrequencyResponse](frequencyHz, magResponse, phaseResponse) {
      return this.getFrequencyResponse(frequencyHz, magResponse, phaseResponse);
    }
  };
  dart.setSignature(web_audio.BiquadFilterNode, {
    constructors: () => ({_: dart.definiteFunctionType(web_audio.BiquadFilterNode, [])}),
    methods: () => ({[dartx.getFrequencyResponse]: dart.definiteFunctionType(dart.void, [typed_data.Float32List, typed_data.Float32List, typed_data.Float32List])})
  });
  dart.registerExtension(dart.global.BiquadFilterNode, web_audio.BiquadFilterNode);
  web_audio.ChannelMergerNode = class ChannelMergerNode extends web_audio.AudioNode {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(web_audio.ChannelMergerNode, {
    constructors: () => ({_: dart.definiteFunctionType(web_audio.ChannelMergerNode, [])})
  });
  dart.registerExtension(dart.global.ChannelMergerNode, web_audio.ChannelMergerNode);
  web_audio.ChannelSplitterNode = class ChannelSplitterNode extends web_audio.AudioNode {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(web_audio.ChannelSplitterNode, {
    constructors: () => ({_: dart.definiteFunctionType(web_audio.ChannelSplitterNode, [])})
  });
  dart.registerExtension(dart.global.ChannelSplitterNode, web_audio.ChannelSplitterNode);
  dart.defineExtensionNames([
    'buffer',
    'normalize'
  ]);
  web_audio.ConvolverNode = class ConvolverNode extends web_audio.AudioNode {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.buffer]() {
      return this.buffer;
    }
    set [dartx.buffer](value) {
      this.buffer = value;
    }
    get [dartx.normalize]() {
      return this.normalize;
    }
    set [dartx.normalize](value) {
      this.normalize = value;
    }
  };
  dart.setSignature(web_audio.ConvolverNode, {
    constructors: () => ({_: dart.definiteFunctionType(web_audio.ConvolverNode, [])})
  });
  dart.registerExtension(dart.global.ConvolverNode, web_audio.ConvolverNode);
  dart.defineExtensionNames([
    'delayTime'
  ]);
  web_audio.DelayNode = class DelayNode extends web_audio.AudioNode {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.delayTime]() {
      return this.delayTime;
    }
  };
  dart.setSignature(web_audio.DelayNode, {
    constructors: () => ({_: dart.definiteFunctionType(web_audio.DelayNode, [])})
  });
  dart.registerExtension(dart.global.DelayNode, web_audio.DelayNode);
  dart.defineExtensionNames([
    'attack',
    'knee',
    'ratio',
    'reduction',
    'release',
    'threshold'
  ]);
  web_audio.DynamicsCompressorNode = class DynamicsCompressorNode extends web_audio.AudioNode {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.attack]() {
      return this.attack;
    }
    get [dartx.knee]() {
      return this.knee;
    }
    get [dartx.ratio]() {
      return this.ratio;
    }
    get [dartx.reduction]() {
      return this.reduction;
    }
    get [dartx.release]() {
      return this.release;
    }
    get [dartx.threshold]() {
      return this.threshold;
    }
  };
  dart.setSignature(web_audio.DynamicsCompressorNode, {
    constructors: () => ({_: dart.definiteFunctionType(web_audio.DynamicsCompressorNode, [])})
  });
  dart.registerExtension(dart.global.DynamicsCompressorNode, web_audio.DynamicsCompressorNode);
  dart.defineExtensionNames([
    'gain'
  ]);
  web_audio.GainNode = class GainNode extends web_audio.AudioNode {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.gain]() {
      return this.gain;
    }
  };
  dart.setSignature(web_audio.GainNode, {
    constructors: () => ({_: dart.definiteFunctionType(web_audio.GainNode, [])})
  });
  dart.registerExtension(dart.global.GainNode, web_audio.GainNode);
  dart.defineExtensionNames([
    'mediaElement'
  ]);
  web_audio.MediaElementAudioSourceNode = class MediaElementAudioSourceNode extends web_audio.AudioSourceNode {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.mediaElement]() {
      return this.mediaElement;
    }
  };
  dart.setSignature(web_audio.MediaElementAudioSourceNode, {
    constructors: () => ({_: dart.definiteFunctionType(web_audio.MediaElementAudioSourceNode, [])})
  });
  dart.registerExtension(dart.global.MediaElementAudioSourceNode, web_audio.MediaElementAudioSourceNode);
  dart.defineExtensionNames([
    'stream'
  ]);
  web_audio.MediaStreamAudioDestinationNode = class MediaStreamAudioDestinationNode extends web_audio.AudioNode {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.stream]() {
      return this.stream;
    }
  };
  dart.setSignature(web_audio.MediaStreamAudioDestinationNode, {
    constructors: () => ({_: dart.definiteFunctionType(web_audio.MediaStreamAudioDestinationNode, [])})
  });
  dart.registerExtension(dart.global.MediaStreamAudioDestinationNode, web_audio.MediaStreamAudioDestinationNode);
  dart.defineExtensionNames([
    'mediaStream'
  ]);
  web_audio.MediaStreamAudioSourceNode = class MediaStreamAudioSourceNode extends web_audio.AudioSourceNode {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.mediaStream]() {
      return this.mediaStream;
    }
  };
  dart.setSignature(web_audio.MediaStreamAudioSourceNode, {
    constructors: () => ({_: dart.definiteFunctionType(web_audio.MediaStreamAudioSourceNode, [])})
  });
  dart.registerExtension(dart.global.MediaStreamAudioSourceNode, web_audio.MediaStreamAudioSourceNode);
  dart.defineExtensionNames([
    'renderedBuffer'
  ]);
  web_audio.OfflineAudioCompletionEvent = class OfflineAudioCompletionEvent extends html$.Event {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.renderedBuffer]() {
      return this.renderedBuffer;
    }
  };
  dart.setSignature(web_audio.OfflineAudioCompletionEvent, {
    constructors: () => ({_: dart.definiteFunctionType(web_audio.OfflineAudioCompletionEvent, [])})
  });
  dart.registerExtension(dart.global.OfflineAudioCompletionEvent, web_audio.OfflineAudioCompletionEvent);
  web_audio.OfflineAudioContext = class OfflineAudioContext extends web_audio.AudioContext {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(numberOfChannels, numberOfFrames, sampleRate) {
      return web_audio.OfflineAudioContext._create_1(numberOfChannels, numberOfFrames, sampleRate);
    }
    static _create_1(numberOfChannels, numberOfFrames, sampleRate) {
      return new OfflineAudioContext(numberOfChannels, numberOfFrames, sampleRate);
    }
  };
  dart.setSignature(web_audio.OfflineAudioContext, {
    constructors: () => ({
      _: dart.definiteFunctionType(web_audio.OfflineAudioContext, []),
      new: dart.definiteFunctionType(web_audio.OfflineAudioContext, [core.int, core.int, core.num])
    }),
    statics: () => ({_create_1: dart.definiteFunctionType(web_audio.OfflineAudioContext, [dart.dynamic, dart.dynamic, dart.dynamic])}),
    names: ['_create_1']
  });
  dart.registerExtension(dart.global.OfflineAudioContext, web_audio.OfflineAudioContext);
  dart.defineExtensionNames([
    'noteOff',
    'noteOn',
    'setPeriodicWave',
    'start',
    'stop',
    'onEnded',
    'detune',
    'frequency',
    'type'
  ]);
  web_audio.OscillatorNode = class OscillatorNode extends web_audio.AudioSourceNode {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.detune]() {
      return this.detune;
    }
    get [dartx.frequency]() {
      return this.frequency;
    }
    get [dartx.type]() {
      return this.type;
    }
    set [dartx.type](value) {
      this.type = value;
    }
    [dartx.noteOff](when) {
      return this.noteOff(when);
    }
    [dartx.noteOn](when) {
      return this.noteOn(when);
    }
    [dartx.setPeriodicWave](periodicWave) {
      return this.setPeriodicWave(periodicWave);
    }
    [dartx.start](when) {
      return this.start(when);
    }
    [dartx.stop](when) {
      return this.stop(when);
    }
    get [dartx.onEnded]() {
      return web_audio.OscillatorNode.endedEvent.forTarget(this);
    }
  };
  dart.setSignature(web_audio.OscillatorNode, {
    constructors: () => ({_: dart.definiteFunctionType(web_audio.OscillatorNode, [])}),
    methods: () => ({
      [dartx.noteOff]: dart.definiteFunctionType(dart.void, [core.num]),
      [dartx.noteOn]: dart.definiteFunctionType(dart.void, [core.num]),
      [dartx.setPeriodicWave]: dart.definiteFunctionType(dart.void, [web_audio.PeriodicWave]),
      [dartx.start]: dart.definiteFunctionType(dart.void, [], [core.num]),
      [dartx.stop]: dart.definiteFunctionType(dart.void, [], [core.num])
    })
  });
  web_audio.OscillatorNode.endedEvent = dart.const(new (EventStreamProviderOfEvent())('ended'));
  dart.registerExtension(dart.global.OscillatorNode, web_audio.OscillatorNode);
  dart.defineExtensionNames([
    'setOrientation',
    'setPosition',
    'setVelocity',
    'coneInnerAngle',
    'coneOuterAngle',
    'coneOuterGain',
    'distanceModel',
    'maxDistance',
    'panningModel',
    'refDistance',
    'rolloffFactor'
  ]);
  web_audio.PannerNode = class PannerNode extends web_audio.AudioNode {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.coneInnerAngle]() {
      return this.coneInnerAngle;
    }
    set [dartx.coneInnerAngle](value) {
      this.coneInnerAngle = value;
    }
    get [dartx.coneOuterAngle]() {
      return this.coneOuterAngle;
    }
    set [dartx.coneOuterAngle](value) {
      this.coneOuterAngle = value;
    }
    get [dartx.coneOuterGain]() {
      return this.coneOuterGain;
    }
    set [dartx.coneOuterGain](value) {
      this.coneOuterGain = value;
    }
    get [dartx.distanceModel]() {
      return this.distanceModel;
    }
    set [dartx.distanceModel](value) {
      this.distanceModel = value;
    }
    get [dartx.maxDistance]() {
      return this.maxDistance;
    }
    set [dartx.maxDistance](value) {
      this.maxDistance = value;
    }
    get [dartx.panningModel]() {
      return this.panningModel;
    }
    set [dartx.panningModel](value) {
      this.panningModel = value;
    }
    get [dartx.refDistance]() {
      return this.refDistance;
    }
    set [dartx.refDistance](value) {
      this.refDistance = value;
    }
    get [dartx.rolloffFactor]() {
      return this.rolloffFactor;
    }
    set [dartx.rolloffFactor](value) {
      this.rolloffFactor = value;
    }
    [dartx.setOrientation](x, y, z) {
      return this.setOrientation(x, y, z);
    }
    [dartx.setPosition](x, y, z) {
      return this.setPosition(x, y, z);
    }
    [dartx.setVelocity](x, y, z) {
      return this.setVelocity(x, y, z);
    }
  };
  dart.setSignature(web_audio.PannerNode, {
    constructors: () => ({_: dart.definiteFunctionType(web_audio.PannerNode, [])}),
    methods: () => ({
      [dartx.setOrientation]: dart.definiteFunctionType(dart.void, [core.num, core.num, core.num]),
      [dartx.setPosition]: dart.definiteFunctionType(dart.void, [core.num, core.num, core.num]),
      [dartx.setVelocity]: dart.definiteFunctionType(dart.void, [core.num, core.num, core.num])
    })
  });
  dart.registerExtension(dart.global.PannerNode, web_audio.PannerNode);
  web_audio.PeriodicWave = class PeriodicWave extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(web_audio.PeriodicWave, {
    constructors: () => ({_: dart.definiteFunctionType(web_audio.PeriodicWave, [])})
  });
  dart.registerExtension(dart.global.PeriodicWave, web_audio.PeriodicWave);
  dart.defineExtensionNames([
    'setEventListener',
    'onAudioProcess',
    'bufferSize'
  ]);
  web_audio.ScriptProcessorNode = class ScriptProcessorNode extends web_audio.AudioNode {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.bufferSize]() {
      return this.bufferSize;
    }
    [dartx.setEventListener](eventListener) {
      return this.setEventListener(eventListener);
    }
    get [dartx.onAudioProcess]() {
      return web_audio.ScriptProcessorNode.audioProcessEvent.forTarget(this);
    }
  };
  dart.setSignature(web_audio.ScriptProcessorNode, {
    constructors: () => ({_: dart.definiteFunctionType(web_audio.ScriptProcessorNode, [])}),
    methods: () => ({[dartx.setEventListener]: dart.definiteFunctionType(dart.void, [html$.EventListener])})
  });
  web_audio.ScriptProcessorNode.audioProcessEvent = dart.const(new (EventStreamProviderOfAudioProcessingEvent())('audioprocess'));
  dart.registerExtension(dart.global.ScriptProcessorNode, web_audio.ScriptProcessorNode);
  dart.defineExtensionNames([
    'curve',
    'oversample'
  ]);
  web_audio.WaveShaperNode = class WaveShaperNode extends web_audio.AudioNode {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.curve]() {
      return this.curve;
    }
    set [dartx.curve](value) {
      this.curve = value;
    }
    get [dartx.oversample]() {
      return this.oversample;
    }
    set [dartx.oversample](value) {
      this.oversample = value;
    }
  };
  dart.setSignature(web_audio.WaveShaperNode, {
    constructors: () => ({_: dart.definiteFunctionType(web_audio.WaveShaperNode, [])})
  });
  dart.registerExtension(dart.global.WaveShaperNode, web_audio.WaveShaperNode);
  const _getContextAttributes_1$ = Symbol('_getContextAttributes_1');
  const _texImage2D_1 = Symbol('_texImage2D_1');
  const _texImage2D_2 = Symbol('_texImage2D_2');
  const _texImage2D_3 = Symbol('_texImage2D_3');
  const _texImage2D_4 = Symbol('_texImage2D_4');
  const _texImage2D_5 = Symbol('_texImage2D_5');
  const _texImage2DImageData_1 = Symbol('_texImage2DImageData_1');
  const _texSubImage2D_1 = Symbol('_texSubImage2D_1');
  const _texSubImage2D_2 = Symbol('_texSubImage2D_2');
  const _texSubImage2D_3 = Symbol('_texSubImage2D_3');
  const _texSubImage2D_4 = Symbol('_texSubImage2D_4');
  const _texSubImage2D_5 = Symbol('_texSubImage2D_5');
  const _texSubImage2DImageData_1 = Symbol('_texSubImage2DImageData_1');
  dart.defineExtensionNames([
    'activeTexture',
    'attachShader',
    'bindAttribLocation',
    'bindBuffer',
    'bindFramebuffer',
    'bindRenderbuffer',
    'bindTexture',
    'blendColor',
    'blendEquation',
    'blendEquationSeparate',
    'blendFunc',
    'blendFuncSeparate',
    'bufferByteData',
    'bufferData',
    'bufferDataTyped',
    'bufferSubByteData',
    'bufferSubData',
    'bufferSubDataTyped',
    'checkFramebufferStatus',
    'clear',
    'clearColor',
    'clearDepth',
    'clearStencil',
    'colorMask',
    'compileShader',
    'compressedTexImage2D',
    'compressedTexSubImage2D',
    'copyTexImage2D',
    'copyTexSubImage2D',
    'createBuffer',
    'createFramebuffer',
    'createProgram',
    'createRenderbuffer',
    'createShader',
    'createTexture',
    'cullFace',
    'deleteBuffer',
    'deleteFramebuffer',
    'deleteProgram',
    'deleteRenderbuffer',
    'deleteShader',
    'deleteTexture',
    'depthFunc',
    'depthMask',
    'depthRange',
    'detachShader',
    'disable',
    'disableVertexAttribArray',
    'drawArrays',
    'drawElements',
    'enable',
    'enableVertexAttribArray',
    'finish',
    'flush',
    'framebufferRenderbuffer',
    'framebufferTexture2D',
    'frontFace',
    'generateMipmap',
    'getActiveAttrib',
    'getActiveUniform',
    'getAttachedShaders',
    'getAttribLocation',
    'getBufferParameter',
    'getContextAttributes',
    'getError',
    'getExtension',
    'getFramebufferAttachmentParameter',
    'getParameter',
    'getProgramInfoLog',
    'getProgramParameter',
    'getRenderbufferParameter',
    'getShaderInfoLog',
    'getShaderParameter',
    'getShaderPrecisionFormat',
    'getShaderSource',
    'getSupportedExtensions',
    'getTexParameter',
    'getUniform',
    'getUniformLocation',
    'getVertexAttrib',
    'getVertexAttribOffset',
    'hint',
    'isBuffer',
    'isContextLost',
    'isEnabled',
    'isFramebuffer',
    'isProgram',
    'isRenderbuffer',
    'isShader',
    'isTexture',
    'lineWidth',
    'linkProgram',
    'pixelStorei',
    'polygonOffset',
    'readPixels',
    'renderbufferStorage',
    'sampleCoverage',
    'scissor',
    'shaderSource',
    'stencilFunc',
    'stencilFuncSeparate',
    'stencilMask',
    'stencilMaskSeparate',
    'stencilOp',
    'stencilOpSeparate',
    'texImage2D',
    'texImage2DCanvas',
    'texImage2DImage',
    'texImage2DImageData',
    'texImage2DVideo',
    'texParameterf',
    'texParameteri',
    'texSubImage2D',
    'texSubImage2DCanvas',
    'texSubImage2DImage',
    'texSubImage2DImageData',
    'texSubImage2DVideo',
    'uniform1f',
    'uniform1fv',
    'uniform1i',
    'uniform1iv',
    'uniform2f',
    'uniform2fv',
    'uniform2i',
    'uniform2iv',
    'uniform3f',
    'uniform3fv',
    'uniform3i',
    'uniform3iv',
    'uniform4f',
    'uniform4fv',
    'uniform4i',
    'uniform4iv',
    'uniformMatrix2fv',
    'uniformMatrix3fv',
    'uniformMatrix4fv',
    'useProgram',
    'validateProgram',
    'vertexAttrib1f',
    'vertexAttrib1fv',
    'vertexAttrib2f',
    'vertexAttrib2fv',
    'vertexAttrib3f',
    'vertexAttrib3fv',
    'vertexAttrib4f',
    'vertexAttrib4fv',
    'vertexAttribPointer',
    'viewport',
    'texImage2DUntyped',
    'texImage2DTyped',
    'texSubImage2DUntyped',
    'texSubImage2DTyped',
    'canvas',
    'drawingBufferHeight',
    'drawingBufferWidth'
  ]);
  web_gl.RenderingContext = class RenderingContext extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static get supported() {
      return !!window.WebGLRenderingContext;
    }
    get [dartx.canvas]() {
      return this.canvas;
    }
    get [dartx.drawingBufferHeight]() {
      return this.drawingBufferHeight;
    }
    get [dartx.drawingBufferWidth]() {
      return this.drawingBufferWidth;
    }
    [dartx.activeTexture](texture) {
      return this.activeTexture(texture);
    }
    [dartx.attachShader](program, shader) {
      return this.attachShader(program, shader);
    }
    [dartx.bindAttribLocation](program, index, name) {
      return this.bindAttribLocation(program, index, name);
    }
    [dartx.bindBuffer](target, buffer) {
      return this.bindBuffer(target, buffer);
    }
    [dartx.bindFramebuffer](target, framebuffer) {
      return this.bindFramebuffer(target, framebuffer);
    }
    [dartx.bindRenderbuffer](target, renderbuffer) {
      return this.bindRenderbuffer(target, renderbuffer);
    }
    [dartx.bindTexture](target, texture) {
      return this.bindTexture(target, texture);
    }
    [dartx.blendColor](red, green, blue, alpha) {
      return this.blendColor(red, green, blue, alpha);
    }
    [dartx.blendEquation](mode) {
      return this.blendEquation(mode);
    }
    [dartx.blendEquationSeparate](modeRGB, modeAlpha) {
      return this.blendEquationSeparate(modeRGB, modeAlpha);
    }
    [dartx.blendFunc](sfactor, dfactor) {
      return this.blendFunc(sfactor, dfactor);
    }
    [dartx.blendFuncSeparate](srcRGB, dstRGB, srcAlpha, dstAlpha) {
      return this.blendFuncSeparate(srcRGB, dstRGB, srcAlpha, dstAlpha);
    }
    [dartx.bufferByteData](target, data, usage) {
      return this.bufferData(target, data, usage);
    }
    [dartx.bufferData](target, data_OR_size, usage) {
      return this.bufferData(target, data_OR_size, usage);
    }
    [dartx.bufferDataTyped](target, data, usage) {
      return this.bufferData(target, data, usage);
    }
    [dartx.bufferSubByteData](target, offset, data) {
      return this.bufferSubData(target, offset, data);
    }
    [dartx.bufferSubData](target, offset, data) {
      return this.bufferSubData(target, offset, data);
    }
    [dartx.bufferSubDataTyped](target, offset, data) {
      return this.bufferSubData(target, offset, data);
    }
    [dartx.checkFramebufferStatus](target) {
      return this.checkFramebufferStatus(target);
    }
    [dartx.clear](mask) {
      return this.clear(mask);
    }
    [dartx.clearColor](red, green, blue, alpha) {
      return this.clearColor(red, green, blue, alpha);
    }
    [dartx.clearDepth](depth) {
      return this.clearDepth(depth);
    }
    [dartx.clearStencil](s) {
      return this.clearStencil(s);
    }
    [dartx.colorMask](red, green, blue, alpha) {
      return this.colorMask(red, green, blue, alpha);
    }
    [dartx.compileShader](shader) {
      return this.compileShader(shader);
    }
    [dartx.compressedTexImage2D](target, level, internalformat, width, height, border, data) {
      return this.compressedTexImage2D(target, level, internalformat, width, height, border, data);
    }
    [dartx.compressedTexSubImage2D](target, level, xoffset, yoffset, width, height, format, data) {
      return this.compressedTexSubImage2D(target, level, xoffset, yoffset, width, height, format, data);
    }
    [dartx.copyTexImage2D](target, level, internalformat, x, y, width, height, border) {
      return this.copyTexImage2D(target, level, internalformat, x, y, width, height, border);
    }
    [dartx.copyTexSubImage2D](target, level, xoffset, yoffset, x, y, width, height) {
      return this.copyTexSubImage2D(target, level, xoffset, yoffset, x, y, width, height);
    }
    [dartx.createBuffer]() {
      return this.createBuffer();
    }
    [dartx.createFramebuffer]() {
      return this.createFramebuffer();
    }
    [dartx.createProgram]() {
      return this.createProgram();
    }
    [dartx.createRenderbuffer]() {
      return this.createRenderbuffer();
    }
    [dartx.createShader](type) {
      return this.createShader(type);
    }
    [dartx.createTexture]() {
      return this.createTexture();
    }
    [dartx.cullFace](mode) {
      return this.cullFace(mode);
    }
    [dartx.deleteBuffer](buffer) {
      return this.deleteBuffer(buffer);
    }
    [dartx.deleteFramebuffer](framebuffer) {
      return this.deleteFramebuffer(framebuffer);
    }
    [dartx.deleteProgram](program) {
      return this.deleteProgram(program);
    }
    [dartx.deleteRenderbuffer](renderbuffer) {
      return this.deleteRenderbuffer(renderbuffer);
    }
    [dartx.deleteShader](shader) {
      return this.deleteShader(shader);
    }
    [dartx.deleteTexture](texture) {
      return this.deleteTexture(texture);
    }
    [dartx.depthFunc](func) {
      return this.depthFunc(func);
    }
    [dartx.depthMask](flag) {
      return this.depthMask(flag);
    }
    [dartx.depthRange](zNear, zFar) {
      return this.depthRange(zNear, zFar);
    }
    [dartx.detachShader](program, shader) {
      return this.detachShader(program, shader);
    }
    [dartx.disable](cap) {
      return this.disable(cap);
    }
    [dartx.disableVertexAttribArray](index) {
      return this.disableVertexAttribArray(index);
    }
    [dartx.drawArrays](mode, first, count) {
      return this.drawArrays(mode, first, count);
    }
    [dartx.drawElements](mode, count, type, offset) {
      return this.drawElements(mode, count, type, offset);
    }
    [dartx.enable](cap) {
      return this.enable(cap);
    }
    [dartx.enableVertexAttribArray](index) {
      return this.enableVertexAttribArray(index);
    }
    [dartx.finish]() {
      return this.finish();
    }
    [dartx.flush]() {
      return this.flush();
    }
    [dartx.framebufferRenderbuffer](target, attachment, renderbuffertarget, renderbuffer) {
      return this.framebufferRenderbuffer(target, attachment, renderbuffertarget, renderbuffer);
    }
    [dartx.framebufferTexture2D](target, attachment, textarget, texture, level) {
      return this.framebufferTexture2D(target, attachment, textarget, texture, level);
    }
    [dartx.frontFace](mode) {
      return this.frontFace(mode);
    }
    [dartx.generateMipmap](target) {
      return this.generateMipmap(target);
    }
    [dartx.getActiveAttrib](program, index) {
      return this.getActiveAttrib(program, index);
    }
    [dartx.getActiveUniform](program, index) {
      return this.getActiveUniform(program, index);
    }
    [dartx.getAttachedShaders](program) {
      return this.getAttachedShaders(program);
    }
    [dartx.getAttribLocation](program, name) {
      return this.getAttribLocation(program, name);
    }
    [dartx.getBufferParameter](target, pname) {
      return this.getBufferParameter(target, pname);
    }
    [dartx.getContextAttributes]() {
      return web_gl.ContextAttributes._check(html_common.convertNativeToDart_ContextAttributes(this[_getContextAttributes_1$]()));
    }
    [_getContextAttributes_1$]() {
      return this.getContextAttributes();
    }
    [dartx.getError]() {
      return this.getError();
    }
    [dartx.getExtension](name) {
      return this.getExtension(name);
    }
    [dartx.getFramebufferAttachmentParameter](target, attachment, pname) {
      return this.getFramebufferAttachmentParameter(target, attachment, pname);
    }
    [dartx.getParameter](pname) {
      return this.getParameter(pname);
    }
    [dartx.getProgramInfoLog](program) {
      return this.getProgramInfoLog(program);
    }
    [dartx.getProgramParameter](program, pname) {
      return this.getProgramParameter(program, pname);
    }
    [dartx.getRenderbufferParameter](target, pname) {
      return this.getRenderbufferParameter(target, pname);
    }
    [dartx.getShaderInfoLog](shader) {
      return this.getShaderInfoLog(shader);
    }
    [dartx.getShaderParameter](shader, pname) {
      return this.getShaderParameter(shader, pname);
    }
    [dartx.getShaderPrecisionFormat](shadertype, precisiontype) {
      return this.getShaderPrecisionFormat(shadertype, precisiontype);
    }
    [dartx.getShaderSource](shader) {
      return this.getShaderSource(shader);
    }
    [dartx.getSupportedExtensions]() {
      return this.getSupportedExtensions();
    }
    [dartx.getTexParameter](target, pname) {
      return this.getTexParameter(target, pname);
    }
    [dartx.getUniform](program, location) {
      return this.getUniform(program, location);
    }
    [dartx.getUniformLocation](program, name) {
      return this.getUniformLocation(program, name);
    }
    [dartx.getVertexAttrib](index, pname) {
      return this.getVertexAttrib(index, pname);
    }
    [dartx.getVertexAttribOffset](index, pname) {
      return this.getVertexAttribOffset(index, pname);
    }
    [dartx.hint](target, mode) {
      return this.hint(target, mode);
    }
    [dartx.isBuffer](buffer) {
      return this.isBuffer(buffer);
    }
    [dartx.isContextLost]() {
      return this.isContextLost();
    }
    [dartx.isEnabled](cap) {
      return this.isEnabled(cap);
    }
    [dartx.isFramebuffer](framebuffer) {
      return this.isFramebuffer(framebuffer);
    }
    [dartx.isProgram](program) {
      return this.isProgram(program);
    }
    [dartx.isRenderbuffer](renderbuffer) {
      return this.isRenderbuffer(renderbuffer);
    }
    [dartx.isShader](shader) {
      return this.isShader(shader);
    }
    [dartx.isTexture](texture) {
      return this.isTexture(texture);
    }
    [dartx.lineWidth](width) {
      return this.lineWidth(width);
    }
    [dartx.linkProgram](program) {
      return this.linkProgram(program);
    }
    [dartx.pixelStorei](pname, param) {
      return this.pixelStorei(pname, param);
    }
    [dartx.polygonOffset](factor, units) {
      return this.polygonOffset(factor, units);
    }
    [dartx.readPixels](x, y, width, height, format, type, pixels) {
      return this.readPixels(x, y, width, height, format, type, pixels);
    }
    [dartx.renderbufferStorage](target, internalformat, width, height) {
      return this.renderbufferStorage(target, internalformat, width, height);
    }
    [dartx.sampleCoverage](value, invert) {
      return this.sampleCoverage(value, invert);
    }
    [dartx.scissor](x, y, width, height) {
      return this.scissor(x, y, width, height);
    }
    [dartx.shaderSource](shader, string) {
      return this.shaderSource(shader, string);
    }
    [dartx.stencilFunc](func, ref, mask) {
      return this.stencilFunc(func, ref, mask);
    }
    [dartx.stencilFuncSeparate](face, func, ref, mask) {
      return this.stencilFuncSeparate(face, func, ref, mask);
    }
    [dartx.stencilMask](mask) {
      return this.stencilMask(mask);
    }
    [dartx.stencilMaskSeparate](face, mask) {
      return this.stencilMaskSeparate(face, mask);
    }
    [dartx.stencilOp](fail, zfail, zpass) {
      return this.stencilOp(fail, zfail, zpass);
    }
    [dartx.stencilOpSeparate](face, fail, zfail, zpass) {
      return this.stencilOpSeparate(face, fail, zfail, zpass);
    }
    [dartx.texImage2D](target, level, internalformat, format_OR_width, height_OR_type, border_OR_canvas_OR_image_OR_pixels_OR_video, format, type, pixels) {
      if (format === void 0) format = null;
      if (type === void 0) type = null;
      if (pixels === void 0) pixels = null;
      if (pixels != null && type != null && format != null && typeof border_OR_canvas_OR_image_OR_pixels_OR_video == 'number') {
        this[_texImage2D_1](target, level, internalformat, format_OR_width, height_OR_type, border_OR_canvas_OR_image_OR_pixels_OR_video, format, type, pixels);
        return;
      }
      if ((html$.ImageData.is(border_OR_canvas_OR_image_OR_pixels_OR_video) || border_OR_canvas_OR_image_OR_pixels_OR_video == null) && format == null && type == null && pixels == null) {
        let pixels_1 = html_common.convertDartToNative_ImageData(html$.ImageData._check(border_OR_canvas_OR_image_OR_pixels_OR_video));
        this[_texImage2D_2](target, level, internalformat, format_OR_width, height_OR_type, pixels_1);
        return;
      }
      if (html$.ImageElement.is(border_OR_canvas_OR_image_OR_pixels_OR_video) && format == null && type == null && pixels == null) {
        this[_texImage2D_3](target, level, internalformat, format_OR_width, height_OR_type, border_OR_canvas_OR_image_OR_pixels_OR_video);
        return;
      }
      if (html$.CanvasElement.is(border_OR_canvas_OR_image_OR_pixels_OR_video) && format == null && type == null && pixels == null) {
        this[_texImage2D_4](target, level, internalformat, format_OR_width, height_OR_type, border_OR_canvas_OR_image_OR_pixels_OR_video);
        return;
      }
      if (html$.VideoElement.is(border_OR_canvas_OR_image_OR_pixels_OR_video) && format == null && type == null && pixels == null) {
        this[_texImage2D_5](target, level, internalformat, format_OR_width, height_OR_type, border_OR_canvas_OR_image_OR_pixels_OR_video);
        return;
      }
      dart.throw(new core.ArgumentError("Incorrect number or type of arguments"));
    }
    [_texImage2D_1](target, level, internalformat, width, height, border, format, type, pixels) {
      return this.texImage2D(target, level, internalformat, width, height, border, format, type, pixels);
    }
    [_texImage2D_2](target, level, internalformat, format, type, pixels) {
      return this.texImage2D(target, level, internalformat, format, type, pixels);
    }
    [_texImage2D_3](target, level, internalformat, format, type, image) {
      return this.texImage2D(target, level, internalformat, format, type, image);
    }
    [_texImage2D_4](target, level, internalformat, format, type, canvas) {
      return this.texImage2D(target, level, internalformat, format, type, canvas);
    }
    [_texImage2D_5](target, level, internalformat, format, type, video) {
      return this.texImage2D(target, level, internalformat, format, type, video);
    }
    [dartx.texImage2DCanvas](target, level, internalformat, format, type, canvas) {
      return this.texImage2D(target, level, internalformat, format, type, canvas);
    }
    [dartx.texImage2DImage](target, level, internalformat, format, type, image) {
      return this.texImage2D(target, level, internalformat, format, type, image);
    }
    [dartx.texImage2DImageData](target, level, internalformat, format, type, pixels) {
      let pixels_1 = html_common.convertDartToNative_ImageData(pixels);
      this[_texImage2DImageData_1](target, level, internalformat, format, type, pixels_1);
      return;
    }
    [_texImage2DImageData_1](target, level, internalformat, format, type, pixels) {
      return this.texImage2D(target, level, internalformat, format, type, pixels);
    }
    [dartx.texImage2DVideo](target, level, internalformat, format, type, video) {
      return this.texImage2D(target, level, internalformat, format, type, video);
    }
    [dartx.texParameterf](target, pname, param) {
      return this.texParameterf(target, pname, param);
    }
    [dartx.texParameteri](target, pname, param) {
      return this.texParameteri(target, pname, param);
    }
    [dartx.texSubImage2D](target, level, xoffset, yoffset, format_OR_width, height_OR_type, canvas_OR_format_OR_image_OR_pixels_OR_video, type, pixels) {
      if (type === void 0) type = null;
      if (pixels === void 0) pixels = null;
      if (pixels != null && type != null && typeof canvas_OR_format_OR_image_OR_pixels_OR_video == 'number') {
        this[_texSubImage2D_1](target, level, xoffset, yoffset, format_OR_width, height_OR_type, canvas_OR_format_OR_image_OR_pixels_OR_video, type, pixels);
        return;
      }
      if ((html$.ImageData.is(canvas_OR_format_OR_image_OR_pixels_OR_video) || canvas_OR_format_OR_image_OR_pixels_OR_video == null) && type == null && pixels == null) {
        let pixels_1 = html_common.convertDartToNative_ImageData(html$.ImageData._check(canvas_OR_format_OR_image_OR_pixels_OR_video));
        this[_texSubImage2D_2](target, level, xoffset, yoffset, format_OR_width, height_OR_type, pixels_1);
        return;
      }
      if (html$.ImageElement.is(canvas_OR_format_OR_image_OR_pixels_OR_video) && type == null && pixels == null) {
        this[_texSubImage2D_3](target, level, xoffset, yoffset, format_OR_width, height_OR_type, canvas_OR_format_OR_image_OR_pixels_OR_video);
        return;
      }
      if (html$.CanvasElement.is(canvas_OR_format_OR_image_OR_pixels_OR_video) && type == null && pixels == null) {
        this[_texSubImage2D_4](target, level, xoffset, yoffset, format_OR_width, height_OR_type, canvas_OR_format_OR_image_OR_pixels_OR_video);
        return;
      }
      if (html$.VideoElement.is(canvas_OR_format_OR_image_OR_pixels_OR_video) && type == null && pixels == null) {
        this[_texSubImage2D_5](target, level, xoffset, yoffset, format_OR_width, height_OR_type, canvas_OR_format_OR_image_OR_pixels_OR_video);
        return;
      }
      dart.throw(new core.ArgumentError("Incorrect number or type of arguments"));
    }
    [_texSubImage2D_1](target, level, xoffset, yoffset, width, height, format, type, pixels) {
      return this.texSubImage2D(target, level, xoffset, yoffset, width, height, format, type, pixels);
    }
    [_texSubImage2D_2](target, level, xoffset, yoffset, format, type, pixels) {
      return this.texSubImage2D(target, level, xoffset, yoffset, format, type, pixels);
    }
    [_texSubImage2D_3](target, level, xoffset, yoffset, format, type, image) {
      return this.texSubImage2D(target, level, xoffset, yoffset, format, type, image);
    }
    [_texSubImage2D_4](target, level, xoffset, yoffset, format, type, canvas) {
      return this.texSubImage2D(target, level, xoffset, yoffset, format, type, canvas);
    }
    [_texSubImage2D_5](target, level, xoffset, yoffset, format, type, video) {
      return this.texSubImage2D(target, level, xoffset, yoffset, format, type, video);
    }
    [dartx.texSubImage2DCanvas](target, level, xoffset, yoffset, format, type, canvas) {
      return this.texSubImage2D(target, level, xoffset, yoffset, format, type, canvas);
    }
    [dartx.texSubImage2DImage](target, level, xoffset, yoffset, format, type, image) {
      return this.texSubImage2D(target, level, xoffset, yoffset, format, type, image);
    }
    [dartx.texSubImage2DImageData](target, level, xoffset, yoffset, format, type, pixels) {
      let pixels_1 = html_common.convertDartToNative_ImageData(pixels);
      this[_texSubImage2DImageData_1](target, level, xoffset, yoffset, format, type, pixels_1);
      return;
    }
    [_texSubImage2DImageData_1](target, level, xoffset, yoffset, format, type, pixels) {
      return this.texSubImage2D(target, level, xoffset, yoffset, format, type, pixels);
    }
    [dartx.texSubImage2DVideo](target, level, xoffset, yoffset, format, type, video) {
      return this.texSubImage2D(target, level, xoffset, yoffset, format, type, video);
    }
    [dartx.uniform1f](location, x) {
      return this.uniform1f(location, x);
    }
    [dartx.uniform1fv](location, v) {
      return this.uniform1fv(location, v);
    }
    [dartx.uniform1i](location, x) {
      return this.uniform1i(location, x);
    }
    [dartx.uniform1iv](location, v) {
      return this.uniform1iv(location, v);
    }
    [dartx.uniform2f](location, x, y) {
      return this.uniform2f(location, x, y);
    }
    [dartx.uniform2fv](location, v) {
      return this.uniform2fv(location, v);
    }
    [dartx.uniform2i](location, x, y) {
      return this.uniform2i(location, x, y);
    }
    [dartx.uniform2iv](location, v) {
      return this.uniform2iv(location, v);
    }
    [dartx.uniform3f](location, x, y, z) {
      return this.uniform3f(location, x, y, z);
    }
    [dartx.uniform3fv](location, v) {
      return this.uniform3fv(location, v);
    }
    [dartx.uniform3i](location, x, y, z) {
      return this.uniform3i(location, x, y, z);
    }
    [dartx.uniform3iv](location, v) {
      return this.uniform3iv(location, v);
    }
    [dartx.uniform4f](location, x, y, z, w) {
      return this.uniform4f(location, x, y, z, w);
    }
    [dartx.uniform4fv](location, v) {
      return this.uniform4fv(location, v);
    }
    [dartx.uniform4i](location, x, y, z, w) {
      return this.uniform4i(location, x, y, z, w);
    }
    [dartx.uniform4iv](location, v) {
      return this.uniform4iv(location, v);
    }
    [dartx.uniformMatrix2fv](location, transpose, array) {
      return this.uniformMatrix2fv(location, transpose, array);
    }
    [dartx.uniformMatrix3fv](location, transpose, array) {
      return this.uniformMatrix3fv(location, transpose, array);
    }
    [dartx.uniformMatrix4fv](location, transpose, array) {
      return this.uniformMatrix4fv(location, transpose, array);
    }
    [dartx.useProgram](program) {
      return this.useProgram(program);
    }
    [dartx.validateProgram](program) {
      return this.validateProgram(program);
    }
    [dartx.vertexAttrib1f](indx, x) {
      return this.vertexAttrib1f(indx, x);
    }
    [dartx.vertexAttrib1fv](indx, values) {
      return this.vertexAttrib1fv(indx, values);
    }
    [dartx.vertexAttrib2f](indx, x, y) {
      return this.vertexAttrib2f(indx, x, y);
    }
    [dartx.vertexAttrib2fv](indx, values) {
      return this.vertexAttrib2fv(indx, values);
    }
    [dartx.vertexAttrib3f](indx, x, y, z) {
      return this.vertexAttrib3f(indx, x, y, z);
    }
    [dartx.vertexAttrib3fv](indx, values) {
      return this.vertexAttrib3fv(indx, values);
    }
    [dartx.vertexAttrib4f](indx, x, y, z, w) {
      return this.vertexAttrib4f(indx, x, y, z, w);
    }
    [dartx.vertexAttrib4fv](indx, values) {
      return this.vertexAttrib4fv(indx, values);
    }
    [dartx.vertexAttribPointer](indx, size, type, normalized, stride, offset) {
      return this.vertexAttribPointer(indx, size, type, normalized, stride, offset);
    }
    [dartx.viewport](x, y, width, height) {
      return this.viewport(x, y, width, height);
    }
    [dartx.texImage2DUntyped](targetTexture, levelOfDetail, internalFormat, format, type, data) {
      return this.texImage2D(targetTexture, levelOfDetail, internalFormat, format, type, data);
    }
    [dartx.texImage2DTyped](targetTexture, levelOfDetail, internalFormat, width, height, border, format, type, data) {
      return this.texImage2D(targetTexture, levelOfDetail, internalFormat, width, height, border, format, type, data);
    }
    [dartx.texSubImage2DUntyped](targetTexture, levelOfDetail, xOffset, yOffset, format, type, data) {
      return this.texSubImage2D(targetTexture, levelOfDetail, xOffset, yOffset, format, type, data);
    }
    [dartx.texSubImage2DTyped](targetTexture, levelOfDetail, xOffset, yOffset, width, height, border, format, type, data) {
      return this.texSubImage2D(targetTexture, levelOfDetail, xOffset, yOffset, width, height, border, format, type, data);
    }
  };
  web_gl.RenderingContext[dart.implements] = () => [html$.CanvasRenderingContext];
  dart.setSignature(web_gl.RenderingContext, {
    constructors: () => ({_: dart.definiteFunctionType(web_gl.RenderingContext, [])}),
    methods: () => ({
      [dartx.activeTexture]: dart.definiteFunctionType(dart.void, [core.int]),
      [dartx.attachShader]: dart.definiteFunctionType(dart.void, [web_gl.Program, web_gl.Shader]),
      [dartx.bindAttribLocation]: dart.definiteFunctionType(dart.void, [web_gl.Program, core.int, core.String]),
      [dartx.bindBuffer]: dart.definiteFunctionType(dart.void, [core.int, web_gl.Buffer]),
      [dartx.bindFramebuffer]: dart.definiteFunctionType(dart.void, [core.int, web_gl.Framebuffer]),
      [dartx.bindRenderbuffer]: dart.definiteFunctionType(dart.void, [core.int, web_gl.Renderbuffer]),
      [dartx.bindTexture]: dart.definiteFunctionType(dart.void, [core.int, web_gl.Texture]),
      [dartx.blendColor]: dart.definiteFunctionType(dart.void, [core.num, core.num, core.num, core.num]),
      [dartx.blendEquation]: dart.definiteFunctionType(dart.void, [core.int]),
      [dartx.blendEquationSeparate]: dart.definiteFunctionType(dart.void, [core.int, core.int]),
      [dartx.blendFunc]: dart.definiteFunctionType(dart.void, [core.int, core.int]),
      [dartx.blendFuncSeparate]: dart.definiteFunctionType(dart.void, [core.int, core.int, core.int, core.int]),
      [dartx.bufferByteData]: dart.definiteFunctionType(dart.void, [core.int, typed_data.ByteBuffer, core.int]),
      [dartx.bufferData]: dart.definiteFunctionType(dart.void, [core.int, dart.dynamic, core.int]),
      [dartx.bufferDataTyped]: dart.definiteFunctionType(dart.void, [core.int, typed_data.TypedData, core.int]),
      [dartx.bufferSubByteData]: dart.definiteFunctionType(dart.void, [core.int, core.int, typed_data.ByteBuffer]),
      [dartx.bufferSubData]: dart.definiteFunctionType(dart.void, [core.int, core.int, dart.dynamic]),
      [dartx.bufferSubDataTyped]: dart.definiteFunctionType(dart.void, [core.int, core.int, typed_data.TypedData]),
      [dartx.checkFramebufferStatus]: dart.definiteFunctionType(core.int, [core.int]),
      [dartx.clear]: dart.definiteFunctionType(dart.void, [core.int]),
      [dartx.clearColor]: dart.definiteFunctionType(dart.void, [core.num, core.num, core.num, core.num]),
      [dartx.clearDepth]: dart.definiteFunctionType(dart.void, [core.num]),
      [dartx.clearStencil]: dart.definiteFunctionType(dart.void, [core.int]),
      [dartx.colorMask]: dart.definiteFunctionType(dart.void, [core.bool, core.bool, core.bool, core.bool]),
      [dartx.compileShader]: dart.definiteFunctionType(dart.void, [web_gl.Shader]),
      [dartx.compressedTexImage2D]: dart.definiteFunctionType(dart.void, [core.int, core.int, core.int, core.int, core.int, core.int, typed_data.TypedData]),
      [dartx.compressedTexSubImage2D]: dart.definiteFunctionType(dart.void, [core.int, core.int, core.int, core.int, core.int, core.int, core.int, typed_data.TypedData]),
      [dartx.copyTexImage2D]: dart.definiteFunctionType(dart.void, [core.int, core.int, core.int, core.int, core.int, core.int, core.int, core.int]),
      [dartx.copyTexSubImage2D]: dart.definiteFunctionType(dart.void, [core.int, core.int, core.int, core.int, core.int, core.int, core.int, core.int]),
      [dartx.createBuffer]: dart.definiteFunctionType(web_gl.Buffer, []),
      [dartx.createFramebuffer]: dart.definiteFunctionType(web_gl.Framebuffer, []),
      [dartx.createProgram]: dart.definiteFunctionType(web_gl.Program, []),
      [dartx.createRenderbuffer]: dart.definiteFunctionType(web_gl.Renderbuffer, []),
      [dartx.createShader]: dart.definiteFunctionType(web_gl.Shader, [core.int]),
      [dartx.createTexture]: dart.definiteFunctionType(web_gl.Texture, []),
      [dartx.cullFace]: dart.definiteFunctionType(dart.void, [core.int]),
      [dartx.deleteBuffer]: dart.definiteFunctionType(dart.void, [web_gl.Buffer]),
      [dartx.deleteFramebuffer]: dart.definiteFunctionType(dart.void, [web_gl.Framebuffer]),
      [dartx.deleteProgram]: dart.definiteFunctionType(dart.void, [web_gl.Program]),
      [dartx.deleteRenderbuffer]: dart.definiteFunctionType(dart.void, [web_gl.Renderbuffer]),
      [dartx.deleteShader]: dart.definiteFunctionType(dart.void, [web_gl.Shader]),
      [dartx.deleteTexture]: dart.definiteFunctionType(dart.void, [web_gl.Texture]),
      [dartx.depthFunc]: dart.definiteFunctionType(dart.void, [core.int]),
      [dartx.depthMask]: dart.definiteFunctionType(dart.void, [core.bool]),
      [dartx.depthRange]: dart.definiteFunctionType(dart.void, [core.num, core.num]),
      [dartx.detachShader]: dart.definiteFunctionType(dart.void, [web_gl.Program, web_gl.Shader]),
      [dartx.disable]: dart.definiteFunctionType(dart.void, [core.int]),
      [dartx.disableVertexAttribArray]: dart.definiteFunctionType(dart.void, [core.int]),
      [dartx.drawArrays]: dart.definiteFunctionType(dart.void, [core.int, core.int, core.int]),
      [dartx.drawElements]: dart.definiteFunctionType(dart.void, [core.int, core.int, core.int, core.int]),
      [dartx.enable]: dart.definiteFunctionType(dart.void, [core.int]),
      [dartx.enableVertexAttribArray]: dart.definiteFunctionType(dart.void, [core.int]),
      [dartx.finish]: dart.definiteFunctionType(dart.void, []),
      [dartx.flush]: dart.definiteFunctionType(dart.void, []),
      [dartx.framebufferRenderbuffer]: dart.definiteFunctionType(dart.void, [core.int, core.int, core.int, web_gl.Renderbuffer]),
      [dartx.framebufferTexture2D]: dart.definiteFunctionType(dart.void, [core.int, core.int, core.int, web_gl.Texture, core.int]),
      [dartx.frontFace]: dart.definiteFunctionType(dart.void, [core.int]),
      [dartx.generateMipmap]: dart.definiteFunctionType(dart.void, [core.int]),
      [dartx.getActiveAttrib]: dart.definiteFunctionType(web_gl.ActiveInfo, [web_gl.Program, core.int]),
      [dartx.getActiveUniform]: dart.definiteFunctionType(web_gl.ActiveInfo, [web_gl.Program, core.int]),
      [dartx.getAttachedShaders]: dart.definiteFunctionType(core.List$(web_gl.Shader), [web_gl.Program]),
      [dartx.getAttribLocation]: dart.definiteFunctionType(core.int, [web_gl.Program, core.String]),
      [dartx.getBufferParameter]: dart.definiteFunctionType(core.Object, [core.int, core.int]),
      [dartx.getContextAttributes]: dart.definiteFunctionType(web_gl.ContextAttributes, []),
      [_getContextAttributes_1$]: dart.definiteFunctionType(dart.dynamic, []),
      [dartx.getError]: dart.definiteFunctionType(core.int, []),
      [dartx.getExtension]: dart.definiteFunctionType(core.Object, [core.String]),
      [dartx.getFramebufferAttachmentParameter]: dart.definiteFunctionType(core.Object, [core.int, core.int, core.int]),
      [dartx.getParameter]: dart.definiteFunctionType(core.Object, [core.int]),
      [dartx.getProgramInfoLog]: dart.definiteFunctionType(core.String, [web_gl.Program]),
      [dartx.getProgramParameter]: dart.definiteFunctionType(core.Object, [web_gl.Program, core.int]),
      [dartx.getRenderbufferParameter]: dart.definiteFunctionType(core.Object, [core.int, core.int]),
      [dartx.getShaderInfoLog]: dart.definiteFunctionType(core.String, [web_gl.Shader]),
      [dartx.getShaderParameter]: dart.definiteFunctionType(core.Object, [web_gl.Shader, core.int]),
      [dartx.getShaderPrecisionFormat]: dart.definiteFunctionType(web_gl.ShaderPrecisionFormat, [core.int, core.int]),
      [dartx.getShaderSource]: dart.definiteFunctionType(core.String, [web_gl.Shader]),
      [dartx.getSupportedExtensions]: dart.definiteFunctionType(core.List$(core.String), []),
      [dartx.getTexParameter]: dart.definiteFunctionType(core.Object, [core.int, core.int]),
      [dartx.getUniform]: dart.definiteFunctionType(core.Object, [web_gl.Program, web_gl.UniformLocation]),
      [dartx.getUniformLocation]: dart.definiteFunctionType(web_gl.UniformLocation, [web_gl.Program, core.String]),
      [dartx.getVertexAttrib]: dart.definiteFunctionType(core.Object, [core.int, core.int]),
      [dartx.getVertexAttribOffset]: dart.definiteFunctionType(core.int, [core.int, core.int]),
      [dartx.hint]: dart.definiteFunctionType(dart.void, [core.int, core.int]),
      [dartx.isBuffer]: dart.definiteFunctionType(core.bool, [web_gl.Buffer]),
      [dartx.isContextLost]: dart.definiteFunctionType(core.bool, []),
      [dartx.isEnabled]: dart.definiteFunctionType(core.bool, [core.int]),
      [dartx.isFramebuffer]: dart.definiteFunctionType(core.bool, [web_gl.Framebuffer]),
      [dartx.isProgram]: dart.definiteFunctionType(core.bool, [web_gl.Program]),
      [dartx.isRenderbuffer]: dart.definiteFunctionType(core.bool, [web_gl.Renderbuffer]),
      [dartx.isShader]: dart.definiteFunctionType(core.bool, [web_gl.Shader]),
      [dartx.isTexture]: dart.definiteFunctionType(core.bool, [web_gl.Texture]),
      [dartx.lineWidth]: dart.definiteFunctionType(dart.void, [core.num]),
      [dartx.linkProgram]: dart.definiteFunctionType(dart.void, [web_gl.Program]),
      [dartx.pixelStorei]: dart.definiteFunctionType(dart.void, [core.int, core.int]),
      [dartx.polygonOffset]: dart.definiteFunctionType(dart.void, [core.num, core.num]),
      [dartx.readPixels]: dart.definiteFunctionType(dart.void, [core.int, core.int, core.int, core.int, core.int, core.int, typed_data.TypedData]),
      [dartx.renderbufferStorage]: dart.definiteFunctionType(dart.void, [core.int, core.int, core.int, core.int]),
      [dartx.sampleCoverage]: dart.definiteFunctionType(dart.void, [core.num, core.bool]),
      [dartx.scissor]: dart.definiteFunctionType(dart.void, [core.int, core.int, core.int, core.int]),
      [dartx.shaderSource]: dart.definiteFunctionType(dart.void, [web_gl.Shader, core.String]),
      [dartx.stencilFunc]: dart.definiteFunctionType(dart.void, [core.int, core.int, core.int]),
      [dartx.stencilFuncSeparate]: dart.definiteFunctionType(dart.void, [core.int, core.int, core.int, core.int]),
      [dartx.stencilMask]: dart.definiteFunctionType(dart.void, [core.int]),
      [dartx.stencilMaskSeparate]: dart.definiteFunctionType(dart.void, [core.int, core.int]),
      [dartx.stencilOp]: dart.definiteFunctionType(dart.void, [core.int, core.int, core.int]),
      [dartx.stencilOpSeparate]: dart.definiteFunctionType(dart.void, [core.int, core.int, core.int, core.int]),
      [dartx.texImage2D]: dart.definiteFunctionType(dart.void, [core.int, core.int, core.int, core.int, core.int, dart.dynamic], [core.int, core.int, typed_data.TypedData]),
      [_texImage2D_1]: dart.definiteFunctionType(dart.void, [dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, core.int, dart.dynamic, dart.dynamic, typed_data.TypedData]),
      [_texImage2D_2]: dart.definiteFunctionType(dart.void, [dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic]),
      [_texImage2D_3]: dart.definiteFunctionType(dart.void, [dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, html$.ImageElement]),
      [_texImage2D_4]: dart.definiteFunctionType(dart.void, [dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, html$.CanvasElement]),
      [_texImage2D_5]: dart.definiteFunctionType(dart.void, [dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, html$.VideoElement]),
      [dartx.texImage2DCanvas]: dart.definiteFunctionType(dart.void, [core.int, core.int, core.int, core.int, core.int, html$.CanvasElement]),
      [dartx.texImage2DImage]: dart.definiteFunctionType(dart.void, [core.int, core.int, core.int, core.int, core.int, html$.ImageElement]),
      [dartx.texImage2DImageData]: dart.definiteFunctionType(dart.void, [core.int, core.int, core.int, core.int, core.int, html$.ImageData]),
      [_texImage2DImageData_1]: dart.definiteFunctionType(dart.void, [dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic]),
      [dartx.texImage2DVideo]: dart.definiteFunctionType(dart.void, [core.int, core.int, core.int, core.int, core.int, html$.VideoElement]),
      [dartx.texParameterf]: dart.definiteFunctionType(dart.void, [core.int, core.int, core.num]),
      [dartx.texParameteri]: dart.definiteFunctionType(dart.void, [core.int, core.int, core.int]),
      [dartx.texSubImage2D]: dart.definiteFunctionType(dart.void, [core.int, core.int, core.int, core.int, core.int, core.int, dart.dynamic], [core.int, typed_data.TypedData]),
      [_texSubImage2D_1]: dart.definiteFunctionType(dart.void, [dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, core.int, dart.dynamic, typed_data.TypedData]),
      [_texSubImage2D_2]: dart.definiteFunctionType(dart.void, [dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic]),
      [_texSubImage2D_3]: dart.definiteFunctionType(dart.void, [dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, html$.ImageElement]),
      [_texSubImage2D_4]: dart.definiteFunctionType(dart.void, [dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, html$.CanvasElement]),
      [_texSubImage2D_5]: dart.definiteFunctionType(dart.void, [dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, html$.VideoElement]),
      [dartx.texSubImage2DCanvas]: dart.definiteFunctionType(dart.void, [core.int, core.int, core.int, core.int, core.int, core.int, html$.CanvasElement]),
      [dartx.texSubImage2DImage]: dart.definiteFunctionType(dart.void, [core.int, core.int, core.int, core.int, core.int, core.int, html$.ImageElement]),
      [dartx.texSubImage2DImageData]: dart.definiteFunctionType(dart.void, [core.int, core.int, core.int, core.int, core.int, core.int, html$.ImageData]),
      [_texSubImage2DImageData_1]: dart.definiteFunctionType(dart.void, [dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic]),
      [dartx.texSubImage2DVideo]: dart.definiteFunctionType(dart.void, [core.int, core.int, core.int, core.int, core.int, core.int, html$.VideoElement]),
      [dartx.uniform1f]: dart.definiteFunctionType(dart.void, [web_gl.UniformLocation, core.num]),
      [dartx.uniform1fv]: dart.definiteFunctionType(dart.void, [web_gl.UniformLocation, typed_data.Float32List]),
      [dartx.uniform1i]: dart.definiteFunctionType(dart.void, [web_gl.UniformLocation, core.int]),
      [dartx.uniform1iv]: dart.definiteFunctionType(dart.void, [web_gl.UniformLocation, typed_data.Int32List]),
      [dartx.uniform2f]: dart.definiteFunctionType(dart.void, [web_gl.UniformLocation, core.num, core.num]),
      [dartx.uniform2fv]: dart.definiteFunctionType(dart.void, [web_gl.UniformLocation, typed_data.Float32List]),
      [dartx.uniform2i]: dart.definiteFunctionType(dart.void, [web_gl.UniformLocation, core.int, core.int]),
      [dartx.uniform2iv]: dart.definiteFunctionType(dart.void, [web_gl.UniformLocation, typed_data.Int32List]),
      [dartx.uniform3f]: dart.definiteFunctionType(dart.void, [web_gl.UniformLocation, core.num, core.num, core.num]),
      [dartx.uniform3fv]: dart.definiteFunctionType(dart.void, [web_gl.UniformLocation, typed_data.Float32List]),
      [dartx.uniform3i]: dart.definiteFunctionType(dart.void, [web_gl.UniformLocation, core.int, core.int, core.int]),
      [dartx.uniform3iv]: dart.definiteFunctionType(dart.void, [web_gl.UniformLocation, typed_data.Int32List]),
      [dartx.uniform4f]: dart.definiteFunctionType(dart.void, [web_gl.UniformLocation, core.num, core.num, core.num, core.num]),
      [dartx.uniform4fv]: dart.definiteFunctionType(dart.void, [web_gl.UniformLocation, typed_data.Float32List]),
      [dartx.uniform4i]: dart.definiteFunctionType(dart.void, [web_gl.UniformLocation, core.int, core.int, core.int, core.int]),
      [dartx.uniform4iv]: dart.definiteFunctionType(dart.void, [web_gl.UniformLocation, typed_data.Int32List]),
      [dartx.uniformMatrix2fv]: dart.definiteFunctionType(dart.void, [web_gl.UniformLocation, core.bool, typed_data.Float32List]),
      [dartx.uniformMatrix3fv]: dart.definiteFunctionType(dart.void, [web_gl.UniformLocation, core.bool, typed_data.Float32List]),
      [dartx.uniformMatrix4fv]: dart.definiteFunctionType(dart.void, [web_gl.UniformLocation, core.bool, typed_data.Float32List]),
      [dartx.useProgram]: dart.definiteFunctionType(dart.void, [web_gl.Program]),
      [dartx.validateProgram]: dart.definiteFunctionType(dart.void, [web_gl.Program]),
      [dartx.vertexAttrib1f]: dart.definiteFunctionType(dart.void, [core.int, core.num]),
      [dartx.vertexAttrib1fv]: dart.definiteFunctionType(dart.void, [core.int, typed_data.Float32List]),
      [dartx.vertexAttrib2f]: dart.definiteFunctionType(dart.void, [core.int, core.num, core.num]),
      [dartx.vertexAttrib2fv]: dart.definiteFunctionType(dart.void, [core.int, typed_data.Float32List]),
      [dartx.vertexAttrib3f]: dart.definiteFunctionType(dart.void, [core.int, core.num, core.num, core.num]),
      [dartx.vertexAttrib3fv]: dart.definiteFunctionType(dart.void, [core.int, typed_data.Float32List]),
      [dartx.vertexAttrib4f]: dart.definiteFunctionType(dart.void, [core.int, core.num, core.num, core.num, core.num]),
      [dartx.vertexAttrib4fv]: dart.definiteFunctionType(dart.void, [core.int, typed_data.Float32List]),
      [dartx.vertexAttribPointer]: dart.definiteFunctionType(dart.void, [core.int, core.int, core.int, core.bool, core.int, core.int]),
      [dartx.viewport]: dart.definiteFunctionType(dart.void, [core.int, core.int, core.int, core.int]),
      [dartx.texImage2DUntyped]: dart.definiteFunctionType(dart.void, [core.int, core.int, core.int, core.int, core.int, dart.dynamic]),
      [dartx.texImage2DTyped]: dart.definiteFunctionType(dart.void, [core.int, core.int, core.int, core.int, core.int, core.int, core.int, core.int, typed_data.TypedData]),
      [dartx.texSubImage2DUntyped]: dart.definiteFunctionType(dart.void, [core.int, core.int, core.int, core.int, core.int, core.int, dart.dynamic]),
      [dartx.texSubImage2DTyped]: dart.definiteFunctionType(dart.void, [core.int, core.int, core.int, core.int, core.int, core.int, core.int, core.int, core.int, typed_data.TypedData])
    })
  });
  web_gl.RenderingContext.ACTIVE_ATTRIBUTES = 35721;
  web_gl.RenderingContext.ACTIVE_TEXTURE = 34016;
  web_gl.RenderingContext.ACTIVE_UNIFORMS = 35718;
  web_gl.RenderingContext.ALIASED_LINE_WIDTH_RANGE = 33902;
  web_gl.RenderingContext.ALIASED_POINT_SIZE_RANGE = 33901;
  web_gl.RenderingContext.ALPHA = 6406;
  web_gl.RenderingContext.ALPHA_BITS = 3413;
  web_gl.RenderingContext.ALWAYS = 519;
  web_gl.RenderingContext.ARRAY_BUFFER = 34962;
  web_gl.RenderingContext.ARRAY_BUFFER_BINDING = 34964;
  web_gl.RenderingContext.ATTACHED_SHADERS = 35717;
  web_gl.RenderingContext.BACK = 1029;
  web_gl.RenderingContext.BLEND = 3042;
  web_gl.RenderingContext.BLEND_COLOR = 32773;
  web_gl.RenderingContext.BLEND_DST_ALPHA = 32970;
  web_gl.RenderingContext.BLEND_DST_RGB = 32968;
  web_gl.RenderingContext.BLEND_EQUATION = 32777;
  web_gl.RenderingContext.BLEND_EQUATION_ALPHA = 34877;
  web_gl.RenderingContext.BLEND_EQUATION_RGB = 32777;
  web_gl.RenderingContext.BLEND_SRC_ALPHA = 32971;
  web_gl.RenderingContext.BLEND_SRC_RGB = 32969;
  web_gl.RenderingContext.BLUE_BITS = 3412;
  web_gl.RenderingContext.BOOL = 35670;
  web_gl.RenderingContext.BOOL_VEC2 = 35671;
  web_gl.RenderingContext.BOOL_VEC3 = 35672;
  web_gl.RenderingContext.BOOL_VEC4 = 35673;
  web_gl.RenderingContext.BROWSER_DEFAULT_WEBGL = 37444;
  web_gl.RenderingContext.BUFFER_SIZE = 34660;
  web_gl.RenderingContext.BUFFER_USAGE = 34661;
  web_gl.RenderingContext.BYTE = 5120;
  web_gl.RenderingContext.CCW = 2305;
  web_gl.RenderingContext.CLAMP_TO_EDGE = 33071;
  web_gl.RenderingContext.COLOR_ATTACHMENT0 = 36064;
  web_gl.RenderingContext.COLOR_BUFFER_BIT = 16384;
  web_gl.RenderingContext.COLOR_CLEAR_VALUE = 3106;
  web_gl.RenderingContext.COLOR_WRITEMASK = 3107;
  web_gl.RenderingContext.COMPILE_STATUS = 35713;
  web_gl.RenderingContext.COMPRESSED_TEXTURE_FORMATS = 34467;
  web_gl.RenderingContext.CONSTANT_ALPHA = 32771;
  web_gl.RenderingContext.CONSTANT_COLOR = 32769;
  web_gl.RenderingContext.CONTEXT_LOST_WEBGL = 37442;
  web_gl.RenderingContext.CULL_FACE = 2884;
  web_gl.RenderingContext.CULL_FACE_MODE = 2885;
  web_gl.RenderingContext.CURRENT_PROGRAM = 35725;
  web_gl.RenderingContext.CURRENT_VERTEX_ATTRIB = 34342;
  web_gl.RenderingContext.CW = 2304;
  web_gl.RenderingContext.DECR = 7683;
  web_gl.RenderingContext.DECR_WRAP = 34056;
  web_gl.RenderingContext.DELETE_STATUS = 35712;
  web_gl.RenderingContext.DEPTH_ATTACHMENT = 36096;
  web_gl.RenderingContext.DEPTH_BITS = 3414;
  web_gl.RenderingContext.DEPTH_BUFFER_BIT = 256;
  web_gl.RenderingContext.DEPTH_CLEAR_VALUE = 2931;
  web_gl.RenderingContext.DEPTH_COMPONENT = 6402;
  web_gl.RenderingContext.DEPTH_COMPONENT16 = 33189;
  web_gl.RenderingContext.DEPTH_FUNC = 2932;
  web_gl.RenderingContext.DEPTH_RANGE = 2928;
  web_gl.RenderingContext.DEPTH_STENCIL = 34041;
  web_gl.RenderingContext.DEPTH_STENCIL_ATTACHMENT = 33306;
  web_gl.RenderingContext.DEPTH_TEST = 2929;
  web_gl.RenderingContext.DEPTH_WRITEMASK = 2930;
  web_gl.RenderingContext.DITHER = 3024;
  web_gl.RenderingContext.DONT_CARE = 4352;
  web_gl.RenderingContext.DST_ALPHA = 772;
  web_gl.RenderingContext.DST_COLOR = 774;
  web_gl.RenderingContext.DYNAMIC_DRAW = 35048;
  web_gl.RenderingContext.ELEMENT_ARRAY_BUFFER = 34963;
  web_gl.RenderingContext.ELEMENT_ARRAY_BUFFER_BINDING = 34965;
  web_gl.RenderingContext.EQUAL = 514;
  web_gl.RenderingContext.FASTEST = 4353;
  web_gl.RenderingContext.FLOAT = 5126;
  web_gl.RenderingContext.FLOAT_MAT2 = 35674;
  web_gl.RenderingContext.FLOAT_MAT3 = 35675;
  web_gl.RenderingContext.FLOAT_MAT4 = 35676;
  web_gl.RenderingContext.FLOAT_VEC2 = 35664;
  web_gl.RenderingContext.FLOAT_VEC3 = 35665;
  web_gl.RenderingContext.FLOAT_VEC4 = 35666;
  web_gl.RenderingContext.FRAGMENT_SHADER = 35632;
  web_gl.RenderingContext.FRAMEBUFFER = 36160;
  web_gl.RenderingContext.FRAMEBUFFER_ATTACHMENT_OBJECT_NAME = 36049;
  web_gl.RenderingContext.FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE = 36048;
  web_gl.RenderingContext.FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE = 36051;
  web_gl.RenderingContext.FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL = 36050;
  web_gl.RenderingContext.FRAMEBUFFER_BINDING = 36006;
  web_gl.RenderingContext.FRAMEBUFFER_COMPLETE = 36053;
  web_gl.RenderingContext.FRAMEBUFFER_INCOMPLETE_ATTACHMENT = 36054;
  web_gl.RenderingContext.FRAMEBUFFER_INCOMPLETE_DIMENSIONS = 36057;
  web_gl.RenderingContext.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT = 36055;
  web_gl.RenderingContext.FRAMEBUFFER_UNSUPPORTED = 36061;
  web_gl.RenderingContext.FRONT = 1028;
  web_gl.RenderingContext.FRONT_AND_BACK = 1032;
  web_gl.RenderingContext.FRONT_FACE = 2886;
  web_gl.RenderingContext.FUNC_ADD = 32774;
  web_gl.RenderingContext.FUNC_REVERSE_SUBTRACT = 32779;
  web_gl.RenderingContext.FUNC_SUBTRACT = 32778;
  web_gl.RenderingContext.GENERATE_MIPMAP_HINT = 33170;
  web_gl.RenderingContext.GEQUAL = 518;
  web_gl.RenderingContext.GREATER = 516;
  web_gl.RenderingContext.GREEN_BITS = 3411;
  web_gl.RenderingContext.HIGH_FLOAT = 36338;
  web_gl.RenderingContext.HIGH_INT = 36341;
  web_gl.RenderingContext.IMPLEMENTATION_COLOR_READ_FORMAT = 35739;
  web_gl.RenderingContext.IMPLEMENTATION_COLOR_READ_TYPE = 35738;
  web_gl.RenderingContext.INCR = 7682;
  web_gl.RenderingContext.INCR_WRAP = 34055;
  web_gl.RenderingContext.INT = 5124;
  web_gl.RenderingContext.INT_VEC2 = 35667;
  web_gl.RenderingContext.INT_VEC3 = 35668;
  web_gl.RenderingContext.INT_VEC4 = 35669;
  web_gl.RenderingContext.INVALID_ENUM = 1280;
  web_gl.RenderingContext.INVALID_FRAMEBUFFER_OPERATION = 1286;
  web_gl.RenderingContext.INVALID_OPERATION = 1282;
  web_gl.RenderingContext.INVALID_VALUE = 1281;
  web_gl.RenderingContext.INVERT = 5386;
  web_gl.RenderingContext.KEEP = 7680;
  web_gl.RenderingContext.LEQUAL = 515;
  web_gl.RenderingContext.LESS = 513;
  web_gl.RenderingContext.LINEAR = 9729;
  web_gl.RenderingContext.LINEAR_MIPMAP_LINEAR = 9987;
  web_gl.RenderingContext.LINEAR_MIPMAP_NEAREST = 9985;
  web_gl.RenderingContext.LINES = 1;
  web_gl.RenderingContext.LINE_LOOP = 2;
  web_gl.RenderingContext.LINE_STRIP = 3;
  web_gl.RenderingContext.LINE_WIDTH = 2849;
  web_gl.RenderingContext.LINK_STATUS = 35714;
  web_gl.RenderingContext.LOW_FLOAT = 36336;
  web_gl.RenderingContext.LOW_INT = 36339;
  web_gl.RenderingContext.LUMINANCE = 6409;
  web_gl.RenderingContext.LUMINANCE_ALPHA = 6410;
  web_gl.RenderingContext.MAX_COMBINED_TEXTURE_IMAGE_UNITS = 35661;
  web_gl.RenderingContext.MAX_CUBE_MAP_TEXTURE_SIZE = 34076;
  web_gl.RenderingContext.MAX_FRAGMENT_UNIFORM_VECTORS = 36349;
  web_gl.RenderingContext.MAX_RENDERBUFFER_SIZE = 34024;
  web_gl.RenderingContext.MAX_TEXTURE_IMAGE_UNITS = 34930;
  web_gl.RenderingContext.MAX_TEXTURE_SIZE = 3379;
  web_gl.RenderingContext.MAX_VARYING_VECTORS = 36348;
  web_gl.RenderingContext.MAX_VERTEX_ATTRIBS = 34921;
  web_gl.RenderingContext.MAX_VERTEX_TEXTURE_IMAGE_UNITS = 35660;
  web_gl.RenderingContext.MAX_VERTEX_UNIFORM_VECTORS = 36347;
  web_gl.RenderingContext.MAX_VIEWPORT_DIMS = 3386;
  web_gl.RenderingContext.MEDIUM_FLOAT = 36337;
  web_gl.RenderingContext.MEDIUM_INT = 36340;
  web_gl.RenderingContext.MIRRORED_REPEAT = 33648;
  web_gl.RenderingContext.NEAREST = 9728;
  web_gl.RenderingContext.NEAREST_MIPMAP_LINEAR = 9986;
  web_gl.RenderingContext.NEAREST_MIPMAP_NEAREST = 9984;
  web_gl.RenderingContext.NEVER = 512;
  web_gl.RenderingContext.NICEST = 4354;
  web_gl.RenderingContext.NONE = 0;
  web_gl.RenderingContext.NOTEQUAL = 517;
  web_gl.RenderingContext.NO_ERROR = 0;
  web_gl.RenderingContext.ONE = 1;
  web_gl.RenderingContext.ONE_MINUS_CONSTANT_ALPHA = 32772;
  web_gl.RenderingContext.ONE_MINUS_CONSTANT_COLOR = 32770;
  web_gl.RenderingContext.ONE_MINUS_DST_ALPHA = 773;
  web_gl.RenderingContext.ONE_MINUS_DST_COLOR = 775;
  web_gl.RenderingContext.ONE_MINUS_SRC_ALPHA = 771;
  web_gl.RenderingContext.ONE_MINUS_SRC_COLOR = 769;
  web_gl.RenderingContext.OUT_OF_MEMORY = 1285;
  web_gl.RenderingContext.PACK_ALIGNMENT = 3333;
  web_gl.RenderingContext.POINTS = 0;
  web_gl.RenderingContext.POLYGON_OFFSET_FACTOR = 32824;
  web_gl.RenderingContext.POLYGON_OFFSET_FILL = 32823;
  web_gl.RenderingContext.POLYGON_OFFSET_UNITS = 10752;
  web_gl.RenderingContext.RED_BITS = 3410;
  web_gl.RenderingContext.RENDERBUFFER = 36161;
  web_gl.RenderingContext.RENDERBUFFER_ALPHA_SIZE = 36179;
  web_gl.RenderingContext.RENDERBUFFER_BINDING = 36007;
  web_gl.RenderingContext.RENDERBUFFER_BLUE_SIZE = 36178;
  web_gl.RenderingContext.RENDERBUFFER_DEPTH_SIZE = 36180;
  web_gl.RenderingContext.RENDERBUFFER_GREEN_SIZE = 36177;
  web_gl.RenderingContext.RENDERBUFFER_HEIGHT = 36163;
  web_gl.RenderingContext.RENDERBUFFER_INTERNAL_FORMAT = 36164;
  web_gl.RenderingContext.RENDERBUFFER_RED_SIZE = 36176;
  web_gl.RenderingContext.RENDERBUFFER_STENCIL_SIZE = 36181;
  web_gl.RenderingContext.RENDERBUFFER_WIDTH = 36162;
  web_gl.RenderingContext.RENDERER = 7937;
  web_gl.RenderingContext.REPEAT = 10497;
  web_gl.RenderingContext.REPLACE = 7681;
  web_gl.RenderingContext.RGB = 6407;
  web_gl.RenderingContext.RGB565 = 36194;
  web_gl.RenderingContext.RGB5_A1 = 32855;
  web_gl.RenderingContext.RGBA = 6408;
  web_gl.RenderingContext.RGBA4 = 32854;
  web_gl.RenderingContext.SAMPLER_2D = 35678;
  web_gl.RenderingContext.SAMPLER_CUBE = 35680;
  web_gl.RenderingContext.SAMPLES = 32937;
  web_gl.RenderingContext.SAMPLE_ALPHA_TO_COVERAGE = 32926;
  web_gl.RenderingContext.SAMPLE_BUFFERS = 32936;
  web_gl.RenderingContext.SAMPLE_COVERAGE = 32928;
  web_gl.RenderingContext.SAMPLE_COVERAGE_INVERT = 32939;
  web_gl.RenderingContext.SAMPLE_COVERAGE_VALUE = 32938;
  web_gl.RenderingContext.SCISSOR_BOX = 3088;
  web_gl.RenderingContext.SCISSOR_TEST = 3089;
  web_gl.RenderingContext.SHADER_TYPE = 35663;
  web_gl.RenderingContext.SHADING_LANGUAGE_VERSION = 35724;
  web_gl.RenderingContext.SHORT = 5122;
  web_gl.RenderingContext.SRC_ALPHA = 770;
  web_gl.RenderingContext.SRC_ALPHA_SATURATE = 776;
  web_gl.RenderingContext.SRC_COLOR = 768;
  web_gl.RenderingContext.STATIC_DRAW = 35044;
  web_gl.RenderingContext.STENCIL_ATTACHMENT = 36128;
  web_gl.RenderingContext.STENCIL_BACK_FAIL = 34817;
  web_gl.RenderingContext.STENCIL_BACK_FUNC = 34816;
  web_gl.RenderingContext.STENCIL_BACK_PASS_DEPTH_FAIL = 34818;
  web_gl.RenderingContext.STENCIL_BACK_PASS_DEPTH_PASS = 34819;
  web_gl.RenderingContext.STENCIL_BACK_REF = 36003;
  web_gl.RenderingContext.STENCIL_BACK_VALUE_MASK = 36004;
  web_gl.RenderingContext.STENCIL_BACK_WRITEMASK = 36005;
  web_gl.RenderingContext.STENCIL_BITS = 3415;
  web_gl.RenderingContext.STENCIL_BUFFER_BIT = 1024;
  web_gl.RenderingContext.STENCIL_CLEAR_VALUE = 2961;
  web_gl.RenderingContext.STENCIL_FAIL = 2964;
  web_gl.RenderingContext.STENCIL_FUNC = 2962;
  web_gl.RenderingContext.STENCIL_INDEX = 6401;
  web_gl.RenderingContext.STENCIL_INDEX8 = 36168;
  web_gl.RenderingContext.STENCIL_PASS_DEPTH_FAIL = 2965;
  web_gl.RenderingContext.STENCIL_PASS_DEPTH_PASS = 2966;
  web_gl.RenderingContext.STENCIL_REF = 2967;
  web_gl.RenderingContext.STENCIL_TEST = 2960;
  web_gl.RenderingContext.STENCIL_VALUE_MASK = 2963;
  web_gl.RenderingContext.STENCIL_WRITEMASK = 2968;
  web_gl.RenderingContext.STREAM_DRAW = 35040;
  web_gl.RenderingContext.SUBPIXEL_BITS = 3408;
  web_gl.RenderingContext.TEXTURE = 5890;
  web_gl.RenderingContext.TEXTURE0 = 33984;
  web_gl.RenderingContext.TEXTURE1 = 33985;
  web_gl.RenderingContext.TEXTURE10 = 33994;
  web_gl.RenderingContext.TEXTURE11 = 33995;
  web_gl.RenderingContext.TEXTURE12 = 33996;
  web_gl.RenderingContext.TEXTURE13 = 33997;
  web_gl.RenderingContext.TEXTURE14 = 33998;
  web_gl.RenderingContext.TEXTURE15 = 33999;
  web_gl.RenderingContext.TEXTURE16 = 34000;
  web_gl.RenderingContext.TEXTURE17 = 34001;
  web_gl.RenderingContext.TEXTURE18 = 34002;
  web_gl.RenderingContext.TEXTURE19 = 34003;
  web_gl.RenderingContext.TEXTURE2 = 33986;
  web_gl.RenderingContext.TEXTURE20 = 34004;
  web_gl.RenderingContext.TEXTURE21 = 34005;
  web_gl.RenderingContext.TEXTURE22 = 34006;
  web_gl.RenderingContext.TEXTURE23 = 34007;
  web_gl.RenderingContext.TEXTURE24 = 34008;
  web_gl.RenderingContext.TEXTURE25 = 34009;
  web_gl.RenderingContext.TEXTURE26 = 34010;
  web_gl.RenderingContext.TEXTURE27 = 34011;
  web_gl.RenderingContext.TEXTURE28 = 34012;
  web_gl.RenderingContext.TEXTURE29 = 34013;
  web_gl.RenderingContext.TEXTURE3 = 33987;
  web_gl.RenderingContext.TEXTURE30 = 34014;
  web_gl.RenderingContext.TEXTURE31 = 34015;
  web_gl.RenderingContext.TEXTURE4 = 33988;
  web_gl.RenderingContext.TEXTURE5 = 33989;
  web_gl.RenderingContext.TEXTURE6 = 33990;
  web_gl.RenderingContext.TEXTURE7 = 33991;
  web_gl.RenderingContext.TEXTURE8 = 33992;
  web_gl.RenderingContext.TEXTURE9 = 33993;
  web_gl.RenderingContext.TEXTURE_2D = 3553;
  web_gl.RenderingContext.TEXTURE_BINDING_2D = 32873;
  web_gl.RenderingContext.TEXTURE_BINDING_CUBE_MAP = 34068;
  web_gl.RenderingContext.TEXTURE_CUBE_MAP = 34067;
  web_gl.RenderingContext.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070;
  web_gl.RenderingContext.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072;
  web_gl.RenderingContext.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074;
  web_gl.RenderingContext.TEXTURE_CUBE_MAP_POSITIVE_X = 34069;
  web_gl.RenderingContext.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071;
  web_gl.RenderingContext.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073;
  web_gl.RenderingContext.TEXTURE_MAG_FILTER = 10240;
  web_gl.RenderingContext.TEXTURE_MIN_FILTER = 10241;
  web_gl.RenderingContext.TEXTURE_WRAP_S = 10242;
  web_gl.RenderingContext.TEXTURE_WRAP_T = 10243;
  web_gl.RenderingContext.TRIANGLES = 4;
  web_gl.RenderingContext.TRIANGLE_FAN = 6;
  web_gl.RenderingContext.TRIANGLE_STRIP = 5;
  web_gl.RenderingContext.UNPACK_ALIGNMENT = 3317;
  web_gl.RenderingContext.UNPACK_COLORSPACE_CONVERSION_WEBGL = 37443;
  web_gl.RenderingContext.UNPACK_FLIP_Y_WEBGL = 37440;
  web_gl.RenderingContext.UNPACK_PREMULTIPLY_ALPHA_WEBGL = 37441;
  web_gl.RenderingContext.UNSIGNED_BYTE = 5121;
  web_gl.RenderingContext.UNSIGNED_INT = 5125;
  web_gl.RenderingContext.UNSIGNED_SHORT = 5123;
  web_gl.RenderingContext.UNSIGNED_SHORT_4_4_4_4 = 32819;
  web_gl.RenderingContext.UNSIGNED_SHORT_5_5_5_1 = 32820;
  web_gl.RenderingContext.UNSIGNED_SHORT_5_6_5 = 33635;
  web_gl.RenderingContext.VALIDATE_STATUS = 35715;
  web_gl.RenderingContext.VENDOR = 7936;
  web_gl.RenderingContext.VERSION = 7938;
  web_gl.RenderingContext.VERTEX_ATTRIB_ARRAY_BUFFER_BINDING = 34975;
  web_gl.RenderingContext.VERTEX_ATTRIB_ARRAY_ENABLED = 34338;
  web_gl.RenderingContext.VERTEX_ATTRIB_ARRAY_NORMALIZED = 34922;
  web_gl.RenderingContext.VERTEX_ATTRIB_ARRAY_POINTER = 34373;
  web_gl.RenderingContext.VERTEX_ATTRIB_ARRAY_SIZE = 34339;
  web_gl.RenderingContext.VERTEX_ATTRIB_ARRAY_STRIDE = 34340;
  web_gl.RenderingContext.VERTEX_ATTRIB_ARRAY_TYPE = 34341;
  web_gl.RenderingContext.VERTEX_SHADER = 35633;
  web_gl.RenderingContext.VIEWPORT = 2978;
  web_gl.RenderingContext.ZERO = 0;
  dart.registerExtension(dart.global.WebGLRenderingContext, web_gl.RenderingContext);
  web_gl.ACTIVE_ATTRIBUTES = web_gl.RenderingContext.ACTIVE_ATTRIBUTES;
  web_gl.ACTIVE_TEXTURE = web_gl.RenderingContext.ACTIVE_TEXTURE;
  web_gl.ACTIVE_UNIFORMS = web_gl.RenderingContext.ACTIVE_UNIFORMS;
  web_gl.ALIASED_LINE_WIDTH_RANGE = web_gl.RenderingContext.ALIASED_LINE_WIDTH_RANGE;
  web_gl.ALIASED_POINT_SIZE_RANGE = web_gl.RenderingContext.ALIASED_POINT_SIZE_RANGE;
  web_gl.ALPHA = web_gl.RenderingContext.ALPHA;
  web_gl.ALPHA_BITS = web_gl.RenderingContext.ALPHA_BITS;
  web_gl.ALWAYS = web_gl.RenderingContext.ALWAYS;
  web_gl.ARRAY_BUFFER = web_gl.RenderingContext.ARRAY_BUFFER;
  web_gl.ARRAY_BUFFER_BINDING = web_gl.RenderingContext.ARRAY_BUFFER_BINDING;
  web_gl.ATTACHED_SHADERS = web_gl.RenderingContext.ATTACHED_SHADERS;
  web_gl.BACK = web_gl.RenderingContext.BACK;
  web_gl.BLEND = web_gl.RenderingContext.BLEND;
  web_gl.BLEND_COLOR = web_gl.RenderingContext.BLEND_COLOR;
  web_gl.BLEND_DST_ALPHA = web_gl.RenderingContext.BLEND_DST_ALPHA;
  web_gl.BLEND_DST_RGB = web_gl.RenderingContext.BLEND_DST_RGB;
  web_gl.BLEND_EQUATION = web_gl.RenderingContext.BLEND_EQUATION;
  web_gl.BLEND_EQUATION_ALPHA = web_gl.RenderingContext.BLEND_EQUATION_ALPHA;
  web_gl.BLEND_EQUATION_RGB = web_gl.RenderingContext.BLEND_EQUATION_RGB;
  web_gl.BLEND_SRC_ALPHA = web_gl.RenderingContext.BLEND_SRC_ALPHA;
  web_gl.BLEND_SRC_RGB = web_gl.RenderingContext.BLEND_SRC_RGB;
  web_gl.BLUE_BITS = web_gl.RenderingContext.BLUE_BITS;
  web_gl.BOOL = web_gl.RenderingContext.BOOL;
  web_gl.BOOL_VEC2 = web_gl.RenderingContext.BOOL_VEC2;
  web_gl.BOOL_VEC3 = web_gl.RenderingContext.BOOL_VEC3;
  web_gl.BOOL_VEC4 = web_gl.RenderingContext.BOOL_VEC4;
  web_gl.BROWSER_DEFAULT_WEBGL = web_gl.RenderingContext.BROWSER_DEFAULT_WEBGL;
  web_gl.BUFFER_SIZE = web_gl.RenderingContext.BUFFER_SIZE;
  web_gl.BUFFER_USAGE = web_gl.RenderingContext.BUFFER_USAGE;
  web_gl.BYTE = web_gl.RenderingContext.BYTE;
  web_gl.CCW = web_gl.RenderingContext.CCW;
  web_gl.CLAMP_TO_EDGE = web_gl.RenderingContext.CLAMP_TO_EDGE;
  web_gl.COLOR_ATTACHMENT0 = web_gl.RenderingContext.COLOR_ATTACHMENT0;
  web_gl.COLOR_BUFFER_BIT = web_gl.RenderingContext.COLOR_BUFFER_BIT;
  web_gl.COLOR_CLEAR_VALUE = web_gl.RenderingContext.COLOR_CLEAR_VALUE;
  web_gl.COLOR_WRITEMASK = web_gl.RenderingContext.COLOR_WRITEMASK;
  web_gl.COMPILE_STATUS = web_gl.RenderingContext.COMPILE_STATUS;
  web_gl.COMPRESSED_TEXTURE_FORMATS = web_gl.RenderingContext.COMPRESSED_TEXTURE_FORMATS;
  web_gl.CONSTANT_ALPHA = web_gl.RenderingContext.CONSTANT_ALPHA;
  web_gl.CONSTANT_COLOR = web_gl.RenderingContext.CONSTANT_COLOR;
  web_gl.CONTEXT_LOST_WEBGL = web_gl.RenderingContext.CONTEXT_LOST_WEBGL;
  web_gl.CULL_FACE = web_gl.RenderingContext.CULL_FACE;
  web_gl.CULL_FACE_MODE = web_gl.RenderingContext.CULL_FACE_MODE;
  web_gl.CURRENT_PROGRAM = web_gl.RenderingContext.CURRENT_PROGRAM;
  web_gl.CURRENT_VERTEX_ATTRIB = web_gl.RenderingContext.CURRENT_VERTEX_ATTRIB;
  web_gl.CW = web_gl.RenderingContext.CW;
  web_gl.DECR = web_gl.RenderingContext.DECR;
  web_gl.DECR_WRAP = web_gl.RenderingContext.DECR_WRAP;
  web_gl.DELETE_STATUS = web_gl.RenderingContext.DELETE_STATUS;
  web_gl.DEPTH_ATTACHMENT = web_gl.RenderingContext.DEPTH_ATTACHMENT;
  web_gl.DEPTH_BITS = web_gl.RenderingContext.DEPTH_BITS;
  web_gl.DEPTH_BUFFER_BIT = web_gl.RenderingContext.DEPTH_BUFFER_BIT;
  web_gl.DEPTH_CLEAR_VALUE = web_gl.RenderingContext.DEPTH_CLEAR_VALUE;
  web_gl.DEPTH_COMPONENT = web_gl.RenderingContext.DEPTH_COMPONENT;
  web_gl.DEPTH_COMPONENT16 = web_gl.RenderingContext.DEPTH_COMPONENT16;
  web_gl.DEPTH_FUNC = web_gl.RenderingContext.DEPTH_FUNC;
  web_gl.DEPTH_RANGE = web_gl.RenderingContext.DEPTH_RANGE;
  web_gl.DEPTH_STENCIL = web_gl.RenderingContext.DEPTH_STENCIL;
  web_gl.DEPTH_STENCIL_ATTACHMENT = web_gl.RenderingContext.DEPTH_STENCIL_ATTACHMENT;
  web_gl.DEPTH_TEST = web_gl.RenderingContext.DEPTH_TEST;
  web_gl.DEPTH_WRITEMASK = web_gl.RenderingContext.DEPTH_WRITEMASK;
  web_gl.DITHER = web_gl.RenderingContext.DITHER;
  web_gl.DONT_CARE = web_gl.RenderingContext.DONT_CARE;
  web_gl.DST_ALPHA = web_gl.RenderingContext.DST_ALPHA;
  web_gl.DST_COLOR = web_gl.RenderingContext.DST_COLOR;
  web_gl.DYNAMIC_DRAW = web_gl.RenderingContext.DYNAMIC_DRAW;
  web_gl.ELEMENT_ARRAY_BUFFER = web_gl.RenderingContext.ELEMENT_ARRAY_BUFFER;
  web_gl.ELEMENT_ARRAY_BUFFER_BINDING = web_gl.RenderingContext.ELEMENT_ARRAY_BUFFER_BINDING;
  web_gl.EQUAL = web_gl.RenderingContext.EQUAL;
  web_gl.FASTEST = web_gl.RenderingContext.FASTEST;
  web_gl.FLOAT = web_gl.RenderingContext.FLOAT;
  web_gl.FLOAT_MAT2 = web_gl.RenderingContext.FLOAT_MAT2;
  web_gl.FLOAT_MAT3 = web_gl.RenderingContext.FLOAT_MAT3;
  web_gl.FLOAT_MAT4 = web_gl.RenderingContext.FLOAT_MAT4;
  web_gl.FLOAT_VEC2 = web_gl.RenderingContext.FLOAT_VEC2;
  web_gl.FLOAT_VEC3 = web_gl.RenderingContext.FLOAT_VEC3;
  web_gl.FLOAT_VEC4 = web_gl.RenderingContext.FLOAT_VEC4;
  web_gl.FRAGMENT_SHADER = web_gl.RenderingContext.FRAGMENT_SHADER;
  web_gl.FRAMEBUFFER = web_gl.RenderingContext.FRAMEBUFFER;
  web_gl.FRAMEBUFFER_ATTACHMENT_OBJECT_NAME = web_gl.RenderingContext.FRAMEBUFFER_ATTACHMENT_OBJECT_NAME;
  web_gl.FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE = web_gl.RenderingContext.FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE;
  web_gl.FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE = web_gl.RenderingContext.FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE;
  web_gl.FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL = web_gl.RenderingContext.FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL;
  web_gl.FRAMEBUFFER_BINDING = web_gl.RenderingContext.FRAMEBUFFER_BINDING;
  web_gl.FRAMEBUFFER_COMPLETE = web_gl.RenderingContext.FRAMEBUFFER_COMPLETE;
  web_gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT = web_gl.RenderingContext.FRAMEBUFFER_INCOMPLETE_ATTACHMENT;
  web_gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS = web_gl.RenderingContext.FRAMEBUFFER_INCOMPLETE_DIMENSIONS;
  web_gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT = web_gl.RenderingContext.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT;
  web_gl.FRAMEBUFFER_UNSUPPORTED = web_gl.RenderingContext.FRAMEBUFFER_UNSUPPORTED;
  web_gl.FRONT = web_gl.RenderingContext.FRONT;
  web_gl.FRONT_AND_BACK = web_gl.RenderingContext.FRONT_AND_BACK;
  web_gl.FRONT_FACE = web_gl.RenderingContext.FRONT_FACE;
  web_gl.FUNC_ADD = web_gl.RenderingContext.FUNC_ADD;
  web_gl.FUNC_REVERSE_SUBTRACT = web_gl.RenderingContext.FUNC_REVERSE_SUBTRACT;
  web_gl.FUNC_SUBTRACT = web_gl.RenderingContext.FUNC_SUBTRACT;
  web_gl.GENERATE_MIPMAP_HINT = web_gl.RenderingContext.GENERATE_MIPMAP_HINT;
  web_gl.GEQUAL = web_gl.RenderingContext.GEQUAL;
  web_gl.GREATER = web_gl.RenderingContext.GREATER;
  web_gl.GREEN_BITS = web_gl.RenderingContext.GREEN_BITS;
  web_gl.OesTextureHalfFloat = class OesTextureHalfFloat extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(web_gl.OesTextureHalfFloat, {
    constructors: () => ({_: dart.definiteFunctionType(web_gl.OesTextureHalfFloat, [])})
  });
  web_gl.OesTextureHalfFloat.HALF_FLOAT_OES = 36193;
  dart.registerExtension(dart.global.OESTextureHalfFloat, web_gl.OesTextureHalfFloat);
  web_gl.HALF_FLOAT_OES = web_gl.OesTextureHalfFloat.HALF_FLOAT_OES;
  web_gl.HIGH_FLOAT = web_gl.RenderingContext.HIGH_FLOAT;
  web_gl.HIGH_INT = web_gl.RenderingContext.HIGH_INT;
  web_gl.INCR = web_gl.RenderingContext.INCR;
  web_gl.INCR_WRAP = web_gl.RenderingContext.INCR_WRAP;
  web_gl.INT = web_gl.RenderingContext.INT;
  web_gl.INT_VEC2 = web_gl.RenderingContext.INT_VEC2;
  web_gl.INT_VEC3 = web_gl.RenderingContext.INT_VEC3;
  web_gl.INT_VEC4 = web_gl.RenderingContext.INT_VEC4;
  web_gl.INVALID_ENUM = web_gl.RenderingContext.INVALID_ENUM;
  web_gl.INVALID_FRAMEBUFFER_OPERATION = web_gl.RenderingContext.INVALID_FRAMEBUFFER_OPERATION;
  web_gl.INVALID_OPERATION = web_gl.RenderingContext.INVALID_OPERATION;
  web_gl.INVALID_VALUE = web_gl.RenderingContext.INVALID_VALUE;
  web_gl.INVERT = web_gl.RenderingContext.INVERT;
  web_gl.KEEP = web_gl.RenderingContext.KEEP;
  web_gl.LEQUAL = web_gl.RenderingContext.LEQUAL;
  web_gl.LESS = web_gl.RenderingContext.LESS;
  web_gl.LINEAR = web_gl.RenderingContext.LINEAR;
  web_gl.LINEAR_MIPMAP_LINEAR = web_gl.RenderingContext.LINEAR_MIPMAP_LINEAR;
  web_gl.LINEAR_MIPMAP_NEAREST = web_gl.RenderingContext.LINEAR_MIPMAP_NEAREST;
  web_gl.LINES = web_gl.RenderingContext.LINES;
  web_gl.LINE_LOOP = web_gl.RenderingContext.LINE_LOOP;
  web_gl.LINE_STRIP = web_gl.RenderingContext.LINE_STRIP;
  web_gl.LINE_WIDTH = web_gl.RenderingContext.LINE_WIDTH;
  web_gl.LINK_STATUS = web_gl.RenderingContext.LINK_STATUS;
  web_gl.LOW_FLOAT = web_gl.RenderingContext.LOW_FLOAT;
  web_gl.LOW_INT = web_gl.RenderingContext.LOW_INT;
  web_gl.LUMINANCE = web_gl.RenderingContext.LUMINANCE;
  web_gl.LUMINANCE_ALPHA = web_gl.RenderingContext.LUMINANCE_ALPHA;
  web_gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS = web_gl.RenderingContext.MAX_COMBINED_TEXTURE_IMAGE_UNITS;
  web_gl.MAX_CUBE_MAP_TEXTURE_SIZE = web_gl.RenderingContext.MAX_CUBE_MAP_TEXTURE_SIZE;
  web_gl.MAX_FRAGMENT_UNIFORM_VECTORS = web_gl.RenderingContext.MAX_FRAGMENT_UNIFORM_VECTORS;
  web_gl.MAX_RENDERBUFFER_SIZE = web_gl.RenderingContext.MAX_RENDERBUFFER_SIZE;
  web_gl.MAX_TEXTURE_IMAGE_UNITS = web_gl.RenderingContext.MAX_TEXTURE_IMAGE_UNITS;
  web_gl.MAX_TEXTURE_SIZE = web_gl.RenderingContext.MAX_TEXTURE_SIZE;
  web_gl.MAX_VARYING_VECTORS = web_gl.RenderingContext.MAX_VARYING_VECTORS;
  web_gl.MAX_VERTEX_ATTRIBS = web_gl.RenderingContext.MAX_VERTEX_ATTRIBS;
  web_gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS = web_gl.RenderingContext.MAX_VERTEX_TEXTURE_IMAGE_UNITS;
  web_gl.MAX_VERTEX_UNIFORM_VECTORS = web_gl.RenderingContext.MAX_VERTEX_UNIFORM_VECTORS;
  web_gl.MAX_VIEWPORT_DIMS = web_gl.RenderingContext.MAX_VIEWPORT_DIMS;
  web_gl.MEDIUM_FLOAT = web_gl.RenderingContext.MEDIUM_FLOAT;
  web_gl.MEDIUM_INT = web_gl.RenderingContext.MEDIUM_INT;
  web_gl.MIRRORED_REPEAT = web_gl.RenderingContext.MIRRORED_REPEAT;
  web_gl.NEAREST = web_gl.RenderingContext.NEAREST;
  web_gl.NEAREST_MIPMAP_LINEAR = web_gl.RenderingContext.NEAREST_MIPMAP_LINEAR;
  web_gl.NEAREST_MIPMAP_NEAREST = web_gl.RenderingContext.NEAREST_MIPMAP_NEAREST;
  web_gl.NEVER = web_gl.RenderingContext.NEVER;
  web_gl.NICEST = web_gl.RenderingContext.NICEST;
  web_gl.NONE = web_gl.RenderingContext.NONE;
  web_gl.NOTEQUAL = web_gl.RenderingContext.NOTEQUAL;
  web_gl.NO_ERROR = web_gl.RenderingContext.NO_ERROR;
  web_gl.ONE = web_gl.RenderingContext.ONE;
  web_gl.ONE_MINUS_CONSTANT_ALPHA = web_gl.RenderingContext.ONE_MINUS_CONSTANT_ALPHA;
  web_gl.ONE_MINUS_CONSTANT_COLOR = web_gl.RenderingContext.ONE_MINUS_CONSTANT_COLOR;
  web_gl.ONE_MINUS_DST_ALPHA = web_gl.RenderingContext.ONE_MINUS_DST_ALPHA;
  web_gl.ONE_MINUS_DST_COLOR = web_gl.RenderingContext.ONE_MINUS_DST_COLOR;
  web_gl.ONE_MINUS_SRC_ALPHA = web_gl.RenderingContext.ONE_MINUS_SRC_ALPHA;
  web_gl.ONE_MINUS_SRC_COLOR = web_gl.RenderingContext.ONE_MINUS_SRC_COLOR;
  web_gl.OUT_OF_MEMORY = web_gl.RenderingContext.OUT_OF_MEMORY;
  web_gl.PACK_ALIGNMENT = web_gl.RenderingContext.PACK_ALIGNMENT;
  web_gl.POINTS = web_gl.RenderingContext.POINTS;
  web_gl.POLYGON_OFFSET_FACTOR = web_gl.RenderingContext.POLYGON_OFFSET_FACTOR;
  web_gl.POLYGON_OFFSET_FILL = web_gl.RenderingContext.POLYGON_OFFSET_FILL;
  web_gl.POLYGON_OFFSET_UNITS = web_gl.RenderingContext.POLYGON_OFFSET_UNITS;
  web_gl.RED_BITS = web_gl.RenderingContext.RED_BITS;
  web_gl.RENDERBUFFER = web_gl.RenderingContext.RENDERBUFFER;
  web_gl.RENDERBUFFER_ALPHA_SIZE = web_gl.RenderingContext.RENDERBUFFER_ALPHA_SIZE;
  web_gl.RENDERBUFFER_BINDING = web_gl.RenderingContext.RENDERBUFFER_BINDING;
  web_gl.RENDERBUFFER_BLUE_SIZE = web_gl.RenderingContext.RENDERBUFFER_BLUE_SIZE;
  web_gl.RENDERBUFFER_DEPTH_SIZE = web_gl.RenderingContext.RENDERBUFFER_DEPTH_SIZE;
  web_gl.RENDERBUFFER_GREEN_SIZE = web_gl.RenderingContext.RENDERBUFFER_GREEN_SIZE;
  web_gl.RENDERBUFFER_HEIGHT = web_gl.RenderingContext.RENDERBUFFER_HEIGHT;
  web_gl.RENDERBUFFER_INTERNAL_FORMAT = web_gl.RenderingContext.RENDERBUFFER_INTERNAL_FORMAT;
  web_gl.RENDERBUFFER_RED_SIZE = web_gl.RenderingContext.RENDERBUFFER_RED_SIZE;
  web_gl.RENDERBUFFER_STENCIL_SIZE = web_gl.RenderingContext.RENDERBUFFER_STENCIL_SIZE;
  web_gl.RENDERBUFFER_WIDTH = web_gl.RenderingContext.RENDERBUFFER_WIDTH;
  web_gl.RENDERER = web_gl.RenderingContext.RENDERER;
  web_gl.REPEAT = web_gl.RenderingContext.REPEAT;
  web_gl.REPLACE = web_gl.RenderingContext.REPLACE;
  web_gl.RGB = web_gl.RenderingContext.RGB;
  web_gl.RGB565 = web_gl.RenderingContext.RGB565;
  web_gl.RGB5_A1 = web_gl.RenderingContext.RGB5_A1;
  web_gl.RGBA = web_gl.RenderingContext.RGBA;
  web_gl.RGBA4 = web_gl.RenderingContext.RGBA4;
  web_gl.SAMPLER_2D = web_gl.RenderingContext.SAMPLER_2D;
  web_gl.SAMPLER_CUBE = web_gl.RenderingContext.SAMPLER_CUBE;
  web_gl.SAMPLES = web_gl.RenderingContext.SAMPLES;
  web_gl.SAMPLE_ALPHA_TO_COVERAGE = web_gl.RenderingContext.SAMPLE_ALPHA_TO_COVERAGE;
  web_gl.SAMPLE_BUFFERS = web_gl.RenderingContext.SAMPLE_BUFFERS;
  web_gl.SAMPLE_COVERAGE = web_gl.RenderingContext.SAMPLE_COVERAGE;
  web_gl.SAMPLE_COVERAGE_INVERT = web_gl.RenderingContext.SAMPLE_COVERAGE_INVERT;
  web_gl.SAMPLE_COVERAGE_VALUE = web_gl.RenderingContext.SAMPLE_COVERAGE_VALUE;
  web_gl.SCISSOR_BOX = web_gl.RenderingContext.SCISSOR_BOX;
  web_gl.SCISSOR_TEST = web_gl.RenderingContext.SCISSOR_TEST;
  web_gl.SHADER_TYPE = web_gl.RenderingContext.SHADER_TYPE;
  web_gl.SHADING_LANGUAGE_VERSION = web_gl.RenderingContext.SHADING_LANGUAGE_VERSION;
  web_gl.SHORT = web_gl.RenderingContext.SHORT;
  web_gl.SRC_ALPHA = web_gl.RenderingContext.SRC_ALPHA;
  web_gl.SRC_ALPHA_SATURATE = web_gl.RenderingContext.SRC_ALPHA_SATURATE;
  web_gl.SRC_COLOR = web_gl.RenderingContext.SRC_COLOR;
  web_gl.STATIC_DRAW = web_gl.RenderingContext.STATIC_DRAW;
  web_gl.STENCIL_ATTACHMENT = web_gl.RenderingContext.STENCIL_ATTACHMENT;
  web_gl.STENCIL_BACK_FAIL = web_gl.RenderingContext.STENCIL_BACK_FAIL;
  web_gl.STENCIL_BACK_FUNC = web_gl.RenderingContext.STENCIL_BACK_FUNC;
  web_gl.STENCIL_BACK_PASS_DEPTH_FAIL = web_gl.RenderingContext.STENCIL_BACK_PASS_DEPTH_FAIL;
  web_gl.STENCIL_BACK_PASS_DEPTH_PASS = web_gl.RenderingContext.STENCIL_BACK_PASS_DEPTH_PASS;
  web_gl.STENCIL_BACK_REF = web_gl.RenderingContext.STENCIL_BACK_REF;
  web_gl.STENCIL_BACK_VALUE_MASK = web_gl.RenderingContext.STENCIL_BACK_VALUE_MASK;
  web_gl.STENCIL_BACK_WRITEMASK = web_gl.RenderingContext.STENCIL_BACK_WRITEMASK;
  web_gl.STENCIL_BITS = web_gl.RenderingContext.STENCIL_BITS;
  web_gl.STENCIL_BUFFER_BIT = web_gl.RenderingContext.STENCIL_BUFFER_BIT;
  web_gl.STENCIL_CLEAR_VALUE = web_gl.RenderingContext.STENCIL_CLEAR_VALUE;
  web_gl.STENCIL_FAIL = web_gl.RenderingContext.STENCIL_FAIL;
  web_gl.STENCIL_FUNC = web_gl.RenderingContext.STENCIL_FUNC;
  web_gl.STENCIL_INDEX = web_gl.RenderingContext.STENCIL_INDEX;
  web_gl.STENCIL_INDEX8 = web_gl.RenderingContext.STENCIL_INDEX8;
  web_gl.STENCIL_PASS_DEPTH_FAIL = web_gl.RenderingContext.STENCIL_PASS_DEPTH_FAIL;
  web_gl.STENCIL_PASS_DEPTH_PASS = web_gl.RenderingContext.STENCIL_PASS_DEPTH_PASS;
  web_gl.STENCIL_REF = web_gl.RenderingContext.STENCIL_REF;
  web_gl.STENCIL_TEST = web_gl.RenderingContext.STENCIL_TEST;
  web_gl.STENCIL_VALUE_MASK = web_gl.RenderingContext.STENCIL_VALUE_MASK;
  web_gl.STENCIL_WRITEMASK = web_gl.RenderingContext.STENCIL_WRITEMASK;
  web_gl.STREAM_DRAW = web_gl.RenderingContext.STREAM_DRAW;
  web_gl.SUBPIXEL_BITS = web_gl.RenderingContext.SUBPIXEL_BITS;
  web_gl.TEXTURE = web_gl.RenderingContext.TEXTURE;
  web_gl.TEXTURE0 = web_gl.RenderingContext.TEXTURE0;
  web_gl.TEXTURE1 = web_gl.RenderingContext.TEXTURE1;
  web_gl.TEXTURE10 = web_gl.RenderingContext.TEXTURE10;
  web_gl.TEXTURE11 = web_gl.RenderingContext.TEXTURE11;
  web_gl.TEXTURE12 = web_gl.RenderingContext.TEXTURE12;
  web_gl.TEXTURE13 = web_gl.RenderingContext.TEXTURE13;
  web_gl.TEXTURE14 = web_gl.RenderingContext.TEXTURE14;
  web_gl.TEXTURE15 = web_gl.RenderingContext.TEXTURE15;
  web_gl.TEXTURE16 = web_gl.RenderingContext.TEXTURE16;
  web_gl.TEXTURE17 = web_gl.RenderingContext.TEXTURE17;
  web_gl.TEXTURE18 = web_gl.RenderingContext.TEXTURE18;
  web_gl.TEXTURE19 = web_gl.RenderingContext.TEXTURE19;
  web_gl.TEXTURE2 = web_gl.RenderingContext.TEXTURE2;
  web_gl.TEXTURE20 = web_gl.RenderingContext.TEXTURE20;
  web_gl.TEXTURE21 = web_gl.RenderingContext.TEXTURE21;
  web_gl.TEXTURE22 = web_gl.RenderingContext.TEXTURE22;
  web_gl.TEXTURE23 = web_gl.RenderingContext.TEXTURE23;
  web_gl.TEXTURE24 = web_gl.RenderingContext.TEXTURE24;
  web_gl.TEXTURE25 = web_gl.RenderingContext.TEXTURE25;
  web_gl.TEXTURE26 = web_gl.RenderingContext.TEXTURE26;
  web_gl.TEXTURE27 = web_gl.RenderingContext.TEXTURE27;
  web_gl.TEXTURE28 = web_gl.RenderingContext.TEXTURE28;
  web_gl.TEXTURE29 = web_gl.RenderingContext.TEXTURE29;
  web_gl.TEXTURE3 = web_gl.RenderingContext.TEXTURE3;
  web_gl.TEXTURE30 = web_gl.RenderingContext.TEXTURE30;
  web_gl.TEXTURE31 = web_gl.RenderingContext.TEXTURE31;
  web_gl.TEXTURE4 = web_gl.RenderingContext.TEXTURE4;
  web_gl.TEXTURE5 = web_gl.RenderingContext.TEXTURE5;
  web_gl.TEXTURE6 = web_gl.RenderingContext.TEXTURE6;
  web_gl.TEXTURE7 = web_gl.RenderingContext.TEXTURE7;
  web_gl.TEXTURE8 = web_gl.RenderingContext.TEXTURE8;
  web_gl.TEXTURE9 = web_gl.RenderingContext.TEXTURE9;
  web_gl.TEXTURE_2D = web_gl.RenderingContext.TEXTURE_2D;
  web_gl.TEXTURE_BINDING_2D = web_gl.RenderingContext.TEXTURE_BINDING_2D;
  web_gl.TEXTURE_BINDING_CUBE_MAP = web_gl.RenderingContext.TEXTURE_BINDING_CUBE_MAP;
  web_gl.TEXTURE_CUBE_MAP = web_gl.RenderingContext.TEXTURE_CUBE_MAP;
  web_gl.TEXTURE_CUBE_MAP_NEGATIVE_X = web_gl.RenderingContext.TEXTURE_CUBE_MAP_NEGATIVE_X;
  web_gl.TEXTURE_CUBE_MAP_NEGATIVE_Y = web_gl.RenderingContext.TEXTURE_CUBE_MAP_NEGATIVE_Y;
  web_gl.TEXTURE_CUBE_MAP_NEGATIVE_Z = web_gl.RenderingContext.TEXTURE_CUBE_MAP_NEGATIVE_Z;
  web_gl.TEXTURE_CUBE_MAP_POSITIVE_X = web_gl.RenderingContext.TEXTURE_CUBE_MAP_POSITIVE_X;
  web_gl.TEXTURE_CUBE_MAP_POSITIVE_Y = web_gl.RenderingContext.TEXTURE_CUBE_MAP_POSITIVE_Y;
  web_gl.TEXTURE_CUBE_MAP_POSITIVE_Z = web_gl.RenderingContext.TEXTURE_CUBE_MAP_POSITIVE_Z;
  web_gl.TEXTURE_MAG_FILTER = web_gl.RenderingContext.TEXTURE_MAG_FILTER;
  web_gl.TEXTURE_MIN_FILTER = web_gl.RenderingContext.TEXTURE_MIN_FILTER;
  web_gl.TEXTURE_WRAP_S = web_gl.RenderingContext.TEXTURE_WRAP_S;
  web_gl.TEXTURE_WRAP_T = web_gl.RenderingContext.TEXTURE_WRAP_T;
  web_gl.TRIANGLES = web_gl.RenderingContext.TRIANGLES;
  web_gl.TRIANGLE_FAN = web_gl.RenderingContext.TRIANGLE_FAN;
  web_gl.TRIANGLE_STRIP = web_gl.RenderingContext.TRIANGLE_STRIP;
  web_gl.UNPACK_ALIGNMENT = web_gl.RenderingContext.UNPACK_ALIGNMENT;
  web_gl.UNPACK_COLORSPACE_CONVERSION_WEBGL = web_gl.RenderingContext.UNPACK_COLORSPACE_CONVERSION_WEBGL;
  web_gl.UNPACK_FLIP_Y_WEBGL = web_gl.RenderingContext.UNPACK_FLIP_Y_WEBGL;
  web_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL = web_gl.RenderingContext.UNPACK_PREMULTIPLY_ALPHA_WEBGL;
  web_gl.UNSIGNED_BYTE = web_gl.RenderingContext.UNSIGNED_BYTE;
  web_gl.UNSIGNED_INT = web_gl.RenderingContext.UNSIGNED_INT;
  web_gl.UNSIGNED_SHORT = web_gl.RenderingContext.UNSIGNED_SHORT;
  web_gl.UNSIGNED_SHORT_4_4_4_4 = web_gl.RenderingContext.UNSIGNED_SHORT_4_4_4_4;
  web_gl.UNSIGNED_SHORT_5_5_5_1 = web_gl.RenderingContext.UNSIGNED_SHORT_5_5_5_1;
  web_gl.UNSIGNED_SHORT_5_6_5 = web_gl.RenderingContext.UNSIGNED_SHORT_5_6_5;
  web_gl.VALIDATE_STATUS = web_gl.RenderingContext.VALIDATE_STATUS;
  web_gl.VENDOR = web_gl.RenderingContext.VENDOR;
  web_gl.VERSION = web_gl.RenderingContext.VERSION;
  web_gl.VERTEX_ATTRIB_ARRAY_BUFFER_BINDING = web_gl.RenderingContext.VERTEX_ATTRIB_ARRAY_BUFFER_BINDING;
  web_gl.VERTEX_ATTRIB_ARRAY_ENABLED = web_gl.RenderingContext.VERTEX_ATTRIB_ARRAY_ENABLED;
  web_gl.VERTEX_ATTRIB_ARRAY_NORMALIZED = web_gl.RenderingContext.VERTEX_ATTRIB_ARRAY_NORMALIZED;
  web_gl.VERTEX_ATTRIB_ARRAY_POINTER = web_gl.RenderingContext.VERTEX_ATTRIB_ARRAY_POINTER;
  web_gl.VERTEX_ATTRIB_ARRAY_SIZE = web_gl.RenderingContext.VERTEX_ATTRIB_ARRAY_SIZE;
  web_gl.VERTEX_ATTRIB_ARRAY_STRIDE = web_gl.RenderingContext.VERTEX_ATTRIB_ARRAY_STRIDE;
  web_gl.VERTEX_ATTRIB_ARRAY_TYPE = web_gl.RenderingContext.VERTEX_ATTRIB_ARRAY_TYPE;
  web_gl.VERTEX_SHADER = web_gl.RenderingContext.VERTEX_SHADER;
  web_gl.VIEWPORT = web_gl.RenderingContext.VIEWPORT;
  web_gl.ZERO = web_gl.RenderingContext.ZERO;
  dart.defineExtensionNames([
    'name',
    'size',
    'type'
  ]);
  web_gl.ActiveInfo = class ActiveInfo extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.name]() {
      return this.name;
    }
    get [dartx.size]() {
      return this.size;
    }
    get [dartx.type]() {
      return this.type;
    }
  };
  dart.setSignature(web_gl.ActiveInfo, {
    constructors: () => ({_: dart.definiteFunctionType(web_gl.ActiveInfo, [])})
  });
  dart.registerExtension(dart.global.WebGLActiveInfo, web_gl.ActiveInfo);
  dart.defineExtensionNames([
    'drawArraysInstancedAngle',
    'drawElementsInstancedAngle',
    'vertexAttribDivisorAngle'
  ]);
  web_gl.AngleInstancedArrays = class AngleInstancedArrays extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [dartx.drawArraysInstancedAngle](mode, first, count, primcount) {
      return this.drawArraysInstancedANGLE(mode, first, count, primcount);
    }
    [dartx.drawElementsInstancedAngle](mode, count, type, offset, primcount) {
      return this.drawElementsInstancedANGLE(mode, count, type, offset, primcount);
    }
    [dartx.vertexAttribDivisorAngle](index, divisor) {
      return this.vertexAttribDivisorANGLE(index, divisor);
    }
  };
  dart.setSignature(web_gl.AngleInstancedArrays, {
    constructors: () => ({_: dart.definiteFunctionType(web_gl.AngleInstancedArrays, [])}),
    methods: () => ({
      [dartx.drawArraysInstancedAngle]: dart.definiteFunctionType(dart.void, [core.int, core.int, core.int, core.int]),
      [dartx.drawElementsInstancedAngle]: dart.definiteFunctionType(dart.void, [core.int, core.int, core.int, core.int, core.int]),
      [dartx.vertexAttribDivisorAngle]: dart.definiteFunctionType(dart.void, [core.int, core.int])
    })
  });
  web_gl.AngleInstancedArrays.VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE = 35070;
  dart.registerExtension(dart.global.ANGLEInstancedArrays, web_gl.AngleInstancedArrays);
  web_gl.Buffer = class Buffer extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(web_gl.Buffer, {
    constructors: () => ({_: dart.definiteFunctionType(web_gl.Buffer, [])})
  });
  dart.registerExtension(dart.global.WebGLBuffer, web_gl.Buffer);
  web_gl.CompressedTextureAtc = class CompressedTextureAtc extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(web_gl.CompressedTextureAtc, {
    constructors: () => ({_: dart.definiteFunctionType(web_gl.CompressedTextureAtc, [])})
  });
  web_gl.CompressedTextureAtc.COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL = 35987;
  web_gl.CompressedTextureAtc.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL = 34798;
  web_gl.CompressedTextureAtc.COMPRESSED_RGB_ATC_WEBGL = 35986;
  dart.registerExtension(dart.global.WebGLCompressedTextureATC, web_gl.CompressedTextureAtc);
  web_gl.CompressedTextureETC1 = class CompressedTextureETC1 extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(web_gl.CompressedTextureETC1, {
    constructors: () => ({_: dart.definiteFunctionType(web_gl.CompressedTextureETC1, [])})
  });
  web_gl.CompressedTextureETC1.COMPRESSED_RGB_ETC1_WEBGL = 36196;
  dart.registerExtension(dart.global.WebGLCompressedTextureETC1, web_gl.CompressedTextureETC1);
  web_gl.CompressedTexturePvrtc = class CompressedTexturePvrtc extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(web_gl.CompressedTexturePvrtc, {
    constructors: () => ({_: dart.definiteFunctionType(web_gl.CompressedTexturePvrtc, [])})
  });
  web_gl.CompressedTexturePvrtc.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG = 35843;
  web_gl.CompressedTexturePvrtc.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG = 35842;
  web_gl.CompressedTexturePvrtc.COMPRESSED_RGB_PVRTC_2BPPV1_IMG = 35841;
  web_gl.CompressedTexturePvrtc.COMPRESSED_RGB_PVRTC_4BPPV1_IMG = 35840;
  dart.registerExtension(dart.global.WebGLCompressedTexturePVRTC, web_gl.CompressedTexturePvrtc);
  web_gl.CompressedTextureS3TC = class CompressedTextureS3TC extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(web_gl.CompressedTextureS3TC, {
    constructors: () => ({_: dart.definiteFunctionType(web_gl.CompressedTextureS3TC, [])})
  });
  web_gl.CompressedTextureS3TC.COMPRESSED_RGBA_S3TC_DXT1_EXT = 33777;
  web_gl.CompressedTextureS3TC.COMPRESSED_RGBA_S3TC_DXT3_EXT = 33778;
  web_gl.CompressedTextureS3TC.COMPRESSED_RGBA_S3TC_DXT5_EXT = 33779;
  web_gl.CompressedTextureS3TC.COMPRESSED_RGB_S3TC_DXT1_EXT = 33776;
  dart.registerExtension(dart.global.WebGLCompressedTextureS3TC, web_gl.CompressedTextureS3TC);
  dart.defineExtensionNames([
    'alpha',
    'antialias',
    'depth',
    'failIfMajorPerformanceCaveat',
    'premultipliedAlpha',
    'preserveDrawingBuffer',
    'stencil'
  ]);
  web_gl.ContextAttributes = class ContextAttributes extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.alpha]() {
      return this.alpha;
    }
    set [dartx.alpha](value) {
      this.alpha = value;
    }
    get [dartx.antialias]() {
      return this.antialias;
    }
    set [dartx.antialias](value) {
      this.antialias = value;
    }
    get [dartx.depth]() {
      return this.depth;
    }
    set [dartx.depth](value) {
      this.depth = value;
    }
    get [dartx.failIfMajorPerformanceCaveat]() {
      return this.failIfMajorPerformanceCaveat;
    }
    set [dartx.failIfMajorPerformanceCaveat](value) {
      this.failIfMajorPerformanceCaveat = value;
    }
    get [dartx.premultipliedAlpha]() {
      return this.premultipliedAlpha;
    }
    set [dartx.premultipliedAlpha](value) {
      this.premultipliedAlpha = value;
    }
    get [dartx.preserveDrawingBuffer]() {
      return this.preserveDrawingBuffer;
    }
    set [dartx.preserveDrawingBuffer](value) {
      this.preserveDrawingBuffer = value;
    }
    get [dartx.stencil]() {
      return this.stencil;
    }
    set [dartx.stencil](value) {
      this.stencil = value;
    }
  };
  dart.setSignature(web_gl.ContextAttributes, {
    constructors: () => ({_: dart.definiteFunctionType(web_gl.ContextAttributes, [])})
  });
  dart.registerExtension(dart.global.WebGLContextAttributes, web_gl.ContextAttributes);
  dart.defineExtensionNames([
    'statusMessage'
  ]);
  web_gl.ContextEvent = class ContextEvent extends html$.Event {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.statusMessage]() {
      return this.statusMessage;
    }
  };
  dart.setSignature(web_gl.ContextEvent, {
    constructors: () => ({_: dart.definiteFunctionType(web_gl.ContextEvent, [])})
  });
  dart.registerExtension(dart.global.WebGLContextEvent, web_gl.ContextEvent);
  web_gl.DebugRendererInfo = class DebugRendererInfo extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(web_gl.DebugRendererInfo, {
    constructors: () => ({_: dart.definiteFunctionType(web_gl.DebugRendererInfo, [])})
  });
  web_gl.DebugRendererInfo.UNMASKED_RENDERER_WEBGL = 37446;
  web_gl.DebugRendererInfo.UNMASKED_VENDOR_WEBGL = 37445;
  dart.registerExtension(dart.global.WebGLDebugRendererInfo, web_gl.DebugRendererInfo);
  dart.defineExtensionNames([
    'getTranslatedShaderSource'
  ]);
  web_gl.DebugShaders = class DebugShaders extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [dartx.getTranslatedShaderSource](shader) {
      return this.getTranslatedShaderSource(shader);
    }
  };
  dart.setSignature(web_gl.DebugShaders, {
    constructors: () => ({_: dart.definiteFunctionType(web_gl.DebugShaders, [])}),
    methods: () => ({[dartx.getTranslatedShaderSource]: dart.definiteFunctionType(core.String, [web_gl.Shader])})
  });
  dart.registerExtension(dart.global.WebGLDebugShaders, web_gl.DebugShaders);
  web_gl.DepthTexture = class DepthTexture extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(web_gl.DepthTexture, {
    constructors: () => ({_: dart.definiteFunctionType(web_gl.DepthTexture, [])})
  });
  web_gl.DepthTexture.UNSIGNED_INT_24_8_WEBGL = 34042;
  dart.registerExtension(dart.global.WebGLDepthTexture, web_gl.DepthTexture);
  dart.defineExtensionNames([
    'drawBuffersWebgl'
  ]);
  web_gl.DrawBuffers = class DrawBuffers extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [dartx.drawBuffersWebgl](buffers) {
      return this.drawBuffersWEBGL(buffers);
    }
  };
  dart.setSignature(web_gl.DrawBuffers, {
    constructors: () => ({_: dart.definiteFunctionType(web_gl.DrawBuffers, [])}),
    methods: () => ({[dartx.drawBuffersWebgl]: dart.definiteFunctionType(dart.void, [core.List$(core.int)])})
  });
  web_gl.DrawBuffers.COLOR_ATTACHMENT0_WEBGL = 36064;
  web_gl.DrawBuffers.COLOR_ATTACHMENT10_WEBGL = 36074;
  web_gl.DrawBuffers.COLOR_ATTACHMENT11_WEBGL = 36075;
  web_gl.DrawBuffers.COLOR_ATTACHMENT12_WEBGL = 36076;
  web_gl.DrawBuffers.COLOR_ATTACHMENT13_WEBGL = 36077;
  web_gl.DrawBuffers.COLOR_ATTACHMENT14_WEBGL = 36078;
  web_gl.DrawBuffers.COLOR_ATTACHMENT15_WEBGL = 36079;
  web_gl.DrawBuffers.COLOR_ATTACHMENT1_WEBGL = 36065;
  web_gl.DrawBuffers.COLOR_ATTACHMENT2_WEBGL = 36066;
  web_gl.DrawBuffers.COLOR_ATTACHMENT3_WEBGL = 36067;
  web_gl.DrawBuffers.COLOR_ATTACHMENT4_WEBGL = 36068;
  web_gl.DrawBuffers.COLOR_ATTACHMENT5_WEBGL = 36069;
  web_gl.DrawBuffers.COLOR_ATTACHMENT6_WEBGL = 36070;
  web_gl.DrawBuffers.COLOR_ATTACHMENT7_WEBGL = 36071;
  web_gl.DrawBuffers.COLOR_ATTACHMENT8_WEBGL = 36072;
  web_gl.DrawBuffers.COLOR_ATTACHMENT9_WEBGL = 36073;
  web_gl.DrawBuffers.DRAW_BUFFER0_WEBGL = 34853;
  web_gl.DrawBuffers.DRAW_BUFFER10_WEBGL = 34863;
  web_gl.DrawBuffers.DRAW_BUFFER11_WEBGL = 34864;
  web_gl.DrawBuffers.DRAW_BUFFER12_WEBGL = 34865;
  web_gl.DrawBuffers.DRAW_BUFFER13_WEBGL = 34866;
  web_gl.DrawBuffers.DRAW_BUFFER14_WEBGL = 34867;
  web_gl.DrawBuffers.DRAW_BUFFER15_WEBGL = 34868;
  web_gl.DrawBuffers.DRAW_BUFFER1_WEBGL = 34854;
  web_gl.DrawBuffers.DRAW_BUFFER2_WEBGL = 34855;
  web_gl.DrawBuffers.DRAW_BUFFER3_WEBGL = 34856;
  web_gl.DrawBuffers.DRAW_BUFFER4_WEBGL = 34857;
  web_gl.DrawBuffers.DRAW_BUFFER5_WEBGL = 34858;
  web_gl.DrawBuffers.DRAW_BUFFER6_WEBGL = 34859;
  web_gl.DrawBuffers.DRAW_BUFFER7_WEBGL = 34860;
  web_gl.DrawBuffers.DRAW_BUFFER8_WEBGL = 34861;
  web_gl.DrawBuffers.DRAW_BUFFER9_WEBGL = 34862;
  web_gl.DrawBuffers.MAX_COLOR_ATTACHMENTS_WEBGL = 36063;
  web_gl.DrawBuffers.MAX_DRAW_BUFFERS_WEBGL = 34852;
  dart.registerExtension(dart.global.WebGLDrawBuffers, web_gl.DrawBuffers);
  web_gl.ExtBlendMinMax = class ExtBlendMinMax extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(web_gl.ExtBlendMinMax, {
    constructors: () => ({_: dart.definiteFunctionType(web_gl.ExtBlendMinMax, [])})
  });
  web_gl.ExtBlendMinMax.MAX_EXT = 32776;
  web_gl.ExtBlendMinMax.MIN_EXT = 32775;
  dart.registerExtension(dart.global.EXTBlendMinMax, web_gl.ExtBlendMinMax);
  web_gl.ExtFragDepth = class ExtFragDepth extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(web_gl.ExtFragDepth, {
    constructors: () => ({_: dart.definiteFunctionType(web_gl.ExtFragDepth, [])})
  });
  dart.registerExtension(dart.global.EXTFragDepth, web_gl.ExtFragDepth);
  web_gl.ExtShaderTextureLod = class ExtShaderTextureLod extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(web_gl.ExtShaderTextureLod, {
    constructors: () => ({_: dart.definiteFunctionType(web_gl.ExtShaderTextureLod, [])})
  });
  dart.registerExtension(dart.global.EXTShaderTextureLOD, web_gl.ExtShaderTextureLod);
  web_gl.ExtTextureFilterAnisotropic = class ExtTextureFilterAnisotropic extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(web_gl.ExtTextureFilterAnisotropic, {
    constructors: () => ({_: dart.definiteFunctionType(web_gl.ExtTextureFilterAnisotropic, [])})
  });
  web_gl.ExtTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT = 34047;
  web_gl.ExtTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT = 34046;
  dart.registerExtension(dart.global.EXTTextureFilterAnisotropic, web_gl.ExtTextureFilterAnisotropic);
  web_gl.Framebuffer = class Framebuffer extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(web_gl.Framebuffer, {
    constructors: () => ({_: dart.definiteFunctionType(web_gl.Framebuffer, [])})
  });
  dart.registerExtension(dart.global.WebGLFramebuffer, web_gl.Framebuffer);
  dart.defineExtensionNames([
    'loseContext',
    'restoreContext'
  ]);
  web_gl.LoseContext = class LoseContext extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [dartx.loseContext]() {
      return this.loseContext();
    }
    [dartx.restoreContext]() {
      return this.restoreContext();
    }
  };
  dart.setSignature(web_gl.LoseContext, {
    constructors: () => ({_: dart.definiteFunctionType(web_gl.LoseContext, [])}),
    methods: () => ({
      [dartx.loseContext]: dart.definiteFunctionType(dart.void, []),
      [dartx.restoreContext]: dart.definiteFunctionType(dart.void, [])
    })
  });
  dart.registerExtension(dart.global.WebGLLoseContext, web_gl.LoseContext);
  web_gl.OesElementIndexUint = class OesElementIndexUint extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(web_gl.OesElementIndexUint, {
    constructors: () => ({_: dart.definiteFunctionType(web_gl.OesElementIndexUint, [])})
  });
  dart.registerExtension(dart.global.OESElementIndexUint, web_gl.OesElementIndexUint);
  web_gl.OesStandardDerivatives = class OesStandardDerivatives extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(web_gl.OesStandardDerivatives, {
    constructors: () => ({_: dart.definiteFunctionType(web_gl.OesStandardDerivatives, [])})
  });
  web_gl.OesStandardDerivatives.FRAGMENT_SHADER_DERIVATIVE_HINT_OES = 35723;
  dart.registerExtension(dart.global.OESStandardDerivatives, web_gl.OesStandardDerivatives);
  web_gl.OesTextureFloat = class OesTextureFloat extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(web_gl.OesTextureFloat, {
    constructors: () => ({_: dart.definiteFunctionType(web_gl.OesTextureFloat, [])})
  });
  dart.registerExtension(dart.global.OESTextureFloat, web_gl.OesTextureFloat);
  web_gl.OesTextureFloatLinear = class OesTextureFloatLinear extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(web_gl.OesTextureFloatLinear, {
    constructors: () => ({_: dart.definiteFunctionType(web_gl.OesTextureFloatLinear, [])})
  });
  dart.registerExtension(dart.global.OESTextureFloatLinear, web_gl.OesTextureFloatLinear);
  web_gl.OesTextureHalfFloatLinear = class OesTextureHalfFloatLinear extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(web_gl.OesTextureHalfFloatLinear, {
    constructors: () => ({_: dart.definiteFunctionType(web_gl.OesTextureHalfFloatLinear, [])})
  });
  dart.registerExtension(dart.global.OESTextureHalfFloatLinear, web_gl.OesTextureHalfFloatLinear);
  dart.defineExtensionNames([
    'bindVertexArray',
    'createVertexArray',
    'deleteVertexArray',
    'isVertexArray'
  ]);
  web_gl.OesVertexArrayObject = class OesVertexArrayObject extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [dartx.bindVertexArray](arrayObject) {
      return this.bindVertexArrayOES(arrayObject);
    }
    [dartx.createVertexArray]() {
      return this.createVertexArrayOES();
    }
    [dartx.deleteVertexArray](arrayObject) {
      return this.deleteVertexArrayOES(arrayObject);
    }
    [dartx.isVertexArray](arrayObject) {
      return this.isVertexArrayOES(arrayObject);
    }
  };
  dart.setSignature(web_gl.OesVertexArrayObject, {
    constructors: () => ({_: dart.definiteFunctionType(web_gl.OesVertexArrayObject, [])}),
    methods: () => ({
      [dartx.bindVertexArray]: dart.definiteFunctionType(dart.void, [web_gl.VertexArrayObject]),
      [dartx.createVertexArray]: dart.definiteFunctionType(web_gl.VertexArrayObject, []),
      [dartx.deleteVertexArray]: dart.definiteFunctionType(dart.void, [web_gl.VertexArrayObject]),
      [dartx.isVertexArray]: dart.definiteFunctionType(core.bool, [web_gl.VertexArrayObject])
    })
  });
  web_gl.OesVertexArrayObject.VERTEX_ARRAY_BINDING_OES = 34229;
  dart.registerExtension(dart.global.OESVertexArrayObject, web_gl.OesVertexArrayObject);
  web_gl.Program = class Program extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(web_gl.Program, {
    constructors: () => ({_: dart.definiteFunctionType(web_gl.Program, [])})
  });
  dart.registerExtension(dart.global.WebGLProgram, web_gl.Program);
  web_gl.Renderbuffer = class Renderbuffer extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(web_gl.Renderbuffer, {
    constructors: () => ({_: dart.definiteFunctionType(web_gl.Renderbuffer, [])})
  });
  dart.registerExtension(dart.global.WebGLRenderbuffer, web_gl.Renderbuffer);
  web_gl.Shader = class Shader extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(web_gl.Shader, {
    constructors: () => ({_: dart.definiteFunctionType(web_gl.Shader, [])})
  });
  dart.registerExtension(dart.global.WebGLShader, web_gl.Shader);
  dart.defineExtensionNames([
    'precision',
    'rangeMax',
    'rangeMin'
  ]);
  web_gl.ShaderPrecisionFormat = class ShaderPrecisionFormat extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.precision]() {
      return this.precision;
    }
    get [dartx.rangeMax]() {
      return this.rangeMax;
    }
    get [dartx.rangeMin]() {
      return this.rangeMin;
    }
  };
  dart.setSignature(web_gl.ShaderPrecisionFormat, {
    constructors: () => ({_: dart.definiteFunctionType(web_gl.ShaderPrecisionFormat, [])})
  });
  dart.registerExtension(dart.global.WebGLShaderPrecisionFormat, web_gl.ShaderPrecisionFormat);
  web_gl.Texture = class Texture extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(web_gl.Texture, {
    constructors: () => ({_: dart.definiteFunctionType(web_gl.Texture, [])})
  });
  dart.registerExtension(dart.global.WebGLTexture, web_gl.Texture);
  web_gl.UniformLocation = class UniformLocation extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(web_gl.UniformLocation, {
    constructors: () => ({_: dart.definiteFunctionType(web_gl.UniformLocation, [])})
  });
  dart.registerExtension(dart.global.WebGLUniformLocation, web_gl.UniformLocation);
  web_gl.VertexArrayObject = class VertexArrayObject extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(web_gl.VertexArrayObject, {
    constructors: () => ({_: dart.definiteFunctionType(web_gl.VertexArrayObject, [])})
  });
  dart.registerExtension(dart.global.WebGLVertexArrayObjectOES, web_gl.VertexArrayObject);
  web_gl._WebGLRenderingContextBase = class _WebGLRenderingContextBase extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(web_gl._WebGLRenderingContextBase, {
    constructors: () => ({_: dart.definiteFunctionType(web_gl._WebGLRenderingContextBase, [])})
  });
  web_sql.SqlStatementCallback = dart.typedef('SqlStatementCallback', () => dart.functionType(dart.void, [web_sql.SqlTransaction, web_sql.SqlResultSet]));
  web_sql.SqlStatementErrorCallback = dart.typedef('SqlStatementErrorCallback', () => dart.functionType(dart.void, [web_sql.SqlTransaction, web_sql.SqlError]));
  web_sql.SqlTransactionCallback = dart.typedef('SqlTransactionCallback', () => dart.functionType(dart.void, [web_sql.SqlTransaction]));
  web_sql.SqlTransactionErrorCallback = dart.typedef('SqlTransactionErrorCallback', () => dart.functionType(dart.void, [web_sql.SqlError]));
  dart.defineExtensionNames([
    'changeVersion',
    'readTransaction',
    'transaction',
    'version'
  ]);
  web_sql.SqlDatabase = class SqlDatabase extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static get supported() {
      return !!window.openDatabase;
    }
    get [dartx.version]() {
      return this.version;
    }
    [dartx.changeVersion](oldVersion, newVersion, callback, errorCallback, successCallback) {
      return this.changeVersion(oldVersion, newVersion, callback, errorCallback, successCallback);
    }
    [dartx.readTransaction](callback, errorCallback, successCallback) {
      return this.readTransaction(callback, errorCallback, successCallback);
    }
    [dartx.transaction](callback, errorCallback, successCallback) {
      return this.transaction(callback, errorCallback, successCallback);
    }
  };
  dart.setSignature(web_sql.SqlDatabase, {
    constructors: () => ({_: dart.definiteFunctionType(web_sql.SqlDatabase, [])}),
    methods: () => ({
      [dartx.changeVersion]: dart.definiteFunctionType(dart.void, [core.String, core.String], [web_sql.SqlTransactionCallback, web_sql.SqlTransactionErrorCallback, html$.VoidCallback]),
      [dartx.readTransaction]: dart.definiteFunctionType(dart.void, [web_sql.SqlTransactionCallback], [web_sql.SqlTransactionErrorCallback, html$.VoidCallback]),
      [dartx.transaction]: dart.definiteFunctionType(dart.void, [web_sql.SqlTransactionCallback], [web_sql.SqlTransactionErrorCallback, html$.VoidCallback])
    })
  });
  dart.registerExtension(dart.global.Database, web_sql.SqlDatabase);
  dart.defineExtensionNames([
    'code',
    'message'
  ]);
  web_sql.SqlError = class SqlError extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.code]() {
      return this.code;
    }
    get [dartx.message]() {
      return this.message;
    }
  };
  dart.setSignature(web_sql.SqlError, {
    constructors: () => ({_: dart.definiteFunctionType(web_sql.SqlError, [])})
  });
  web_sql.SqlError.CONSTRAINT_ERR = 6;
  web_sql.SqlError.DATABASE_ERR = 1;
  web_sql.SqlError.QUOTA_ERR = 4;
  web_sql.SqlError.SYNTAX_ERR = 5;
  web_sql.SqlError.TIMEOUT_ERR = 7;
  web_sql.SqlError.TOO_LARGE_ERR = 3;
  web_sql.SqlError.UNKNOWN_ERR = 0;
  web_sql.SqlError.VERSION_ERR = 2;
  dart.registerExtension(dart.global.SQLError, web_sql.SqlError);
  dart.defineExtensionNames([
    'insertId',
    'rows',
    'rowsAffected'
  ]);
  web_sql.SqlResultSet = class SqlResultSet extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.insertId]() {
      return this.insertId;
    }
    get [dartx.rows]() {
      return this.rows;
    }
    get [dartx.rowsAffected]() {
      return this.rowsAffected;
    }
  };
  dart.setSignature(web_sql.SqlResultSet, {
    constructors: () => ({_: dart.definiteFunctionType(web_sql.SqlResultSet, [])})
  });
  dart.registerExtension(dart.global.SQLResultSet, web_sql.SqlResultSet);
  const _item_1 = Symbol('_item_1');
  dart.defineExtensionNames([
    'length',
    'get',
    'set',
    'length',
    'first',
    'last',
    'single',
    'elementAt',
    'item'
  ]);
  web_sql.SqlResultSetRowList = class SqlResultSetRowList extends dart.mixin(_interceptors.Interceptor, collection.ListMixin$(core.Map), html$.ImmutableListMixin$(core.Map)) {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.length]() {
      return this.length;
    }
    [dartx.get](index) {
      if (index >>> 0 !== index || index >= this[dartx.length]) dart.throw(core.RangeError.index(index, this));
      return this[dartx.item](index);
    }
    [dartx.set](index, value) {
      dart.throw(new core.UnsupportedError("Cannot assign element of immutable List."));
      return value;
    }
    set [dartx.length](value) {
      dart.throw(new core.UnsupportedError("Cannot resize immutable List."));
    }
    get [dartx.first]() {
      if (dart.notNull(this[dartx.length]) > 0) {
        return this[0];
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.last]() {
      let len = this[dartx.length];
      if (dart.notNull(len) > 0) {
        return this[dart.notNull(len) - 1];
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.single]() {
      let len = this[dartx.length];
      if (len == 1) {
        return this[0];
      }
      if (len == 0) dart.throw(new core.StateError("No elements"));
      dart.throw(new core.StateError("More than one element"));
    }
    [dartx.elementAt](index) {
      return this[dartx.get](index);
    }
    [dartx.item](index) {
      return html_common.convertNativeToDart_Dictionary(this[_item_1](index));
    }
    [_item_1](index) {
      return this.item(index);
    }
  };
  web_sql.SqlResultSetRowList[dart.implements] = () => [ListOfMap()];
  dart.setSignature(web_sql.SqlResultSetRowList, {
    constructors: () => ({_: dart.definiteFunctionType(web_sql.SqlResultSetRowList, [])}),
    methods: () => ({
      [dartx.get]: dart.definiteFunctionType(core.Map, [core.int]),
      [dartx.set]: dart.definiteFunctionType(dart.void, [core.int, core.Map]),
      [dartx.elementAt]: dart.definiteFunctionType(core.Map, [core.int]),
      [dartx.item]: dart.definiteFunctionType(core.Map, [core.int]),
      [_item_1]: dart.definiteFunctionType(dart.dynamic, [dart.dynamic])
    })
  });
  dart.registerExtension(dart.global.SQLResultSetRowList, web_sql.SqlResultSetRowList);
  dart.defineExtensionNames([
    'executeSql'
  ]);
  web_sql.SqlTransaction = class SqlTransaction extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [dartx.executeSql](sqlStatement, arguments$, callback, errorCallback) {
      return this.executeSql(sqlStatement, arguments$, callback, errorCallback);
    }
  };
  dart.setSignature(web_sql.SqlTransaction, {
    constructors: () => ({_: dart.definiteFunctionType(web_sql.SqlTransaction, [])}),
    methods: () => ({[dartx.executeSql]: dart.definiteFunctionType(dart.void, [core.String, core.List$(core.Object)], [web_sql.SqlStatementCallback, web_sql.SqlStatementErrorCallback])})
  });
  dart.registerExtension(dart.global.SQLTransaction, web_sql.SqlTransaction);
  // Exports:
  exports.dart = dart;
  exports.dartx = dartx;
  exports._debugger = _debugger;
  exports._foreign_helper = _foreign_helper;
  exports._interceptors = _interceptors;
  exports._internal = _internal;
  exports._isolate_helper = _isolate_helper;
  exports._js_embedded_names = _js_embedded_names;
  exports._js_helper = _js_helper;
  exports._js_mirrors = _js_mirrors;
  exports._js_primitives = _js_primitives;
  exports._metadata = _metadata;
  exports._native_typed_data = _native_typed_data;
  exports.async = async;
  exports.collection = collection;
  exports.convert = convert;
  exports.core = core;
  exports.isolate = isolate;
  exports.js = js;
  exports.math = math;
  exports.mirrors = mirrors;
  exports.typed_data = typed_data;
  exports.indexed_db = indexed_db;
  exports.html = html$;
  exports.html_common = html_common;
  exports.svg = svg$;
  exports.web_audio = web_audio;
  exports.web_gl = web_gl;
  exports.web_sql = web_sql;
});
