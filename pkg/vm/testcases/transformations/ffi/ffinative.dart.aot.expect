library #lib;
import self as self;
import "dart:core" as core;
import "dart:nativewrappers" as nat;
import "dart:ffi" as ffi;
import "dart:_internal" as _in;

import "dart:ffi";
import "dart:nativewrappers";

abstract class Classy extends core::Object {

  [@vm.inferred-return-type.metadata=int]
  [@vm.unboxing-info.metadata=(i)->i]
  @#C6
  @#C8
  external static method returnIntPtrStatic([@vm.inferred-arg-type.metadata=dart.core::_Smi (value: 222)] core::int x) → core::int;
}
class NativeClassy extends nat::NativeFieldWrapperClass1 {
  synthetic constructor •() → self::NativeClassy
    : super nat::NativeFieldWrapperClass1::•()
    ;

  [@vm.procedure-attributes.metadata=methodOrSetterCalledDynamically:false,getterCalledDynamically:false,hasThisUses:false,hasTearOffUses:false,methodOrSetterSelectorId:1,getterSelectorId:2]
  @#C11
  @#C14
  method goodHasReceiverPointer() → void
    return block {
      final nat::NativeFieldWrapperClass1 #t1 = this;
      final core::int #t2 = #C15;
      final void #t3 = self::NativeClassy::_goodHasReceiverPointer$Method$FfiNative([@vm.inferred-type.metadata=dart.ffi::Pointer] ffi::_fromAddress<ffi::Void>( block {
        synthesized core::int #pointerAddress = [@vm.inferred-type.metadata=int] nat::_getNativeField(#t1);
        if([@vm.direct-call.metadata=dart.core::_IntegerImplementation.==] [@vm.inferred-type.metadata=dart.core::bool (skip check)] #pointerAddress.{core::Object::==}(#C16){(core::Object) → core::bool})
          core::StateError::_throwNew(#C17);
        else
          ;
      } =>#pointerAddress), #t2);
      _in::reachabilityFence(#t1);
    } =>#t3;

  [@vm.procedure-attributes.metadata=methodOrSetterCalledDynamically:false,getterCalledDynamically:false,hasThisUses:false,hasTearOffUses:false,methodOrSetterSelectorId:3,getterSelectorId:4]
  @#C19
  @#C14
  method goodHasReceiverHandle() → void
    return self::NativeClassy::_goodHasReceiverHandle$Method$FfiNative(this, #C15);

  [@vm.procedure-attributes.metadata=methodOrSetterCalledDynamically:false,getterCalledDynamically:false,hasThisUses:false,hasTearOffUses:false,methodOrSetterSelectorId:5,getterSelectorId:6]
  @#C21
  @#C14
  method goodHasReceiverHandleAndPtr([@vm.inferred-arg-type.metadata=#lib::NativeClassy] self::NativeClassy v) → void
    return block {
      final self::NativeClassy #t4 = this;
      final nat::NativeFieldWrapperClass1 #t5 = v;
      final void #t6 = self::NativeClassy::_goodHasReceiverHandleAndPtr$Method$FfiNative(#t4, [@vm.inferred-type.metadata=dart.ffi::Pointer] ffi::_fromAddress<ffi::Void>([@vm.inferred-type.metadata=int] nat::_getNativeField(#t5)));
      _in::reachabilityFence(#t5);
    } =>#t6;

  [@vm.procedure-attributes.metadata=methodOrSetterCalledDynamically:false,getterCalledDynamically:false,hasThisUses:false,hasTearOffUses:false,methodOrSetterSelectorId:7,getterSelectorId:8]
  @#C23
  @#C14
  method goodHasReceiverHandleAndHandle([@vm.inferred-arg-type.metadata=#lib::NativeClassy] self::NativeClassy v) → void
    return self::NativeClassy::_goodHasReceiverHandleAndHandle$Method$FfiNative(this, v);

  [@vm.procedure-attributes.metadata=methodOrSetterCalledDynamically:false,getterCalledDynamically:false,hasThisUses:false,hasTearOffUses:false,methodOrSetterSelectorId:9,getterSelectorId:10]
  @#C25
  @#C14
  method goodHasReceiverPtrAndHandle([@vm.inferred-arg-type.metadata=#lib::NativeClassy] self::NativeClassy v) → void
    return block {
      final nat::NativeFieldWrapperClass1 #t7 = this;
      final self::NativeClassy #t8 = v;
      final void #t9 = self::NativeClassy::_goodHasReceiverPtrAndHandle$Method$FfiNative([@vm.inferred-type.metadata=dart.ffi::Pointer] ffi::_fromAddress<ffi::Void>( block {
        synthesized core::int #pointerAddress = [@vm.inferred-type.metadata=int] nat::_getNativeField(#t7);
        if([@vm.direct-call.metadata=dart.core::_IntegerImplementation.==] [@vm.inferred-type.metadata=dart.core::bool (skip check)] #pointerAddress.{core::Object::==}(#C16){(core::Object) → core::bool})
          core::StateError::_throwNew(#C17);
        else
          ;
      } =>#pointerAddress), #t8);
      _in::reachabilityFence(#t7);
    } =>#t9;

  [@vm.procedure-attributes.metadata=methodOrSetterCalledDynamically:false,getterCalledDynamically:false,hasThisUses:false,hasTearOffUses:false,methodOrSetterSelectorId:11,getterSelectorId:12]
  @#C27
  @#C14
  method meh() → core::String?
    return block {
      final nat::NativeFieldWrapperClass1 #t10 = this;
      final core::bool #t11 = #C28;
      final core::String? #t12 = _in::unsafeCast<core::String?>(self::NativeClassy::_meh$Method$FfiNative([@vm.inferred-type.metadata=dart.ffi::Pointer] ffi::_fromAddress<ffi::Void>( block {
        synthesized core::int #pointerAddress = [@vm.inferred-type.metadata=int] nat::_getNativeField(#t10);
        if([@vm.direct-call.metadata=dart.core::_IntegerImplementation.==] [@vm.inferred-type.metadata=dart.core::bool (skip check)] #pointerAddress.{core::Object::==}(#C16){(core::Object) → core::bool})
          core::StateError::_throwNew(#C17);
        else
          ;
      } =>#pointerAddress), #t11));
      _in::reachabilityFence(#t10);
    } =>#t12;

  [@vm.inferred-return-type.metadata=dart.core::bool]
  [@vm.procedure-attributes.metadata=methodOrSetterCalledDynamically:false,getterCalledDynamically:false,hasThisUses:false,hasTearOffUses:false,methodOrSetterSelectorId:13,getterSelectorId:14]
  @#C30
  @#C14
  method blah() → core::bool
    return block {
      final nat::NativeFieldWrapperClass1 #t13 = this;
      final core::bool #t14 = [@vm.inferred-type.metadata=dart.core::bool] self::NativeClassy::_blah$Method$FfiNative([@vm.inferred-type.metadata=dart.ffi::Pointer] ffi::_fromAddress<ffi::Void>( block {
        synthesized core::int #pointerAddress = [@vm.inferred-type.metadata=int] nat::_getNativeField(#t13);
        if([@vm.direct-call.metadata=dart.core::_IntegerImplementation.==] [@vm.inferred-type.metadata=dart.core::bool (skip check)] #pointerAddress.{core::Object::==}(#C16){(core::Object) → core::bool})
          core::StateError::_throwNew(#C17);
        else
          ;
      } =>#pointerAddress));
      _in::reachabilityFence(#t13);
    } =>#t14;

  [@vm.inferred-return-type.metadata=dart.core::bool]
  [@vm.procedure-attributes.metadata=methodOrSetterCalledDynamically:false,getterCalledDynamically:false,hasThisUses:false,hasNonThisUses:false,hasTearOffUses:false,methodOrSetterSelectorId:15,getterSelectorId:16]
  @#C32
  @#C14
  get myField() → core::bool
    return block {
      final nat::NativeFieldWrapperClass1 #t15 = this;
      final core::bool #t16 = [@vm.inferred-type.metadata=dart.core::bool] self::NativeClassy::_myField$Getter$FfiNative([@vm.inferred-type.metadata=dart.ffi::Pointer] ffi::_fromAddress<ffi::Void>( block {
        synthesized core::int #pointerAddress = [@vm.inferred-type.metadata=int] nat::_getNativeField(#t15);
        if([@vm.direct-call.metadata=dart.core::_IntegerImplementation.==] [@vm.inferred-type.metadata=dart.core::bool (skip check)] #pointerAddress.{core::Object::==}(#C16){(core::Object) → core::bool})
          core::StateError::_throwNew(#C17);
        else
          ;
      } =>#pointerAddress));
      _in::reachabilityFence(#t15);
    } =>#t16;

  [@vm.procedure-attributes.metadata=methodOrSetterCalledDynamically:false,getterCalledDynamically:false,hasThisUses:false,hasTearOffUses:false,methodOrSetterSelectorId:15,getterSelectorId:16]
  @#C34
  @#C14
  set myField([@vm.inferred-arg-type.metadata=dart.core::bool] core::bool value) → void
    return block {
      final nat::NativeFieldWrapperClass1 #t17 = this;
      final core::bool #t18 = value;
      final void #t19 = self::NativeClassy::_myField$Setter$FfiNative([@vm.inferred-type.metadata=dart.ffi::Pointer] ffi::_fromAddress<ffi::Void>( block {
        synthesized core::int #pointerAddress = [@vm.inferred-type.metadata=int] nat::_getNativeField(#t17);
        if([@vm.direct-call.metadata=dart.core::_IntegerImplementation.==] [@vm.inferred-type.metadata=dart.core::bool (skip check)] #pointerAddress.{core::Object::==}(#C16){(core::Object) → core::bool})
          core::StateError::_throwNew(#C17);
        else
          ;
      } =>#pointerAddress), #t18);
      _in::reachabilityFence(#t17);
    } =>#t19;

  [@vm.unboxing-info.metadata=(b,i)->b]
  @#C35
  external static method _goodHasReceiverPointer$Method$FfiNative([@vm.inferred-arg-type.metadata=dart.ffi::Pointer] ffi::Pointer<ffi::Void> #t0, [@vm.inferred-arg-type.metadata=dart.core::_Smi (value: 175)] core::int #t1) → void;

  [@vm.unboxing-info.metadata=(b,i)->b]
  @#C36
  external static method _goodHasReceiverHandle$Method$FfiNative([@vm.inferred-arg-type.metadata=#lib::NativeClassy] self::NativeClassy #t0, [@vm.inferred-arg-type.metadata=dart.core::_Smi (value: 175)] core::int #t1) → void;
  @#C37
  external static method _goodHasReceiverHandleAndPtr$Method$FfiNative([@vm.inferred-arg-type.metadata=#lib::NativeClassy] self::NativeClassy #t0, [@vm.inferred-arg-type.metadata=dart.ffi::Pointer] ffi::Pointer<ffi::Void> #t1) → void;
  @#C38
  external static method _goodHasReceiverHandleAndHandle$Method$FfiNative([@vm.inferred-arg-type.metadata=#lib::NativeClassy] self::NativeClassy #t0, [@vm.inferred-arg-type.metadata=#lib::NativeClassy] self::NativeClassy #t1) → void;
  @#C39
  external static method _goodHasReceiverPtrAndHandle$Method$FfiNative([@vm.inferred-arg-type.metadata=dart.ffi::Pointer] ffi::Pointer<ffi::Void> #t0, [@vm.inferred-arg-type.metadata=#lib::NativeClassy] self::NativeClassy #t1) → void;
  @#C40
  external static method _meh$Method$FfiNative([@vm.inferred-arg-type.metadata=dart.ffi::Pointer] ffi::Pointer<ffi::Void> #t0, [@vm.inferred-arg-type.metadata=dart.core::bool (value: true)] core::bool #t1) → core::Object?;

  [@vm.inferred-return-type.metadata=dart.core::bool]
  @#C41
  external static method _blah$Method$FfiNative([@vm.inferred-arg-type.metadata=dart.ffi::Pointer] ffi::Pointer<ffi::Void> #t0) → core::bool;

  [@vm.inferred-return-type.metadata=dart.core::bool]
  @#C42
  external static method _myField$Getter$FfiNative([@vm.inferred-arg-type.metadata=dart.ffi::Pointer] ffi::Pointer<ffi::Void> #t0) → core::bool;
  @#C43
  external static method _myField$Setter$FfiNative([@vm.inferred-arg-type.metadata=dart.ffi::Pointer] ffi::Pointer<ffi::Void> #t0, [@vm.inferred-arg-type.metadata=dart.core::bool] core::bool #t1) → void;
}

[@vm.inferred-return-type.metadata=int]
[@vm.unboxing-info.metadata=(i)->i]
@#C6
@#C8
external static method returnIntPtr([@vm.inferred-arg-type.metadata=dart.core::_Smi (value: 13)] core::int x) → core::int;

[@vm.inferred-return-type.metadata=int]
[@vm.unboxing-info.metadata=(i)->i]
@#C45
@#C46
external static method returnIntPtrLeaf([@vm.inferred-arg-type.metadata=dart.core::_Smi (value: 37)] core::int x) → core::int;

[@vm.inferred-return-type.metadata=dart.core::Null? (value: null)]
static method main() → void {
  self::returnIntPtr(13);
  self::returnIntPtrLeaf(37);
  self::Classy::returnIntPtrStatic(222);
  [@vm.direct-call.metadata=#lib::NativeClassy.goodHasReceiverPointer] [@vm.inferred-type.metadata=!? (skip check)] new self::NativeClassy::•().{self::NativeClassy::goodHasReceiverPointer}(){(core::int) → void};
  [@vm.direct-call.metadata=#lib::NativeClassy.goodHasReceiverHandle] [@vm.inferred-type.metadata=!? (skip check)] new self::NativeClassy::•().{self::NativeClassy::goodHasReceiverHandle}(){(core::int) → void};
  [@vm.direct-call.metadata=#lib::NativeClassy.goodHasReceiverHandleAndPtr] [@vm.inferred-type.metadata=!? (skip check)] new self::NativeClassy::•().{self::NativeClassy::goodHasReceiverHandleAndPtr}(new self::NativeClassy::•()){(self::NativeClassy) → void};
  [@vm.direct-call.metadata=#lib::NativeClassy.goodHasReceiverHandleAndHandle] [@vm.inferred-type.metadata=!? (skip check)] new self::NativeClassy::•().{self::NativeClassy::goodHasReceiverHandleAndHandle}(new self::NativeClassy::•()){(self::NativeClassy) → void};
  [@vm.direct-call.metadata=#lib::NativeClassy.goodHasReceiverPtrAndHandle] [@vm.inferred-type.metadata=!? (skip check)] new self::NativeClassy::•().{self::NativeClassy::goodHasReceiverPtrAndHandle}(new self::NativeClassy::•()){(self::NativeClassy) → void};
  [@vm.direct-call.metadata=#lib::NativeClassy.meh] [@vm.inferred-type.metadata=!? (skip check)] new self::NativeClassy::•().{self::NativeClassy::meh}(){(core::bool) → core::String?};
  [@vm.direct-call.metadata=#lib::NativeClassy.blah] [@vm.inferred-type.metadata=!? (skip check)] new self::NativeClassy::•().{self::NativeClassy::blah}(){() → core::bool};
  final core::bool b = [@vm.direct-call.metadata=#lib::NativeClassy.myField] [@vm.inferred-type.metadata=dart.core::bool] new self::NativeClassy::•().{self::NativeClassy::myField}{core::bool};
  [@vm.direct-call.metadata=#lib::NativeClassy.myField] [@vm.inferred-type.metadata=!? (skip check)] new self::NativeClassy::•().{self::NativeClassy::myField} = !b;
  ffi::Native::_addressOf<ffi::NativeFunction<(ffi::IntPtr) → ffi::IntPtr>>(#C5);
}
constants  {
  #C1 = "cfe:ffi:native-marker"
  #C2 = "ReturnIntPtr"
  #C3 = "#lib"
  #C4 = false
  #C5 = ffi::Native<(ffi::IntPtr) → ffi::IntPtr> {symbol:#C2, assetId:#C3, isLeaf:#C4}
  #C6 = core::pragma {name:#C1, options:#C5}
  #C7 = "vm:ffi:native"
  #C8 = core::pragma {name:#C7, options:#C5}
  #C9 = "doesntmatter"
  #C10 = ffi::Native<(ffi::Pointer<ffi::Void>, ffi::IntPtr) → ffi::Void> {symbol:#C9, assetId:#C3, isLeaf:#C4}
  #C11 = core::pragma {name:#C1, options:#C10}
  #C12 = "vm:prefer-inline"
  #C13 = null
  #C14 = core::pragma {name:#C12, options:#C13}
  #C15 = 175
  #C16 = 0
  #C17 = "A Dart object attempted to access a native peer, but the native peer has been collected (nullptr). This is usually the result of calling methods on a native-backed object when the native resources have already been disposed."
  #C18 = ffi::Native<(ffi::Handle, ffi::IntPtr) → ffi::Void> {symbol:#C9, assetId:#C3, isLeaf:#C4}
  #C19 = core::pragma {name:#C1, options:#C18}
  #C20 = ffi::Native<(ffi::Handle, ffi::Pointer<ffi::Void>) → ffi::Void> {symbol:#C9, assetId:#C3, isLeaf:#C4}
  #C21 = core::pragma {name:#C1, options:#C20}
  #C22 = ffi::Native<(ffi::Handle, ffi::Handle) → ffi::Void> {symbol:#C9, assetId:#C3, isLeaf:#C4}
  #C23 = core::pragma {name:#C1, options:#C22}
  #C24 = ffi::Native<(ffi::Pointer<ffi::Void>, ffi::Handle) → ffi::Void> {symbol:#C9, assetId:#C3, isLeaf:#C4}
  #C25 = core::pragma {name:#C1, options:#C24}
  #C26 = ffi::Native<(ffi::Pointer<ffi::Void>, ffi::Bool) → ffi::Handle> {symbol:#C9, assetId:#C3, isLeaf:#C4}
  #C27 = core::pragma {name:#C1, options:#C26}
  #C28 = true
  #C29 = ffi::Native<(ffi::Pointer<ffi::Void>) → ffi::Bool> {symbol:#C9, assetId:#C3, isLeaf:#C4}
  #C30 = core::pragma {name:#C1, options:#C29}
  #C31 = ffi::Native<(ffi::Pointer<ffi::Void>) → ffi::Bool> {symbol:#C9, assetId:#C3, isLeaf:#C28}
  #C32 = core::pragma {name:#C1, options:#C31}
  #C33 = ffi::Native<(ffi::Pointer<ffi::Void>, ffi::Bool) → ffi::Void> {symbol:#C9, assetId:#C3, isLeaf:#C28}
  #C34 = core::pragma {name:#C1, options:#C33}
  #C35 = core::pragma {name:#C7, options:#C10}
  #C36 = core::pragma {name:#C7, options:#C18}
  #C37 = core::pragma {name:#C7, options:#C20}
  #C38 = core::pragma {name:#C7, options:#C22}
  #C39 = core::pragma {name:#C7, options:#C24}
  #C40 = core::pragma {name:#C7, options:#C26}
  #C41 = core::pragma {name:#C7, options:#C29}
  #C42 = core::pragma {name:#C7, options:#C31}
  #C43 = core::pragma {name:#C7, options:#C33}
  #C44 = ffi::Native<(ffi::IntPtr) → ffi::IntPtr> {symbol:#C2, assetId:#C3, isLeaf:#C28}
  #C45 = core::pragma {name:#C1, options:#C44}
  #C46 = core::pragma {name:#C7, options:#C44}
}
