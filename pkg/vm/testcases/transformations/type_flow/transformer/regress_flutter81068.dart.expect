library #lib;
import self as self;
import "dart:core" as core;
import "dart:async" as asy;
import "dart:_internal" as _in;

import "dart:async";

abstract class A<T extends core::Object? = dynamic> extends core::Object {
  synthetic constructor •() → self::A<self::A::T%>
    : super core::Object::•()
    ;
}
class B<T extends core::Object? = dynamic> extends self::A<core::String> implements asy::Future<self::B::T%> {
  synthetic constructor •() → self::B<self::B::T%>
    : super self::A::•()
    ;
[@vm.procedure-attributes.metadata=methodOrSetterCalledDynamically:false,getterCalledDynamically:false,hasTearOffUses:false,methodOrSetterSelectorId:1,getterSelectorId:2]  method noSuchMethod(core::Invocation i) → dynamic
    return throw "Not implemented";
[@vm.procedure-attributes.metadata=methodOrSetterCalledDynamically:false,getterCalledDynamically:false,hasThisUses:false,hasTearOffUses:false,methodOrSetterSelectorId:3,getterSelectorId:4]  no-such-method-forwarder method then<R extends core::Object? = dynamic>((self::B::T%) → FutureOr<self::B::then::R%>onValue, {core::Function? onError = #C1}) → asy::Future<self::B::then::R%>
    return _in::unsafeCast<asy::Future<self::B::then::R%>>([@vm.direct-call.metadata=#lib::B.noSuchMethod] [@vm.inferred-type.metadata=! (skip check)] this.{self::B::noSuchMethod}(new core::_InvocationMirror::_withType(#C2, 0, [@vm.inferred-type.metadata=dart.core::_ImmutableList] core::List::unmodifiable<core::Type*>([@vm.inferred-type.metadata=dart.core::_GrowableList<dart.core::Type*>] core::_GrowableList::_literal1<core::Type*>(self::B::then::R%)), [@vm.inferred-type.metadata=dart.core::_ImmutableList] core::List::unmodifiable<dynamic>([@vm.inferred-type.metadata=dart.core::_GrowableList<dynamic>] core::_GrowableList::_literal1<dynamic>(onValue)), [@vm.inferred-type.metadata=dart.collection::UnmodifiableMapView<dart.core::Symbol*, dynamic>] core::Map::unmodifiable<core::Symbol*, dynamic>(<core::Symbol*, dynamic>{#C3: onError}))){(core::Invocation) → dynamic});
[@vm.procedure-attributes.metadata=methodOrSetterCalledDynamically:false,getterCalledDynamically:false,hasThisUses:false,hasTearOffUses:false,methodOrSetterSelectorId:5,getterSelectorId:6]  no-such-method-forwarder method catchError([@vm.inferred-type.metadata=dart.core::_Closure] core::Function onError) → asy::Future<self::B::T%>
    return _in::unsafeCast<asy::Future<self::B::T%>>([@vm.direct-call.metadata=#lib::B.noSuchMethod] [@vm.inferred-type.metadata=! (skip check)] this.{self::B::noSuchMethod}(new core::_InvocationMirror::_withType(#C4, 0, #C5, [@vm.inferred-type.metadata=dart.core::_ImmutableList] core::List::unmodifiable<dynamic>([@vm.inferred-type.metadata=dart.core::_GrowableList<dynamic>] core::_GrowableList::_literal1<dynamic>(onError)), [@vm.inferred-type.metadata=dart.collection::UnmodifiableMapView<dart.core::Symbol*, dynamic>] core::Map::unmodifiable<core::Symbol*, dynamic>(<core::Symbol*, dynamic>{#C6: #C1}))){(core::Invocation) → dynamic});
[@vm.procedure-attributes.metadata=methodOrSetterCalledDynamically:false,getterCalledDynamically:false,hasThisUses:false,hasTearOffUses:false,methodOrSetterSelectorId:7,getterSelectorId:8]  no-such-method-forwarder method whenComplete(() → FutureOr<void>action) → asy::Future<self::B::T%>
    return _in::unsafeCast<asy::Future<self::B::T%>>([@vm.direct-call.metadata=#lib::B.noSuchMethod] [@vm.inferred-type.metadata=! (skip check)] this.{self::B::noSuchMethod}(new core::_InvocationMirror::_withType(#C7, 0, #C5, [@vm.inferred-type.metadata=dart.core::_ImmutableList] core::List::unmodifiable<dynamic>([@vm.inferred-type.metadata=dart.core::_GrowableList<dynamic>] core::_GrowableList::_literal1<dynamic>(action)), [@vm.inferred-type.metadata=dart.collection::UnmodifiableMapView<dart.core::Symbol*, dynamic>] core::Map::unmodifiable<core::Symbol*, dynamic>(#C8))){(core::Invocation) → dynamic});
}
static method createB<T extends core::Object? = dynamic>() → self::B<dynamic>
  return new self::B::•<self::createB::T%>();
static method main() → void {
  core::print([@vm.inferred-type.metadata=#lib::B<?>] self::createB<core::int>() as FutureOr<core::double>);
}
constants  {
  #C1 = null
  #C2 = #then
  #C3 = #onError
  #C4 = #catchError
  #C5 = <core::Type*>[]
  #C6 = #test
  #C7 = #whenComplete
  #C8 = <core::Symbol*, dynamic>{}
}
