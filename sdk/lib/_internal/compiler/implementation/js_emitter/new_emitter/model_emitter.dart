// Copyright (c) 2014, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

library dart2js.new_js_emitter.model_emitter;

import '../../dart2jslib.dart' show Compiler;
import '../../js/js.dart' as js;
import '../../js_backend/js_backend.dart' show Namer, ConstantEmitter;
import '../../../js_lib/shared/embedded_names.dart' show
    DEFERRED_LIBRARY_URIS,
    DEFERRED_LIBRARY_HASHES,
    INITIALIZE_LOADED_HUNK,
    IS_HUNK_LOADED;

import '../model.dart';

class ModelEmitter {
  final Compiler compiler;
  final Namer namer;
  final ConstantEmitter constantEmitter;

  /// For deferred loading we communicate the initializers via this global var.
  static const String deferredInitializersGlobal =
      r"$__dart_deferred_initializers__";

  static const String deferredExtension = ".part.js";

  ModelEmitter(Compiler compiler, Namer namer)
      : this.compiler = compiler,
        this.namer = namer,
        constantEmitter = new ConstantEmitter(compiler, namer);

  void emitProgram(Program program) {
    List<Output> outputs = program.outputs;
    MainOutput mainUnit = outputs.first;
    js.Statement mainAst = emitMainUnit(mainUnit, program.loadMap);
    String mainCode = js.prettyPrint(mainAst, compiler).getText();
    compiler.outputProvider(mainUnit.outputFileName, 'js')
        ..add(buildGeneratedBy(compiler))
        ..add(mainCode)
        ..close();
    compiler.assembledCode = mainCode;

    outputs.skip(1).forEach((DeferredOutput deferredUnit) {
      js.Expression ast = emitDeferredUnit(deferredUnit, mainUnit.holders);
      String code = js.prettyPrint(ast, compiler).getText();
      compiler.outputProvider(deferredUnit.outputFileName, deferredExtension)
          ..add(code)
          ..close();
    });
  }

  js.LiteralString unparse(Compiler compiler, js.Expression value) {
    String text = js.prettyPrint(value, compiler).getText();
    if (value is js.Fun) text = '($text)';
    return js.js.escapedString(text);
  }

  String buildGeneratedBy(compiler) {
    var suffix = '';
    if (compiler.hasBuildId) suffix = ' version: ${compiler.buildId}';
    return '// Generated by dart2js, the Dart to JavaScript compiler$suffix.\n';
  }

  js.Statement emitMainUnit(MainOutput unit,
                            Map<String, List<Output>> loadMap) {
    js.Expression program =
        new js.ArrayInitializer.from(unit.libraries.map(emitLibrary));
    return js.js.statement(
        boilerplate,
        [emitDeferredInitializerGlobal(loadMap),
         emitHolders(unit.holders),
         emitEmbeddedGlobals(loadMap),
         emitConstants(unit.constants),
         unit.main,
         program]);
  }

  js.Block emitHolders(List<Holder> holders) {
    // The top-level variables for holders must *not* be renamed by the
    // JavaScript pretty printer because a lot of code already uses the
    // non-renamed names. The generated code looks like this:
    //
    //    var H = {}, ..., G = {};
    //    var holders = [ H, ..., G ];
    //
    // and it is inserted at the top of the top-level function expression
    // that covers the entire program.

    List<js.Statement> statements = [
        new js.ExpressionStatement(
            new js.VariableDeclarationList(holders.map((e) =>
                new js.VariableInitialization(
                    new js.VariableDeclaration(e.name, allowRename: false),
                    new js.ObjectInitializer(const []))).toList())),
        js.js.statement('var holders = #', new js.ArrayInitializer.from(
            holders.map((e) => new js.VariableUse(e.name))))
    ];
    return new js.Block(statements);
  }

  js.Block emitEmbeddedGlobals(Map<String, List<Output>> loadMap) {
    List<js.Property> globals = <js.Property>[];

    if (loadMap.isNotEmpty) {
      globals.addAll(emitLoadUrisAndHashes(loadMap));
      globals.add(emitIsHunkLoadedFunction());
      globals.add(emitInitializeLoadedHunk());
    }

    if (globals.isEmpty) return new js.Block.empty();

    js.ObjectInitializer globalsObject = new js.ObjectInitializer(globals);

    List<js.Statement> statements =
        [new js.ExpressionStatement(
            new js.VariableDeclarationList(
                [new js.VariableInitialization(
                    new js.VariableDeclaration(r"init", allowRename: false),
                    globalsObject)]))];
    return new js.Block(statements);
  }

  List<js.Property> emitLoadUrisAndHashes(Map<String, List<Output>> loadMap) {
    js.ArrayInitializer outputUris(List<Output> outputs) {
      return js.stringArray(outputs.map((DeferredOutput output) =>
          "${output.outputFileName}$deferredExtension"));
    }
    js.ArrayInitializer outputHashes(List<Output> outputs) {
      // TODO(floitsch): the hash must depend on the generated code.
      return js.numArray(
          outputs.map((DeferredOutput output) => output.hashCode));
    }

    List<js.Property> uris = new List<js.Property>(loadMap.length);
    List<js.Property> hashes = new List<js.Property>(loadMap.length);
    int count = 0;
    loadMap.forEach((String loadId, List<Output> outputList) {
      uris[count] = new js.Property(js.string(loadId), outputUris(outputList));
      hashes[count] =
          new js.Property(js.string(loadId), outputHashes(outputList));
      count++;
    });

    return <js.Property>[
         new js.Property(js.string(DEFERRED_LIBRARY_URIS),
                         new js.ObjectInitializer(uris)),
         new js.Property(js.string(DEFERRED_LIBRARY_HASHES),
                         new js.ObjectInitializer(hashes))
         ];
  }

  js.Statement emitDeferredInitializerGlobal(Map loadMap) {
    if (loadMap.isEmpty) return new js.Block.empty();

    return js.js.statement("""
  if (typeof($deferredInitializersGlobal) === 'undefined')
    var $deferredInitializersGlobal = Object.create(null);""");
  }

  js.Property emitIsHunkLoadedFunction() {
    js.Expression function =
        js.js("function(hash) { return !!$deferredInitializersGlobal[hash]; }");
    return new js.Property(js.string(IS_HUNK_LOADED), function);
  }

  js.Property emitInitializeLoadedHunk() {
    js.Expression function =
        js.js("function(hash) { eval($deferredInitializersGlobal[hash]); }");
    return new js.Property(js.string(INITIALIZE_LOADED_HUNK), function);
  }

  js.Expression emitDeferredUnit(DeferredOutput unit, List<Holder> holders) {
    // TODO(floitsch): the hash must depend on the output.
    int hash = this.hashCode;
    if (unit.constants.isNotEmpty) {
      throw new UnimplementedError("constants in deferred units");
    }
    js.ArrayInitializer content =
        new js.ArrayInitializer.from(unit.libraries.map(emitLibrary));
    return js.js("$deferredInitializersGlobal[$hash] = #", content);
  }

  js.Block emitConstants(List<Constant> constants) {
    Iterable<js.Statement> statements = constants.map((Constant constant) {
      js.Expression code =
          constantEmitter.initializationExpression(constant.value);
      return js.js.statement("#.# = #;",
                             [constant.holder.name, constant.name, code]);
    });
    return new js.Block(statements.toList());
  }

  js.Expression emitLibrary(Library library) {
    Iterable staticDescriptors = library.statics.expand((e) =>
        [ js.string(e.name), js.number(e.holder.index), emitStaticMethod(e) ]);
    Iterable classDescriptors = library.classes.expand((e) =>
        [ js.string(e.name), js.number(e.holder.index), emitClass(e) ]);

    js.Expression staticArray = new js.ArrayInitializer.from(staticDescriptors);
    js.Expression classArray = new js.ArrayInitializer.from(classDescriptors);

    return new js.ArrayInitializer.from([staticArray, classArray]);
  }

  js.Expression emitClass(Class cls) {
    List elements = [ js.string(cls.superclassName),
                      js.number(cls.superclassHolderIndex) ];
    elements.addAll(cls.methods.expand((e) => [ js.string(e.name), e.code ]));
    return unparse(compiler, new js.ArrayInitializer.from(elements));
  }

  js.Expression emitStaticMethod(StaticMethod method) {
    return unparse(compiler, method.code);
  }
}

final String boilerplate = r"""
{
// Declare deferred-initializer global.
#;

!function(start, program) {

  // Initialize holder objects.
  #;

  function setupProgram() {
    for (var i = 0; i < program.length; i++) {
      setupLibrary(program[i]);
    }
  }

  function setupLibrary(library) {
    var statics = library[0];
    for (var i = 0; i < statics.length; i += 3) {
      var holderIndex = statics[i + 1];
      setupStatic(statics[i], holders[holderIndex], statics[i + 2]);
    }

    var classes = library[1];
    for (var i = 0; i < classes.length; i += 3) {
      var holderIndex = classes[i + 1];
      setupClass(classes[i], holders[holderIndex], classes[i + 2]);
    }
  }

  function setupStatic(name, holder, descriptor) {
    holder[name] = function() {
      var method = compile(name, descriptor);
      holder[name] = method;
      return method.apply(this, arguments);
    };
  }

  function setupClass(name, holder, descriptor) {
    var resolve = function() {
      var constructor = compileConstructor(name, descriptor);
      holder[name] = constructor;
      return constructor;
    };

    var patch = function() {
      var constructor = resolve();
      var object = new constructor();
      constructor.apply(object, arguments);
      return object;
    };

    // We store the resolve function on the patch function to make it possible
    // to resolve superclass references without constructing instances. The
    // resolve property also serves as a marker that indicates whether or not
    // a class has been resolved yet.
    patch.resolve = resolve;
    holder[name] = patch;
  }

  function compileConstructor(name, descriptor) {
    descriptor = compile(name, descriptor);
    var prototype = determinePrototype(descriptor);
    for (var i = 2; i < descriptor.length; i += 2) {
      prototype[descriptor[i]] = descriptor[i + 1];
    }
    var result = function() { };  // TODO(kasperl): Compile.
    result.prototype = prototype;
    return result;
  }

  function determinePrototype(descriptor) {
    var superclassName = descriptor[0];
    if (!superclassName) return { };

    // Look up the superclass constructor function in the right holder.
    var holderIndex = descriptor[1];
    var superclass = holders[holderIndex][superclassName];
    if (superclass.resolve) superclass = superclass.resolve();

    // Create a new prototype object chained to the superclass prototype.
    var intermediate = function() { };
    intermediate.prototype = superclass.prototype;
    return new intermediate();
  }

  function compile(__name__, __s__) {
    'use strict';
    // TODO(floitsch): evaluate the performance impact of the string
    // concatenations.
    return eval(__s__ + "\n//# sourceURL=" + __name__ + ".js");
  }

  setupProgram();

  // Initialize globals.
  #;

  // Initialize constants.
  #;

  var end = Date.now();
  print('Setup: ' + (end - start) + ' ms.');

  if (true) #();  // Start main.

}(Date.now(), #)
}""";
