library pub.lock_file;
import 'package:path/path.dart' as p;
import 'package:pub_semver/pub_semver.dart';
import 'package:source_span/source_span.dart';
import 'package:yaml/yaml.dart';
import 'io.dart';
import 'package.dart';
import 'source_registry.dart';
import 'utils.dart';
class LockFile {
  Map<String, PackageId> packages;
  factory LockFile(List<PackageId> ids) {
    var lockFile = new LockFile.empty();
    for (var id in ids) {
      if (!id.isRoot) lockFile.packages[id.name] = id;
    }
    return lockFile;
  }
  LockFile._(this.packages);
  LockFile.empty() : packages = <String, PackageId>{};
  factory LockFile.load(String filePath, SourceRegistry sources) {
    return LockFile._parse(filePath, readTextFile(filePath), sources);
  }
  factory LockFile.parse(String contents, SourceRegistry sources) {
    return LockFile._parse(null, contents, sources);
  }
  static LockFile _parse(String filePath, String contents,
      SourceRegistry sources) {
    var packages = <String, PackageId>{};
    if (contents.trim() == '') return new LockFile.empty();
    var sourceUrl;
    if (filePath != null) sourceUrl = p.toUri(filePath);
    var parsed = loadYamlNode(contents, sourceUrl: sourceUrl);
    _validate(parsed is Map, 'The lockfile must be a YAML mapping.', parsed);
    var packageEntries = parsed['packages'];
    if (packageEntries != null) {
      _validate(
          packageEntries is Map,
          'The "packages" field must be a map.',
          parsed.nodes['packages']);
      packageEntries.forEach((name, spec) {
        _validate(
            spec.containsKey('version'),
            'Package $name is missing a version.',
            spec);
        var version = new Version.parse(spec['version']);
        _validate(
            spec.containsKey('source'),
            'Package $name is missing a source.',
            spec);
        var sourceName = spec['source'];
        _validate(
            spec.containsKey('description'),
            'Package $name is missing a description.',
            spec);
        var description = spec['description'];
        var source = sources[sourceName];
        try {
          description =
              source.parseDescription(filePath, description, fromLockFile: true);
        } on FormatException catch (ex) {
          throw new SourceSpanFormatException(
              ex.message,
              spec.nodes['source'].span);
        }
        var id = new PackageId(name, sourceName, version, description);
        _validate(
            name == id.name,
            "Package name $name doesn't match ${id.name}.",
            spec);
        packages[name] = id;
      });
    }
    return new LockFile._(packages);
  }
  static void _validate(bool condition, String message, YamlNode node) {
    if (condition) return;
    throw new SourceSpanFormatException(message, node.span);
  }
  String serialize(String packageDir, SourceRegistry sources) {
    var data = {};
    packages.forEach((name, package) {
      var description =
          sources[package.source].serializeDescription(packageDir, package.description);
      data[name] = {
        'version': package.version.toString(),
        'source': package.source,
        'description': description
      };
    });
    return """
# Generated by pub
# See http://pub.dartlang.org/doc/glossary.html#lockfile
${yamlToString({'packages' : data})}
""";
  }
}
