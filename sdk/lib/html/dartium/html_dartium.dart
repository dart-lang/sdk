library html;

import 'dart:async';
import 'dart:collection';
import 'dart:collection-dev';
import 'dart:html_common';
import 'dart:indexed_db';
import 'dart:isolate';
import 'dart:json' as json;
import 'dart:nativewrappers';
import 'dart:svg' as svg;
import 'dart:web_audio' as web_audio;
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// DO NOT EDIT
// Auto-generated dart:html library.


// Not actually used, but imported since dart:html can generate these objects.





Window _window;

Window get window {
  if (_window != null) {
    return _window;
  }
  _window = _Utils.window();
  return _window;
}

HtmlDocument _document;

HtmlDocument get document {
  if (_document != null) {
    return _document;
  }
  _document = window.document;
  return _document;
}


Element query(String selector) => document.query(selector);
List<Element> queryAll(String selector) => document.queryAll(selector);

int _getNewIsolateId() => _Utils._getNewIsolateId();

bool _callPortInitialized = false;
var _callPortLastResult = null;

_callPortSync(num id, var message) {
  if (!_callPortInitialized) {
    window.on['js-result'].add((event) {
      _callPortLastResult = json.parse(_getPortSyncEventData(event));
    }, false);
    _callPortInitialized = true;
  }
  assert(_callPortLastResult == null);
  _dispatchEvent('js-sync-message', {'id': id, 'message': message});
  var result = _callPortLastResult;
  _callPortLastResult = null;
  return result;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('AbstractWorker')
class AbstractWorker extends EventTarget {
  AbstractWorker.internal() : super.internal();

  @DomName('AbstractWorker.error')
  @DocsEditable
  static const EventStreamProvider<Event> errorEvent = const EventStreamProvider<Event>('error');

  @DocsEditable
  @DomName('EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent')
  @deprecated
  AbstractWorkerEvents get on =>
    new AbstractWorkerEvents(this);

  @DomName('AbstractWorker.addEventListener')
  @DocsEditable
  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]) native "AbstractWorker_addEventListener_Callback";

  @DomName('AbstractWorker.dispatchEvent')
  @DocsEditable
  bool dispatchEvent(Event evt) native "AbstractWorker_dispatchEvent_Callback";

  @DomName('AbstractWorker.removeEventListener')
  @DocsEditable
  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]) native "AbstractWorker_removeEventListener_Callback";

  @DomName('AbstractWorker.error')
  @DocsEditable
  Stream<Event> get onError => errorEvent.forTarget(this);

}

@DocsEditable
@deprecated
class AbstractWorkerEvents extends Events {
  @DocsEditable
  AbstractWorkerEvents(EventTarget _ptr) : super(_ptr);

  @DocsEditable
  EventListenerList get error => this['error'];
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('HTMLAnchorElement')
class AnchorElement extends _Element_Merged {
  AnchorElement.internal() : super.internal();

  @DocsEditable
  factory AnchorElement({String href}) {
    var e = document.$dom_createElement("a");
    if (href != null) e.href = href;
    return e;
  }

  @DomName('HTMLAnchorElement.download')
  @DocsEditable
  String get download native "HTMLAnchorElement_download_Getter";

  @DomName('HTMLAnchorElement.download')
  @DocsEditable
  void set download(String value) native "HTMLAnchorElement_download_Setter";

  @DomName('HTMLAnchorElement.hash')
  @DocsEditable
  String get hash native "HTMLAnchorElement_hash_Getter";

  @DomName('HTMLAnchorElement.hash')
  @DocsEditable
  void set hash(String value) native "HTMLAnchorElement_hash_Setter";

  @DomName('HTMLAnchorElement.host')
  @DocsEditable
  String get host native "HTMLAnchorElement_host_Getter";

  @DomName('HTMLAnchorElement.host')
  @DocsEditable
  void set host(String value) native "HTMLAnchorElement_host_Setter";

  @DomName('HTMLAnchorElement.hostname')
  @DocsEditable
  String get hostname native "HTMLAnchorElement_hostname_Getter";

  @DomName('HTMLAnchorElement.hostname')
  @DocsEditable
  void set hostname(String value) native "HTMLAnchorElement_hostname_Setter";

  @DomName('HTMLAnchorElement.href')
  @DocsEditable
  String get href native "HTMLAnchorElement_href_Getter";

  @DomName('HTMLAnchorElement.href')
  @DocsEditable
  void set href(String value) native "HTMLAnchorElement_href_Setter";

  @DomName('HTMLAnchorElement.hreflang')
  @DocsEditable
  String get hreflang native "HTMLAnchorElement_hreflang_Getter";

  @DomName('HTMLAnchorElement.hreflang')
  @DocsEditable
  void set hreflang(String value) native "HTMLAnchorElement_hreflang_Setter";

  @DomName('HTMLAnchorElement.name')
  @DocsEditable
  String get name native "HTMLAnchorElement_name_Getter";

  @DomName('HTMLAnchorElement.name')
  @DocsEditable
  void set name(String value) native "HTMLAnchorElement_name_Setter";

  @DomName('HTMLAnchorElement.origin')
  @DocsEditable
  String get origin native "HTMLAnchorElement_origin_Getter";

  @DomName('HTMLAnchorElement.pathname')
  @DocsEditable
  String get pathname native "HTMLAnchorElement_pathname_Getter";

  @DomName('HTMLAnchorElement.pathname')
  @DocsEditable
  void set pathname(String value) native "HTMLAnchorElement_pathname_Setter";

  @DomName('HTMLAnchorElement.ping')
  @DocsEditable
  String get ping native "HTMLAnchorElement_ping_Getter";

  @DomName('HTMLAnchorElement.ping')
  @DocsEditable
  void set ping(String value) native "HTMLAnchorElement_ping_Setter";

  @DomName('HTMLAnchorElement.port')
  @DocsEditable
  String get port native "HTMLAnchorElement_port_Getter";

  @DomName('HTMLAnchorElement.port')
  @DocsEditable
  void set port(String value) native "HTMLAnchorElement_port_Setter";

  @DomName('HTMLAnchorElement.protocol')
  @DocsEditable
  String get protocol native "HTMLAnchorElement_protocol_Getter";

  @DomName('HTMLAnchorElement.protocol')
  @DocsEditable
  void set protocol(String value) native "HTMLAnchorElement_protocol_Setter";

  @DomName('HTMLAnchorElement.rel')
  @DocsEditable
  String get rel native "HTMLAnchorElement_rel_Getter";

  @DomName('HTMLAnchorElement.rel')
  @DocsEditable
  void set rel(String value) native "HTMLAnchorElement_rel_Setter";

  @DomName('HTMLAnchorElement.search')
  @DocsEditable
  String get search native "HTMLAnchorElement_search_Getter";

  @DomName('HTMLAnchorElement.search')
  @DocsEditable
  void set search(String value) native "HTMLAnchorElement_search_Setter";

  @DomName('HTMLAnchorElement.target')
  @DocsEditable
  String get target native "HTMLAnchorElement_target_Getter";

  @DomName('HTMLAnchorElement.target')
  @DocsEditable
  void set target(String value) native "HTMLAnchorElement_target_Setter";

  @DomName('HTMLAnchorElement.type')
  @DocsEditable
  String get type native "HTMLAnchorElement_type_Getter";

  @DomName('HTMLAnchorElement.type')
  @DocsEditable
  void set type(String value) native "HTMLAnchorElement_type_Setter";

  @DomName('HTMLAnchorElement.toString')
  @DocsEditable
  String toString() native "HTMLAnchorElement_toString_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('WebKitAnimationEvent')
class AnimationEvent extends Event {
  AnimationEvent.internal() : super.internal();

  @DomName('WebKitAnimationEvent.animationName')
  @DocsEditable
  String get animationName native "WebKitAnimationEvent_animationName_Getter";

  @DomName('WebKitAnimationEvent.elapsedTime')
  @DocsEditable
  num get elapsedTime native "WebKitAnimationEvent_elapsedTime_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('DOMApplicationCache')
@SupportedBrowser(SupportedBrowser.CHROME)
@SupportedBrowser(SupportedBrowser.FIREFOX)
@SupportedBrowser(SupportedBrowser.IE, '10')
@SupportedBrowser(SupportedBrowser.OPERA)
@SupportedBrowser(SupportedBrowser.SAFARI)
class ApplicationCache extends EventTarget {
  ApplicationCache.internal() : super.internal();

  @DomName('DOMApplicationCache.cached')
  @DocsEditable
  static const EventStreamProvider<Event> cachedEvent = const EventStreamProvider<Event>('cached');

  @DomName('DOMApplicationCache.checking')
  @DocsEditable
  static const EventStreamProvider<Event> checkingEvent = const EventStreamProvider<Event>('checking');

  @DomName('DOMApplicationCache.downloading')
  @DocsEditable
  static const EventStreamProvider<Event> downloadingEvent = const EventStreamProvider<Event>('downloading');

  @DomName('DOMApplicationCache.error')
  @DocsEditable
  static const EventStreamProvider<Event> errorEvent = const EventStreamProvider<Event>('error');

  @DomName('DOMApplicationCache.noupdate')
  @DocsEditable
  static const EventStreamProvider<Event> noUpdateEvent = const EventStreamProvider<Event>('noupdate');

  @DomName('DOMApplicationCache.obsolete')
  @DocsEditable
  static const EventStreamProvider<Event> obsoleteEvent = const EventStreamProvider<Event>('obsolete');

  @DomName('DOMApplicationCache.progress')
  @DocsEditable
  static const EventStreamProvider<Event> progressEvent = const EventStreamProvider<Event>('progress');

  @DomName('DOMApplicationCache.updateready')
  @DocsEditable
  static const EventStreamProvider<Event> updateReadyEvent = const EventStreamProvider<Event>('updateready');

  /// Checks if this type is supported on the current platform.
  static bool get supported => true;

  @DocsEditable
  @DomName('EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent')
  @deprecated
  ApplicationCacheEvents get on =>
    new ApplicationCacheEvents(this);

  static const int CHECKING = 2;

  static const int DOWNLOADING = 3;

  static const int IDLE = 1;

  static const int OBSOLETE = 5;

  static const int UNCACHED = 0;

  static const int UPDATEREADY = 4;

  @DomName('DOMApplicationCache.status')
  @DocsEditable
  int get status native "DOMApplicationCache_status_Getter";

  @DomName('DOMApplicationCache.abort')
  @DocsEditable
  void abort() native "DOMApplicationCache_abort_Callback";

  @DomName('DOMApplicationCache.addEventListener')
  @DocsEditable
  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]) native "DOMApplicationCache_addEventListener_Callback";

  @DomName('DOMApplicationCache.dispatchEvent')
  @DocsEditable
  bool dispatchEvent(Event evt) native "DOMApplicationCache_dispatchEvent_Callback";

  @DomName('DOMApplicationCache.removeEventListener')
  @DocsEditable
  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]) native "DOMApplicationCache_removeEventListener_Callback";

  @DomName('DOMApplicationCache.swapCache')
  @DocsEditable
  void swapCache() native "DOMApplicationCache_swapCache_Callback";

  @DomName('DOMApplicationCache.update')
  @DocsEditable
  void update() native "DOMApplicationCache_update_Callback";

  @DomName('DOMApplicationCache.cached')
  @DocsEditable
  Stream<Event> get onCached => cachedEvent.forTarget(this);

  @DomName('DOMApplicationCache.checking')
  @DocsEditable
  Stream<Event> get onChecking => checkingEvent.forTarget(this);

  @DomName('DOMApplicationCache.downloading')
  @DocsEditable
  Stream<Event> get onDownloading => downloadingEvent.forTarget(this);

  @DomName('DOMApplicationCache.error')
  @DocsEditable
  Stream<Event> get onError => errorEvent.forTarget(this);

  @DomName('DOMApplicationCache.noupdate')
  @DocsEditable
  Stream<Event> get onNoUpdate => noUpdateEvent.forTarget(this);

  @DomName('DOMApplicationCache.obsolete')
  @DocsEditable
  Stream<Event> get onObsolete => obsoleteEvent.forTarget(this);

  @DomName('DOMApplicationCache.progress')
  @DocsEditable
  Stream<Event> get onProgress => progressEvent.forTarget(this);

  @DomName('DOMApplicationCache.updateready')
  @DocsEditable
  Stream<Event> get onUpdateReady => updateReadyEvent.forTarget(this);

}

@DocsEditable
@deprecated
class ApplicationCacheEvents extends Events {
  @DocsEditable
  ApplicationCacheEvents(EventTarget _ptr) : super(_ptr);

  @DocsEditable
  EventListenerList get cached => this['cached'];

  @DocsEditable
  EventListenerList get checking => this['checking'];

  @DocsEditable
  EventListenerList get downloading => this['downloading'];

  @DocsEditable
  EventListenerList get error => this['error'];

  @DocsEditable
  EventListenerList get noUpdate => this['noupdate'];

  @DocsEditable
  EventListenerList get obsolete => this['obsolete'];

  @DocsEditable
  EventListenerList get progress => this['progress'];

  @DocsEditable
  EventListenerList get updateReady => this['updateready'];
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('HTMLAreaElement')
class AreaElement extends _Element_Merged {
  AreaElement.internal() : super.internal();

  @DocsEditable
  factory AreaElement() => document.$dom_createElement("area");

  @DomName('HTMLAreaElement.alt')
  @DocsEditable
  String get alt native "HTMLAreaElement_alt_Getter";

  @DomName('HTMLAreaElement.alt')
  @DocsEditable
  void set alt(String value) native "HTMLAreaElement_alt_Setter";

  @DomName('HTMLAreaElement.coords')
  @DocsEditable
  String get coords native "HTMLAreaElement_coords_Getter";

  @DomName('HTMLAreaElement.coords')
  @DocsEditable
  void set coords(String value) native "HTMLAreaElement_coords_Setter";

  @DomName('HTMLAreaElement.hash')
  @DocsEditable
  String get hash native "HTMLAreaElement_hash_Getter";

  @DomName('HTMLAreaElement.host')
  @DocsEditable
  String get host native "HTMLAreaElement_host_Getter";

  @DomName('HTMLAreaElement.hostname')
  @DocsEditable
  String get hostname native "HTMLAreaElement_hostname_Getter";

  @DomName('HTMLAreaElement.href')
  @DocsEditable
  String get href native "HTMLAreaElement_href_Getter";

  @DomName('HTMLAreaElement.href')
  @DocsEditable
  void set href(String value) native "HTMLAreaElement_href_Setter";

  @DomName('HTMLAreaElement.pathname')
  @DocsEditable
  String get pathname native "HTMLAreaElement_pathname_Getter";

  @DomName('HTMLAreaElement.ping')
  @DocsEditable
  String get ping native "HTMLAreaElement_ping_Getter";

  @DomName('HTMLAreaElement.ping')
  @DocsEditable
  void set ping(String value) native "HTMLAreaElement_ping_Setter";

  @DomName('HTMLAreaElement.port')
  @DocsEditable
  String get port native "HTMLAreaElement_port_Getter";

  @DomName('HTMLAreaElement.protocol')
  @DocsEditable
  String get protocol native "HTMLAreaElement_protocol_Getter";

  @DomName('HTMLAreaElement.search')
  @DocsEditable
  String get search native "HTMLAreaElement_search_Getter";

  @DomName('HTMLAreaElement.shape')
  @DocsEditable
  String get shape native "HTMLAreaElement_shape_Getter";

  @DomName('HTMLAreaElement.shape')
  @DocsEditable
  void set shape(String value) native "HTMLAreaElement_shape_Setter";

  @DomName('HTMLAreaElement.target')
  @DocsEditable
  String get target native "HTMLAreaElement_target_Getter";

  @DomName('HTMLAreaElement.target')
  @DocsEditable
  void set target(String value) native "HTMLAreaElement_target_Setter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('ArrayBuffer')
@SupportedBrowser(SupportedBrowser.CHROME)
@SupportedBrowser(SupportedBrowser.FIREFOX)
@SupportedBrowser(SupportedBrowser.IE, '10')
@SupportedBrowser(SupportedBrowser.SAFARI)
class ArrayBuffer extends NativeFieldWrapperClass1 {
  ArrayBuffer.internal();

  @DocsEditable
  factory ArrayBuffer(int length) => ArrayBuffer._create(length);
  static ArrayBuffer _create(int length) native "ArrayBuffer_constructor_Callback";

  /// Checks if this type is supported on the current platform.
  static bool get supported => true;

  @DomName('ArrayBuffer.byteLength')
  @DocsEditable
  int get byteLength native "ArrayBuffer_byteLength_Getter";

  ArrayBuffer slice(int begin, [int end]) {
    if (?end) {
      return _slice_1(begin, end);
    }
    return _slice_2(begin);
  }

  @DomName('ArrayBuffer._slice_1')
  @DocsEditable
  ArrayBuffer _slice_1(begin, end) native "ArrayBuffer__slice_1_Callback";

  @DomName('ArrayBuffer._slice_2')
  @DocsEditable
  ArrayBuffer _slice_2(begin) native "ArrayBuffer__slice_2_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('ArrayBufferView')
@SupportedBrowser(SupportedBrowser.CHROME)
@SupportedBrowser(SupportedBrowser.FIREFOX)
@SupportedBrowser(SupportedBrowser.IE, '10')
@SupportedBrowser(SupportedBrowser.SAFARI)
class ArrayBufferView extends NativeFieldWrapperClass1 {
  ArrayBufferView.internal();

  @DomName('ArrayBufferView.buffer')
  @DocsEditable
  ArrayBuffer get buffer native "ArrayBufferView_buffer_Getter";

  @DomName('ArrayBufferView.byteLength')
  @DocsEditable
  int get byteLength native "ArrayBufferView_byteLength_Getter";

  @DomName('ArrayBufferView.byteOffset')
  @DocsEditable
  int get byteOffset native "ArrayBufferView_byteOffset_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('Attr')
class Attr extends Node {
  Attr.internal() : super.internal();

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('HTMLAudioElement')
class AudioElement extends MediaElement {
  AudioElement.internal() : super.internal();

  @DocsEditable
  factory AudioElement([String src]) {
    if (!?src) {
      return AudioElement._create();
    }
    return AudioElement._create(src);
  }
  static AudioElement _create([String src]) native "HTMLAudioElement_constructor_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('HTMLBRElement')
class BRElement extends _Element_Merged {
  BRElement.internal() : super.internal();

  @DocsEditable
  factory BRElement() => document.$dom_createElement("br");

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('BarInfo')
class BarInfo extends NativeFieldWrapperClass1 {
  BarInfo.internal();

  @DomName('BarInfo.visible')
  @DocsEditable
  bool get visible native "BarInfo_visible_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('HTMLBaseElement')
class BaseElement extends _Element_Merged {
  BaseElement.internal() : super.internal();

  @DocsEditable
  factory BaseElement() => document.$dom_createElement("base");

  @DomName('HTMLBaseElement.href')
  @DocsEditable
  String get href native "HTMLBaseElement_href_Getter";

  @DomName('HTMLBaseElement.href')
  @DocsEditable
  void set href(String value) native "HTMLBaseElement_href_Setter";

  @DomName('HTMLBaseElement.target')
  @DocsEditable
  String get target native "HTMLBaseElement_target_Getter";

  @DomName('HTMLBaseElement.target')
  @DocsEditable
  void set target(String value) native "HTMLBaseElement_target_Setter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('BatteryManager')
class BatteryManager extends EventTarget {
  BatteryManager.internal() : super.internal();

  @DomName('BatteryManager.chargingchange')
  @DocsEditable
  static const EventStreamProvider<Event> chargingChangeEvent = const EventStreamProvider<Event>('chargingchange');

  @DomName('BatteryManager.chargingtimechange')
  @DocsEditable
  static const EventStreamProvider<Event> chargingTimeChangeEvent = const EventStreamProvider<Event>('chargingtimechange');

  @DomName('BatteryManager.dischargingtimechange')
  @DocsEditable
  static const EventStreamProvider<Event> dischargingTimeChangeEvent = const EventStreamProvider<Event>('dischargingtimechange');

  @DomName('BatteryManager.levelchange')
  @DocsEditable
  static const EventStreamProvider<Event> levelChangeEvent = const EventStreamProvider<Event>('levelchange');

  @DocsEditable
  @DomName('EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent')
  @deprecated
  BatteryManagerEvents get on =>
    new BatteryManagerEvents(this);

  @DomName('BatteryManager.charging')
  @DocsEditable
  bool get charging native "BatteryManager_charging_Getter";

  @DomName('BatteryManager.chargingTime')
  @DocsEditable
  num get chargingTime native "BatteryManager_chargingTime_Getter";

  @DomName('BatteryManager.dischargingTime')
  @DocsEditable
  num get dischargingTime native "BatteryManager_dischargingTime_Getter";

  @DomName('BatteryManager.level')
  @DocsEditable
  num get level native "BatteryManager_level_Getter";

  @DomName('BatteryManager.addEventListener')
  @DocsEditable
  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]) native "BatteryManager_addEventListener_Callback";

  @DomName('BatteryManager.dispatchEvent')
  @DocsEditable
  bool dispatchEvent(Event event) native "BatteryManager_dispatchEvent_Callback";

  @DomName('BatteryManager.removeEventListener')
  @DocsEditable
  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]) native "BatteryManager_removeEventListener_Callback";

  @DomName('BatteryManager.chargingchange')
  @DocsEditable
  Stream<Event> get onChargingChange => chargingChangeEvent.forTarget(this);

  @DomName('BatteryManager.chargingtimechange')
  @DocsEditable
  Stream<Event> get onChargingTimeChange => chargingTimeChangeEvent.forTarget(this);

  @DomName('BatteryManager.dischargingtimechange')
  @DocsEditable
  Stream<Event> get onDischargingTimeChange => dischargingTimeChangeEvent.forTarget(this);

  @DomName('BatteryManager.levelchange')
  @DocsEditable
  Stream<Event> get onLevelChange => levelChangeEvent.forTarget(this);

}

@DocsEditable
@deprecated
class BatteryManagerEvents extends Events {
  @DocsEditable
  BatteryManagerEvents(EventTarget _ptr) : super(_ptr);

  @DocsEditable
  EventListenerList get chargingChange => this['chargingchange'];

  @DocsEditable
  EventListenerList get chargingTimeChange => this['chargingtimechange'];

  @DocsEditable
  EventListenerList get dischargingTimeChange => this['dischargingtimechange'];

  @DocsEditable
  EventListenerList get levelChange => this['levelchange'];
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('BeforeLoadEvent')
class BeforeLoadEvent extends Event {
  BeforeLoadEvent.internal() : super.internal();

  @DomName('BeforeLoadEvent.url')
  @DocsEditable
  String get url native "BeforeLoadEvent_url_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.


@DomName('Blob')
class Blob extends NativeFieldWrapperClass1 {
  Blob.internal();

  @DocsEditable
  factory Blob(List blobParts, [String type, String endings]) {
    if (!?type) {
      return Blob._create(blobParts);
    }
    if (!?endings) {
      return Blob._create(blobParts, type);
    }
    return Blob._create(blobParts, type, endings);
  }
  static Blob _create(List blobParts, [String type, String endings]) native "Blob_constructor_Callback";

  @DomName('Blob.size')
  @DocsEditable
  int get size native "Blob_size_Getter";

  @DomName('Blob.type')
  @DocsEditable
  String get type native "Blob_type_Getter";

  Blob slice([int start, int end, String contentType]) {
    if (?contentType) {
      return _slice_1(start, end, contentType);
    }
    if (?end) {
      return _slice_2(start, end);
    }
    if (?start) {
      return _slice_3(start);
    }
    return _slice_4();
  }

  @DomName('Blob._slice_1')
  @DocsEditable
  Blob _slice_1(start, end, contentType) native "Blob__slice_1_Callback";

  @DomName('Blob._slice_2')
  @DocsEditable
  Blob _slice_2(start, end) native "Blob__slice_2_Callback";

  @DomName('Blob._slice_3')
  @DocsEditable
  Blob _slice_3(start) native "Blob__slice_3_Callback";

  @DomName('Blob._slice_4')
  @DocsEditable
  Blob _slice_4() native "Blob__slice_4_Callback";

}

// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('HTMLBodyElement')
class BodyElement extends _Element_Merged {
  BodyElement.internal() : super.internal();

  @DomName('HTMLBodyElement.beforeunload')
  @DocsEditable
  static const EventStreamProvider<Event> beforeUnloadEvent = const EventStreamProvider<Event>('beforeunload');

  @DomName('HTMLBodyElement.blur')
  @DocsEditable
  static const EventStreamProvider<Event> blurEvent = const EventStreamProvider<Event>('blur');

  @DomName('HTMLBodyElement.error')
  @DocsEditable
  static const EventStreamProvider<Event> errorEvent = const EventStreamProvider<Event>('error');

  @DomName('HTMLBodyElement.focus')
  @DocsEditable
  static const EventStreamProvider<Event> focusEvent = const EventStreamProvider<Event>('focus');

  @DomName('HTMLBodyElement.hashchange')
  @DocsEditable
  static const EventStreamProvider<Event> hashChangeEvent = const EventStreamProvider<Event>('hashchange');

  @DomName('HTMLBodyElement.load')
  @DocsEditable
  static const EventStreamProvider<Event> loadEvent = const EventStreamProvider<Event>('load');

  @DomName('HTMLBodyElement.message')
  @DocsEditable
  static const EventStreamProvider<MessageEvent> messageEvent = const EventStreamProvider<MessageEvent>('message');

  @DomName('HTMLBodyElement.offline')
  @DocsEditable
  static const EventStreamProvider<Event> offlineEvent = const EventStreamProvider<Event>('offline');

  @DomName('HTMLBodyElement.online')
  @DocsEditable
  static const EventStreamProvider<Event> onlineEvent = const EventStreamProvider<Event>('online');

  @DomName('HTMLBodyElement.popstate')
  @DocsEditable
  static const EventStreamProvider<PopStateEvent> popStateEvent = const EventStreamProvider<PopStateEvent>('popstate');

  @DomName('HTMLBodyElement.resize')
  @DocsEditable
  static const EventStreamProvider<Event> resizeEvent = const EventStreamProvider<Event>('resize');

  @DomName('HTMLBodyElement.storage')
  @DocsEditable
  static const EventStreamProvider<StorageEvent> storageEvent = const EventStreamProvider<StorageEvent>('storage');

  @DomName('HTMLBodyElement.unload')
  @DocsEditable
  static const EventStreamProvider<Event> unloadEvent = const EventStreamProvider<Event>('unload');

  @DocsEditable
  factory BodyElement() => document.$dom_createElement("body");

  @DocsEditable
  @DomName('EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent')
  @deprecated
  BodyElementEvents get on =>
    new BodyElementEvents(this);

  @DomName('HTMLBodyElement.beforeunload')
  @DocsEditable
  Stream<Event> get onBeforeUnload => beforeUnloadEvent.forTarget(this);

  @DomName('HTMLBodyElement.blur')
  @DocsEditable
  Stream<Event> get onBlur => blurEvent.forTarget(this);

  @DomName('HTMLBodyElement.error')
  @DocsEditable
  Stream<Event> get onError => errorEvent.forTarget(this);

  @DomName('HTMLBodyElement.focus')
  @DocsEditable
  Stream<Event> get onFocus => focusEvent.forTarget(this);

  @DomName('HTMLBodyElement.hashchange')
  @DocsEditable
  Stream<Event> get onHashChange => hashChangeEvent.forTarget(this);

  @DomName('HTMLBodyElement.load')
  @DocsEditable
  Stream<Event> get onLoad => loadEvent.forTarget(this);

  @DomName('HTMLBodyElement.message')
  @DocsEditable
  Stream<MessageEvent> get onMessage => messageEvent.forTarget(this);

  @DomName('HTMLBodyElement.offline')
  @DocsEditable
  Stream<Event> get onOffline => offlineEvent.forTarget(this);

  @DomName('HTMLBodyElement.online')
  @DocsEditable
  Stream<Event> get onOnline => onlineEvent.forTarget(this);

  @DomName('HTMLBodyElement.popstate')
  @DocsEditable
  Stream<PopStateEvent> get onPopState => popStateEvent.forTarget(this);

  @DomName('HTMLBodyElement.resize')
  @DocsEditable
  Stream<Event> get onResize => resizeEvent.forTarget(this);

  @DomName('HTMLBodyElement.storage')
  @DocsEditable
  Stream<StorageEvent> get onStorage => storageEvent.forTarget(this);

  @DomName('HTMLBodyElement.unload')
  @DocsEditable
  Stream<Event> get onUnload => unloadEvent.forTarget(this);

}

@DocsEditable
@deprecated
class BodyElementEvents extends ElementEvents {
  @DocsEditable
  BodyElementEvents(EventTarget _ptr) : super(_ptr);

  @DocsEditable
  EventListenerList get beforeUnload => this['beforeunload'];

  @DocsEditable
  EventListenerList get blur => this['blur'];

  @DocsEditable
  EventListenerList get error => this['error'];

  @DocsEditable
  EventListenerList get focus => this['focus'];

  @DocsEditable
  EventListenerList get hashChange => this['hashchange'];

  @DocsEditable
  EventListenerList get load => this['load'];

  @DocsEditable
  EventListenerList get message => this['message'];

  @DocsEditable
  EventListenerList get offline => this['offline'];

  @DocsEditable
  EventListenerList get online => this['online'];

  @DocsEditable
  EventListenerList get popState => this['popstate'];

  @DocsEditable
  EventListenerList get resize => this['resize'];

  @DocsEditable
  EventListenerList get storage => this['storage'];

  @DocsEditable
  EventListenerList get unload => this['unload'];
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('HTMLButtonElement')
class ButtonElement extends _Element_Merged {
  ButtonElement.internal() : super.internal();

  @DocsEditable
  factory ButtonElement() => document.$dom_createElement("button");

  @DomName('HTMLButtonElement.autofocus')
  @DocsEditable
  bool get autofocus native "HTMLButtonElement_autofocus_Getter";

  @DomName('HTMLButtonElement.autofocus')
  @DocsEditable
  void set autofocus(bool value) native "HTMLButtonElement_autofocus_Setter";

  @DomName('HTMLButtonElement.disabled')
  @DocsEditable
  bool get disabled native "HTMLButtonElement_disabled_Getter";

  @DomName('HTMLButtonElement.disabled')
  @DocsEditable
  void set disabled(bool value) native "HTMLButtonElement_disabled_Setter";

  @DomName('HTMLButtonElement.form')
  @DocsEditable
  FormElement get form native "HTMLButtonElement_form_Getter";

  @DomName('HTMLButtonElement.formAction')
  @DocsEditable
  String get formAction native "HTMLButtonElement_formAction_Getter";

  @DomName('HTMLButtonElement.formAction')
  @DocsEditable
  void set formAction(String value) native "HTMLButtonElement_formAction_Setter";

  @DomName('HTMLButtonElement.formEnctype')
  @DocsEditable
  String get formEnctype native "HTMLButtonElement_formEnctype_Getter";

  @DomName('HTMLButtonElement.formEnctype')
  @DocsEditable
  void set formEnctype(String value) native "HTMLButtonElement_formEnctype_Setter";

  @DomName('HTMLButtonElement.formMethod')
  @DocsEditable
  String get formMethod native "HTMLButtonElement_formMethod_Getter";

  @DomName('HTMLButtonElement.formMethod')
  @DocsEditable
  void set formMethod(String value) native "HTMLButtonElement_formMethod_Setter";

  @DomName('HTMLButtonElement.formNoValidate')
  @DocsEditable
  bool get formNoValidate native "HTMLButtonElement_formNoValidate_Getter";

  @DomName('HTMLButtonElement.formNoValidate')
  @DocsEditable
  void set formNoValidate(bool value) native "HTMLButtonElement_formNoValidate_Setter";

  @DomName('HTMLButtonElement.formTarget')
  @DocsEditable
  String get formTarget native "HTMLButtonElement_formTarget_Getter";

  @DomName('HTMLButtonElement.formTarget')
  @DocsEditable
  void set formTarget(String value) native "HTMLButtonElement_formTarget_Setter";

  @DomName('HTMLButtonElement.labels')
  @DocsEditable
  List<Node> get labels native "HTMLButtonElement_labels_Getter";

  @DomName('HTMLButtonElement.name')
  @DocsEditable
  String get name native "HTMLButtonElement_name_Getter";

  @DomName('HTMLButtonElement.name')
  @DocsEditable
  void set name(String value) native "HTMLButtonElement_name_Setter";

  @DomName('HTMLButtonElement.type')
  @DocsEditable
  String get type native "HTMLButtonElement_type_Getter";

  @DomName('HTMLButtonElement.type')
  @DocsEditable
  void set type(String value) native "HTMLButtonElement_type_Setter";

  @DomName('HTMLButtonElement.validationMessage')
  @DocsEditable
  String get validationMessage native "HTMLButtonElement_validationMessage_Getter";

  @DomName('HTMLButtonElement.validity')
  @DocsEditable
  ValidityState get validity native "HTMLButtonElement_validity_Getter";

  @DomName('HTMLButtonElement.value')
  @DocsEditable
  String get value native "HTMLButtonElement_value_Getter";

  @DomName('HTMLButtonElement.value')
  @DocsEditable
  void set value(String value) native "HTMLButtonElement_value_Setter";

  @DomName('HTMLButtonElement.willValidate')
  @DocsEditable
  bool get willValidate native "HTMLButtonElement_willValidate_Getter";

  @DomName('HTMLButtonElement.checkValidity')
  @DocsEditable
  bool checkValidity() native "HTMLButtonElement_checkValidity_Callback";

  @DomName('HTMLButtonElement.setCustomValidity')
  @DocsEditable
  void setCustomValidity(String error) native "HTMLButtonElement_setCustomValidity_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('CDATASection')
class CDataSection extends Text {
  CDataSection.internal() : super.internal();

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.


@DomName('HTMLCanvasElement')
class CanvasElement extends _Element_Merged {
  CanvasElement.internal() : super.internal();

  @DocsEditable
  factory CanvasElement({int width, int height}) {
    var e = document.$dom_createElement("canvas");
    if (width != null) e.width = width;
    if (height != null) e.height = height;
    return e;
  }

  @DomName('HTMLCanvasElement.height')
  @DocsEditable
  int get height native "HTMLCanvasElement_height_Getter";

  @DomName('HTMLCanvasElement.height')
  @DocsEditable
  void set height(int value) native "HTMLCanvasElement_height_Setter";

  @DomName('HTMLCanvasElement.width')
  @DocsEditable
  int get width native "HTMLCanvasElement_width_Getter";

  @DomName('HTMLCanvasElement.width')
  @DocsEditable
  void set width(int value) native "HTMLCanvasElement_width_Setter";

  @DomName('HTMLCanvasElement.getContext')
  @DocsEditable
  Object getContext(String contextId) native "HTMLCanvasElement_getContext_Callback";

  @DomName('HTMLCanvasElement.toDataURL')
  @DocsEditable
  String toDataUrl(String type, [num quality]) native "HTMLCanvasElement_toDataURL_Callback";


  CanvasRenderingContext2D get context2d => getContext('2d');
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
/**
 * An opaque canvas object representing a gradient.
 *
 * Created by calling [createLinearGradient] or [createRadialGradient] on a
 * [CanvasRenderingContext2D] object.
 *
 * Example usage:
 *
 *     var canvas = new CanvasElement(width: 600, height: 600);
 *     var ctx = canvas.context2d;
 *     ctx.clearRect(0, 0, 600, 600);
 *     ctx.save();
 *     // Create radial gradient.
 *     CanvasGradient gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, 600);
 *     gradient.addColorStop(0, '#000');
 *     gradient.addColorStop(1, 'rgb(255, 255, 255)');
 *     // Assign gradients to fill.
 *     ctx.fillStyle = gradient;
 *     // Draw a rectangle with a gradient fill.
 *     ctx.fillRect(0, 0, 600, 600);
 *     ctx.save();
 *     document.body.children.add(canvas);
 *
 * See also:
 *
 * * [CanvasGradient](https://developer.mozilla.org/en-US/docs/DOM/CanvasGradient) from MDN.
 * * [CanvasGradient](http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#canvasgradient) from whatwg.
 * * [CanvasGradient](http://www.w3.org/TR/2010/WD-2dcontext-20100304/#canvasgradient) from W3C.
 */
@DomName('CanvasGradient')
@DomName('CanvasGradient')
class CanvasGradient extends NativeFieldWrapperClass1 {
  CanvasGradient.internal();

  @DomName('CanvasGradient.addColorStop')
  @DocsEditable
  void addColorStop(num offset, String color) native "CanvasGradient_addColorStop_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
/**
 * An opaque object representing a pattern of image, canvas, or video.
 *
 * Created by calling [createPattern] on a [CanvasRenderingContext2D] object.
 *
 * Example usage:
 *
 *     var canvas = new CanvasElement(width: 600, height: 600);
 *     var ctx = canvas.context2d;
 *     var img = new ImageElement();
 *     // Image src needs to be loaded before pattern is applied.
 *     img.onLoad.listen((event) {
 *       // When the image is loaded, create a pattern
 *       // from the ImageElement.
 *       CanvasPattern pattern = ctx.createPattern(img, 'repeat');
 *       ctx.rect(0, 0, canvas.width, canvas.height);
 *       ctx.fillStyle = pattern;
 *       ctx.fill();
 *     });
 *     img.src = "images/foo.jpg";
 *     document.body.children.add(canvas);
 *
 * See also:
 * * [CanvasPattern](https://developer.mozilla.org/en-US/docs/DOM/CanvasPattern) from MDN.
 * * [CanvasPattern](http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#canvaspattern) from whatwg.
 * * [CanvasPattern](http://www.w3.org/TR/2010/WD-2dcontext-20100304/#canvaspattern) from W3C.
 */
@DomName('CanvasPattern')
@DomName('CanvasPattern')
class CanvasPattern extends NativeFieldWrapperClass1 {
  CanvasPattern.internal();

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
/**
 * A rendering context for a canvas element.
 *
 * This context is extended by [CanvasRenderingContext2D] and
 * [WebGLRenderingContext].
 */
@DomName('CanvasRenderingContext')
@DomName('CanvasRenderingContext')
class CanvasRenderingContext extends NativeFieldWrapperClass1 {
  CanvasRenderingContext.internal();

  @DomName('CanvasRenderingContext.canvas')
  @DocsEditable
  CanvasElement get canvas native "CanvasRenderingContext_canvas_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.


@DomName('CanvasRenderingContext2D')
class CanvasRenderingContext2D extends CanvasRenderingContext {
  CanvasRenderingContext2D.internal() : super.internal();

  @DomName('CanvasRenderingContext2D.fillStyle')
  @DocsEditable
  dynamic get fillStyle native "CanvasRenderingContext2D_fillStyle_Getter";

  @DomName('CanvasRenderingContext2D.fillStyle')
  @DocsEditable
  void set fillStyle(dynamic value) native "CanvasRenderingContext2D_fillStyle_Setter";

  @DomName('CanvasRenderingContext2D.font')
  @DocsEditable
  String get font native "CanvasRenderingContext2D_font_Getter";

  @DomName('CanvasRenderingContext2D.font')
  @DocsEditable
  void set font(String value) native "CanvasRenderingContext2D_font_Setter";

  @DomName('CanvasRenderingContext2D.globalAlpha')
  @DocsEditable
  num get globalAlpha native "CanvasRenderingContext2D_globalAlpha_Getter";

  @DomName('CanvasRenderingContext2D.globalAlpha')
  @DocsEditable
  void set globalAlpha(num value) native "CanvasRenderingContext2D_globalAlpha_Setter";

  @DomName('CanvasRenderingContext2D.globalCompositeOperation')
  @DocsEditable
  String get globalCompositeOperation native "CanvasRenderingContext2D_globalCompositeOperation_Getter";

  @DomName('CanvasRenderingContext2D.globalCompositeOperation')
  @DocsEditable
  void set globalCompositeOperation(String value) native "CanvasRenderingContext2D_globalCompositeOperation_Setter";

  @DomName('CanvasRenderingContext2D.lineCap')
  @DocsEditable
  String get lineCap native "CanvasRenderingContext2D_lineCap_Getter";

  @DomName('CanvasRenderingContext2D.lineCap')
  @DocsEditable
  void set lineCap(String value) native "CanvasRenderingContext2D_lineCap_Setter";

  @DomName('CanvasRenderingContext2D.lineDashOffset')
  @DocsEditable
  num get lineDashOffset native "CanvasRenderingContext2D_lineDashOffset_Getter";

  @DomName('CanvasRenderingContext2D.lineDashOffset')
  @DocsEditable
  void set lineDashOffset(num value) native "CanvasRenderingContext2D_lineDashOffset_Setter";

  @DomName('CanvasRenderingContext2D.lineJoin')
  @DocsEditable
  String get lineJoin native "CanvasRenderingContext2D_lineJoin_Getter";

  @DomName('CanvasRenderingContext2D.lineJoin')
  @DocsEditable
  void set lineJoin(String value) native "CanvasRenderingContext2D_lineJoin_Setter";

  @DomName('CanvasRenderingContext2D.lineWidth')
  @DocsEditable
  num get lineWidth native "CanvasRenderingContext2D_lineWidth_Getter";

  @DomName('CanvasRenderingContext2D.lineWidth')
  @DocsEditable
  void set lineWidth(num value) native "CanvasRenderingContext2D_lineWidth_Setter";

  @DomName('CanvasRenderingContext2D.miterLimit')
  @DocsEditable
  num get miterLimit native "CanvasRenderingContext2D_miterLimit_Getter";

  @DomName('CanvasRenderingContext2D.miterLimit')
  @DocsEditable
  void set miterLimit(num value) native "CanvasRenderingContext2D_miterLimit_Setter";

  @DomName('CanvasRenderingContext2D.shadowBlur')
  @DocsEditable
  num get shadowBlur native "CanvasRenderingContext2D_shadowBlur_Getter";

  @DomName('CanvasRenderingContext2D.shadowBlur')
  @DocsEditable
  void set shadowBlur(num value) native "CanvasRenderingContext2D_shadowBlur_Setter";

  @DomName('CanvasRenderingContext2D.shadowColor')
  @DocsEditable
  String get shadowColor native "CanvasRenderingContext2D_shadowColor_Getter";

  @DomName('CanvasRenderingContext2D.shadowColor')
  @DocsEditable
  void set shadowColor(String value) native "CanvasRenderingContext2D_shadowColor_Setter";

  @DomName('CanvasRenderingContext2D.shadowOffsetX')
  @DocsEditable
  num get shadowOffsetX native "CanvasRenderingContext2D_shadowOffsetX_Getter";

  @DomName('CanvasRenderingContext2D.shadowOffsetX')
  @DocsEditable
  void set shadowOffsetX(num value) native "CanvasRenderingContext2D_shadowOffsetX_Setter";

  @DomName('CanvasRenderingContext2D.shadowOffsetY')
  @DocsEditable
  num get shadowOffsetY native "CanvasRenderingContext2D_shadowOffsetY_Getter";

  @DomName('CanvasRenderingContext2D.shadowOffsetY')
  @DocsEditable
  void set shadowOffsetY(num value) native "CanvasRenderingContext2D_shadowOffsetY_Setter";

  @DomName('CanvasRenderingContext2D.strokeStyle')
  @DocsEditable
  dynamic get strokeStyle native "CanvasRenderingContext2D_strokeStyle_Getter";

  @DomName('CanvasRenderingContext2D.strokeStyle')
  @DocsEditable
  void set strokeStyle(dynamic value) native "CanvasRenderingContext2D_strokeStyle_Setter";

  @DomName('CanvasRenderingContext2D.textAlign')
  @DocsEditable
  String get textAlign native "CanvasRenderingContext2D_textAlign_Getter";

  @DomName('CanvasRenderingContext2D.textAlign')
  @DocsEditable
  void set textAlign(String value) native "CanvasRenderingContext2D_textAlign_Setter";

  @DomName('CanvasRenderingContext2D.textBaseline')
  @DocsEditable
  String get textBaseline native "CanvasRenderingContext2D_textBaseline_Getter";

  @DomName('CanvasRenderingContext2D.textBaseline')
  @DocsEditable
  void set textBaseline(String value) native "CanvasRenderingContext2D_textBaseline_Setter";

  @DomName('CanvasRenderingContext2D.webkitBackingStorePixelRatio')
  @DocsEditable
  num get webkitBackingStorePixelRatio native "CanvasRenderingContext2D_webkitBackingStorePixelRatio_Getter";

  @DomName('CanvasRenderingContext2D.webkitImageSmoothingEnabled')
  @DocsEditable
  bool get webkitImageSmoothingEnabled native "CanvasRenderingContext2D_webkitImageSmoothingEnabled_Getter";

  @DomName('CanvasRenderingContext2D.webkitImageSmoothingEnabled')
  @DocsEditable
  void set webkitImageSmoothingEnabled(bool value) native "CanvasRenderingContext2D_webkitImageSmoothingEnabled_Setter";

  @DomName('CanvasRenderingContext2D.webkitLineDash')
  @DocsEditable
  List get webkitLineDash native "CanvasRenderingContext2D_webkitLineDash_Getter";

  @DomName('CanvasRenderingContext2D.webkitLineDash')
  @DocsEditable
  void set webkitLineDash(List value) native "CanvasRenderingContext2D_webkitLineDash_Setter";

  @DomName('CanvasRenderingContext2D.webkitLineDashOffset')
  @DocsEditable
  num get webkitLineDashOffset native "CanvasRenderingContext2D_webkitLineDashOffset_Getter";

  @DomName('CanvasRenderingContext2D.webkitLineDashOffset')
  @DocsEditable
  void set webkitLineDashOffset(num value) native "CanvasRenderingContext2D_webkitLineDashOffset_Setter";

  @DomName('CanvasRenderingContext2D.arc')
  @DocsEditable
  void arc(num x, num y, num radius, num startAngle, num endAngle, bool anticlockwise) native "CanvasRenderingContext2D_arc_Callback";

  @DomName('CanvasRenderingContext2D.arcTo')
  @DocsEditable
  void arcTo(num x1, num y1, num x2, num y2, num radius) native "CanvasRenderingContext2D_arcTo_Callback";

  @DomName('CanvasRenderingContext2D.beginPath')
  @DocsEditable
  void beginPath() native "CanvasRenderingContext2D_beginPath_Callback";

  @DomName('CanvasRenderingContext2D.bezierCurveTo')
  @DocsEditable
  void bezierCurveTo(num cp1x, num cp1y, num cp2x, num cp2y, num x, num y) native "CanvasRenderingContext2D_bezierCurveTo_Callback";

  @DomName('CanvasRenderingContext2D.clearRect')
  @DocsEditable
  void clearRect(num x, num y, num width, num height) native "CanvasRenderingContext2D_clearRect_Callback";

  @DomName('CanvasRenderingContext2D.clip')
  @DocsEditable
  void clip() native "CanvasRenderingContext2D_clip_Callback";

  @DomName('CanvasRenderingContext2D.closePath')
  @DocsEditable
  void closePath() native "CanvasRenderingContext2D_closePath_Callback";

  ImageData createImageData(imagedata_OR_sw, [num sh]) {
    if ((imagedata_OR_sw is ImageData || imagedata_OR_sw == null) && !?sh) {
      return _createImageData_1(imagedata_OR_sw);
    }
    if ((imagedata_OR_sw is num || imagedata_OR_sw == null) && (sh is num || sh == null)) {
      return _createImageData_2(imagedata_OR_sw, sh);
    }
    throw new ArgumentError("Incorrect number or type of arguments");
  }

  @DomName('CanvasRenderingContext2D._createImageData_1')
  @DocsEditable
  ImageData _createImageData_1(imagedata_OR_sw) native "CanvasRenderingContext2D__createImageData_1_Callback";

  @DomName('CanvasRenderingContext2D._createImageData_2')
  @DocsEditable
  ImageData _createImageData_2(imagedata_OR_sw, sh) native "CanvasRenderingContext2D__createImageData_2_Callback";

  @DomName('CanvasRenderingContext2D.createLinearGradient')
  @DocsEditable
  CanvasGradient createLinearGradient(num x0, num y0, num x1, num y1) native "CanvasRenderingContext2D_createLinearGradient_Callback";

  CanvasPattern createPattern(canvas_OR_image, String repetitionType) {
    if ((canvas_OR_image is CanvasElement || canvas_OR_image == null) && (repetitionType is String || repetitionType == null)) {
      return _createPattern_1(canvas_OR_image, repetitionType);
    }
    if ((canvas_OR_image is ImageElement || canvas_OR_image == null) && (repetitionType is String || repetitionType == null)) {
      return _createPattern_2(canvas_OR_image, repetitionType);
    }
    throw new ArgumentError("Incorrect number or type of arguments");
  }

  @DomName('CanvasRenderingContext2D._createPattern_1')
  @DocsEditable
  CanvasPattern _createPattern_1(canvas_OR_image, repetitionType) native "CanvasRenderingContext2D__createPattern_1_Callback";

  @DomName('CanvasRenderingContext2D._createPattern_2')
  @DocsEditable
  CanvasPattern _createPattern_2(canvas_OR_image, repetitionType) native "CanvasRenderingContext2D__createPattern_2_Callback";

  @DomName('CanvasRenderingContext2D.createRadialGradient')
  @DocsEditable
  CanvasGradient createRadialGradient(num x0, num y0, num r0, num x1, num y1, num r1) native "CanvasRenderingContext2D_createRadialGradient_Callback";

  void drawImage(canvas_OR_image_OR_video, num sx_OR_x, num sy_OR_y, [num sw_OR_width, num height_OR_sh, num dx, num dy, num dw, num dh]) {
    if ((canvas_OR_image_OR_video is ImageElement || canvas_OR_image_OR_video == null) && (sx_OR_x is num || sx_OR_x == null) && (sy_OR_y is num || sy_OR_y == null) && !?sw_OR_width && !?height_OR_sh && !?dx && !?dy && !?dw && !?dh) {
      _drawImage_1(canvas_OR_image_OR_video, sx_OR_x, sy_OR_y);
      return;
    }
    if ((canvas_OR_image_OR_video is ImageElement || canvas_OR_image_OR_video == null) && (sx_OR_x is num || sx_OR_x == null) && (sy_OR_y is num || sy_OR_y == null) && (sw_OR_width is num || sw_OR_width == null) && (height_OR_sh is num || height_OR_sh == null) && !?dx && !?dy && !?dw && !?dh) {
      _drawImage_2(canvas_OR_image_OR_video, sx_OR_x, sy_OR_y, sw_OR_width, height_OR_sh);
      return;
    }
    if ((canvas_OR_image_OR_video is ImageElement || canvas_OR_image_OR_video == null) && (sx_OR_x is num || sx_OR_x == null) && (sy_OR_y is num || sy_OR_y == null) && (sw_OR_width is num || sw_OR_width == null) && (height_OR_sh is num || height_OR_sh == null) && (dx is num || dx == null) && (dy is num || dy == null) && (dw is num || dw == null) && (dh is num || dh == null)) {
      _drawImage_3(canvas_OR_image_OR_video, sx_OR_x, sy_OR_y, sw_OR_width, height_OR_sh, dx, dy, dw, dh);
      return;
    }
    if ((canvas_OR_image_OR_video is CanvasElement || canvas_OR_image_OR_video == null) && (sx_OR_x is num || sx_OR_x == null) && (sy_OR_y is num || sy_OR_y == null) && !?sw_OR_width && !?height_OR_sh && !?dx && !?dy && !?dw && !?dh) {
      _drawImage_4(canvas_OR_image_OR_video, sx_OR_x, sy_OR_y);
      return;
    }
    if ((canvas_OR_image_OR_video is CanvasElement || canvas_OR_image_OR_video == null) && (sx_OR_x is num || sx_OR_x == null) && (sy_OR_y is num || sy_OR_y == null) && (sw_OR_width is num || sw_OR_width == null) && (height_OR_sh is num || height_OR_sh == null) && !?dx && !?dy && !?dw && !?dh) {
      _drawImage_5(canvas_OR_image_OR_video, sx_OR_x, sy_OR_y, sw_OR_width, height_OR_sh);
      return;
    }
    if ((canvas_OR_image_OR_video is CanvasElement || canvas_OR_image_OR_video == null) && (sx_OR_x is num || sx_OR_x == null) && (sy_OR_y is num || sy_OR_y == null) && (sw_OR_width is num || sw_OR_width == null) && (height_OR_sh is num || height_OR_sh == null) && (dx is num || dx == null) && (dy is num || dy == null) && (dw is num || dw == null) && (dh is num || dh == null)) {
      _drawImage_6(canvas_OR_image_OR_video, sx_OR_x, sy_OR_y, sw_OR_width, height_OR_sh, dx, dy, dw, dh);
      return;
    }
    if ((canvas_OR_image_OR_video is VideoElement || canvas_OR_image_OR_video == null) && (sx_OR_x is num || sx_OR_x == null) && (sy_OR_y is num || sy_OR_y == null) && !?sw_OR_width && !?height_OR_sh && !?dx && !?dy && !?dw && !?dh) {
      _drawImage_7(canvas_OR_image_OR_video, sx_OR_x, sy_OR_y);
      return;
    }
    if ((canvas_OR_image_OR_video is VideoElement || canvas_OR_image_OR_video == null) && (sx_OR_x is num || sx_OR_x == null) && (sy_OR_y is num || sy_OR_y == null) && (sw_OR_width is num || sw_OR_width == null) && (height_OR_sh is num || height_OR_sh == null) && !?dx && !?dy && !?dw && !?dh) {
      _drawImage_8(canvas_OR_image_OR_video, sx_OR_x, sy_OR_y, sw_OR_width, height_OR_sh);
      return;
    }
    if ((canvas_OR_image_OR_video is VideoElement || canvas_OR_image_OR_video == null) && (sx_OR_x is num || sx_OR_x == null) && (sy_OR_y is num || sy_OR_y == null) && (sw_OR_width is num || sw_OR_width == null) && (height_OR_sh is num || height_OR_sh == null) && (dx is num || dx == null) && (dy is num || dy == null) && (dw is num || dw == null) && (dh is num || dh == null)) {
      _drawImage_9(canvas_OR_image_OR_video, sx_OR_x, sy_OR_y, sw_OR_width, height_OR_sh, dx, dy, dw, dh);
      return;
    }
    throw new ArgumentError("Incorrect number or type of arguments");
  }

  @DomName('CanvasRenderingContext2D._drawImage_1')
  @DocsEditable
  void _drawImage_1(canvas_OR_image_OR_video, sx_OR_x, sy_OR_y) native "CanvasRenderingContext2D__drawImage_1_Callback";

  @DomName('CanvasRenderingContext2D._drawImage_2')
  @DocsEditable
  void _drawImage_2(canvas_OR_image_OR_video, sx_OR_x, sy_OR_y, sw_OR_width, height_OR_sh) native "CanvasRenderingContext2D__drawImage_2_Callback";

  @DomName('CanvasRenderingContext2D._drawImage_3')
  @DocsEditable
  void _drawImage_3(canvas_OR_image_OR_video, sx_OR_x, sy_OR_y, sw_OR_width, height_OR_sh, dx, dy, dw, dh) native "CanvasRenderingContext2D__drawImage_3_Callback";

  @DomName('CanvasRenderingContext2D._drawImage_4')
  @DocsEditable
  void _drawImage_4(canvas_OR_image_OR_video, sx_OR_x, sy_OR_y) native "CanvasRenderingContext2D__drawImage_4_Callback";

  @DomName('CanvasRenderingContext2D._drawImage_5')
  @DocsEditable
  void _drawImage_5(canvas_OR_image_OR_video, sx_OR_x, sy_OR_y, sw_OR_width, height_OR_sh) native "CanvasRenderingContext2D__drawImage_5_Callback";

  @DomName('CanvasRenderingContext2D._drawImage_6')
  @DocsEditable
  void _drawImage_6(canvas_OR_image_OR_video, sx_OR_x, sy_OR_y, sw_OR_width, height_OR_sh, dx, dy, dw, dh) native "CanvasRenderingContext2D__drawImage_6_Callback";

  @DomName('CanvasRenderingContext2D._drawImage_7')
  @DocsEditable
  void _drawImage_7(canvas_OR_image_OR_video, sx_OR_x, sy_OR_y) native "CanvasRenderingContext2D__drawImage_7_Callback";

  @DomName('CanvasRenderingContext2D._drawImage_8')
  @DocsEditable
  void _drawImage_8(canvas_OR_image_OR_video, sx_OR_x, sy_OR_y, sw_OR_width, height_OR_sh) native "CanvasRenderingContext2D__drawImage_8_Callback";

  @DomName('CanvasRenderingContext2D._drawImage_9')
  @DocsEditable
  void _drawImage_9(canvas_OR_image_OR_video, sx_OR_x, sy_OR_y, sw_OR_width, height_OR_sh, dx, dy, dw, dh) native "CanvasRenderingContext2D__drawImage_9_Callback";

  @DomName('CanvasRenderingContext2D.fill')
  @DocsEditable
  void fill() native "CanvasRenderingContext2D_fill_Callback";

  @DomName('CanvasRenderingContext2D.fillRect')
  @DocsEditable
  void fillRect(num x, num y, num width, num height) native "CanvasRenderingContext2D_fillRect_Callback";

  void fillText(String text, num x, num y, [num maxWidth]) {
    if (?maxWidth) {
      _fillText_1(text, x, y, maxWidth);
      return;
    }
    _fillText_2(text, x, y);
    return;
  }

  @DomName('CanvasRenderingContext2D._fillText_1')
  @DocsEditable
  void _fillText_1(text, x, y, maxWidth) native "CanvasRenderingContext2D__fillText_1_Callback";

  @DomName('CanvasRenderingContext2D._fillText_2')
  @DocsEditable
  void _fillText_2(text, x, y) native "CanvasRenderingContext2D__fillText_2_Callback";

  @DomName('CanvasRenderingContext2D.getImageData')
  @DocsEditable
  ImageData getImageData(num sx, num sy, num sw, num sh) native "CanvasRenderingContext2D_getImageData_Callback";

  @DomName('CanvasRenderingContext2D.getLineDash')
  @DocsEditable
  List<num> getLineDash() native "CanvasRenderingContext2D_getLineDash_Callback";

  @DomName('CanvasRenderingContext2D.isPointInPath')
  @DocsEditable
  bool isPointInPath(num x, num y) native "CanvasRenderingContext2D_isPointInPath_Callback";

  @DomName('CanvasRenderingContext2D.lineTo')
  @DocsEditable
  void lineTo(num x, num y) native "CanvasRenderingContext2D_lineTo_Callback";

  @DomName('CanvasRenderingContext2D.measureText')
  @DocsEditable
  TextMetrics measureText(String text) native "CanvasRenderingContext2D_measureText_Callback";

  @DomName('CanvasRenderingContext2D.moveTo')
  @DocsEditable
  void moveTo(num x, num y) native "CanvasRenderingContext2D_moveTo_Callback";

  void putImageData(ImageData imagedata, num dx, num dy, [num dirtyX, num dirtyY, num dirtyWidth, num dirtyHeight]) {
    if ((imagedata is ImageData || imagedata == null) && (dx is num || dx == null) && (dy is num || dy == null) && !?dirtyX && !?dirtyY && !?dirtyWidth && !?dirtyHeight) {
      _putImageData_1(imagedata, dx, dy);
      return;
    }
    if ((imagedata is ImageData || imagedata == null) && (dx is num || dx == null) && (dy is num || dy == null) && (dirtyX is num || dirtyX == null) && (dirtyY is num || dirtyY == null) && (dirtyWidth is num || dirtyWidth == null) && (dirtyHeight is num || dirtyHeight == null)) {
      _putImageData_2(imagedata, dx, dy, dirtyX, dirtyY, dirtyWidth, dirtyHeight);
      return;
    }
    throw new ArgumentError("Incorrect number or type of arguments");
  }

  @DomName('CanvasRenderingContext2D._putImageData_1')
  @DocsEditable
  void _putImageData_1(imagedata, dx, dy) native "CanvasRenderingContext2D__putImageData_1_Callback";

  @DomName('CanvasRenderingContext2D._putImageData_2')
  @DocsEditable
  void _putImageData_2(imagedata, dx, dy, dirtyX, dirtyY, dirtyWidth, dirtyHeight) native "CanvasRenderingContext2D__putImageData_2_Callback";

  @DomName('CanvasRenderingContext2D.quadraticCurveTo')
  @DocsEditable
  void quadraticCurveTo(num cpx, num cpy, num x, num y) native "CanvasRenderingContext2D_quadraticCurveTo_Callback";

  @DomName('CanvasRenderingContext2D.rect')
  @DocsEditable
  void rect(num x, num y, num width, num height) native "CanvasRenderingContext2D_rect_Callback";

  @DomName('CanvasRenderingContext2D.restore')
  @DocsEditable
  void restore() native "CanvasRenderingContext2D_restore_Callback";

  @DomName('CanvasRenderingContext2D.rotate')
  @DocsEditable
  void rotate(num angle) native "CanvasRenderingContext2D_rotate_Callback";

  @DomName('CanvasRenderingContext2D.save')
  @DocsEditable
  void save() native "CanvasRenderingContext2D_save_Callback";

  @DomName('CanvasRenderingContext2D.scale')
  @DocsEditable
  void scale(num sx, num sy) native "CanvasRenderingContext2D_scale_Callback";

  @DomName('CanvasRenderingContext2D.setLineDash')
  @DocsEditable
  void setLineDash(List<num> dash) native "CanvasRenderingContext2D_setLineDash_Callback";

  @DomName('CanvasRenderingContext2D.setTransform')
  @DocsEditable
  void setTransform(num m11, num m12, num m21, num m22, num dx, num dy) native "CanvasRenderingContext2D_setTransform_Callback";

  @DomName('CanvasRenderingContext2D.stroke')
  @DocsEditable
  void stroke() native "CanvasRenderingContext2D_stroke_Callback";

  void strokeRect(num x, num y, num width, num height, [num lineWidth]) {
    if (?lineWidth) {
      _strokeRect_1(x, y, width, height, lineWidth);
      return;
    }
    _strokeRect_2(x, y, width, height);
    return;
  }

  @DomName('CanvasRenderingContext2D._strokeRect_1')
  @DocsEditable
  void _strokeRect_1(x, y, width, height, lineWidth) native "CanvasRenderingContext2D__strokeRect_1_Callback";

  @DomName('CanvasRenderingContext2D._strokeRect_2')
  @DocsEditable
  void _strokeRect_2(x, y, width, height) native "CanvasRenderingContext2D__strokeRect_2_Callback";

  void strokeText(String text, num x, num y, [num maxWidth]) {
    if (?maxWidth) {
      _strokeText_1(text, x, y, maxWidth);
      return;
    }
    _strokeText_2(text, x, y);
    return;
  }

  @DomName('CanvasRenderingContext2D._strokeText_1')
  @DocsEditable
  void _strokeText_1(text, x, y, maxWidth) native "CanvasRenderingContext2D__strokeText_1_Callback";

  @DomName('CanvasRenderingContext2D._strokeText_2')
  @DocsEditable
  void _strokeText_2(text, x, y) native "CanvasRenderingContext2D__strokeText_2_Callback";

  @DomName('CanvasRenderingContext2D.transform')
  @DocsEditable
  void transform(num m11, num m12, num m21, num m22, num dx, num dy) native "CanvasRenderingContext2D_transform_Callback";

  @DomName('CanvasRenderingContext2D.translate')
  @DocsEditable
  void translate(num tx, num ty) native "CanvasRenderingContext2D_translate_Callback";

  @DomName('CanvasRenderingContext2D.webkitGetImageDataHD')
  @DocsEditable
  ImageData webkitGetImageDataHD(num sx, num sy, num sw, num sh) native "CanvasRenderingContext2D_webkitGetImageDataHD_Callback";

  void webkitPutImageDataHD(ImageData imagedata, num dx, num dy, [num dirtyX, num dirtyY, num dirtyWidth, num dirtyHeight]) {
    if ((imagedata is ImageData || imagedata == null) && (dx is num || dx == null) && (dy is num || dy == null) && !?dirtyX && !?dirtyY && !?dirtyWidth && !?dirtyHeight) {
      _webkitPutImageDataHD_1(imagedata, dx, dy);
      return;
    }
    if ((imagedata is ImageData || imagedata == null) && (dx is num || dx == null) && (dy is num || dy == null) && (dirtyX is num || dirtyX == null) && (dirtyY is num || dirtyY == null) && (dirtyWidth is num || dirtyWidth == null) && (dirtyHeight is num || dirtyHeight == null)) {
      _webkitPutImageDataHD_2(imagedata, dx, dy, dirtyX, dirtyY, dirtyWidth, dirtyHeight);
      return;
    }
    throw new ArgumentError("Incorrect number or type of arguments");
  }

  @DomName('CanvasRenderingContext2D._webkitPutImageDataHD_1')
  @DocsEditable
  void _webkitPutImageDataHD_1(imagedata, dx, dy) native "CanvasRenderingContext2D__webkitPutImageDataHD_1_Callback";

  @DomName('CanvasRenderingContext2D._webkitPutImageDataHD_2')
  @DocsEditable
  void _webkitPutImageDataHD_2(imagedata, dx, dy, dirtyX, dirtyY, dirtyWidth, dirtyHeight) native "CanvasRenderingContext2D__webkitPutImageDataHD_2_Callback";


  /**
   * Sets the color used inside shapes.
   * [r], [g], [b] are 0-255, [a] is 0-1.
   */
  void setFillColorRgb(int r, int g, int b, [num a = 1]) {
    this.fillStyle = 'rgba($r, $g, $b, $a)';
  }

  /**
   * Sets the color used inside shapes.
   * [h] is in degrees, 0-360.
   * [s], [l] are in percent, 0-100.
   * [a] is 0-1.
   */
  void setFillColorHsl(int h, num s, num l, [num a = 1]) {
    this.fillStyle = 'hsla($h, $s%, $l%, $a)';
  }

  /**
   * Sets the color used for stroking shapes.
   * [r], [g], [b] are 0-255, [a] is 0-1.
   */
  void setStrokeColorRgb(int r, int g, int b, [num a = 1]) {
    this.strokeStyle = 'rgba($r, $g, $b, $a)';
  }

  /**
   * Sets the color used for stroking shapes.
   * [h] is in degrees, 0-360.
   * [s], [l] are in percent, 0-100.
   * [a] is 0-1.
   */
  void setStrokeColorHsl(int h, num s, num l, [num a = 1]) {
    this.strokeStyle = 'hsla($h, $s%, $l%, $a)';
  }
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('CharacterData')
class CharacterData extends Node {
  CharacterData.internal() : super.internal();

  @DomName('CharacterData.data')
  @DocsEditable
  String get data native "CharacterData_data_Getter";

  @DomName('CharacterData.data')
  @DocsEditable
  void set data(String value) native "CharacterData_data_Setter";

  @DomName('CharacterData.length')
  @DocsEditable
  int get length native "CharacterData_length_Getter";

  @DomName('CharacterData.appendData')
  @DocsEditable
  void appendData(String data) native "CharacterData_appendData_Callback";

  @DomName('CharacterData.deleteData')
  @DocsEditable
  void deleteData(int offset, int length) native "CharacterData_deleteData_Callback";

  @DomName('CharacterData.insertData')
  @DocsEditable
  void insertData(int offset, String data) native "CharacterData_insertData_Callback";

  @DomName('CharacterData.remove')
  @DocsEditable
  void remove() native "CharacterData_remove_Callback";

  @DomName('CharacterData.replaceData')
  @DocsEditable
  void replaceData(int offset, int length, String data) native "CharacterData_replaceData_Callback";

  @DomName('CharacterData.substringData')
  @DocsEditable
  String substringData(int offset, int length) native "CharacterData_substringData_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('ClientRect')
class ClientRect extends NativeFieldWrapperClass1 {
  ClientRect.internal();

  @DomName('ClientRect.bottom')
  @DocsEditable
  num get bottom native "ClientRect_bottom_Getter";

  @DomName('ClientRect.height')
  @DocsEditable
  num get height native "ClientRect_height_Getter";

  @DomName('ClientRect.left')
  @DocsEditable
  num get left native "ClientRect_left_Getter";

  @DomName('ClientRect.right')
  @DocsEditable
  num get right native "ClientRect_right_Getter";

  @DomName('ClientRect.top')
  @DocsEditable
  num get top native "ClientRect_top_Getter";

  @DomName('ClientRect.width')
  @DocsEditable
  num get width native "ClientRect_width_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('Clipboard')
class Clipboard extends NativeFieldWrapperClass1 {
  Clipboard.internal();

  @DomName('Clipboard.dropEffect')
  @DocsEditable
  String get dropEffect native "Clipboard_dropEffect_Getter";

  @DomName('Clipboard.dropEffect')
  @DocsEditable
  void set dropEffect(String value) native "Clipboard_dropEffect_Setter";

  @DomName('Clipboard.effectAllowed')
  @DocsEditable
  String get effectAllowed native "Clipboard_effectAllowed_Getter";

  @DomName('Clipboard.effectAllowed')
  @DocsEditable
  void set effectAllowed(String value) native "Clipboard_effectAllowed_Setter";

  @DomName('Clipboard.files')
  @DocsEditable
  List<File> get files native "Clipboard_files_Getter";

  @DomName('Clipboard.items')
  @DocsEditable
  DataTransferItemList get items native "Clipboard_items_Getter";

  @DomName('Clipboard.types')
  @DocsEditable
  List get types native "Clipboard_types_Getter";

  @DomName('Clipboard.clearData')
  @DocsEditable
  void clearData([String type]) native "Clipboard_clearData_Callback";

  @DomName('Clipboard.getData')
  @DocsEditable
  String getData(String type) native "Clipboard_getData_Callback";

  @DomName('Clipboard.setData')
  @DocsEditable
  bool setData(String type, String data) native "Clipboard_setData_Callback";

  @DomName('Clipboard.setDragImage')
  @DocsEditable
  void setDragImage(ImageElement image, int x, int y) native "Clipboard_setDragImage_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('CloseEvent')
class CloseEvent extends Event {
  CloseEvent.internal() : super.internal();

  @DomName('CloseEvent.code')
  @DocsEditable
  int get code native "CloseEvent_code_Getter";

  @DomName('CloseEvent.reason')
  @DocsEditable
  String get reason native "CloseEvent_reason_Getter";

  @DomName('CloseEvent.wasClean')
  @DocsEditable
  bool get wasClean native "CloseEvent_wasClean_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('Comment')
class Comment extends CharacterData {
  Comment.internal() : super.internal();

}
// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DomName('CompositionEvent')
class CompositionEvent extends UIEvent {
  factory CompositionEvent(String type,
      {bool canBubble: false, bool cancelable: false, Window view,
      String data}) {
    if (view == null) {
      view = window;
    }
    var e = document.$dom_createEvent("CompositionEvent");
    e.$dom_initCompositionEvent(type, canBubble, cancelable, view, data);
    return e;
  }
  CompositionEvent.internal() : super.internal();

  @DomName('CompositionEvent.data')
  @DocsEditable
  String get data native "CompositionEvent_data_Getter";

  @DomName('CompositionEvent.initCompositionEvent')
  @DocsEditable
  void $dom_initCompositionEvent(String typeArg, bool canBubbleArg, bool cancelableArg, Window viewArg, String dataArg) native "CompositionEvent_initCompositionEvent_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('Console')
class Console extends NativeFieldWrapperClass1 {
  Console.internal();

  @DomName('Console.memory')
  @DocsEditable
  MemoryInfo get memory native "Console_memory_Getter";

  @DomName('Console.profiles')
  @DocsEditable
  List<ScriptProfile> get profiles native "Console_profiles_Getter";

  @DomName('Console.assertCondition')
  @DocsEditable
  void assertCondition(bool condition, Object arg) native "Console_assertCondition_Callback";

  @DomName('Console.clear')
  @DocsEditable
  void clear(Object arg) native "Console_clear_Callback";

  @DomName('Console.count')
  @DocsEditable
  void count(Object arg) native "Console_count_Callback";

  @DomName('Console.debug')
  @DocsEditable
  void debug(Object arg) native "Console_debug_Callback";

  @DomName('Console.dir')
  @DocsEditable
  void dir(Object arg) native "Console_dir_Callback";

  @DomName('Console.dirxml')
  @DocsEditable
  void dirxml(Object arg) native "Console_dirxml_Callback";

  @DomName('Console.error')
  @DocsEditable
  void error(Object arg) native "Console_error_Callback";

  @DomName('Console.group')
  @DocsEditable
  void group(Object arg) native "Console_group_Callback";

  @DomName('Console.groupCollapsed')
  @DocsEditable
  void groupCollapsed(Object arg) native "Console_groupCollapsed_Callback";

  @DomName('Console.groupEnd')
  @DocsEditable
  void groupEnd() native "Console_groupEnd_Callback";

  @DomName('Console.info')
  @DocsEditable
  void info(Object arg) native "Console_info_Callback";

  @DomName('Console.log')
  @DocsEditable
  void log(Object arg) native "Console_log_Callback";

  @DomName('Console.markTimeline')
  @DocsEditable
  void markTimeline() native "Console_markTimeline_Callback";

  @DomName('Console.profile')
  @DocsEditable
  void profile(String title) native "Console_profile_Callback";

  @DomName('Console.profileEnd')
  @DocsEditable
  void profileEnd(String title) native "Console_profileEnd_Callback";

  @DomName('Console.time')
  @DocsEditable
  void time(String title) native "Console_time_Callback";

  @DomName('Console.timeEnd')
  @DocsEditable
  void timeEnd(String title) native "Console_timeEnd_Callback";

  @DomName('Console.timeStamp')
  @DocsEditable
  void timeStamp() native "Console_timeStamp_Callback";

  @DomName('Console.trace')
  @DocsEditable
  void trace(Object arg) native "Console_trace_Callback";

  @DomName('Console.warn')
  @DocsEditable
  void warn(Object arg) native "Console_warn_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('HTMLContentElement')
@SupportedBrowser(SupportedBrowser.CHROME, '25')
@Experimental
class ContentElement extends _Element_Merged {
  ContentElement.internal() : super.internal();

  @DocsEditable
  factory ContentElement() => document.$dom_createElement("content");

  /// Checks if this type is supported on the current platform.
  static bool get supported => true;

  @DomName('HTMLContentElement.resetStyleInheritance')
  @DocsEditable
  bool get resetStyleInheritance native "HTMLContentElement_resetStyleInheritance_Getter";

  @DomName('HTMLContentElement.resetStyleInheritance')
  @DocsEditable
  void set resetStyleInheritance(bool value) native "HTMLContentElement_resetStyleInheritance_Setter";

  @DomName('HTMLContentElement.select')
  @DocsEditable
  String get select native "HTMLContentElement_select_Getter";

  @DomName('HTMLContentElement.select')
  @DocsEditable
  void set select(String value) native "HTMLContentElement_select_Setter";

  @DomName('HTMLContentElement.getDistributedNodes')
  @DocsEditable
  List<Node> getDistributedNodes() native "HTMLContentElement_getDistributedNodes_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('Coordinates')
class Coordinates extends NativeFieldWrapperClass1 {
  Coordinates.internal();

  @DomName('Coordinates.accuracy')
  @DocsEditable
  num get accuracy native "Coordinates_accuracy_Getter";

  @DomName('Coordinates.altitude')
  @DocsEditable
  num get altitude native "Coordinates_altitude_Getter";

  @DomName('Coordinates.altitudeAccuracy')
  @DocsEditable
  num get altitudeAccuracy native "Coordinates_altitudeAccuracy_Getter";

  @DomName('Coordinates.heading')
  @DocsEditable
  num get heading native "Coordinates_heading_Getter";

  @DomName('Coordinates.latitude')
  @DocsEditable
  num get latitude native "Coordinates_latitude_Getter";

  @DomName('Coordinates.longitude')
  @DocsEditable
  num get longitude native "Coordinates_longitude_Getter";

  @DomName('Coordinates.speed')
  @DocsEditable
  num get speed native "Coordinates_speed_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('Counter')
class Counter extends NativeFieldWrapperClass1 {
  Counter.internal();

  @DomName('Counter.identifier')
  @DocsEditable
  String get identifier native "Counter_identifier_Getter";

  @DomName('Counter.listStyle')
  @DocsEditable
  String get listStyle native "Counter_listStyle_Getter";

  @DomName('Counter.separator')
  @DocsEditable
  String get separator native "Counter_separator_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('Crypto')
class Crypto extends NativeFieldWrapperClass1 {
  Crypto.internal();

  @DomName('Crypto.getRandomValues')
  @DocsEditable
  ArrayBufferView getRandomValues(ArrayBufferView array) native "Crypto_getRandomValues_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('CSSCharsetRule')
class CssCharsetRule extends CssRule {
  CssCharsetRule.internal() : super.internal();

  @DomName('CSSCharsetRule.encoding')
  @DocsEditable
  String get encoding native "CSSCharsetRule_encoding_Getter";

  @DomName('CSSCharsetRule.encoding')
  @DocsEditable
  void set encoding(String value) native "CSSCharsetRule_encoding_Setter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('CSSFontFaceRule')
class CssFontFaceRule extends CssRule {
  CssFontFaceRule.internal() : super.internal();

  @DomName('CSSFontFaceRule.style')
  @DocsEditable
  CssStyleDeclaration get style native "CSSFontFaceRule_style_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('CSSImportRule')
class CssImportRule extends CssRule {
  CssImportRule.internal() : super.internal();

  @DomName('CSSImportRule.href')
  @DocsEditable
  String get href native "CSSImportRule_href_Getter";

  @DomName('CSSImportRule.media')
  @DocsEditable
  MediaList get media native "CSSImportRule_media_Getter";

  @DomName('CSSImportRule.styleSheet')
  @DocsEditable
  CssStyleSheet get styleSheet native "CSSImportRule_styleSheet_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('WebKitCSSKeyframeRule')
class CssKeyframeRule extends CssRule {
  CssKeyframeRule.internal() : super.internal();

  @DomName('WebKitCSSKeyframeRule.keyText')
  @DocsEditable
  String get keyText native "WebKitCSSKeyframeRule_keyText_Getter";

  @DomName('WebKitCSSKeyframeRule.keyText')
  @DocsEditable
  void set keyText(String value) native "WebKitCSSKeyframeRule_keyText_Setter";

  @DomName('WebKitCSSKeyframeRule.style')
  @DocsEditable
  CssStyleDeclaration get style native "WebKitCSSKeyframeRule_style_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('WebKitCSSKeyframesRule')
class CssKeyframesRule extends CssRule {
  CssKeyframesRule.internal() : super.internal();

  @DomName('WebKitCSSKeyframesRule.cssRules')
  @DocsEditable
  List<CssRule> get cssRules native "WebKitCSSKeyframesRule_cssRules_Getter";

  @DomName('WebKitCSSKeyframesRule.name')
  @DocsEditable
  String get name native "WebKitCSSKeyframesRule_name_Getter";

  @DomName('WebKitCSSKeyframesRule.name')
  @DocsEditable
  void set name(String value) native "WebKitCSSKeyframesRule_name_Setter";

  @DomName('WebKitCSSKeyframesRule.deleteRule')
  @DocsEditable
  void deleteRule(String key) native "WebKitCSSKeyframesRule_deleteRule_Callback";

  @DomName('WebKitCSSKeyframesRule.findRule')
  @DocsEditable
  CssKeyframeRule findRule(String key) native "WebKitCSSKeyframesRule_findRule_Callback";

  @DomName('WebKitCSSKeyframesRule.insertRule')
  @DocsEditable
  void insertRule(String rule) native "WebKitCSSKeyframesRule_insertRule_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('WebKitCSSMatrix')
@SupportedBrowser(SupportedBrowser.CHROME)
@SupportedBrowser(SupportedBrowser.SAFARI)
@Experimental
class CssMatrix extends NativeFieldWrapperClass1 {
  CssMatrix.internal();

  @DocsEditable
  factory CssMatrix([String cssValue]) {
    if (!?cssValue) {
      return CssMatrix._create();
    }
    return CssMatrix._create(cssValue);
  }
  static CssMatrix _create([String cssValue]) native "WebKitCSSMatrix_constructor_Callback";

  /// Checks if this type is supported on the current platform.
  static bool get supported => true;

  @DomName('WebKitCSSMatrix.a')
  @DocsEditable
  num get a native "WebKitCSSMatrix_a_Getter";

  @DomName('WebKitCSSMatrix.a')
  @DocsEditable
  void set a(num value) native "WebKitCSSMatrix_a_Setter";

  @DomName('WebKitCSSMatrix.b')
  @DocsEditable
  num get b native "WebKitCSSMatrix_b_Getter";

  @DomName('WebKitCSSMatrix.b')
  @DocsEditable
  void set b(num value) native "WebKitCSSMatrix_b_Setter";

  @DomName('WebKitCSSMatrix.c')
  @DocsEditable
  num get c native "WebKitCSSMatrix_c_Getter";

  @DomName('WebKitCSSMatrix.c')
  @DocsEditable
  void set c(num value) native "WebKitCSSMatrix_c_Setter";

  @DomName('WebKitCSSMatrix.d')
  @DocsEditable
  num get d native "WebKitCSSMatrix_d_Getter";

  @DomName('WebKitCSSMatrix.d')
  @DocsEditable
  void set d(num value) native "WebKitCSSMatrix_d_Setter";

  @DomName('WebKitCSSMatrix.e')
  @DocsEditable
  num get e native "WebKitCSSMatrix_e_Getter";

  @DomName('WebKitCSSMatrix.e')
  @DocsEditable
  void set e(num value) native "WebKitCSSMatrix_e_Setter";

  @DomName('WebKitCSSMatrix.f')
  @DocsEditable
  num get f native "WebKitCSSMatrix_f_Getter";

  @DomName('WebKitCSSMatrix.f')
  @DocsEditable
  void set f(num value) native "WebKitCSSMatrix_f_Setter";

  @DomName('WebKitCSSMatrix.m11')
  @DocsEditable
  num get m11 native "WebKitCSSMatrix_m11_Getter";

  @DomName('WebKitCSSMatrix.m11')
  @DocsEditable
  void set m11(num value) native "WebKitCSSMatrix_m11_Setter";

  @DomName('WebKitCSSMatrix.m12')
  @DocsEditable
  num get m12 native "WebKitCSSMatrix_m12_Getter";

  @DomName('WebKitCSSMatrix.m12')
  @DocsEditable
  void set m12(num value) native "WebKitCSSMatrix_m12_Setter";

  @DomName('WebKitCSSMatrix.m13')
  @DocsEditable
  num get m13 native "WebKitCSSMatrix_m13_Getter";

  @DomName('WebKitCSSMatrix.m13')
  @DocsEditable
  void set m13(num value) native "WebKitCSSMatrix_m13_Setter";

  @DomName('WebKitCSSMatrix.m14')
  @DocsEditable
  num get m14 native "WebKitCSSMatrix_m14_Getter";

  @DomName('WebKitCSSMatrix.m14')
  @DocsEditable
  void set m14(num value) native "WebKitCSSMatrix_m14_Setter";

  @DomName('WebKitCSSMatrix.m21')
  @DocsEditable
  num get m21 native "WebKitCSSMatrix_m21_Getter";

  @DomName('WebKitCSSMatrix.m21')
  @DocsEditable
  void set m21(num value) native "WebKitCSSMatrix_m21_Setter";

  @DomName('WebKitCSSMatrix.m22')
  @DocsEditable
  num get m22 native "WebKitCSSMatrix_m22_Getter";

  @DomName('WebKitCSSMatrix.m22')
  @DocsEditable
  void set m22(num value) native "WebKitCSSMatrix_m22_Setter";

  @DomName('WebKitCSSMatrix.m23')
  @DocsEditable
  num get m23 native "WebKitCSSMatrix_m23_Getter";

  @DomName('WebKitCSSMatrix.m23')
  @DocsEditable
  void set m23(num value) native "WebKitCSSMatrix_m23_Setter";

  @DomName('WebKitCSSMatrix.m24')
  @DocsEditable
  num get m24 native "WebKitCSSMatrix_m24_Getter";

  @DomName('WebKitCSSMatrix.m24')
  @DocsEditable
  void set m24(num value) native "WebKitCSSMatrix_m24_Setter";

  @DomName('WebKitCSSMatrix.m31')
  @DocsEditable
  num get m31 native "WebKitCSSMatrix_m31_Getter";

  @DomName('WebKitCSSMatrix.m31')
  @DocsEditable
  void set m31(num value) native "WebKitCSSMatrix_m31_Setter";

  @DomName('WebKitCSSMatrix.m32')
  @DocsEditable
  num get m32 native "WebKitCSSMatrix_m32_Getter";

  @DomName('WebKitCSSMatrix.m32')
  @DocsEditable
  void set m32(num value) native "WebKitCSSMatrix_m32_Setter";

  @DomName('WebKitCSSMatrix.m33')
  @DocsEditable
  num get m33 native "WebKitCSSMatrix_m33_Getter";

  @DomName('WebKitCSSMatrix.m33')
  @DocsEditable
  void set m33(num value) native "WebKitCSSMatrix_m33_Setter";

  @DomName('WebKitCSSMatrix.m34')
  @DocsEditable
  num get m34 native "WebKitCSSMatrix_m34_Getter";

  @DomName('WebKitCSSMatrix.m34')
  @DocsEditable
  void set m34(num value) native "WebKitCSSMatrix_m34_Setter";

  @DomName('WebKitCSSMatrix.m41')
  @DocsEditable
  num get m41 native "WebKitCSSMatrix_m41_Getter";

  @DomName('WebKitCSSMatrix.m41')
  @DocsEditable
  void set m41(num value) native "WebKitCSSMatrix_m41_Setter";

  @DomName('WebKitCSSMatrix.m42')
  @DocsEditable
  num get m42 native "WebKitCSSMatrix_m42_Getter";

  @DomName('WebKitCSSMatrix.m42')
  @DocsEditable
  void set m42(num value) native "WebKitCSSMatrix_m42_Setter";

  @DomName('WebKitCSSMatrix.m43')
  @DocsEditable
  num get m43 native "WebKitCSSMatrix_m43_Getter";

  @DomName('WebKitCSSMatrix.m43')
  @DocsEditable
  void set m43(num value) native "WebKitCSSMatrix_m43_Setter";

  @DomName('WebKitCSSMatrix.m44')
  @DocsEditable
  num get m44 native "WebKitCSSMatrix_m44_Getter";

  @DomName('WebKitCSSMatrix.m44')
  @DocsEditable
  void set m44(num value) native "WebKitCSSMatrix_m44_Setter";

  @DomName('WebKitCSSMatrix.inverse')
  @DocsEditable
  CssMatrix inverse() native "WebKitCSSMatrix_inverse_Callback";

  @DomName('WebKitCSSMatrix.multiply')
  @DocsEditable
  CssMatrix multiply(CssMatrix secondMatrix) native "WebKitCSSMatrix_multiply_Callback";

  @DomName('WebKitCSSMatrix.rotate')
  @DocsEditable
  CssMatrix rotate(num rotX, num rotY, num rotZ) native "WebKitCSSMatrix_rotate_Callback";

  @DomName('WebKitCSSMatrix.rotateAxisAngle')
  @DocsEditable
  CssMatrix rotateAxisAngle(num x, num y, num z, num angle) native "WebKitCSSMatrix_rotateAxisAngle_Callback";

  @DomName('WebKitCSSMatrix.scale')
  @DocsEditable
  CssMatrix scale(num scaleX, num scaleY, num scaleZ) native "WebKitCSSMatrix_scale_Callback";

  @DomName('WebKitCSSMatrix.setMatrixValue')
  @DocsEditable
  void setMatrixValue(String string) native "WebKitCSSMatrix_setMatrixValue_Callback";

  @DomName('WebKitCSSMatrix.skewX')
  @DocsEditable
  CssMatrix skewX(num angle) native "WebKitCSSMatrix_skewX_Callback";

  @DomName('WebKitCSSMatrix.skewY')
  @DocsEditable
  CssMatrix skewY(num angle) native "WebKitCSSMatrix_skewY_Callback";

  @DomName('WebKitCSSMatrix.toString')
  @DocsEditable
  String toString() native "WebKitCSSMatrix_toString_Callback";

  @DomName('WebKitCSSMatrix.translate')
  @DocsEditable
  CssMatrix translate(num x, num y, num z) native "WebKitCSSMatrix_translate_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('CSSMediaRule')
class CssMediaRule extends CssRule {
  CssMediaRule.internal() : super.internal();

  @DomName('CSSMediaRule.cssRules')
  @DocsEditable
  List<CssRule> get cssRules native "CSSMediaRule_cssRules_Getter";

  @DomName('CSSMediaRule.media')
  @DocsEditable
  MediaList get media native "CSSMediaRule_media_Getter";

  @DomName('CSSMediaRule.deleteRule')
  @DocsEditable
  void deleteRule(int index) native "CSSMediaRule_deleteRule_Callback";

  @DomName('CSSMediaRule.insertRule')
  @DocsEditable
  int insertRule(String rule, int index) native "CSSMediaRule_insertRule_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('CSSPageRule')
class CssPageRule extends CssRule {
  CssPageRule.internal() : super.internal();

  @DomName('CSSPageRule.selectorText')
  @DocsEditable
  String get selectorText native "CSSPageRule_selectorText_Getter";

  @DomName('CSSPageRule.selectorText')
  @DocsEditable
  void set selectorText(String value) native "CSSPageRule_selectorText_Setter";

  @DomName('CSSPageRule.style')
  @DocsEditable
  CssStyleDeclaration get style native "CSSPageRule_style_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('CSSPrimitiveValue')
class CssPrimitiveValue extends CssValue {
  CssPrimitiveValue.internal() : super.internal();

  static const int CSS_ATTR = 22;

  static const int CSS_CM = 6;

  static const int CSS_COUNTER = 23;

  static const int CSS_DEG = 11;

  static const int CSS_DIMENSION = 18;

  static const int CSS_EMS = 3;

  static const int CSS_EXS = 4;

  static const int CSS_GRAD = 13;

  static const int CSS_HZ = 16;

  static const int CSS_IDENT = 21;

  static const int CSS_IN = 8;

  static const int CSS_KHZ = 17;

  static const int CSS_MM = 7;

  static const int CSS_MS = 14;

  static const int CSS_NUMBER = 1;

  static const int CSS_PC = 10;

  static const int CSS_PERCENTAGE = 2;

  static const int CSS_PT = 9;

  static const int CSS_PX = 5;

  static const int CSS_RAD = 12;

  static const int CSS_RECT = 24;

  static const int CSS_RGBCOLOR = 25;

  static const int CSS_S = 15;

  static const int CSS_STRING = 19;

  static const int CSS_UNKNOWN = 0;

  static const int CSS_URI = 20;

  static const int CSS_VH = 27;

  static const int CSS_VMIN = 28;

  static const int CSS_VW = 26;

  @DomName('CSSPrimitiveValue.primitiveType')
  @DocsEditable
  int get primitiveType native "CSSPrimitiveValue_primitiveType_Getter";

  @DomName('CSSPrimitiveValue.getCounterValue')
  @DocsEditable
  Counter getCounterValue() native "CSSPrimitiveValue_getCounterValue_Callback";

  @DomName('CSSPrimitiveValue.getFloatValue')
  @DocsEditable
  num getFloatValue(int unitType) native "CSSPrimitiveValue_getFloatValue_Callback";

  @DomName('CSSPrimitiveValue.getRGBColorValue')
  @DocsEditable
  RgbColor getRgbColorValue() native "CSSPrimitiveValue_getRGBColorValue_Callback";

  @DomName('CSSPrimitiveValue.getRectValue')
  @DocsEditable
  Rect getRectValue() native "CSSPrimitiveValue_getRectValue_Callback";

  @DomName('CSSPrimitiveValue.getStringValue')
  @DocsEditable
  String getStringValue() native "CSSPrimitiveValue_getStringValue_Callback";

  @DomName('CSSPrimitiveValue.setFloatValue')
  @DocsEditable
  void setFloatValue(int unitType, num floatValue) native "CSSPrimitiveValue_setFloatValue_Callback";

  @DomName('CSSPrimitiveValue.setStringValue')
  @DocsEditable
  void setStringValue(int stringType, String stringValue) native "CSSPrimitiveValue_setStringValue_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('CSSRule')
class CssRule extends NativeFieldWrapperClass1 {
  CssRule.internal();

  static const int CHARSET_RULE = 2;

  static const int FONT_FACE_RULE = 5;

  static const int IMPORT_RULE = 3;

  static const int MEDIA_RULE = 4;

  static const int PAGE_RULE = 6;

  static const int STYLE_RULE = 1;

  static const int UNKNOWN_RULE = 0;

  static const int WEBKIT_KEYFRAMES_RULE = 7;

  static const int WEBKIT_KEYFRAME_RULE = 8;

  @DomName('CSSRule.cssText')
  @DocsEditable
  String get cssText native "CSSRule_cssText_Getter";

  @DomName('CSSRule.cssText')
  @DocsEditable
  void set cssText(String value) native "CSSRule_cssText_Setter";

  @DomName('CSSRule.parentRule')
  @DocsEditable
  CssRule get parentRule native "CSSRule_parentRule_Getter";

  @DomName('CSSRule.parentStyleSheet')
  @DocsEditable
  CssStyleSheet get parentStyleSheet native "CSSRule_parentStyleSheet_Getter";

  @DomName('CSSRule.type')
  @DocsEditable
  int get type native "CSSRule_type_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.


String _cachedBrowserPrefix;

String get _browserPrefix {
  if (_cachedBrowserPrefix == null) {
    if (_Device.isFirefox) {
      _cachedBrowserPrefix = '-moz-';
    } else if (_Device.isIE) {
      _cachedBrowserPrefix = '-ms-';
    } else if (_Device.isOpera) {
      _cachedBrowserPrefix = '-o-';
    } else {
      _cachedBrowserPrefix = '-webkit-';
    }
  }
  return _cachedBrowserPrefix;
}

@DomName('CSSStyleDeclaration')
class CssStyleDeclaration extends NativeFieldWrapperClass1 {
  factory CssStyleDeclaration() => _CssStyleDeclarationFactoryProvider.createCssStyleDeclaration();
  factory CssStyleDeclaration.css(String css) =>
      _CssStyleDeclarationFactoryProvider.createCssStyleDeclaration_css(css);

  CssStyleDeclaration.internal();

  @DomName('CSSStyleDeclaration.cssText')
  @DocsEditable
  String get cssText native "CSSStyleDeclaration_cssText_Getter";

  @DomName('CSSStyleDeclaration.cssText')
  @DocsEditable
  void set cssText(String value) native "CSSStyleDeclaration_cssText_Setter";

  @DomName('CSSStyleDeclaration.length')
  @DocsEditable
  int get length native "CSSStyleDeclaration_length_Getter";

  @DomName('CSSStyleDeclaration.parentRule')
  @DocsEditable
  CssRule get parentRule native "CSSStyleDeclaration_parentRule_Getter";

  @DomName('CSSStyleDeclaration.getPropertyCSSValue')
  @DocsEditable
  CssValue getPropertyCssValue(String propertyName) native "CSSStyleDeclaration_getPropertyCSSValue_Callback";

  @DomName('CSSStyleDeclaration.getPropertyPriority')
  @DocsEditable
  String getPropertyPriority(String propertyName) native "CSSStyleDeclaration_getPropertyPriority_Callback";

  @DomName('CSSStyleDeclaration.getPropertyShorthand')
  @DocsEditable
  String getPropertyShorthand(String propertyName) native "CSSStyleDeclaration_getPropertyShorthand_Callback";

  @DomName('CSSStyleDeclaration._getPropertyValue')
  @DocsEditable
  String _getPropertyValue(String propertyName) native "CSSStyleDeclaration__getPropertyValue_Callback";

  @DomName('CSSStyleDeclaration.isPropertyImplicit')
  @DocsEditable
  bool isPropertyImplicit(String propertyName) native "CSSStyleDeclaration_isPropertyImplicit_Callback";

  @DomName('CSSStyleDeclaration.item')
  @DocsEditable
  String item(int index) native "CSSStyleDeclaration_item_Callback";

  @DomName('CSSStyleDeclaration.removeProperty')
  @DocsEditable
  String removeProperty(String propertyName) native "CSSStyleDeclaration_removeProperty_Callback";

  @DomName('CSSStyleDeclaration.setProperty')
  @DocsEditable
  void setProperty(String propertyName, String value, [String priority]) native "CSSStyleDeclaration_setProperty_Callback";


  String getPropertyValue(String propertyName) {
    var propValue = _getPropertyValue(propertyName);
    return propValue != null ? propValue : '';
  }


  // TODO(jacobr): generate this list of properties using the existing script.
  /** Gets the value of "align-content" */
  String get alignContent =>
    getPropertyValue('${_browserPrefix}align-content');

  /** Sets the value of "align-content" */
  void set alignContent(String value) {
    setProperty('${_browserPrefix}align-content', value, '');
  }

  /** Gets the value of "align-items" */
  String get alignItems =>
    getPropertyValue('${_browserPrefix}align-items');

  /** Sets the value of "align-items" */
  void set alignItems(String value) {
    setProperty('${_browserPrefix}align-items', value, '');
  }

  /** Gets the value of "align-self" */
  String get alignSelf =>
    getPropertyValue('${_browserPrefix}align-self');

  /** Sets the value of "align-self" */
  void set alignSelf(String value) {
    setProperty('${_browserPrefix}align-self', value, '');
  }

  /** Gets the value of "animation" */
  String get animation =>
    getPropertyValue('${_browserPrefix}animation');

  /** Sets the value of "animation" */
  void set animation(String value) {
    setProperty('${_browserPrefix}animation', value, '');
  }

  /** Gets the value of "animation-delay" */
  String get animationDelay =>
    getPropertyValue('${_browserPrefix}animation-delay');

  /** Sets the value of "animation-delay" */
  void set animationDelay(String value) {
    setProperty('${_browserPrefix}animation-delay', value, '');
  }

  /** Gets the value of "animation-direction" */
  String get animationDirection =>
    getPropertyValue('${_browserPrefix}animation-direction');

  /** Sets the value of "animation-direction" */
  void set animationDirection(String value) {
    setProperty('${_browserPrefix}animation-direction', value, '');
  }

  /** Gets the value of "animation-duration" */
  String get animationDuration =>
    getPropertyValue('${_browserPrefix}animation-duration');

  /** Sets the value of "animation-duration" */
  void set animationDuration(String value) {
    setProperty('${_browserPrefix}animation-duration', value, '');
  }

  /** Gets the value of "animation-fill-mode" */
  String get animationFillMode =>
    getPropertyValue('${_browserPrefix}animation-fill-mode');

  /** Sets the value of "animation-fill-mode" */
  void set animationFillMode(String value) {
    setProperty('${_browserPrefix}animation-fill-mode', value, '');
  }

  /** Gets the value of "animation-iteration-count" */
  String get animationIterationCount =>
    getPropertyValue('${_browserPrefix}animation-iteration-count');

  /** Sets the value of "animation-iteration-count" */
  void set animationIterationCount(String value) {
    setProperty('${_browserPrefix}animation-iteration-count', value, '');
  }

  /** Gets the value of "animation-name" */
  String get animationName =>
    getPropertyValue('${_browserPrefix}animation-name');

  /** Sets the value of "animation-name" */
  void set animationName(String value) {
    setProperty('${_browserPrefix}animation-name', value, '');
  }

  /** Gets the value of "animation-play-state" */
  String get animationPlayState =>
    getPropertyValue('${_browserPrefix}animation-play-state');

  /** Sets the value of "animation-play-state" */
  void set animationPlayState(String value) {
    setProperty('${_browserPrefix}animation-play-state', value, '');
  }

  /** Gets the value of "animation-timing-function" */
  String get animationTimingFunction =>
    getPropertyValue('${_browserPrefix}animation-timing-function');

  /** Sets the value of "animation-timing-function" */
  void set animationTimingFunction(String value) {
    setProperty('${_browserPrefix}animation-timing-function', value, '');
  }

  /** Gets the value of "app-region" */
  String get appRegion =>
    getPropertyValue('${_browserPrefix}app-region');

  /** Sets the value of "app-region" */
  void set appRegion(String value) {
    setProperty('${_browserPrefix}app-region', value, '');
  }

  /** Gets the value of "appearance" */
  String get appearance =>
    getPropertyValue('${_browserPrefix}appearance');

  /** Sets the value of "appearance" */
  void set appearance(String value) {
    setProperty('${_browserPrefix}appearance', value, '');
  }

  /** Gets the value of "aspect-ratio" */
  String get aspectRatio =>
    getPropertyValue('${_browserPrefix}aspect-ratio');

  /** Sets the value of "aspect-ratio" */
  void set aspectRatio(String value) {
    setProperty('${_browserPrefix}aspect-ratio', value, '');
  }

  /** Gets the value of "backface-visibility" */
  String get backfaceVisibility =>
    getPropertyValue('${_browserPrefix}backface-visibility');

  /** Sets the value of "backface-visibility" */
  void set backfaceVisibility(String value) {
    setProperty('${_browserPrefix}backface-visibility', value, '');
  }

  /** Gets the value of "background" */
  String get background =>
    getPropertyValue('background');

  /** Sets the value of "background" */
  void set background(String value) {
    setProperty('background', value, '');
  }

  /** Gets the value of "background-attachment" */
  String get backgroundAttachment =>
    getPropertyValue('background-attachment');

  /** Sets the value of "background-attachment" */
  void set backgroundAttachment(String value) {
    setProperty('background-attachment', value, '');
  }

  /** Gets the value of "background-clip" */
  String get backgroundClip =>
    getPropertyValue('background-clip');

  /** Sets the value of "background-clip" */
  void set backgroundClip(String value) {
    setProperty('background-clip', value, '');
  }

  /** Gets the value of "background-color" */
  String get backgroundColor =>
    getPropertyValue('background-color');

  /** Sets the value of "background-color" */
  void set backgroundColor(String value) {
    setProperty('background-color', value, '');
  }

  /** Gets the value of "background-composite" */
  String get backgroundComposite =>
    getPropertyValue('${_browserPrefix}background-composite');

  /** Sets the value of "background-composite" */
  void set backgroundComposite(String value) {
    setProperty('${_browserPrefix}background-composite', value, '');
  }

  /** Gets the value of "background-image" */
  String get backgroundImage =>
    getPropertyValue('background-image');

  /** Sets the value of "background-image" */
  void set backgroundImage(String value) {
    setProperty('background-image', value, '');
  }

  /** Gets the value of "background-origin" */
  String get backgroundOrigin =>
    getPropertyValue('background-origin');

  /** Sets the value of "background-origin" */
  void set backgroundOrigin(String value) {
    setProperty('background-origin', value, '');
  }

  /** Gets the value of "background-position" */
  String get backgroundPosition =>
    getPropertyValue('background-position');

  /** Sets the value of "background-position" */
  void set backgroundPosition(String value) {
    setProperty('background-position', value, '');
  }

  /** Gets the value of "background-position-x" */
  String get backgroundPositionX =>
    getPropertyValue('background-position-x');

  /** Sets the value of "background-position-x" */
  void set backgroundPositionX(String value) {
    setProperty('background-position-x', value, '');
  }

  /** Gets the value of "background-position-y" */
  String get backgroundPositionY =>
    getPropertyValue('background-position-y');

  /** Sets the value of "background-position-y" */
  void set backgroundPositionY(String value) {
    setProperty('background-position-y', value, '');
  }

  /** Gets the value of "background-repeat" */
  String get backgroundRepeat =>
    getPropertyValue('background-repeat');

  /** Sets the value of "background-repeat" */
  void set backgroundRepeat(String value) {
    setProperty('background-repeat', value, '');
  }

  /** Gets the value of "background-repeat-x" */
  String get backgroundRepeatX =>
    getPropertyValue('background-repeat-x');

  /** Sets the value of "background-repeat-x" */
  void set backgroundRepeatX(String value) {
    setProperty('background-repeat-x', value, '');
  }

  /** Gets the value of "background-repeat-y" */
  String get backgroundRepeatY =>
    getPropertyValue('background-repeat-y');

  /** Sets the value of "background-repeat-y" */
  void set backgroundRepeatY(String value) {
    setProperty('background-repeat-y', value, '');
  }

  /** Gets the value of "background-size" */
  String get backgroundSize =>
    getPropertyValue('background-size');

  /** Sets the value of "background-size" */
  void set backgroundSize(String value) {
    setProperty('background-size', value, '');
  }

  /** Gets the value of "blend-mode" */
  String get blendMode =>
    getPropertyValue('${_browserPrefix}blend-mode');

  /** Sets the value of "blend-mode" */
  void set blendMode(String value) {
    setProperty('${_browserPrefix}blend-mode', value, '');
  }

  /** Gets the value of "border" */
  String get border =>
    getPropertyValue('border');

  /** Sets the value of "border" */
  void set border(String value) {
    setProperty('border', value, '');
  }

  /** Gets the value of "border-after" */
  String get borderAfter =>
    getPropertyValue('${_browserPrefix}border-after');

  /** Sets the value of "border-after" */
  void set borderAfter(String value) {
    setProperty('${_browserPrefix}border-after', value, '');
  }

  /** Gets the value of "border-after-color" */
  String get borderAfterColor =>
    getPropertyValue('${_browserPrefix}border-after-color');

  /** Sets the value of "border-after-color" */
  void set borderAfterColor(String value) {
    setProperty('${_browserPrefix}border-after-color', value, '');
  }

  /** Gets the value of "border-after-style" */
  String get borderAfterStyle =>
    getPropertyValue('${_browserPrefix}border-after-style');

  /** Sets the value of "border-after-style" */
  void set borderAfterStyle(String value) {
    setProperty('${_browserPrefix}border-after-style', value, '');
  }

  /** Gets the value of "border-after-width" */
  String get borderAfterWidth =>
    getPropertyValue('${_browserPrefix}border-after-width');

  /** Sets the value of "border-after-width" */
  void set borderAfterWidth(String value) {
    setProperty('${_browserPrefix}border-after-width', value, '');
  }

  /** Gets the value of "border-before" */
  String get borderBefore =>
    getPropertyValue('${_browserPrefix}border-before');

  /** Sets the value of "border-before" */
  void set borderBefore(String value) {
    setProperty('${_browserPrefix}border-before', value, '');
  }

  /** Gets the value of "border-before-color" */
  String get borderBeforeColor =>
    getPropertyValue('${_browserPrefix}border-before-color');

  /** Sets the value of "border-before-color" */
  void set borderBeforeColor(String value) {
    setProperty('${_browserPrefix}border-before-color', value, '');
  }

  /** Gets the value of "border-before-style" */
  String get borderBeforeStyle =>
    getPropertyValue('${_browserPrefix}border-before-style');

  /** Sets the value of "border-before-style" */
  void set borderBeforeStyle(String value) {
    setProperty('${_browserPrefix}border-before-style', value, '');
  }

  /** Gets the value of "border-before-width" */
  String get borderBeforeWidth =>
    getPropertyValue('${_browserPrefix}border-before-width');

  /** Sets the value of "border-before-width" */
  void set borderBeforeWidth(String value) {
    setProperty('${_browserPrefix}border-before-width', value, '');
  }

  /** Gets the value of "border-bottom" */
  String get borderBottom =>
    getPropertyValue('border-bottom');

  /** Sets the value of "border-bottom" */
  void set borderBottom(String value) {
    setProperty('border-bottom', value, '');
  }

  /** Gets the value of "border-bottom-color" */
  String get borderBottomColor =>
    getPropertyValue('border-bottom-color');

  /** Sets the value of "border-bottom-color" */
  void set borderBottomColor(String value) {
    setProperty('border-bottom-color', value, '');
  }

  /** Gets the value of "border-bottom-left-radius" */
  String get borderBottomLeftRadius =>
    getPropertyValue('border-bottom-left-radius');

  /** Sets the value of "border-bottom-left-radius" */
  void set borderBottomLeftRadius(String value) {
    setProperty('border-bottom-left-radius', value, '');
  }

  /** Gets the value of "border-bottom-right-radius" */
  String get borderBottomRightRadius =>
    getPropertyValue('border-bottom-right-radius');

  /** Sets the value of "border-bottom-right-radius" */
  void set borderBottomRightRadius(String value) {
    setProperty('border-bottom-right-radius', value, '');
  }

  /** Gets the value of "border-bottom-style" */
  String get borderBottomStyle =>
    getPropertyValue('border-bottom-style');

  /** Sets the value of "border-bottom-style" */
  void set borderBottomStyle(String value) {
    setProperty('border-bottom-style', value, '');
  }

  /** Gets the value of "border-bottom-width" */
  String get borderBottomWidth =>
    getPropertyValue('border-bottom-width');

  /** Sets the value of "border-bottom-width" */
  void set borderBottomWidth(String value) {
    setProperty('border-bottom-width', value, '');
  }

  /** Gets the value of "border-collapse" */
  String get borderCollapse =>
    getPropertyValue('border-collapse');

  /** Sets the value of "border-collapse" */
  void set borderCollapse(String value) {
    setProperty('border-collapse', value, '');
  }

  /** Gets the value of "border-color" */
  String get borderColor =>
    getPropertyValue('border-color');

  /** Sets the value of "border-color" */
  void set borderColor(String value) {
    setProperty('border-color', value, '');
  }

  /** Gets the value of "border-end" */
  String get borderEnd =>
    getPropertyValue('${_browserPrefix}border-end');

  /** Sets the value of "border-end" */
  void set borderEnd(String value) {
    setProperty('${_browserPrefix}border-end', value, '');
  }

  /** Gets the value of "border-end-color" */
  String get borderEndColor =>
    getPropertyValue('${_browserPrefix}border-end-color');

  /** Sets the value of "border-end-color" */
  void set borderEndColor(String value) {
    setProperty('${_browserPrefix}border-end-color', value, '');
  }

  /** Gets the value of "border-end-style" */
  String get borderEndStyle =>
    getPropertyValue('${_browserPrefix}border-end-style');

  /** Sets the value of "border-end-style" */
  void set borderEndStyle(String value) {
    setProperty('${_browserPrefix}border-end-style', value, '');
  }

  /** Gets the value of "border-end-width" */
  String get borderEndWidth =>
    getPropertyValue('${_browserPrefix}border-end-width');

  /** Sets the value of "border-end-width" */
  void set borderEndWidth(String value) {
    setProperty('${_browserPrefix}border-end-width', value, '');
  }

  /** Gets the value of "border-fit" */
  String get borderFit =>
    getPropertyValue('${_browserPrefix}border-fit');

  /** Sets the value of "border-fit" */
  void set borderFit(String value) {
    setProperty('${_browserPrefix}border-fit', value, '');
  }

  /** Gets the value of "border-horizontal-spacing" */
  String get borderHorizontalSpacing =>
    getPropertyValue('${_browserPrefix}border-horizontal-spacing');

  /** Sets the value of "border-horizontal-spacing" */
  void set borderHorizontalSpacing(String value) {
    setProperty('${_browserPrefix}border-horizontal-spacing', value, '');
  }

  /** Gets the value of "border-image" */
  String get borderImage =>
    getPropertyValue('border-image');

  /** Sets the value of "border-image" */
  void set borderImage(String value) {
    setProperty('border-image', value, '');
  }

  /** Gets the value of "border-image-outset" */
  String get borderImageOutset =>
    getPropertyValue('border-image-outset');

  /** Sets the value of "border-image-outset" */
  void set borderImageOutset(String value) {
    setProperty('border-image-outset', value, '');
  }

  /** Gets the value of "border-image-repeat" */
  String get borderImageRepeat =>
    getPropertyValue('border-image-repeat');

  /** Sets the value of "border-image-repeat" */
  void set borderImageRepeat(String value) {
    setProperty('border-image-repeat', value, '');
  }

  /** Gets the value of "border-image-slice" */
  String get borderImageSlice =>
    getPropertyValue('border-image-slice');

  /** Sets the value of "border-image-slice" */
  void set borderImageSlice(String value) {
    setProperty('border-image-slice', value, '');
  }

  /** Gets the value of "border-image-source" */
  String get borderImageSource =>
    getPropertyValue('border-image-source');

  /** Sets the value of "border-image-source" */
  void set borderImageSource(String value) {
    setProperty('border-image-source', value, '');
  }

  /** Gets the value of "border-image-width" */
  String get borderImageWidth =>
    getPropertyValue('border-image-width');

  /** Sets the value of "border-image-width" */
  void set borderImageWidth(String value) {
    setProperty('border-image-width', value, '');
  }

  /** Gets the value of "border-left" */
  String get borderLeft =>
    getPropertyValue('border-left');

  /** Sets the value of "border-left" */
  void set borderLeft(String value) {
    setProperty('border-left', value, '');
  }

  /** Gets the value of "border-left-color" */
  String get borderLeftColor =>
    getPropertyValue('border-left-color');

  /** Sets the value of "border-left-color" */
  void set borderLeftColor(String value) {
    setProperty('border-left-color', value, '');
  }

  /** Gets the value of "border-left-style" */
  String get borderLeftStyle =>
    getPropertyValue('border-left-style');

  /** Sets the value of "border-left-style" */
  void set borderLeftStyle(String value) {
    setProperty('border-left-style', value, '');
  }

  /** Gets the value of "border-left-width" */
  String get borderLeftWidth =>
    getPropertyValue('border-left-width');

  /** Sets the value of "border-left-width" */
  void set borderLeftWidth(String value) {
    setProperty('border-left-width', value, '');
  }

  /** Gets the value of "border-radius" */
  String get borderRadius =>
    getPropertyValue('border-radius');

  /** Sets the value of "border-radius" */
  void set borderRadius(String value) {
    setProperty('border-radius', value, '');
  }

  /** Gets the value of "border-right" */
  String get borderRight =>
    getPropertyValue('border-right');

  /** Sets the value of "border-right" */
  void set borderRight(String value) {
    setProperty('border-right', value, '');
  }

  /** Gets the value of "border-right-color" */
  String get borderRightColor =>
    getPropertyValue('border-right-color');

  /** Sets the value of "border-right-color" */
  void set borderRightColor(String value) {
    setProperty('border-right-color', value, '');
  }

  /** Gets the value of "border-right-style" */
  String get borderRightStyle =>
    getPropertyValue('border-right-style');

  /** Sets the value of "border-right-style" */
  void set borderRightStyle(String value) {
    setProperty('border-right-style', value, '');
  }

  /** Gets the value of "border-right-width" */
  String get borderRightWidth =>
    getPropertyValue('border-right-width');

  /** Sets the value of "border-right-width" */
  void set borderRightWidth(String value) {
    setProperty('border-right-width', value, '');
  }

  /** Gets the value of "border-spacing" */
  String get borderSpacing =>
    getPropertyValue('border-spacing');

  /** Sets the value of "border-spacing" */
  void set borderSpacing(String value) {
    setProperty('border-spacing', value, '');
  }

  /** Gets the value of "border-start" */
  String get borderStart =>
    getPropertyValue('${_browserPrefix}border-start');

  /** Sets the value of "border-start" */
  void set borderStart(String value) {
    setProperty('${_browserPrefix}border-start', value, '');
  }

  /** Gets the value of "border-start-color" */
  String get borderStartColor =>
    getPropertyValue('${_browserPrefix}border-start-color');

  /** Sets the value of "border-start-color" */
  void set borderStartColor(String value) {
    setProperty('${_browserPrefix}border-start-color', value, '');
  }

  /** Gets the value of "border-start-style" */
  String get borderStartStyle =>
    getPropertyValue('${_browserPrefix}border-start-style');

  /** Sets the value of "border-start-style" */
  void set borderStartStyle(String value) {
    setProperty('${_browserPrefix}border-start-style', value, '');
  }

  /** Gets the value of "border-start-width" */
  String get borderStartWidth =>
    getPropertyValue('${_browserPrefix}border-start-width');

  /** Sets the value of "border-start-width" */
  void set borderStartWidth(String value) {
    setProperty('${_browserPrefix}border-start-width', value, '');
  }

  /** Gets the value of "border-style" */
  String get borderStyle =>
    getPropertyValue('border-style');

  /** Sets the value of "border-style" */
  void set borderStyle(String value) {
    setProperty('border-style', value, '');
  }

  /** Gets the value of "border-top" */
  String get borderTop =>
    getPropertyValue('border-top');

  /** Sets the value of "border-top" */
  void set borderTop(String value) {
    setProperty('border-top', value, '');
  }

  /** Gets the value of "border-top-color" */
  String get borderTopColor =>
    getPropertyValue('border-top-color');

  /** Sets the value of "border-top-color" */
  void set borderTopColor(String value) {
    setProperty('border-top-color', value, '');
  }

  /** Gets the value of "border-top-left-radius" */
  String get borderTopLeftRadius =>
    getPropertyValue('border-top-left-radius');

  /** Sets the value of "border-top-left-radius" */
  void set borderTopLeftRadius(String value) {
    setProperty('border-top-left-radius', value, '');
  }

  /** Gets the value of "border-top-right-radius" */
  String get borderTopRightRadius =>
    getPropertyValue('border-top-right-radius');

  /** Sets the value of "border-top-right-radius" */
  void set borderTopRightRadius(String value) {
    setProperty('border-top-right-radius', value, '');
  }

  /** Gets the value of "border-top-style" */
  String get borderTopStyle =>
    getPropertyValue('border-top-style');

  /** Sets the value of "border-top-style" */
  void set borderTopStyle(String value) {
    setProperty('border-top-style', value, '');
  }

  /** Gets the value of "border-top-width" */
  String get borderTopWidth =>
    getPropertyValue('border-top-width');

  /** Sets the value of "border-top-width" */
  void set borderTopWidth(String value) {
    setProperty('border-top-width', value, '');
  }

  /** Gets the value of "border-vertical-spacing" */
  String get borderVerticalSpacing =>
    getPropertyValue('${_browserPrefix}border-vertical-spacing');

  /** Sets the value of "border-vertical-spacing" */
  void set borderVerticalSpacing(String value) {
    setProperty('${_browserPrefix}border-vertical-spacing', value, '');
  }

  /** Gets the value of "border-width" */
  String get borderWidth =>
    getPropertyValue('border-width');

  /** Sets the value of "border-width" */
  void set borderWidth(String value) {
    setProperty('border-width', value, '');
  }

  /** Gets the value of "bottom" */
  String get bottom =>
    getPropertyValue('bottom');

  /** Sets the value of "bottom" */
  void set bottom(String value) {
    setProperty('bottom', value, '');
  }

  /** Gets the value of "box-align" */
  String get boxAlign =>
    getPropertyValue('${_browserPrefix}box-align');

  /** Sets the value of "box-align" */
  void set boxAlign(String value) {
    setProperty('${_browserPrefix}box-align', value, '');
  }

  /** Gets the value of "box-decoration-break" */
  String get boxDecorationBreak =>
    getPropertyValue('${_browserPrefix}box-decoration-break');

  /** Sets the value of "box-decoration-break" */
  void set boxDecorationBreak(String value) {
    setProperty('${_browserPrefix}box-decoration-break', value, '');
  }

  /** Gets the value of "box-direction" */
  String get boxDirection =>
    getPropertyValue('${_browserPrefix}box-direction');

  /** Sets the value of "box-direction" */
  void set boxDirection(String value) {
    setProperty('${_browserPrefix}box-direction', value, '');
  }

  /** Gets the value of "box-flex" */
  String get boxFlex =>
    getPropertyValue('${_browserPrefix}box-flex');

  /** Sets the value of "box-flex" */
  void set boxFlex(String value) {
    setProperty('${_browserPrefix}box-flex', value, '');
  }

  /** Gets the value of "box-flex-group" */
  String get boxFlexGroup =>
    getPropertyValue('${_browserPrefix}box-flex-group');

  /** Sets the value of "box-flex-group" */
  void set boxFlexGroup(String value) {
    setProperty('${_browserPrefix}box-flex-group', value, '');
  }

  /** Gets the value of "box-lines" */
  String get boxLines =>
    getPropertyValue('${_browserPrefix}box-lines');

  /** Sets the value of "box-lines" */
  void set boxLines(String value) {
    setProperty('${_browserPrefix}box-lines', value, '');
  }

  /** Gets the value of "box-ordinal-group" */
  String get boxOrdinalGroup =>
    getPropertyValue('${_browserPrefix}box-ordinal-group');

  /** Sets the value of "box-ordinal-group" */
  void set boxOrdinalGroup(String value) {
    setProperty('${_browserPrefix}box-ordinal-group', value, '');
  }

  /** Gets the value of "box-orient" */
  String get boxOrient =>
    getPropertyValue('${_browserPrefix}box-orient');

  /** Sets the value of "box-orient" */
  void set boxOrient(String value) {
    setProperty('${_browserPrefix}box-orient', value, '');
  }

  /** Gets the value of "box-pack" */
  String get boxPack =>
    getPropertyValue('${_browserPrefix}box-pack');

  /** Sets the value of "box-pack" */
  void set boxPack(String value) {
    setProperty('${_browserPrefix}box-pack', value, '');
  }

  /** Gets the value of "box-reflect" */
  String get boxReflect =>
    getPropertyValue('${_browserPrefix}box-reflect');

  /** Sets the value of "box-reflect" */
  void set boxReflect(String value) {
    setProperty('${_browserPrefix}box-reflect', value, '');
  }

  /** Gets the value of "box-shadow" */
  String get boxShadow =>
    getPropertyValue('box-shadow');

  /** Sets the value of "box-shadow" */
  void set boxShadow(String value) {
    setProperty('box-shadow', value, '');
  }

  /** Gets the value of "box-sizing" */
  String get boxSizing =>
    getPropertyValue('box-sizing');

  /** Sets the value of "box-sizing" */
  void set boxSizing(String value) {
    setProperty('box-sizing', value, '');
  }

  /** Gets the value of "caption-side" */
  String get captionSide =>
    getPropertyValue('caption-side');

  /** Sets the value of "caption-side" */
  void set captionSide(String value) {
    setProperty('caption-side', value, '');
  }

  /** Gets the value of "clear" */
  String get clear =>
    getPropertyValue('clear');

  /** Sets the value of "clear" */
  void set clear(String value) {
    setProperty('clear', value, '');
  }

  /** Gets the value of "clip" */
  String get clip =>
    getPropertyValue('clip');

  /** Sets the value of "clip" */
  void set clip(String value) {
    setProperty('clip', value, '');
  }

  /** Gets the value of "clip-path" */
  String get clipPath =>
    getPropertyValue('${_browserPrefix}clip-path');

  /** Sets the value of "clip-path" */
  void set clipPath(String value) {
    setProperty('${_browserPrefix}clip-path', value, '');
  }

  /** Gets the value of "color" */
  String get color =>
    getPropertyValue('color');

  /** Sets the value of "color" */
  void set color(String value) {
    setProperty('color', value, '');
  }

  /** Gets the value of "color-correction" */
  String get colorCorrection =>
    getPropertyValue('${_browserPrefix}color-correction');

  /** Sets the value of "color-correction" */
  void set colorCorrection(String value) {
    setProperty('${_browserPrefix}color-correction', value, '');
  }

  /** Gets the value of "column-axis" */
  String get columnAxis =>
    getPropertyValue('${_browserPrefix}column-axis');

  /** Sets the value of "column-axis" */
  void set columnAxis(String value) {
    setProperty('${_browserPrefix}column-axis', value, '');
  }

  /** Gets the value of "column-break-after" */
  String get columnBreakAfter =>
    getPropertyValue('${_browserPrefix}column-break-after');

  /** Sets the value of "column-break-after" */
  void set columnBreakAfter(String value) {
    setProperty('${_browserPrefix}column-break-after', value, '');
  }

  /** Gets the value of "column-break-before" */
  String get columnBreakBefore =>
    getPropertyValue('${_browserPrefix}column-break-before');

  /** Sets the value of "column-break-before" */
  void set columnBreakBefore(String value) {
    setProperty('${_browserPrefix}column-break-before', value, '');
  }

  /** Gets the value of "column-break-inside" */
  String get columnBreakInside =>
    getPropertyValue('${_browserPrefix}column-break-inside');

  /** Sets the value of "column-break-inside" */
  void set columnBreakInside(String value) {
    setProperty('${_browserPrefix}column-break-inside', value, '');
  }

  /** Gets the value of "column-count" */
  String get columnCount =>
    getPropertyValue('${_browserPrefix}column-count');

  /** Sets the value of "column-count" */
  void set columnCount(String value) {
    setProperty('${_browserPrefix}column-count', value, '');
  }

  /** Gets the value of "column-gap" */
  String get columnGap =>
    getPropertyValue('${_browserPrefix}column-gap');

  /** Sets the value of "column-gap" */
  void set columnGap(String value) {
    setProperty('${_browserPrefix}column-gap', value, '');
  }

  /** Gets the value of "column-progression" */
  String get columnProgression =>
    getPropertyValue('${_browserPrefix}column-progression');

  /** Sets the value of "column-progression" */
  void set columnProgression(String value) {
    setProperty('${_browserPrefix}column-progression', value, '');
  }

  /** Gets the value of "column-rule" */
  String get columnRule =>
    getPropertyValue('${_browserPrefix}column-rule');

  /** Sets the value of "column-rule" */
  void set columnRule(String value) {
    setProperty('${_browserPrefix}column-rule', value, '');
  }

  /** Gets the value of "column-rule-color" */
  String get columnRuleColor =>
    getPropertyValue('${_browserPrefix}column-rule-color');

  /** Sets the value of "column-rule-color" */
  void set columnRuleColor(String value) {
    setProperty('${_browserPrefix}column-rule-color', value, '');
  }

  /** Gets the value of "column-rule-style" */
  String get columnRuleStyle =>
    getPropertyValue('${_browserPrefix}column-rule-style');

  /** Sets the value of "column-rule-style" */
  void set columnRuleStyle(String value) {
    setProperty('${_browserPrefix}column-rule-style', value, '');
  }

  /** Gets the value of "column-rule-width" */
  String get columnRuleWidth =>
    getPropertyValue('${_browserPrefix}column-rule-width');

  /** Sets the value of "column-rule-width" */
  void set columnRuleWidth(String value) {
    setProperty('${_browserPrefix}column-rule-width', value, '');
  }

  /** Gets the value of "column-span" */
  String get columnSpan =>
    getPropertyValue('${_browserPrefix}column-span');

  /** Sets the value of "column-span" */
  void set columnSpan(String value) {
    setProperty('${_browserPrefix}column-span', value, '');
  }

  /** Gets the value of "column-width" */
  String get columnWidth =>
    getPropertyValue('${_browserPrefix}column-width');

  /** Sets the value of "column-width" */
  void set columnWidth(String value) {
    setProperty('${_browserPrefix}column-width', value, '');
  }

  /** Gets the value of "columns" */
  String get columns =>
    getPropertyValue('${_browserPrefix}columns');

  /** Sets the value of "columns" */
  void set columns(String value) {
    setProperty('${_browserPrefix}columns', value, '');
  }

  /** Gets the value of "content" */
  String get content =>
    getPropertyValue('content');

  /** Sets the value of "content" */
  void set content(String value) {
    setProperty('content', value, '');
  }

  /** Gets the value of "counter-increment" */
  String get counterIncrement =>
    getPropertyValue('counter-increment');

  /** Sets the value of "counter-increment" */
  void set counterIncrement(String value) {
    setProperty('counter-increment', value, '');
  }

  /** Gets the value of "counter-reset" */
  String get counterReset =>
    getPropertyValue('counter-reset');

  /** Sets the value of "counter-reset" */
  void set counterReset(String value) {
    setProperty('counter-reset', value, '');
  }

  /** Gets the value of "cursor" */
  String get cursor =>
    getPropertyValue('cursor');

  /** Sets the value of "cursor" */
  void set cursor(String value) {
    setProperty('cursor', value, '');
  }

  /** Gets the value of "dashboard-region" */
  String get dashboardRegion =>
    getPropertyValue('${_browserPrefix}dashboard-region');

  /** Sets the value of "dashboard-region" */
  void set dashboardRegion(String value) {
    setProperty('${_browserPrefix}dashboard-region', value, '');
  }

  /** Gets the value of "direction" */
  String get direction =>
    getPropertyValue('direction');

  /** Sets the value of "direction" */
  void set direction(String value) {
    setProperty('direction', value, '');
  }

  /** Gets the value of "display" */
  String get display =>
    getPropertyValue('display');

  /** Sets the value of "display" */
  void set display(String value) {
    setProperty('display', value, '');
  }

  /** Gets the value of "empty-cells" */
  String get emptyCells =>
    getPropertyValue('empty-cells');

  /** Sets the value of "empty-cells" */
  void set emptyCells(String value) {
    setProperty('empty-cells', value, '');
  }

  /** Gets the value of "filter" */
  String get filter =>
    getPropertyValue('${_browserPrefix}filter');

  /** Sets the value of "filter" */
  void set filter(String value) {
    setProperty('${_browserPrefix}filter', value, '');
  }

  /** Gets the value of "flex" */
  String get flex =>
    getPropertyValue('${_browserPrefix}flex');

  /** Sets the value of "flex" */
  void set flex(String value) {
    setProperty('${_browserPrefix}flex', value, '');
  }

  /** Gets the value of "flex-basis" */
  String get flexBasis =>
    getPropertyValue('${_browserPrefix}flex-basis');

  /** Sets the value of "flex-basis" */
  void set flexBasis(String value) {
    setProperty('${_browserPrefix}flex-basis', value, '');
  }

  /** Gets the value of "flex-direction" */
  String get flexDirection =>
    getPropertyValue('${_browserPrefix}flex-direction');

  /** Sets the value of "flex-direction" */
  void set flexDirection(String value) {
    setProperty('${_browserPrefix}flex-direction', value, '');
  }

  /** Gets the value of "flex-flow" */
  String get flexFlow =>
    getPropertyValue('${_browserPrefix}flex-flow');

  /** Sets the value of "flex-flow" */
  void set flexFlow(String value) {
    setProperty('${_browserPrefix}flex-flow', value, '');
  }

  /** Gets the value of "flex-grow" */
  String get flexGrow =>
    getPropertyValue('${_browserPrefix}flex-grow');

  /** Sets the value of "flex-grow" */
  void set flexGrow(String value) {
    setProperty('${_browserPrefix}flex-grow', value, '');
  }

  /** Gets the value of "flex-shrink" */
  String get flexShrink =>
    getPropertyValue('${_browserPrefix}flex-shrink');

  /** Sets the value of "flex-shrink" */
  void set flexShrink(String value) {
    setProperty('${_browserPrefix}flex-shrink', value, '');
  }

  /** Gets the value of "flex-wrap" */
  String get flexWrap =>
    getPropertyValue('${_browserPrefix}flex-wrap');

  /** Sets the value of "flex-wrap" */
  void set flexWrap(String value) {
    setProperty('${_browserPrefix}flex-wrap', value, '');
  }

  /** Gets the value of "float" */
  String get float =>
    getPropertyValue('float');

  /** Sets the value of "float" */
  void set float(String value) {
    setProperty('float', value, '');
  }

  /** Gets the value of "flow-from" */
  String get flowFrom =>
    getPropertyValue('${_browserPrefix}flow-from');

  /** Sets the value of "flow-from" */
  void set flowFrom(String value) {
    setProperty('${_browserPrefix}flow-from', value, '');
  }

  /** Gets the value of "flow-into" */
  String get flowInto =>
    getPropertyValue('${_browserPrefix}flow-into');

  /** Sets the value of "flow-into" */
  void set flowInto(String value) {
    setProperty('${_browserPrefix}flow-into', value, '');
  }

  /** Gets the value of "font" */
  String get font =>
    getPropertyValue('font');

  /** Sets the value of "font" */
  void set font(String value) {
    setProperty('font', value, '');
  }

  /** Gets the value of "font-family" */
  String get fontFamily =>
    getPropertyValue('font-family');

  /** Sets the value of "font-family" */
  void set fontFamily(String value) {
    setProperty('font-family', value, '');
  }

  /** Gets the value of "font-feature-settings" */
  String get fontFeatureSettings =>
    getPropertyValue('${_browserPrefix}font-feature-settings');

  /** Sets the value of "font-feature-settings" */
  void set fontFeatureSettings(String value) {
    setProperty('${_browserPrefix}font-feature-settings', value, '');
  }

  /** Gets the value of "font-kerning" */
  String get fontKerning =>
    getPropertyValue('${_browserPrefix}font-kerning');

  /** Sets the value of "font-kerning" */
  void set fontKerning(String value) {
    setProperty('${_browserPrefix}font-kerning', value, '');
  }

  /** Gets the value of "font-size" */
  String get fontSize =>
    getPropertyValue('font-size');

  /** Sets the value of "font-size" */
  void set fontSize(String value) {
    setProperty('font-size', value, '');
  }

  /** Gets the value of "font-size-delta" */
  String get fontSizeDelta =>
    getPropertyValue('${_browserPrefix}font-size-delta');

  /** Sets the value of "font-size-delta" */
  void set fontSizeDelta(String value) {
    setProperty('${_browserPrefix}font-size-delta', value, '');
  }

  /** Gets the value of "font-smoothing" */
  String get fontSmoothing =>
    getPropertyValue('${_browserPrefix}font-smoothing');

  /** Sets the value of "font-smoothing" */
  void set fontSmoothing(String value) {
    setProperty('${_browserPrefix}font-smoothing', value, '');
  }

  /** Gets the value of "font-stretch" */
  String get fontStretch =>
    getPropertyValue('font-stretch');

  /** Sets the value of "font-stretch" */
  void set fontStretch(String value) {
    setProperty('font-stretch', value, '');
  }

  /** Gets the value of "font-style" */
  String get fontStyle =>
    getPropertyValue('font-style');

  /** Sets the value of "font-style" */
  void set fontStyle(String value) {
    setProperty('font-style', value, '');
  }

  /** Gets the value of "font-variant" */
  String get fontVariant =>
    getPropertyValue('font-variant');

  /** Sets the value of "font-variant" */
  void set fontVariant(String value) {
    setProperty('font-variant', value, '');
  }

  /** Gets the value of "font-variant-ligatures" */
  String get fontVariantLigatures =>
    getPropertyValue('${_browserPrefix}font-variant-ligatures');

  /** Sets the value of "font-variant-ligatures" */
  void set fontVariantLigatures(String value) {
    setProperty('${_browserPrefix}font-variant-ligatures', value, '');
  }

  /** Gets the value of "font-weight" */
  String get fontWeight =>
    getPropertyValue('font-weight');

  /** Sets the value of "font-weight" */
  void set fontWeight(String value) {
    setProperty('font-weight', value, '');
  }

  /** Gets the value of "grid-column" */
  String get gridColumn =>
    getPropertyValue('${_browserPrefix}grid-column');

  /** Sets the value of "grid-column" */
  void set gridColumn(String value) {
    setProperty('${_browserPrefix}grid-column', value, '');
  }

  /** Gets the value of "grid-columns" */
  String get gridColumns =>
    getPropertyValue('${_browserPrefix}grid-columns');

  /** Sets the value of "grid-columns" */
  void set gridColumns(String value) {
    setProperty('${_browserPrefix}grid-columns', value, '');
  }

  /** Gets the value of "grid-row" */
  String get gridRow =>
    getPropertyValue('${_browserPrefix}grid-row');

  /** Sets the value of "grid-row" */
  void set gridRow(String value) {
    setProperty('${_browserPrefix}grid-row', value, '');
  }

  /** Gets the value of "grid-rows" */
  String get gridRows =>
    getPropertyValue('${_browserPrefix}grid-rows');

  /** Sets the value of "grid-rows" */
  void set gridRows(String value) {
    setProperty('${_browserPrefix}grid-rows', value, '');
  }

  /** Gets the value of "height" */
  String get height =>
    getPropertyValue('height');

  /** Sets the value of "height" */
  void set height(String value) {
    setProperty('height', value, '');
  }

  /** Gets the value of "highlight" */
  String get highlight =>
    getPropertyValue('${_browserPrefix}highlight');

  /** Sets the value of "highlight" */
  void set highlight(String value) {
    setProperty('${_browserPrefix}highlight', value, '');
  }

  /** Gets the value of "hyphenate-character" */
  String get hyphenateCharacter =>
    getPropertyValue('${_browserPrefix}hyphenate-character');

  /** Sets the value of "hyphenate-character" */
  void set hyphenateCharacter(String value) {
    setProperty('${_browserPrefix}hyphenate-character', value, '');
  }

  /** Gets the value of "hyphenate-limit-after" */
  String get hyphenateLimitAfter =>
    getPropertyValue('${_browserPrefix}hyphenate-limit-after');

  /** Sets the value of "hyphenate-limit-after" */
  void set hyphenateLimitAfter(String value) {
    setProperty('${_browserPrefix}hyphenate-limit-after', value, '');
  }

  /** Gets the value of "hyphenate-limit-before" */
  String get hyphenateLimitBefore =>
    getPropertyValue('${_browserPrefix}hyphenate-limit-before');

  /** Sets the value of "hyphenate-limit-before" */
  void set hyphenateLimitBefore(String value) {
    setProperty('${_browserPrefix}hyphenate-limit-before', value, '');
  }

  /** Gets the value of "hyphenate-limit-lines" */
  String get hyphenateLimitLines =>
    getPropertyValue('${_browserPrefix}hyphenate-limit-lines');

  /** Sets the value of "hyphenate-limit-lines" */
  void set hyphenateLimitLines(String value) {
    setProperty('${_browserPrefix}hyphenate-limit-lines', value, '');
  }

  /** Gets the value of "hyphens" */
  String get hyphens =>
    getPropertyValue('${_browserPrefix}hyphens');

  /** Sets the value of "hyphens" */
  void set hyphens(String value) {
    setProperty('${_browserPrefix}hyphens', value, '');
  }

  /** Gets the value of "image-orientation" */
  String get imageOrientation =>
    getPropertyValue('image-orientation');

  /** Sets the value of "image-orientation" */
  void set imageOrientation(String value) {
    setProperty('image-orientation', value, '');
  }

  /** Gets the value of "image-rendering" */
  String get imageRendering =>
    getPropertyValue('image-rendering');

  /** Sets the value of "image-rendering" */
  void set imageRendering(String value) {
    setProperty('image-rendering', value, '');
  }

  /** Gets the value of "image-resolution" */
  String get imageResolution =>
    getPropertyValue('image-resolution');

  /** Sets the value of "image-resolution" */
  void set imageResolution(String value) {
    setProperty('image-resolution', value, '');
  }

  /** Gets the value of "justify-content" */
  String get justifyContent =>
    getPropertyValue('${_browserPrefix}justify-content');

  /** Sets the value of "justify-content" */
  void set justifyContent(String value) {
    setProperty('${_browserPrefix}justify-content', value, '');
  }

  /** Gets the value of "left" */
  String get left =>
    getPropertyValue('left');

  /** Sets the value of "left" */
  void set left(String value) {
    setProperty('left', value, '');
  }

  /** Gets the value of "letter-spacing" */
  String get letterSpacing =>
    getPropertyValue('letter-spacing');

  /** Sets the value of "letter-spacing" */
  void set letterSpacing(String value) {
    setProperty('letter-spacing', value, '');
  }

  /** Gets the value of "line-align" */
  String get lineAlign =>
    getPropertyValue('${_browserPrefix}line-align');

  /** Sets the value of "line-align" */
  void set lineAlign(String value) {
    setProperty('${_browserPrefix}line-align', value, '');
  }

  /** Gets the value of "line-box-contain" */
  String get lineBoxContain =>
    getPropertyValue('${_browserPrefix}line-box-contain');

  /** Sets the value of "line-box-contain" */
  void set lineBoxContain(String value) {
    setProperty('${_browserPrefix}line-box-contain', value, '');
  }

  /** Gets the value of "line-break" */
  String get lineBreak =>
    getPropertyValue('${_browserPrefix}line-break');

  /** Sets the value of "line-break" */
  void set lineBreak(String value) {
    setProperty('${_browserPrefix}line-break', value, '');
  }

  /** Gets the value of "line-clamp" */
  String get lineClamp =>
    getPropertyValue('${_browserPrefix}line-clamp');

  /** Sets the value of "line-clamp" */
  void set lineClamp(String value) {
    setProperty('${_browserPrefix}line-clamp', value, '');
  }

  /** Gets the value of "line-grid" */
  String get lineGrid =>
    getPropertyValue('${_browserPrefix}line-grid');

  /** Sets the value of "line-grid" */
  void set lineGrid(String value) {
    setProperty('${_browserPrefix}line-grid', value, '');
  }

  /** Gets the value of "line-height" */
  String get lineHeight =>
    getPropertyValue('line-height');

  /** Sets the value of "line-height" */
  void set lineHeight(String value) {
    setProperty('line-height', value, '');
  }

  /** Gets the value of "line-snap" */
  String get lineSnap =>
    getPropertyValue('${_browserPrefix}line-snap');

  /** Sets the value of "line-snap" */
  void set lineSnap(String value) {
    setProperty('${_browserPrefix}line-snap', value, '');
  }

  /** Gets the value of "list-style" */
  String get listStyle =>
    getPropertyValue('list-style');

  /** Sets the value of "list-style" */
  void set listStyle(String value) {
    setProperty('list-style', value, '');
  }

  /** Gets the value of "list-style-image" */
  String get listStyleImage =>
    getPropertyValue('list-style-image');

  /** Sets the value of "list-style-image" */
  void set listStyleImage(String value) {
    setProperty('list-style-image', value, '');
  }

  /** Gets the value of "list-style-position" */
  String get listStylePosition =>
    getPropertyValue('list-style-position');

  /** Sets the value of "list-style-position" */
  void set listStylePosition(String value) {
    setProperty('list-style-position', value, '');
  }

  /** Gets the value of "list-style-type" */
  String get listStyleType =>
    getPropertyValue('list-style-type');

  /** Sets the value of "list-style-type" */
  void set listStyleType(String value) {
    setProperty('list-style-type', value, '');
  }

  /** Gets the value of "locale" */
  String get locale =>
    getPropertyValue('${_browserPrefix}locale');

  /** Sets the value of "locale" */
  void set locale(String value) {
    setProperty('${_browserPrefix}locale', value, '');
  }

  /** Gets the value of "logical-height" */
  String get logicalHeight =>
    getPropertyValue('${_browserPrefix}logical-height');

  /** Sets the value of "logical-height" */
  void set logicalHeight(String value) {
    setProperty('${_browserPrefix}logical-height', value, '');
  }

  /** Gets the value of "logical-width" */
  String get logicalWidth =>
    getPropertyValue('${_browserPrefix}logical-width');

  /** Sets the value of "logical-width" */
  void set logicalWidth(String value) {
    setProperty('${_browserPrefix}logical-width', value, '');
  }

  /** Gets the value of "margin" */
  String get margin =>
    getPropertyValue('margin');

  /** Sets the value of "margin" */
  void set margin(String value) {
    setProperty('margin', value, '');
  }

  /** Gets the value of "margin-after" */
  String get marginAfter =>
    getPropertyValue('${_browserPrefix}margin-after');

  /** Sets the value of "margin-after" */
  void set marginAfter(String value) {
    setProperty('${_browserPrefix}margin-after', value, '');
  }

  /** Gets the value of "margin-after-collapse" */
  String get marginAfterCollapse =>
    getPropertyValue('${_browserPrefix}margin-after-collapse');

  /** Sets the value of "margin-after-collapse" */
  void set marginAfterCollapse(String value) {
    setProperty('${_browserPrefix}margin-after-collapse', value, '');
  }

  /** Gets the value of "margin-before" */
  String get marginBefore =>
    getPropertyValue('${_browserPrefix}margin-before');

  /** Sets the value of "margin-before" */
  void set marginBefore(String value) {
    setProperty('${_browserPrefix}margin-before', value, '');
  }

  /** Gets the value of "margin-before-collapse" */
  String get marginBeforeCollapse =>
    getPropertyValue('${_browserPrefix}margin-before-collapse');

  /** Sets the value of "margin-before-collapse" */
  void set marginBeforeCollapse(String value) {
    setProperty('${_browserPrefix}margin-before-collapse', value, '');
  }

  /** Gets the value of "margin-bottom" */
  String get marginBottom =>
    getPropertyValue('margin-bottom');

  /** Sets the value of "margin-bottom" */
  void set marginBottom(String value) {
    setProperty('margin-bottom', value, '');
  }

  /** Gets the value of "margin-bottom-collapse" */
  String get marginBottomCollapse =>
    getPropertyValue('${_browserPrefix}margin-bottom-collapse');

  /** Sets the value of "margin-bottom-collapse" */
  void set marginBottomCollapse(String value) {
    setProperty('${_browserPrefix}margin-bottom-collapse', value, '');
  }

  /** Gets the value of "margin-collapse" */
  String get marginCollapse =>
    getPropertyValue('${_browserPrefix}margin-collapse');

  /** Sets the value of "margin-collapse" */
  void set marginCollapse(String value) {
    setProperty('${_browserPrefix}margin-collapse', value, '');
  }

  /** Gets the value of "margin-end" */
  String get marginEnd =>
    getPropertyValue('${_browserPrefix}margin-end');

  /** Sets the value of "margin-end" */
  void set marginEnd(String value) {
    setProperty('${_browserPrefix}margin-end', value, '');
  }

  /** Gets the value of "margin-left" */
  String get marginLeft =>
    getPropertyValue('margin-left');

  /** Sets the value of "margin-left" */
  void set marginLeft(String value) {
    setProperty('margin-left', value, '');
  }

  /** Gets the value of "margin-right" */
  String get marginRight =>
    getPropertyValue('margin-right');

  /** Sets the value of "margin-right" */
  void set marginRight(String value) {
    setProperty('margin-right', value, '');
  }

  /** Gets the value of "margin-start" */
  String get marginStart =>
    getPropertyValue('${_browserPrefix}margin-start');

  /** Sets the value of "margin-start" */
  void set marginStart(String value) {
    setProperty('${_browserPrefix}margin-start', value, '');
  }

  /** Gets the value of "margin-top" */
  String get marginTop =>
    getPropertyValue('margin-top');

  /** Sets the value of "margin-top" */
  void set marginTop(String value) {
    setProperty('margin-top', value, '');
  }

  /** Gets the value of "margin-top-collapse" */
  String get marginTopCollapse =>
    getPropertyValue('${_browserPrefix}margin-top-collapse');

  /** Sets the value of "margin-top-collapse" */
  void set marginTopCollapse(String value) {
    setProperty('${_browserPrefix}margin-top-collapse', value, '');
  }

  /** Gets the value of "marquee" */
  String get marquee =>
    getPropertyValue('${_browserPrefix}marquee');

  /** Sets the value of "marquee" */
  void set marquee(String value) {
    setProperty('${_browserPrefix}marquee', value, '');
  }

  /** Gets the value of "marquee-direction" */
  String get marqueeDirection =>
    getPropertyValue('${_browserPrefix}marquee-direction');

  /** Sets the value of "marquee-direction" */
  void set marqueeDirection(String value) {
    setProperty('${_browserPrefix}marquee-direction', value, '');
  }

  /** Gets the value of "marquee-increment" */
  String get marqueeIncrement =>
    getPropertyValue('${_browserPrefix}marquee-increment');

  /** Sets the value of "marquee-increment" */
  void set marqueeIncrement(String value) {
    setProperty('${_browserPrefix}marquee-increment', value, '');
  }

  /** Gets the value of "marquee-repetition" */
  String get marqueeRepetition =>
    getPropertyValue('${_browserPrefix}marquee-repetition');

  /** Sets the value of "marquee-repetition" */
  void set marqueeRepetition(String value) {
    setProperty('${_browserPrefix}marquee-repetition', value, '');
  }

  /** Gets the value of "marquee-speed" */
  String get marqueeSpeed =>
    getPropertyValue('${_browserPrefix}marquee-speed');

  /** Sets the value of "marquee-speed" */
  void set marqueeSpeed(String value) {
    setProperty('${_browserPrefix}marquee-speed', value, '');
  }

  /** Gets the value of "marquee-style" */
  String get marqueeStyle =>
    getPropertyValue('${_browserPrefix}marquee-style');

  /** Sets the value of "marquee-style" */
  void set marqueeStyle(String value) {
    setProperty('${_browserPrefix}marquee-style', value, '');
  }

  /** Gets the value of "mask" */
  String get mask =>
    getPropertyValue('${_browserPrefix}mask');

  /** Sets the value of "mask" */
  void set mask(String value) {
    setProperty('${_browserPrefix}mask', value, '');
  }

  /** Gets the value of "mask-attachment" */
  String get maskAttachment =>
    getPropertyValue('${_browserPrefix}mask-attachment');

  /** Sets the value of "mask-attachment" */
  void set maskAttachment(String value) {
    setProperty('${_browserPrefix}mask-attachment', value, '');
  }

  /** Gets the value of "mask-box-image" */
  String get maskBoxImage =>
    getPropertyValue('${_browserPrefix}mask-box-image');

  /** Sets the value of "mask-box-image" */
  void set maskBoxImage(String value) {
    setProperty('${_browserPrefix}mask-box-image', value, '');
  }

  /** Gets the value of "mask-box-image-outset" */
  String get maskBoxImageOutset =>
    getPropertyValue('${_browserPrefix}mask-box-image-outset');

  /** Sets the value of "mask-box-image-outset" */
  void set maskBoxImageOutset(String value) {
    setProperty('${_browserPrefix}mask-box-image-outset', value, '');
  }

  /** Gets the value of "mask-box-image-repeat" */
  String get maskBoxImageRepeat =>
    getPropertyValue('${_browserPrefix}mask-box-image-repeat');

  /** Sets the value of "mask-box-image-repeat" */
  void set maskBoxImageRepeat(String value) {
    setProperty('${_browserPrefix}mask-box-image-repeat', value, '');
  }

  /** Gets the value of "mask-box-image-slice" */
  String get maskBoxImageSlice =>
    getPropertyValue('${_browserPrefix}mask-box-image-slice');

  /** Sets the value of "mask-box-image-slice" */
  void set maskBoxImageSlice(String value) {
    setProperty('${_browserPrefix}mask-box-image-slice', value, '');
  }

  /** Gets the value of "mask-box-image-source" */
  String get maskBoxImageSource =>
    getPropertyValue('${_browserPrefix}mask-box-image-source');

  /** Sets the value of "mask-box-image-source" */
  void set maskBoxImageSource(String value) {
    setProperty('${_browserPrefix}mask-box-image-source', value, '');
  }

  /** Gets the value of "mask-box-image-width" */
  String get maskBoxImageWidth =>
    getPropertyValue('${_browserPrefix}mask-box-image-width');

  /** Sets the value of "mask-box-image-width" */
  void set maskBoxImageWidth(String value) {
    setProperty('${_browserPrefix}mask-box-image-width', value, '');
  }

  /** Gets the value of "mask-clip" */
  String get maskClip =>
    getPropertyValue('${_browserPrefix}mask-clip');

  /** Sets the value of "mask-clip" */
  void set maskClip(String value) {
    setProperty('${_browserPrefix}mask-clip', value, '');
  }

  /** Gets the value of "mask-composite" */
  String get maskComposite =>
    getPropertyValue('${_browserPrefix}mask-composite');

  /** Sets the value of "mask-composite" */
  void set maskComposite(String value) {
    setProperty('${_browserPrefix}mask-composite', value, '');
  }

  /** Gets the value of "mask-image" */
  String get maskImage =>
    getPropertyValue('${_browserPrefix}mask-image');

  /** Sets the value of "mask-image" */
  void set maskImage(String value) {
    setProperty('${_browserPrefix}mask-image', value, '');
  }

  /** Gets the value of "mask-origin" */
  String get maskOrigin =>
    getPropertyValue('${_browserPrefix}mask-origin');

  /** Sets the value of "mask-origin" */
  void set maskOrigin(String value) {
    setProperty('${_browserPrefix}mask-origin', value, '');
  }

  /** Gets the value of "mask-position" */
  String get maskPosition =>
    getPropertyValue('${_browserPrefix}mask-position');

  /** Sets the value of "mask-position" */
  void set maskPosition(String value) {
    setProperty('${_browserPrefix}mask-position', value, '');
  }

  /** Gets the value of "mask-position-x" */
  String get maskPositionX =>
    getPropertyValue('${_browserPrefix}mask-position-x');

  /** Sets the value of "mask-position-x" */
  void set maskPositionX(String value) {
    setProperty('${_browserPrefix}mask-position-x', value, '');
  }

  /** Gets the value of "mask-position-y" */
  String get maskPositionY =>
    getPropertyValue('${_browserPrefix}mask-position-y');

  /** Sets the value of "mask-position-y" */
  void set maskPositionY(String value) {
    setProperty('${_browserPrefix}mask-position-y', value, '');
  }

  /** Gets the value of "mask-repeat" */
  String get maskRepeat =>
    getPropertyValue('${_browserPrefix}mask-repeat');

  /** Sets the value of "mask-repeat" */
  void set maskRepeat(String value) {
    setProperty('${_browserPrefix}mask-repeat', value, '');
  }

  /** Gets the value of "mask-repeat-x" */
  String get maskRepeatX =>
    getPropertyValue('${_browserPrefix}mask-repeat-x');

  /** Sets the value of "mask-repeat-x" */
  void set maskRepeatX(String value) {
    setProperty('${_browserPrefix}mask-repeat-x', value, '');
  }

  /** Gets the value of "mask-repeat-y" */
  String get maskRepeatY =>
    getPropertyValue('${_browserPrefix}mask-repeat-y');

  /** Sets the value of "mask-repeat-y" */
  void set maskRepeatY(String value) {
    setProperty('${_browserPrefix}mask-repeat-y', value, '');
  }

  /** Gets the value of "mask-size" */
  String get maskSize =>
    getPropertyValue('${_browserPrefix}mask-size');

  /** Sets the value of "mask-size" */
  void set maskSize(String value) {
    setProperty('${_browserPrefix}mask-size', value, '');
  }

  /** Gets the value of "max-height" */
  String get maxHeight =>
    getPropertyValue('max-height');

  /** Sets the value of "max-height" */
  void set maxHeight(String value) {
    setProperty('max-height', value, '');
  }

  /** Gets the value of "max-logical-height" */
  String get maxLogicalHeight =>
    getPropertyValue('${_browserPrefix}max-logical-height');

  /** Sets the value of "max-logical-height" */
  void set maxLogicalHeight(String value) {
    setProperty('${_browserPrefix}max-logical-height', value, '');
  }

  /** Gets the value of "max-logical-width" */
  String get maxLogicalWidth =>
    getPropertyValue('${_browserPrefix}max-logical-width');

  /** Sets the value of "max-logical-width" */
  void set maxLogicalWidth(String value) {
    setProperty('${_browserPrefix}max-logical-width', value, '');
  }

  /** Gets the value of "max-width" */
  String get maxWidth =>
    getPropertyValue('max-width');

  /** Sets the value of "max-width" */
  void set maxWidth(String value) {
    setProperty('max-width', value, '');
  }

  /** Gets the value of "max-zoom" */
  String get maxZoom =>
    getPropertyValue('max-zoom');

  /** Sets the value of "max-zoom" */
  void set maxZoom(String value) {
    setProperty('max-zoom', value, '');
  }

  /** Gets the value of "min-height" */
  String get minHeight =>
    getPropertyValue('min-height');

  /** Sets the value of "min-height" */
  void set minHeight(String value) {
    setProperty('min-height', value, '');
  }

  /** Gets the value of "min-logical-height" */
  String get minLogicalHeight =>
    getPropertyValue('${_browserPrefix}min-logical-height');

  /** Sets the value of "min-logical-height" */
  void set minLogicalHeight(String value) {
    setProperty('${_browserPrefix}min-logical-height', value, '');
  }

  /** Gets the value of "min-logical-width" */
  String get minLogicalWidth =>
    getPropertyValue('${_browserPrefix}min-logical-width');

  /** Sets the value of "min-logical-width" */
  void set minLogicalWidth(String value) {
    setProperty('${_browserPrefix}min-logical-width', value, '');
  }

  /** Gets the value of "min-width" */
  String get minWidth =>
    getPropertyValue('min-width');

  /** Sets the value of "min-width" */
  void set minWidth(String value) {
    setProperty('min-width', value, '');
  }

  /** Gets the value of "min-zoom" */
  String get minZoom =>
    getPropertyValue('min-zoom');

  /** Sets the value of "min-zoom" */
  void set minZoom(String value) {
    setProperty('min-zoom', value, '');
  }

  /** Gets the value of "nbsp-mode" */
  String get nbspMode =>
    getPropertyValue('${_browserPrefix}nbsp-mode');

  /** Sets the value of "nbsp-mode" */
  void set nbspMode(String value) {
    setProperty('${_browserPrefix}nbsp-mode', value, '');
  }

  /** Gets the value of "opacity" */
  String get opacity =>
    getPropertyValue('opacity');

  /** Sets the value of "opacity" */
  void set opacity(String value) {
    setProperty('opacity', value, '');
  }

  /** Gets the value of "order" */
  String get order =>
    getPropertyValue('${_browserPrefix}order');

  /** Sets the value of "order" */
  void set order(String value) {
    setProperty('${_browserPrefix}order', value, '');
  }

  /** Gets the value of "orientation" */
  String get orientation =>
    getPropertyValue('orientation');

  /** Sets the value of "orientation" */
  void set orientation(String value) {
    setProperty('orientation', value, '');
  }

  /** Gets the value of "orphans" */
  String get orphans =>
    getPropertyValue('orphans');

  /** Sets the value of "orphans" */
  void set orphans(String value) {
    setProperty('orphans', value, '');
  }

  /** Gets the value of "outline" */
  String get outline =>
    getPropertyValue('outline');

  /** Sets the value of "outline" */
  void set outline(String value) {
    setProperty('outline', value, '');
  }

  /** Gets the value of "outline-color" */
  String get outlineColor =>
    getPropertyValue('outline-color');

  /** Sets the value of "outline-color" */
  void set outlineColor(String value) {
    setProperty('outline-color', value, '');
  }

  /** Gets the value of "outline-offset" */
  String get outlineOffset =>
    getPropertyValue('outline-offset');

  /** Sets the value of "outline-offset" */
  void set outlineOffset(String value) {
    setProperty('outline-offset', value, '');
  }

  /** Gets the value of "outline-style" */
  String get outlineStyle =>
    getPropertyValue('outline-style');

  /** Sets the value of "outline-style" */
  void set outlineStyle(String value) {
    setProperty('outline-style', value, '');
  }

  /** Gets the value of "outline-width" */
  String get outlineWidth =>
    getPropertyValue('outline-width');

  /** Sets the value of "outline-width" */
  void set outlineWidth(String value) {
    setProperty('outline-width', value, '');
  }

  /** Gets the value of "overflow" */
  String get overflow =>
    getPropertyValue('overflow');

  /** Sets the value of "overflow" */
  void set overflow(String value) {
    setProperty('overflow', value, '');
  }

  /** Gets the value of "overflow-scrolling" */
  String get overflowScrolling =>
    getPropertyValue('${_browserPrefix}overflow-scrolling');

  /** Sets the value of "overflow-scrolling" */
  void set overflowScrolling(String value) {
    setProperty('${_browserPrefix}overflow-scrolling', value, '');
  }

  /** Gets the value of "overflow-wrap" */
  String get overflowWrap =>
    getPropertyValue('overflow-wrap');

  /** Sets the value of "overflow-wrap" */
  void set overflowWrap(String value) {
    setProperty('overflow-wrap', value, '');
  }

  /** Gets the value of "overflow-x" */
  String get overflowX =>
    getPropertyValue('overflow-x');

  /** Sets the value of "overflow-x" */
  void set overflowX(String value) {
    setProperty('overflow-x', value, '');
  }

  /** Gets the value of "overflow-y" */
  String get overflowY =>
    getPropertyValue('overflow-y');

  /** Sets the value of "overflow-y" */
  void set overflowY(String value) {
    setProperty('overflow-y', value, '');
  }

  /** Gets the value of "padding" */
  String get padding =>
    getPropertyValue('padding');

  /** Sets the value of "padding" */
  void set padding(String value) {
    setProperty('padding', value, '');
  }

  /** Gets the value of "padding-after" */
  String get paddingAfter =>
    getPropertyValue('${_browserPrefix}padding-after');

  /** Sets the value of "padding-after" */
  void set paddingAfter(String value) {
    setProperty('${_browserPrefix}padding-after', value, '');
  }

  /** Gets the value of "padding-before" */
  String get paddingBefore =>
    getPropertyValue('${_browserPrefix}padding-before');

  /** Sets the value of "padding-before" */
  void set paddingBefore(String value) {
    setProperty('${_browserPrefix}padding-before', value, '');
  }

  /** Gets the value of "padding-bottom" */
  String get paddingBottom =>
    getPropertyValue('padding-bottom');

  /** Sets the value of "padding-bottom" */
  void set paddingBottom(String value) {
    setProperty('padding-bottom', value, '');
  }

  /** Gets the value of "padding-end" */
  String get paddingEnd =>
    getPropertyValue('${_browserPrefix}padding-end');

  /** Sets the value of "padding-end" */
  void set paddingEnd(String value) {
    setProperty('${_browserPrefix}padding-end', value, '');
  }

  /** Gets the value of "padding-left" */
  String get paddingLeft =>
    getPropertyValue('padding-left');

  /** Sets the value of "padding-left" */
  void set paddingLeft(String value) {
    setProperty('padding-left', value, '');
  }

  /** Gets the value of "padding-right" */
  String get paddingRight =>
    getPropertyValue('padding-right');

  /** Sets the value of "padding-right" */
  void set paddingRight(String value) {
    setProperty('padding-right', value, '');
  }

  /** Gets the value of "padding-start" */
  String get paddingStart =>
    getPropertyValue('${_browserPrefix}padding-start');

  /** Sets the value of "padding-start" */
  void set paddingStart(String value) {
    setProperty('${_browserPrefix}padding-start', value, '');
  }

  /** Gets the value of "padding-top" */
  String get paddingTop =>
    getPropertyValue('padding-top');

  /** Sets the value of "padding-top" */
  void set paddingTop(String value) {
    setProperty('padding-top', value, '');
  }

  /** Gets the value of "page" */
  String get page =>
    getPropertyValue('page');

  /** Sets the value of "page" */
  void set page(String value) {
    setProperty('page', value, '');
  }

  /** Gets the value of "page-break-after" */
  String get pageBreakAfter =>
    getPropertyValue('page-break-after');

  /** Sets the value of "page-break-after" */
  void set pageBreakAfter(String value) {
    setProperty('page-break-after', value, '');
  }

  /** Gets the value of "page-break-before" */
  String get pageBreakBefore =>
    getPropertyValue('page-break-before');

  /** Sets the value of "page-break-before" */
  void set pageBreakBefore(String value) {
    setProperty('page-break-before', value, '');
  }

  /** Gets the value of "page-break-inside" */
  String get pageBreakInside =>
    getPropertyValue('page-break-inside');

  /** Sets the value of "page-break-inside" */
  void set pageBreakInside(String value) {
    setProperty('page-break-inside', value, '');
  }

  /** Gets the value of "perspective" */
  String get perspective =>
    getPropertyValue('${_browserPrefix}perspective');

  /** Sets the value of "perspective" */
  void set perspective(String value) {
    setProperty('${_browserPrefix}perspective', value, '');
  }

  /** Gets the value of "perspective-origin" */
  String get perspectiveOrigin =>
    getPropertyValue('${_browserPrefix}perspective-origin');

  /** Sets the value of "perspective-origin" */
  void set perspectiveOrigin(String value) {
    setProperty('${_browserPrefix}perspective-origin', value, '');
  }

  /** Gets the value of "perspective-origin-x" */
  String get perspectiveOriginX =>
    getPropertyValue('${_browserPrefix}perspective-origin-x');

  /** Sets the value of "perspective-origin-x" */
  void set perspectiveOriginX(String value) {
    setProperty('${_browserPrefix}perspective-origin-x', value, '');
  }

  /** Gets the value of "perspective-origin-y" */
  String get perspectiveOriginY =>
    getPropertyValue('${_browserPrefix}perspective-origin-y');

  /** Sets the value of "perspective-origin-y" */
  void set perspectiveOriginY(String value) {
    setProperty('${_browserPrefix}perspective-origin-y', value, '');
  }

  /** Gets the value of "pointer-events" */
  String get pointerEvents =>
    getPropertyValue('pointer-events');

  /** Sets the value of "pointer-events" */
  void set pointerEvents(String value) {
    setProperty('pointer-events', value, '');
  }

  /** Gets the value of "position" */
  String get position =>
    getPropertyValue('position');

  /** Sets the value of "position" */
  void set position(String value) {
    setProperty('position', value, '');
  }

  /** Gets the value of "print-color-adjust" */
  String get printColorAdjust =>
    getPropertyValue('${_browserPrefix}print-color-adjust');

  /** Sets the value of "print-color-adjust" */
  void set printColorAdjust(String value) {
    setProperty('${_browserPrefix}print-color-adjust', value, '');
  }

  /** Gets the value of "quotes" */
  String get quotes =>
    getPropertyValue('quotes');

  /** Sets the value of "quotes" */
  void set quotes(String value) {
    setProperty('quotes', value, '');
  }

  /** Gets the value of "region-break-after" */
  String get regionBreakAfter =>
    getPropertyValue('${_browserPrefix}region-break-after');

  /** Sets the value of "region-break-after" */
  void set regionBreakAfter(String value) {
    setProperty('${_browserPrefix}region-break-after', value, '');
  }

  /** Gets the value of "region-break-before" */
  String get regionBreakBefore =>
    getPropertyValue('${_browserPrefix}region-break-before');

  /** Sets the value of "region-break-before" */
  void set regionBreakBefore(String value) {
    setProperty('${_browserPrefix}region-break-before', value, '');
  }

  /** Gets the value of "region-break-inside" */
  String get regionBreakInside =>
    getPropertyValue('${_browserPrefix}region-break-inside');

  /** Sets the value of "region-break-inside" */
  void set regionBreakInside(String value) {
    setProperty('${_browserPrefix}region-break-inside', value, '');
  }

  /** Gets the value of "region-overflow" */
  String get regionOverflow =>
    getPropertyValue('${_browserPrefix}region-overflow');

  /** Sets the value of "region-overflow" */
  void set regionOverflow(String value) {
    setProperty('${_browserPrefix}region-overflow', value, '');
  }

  /** Gets the value of "resize" */
  String get resize =>
    getPropertyValue('resize');

  /** Sets the value of "resize" */
  void set resize(String value) {
    setProperty('resize', value, '');
  }

  /** Gets the value of "right" */
  String get right =>
    getPropertyValue('right');

  /** Sets the value of "right" */
  void set right(String value) {
    setProperty('right', value, '');
  }

  /** Gets the value of "rtl-ordering" */
  String get rtlOrdering =>
    getPropertyValue('${_browserPrefix}rtl-ordering');

  /** Sets the value of "rtl-ordering" */
  void set rtlOrdering(String value) {
    setProperty('${_browserPrefix}rtl-ordering', value, '');
  }

  /** Gets the value of "shape-inside" */
  String get shapeInside =>
    getPropertyValue('${_browserPrefix}shape-inside');

  /** Sets the value of "shape-inside" */
  void set shapeInside(String value) {
    setProperty('${_browserPrefix}shape-inside', value, '');
  }

  /** Gets the value of "shape-margin" */
  String get shapeMargin =>
    getPropertyValue('${_browserPrefix}shape-margin');

  /** Sets the value of "shape-margin" */
  void set shapeMargin(String value) {
    setProperty('${_browserPrefix}shape-margin', value, '');
  }

  /** Gets the value of "shape-outside" */
  String get shapeOutside =>
    getPropertyValue('${_browserPrefix}shape-outside');

  /** Sets the value of "shape-outside" */
  void set shapeOutside(String value) {
    setProperty('${_browserPrefix}shape-outside', value, '');
  }

  /** Gets the value of "shape-padding" */
  String get shapePadding =>
    getPropertyValue('${_browserPrefix}shape-padding');

  /** Sets the value of "shape-padding" */
  void set shapePadding(String value) {
    setProperty('${_browserPrefix}shape-padding', value, '');
  }

  /** Gets the value of "size" */
  String get size =>
    getPropertyValue('size');

  /** Sets the value of "size" */
  void set size(String value) {
    setProperty('size', value, '');
  }

  /** Gets the value of "speak" */
  String get speak =>
    getPropertyValue('speak');

  /** Sets the value of "speak" */
  void set speak(String value) {
    setProperty('speak', value, '');
  }

  /** Gets the value of "src" */
  String get src =>
    getPropertyValue('src');

  /** Sets the value of "src" */
  void set src(String value) {
    setProperty('src', value, '');
  }

  /** Gets the value of "tab-size" */
  String get tabSize =>
    getPropertyValue('tab-size');

  /** Sets the value of "tab-size" */
  void set tabSize(String value) {
    setProperty('tab-size', value, '');
  }

  /** Gets the value of "table-layout" */
  String get tableLayout =>
    getPropertyValue('table-layout');

  /** Sets the value of "table-layout" */
  void set tableLayout(String value) {
    setProperty('table-layout', value, '');
  }

  /** Gets the value of "tap-highlight-color" */
  String get tapHighlightColor =>
    getPropertyValue('${_browserPrefix}tap-highlight-color');

  /** Sets the value of "tap-highlight-color" */
  void set tapHighlightColor(String value) {
    setProperty('${_browserPrefix}tap-highlight-color', value, '');
  }

  /** Gets the value of "text-align" */
  String get textAlign =>
    getPropertyValue('text-align');

  /** Sets the value of "text-align" */
  void set textAlign(String value) {
    setProperty('text-align', value, '');
  }

  /** Gets the value of "text-align-last" */
  String get textAlignLast =>
    getPropertyValue('${_browserPrefix}text-align-last');

  /** Sets the value of "text-align-last" */
  void set textAlignLast(String value) {
    setProperty('${_browserPrefix}text-align-last', value, '');
  }

  /** Gets the value of "text-combine" */
  String get textCombine =>
    getPropertyValue('${_browserPrefix}text-combine');

  /** Sets the value of "text-combine" */
  void set textCombine(String value) {
    setProperty('${_browserPrefix}text-combine', value, '');
  }

  /** Gets the value of "text-decoration" */
  String get textDecoration =>
    getPropertyValue('text-decoration');

  /** Sets the value of "text-decoration" */
  void set textDecoration(String value) {
    setProperty('text-decoration', value, '');
  }

  /** Gets the value of "text-decoration-line" */
  String get textDecorationLine =>
    getPropertyValue('${_browserPrefix}text-decoration-line');

  /** Sets the value of "text-decoration-line" */
  void set textDecorationLine(String value) {
    setProperty('${_browserPrefix}text-decoration-line', value, '');
  }

  /** Gets the value of "text-decoration-style" */
  String get textDecorationStyle =>
    getPropertyValue('${_browserPrefix}text-decoration-style');

  /** Sets the value of "text-decoration-style" */
  void set textDecorationStyle(String value) {
    setProperty('${_browserPrefix}text-decoration-style', value, '');
  }

  /** Gets the value of "text-decorations-in-effect" */
  String get textDecorationsInEffect =>
    getPropertyValue('${_browserPrefix}text-decorations-in-effect');

  /** Sets the value of "text-decorations-in-effect" */
  void set textDecorationsInEffect(String value) {
    setProperty('${_browserPrefix}text-decorations-in-effect', value, '');
  }

  /** Gets the value of "text-emphasis" */
  String get textEmphasis =>
    getPropertyValue('${_browserPrefix}text-emphasis');

  /** Sets the value of "text-emphasis" */
  void set textEmphasis(String value) {
    setProperty('${_browserPrefix}text-emphasis', value, '');
  }

  /** Gets the value of "text-emphasis-color" */
  String get textEmphasisColor =>
    getPropertyValue('${_browserPrefix}text-emphasis-color');

  /** Sets the value of "text-emphasis-color" */
  void set textEmphasisColor(String value) {
    setProperty('${_browserPrefix}text-emphasis-color', value, '');
  }

  /** Gets the value of "text-emphasis-position" */
  String get textEmphasisPosition =>
    getPropertyValue('${_browserPrefix}text-emphasis-position');

  /** Sets the value of "text-emphasis-position" */
  void set textEmphasisPosition(String value) {
    setProperty('${_browserPrefix}text-emphasis-position', value, '');
  }

  /** Gets the value of "text-emphasis-style" */
  String get textEmphasisStyle =>
    getPropertyValue('${_browserPrefix}text-emphasis-style');

  /** Sets the value of "text-emphasis-style" */
  void set textEmphasisStyle(String value) {
    setProperty('${_browserPrefix}text-emphasis-style', value, '');
  }

  /** Gets the value of "text-fill-color" */
  String get textFillColor =>
    getPropertyValue('${_browserPrefix}text-fill-color');

  /** Sets the value of "text-fill-color" */
  void set textFillColor(String value) {
    setProperty('${_browserPrefix}text-fill-color', value, '');
  }

  /** Gets the value of "text-indent" */
  String get textIndent =>
    getPropertyValue('text-indent');

  /** Sets the value of "text-indent" */
  void set textIndent(String value) {
    setProperty('text-indent', value, '');
  }

  /** Gets the value of "text-line-through" */
  String get textLineThrough =>
    getPropertyValue('text-line-through');

  /** Sets the value of "text-line-through" */
  void set textLineThrough(String value) {
    setProperty('text-line-through', value, '');
  }

  /** Gets the value of "text-line-through-color" */
  String get textLineThroughColor =>
    getPropertyValue('text-line-through-color');

  /** Sets the value of "text-line-through-color" */
  void set textLineThroughColor(String value) {
    setProperty('text-line-through-color', value, '');
  }

  /** Gets the value of "text-line-through-mode" */
  String get textLineThroughMode =>
    getPropertyValue('text-line-through-mode');

  /** Sets the value of "text-line-through-mode" */
  void set textLineThroughMode(String value) {
    setProperty('text-line-through-mode', value, '');
  }

  /** Gets the value of "text-line-through-style" */
  String get textLineThroughStyle =>
    getPropertyValue('text-line-through-style');

  /** Sets the value of "text-line-through-style" */
  void set textLineThroughStyle(String value) {
    setProperty('text-line-through-style', value, '');
  }

  /** Gets the value of "text-line-through-width" */
  String get textLineThroughWidth =>
    getPropertyValue('text-line-through-width');

  /** Sets the value of "text-line-through-width" */
  void set textLineThroughWidth(String value) {
    setProperty('text-line-through-width', value, '');
  }

  /** Gets the value of "text-orientation" */
  String get textOrientation =>
    getPropertyValue('${_browserPrefix}text-orientation');

  /** Sets the value of "text-orientation" */
  void set textOrientation(String value) {
    setProperty('${_browserPrefix}text-orientation', value, '');
  }

  /** Gets the value of "text-overflow" */
  String get textOverflow =>
    getPropertyValue('text-overflow');

  /** Sets the value of "text-overflow" */
  void set textOverflow(String value) {
    setProperty('text-overflow', value, '');
  }

  /** Gets the value of "text-overline" */
  String get textOverline =>
    getPropertyValue('text-overline');

  /** Sets the value of "text-overline" */
  void set textOverline(String value) {
    setProperty('text-overline', value, '');
  }

  /** Gets the value of "text-overline-color" */
  String get textOverlineColor =>
    getPropertyValue('text-overline-color');

  /** Sets the value of "text-overline-color" */
  void set textOverlineColor(String value) {
    setProperty('text-overline-color', value, '');
  }

  /** Gets the value of "text-overline-mode" */
  String get textOverlineMode =>
    getPropertyValue('text-overline-mode');

  /** Sets the value of "text-overline-mode" */
  void set textOverlineMode(String value) {
    setProperty('text-overline-mode', value, '');
  }

  /** Gets the value of "text-overline-style" */
  String get textOverlineStyle =>
    getPropertyValue('text-overline-style');

  /** Sets the value of "text-overline-style" */
  void set textOverlineStyle(String value) {
    setProperty('text-overline-style', value, '');
  }

  /** Gets the value of "text-overline-width" */
  String get textOverlineWidth =>
    getPropertyValue('text-overline-width');

  /** Sets the value of "text-overline-width" */
  void set textOverlineWidth(String value) {
    setProperty('text-overline-width', value, '');
  }

  /** Gets the value of "text-rendering" */
  String get textRendering =>
    getPropertyValue('text-rendering');

  /** Sets the value of "text-rendering" */
  void set textRendering(String value) {
    setProperty('text-rendering', value, '');
  }

  /** Gets the value of "text-security" */
  String get textSecurity =>
    getPropertyValue('${_browserPrefix}text-security');

  /** Sets the value of "text-security" */
  void set textSecurity(String value) {
    setProperty('${_browserPrefix}text-security', value, '');
  }

  /** Gets the value of "text-shadow" */
  String get textShadow =>
    getPropertyValue('text-shadow');

  /** Sets the value of "text-shadow" */
  void set textShadow(String value) {
    setProperty('text-shadow', value, '');
  }

  /** Gets the value of "text-size-adjust" */
  String get textSizeAdjust =>
    getPropertyValue('${_browserPrefix}text-size-adjust');

  /** Sets the value of "text-size-adjust" */
  void set textSizeAdjust(String value) {
    setProperty('${_browserPrefix}text-size-adjust', value, '');
  }

  /** Gets the value of "text-stroke" */
  String get textStroke =>
    getPropertyValue('${_browserPrefix}text-stroke');

  /** Sets the value of "text-stroke" */
  void set textStroke(String value) {
    setProperty('${_browserPrefix}text-stroke', value, '');
  }

  /** Gets the value of "text-stroke-color" */
  String get textStrokeColor =>
    getPropertyValue('${_browserPrefix}text-stroke-color');

  /** Sets the value of "text-stroke-color" */
  void set textStrokeColor(String value) {
    setProperty('${_browserPrefix}text-stroke-color', value, '');
  }

  /** Gets the value of "text-stroke-width" */
  String get textStrokeWidth =>
    getPropertyValue('${_browserPrefix}text-stroke-width');

  /** Sets the value of "text-stroke-width" */
  void set textStrokeWidth(String value) {
    setProperty('${_browserPrefix}text-stroke-width', value, '');
  }

  /** Gets the value of "text-transform" */
  String get textTransform =>
    getPropertyValue('text-transform');

  /** Sets the value of "text-transform" */
  void set textTransform(String value) {
    setProperty('text-transform', value, '');
  }

  /** Gets the value of "text-underline" */
  String get textUnderline =>
    getPropertyValue('text-underline');

  /** Sets the value of "text-underline" */
  void set textUnderline(String value) {
    setProperty('text-underline', value, '');
  }

  /** Gets the value of "text-underline-color" */
  String get textUnderlineColor =>
    getPropertyValue('text-underline-color');

  /** Sets the value of "text-underline-color" */
  void set textUnderlineColor(String value) {
    setProperty('text-underline-color', value, '');
  }

  /** Gets the value of "text-underline-mode" */
  String get textUnderlineMode =>
    getPropertyValue('text-underline-mode');

  /** Sets the value of "text-underline-mode" */
  void set textUnderlineMode(String value) {
    setProperty('text-underline-mode', value, '');
  }

  /** Gets the value of "text-underline-style" */
  String get textUnderlineStyle =>
    getPropertyValue('text-underline-style');

  /** Sets the value of "text-underline-style" */
  void set textUnderlineStyle(String value) {
    setProperty('text-underline-style', value, '');
  }

  /** Gets the value of "text-underline-width" */
  String get textUnderlineWidth =>
    getPropertyValue('text-underline-width');

  /** Sets the value of "text-underline-width" */
  void set textUnderlineWidth(String value) {
    setProperty('text-underline-width', value, '');
  }

  /** Gets the value of "top" */
  String get top =>
    getPropertyValue('top');

  /** Sets the value of "top" */
  void set top(String value) {
    setProperty('top', value, '');
  }

  /** Gets the value of "transform" */
  String get transform =>
    getPropertyValue('${_browserPrefix}transform');

  /** Sets the value of "transform" */
  void set transform(String value) {
    setProperty('${_browserPrefix}transform', value, '');
  }

  /** Gets the value of "transform-origin" */
  String get transformOrigin =>
    getPropertyValue('${_browserPrefix}transform-origin');

  /** Sets the value of "transform-origin" */
  void set transformOrigin(String value) {
    setProperty('${_browserPrefix}transform-origin', value, '');
  }

  /** Gets the value of "transform-origin-x" */
  String get transformOriginX =>
    getPropertyValue('${_browserPrefix}transform-origin-x');

  /** Sets the value of "transform-origin-x" */
  void set transformOriginX(String value) {
    setProperty('${_browserPrefix}transform-origin-x', value, '');
  }

  /** Gets the value of "transform-origin-y" */
  String get transformOriginY =>
    getPropertyValue('${_browserPrefix}transform-origin-y');

  /** Sets the value of "transform-origin-y" */
  void set transformOriginY(String value) {
    setProperty('${_browserPrefix}transform-origin-y', value, '');
  }

  /** Gets the value of "transform-origin-z" */
  String get transformOriginZ =>
    getPropertyValue('${_browserPrefix}transform-origin-z');

  /** Sets the value of "transform-origin-z" */
  void set transformOriginZ(String value) {
    setProperty('${_browserPrefix}transform-origin-z', value, '');
  }

  /** Gets the value of "transform-style" */
  String get transformStyle =>
    getPropertyValue('${_browserPrefix}transform-style');

  /** Sets the value of "transform-style" */
  void set transformStyle(String value) {
    setProperty('${_browserPrefix}transform-style', value, '');
  }

  /** Gets the value of "transition" */
  String get transition =>
    getPropertyValue('${_browserPrefix}transition');

  /** Sets the value of "transition" */
  void set transition(String value) {
    setProperty('${_browserPrefix}transition', value, '');
  }

  /** Gets the value of "transition-delay" */
  String get transitionDelay =>
    getPropertyValue('${_browserPrefix}transition-delay');

  /** Sets the value of "transition-delay" */
  void set transitionDelay(String value) {
    setProperty('${_browserPrefix}transition-delay', value, '');
  }

  /** Gets the value of "transition-duration" */
  String get transitionDuration =>
    getPropertyValue('${_browserPrefix}transition-duration');

  /** Sets the value of "transition-duration" */
  void set transitionDuration(String value) {
    setProperty('${_browserPrefix}transition-duration', value, '');
  }

  /** Gets the value of "transition-property" */
  String get transitionProperty =>
    getPropertyValue('${_browserPrefix}transition-property');

  /** Sets the value of "transition-property" */
  void set transitionProperty(String value) {
    setProperty('${_browserPrefix}transition-property', value, '');
  }

  /** Gets the value of "transition-timing-function" */
  String get transitionTimingFunction =>
    getPropertyValue('${_browserPrefix}transition-timing-function');

  /** Sets the value of "transition-timing-function" */
  void set transitionTimingFunction(String value) {
    setProperty('${_browserPrefix}transition-timing-function', value, '');
  }

  /** Gets the value of "unicode-bidi" */
  String get unicodeBidi =>
    getPropertyValue('unicode-bidi');

  /** Sets the value of "unicode-bidi" */
  void set unicodeBidi(String value) {
    setProperty('unicode-bidi', value, '');
  }

  /** Gets the value of "unicode-range" */
  String get unicodeRange =>
    getPropertyValue('unicode-range');

  /** Sets the value of "unicode-range" */
  void set unicodeRange(String value) {
    setProperty('unicode-range', value, '');
  }

  /** Gets the value of "user-drag" */
  String get userDrag =>
    getPropertyValue('${_browserPrefix}user-drag');

  /** Sets the value of "user-drag" */
  void set userDrag(String value) {
    setProperty('${_browserPrefix}user-drag', value, '');
  }

  /** Gets the value of "user-modify" */
  String get userModify =>
    getPropertyValue('${_browserPrefix}user-modify');

  /** Sets the value of "user-modify" */
  void set userModify(String value) {
    setProperty('${_browserPrefix}user-modify', value, '');
  }

  /** Gets the value of "user-select" */
  String get userSelect =>
    getPropertyValue('${_browserPrefix}user-select');

  /** Sets the value of "user-select" */
  void set userSelect(String value) {
    setProperty('${_browserPrefix}user-select', value, '');
  }

  /** Gets the value of "user-zoom" */
  String get userZoom =>
    getPropertyValue('user-zoom');

  /** Sets the value of "user-zoom" */
  void set userZoom(String value) {
    setProperty('user-zoom', value, '');
  }

  /** Gets the value of "vertical-align" */
  String get verticalAlign =>
    getPropertyValue('vertical-align');

  /** Sets the value of "vertical-align" */
  void set verticalAlign(String value) {
    setProperty('vertical-align', value, '');
  }

  /** Gets the value of "visibility" */
  String get visibility =>
    getPropertyValue('visibility');

  /** Sets the value of "visibility" */
  void set visibility(String value) {
    setProperty('visibility', value, '');
  }

  /** Gets the value of "white-space" */
  String get whiteSpace =>
    getPropertyValue('white-space');

  /** Sets the value of "white-space" */
  void set whiteSpace(String value) {
    setProperty('white-space', value, '');
  }

  /** Gets the value of "widows" */
  String get widows =>
    getPropertyValue('widows');

  /** Sets the value of "widows" */
  void set widows(String value) {
    setProperty('widows', value, '');
  }

  /** Gets the value of "width" */
  String get width =>
    getPropertyValue('width');

  /** Sets the value of "width" */
  void set width(String value) {
    setProperty('width', value, '');
  }

  /** Gets the value of "word-break" */
  String get wordBreak =>
    getPropertyValue('word-break');

  /** Sets the value of "word-break" */
  void set wordBreak(String value) {
    setProperty('word-break', value, '');
  }

  /** Gets the value of "word-spacing" */
  String get wordSpacing =>
    getPropertyValue('word-spacing');

  /** Sets the value of "word-spacing" */
  void set wordSpacing(String value) {
    setProperty('word-spacing', value, '');
  }

  /** Gets the value of "word-wrap" */
  String get wordWrap =>
    getPropertyValue('word-wrap');

  /** Sets the value of "word-wrap" */
  void set wordWrap(String value) {
    setProperty('word-wrap', value, '');
  }

  /** Gets the value of "wrap" */
  String get wrap =>
    getPropertyValue('${_browserPrefix}wrap');

  /** Sets the value of "wrap" */
  void set wrap(String value) {
    setProperty('${_browserPrefix}wrap', value, '');
  }

  /** Gets the value of "wrap-flow" */
  String get wrapFlow =>
    getPropertyValue('${_browserPrefix}wrap-flow');

  /** Sets the value of "wrap-flow" */
  void set wrapFlow(String value) {
    setProperty('${_browserPrefix}wrap-flow', value, '');
  }

  /** Gets the value of "wrap-through" */
  String get wrapThrough =>
    getPropertyValue('${_browserPrefix}wrap-through');

  /** Sets the value of "wrap-through" */
  void set wrapThrough(String value) {
    setProperty('${_browserPrefix}wrap-through', value, '');
  }

  /** Gets the value of "writing-mode" */
  String get writingMode =>
    getPropertyValue('${_browserPrefix}writing-mode');

  /** Sets the value of "writing-mode" */
  void set writingMode(String value) {
    setProperty('${_browserPrefix}writing-mode', value, '');
  }

  /** Gets the value of "z-index" */
  String get zIndex =>
    getPropertyValue('z-index');

  /** Sets the value of "z-index" */
  void set zIndex(String value) {
    setProperty('z-index', value, '');
  }

  /** Gets the value of "zoom" */
  String get zoom =>
    getPropertyValue('zoom');

  /** Sets the value of "zoom" */
  void set zoom(String value) {
    setProperty('zoom', value, '');
  }
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('CSSStyleRule')
class CssStyleRule extends CssRule {
  CssStyleRule.internal() : super.internal();

  @DomName('CSSStyleRule.selectorText')
  @DocsEditable
  String get selectorText native "CSSStyleRule_selectorText_Getter";

  @DomName('CSSStyleRule.selectorText')
  @DocsEditable
  void set selectorText(String value) native "CSSStyleRule_selectorText_Setter";

  @DomName('CSSStyleRule.style')
  @DocsEditable
  CssStyleDeclaration get style native "CSSStyleRule_style_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('CSSStyleSheet')
class CssStyleSheet extends StyleSheet {
  CssStyleSheet.internal() : super.internal();

  @DomName('CSSStyleSheet.cssRules')
  @DocsEditable
  List<CssRule> get cssRules native "CSSStyleSheet_cssRules_Getter";

  @DomName('CSSStyleSheet.ownerRule')
  @DocsEditable
  CssRule get ownerRule native "CSSStyleSheet_ownerRule_Getter";

  @DomName('CSSStyleSheet.rules')
  @DocsEditable
  List<CssRule> get rules native "CSSStyleSheet_rules_Getter";

  int addRule(String selector, String style, [int index]) {
    if (?index) {
      return _addRule_1(selector, style, index);
    }
    return _addRule_2(selector, style);
  }

  @DomName('CSSStyleSheet._addRule_1')
  @DocsEditable
  int _addRule_1(selector, style, index) native "CSSStyleSheet__addRule_1_Callback";

  @DomName('CSSStyleSheet._addRule_2')
  @DocsEditable
  int _addRule_2(selector, style) native "CSSStyleSheet__addRule_2_Callback";

  @DomName('CSSStyleSheet.deleteRule')
  @DocsEditable
  void deleteRule(int index) native "CSSStyleSheet_deleteRule_Callback";

  @DomName('CSSStyleSheet.insertRule')
  @DocsEditable
  int insertRule(String rule, int index) native "CSSStyleSheet_insertRule_Callback";

  @DomName('CSSStyleSheet.removeRule')
  @DocsEditable
  void removeRule(int index) native "CSSStyleSheet_removeRule_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('WebKitCSSTransformValue')
class CssTransformValue extends _CssValueList {
  CssTransformValue.internal() : super.internal();

  static const int CSS_MATRIX = 11;

  static const int CSS_MATRIX3D = 21;

  static const int CSS_PERSPECTIVE = 20;

  static const int CSS_ROTATE = 4;

  static const int CSS_ROTATE3D = 17;

  static const int CSS_ROTATEX = 14;

  static const int CSS_ROTATEY = 15;

  static const int CSS_ROTATEZ = 16;

  static const int CSS_SCALE = 5;

  static const int CSS_SCALE3D = 19;

  static const int CSS_SCALEX = 6;

  static const int CSS_SCALEY = 7;

  static const int CSS_SCALEZ = 18;

  static const int CSS_SKEW = 8;

  static const int CSS_SKEWX = 9;

  static const int CSS_SKEWY = 10;

  static const int CSS_TRANSLATE = 1;

  static const int CSS_TRANSLATE3D = 13;

  static const int CSS_TRANSLATEX = 2;

  static const int CSS_TRANSLATEY = 3;

  static const int CSS_TRANSLATEZ = 12;

  @DomName('WebKitCSSTransformValue.operationType')
  @DocsEditable
  int get operationType native "WebKitCSSTransformValue_operationType_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('CSSUnknownRule')
class CssUnknownRule extends CssRule {
  CssUnknownRule.internal() : super.internal();

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('CSSValue')
class CssValue extends NativeFieldWrapperClass1 {
  CssValue.internal();

  static const int CSS_CUSTOM = 3;

  static const int CSS_INHERIT = 0;

  static const int CSS_PRIMITIVE_VALUE = 1;

  static const int CSS_VALUE_LIST = 2;

  @DomName('CSSValue.cssText')
  @DocsEditable
  String get cssText native "CSSValue_cssText_Getter";

  @DomName('CSSValue.cssText')
  @DocsEditable
  void set cssText(String value) native "CSSValue_cssText_Setter";

  @DomName('CSSValue.cssValueType')
  @DocsEditable
  int get cssValueType native "CSSValue_cssValueType_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DomName('CustomEvent')
class CustomEvent extends Event {
  factory CustomEvent(String type,
      {bool canBubble: true, bool cancelable: true, Object detail}) {

    final CustomEvent e = document.$dom_createEvent("CustomEvent");
    e.$dom_initCustomEvent(type, canBubble, cancelable, detail);

    return e;
  }
  CustomEvent.internal() : super.internal();

  @DomName('CustomEvent.detail')
  @DocsEditable
  Object get detail native "CustomEvent_detail_Getter";

  @DomName('CustomEvent.initCustomEvent')
  @DocsEditable
  void $dom_initCustomEvent(String typeArg, bool canBubbleArg, bool cancelableArg, Object detailArg) native "CustomEvent_initCustomEvent_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('HTMLDListElement')
class DListElement extends _Element_Merged {
  DListElement.internal() : super.internal();

  @DocsEditable
  factory DListElement() => document.$dom_createElement("dl");

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('HTMLDataListElement')
@SupportedBrowser(SupportedBrowser.CHROME)
@SupportedBrowser(SupportedBrowser.FIREFOX)
@SupportedBrowser(SupportedBrowser.IE, '10')
@SupportedBrowser(SupportedBrowser.SAFARI)
class DataListElement extends _Element_Merged {
  DataListElement.internal() : super.internal();

  @DocsEditable
  factory DataListElement() => document.$dom_createElement("datalist");

  /// Checks if this type is supported on the current platform.
  static bool get supported => true;

  @DomName('HTMLDataListElement.options')
  @DocsEditable
  HtmlCollection get options native "HTMLDataListElement_options_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('DataTransferItem')
class DataTransferItem extends NativeFieldWrapperClass1 {
  DataTransferItem.internal();

  @DomName('DataTransferItem.kind')
  @DocsEditable
  String get kind native "DataTransferItem_kind_Getter";

  @DomName('DataTransferItem.type')
  @DocsEditable
  String get type native "DataTransferItem_type_Getter";

  @DomName('DataTransferItem.getAsFile')
  @DocsEditable
  Blob getAsFile() native "DataTransferItem_getAsFile_Callback";

  @DomName('DataTransferItem.getAsString')
  @DocsEditable
  void getAsString([StringCallback callback]) native "DataTransferItem_getAsString_Callback";

  @DomName('DataTransferItem.webkitGetAsEntry')
  @DocsEditable
  Entry webkitGetAsEntry() native "DataTransferItem_webkitGetAsEntry_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('DataTransferItemList')
class DataTransferItemList extends NativeFieldWrapperClass1 {
  DataTransferItemList.internal();

  @DomName('DataTransferItemList.length')
  @DocsEditable
  int get length native "DataTransferItemList_length_Getter";

  void add(data_OR_file, [String type]) {
    if ((data_OR_file is File || data_OR_file == null) && !?type) {
      _add_1(data_OR_file);
      return;
    }
    if ((data_OR_file is String || data_OR_file == null) && (type is String || type == null)) {
      _add_2(data_OR_file, type);
      return;
    }
    throw new ArgumentError("Incorrect number or type of arguments");
  }

  @DomName('DataTransferItemList._add_1')
  @DocsEditable
  void _add_1(data_OR_file) native "DataTransferItemList__add_1_Callback";

  @DomName('DataTransferItemList._add_2')
  @DocsEditable
  void _add_2(data_OR_file, type) native "DataTransferItemList__add_2_Callback";

  @DomName('DataTransferItemList.clear')
  @DocsEditable
  void clear() native "DataTransferItemList_clear_Callback";

  @DomName('DataTransferItemList.item')
  @DocsEditable
  DataTransferItem item(int index) native "DataTransferItemList_item_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('DataView')
class DataView extends ArrayBufferView {
  DataView.internal() : super.internal();

  @DocsEditable
  factory DataView(ArrayBuffer buffer, [int byteOffset, int byteLength]) {
    if (!?byteOffset) {
      return DataView._create(buffer);
    }
    if (!?byteLength) {
      return DataView._create(buffer, byteOffset);
    }
    return DataView._create(buffer, byteOffset, byteLength);
  }
  static DataView _create(ArrayBuffer buffer, [int byteOffset, int byteLength]) native "DataView_constructor_Callback";

  num getFloat32(int byteOffset, {bool littleEndian}) {
    if (?littleEndian) {
      return _getFloat32_1(byteOffset, littleEndian);
    }
    return _getFloat32_2(byteOffset);
  }

  @DomName('DataView._getFloat32_1')
  @DocsEditable
  num _getFloat32_1(byteOffset, littleEndian) native "DataView__getFloat32_1_Callback";

  @DomName('DataView._getFloat32_2')
  @DocsEditable
  num _getFloat32_2(byteOffset) native "DataView__getFloat32_2_Callback";

  num getFloat64(int byteOffset, {bool littleEndian}) {
    if (?littleEndian) {
      return _getFloat64_1(byteOffset, littleEndian);
    }
    return _getFloat64_2(byteOffset);
  }

  @DomName('DataView._getFloat64_1')
  @DocsEditable
  num _getFloat64_1(byteOffset, littleEndian) native "DataView__getFloat64_1_Callback";

  @DomName('DataView._getFloat64_2')
  @DocsEditable
  num _getFloat64_2(byteOffset) native "DataView__getFloat64_2_Callback";

  int getInt16(int byteOffset, {bool littleEndian}) {
    if (?littleEndian) {
      return _getInt16_1(byteOffset, littleEndian);
    }
    return _getInt16_2(byteOffset);
  }

  @DomName('DataView._getInt16_1')
  @DocsEditable
  int _getInt16_1(byteOffset, littleEndian) native "DataView__getInt16_1_Callback";

  @DomName('DataView._getInt16_2')
  @DocsEditable
  int _getInt16_2(byteOffset) native "DataView__getInt16_2_Callback";

  int getInt32(int byteOffset, {bool littleEndian}) {
    if (?littleEndian) {
      return _getInt32_1(byteOffset, littleEndian);
    }
    return _getInt32_2(byteOffset);
  }

  @DomName('DataView._getInt32_1')
  @DocsEditable
  int _getInt32_1(byteOffset, littleEndian) native "DataView__getInt32_1_Callback";

  @DomName('DataView._getInt32_2')
  @DocsEditable
  int _getInt32_2(byteOffset) native "DataView__getInt32_2_Callback";

  @DomName('DataView.getInt8')
  @DocsEditable
  int getInt8(int byteOffset) native "DataView_getInt8_Callback";

  int getUint16(int byteOffset, {bool littleEndian}) {
    if (?littleEndian) {
      return _getUint16_1(byteOffset, littleEndian);
    }
    return _getUint16_2(byteOffset);
  }

  @DomName('DataView._getUint16_1')
  @DocsEditable
  int _getUint16_1(byteOffset, littleEndian) native "DataView__getUint16_1_Callback";

  @DomName('DataView._getUint16_2')
  @DocsEditable
  int _getUint16_2(byteOffset) native "DataView__getUint16_2_Callback";

  int getUint32(int byteOffset, {bool littleEndian}) {
    if (?littleEndian) {
      return _getUint32_1(byteOffset, littleEndian);
    }
    return _getUint32_2(byteOffset);
  }

  @DomName('DataView._getUint32_1')
  @DocsEditable
  int _getUint32_1(byteOffset, littleEndian) native "DataView__getUint32_1_Callback";

  @DomName('DataView._getUint32_2')
  @DocsEditable
  int _getUint32_2(byteOffset) native "DataView__getUint32_2_Callback";

  @DomName('DataView.getUint8')
  @DocsEditable
  int getUint8(int byteOffset) native "DataView_getUint8_Callback";

  void setFloat32(int byteOffset, num value, {bool littleEndian}) {
    if (?littleEndian) {
      _setFloat32_1(byteOffset, value, littleEndian);
      return;
    }
    _setFloat32_2(byteOffset, value);
    return;
  }

  @DomName('DataView._setFloat32_1')
  @DocsEditable
  void _setFloat32_1(byteOffset, value, littleEndian) native "DataView__setFloat32_1_Callback";

  @DomName('DataView._setFloat32_2')
  @DocsEditable
  void _setFloat32_2(byteOffset, value) native "DataView__setFloat32_2_Callback";

  void setFloat64(int byteOffset, num value, {bool littleEndian}) {
    if (?littleEndian) {
      _setFloat64_1(byteOffset, value, littleEndian);
      return;
    }
    _setFloat64_2(byteOffset, value);
    return;
  }

  @DomName('DataView._setFloat64_1')
  @DocsEditable
  void _setFloat64_1(byteOffset, value, littleEndian) native "DataView__setFloat64_1_Callback";

  @DomName('DataView._setFloat64_2')
  @DocsEditable
  void _setFloat64_2(byteOffset, value) native "DataView__setFloat64_2_Callback";

  void setInt16(int byteOffset, int value, {bool littleEndian}) {
    if (?littleEndian) {
      _setInt16_1(byteOffset, value, littleEndian);
      return;
    }
    _setInt16_2(byteOffset, value);
    return;
  }

  @DomName('DataView._setInt16_1')
  @DocsEditable
  void _setInt16_1(byteOffset, value, littleEndian) native "DataView__setInt16_1_Callback";

  @DomName('DataView._setInt16_2')
  @DocsEditable
  void _setInt16_2(byteOffset, value) native "DataView__setInt16_2_Callback";

  void setInt32(int byteOffset, int value, {bool littleEndian}) {
    if (?littleEndian) {
      _setInt32_1(byteOffset, value, littleEndian);
      return;
    }
    _setInt32_2(byteOffset, value);
    return;
  }

  @DomName('DataView._setInt32_1')
  @DocsEditable
  void _setInt32_1(byteOffset, value, littleEndian) native "DataView__setInt32_1_Callback";

  @DomName('DataView._setInt32_2')
  @DocsEditable
  void _setInt32_2(byteOffset, value) native "DataView__setInt32_2_Callback";

  @DomName('DataView.setInt8')
  @DocsEditable
  void setInt8(int byteOffset, int value) native "DataView_setInt8_Callback";

  void setUint16(int byteOffset, int value, {bool littleEndian}) {
    if (?littleEndian) {
      _setUint16_1(byteOffset, value, littleEndian);
      return;
    }
    _setUint16_2(byteOffset, value);
    return;
  }

  @DomName('DataView._setUint16_1')
  @DocsEditable
  void _setUint16_1(byteOffset, value, littleEndian) native "DataView__setUint16_1_Callback";

  @DomName('DataView._setUint16_2')
  @DocsEditable
  void _setUint16_2(byteOffset, value) native "DataView__setUint16_2_Callback";

  void setUint32(int byteOffset, int value, {bool littleEndian}) {
    if (?littleEndian) {
      _setUint32_1(byteOffset, value, littleEndian);
      return;
    }
    _setUint32_2(byteOffset, value);
    return;
  }

  @DomName('DataView._setUint32_1')
  @DocsEditable
  void _setUint32_1(byteOffset, value, littleEndian) native "DataView__setUint32_1_Callback";

  @DomName('DataView._setUint32_2')
  @DocsEditable
  void _setUint32_2(byteOffset, value) native "DataView__setUint32_2_Callback";

  @DomName('DataView.setUint8')
  @DocsEditable
  void setUint8(int byteOffset, int value) native "DataView_setUint8_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('Database')
@SupportedBrowser(SupportedBrowser.CHROME)
@SupportedBrowser(SupportedBrowser.SAFARI)
@Experimental
class Database extends NativeFieldWrapperClass1 {
  Database.internal();

  /// Checks if this type is supported on the current platform.
  static bool get supported => true;

  @DomName('Database.version')
  @DocsEditable
  String get version native "Database_version_Getter";

  @DomName('Database.changeVersion')
  @DocsEditable
  void changeVersion(String oldVersion, String newVersion, [SqlTransactionCallback callback, SqlTransactionErrorCallback errorCallback, VoidCallback successCallback]) native "Database_changeVersion_Callback";

  @DomName('Database.readTransaction')
  @DocsEditable
  void readTransaction(SqlTransactionCallback callback, [SqlTransactionErrorCallback errorCallback, VoidCallback successCallback]) native "Database_readTransaction_Callback";

  @DomName('Database.transaction')
  @DocsEditable
  void transaction(SqlTransactionCallback callback, [SqlTransactionErrorCallback errorCallback, VoidCallback successCallback]) native "Database_transaction_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


typedef void DatabaseCallback(database);
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('DatabaseSync')
@SupportedBrowser(SupportedBrowser.CHROME)
@SupportedBrowser(SupportedBrowser.SAFARI)
@Experimental
class DatabaseSync extends NativeFieldWrapperClass1 {
  DatabaseSync.internal();

  @DomName('DatabaseSync.lastErrorMessage')
  @DocsEditable
  String get lastErrorMessage native "DatabaseSync_lastErrorMessage_Getter";

  @DomName('DatabaseSync.version')
  @DocsEditable
  String get version native "DatabaseSync_version_Getter";

  @DomName('DatabaseSync.changeVersion')
  @DocsEditable
  void changeVersion(String oldVersion, String newVersion, [SqlTransactionSyncCallback callback]) native "DatabaseSync_changeVersion_Callback";

  @DomName('DatabaseSync.readTransaction')
  @DocsEditable
  void readTransaction(SqlTransactionSyncCallback callback) native "DatabaseSync_readTransaction_Callback";

  @DomName('DatabaseSync.transaction')
  @DocsEditable
  void transaction(SqlTransactionSyncCallback callback) native "DatabaseSync_transaction_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('DedicatedWorkerContext')
class DedicatedWorkerContext extends WorkerContext {
  DedicatedWorkerContext.internal() : super.internal();

  @DomName('DedicatedWorkerContext.message')
  @DocsEditable
  static const EventStreamProvider<MessageEvent> messageEvent = const EventStreamProvider<MessageEvent>('message');

  @DocsEditable
  @DomName('EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent')
  @deprecated
  DedicatedWorkerContextEvents get on =>
    new DedicatedWorkerContextEvents(this);

  @DomName('DedicatedWorkerContext.postMessage')
  @DocsEditable
  void postMessage(Object message, [List messagePorts]) native "DedicatedWorkerContext_postMessage_Callback";

  @DomName('DedicatedWorkerContext.message')
  @DocsEditable
  Stream<MessageEvent> get onMessage => messageEvent.forTarget(this);

}

@DocsEditable
@deprecated
class DedicatedWorkerContextEvents extends WorkerContextEvents {
  @DocsEditable
  DedicatedWorkerContextEvents(EventTarget _ptr) : super(_ptr);

  @DocsEditable
  EventListenerList get message => this['message'];
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('HTMLDetailsElement')
@SupportedBrowser(SupportedBrowser.CHROME)
@SupportedBrowser(SupportedBrowser.SAFARI)
@Experimental
class DetailsElement extends _Element_Merged {
  DetailsElement.internal() : super.internal();

  @DocsEditable
  factory DetailsElement() => document.$dom_createElement("details");

  /// Checks if this type is supported on the current platform.
  static bool get supported => true;

  @DomName('HTMLDetailsElement.open')
  @DocsEditable
  bool get open native "HTMLDetailsElement_open_Getter";

  @DomName('HTMLDetailsElement.open')
  @DocsEditable
  void set open(bool value) native "HTMLDetailsElement_open_Setter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('DeviceMotionEvent')
class DeviceMotionEvent extends Event {
  DeviceMotionEvent.internal() : super.internal();

  @DomName('DeviceMotionEvent.interval')
  @DocsEditable
  num get interval native "DeviceMotionEvent_interval_Getter";

}
// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

@DomName('DeviceOrientationEvent')

class DeviceOrientationEvent extends Event {
  factory DeviceOrientationEvent(String type,
      {bool canBubble: true, bool cancelable: true, num alpha: 0, num beta: 0,
      num gamma: 0, bool absolute: false}) {
    var e = document.$dom_createEvent("DeviceOrientationEvent");
    e.$dom_initDeviceOrientationEvent(type, canBubble, cancelable, alpha, beta,
        gamma, absolute);
    return e;
  }
  DeviceOrientationEvent.internal() : super.internal();

  @DomName('DeviceOrientationEvent.absolute')
  @DocsEditable
  bool get absolute native "DeviceOrientationEvent_absolute_Getter";

  @DomName('DeviceOrientationEvent.alpha')
  @DocsEditable
  num get alpha native "DeviceOrientationEvent_alpha_Getter";

  @DomName('DeviceOrientationEvent.beta')
  @DocsEditable
  num get beta native "DeviceOrientationEvent_beta_Getter";

  @DomName('DeviceOrientationEvent.gamma')
  @DocsEditable
  num get gamma native "DeviceOrientationEvent_gamma_Getter";

  @DomName('DeviceOrientationEvent.initDeviceOrientationEvent')
  @DocsEditable
  void $dom_initDeviceOrientationEvent(String type, bool bubbles, bool cancelable, num alpha, num beta, num gamma, bool absolute) native "DeviceOrientationEvent_initDeviceOrientationEvent_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('DirectoryEntry')
class DirectoryEntry extends Entry {
  DirectoryEntry.internal() : super.internal();

  @DomName('DirectoryEntry.createReader')
  @DocsEditable
  DirectoryReader createReader() native "DirectoryEntry_createReader_Callback";

  @DomName('DirectoryEntry.getDirectory')
  @DocsEditable
  void getDirectory(String path, {Map options, EntryCallback successCallback, ErrorCallback errorCallback}) native "DirectoryEntry_getDirectory_Callback";

  @DomName('DirectoryEntry.getFile')
  @DocsEditable
  void getFile(String path, {Map options, EntryCallback successCallback, ErrorCallback errorCallback}) native "DirectoryEntry_getFile_Callback";

  @DomName('DirectoryEntry.removeRecursively')
  @DocsEditable
  void removeRecursively(VoidCallback successCallback, [ErrorCallback errorCallback]) native "DirectoryEntry_removeRecursively_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('DirectoryEntrySync')
class DirectoryEntrySync extends EntrySync {
  DirectoryEntrySync.internal() : super.internal();

  @DomName('DirectoryEntrySync.createReader')
  @DocsEditable
  DirectoryReaderSync createReader() native "DirectoryEntrySync_createReader_Callback";

  @DomName('DirectoryEntrySync.getDirectory')
  @DocsEditable
  DirectoryEntrySync getDirectory(String path, Map flags) native "DirectoryEntrySync_getDirectory_Callback";

  @DomName('DirectoryEntrySync.getFile')
  @DocsEditable
  FileEntrySync getFile(String path, Map flags) native "DirectoryEntrySync_getFile_Callback";

  @DomName('DirectoryEntrySync.removeRecursively')
  @DocsEditable
  void removeRecursively() native "DirectoryEntrySync_removeRecursively_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('DirectoryReader')
class DirectoryReader extends NativeFieldWrapperClass1 {
  DirectoryReader.internal();

  @DomName('DirectoryReader.readEntries')
  @DocsEditable
  void readEntries(EntriesCallback successCallback, [ErrorCallback errorCallback]) native "DirectoryReader_readEntries_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('DirectoryReaderSync')
class DirectoryReaderSync extends NativeFieldWrapperClass1 {
  DirectoryReaderSync.internal();

  @DomName('DirectoryReaderSync.readEntries')
  @DocsEditable
  List<EntrySync> readEntries() native "DirectoryReaderSync_readEntries_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('HTMLDivElement')
class DivElement extends _Element_Merged {
  DivElement.internal() : super.internal();

  @DocsEditable
  factory DivElement() => document.$dom_createElement("div");

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.


/**
 * The base class for all documents.
 *
 * Each web page loaded in the browser has its own [Document] object, which is
 * typically an [HtmlDocument].
 *
 * If you aren't comfortable with DOM concepts, see the Dart tutorial
 * [Target 2: Connect Dart & HTML](http://www.dartlang.org/docs/tutorials/connect-dart-html/).
 */
@DomName('Document')
class Document extends Node 
{

  Document.internal() : super.internal();

  @DomName('Document.readystatechange')
  @DocsEditable
  static const EventStreamProvider<Event> readyStateChangeEvent = const EventStreamProvider<Event>('readystatechange');

  @DomName('Document.selectionchange')
  @DocsEditable
  static const EventStreamProvider<Event> selectionChangeEvent = const EventStreamProvider<Event>('selectionchange');

  @DomName('Document.webkitpointerlockchange')
  @DocsEditable
  static const EventStreamProvider<Event> pointerLockChangeEvent = const EventStreamProvider<Event>('webkitpointerlockchange');

  @DomName('Document.webkitpointerlockerror')
  @DocsEditable
  static const EventStreamProvider<Event> pointerLockErrorEvent = const EventStreamProvider<Event>('webkitpointerlockerror');

  @DocsEditable
  @DomName('EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent')
  @deprecated
  DocumentEvents get on =>
    new DocumentEvents(this);

  @DomName('Document.body')
  @DocsEditable
  Element get $dom_body native "Document_body_Getter";

  @DomName('Document.body')
  @DocsEditable
  void set $dom_body(Element value) native "Document_body_Setter";

  @DomName('Document.charset')
  @DocsEditable
  String get charset native "Document_charset_Getter";

  @DomName('Document.charset')
  @DocsEditable
  void set charset(String value) native "Document_charset_Setter";

  @DomName('Document.cookie')
  @DocsEditable
  String get cookie native "Document_cookie_Getter";

  @DomName('Document.cookie')
  @DocsEditable
  void set cookie(String value) native "Document_cookie_Setter";

  @DomName('Document.defaultView')
  @DocsEditable
  WindowBase get window native "Document_defaultView_Getter";

  @DomName('Document.documentElement')
  @DocsEditable
  Element get documentElement native "Document_documentElement_Getter";

  @DomName('Document.domain')
  @DocsEditable
  String get domain native "Document_domain_Getter";

  @DomName('Document.head')
  @DocsEditable
  HeadElement get $dom_head native "Document_head_Getter";

  @DomName('Document.implementation')
  @DocsEditable
  DomImplementation get implementation native "Document_implementation_Getter";

  @DomName('Document.lastModified')
  @DocsEditable
  String get $dom_lastModified native "Document_lastModified_Getter";

  @DomName('Document.preferredStylesheetSet')
  @DocsEditable
  String get $dom_preferredStylesheetSet native "Document_preferredStylesheetSet_Getter";

  @DomName('Document.readyState')
  @DocsEditable
  String get readyState native "Document_readyState_Getter";

  @DomName('Document.referrer')
  @DocsEditable
  String get $dom_referrer native "Document_referrer_Getter";

  @DomName('Document.selectedStylesheetSet')
  @DocsEditable
  String get $dom_selectedStylesheetSet native "Document_selectedStylesheetSet_Getter";

  @DomName('Document.selectedStylesheetSet')
  @DocsEditable
  void set $dom_selectedStylesheetSet(String value) native "Document_selectedStylesheetSet_Setter";

  @DomName('Document.styleSheets')
  @DocsEditable
  List<StyleSheet> get $dom_styleSheets native "Document_styleSheets_Getter";

  @DomName('Document.title')
  @DocsEditable
  String get $dom_title native "Document_title_Getter";

  @DomName('Document.title')
  @DocsEditable
  void set $dom_title(String value) native "Document_title_Setter";

  @DomName('Document.webkitFullscreenElement')
  @DocsEditable
  Element get $dom_webkitFullscreenElement native "Document_webkitFullscreenElement_Getter";

  @DomName('Document.webkitFullscreenEnabled')
  @DocsEditable
  bool get $dom_webkitFullscreenEnabled native "Document_webkitFullscreenEnabled_Getter";

  @DomName('Document.webkitHidden')
  @DocsEditable
  bool get $dom_webkitHidden native "Document_webkitHidden_Getter";

  @DomName('Document.webkitIsFullScreen')
  @DocsEditable
  bool get $dom_webkitIsFullScreen native "Document_webkitIsFullScreen_Getter";

  @DomName('Document.webkitPointerLockElement')
  @DocsEditable
  Element get $dom_webkitPointerLockElement native "Document_webkitPointerLockElement_Getter";

  @DomName('Document.webkitVisibilityState')
  @DocsEditable
  String get $dom_webkitVisibilityState native "Document_webkitVisibilityState_Getter";

  @DomName('Document.caretRangeFromPoint')
  @DocsEditable
  Range $dom_caretRangeFromPoint(int x, int y) native "Document_caretRangeFromPoint_Callback";

  @DomName('Document.createCDATASection')
  @DocsEditable
  CDataSection createCDataSection(String data) native "Document_createCDATASection_Callback";

  @DomName('Document.createDocumentFragment')
  @DocsEditable
  DocumentFragment createDocumentFragment() native "Document_createDocumentFragment_Callback";

  @DomName('Document.createElement')
  @DocsEditable
  Element $dom_createElement(String tagName) native "Document_createElement_Callback";

  @DomName('Document.createElementNS')
  @DocsEditable
  Element $dom_createElementNS(String namespaceURI, String qualifiedName) native "Document_createElementNS_Callback";

  @DomName('Document.createEvent')
  @DocsEditable
  Event $dom_createEvent(String eventType) native "Document_createEvent_Callback";

  @DomName('Document.createRange')
  @DocsEditable
  Range $dom_createRange() native "Document_createRange_Callback";

  @DomName('Document.createTextNode')
  @DocsEditable
  Text $dom_createTextNode(String data) native "Document_createTextNode_Callback";

  @DomName('Document.createTouch')
  @DocsEditable
  Touch $dom_createTouch(Window window, EventTarget target, int identifier, int pageX, int pageY, int screenX, int screenY, int webkitRadiusX, int webkitRadiusY, num webkitRotationAngle, num webkitForce) native "Document_createTouch_Callback";

  @DomName('Document.createTouchList')
  @DocsEditable
  TouchList $dom_createTouchList() native "Document_createTouchList_Callback";

  @DomName('Document.elementFromPoint')
  @DocsEditable
  Element $dom_elementFromPoint(int x, int y) native "Document_elementFromPoint_Callback";

  @DomName('Document.execCommand')
  @DocsEditable
  bool execCommand(String command, bool userInterface, String value) native "Document_execCommand_Callback";

  @DomName('Document.getCSSCanvasContext')
  @DocsEditable
  CanvasRenderingContext $dom_getCssCanvasContext(String contextId, String name, int width, int height) native "Document_getCSSCanvasContext_Callback";

  @DomName('Document.getElementById')
  @DocsEditable
  Element $dom_getElementById(String elementId) native "Document_getElementById_Callback";

  @DomName('Document.getElementsByClassName')
  @DocsEditable
  List<Node> $dom_getElementsByClassName(String tagname) native "Document_getElementsByClassName_Callback";

  @DomName('Document.getElementsByName')
  @DocsEditable
  List<Node> $dom_getElementsByName(String elementName) native "Document_getElementsByName_Callback";

  @DomName('Document.getElementsByTagName')
  @DocsEditable
  List<Node> $dom_getElementsByTagName(String tagname) native "Document_getElementsByTagName_Callback";

  @DomName('Document.queryCommandEnabled')
  @DocsEditable
  bool queryCommandEnabled(String command) native "Document_queryCommandEnabled_Callback";

  @DomName('Document.queryCommandIndeterm')
  @DocsEditable
  bool queryCommandIndeterm(String command) native "Document_queryCommandIndeterm_Callback";

  @DomName('Document.queryCommandState')
  @DocsEditable
  bool queryCommandState(String command) native "Document_queryCommandState_Callback";

  @DomName('Document.queryCommandSupported')
  @DocsEditable
  bool queryCommandSupported(String command) native "Document_queryCommandSupported_Callback";

  @DomName('Document.queryCommandValue')
  @DocsEditable
  String queryCommandValue(String command) native "Document_queryCommandValue_Callback";

  @DomName('Document.querySelector')
  @DocsEditable
  Element $dom_querySelector(String selectors) native "Document_querySelector_Callback";

  @DomName('Document.querySelectorAll')
  @DocsEditable
  List<Node> $dom_querySelectorAll(String selectors) native "Document_querySelectorAll_Callback";

  @DomName('Document.webkitCancelFullScreen')
  @DocsEditable
  void $dom_webkitCancelFullScreen() native "Document_webkitCancelFullScreen_Callback";

  @DomName('Document.webkitExitFullscreen')
  @DocsEditable
  void $dom_webkitExitFullscreen() native "Document_webkitExitFullscreen_Callback";

  @DomName('Document.webkitExitPointerLock')
  @DocsEditable
  void $dom_webkitExitPointerLock() native "Document_webkitExitPointerLock_Callback";

  @DomName('Document.abort')
  @DocsEditable
  Stream<Event> get onAbort => Element.abortEvent.forTarget(this);

  @DomName('Document.beforecopy')
  @DocsEditable
  Stream<Event> get onBeforeCopy => Element.beforeCopyEvent.forTarget(this);

  @DomName('Document.beforecut')
  @DocsEditable
  Stream<Event> get onBeforeCut => Element.beforeCutEvent.forTarget(this);

  @DomName('Document.beforepaste')
  @DocsEditable
  Stream<Event> get onBeforePaste => Element.beforePasteEvent.forTarget(this);

  @DomName('Document.blur')
  @DocsEditable
  Stream<Event> get onBlur => Element.blurEvent.forTarget(this);

  @DomName('Document.change')
  @DocsEditable
  Stream<Event> get onChange => Element.changeEvent.forTarget(this);

  @DomName('Document.click')
  @DocsEditable
  Stream<MouseEvent> get onClick => Element.clickEvent.forTarget(this);

  @DomName('Document.contextmenu')
  @DocsEditable
  Stream<MouseEvent> get onContextMenu => Element.contextMenuEvent.forTarget(this);

  @DomName('Document.copy')
  @DocsEditable
  Stream<Event> get onCopy => Element.copyEvent.forTarget(this);

  @DomName('Document.cut')
  @DocsEditable
  Stream<Event> get onCut => Element.cutEvent.forTarget(this);

  @DomName('Document.dblclick')
  @DocsEditable
  Stream<Event> get onDoubleClick => Element.doubleClickEvent.forTarget(this);

  @DomName('Document.drag')
  @DocsEditable
  Stream<MouseEvent> get onDrag => Element.dragEvent.forTarget(this);

  @DomName('Document.dragend')
  @DocsEditable
  Stream<MouseEvent> get onDragEnd => Element.dragEndEvent.forTarget(this);

  @DomName('Document.dragenter')
  @DocsEditable
  Stream<MouseEvent> get onDragEnter => Element.dragEnterEvent.forTarget(this);

  @DomName('Document.dragleave')
  @DocsEditable
  Stream<MouseEvent> get onDragLeave => Element.dragLeaveEvent.forTarget(this);

  @DomName('Document.dragover')
  @DocsEditable
  Stream<MouseEvent> get onDragOver => Element.dragOverEvent.forTarget(this);

  @DomName('Document.dragstart')
  @DocsEditable
  Stream<MouseEvent> get onDragStart => Element.dragStartEvent.forTarget(this);

  @DomName('Document.drop')
  @DocsEditable
  Stream<MouseEvent> get onDrop => Element.dropEvent.forTarget(this);

  @DomName('Document.error')
  @DocsEditable
  Stream<Event> get onError => Element.errorEvent.forTarget(this);

  @DomName('Document.focus')
  @DocsEditable
  Stream<Event> get onFocus => Element.focusEvent.forTarget(this);

  @DomName('Document.input')
  @DocsEditable
  Stream<Event> get onInput => Element.inputEvent.forTarget(this);

  @DomName('Document.invalid')
  @DocsEditable
  Stream<Event> get onInvalid => Element.invalidEvent.forTarget(this);

  @DomName('Document.keydown')
  @DocsEditable
  Stream<KeyboardEvent> get onKeyDown => Element.keyDownEvent.forTarget(this);

  @DomName('Document.keypress')
  @DocsEditable
  Stream<KeyboardEvent> get onKeyPress => Element.keyPressEvent.forTarget(this);

  @DomName('Document.keyup')
  @DocsEditable
  Stream<KeyboardEvent> get onKeyUp => Element.keyUpEvent.forTarget(this);

  @DomName('Document.load')
  @DocsEditable
  Stream<Event> get onLoad => Element.loadEvent.forTarget(this);

  @DomName('Document.mousedown')
  @DocsEditable
  Stream<MouseEvent> get onMouseDown => Element.mouseDownEvent.forTarget(this);

  @DomName('Document.mousemove')
  @DocsEditable
  Stream<MouseEvent> get onMouseMove => Element.mouseMoveEvent.forTarget(this);

  @DomName('Document.mouseout')
  @DocsEditable
  Stream<MouseEvent> get onMouseOut => Element.mouseOutEvent.forTarget(this);

  @DomName('Document.mouseover')
  @DocsEditable
  Stream<MouseEvent> get onMouseOver => Element.mouseOverEvent.forTarget(this);

  @DomName('Document.mouseup')
  @DocsEditable
  Stream<MouseEvent> get onMouseUp => Element.mouseUpEvent.forTarget(this);

  @DomName('Document.mousewheel')
  @DocsEditable
  Stream<WheelEvent> get onMouseWheel => Element.mouseWheelEvent.forTarget(this);

  @DomName('Document.paste')
  @DocsEditable
  Stream<Event> get onPaste => Element.pasteEvent.forTarget(this);

  @DomName('Document.readystatechange')
  @DocsEditable
  Stream<Event> get onReadyStateChange => readyStateChangeEvent.forTarget(this);

  @DomName('Document.reset')
  @DocsEditable
  Stream<Event> get onReset => Element.resetEvent.forTarget(this);

  @DomName('Document.scroll')
  @DocsEditable
  Stream<Event> get onScroll => Element.scrollEvent.forTarget(this);

  @DomName('Document.search')
  @DocsEditable
  Stream<Event> get onSearch => Element.searchEvent.forTarget(this);

  @DomName('Document.select')
  @DocsEditable
  Stream<Event> get onSelect => Element.selectEvent.forTarget(this);

  @DomName('Document.selectionchange')
  @DocsEditable
  Stream<Event> get onSelectionChange => selectionChangeEvent.forTarget(this);

  @DomName('Document.selectstart')
  @DocsEditable
  Stream<Event> get onSelectStart => Element.selectStartEvent.forTarget(this);

  @DomName('Document.submit')
  @DocsEditable
  Stream<Event> get onSubmit => Element.submitEvent.forTarget(this);

  @DomName('Document.touchcancel')
  @DocsEditable
  Stream<TouchEvent> get onTouchCancel => Element.touchCancelEvent.forTarget(this);

  @DomName('Document.touchend')
  @DocsEditable
  Stream<TouchEvent> get onTouchEnd => Element.touchEndEvent.forTarget(this);

  @DomName('Document.touchmove')
  @DocsEditable
  Stream<TouchEvent> get onTouchMove => Element.touchMoveEvent.forTarget(this);

  @DomName('Document.touchstart')
  @DocsEditable
  Stream<TouchEvent> get onTouchStart => Element.touchStartEvent.forTarget(this);

  @DomName('Document.webkitfullscreenchange')
  @DocsEditable
  Stream<Event> get onFullscreenChange => Element.fullscreenChangeEvent.forTarget(this);

  @DomName('Document.webkitfullscreenerror')
  @DocsEditable
  Stream<Event> get onFullscreenError => Element.fullscreenErrorEvent.forTarget(this);

  @DomName('Document.webkitpointerlockchange')
  @DocsEditable
  Stream<Event> get onPointerLockChange => pointerLockChangeEvent.forTarget(this);

  @DomName('Document.webkitpointerlockerror')
  @DocsEditable
  Stream<Event> get onPointerLockError => pointerLockErrorEvent.forTarget(this);


  /**
   * Finds the first descendant element of this document that matches the
   * specified group of selectors.
   *
   * Unless your webpage contains multiple documents, the top-level query
   * method behaves the same as this method, so you should use it instead to
   * save typing a few characters.
   *
   * [selectors] should be a string using CSS selector syntax.
   *     var element1 = document.query('.className');
   *     var element2 = document.query('#id');
   *
   * For details about CSS selector syntax, see the
   * [CSS selector specification](http://www.w3.org/TR/css3-selectors/).
   */
  Element query(String selectors) {
    // It is fine for our RegExp to detect element id query selectors to have
    // false negatives but not false positives.
    if (new RegExp("^#[_a-zA-Z]\\w*\$").hasMatch(selectors)) {
      return $dom_getElementById(selectors.substring(1));
    }
    return $dom_querySelector(selectors);
  }

  /**
   * Finds all descendant elements of this document that match the specified
   * group of selectors.
   *
   * Unless your webpage contains multiple documents, the top-level queryAll
   * method behaves the same as this method, so you should use it instead to
   * save typing a few characters.
   *
   * [selectors] should be a string using CSS selector syntax.
   *     var items = document.queryAll('.itemClassName');
   *
   * For details about CSS selector syntax, see the
   * [CSS selector specification](http://www.w3.org/TR/css3-selectors/).
   */
  List<Element> queryAll(String selectors) {
    if (new RegExp("""^\\[name=["'][^'"]+['"]\\]\$""").hasMatch(selectors)) {
      final mutableMatches = $dom_getElementsByName(
          selectors.substring(7,selectors.length - 2));
      int len = mutableMatches.length;
      final copyOfMatches = new List<Element>.fixedLength(len);
      for (int i = 0; i < len; ++i) {
        copyOfMatches[i] = mutableMatches[i];
      }
      return new _FrozenElementList._wrap(copyOfMatches);
    } else if (new RegExp("^[*a-zA-Z0-9]+\$").hasMatch(selectors)) {
      final mutableMatches = $dom_getElementsByTagName(selectors);
      int len = mutableMatches.length;
      final copyOfMatches = new List<Element>.fixedLength(len);
      for (int i = 0; i < len; ++i) {
        copyOfMatches[i] = mutableMatches[i];
      }
      return new _FrozenElementList._wrap(copyOfMatches);
    } else {
      return new _FrozenElementList._wrap($dom_querySelectorAll(selectors));
    }
  }
}

@DocsEditable
@deprecated
class DocumentEvents extends ElementEvents {
  @DocsEditable
  DocumentEvents(EventTarget _ptr) : super(_ptr);

  @DocsEditable
  EventListenerList get readyStateChange => this['readystatechange'];

  @DocsEditable
  EventListenerList get selectionChange => this['selectionchange'];

  @DocsEditable
  EventListenerList get pointerLockChange => this['webkitpointerlockchange'];

  @DocsEditable
  EventListenerList get pointerLockError => this['webkitpointerlockerror'];
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.


@DomName('DocumentFragment')
class DocumentFragment extends Node {
  factory DocumentFragment() => _DocumentFragmentFactoryProvider.createDocumentFragment();

  factory DocumentFragment.html(String html) =>
      _DocumentFragmentFactoryProvider.createDocumentFragment_html(html);

  factory DocumentFragment.svg(String svgContent) =>
      _DocumentFragmentFactoryProvider.createDocumentFragment_svg(svgContent);

  @deprecated
  List<Element> get elements => this.children;

  // TODO: The type of value should be Collection<Element>. See http://b/5392897
  @deprecated
  void set elements(value) {
    this.children = value;
  }

  List<Element> _children;

  List<Element> get children {
    if (_children == null) {
      _children = new FilteredElementList(this);
    }
    return _children;
  }

  void set children(List<Element> value) {
    // Copy list first since we don't want liveness during iteration.
    List copy = new List.from(value);
    var children = this.children;
    children.clear();
    children.addAll(copy);
  }

  Element query(String selectors) => $dom_querySelector(selectors);

  List<Element> queryAll(String selectors) =>
    new _FrozenElementList._wrap($dom_querySelectorAll(selectors));

  String get innerHtml {
    final e = new Element.tag("div");
    e.nodes.add(this.clone(true));
    return e.innerHtml;
  }

  // TODO(nweiz): Do we want to support some variant of innerHtml for XML and/or
  // SVG strings?
  void set innerHtml(String value) {
    this.nodes.clear();

    final e = new Element.tag("div");
    e.innerHtml = value;

    // Copy list first since we don't want liveness during iteration.
    List nodes = new List.from(e.nodes);
    this.nodes.addAll(nodes);
  }

  void append(Element element) {
    this.children.add(element);
  }

  void appendText(String text) {
    this.nodes.add(new Text(text));
  }

  void appendHtml(String text) {
    this.nodes.add(new DocumentFragment.html(text));
  }

  DocumentFragment.internal() : super.internal();

  @DocsEditable
  @DomName('EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent')
  @deprecated
  ElementEvents get on =>
    new ElementEvents(this);

  @DomName('DocumentFragment.querySelector')
  @DocsEditable
  Element $dom_querySelector(String selectors) native "DocumentFragment_querySelector_Callback";

  @DomName('DocumentFragment.querySelectorAll')
  @DocsEditable
  List<Node> $dom_querySelectorAll(String selectors) native "DocumentFragment_querySelectorAll_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('DocumentType')
class DocumentType extends Node {
  DocumentType.internal() : super.internal();

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('DOMError')
class DomError extends NativeFieldWrapperClass1 {
  DomError.internal();

  @DomName('DOMError.name')
  @DocsEditable
  String get name native "DOMError_name_Getter";

}
// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.


/// @domName DOMException
class DomException extends NativeFieldWrapperClass1 {

  static const String INDEX_SIZE = 'IndexSizeError';
  static const String HIERARCHY_REQUEST = 'HierarchyRequestError';
  static const String WRONG_DOCUMENT = 'WrongDocumentError';
  static const String INVALID_CHARACTER = 'InvalidCharacterError';
  static const String NO_MODIFICATION_ALLOWED = 'NoModificationAllowedError';
  static const String NOT_FOUND = 'NotFoundError';
  static const String NOT_SUPPORTED = 'NotSupportedError';
  static const String INVALID_STATE = 'InvalidStateError';
  static const String SYNTAX = 'SyntaxError';
  static const String INVALID_MODIFICATION = 'InvalidModificationError';
  static const String NAMESPACE = 'NamespaceError';
  static const String INVALID_ACCESS = 'InvalidAccessError';
  static const String TYPE_MISMATCH = 'TypeMismatchError';
  static const String SECURITY = 'SecurityError';
  static const String NETWORK = 'NetworkError';
  static const String ABORT = 'AbortError';
  static const String URL_MISMATCH = 'URLMismatchError';
  static const String QUOTA_EXCEEDED = 'QuotaExceededError';
  static const String TIMEOUT = 'TimeoutError';
  static const String INVALID_NODE_TYPE = 'InvalidNodeTypeError';
  static const String DATA_CLONE = 'DataCloneError';

  DomException.internal();

  @DomName('DOMCoreException.message')
  @DocsEditable
  String get message native "DOMCoreException_message_Getter";

  @DomName('DOMCoreException.name')
  @DocsEditable
  String get name native "DOMCoreException_name_Getter";

  @DomName('DOMCoreException.toString')
  @DocsEditable
  String toString() native "DOMCoreException_toString_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('DOMImplementation')
class DomImplementation extends NativeFieldWrapperClass1 {
  DomImplementation.internal();

  @DomName('DOMImplementation.createCSSStyleSheet')
  @DocsEditable
  CssStyleSheet createCssStyleSheet(String title, String media) native "DOMImplementation_createCSSStyleSheet_Callback";

  @DomName('DOMImplementation.createDocument')
  @DocsEditable
  Document createDocument(String namespaceURI, String qualifiedName, DocumentType doctype) native "DOMImplementation_createDocument_Callback";

  @DomName('DOMImplementation.createDocumentType')
  @DocsEditable
  DocumentType createDocumentType(String qualifiedName, String publicId, String systemId) native "DOMImplementation_createDocumentType_Callback";

  @DomName('DOMImplementation.createHTMLDocument')
  @DocsEditable
  HtmlDocument createHtmlDocument(String title) native "DOMImplementation_createHTMLDocument_Callback";

  @DomName('DOMImplementation.hasFeature')
  @DocsEditable
  bool hasFeature(String feature, String version) native "DOMImplementation_hasFeature_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('MimeType')
class DomMimeType extends NativeFieldWrapperClass1 {
  DomMimeType.internal();

  @DomName('DOMMimeType.description')
  @DocsEditable
  String get description native "DOMMimeType_description_Getter";

  @DomName('DOMMimeType.enabledPlugin')
  @DocsEditable
  DomPlugin get enabledPlugin native "DOMMimeType_enabledPlugin_Getter";

  @DomName('DOMMimeType.suffixes')
  @DocsEditable
  String get suffixes native "DOMMimeType_suffixes_Getter";

  @DomName('DOMMimeType.type')
  @DocsEditable
  String get type native "DOMMimeType_type_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('MimeTypeArray')
class DomMimeTypeArray extends NativeFieldWrapperClass1 implements List<DomMimeType> {
  DomMimeTypeArray.internal();

  @DomName('DOMMimeTypeArray.length')
  @DocsEditable
  int get length native "DOMMimeTypeArray_length_Getter";

  DomMimeType operator[](int index) native "DOMMimeTypeArray_item_Callback";

  void operator[]=(int index, DomMimeType value) {
    throw new UnsupportedError("Cannot assign element of immutable List.");
  }
  // -- start List<DomMimeType> mixins.
  // DomMimeType is the element type.

  // From Iterable<DomMimeType>:

  Iterator<DomMimeType> get iterator {
    // Note: NodeLists are not fixed size. And most probably length shouldn't
    // be cached in both iterator _and_ forEach method. For now caching it
    // for consistency.
    return new FixedSizeListIterator<DomMimeType>(this);
  }

  dynamic reduce(dynamic initialValue, dynamic combine(dynamic, DomMimeType)) {
    return IterableMixinWorkaround.reduce(this, initialValue, combine);
  }

  bool contains(DomMimeType element) => IterableMixinWorkaround.contains(this, element);

  void forEach(void f(DomMimeType element)) => IterableMixinWorkaround.forEach(this, f);

  String join([String separator]) =>
      IterableMixinWorkaround.joinList(this, separator);

  List mappedBy(f(DomMimeType element)) => IterableMixinWorkaround.mappedByList(this, f);

  Iterable<DomMimeType> where(bool f(DomMimeType element)) =>
      IterableMixinWorkaround.where(this, f);

  bool every(bool f(DomMimeType element)) => IterableMixinWorkaround.every(this, f);

  bool any(bool f(DomMimeType element)) => IterableMixinWorkaround.any(this, f);

  List<DomMimeType> toList() => new List<DomMimeType>.from(this);
  Set<DomMimeType> toSet() => new Set<DomMimeType>.from(this);

  bool get isEmpty => this.length == 0;

  List<DomMimeType> take(int n) => IterableMixinWorkaround.takeList(this, n);

  Iterable<DomMimeType> takeWhile(bool test(DomMimeType value)) {
    return IterableMixinWorkaround.takeWhile(this, test);
  }

  List<DomMimeType> skip(int n) => IterableMixinWorkaround.skipList(this, n);

  Iterable<DomMimeType> skipWhile(bool test(DomMimeType value)) {
    return IterableMixinWorkaround.skipWhile(this, test);
  }

  DomMimeType firstMatching(bool test(DomMimeType value), { DomMimeType orElse() }) {
    return IterableMixinWorkaround.firstMatching(this, test, orElse);
  }

  DomMimeType lastMatching(bool test(DomMimeType value), {DomMimeType orElse()}) {
    return IterableMixinWorkaround.lastMatchingInList(this, test, orElse);
  }

  DomMimeType singleMatching(bool test(DomMimeType value)) {
    return IterableMixinWorkaround.singleMatching(this, test);
  }

  DomMimeType elementAt(int index) {
    return this[index];
  }

  // From Collection<DomMimeType>:

  void add(DomMimeType value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addLast(DomMimeType value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addAll(Iterable<DomMimeType> iterable) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  // From List<DomMimeType>:
  void set length(int value) {
    throw new UnsupportedError("Cannot resize immutable List.");
  }

  void clear() {
    throw new UnsupportedError("Cannot clear immutable List.");
  }

  List<DomMimeType> get reversed =>
      new ReversedListView<DomMimeType>(this, 0, null);

  void sort([int compare(DomMimeType a, DomMimeType b)]) {
    throw new UnsupportedError("Cannot sort immutable List.");
  }

  int indexOf(DomMimeType element, [int start = 0]) =>
      Lists.indexOf(this, element, start, this.length);

  int lastIndexOf(DomMimeType element, [int start]) {
    if (start == null) start = length - 1;
    return Lists.lastIndexOf(this, element, start);
  }

  DomMimeType get first {
    if (this.length > 0) return this[0];
    throw new StateError("No elements");
  }

  DomMimeType get last {
    if (this.length > 0) return this[this.length - 1];
    throw new StateError("No elements");
  }

  DomMimeType get single {
    if (length == 1) return this[0];
    if (length == 0) throw new StateError("No elements");
    throw new StateError("More than one element");
  }

  DomMimeType min([int compare(DomMimeType a, DomMimeType b)]) =>
      IterableMixinWorkaround.min(this, compare);

  DomMimeType max([int compare(DomMimeType a, DomMimeType b)]) =>
      IterableMixinWorkaround.max(this, compare);

  DomMimeType removeAt(int pos) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  DomMimeType removeLast() {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void remove(Object object) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void removeAll(Iterable elements) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void retainAll(Iterable elements) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void removeMatching(bool test(DomMimeType element)) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void retainMatching(bool test(DomMimeType element)) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void setRange(int start, int rangeLength, List<DomMimeType> from, [int startFrom]) {
    throw new UnsupportedError("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int rangeLength) {
    throw new UnsupportedError("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int rangeLength, [DomMimeType initialValue]) {
    throw new UnsupportedError("Cannot insertRange on immutable List.");
  }

  List<DomMimeType> getRange(int start, int rangeLength) =>
      Lists.getRange(this, start, rangeLength, <DomMimeType>[]);

  // -- end List<DomMimeType> mixins.

  @DomName('DOMMimeTypeArray.item')
  @DocsEditable
  DomMimeType item(int index) native "DOMMimeTypeArray_item_Callback";

  @DomName('DOMMimeTypeArray.namedItem')
  @DocsEditable
  DomMimeType namedItem(String name) native "DOMMimeTypeArray_namedItem_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('DOMParser')
class DomParser extends NativeFieldWrapperClass1 {
  DomParser.internal();

  @DocsEditable
  factory DomParser() => DomParser._create();
  static DomParser _create() native "DOMParser_constructor_Callback";

  @DomName('DOMParser.parseFromString')
  @DocsEditable
  Document parseFromString(String str, String contentType) native "DOMParser_parseFromString_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('Plugin')
class DomPlugin extends NativeFieldWrapperClass1 {
  DomPlugin.internal();

  @DomName('DOMPlugin.description')
  @DocsEditable
  String get description native "DOMPlugin_description_Getter";

  @DomName('DOMPlugin.filename')
  @DocsEditable
  String get filename native "DOMPlugin_filename_Getter";

  @DomName('DOMPlugin.length')
  @DocsEditable
  int get length native "DOMPlugin_length_Getter";

  @DomName('DOMPlugin.name')
  @DocsEditable
  String get name native "DOMPlugin_name_Getter";

  @DomName('DOMPlugin.item')
  @DocsEditable
  DomMimeType item(int index) native "DOMPlugin_item_Callback";

  @DomName('DOMPlugin.namedItem')
  @DocsEditable
  DomMimeType namedItem(String name) native "DOMPlugin_namedItem_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('PluginArray')
class DomPluginArray extends NativeFieldWrapperClass1 implements List<DomPlugin> {
  DomPluginArray.internal();

  @DomName('DOMPluginArray.length')
  @DocsEditable
  int get length native "DOMPluginArray_length_Getter";

  DomPlugin operator[](int index) native "DOMPluginArray_item_Callback";

  void operator[]=(int index, DomPlugin value) {
    throw new UnsupportedError("Cannot assign element of immutable List.");
  }
  // -- start List<DomPlugin> mixins.
  // DomPlugin is the element type.

  // From Iterable<DomPlugin>:

  Iterator<DomPlugin> get iterator {
    // Note: NodeLists are not fixed size. And most probably length shouldn't
    // be cached in both iterator _and_ forEach method. For now caching it
    // for consistency.
    return new FixedSizeListIterator<DomPlugin>(this);
  }

  dynamic reduce(dynamic initialValue, dynamic combine(dynamic, DomPlugin)) {
    return IterableMixinWorkaround.reduce(this, initialValue, combine);
  }

  bool contains(DomPlugin element) => IterableMixinWorkaround.contains(this, element);

  void forEach(void f(DomPlugin element)) => IterableMixinWorkaround.forEach(this, f);

  String join([String separator]) =>
      IterableMixinWorkaround.joinList(this, separator);

  List mappedBy(f(DomPlugin element)) => IterableMixinWorkaround.mappedByList(this, f);

  Iterable<DomPlugin> where(bool f(DomPlugin element)) =>
      IterableMixinWorkaround.where(this, f);

  bool every(bool f(DomPlugin element)) => IterableMixinWorkaround.every(this, f);

  bool any(bool f(DomPlugin element)) => IterableMixinWorkaround.any(this, f);

  List<DomPlugin> toList() => new List<DomPlugin>.from(this);
  Set<DomPlugin> toSet() => new Set<DomPlugin>.from(this);

  bool get isEmpty => this.length == 0;

  List<DomPlugin> take(int n) => IterableMixinWorkaround.takeList(this, n);

  Iterable<DomPlugin> takeWhile(bool test(DomPlugin value)) {
    return IterableMixinWorkaround.takeWhile(this, test);
  }

  List<DomPlugin> skip(int n) => IterableMixinWorkaround.skipList(this, n);

  Iterable<DomPlugin> skipWhile(bool test(DomPlugin value)) {
    return IterableMixinWorkaround.skipWhile(this, test);
  }

  DomPlugin firstMatching(bool test(DomPlugin value), { DomPlugin orElse() }) {
    return IterableMixinWorkaround.firstMatching(this, test, orElse);
  }

  DomPlugin lastMatching(bool test(DomPlugin value), {DomPlugin orElse()}) {
    return IterableMixinWorkaround.lastMatchingInList(this, test, orElse);
  }

  DomPlugin singleMatching(bool test(DomPlugin value)) {
    return IterableMixinWorkaround.singleMatching(this, test);
  }

  DomPlugin elementAt(int index) {
    return this[index];
  }

  // From Collection<DomPlugin>:

  void add(DomPlugin value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addLast(DomPlugin value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addAll(Iterable<DomPlugin> iterable) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  // From List<DomPlugin>:
  void set length(int value) {
    throw new UnsupportedError("Cannot resize immutable List.");
  }

  void clear() {
    throw new UnsupportedError("Cannot clear immutable List.");
  }

  List<DomPlugin> get reversed =>
      new ReversedListView<DomPlugin>(this, 0, null);

  void sort([int compare(DomPlugin a, DomPlugin b)]) {
    throw new UnsupportedError("Cannot sort immutable List.");
  }

  int indexOf(DomPlugin element, [int start = 0]) =>
      Lists.indexOf(this, element, start, this.length);

  int lastIndexOf(DomPlugin element, [int start]) {
    if (start == null) start = length - 1;
    return Lists.lastIndexOf(this, element, start);
  }

  DomPlugin get first {
    if (this.length > 0) return this[0];
    throw new StateError("No elements");
  }

  DomPlugin get last {
    if (this.length > 0) return this[this.length - 1];
    throw new StateError("No elements");
  }

  DomPlugin get single {
    if (length == 1) return this[0];
    if (length == 0) throw new StateError("No elements");
    throw new StateError("More than one element");
  }

  DomPlugin min([int compare(DomPlugin a, DomPlugin b)]) =>
      IterableMixinWorkaround.min(this, compare);

  DomPlugin max([int compare(DomPlugin a, DomPlugin b)]) =>
      IterableMixinWorkaround.max(this, compare);

  DomPlugin removeAt(int pos) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  DomPlugin removeLast() {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void remove(Object object) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void removeAll(Iterable elements) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void retainAll(Iterable elements) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void removeMatching(bool test(DomPlugin element)) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void retainMatching(bool test(DomPlugin element)) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void setRange(int start, int rangeLength, List<DomPlugin> from, [int startFrom]) {
    throw new UnsupportedError("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int rangeLength) {
    throw new UnsupportedError("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int rangeLength, [DomPlugin initialValue]) {
    throw new UnsupportedError("Cannot insertRange on immutable List.");
  }

  List<DomPlugin> getRange(int start, int rangeLength) =>
      Lists.getRange(this, start, rangeLength, <DomPlugin>[]);

  // -- end List<DomPlugin> mixins.

  @DomName('DOMPluginArray.item')
  @DocsEditable
  DomPlugin item(int index) native "DOMPluginArray_item_Callback";

  @DomName('DOMPluginArray.namedItem')
  @DocsEditable
  DomPlugin namedItem(String name) native "DOMPluginArray_namedItem_Callback";

  @DomName('DOMPluginArray.refresh')
  @DocsEditable
  void refresh(bool reload) native "DOMPluginArray_refresh_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('WebKitPoint')
@SupportedBrowser(SupportedBrowser.CHROME)
@SupportedBrowser(SupportedBrowser.SAFARI)
@Experimental
class DomPoint extends NativeFieldWrapperClass1 {
  DomPoint.internal();

  @DocsEditable
  factory DomPoint(num x, num y) => DomPoint._create(x, y);
  static DomPoint _create(num x, num y) native "WebKitPoint_constructor_Callback";

  /// Checks if this type is supported on the current platform.
  static bool get supported => true;

  @DomName('WebKitPoint.x')
  @DocsEditable
  num get x native "WebKitPoint_x_Getter";

  @DomName('WebKitPoint.x')
  @DocsEditable
  void set x(num value) native "WebKitPoint_x_Setter";

  @DomName('WebKitPoint.y')
  @DocsEditable
  num get y native "WebKitPoint_y_Getter";

  @DomName('WebKitPoint.y')
  @DocsEditable
  void set y(num value) native "WebKitPoint_y_Setter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('Selection')
class DomSelection extends NativeFieldWrapperClass1 {
  DomSelection.internal();

  @DomName('DOMSelection.anchorNode')
  @DocsEditable
  Node get anchorNode native "DOMSelection_anchorNode_Getter";

  @DomName('DOMSelection.anchorOffset')
  @DocsEditable
  int get anchorOffset native "DOMSelection_anchorOffset_Getter";

  @DomName('DOMSelection.baseNode')
  @DocsEditable
  Node get baseNode native "DOMSelection_baseNode_Getter";

  @DomName('DOMSelection.baseOffset')
  @DocsEditable
  int get baseOffset native "DOMSelection_baseOffset_Getter";

  @DomName('DOMSelection.extentNode')
  @DocsEditable
  Node get extentNode native "DOMSelection_extentNode_Getter";

  @DomName('DOMSelection.extentOffset')
  @DocsEditable
  int get extentOffset native "DOMSelection_extentOffset_Getter";

  @DomName('DOMSelection.focusNode')
  @DocsEditable
  Node get focusNode native "DOMSelection_focusNode_Getter";

  @DomName('DOMSelection.focusOffset')
  @DocsEditable
  int get focusOffset native "DOMSelection_focusOffset_Getter";

  @DomName('DOMSelection.isCollapsed')
  @DocsEditable
  bool get isCollapsed native "DOMSelection_isCollapsed_Getter";

  @DomName('DOMSelection.rangeCount')
  @DocsEditable
  int get rangeCount native "DOMSelection_rangeCount_Getter";

  @DomName('DOMSelection.type')
  @DocsEditable
  String get type native "DOMSelection_type_Getter";

  @DomName('DOMSelection.addRange')
  @DocsEditable
  void addRange(Range range) native "DOMSelection_addRange_Callback";

  @DomName('DOMSelection.collapse')
  @DocsEditable
  void collapse(Node node, int index) native "DOMSelection_collapse_Callback";

  @DomName('DOMSelection.collapseToEnd')
  @DocsEditable
  void collapseToEnd() native "DOMSelection_collapseToEnd_Callback";

  @DomName('DOMSelection.collapseToStart')
  @DocsEditable
  void collapseToStart() native "DOMSelection_collapseToStart_Callback";

  @DomName('DOMSelection.containsNode')
  @DocsEditable
  bool containsNode(Node node, bool allowPartial) native "DOMSelection_containsNode_Callback";

  @DomName('DOMSelection.deleteFromDocument')
  @DocsEditable
  void deleteFromDocument() native "DOMSelection_deleteFromDocument_Callback";

  @DomName('DOMSelection.empty')
  @DocsEditable
  void empty() native "DOMSelection_empty_Callback";

  @DomName('DOMSelection.extend')
  @DocsEditable
  void extend(Node node, int offset) native "DOMSelection_extend_Callback";

  @DomName('DOMSelection.getRangeAt')
  @DocsEditable
  Range getRangeAt(int index) native "DOMSelection_getRangeAt_Callback";

  @DomName('DOMSelection.modify')
  @DocsEditable
  void modify(String alter, String direction, String granularity) native "DOMSelection_modify_Callback";

  @DomName('DOMSelection.removeAllRanges')
  @DocsEditable
  void removeAllRanges() native "DOMSelection_removeAllRanges_Callback";

  @DomName('DOMSelection.selectAllChildren')
  @DocsEditable
  void selectAllChildren(Node node) native "DOMSelection_selectAllChildren_Callback";

  @DomName('DOMSelection.setBaseAndExtent')
  @DocsEditable
  void setBaseAndExtent(Node baseNode, int baseOffset, Node extentNode, int extentOffset) native "DOMSelection_setBaseAndExtent_Callback";

  @DomName('DOMSelection.setPosition')
  @DocsEditable
  void setPosition(Node node, int offset) native "DOMSelection_setPosition_Callback";

  @DomName('DOMSelection.toString')
  @DocsEditable
  String toString() native "DOMSelection_toString_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('DOMSettableTokenList')
class DomSettableTokenList extends DomTokenList {
  DomSettableTokenList.internal() : super.internal();

  @DomName('DOMSettableTokenList.value')
  @DocsEditable
  String get value native "DOMSettableTokenList_value_Getter";

  @DomName('DOMSettableTokenList.value')
  @DocsEditable
  void set value(String value) native "DOMSettableTokenList_value_Setter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('DOMStringList')
class DomStringList extends NativeFieldWrapperClass1 implements List<String> {
  DomStringList.internal();

  @DomName('DOMStringList.length')
  @DocsEditable
  int get length native "DOMStringList_length_Getter";

  String operator[](int index) native "DOMStringList_item_Callback";

  void operator[]=(int index, String value) {
    throw new UnsupportedError("Cannot assign element of immutable List.");
  }
  // -- start List<String> mixins.
  // String is the element type.

  // From Iterable<String>:

  Iterator<String> get iterator {
    // Note: NodeLists are not fixed size. And most probably length shouldn't
    // be cached in both iterator _and_ forEach method. For now caching it
    // for consistency.
    return new FixedSizeListIterator<String>(this);
  }

  dynamic reduce(dynamic initialValue, dynamic combine(dynamic, String)) {
    return IterableMixinWorkaround.reduce(this, initialValue, combine);
  }

  // contains() defined by IDL.

  void forEach(void f(String element)) => IterableMixinWorkaround.forEach(this, f);

  String join([String separator]) =>
      IterableMixinWorkaround.joinList(this, separator);

  List mappedBy(f(String element)) => IterableMixinWorkaround.mappedByList(this, f);

  Iterable<String> where(bool f(String element)) =>
      IterableMixinWorkaround.where(this, f);

  bool every(bool f(String element)) => IterableMixinWorkaround.every(this, f);

  bool any(bool f(String element)) => IterableMixinWorkaround.any(this, f);

  List<String> toList() => new List<String>.from(this);
  Set<String> toSet() => new Set<String>.from(this);

  bool get isEmpty => this.length == 0;

  List<String> take(int n) => IterableMixinWorkaround.takeList(this, n);

  Iterable<String> takeWhile(bool test(String value)) {
    return IterableMixinWorkaround.takeWhile(this, test);
  }

  List<String> skip(int n) => IterableMixinWorkaround.skipList(this, n);

  Iterable<String> skipWhile(bool test(String value)) {
    return IterableMixinWorkaround.skipWhile(this, test);
  }

  String firstMatching(bool test(String value), { String orElse() }) {
    return IterableMixinWorkaround.firstMatching(this, test, orElse);
  }

  String lastMatching(bool test(String value), {String orElse()}) {
    return IterableMixinWorkaround.lastMatchingInList(this, test, orElse);
  }

  String singleMatching(bool test(String value)) {
    return IterableMixinWorkaround.singleMatching(this, test);
  }

  String elementAt(int index) {
    return this[index];
  }

  // From Collection<String>:

  void add(String value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addLast(String value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addAll(Iterable<String> iterable) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  // From List<String>:
  void set length(int value) {
    throw new UnsupportedError("Cannot resize immutable List.");
  }

  void clear() {
    throw new UnsupportedError("Cannot clear immutable List.");
  }

  List<String> get reversed =>
      new ReversedListView<String>(this, 0, null);

  void sort([int compare(String a, String b)]) {
    throw new UnsupportedError("Cannot sort immutable List.");
  }

  int indexOf(String element, [int start = 0]) =>
      Lists.indexOf(this, element, start, this.length);

  int lastIndexOf(String element, [int start]) {
    if (start == null) start = length - 1;
    return Lists.lastIndexOf(this, element, start);
  }

  String get first {
    if (this.length > 0) return this[0];
    throw new StateError("No elements");
  }

  String get last {
    if (this.length > 0) return this[this.length - 1];
    throw new StateError("No elements");
  }

  String get single {
    if (length == 1) return this[0];
    if (length == 0) throw new StateError("No elements");
    throw new StateError("More than one element");
  }

  String min([int compare(String a, String b)]) =>
      IterableMixinWorkaround.min(this, compare);

  String max([int compare(String a, String b)]) =>
      IterableMixinWorkaround.max(this, compare);

  String removeAt(int pos) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  String removeLast() {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void remove(Object object) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void removeAll(Iterable elements) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void retainAll(Iterable elements) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void removeMatching(bool test(String element)) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void retainMatching(bool test(String element)) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void setRange(int start, int rangeLength, List<String> from, [int startFrom]) {
    throw new UnsupportedError("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int rangeLength) {
    throw new UnsupportedError("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int rangeLength, [String initialValue]) {
    throw new UnsupportedError("Cannot insertRange on immutable List.");
  }

  List<String> getRange(int start, int rangeLength) =>
      Lists.getRange(this, start, rangeLength, <String>[]);

  // -- end List<String> mixins.

  @DomName('DOMStringList.contains')
  @DocsEditable
  bool contains(String string) native "DOMStringList_contains_Callback";

  @DomName('DOMStringList.item')
  @DocsEditable
  String item(int index) native "DOMStringList_item_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('DOMStringMap')
class DomStringMap extends NativeFieldWrapperClass1 {
  DomStringMap.internal();

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('DOMTokenList')
class DomTokenList extends NativeFieldWrapperClass1 {
  DomTokenList.internal();

  @DomName('DOMTokenList.length')
  @DocsEditable
  int get length native "DOMTokenList_length_Getter";

  @DomName('DOMTokenList.contains')
  @DocsEditable
  bool contains(String token) native "DOMTokenList_contains_Callback";

  @DomName('DOMTokenList.item')
  @DocsEditable
  String item(int index) native "DOMTokenList_item_Callback";

  @DomName('DOMTokenList.toString')
  @DocsEditable
  String toString() native "DOMTokenList_toString_Callback";

  bool toggle(String token, [bool force]) {
    if (?force) {
      return _toggle_1(token, force);
    }
    return _toggle_2(token);
  }

  @DomName('DOMTokenList._toggle_1')
  @DocsEditable
  bool _toggle_1(token, force) native "DOMTokenList__toggle_1_Callback";

  @DomName('DOMTokenList._toggle_2')
  @DocsEditable
  bool _toggle_2(token) native "DOMTokenList__toggle_2_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.


// TODO(jacobr): use _Lists.dart to remove some of the duplicated
// functionality.
class _ChildrenElementList implements List {
  // Raw Element.
  final Element _element;
  final HtmlCollection _childElements;

  _ChildrenElementList._wrap(Element element)
    : _childElements = element.$dom_children,
      _element = element;

  List<Element> toList() {
    final output = new List<Element>.fixedLength(_childElements.length);
    for (int i = 0, len = _childElements.length; i < len; i++) {
      output[i] = _childElements[i];
    }
    return output;
  }

  Set<Element> toSet() {
    final output = new Set<Element>();
    for (int i = 0, len = _childElements.length; i < len; i++) {
      output.add(_childElements[i]);
    }
    return output;
  }

  bool contains(Element element) => _childElements.contains(element);

  void forEach(void f(Element element)) {
    for (Element element in _childElements) {
      f(element);
    }
  }

  bool every(bool f(Element element)) {
    for (Element element in this) {
      if (!f(element)) {
        return false;
      }
    }
    return true;
  }

  bool any(bool f(Element element)) {
    for (Element element in this) {
      if (f(element)) {
        return true;
      }
    }
    return false;
  }

  String join([String separator]) {
    return IterableMixinWorkaround.joinList(this, separator);
  }

  List mappedBy(f(Element element)) {
    return IterableMixinWorkaround.mappedByList(this, f);
  }

  Iterable<Element> where(bool f(Element element)) {
    return IterableMixinWorkaround.where(this, f);
  }

  bool get isEmpty {
    return _element.$dom_firstElementChild == null;
  }

  List<Element> take(int n) {
    return IterableMixinWorkaround.takeList(this, n);
  }

  Iterable<Element> takeWhile(bool test(Element value)) {
    return IterableMixinWorkaround.takeWhile(this, test);
  }

  List<Element> skip(int n) {
    return IterableMixinWorkaround.skipList(this, n);
  }

  Iterable<Element> skipWhile(bool test(Element value)) {
    return IterableMixinWorkaround.skipWhile(this, test);
  }

  Element firstMatching(bool test(Element value), {Element orElse()}) {
    return IterableMixinWorkaround.firstMatching(this, test, orElse);
  }

  Element lastMatching(bool test(Element value), {Element orElse()}) {
    return IterableMixinWorkaround.lastMatchingInList(this, test, orElse);
  }

  Element singleMatching(bool test(Element value)) {
    return IterableMixinWorkaround.singleMatching(this, test);
  }

  Element elementAt(int index) {
    return this[index];
  }

  int get length {
    return _childElements.length;
  }

  Element operator [](int index) {
    return _childElements[index];
  }

  void operator []=(int index, Element value) {
    _element.$dom_replaceChild(value, _childElements[index]);
  }

  void set length(int newLength) {
    // TODO(jacobr): remove children when length is reduced.
    throw new UnsupportedError('');
  }

  Element add(Element value) {
    _element.$dom_appendChild(value);
    return value;
  }

  Element addLast(Element value) => add(value);

  Iterator<Element> get iterator => toList().iterator;

  void addAll(Iterable<Element> iterable) {
    for (Element element in iterable) {
      _element.$dom_appendChild(element);
    }
  }

  List<Element> get reversed =>
      new ReversedListView<Element>(this, 0, null);

  void sort([int compare(Element a, Element b)]) {
    throw new UnsupportedError('TODO(jacobr): should we impl?');
  }

  dynamic reduce(dynamic initialValue,
      dynamic combine(dynamic previousValue, Element element)) {
    return IterableMixinWorkaround.reduce(this, initialValue, combine);
  }

  void setRange(int start, int rangeLength, List from, [int startFrom = 0]) {
    throw new UnimplementedError();
  }

  void remove(Object object) {
    if (object is Element) {
      Element element = object;
      if (identical(element.parentNode, _element)) {
        _element.$dom_removeChild(element);
      }
    }
  }

  void removeAll(Iterable elements) {
    IterableMixinWorkaround.removeAll(this, elements);
  }

  void retainAll(Iterable elements) {
    IterableMixinWorkaround.retainAll(this, elements);
  }

  void removeMatching(bool test(Element element)) {
    IterableMixinWorkaround.removeMatching(this, test);
  }

  void retainMatching(bool test(Element element)) {
    IterableMixinWorkaround.retainMatching(this, test);
  }

  void removeRange(int start, int rangeLength) {
    throw new UnimplementedError();
  }

  void insertRange(int start, int rangeLength, [initialValue = null]) {
    throw new UnimplementedError();
  }

  List getRange(int start, int rangeLength) =>
    new _FrozenElementList._wrap(Lists.getRange(this, start, rangeLength,
        []));

  int indexOf(Element element, [int start = 0]) {
    return Lists.indexOf(this, element, start, this.length);
  }

  int lastIndexOf(Element element, [int start = null]) {
    if (start == null) start = length - 1;
    return Lists.lastIndexOf(this, element, start);
  }

  void clear() {
    // It is unclear if we want to keep non element nodes?
    _element.text = '';
  }

  Element removeAt(int index) {
    final result = this[index];
    if (result != null) {
      _element.$dom_removeChild(result);
    }
    return result;
  }

  Element removeLast() {
    final result = this.last;
    if (result != null) {
      _element.$dom_removeChild(result);
    }
    return result;
  }

  Element get first {
    Element result = _element.$dom_firstElementChild;
    if (result == null) throw new StateError("No elements");
    return result;
  }


  Element get last {
    Element result = _element.$dom_lastElementChild;
    if (result == null) throw new StateError("No elements");
    return result;
  }

  Element get single {
    if (length > 1) throw new StateError("More than one element");
    return first;
  }

  Element min([int compare(Element a, Element b)]) {
    return IterableMixinWorkaround.min(this, compare);
  }

  Element max([int compare(Element a, Element b)]) {
    return IterableMixinWorkaround.max(this, compare);
  }
}

// TODO(jacobr): this is an inefficient implementation but it is hard to see
// a better option given that we cannot quite force NodeList to be an
// ElementList as there are valid cases where a NodeList JavaScript object
// contains Node objects that are not Elements.
class _FrozenElementList implements List {
  final List<Node> _nodeList;

  _FrozenElementList._wrap(this._nodeList);

  bool contains(Element element) {
    for (Element el in this) {
      if (el == element) return true;
    }
    return false;
  }

  void forEach(void f(Element element)) {
    for (Element el in this) {
      f(el);
    }
  }

  String join([String separator]) {
    return IterableMixinWorkaround.joinList(this, separator);
  }

  List mappedBy(f(Element element)) {
    return IterableMixinWorkaround.mappedByList(this, f);
  }

  Iterable<Element> where(bool f(Element element)) {
    return IterableMixinWorkaround.where(this, f);
  }

  bool every(bool f(Element element)) {
    for(Element element in this) {
      if (!f(element)) {
        return false;
      }
    };
    return true;
  }

  bool any(bool f(Element element)) {
    for(Element element in this) {
      if (f(element)) {
        return true;
      }
    };
    return false;
  }

  List<Element> toList() => new List<Element>.from(this);
  Set<Element> toSet() => new Set<Element>.from(this);

  List<Element> take(int n) {
    return IterableMixinWorkaround.takeList(this, n);
  }

  Iterable<Element> takeWhile(bool test(Element value)) {
    return IterableMixinWorkaround.takeWhile(this, test);
  }

  List<Element> skip(int n) {
    return IterableMixinWorkaround.skipList(this, n);
  }

  Iterable<Element> skipWhile(bool test(Element value)) {
    return IterableMixinWorkaround.skipWhile(this, test);
  }

  Element firstMatching(bool test(Element value), {Element orElse()}) {
    return IterableMixinWorkaround.firstMatching(this, test, orElse);
  }

  Element lastMatching(bool test(Element value), {Element orElse()}) {
    return IterableMixinWorkaround.lastMatchingInList(this, test, orElse);
  }

  Element singleMatching(bool test(Element value)) {
    return IterableMixinWorkaround.singleMatching(this, test);
  }

  Element elementAt(int index) {
    return this[index];
  }

  bool get isEmpty => _nodeList.isEmpty;

  int get length => _nodeList.length;

  Element operator [](int index) => _nodeList[index];

  void operator []=(int index, Element value) {
    throw new UnsupportedError('');
  }

  void set length(int newLength) {
    _nodeList.length = newLength;
  }

  void add(Element value) {
    throw new UnsupportedError('');
  }

  void addLast(Element value) {
    throw new UnsupportedError('');
  }

  Iterator<Element> get iterator => new _FrozenElementListIterator(this);

  void addAll(Iterable<Element> iterable) {
    throw new UnsupportedError('');
  }

  List<Element> get reversed =>
      new ReversedListView<Element>(this, 0, null);

  void sort([int compare(Element a, Element b)]) {
    throw new UnsupportedError('');
  }

  dynamic reduce(dynamic initialValue,
      dynamic combine(dynamic previousValue, Element element)) {
    return IterableMixinWorkaround.reduce(this, initialValue, combine);
  }

  void setRange(int start, int rangeLength, List from, [int startFrom = 0]) {
    throw new UnsupportedError('');
  }

  void removeRange(int start, int rangeLength) {
    throw new UnsupportedError('');
  }

  void insertRange(int start, int rangeLength, [initialValue = null]) {
    throw new UnsupportedError('');
  }

  List<Element> getRange(int start, int rangeLength) =>
    new _FrozenElementList._wrap(_nodeList.getRange(start, rangeLength));

  int indexOf(Element element, [int start = 0]) =>
    _nodeList.indexOf(element, start);

  int lastIndexOf(Element element, [int start = null]) =>
    _nodeList.lastIndexOf(element, start);

  void clear() {
    throw new UnsupportedError('');
  }

  Element removeAt(int index) {
    throw new UnsupportedError('');
  }

  Element removeLast() {
    throw new UnsupportedError('');
  }

  void remove(Object element) {
    throw new UnsupportedError('');
  }

  void removeAll(Iterable elements) {
    throw new UnsupportedError('');
  }

  void retainAll(Iterable elements) {
    throw new UnsupportedError('');
  }

  void removeMatching(bool test(Element element)) {
    throw new UnsupportedError('');
  }

  void retainMatching(bool test(Element element)) {
    throw new UnsupportedError('');
  }

  Element get first => _nodeList.first;

  Element get last => _nodeList.last;

  Element get single => _nodeList.single;

  Element min([int compare(Element a, Element b)]) {
    return IterableMixinWorkaround.min(this, compare);
  }

  Element max([int compare(Element a, Element b)]) {
    return IterableMixinWorkaround.max(this, compare);
  }
}

class _FrozenElementListIterator implements Iterator<Element> {
  final _FrozenElementList _list;
  int _index = -1;
  Element _current;

  _FrozenElementListIterator(this._list);

  /**
   * Moves to the next element. Returns true if the iterator is positioned
   * at an element. Returns false if it is positioned after the last element.
   */
  bool moveNext() {
    int nextIndex = _index + 1;
    if (nextIndex < _list.length) {
      _current = _list[nextIndex];
      _index = nextIndex;
      return true;
    }
    _index = _list.length;
    _current = null;
    return false;
  }

  /**
   * Returns the element the [Iterator] is positioned at.
   *
   * Return [:null:] if the iterator is positioned before the first, or
   * after the last element.
   */
  Element get current => _current;
}

class _ElementCssClassSet extends CssClassSet {

  final Element _element;

  _ElementCssClassSet(this._element);

  Set<String> readClasses() {
    var s = new Set<String>();
    var classname = _element.$dom_className;

    for (String name in classname.split(' ')) {
      String trimmed = name.trim();
      if (!trimmed.isEmpty) {
        s.add(trimmed);
      }
    }
    return s;
  }

  void writeClasses(Set<String> s) {
    List list = new List.from(s);
    _element.$dom_className = s.join(' ');
  }
}

/**
 * An abstract class, which all HTML elements extend.
 */
@DomName('Element')
abstract class Element extends Node implements ElementTraversal {

  /**
   * Creates an HTML element from a valid fragment of HTML.
   *
   * The [html] fragment must represent valid HTML with a single element root,
   * which will be parsed and returned.
   *
   * Important: the contents of [html] should not contain any user-supplied
   * data. Without strict data validation it is impossible to prevent script
   * injection exploits.
   *
   * It is instead recommended that elements be constructed via [Element.tag]
   * and text be added via [text].
   *
   *     var element = new Element.html('<div class="foo">content</div>');
   */
  factory Element.html(String html) =>
      _ElementFactoryProvider.createElement_html(html);

  /**
   * Creates the HTML element specified by the tag name.
   *
   * This is similar to [Document.createElement].
   * [tag] should be a valid HTML tag name. If [tag] is an unknown tag then
   * this will create an [UnknownElement].
   *
   *     var divElement = new Element.tag('div');
   *     print(divElement is DivElement); // 'true'
   *     var myElement = new Element.tag('unknownTag');
   *     print(myElement is UnknownElement); // 'true'
   *
   * For standard elements it is more preferable to use the type constructors:
   *     var element = new DivElement();
   *
   * See also:
   *
   * * [isTagSupported]
   */
  factory Element.tag(String tag) =>
      _ElementFactoryProvider.createElement_tag(tag);

  /**
   * All attributes on this element.
   *
   * Any modifications to the attribute map will automatically be applied to
   * this element.
   *
   * This only includes attributes which are not in a namespace
   * (such as 'xlink:href'), additional attributes can be accessed via
   * [getNamespacedAttributes].
   */
  Map<String, String> get attributes => new _ElementAttributeMap(this);

  void set attributes(Map<String, String> value) {
    Map<String, String> attributes = this.attributes;
    attributes.clear();
    for (String key in value.keys) {
      attributes[key] = value[key];
    }
  }

  /**
   * Deprecated, use innerHtml instead.
   */
  @deprecated
  String get innerHTML => this.innerHtml;
  @deprecated
  void set innerHTML(String value) {
    this.innerHtml = value;
  }

  @deprecated
  void set elements(Collection<Element> value) {
    this.children = value;
  }

  /**
   * Deprecated, use [children] instead.
   */
  @deprecated
  List<Element> get elements => this.children;

  /**
   * List of the direct children of this element.
   *
   * This collection can be used to add and remove elements from the document.
   *
   *     var item = new DivElement();
   *     item.text = 'Something';
   *     document.body.children.add(item) // Item is now displayed on the page.
   *     for (var element in document.body.children) {
   *       element.style.background = 'red'; // Turns every child of body red.
   *     }
   */
  List<Element> get children => new _ChildrenElementList._wrap(this);

  void set children(List<Element> value) {
    // Copy list first since we don't want liveness during iteration.
    List copy = new List.from(value);
    var children = this.children;
    children.clear();
    children.addAll(copy);
  }

  /**
   * Finds the first descendant element of this element that matches the
   * specified group of selectors.
   *
   * [selectors] should be a string using CSS selector syntax.
   *
   *     // Gets the first descendant with the class 'classname'
   *     var element = element.query('.className');
   *     // Gets the element with id 'id'
   *     var element = element.query('#id');
   *     // Gets the first descendant [ImageElement]
   *     var img = element.query('img');
   *
   * See also:
   *
   * * [CSS Selectors](http://docs.webplatform.org/wiki/css/selectors)
   */
  Element query(String selectors) => $dom_querySelector(selectors);

  /**
   * Finds all descendent elements of this element that match the specified
   * group of selectors.
   *
   * [selectors] should be a string using CSS selector syntax.
   *
   *     var items = element.query('.itemClassName');
   */
  List<Element> queryAll(String selectors) =>
    new _FrozenElementList._wrap($dom_querySelectorAll(selectors));

  /**
   * The set of CSS classes applied to this element.
   *
   * This set makes it easy to add, remove or toggle the classes applied to
   * this element.
   *
   *     element.classes.add('selected');
   *     element.classes.toggle('isOnline');
   *     element.classes.remove('selected');
   */
  CssClassSet get classes => new _ElementCssClassSet(this);

  void set classes(Collection<String> value) {
    CssClassSet classSet = classes;
    classSet.clear();
    classSet.addAll(value);
  }

  /**
   * Allows access to all custom data attributes (data-*) set on this element.
   *
   * The keys for the map must follow these rules:
   *
   * * The name must not begin with 'xml'.
   * * The name cannot contain a semi-colon (';').
   * * The name cannot contain any capital letters.
   *
   * Any keys from markup will be converted to camel-cased keys in the map.
   *
   * For example, HTML specified as:
   *
   *     <div data-my-random-value='value'></div>
   *
   * Would be accessed in Dart as:
   *
   *     var value = element.dataAttributes['myRandomValue'];
   *
   * See also:
   *
   * * [Custom data attributes](http://www.w3.org/TR/html5/global-attributes.html#custom-data-attribute)
   */
  Map<String, String> get dataAttributes =>
    new _DataAttributeMap(attributes);

  void set dataAttributes(Map<String, String> value) {
    final dataAttributes = this.dataAttributes;
    dataAttributes.clear();
    for (String key in value.keys) {
      dataAttributes[key] = value[key];
    }
  }

  /**
   * Gets a map for manipulating the attributes of a particular namespace.
   *
   * This is primarily useful for SVG attributes such as xref:link.
   */
  Map<String, String> getNamespacedAttributes(String namespace) {
    return new _NamespacedAttributeMap(this, namespace);
  }

  /**
   * The set of all CSS values applied to this element, including inherited
   * and default values.
   *
   * The computedStyle contains values that are inherited from other
   * sources, such as parent elements or stylesheets. This differs from the
   * [style] property, which contains only the values specified directly on this
   * element.
   *
   * PseudoElement can be values such as `::after`, `::before`, `::marker`,
   * `::line-marker`.
   *
   * See also:
   *
   * * [CSS Inheritance and Cascade](http://docs.webplatform.org/wiki/tutorials/inheritance_and_cascade)
   * * [Pseudo-elements](http://docs.webplatform.org/wiki/css/selectors/pseudo-elements)
   */
  CssStyleDeclaration getComputedStyle([String pseudoElement]) {
    if (pseudoElement == null) {
      pseudoElement = '';
    }
    // TODO(jacobr): last param should be null, see b/5045788
    return window.$dom_getComputedStyle(this, pseudoElement);
  }

  /**
   * Adds the specified element to after the last child of this element.
   */
  void append(Element e) {
    this.children.add(e);
  }

  /**
   * Adds the specified text as a text node after the last child of this
   * element.
   */
  void appendText(String text) {
    this.insertAdjacentText('beforeend', text);
  }

  /**
   * Parses the specified text as HTML and adds the resulting node after the
   * last child of this element.
   */
  void appendHtml(String text) {
    this.insertAdjacentHtml('beforeend', text);
  }

  /**
   * Checks to see if the tag name is supported by the current platform.
   *
   * The tag should be a valid HTML tag name.
   */
  static bool isTagSupported(String tag) {
    var e = _ElementFactoryProvider.createElement_tag(tag);
    return e is Element && !(e is UnknownElement);
  }

  // Hooks to support custom WebComponents.
  /**
   * Experimental support for [web components][wc]. This field stores a
   * reference to the component implementation. It was inspired by Mozilla's
   * [x-tags][] project. Please note: in the future it may be possible to
   * `extend Element` from your class, in which case this field will be
   * deprecated and will simply return this [Element] object.
   *
   * [wc]: http://dvcs.w3.org/hg/webcomponents/raw-file/tip/explainer/index.html
   * [x-tags]: http://x-tags.org/
   */
  var xtag;


  Element.internal() : super.internal();

  @DomName('Element.abort')
  @DocsEditable
  static const EventStreamProvider<Event> abortEvent = const EventStreamProvider<Event>('abort');

  @DomName('Element.beforecopy')
  @DocsEditable
  static const EventStreamProvider<Event> beforeCopyEvent = const EventStreamProvider<Event>('beforecopy');

  @DomName('Element.beforecut')
  @DocsEditable
  static const EventStreamProvider<Event> beforeCutEvent = const EventStreamProvider<Event>('beforecut');

  @DomName('Element.beforepaste')
  @DocsEditable
  static const EventStreamProvider<Event> beforePasteEvent = const EventStreamProvider<Event>('beforepaste');

  @DomName('Element.blur')
  @DocsEditable
  static const EventStreamProvider<Event> blurEvent = const EventStreamProvider<Event>('blur');

  @DomName('Element.change')
  @DocsEditable
  static const EventStreamProvider<Event> changeEvent = const EventStreamProvider<Event>('change');

  @DomName('Element.click')
  @DocsEditable
  static const EventStreamProvider<MouseEvent> clickEvent = const EventStreamProvider<MouseEvent>('click');

  @DomName('Element.contextmenu')
  @DocsEditable
  static const EventStreamProvider<MouseEvent> contextMenuEvent = const EventStreamProvider<MouseEvent>('contextmenu');

  @DomName('Element.copy')
  @DocsEditable
  static const EventStreamProvider<Event> copyEvent = const EventStreamProvider<Event>('copy');

  @DomName('Element.cut')
  @DocsEditable
  static const EventStreamProvider<Event> cutEvent = const EventStreamProvider<Event>('cut');

  @DomName('Element.dblclick')
  @DocsEditable
  static const EventStreamProvider<Event> doubleClickEvent = const EventStreamProvider<Event>('dblclick');

  @DomName('Element.drag')
  @DocsEditable
  static const EventStreamProvider<MouseEvent> dragEvent = const EventStreamProvider<MouseEvent>('drag');

  @DomName('Element.dragend')
  @DocsEditable
  static const EventStreamProvider<MouseEvent> dragEndEvent = const EventStreamProvider<MouseEvent>('dragend');

  @DomName('Element.dragenter')
  @DocsEditable
  static const EventStreamProvider<MouseEvent> dragEnterEvent = const EventStreamProvider<MouseEvent>('dragenter');

  @DomName('Element.dragleave')
  @DocsEditable
  static const EventStreamProvider<MouseEvent> dragLeaveEvent = const EventStreamProvider<MouseEvent>('dragleave');

  @DomName('Element.dragover')
  @DocsEditable
  static const EventStreamProvider<MouseEvent> dragOverEvent = const EventStreamProvider<MouseEvent>('dragover');

  @DomName('Element.dragstart')
  @DocsEditable
  static const EventStreamProvider<MouseEvent> dragStartEvent = const EventStreamProvider<MouseEvent>('dragstart');

  @DomName('Element.drop')
  @DocsEditable
  static const EventStreamProvider<MouseEvent> dropEvent = const EventStreamProvider<MouseEvent>('drop');

  @DomName('Element.error')
  @DocsEditable
  static const EventStreamProvider<Event> errorEvent = const EventStreamProvider<Event>('error');

  @DomName('Element.focus')
  @DocsEditable
  static const EventStreamProvider<Event> focusEvent = const EventStreamProvider<Event>('focus');

  @DomName('Element.input')
  @DocsEditable
  static const EventStreamProvider<Event> inputEvent = const EventStreamProvider<Event>('input');

  @DomName('Element.invalid')
  @DocsEditable
  static const EventStreamProvider<Event> invalidEvent = const EventStreamProvider<Event>('invalid');

  @DomName('Element.keydown')
  @DocsEditable
  static const EventStreamProvider<KeyboardEvent> keyDownEvent = const EventStreamProvider<KeyboardEvent>('keydown');

  @DomName('Element.keypress')
  @DocsEditable
  static const EventStreamProvider<KeyboardEvent> keyPressEvent = const EventStreamProvider<KeyboardEvent>('keypress');

  @DomName('Element.keyup')
  @DocsEditable
  static const EventStreamProvider<KeyboardEvent> keyUpEvent = const EventStreamProvider<KeyboardEvent>('keyup');

  @DomName('Element.load')
  @DocsEditable
  static const EventStreamProvider<Event> loadEvent = const EventStreamProvider<Event>('load');

  @DomName('Element.mousedown')
  @DocsEditable
  static const EventStreamProvider<MouseEvent> mouseDownEvent = const EventStreamProvider<MouseEvent>('mousedown');

  @DomName('Element.mousemove')
  @DocsEditable
  static const EventStreamProvider<MouseEvent> mouseMoveEvent = const EventStreamProvider<MouseEvent>('mousemove');

  @DomName('Element.mouseout')
  @DocsEditable
  static const EventStreamProvider<MouseEvent> mouseOutEvent = const EventStreamProvider<MouseEvent>('mouseout');

  @DomName('Element.mouseover')
  @DocsEditable
  static const EventStreamProvider<MouseEvent> mouseOverEvent = const EventStreamProvider<MouseEvent>('mouseover');

  @DomName('Element.mouseup')
  @DocsEditable
  static const EventStreamProvider<MouseEvent> mouseUpEvent = const EventStreamProvider<MouseEvent>('mouseup');

  @DomName('Element.mousewheel')
  @DocsEditable
  static const EventStreamProvider<WheelEvent> mouseWheelEvent = const EventStreamProvider<WheelEvent>('mousewheel');

  @DomName('Element.paste')
  @DocsEditable
  static const EventStreamProvider<Event> pasteEvent = const EventStreamProvider<Event>('paste');

  @DomName('Element.reset')
  @DocsEditable
  static const EventStreamProvider<Event> resetEvent = const EventStreamProvider<Event>('reset');

  @DomName('Element.scroll')
  @DocsEditable
  static const EventStreamProvider<Event> scrollEvent = const EventStreamProvider<Event>('scroll');

  @DomName('Element.search')
  @DocsEditable
  static const EventStreamProvider<Event> searchEvent = const EventStreamProvider<Event>('search');

  @DomName('Element.select')
  @DocsEditable
  static const EventStreamProvider<Event> selectEvent = const EventStreamProvider<Event>('select');

  @DomName('Element.selectstart')
  @DocsEditable
  static const EventStreamProvider<Event> selectStartEvent = const EventStreamProvider<Event>('selectstart');

  @DomName('Element.submit')
  @DocsEditable
  static const EventStreamProvider<Event> submitEvent = const EventStreamProvider<Event>('submit');

  @DomName('Element.touchcancel')
  @DocsEditable
  static const EventStreamProvider<TouchEvent> touchCancelEvent = const EventStreamProvider<TouchEvent>('touchcancel');

  @DomName('Element.touchend')
  @DocsEditable
  static const EventStreamProvider<TouchEvent> touchEndEvent = const EventStreamProvider<TouchEvent>('touchend');

  @DomName('Element.touchenter')
  @DocsEditable
  static const EventStreamProvider<TouchEvent> touchEnterEvent = const EventStreamProvider<TouchEvent>('touchenter');

  @DomName('Element.touchleave')
  @DocsEditable
  static const EventStreamProvider<TouchEvent> touchLeaveEvent = const EventStreamProvider<TouchEvent>('touchleave');

  @DomName('Element.touchmove')
  @DocsEditable
  static const EventStreamProvider<TouchEvent> touchMoveEvent = const EventStreamProvider<TouchEvent>('touchmove');

  @DomName('Element.touchstart')
  @DocsEditable
  static const EventStreamProvider<TouchEvent> touchStartEvent = const EventStreamProvider<TouchEvent>('touchstart');

  @DomName('Element.webkitTransitionEnd')
  @DocsEditable
  static const EventStreamProvider<TransitionEvent> transitionEndEvent = const EventStreamProvider<TransitionEvent>('webkitTransitionEnd');

  @DomName('Element.webkitfullscreenchange')
  @DocsEditable
  static const EventStreamProvider<Event> fullscreenChangeEvent = const EventStreamProvider<Event>('webkitfullscreenchange');

  @DomName('Element.webkitfullscreenerror')
  @DocsEditable
  static const EventStreamProvider<Event> fullscreenErrorEvent = const EventStreamProvider<Event>('webkitfullscreenerror');

  @DocsEditable
  @DomName('EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent')
  @deprecated
  ElementEvents get on =>
    new ElementEvents(this);

  HtmlCollection get $dom_children;

  String contentEditable;

  String dir;

  bool draggable;

  bool hidden;

  String id;

  String innerHtml;

  bool get isContentEditable;

  String lang;

  String get outerHtml;

  bool spellcheck;

  int tabIndex;

  String title;

  bool translate;

  String webkitdropzone;

  void click();

  Element insertAdjacentElement(String where, Element element);

  void insertAdjacentHtml(String where, String html);

  void insertAdjacentText(String where, String text);

  static const int ALLOW_KEYBOARD_INPUT = 1;

  @DomName('Element.childElementCount')
  @DocsEditable
  int get $dom_childElementCount native "Element_childElementCount_Getter";

  @DomName('Element.className')
  @DocsEditable
  String get $dom_className native "Element_className_Getter";

  @DomName('Element.className')
  @DocsEditable
  void set $dom_className(String value) native "Element_className_Setter";

  @DomName('Element.clientHeight')
  @DocsEditable
  int get clientHeight native "Element_clientHeight_Getter";

  @DomName('Element.clientLeft')
  @DocsEditable
  int get clientLeft native "Element_clientLeft_Getter";

  @DomName('Element.clientTop')
  @DocsEditable
  int get clientTop native "Element_clientTop_Getter";

  @DomName('Element.clientWidth')
  @DocsEditable
  int get clientWidth native "Element_clientWidth_Getter";

  @DomName('Element.dataset')
  @DocsEditable
  Map<String, String> get dataset native "Element_dataset_Getter";

  @DomName('Element.firstElementChild')
  @DocsEditable
  Element get $dom_firstElementChild native "Element_firstElementChild_Getter";

  @DomName('Element.lastElementChild')
  @DocsEditable
  Element get $dom_lastElementChild native "Element_lastElementChild_Getter";

  @DomName('Element.nextElementSibling')
  @DocsEditable
  Element get nextElementSibling native "Element_nextElementSibling_Getter";

  @DomName('Element.offsetHeight')
  @DocsEditable
  int get offsetHeight native "Element_offsetHeight_Getter";

  @DomName('Element.offsetLeft')
  @DocsEditable
  int get offsetLeft native "Element_offsetLeft_Getter";

  @DomName('Element.offsetParent')
  @DocsEditable
  Element get offsetParent native "Element_offsetParent_Getter";

  @DomName('Element.offsetTop')
  @DocsEditable
  int get offsetTop native "Element_offsetTop_Getter";

  @DomName('Element.offsetWidth')
  @DocsEditable
  int get offsetWidth native "Element_offsetWidth_Getter";

  @DomName('Element.previousElementSibling')
  @DocsEditable
  Element get previousElementSibling native "Element_previousElementSibling_Getter";

  @DomName('Element.scrollHeight')
  @DocsEditable
  int get scrollHeight native "Element_scrollHeight_Getter";

  @DomName('Element.scrollLeft')
  @DocsEditable
  int get scrollLeft native "Element_scrollLeft_Getter";

  @DomName('Element.scrollLeft')
  @DocsEditable
  void set scrollLeft(int value) native "Element_scrollLeft_Setter";

  @DomName('Element.scrollTop')
  @DocsEditable
  int get scrollTop native "Element_scrollTop_Getter";

  @DomName('Element.scrollTop')
  @DocsEditable
  void set scrollTop(int value) native "Element_scrollTop_Setter";

  @DomName('Element.scrollWidth')
  @DocsEditable
  int get scrollWidth native "Element_scrollWidth_Getter";

  @DomName('Element.style')
  @DocsEditable
  CssStyleDeclaration get style native "Element_style_Getter";

  @DomName('Element.tagName')
  @DocsEditable
  String get tagName native "Element_tagName_Getter";

  @DomName('Element.webkitPseudo')
  @DocsEditable
  String get webkitPseudo native "Element_webkitPseudo_Getter";

  @DomName('Element.webkitPseudo')
  @DocsEditable
  void set webkitPseudo(String value) native "Element_webkitPseudo_Setter";

  @DomName('Element.webkitShadowRoot')
  @DocsEditable
  ShadowRoot get webkitShadowRoot native "Element_webkitShadowRoot_Getter";

  @DomName('Element.blur')
  @DocsEditable
  void blur() native "Element_blur_Callback";

  @DomName('Element.focus')
  @DocsEditable
  void focus() native "Element_focus_Callback";

  @DomName('Element.getAttribute')
  @DocsEditable
  String $dom_getAttribute(String name) native "Element_getAttribute_Callback";

  @DomName('Element.getAttributeNS')
  @DocsEditable
  String $dom_getAttributeNS(String namespaceURI, String localName) native "Element_getAttributeNS_Callback";

  @DomName('Element.getBoundingClientRect')
  @DocsEditable
  ClientRect getBoundingClientRect() native "Element_getBoundingClientRect_Callback";

  @DomName('Element.getClientRects')
  @DocsEditable
  List<ClientRect> getClientRects() native "Element_getClientRects_Callback";

  @DomName('Element.getElementsByClassName')
  @DocsEditable
  List<Node> $dom_getElementsByClassName(String name) native "Element_getElementsByClassName_Callback";

  @DomName('Element.getElementsByTagName')
  @DocsEditable
  List<Node> $dom_getElementsByTagName(String name) native "Element_getElementsByTagName_Callback";

  @DomName('Element.hasAttribute')
  @DocsEditable
  bool $dom_hasAttribute(String name) native "Element_hasAttribute_Callback";

  @DomName('Element.hasAttributeNS')
  @DocsEditable
  bool $dom_hasAttributeNS(String namespaceURI, String localName) native "Element_hasAttributeNS_Callback";

  @DomName('Element.querySelector')
  @DocsEditable
  Element $dom_querySelector(String selectors) native "Element_querySelector_Callback";

  @DomName('Element.querySelectorAll')
  @DocsEditable
  List<Node> $dom_querySelectorAll(String selectors) native "Element_querySelectorAll_Callback";

  @DomName('Element.remove')
  @DocsEditable
  void remove() native "Element_remove_Callback";

  @DomName('Element.removeAttribute')
  @DocsEditable
  void $dom_removeAttribute(String name) native "Element_removeAttribute_Callback";

  @DomName('Element.removeAttributeNS')
  @DocsEditable
  void $dom_removeAttributeNS(String namespaceURI, String localName) native "Element_removeAttributeNS_Callback";

  @DomName('Element.scrollByLines')
  @DocsEditable
  void scrollByLines(int lines) native "Element_scrollByLines_Callback";

  @DomName('Element.scrollByPages')
  @DocsEditable
  void scrollByPages(int pages) native "Element_scrollByPages_Callback";

  void scrollIntoView([bool centerIfNeeded]) {
    if (?centerIfNeeded) {
      _scrollIntoViewIfNeeded_1(centerIfNeeded);
      return;
    }
    _scrollIntoViewIfNeeded_2();
    return;
  }

  @DomName('Element._scrollIntoViewIfNeeded_1')
  @DocsEditable
  void _scrollIntoViewIfNeeded_1(centerIfNeeded) native "Element__scrollIntoViewIfNeeded_1_Callback";

  @DomName('Element._scrollIntoViewIfNeeded_2')
  @DocsEditable
  void _scrollIntoViewIfNeeded_2() native "Element__scrollIntoViewIfNeeded_2_Callback";

  @DomName('Element.setAttribute')
  @DocsEditable
  void $dom_setAttribute(String name, String value) native "Element_setAttribute_Callback";

  @DomName('Element.setAttributeNS')
  @DocsEditable
  void $dom_setAttributeNS(String namespaceURI, String qualifiedName, String value) native "Element_setAttributeNS_Callback";

  @DomName('Element.webkitCreateShadowRoot')
  @DocsEditable
  @SupportedBrowser(SupportedBrowser.CHROME, '25')
  @Experimental
  ShadowRoot createShadowRoot() native "Element_webkitCreateShadowRoot_Callback";

  @DomName('Element.webkitMatchesSelector')
  @DocsEditable
  bool matches(String selectors) native "Element_webkitMatchesSelector_Callback";

  @DomName('Element.webkitRequestFullScreen')
  @DocsEditable
  void webkitRequestFullScreen(int flags) native "Element_webkitRequestFullScreen_Callback";

  @DomName('Element.webkitRequestFullscreen')
  @DocsEditable
  void webkitRequestFullscreen() native "Element_webkitRequestFullscreen_Callback";

  @DomName('Element.webkitRequestPointerLock')
  @DocsEditable
  void webkitRequestPointerLock() native "Element_webkitRequestPointerLock_Callback";

  @DomName('Element.abort')
  @DocsEditable
  Stream<Event> get onAbort => abortEvent.forTarget(this);

  @DomName('Element.beforecopy')
  @DocsEditable
  Stream<Event> get onBeforeCopy => beforeCopyEvent.forTarget(this);

  @DomName('Element.beforecut')
  @DocsEditable
  Stream<Event> get onBeforeCut => beforeCutEvent.forTarget(this);

  @DomName('Element.beforepaste')
  @DocsEditable
  Stream<Event> get onBeforePaste => beforePasteEvent.forTarget(this);

  @DomName('Element.blur')
  @DocsEditable
  Stream<Event> get onBlur => blurEvent.forTarget(this);

  @DomName('Element.change')
  @DocsEditable
  Stream<Event> get onChange => changeEvent.forTarget(this);

  @DomName('Element.click')
  @DocsEditable
  Stream<MouseEvent> get onClick => clickEvent.forTarget(this);

  @DomName('Element.contextmenu')
  @DocsEditable
  Stream<MouseEvent> get onContextMenu => contextMenuEvent.forTarget(this);

  @DomName('Element.copy')
  @DocsEditable
  Stream<Event> get onCopy => copyEvent.forTarget(this);

  @DomName('Element.cut')
  @DocsEditable
  Stream<Event> get onCut => cutEvent.forTarget(this);

  @DomName('Element.dblclick')
  @DocsEditable
  Stream<Event> get onDoubleClick => doubleClickEvent.forTarget(this);

  @DomName('Element.drag')
  @DocsEditable
  Stream<MouseEvent> get onDrag => dragEvent.forTarget(this);

  @DomName('Element.dragend')
  @DocsEditable
  Stream<MouseEvent> get onDragEnd => dragEndEvent.forTarget(this);

  @DomName('Element.dragenter')
  @DocsEditable
  Stream<MouseEvent> get onDragEnter => dragEnterEvent.forTarget(this);

  @DomName('Element.dragleave')
  @DocsEditable
  Stream<MouseEvent> get onDragLeave => dragLeaveEvent.forTarget(this);

  @DomName('Element.dragover')
  @DocsEditable
  Stream<MouseEvent> get onDragOver => dragOverEvent.forTarget(this);

  @DomName('Element.dragstart')
  @DocsEditable
  Stream<MouseEvent> get onDragStart => dragStartEvent.forTarget(this);

  @DomName('Element.drop')
  @DocsEditable
  Stream<MouseEvent> get onDrop => dropEvent.forTarget(this);

  @DomName('Element.error')
  @DocsEditable
  Stream<Event> get onError => errorEvent.forTarget(this);

  @DomName('Element.focus')
  @DocsEditable
  Stream<Event> get onFocus => focusEvent.forTarget(this);

  @DomName('Element.input')
  @DocsEditable
  Stream<Event> get onInput => inputEvent.forTarget(this);

  @DomName('Element.invalid')
  @DocsEditable
  Stream<Event> get onInvalid => invalidEvent.forTarget(this);

  @DomName('Element.keydown')
  @DocsEditable
  Stream<KeyboardEvent> get onKeyDown => keyDownEvent.forTarget(this);

  @DomName('Element.keypress')
  @DocsEditable
  Stream<KeyboardEvent> get onKeyPress => keyPressEvent.forTarget(this);

  @DomName('Element.keyup')
  @DocsEditable
  Stream<KeyboardEvent> get onKeyUp => keyUpEvent.forTarget(this);

  @DomName('Element.load')
  @DocsEditable
  Stream<Event> get onLoad => loadEvent.forTarget(this);

  @DomName('Element.mousedown')
  @DocsEditable
  Stream<MouseEvent> get onMouseDown => mouseDownEvent.forTarget(this);

  @DomName('Element.mousemove')
  @DocsEditable
  Stream<MouseEvent> get onMouseMove => mouseMoveEvent.forTarget(this);

  @DomName('Element.mouseout')
  @DocsEditable
  Stream<MouseEvent> get onMouseOut => mouseOutEvent.forTarget(this);

  @DomName('Element.mouseover')
  @DocsEditable
  Stream<MouseEvent> get onMouseOver => mouseOverEvent.forTarget(this);

  @DomName('Element.mouseup')
  @DocsEditable
  Stream<MouseEvent> get onMouseUp => mouseUpEvent.forTarget(this);

  @DomName('Element.mousewheel')
  @DocsEditable
  Stream<WheelEvent> get onMouseWheel => mouseWheelEvent.forTarget(this);

  @DomName('Element.paste')
  @DocsEditable
  Stream<Event> get onPaste => pasteEvent.forTarget(this);

  @DomName('Element.reset')
  @DocsEditable
  Stream<Event> get onReset => resetEvent.forTarget(this);

  @DomName('Element.scroll')
  @DocsEditable
  Stream<Event> get onScroll => scrollEvent.forTarget(this);

  @DomName('Element.search')
  @DocsEditable
  Stream<Event> get onSearch => searchEvent.forTarget(this);

  @DomName('Element.select')
  @DocsEditable
  Stream<Event> get onSelect => selectEvent.forTarget(this);

  @DomName('Element.selectstart')
  @DocsEditable
  Stream<Event> get onSelectStart => selectStartEvent.forTarget(this);

  @DomName('Element.submit')
  @DocsEditable
  Stream<Event> get onSubmit => submitEvent.forTarget(this);

  @DomName('Element.touchcancel')
  @DocsEditable
  Stream<TouchEvent> get onTouchCancel => touchCancelEvent.forTarget(this);

  @DomName('Element.touchend')
  @DocsEditable
  Stream<TouchEvent> get onTouchEnd => touchEndEvent.forTarget(this);

  @DomName('Element.touchenter')
  @DocsEditable
  Stream<TouchEvent> get onTouchEnter => touchEnterEvent.forTarget(this);

  @DomName('Element.touchleave')
  @DocsEditable
  Stream<TouchEvent> get onTouchLeave => touchLeaveEvent.forTarget(this);

  @DomName('Element.touchmove')
  @DocsEditable
  Stream<TouchEvent> get onTouchMove => touchMoveEvent.forTarget(this);

  @DomName('Element.touchstart')
  @DocsEditable
  Stream<TouchEvent> get onTouchStart => touchStartEvent.forTarget(this);

  @DomName('Element.webkitTransitionEnd')
  @DocsEditable
  Stream<TransitionEvent> get onTransitionEnd => transitionEndEvent.forTarget(this);

  @DomName('Element.webkitfullscreenchange')
  @DocsEditable
  Stream<Event> get onFullscreenChange => fullscreenChangeEvent.forTarget(this);

  @DomName('Element.webkitfullscreenerror')
  @DocsEditable
  Stream<Event> get onFullscreenError => fullscreenErrorEvent.forTarget(this);

}

final _START_TAG_REGEXP = new RegExp('<(\\w+)');
class _ElementFactoryProvider {
  static const _CUSTOM_PARENT_TAG_MAP = const {
    'body' : 'html',
    'head' : 'html',
    'caption' : 'table',
    'td': 'tr',
    'th': 'tr',
    'colgroup': 'table',
    'col' : 'colgroup',
    'tr' : 'tbody',
    'tbody' : 'table',
    'tfoot' : 'table',
    'thead' : 'table',
    'track' : 'audio',
  };

  // TODO(jmesserly): const set would be better
  static const _TABLE_TAGS = const {
    'caption': null,
    'col': null,
    'colgroup': null,
    'tbody': null,
    'td': null,
    'tfoot': null,
    'th': null,
    'thead': null,
    'tr': null,
  };

  @DomName('Document.createElement')
  static Element createElement_html(String html) {
    // TODO(jacobr): this method can be made more robust and performant.
    // 1) Cache the dummy parent elements required to use innerHTML rather than
    //    creating them every call.
    // 2) Verify that the html does not contain leading or trailing text nodes.
    // 3) Verify that the html does not contain both <head> and <body> tags.
    // 4) Detatch the created element from its dummy parent.
    String parentTag = 'div';
    String tag;
    final match = _START_TAG_REGEXP.firstMatch(html);
    if (match != null) {
      tag = match.group(1).toLowerCase();
      if (_Device.isIE && _TABLE_TAGS.containsKey(tag)) {
        return _createTableForIE(html, tag);
      }
      parentTag = _CUSTOM_PARENT_TAG_MAP[tag];
      if (parentTag == null) parentTag = 'div';
    }

    final temp = new Element.tag(parentTag);
    temp.innerHtml = html;

    Element element;
    if (temp.children.length == 1) {
      element = temp.children[0];
    } else if (parentTag == 'html' && temp.children.length == 2) {
      // In html5 the root <html> tag will always have a <body> and a <head>,
      // even though the inner html only contains one of them.
      element = temp.children[tag == 'head' ? 0 : 1];
    } else {
      _singleNode(temp.children);
    }
    element.remove();
    return element;
  }

  /**
   * IE table elements don't support innerHTML (even in standards mode).
   * Instead we use a div and inject the table element in the innerHtml string.
   * This technique works on other browsers too, but it's probably slower,
   * so we only use it when running on IE.
   *
   * See also innerHTML:
   * <http://msdn.microsoft.com/en-us/library/ie/ms533897(v=vs.85).aspx>
   * and Building Tables Dynamically:
   * <http://msdn.microsoft.com/en-us/library/ie/ms532998(v=vs.85).aspx>.
   */
  static Element _createTableForIE(String html, String tag) {
    var div = new Element.tag('div');
    div.innerHtml = '<table>$html</table>';
    var table = _singleNode(div.children);
    Element element;
    switch (tag) {
      case 'td':
      case 'th':
        element = _singleNode(_singleNode(table.rows).cells);
        break;
      case 'tr':
        element = _singleNode(table.rows);
        break;
      case 'tbody':
        element = _singleNode(table.tBodies);
        break;
      case 'thead':
        element = table.tHead;
        break;
      case 'tfoot':
        element = table.tFoot;
        break;
      case 'caption':
        element = table.caption;
        break;
      case 'colgroup':
        element = _getColgroup(table);
        break;
      case 'col':
        element = _singleNode(_getColgroup(table).children);
        break;
    }
    element.remove();
    return element;
  }

  static TableColElement _getColgroup(TableElement table) {
    // TODO(jmesserly): is there a better way to do this?
    return _singleNode(table.children.where((n) => n.tagName == 'COLGROUP')
        .toList());
  }

  static Node _singleNode(List<Node> list) {
    if (list.length == 1) return list[0];
    throw new ArgumentError('HTML had ${list.length} '
        'top level elements but 1 expected');
  }

  @DomName('Document.createElement')
  static Element createElement_tag(String tag) =>
      document.$dom_createElement(tag);
}

@DocsEditable
@deprecated
class ElementEvents extends Events {
  @DocsEditable
  ElementEvents(EventTarget _ptr) : super(_ptr);

  @DocsEditable
  EventListenerList get abort => this['abort'];

  @DocsEditable
  EventListenerList get beforeCopy => this['beforecopy'];

  @DocsEditable
  EventListenerList get beforeCut => this['beforecut'];

  @DocsEditable
  EventListenerList get beforePaste => this['beforepaste'];

  @DocsEditable
  EventListenerList get blur => this['blur'];

  @DocsEditable
  EventListenerList get change => this['change'];

  @DocsEditable
  EventListenerList get click => this['click'];

  @DocsEditable
  EventListenerList get contextMenu => this['contextmenu'];

  @DocsEditable
  EventListenerList get copy => this['copy'];

  @DocsEditable
  EventListenerList get cut => this['cut'];

  @DocsEditable
  EventListenerList get doubleClick => this['dblclick'];

  @DocsEditable
  EventListenerList get drag => this['drag'];

  @DocsEditable
  EventListenerList get dragEnd => this['dragend'];

  @DocsEditable
  EventListenerList get dragEnter => this['dragenter'];

  @DocsEditable
  EventListenerList get dragLeave => this['dragleave'];

  @DocsEditable
  EventListenerList get dragOver => this['dragover'];

  @DocsEditable
  EventListenerList get dragStart => this['dragstart'];

  @DocsEditable
  EventListenerList get drop => this['drop'];

  @DocsEditable
  EventListenerList get error => this['error'];

  @DocsEditable
  EventListenerList get focus => this['focus'];

  @DocsEditable
  EventListenerList get input => this['input'];

  @DocsEditable
  EventListenerList get invalid => this['invalid'];

  @DocsEditable
  EventListenerList get keyDown => this['keydown'];

  @DocsEditable
  EventListenerList get keyPress => this['keypress'];

  @DocsEditable
  EventListenerList get keyUp => this['keyup'];

  @DocsEditable
  EventListenerList get load => this['load'];

  @DocsEditable
  EventListenerList get mouseDown => this['mousedown'];

  @DocsEditable
  EventListenerList get mouseMove => this['mousemove'];

  @DocsEditable
  EventListenerList get mouseOut => this['mouseout'];

  @DocsEditable
  EventListenerList get mouseOver => this['mouseover'];

  @DocsEditable
  EventListenerList get mouseUp => this['mouseup'];

  @DocsEditable
  EventListenerList get mouseWheel => this['mousewheel'];

  @DocsEditable
  EventListenerList get paste => this['paste'];

  @DocsEditable
  EventListenerList get reset => this['reset'];

  @DocsEditable
  EventListenerList get scroll => this['scroll'];

  @DocsEditable
  EventListenerList get search => this['search'];

  @DocsEditable
  EventListenerList get select => this['select'];

  @DocsEditable
  EventListenerList get selectStart => this['selectstart'];

  @DocsEditable
  EventListenerList get submit => this['submit'];

  @DocsEditable
  EventListenerList get touchCancel => this['touchcancel'];

  @DocsEditable
  EventListenerList get touchEnd => this['touchend'];

  @DocsEditable
  EventListenerList get touchEnter => this['touchenter'];

  @DocsEditable
  EventListenerList get touchLeave => this['touchleave'];

  @DocsEditable
  EventListenerList get touchMove => this['touchmove'];

  @DocsEditable
  EventListenerList get touchStart => this['touchstart'];

  @DocsEditable
  EventListenerList get transitionEnd => this['webkitTransitionEnd'];

  @DocsEditable
  EventListenerList get fullscreenChange => this['webkitfullscreenchange'];

  @DocsEditable
  EventListenerList get fullscreenError => this['webkitfullscreenerror'];
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('ElementTraversal')
class ElementTraversal extends NativeFieldWrapperClass1 {
  ElementTraversal.internal();

  @DomName('ElementTraversal.childElementCount')
  @DocsEditable
  int get $dom_childElementCount native "ElementTraversal_childElementCount_Getter";

  @DomName('ElementTraversal.firstElementChild')
  @DocsEditable
  Element get $dom_firstElementChild native "ElementTraversal_firstElementChild_Getter";

  @DomName('ElementTraversal.lastElementChild')
  @DocsEditable
  Element get $dom_lastElementChild native "ElementTraversal_lastElementChild_Getter";

  @DomName('ElementTraversal.nextElementSibling')
  @DocsEditable
  Element get nextElementSibling native "ElementTraversal_nextElementSibling_Getter";

  @DomName('ElementTraversal.previousElementSibling')
  @DocsEditable
  Element get previousElementSibling native "ElementTraversal_previousElementSibling_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('HTMLEmbedElement')
@SupportedBrowser(SupportedBrowser.CHROME)
@SupportedBrowser(SupportedBrowser.IE)
@SupportedBrowser(SupportedBrowser.SAFARI)
class EmbedElement extends _Element_Merged {
  EmbedElement.internal() : super.internal();

  @DocsEditable
  factory EmbedElement() => document.$dom_createElement("embed");

  /// Checks if this type is supported on the current platform.
  static bool get supported => true;

  @DomName('HTMLEmbedElement.align')
  @DocsEditable
  String get align native "HTMLEmbedElement_align_Getter";

  @DomName('HTMLEmbedElement.align')
  @DocsEditable
  void set align(String value) native "HTMLEmbedElement_align_Setter";

  @DomName('HTMLEmbedElement.height')
  @DocsEditable
  String get height native "HTMLEmbedElement_height_Getter";

  @DomName('HTMLEmbedElement.height')
  @DocsEditable
  void set height(String value) native "HTMLEmbedElement_height_Setter";

  @DomName('HTMLEmbedElement.name')
  @DocsEditable
  String get name native "HTMLEmbedElement_name_Getter";

  @DomName('HTMLEmbedElement.name')
  @DocsEditable
  void set name(String value) native "HTMLEmbedElement_name_Setter";

  @DomName('HTMLEmbedElement.src')
  @DocsEditable
  String get src native "HTMLEmbedElement_src_Getter";

  @DomName('HTMLEmbedElement.src')
  @DocsEditable
  void set src(String value) native "HTMLEmbedElement_src_Setter";

  @DomName('HTMLEmbedElement.type')
  @DocsEditable
  String get type native "HTMLEmbedElement_type_Getter";

  @DomName('HTMLEmbedElement.type')
  @DocsEditable
  void set type(String value) native "HTMLEmbedElement_type_Setter";

  @DomName('HTMLEmbedElement.width')
  @DocsEditable
  String get width native "HTMLEmbedElement_width_Getter";

  @DomName('HTMLEmbedElement.width')
  @DocsEditable
  void set width(String value) native "HTMLEmbedElement_width_Setter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('EntityReference')
class EntityReference extends Node {
  EntityReference.internal() : super.internal();

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


typedef void EntriesCallback(List<Entry> entries);
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('Entry')
class Entry extends NativeFieldWrapperClass1 {
  Entry.internal();

  @DomName('Entry.filesystem')
  @DocsEditable
  FileSystem get filesystem native "Entry_filesystem_Getter";

  @DomName('Entry.fullPath')
  @DocsEditable
  String get fullPath native "Entry_fullPath_Getter";

  @DomName('Entry.isDirectory')
  @DocsEditable
  bool get isDirectory native "Entry_isDirectory_Getter";

  @DomName('Entry.isFile')
  @DocsEditable
  bool get isFile native "Entry_isFile_Getter";

  @DomName('Entry.name')
  @DocsEditable
  String get name native "Entry_name_Getter";

  void copyTo(DirectoryEntry parent, [String name, EntryCallback successCallback, ErrorCallback errorCallback]) {
    if (?name) {
      _copyTo_1(parent, name, successCallback, errorCallback);
      return;
    }
    _copyTo_2(parent);
    return;
  }

  @DomName('Entry._copyTo_1')
  @DocsEditable
  void _copyTo_1(parent, name, successCallback, errorCallback) native "Entry__copyTo_1_Callback";

  @DomName('Entry._copyTo_2')
  @DocsEditable
  void _copyTo_2(parent) native "Entry__copyTo_2_Callback";

  @DomName('Entry.getMetadata')
  @DocsEditable
  void getMetadata(MetadataCallback successCallback, [ErrorCallback errorCallback]) native "Entry_getMetadata_Callback";

  @DomName('Entry.getParent')
  @DocsEditable
  void getParent([EntryCallback successCallback, ErrorCallback errorCallback]) native "Entry_getParent_Callback";

  void moveTo(DirectoryEntry parent, [String name, EntryCallback successCallback, ErrorCallback errorCallback]) {
    if (?name) {
      _moveTo_1(parent, name, successCallback, errorCallback);
      return;
    }
    _moveTo_2(parent);
    return;
  }

  @DomName('Entry._moveTo_1')
  @DocsEditable
  void _moveTo_1(parent, name, successCallback, errorCallback) native "Entry__moveTo_1_Callback";

  @DomName('Entry._moveTo_2')
  @DocsEditable
  void _moveTo_2(parent) native "Entry__moveTo_2_Callback";

  @DomName('Entry.remove')
  @DocsEditable
  void remove(VoidCallback successCallback, [ErrorCallback errorCallback]) native "Entry_remove_Callback";

  @DomName('Entry.toURL')
  @DocsEditable
  String toUrl() native "Entry_toURL_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


typedef void EntryCallback(Entry entry);
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('EntrySync')
class EntrySync extends NativeFieldWrapperClass1 {
  EntrySync.internal();

  @DomName('EntrySync.filesystem')
  @DocsEditable
  FileSystemSync get filesystem native "EntrySync_filesystem_Getter";

  @DomName('EntrySync.fullPath')
  @DocsEditable
  String get fullPath native "EntrySync_fullPath_Getter";

  @DomName('EntrySync.isDirectory')
  @DocsEditable
  bool get isDirectory native "EntrySync_isDirectory_Getter";

  @DomName('EntrySync.isFile')
  @DocsEditable
  bool get isFile native "EntrySync_isFile_Getter";

  @DomName('EntrySync.name')
  @DocsEditable
  String get name native "EntrySync_name_Getter";

  @DomName('EntrySync.copyTo')
  @DocsEditable
  EntrySync copyTo(DirectoryEntrySync parent, String name) native "EntrySync_copyTo_Callback";

  @DomName('EntrySync.getMetadata')
  @DocsEditable
  Metadata getMetadata() native "EntrySync_getMetadata_Callback";

  @DomName('EntrySync.getParent')
  @DocsEditable
  EntrySync getParent() native "EntrySync_getParent_Callback";

  @DomName('EntrySync.moveTo')
  @DocsEditable
  EntrySync moveTo(DirectoryEntrySync parent, String name) native "EntrySync_moveTo_Callback";

  @DomName('EntrySync.remove')
  @DocsEditable
  void remove() native "EntrySync_remove_Callback";

  @DomName('EntrySync.toURL')
  @DocsEditable
  String toUrl() native "EntrySync_toURL_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


typedef void ErrorCallback(FileError error);
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('ErrorEvent')
class ErrorEvent extends Event {
  ErrorEvent.internal() : super.internal();

  @DomName('ErrorEvent.filename')
  @DocsEditable
  String get filename native "ErrorEvent_filename_Getter";

  @DomName('ErrorEvent.lineno')
  @DocsEditable
  int get lineno native "ErrorEvent_lineno_Getter";

  @DomName('ErrorEvent.message')
  @DocsEditable
  String get message native "ErrorEvent_message_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DomName('Event')
class Event extends NativeFieldWrapperClass1 {
  // In JS, canBubble and cancelable are technically required parameters to
  // init*Event. In practice, though, if they aren't provided they simply
  // default to false (since that's Boolean(undefined)).
  //
  // Contrary to JS, we default canBubble and cancelable to true, since that's
  // what people want most of the time anyway.
  factory Event(String type,
      {bool canBubble: true, bool cancelable: true}) {
    return new Event.eventType('Event', type, canBubble: canBubble,
        cancelable: canBubble);
  }

  /**
   * Creates a new Event object of the specified type.
   *
   * This is analogous to document.createEvent.
   * Normally events should be created via their constructors, if available.
   *
   *     var e = new Event.type('MouseEvent', 'mousedown', true, true);
   */
  factory Event.eventType(String type, String name, {bool canBubble: true,
      bool cancelable: true}) {
    final Event e = document.$dom_createEvent(type);
    e.$dom_initEvent(name, canBubble, cancelable);
    return e;
  }
  Event.internal();

  static const int AT_TARGET = 2;

  static const int BLUR = 8192;

  static const int BUBBLING_PHASE = 3;

  static const int CAPTURING_PHASE = 1;

  static const int CHANGE = 32768;

  static const int CLICK = 64;

  static const int DBLCLICK = 128;

  static const int DRAGDROP = 2048;

  static const int FOCUS = 4096;

  static const int KEYDOWN = 256;

  static const int KEYPRESS = 1024;

  static const int KEYUP = 512;

  static const int MOUSEDOWN = 1;

  static const int MOUSEDRAG = 32;

  static const int MOUSEMOVE = 16;

  static const int MOUSEOUT = 8;

  static const int MOUSEOVER = 4;

  static const int MOUSEUP = 2;

  static const int NONE = 0;

  static const int SELECT = 16384;

  @DomName('Event.bubbles')
  @DocsEditable
  bool get bubbles native "Event_bubbles_Getter";

  @DomName('Event.cancelBubble')
  @DocsEditable
  bool get cancelBubble native "Event_cancelBubble_Getter";

  @DomName('Event.cancelBubble')
  @DocsEditable
  void set cancelBubble(bool value) native "Event_cancelBubble_Setter";

  @DomName('Event.cancelable')
  @DocsEditable
  bool get cancelable native "Event_cancelable_Getter";

  @DomName('Event.clipboardData')
  @DocsEditable
  Clipboard get clipboardData native "Event_clipboardData_Getter";

  @DomName('Event.currentTarget')
  @DocsEditable
  EventTarget get currentTarget native "Event_currentTarget_Getter";

  @DomName('Event.defaultPrevented')
  @DocsEditable
  bool get defaultPrevented native "Event_defaultPrevented_Getter";

  @DomName('Event.eventPhase')
  @DocsEditable
  int get eventPhase native "Event_eventPhase_Getter";

  @DomName('Event.returnValue')
  @DocsEditable
  bool get returnValue native "Event_returnValue_Getter";

  @DomName('Event.returnValue')
  @DocsEditable
  void set returnValue(bool value) native "Event_returnValue_Setter";

  @DomName('Event.target')
  @DocsEditable
  EventTarget get target native "Event_target_Getter";

  @DomName('Event.timeStamp')
  @DocsEditable
  int get timeStamp native "Event_timeStamp_Getter";

  @DomName('Event.type')
  @DocsEditable
  String get type native "Event_type_Getter";

  @DomName('Event.initEvent')
  @DocsEditable
  void $dom_initEvent(String eventTypeArg, bool canBubbleArg, bool cancelableArg) native "Event_initEvent_Callback";

  @DomName('Event.preventDefault')
  @DocsEditable
  void preventDefault() native "Event_preventDefault_Callback";

  @DomName('Event.stopImmediatePropagation')
  @DocsEditable
  void stopImmediatePropagation() native "Event_stopImmediatePropagation_Callback";

  @DomName('Event.stopPropagation')
  @DocsEditable
  void stopPropagation() native "Event_stopPropagation_Callback";


  /**
   * Checks to see if the event class is supported by the current platform.
   */
  static bool _isTypeSupported(String eventType) {
    // Browsers throw for unsupported event names.
    try {
      var e = document.$dom_createEvent(eventType);
      return e is Event;
    } catch (_) { }
    return false;
  }
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('EventException')
class EventException extends NativeFieldWrapperClass1 {
  EventException.internal();

  static const int DISPATCH_REQUEST_ERR = 1;

  static const int UNSPECIFIED_EVENT_TYPE_ERR = 0;

  @DomName('EventException.code')
  @DocsEditable
  int get code native "EventException_code_Getter";

  @DomName('EventException.message')
  @DocsEditable
  String get message native "EventException_message_Getter";

  @DomName('EventException.name')
  @DocsEditable
  String get name native "EventException_name_Getter";

  @DomName('EventException.toString')
  @DocsEditable
  String toString() native "EventException_toString_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('EventSource')
class EventSource extends EventTarget {
  EventSource.internal() : super.internal();

  @DomName('EventSource.error')
  @DocsEditable
  static const EventStreamProvider<Event> errorEvent = const EventStreamProvider<Event>('error');

  @DomName('EventSource.message')
  @DocsEditable
  static const EventStreamProvider<MessageEvent> messageEvent = const EventStreamProvider<MessageEvent>('message');

  @DomName('EventSource.open')
  @DocsEditable
  static const EventStreamProvider<Event> openEvent = const EventStreamProvider<Event>('open');

  @DocsEditable
  factory EventSource(String url, [Map eventSourceInit]) {
    if (!?eventSourceInit) {
      return EventSource._create(url);
    }
    return EventSource._create(url, eventSourceInit);
  }
  static EventSource _create(String url, [Map eventSourceInit]) native "EventSource_constructor_Callback";

  @DocsEditable
  @DomName('EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent')
  @deprecated
  EventSourceEvents get on =>
    new EventSourceEvents(this);

  static const int CLOSED = 2;

  static const int CONNECTING = 0;

  static const int OPEN = 1;

  @DomName('EventSource.readyState')
  @DocsEditable
  int get readyState native "EventSource_readyState_Getter";

  @DomName('EventSource.url')
  @DocsEditable
  String get url native "EventSource_url_Getter";

  @DomName('EventSource.withCredentials')
  @DocsEditable
  bool get withCredentials native "EventSource_withCredentials_Getter";

  @DomName('EventSource.addEventListener')
  @DocsEditable
  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]) native "EventSource_addEventListener_Callback";

  @DomName('EventSource.close')
  @DocsEditable
  void close() native "EventSource_close_Callback";

  @DomName('EventSource.dispatchEvent')
  @DocsEditable
  bool dispatchEvent(Event evt) native "EventSource_dispatchEvent_Callback";

  @DomName('EventSource.removeEventListener')
  @DocsEditable
  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]) native "EventSource_removeEventListener_Callback";

  @DomName('EventSource.error')
  @DocsEditable
  Stream<Event> get onError => errorEvent.forTarget(this);

  @DomName('EventSource.message')
  @DocsEditable
  Stream<MessageEvent> get onMessage => messageEvent.forTarget(this);

  @DomName('EventSource.open')
  @DocsEditable
  Stream<Event> get onOpen => openEvent.forTarget(this);

}

@DocsEditable
@deprecated
class EventSourceEvents extends Events {
  @DocsEditable
  EventSourceEvents(EventTarget _ptr) : super(_ptr);

  @DocsEditable
  EventListenerList get error => this['error'];

  @DocsEditable
  EventListenerList get message => this['message'];

  @DocsEditable
  EventListenerList get open => this['open'];
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.


/**
 * Base class that supports listening for and dispatching browser events.
 *
 * Events can either be accessed by string name (using the indexed getter) or by
 * getters exposed by subclasses. Use the getters exposed by subclasses when
 * possible for better compile-time type checks.
 *
 * Using an indexed getter:
 *     events['mouseover'].add((e) => print("Mouse over!"));
 *
 * Using a getter provided by a subclass:
 *     elementEvents.mouseOver.add((e) => print("Mouse over!"));
 */
class Events {
  /* Raw event target. */
  final EventTarget _ptr;

  Events(this._ptr);

  EventListenerList operator [](String type) {
    return new EventListenerList(_ptr, type);
  }
}

/**
 * Supports adding, removing, and dispatching events for a specific event type.
 */
class EventListenerList {

  final EventTarget _ptr;
  final String _type;

  EventListenerList(this._ptr, this._type);

  // TODO(jacobr): implement equals.

  EventListenerList add(EventListener listener,
      [bool useCapture = false]) {
    _add(listener, useCapture);
    return this;
  }

  EventListenerList remove(EventListener listener,
      [bool useCapture = false]) {
    _remove(listener, useCapture);
    return this;
  }

  bool dispatch(Event evt) {
    return _ptr.dispatchEvent(evt);
  }

  void _add(EventListener listener, bool useCapture) {
    _ptr.$dom_addEventListener(_type, listener, useCapture);
  }

  void _remove(EventListener listener, bool useCapture) {
    _ptr.$dom_removeEventListener(_type, listener, useCapture);
  }
}

/**
 * Base class for all browser objects that support events.
 *
 * Use the [on] property to add, remove, and dispatch events (rather than
 * [$dom_addEventListener], [$dom_dispatchEvent], and
 * [$dom_removeEventListener]) for compile-time type checks and a more concise
 * API.
 */
@DomName('EventTarget')
class EventTarget extends NativeFieldWrapperClass1 {

  @DomName('EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent')
  Events get on => new Events(this);
  EventTarget.internal();

  @DomName('EventTarget.addEventListener')
  @DocsEditable
  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]) native "EventTarget_addEventListener_Callback";

  @DomName('EventTarget.dispatchEvent')
  @DocsEditable
  bool dispatchEvent(Event event) native "EventTarget_dispatchEvent_Callback";

  @DomName('EventTarget.removeEventListener')
  @DocsEditable
  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]) native "EventTarget_removeEventListener_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('EXTTextureFilterAnisotropic')
class ExtTextureFilterAnisotropic extends NativeFieldWrapperClass1 {
  ExtTextureFilterAnisotropic.internal();

  static const int MAX_TEXTURE_MAX_ANISOTROPY_EXT = 0x84FF;

  static const int TEXTURE_MAX_ANISOTROPY_EXT = 0x84FE;

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('HTMLFieldSetElement')
class FieldSetElement extends _Element_Merged {
  FieldSetElement.internal() : super.internal();

  @DocsEditable
  factory FieldSetElement() => document.$dom_createElement("fieldset");

  @DomName('HTMLFieldSetElement.disabled')
  @DocsEditable
  bool get disabled native "HTMLFieldSetElement_disabled_Getter";

  @DomName('HTMLFieldSetElement.disabled')
  @DocsEditable
  void set disabled(bool value) native "HTMLFieldSetElement_disabled_Setter";

  @DomName('HTMLFieldSetElement.elements')
  @DocsEditable
  HtmlCollection get elements native "HTMLFieldSetElement_elements_Getter";

  @DomName('HTMLFieldSetElement.form')
  @DocsEditable
  FormElement get form native "HTMLFieldSetElement_form_Getter";

  @DomName('HTMLFieldSetElement.name')
  @DocsEditable
  String get name native "HTMLFieldSetElement_name_Getter";

  @DomName('HTMLFieldSetElement.name')
  @DocsEditable
  void set name(String value) native "HTMLFieldSetElement_name_Setter";

  @DomName('HTMLFieldSetElement.type')
  @DocsEditable
  String get type native "HTMLFieldSetElement_type_Getter";

  @DomName('HTMLFieldSetElement.validationMessage')
  @DocsEditable
  String get validationMessage native "HTMLFieldSetElement_validationMessage_Getter";

  @DomName('HTMLFieldSetElement.validity')
  @DocsEditable
  ValidityState get validity native "HTMLFieldSetElement_validity_Getter";

  @DomName('HTMLFieldSetElement.willValidate')
  @DocsEditable
  bool get willValidate native "HTMLFieldSetElement_willValidate_Getter";

  @DomName('HTMLFieldSetElement.checkValidity')
  @DocsEditable
  bool checkValidity() native "HTMLFieldSetElement_checkValidity_Callback";

  @DomName('HTMLFieldSetElement.setCustomValidity')
  @DocsEditable
  void setCustomValidity(String error) native "HTMLFieldSetElement_setCustomValidity_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('File')
class File extends Blob {
  File.internal() : super.internal();

  @DomName('File.lastModifiedDate')
  @DocsEditable
  Date get lastModifiedDate native "File_lastModifiedDate_Getter";

  @DomName('File.name')
  @DocsEditable
  String get name native "File_name_Getter";

  @DomName('File.webkitRelativePath')
  @DocsEditable
  String get webkitRelativePath native "File_webkitRelativePath_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


typedef void FileCallback(File file);
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('FileEntry')
class FileEntry extends Entry {
  FileEntry.internal() : super.internal();

  @DomName('FileEntry.createWriter')
  @DocsEditable
  void createWriter(FileWriterCallback successCallback, [ErrorCallback errorCallback]) native "FileEntry_createWriter_Callback";

  @DomName('FileEntry.file')
  @DocsEditable
  void file(FileCallback successCallback, [ErrorCallback errorCallback]) native "FileEntry_file_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('FileEntrySync')
class FileEntrySync extends EntrySync {
  FileEntrySync.internal() : super.internal();

  @DomName('FileEntrySync.createWriter')
  @DocsEditable
  FileWriterSync createWriter() native "FileEntrySync_createWriter_Callback";

  @DomName('FileEntrySync.file')
  @DocsEditable
  File file() native "FileEntrySync_file_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('FileError')
class FileError extends NativeFieldWrapperClass1 {
  FileError.internal();

  static const int ABORT_ERR = 3;

  static const int ENCODING_ERR = 5;

  static const int INVALID_MODIFICATION_ERR = 9;

  static const int INVALID_STATE_ERR = 7;

  static const int NOT_FOUND_ERR = 1;

  static const int NOT_READABLE_ERR = 4;

  static const int NO_MODIFICATION_ALLOWED_ERR = 6;

  static const int PATH_EXISTS_ERR = 12;

  static const int QUOTA_EXCEEDED_ERR = 10;

  static const int SECURITY_ERR = 2;

  static const int SYNTAX_ERR = 8;

  static const int TYPE_MISMATCH_ERR = 11;

  @DomName('FileError.code')
  @DocsEditable
  int get code native "FileError_code_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('FileException')
class FileException extends NativeFieldWrapperClass1 {
  FileException.internal();

  static const int ABORT_ERR = 3;

  static const int ENCODING_ERR = 5;

  static const int INVALID_MODIFICATION_ERR = 9;

  static const int INVALID_STATE_ERR = 7;

  static const int NOT_FOUND_ERR = 1;

  static const int NOT_READABLE_ERR = 4;

  static const int NO_MODIFICATION_ALLOWED_ERR = 6;

  static const int PATH_EXISTS_ERR = 12;

  static const int QUOTA_EXCEEDED_ERR = 10;

  static const int SECURITY_ERR = 2;

  static const int SYNTAX_ERR = 8;

  static const int TYPE_MISMATCH_ERR = 11;

  @DomName('FileException.code')
  @DocsEditable
  int get code native "FileException_code_Getter";

  @DomName('FileException.message')
  @DocsEditable
  String get message native "FileException_message_Getter";

  @DomName('FileException.name')
  @DocsEditable
  String get name native "FileException_name_Getter";

  @DomName('FileException.toString')
  @DocsEditable
  String toString() native "FileException_toString_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('FileList')
class FileList extends NativeFieldWrapperClass1 implements List<File> {
  FileList.internal();

  @DomName('FileList.length')
  @DocsEditable
  int get length native "FileList_length_Getter";

  File operator[](int index) native "FileList_item_Callback";

  void operator[]=(int index, File value) {
    throw new UnsupportedError("Cannot assign element of immutable List.");
  }
  // -- start List<File> mixins.
  // File is the element type.

  // From Iterable<File>:

  Iterator<File> get iterator {
    // Note: NodeLists are not fixed size. And most probably length shouldn't
    // be cached in both iterator _and_ forEach method. For now caching it
    // for consistency.
    return new FixedSizeListIterator<File>(this);
  }

  dynamic reduce(dynamic initialValue, dynamic combine(dynamic, File)) {
    return IterableMixinWorkaround.reduce(this, initialValue, combine);
  }

  bool contains(File element) => IterableMixinWorkaround.contains(this, element);

  void forEach(void f(File element)) => IterableMixinWorkaround.forEach(this, f);

  String join([String separator]) =>
      IterableMixinWorkaround.joinList(this, separator);

  List mappedBy(f(File element)) => IterableMixinWorkaround.mappedByList(this, f);

  Iterable<File> where(bool f(File element)) =>
      IterableMixinWorkaround.where(this, f);

  bool every(bool f(File element)) => IterableMixinWorkaround.every(this, f);

  bool any(bool f(File element)) => IterableMixinWorkaround.any(this, f);

  List<File> toList() => new List<File>.from(this);
  Set<File> toSet() => new Set<File>.from(this);

  bool get isEmpty => this.length == 0;

  List<File> take(int n) => IterableMixinWorkaround.takeList(this, n);

  Iterable<File> takeWhile(bool test(File value)) {
    return IterableMixinWorkaround.takeWhile(this, test);
  }

  List<File> skip(int n) => IterableMixinWorkaround.skipList(this, n);

  Iterable<File> skipWhile(bool test(File value)) {
    return IterableMixinWorkaround.skipWhile(this, test);
  }

  File firstMatching(bool test(File value), { File orElse() }) {
    return IterableMixinWorkaround.firstMatching(this, test, orElse);
  }

  File lastMatching(bool test(File value), {File orElse()}) {
    return IterableMixinWorkaround.lastMatchingInList(this, test, orElse);
  }

  File singleMatching(bool test(File value)) {
    return IterableMixinWorkaround.singleMatching(this, test);
  }

  File elementAt(int index) {
    return this[index];
  }

  // From Collection<File>:

  void add(File value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addLast(File value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addAll(Iterable<File> iterable) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  // From List<File>:
  void set length(int value) {
    throw new UnsupportedError("Cannot resize immutable List.");
  }

  void clear() {
    throw new UnsupportedError("Cannot clear immutable List.");
  }

  List<File> get reversed =>
      new ReversedListView<File>(this, 0, null);

  void sort([int compare(File a, File b)]) {
    throw new UnsupportedError("Cannot sort immutable List.");
  }

  int indexOf(File element, [int start = 0]) =>
      Lists.indexOf(this, element, start, this.length);

  int lastIndexOf(File element, [int start]) {
    if (start == null) start = length - 1;
    return Lists.lastIndexOf(this, element, start);
  }

  File get first {
    if (this.length > 0) return this[0];
    throw new StateError("No elements");
  }

  File get last {
    if (this.length > 0) return this[this.length - 1];
    throw new StateError("No elements");
  }

  File get single {
    if (length == 1) return this[0];
    if (length == 0) throw new StateError("No elements");
    throw new StateError("More than one element");
  }

  File min([int compare(File a, File b)]) =>
      IterableMixinWorkaround.min(this, compare);

  File max([int compare(File a, File b)]) =>
      IterableMixinWorkaround.max(this, compare);

  File removeAt(int pos) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  File removeLast() {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void remove(Object object) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void removeAll(Iterable elements) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void retainAll(Iterable elements) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void removeMatching(bool test(File element)) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void retainMatching(bool test(File element)) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void setRange(int start, int rangeLength, List<File> from, [int startFrom]) {
    throw new UnsupportedError("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int rangeLength) {
    throw new UnsupportedError("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int rangeLength, [File initialValue]) {
    throw new UnsupportedError("Cannot insertRange on immutable List.");
  }

  List<File> getRange(int start, int rangeLength) =>
      Lists.getRange(this, start, rangeLength, <File>[]);

  // -- end List<File> mixins.

  @DomName('FileList.item')
  @DocsEditable
  File item(int index) native "FileList_item_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('FileReader')
class FileReader extends EventTarget {
  FileReader.internal() : super.internal();

  @DomName('FileReader.abort')
  @DocsEditable
  static const EventStreamProvider<ProgressEvent> abortEvent = const EventStreamProvider<ProgressEvent>('abort');

  @DomName('FileReader.error')
  @DocsEditable
  static const EventStreamProvider<Event> errorEvent = const EventStreamProvider<Event>('error');

  @DomName('FileReader.load')
  @DocsEditable
  static const EventStreamProvider<ProgressEvent> loadEvent = const EventStreamProvider<ProgressEvent>('load');

  @DomName('FileReader.loadend')
  @DocsEditable
  static const EventStreamProvider<ProgressEvent> loadEndEvent = const EventStreamProvider<ProgressEvent>('loadend');

  @DomName('FileReader.loadstart')
  @DocsEditable
  static const EventStreamProvider<ProgressEvent> loadStartEvent = const EventStreamProvider<ProgressEvent>('loadstart');

  @DomName('FileReader.progress')
  @DocsEditable
  static const EventStreamProvider<ProgressEvent> progressEvent = const EventStreamProvider<ProgressEvent>('progress');

  @DocsEditable
  factory FileReader() => FileReader._create();
  static FileReader _create() native "FileReader_constructor_Callback";

  @DocsEditable
  @DomName('EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent')
  @deprecated
  FileReaderEvents get on =>
    new FileReaderEvents(this);

  static const int DONE = 2;

  static const int EMPTY = 0;

  static const int LOADING = 1;

  @DomName('FileReader.error')
  @DocsEditable
  FileError get error native "FileReader_error_Getter";

  @DomName('FileReader.readyState')
  @DocsEditable
  int get readyState native "FileReader_readyState_Getter";

  @DomName('FileReader.result')
  @DocsEditable
  Object get result native "FileReader_result_Getter";

  @DomName('FileReader.abort')
  @DocsEditable
  void abort() native "FileReader_abort_Callback";

  @DomName('FileReader.addEventListener')
  @DocsEditable
  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]) native "FileReader_addEventListener_Callback";

  @DomName('FileReader.dispatchEvent')
  @DocsEditable
  bool dispatchEvent(Event evt) native "FileReader_dispatchEvent_Callback";

  @DomName('FileReader.readAsArrayBuffer')
  @DocsEditable
  void readAsArrayBuffer(Blob blob) native "FileReader_readAsArrayBuffer_Callback";

  @DomName('FileReader.readAsBinaryString')
  @DocsEditable
  void readAsBinaryString(Blob blob) native "FileReader_readAsBinaryString_Callback";

  @DomName('FileReader.readAsDataURL')
  @DocsEditable
  void readAsDataUrl(Blob blob) native "FileReader_readAsDataURL_Callback";

  void readAsText(Blob blob, [String encoding]) {
    if (?encoding) {
      _readAsText_1(blob, encoding);
      return;
    }
    _readAsText_2(blob);
    return;
  }

  @DomName('FileReader._readAsText_1')
  @DocsEditable
  void _readAsText_1(blob, encoding) native "FileReader__readAsText_1_Callback";

  @DomName('FileReader._readAsText_2')
  @DocsEditable
  void _readAsText_2(blob) native "FileReader__readAsText_2_Callback";

  @DomName('FileReader.removeEventListener')
  @DocsEditable
  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]) native "FileReader_removeEventListener_Callback";

  @DomName('FileReader.abort')
  @DocsEditable
  Stream<ProgressEvent> get onAbort => abortEvent.forTarget(this);

  @DomName('FileReader.error')
  @DocsEditable
  Stream<Event> get onError => errorEvent.forTarget(this);

  @DomName('FileReader.load')
  @DocsEditable
  Stream<ProgressEvent> get onLoad => loadEvent.forTarget(this);

  @DomName('FileReader.loadend')
  @DocsEditable
  Stream<ProgressEvent> get onLoadEnd => loadEndEvent.forTarget(this);

  @DomName('FileReader.loadstart')
  @DocsEditable
  Stream<ProgressEvent> get onLoadStart => loadStartEvent.forTarget(this);

  @DomName('FileReader.progress')
  @DocsEditable
  Stream<ProgressEvent> get onProgress => progressEvent.forTarget(this);

}

@DocsEditable
@deprecated
class FileReaderEvents extends Events {
  @DocsEditable
  FileReaderEvents(EventTarget _ptr) : super(_ptr);

  @DocsEditable
  EventListenerList get abort => this['abort'];

  @DocsEditable
  EventListenerList get error => this['error'];

  @DocsEditable
  EventListenerList get load => this['load'];

  @DocsEditable
  EventListenerList get loadEnd => this['loadend'];

  @DocsEditable
  EventListenerList get loadStart => this['loadstart'];

  @DocsEditable
  EventListenerList get progress => this['progress'];
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('FileReaderSync')
class FileReaderSync extends NativeFieldWrapperClass1 {
  FileReaderSync.internal();

  @DocsEditable
  factory FileReaderSync() => FileReaderSync._create();
  static FileReaderSync _create() native "FileReaderSync_constructor_Callback";

  @DomName('FileReaderSync.readAsArrayBuffer')
  @DocsEditable
  ArrayBuffer readAsArrayBuffer(Blob blob) native "FileReaderSync_readAsArrayBuffer_Callback";

  @DomName('FileReaderSync.readAsBinaryString')
  @DocsEditable
  String readAsBinaryString(Blob blob) native "FileReaderSync_readAsBinaryString_Callback";

  @DomName('FileReaderSync.readAsDataURL')
  @DocsEditable
  String readAsDataUrl(Blob blob) native "FileReaderSync_readAsDataURL_Callback";

  String readAsText(Blob blob, [String encoding]) {
    if (?encoding) {
      return _readAsText_1(blob, encoding);
    }
    return _readAsText_2(blob);
  }

  @DomName('FileReaderSync._readAsText_1')
  @DocsEditable
  String _readAsText_1(blob, encoding) native "FileReaderSync__readAsText_1_Callback";

  @DomName('FileReaderSync._readAsText_2')
  @DocsEditable
  String _readAsText_2(blob) native "FileReaderSync__readAsText_2_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('DOMFileSystem')
class FileSystem extends NativeFieldWrapperClass1 {
  FileSystem.internal();

  /// Checks if this type is supported on the current platform.
  static bool get supported => true;

  @DomName('DOMFileSystem.name')
  @DocsEditable
  String get name native "DOMFileSystem_name_Getter";

  @DomName('DOMFileSystem.root')
  @DocsEditable
  DirectoryEntry get root native "DOMFileSystem_root_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


typedef void FileSystemCallback(FileSystem fileSystem);
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('DOMFileSystemSync')
class FileSystemSync extends NativeFieldWrapperClass1 {
  FileSystemSync.internal();

  @DomName('DOMFileSystemSync.name')
  @DocsEditable
  String get name native "DOMFileSystemSync_name_Getter";

  @DomName('DOMFileSystemSync.root')
  @DocsEditable
  DirectoryEntrySync get root native "DOMFileSystemSync_root_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('FileWriter')
class FileWriter extends EventTarget {
  FileWriter.internal() : super.internal();

  @DomName('FileWriter.abort')
  @DocsEditable
  static const EventStreamProvider<ProgressEvent> abortEvent = const EventStreamProvider<ProgressEvent>('abort');

  @DomName('FileWriter.error')
  @DocsEditable
  static const EventStreamProvider<Event> errorEvent = const EventStreamProvider<Event>('error');

  @DomName('FileWriter.progress')
  @DocsEditable
  static const EventStreamProvider<ProgressEvent> progressEvent = const EventStreamProvider<ProgressEvent>('progress');

  @DomName('FileWriter.write')
  @DocsEditable
  static const EventStreamProvider<ProgressEvent> writeEvent = const EventStreamProvider<ProgressEvent>('write');

  @DomName('FileWriter.writeend')
  @DocsEditable
  static const EventStreamProvider<ProgressEvent> writeEndEvent = const EventStreamProvider<ProgressEvent>('writeend');

  @DomName('FileWriter.writestart')
  @DocsEditable
  static const EventStreamProvider<ProgressEvent> writeStartEvent = const EventStreamProvider<ProgressEvent>('writestart');

  @DocsEditable
  @DomName('EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent')
  @deprecated
  FileWriterEvents get on =>
    new FileWriterEvents(this);

  static const int DONE = 2;

  static const int INIT = 0;

  static const int WRITING = 1;

  @DomName('FileWriter.error')
  @DocsEditable
  FileError get error native "FileWriter_error_Getter";

  @DomName('FileWriter.length')
  @DocsEditable
  int get length native "FileWriter_length_Getter";

  @DomName('FileWriter.position')
  @DocsEditable
  int get position native "FileWriter_position_Getter";

  @DomName('FileWriter.readyState')
  @DocsEditable
  int get readyState native "FileWriter_readyState_Getter";

  @DomName('FileWriter.abort')
  @DocsEditable
  void abort() native "FileWriter_abort_Callback";

  @DomName('FileWriter.addEventListener')
  @DocsEditable
  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]) native "FileWriter_addEventListener_Callback";

  @DomName('FileWriter.dispatchEvent')
  @DocsEditable
  bool dispatchEvent(Event evt) native "FileWriter_dispatchEvent_Callback";

  @DomName('FileWriter.removeEventListener')
  @DocsEditable
  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]) native "FileWriter_removeEventListener_Callback";

  @DomName('FileWriter.seek')
  @DocsEditable
  void seek(int position) native "FileWriter_seek_Callback";

  @DomName('FileWriter.truncate')
  @DocsEditable
  void truncate(int size) native "FileWriter_truncate_Callback";

  @DomName('FileWriter.write')
  @DocsEditable
  void write(Blob data) native "FileWriter_write_Callback";

  @DomName('FileWriter.abort')
  @DocsEditable
  Stream<ProgressEvent> get onAbort => abortEvent.forTarget(this);

  @DomName('FileWriter.error')
  @DocsEditable
  Stream<Event> get onError => errorEvent.forTarget(this);

  @DomName('FileWriter.progress')
  @DocsEditable
  Stream<ProgressEvent> get onProgress => progressEvent.forTarget(this);

  @DomName('FileWriter.write')
  @DocsEditable
  Stream<ProgressEvent> get onWrite => writeEvent.forTarget(this);

  @DomName('FileWriter.writeend')
  @DocsEditable
  Stream<ProgressEvent> get onWriteEnd => writeEndEvent.forTarget(this);

  @DomName('FileWriter.writestart')
  @DocsEditable
  Stream<ProgressEvent> get onWriteStart => writeStartEvent.forTarget(this);

}

@DocsEditable
@deprecated
class FileWriterEvents extends Events {
  @DocsEditable
  FileWriterEvents(EventTarget _ptr) : super(_ptr);

  @DocsEditable
  EventListenerList get abort => this['abort'];

  @DocsEditable
  EventListenerList get error => this['error'];

  @DocsEditable
  EventListenerList get progress => this['progress'];

  @DocsEditable
  EventListenerList get write => this['write'];

  @DocsEditable
  EventListenerList get writeEnd => this['writeend'];

  @DocsEditable
  EventListenerList get writeStart => this['writestart'];
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


typedef void FileWriterCallback(FileWriter fileWriter);
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('FileWriterSync')
class FileWriterSync extends NativeFieldWrapperClass1 {
  FileWriterSync.internal();

  @DomName('FileWriterSync.length')
  @DocsEditable
  int get length native "FileWriterSync_length_Getter";

  @DomName('FileWriterSync.position')
  @DocsEditable
  int get position native "FileWriterSync_position_Getter";

  @DomName('FileWriterSync.seek')
  @DocsEditable
  void seek(int position) native "FileWriterSync_seek_Callback";

  @DomName('FileWriterSync.truncate')
  @DocsEditable
  void truncate(int size) native "FileWriterSync_truncate_Callback";

  @DomName('FileWriterSync.write')
  @DocsEditable
  void write(Blob data) native "FileWriterSync_write_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('Float32Array')
class Float32Array extends ArrayBufferView implements List<num> {
  Float32Array.internal() : super.internal();

  factory Float32Array(int length) =>
    _TypedArrayFactoryProvider.createFloat32Array(length);

  factory Float32Array.fromList(List<num> list) =>
    _TypedArrayFactoryProvider.createFloat32Array_fromList(list);

  factory Float32Array.fromBuffer(ArrayBuffer buffer, [int byteOffset, int length]) => 
    _TypedArrayFactoryProvider.createFloat32Array_fromBuffer(buffer, byteOffset, length);

  static const int BYTES_PER_ELEMENT = 4;

  @DomName('Float32Array.length')
  @DocsEditable
  int get length native "Float32Array_length_Getter";

  @DomName('Float32Array.numericIndexGetter')
  @DocsEditable
  num operator[](int index) native "Float32Array_numericIndexGetter_Callback";

  @DomName('Float32Array.numericIndexSetter')
  @DocsEditable
  void operator[]=(int index, num value) native "Float32Array_numericIndexSetter_Callback";
  // -- start List<num> mixins.
  // num is the element type.

  // From Iterable<num>:

  Iterator<num> get iterator {
    // Note: NodeLists are not fixed size. And most probably length shouldn't
    // be cached in both iterator _and_ forEach method. For now caching it
    // for consistency.
    return new FixedSizeListIterator<num>(this);
  }

  dynamic reduce(dynamic initialValue, dynamic combine(dynamic, num)) {
    return IterableMixinWorkaround.reduce(this, initialValue, combine);
  }

  bool contains(num element) => IterableMixinWorkaround.contains(this, element);

  void forEach(void f(num element)) => IterableMixinWorkaround.forEach(this, f);

  String join([String separator]) =>
      IterableMixinWorkaround.joinList(this, separator);

  List mappedBy(f(num element)) => IterableMixinWorkaround.mappedByList(this, f);

  Iterable<num> where(bool f(num element)) =>
      IterableMixinWorkaround.where(this, f);

  bool every(bool f(num element)) => IterableMixinWorkaround.every(this, f);

  bool any(bool f(num element)) => IterableMixinWorkaround.any(this, f);

  List<num> toList() => new List<num>.from(this);
  Set<num> toSet() => new Set<num>.from(this);

  bool get isEmpty => this.length == 0;

  List<num> take(int n) => IterableMixinWorkaround.takeList(this, n);

  Iterable<num> takeWhile(bool test(num value)) {
    return IterableMixinWorkaround.takeWhile(this, test);
  }

  List<num> skip(int n) => IterableMixinWorkaround.skipList(this, n);

  Iterable<num> skipWhile(bool test(num value)) {
    return IterableMixinWorkaround.skipWhile(this, test);
  }

  num firstMatching(bool test(num value), { num orElse() }) {
    return IterableMixinWorkaround.firstMatching(this, test, orElse);
  }

  num lastMatching(bool test(num value), {num orElse()}) {
    return IterableMixinWorkaround.lastMatchingInList(this, test, orElse);
  }

  num singleMatching(bool test(num value)) {
    return IterableMixinWorkaround.singleMatching(this, test);
  }

  num elementAt(int index) {
    return this[index];
  }

  // From Collection<num>:

  void add(num value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addLast(num value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addAll(Iterable<num> iterable) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  // From List<num>:
  void set length(int value) {
    throw new UnsupportedError("Cannot resize immutable List.");
  }

  void clear() {
    throw new UnsupportedError("Cannot clear immutable List.");
  }

  List<num> get reversed =>
      new ReversedListView<num>(this, 0, null);

  void sort([int compare(num a, num b)]) {
    throw new UnsupportedError("Cannot sort immutable List.");
  }

  int indexOf(num element, [int start = 0]) =>
      Lists.indexOf(this, element, start, this.length);

  int lastIndexOf(num element, [int start]) {
    if (start == null) start = length - 1;
    return Lists.lastIndexOf(this, element, start);
  }

  num get first {
    if (this.length > 0) return this[0];
    throw new StateError("No elements");
  }

  num get last {
    if (this.length > 0) return this[this.length - 1];
    throw new StateError("No elements");
  }

  num get single {
    if (length == 1) return this[0];
    if (length == 0) throw new StateError("No elements");
    throw new StateError("More than one element");
  }

  num min([int compare(num a, num b)]) =>
      IterableMixinWorkaround.min(this, compare);

  num max([int compare(num a, num b)]) =>
      IterableMixinWorkaround.max(this, compare);

  num removeAt(int pos) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  num removeLast() {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void remove(Object object) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void removeAll(Iterable elements) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void retainAll(Iterable elements) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void removeMatching(bool test(num element)) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void retainMatching(bool test(num element)) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void setRange(int start, int rangeLength, List<num> from, [int startFrom]) {
    throw new UnsupportedError("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int rangeLength) {
    throw new UnsupportedError("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int rangeLength, [num initialValue]) {
    throw new UnsupportedError("Cannot insertRange on immutable List.");
  }

  List<num> getRange(int start, int rangeLength) =>
      Lists.getRange(this, start, rangeLength, <num>[]);

  // -- end List<num> mixins.

  @DomName('Float32Array.setElements')
  @DocsEditable
  void setElements(Object array, [int offset]) native "Float32Array_setElements_Callback";

  Float32Array subarray(int start, [int end]) {
    if (?end) {
      return _subarray_1(start, end);
    }
    return _subarray_2(start);
  }

  @DomName('Float32Array._subarray_1')
  @DocsEditable
  Float32Array _subarray_1(start, end) native "Float32Array__subarray_1_Callback";

  @DomName('Float32Array._subarray_2')
  @DocsEditable
  Float32Array _subarray_2(start) native "Float32Array__subarray_2_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('Float64Array')
class Float64Array extends ArrayBufferView implements List<num> {
  Float64Array.internal() : super.internal();

  factory Float64Array(int length) =>
    _TypedArrayFactoryProvider.createFloat64Array(length);

  factory Float64Array.fromList(List<num> list) =>
    _TypedArrayFactoryProvider.createFloat64Array_fromList(list);

  factory Float64Array.fromBuffer(ArrayBuffer buffer, [int byteOffset, int length]) => 
    _TypedArrayFactoryProvider.createFloat64Array_fromBuffer(buffer, byteOffset, length);

  static const int BYTES_PER_ELEMENT = 8;

  @DomName('Float64Array.length')
  @DocsEditable
  int get length native "Float64Array_length_Getter";

  @DomName('Float64Array.numericIndexGetter')
  @DocsEditable
  num operator[](int index) native "Float64Array_numericIndexGetter_Callback";

  @DomName('Float64Array.numericIndexSetter')
  @DocsEditable
  void operator[]=(int index, num value) native "Float64Array_numericIndexSetter_Callback";
  // -- start List<num> mixins.
  // num is the element type.

  // From Iterable<num>:

  Iterator<num> get iterator {
    // Note: NodeLists are not fixed size. And most probably length shouldn't
    // be cached in both iterator _and_ forEach method. For now caching it
    // for consistency.
    return new FixedSizeListIterator<num>(this);
  }

  dynamic reduce(dynamic initialValue, dynamic combine(dynamic, num)) {
    return IterableMixinWorkaround.reduce(this, initialValue, combine);
  }

  bool contains(num element) => IterableMixinWorkaround.contains(this, element);

  void forEach(void f(num element)) => IterableMixinWorkaround.forEach(this, f);

  String join([String separator]) =>
      IterableMixinWorkaround.joinList(this, separator);

  List mappedBy(f(num element)) => IterableMixinWorkaround.mappedByList(this, f);

  Iterable<num> where(bool f(num element)) =>
      IterableMixinWorkaround.where(this, f);

  bool every(bool f(num element)) => IterableMixinWorkaround.every(this, f);

  bool any(bool f(num element)) => IterableMixinWorkaround.any(this, f);

  List<num> toList() => new List<num>.from(this);
  Set<num> toSet() => new Set<num>.from(this);

  bool get isEmpty => this.length == 0;

  List<num> take(int n) => IterableMixinWorkaround.takeList(this, n);

  Iterable<num> takeWhile(bool test(num value)) {
    return IterableMixinWorkaround.takeWhile(this, test);
  }

  List<num> skip(int n) => IterableMixinWorkaround.skipList(this, n);

  Iterable<num> skipWhile(bool test(num value)) {
    return IterableMixinWorkaround.skipWhile(this, test);
  }

  num firstMatching(bool test(num value), { num orElse() }) {
    return IterableMixinWorkaround.firstMatching(this, test, orElse);
  }

  num lastMatching(bool test(num value), {num orElse()}) {
    return IterableMixinWorkaround.lastMatchingInList(this, test, orElse);
  }

  num singleMatching(bool test(num value)) {
    return IterableMixinWorkaround.singleMatching(this, test);
  }

  num elementAt(int index) {
    return this[index];
  }

  // From Collection<num>:

  void add(num value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addLast(num value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addAll(Iterable<num> iterable) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  // From List<num>:
  void set length(int value) {
    throw new UnsupportedError("Cannot resize immutable List.");
  }

  void clear() {
    throw new UnsupportedError("Cannot clear immutable List.");
  }

  List<num> get reversed =>
      new ReversedListView<num>(this, 0, null);

  void sort([int compare(num a, num b)]) {
    throw new UnsupportedError("Cannot sort immutable List.");
  }

  int indexOf(num element, [int start = 0]) =>
      Lists.indexOf(this, element, start, this.length);

  int lastIndexOf(num element, [int start]) {
    if (start == null) start = length - 1;
    return Lists.lastIndexOf(this, element, start);
  }

  num get first {
    if (this.length > 0) return this[0];
    throw new StateError("No elements");
  }

  num get last {
    if (this.length > 0) return this[this.length - 1];
    throw new StateError("No elements");
  }

  num get single {
    if (length == 1) return this[0];
    if (length == 0) throw new StateError("No elements");
    throw new StateError("More than one element");
  }

  num min([int compare(num a, num b)]) =>
      IterableMixinWorkaround.min(this, compare);

  num max([int compare(num a, num b)]) =>
      IterableMixinWorkaround.max(this, compare);

  num removeAt(int pos) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  num removeLast() {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void remove(Object object) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void removeAll(Iterable elements) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void retainAll(Iterable elements) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void removeMatching(bool test(num element)) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void retainMatching(bool test(num element)) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void setRange(int start, int rangeLength, List<num> from, [int startFrom]) {
    throw new UnsupportedError("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int rangeLength) {
    throw new UnsupportedError("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int rangeLength, [num initialValue]) {
    throw new UnsupportedError("Cannot insertRange on immutable List.");
  }

  List<num> getRange(int start, int rangeLength) =>
      Lists.getRange(this, start, rangeLength, <num>[]);

  // -- end List<num> mixins.

  @DomName('Float64Array.setElements')
  @DocsEditable
  void setElements(Object array, [int offset]) native "Float64Array_setElements_Callback";

  Float64Array subarray(int start, [int end]) {
    if (?end) {
      return _subarray_1(start, end);
    }
    return _subarray_2(start);
  }

  @DomName('Float64Array._subarray_1')
  @DocsEditable
  Float64Array _subarray_1(start, end) native "Float64Array__subarray_1_Callback";

  @DomName('Float64Array._subarray_2')
  @DocsEditable
  Float64Array _subarray_2(start) native "Float64Array__subarray_2_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('FormData')
class FormData extends NativeFieldWrapperClass1 {
  FormData.internal();

  @DocsEditable
  factory FormData([FormElement form]) {
    if (!?form) {
      return FormData._create();
    }
    return FormData._create(form);
  }
  static FormData _create([FormElement form]) native "DOMFormData_constructor_Callback";

  @DomName('DOMFormData.append')
  @DocsEditable
  void append(String name, value, [String filename]) native "DOMFormData_append_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('HTMLFormElement')
class FormElement extends _Element_Merged {
  FormElement.internal() : super.internal();

  @DocsEditable
  factory FormElement() => document.$dom_createElement("form");

  @DomName('HTMLFormElement.acceptCharset')
  @DocsEditable
  String get acceptCharset native "HTMLFormElement_acceptCharset_Getter";

  @DomName('HTMLFormElement.acceptCharset')
  @DocsEditable
  void set acceptCharset(String value) native "HTMLFormElement_acceptCharset_Setter";

  @DomName('HTMLFormElement.action')
  @DocsEditable
  String get action native "HTMLFormElement_action_Getter";

  @DomName('HTMLFormElement.action')
  @DocsEditable
  void set action(String value) native "HTMLFormElement_action_Setter";

  @DomName('HTMLFormElement.autocomplete')
  @DocsEditable
  String get autocomplete native "HTMLFormElement_autocomplete_Getter";

  @DomName('HTMLFormElement.autocomplete')
  @DocsEditable
  void set autocomplete(String value) native "HTMLFormElement_autocomplete_Setter";

  @DomName('HTMLFormElement.encoding')
  @DocsEditable
  String get encoding native "HTMLFormElement_encoding_Getter";

  @DomName('HTMLFormElement.encoding')
  @DocsEditable
  void set encoding(String value) native "HTMLFormElement_encoding_Setter";

  @DomName('HTMLFormElement.enctype')
  @DocsEditable
  String get enctype native "HTMLFormElement_enctype_Getter";

  @DomName('HTMLFormElement.enctype')
  @DocsEditable
  void set enctype(String value) native "HTMLFormElement_enctype_Setter";

  @DomName('HTMLFormElement.length')
  @DocsEditable
  int get length native "HTMLFormElement_length_Getter";

  @DomName('HTMLFormElement.method')
  @DocsEditable
  String get method native "HTMLFormElement_method_Getter";

  @DomName('HTMLFormElement.method')
  @DocsEditable
  void set method(String value) native "HTMLFormElement_method_Setter";

  @DomName('HTMLFormElement.name')
  @DocsEditable
  String get name native "HTMLFormElement_name_Getter";

  @DomName('HTMLFormElement.name')
  @DocsEditable
  void set name(String value) native "HTMLFormElement_name_Setter";

  @DomName('HTMLFormElement.noValidate')
  @DocsEditable
  bool get noValidate native "HTMLFormElement_noValidate_Getter";

  @DomName('HTMLFormElement.noValidate')
  @DocsEditable
  void set noValidate(bool value) native "HTMLFormElement_noValidate_Setter";

  @DomName('HTMLFormElement.target')
  @DocsEditable
  String get target native "HTMLFormElement_target_Getter";

  @DomName('HTMLFormElement.target')
  @DocsEditable
  void set target(String value) native "HTMLFormElement_target_Setter";

  @DomName('HTMLFormElement.checkValidity')
  @DocsEditable
  bool checkValidity() native "HTMLFormElement_checkValidity_Callback";

  @DomName('HTMLFormElement.reset')
  @DocsEditable
  void reset() native "HTMLFormElement_reset_Callback";

  @DomName('HTMLFormElement.submit')
  @DocsEditable
  void submit() native "HTMLFormElement_submit_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('Gamepad')
class Gamepad extends NativeFieldWrapperClass1 {
  Gamepad.internal();

  @DomName('Gamepad.axes')
  @DocsEditable
  List<num> get axes native "Gamepad_axes_Getter";

  @DomName('Gamepad.buttons')
  @DocsEditable
  List<num> get buttons native "Gamepad_buttons_Getter";

  @DomName('Gamepad.id')
  @DocsEditable
  String get id native "Gamepad_id_Getter";

  @DomName('Gamepad.index')
  @DocsEditable
  int get index native "Gamepad_index_Getter";

  @DomName('Gamepad.timestamp')
  @DocsEditable
  int get timestamp native "Gamepad_timestamp_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('Geolocation')
class Geolocation extends NativeFieldWrapperClass1 {
  Geolocation.internal();

  @DomName('Geolocation.clearWatch')
  @DocsEditable
  void clearWatch(int watchId) native "Geolocation_clearWatch_Callback";

  @DomName('Geolocation.getCurrentPosition')
  @DocsEditable
  void getCurrentPosition(PositionCallback successCallback, [PositionErrorCallback errorCallback, Object options]) native "Geolocation_getCurrentPosition_Callback";

  @DomName('Geolocation.watchPosition')
  @DocsEditable
  int watchPosition(PositionCallback successCallback, [PositionErrorCallback errorCallback, Object options]) native "Geolocation_watchPosition_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('Geoposition')
class Geoposition extends NativeFieldWrapperClass1 {
  Geoposition.internal();

  @DomName('Geoposition.coords')
  @DocsEditable
  Coordinates get coords native "Geoposition_coords_Getter";

  @DomName('Geoposition.timestamp')
  @DocsEditable
  int get timestamp native "Geoposition_timestamp_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('HTMLHRElement')
class HRElement extends _Element_Merged {
  HRElement.internal() : super.internal();

  @DocsEditable
  factory HRElement() => document.$dom_createElement("hr");

}
// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

@DomName('HashChangeEvent')
@SupportedBrowser(SupportedBrowser.CHROME)
@SupportedBrowser(SupportedBrowser.FIREFOX)
@SupportedBrowser(SupportedBrowser.SAFARI)

class HashChangeEvent extends Event {
  factory HashChangeEvent(String type,
      {bool canBubble: true, bool cancelable: true, String oldUrl,
      String newUrl}) {
    var event = document.$dom_createEvent("HashChangeEvent");
    event.$dom_initHashChangeEvent(type, canBubble, cancelable, oldUrl, newUrl);
    return event;
  }
  HashChangeEvent.internal() : super.internal();

  /// Checks if this type is supported on the current platform.
  static bool get supported => true;

  @DomName('HashChangeEvent.newURL')
  @DocsEditable
  String get newUrl native "HashChangeEvent_newURL_Getter";

  @DomName('HashChangeEvent.oldURL')
  @DocsEditable
  String get oldUrl native "HashChangeEvent_oldURL_Getter";

  @DomName('HashChangeEvent.initHashChangeEvent')
  @DocsEditable
  void $dom_initHashChangeEvent(String type, bool canBubble, bool cancelable, String oldURL, String newURL) native "HashChangeEvent_initHashChangeEvent_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('HTMLHeadElement')
class HeadElement extends _Element_Merged {
  HeadElement.internal() : super.internal();

  @DocsEditable
  factory HeadElement() => document.$dom_createElement("head");

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('HTMLHeadingElement')
class HeadingElement extends _Element_Merged {
  HeadingElement.internal() : super.internal();

  @DocsEditable
  factory HeadingElement.h1() => document.$dom_createElement("h1");

  @DocsEditable
  factory HeadingElement.h2() => document.$dom_createElement("h2");

  @DocsEditable
  factory HeadingElement.h3() => document.$dom_createElement("h3");

  @DocsEditable
  factory HeadingElement.h4() => document.$dom_createElement("h4");

  @DocsEditable
  factory HeadingElement.h5() => document.$dom_createElement("h5");

  @DocsEditable
  factory HeadingElement.h6() => document.$dom_createElement("h6");

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.


@DomName('History')
class History extends NativeFieldWrapperClass1 implements HistoryBase {

  /**
   * Checks if the State APIs are supported on the current platform.
   *
   * See also:
   *
   * * [pushState]
   * * [replaceState]
   * * [state]
   */
  static bool get supportsState => true;
  History.internal();

  @DomName('History.length')
  @DocsEditable
  int get length native "History_length_Getter";

  @DomName('History.state')
  @DocsEditable
  dynamic get state native "History_state_Getter";

  @DomName('History.back')
  @DocsEditable
  void back() native "History_back_Callback";

  @DomName('History.forward')
  @DocsEditable
  void forward() native "History_forward_Callback";

  @DomName('History.go')
  @DocsEditable
  void go(int distance) native "History_go_Callback";

  @DomName('History.pushState')
  @DocsEditable
  @SupportedBrowser(SupportedBrowser.CHROME)
  @SupportedBrowser(SupportedBrowser.FIREFOX)
  @SupportedBrowser(SupportedBrowser.IE, '10')
  @SupportedBrowser(SupportedBrowser.SAFARI)
  void pushState(Object data, String title, [String url]) native "History_pushState_Callback";

  @DomName('History.replaceState')
  @DocsEditable
  @SupportedBrowser(SupportedBrowser.CHROME)
  @SupportedBrowser(SupportedBrowser.FIREFOX)
  @SupportedBrowser(SupportedBrowser.IE, '10')
  @SupportedBrowser(SupportedBrowser.SAFARI)
  void replaceState(Object data, String title, [String url]) native "History_replaceState_Callback";
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('HTMLAllCollection')
class HtmlAllCollection extends NativeFieldWrapperClass1 implements List<Node> {
  HtmlAllCollection.internal();

  @DomName('HTMLAllCollection.length')
  @DocsEditable
  int get length native "HTMLAllCollection_length_Getter";

  Node operator[](int index) native "HTMLAllCollection_item_Callback";

  void operator[]=(int index, Node value) {
    throw new UnsupportedError("Cannot assign element of immutable List.");
  }
  // -- start List<Node> mixins.
  // Node is the element type.

  // From Iterable<Node>:

  Iterator<Node> get iterator {
    // Note: NodeLists are not fixed size. And most probably length shouldn't
    // be cached in both iterator _and_ forEach method. For now caching it
    // for consistency.
    return new FixedSizeListIterator<Node>(this);
  }

  dynamic reduce(dynamic initialValue, dynamic combine(dynamic, Node)) {
    return IterableMixinWorkaround.reduce(this, initialValue, combine);
  }

  bool contains(Node element) => IterableMixinWorkaround.contains(this, element);

  void forEach(void f(Node element)) => IterableMixinWorkaround.forEach(this, f);

  String join([String separator]) =>
      IterableMixinWorkaround.joinList(this, separator);

  List mappedBy(f(Node element)) => IterableMixinWorkaround.mappedByList(this, f);

  Iterable<Node> where(bool f(Node element)) =>
      IterableMixinWorkaround.where(this, f);

  bool every(bool f(Node element)) => IterableMixinWorkaround.every(this, f);

  bool any(bool f(Node element)) => IterableMixinWorkaround.any(this, f);

  List<Node> toList() => new List<Node>.from(this);
  Set<Node> toSet() => new Set<Node>.from(this);

  bool get isEmpty => this.length == 0;

  List<Node> take(int n) => IterableMixinWorkaround.takeList(this, n);

  Iterable<Node> takeWhile(bool test(Node value)) {
    return IterableMixinWorkaround.takeWhile(this, test);
  }

  List<Node> skip(int n) => IterableMixinWorkaround.skipList(this, n);

  Iterable<Node> skipWhile(bool test(Node value)) {
    return IterableMixinWorkaround.skipWhile(this, test);
  }

  Node firstMatching(bool test(Node value), { Node orElse() }) {
    return IterableMixinWorkaround.firstMatching(this, test, orElse);
  }

  Node lastMatching(bool test(Node value), {Node orElse()}) {
    return IterableMixinWorkaround.lastMatchingInList(this, test, orElse);
  }

  Node singleMatching(bool test(Node value)) {
    return IterableMixinWorkaround.singleMatching(this, test);
  }

  Node elementAt(int index) {
    return this[index];
  }

  // From Collection<Node>:

  void add(Node value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addLast(Node value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addAll(Iterable<Node> iterable) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  // From List<Node>:
  void set length(int value) {
    throw new UnsupportedError("Cannot resize immutable List.");
  }

  void clear() {
    throw new UnsupportedError("Cannot clear immutable List.");
  }

  List<Node> get reversed =>
      new ReversedListView<Node>(this, 0, null);

  void sort([int compare(Node a, Node b)]) {
    throw new UnsupportedError("Cannot sort immutable List.");
  }

  int indexOf(Node element, [int start = 0]) =>
      Lists.indexOf(this, element, start, this.length);

  int lastIndexOf(Node element, [int start]) {
    if (start == null) start = length - 1;
    return Lists.lastIndexOf(this, element, start);
  }

  Node get first {
    if (this.length > 0) return this[0];
    throw new StateError("No elements");
  }

  Node get last {
    if (this.length > 0) return this[this.length - 1];
    throw new StateError("No elements");
  }

  Node get single {
    if (length == 1) return this[0];
    if (length == 0) throw new StateError("No elements");
    throw new StateError("More than one element");
  }

  Node min([int compare(Node a, Node b)]) =>
      IterableMixinWorkaround.min(this, compare);

  Node max([int compare(Node a, Node b)]) =>
      IterableMixinWorkaround.max(this, compare);

  Node removeAt(int pos) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  Node removeLast() {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void remove(Object object) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void removeAll(Iterable elements) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void retainAll(Iterable elements) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void removeMatching(bool test(Node element)) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void retainMatching(bool test(Node element)) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void setRange(int start, int rangeLength, List<Node> from, [int startFrom]) {
    throw new UnsupportedError("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int rangeLength) {
    throw new UnsupportedError("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int rangeLength, [Node initialValue]) {
    throw new UnsupportedError("Cannot insertRange on immutable List.");
  }

  List<Node> getRange(int start, int rangeLength) =>
      Lists.getRange(this, start, rangeLength, <Node>[]);

  // -- end List<Node> mixins.

  @DomName('HTMLAllCollection.item')
  @DocsEditable
  Node item(int index) native "HTMLAllCollection_item_Callback";

  @DomName('HTMLAllCollection.namedItem')
  @DocsEditable
  Node namedItem(String name) native "HTMLAllCollection_namedItem_Callback";

  @DomName('HTMLAllCollection.tags')
  @DocsEditable
  List<Node> tags(String name) native "HTMLAllCollection_tags_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('HTMLCollection')
class HtmlCollection extends NativeFieldWrapperClass1 implements List<Node> {
  HtmlCollection.internal();

  @DomName('HTMLCollection.length')
  @DocsEditable
  int get length native "HTMLCollection_length_Getter";

  Node operator[](int index) native "HTMLCollection_item_Callback";

  void operator[]=(int index, Node value) {
    throw new UnsupportedError("Cannot assign element of immutable List.");
  }
  // -- start List<Node> mixins.
  // Node is the element type.

  // From Iterable<Node>:

  Iterator<Node> get iterator {
    // Note: NodeLists are not fixed size. And most probably length shouldn't
    // be cached in both iterator _and_ forEach method. For now caching it
    // for consistency.
    return new FixedSizeListIterator<Node>(this);
  }

  dynamic reduce(dynamic initialValue, dynamic combine(dynamic, Node)) {
    return IterableMixinWorkaround.reduce(this, initialValue, combine);
  }

  bool contains(Node element) => IterableMixinWorkaround.contains(this, element);

  void forEach(void f(Node element)) => IterableMixinWorkaround.forEach(this, f);

  String join([String separator]) =>
      IterableMixinWorkaround.joinList(this, separator);

  List mappedBy(f(Node element)) => IterableMixinWorkaround.mappedByList(this, f);

  Iterable<Node> where(bool f(Node element)) =>
      IterableMixinWorkaround.where(this, f);

  bool every(bool f(Node element)) => IterableMixinWorkaround.every(this, f);

  bool any(bool f(Node element)) => IterableMixinWorkaround.any(this, f);

  List<Node> toList() => new List<Node>.from(this);
  Set<Node> toSet() => new Set<Node>.from(this);

  bool get isEmpty => this.length == 0;

  List<Node> take(int n) => IterableMixinWorkaround.takeList(this, n);

  Iterable<Node> takeWhile(bool test(Node value)) {
    return IterableMixinWorkaround.takeWhile(this, test);
  }

  List<Node> skip(int n) => IterableMixinWorkaround.skipList(this, n);

  Iterable<Node> skipWhile(bool test(Node value)) {
    return IterableMixinWorkaround.skipWhile(this, test);
  }

  Node firstMatching(bool test(Node value), { Node orElse() }) {
    return IterableMixinWorkaround.firstMatching(this, test, orElse);
  }

  Node lastMatching(bool test(Node value), {Node orElse()}) {
    return IterableMixinWorkaround.lastMatchingInList(this, test, orElse);
  }

  Node singleMatching(bool test(Node value)) {
    return IterableMixinWorkaround.singleMatching(this, test);
  }

  Node elementAt(int index) {
    return this[index];
  }

  // From Collection<Node>:

  void add(Node value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addLast(Node value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addAll(Iterable<Node> iterable) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  // From List<Node>:
  void set length(int value) {
    throw new UnsupportedError("Cannot resize immutable List.");
  }

  void clear() {
    throw new UnsupportedError("Cannot clear immutable List.");
  }

  List<Node> get reversed =>
      new ReversedListView<Node>(this, 0, null);

  void sort([int compare(Node a, Node b)]) {
    throw new UnsupportedError("Cannot sort immutable List.");
  }

  int indexOf(Node element, [int start = 0]) =>
      Lists.indexOf(this, element, start, this.length);

  int lastIndexOf(Node element, [int start]) {
    if (start == null) start = length - 1;
    return Lists.lastIndexOf(this, element, start);
  }

  Node get first {
    if (this.length > 0) return this[0];
    throw new StateError("No elements");
  }

  Node get last {
    if (this.length > 0) return this[this.length - 1];
    throw new StateError("No elements");
  }

  Node get single {
    if (length == 1) return this[0];
    if (length == 0) throw new StateError("No elements");
    throw new StateError("More than one element");
  }

  Node min([int compare(Node a, Node b)]) =>
      IterableMixinWorkaround.min(this, compare);

  Node max([int compare(Node a, Node b)]) =>
      IterableMixinWorkaround.max(this, compare);

  Node removeAt(int pos) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  Node removeLast() {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void remove(Object object) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void removeAll(Iterable elements) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void retainAll(Iterable elements) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void removeMatching(bool test(Node element)) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void retainMatching(bool test(Node element)) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void setRange(int start, int rangeLength, List<Node> from, [int startFrom]) {
    throw new UnsupportedError("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int rangeLength) {
    throw new UnsupportedError("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int rangeLength, [Node initialValue]) {
    throw new UnsupportedError("Cannot insertRange on immutable List.");
  }

  List<Node> getRange(int start, int rangeLength) =>
      Lists.getRange(this, start, rangeLength, <Node>[]);

  // -- end List<Node> mixins.

  @DomName('HTMLCollection.item')
  @DocsEditable
  Node item(int index) native "HTMLCollection_item_Callback";

  @DomName('HTMLCollection.namedItem')
  @DocsEditable
  Node namedItem(String name) native "HTMLCollection_namedItem_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DomName('HTMLDocument')
class HtmlDocument extends Document {
  HtmlDocument.internal() : super.internal();

  @DomName('HTMLDocument.activeElement')
  @DocsEditable
  Element get activeElement native "HTMLDocument_activeElement_Getter";

  @DomName('Document.body')
  BodyElement get body => document.$dom_body;

  @DomName('Document.body')
  void set body(BodyElement value) {
    document.$dom_body = value;
  }

  @DomName('Document.caretRangeFromPoint')
  Range caretRangeFromPoint(int x, int y) {
    return document.$dom_caretRangeFromPoint(x, y);
  }

  @DomName('Document.elementFromPoint')
  Element elementFromPoint(int x, int y) {
    return document.$dom_elementFromPoint(x, y);
  }

  /**
   * Checks if the getCssCanvasContext API is supported on the current platform.
   *
   * See also:
   *
   * * [getCssCanvasContext]
   */
  static bool get supportsCssCanvasContext => true;


  /**
   * Gets a CanvasRenderingContext which can be used as the CSS background of an
   * element.
   *
   * CSS:
   *
   *     background: -webkit-canvas(backgroundCanvas)
   *
   * Generate the canvas:
   *
   *     var context = document.getCssCanvasContext('2d', 'backgroundCanvas',
   *         100, 100);
   *     context.fillStyle = 'red';
   *     context.fillRect(0, 0, 100, 100);
   *
   * See also:
   *
   * * [supportsCssCanvasContext]
   * * [CanvasElement.getContext]
   */
  @SupportedBrowser(SupportedBrowser.CHROME)
  @SupportedBrowser(SupportedBrowser.SAFARI)
  @Experimental
  @DomName('Document.getCSSCanvasContext')
  CanvasRenderingContext getCssCanvasContext(String contextId, String name,
      int width, int height) {
    return document.$dom_getCssCanvasContext(contextId, name, width, height);
  }

  @DomName('Document.head')
  HeadElement get head => document.$dom_head;

  @DomName('Document.lastModified')
  String get lastModified => document.$dom_lastModified;

  @DomName('Document.preferredStylesheetSet')
  String get preferredStylesheetSet => document.$dom_preferredStylesheetSet;

  @DomName('Document.referrer')
  String get referrer => document.$dom_referrer;

  @DomName('Document.selectedStylesheetSet')
  String get selectedStylesheetSet => document.$dom_selectedStylesheetSet;
  void set selectedStylesheetSet(String value) {
    document.$dom_selectedStylesheetSet = value;
  }

  @DomName('Document.styleSheets')
  List<StyleSheet> get styleSheets => document.$dom_styleSheets;

  @DomName('Document.title')
  String get title => document.$dom_title;

  @DomName('Document.title')
  void set title(String value) {
    document.$dom_title = value;
  }

  @DomName('Document.webkitCancelFullScreen')
  void webkitCancelFullScreen() {
    document.$dom_webkitCancelFullScreen();
  }

  @DomName('Document.webkitExitFullscreen')
  void webkitExitFullscreen() {
    document.$dom_webkitExitFullscreen();
  }

  @DomName('Document.webkitExitPointerLock')
  void webkitExitPointerLock() {
    document.$dom_webkitExitPointerLock();
  }

  @DomName('Document.webkitFullscreenElement')
  Element get webkitFullscreenElement => document.$dom_webkitFullscreenElement;

  @DomName('Document.webkitFullscreenEnabled')
  bool get webkitFullscreenEnabled => document.$dom_webkitFullscreenEnabled;

  @DomName('Document.webkitHidden')
  bool get webkitHidden => document.$dom_webkitHidden;

  @DomName('Document.webkitIsFullScreen')
  bool get webkitIsFullScreen => document.$dom_webkitIsFullScreen;

  @DomName('Document.webkitPointerLockElement')
  Element get webkitPointerLockElement =>
      document.$dom_webkitPointerLockElement;

  @DomName('Document.webkitVisibilityState')
  String get webkitVisibilityState => document.$dom_webkitVisibilityState;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('HTMLHtmlElement')
class HtmlElement extends _Element_Merged {
  HtmlElement.internal() : super.internal();

  @DocsEditable
  factory HtmlElement() => document.$dom_createElement("html");

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('HTMLFormControlsCollection')
class HtmlFormControlsCollection extends HtmlCollection {
  HtmlFormControlsCollection.internal() : super.internal();

  @DomName('HTMLFormControlsCollection.namedItem')
  @DocsEditable
  Node namedItem(String name) native "HTMLFormControlsCollection_namedItem_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('HTMLOptionsCollection')
class HtmlOptionsCollection extends HtmlCollection {
  HtmlOptionsCollection.internal() : super.internal();

  @DomName('HTMLOptionsCollection.numericIndexSetter')
  @DocsEditable
  void operator[]=(int index, Node value) native "HTMLOptionsCollection_numericIndexSetter_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.


/**
 * A utility for retrieving data from a URL.
 *
 * HttpRequest can be used to obtain data from http, ftp, and file
 * protocols.
 *
 * For example, suppose we're developing these API docs, and we
 * wish to retrieve the HTML of the top-level page and print it out.
 * The easiest way to do that would be:
 *
 *     var httpRequest = HttpRequest.get('http://api.dartlang.org',
 *         (request) => print(request.responseText));
 *
 * **Important**: With the default behavior of this class, your
 * code making the request should be served from the same origin (domain name,
 * port, and application layer protocol) as the URL you are trying to access
 * with HttpRequest. However, there are ways to
 * [get around this restriction](http://www.dartlang.org/articles/json-web-service/#note-on-jsonp).
 *
 * See also:
 *
 * * [Dart article on using HttpRequests](http://www.dartlang.org/articles/json-web-service/#getting-data)
 * * [JS XMLHttpRequest](https://developer.mozilla.org/en-US/docs/DOM/XMLHttpRequest)
 * * [Using XMLHttpRequest](https://developer.mozilla.org/en-US/docs/DOM/XMLHttpRequest/Using_XMLHttpRequest)
 */
@DomName('XMLHttpRequest')
class HttpRequest extends EventTarget {
  /**
   * Creates a URL get request for the specified `url`.
   *
   * After completing the request, the object will call the user-provided
   * [onComplete] callback.
   */
  factory HttpRequest.get(String url, onComplete(HttpRequest request)) =>
      _HttpRequestUtils.get(url, onComplete, false);

  // 80 char issue for comments in lists: dartbug.com/7588.
  /**
   * Creates a URL GET request for the specified `url` with
   * credentials such a cookie (already) set in the header or
   * [authorization headers](http://tools.ietf.org/html/rfc1945#section-10.2).
   *
   * After completing the request, the object will call the user-provided
   * [onComplete] callback.
   *
   * A few other details to keep in mind when using credentials:
   *
   * * Using credentials is only useful for cross-origin requests.
   * * The `Access-Control-Allow-Origin` header of `url` cannot contain a wildcard (*).
   * * The `Access-Control-Allow-Credentials` header of `url` must be set to true.
   * * If `Access-Control-Expose-Headers` has not been set to true, only a subset of all the response headers will be returned when calling [getAllRequestHeaders].
   *
   * See also: [authorization headers](http://en.wikipedia.org/wiki/Basic_access_authentication).
   */
  factory HttpRequest.getWithCredentials(String url,
      onComplete(HttpRequest request)) =>
      _HttpRequestUtils.get(url, onComplete, true);

  HttpRequest.internal() : super.internal();

  @DomName('XMLHttpRequest.abort')
  @DocsEditable
  static const EventStreamProvider<ProgressEvent> abortEvent = const EventStreamProvider<ProgressEvent>('abort');

  @DomName('XMLHttpRequest.error')
  @DocsEditable
  static const EventStreamProvider<ProgressEvent> errorEvent = const EventStreamProvider<ProgressEvent>('error');

  @DomName('XMLHttpRequest.load')
  @DocsEditable
  static const EventStreamProvider<ProgressEvent> loadEvent = const EventStreamProvider<ProgressEvent>('load');

  @DomName('XMLHttpRequest.loadend')
  @DocsEditable
  static const EventStreamProvider<ProgressEvent> loadEndEvent = const EventStreamProvider<ProgressEvent>('loadend');

  @DomName('XMLHttpRequest.loadstart')
  @DocsEditable
  static const EventStreamProvider<ProgressEvent> loadStartEvent = const EventStreamProvider<ProgressEvent>('loadstart');

  @DomName('XMLHttpRequest.progress')
  @DocsEditable
  static const EventStreamProvider<ProgressEvent> progressEvent = const EventStreamProvider<ProgressEvent>('progress');

  @DomName('XMLHttpRequest.readystatechange')
  @DocsEditable
  static const EventStreamProvider<ProgressEvent> readyStateChangeEvent = const EventStreamProvider<ProgressEvent>('readystatechange');

  @DocsEditable
  factory HttpRequest() => HttpRequest._create();
  static HttpRequest _create() native "XMLHttpRequest_constructor_Callback";

  @DocsEditable
  @DomName('EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent')
  @deprecated
  HttpRequestEvents get on =>
    new HttpRequestEvents(this);

  static const int DONE = 4;

  static const int HEADERS_RECEIVED = 2;

  static const int LOADING = 3;

  static const int OPENED = 1;

  static const int UNSENT = 0;

  @DomName('XMLHttpRequest.readyState')
  @DocsEditable
  int get readyState native "XMLHttpRequest_readyState_Getter";

  @DomName('XMLHttpRequest.response')
  @DocsEditable
  Object get response native "XMLHttpRequest_response_Getter";

  @DomName('XMLHttpRequest.responseText')
  @DocsEditable
  String get responseText native "XMLHttpRequest_responseText_Getter";

  @DomName('XMLHttpRequest.responseType')
  @DocsEditable
  String get responseType native "XMLHttpRequest_responseType_Getter";

  @DomName('XMLHttpRequest.responseType')
  @DocsEditable
  void set responseType(String value) native "XMLHttpRequest_responseType_Setter";

  @DomName('XMLHttpRequest.responseXML')
  @DocsEditable
  Document get responseXml native "XMLHttpRequest_responseXML_Getter";

  @DomName('XMLHttpRequest.status')
  @DocsEditable
  int get status native "XMLHttpRequest_status_Getter";

  @DomName('XMLHttpRequest.statusText')
  @DocsEditable
  String get statusText native "XMLHttpRequest_statusText_Getter";

  @DomName('XMLHttpRequest.upload')
  @DocsEditable
  HttpRequestUpload get upload native "XMLHttpRequest_upload_Getter";

  @DomName('XMLHttpRequest.withCredentials')
  @DocsEditable
  bool get withCredentials native "XMLHttpRequest_withCredentials_Getter";

  @DomName('XMLHttpRequest.withCredentials')
  @DocsEditable
  void set withCredentials(bool value) native "XMLHttpRequest_withCredentials_Setter";

  @DomName('XMLHttpRequest.abort')
  @DocsEditable
  void abort() native "XMLHttpRequest_abort_Callback";

  @DomName('XMLHttpRequest.addEventListener')
  @DocsEditable
  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]) native "XMLHttpRequest_addEventListener_Callback";

  @DomName('XMLHttpRequest.dispatchEvent')
  @DocsEditable
  bool dispatchEvent(Event evt) native "XMLHttpRequest_dispatchEvent_Callback";

  @DomName('XMLHttpRequest.getAllResponseHeaders')
  @DocsEditable
  String getAllResponseHeaders() native "XMLHttpRequest_getAllResponseHeaders_Callback";

  @DomName('XMLHttpRequest.getResponseHeader')
  @DocsEditable
  String getResponseHeader(String header) native "XMLHttpRequest_getResponseHeader_Callback";

  @DomName('XMLHttpRequest.open')
  @DocsEditable
  void open(String method, String url, [bool async, String user, String password]) native "XMLHttpRequest_open_Callback";

  @DomName('XMLHttpRequest.overrideMimeType')
  @DocsEditable
  void overrideMimeType(String override) native "XMLHttpRequest_overrideMimeType_Callback";

  @DomName('XMLHttpRequest.removeEventListener')
  @DocsEditable
  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]) native "XMLHttpRequest_removeEventListener_Callback";

  @DomName('XMLHttpRequest.send')
  @DocsEditable
  void send([data]) native "XMLHttpRequest_send_Callback";

  @DomName('XMLHttpRequest.setRequestHeader')
  @DocsEditable
  void setRequestHeader(String header, String value) native "XMLHttpRequest_setRequestHeader_Callback";

  @DomName('XMLHttpRequest.abort')
  @DocsEditable
  Stream<ProgressEvent> get onAbort => abortEvent.forTarget(this);

  @DomName('XMLHttpRequest.error')
  @DocsEditable
  Stream<ProgressEvent> get onError => errorEvent.forTarget(this);

  @DomName('XMLHttpRequest.load')
  @DocsEditable
  Stream<ProgressEvent> get onLoad => loadEvent.forTarget(this);

  @DomName('XMLHttpRequest.loadend')
  @DocsEditable
  Stream<ProgressEvent> get onLoadEnd => loadEndEvent.forTarget(this);

  @DomName('XMLHttpRequest.loadstart')
  @DocsEditable
  Stream<ProgressEvent> get onLoadStart => loadStartEvent.forTarget(this);

  @DomName('XMLHttpRequest.progress')
  @DocsEditable
  Stream<ProgressEvent> get onProgress => progressEvent.forTarget(this);

  @DomName('XMLHttpRequest.readystatechange')
  @DocsEditable
  Stream<ProgressEvent> get onReadyStateChange => readyStateChangeEvent.forTarget(this);

}

@DocsEditable
@deprecated
class HttpRequestEvents extends Events {
  @DocsEditable
  HttpRequestEvents(EventTarget _ptr) : super(_ptr);

  @DocsEditable
  EventListenerList get abort => this['abort'];

  @DocsEditable
  EventListenerList get error => this['error'];

  @DocsEditable
  EventListenerList get load => this['load'];

  @DocsEditable
  EventListenerList get loadEnd => this['loadend'];

  @DocsEditable
  EventListenerList get loadStart => this['loadstart'];

  @DocsEditable
  EventListenerList get progress => this['progress'];

  @DocsEditable
  EventListenerList get readyStateChange => this['readystatechange'];
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('XMLHttpRequestException')
class HttpRequestException extends NativeFieldWrapperClass1 {
  HttpRequestException.internal();

  static const int ABORT_ERR = 102;

  static const int NETWORK_ERR = 101;

  @DomName('XMLHttpRequestException.code')
  @DocsEditable
  int get code native "XMLHttpRequestException_code_Getter";

  @DomName('XMLHttpRequestException.message')
  @DocsEditable
  String get message native "XMLHttpRequestException_message_Getter";

  @DomName('XMLHttpRequestException.name')
  @DocsEditable
  String get name native "XMLHttpRequestException_name_Getter";

  @DomName('XMLHttpRequestException.toString')
  @DocsEditable
  String toString() native "XMLHttpRequestException_toString_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('XMLHttpRequestProgressEvent')
@SupportedBrowser(SupportedBrowser.CHROME)
@SupportedBrowser(SupportedBrowser.SAFARI)
@Experimental
class HttpRequestProgressEvent extends ProgressEvent {
  HttpRequestProgressEvent.internal() : super.internal();

  /// Checks if this type is supported on the current platform.
  static bool get supported => true;

  @DomName('XMLHttpRequestProgressEvent.position')
  @DocsEditable
  int get position native "XMLHttpRequestProgressEvent_position_Getter";

  @DomName('XMLHttpRequestProgressEvent.totalSize')
  @DocsEditable
  int get totalSize native "XMLHttpRequestProgressEvent_totalSize_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('XMLHttpRequestUpload')
class HttpRequestUpload extends EventTarget {
  HttpRequestUpload.internal() : super.internal();

  @DomName('XMLHttpRequestUpload.abort')
  @DocsEditable
  static const EventStreamProvider<ProgressEvent> abortEvent = const EventStreamProvider<ProgressEvent>('abort');

  @DomName('XMLHttpRequestUpload.error')
  @DocsEditable
  static const EventStreamProvider<ProgressEvent> errorEvent = const EventStreamProvider<ProgressEvent>('error');

  @DomName('XMLHttpRequestUpload.load')
  @DocsEditable
  static const EventStreamProvider<ProgressEvent> loadEvent = const EventStreamProvider<ProgressEvent>('load');

  @DomName('XMLHttpRequestUpload.loadend')
  @DocsEditable
  static const EventStreamProvider<ProgressEvent> loadEndEvent = const EventStreamProvider<ProgressEvent>('loadend');

  @DomName('XMLHttpRequestUpload.loadstart')
  @DocsEditable
  static const EventStreamProvider<ProgressEvent> loadStartEvent = const EventStreamProvider<ProgressEvent>('loadstart');

  @DomName('XMLHttpRequestUpload.progress')
  @DocsEditable
  static const EventStreamProvider<ProgressEvent> progressEvent = const EventStreamProvider<ProgressEvent>('progress');

  @DocsEditable
  @DomName('EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent')
  @deprecated
  HttpRequestUploadEvents get on =>
    new HttpRequestUploadEvents(this);

  @DomName('XMLHttpRequestUpload.addEventListener')
  @DocsEditable
  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]) native "XMLHttpRequestUpload_addEventListener_Callback";

  @DomName('XMLHttpRequestUpload.dispatchEvent')
  @DocsEditable
  bool dispatchEvent(Event evt) native "XMLHttpRequestUpload_dispatchEvent_Callback";

  @DomName('XMLHttpRequestUpload.removeEventListener')
  @DocsEditable
  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]) native "XMLHttpRequestUpload_removeEventListener_Callback";

  @DomName('XMLHttpRequestUpload.abort')
  @DocsEditable
  Stream<ProgressEvent> get onAbort => abortEvent.forTarget(this);

  @DomName('XMLHttpRequestUpload.error')
  @DocsEditable
  Stream<ProgressEvent> get onError => errorEvent.forTarget(this);

  @DomName('XMLHttpRequestUpload.load')
  @DocsEditable
  Stream<ProgressEvent> get onLoad => loadEvent.forTarget(this);

  @DomName('XMLHttpRequestUpload.loadend')
  @DocsEditable
  Stream<ProgressEvent> get onLoadEnd => loadEndEvent.forTarget(this);

  @DomName('XMLHttpRequestUpload.loadstart')
  @DocsEditable
  Stream<ProgressEvent> get onLoadStart => loadStartEvent.forTarget(this);

  @DomName('XMLHttpRequestUpload.progress')
  @DocsEditable
  Stream<ProgressEvent> get onProgress => progressEvent.forTarget(this);

}

@DocsEditable
@deprecated
class HttpRequestUploadEvents extends Events {
  @DocsEditable
  HttpRequestUploadEvents(EventTarget _ptr) : super(_ptr);

  @DocsEditable
  EventListenerList get abort => this['abort'];

  @DocsEditable
  EventListenerList get error => this['error'];

  @DocsEditable
  EventListenerList get load => this['load'];

  @DocsEditable
  EventListenerList get loadEnd => this['loadend'];

  @DocsEditable
  EventListenerList get loadStart => this['loadstart'];

  @DocsEditable
  EventListenerList get progress => this['progress'];
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('HTMLIFrameElement')
class IFrameElement extends _Element_Merged {
  IFrameElement.internal() : super.internal();

  @DocsEditable
  factory IFrameElement() => document.$dom_createElement("iframe");

  @DomName('HTMLIFrameElement.contentWindow')
  @DocsEditable
  WindowBase get contentWindow native "HTMLIFrameElement_contentWindow_Getter";

  @DomName('HTMLIFrameElement.height')
  @DocsEditable
  String get height native "HTMLIFrameElement_height_Getter";

  @DomName('HTMLIFrameElement.height')
  @DocsEditable
  void set height(String value) native "HTMLIFrameElement_height_Setter";

  @DomName('HTMLIFrameElement.name')
  @DocsEditable
  String get name native "HTMLIFrameElement_name_Getter";

  @DomName('HTMLIFrameElement.name')
  @DocsEditable
  void set name(String value) native "HTMLIFrameElement_name_Setter";

  @DomName('HTMLIFrameElement.sandbox')
  @DocsEditable
  String get sandbox native "HTMLIFrameElement_sandbox_Getter";

  @DomName('HTMLIFrameElement.sandbox')
  @DocsEditable
  void set sandbox(String value) native "HTMLIFrameElement_sandbox_Setter";

  @DomName('HTMLIFrameElement.src')
  @DocsEditable
  String get src native "HTMLIFrameElement_src_Getter";

  @DomName('HTMLIFrameElement.src')
  @DocsEditable
  void set src(String value) native "HTMLIFrameElement_src_Setter";

  @DomName('HTMLIFrameElement.srcdoc')
  @DocsEditable
  String get srcdoc native "HTMLIFrameElement_srcdoc_Getter";

  @DomName('HTMLIFrameElement.srcdoc')
  @DocsEditable
  void set srcdoc(String value) native "HTMLIFrameElement_srcdoc_Setter";

  @DomName('HTMLIFrameElement.width')
  @DocsEditable
  String get width native "HTMLIFrameElement_width_Getter";

  @DomName('HTMLIFrameElement.width')
  @DocsEditable
  void set width(String value) native "HTMLIFrameElement_width_Setter";

}
// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

@DomName('ImageData')

class ImageData extends NativeFieldWrapperClass1 {
  List<int> __data;

  List<int> get data {
    if (__data == null) {
      __data = _data;
    }
    return __data;
  }

  ImageData.internal();

  @DomName('ImageData.data')
  @DocsEditable
  List<int> get _data native "ImageData_data_Getter";

  @DomName('ImageData.height')
  @DocsEditable
  int get height native "ImageData_height_Getter";

  @DomName('ImageData.width')
  @DocsEditable
  int get width native "ImageData_width_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('HTMLImageElement')
class ImageElement extends _Element_Merged {
  ImageElement.internal() : super.internal();

  @DocsEditable
  factory ImageElement({String src, int width, int height}) {
    var e = document.$dom_createElement("img");
    if (src != null) e.src = src;
    if (width != null) e.width = width;
    if (height != null) e.height = height;
    return e;
  }

  @DomName('HTMLImageElement.alt')
  @DocsEditable
  String get alt native "HTMLImageElement_alt_Getter";

  @DomName('HTMLImageElement.alt')
  @DocsEditable
  void set alt(String value) native "HTMLImageElement_alt_Setter";

  @DomName('HTMLImageElement.border')
  @DocsEditable
  String get border native "HTMLImageElement_border_Getter";

  @DomName('HTMLImageElement.border')
  @DocsEditable
  void set border(String value) native "HTMLImageElement_border_Setter";

  @DomName('HTMLImageElement.complete')
  @DocsEditable
  bool get complete native "HTMLImageElement_complete_Getter";

  @DomName('HTMLImageElement.crossOrigin')
  @DocsEditable
  String get crossOrigin native "HTMLImageElement_crossOrigin_Getter";

  @DomName('HTMLImageElement.crossOrigin')
  @DocsEditable
  void set crossOrigin(String value) native "HTMLImageElement_crossOrigin_Setter";

  @DomName('HTMLImageElement.height')
  @DocsEditable
  int get height native "HTMLImageElement_height_Getter";

  @DomName('HTMLImageElement.height')
  @DocsEditable
  void set height(int value) native "HTMLImageElement_height_Setter";

  @DomName('HTMLImageElement.isMap')
  @DocsEditable
  bool get isMap native "HTMLImageElement_isMap_Getter";

  @DomName('HTMLImageElement.isMap')
  @DocsEditable
  void set isMap(bool value) native "HTMLImageElement_isMap_Setter";

  @DomName('HTMLImageElement.lowsrc')
  @DocsEditable
  String get lowsrc native "HTMLImageElement_lowsrc_Getter";

  @DomName('HTMLImageElement.lowsrc')
  @DocsEditable
  void set lowsrc(String value) native "HTMLImageElement_lowsrc_Setter";

  @DomName('HTMLImageElement.naturalHeight')
  @DocsEditable
  int get naturalHeight native "HTMLImageElement_naturalHeight_Getter";

  @DomName('HTMLImageElement.naturalWidth')
  @DocsEditable
  int get naturalWidth native "HTMLImageElement_naturalWidth_Getter";

  @DomName('HTMLImageElement.src')
  @DocsEditable
  String get src native "HTMLImageElement_src_Getter";

  @DomName('HTMLImageElement.src')
  @DocsEditable
  void set src(String value) native "HTMLImageElement_src_Setter";

  @DomName('HTMLImageElement.useMap')
  @DocsEditable
  String get useMap native "HTMLImageElement_useMap_Getter";

  @DomName('HTMLImageElement.useMap')
  @DocsEditable
  void set useMap(String value) native "HTMLImageElement_useMap_Setter";

  @DomName('HTMLImageElement.width')
  @DocsEditable
  int get width native "HTMLImageElement_width_Getter";

  @DomName('HTMLImageElement.width')
  @DocsEditable
  void set width(int value) native "HTMLImageElement_width_Setter";

  @DomName('HTMLImageElement.x')
  @DocsEditable
  int get x native "HTMLImageElement_x_Getter";

  @DomName('HTMLImageElement.y')
  @DocsEditable
  int get y native "HTMLImageElement_y_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.


@DomName('HTMLInputElement')
class InputElement extends _Element_Merged implements
    HiddenInputElement,
    SearchInputElement,
    TextInputElement,
    UrlInputElement,
    TelephoneInputElement,
    EmailInputElement,
    PasswordInputElement,
    DateTimeInputElement,
    DateInputElement,
    MonthInputElement,
    WeekInputElement,
    TimeInputElement,
    LocalDateTimeInputElement,
    NumberInputElement,
    RangeInputElement,
    CheckboxInputElement,
    RadioButtonInputElement,
    FileUploadInputElement,
    SubmitButtonInputElement,
    ImageButtonInputElement,
    ResetButtonInputElement,
    ButtonInputElement
     {

  factory InputElement({String type}) {
    var e = document.$dom_createElement("input");
    if (type != null) {
      try {
        // IE throws an exception for unknown types.
        e.type = type;
      } catch(_) {}
    }
    return e;
  }
  InputElement.internal() : super.internal();

  @DomName('HTMLInputElement.webkitSpeechChange')
  @DocsEditable
  static const EventStreamProvider<Event> speechChangeEvent = const EventStreamProvider<Event>('webkitSpeechChange');

  @DocsEditable
  @DomName('EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent')
  @deprecated
  InputElementEvents get on =>
    new InputElementEvents(this);

  @DomName('HTMLInputElement.accept')
  @DocsEditable
  String get accept native "HTMLInputElement_accept_Getter";

  @DomName('HTMLInputElement.accept')
  @DocsEditable
  void set accept(String value) native "HTMLInputElement_accept_Setter";

  @DomName('HTMLInputElement.alt')
  @DocsEditable
  String get alt native "HTMLInputElement_alt_Getter";

  @DomName('HTMLInputElement.alt')
  @DocsEditable
  void set alt(String value) native "HTMLInputElement_alt_Setter";

  @DomName('HTMLInputElement.autocomplete')
  @DocsEditable
  String get autocomplete native "HTMLInputElement_autocomplete_Getter";

  @DomName('HTMLInputElement.autocomplete')
  @DocsEditable
  void set autocomplete(String value) native "HTMLInputElement_autocomplete_Setter";

  @DomName('HTMLInputElement.autofocus')
  @DocsEditable
  bool get autofocus native "HTMLInputElement_autofocus_Getter";

  @DomName('HTMLInputElement.autofocus')
  @DocsEditable
  void set autofocus(bool value) native "HTMLInputElement_autofocus_Setter";

  @DomName('HTMLInputElement.checked')
  @DocsEditable
  bool get checked native "HTMLInputElement_checked_Getter";

  @DomName('HTMLInputElement.checked')
  @DocsEditable
  void set checked(bool value) native "HTMLInputElement_checked_Setter";

  @DomName('HTMLInputElement.defaultChecked')
  @DocsEditable
  bool get defaultChecked native "HTMLInputElement_defaultChecked_Getter";

  @DomName('HTMLInputElement.defaultChecked')
  @DocsEditable
  void set defaultChecked(bool value) native "HTMLInputElement_defaultChecked_Setter";

  @DomName('HTMLInputElement.defaultValue')
  @DocsEditable
  String get defaultValue native "HTMLInputElement_defaultValue_Getter";

  @DomName('HTMLInputElement.defaultValue')
  @DocsEditable
  void set defaultValue(String value) native "HTMLInputElement_defaultValue_Setter";

  @DomName('HTMLInputElement.dirName')
  @DocsEditable
  String get dirName native "HTMLInputElement_dirName_Getter";

  @DomName('HTMLInputElement.dirName')
  @DocsEditable
  void set dirName(String value) native "HTMLInputElement_dirName_Setter";

  @DomName('HTMLInputElement.disabled')
  @DocsEditable
  bool get disabled native "HTMLInputElement_disabled_Getter";

  @DomName('HTMLInputElement.disabled')
  @DocsEditable
  void set disabled(bool value) native "HTMLInputElement_disabled_Setter";

  @DomName('HTMLInputElement.files')
  @DocsEditable
  List<File> get files native "HTMLInputElement_files_Getter";

  @DomName('HTMLInputElement.files')
  @DocsEditable
  void set files(List<File> value) native "HTMLInputElement_files_Setter";

  @DomName('HTMLInputElement.form')
  @DocsEditable
  FormElement get form native "HTMLInputElement_form_Getter";

  @DomName('HTMLInputElement.formAction')
  @DocsEditable
  String get formAction native "HTMLInputElement_formAction_Getter";

  @DomName('HTMLInputElement.formAction')
  @DocsEditable
  void set formAction(String value) native "HTMLInputElement_formAction_Setter";

  @DomName('HTMLInputElement.formEnctype')
  @DocsEditable
  String get formEnctype native "HTMLInputElement_formEnctype_Getter";

  @DomName('HTMLInputElement.formEnctype')
  @DocsEditable
  void set formEnctype(String value) native "HTMLInputElement_formEnctype_Setter";

  @DomName('HTMLInputElement.formMethod')
  @DocsEditable
  String get formMethod native "HTMLInputElement_formMethod_Getter";

  @DomName('HTMLInputElement.formMethod')
  @DocsEditable
  void set formMethod(String value) native "HTMLInputElement_formMethod_Setter";

  @DomName('HTMLInputElement.formNoValidate')
  @DocsEditable
  bool get formNoValidate native "HTMLInputElement_formNoValidate_Getter";

  @DomName('HTMLInputElement.formNoValidate')
  @DocsEditable
  void set formNoValidate(bool value) native "HTMLInputElement_formNoValidate_Setter";

  @DomName('HTMLInputElement.formTarget')
  @DocsEditable
  String get formTarget native "HTMLInputElement_formTarget_Getter";

  @DomName('HTMLInputElement.formTarget')
  @DocsEditable
  void set formTarget(String value) native "HTMLInputElement_formTarget_Setter";

  @DomName('HTMLInputElement.height')
  @DocsEditable
  int get height native "HTMLInputElement_height_Getter";

  @DomName('HTMLInputElement.height')
  @DocsEditable
  void set height(int value) native "HTMLInputElement_height_Setter";

  @DomName('HTMLInputElement.incremental')
  @DocsEditable
  bool get incremental native "HTMLInputElement_incremental_Getter";

  @DomName('HTMLInputElement.incremental')
  @DocsEditable
  void set incremental(bool value) native "HTMLInputElement_incremental_Setter";

  @DomName('HTMLInputElement.indeterminate')
  @DocsEditable
  bool get indeterminate native "HTMLInputElement_indeterminate_Getter";

  @DomName('HTMLInputElement.indeterminate')
  @DocsEditable
  void set indeterminate(bool value) native "HTMLInputElement_indeterminate_Setter";

  @DomName('HTMLInputElement.labels')
  @DocsEditable
  List<Node> get labels native "HTMLInputElement_labels_Getter";

  @DomName('HTMLInputElement.list')
  @DocsEditable
  Element get list native "HTMLInputElement_list_Getter";

  @DomName('HTMLInputElement.max')
  @DocsEditable
  String get max native "HTMLInputElement_max_Getter";

  @DomName('HTMLInputElement.max')
  @DocsEditable
  void set max(String value) native "HTMLInputElement_max_Setter";

  @DomName('HTMLInputElement.maxLength')
  @DocsEditable
  int get maxLength native "HTMLInputElement_maxLength_Getter";

  @DomName('HTMLInputElement.maxLength')
  @DocsEditable
  void set maxLength(int value) native "HTMLInputElement_maxLength_Setter";

  @DomName('HTMLInputElement.min')
  @DocsEditable
  String get min native "HTMLInputElement_min_Getter";

  @DomName('HTMLInputElement.min')
  @DocsEditable
  void set min(String value) native "HTMLInputElement_min_Setter";

  @DomName('HTMLInputElement.multiple')
  @DocsEditable
  bool get multiple native "HTMLInputElement_multiple_Getter";

  @DomName('HTMLInputElement.multiple')
  @DocsEditable
  void set multiple(bool value) native "HTMLInputElement_multiple_Setter";

  @DomName('HTMLInputElement.name')
  @DocsEditable
  String get name native "HTMLInputElement_name_Getter";

  @DomName('HTMLInputElement.name')
  @DocsEditable
  void set name(String value) native "HTMLInputElement_name_Setter";

  @DomName('HTMLInputElement.pattern')
  @DocsEditable
  String get pattern native "HTMLInputElement_pattern_Getter";

  @DomName('HTMLInputElement.pattern')
  @DocsEditable
  void set pattern(String value) native "HTMLInputElement_pattern_Setter";

  @DomName('HTMLInputElement.placeholder')
  @DocsEditable
  String get placeholder native "HTMLInputElement_placeholder_Getter";

  @DomName('HTMLInputElement.placeholder')
  @DocsEditable
  void set placeholder(String value) native "HTMLInputElement_placeholder_Setter";

  @DomName('HTMLInputElement.readOnly')
  @DocsEditable
  bool get readOnly native "HTMLInputElement_readOnly_Getter";

  @DomName('HTMLInputElement.readOnly')
  @DocsEditable
  void set readOnly(bool value) native "HTMLInputElement_readOnly_Setter";

  @DomName('HTMLInputElement.required')
  @DocsEditable
  bool get required native "HTMLInputElement_required_Getter";

  @DomName('HTMLInputElement.required')
  @DocsEditable
  void set required(bool value) native "HTMLInputElement_required_Setter";

  @DomName('HTMLInputElement.selectionDirection')
  @DocsEditable
  String get selectionDirection native "HTMLInputElement_selectionDirection_Getter";

  @DomName('HTMLInputElement.selectionDirection')
  @DocsEditable
  void set selectionDirection(String value) native "HTMLInputElement_selectionDirection_Setter";

  @DomName('HTMLInputElement.selectionEnd')
  @DocsEditable
  int get selectionEnd native "HTMLInputElement_selectionEnd_Getter";

  @DomName('HTMLInputElement.selectionEnd')
  @DocsEditable
  void set selectionEnd(int value) native "HTMLInputElement_selectionEnd_Setter";

  @DomName('HTMLInputElement.selectionStart')
  @DocsEditable
  int get selectionStart native "HTMLInputElement_selectionStart_Getter";

  @DomName('HTMLInputElement.selectionStart')
  @DocsEditable
  void set selectionStart(int value) native "HTMLInputElement_selectionStart_Setter";

  @DomName('HTMLInputElement.size')
  @DocsEditable
  int get size native "HTMLInputElement_size_Getter";

  @DomName('HTMLInputElement.size')
  @DocsEditable
  void set size(int value) native "HTMLInputElement_size_Setter";

  @DomName('HTMLInputElement.src')
  @DocsEditable
  String get src native "HTMLInputElement_src_Getter";

  @DomName('HTMLInputElement.src')
  @DocsEditable
  void set src(String value) native "HTMLInputElement_src_Setter";

  @DomName('HTMLInputElement.step')
  @DocsEditable
  String get step native "HTMLInputElement_step_Getter";

  @DomName('HTMLInputElement.step')
  @DocsEditable
  void set step(String value) native "HTMLInputElement_step_Setter";

  @DomName('HTMLInputElement.type')
  @DocsEditable
  String get type native "HTMLInputElement_type_Getter";

  @DomName('HTMLInputElement.type')
  @DocsEditable
  void set type(String value) native "HTMLInputElement_type_Setter";

  @DomName('HTMLInputElement.useMap')
  @DocsEditable
  String get useMap native "HTMLInputElement_useMap_Getter";

  @DomName('HTMLInputElement.useMap')
  @DocsEditable
  void set useMap(String value) native "HTMLInputElement_useMap_Setter";

  @DomName('HTMLInputElement.validationMessage')
  @DocsEditable
  String get validationMessage native "HTMLInputElement_validationMessage_Getter";

  @DomName('HTMLInputElement.validity')
  @DocsEditable
  ValidityState get validity native "HTMLInputElement_validity_Getter";

  @DomName('HTMLInputElement.value')
  @DocsEditable
  String get value native "HTMLInputElement_value_Getter";

  @DomName('HTMLInputElement.value')
  @DocsEditable
  void set value(String value) native "HTMLInputElement_value_Setter";

  @DomName('HTMLInputElement.valueAsDate')
  @DocsEditable
  Date get valueAsDate native "HTMLInputElement_valueAsDate_Getter";

  @DomName('HTMLInputElement.valueAsDate')
  @DocsEditable
  void set valueAsDate(Date value) native "HTMLInputElement_valueAsDate_Setter";

  @DomName('HTMLInputElement.valueAsNumber')
  @DocsEditable
  num get valueAsNumber native "HTMLInputElement_valueAsNumber_Getter";

  @DomName('HTMLInputElement.valueAsNumber')
  @DocsEditable
  void set valueAsNumber(num value) native "HTMLInputElement_valueAsNumber_Setter";

  @DomName('HTMLInputElement.webkitEntries')
  @DocsEditable
  List<Entry> get webkitEntries native "HTMLInputElement_webkitEntries_Getter";

  @DomName('HTMLInputElement.webkitGrammar')
  @DocsEditable
  bool get webkitGrammar native "HTMLInputElement_webkitGrammar_Getter";

  @DomName('HTMLInputElement.webkitGrammar')
  @DocsEditable
  void set webkitGrammar(bool value) native "HTMLInputElement_webkitGrammar_Setter";

  @DomName('HTMLInputElement.webkitSpeech')
  @DocsEditable
  bool get webkitSpeech native "HTMLInputElement_webkitSpeech_Getter";

  @DomName('HTMLInputElement.webkitSpeech')
  @DocsEditable
  void set webkitSpeech(bool value) native "HTMLInputElement_webkitSpeech_Setter";

  @DomName('HTMLInputElement.webkitdirectory')
  @DocsEditable
  bool get webkitdirectory native "HTMLInputElement_webkitdirectory_Getter";

  @DomName('HTMLInputElement.webkitdirectory')
  @DocsEditable
  void set webkitdirectory(bool value) native "HTMLInputElement_webkitdirectory_Setter";

  @DomName('HTMLInputElement.width')
  @DocsEditable
  int get width native "HTMLInputElement_width_Getter";

  @DomName('HTMLInputElement.width')
  @DocsEditable
  void set width(int value) native "HTMLInputElement_width_Setter";

  @DomName('HTMLInputElement.willValidate')
  @DocsEditable
  bool get willValidate native "HTMLInputElement_willValidate_Getter";

  @DomName('HTMLInputElement.checkValidity')
  @DocsEditable
  bool checkValidity() native "HTMLInputElement_checkValidity_Callback";

  @DomName('HTMLInputElement.select')
  @DocsEditable
  void select() native "HTMLInputElement_select_Callback";

  @DomName('HTMLInputElement.setCustomValidity')
  @DocsEditable
  void setCustomValidity(String error) native "HTMLInputElement_setCustomValidity_Callback";

  void setRangeText(String replacement, [int start, int end, String selectionMode]) {
    if ((replacement is String || replacement == null) && !?start && !?end && !?selectionMode) {
      _setRangeText_1(replacement);
      return;
    }
    if ((replacement is String || replacement == null) && (start is int || start == null) && (end is int || end == null) && (selectionMode is String || selectionMode == null)) {
      _setRangeText_2(replacement, start, end, selectionMode);
      return;
    }
    throw new ArgumentError("Incorrect number or type of arguments");
  }

  @DomName('HTMLInputElement._setRangeText_1')
  @DocsEditable
  void _setRangeText_1(replacement) native "HTMLInputElement__setRangeText_1_Callback";

  @DomName('HTMLInputElement._setRangeText_2')
  @DocsEditable
  void _setRangeText_2(replacement, start, end, selectionMode) native "HTMLInputElement__setRangeText_2_Callback";

  @DomName('HTMLInputElement.setSelectionRange')
  @DocsEditable
  void setSelectionRange(int start, int end, [String direction]) native "HTMLInputElement_setSelectionRange_Callback";

  void stepDown([int n]) {
    if (?n) {
      _stepDown_1(n);
      return;
    }
    _stepDown_2();
    return;
  }

  @DomName('HTMLInputElement._stepDown_1')
  @DocsEditable
  void _stepDown_1(n) native "HTMLInputElement__stepDown_1_Callback";

  @DomName('HTMLInputElement._stepDown_2')
  @DocsEditable
  void _stepDown_2() native "HTMLInputElement__stepDown_2_Callback";

  void stepUp([int n]) {
    if (?n) {
      _stepUp_1(n);
      return;
    }
    _stepUp_2();
    return;
  }

  @DomName('HTMLInputElement._stepUp_1')
  @DocsEditable
  void _stepUp_1(n) native "HTMLInputElement__stepUp_1_Callback";

  @DomName('HTMLInputElement._stepUp_2')
  @DocsEditable
  void _stepUp_2() native "HTMLInputElement__stepUp_2_Callback";

  @DomName('HTMLInputElement.webkitSpeechChange')
  @DocsEditable
  Stream<Event> get onSpeechChange => speechChangeEvent.forTarget(this);

}


// Interfaces representing the InputElement APIs which are supported
// for the various types of InputElement.
// From http://dev.w3.org/html5/spec/the-input-element.html#the-input-element.

/**
 * Exposes the functionality common between all InputElement types.
 */
abstract class InputElementBase implements Element {
  @DomName('HTMLInputElement.autofocus')
  bool autofocus;

  @DomName('HTMLInputElement.disabled')
  bool disabled;

  @DomName('HTMLInputElement.incremental')
  bool incremental;

  @DomName('HTMLInputElement.indeterminate')
  bool indeterminate;

  @DomName('HTMLInputElement.labels')
  List<Node> get labels;

  @DomName('HTMLInputElement.name')
  String name;

  @DomName('HTMLInputElement.validationMessage')
  String get validationMessage;

  @DomName('HTMLInputElement.validity')
  ValidityState get validity;

  @DomName('HTMLInputElement.value')
  String value;

  @DomName('HTMLInputElement.willValidate')
  bool get willValidate;

  @DomName('HTMLInputElement.checkValidity')
  bool checkValidity();

  @DomName('HTMLInputElement.setCustomValidity')
  void setCustomValidity(String error);
}

/**
 * Hidden input which is not intended to be seen or edited by the user.
 */
abstract class HiddenInputElement implements Element {
  factory HiddenInputElement() => new InputElement(type: 'hidden');
}


/**
 * Base interface for all inputs which involve text editing.
 */
abstract class TextInputElementBase implements InputElementBase {
  @DomName('HTMLInputElement.autocomplete')
  String autocomplete;

  @DomName('HTMLInputElement.maxLength')
  int maxLength;

  @DomName('HTMLInputElement.pattern')
  String pattern;

  @DomName('HTMLInputElement.placeholder')
  String placeholder;

  @DomName('HTMLInputElement.readOnly')
  bool readOnly;

  @DomName('HTMLInputElement.required')
  bool required;

  @DomName('HTMLInputElement.size')
  int size;

  @DomName('HTMLInputElement.select')
  void select();

  @DomName('HTMLInputElement.selectionDirection')
  String selectionDirection;

  @DomName('HTMLInputElement.selectionEnd')
  int selectionEnd;

  @DomName('HTMLInputElement.selectionStart')
  int selectionStart;

  @DomName('HTMLInputElement.setSelectionRange')
  void setSelectionRange(int start, int end, [String direction]);
}

/**
 * Similar to [TextInputElement], but on platforms where search is styled
 * differently this will get the search style.
 *
 * Use [supported] to check if this is supported on the current platform.
 */
@SupportedBrowser(SupportedBrowser.CHROME)
@SupportedBrowser(SupportedBrowser.FIREFOX)
@SupportedBrowser(SupportedBrowser.IE, '10')
@SupportedBrowser(SupportedBrowser.SAFARI)
abstract class SearchInputElement implements TextInputElementBase {
  factory SearchInputElement() => new InputElement(type: 'search');

  @DomName('HTMLInputElement.dirName')
  String dirName;

  @DomName('HTMLInputElement.list')
  Element get list;

  /// Returns true if this input type is supported on the current platform.
  static bool get supported {
    return (new InputElement(type: 'search')).type == 'search';
  }
}

/**
 * A basic text input editor control.
 */
abstract class TextInputElement implements TextInputElementBase {
  factory TextInputElement() => new InputElement(type: 'text');

  @DomName('HTMLInputElement.dirName')
  String dirName;

  @DomName('HTMLInputElement.list')
  Element get list;
}

/**
 * A control for editing an absolute URL.
 *
 * Use [supported] to check if this is supported on the current platform.
 */
@SupportedBrowser(SupportedBrowser.CHROME)
@SupportedBrowser(SupportedBrowser.FIREFOX)
@SupportedBrowser(SupportedBrowser.IE, '10')
@SupportedBrowser(SupportedBrowser.SAFARI)
abstract class UrlInputElement implements TextInputElementBase {
  factory UrlInputElement() => new InputElement(type: 'url');

  @DomName('HTMLInputElement.list')
  Element get list;

  /// Returns true if this input type is supported on the current platform.
  static bool get supported {
    return (new InputElement(type: 'url')).type == 'url';
  }
}

/**
 * Represents a control for editing a telephone number.
 *
 * This provides a single line of text with minimal formatting help since
 * there is a wide variety of telephone numbers.
 *
 * Use [supported] to check if this is supported on the current platform.
 */
@SupportedBrowser(SupportedBrowser.CHROME)
@SupportedBrowser(SupportedBrowser.FIREFOX)
@SupportedBrowser(SupportedBrowser.IE, '10')
@SupportedBrowser(SupportedBrowser.SAFARI)
abstract class TelephoneInputElement implements TextInputElementBase {
  factory TelephoneInputElement() => new InputElement(type: 'tel');

  @DomName('HTMLInputElement.list')
  Element get list;

  /// Returns true if this input type is supported on the current platform.
  static bool get supported {
    return (new InputElement(type: 'tel')).type == 'tel';
  }
}

/**
 * An e-mail address or list of e-mail addresses.
 *
 * Use [supported] to check if this is supported on the current platform.
 */
@SupportedBrowser(SupportedBrowser.CHROME)
@SupportedBrowser(SupportedBrowser.FIREFOX)
@SupportedBrowser(SupportedBrowser.IE, '10')
@SupportedBrowser(SupportedBrowser.SAFARI)
abstract class EmailInputElement implements TextInputElementBase {
  factory EmailInputElement() => new InputElement(type: 'email');

  @DomName('HTMLInputElement.autocomplete')
  String autocomplete;

  @DomName('HTMLInputElement.autofocus')
  bool autofocus;

  @DomName('HTMLInputElement.list')
  Element get list;

  @DomName('HTMLInputElement.maxLength')
  int maxLength;

  @DomName('HTMLInputElement.multiple')
  bool multiple;

  @DomName('HTMLInputElement.pattern')
  String pattern;

  @DomName('HTMLInputElement.placeholder')
  String placeholder;

  @DomName('HTMLInputElement.readOnly')
  bool readOnly;

  @DomName('HTMLInputElement.required')
  bool required;

  @DomName('HTMLInputElement.size')
  int size;

  /// Returns true if this input type is supported on the current platform.
  static bool get supported {
    return (new InputElement(type: 'email')).type == 'email';
  }
}

/**
 * Text with no line breaks (sensitive information).
 */
abstract class PasswordInputElement implements TextInputElementBase {
  factory PasswordInputElement() => new InputElement(type: 'password');
}

/**
 * Base interface for all input element types which involve ranges.
 */
abstract class RangeInputElementBase implements InputElementBase {

  @DomName('HTMLInputElement.list')
  Element get list;

  @DomName('HTMLInputElement.max')
  String max;

  @DomName('HTMLInputElement.min')
  String min;

  @DomName('HTMLInputElement.step')
  String step;

  @DomName('HTMLInputElement.valueAsNumber')
  num valueAsNumber;

  @DomName('HTMLInputElement.stepDown')
  void stepDown([int n]);

  @DomName('HTMLInputElement.stepUp')
  void stepUp([int n]);
}

/**
 * A date and time (year, month, day, hour, minute, second, fraction of a
 * second) with the time zone set to UTC.
 *
 * Use [supported] to check if this is supported on the current platform.
 */
@SupportedBrowser(SupportedBrowser.CHROME, '25')
@Experimental
abstract class DateTimeInputElement implements RangeInputElementBase {
  factory DateTimeInputElement() => new InputElement(type: 'datetime');

  @DomName('HTMLInputElement.valueAsDate')
  DateTime valueAsDate;

  @DomName('HTMLInputElement.readOnly')
  bool readOnly;

  @DomName('HTMLInputElement.required')
  bool required;

  /// Returns true if this input type is supported on the current platform.
  static bool get supported {
    return (new InputElement(type: 'datetime')).type == 'datetime';
  }
}

/**
 * A date (year, month, day) with no time zone.
 *
 * Use [supported] to check if this is supported on the current platform.
 */
@SupportedBrowser(SupportedBrowser.CHROME, '25')
@Experimental
abstract class DateInputElement implements RangeInputElementBase {
  factory DateInputElement() => new InputElement(type: 'date');

  @DomName('HTMLInputElement.valueAsDate')
  DateTime valueAsDate;

  @DomName('HTMLInputElement.readOnly')
  bool readOnly;

  @DomName('HTMLInputElement.required')
  bool required;

  /// Returns true if this input type is supported on the current platform.
  static bool get supported {
    return (new InputElement(type: 'date')).type == 'date';
  }
}

/**
 * A date consisting of a year and a month with no time zone.
 *
 * Use [supported] to check if this is supported on the current platform.
 */
@SupportedBrowser(SupportedBrowser.CHROME, '25')
@Experimental
abstract class MonthInputElement implements RangeInputElementBase {
  factory MonthInputElement() => new InputElement(type: 'month');

  @DomName('HTMLInputElement.valueAsDate')
  DateTime valueAsDate;

  @DomName('HTMLInputElement.readOnly')
  bool readOnly;

  @DomName('HTMLInputElement.required')
  bool required;

  /// Returns true if this input type is supported on the current platform.
  static bool get supported {
    return (new InputElement(type: 'month')).type == 'month';
  }
}

/**
 * A date consisting of a week-year number and a week number with no time zone.
 *
 * Use [supported] to check if this is supported on the current platform.
 */
@SupportedBrowser(SupportedBrowser.CHROME, '25')
@Experimental
abstract class WeekInputElement implements RangeInputElementBase {
  factory WeekInputElement() => new InputElement(type: 'week');

  @DomName('HTMLInputElement.valueAsDate')
  DateTime valueAsDate;

  @DomName('HTMLInputElement.readOnly')
  bool readOnly;

  @DomName('HTMLInputElement.required')
  bool required;

  /// Returns true if this input type is supported on the current platform.
  static bool get supported {
    return (new InputElement(type: 'week')).type == 'week';
  }
}

/**
 * A time (hour, minute, seconds, fractional seconds) with no time zone.
 *
 * Use [supported] to check if this is supported on the current platform.
 */
@SupportedBrowser(SupportedBrowser.CHROME)
@Experimental
abstract class TimeInputElement implements RangeInputElementBase {
  factory TimeInputElement() => new InputElement(type: 'time');

  @DomName('HTMLInputElement.valueAsDate')
  DateTime valueAsDate;

  @DomName('HTMLInputElement.readOnly')
  bool readOnly;

  @DomName('HTMLInputElement.required')
  bool required;

  /// Returns true if this input type is supported on the current platform.
  static bool get supported {
    return (new InputElement(type: 'time')).type == 'time';
  }
}

/**
 * A date and time (year, month, day, hour, minute, second, fraction of a
 * second) with no time zone.
 *
 * Use [supported] to check if this is supported on the current platform.
 */
@SupportedBrowser(SupportedBrowser.CHROME, '25')
@Experimental
abstract class LocalDateTimeInputElement implements RangeInputElementBase {
  factory LocalDateTimeInputElement() =>
      new InputElement(type: 'datetime-local');

  @DomName('HTMLInputElement.readOnly')
  bool readOnly;

  @DomName('HTMLInputElement.required')
  bool required;

  /// Returns true if this input type is supported on the current platform.
  static bool get supported {
    return (new InputElement(type: 'datetime-local')).type == 'datetime-local';
  }
}

/**
 * A numeric editor control.
 */
@SupportedBrowser(SupportedBrowser.CHROME)
@SupportedBrowser(SupportedBrowser.IE)
@SupportedBrowser(SupportedBrowser.SAFARI)
@Experimental
abstract class NumberInputElement implements RangeInputElementBase {
  factory NumberInputElement() => new InputElement(type: 'number');

  @DomName('HTMLInputElement.placeholder')
  String placeholder;

  @DomName('HTMLInputElement.readOnly')
  bool readOnly;

  @DomName('HTMLInputElement.required')
  bool required;

  /// Returns true if this input type is supported on the current platform.
  static bool get supported {
    return (new InputElement(type: 'number')).type == 'number';
  }
}

/**
 * Similar to [NumberInputElement] but the browser may provide more optimal
 * styling (such as a slider control).
 *
 * Use [supported] to check if this is supported on the current platform.
 */
@SupportedBrowser(SupportedBrowser.CHROME)
@SupportedBrowser(SupportedBrowser.IE, '10')
@Experimental
abstract class RangeInputElement implements RangeInputElementBase {
  factory RangeInputElement() => new InputElement(type: 'range');

  /// Returns true if this input type is supported on the current platform.
  static bool get supported {
    return (new InputElement(type: 'range')).type == 'range';
  }
}

/**
 * A boolean editor control.
 *
 * Note that if [indeterminate] is set then this control is in a third
 * indeterminate state.
 */
abstract class CheckboxInputElement implements InputElementBase {
  factory CheckboxInputElement() => new InputElement(type: 'checkbox');

  @DomName('HTMLInputElement.checked')
  bool checked;

  @DomName('HTMLInputElement.required')
  bool required;
}


/**
 * A control that when used with other [ReadioButtonInputElement] controls
 * forms a radio button group in which only one control can be checked at a
 * time.
 *
 * Radio buttons are considered to be in the same radio button group if:
 *
 * * They are all of type 'radio'.
 * * They all have either the same [FormElement] owner, or no owner.
 * * Their name attributes contain the same name.
 */
abstract class RadioButtonInputElement implements InputElementBase {
  factory RadioButtonInputElement() => new InputElement(type: 'radio');

  @DomName('HTMLInputElement.checked')
  bool checked;

  @DomName('HTMLInputElement.required')
  bool required;
}

/**
 * A control for picking files from the user's computer.
 */
abstract class FileUploadInputElement implements InputElementBase {
  factory FileUploadInputElement() => new InputElement(type: 'file');

  @DomName('HTMLInputElement.accept')
  String accept;

  @DomName('HTMLInputElement.multiple')
  bool multiple;

  @DomName('HTMLInputElement.required')
  bool required;

  @DomName('HTMLInputElement.files')
  List<File> files;
}

/**
 * A button, which when clicked, submits the form.
 */
abstract class SubmitButtonInputElement implements InputElementBase {
  factory SubmitButtonInputElement() => new InputElement(type: 'submit');

  @DomName('HTMLInputElement.formAction')
  String formAction;

  @DomName('HTMLInputElement.formEnctype')
  String formEnctype;

  @DomName('HTMLInputElement.formMethod')
  String formMethod;

  @DomName('HTMLInputElement.formNoValidate')
  bool formNoValidate;

  @DomName('HTMLInputElement.formTarget')
  String formTarget;
}

/**
 * Either an image which the user can select a coordinate to or a form
 * submit button.
 */
abstract class ImageButtonInputElement implements InputElementBase {
  factory ImageButtonInputElement() => new InputElement(type: 'image');

  @DomName('HTMLInputElement.alt')
  String alt;

  @DomName('HTMLInputElement.formAction')
  String formAction;

  @DomName('HTMLInputElement.formEnctype')
  String formEnctype;

  @DomName('HTMLInputElement.formMethod')
  String formMethod;

  @DomName('HTMLInputElement.formNoValidate')
  bool formNoValidate;

  @DomName('HTMLInputElement.formTarget')
  String formTarget;

  @DomName('HTMLInputElement.height')
  int height;

  @DomName('HTMLInputElement.src')
  String src;

  @DomName('HTMLInputElement.width')
  int width;
}

/**
 * A button, which when clicked, resets the form.
 */
abstract class ResetButtonInputElement implements InputElementBase {
  factory ResetButtonInputElement() => new InputElement(type: 'reset');
}

/**
 * A button, with no default behavior.
 */
abstract class ButtonInputElement implements InputElementBase {
  factory ButtonInputElement() => new InputElement(type: 'button');
}


@DocsEditable
@deprecated
class InputElementEvents extends ElementEvents {
  @DocsEditable
  InputElementEvents(EventTarget _ptr) : super(_ptr);

  @DocsEditable
  EventListenerList get speechChange => this['webkitSpeechChange'];
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('Int16Array')
class Int16Array extends ArrayBufferView implements List<int> {
  Int16Array.internal() : super.internal();

  factory Int16Array(int length) =>
    _TypedArrayFactoryProvider.createInt16Array(length);

  factory Int16Array.fromList(List<int> list) =>
    _TypedArrayFactoryProvider.createInt16Array_fromList(list);

  factory Int16Array.fromBuffer(ArrayBuffer buffer, [int byteOffset, int length]) => 
    _TypedArrayFactoryProvider.createInt16Array_fromBuffer(buffer, byteOffset, length);

  static const int BYTES_PER_ELEMENT = 2;

  @DomName('Int16Array.length')
  @DocsEditable
  int get length native "Int16Array_length_Getter";

  @DomName('Int16Array.numericIndexGetter')
  @DocsEditable
  int operator[](int index) native "Int16Array_numericIndexGetter_Callback";

  @DomName('Int16Array.numericIndexSetter')
  @DocsEditable
  void operator[]=(int index, int value) native "Int16Array_numericIndexSetter_Callback";
  // -- start List<int> mixins.
  // int is the element type.

  // From Iterable<int>:

  Iterator<int> get iterator {
    // Note: NodeLists are not fixed size. And most probably length shouldn't
    // be cached in both iterator _and_ forEach method. For now caching it
    // for consistency.
    return new FixedSizeListIterator<int>(this);
  }

  dynamic reduce(dynamic initialValue, dynamic combine(dynamic, int)) {
    return IterableMixinWorkaround.reduce(this, initialValue, combine);
  }

  bool contains(int element) => IterableMixinWorkaround.contains(this, element);

  void forEach(void f(int element)) => IterableMixinWorkaround.forEach(this, f);

  String join([String separator]) =>
      IterableMixinWorkaround.joinList(this, separator);

  List mappedBy(f(int element)) => IterableMixinWorkaround.mappedByList(this, f);

  Iterable<int> where(bool f(int element)) =>
      IterableMixinWorkaround.where(this, f);

  bool every(bool f(int element)) => IterableMixinWorkaround.every(this, f);

  bool any(bool f(int element)) => IterableMixinWorkaround.any(this, f);

  List<int> toList() => new List<int>.from(this);
  Set<int> toSet() => new Set<int>.from(this);

  bool get isEmpty => this.length == 0;

  List<int> take(int n) => IterableMixinWorkaround.takeList(this, n);

  Iterable<int> takeWhile(bool test(int value)) {
    return IterableMixinWorkaround.takeWhile(this, test);
  }

  List<int> skip(int n) => IterableMixinWorkaround.skipList(this, n);

  Iterable<int> skipWhile(bool test(int value)) {
    return IterableMixinWorkaround.skipWhile(this, test);
  }

  int firstMatching(bool test(int value), { int orElse() }) {
    return IterableMixinWorkaround.firstMatching(this, test, orElse);
  }

  int lastMatching(bool test(int value), {int orElse()}) {
    return IterableMixinWorkaround.lastMatchingInList(this, test, orElse);
  }

  int singleMatching(bool test(int value)) {
    return IterableMixinWorkaround.singleMatching(this, test);
  }

  int elementAt(int index) {
    return this[index];
  }

  // From Collection<int>:

  void add(int value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addLast(int value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addAll(Iterable<int> iterable) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  // From List<int>:
  void set length(int value) {
    throw new UnsupportedError("Cannot resize immutable List.");
  }

  void clear() {
    throw new UnsupportedError("Cannot clear immutable List.");
  }

  List<int> get reversed =>
      new ReversedListView<int>(this, 0, null);

  void sort([int compare(int a, int b)]) {
    throw new UnsupportedError("Cannot sort immutable List.");
  }

  int indexOf(int element, [int start = 0]) =>
      Lists.indexOf(this, element, start, this.length);

  int lastIndexOf(int element, [int start]) {
    if (start == null) start = length - 1;
    return Lists.lastIndexOf(this, element, start);
  }

  int get first {
    if (this.length > 0) return this[0];
    throw new StateError("No elements");
  }

  int get last {
    if (this.length > 0) return this[this.length - 1];
    throw new StateError("No elements");
  }

  int get single {
    if (length == 1) return this[0];
    if (length == 0) throw new StateError("No elements");
    throw new StateError("More than one element");
  }

  int min([int compare(int a, int b)]) =>
      IterableMixinWorkaround.min(this, compare);

  int max([int compare(int a, int b)]) =>
      IterableMixinWorkaround.max(this, compare);

  int removeAt(int pos) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  int removeLast() {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void remove(Object object) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void removeAll(Iterable elements) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void retainAll(Iterable elements) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void removeMatching(bool test(int element)) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void retainMatching(bool test(int element)) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void setRange(int start, int rangeLength, List<int> from, [int startFrom]) {
    throw new UnsupportedError("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int rangeLength) {
    throw new UnsupportedError("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int rangeLength, [int initialValue]) {
    throw new UnsupportedError("Cannot insertRange on immutable List.");
  }

  List<int> getRange(int start, int rangeLength) =>
      Lists.getRange(this, start, rangeLength, <int>[]);

  // -- end List<int> mixins.

  @DomName('Int16Array.setElements')
  @DocsEditable
  void setElements(Object array, [int offset]) native "Int16Array_setElements_Callback";

  Int16Array subarray(int start, [int end]) {
    if (?end) {
      return _subarray_1(start, end);
    }
    return _subarray_2(start);
  }

  @DomName('Int16Array._subarray_1')
  @DocsEditable
  Int16Array _subarray_1(start, end) native "Int16Array__subarray_1_Callback";

  @DomName('Int16Array._subarray_2')
  @DocsEditable
  Int16Array _subarray_2(start) native "Int16Array__subarray_2_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('Int32Array')
class Int32Array extends ArrayBufferView implements List<int> {
  Int32Array.internal() : super.internal();

  factory Int32Array(int length) =>
    _TypedArrayFactoryProvider.createInt32Array(length);

  factory Int32Array.fromList(List<int> list) =>
    _TypedArrayFactoryProvider.createInt32Array_fromList(list);

  factory Int32Array.fromBuffer(ArrayBuffer buffer, [int byteOffset, int length]) => 
    _TypedArrayFactoryProvider.createInt32Array_fromBuffer(buffer, byteOffset, length);

  static const int BYTES_PER_ELEMENT = 4;

  @DomName('Int32Array.length')
  @DocsEditable
  int get length native "Int32Array_length_Getter";

  @DomName('Int32Array.numericIndexGetter')
  @DocsEditable
  int operator[](int index) native "Int32Array_numericIndexGetter_Callback";

  @DomName('Int32Array.numericIndexSetter')
  @DocsEditable
  void operator[]=(int index, int value) native "Int32Array_numericIndexSetter_Callback";
  // -- start List<int> mixins.
  // int is the element type.

  // From Iterable<int>:

  Iterator<int> get iterator {
    // Note: NodeLists are not fixed size. And most probably length shouldn't
    // be cached in both iterator _and_ forEach method. For now caching it
    // for consistency.
    return new FixedSizeListIterator<int>(this);
  }

  dynamic reduce(dynamic initialValue, dynamic combine(dynamic, int)) {
    return IterableMixinWorkaround.reduce(this, initialValue, combine);
  }

  bool contains(int element) => IterableMixinWorkaround.contains(this, element);

  void forEach(void f(int element)) => IterableMixinWorkaround.forEach(this, f);

  String join([String separator]) =>
      IterableMixinWorkaround.joinList(this, separator);

  List mappedBy(f(int element)) => IterableMixinWorkaround.mappedByList(this, f);

  Iterable<int> where(bool f(int element)) =>
      IterableMixinWorkaround.where(this, f);

  bool every(bool f(int element)) => IterableMixinWorkaround.every(this, f);

  bool any(bool f(int element)) => IterableMixinWorkaround.any(this, f);

  List<int> toList() => new List<int>.from(this);
  Set<int> toSet() => new Set<int>.from(this);

  bool get isEmpty => this.length == 0;

  List<int> take(int n) => IterableMixinWorkaround.takeList(this, n);

  Iterable<int> takeWhile(bool test(int value)) {
    return IterableMixinWorkaround.takeWhile(this, test);
  }

  List<int> skip(int n) => IterableMixinWorkaround.skipList(this, n);

  Iterable<int> skipWhile(bool test(int value)) {
    return IterableMixinWorkaround.skipWhile(this, test);
  }

  int firstMatching(bool test(int value), { int orElse() }) {
    return IterableMixinWorkaround.firstMatching(this, test, orElse);
  }

  int lastMatching(bool test(int value), {int orElse()}) {
    return IterableMixinWorkaround.lastMatchingInList(this, test, orElse);
  }

  int singleMatching(bool test(int value)) {
    return IterableMixinWorkaround.singleMatching(this, test);
  }

  int elementAt(int index) {
    return this[index];
  }

  // From Collection<int>:

  void add(int value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addLast(int value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addAll(Iterable<int> iterable) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  // From List<int>:
  void set length(int value) {
    throw new UnsupportedError("Cannot resize immutable List.");
  }

  void clear() {
    throw new UnsupportedError("Cannot clear immutable List.");
  }

  List<int> get reversed =>
      new ReversedListView<int>(this, 0, null);

  void sort([int compare(int a, int b)]) {
    throw new UnsupportedError("Cannot sort immutable List.");
  }

  int indexOf(int element, [int start = 0]) =>
      Lists.indexOf(this, element, start, this.length);

  int lastIndexOf(int element, [int start]) {
    if (start == null) start = length - 1;
    return Lists.lastIndexOf(this, element, start);
  }

  int get first {
    if (this.length > 0) return this[0];
    throw new StateError("No elements");
  }

  int get last {
    if (this.length > 0) return this[this.length - 1];
    throw new StateError("No elements");
  }

  int get single {
    if (length == 1) return this[0];
    if (length == 0) throw new StateError("No elements");
    throw new StateError("More than one element");
  }

  int min([int compare(int a, int b)]) =>
      IterableMixinWorkaround.min(this, compare);

  int max([int compare(int a, int b)]) =>
      IterableMixinWorkaround.max(this, compare);

  int removeAt(int pos) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  int removeLast() {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void remove(Object object) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void removeAll(Iterable elements) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void retainAll(Iterable elements) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void removeMatching(bool test(int element)) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void retainMatching(bool test(int element)) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void setRange(int start, int rangeLength, List<int> from, [int startFrom]) {
    throw new UnsupportedError("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int rangeLength) {
    throw new UnsupportedError("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int rangeLength, [int initialValue]) {
    throw new UnsupportedError("Cannot insertRange on immutable List.");
  }

  List<int> getRange(int start, int rangeLength) =>
      Lists.getRange(this, start, rangeLength, <int>[]);

  // -- end List<int> mixins.

  @DomName('Int32Array.setElements')
  @DocsEditable
  void setElements(Object array, [int offset]) native "Int32Array_setElements_Callback";

  Int32Array subarray(int start, [int end]) {
    if (?end) {
      return _subarray_1(start, end);
    }
    return _subarray_2(start);
  }

  @DomName('Int32Array._subarray_1')
  @DocsEditable
  Int32Array _subarray_1(start, end) native "Int32Array__subarray_1_Callback";

  @DomName('Int32Array._subarray_2')
  @DocsEditable
  Int32Array _subarray_2(start) native "Int32Array__subarray_2_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('Int8Array')
class Int8Array extends ArrayBufferView implements List<int> {
  Int8Array.internal() : super.internal();

  factory Int8Array(int length) =>
    _TypedArrayFactoryProvider.createInt8Array(length);

  factory Int8Array.fromList(List<int> list) =>
    _TypedArrayFactoryProvider.createInt8Array_fromList(list);

  factory Int8Array.fromBuffer(ArrayBuffer buffer, [int byteOffset, int length]) => 
    _TypedArrayFactoryProvider.createInt8Array_fromBuffer(buffer, byteOffset, length);

  static const int BYTES_PER_ELEMENT = 1;

  @DomName('Int8Array.length')
  @DocsEditable
  int get length native "Int8Array_length_Getter";

  @DomName('Int8Array.numericIndexGetter')
  @DocsEditable
  int operator[](int index) native "Int8Array_numericIndexGetter_Callback";

  @DomName('Int8Array.numericIndexSetter')
  @DocsEditable
  void operator[]=(int index, int value) native "Int8Array_numericIndexSetter_Callback";
  // -- start List<int> mixins.
  // int is the element type.

  // From Iterable<int>:

  Iterator<int> get iterator {
    // Note: NodeLists are not fixed size. And most probably length shouldn't
    // be cached in both iterator _and_ forEach method. For now caching it
    // for consistency.
    return new FixedSizeListIterator<int>(this);
  }

  dynamic reduce(dynamic initialValue, dynamic combine(dynamic, int)) {
    return IterableMixinWorkaround.reduce(this, initialValue, combine);
  }

  bool contains(int element) => IterableMixinWorkaround.contains(this, element);

  void forEach(void f(int element)) => IterableMixinWorkaround.forEach(this, f);

  String join([String separator]) =>
      IterableMixinWorkaround.joinList(this, separator);

  List mappedBy(f(int element)) => IterableMixinWorkaround.mappedByList(this, f);

  Iterable<int> where(bool f(int element)) =>
      IterableMixinWorkaround.where(this, f);

  bool every(bool f(int element)) => IterableMixinWorkaround.every(this, f);

  bool any(bool f(int element)) => IterableMixinWorkaround.any(this, f);

  List<int> toList() => new List<int>.from(this);
  Set<int> toSet() => new Set<int>.from(this);

  bool get isEmpty => this.length == 0;

  List<int> take(int n) => IterableMixinWorkaround.takeList(this, n);

  Iterable<int> takeWhile(bool test(int value)) {
    return IterableMixinWorkaround.takeWhile(this, test);
  }

  List<int> skip(int n) => IterableMixinWorkaround.skipList(this, n);

  Iterable<int> skipWhile(bool test(int value)) {
    return IterableMixinWorkaround.skipWhile(this, test);
  }

  int firstMatching(bool test(int value), { int orElse() }) {
    return IterableMixinWorkaround.firstMatching(this, test, orElse);
  }

  int lastMatching(bool test(int value), {int orElse()}) {
    return IterableMixinWorkaround.lastMatchingInList(this, test, orElse);
  }

  int singleMatching(bool test(int value)) {
    return IterableMixinWorkaround.singleMatching(this, test);
  }

  int elementAt(int index) {
    return this[index];
  }

  // From Collection<int>:

  void add(int value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addLast(int value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addAll(Iterable<int> iterable) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  // From List<int>:
  void set length(int value) {
    throw new UnsupportedError("Cannot resize immutable List.");
  }

  void clear() {
    throw new UnsupportedError("Cannot clear immutable List.");
  }

  List<int> get reversed =>
      new ReversedListView<int>(this, 0, null);

  void sort([int compare(int a, int b)]) {
    throw new UnsupportedError("Cannot sort immutable List.");
  }

  int indexOf(int element, [int start = 0]) =>
      Lists.indexOf(this, element, start, this.length);

  int lastIndexOf(int element, [int start]) {
    if (start == null) start = length - 1;
    return Lists.lastIndexOf(this, element, start);
  }

  int get first {
    if (this.length > 0) return this[0];
    throw new StateError("No elements");
  }

  int get last {
    if (this.length > 0) return this[this.length - 1];
    throw new StateError("No elements");
  }

  int get single {
    if (length == 1) return this[0];
    if (length == 0) throw new StateError("No elements");
    throw new StateError("More than one element");
  }

  int min([int compare(int a, int b)]) =>
      IterableMixinWorkaround.min(this, compare);

  int max([int compare(int a, int b)]) =>
      IterableMixinWorkaround.max(this, compare);

  int removeAt(int pos) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  int removeLast() {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void remove(Object object) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void removeAll(Iterable elements) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void retainAll(Iterable elements) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void removeMatching(bool test(int element)) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void retainMatching(bool test(int element)) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void setRange(int start, int rangeLength, List<int> from, [int startFrom]) {
    throw new UnsupportedError("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int rangeLength) {
    throw new UnsupportedError("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int rangeLength, [int initialValue]) {
    throw new UnsupportedError("Cannot insertRange on immutable List.");
  }

  List<int> getRange(int start, int rangeLength) =>
      Lists.getRange(this, start, rangeLength, <int>[]);

  // -- end List<int> mixins.

  @DomName('Int8Array.setElements')
  @DocsEditable
  void setElements(Object array, [int offset]) native "Int8Array_setElements_Callback";

  Int8Array subarray(int start, [int end]) {
    if (?end) {
      return _subarray_1(start, end);
    }
    return _subarray_2(start);
  }

  @DomName('Int8Array._subarray_1')
  @DocsEditable
  Int8Array _subarray_1(start, end) native "Int8Array__subarray_1_Callback";

  @DomName('Int8Array._subarray_2')
  @DocsEditable
  Int8Array _subarray_2(start) native "Int8Array__subarray_2_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('JavaScriptCallFrame')
class JavaScriptCallFrame extends NativeFieldWrapperClass1 {
  JavaScriptCallFrame.internal();

  static const int CATCH_SCOPE = 4;

  static const int CLOSURE_SCOPE = 3;

  static const int GLOBAL_SCOPE = 0;

  static const int LOCAL_SCOPE = 1;

  static const int WITH_SCOPE = 2;

  @DomName('JavaScriptCallFrame.caller')
  @DocsEditable
  JavaScriptCallFrame get caller native "JavaScriptCallFrame_caller_Getter";

  @DomName('JavaScriptCallFrame.column')
  @DocsEditable
  int get column native "JavaScriptCallFrame_column_Getter";

  @DomName('JavaScriptCallFrame.functionName')
  @DocsEditable
  String get functionName native "JavaScriptCallFrame_functionName_Getter";

  @DomName('JavaScriptCallFrame.line')
  @DocsEditable
  int get line native "JavaScriptCallFrame_line_Getter";

  @DomName('JavaScriptCallFrame.scopeChain')
  @DocsEditable
  List get scopeChain native "JavaScriptCallFrame_scopeChain_Getter";

  @DomName('JavaScriptCallFrame.sourceID')
  @DocsEditable
  int get sourceID native "JavaScriptCallFrame_sourceID_Getter";

  @DomName('JavaScriptCallFrame.thisObject')
  @DocsEditable
  Object get thisObject native "JavaScriptCallFrame_thisObject_Getter";

  @DomName('JavaScriptCallFrame.type')
  @DocsEditable
  String get type native "JavaScriptCallFrame_type_Getter";

  @DomName('JavaScriptCallFrame.evaluate')
  @DocsEditable
  void evaluate(String script) native "JavaScriptCallFrame_evaluate_Callback";

  @DomName('JavaScriptCallFrame.restart')
  @DocsEditable
  Object restart() native "JavaScriptCallFrame_restart_Callback";

  @DomName('JavaScriptCallFrame.scopeType')
  @DocsEditable
  int scopeType(int scopeIndex) native "JavaScriptCallFrame_scopeType_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.


@DomName('KeyboardEvent')
class KeyboardEvent extends UIEvent {

  factory KeyboardEvent(String type,
      {Window view, bool canBubble: true, bool cancelable: true,
      String keyIdentifier: "", int keyLocation: 1, bool ctrlKey: false,
      bool altKey: false, bool shiftKey: false, bool metaKey: false,
      bool altGraphKey: false}) {
    if (view == null) {
      view = window;
    }
    final e = document.$dom_createEvent("KeyboardEvent");
    e.$dom_initKeyboardEvent(type, canBubble, cancelable, view, keyIdentifier,
        keyLocation, ctrlKey, altKey, shiftKey, metaKey, altGraphKey);
    return e;
  }

  @DomName('KeyboardEvent.keyCode')
  int get keyCode => $dom_keyCode;

  @DomName('KeyboardEvent.charCode')
  int get charCode => $dom_charCode;
  KeyboardEvent.internal() : super.internal();

  @DomName('KeyboardEvent.altGraphKey')
  @DocsEditable
  bool get altGraphKey native "KeyboardEvent_altGraphKey_Getter";

  @DomName('KeyboardEvent.altKey')
  @DocsEditable
  bool get altKey native "KeyboardEvent_altKey_Getter";

  @DomName('KeyboardEvent.ctrlKey')
  @DocsEditable
  bool get ctrlKey native "KeyboardEvent_ctrlKey_Getter";

  @DomName('KeyboardEvent.keyIdentifier')
  @DocsEditable
  String get $dom_keyIdentifier native "KeyboardEvent_keyIdentifier_Getter";

  @DomName('KeyboardEvent.keyLocation')
  @DocsEditable
  int get keyLocation native "KeyboardEvent_keyLocation_Getter";

  @DomName('KeyboardEvent.metaKey')
  @DocsEditable
  bool get metaKey native "KeyboardEvent_metaKey_Getter";

  @DomName('KeyboardEvent.shiftKey')
  @DocsEditable
  bool get shiftKey native "KeyboardEvent_shiftKey_Getter";

  @DomName('KeyboardEvent.initKeyboardEvent')
  @DocsEditable
  void $dom_initKeyboardEvent(String type, bool canBubble, bool cancelable, Window view, String keyIdentifier, int keyLocation, bool ctrlKey, bool altKey, bool shiftKey, bool metaKey, bool altGraphKey) native "KeyboardEvent_initKeyboardEvent_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('HTMLKeygenElement')
@SupportedBrowser(SupportedBrowser.CHROME)
@SupportedBrowser(SupportedBrowser.SAFARI)
@Experimental
class KeygenElement extends _Element_Merged {
  KeygenElement.internal() : super.internal();

  @DocsEditable
  factory KeygenElement() => document.$dom_createElement("keygen");

  /// Checks if this type is supported on the current platform.
  static bool get supported => true;

  @DomName('HTMLKeygenElement.autofocus')
  @DocsEditable
  bool get autofocus native "HTMLKeygenElement_autofocus_Getter";

  @DomName('HTMLKeygenElement.autofocus')
  @DocsEditable
  void set autofocus(bool value) native "HTMLKeygenElement_autofocus_Setter";

  @DomName('HTMLKeygenElement.challenge')
  @DocsEditable
  String get challenge native "HTMLKeygenElement_challenge_Getter";

  @DomName('HTMLKeygenElement.challenge')
  @DocsEditable
  void set challenge(String value) native "HTMLKeygenElement_challenge_Setter";

  @DomName('HTMLKeygenElement.disabled')
  @DocsEditable
  bool get disabled native "HTMLKeygenElement_disabled_Getter";

  @DomName('HTMLKeygenElement.disabled')
  @DocsEditable
  void set disabled(bool value) native "HTMLKeygenElement_disabled_Setter";

  @DomName('HTMLKeygenElement.form')
  @DocsEditable
  FormElement get form native "HTMLKeygenElement_form_Getter";

  @DomName('HTMLKeygenElement.keytype')
  @DocsEditable
  String get keytype native "HTMLKeygenElement_keytype_Getter";

  @DomName('HTMLKeygenElement.keytype')
  @DocsEditable
  void set keytype(String value) native "HTMLKeygenElement_keytype_Setter";

  @DomName('HTMLKeygenElement.labels')
  @DocsEditable
  List<Node> get labels native "HTMLKeygenElement_labels_Getter";

  @DomName('HTMLKeygenElement.name')
  @DocsEditable
  String get name native "HTMLKeygenElement_name_Getter";

  @DomName('HTMLKeygenElement.name')
  @DocsEditable
  void set name(String value) native "HTMLKeygenElement_name_Setter";

  @DomName('HTMLKeygenElement.type')
  @DocsEditable
  String get type native "HTMLKeygenElement_type_Getter";

  @DomName('HTMLKeygenElement.validationMessage')
  @DocsEditable
  String get validationMessage native "HTMLKeygenElement_validationMessage_Getter";

  @DomName('HTMLKeygenElement.validity')
  @DocsEditable
  ValidityState get validity native "HTMLKeygenElement_validity_Getter";

  @DomName('HTMLKeygenElement.willValidate')
  @DocsEditable
  bool get willValidate native "HTMLKeygenElement_willValidate_Getter";

  @DomName('HTMLKeygenElement.checkValidity')
  @DocsEditable
  bool checkValidity() native "HTMLKeygenElement_checkValidity_Callback";

  @DomName('HTMLKeygenElement.setCustomValidity')
  @DocsEditable
  void setCustomValidity(String error) native "HTMLKeygenElement_setCustomValidity_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('HTMLLIElement')
class LIElement extends _Element_Merged {
  LIElement.internal() : super.internal();

  @DocsEditable
  factory LIElement() => document.$dom_createElement("li");

  @DomName('HTMLLIElement.type')
  @DocsEditable
  String get type native "HTMLLIElement_type_Getter";

  @DomName('HTMLLIElement.type')
  @DocsEditable
  void set type(String value) native "HTMLLIElement_type_Setter";

  @DomName('HTMLLIElement.value')
  @DocsEditable
  int get value native "HTMLLIElement_value_Getter";

  @DomName('HTMLLIElement.value')
  @DocsEditable
  void set value(int value) native "HTMLLIElement_value_Setter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('HTMLLabelElement')
class LabelElement extends _Element_Merged {
  LabelElement.internal() : super.internal();

  @DocsEditable
  factory LabelElement() => document.$dom_createElement("label");

  @DomName('HTMLLabelElement.control')
  @DocsEditable
  Element get control native "HTMLLabelElement_control_Getter";

  @DomName('HTMLLabelElement.form')
  @DocsEditable
  FormElement get form native "HTMLLabelElement_form_Getter";

  @DomName('HTMLLabelElement.htmlFor')
  @DocsEditable
  String get htmlFor native "HTMLLabelElement_htmlFor_Getter";

  @DomName('HTMLLabelElement.htmlFor')
  @DocsEditable
  void set htmlFor(String value) native "HTMLLabelElement_htmlFor_Setter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('HTMLLegendElement')
class LegendElement extends _Element_Merged {
  LegendElement.internal() : super.internal();

  @DocsEditable
  factory LegendElement() => document.$dom_createElement("legend");

  @DomName('HTMLLegendElement.form')
  @DocsEditable
  FormElement get form native "HTMLLegendElement_form_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('HTMLLinkElement')
class LinkElement extends _Element_Merged {
  LinkElement.internal() : super.internal();

  @DocsEditable
  factory LinkElement() => document.$dom_createElement("link");

  @DomName('HTMLLinkElement.disabled')
  @DocsEditable
  bool get disabled native "HTMLLinkElement_disabled_Getter";

  @DomName('HTMLLinkElement.disabled')
  @DocsEditable
  void set disabled(bool value) native "HTMLLinkElement_disabled_Setter";

  @DomName('HTMLLinkElement.href')
  @DocsEditable
  String get href native "HTMLLinkElement_href_Getter";

  @DomName('HTMLLinkElement.href')
  @DocsEditable
  void set href(String value) native "HTMLLinkElement_href_Setter";

  @DomName('HTMLLinkElement.hreflang')
  @DocsEditable
  String get hreflang native "HTMLLinkElement_hreflang_Getter";

  @DomName('HTMLLinkElement.hreflang')
  @DocsEditable
  void set hreflang(String value) native "HTMLLinkElement_hreflang_Setter";

  @DomName('HTMLLinkElement.media')
  @DocsEditable
  String get media native "HTMLLinkElement_media_Getter";

  @DomName('HTMLLinkElement.media')
  @DocsEditable
  void set media(String value) native "HTMLLinkElement_media_Setter";

  @DomName('HTMLLinkElement.rel')
  @DocsEditable
  String get rel native "HTMLLinkElement_rel_Getter";

  @DomName('HTMLLinkElement.rel')
  @DocsEditable
  void set rel(String value) native "HTMLLinkElement_rel_Setter";

  @DomName('HTMLLinkElement.sheet')
  @DocsEditable
  StyleSheet get sheet native "HTMLLinkElement_sheet_Getter";

  @DomName('HTMLLinkElement.sizes')
  @DocsEditable
  DomSettableTokenList get sizes native "HTMLLinkElement_sizes_Getter";

  @DomName('HTMLLinkElement.sizes')
  @DocsEditable
  void set sizes(DomSettableTokenList value) native "HTMLLinkElement_sizes_Setter";

  @DomName('HTMLLinkElement.type')
  @DocsEditable
  String get type native "HTMLLinkElement_type_Getter";

  @DomName('HTMLLinkElement.type')
  @DocsEditable
  void set type(String value) native "HTMLLinkElement_type_Setter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('LocalMediaStream')
class LocalMediaStream extends MediaStream implements EventTarget {
  LocalMediaStream.internal() : super.internal();

  @DomName('LocalMediaStream.stop')
  @DocsEditable
  void stop() native "LocalMediaStream_stop_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('Location')
class Location extends NativeFieldWrapperClass1 implements LocationBase {
  Location.internal();

  @DomName('Location.ancestorOrigins')
  @DocsEditable
  List<String> get ancestorOrigins native "Location_ancestorOrigins_Getter";

  @DomName('Location.hash')
  @DocsEditable
  String get hash native "Location_hash_Getter";

  @DomName('Location.hash')
  @DocsEditable
  void set hash(String value) native "Location_hash_Setter";

  @DomName('Location.host')
  @DocsEditable
  String get host native "Location_host_Getter";

  @DomName('Location.host')
  @DocsEditable
  void set host(String value) native "Location_host_Setter";

  @DomName('Location.hostname')
  @DocsEditable
  String get hostname native "Location_hostname_Getter";

  @DomName('Location.hostname')
  @DocsEditable
  void set hostname(String value) native "Location_hostname_Setter";

  @DomName('Location.href')
  @DocsEditable
  String get href native "Location_href_Getter";

  @DomName('Location.href')
  @DocsEditable
  void set href(String value) native "Location_href_Setter";

  @DomName('Location.origin')
  @DocsEditable
  String get origin native "Location_origin_Getter";

  @DomName('Location.pathname')
  @DocsEditable
  String get pathname native "Location_pathname_Getter";

  @DomName('Location.pathname')
  @DocsEditable
  void set pathname(String value) native "Location_pathname_Setter";

  @DomName('Location.port')
  @DocsEditable
  String get port native "Location_port_Getter";

  @DomName('Location.port')
  @DocsEditable
  void set port(String value) native "Location_port_Setter";

  @DomName('Location.protocol')
  @DocsEditable
  String get protocol native "Location_protocol_Getter";

  @DomName('Location.protocol')
  @DocsEditable
  void set protocol(String value) native "Location_protocol_Setter";

  @DomName('Location.search')
  @DocsEditable
  String get search native "Location_search_Getter";

  @DomName('Location.search')
  @DocsEditable
  void set search(String value) native "Location_search_Setter";

  @DomName('Location.assign')
  @DocsEditable
  void assign(String url) native "Location_assign_Callback";

  @DomName('Location.reload')
  @DocsEditable
  void reload() native "Location_reload_Callback";

  @DomName('Location.replace')
  @DocsEditable
  void replace(String url) native "Location_replace_Callback";

  @DomName('Location.toString')
  @DocsEditable
  String toString() native "Location_toString_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('HTMLMapElement')
class MapElement extends _Element_Merged {
  MapElement.internal() : super.internal();

  @DocsEditable
  factory MapElement() => document.$dom_createElement("map");

  @DomName('HTMLMapElement.areas')
  @DocsEditable
  HtmlCollection get areas native "HTMLMapElement_areas_Getter";

  @DomName('HTMLMapElement.name')
  @DocsEditable
  String get name native "HTMLMapElement_name_Getter";

  @DomName('HTMLMapElement.name')
  @DocsEditable
  void set name(String value) native "HTMLMapElement_name_Setter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('MediaController')
class MediaController extends EventTarget {
  MediaController.internal() : super.internal();

  @DocsEditable
  factory MediaController() => MediaController._create();
  static MediaController _create() native "MediaController_constructor_Callback";

  @DomName('MediaController.buffered')
  @DocsEditable
  TimeRanges get buffered native "MediaController_buffered_Getter";

  @DomName('MediaController.currentTime')
  @DocsEditable
  num get currentTime native "MediaController_currentTime_Getter";

  @DomName('MediaController.currentTime')
  @DocsEditable
  void set currentTime(num value) native "MediaController_currentTime_Setter";

  @DomName('MediaController.defaultPlaybackRate')
  @DocsEditable
  num get defaultPlaybackRate native "MediaController_defaultPlaybackRate_Getter";

  @DomName('MediaController.defaultPlaybackRate')
  @DocsEditable
  void set defaultPlaybackRate(num value) native "MediaController_defaultPlaybackRate_Setter";

  @DomName('MediaController.duration')
  @DocsEditable
  num get duration native "MediaController_duration_Getter";

  @DomName('MediaController.muted')
  @DocsEditable
  bool get muted native "MediaController_muted_Getter";

  @DomName('MediaController.muted')
  @DocsEditable
  void set muted(bool value) native "MediaController_muted_Setter";

  @DomName('MediaController.paused')
  @DocsEditable
  bool get paused native "MediaController_paused_Getter";

  @DomName('MediaController.playbackRate')
  @DocsEditable
  num get playbackRate native "MediaController_playbackRate_Getter";

  @DomName('MediaController.playbackRate')
  @DocsEditable
  void set playbackRate(num value) native "MediaController_playbackRate_Setter";

  @DomName('MediaController.playbackState')
  @DocsEditable
  String get playbackState native "MediaController_playbackState_Getter";

  @DomName('MediaController.played')
  @DocsEditable
  TimeRanges get played native "MediaController_played_Getter";

  @DomName('MediaController.seekable')
  @DocsEditable
  TimeRanges get seekable native "MediaController_seekable_Getter";

  @DomName('MediaController.volume')
  @DocsEditable
  num get volume native "MediaController_volume_Getter";

  @DomName('MediaController.volume')
  @DocsEditable
  void set volume(num value) native "MediaController_volume_Setter";

  @DomName('MediaController.addEventListener')
  @DocsEditable
  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]) native "MediaController_addEventListener_Callback";

  @DomName('MediaController.dispatchEvent')
  @DocsEditable
  bool dispatchEvent(Event evt) native "MediaController_dispatchEvent_Callback";

  @DomName('MediaController.pause')
  @DocsEditable
  void pause() native "MediaController_pause_Callback";

  @DomName('MediaController.play')
  @DocsEditable
  void play() native "MediaController_play_Callback";

  @DomName('MediaController.removeEventListener')
  @DocsEditable
  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]) native "MediaController_removeEventListener_Callback";

  @DomName('MediaController.unpause')
  @DocsEditable
  void unpause() native "MediaController_unpause_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('HTMLMediaElement')
class MediaElement extends _Element_Merged {
  MediaElement.internal() : super.internal();

  @DomName('HTMLMediaElement.canplay')
  @DocsEditable
  static const EventStreamProvider<Event> canPlayEvent = const EventStreamProvider<Event>('canplay');

  @DomName('HTMLMediaElement.canplaythrough')
  @DocsEditable
  static const EventStreamProvider<Event> canPlayThroughEvent = const EventStreamProvider<Event>('canplaythrough');

  @DomName('HTMLMediaElement.durationchange')
  @DocsEditable
  static const EventStreamProvider<Event> durationChangeEvent = const EventStreamProvider<Event>('durationchange');

  @DomName('HTMLMediaElement.emptied')
  @DocsEditable
  static const EventStreamProvider<Event> emptiedEvent = const EventStreamProvider<Event>('emptied');

  @DomName('HTMLMediaElement.ended')
  @DocsEditable
  static const EventStreamProvider<Event> endedEvent = const EventStreamProvider<Event>('ended');

  @DomName('HTMLMediaElement.loadeddata')
  @DocsEditable
  static const EventStreamProvider<Event> loadedDataEvent = const EventStreamProvider<Event>('loadeddata');

  @DomName('HTMLMediaElement.loadedmetadata')
  @DocsEditable
  static const EventStreamProvider<Event> loadedMetadataEvent = const EventStreamProvider<Event>('loadedmetadata');

  @DomName('HTMLMediaElement.loadstart')
  @DocsEditable
  static const EventStreamProvider<Event> loadStartEvent = const EventStreamProvider<Event>('loadstart');

  @DomName('HTMLMediaElement.pause')
  @DocsEditable
  static const EventStreamProvider<Event> pauseEvent = const EventStreamProvider<Event>('pause');

  @DomName('HTMLMediaElement.play')
  @DocsEditable
  static const EventStreamProvider<Event> playEvent = const EventStreamProvider<Event>('play');

  @DomName('HTMLMediaElement.playing')
  @DocsEditable
  static const EventStreamProvider<Event> playingEvent = const EventStreamProvider<Event>('playing');

  @DomName('HTMLMediaElement.progress')
  @DocsEditable
  static const EventStreamProvider<Event> progressEvent = const EventStreamProvider<Event>('progress');

  @DomName('HTMLMediaElement.ratechange')
  @DocsEditable
  static const EventStreamProvider<Event> rateChangeEvent = const EventStreamProvider<Event>('ratechange');

  @DomName('HTMLMediaElement.seeked')
  @DocsEditable
  static const EventStreamProvider<Event> seekedEvent = const EventStreamProvider<Event>('seeked');

  @DomName('HTMLMediaElement.seeking')
  @DocsEditable
  static const EventStreamProvider<Event> seekingEvent = const EventStreamProvider<Event>('seeking');

  @DomName('HTMLMediaElement.show')
  @DocsEditable
  static const EventStreamProvider<Event> showEvent = const EventStreamProvider<Event>('show');

  @DomName('HTMLMediaElement.stalled')
  @DocsEditable
  static const EventStreamProvider<Event> stalledEvent = const EventStreamProvider<Event>('stalled');

  @DomName('HTMLMediaElement.suspend')
  @DocsEditable
  static const EventStreamProvider<Event> suspendEvent = const EventStreamProvider<Event>('suspend');

  @DomName('HTMLMediaElement.timeupdate')
  @DocsEditable
  static const EventStreamProvider<Event> timeUpdateEvent = const EventStreamProvider<Event>('timeupdate');

  @DomName('HTMLMediaElement.volumechange')
  @DocsEditable
  static const EventStreamProvider<Event> volumeChangeEvent = const EventStreamProvider<Event>('volumechange');

  @DomName('HTMLMediaElement.waiting')
  @DocsEditable
  static const EventStreamProvider<Event> waitingEvent = const EventStreamProvider<Event>('waiting');

  @DomName('HTMLMediaElement.webkitkeyadded')
  @DocsEditable
  static const EventStreamProvider<MediaKeyEvent> keyAddedEvent = const EventStreamProvider<MediaKeyEvent>('webkitkeyadded');

  @DomName('HTMLMediaElement.webkitkeyerror')
  @DocsEditable
  static const EventStreamProvider<MediaKeyEvent> keyErrorEvent = const EventStreamProvider<MediaKeyEvent>('webkitkeyerror');

  @DomName('HTMLMediaElement.webkitkeymessage')
  @DocsEditable
  static const EventStreamProvider<MediaKeyEvent> keyMessageEvent = const EventStreamProvider<MediaKeyEvent>('webkitkeymessage');

  @DomName('HTMLMediaElement.webkitneedkey')
  @DocsEditable
  static const EventStreamProvider<MediaKeyEvent> needKeyEvent = const EventStreamProvider<MediaKeyEvent>('webkitneedkey');

  @DocsEditable
  @DomName('EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent')
  @deprecated
  MediaElementEvents get on =>
    new MediaElementEvents(this);

  static const int HAVE_CURRENT_DATA = 2;

  static const int HAVE_ENOUGH_DATA = 4;

  static const int HAVE_FUTURE_DATA = 3;

  static const int HAVE_METADATA = 1;

  static const int HAVE_NOTHING = 0;

  static const int NETWORK_EMPTY = 0;

  static const int NETWORK_IDLE = 1;

  static const int NETWORK_LOADING = 2;

  static const int NETWORK_NO_SOURCE = 3;

  @DomName('HTMLMediaElement.autoplay')
  @DocsEditable
  bool get autoplay native "HTMLMediaElement_autoplay_Getter";

  @DomName('HTMLMediaElement.autoplay')
  @DocsEditable
  void set autoplay(bool value) native "HTMLMediaElement_autoplay_Setter";

  @DomName('HTMLMediaElement.buffered')
  @DocsEditable
  TimeRanges get buffered native "HTMLMediaElement_buffered_Getter";

  @DomName('HTMLMediaElement.controller')
  @DocsEditable
  MediaController get controller native "HTMLMediaElement_controller_Getter";

  @DomName('HTMLMediaElement.controller')
  @DocsEditable
  void set controller(MediaController value) native "HTMLMediaElement_controller_Setter";

  @DomName('HTMLMediaElement.controls')
  @DocsEditable
  bool get controls native "HTMLMediaElement_controls_Getter";

  @DomName('HTMLMediaElement.controls')
  @DocsEditable
  void set controls(bool value) native "HTMLMediaElement_controls_Setter";

  @DomName('HTMLMediaElement.currentSrc')
  @DocsEditable
  String get currentSrc native "HTMLMediaElement_currentSrc_Getter";

  @DomName('HTMLMediaElement.currentTime')
  @DocsEditable
  num get currentTime native "HTMLMediaElement_currentTime_Getter";

  @DomName('HTMLMediaElement.currentTime')
  @DocsEditable
  void set currentTime(num value) native "HTMLMediaElement_currentTime_Setter";

  @DomName('HTMLMediaElement.defaultMuted')
  @DocsEditable
  bool get defaultMuted native "HTMLMediaElement_defaultMuted_Getter";

  @DomName('HTMLMediaElement.defaultMuted')
  @DocsEditable
  void set defaultMuted(bool value) native "HTMLMediaElement_defaultMuted_Setter";

  @DomName('HTMLMediaElement.defaultPlaybackRate')
  @DocsEditable
  num get defaultPlaybackRate native "HTMLMediaElement_defaultPlaybackRate_Getter";

  @DomName('HTMLMediaElement.defaultPlaybackRate')
  @DocsEditable
  void set defaultPlaybackRate(num value) native "HTMLMediaElement_defaultPlaybackRate_Setter";

  @DomName('HTMLMediaElement.duration')
  @DocsEditable
  num get duration native "HTMLMediaElement_duration_Getter";

  @DomName('HTMLMediaElement.ended')
  @DocsEditable
  bool get ended native "HTMLMediaElement_ended_Getter";

  @DomName('HTMLMediaElement.error')
  @DocsEditable
  MediaError get error native "HTMLMediaElement_error_Getter";

  @DomName('HTMLMediaElement.initialTime')
  @DocsEditable
  num get initialTime native "HTMLMediaElement_initialTime_Getter";

  @DomName('HTMLMediaElement.loop')
  @DocsEditable
  bool get loop native "HTMLMediaElement_loop_Getter";

  @DomName('HTMLMediaElement.loop')
  @DocsEditable
  void set loop(bool value) native "HTMLMediaElement_loop_Setter";

  @DomName('HTMLMediaElement.mediaGroup')
  @DocsEditable
  String get mediaGroup native "HTMLMediaElement_mediaGroup_Getter";

  @DomName('HTMLMediaElement.mediaGroup')
  @DocsEditable
  void set mediaGroup(String value) native "HTMLMediaElement_mediaGroup_Setter";

  @DomName('HTMLMediaElement.muted')
  @DocsEditable
  bool get muted native "HTMLMediaElement_muted_Getter";

  @DomName('HTMLMediaElement.muted')
  @DocsEditable
  void set muted(bool value) native "HTMLMediaElement_muted_Setter";

  @DomName('HTMLMediaElement.networkState')
  @DocsEditable
  int get networkState native "HTMLMediaElement_networkState_Getter";

  @DomName('HTMLMediaElement.paused')
  @DocsEditable
  bool get paused native "HTMLMediaElement_paused_Getter";

  @DomName('HTMLMediaElement.playbackRate')
  @DocsEditable
  num get playbackRate native "HTMLMediaElement_playbackRate_Getter";

  @DomName('HTMLMediaElement.playbackRate')
  @DocsEditable
  void set playbackRate(num value) native "HTMLMediaElement_playbackRate_Setter";

  @DomName('HTMLMediaElement.played')
  @DocsEditable
  TimeRanges get played native "HTMLMediaElement_played_Getter";

  @DomName('HTMLMediaElement.preload')
  @DocsEditable
  String get preload native "HTMLMediaElement_preload_Getter";

  @DomName('HTMLMediaElement.preload')
  @DocsEditable
  void set preload(String value) native "HTMLMediaElement_preload_Setter";

  @DomName('HTMLMediaElement.readyState')
  @DocsEditable
  int get readyState native "HTMLMediaElement_readyState_Getter";

  @DomName('HTMLMediaElement.seekable')
  @DocsEditable
  TimeRanges get seekable native "HTMLMediaElement_seekable_Getter";

  @DomName('HTMLMediaElement.seeking')
  @DocsEditable
  bool get seeking native "HTMLMediaElement_seeking_Getter";

  @DomName('HTMLMediaElement.src')
  @DocsEditable
  String get src native "HTMLMediaElement_src_Getter";

  @DomName('HTMLMediaElement.src')
  @DocsEditable
  void set src(String value) native "HTMLMediaElement_src_Setter";

  @DomName('HTMLMediaElement.startTime')
  @DocsEditable
  num get startTime native "HTMLMediaElement_startTime_Getter";

  @DomName('HTMLMediaElement.textTracks')
  @DocsEditable
  TextTrackList get textTracks native "HTMLMediaElement_textTracks_Getter";

  @DomName('HTMLMediaElement.volume')
  @DocsEditable
  num get volume native "HTMLMediaElement_volume_Getter";

  @DomName('HTMLMediaElement.volume')
  @DocsEditable
  void set volume(num value) native "HTMLMediaElement_volume_Setter";

  @DomName('HTMLMediaElement.webkitAudioDecodedByteCount')
  @DocsEditable
  int get webkitAudioDecodedByteCount native "HTMLMediaElement_webkitAudioDecodedByteCount_Getter";

  @DomName('HTMLMediaElement.webkitClosedCaptionsVisible')
  @DocsEditable
  bool get webkitClosedCaptionsVisible native "HTMLMediaElement_webkitClosedCaptionsVisible_Getter";

  @DomName('HTMLMediaElement.webkitClosedCaptionsVisible')
  @DocsEditable
  void set webkitClosedCaptionsVisible(bool value) native "HTMLMediaElement_webkitClosedCaptionsVisible_Setter";

  @DomName('HTMLMediaElement.webkitHasClosedCaptions')
  @DocsEditable
  bool get webkitHasClosedCaptions native "HTMLMediaElement_webkitHasClosedCaptions_Getter";

  @DomName('HTMLMediaElement.webkitPreservesPitch')
  @DocsEditable
  bool get webkitPreservesPitch native "HTMLMediaElement_webkitPreservesPitch_Getter";

  @DomName('HTMLMediaElement.webkitPreservesPitch')
  @DocsEditable
  void set webkitPreservesPitch(bool value) native "HTMLMediaElement_webkitPreservesPitch_Setter";

  @DomName('HTMLMediaElement.webkitVideoDecodedByteCount')
  @DocsEditable
  int get webkitVideoDecodedByteCount native "HTMLMediaElement_webkitVideoDecodedByteCount_Getter";

  TextTrack addTextTrack(String kind, [String label, String language]) {
    if (?language) {
      return _addTextTrack_1(kind, label, language);
    }
    if (?label) {
      return _addTextTrack_2(kind, label);
    }
    return _addTextTrack_3(kind);
  }

  @DomName('HTMLMediaElement._addTextTrack_1')
  @DocsEditable
  TextTrack _addTextTrack_1(kind, label, language) native "HTMLMediaElement__addTextTrack_1_Callback";

  @DomName('HTMLMediaElement._addTextTrack_2')
  @DocsEditable
  TextTrack _addTextTrack_2(kind, label) native "HTMLMediaElement__addTextTrack_2_Callback";

  @DomName('HTMLMediaElement._addTextTrack_3')
  @DocsEditable
  TextTrack _addTextTrack_3(kind) native "HTMLMediaElement__addTextTrack_3_Callback";

  @DomName('HTMLMediaElement.canPlayType')
  @DocsEditable
  String canPlayType(String type, String keySystem) native "HTMLMediaElement_canPlayType_Callback";

  @DomName('HTMLMediaElement.load')
  @DocsEditable
  void load() native "HTMLMediaElement_load_Callback";

  @DomName('HTMLMediaElement.pause')
  @DocsEditable
  void pause() native "HTMLMediaElement_pause_Callback";

  @DomName('HTMLMediaElement.play')
  @DocsEditable
  void play() native "HTMLMediaElement_play_Callback";

  void webkitAddKey(String keySystem, Uint8Array key, [Uint8Array initData, String sessionId]) {
    if (?initData) {
      _webkitAddKey_1(keySystem, key, initData, sessionId);
      return;
    }
    _webkitAddKey_2(keySystem, key);
    return;
  }

  @DomName('HTMLMediaElement._webkitAddKey_1')
  @DocsEditable
  void _webkitAddKey_1(keySystem, key, initData, sessionId) native "HTMLMediaElement__webkitAddKey_1_Callback";

  @DomName('HTMLMediaElement._webkitAddKey_2')
  @DocsEditable
  void _webkitAddKey_2(keySystem, key) native "HTMLMediaElement__webkitAddKey_2_Callback";

  @DomName('HTMLMediaElement.webkitCancelKeyRequest')
  @DocsEditable
  void webkitCancelKeyRequest(String keySystem, String sessionId) native "HTMLMediaElement_webkitCancelKeyRequest_Callback";

  void webkitGenerateKeyRequest(String keySystem, [Uint8Array initData]) {
    if (?initData) {
      _webkitGenerateKeyRequest_1(keySystem, initData);
      return;
    }
    _webkitGenerateKeyRequest_2(keySystem);
    return;
  }

  @DomName('HTMLMediaElement._webkitGenerateKeyRequest_1')
  @DocsEditable
  void _webkitGenerateKeyRequest_1(keySystem, initData) native "HTMLMediaElement__webkitGenerateKeyRequest_1_Callback";

  @DomName('HTMLMediaElement._webkitGenerateKeyRequest_2')
  @DocsEditable
  void _webkitGenerateKeyRequest_2(keySystem) native "HTMLMediaElement__webkitGenerateKeyRequest_2_Callback";

  @DomName('HTMLMediaElement.canplay')
  @DocsEditable
  Stream<Event> get onCanPlay => canPlayEvent.forTarget(this);

  @DomName('HTMLMediaElement.canplaythrough')
  @DocsEditable
  Stream<Event> get onCanPlayThrough => canPlayThroughEvent.forTarget(this);

  @DomName('HTMLMediaElement.durationchange')
  @DocsEditable
  Stream<Event> get onDurationChange => durationChangeEvent.forTarget(this);

  @DomName('HTMLMediaElement.emptied')
  @DocsEditable
  Stream<Event> get onEmptied => emptiedEvent.forTarget(this);

  @DomName('HTMLMediaElement.ended')
  @DocsEditable
  Stream<Event> get onEnded => endedEvent.forTarget(this);

  @DomName('HTMLMediaElement.loadeddata')
  @DocsEditable
  Stream<Event> get onLoadedData => loadedDataEvent.forTarget(this);

  @DomName('HTMLMediaElement.loadedmetadata')
  @DocsEditable
  Stream<Event> get onLoadedMetadata => loadedMetadataEvent.forTarget(this);

  @DomName('HTMLMediaElement.loadstart')
  @DocsEditable
  Stream<Event> get onLoadStart => loadStartEvent.forTarget(this);

  @DomName('HTMLMediaElement.pause')
  @DocsEditable
  Stream<Event> get onPause => pauseEvent.forTarget(this);

  @DomName('HTMLMediaElement.play')
  @DocsEditable
  Stream<Event> get onPlay => playEvent.forTarget(this);

  @DomName('HTMLMediaElement.playing')
  @DocsEditable
  Stream<Event> get onPlaying => playingEvent.forTarget(this);

  @DomName('HTMLMediaElement.progress')
  @DocsEditable
  Stream<Event> get onProgress => progressEvent.forTarget(this);

  @DomName('HTMLMediaElement.ratechange')
  @DocsEditable
  Stream<Event> get onRateChange => rateChangeEvent.forTarget(this);

  @DomName('HTMLMediaElement.seeked')
  @DocsEditable
  Stream<Event> get onSeeked => seekedEvent.forTarget(this);

  @DomName('HTMLMediaElement.seeking')
  @DocsEditable
  Stream<Event> get onSeeking => seekingEvent.forTarget(this);

  @DomName('HTMLMediaElement.show')
  @DocsEditable
  Stream<Event> get onShow => showEvent.forTarget(this);

  @DomName('HTMLMediaElement.stalled')
  @DocsEditable
  Stream<Event> get onStalled => stalledEvent.forTarget(this);

  @DomName('HTMLMediaElement.suspend')
  @DocsEditable
  Stream<Event> get onSuspend => suspendEvent.forTarget(this);

  @DomName('HTMLMediaElement.timeupdate')
  @DocsEditable
  Stream<Event> get onTimeUpdate => timeUpdateEvent.forTarget(this);

  @DomName('HTMLMediaElement.volumechange')
  @DocsEditable
  Stream<Event> get onVolumeChange => volumeChangeEvent.forTarget(this);

  @DomName('HTMLMediaElement.waiting')
  @DocsEditable
  Stream<Event> get onWaiting => waitingEvent.forTarget(this);

  @DomName('HTMLMediaElement.webkitkeyadded')
  @DocsEditable
  Stream<MediaKeyEvent> get onKeyAdded => keyAddedEvent.forTarget(this);

  @DomName('HTMLMediaElement.webkitkeyerror')
  @DocsEditable
  Stream<MediaKeyEvent> get onKeyError => keyErrorEvent.forTarget(this);

  @DomName('HTMLMediaElement.webkitkeymessage')
  @DocsEditable
  Stream<MediaKeyEvent> get onKeyMessage => keyMessageEvent.forTarget(this);

  @DomName('HTMLMediaElement.webkitneedkey')
  @DocsEditable
  Stream<MediaKeyEvent> get onNeedKey => needKeyEvent.forTarget(this);

}

@DocsEditable
@deprecated
class MediaElementEvents extends ElementEvents {
  @DocsEditable
  MediaElementEvents(EventTarget _ptr) : super(_ptr);

  @DocsEditable
  EventListenerList get canPlay => this['canplay'];

  @DocsEditable
  EventListenerList get canPlayThrough => this['canplaythrough'];

  @DocsEditable
  EventListenerList get durationChange => this['durationchange'];

  @DocsEditable
  EventListenerList get emptied => this['emptied'];

  @DocsEditable
  EventListenerList get ended => this['ended'];

  @DocsEditable
  EventListenerList get loadedData => this['loadeddata'];

  @DocsEditable
  EventListenerList get loadedMetadata => this['loadedmetadata'];

  @DocsEditable
  EventListenerList get loadStart => this['loadstart'];

  @DocsEditable
  EventListenerList get pause => this['pause'];

  @DocsEditable
  EventListenerList get play => this['play'];

  @DocsEditable
  EventListenerList get playing => this['playing'];

  @DocsEditable
  EventListenerList get progress => this['progress'];

  @DocsEditable
  EventListenerList get rateChange => this['ratechange'];

  @DocsEditable
  EventListenerList get seeked => this['seeked'];

  @DocsEditable
  EventListenerList get seeking => this['seeking'];

  @DocsEditable
  EventListenerList get show => this['show'];

  @DocsEditable
  EventListenerList get stalled => this['stalled'];

  @DocsEditable
  EventListenerList get suspend => this['suspend'];

  @DocsEditable
  EventListenerList get timeUpdate => this['timeupdate'];

  @DocsEditable
  EventListenerList get volumeChange => this['volumechange'];

  @DocsEditable
  EventListenerList get waiting => this['waiting'];

  @DocsEditable
  EventListenerList get keyAdded => this['webkitkeyadded'];

  @DocsEditable
  EventListenerList get keyError => this['webkitkeyerror'];

  @DocsEditable
  EventListenerList get keyMessage => this['webkitkeymessage'];

  @DocsEditable
  EventListenerList get needKey => this['webkitneedkey'];
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('MediaError')
class MediaError extends NativeFieldWrapperClass1 {
  MediaError.internal();

  static const int MEDIA_ERR_ABORTED = 1;

  static const int MEDIA_ERR_DECODE = 3;

  static const int MEDIA_ERR_ENCRYPTED = 5;

  static const int MEDIA_ERR_NETWORK = 2;

  static const int MEDIA_ERR_SRC_NOT_SUPPORTED = 4;

  @DomName('MediaError.code')
  @DocsEditable
  int get code native "MediaError_code_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('MediaKeyError')
class MediaKeyError extends NativeFieldWrapperClass1 {
  MediaKeyError.internal();

  static const int MEDIA_KEYERR_CLIENT = 2;

  static const int MEDIA_KEYERR_DOMAIN = 6;

  static const int MEDIA_KEYERR_HARDWARECHANGE = 5;

  static const int MEDIA_KEYERR_OUTPUT = 4;

  static const int MEDIA_KEYERR_SERVICE = 3;

  static const int MEDIA_KEYERR_UNKNOWN = 1;

  @DomName('MediaKeyError.code')
  @DocsEditable
  int get code native "MediaKeyError_code_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('MediaKeyEvent')
class MediaKeyEvent extends Event {
  MediaKeyEvent.internal() : super.internal();

  @DomName('MediaKeyEvent.defaultURL')
  @DocsEditable
  String get defaultUrl native "MediaKeyEvent_defaultURL_Getter";

  @DomName('MediaKeyEvent.errorCode')
  @DocsEditable
  MediaKeyError get errorCode native "MediaKeyEvent_errorCode_Getter";

  @DomName('MediaKeyEvent.initData')
  @DocsEditable
  Uint8Array get initData native "MediaKeyEvent_initData_Getter";

  @DomName('MediaKeyEvent.keySystem')
  @DocsEditable
  String get keySystem native "MediaKeyEvent_keySystem_Getter";

  @DomName('MediaKeyEvent.message')
  @DocsEditable
  Uint8Array get message native "MediaKeyEvent_message_Getter";

  @DomName('MediaKeyEvent.sessionId')
  @DocsEditable
  String get sessionId native "MediaKeyEvent_sessionId_Getter";

  @DomName('MediaKeyEvent.systemCode')
  @DocsEditable
  int get systemCode native "MediaKeyEvent_systemCode_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('MediaList')
class MediaList extends NativeFieldWrapperClass1 {
  MediaList.internal();

  @DomName('MediaList.length')
  @DocsEditable
  int get length native "MediaList_length_Getter";

  @DomName('MediaList.mediaText')
  @DocsEditable
  String get mediaText native "MediaList_mediaText_Getter";

  @DomName('MediaList.mediaText')
  @DocsEditable
  void set mediaText(String value) native "MediaList_mediaText_Setter";

  @DomName('MediaList.appendMedium')
  @DocsEditable
  void appendMedium(String newMedium) native "MediaList_appendMedium_Callback";

  @DomName('MediaList.deleteMedium')
  @DocsEditable
  void deleteMedium(String oldMedium) native "MediaList_deleteMedium_Callback";

  @DomName('MediaList.item')
  @DocsEditable
  String item(int index) native "MediaList_item_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('MediaQueryList')
class MediaQueryList extends NativeFieldWrapperClass1 {
  MediaQueryList.internal();

  @DomName('MediaQueryList.matches')
  @DocsEditable
  bool get matches native "MediaQueryList_matches_Getter";

  @DomName('MediaQueryList.media')
  @DocsEditable
  String get media native "MediaQueryList_media_Getter";

  @DomName('MediaQueryList.addListener')
  @DocsEditable
  void addListener(MediaQueryListListener listener) native "MediaQueryList_addListener_Callback";

  @DomName('MediaQueryList.removeListener')
  @DocsEditable
  void removeListener(MediaQueryListListener listener) native "MediaQueryList_removeListener_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('MediaQueryListListener')
class MediaQueryListListener extends NativeFieldWrapperClass1 {
  MediaQueryListListener.internal();

  @DomName('MediaQueryListListener.queryChanged')
  @DocsEditable
  void queryChanged(MediaQueryList list) native "MediaQueryListListener_queryChanged_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('MediaSource')
class MediaSource extends EventTarget {
  MediaSource.internal() : super.internal();

  @DocsEditable
  factory MediaSource() => MediaSource._create();
  static MediaSource _create() native "MediaSource_constructor_Callback";

  @DomName('MediaSource.activeSourceBuffers')
  @DocsEditable
  SourceBufferList get activeSourceBuffers native "MediaSource_activeSourceBuffers_Getter";

  @DomName('MediaSource.duration')
  @DocsEditable
  num get duration native "MediaSource_duration_Getter";

  @DomName('MediaSource.duration')
  @DocsEditable
  void set duration(num value) native "MediaSource_duration_Setter";

  @DomName('MediaSource.readyState')
  @DocsEditable
  String get readyState native "MediaSource_readyState_Getter";

  @DomName('MediaSource.sourceBuffers')
  @DocsEditable
  SourceBufferList get sourceBuffers native "MediaSource_sourceBuffers_Getter";

  @DomName('MediaSource.addEventListener')
  @DocsEditable
  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]) native "MediaSource_addEventListener_Callback";

  @DomName('MediaSource.addSourceBuffer')
  @DocsEditable
  SourceBuffer addSourceBuffer(String type) native "MediaSource_addSourceBuffer_Callback";

  @DomName('MediaSource.dispatchEvent')
  @DocsEditable
  bool dispatchEvent(Event event) native "MediaSource_dispatchEvent_Callback";

  @DomName('MediaSource.endOfStream')
  @DocsEditable
  void endOfStream(String error) native "MediaSource_endOfStream_Callback";

  @DomName('MediaSource.removeEventListener')
  @DocsEditable
  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]) native "MediaSource_removeEventListener_Callback";

  @DomName('MediaSource.removeSourceBuffer')
  @DocsEditable
  void removeSourceBuffer(SourceBuffer buffer) native "MediaSource_removeSourceBuffer_Callback";

}
// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.


/// @domName MediaStream; @docsEditable true@DomName('MediaStream')

class MediaStream extends EventTarget {
  MediaStream.internal() : super.internal();

  @DomName('MediaStream.ended')
  @DocsEditable
  static const EventStreamProvider<Event> endedEvent = const EventStreamProvider<Event>('ended');

  @DocsEditable
  factory MediaStream() => MediaStream._create();
  static MediaStream _create() native "MediaStream_constructor_Callback";

  @DocsEditable
  @DomName('EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent')
  @deprecated
  MediaStreamEvents get on =>
    new MediaStreamEvents(this);

  @DomName('MediaStream.ended')
  @DocsEditable
  bool get ended native "MediaStream_ended_Getter";

  @DomName('MediaStream.id')
  @DocsEditable
  String get id native "MediaStream_id_Getter";

  @DomName('MediaStream.label')
  @DocsEditable
  String get label native "MediaStream_label_Getter";

  @DomName('MediaStream.addEventListener')
  @DocsEditable
  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]) native "MediaStream_addEventListener_Callback";

  @DomName('MediaStream.addTrack')
  @DocsEditable
  void addTrack(MediaStreamTrack track) native "MediaStream_addTrack_Callback";

  @DomName('MediaStream.dispatchEvent')
  @DocsEditable
  bool dispatchEvent(Event event) native "MediaStream_dispatchEvent_Callback";

  @DomName('MediaStream.getAudioTracks')
  @DocsEditable
  List<MediaStreamTrack> getAudioTracks() native "MediaStream_getAudioTracks_Callback";

  @DomName('MediaStream.getTrackById')
  @DocsEditable
  MediaStreamTrack getTrackById(String trackId) native "MediaStream_getTrackById_Callback";

  @DomName('MediaStream.getVideoTracks')
  @DocsEditable
  List<MediaStreamTrack> getVideoTracks() native "MediaStream_getVideoTracks_Callback";

  @DomName('MediaStream.removeEventListener')
  @DocsEditable
  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]) native "MediaStream_removeEventListener_Callback";

  @DomName('MediaStream.removeTrack')
  @DocsEditable
  void removeTrack(MediaStreamTrack track) native "MediaStream_removeTrack_Callback";

  @DomName('MediaStream.ended')
  @DocsEditable
  Stream<Event> get onEnded => endedEvent.forTarget(this);


  /**
   * Checks if the MediaStream APIs are supported on the current platform.
   *
   * See also:
   *
   * * [Navigator.getUserMedia]
   */
  static bool get supported => true;
}

@DocsEditable
@deprecated
class MediaStreamEvents extends Events {
  @DocsEditable
  MediaStreamEvents(EventTarget _ptr) : super(_ptr);

  @DocsEditable
  EventListenerList get addTrack => this['addtrack'];

  @DocsEditable
  EventListenerList get ended => this['ended'];

  @DocsEditable
  EventListenerList get removeTrack => this['removetrack'];
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('MediaStreamEvent')
class MediaStreamEvent extends Event {
  MediaStreamEvent.internal() : super.internal();

  /// Checks if this type is supported on the current platform.
  static bool get supported => true;

  @DomName('MediaStreamEvent.stream')
  @DocsEditable
  MediaStream get stream native "MediaStreamEvent_stream_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('MediaStreamTrack')
class MediaStreamTrack extends EventTarget {
  MediaStreamTrack.internal() : super.internal();

  @DomName('MediaStreamTrack.ended')
  @DocsEditable
  static const EventStreamProvider<Event> endedEvent = const EventStreamProvider<Event>('ended');

  @DomName('MediaStreamTrack.mute')
  @DocsEditable
  static const EventStreamProvider<Event> muteEvent = const EventStreamProvider<Event>('mute');

  @DomName('MediaStreamTrack.unmute')
  @DocsEditable
  static const EventStreamProvider<Event> unmuteEvent = const EventStreamProvider<Event>('unmute');

  @DocsEditable
  @DomName('EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent')
  @deprecated
  MediaStreamTrackEvents get on =>
    new MediaStreamTrackEvents(this);

  static const int ENDED = 2;

  static const int LIVE = 0;

  static const int MUTED = 1;

  @DomName('MediaStreamTrack.enabled')
  @DocsEditable
  bool get enabled native "MediaStreamTrack_enabled_Getter";

  @DomName('MediaStreamTrack.enabled')
  @DocsEditable
  void set enabled(bool value) native "MediaStreamTrack_enabled_Setter";

  @DomName('MediaStreamTrack.id')
  @DocsEditable
  String get id native "MediaStreamTrack_id_Getter";

  @DomName('MediaStreamTrack.kind')
  @DocsEditable
  String get kind native "MediaStreamTrack_kind_Getter";

  @DomName('MediaStreamTrack.label')
  @DocsEditable
  String get label native "MediaStreamTrack_label_Getter";

  @DomName('MediaStreamTrack.readyState')
  @DocsEditable
  int get readyState native "MediaStreamTrack_readyState_Getter";

  @DomName('MediaStreamTrack.addEventListener')
  @DocsEditable
  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]) native "MediaStreamTrack_addEventListener_Callback";

  @DomName('MediaStreamTrack.dispatchEvent')
  @DocsEditable
  bool dispatchEvent(Event event) native "MediaStreamTrack_dispatchEvent_Callback";

  @DomName('MediaStreamTrack.removeEventListener')
  @DocsEditable
  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]) native "MediaStreamTrack_removeEventListener_Callback";

  @DomName('MediaStreamTrack.ended')
  @DocsEditable
  Stream<Event> get onEnded => endedEvent.forTarget(this);

  @DomName('MediaStreamTrack.mute')
  @DocsEditable
  Stream<Event> get onMute => muteEvent.forTarget(this);

  @DomName('MediaStreamTrack.unmute')
  @DocsEditable
  Stream<Event> get onUnmute => unmuteEvent.forTarget(this);

}

@DocsEditable
@deprecated
class MediaStreamTrackEvents extends Events {
  @DocsEditable
  MediaStreamTrackEvents(EventTarget _ptr) : super(_ptr);

  @DocsEditable
  EventListenerList get ended => this['ended'];

  @DocsEditable
  EventListenerList get mute => this['mute'];

  @DocsEditable
  EventListenerList get unmute => this['unmute'];
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('MediaStreamTrackEvent')
class MediaStreamTrackEvent extends Event {
  MediaStreamTrackEvent.internal() : super.internal();

  /// Checks if this type is supported on the current platform.
  static bool get supported => true;

  @DomName('MediaStreamTrackEvent.track')
  @DocsEditable
  MediaStreamTrack get track native "MediaStreamTrackEvent_track_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('MemoryInfo')
class MemoryInfo extends NativeFieldWrapperClass1 {
  MemoryInfo.internal();

  @DomName('MemoryInfo.jsHeapSizeLimit')
  @DocsEditable
  int get jsHeapSizeLimit native "MemoryInfo_jsHeapSizeLimit_Getter";

  @DomName('MemoryInfo.totalJSHeapSize')
  @DocsEditable
  int get totalJSHeapSize native "MemoryInfo_totalJSHeapSize_Getter";

  @DomName('MemoryInfo.usedJSHeapSize')
  @DocsEditable
  int get usedJSHeapSize native "MemoryInfo_usedJSHeapSize_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('HTMLMenuElement')
class MenuElement extends _Element_Merged {
  MenuElement.internal() : super.internal();

  @DocsEditable
  factory MenuElement() => document.$dom_createElement("menu");

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('MessageChannel')
class MessageChannel extends NativeFieldWrapperClass1 {
  MessageChannel.internal();

  @DocsEditable
  factory MessageChannel() => MessageChannel._create();
  static MessageChannel _create() native "MessageChannel_constructor_Callback";

  @DomName('MessageChannel.port1')
  @DocsEditable
  MessagePort get port1 native "MessageChannel_port1_Getter";

  @DomName('MessageChannel.port2')
  @DocsEditable
  MessagePort get port2 native "MessageChannel_port2_Getter";

}
// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DomName('MessageEvent')
class MessageEvent extends Event {
  factory MessageEvent(String type,
      {bool canBubble: false, bool cancelable: false, Object data,
      String origin, String lastEventId,
      Window source, List messagePorts}) {
    if (source == null) {
      source = window;
    }
    var event = document.$dom_createEvent("MessageEvent");
    event.$dom_initMessageEvent(type, canBubble, cancelable, data, origin,
        lastEventId, source, messagePorts);
    return event;
  }
  MessageEvent.internal() : super.internal();

  @DomName('MessageEvent.data')
  @DocsEditable
  Object get data native "MessageEvent_data_Getter";

  @DomName('MessageEvent.lastEventId')
  @DocsEditable
  String get lastEventId native "MessageEvent_lastEventId_Getter";

  @DomName('MessageEvent.origin')
  @DocsEditable
  String get origin native "MessageEvent_origin_Getter";

  @DomName('MessageEvent.ports')
  @DocsEditable
  List get ports native "MessageEvent_ports_Getter";

  @DomName('MessageEvent.source')
  @DocsEditable
  WindowBase get source native "MessageEvent_source_Getter";

  @DomName('MessageEvent.initMessageEvent')
  @DocsEditable
  void $dom_initMessageEvent(String typeArg, bool canBubbleArg, bool cancelableArg, Object dataArg, String originArg, String lastEventIdArg, Window sourceArg, List messagePorts) native "MessageEvent_initMessageEvent_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('MessagePort')
class MessagePort extends EventTarget {
  MessagePort.internal() : super.internal();

  @DomName('MessagePort.message')
  @DocsEditable
  static const EventStreamProvider<MessageEvent> messageEvent = const EventStreamProvider<MessageEvent>('message');

  @DocsEditable
  @DomName('EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent')
  @deprecated
  MessagePortEvents get on =>
    new MessagePortEvents(this);

  @DomName('MessagePort.addEventListener')
  @DocsEditable
  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]) native "MessagePort_addEventListener_Callback";

  @DomName('MessagePort.close')
  @DocsEditable
  void close() native "MessagePort_close_Callback";

  @DomName('MessagePort.dispatchEvent')
  @DocsEditable
  bool dispatchEvent(Event evt) native "MessagePort_dispatchEvent_Callback";

  @DomName('MessagePort.postMessage')
  @DocsEditable
  void postMessage(Object message, [List messagePorts]) native "MessagePort_postMessage_Callback";

  @DomName('MessagePort.removeEventListener')
  @DocsEditable
  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]) native "MessagePort_removeEventListener_Callback";

  @DomName('MessagePort.start')
  @DocsEditable
  void start() native "MessagePort_start_Callback";

  @DomName('MessagePort.message')
  @DocsEditable
  Stream<MessageEvent> get onMessage => messageEvent.forTarget(this);

}

@DocsEditable
@deprecated
class MessagePortEvents extends Events {
  @DocsEditable
  MessagePortEvents(EventTarget _ptr) : super(_ptr);

  @DocsEditable
  EventListenerList get message => this['message'];
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('HTMLMetaElement')
class MetaElement extends _Element_Merged {
  MetaElement.internal() : super.internal();

  @DomName('HTMLMetaElement.content')
  @DocsEditable
  String get content native "HTMLMetaElement_content_Getter";

  @DomName('HTMLMetaElement.content')
  @DocsEditable
  void set content(String value) native "HTMLMetaElement_content_Setter";

  @DomName('HTMLMetaElement.httpEquiv')
  @DocsEditable
  String get httpEquiv native "HTMLMetaElement_httpEquiv_Getter";

  @DomName('HTMLMetaElement.httpEquiv')
  @DocsEditable
  void set httpEquiv(String value) native "HTMLMetaElement_httpEquiv_Setter";

  @DomName('HTMLMetaElement.name')
  @DocsEditable
  String get name native "HTMLMetaElement_name_Getter";

  @DomName('HTMLMetaElement.name')
  @DocsEditable
  void set name(String value) native "HTMLMetaElement_name_Setter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('Metadata')
class Metadata extends NativeFieldWrapperClass1 {
  Metadata.internal();

  @DomName('Metadata.modificationTime')
  @DocsEditable
  Date get modificationTime native "Metadata_modificationTime_Getter";

  @DomName('Metadata.size')
  @DocsEditable
  int get size native "Metadata_size_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


typedef void MetadataCallback(Metadata metadata);
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('HTMLMeterElement')
@SupportedBrowser(SupportedBrowser.CHROME)
@SupportedBrowser(SupportedBrowser.FIREFOX)
@SupportedBrowser(SupportedBrowser.SAFARI)
class MeterElement extends _Element_Merged {
  MeterElement.internal() : super.internal();

  @DocsEditable
  factory MeterElement() => document.$dom_createElement("meter");

  /// Checks if this type is supported on the current platform.
  static bool get supported => true;

  @DomName('HTMLMeterElement.high')
  @DocsEditable
  num get high native "HTMLMeterElement_high_Getter";

  @DomName('HTMLMeterElement.high')
  @DocsEditable
  void set high(num value) native "HTMLMeterElement_high_Setter";

  @DomName('HTMLMeterElement.labels')
  @DocsEditable
  List<Node> get labels native "HTMLMeterElement_labels_Getter";

  @DomName('HTMLMeterElement.low')
  @DocsEditable
  num get low native "HTMLMeterElement_low_Getter";

  @DomName('HTMLMeterElement.low')
  @DocsEditable
  void set low(num value) native "HTMLMeterElement_low_Setter";

  @DomName('HTMLMeterElement.max')
  @DocsEditable
  num get max native "HTMLMeterElement_max_Getter";

  @DomName('HTMLMeterElement.max')
  @DocsEditable
  void set max(num value) native "HTMLMeterElement_max_Setter";

  @DomName('HTMLMeterElement.min')
  @DocsEditable
  num get min native "HTMLMeterElement_min_Getter";

  @DomName('HTMLMeterElement.min')
  @DocsEditable
  void set min(num value) native "HTMLMeterElement_min_Setter";

  @DomName('HTMLMeterElement.optimum')
  @DocsEditable
  num get optimum native "HTMLMeterElement_optimum_Getter";

  @DomName('HTMLMeterElement.optimum')
  @DocsEditable
  void set optimum(num value) native "HTMLMeterElement_optimum_Setter";

  @DomName('HTMLMeterElement.value')
  @DocsEditable
  num get value native "HTMLMeterElement_value_Getter";

  @DomName('HTMLMeterElement.value')
  @DocsEditable
  void set value(num value) native "HTMLMeterElement_value_Setter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('HTMLModElement')
class ModElement extends _Element_Merged {
  ModElement.internal() : super.internal();

  @DomName('HTMLModElement.cite')
  @DocsEditable
  String get cite native "HTMLModElement_cite_Getter";

  @DomName('HTMLModElement.cite')
  @DocsEditable
  void set cite(String value) native "HTMLModElement_cite_Setter";

  @DomName('HTMLModElement.dateTime')
  @DocsEditable
  String get dateTime native "HTMLModElement_dateTime_Getter";

  @DomName('HTMLModElement.dateTime')
  @DocsEditable
  void set dateTime(String value) native "HTMLModElement_dateTime_Setter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DomName('MouseEvent')
class MouseEvent extends UIEvent {
  factory MouseEvent(String type,
      {Window view, int detail: 0, int screenX: 0, int screenY: 0,
      int clientX: 0, int clientY: 0, int button: 0, bool canBubble: true,
      bool cancelable: true, bool ctrlKey: false, bool altKey: false,
      bool shiftKey: false, bool metaKey: false, EventTarget relatedTarget}) {

    if (view == null) {
      view = window;
    }
    var event = document.$dom_createEvent('MouseEvent');
    event.$dom_initMouseEvent(type, canBubble, cancelable, view, detail,
        screenX, screenY, clientX, clientY, ctrlKey, altKey, shiftKey, metaKey,
        button, relatedTarget);
    return event;
  }
  MouseEvent.internal() : super.internal();

  @DomName('MouseEvent.altKey')
  @DocsEditable
  bool get altKey native "MouseEvent_altKey_Getter";

  @DomName('MouseEvent.button')
  @DocsEditable
  int get button native "MouseEvent_button_Getter";

  @DomName('MouseEvent.clientX')
  @DocsEditable
  int get clientX native "MouseEvent_clientX_Getter";

  @DomName('MouseEvent.clientY')
  @DocsEditable
  int get clientY native "MouseEvent_clientY_Getter";

  @DomName('MouseEvent.ctrlKey')
  @DocsEditable
  bool get ctrlKey native "MouseEvent_ctrlKey_Getter";

  @DomName('MouseEvent.dataTransfer')
  @DocsEditable
  Clipboard get dataTransfer native "MouseEvent_dataTransfer_Getter";

  @DomName('MouseEvent.fromElement')
  @DocsEditable
  Node get fromElement native "MouseEvent_fromElement_Getter";

  @DomName('MouseEvent.metaKey')
  @DocsEditable
  bool get metaKey native "MouseEvent_metaKey_Getter";

  @DomName('MouseEvent.offsetX')
  @DocsEditable
  int get offsetX native "MouseEvent_offsetX_Getter";

  @DomName('MouseEvent.offsetY')
  @DocsEditable
  int get offsetY native "MouseEvent_offsetY_Getter";

  @DomName('MouseEvent.relatedTarget')
  @DocsEditable
  EventTarget get relatedTarget native "MouseEvent_relatedTarget_Getter";

  @DomName('MouseEvent.screenX')
  @DocsEditable
  int get screenX native "MouseEvent_screenX_Getter";

  @DomName('MouseEvent.screenY')
  @DocsEditable
  int get screenY native "MouseEvent_screenY_Getter";

  @DomName('MouseEvent.shiftKey')
  @DocsEditable
  bool get shiftKey native "MouseEvent_shiftKey_Getter";

  @DomName('MouseEvent.toElement')
  @DocsEditable
  Node get toElement native "MouseEvent_toElement_Getter";

  @DomName('MouseEvent.webkitMovementX')
  @DocsEditable
  int get webkitMovementX native "MouseEvent_webkitMovementX_Getter";

  @DomName('MouseEvent.webkitMovementY')
  @DocsEditable
  int get webkitMovementY native "MouseEvent_webkitMovementY_Getter";

  @DomName('MouseEvent.x')
  @DocsEditable
  int get x native "MouseEvent_x_Getter";

  @DomName('MouseEvent.y')
  @DocsEditable
  int get y native "MouseEvent_y_Getter";

  @DomName('MouseEvent.initMouseEvent')
  @DocsEditable
  void $dom_initMouseEvent(String type, bool canBubble, bool cancelable, Window view, int detail, int screenX, int screenY, int clientX, int clientY, bool ctrlKey, bool altKey, bool shiftKey, bool metaKey, int button, EventTarget relatedTarget) native "MouseEvent_initMouseEvent_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


typedef void MutationCallback(List<MutationRecord> mutations, MutationObserver observer);
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.


@DomName('MutationEvent')
class MutationEvent extends Event {
  factory MutationEvent(String type,
      {bool canBubble: false, bool cancelable: false, Node relatedNode,
      String prevValue, String newValue, String attrName, int attrChange: 0}) {

    var event = document.$dom_createEvent('MutationEvent');
    event.$dom_initMutationEvent(type, canBubble, cancelable, relatedNode,
        prevValue, newValue, attrName, attrChange);
    return event;
  }
  MutationEvent.internal() : super.internal();

  static const int ADDITION = 2;

  static const int MODIFICATION = 1;

  static const int REMOVAL = 3;

  @DomName('MutationEvent.attrChange')
  @DocsEditable
  int get attrChange native "MutationEvent_attrChange_Getter";

  @DomName('MutationEvent.attrName')
  @DocsEditable
  String get attrName native "MutationEvent_attrName_Getter";

  @DomName('MutationEvent.newValue')
  @DocsEditable
  String get newValue native "MutationEvent_newValue_Getter";

  @DomName('MutationEvent.prevValue')
  @DocsEditable
  String get prevValue native "MutationEvent_prevValue_Getter";

  @DomName('MutationEvent.relatedNode')
  @DocsEditable
  Node get relatedNode native "MutationEvent_relatedNode_Getter";

  @DomName('MutationEvent.initMutationEvent')
  @DocsEditable
  void $dom_initMutationEvent(String type, bool canBubble, bool cancelable, Node relatedNode, String prevValue, String newValue, String attrName, int attrChange) native "MutationEvent_initMutationEvent_Callback";

}



// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.


@DomName('MutationObserver')
@SupportedBrowser(SupportedBrowser.CHROME)
@SupportedBrowser(SupportedBrowser.FIREFOX)
@SupportedBrowser(SupportedBrowser.SAFARI)
@Experimental
class MutationObserver extends NativeFieldWrapperClass1 {
  MutationObserver.internal();

  @DocsEditable
  factory MutationObserver(MutationCallback callback) => MutationObserver._create(callback);
  static MutationObserver _create(MutationCallback callback) native "MutationObserver_constructor_Callback";

  @DomName('MutationObserver.disconnect')
  @DocsEditable
  void disconnect() native "MutationObserver_disconnect_Callback";

  @DomName('MutationObserver._observe')
  @DocsEditable
  void _observe(Node target, Map options) native "MutationObserver__observe_Callback";

  @DomName('MutationObserver.takeRecords')
  @DocsEditable
  List<MutationRecord> takeRecords() native "MutationObserver_takeRecords_Callback";

  /**
   * Checks to see if the mutation observer API is supported on the current
   * platform.
   */
  static bool get supported {
    return true;
  }

  void observe(Node target,
               {Map options,
                bool childList,
                bool attributes,
                bool characterData,
                bool subtree,
                bool attributeOldValue,
                bool characterDataOldValue,
                List<String> attributeFilter}) {

    // Parse options into map of known type.
    var parsedOptions = _createDict();

    if (options != null) {
      options.forEach((k, v) {
          if (_boolKeys.containsKey(k)) {
            _add(parsedOptions, k, true == v);
          } else if (k == 'attributeFilter') {
            _add(parsedOptions, k, _fixupList(v));
          } else {
            throw new ArgumentError(
                "Illegal MutationObserver.observe option '$k'");
          }
        });
    }

    // Override options passed in the map with named optional arguments.
    override(key, value) {
      if (value != null) _add(parsedOptions, key, value);
    }

    override('childList', childList);
    override('attributes', attributes);
    override('characterData', characterData);
    override('subtree', subtree);
    override('attributeOldValue', attributeOldValue);
    override('characterDataOldValue', characterDataOldValue);
    if (attributeFilter != null) {
      override('attributeFilter', _fixupList(attributeFilter));
    }

    _call(target, parsedOptions);
  }

   // TODO: Change to a set when const Sets are available.
  static final _boolKeys =
    const {'childList': true,
           'attributes': true,
           'characterData': true,
           'subtree': true,
           'attributeOldValue': true,
           'characterDataOldValue': true };

  static _createDict() => {};
  static _add(m, String key, value) { m[key] = value; }
  static _fixupList(list) => list;

  void _call(Node target, options) {
    _observe(target, options);
  }

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('MutationRecord')
class MutationRecord extends NativeFieldWrapperClass1 {
  MutationRecord.internal();

  @DomName('MutationRecord.addedNodes')
  @DocsEditable
  List<Node> get addedNodes native "MutationRecord_addedNodes_Getter";

  @DomName('MutationRecord.attributeName')
  @DocsEditable
  String get attributeName native "MutationRecord_attributeName_Getter";

  @DomName('MutationRecord.attributeNamespace')
  @DocsEditable
  String get attributeNamespace native "MutationRecord_attributeNamespace_Getter";

  @DomName('MutationRecord.nextSibling')
  @DocsEditable
  Node get nextSibling native "MutationRecord_nextSibling_Getter";

  @DomName('MutationRecord.oldValue')
  @DocsEditable
  String get oldValue native "MutationRecord_oldValue_Getter";

  @DomName('MutationRecord.previousSibling')
  @DocsEditable
  Node get previousSibling native "MutationRecord_previousSibling_Getter";

  @DomName('MutationRecord.removedNodes')
  @DocsEditable
  List<Node> get removedNodes native "MutationRecord_removedNodes_Getter";

  @DomName('MutationRecord.target')
  @DocsEditable
  Node get target native "MutationRecord_target_Getter";

  @DomName('MutationRecord.type')
  @DocsEditable
  String get type native "MutationRecord_type_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('NamedNodeMap')
class NamedNodeMap extends NativeFieldWrapperClass1 implements List<Node> {
  NamedNodeMap.internal();

  @DomName('NamedNodeMap.length')
  @DocsEditable
  int get length native "NamedNodeMap_length_Getter";

  Node operator[](int index) native "NamedNodeMap_item_Callback";

  void operator[]=(int index, Node value) {
    throw new UnsupportedError("Cannot assign element of immutable List.");
  }
  // -- start List<Node> mixins.
  // Node is the element type.

  // From Iterable<Node>:

  Iterator<Node> get iterator {
    // Note: NodeLists are not fixed size. And most probably length shouldn't
    // be cached in both iterator _and_ forEach method. For now caching it
    // for consistency.
    return new FixedSizeListIterator<Node>(this);
  }

  dynamic reduce(dynamic initialValue, dynamic combine(dynamic, Node)) {
    return IterableMixinWorkaround.reduce(this, initialValue, combine);
  }

  bool contains(Node element) => IterableMixinWorkaround.contains(this, element);

  void forEach(void f(Node element)) => IterableMixinWorkaround.forEach(this, f);

  String join([String separator]) =>
      IterableMixinWorkaround.joinList(this, separator);

  List mappedBy(f(Node element)) => IterableMixinWorkaround.mappedByList(this, f);

  Iterable<Node> where(bool f(Node element)) =>
      IterableMixinWorkaround.where(this, f);

  bool every(bool f(Node element)) => IterableMixinWorkaround.every(this, f);

  bool any(bool f(Node element)) => IterableMixinWorkaround.any(this, f);

  List<Node> toList() => new List<Node>.from(this);
  Set<Node> toSet() => new Set<Node>.from(this);

  bool get isEmpty => this.length == 0;

  List<Node> take(int n) => IterableMixinWorkaround.takeList(this, n);

  Iterable<Node> takeWhile(bool test(Node value)) {
    return IterableMixinWorkaround.takeWhile(this, test);
  }

  List<Node> skip(int n) => IterableMixinWorkaround.skipList(this, n);

  Iterable<Node> skipWhile(bool test(Node value)) {
    return IterableMixinWorkaround.skipWhile(this, test);
  }

  Node firstMatching(bool test(Node value), { Node orElse() }) {
    return IterableMixinWorkaround.firstMatching(this, test, orElse);
  }

  Node lastMatching(bool test(Node value), {Node orElse()}) {
    return IterableMixinWorkaround.lastMatchingInList(this, test, orElse);
  }

  Node singleMatching(bool test(Node value)) {
    return IterableMixinWorkaround.singleMatching(this, test);
  }

  Node elementAt(int index) {
    return this[index];
  }

  // From Collection<Node>:

  void add(Node value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addLast(Node value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addAll(Iterable<Node> iterable) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  // From List<Node>:
  void set length(int value) {
    throw new UnsupportedError("Cannot resize immutable List.");
  }

  void clear() {
    throw new UnsupportedError("Cannot clear immutable List.");
  }

  List<Node> get reversed =>
      new ReversedListView<Node>(this, 0, null);

  void sort([int compare(Node a, Node b)]) {
    throw new UnsupportedError("Cannot sort immutable List.");
  }

  int indexOf(Node element, [int start = 0]) =>
      Lists.indexOf(this, element, start, this.length);

  int lastIndexOf(Node element, [int start]) {
    if (start == null) start = length - 1;
    return Lists.lastIndexOf(this, element, start);
  }

  Node get first {
    if (this.length > 0) return this[0];
    throw new StateError("No elements");
  }

  Node get last {
    if (this.length > 0) return this[this.length - 1];
    throw new StateError("No elements");
  }

  Node get single {
    if (length == 1) return this[0];
    if (length == 0) throw new StateError("No elements");
    throw new StateError("More than one element");
  }

  Node min([int compare(Node a, Node b)]) =>
      IterableMixinWorkaround.min(this, compare);

  Node max([int compare(Node a, Node b)]) =>
      IterableMixinWorkaround.max(this, compare);

  Node removeAt(int pos) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  Node removeLast() {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void remove(Object object) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void removeAll(Iterable elements) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void retainAll(Iterable elements) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void removeMatching(bool test(Node element)) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void retainMatching(bool test(Node element)) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void setRange(int start, int rangeLength, List<Node> from, [int startFrom]) {
    throw new UnsupportedError("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int rangeLength) {
    throw new UnsupportedError("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int rangeLength, [Node initialValue]) {
    throw new UnsupportedError("Cannot insertRange on immutable List.");
  }

  List<Node> getRange(int start, int rangeLength) =>
      Lists.getRange(this, start, rangeLength, <Node>[]);

  // -- end List<Node> mixins.

  @DomName('NamedNodeMap.getNamedItem')
  @DocsEditable
  Node getNamedItem(String name) native "NamedNodeMap_getNamedItem_Callback";

  @DomName('NamedNodeMap.getNamedItemNS')
  @DocsEditable
  Node getNamedItemNS(String namespaceURI, String localName) native "NamedNodeMap_getNamedItemNS_Callback";

  @DomName('NamedNodeMap.item')
  @DocsEditable
  Node item(int index) native "NamedNodeMap_item_Callback";

  @DomName('NamedNodeMap.removeNamedItem')
  @DocsEditable
  Node removeNamedItem(String name) native "NamedNodeMap_removeNamedItem_Callback";

  @DomName('NamedNodeMap.removeNamedItemNS')
  @DocsEditable
  Node removeNamedItemNS(String namespaceURI, String localName) native "NamedNodeMap_removeNamedItemNS_Callback";

  @DomName('NamedNodeMap.setNamedItem')
  @DocsEditable
  Node setNamedItem(Node node) native "NamedNodeMap_setNamedItem_Callback";

  @DomName('NamedNodeMap.setNamedItemNS')
  @DocsEditable
  Node setNamedItemNS(Node node) native "NamedNodeMap_setNamedItemNS_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.


@DomName('Navigator')
class Navigator extends NativeFieldWrapperClass1 {


  /**
   * Gets a stream (video and or audio) from the local computer.
   *
   * Use [MediaStream.supported] to check if this is supported by the current
   * platform.
   *
   * Example use:
   *
   *     window.navigator.getUserMedia(audio:true, video: true).then((stream) {
   *       var video = new VideoElement()
   *         ..autoplay = true
   *         ..src = Url.createObjectUrl(stream);
   *       document.body.append(video);
   *     });
   *
   * See also:
   * * [MediaStream.supported]
   */
  @DomName('Navigator.webkitGetUserMedia')
  @SupportedBrowser(SupportedBrowser.CHROME)
  @Experimental
  Future<LocalMediaStream> getUserMedia({bool audio: false,
      bool video: false}) {
    var completer = new Completer<LocalMediaStream>();
    var options = {
      'audio': audio,
      'video': video
    };
    this._getUserMedia(options,
      (stream) {
        completer.complete(stream);
      },
      (error) {
        completer.completeError(error);
      });
    return completer.future;
  }


  Navigator.internal();

  @DomName('Navigator.appCodeName')
  @DocsEditable
  String get appCodeName native "Navigator_appCodeName_Getter";

  @DomName('Navigator.appName')
  @DocsEditable
  String get appName native "Navigator_appName_Getter";

  @DomName('Navigator.appVersion')
  @DocsEditable
  String get appVersion native "Navigator_appVersion_Getter";

  @DomName('Navigator.cookieEnabled')
  @DocsEditable
  bool get cookieEnabled native "Navigator_cookieEnabled_Getter";

  @DomName('Navigator.geolocation')
  @DocsEditable
  Geolocation get geolocation native "Navigator_geolocation_Getter";

  @DomName('Navigator.language')
  @DocsEditable
  String get language native "Navigator_language_Getter";

  @DomName('Navigator.mimeTypes')
  @DocsEditable
  DomMimeTypeArray get mimeTypes native "Navigator_mimeTypes_Getter";

  @DomName('Navigator.onLine')
  @DocsEditable
  bool get onLine native "Navigator_onLine_Getter";

  @DomName('Navigator.platform')
  @DocsEditable
  String get platform native "Navigator_platform_Getter";

  @DomName('Navigator.plugins')
  @DocsEditable
  DomPluginArray get plugins native "Navigator_plugins_Getter";

  @DomName('Navigator.product')
  @DocsEditable
  String get product native "Navigator_product_Getter";

  @DomName('Navigator.productSub')
  @DocsEditable
  String get productSub native "Navigator_productSub_Getter";

  @DomName('Navigator.userAgent')
  @DocsEditable
  String get userAgent native "Navigator_userAgent_Getter";

  @DomName('Navigator.vendor')
  @DocsEditable
  String get vendor native "Navigator_vendor_Getter";

  @DomName('Navigator.vendorSub')
  @DocsEditable
  String get vendorSub native "Navigator_vendorSub_Getter";

  @DomName('Navigator.webkitBattery')
  @DocsEditable
  BatteryManager get webkitBattery native "Navigator_webkitBattery_Getter";

  @DomName('Navigator.getStorageUpdates')
  @DocsEditable
  void getStorageUpdates() native "Navigator_getStorageUpdates_Callback";

  @DomName('Navigator.javaEnabled')
  @DocsEditable
  bool javaEnabled() native "Navigator_javaEnabled_Callback";

  @DomName('Navigator.webkitGetGamepads')
  @DocsEditable
  List<Gamepad> webkitGetGamepads() native "Navigator_webkitGetGamepads_Callback";

  @DomName('Navigator.webkitGetUserMedia')
  @DocsEditable
  void _getUserMedia(Map options, _NavigatorUserMediaSuccessCallback successCallback, [_NavigatorUserMediaErrorCallback errorCallback]) native "Navigator_webkitGetUserMedia_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('NavigatorUserMediaError')
class NavigatorUserMediaError extends NativeFieldWrapperClass1 {
  NavigatorUserMediaError.internal();

  static const int PERMISSION_DENIED = 1;

  @DomName('NavigatorUserMediaError.code')
  @DocsEditable
  int get code native "NavigatorUserMediaError_code_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


typedef void _NavigatorUserMediaErrorCallback(NavigatorUserMediaError error);
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


typedef void _NavigatorUserMediaSuccessCallback(LocalMediaStream stream);
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.


/**
 * Lazy implementation of the child nodes of an element that does not request
 * the actual child nodes of an element until strictly necessary greatly
 * improving performance for the typical cases where it is not required.
 */
class _ChildNodeListLazy implements List {
  final Node _this;

  _ChildNodeListLazy(this._this);


  Node get first {
    Node result = _this.$dom_firstChild;
    if (result == null) throw new StateError("No elements");
    return result;
  }
  Node get last {
    Node result = _this.$dom_lastChild;
    if (result == null) throw new StateError("No elements");
    return result;
  }
  Node get single {
    int l = this.length;
    if (l == 0) throw new StateError("No elements");
    if (l > 1) throw new StateError("More than one element");
    return _this.$dom_firstChild;
  }

  Node min([int compare(Node a, Node b)]) {
    return IterableMixinWorkaround.min(this, compare);
  }

  Node max([int compare(Node a, Node b)]) {
    return IterableMixinWorkaround.max(this, compare);
  }

  void add(Node value) {
    _this.$dom_appendChild(value);
  }

  void addLast(Node value) {
    _this.$dom_appendChild(value);
  }


  void addAll(Iterable<Node> iterable) {
    for (Node node in iterable) {
      _this.$dom_appendChild(node);
    }
  }

  Node removeLast() {
    final result = last;
    if (result != null) {
      _this.$dom_removeChild(result);
    }
    return result;
  }

  Node removeAt(int index) {
    var result = this[index];
    if (result != null) {
      _this.$dom_removeChild(result);
    }
    return result;
  }

  void remove(Object object) {
    if (object is! Node) return;
    Node node = object;
    if (!identical(this, node.parentNode)) return;
    _this.$dom_removeChild(node);
  }

  void removeAll(Iterable elements) {
    IterableMixinWorkaround.removeAll(this, elements);
  }

  void retainAll(Iterable elements) {
    IterableMixinWorkaround.retainAll(this, elements);
  }

  void removeMatching(bool test(Node node)) {
    IterableMixinWorkaround.removeMatching(this, test);
  }

  void retainMatching(bool test(Node node)) {
    IterableMixinWorkaround.retainMatching(this, test);
  }

  void clear() {
    _this.text = '';
  }

  void operator []=(int index, Node value) {
    _this.$dom_replaceChild(value, this[index]);
  }

  Iterator<Node> get iterator => _this.$dom_childNodes.iterator;

  // TODO(jacobr): We can implement these methods much more efficiently by
  // looking up the nodeList only once instead of once per iteration.
  bool contains(Node element) => IterableMixinWorkaround.contains(this, element);

  void forEach(void f(Node element)) => IterableMixinWorkaround.forEach(this, f);

  dynamic reduce(dynamic initialValue,
      dynamic combine(dynamic previousValue, Node element)) {
    return IterableMixinWorkaround.reduce(this, initialValue, combine);
  }

  String join([String separator]) {
    return IterableMixinWorkaround.joinList(this, separator);
  }

  List mappedBy(f(Node element)) {
    return IterableMixinWorkaround.mappedByList(this, f);
  }

  Iterable<Node> where(bool f(Node element)) {
    return IterableMixinWorkaround.where(this, f);
  }

  bool every(bool f(Node element)) => IterableMixinWorkaround.every(this, f);

  bool any(bool f(Node element)) => IterableMixinWorkaround.any(this, f);

  List<Node> toList() => new List<Node>.from(this);
  Set<Node> toSet() => new Set<Node>.from(this);

  bool get isEmpty => this.length == 0;

  // From List<Node>:

  List<Node> take(int n) {
    return IterableMixinWorkaround.takeList(this, n);
  }

  Iterable<Node> takeWhile(bool test(Node value)) {
    return IterableMixinWorkaround.takeWhile(this, test);
  }

  List<Node> skip(int n) {
    return IterableMixinWorkaround.skipList(this, n);
  }

  Iterable<Node> skipWhile(bool test(Node value)) {
    return IterableMixinWorkaround.skipWhile(this, test);
  }

  Node firstMatching(bool test(Node value), {Node orElse()}) {
    return IterableMixinWorkaround.firstMatching(this, test, orElse);
  }

  Node lastMatching(bool test(Node value), {Node orElse()}) {
    return IterableMixinWorkaround.lastMatchingInList(this, test, orElse);
  }

  Node singleMatching(bool test(Node value)) {
    return IterableMixinWorkaround.singleMatching(this, test);
  }

  Node elementAt(int index) {
    return this[index];
  }

  List<Node> get reversed =>
      new ReversedListView<Node>(this, 0, null);

  // TODO(jacobr): this could be implemented for child node lists.
  // The exception we throw here is misleading.
  void sort([int compare(Node a, Node b)]) {
    throw new UnsupportedError("Cannot sort immutable List.");
  }

  int indexOf(Node element, [int start = 0]) =>
      Lists.indexOf(this, element, start, this.length);

  int lastIndexOf(Node element, [int start = 0]) =>
      Lists.lastIndexOf(this, element, start);

  // FIXME: implement these.
  void setRange(int start, int rangeLength, List<Node> from, [int startFrom]) {
    throw new UnsupportedError(
        "Cannot setRange on immutable List.");
  }
  void removeRange(int start, int rangeLength) {
    throw new UnsupportedError(
        "Cannot removeRange on immutable List.");
  }
  void insertRange(int start, int rangeLength, [Node initialValue]) {
    throw new UnsupportedError(
        "Cannot insertRange on immutable List.");
  }
  List<Node> getRange(int start, int rangeLength) =>
      Lists.getRange(this, start, rangeLength, <Node>[]);

  // -- end List<Node> mixins.

  // TODO(jacobr): benchmark whether this is more efficient or whether caching
  // a local copy of $dom_childNodes is more efficient.
  int get length => _this.$dom_childNodes.length;

  void set length(int value) {
    throw new UnsupportedError(
        "Cannot set length on immutable List.");
  }

  Node operator[](int index) => _this.$dom_childNodes[index];
}

@DomName('Node')
class Node extends EventTarget {
  List<Node> get nodes {
    return new _ChildNodeListLazy(this);
  }

  void set nodes(Collection<Node> value) {
    // Copy list first since we don't want liveness during iteration.
    // TODO(jacobr): there is a better way to do this.
    List copy = new List.from(value);
    text = '';
    for (Node node in copy) {
      $dom_appendChild(node);
    }
  }

  /**
   * Removes this node from the DOM.
   */
  @DomName('Node.removeChild')
  void remove() {
    // TODO(jacobr): should we throw an exception if parent is already null?
    // TODO(vsm): Use the native remove when available.
    if (this.parentNode != null) {
      final Node parent = this.parentNode;
      parentNode.$dom_removeChild(this);
    }
  }

  /**
   * Replaces this node with another node.
   */
  @DomName('Node.replaceChild')
  Node replaceWith(Node otherNode) {
    try {
      final Node parent = this.parentNode;
      parent.$dom_replaceChild(otherNode, this);
    } catch (e) {

    };
    return this;
  }

  Node.internal() : super.internal();

  @DomName('Node.attributes')
  @DocsEditable
  NamedNodeMap get $dom_attributes native "Node_attributes_Getter";

  @DomName('Node.childNodes')
  @DocsEditable
  List<Node> get $dom_childNodes native "Node_childNodes_Getter";

  @DomName('Node.firstChild')
  @DocsEditable
  Node get $dom_firstChild native "Node_firstChild_Getter";

  @DomName('Node.lastChild')
  @DocsEditable
  Node get $dom_lastChild native "Node_lastChild_Getter";

  @DomName('Node.localName')
  @DocsEditable
  String get $dom_localName native "Node_localName_Getter";

  @DomName('Node.namespaceURI')
  @DocsEditable
  String get $dom_namespaceUri native "Node_namespaceURI_Getter";

  @DomName('Node.nextSibling')
  @DocsEditable
  Node get nextNode native "Node_nextSibling_Getter";

  @DomName('Node.nodeType')
  @DocsEditable
  int get nodeType native "Node_nodeType_Getter";

  @DomName('Node.nodeValue')
  @DocsEditable
  String get nodeValue native "Node_nodeValue_Getter";

  @DomName('Node.ownerDocument')
  @DocsEditable
  Document get document native "Node_ownerDocument_Getter";

  @DomName('Node.parentElement')
  @DocsEditable
  Element get parent native "Node_parentElement_Getter";

  @DomName('Node.parentNode')
  @DocsEditable
  Node get parentNode native "Node_parentNode_Getter";

  @DomName('Node.previousSibling')
  @DocsEditable
  Node get previousNode native "Node_previousSibling_Getter";

  @DomName('Node.textContent')
  @DocsEditable
  String get text native "Node_textContent_Getter";

  @DomName('Node.textContent')
  @DocsEditable
  void set text(String value) native "Node_textContent_Setter";

  @DomName('Node.addEventListener')
  @DocsEditable
  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]) native "Node_addEventListener_Callback";

  @DomName('Node.appendChild')
  @DocsEditable
  Node $dom_appendChild(Node newChild) native "Node_appendChild_Callback";

  @DomName('Node.cloneNode')
  @DocsEditable
  Node clone(bool deep) native "Node_cloneNode_Callback";

  @DomName('Node.contains')
  @DocsEditable
  bool contains(Node other) native "Node_contains_Callback";

  @DomName('Node.dispatchEvent')
  @DocsEditable
  bool dispatchEvent(Event event) native "Node_dispatchEvent_Callback";

  @DomName('Node.hasChildNodes')
  @DocsEditable
  bool hasChildNodes() native "Node_hasChildNodes_Callback";

  @DomName('Node.insertBefore')
  @DocsEditable
  Node insertBefore(Node newChild, Node refChild) native "Node_insertBefore_Callback";

  @DomName('Node.removeChild')
  @DocsEditable
  Node $dom_removeChild(Node oldChild) native "Node_removeChild_Callback";

  @DomName('Node.removeEventListener')
  @DocsEditable
  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]) native "Node_removeEventListener_Callback";

  @DomName('Node.replaceChild')
  @DocsEditable
  Node $dom_replaceChild(Node newChild, Node oldChild) native "Node_replaceChild_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('NodeFilter')
class NodeFilter extends NativeFieldWrapperClass1 {
  NodeFilter.internal();

  static const int FILTER_ACCEPT = 1;

  static const int FILTER_REJECT = 2;

  static const int FILTER_SKIP = 3;

  static const int SHOW_ALL = 0xFFFFFFFF;

  static const int SHOW_ATTRIBUTE = 0x00000002;

  static const int SHOW_CDATA_SECTION = 0x00000008;

  static const int SHOW_COMMENT = 0x00000080;

  static const int SHOW_DOCUMENT = 0x00000100;

  static const int SHOW_DOCUMENT_FRAGMENT = 0x00000400;

  static const int SHOW_DOCUMENT_TYPE = 0x00000200;

  static const int SHOW_ELEMENT = 0x00000001;

  static const int SHOW_ENTITY = 0x00000020;

  static const int SHOW_ENTITY_REFERENCE = 0x00000010;

  static const int SHOW_NOTATION = 0x00000800;

  static const int SHOW_PROCESSING_INSTRUCTION = 0x00000040;

  static const int SHOW_TEXT = 0x00000004;

  @DomName('NodeFilter.acceptNode')
  @DocsEditable
  int acceptNode(Node n) native "NodeFilter_acceptNode_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('NodeIterator')
class NodeIterator extends NativeFieldWrapperClass1 {
  NodeIterator.internal();

  @DomName('NodeIterator.expandEntityReferences')
  @DocsEditable
  bool get expandEntityReferences native "NodeIterator_expandEntityReferences_Getter";

  @DomName('NodeIterator.filter')
  @DocsEditable
  NodeFilter get filter native "NodeIterator_filter_Getter";

  @DomName('NodeIterator.pointerBeforeReferenceNode')
  @DocsEditable
  bool get pointerBeforeReferenceNode native "NodeIterator_pointerBeforeReferenceNode_Getter";

  @DomName('NodeIterator.referenceNode')
  @DocsEditable
  Node get referenceNode native "NodeIterator_referenceNode_Getter";

  @DomName('NodeIterator.root')
  @DocsEditable
  Node get root native "NodeIterator_root_Getter";

  @DomName('NodeIterator.whatToShow')
  @DocsEditable
  int get whatToShow native "NodeIterator_whatToShow_Getter";

  @DomName('NodeIterator.detach')
  @DocsEditable
  void detach() native "NodeIterator_detach_Callback";

  @DomName('NodeIterator.nextNode')
  @DocsEditable
  Node nextNode() native "NodeIterator_nextNode_Callback";

  @DomName('NodeIterator.previousNode')
  @DocsEditable
  Node previousNode() native "NodeIterator_previousNode_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('NodeList')
class NodeList extends NativeFieldWrapperClass1 implements List<Node> {
  NodeList.internal();

  @DomName('NodeList.length')
  @DocsEditable
  int get length native "NodeList_length_Getter";

  Node operator[](int index) native "NodeList_item_Callback";

  void operator[]=(int index, Node value) {
    throw new UnsupportedError("Cannot assign element of immutable List.");
  }
  // -- start List<Node> mixins.
  // Node is the element type.

  // From Iterable<Node>:

  Iterator<Node> get iterator {
    // Note: NodeLists are not fixed size. And most probably length shouldn't
    // be cached in both iterator _and_ forEach method. For now caching it
    // for consistency.
    return new FixedSizeListIterator<Node>(this);
  }

  dynamic reduce(dynamic initialValue, dynamic combine(dynamic, Node)) {
    return IterableMixinWorkaround.reduce(this, initialValue, combine);
  }

  bool contains(Node element) => IterableMixinWorkaround.contains(this, element);

  void forEach(void f(Node element)) => IterableMixinWorkaround.forEach(this, f);

  String join([String separator]) =>
      IterableMixinWorkaround.joinList(this, separator);

  List mappedBy(f(Node element)) => IterableMixinWorkaround.mappedByList(this, f);

  Iterable<Node> where(bool f(Node element)) =>
      IterableMixinWorkaround.where(this, f);

  bool every(bool f(Node element)) => IterableMixinWorkaround.every(this, f);

  bool any(bool f(Node element)) => IterableMixinWorkaround.any(this, f);

  List<Node> toList() => new List<Node>.from(this);
  Set<Node> toSet() => new Set<Node>.from(this);

  bool get isEmpty => this.length == 0;

  List<Node> take(int n) => IterableMixinWorkaround.takeList(this, n);

  Iterable<Node> takeWhile(bool test(Node value)) {
    return IterableMixinWorkaround.takeWhile(this, test);
  }

  List<Node> skip(int n) => IterableMixinWorkaround.skipList(this, n);

  Iterable<Node> skipWhile(bool test(Node value)) {
    return IterableMixinWorkaround.skipWhile(this, test);
  }

  Node firstMatching(bool test(Node value), { Node orElse() }) {
    return IterableMixinWorkaround.firstMatching(this, test, orElse);
  }

  Node lastMatching(bool test(Node value), {Node orElse()}) {
    return IterableMixinWorkaround.lastMatchingInList(this, test, orElse);
  }

  Node singleMatching(bool test(Node value)) {
    return IterableMixinWorkaround.singleMatching(this, test);
  }

  Node elementAt(int index) {
    return this[index];
  }

  // From Collection<Node>:

  void add(Node value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addLast(Node value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addAll(Iterable<Node> iterable) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  // From List<Node>:
  void set length(int value) {
    throw new UnsupportedError("Cannot resize immutable List.");
  }

  void clear() {
    throw new UnsupportedError("Cannot clear immutable List.");
  }

  List<Node> get reversed =>
      new ReversedListView<Node>(this, 0, null);

  void sort([int compare(Node a, Node b)]) {
    throw new UnsupportedError("Cannot sort immutable List.");
  }

  int indexOf(Node element, [int start = 0]) =>
      Lists.indexOf(this, element, start, this.length);

  int lastIndexOf(Node element, [int start]) {
    if (start == null) start = length - 1;
    return Lists.lastIndexOf(this, element, start);
  }

  Node get first {
    if (this.length > 0) return this[0];
    throw new StateError("No elements");
  }

  Node get last {
    if (this.length > 0) return this[this.length - 1];
    throw new StateError("No elements");
  }

  Node get single {
    if (length == 1) return this[0];
    if (length == 0) throw new StateError("No elements");
    throw new StateError("More than one element");
  }

  Node min([int compare(Node a, Node b)]) =>
      IterableMixinWorkaround.min(this, compare);

  Node max([int compare(Node a, Node b)]) =>
      IterableMixinWorkaround.max(this, compare);

  Node removeAt(int pos) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  Node removeLast() {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void remove(Object object) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void removeAll(Iterable elements) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void retainAll(Iterable elements) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void removeMatching(bool test(Node element)) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void retainMatching(bool test(Node element)) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void setRange(int start, int rangeLength, List<Node> from, [int startFrom]) {
    throw new UnsupportedError("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int rangeLength) {
    throw new UnsupportedError("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int rangeLength, [Node initialValue]) {
    throw new UnsupportedError("Cannot insertRange on immutable List.");
  }

  List<Node> getRange(int start, int rangeLength) =>
      Lists.getRange(this, start, rangeLength, <Node>[]);

  // -- end List<Node> mixins.

  @DomName('NodeList.item')
  @DocsEditable
  Node _item(int index) native "NodeList_item_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('Notation')
class Notation extends Node {
  Notation.internal() : super.internal();

  @DomName('Notation.publicId')
  @DocsEditable
  String get publicId native "Notation_publicId_Getter";

  @DomName('Notation.systemId')
  @DocsEditable
  String get systemId native "Notation_systemId_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('Notification')
class Notification extends EventTarget {
  Notification.internal() : super.internal();

  @DomName('Notification.click')
  @DocsEditable
  static const EventStreamProvider<Event> clickEvent = const EventStreamProvider<Event>('click');

  @DomName('Notification.close')
  @DocsEditable
  static const EventStreamProvider<Event> closeEvent = const EventStreamProvider<Event>('close');

  @DomName('Notification.display')
  @DocsEditable
  static const EventStreamProvider<Event> displayEvent = const EventStreamProvider<Event>('display');

  @DomName('Notification.error')
  @DocsEditable
  static const EventStreamProvider<Event> errorEvent = const EventStreamProvider<Event>('error');

  @DomName('Notification.show')
  @DocsEditable
  static const EventStreamProvider<Event> showEvent = const EventStreamProvider<Event>('show');

  @DocsEditable
  factory Notification(String title, [Map options]) {
    if (!?options) {
      return Notification._create(title);
    }
    return Notification._create(title, options);
  }
  static Notification _create(String title, [Map options]) native "Notification_constructor_Callback";

  @DocsEditable
  @DomName('EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent')
  @deprecated
  NotificationEvents get on =>
    new NotificationEvents(this);

  @DomName('Notification.dir')
  @DocsEditable
  String get dir native "Notification_dir_Getter";

  @DomName('Notification.dir')
  @DocsEditable
  void set dir(String value) native "Notification_dir_Setter";

  @DomName('Notification.permission')
  @DocsEditable
  String get permission native "Notification_permission_Getter";

  @DomName('Notification.replaceId')
  @DocsEditable
  String get replaceId native "Notification_replaceId_Getter";

  @DomName('Notification.replaceId')
  @DocsEditable
  void set replaceId(String value) native "Notification_replaceId_Setter";

  @DomName('Notification.tag')
  @DocsEditable
  String get tag native "Notification_tag_Getter";

  @DomName('Notification.tag')
  @DocsEditable
  void set tag(String value) native "Notification_tag_Setter";

  @DomName('Notification.addEventListener')
  @DocsEditable
  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]) native "Notification_addEventListener_Callback";

  @DomName('Notification.cancel')
  @DocsEditable
  void cancel() native "Notification_cancel_Callback";

  @DomName('Notification.close')
  @DocsEditable
  void close() native "Notification_close_Callback";

  @DomName('Notification.dispatchEvent')
  @DocsEditable
  bool dispatchEvent(Event evt) native "Notification_dispatchEvent_Callback";

  @DomName('Notification.removeEventListener')
  @DocsEditable
  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]) native "Notification_removeEventListener_Callback";

  @DomName('Notification.requestPermission')
  @DocsEditable
  static void requestPermission(NotificationPermissionCallback callback) native "Notification_requestPermission_Callback";

  @DomName('Notification.show')
  @DocsEditable
  void show() native "Notification_show_Callback";

  @DomName('Notification.click')
  @DocsEditable
  Stream<Event> get onClick => clickEvent.forTarget(this);

  @DomName('Notification.close')
  @DocsEditable
  Stream<Event> get onClose => closeEvent.forTarget(this);

  @DomName('Notification.display')
  @DocsEditable
  Stream<Event> get onDisplay => displayEvent.forTarget(this);

  @DomName('Notification.error')
  @DocsEditable
  Stream<Event> get onError => errorEvent.forTarget(this);

  @DomName('Notification.show')
  @DocsEditable
  Stream<Event> get onShow => showEvent.forTarget(this);

}

@DocsEditable
@deprecated
class NotificationEvents extends Events {
  @DocsEditable
  NotificationEvents(EventTarget _ptr) : super(_ptr);

  @DocsEditable
  EventListenerList get click => this['click'];

  @DocsEditable
  EventListenerList get close => this['close'];

  @DocsEditable
  EventListenerList get display => this['display'];

  @DocsEditable
  EventListenerList get error => this['error'];

  @DocsEditable
  EventListenerList get show => this['show'];
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('NotificationCenter')
@SupportedBrowser(SupportedBrowser.CHROME)
@SupportedBrowser(SupportedBrowser.SAFARI)
@Experimental
class NotificationCenter extends NativeFieldWrapperClass1 {
  NotificationCenter.internal();

  /// Checks if this type is supported on the current platform.
  static bool get supported => true;

  @DomName('NotificationCenter.checkPermission')
  @DocsEditable
  int checkPermission() native "NotificationCenter_checkPermission_Callback";

  @DomName('NotificationCenter.createHTMLNotification')
  @DocsEditable
  Notification createHtmlNotification(String url) native "NotificationCenter_createHTMLNotification_Callback";

  @DomName('NotificationCenter.createNotification')
  @DocsEditable
  Notification createNotification(String iconUrl, String title, String body) native "NotificationCenter_createNotification_Callback";

  @DomName('NotificationCenter.requestPermission')
  @DocsEditable
  void requestPermission(VoidCallback callback) native "NotificationCenter_requestPermission_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


typedef void NotificationPermissionCallback(String permission);
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('HTMLOListElement')
class OListElement extends _Element_Merged {
  OListElement.internal() : super.internal();

  @DocsEditable
  factory OListElement() => document.$dom_createElement("ol");

  @DomName('HTMLOListElement.reversed')
  @DocsEditable
  bool get reversed native "HTMLOListElement_reversed_Getter";

  @DomName('HTMLOListElement.reversed')
  @DocsEditable
  void set reversed(bool value) native "HTMLOListElement_reversed_Setter";

  @DomName('HTMLOListElement.start')
  @DocsEditable
  int get start native "HTMLOListElement_start_Getter";

  @DomName('HTMLOListElement.start')
  @DocsEditable
  void set start(int value) native "HTMLOListElement_start_Setter";

  @DomName('HTMLOListElement.type')
  @DocsEditable
  String get type native "HTMLOListElement_type_Getter";

  @DomName('HTMLOListElement.type')
  @DocsEditable
  void set type(String value) native "HTMLOListElement_type_Setter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('HTMLObjectElement')
@SupportedBrowser(SupportedBrowser.CHROME)
@SupportedBrowser(SupportedBrowser.FIREFOX)
@SupportedBrowser(SupportedBrowser.SAFARI)
class ObjectElement extends _Element_Merged {
  ObjectElement.internal() : super.internal();

  @DocsEditable
  factory ObjectElement() => document.$dom_createElement("object");

  /// Checks if this type is supported on the current platform.
  static bool get supported => true;

  @DomName('HTMLObjectElement.code')
  @DocsEditable
  String get code native "HTMLObjectElement_code_Getter";

  @DomName('HTMLObjectElement.code')
  @DocsEditable
  void set code(String value) native "HTMLObjectElement_code_Setter";

  @DomName('HTMLObjectElement.data')
  @DocsEditable
  String get data native "HTMLObjectElement_data_Getter";

  @DomName('HTMLObjectElement.data')
  @DocsEditable
  void set data(String value) native "HTMLObjectElement_data_Setter";

  @DomName('HTMLObjectElement.form')
  @DocsEditable
  FormElement get form native "HTMLObjectElement_form_Getter";

  @DomName('HTMLObjectElement.height')
  @DocsEditable
  String get height native "HTMLObjectElement_height_Getter";

  @DomName('HTMLObjectElement.height')
  @DocsEditable
  void set height(String value) native "HTMLObjectElement_height_Setter";

  @DomName('HTMLObjectElement.name')
  @DocsEditable
  String get name native "HTMLObjectElement_name_Getter";

  @DomName('HTMLObjectElement.name')
  @DocsEditable
  void set name(String value) native "HTMLObjectElement_name_Setter";

  @DomName('HTMLObjectElement.type')
  @DocsEditable
  String get type native "HTMLObjectElement_type_Getter";

  @DomName('HTMLObjectElement.type')
  @DocsEditable
  void set type(String value) native "HTMLObjectElement_type_Setter";

  @DomName('HTMLObjectElement.useMap')
  @DocsEditable
  String get useMap native "HTMLObjectElement_useMap_Getter";

  @DomName('HTMLObjectElement.useMap')
  @DocsEditable
  void set useMap(String value) native "HTMLObjectElement_useMap_Setter";

  @DomName('HTMLObjectElement.validationMessage')
  @DocsEditable
  String get validationMessage native "HTMLObjectElement_validationMessage_Getter";

  @DomName('HTMLObjectElement.validity')
  @DocsEditable
  ValidityState get validity native "HTMLObjectElement_validity_Getter";

  @DomName('HTMLObjectElement.width')
  @DocsEditable
  String get width native "HTMLObjectElement_width_Getter";

  @DomName('HTMLObjectElement.width')
  @DocsEditable
  void set width(String value) native "HTMLObjectElement_width_Setter";

  @DomName('HTMLObjectElement.willValidate')
  @DocsEditable
  bool get willValidate native "HTMLObjectElement_willValidate_Getter";

  @DomName('HTMLObjectElement.checkValidity')
  @DocsEditable
  bool checkValidity() native "HTMLObjectElement_checkValidity_Callback";

  @DomName('HTMLObjectElement.setCustomValidity')
  @DocsEditable
  void setCustomValidity(String error) native "HTMLObjectElement_setCustomValidity_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('OESElementIndexUint')
class OesElementIndexUint extends NativeFieldWrapperClass1 {
  OesElementIndexUint.internal();

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('OESStandardDerivatives')
class OesStandardDerivatives extends NativeFieldWrapperClass1 {
  OesStandardDerivatives.internal();

  static const int FRAGMENT_SHADER_DERIVATIVE_HINT_OES = 0x8B8B;

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('OESTextureFloat')
class OesTextureFloat extends NativeFieldWrapperClass1 {
  OesTextureFloat.internal();

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('OESVertexArrayObject')
class OesVertexArrayObject extends NativeFieldWrapperClass1 {
  OesVertexArrayObject.internal();

  static const int VERTEX_ARRAY_BINDING_OES = 0x85B5;

  @DomName('OESVertexArrayObject.bindVertexArrayOES')
  @DocsEditable
  void bindVertexArray(WebGLVertexArrayObject arrayObject) native "OESVertexArrayObject_bindVertexArrayOES_Callback";

  @DomName('OESVertexArrayObject.createVertexArrayOES')
  @DocsEditable
  WebGLVertexArrayObject createVertexArray() native "OESVertexArrayObject_createVertexArrayOES_Callback";

  @DomName('OESVertexArrayObject.deleteVertexArrayOES')
  @DocsEditable
  void deleteVertexArray(WebGLVertexArrayObject arrayObject) native "OESVertexArrayObject_deleteVertexArrayOES_Callback";

  @DomName('OESVertexArrayObject.isVertexArrayOES')
  @DocsEditable
  bool isVertexArray(WebGLVertexArrayObject arrayObject) native "OESVertexArrayObject_isVertexArrayOES_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('HTMLOptGroupElement')
class OptGroupElement extends _Element_Merged {
  OptGroupElement.internal() : super.internal();

  @DocsEditable
  factory OptGroupElement() => document.$dom_createElement("optgroup");

  @DomName('HTMLOptGroupElement.disabled')
  @DocsEditable
  bool get disabled native "HTMLOptGroupElement_disabled_Getter";

  @DomName('HTMLOptGroupElement.disabled')
  @DocsEditable
  void set disabled(bool value) native "HTMLOptGroupElement_disabled_Setter";

  @DomName('HTMLOptGroupElement.label')
  @DocsEditable
  String get label native "HTMLOptGroupElement_label_Getter";

  @DomName('HTMLOptGroupElement.label')
  @DocsEditable
  void set label(String value) native "HTMLOptGroupElement_label_Setter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('HTMLOptionElement')
class OptionElement extends _Element_Merged {
  OptionElement.internal() : super.internal();

  @DocsEditable
  factory OptionElement([String data, String value, bool defaultSelected, bool selected]) {
    if (!?data) {
      return OptionElement._create();
    }
    if (!?value) {
      return OptionElement._create(data);
    }
    if (!?defaultSelected) {
      return OptionElement._create(data, value);
    }
    if (!?selected) {
      return OptionElement._create(data, value, defaultSelected);
    }
    return OptionElement._create(data, value, defaultSelected, selected);
  }
  static OptionElement _create([String data, String value, bool defaultSelected, bool selected]) native "HTMLOptionElement_constructor_Callback";

  @DomName('HTMLOptionElement.defaultSelected')
  @DocsEditable
  bool get defaultSelected native "HTMLOptionElement_defaultSelected_Getter";

  @DomName('HTMLOptionElement.defaultSelected')
  @DocsEditable
  void set defaultSelected(bool value) native "HTMLOptionElement_defaultSelected_Setter";

  @DomName('HTMLOptionElement.disabled')
  @DocsEditable
  bool get disabled native "HTMLOptionElement_disabled_Getter";

  @DomName('HTMLOptionElement.disabled')
  @DocsEditable
  void set disabled(bool value) native "HTMLOptionElement_disabled_Setter";

  @DomName('HTMLOptionElement.form')
  @DocsEditable
  FormElement get form native "HTMLOptionElement_form_Getter";

  @DomName('HTMLOptionElement.index')
  @DocsEditable
  int get index native "HTMLOptionElement_index_Getter";

  @DomName('HTMLOptionElement.label')
  @DocsEditable
  String get label native "HTMLOptionElement_label_Getter";

  @DomName('HTMLOptionElement.label')
  @DocsEditable
  void set label(String value) native "HTMLOptionElement_label_Setter";

  @DomName('HTMLOptionElement.selected')
  @DocsEditable
  bool get selected native "HTMLOptionElement_selected_Getter";

  @DomName('HTMLOptionElement.selected')
  @DocsEditable
  void set selected(bool value) native "HTMLOptionElement_selected_Setter";

  @DomName('HTMLOptionElement.value')
  @DocsEditable
  String get value native "HTMLOptionElement_value_Getter";

  @DomName('HTMLOptionElement.value')
  @DocsEditable
  void set value(String value) native "HTMLOptionElement_value_Setter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('HTMLOutputElement')
@SupportedBrowser(SupportedBrowser.CHROME)
@SupportedBrowser(SupportedBrowser.FIREFOX)
@SupportedBrowser(SupportedBrowser.SAFARI)
class OutputElement extends _Element_Merged {
  OutputElement.internal() : super.internal();

  @DocsEditable
  factory OutputElement() => document.$dom_createElement("output");

  /// Checks if this type is supported on the current platform.
  static bool get supported => true;

  @DomName('HTMLOutputElement.defaultValue')
  @DocsEditable
  String get defaultValue native "HTMLOutputElement_defaultValue_Getter";

  @DomName('HTMLOutputElement.defaultValue')
  @DocsEditable
  void set defaultValue(String value) native "HTMLOutputElement_defaultValue_Setter";

  @DomName('HTMLOutputElement.form')
  @DocsEditable
  FormElement get form native "HTMLOutputElement_form_Getter";

  @DomName('HTMLOutputElement.htmlFor')
  @DocsEditable
  DomSettableTokenList get htmlFor native "HTMLOutputElement_htmlFor_Getter";

  @DomName('HTMLOutputElement.htmlFor')
  @DocsEditable
  void set htmlFor(DomSettableTokenList value) native "HTMLOutputElement_htmlFor_Setter";

  @DomName('HTMLOutputElement.labels')
  @DocsEditable
  List<Node> get labels native "HTMLOutputElement_labels_Getter";

  @DomName('HTMLOutputElement.name')
  @DocsEditable
  String get name native "HTMLOutputElement_name_Getter";

  @DomName('HTMLOutputElement.name')
  @DocsEditable
  void set name(String value) native "HTMLOutputElement_name_Setter";

  @DomName('HTMLOutputElement.type')
  @DocsEditable
  String get type native "HTMLOutputElement_type_Getter";

  @DomName('HTMLOutputElement.validationMessage')
  @DocsEditable
  String get validationMessage native "HTMLOutputElement_validationMessage_Getter";

  @DomName('HTMLOutputElement.validity')
  @DocsEditable
  ValidityState get validity native "HTMLOutputElement_validity_Getter";

  @DomName('HTMLOutputElement.value')
  @DocsEditable
  String get value native "HTMLOutputElement_value_Getter";

  @DomName('HTMLOutputElement.value')
  @DocsEditable
  void set value(String value) native "HTMLOutputElement_value_Setter";

  @DomName('HTMLOutputElement.willValidate')
  @DocsEditable
  bool get willValidate native "HTMLOutputElement_willValidate_Getter";

  @DomName('HTMLOutputElement.checkValidity')
  @DocsEditable
  bool checkValidity() native "HTMLOutputElement_checkValidity_Callback";

  @DomName('HTMLOutputElement.setCustomValidity')
  @DocsEditable
  void setCustomValidity(String error) native "HTMLOutputElement_setCustomValidity_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('OverflowEvent')
class OverflowEvent extends Event {
  OverflowEvent.internal() : super.internal();

  static const int BOTH = 2;

  static const int HORIZONTAL = 0;

  static const int VERTICAL = 1;

  @DomName('OverflowEvent.horizontalOverflow')
  @DocsEditable
  bool get horizontalOverflow native "OverflowEvent_horizontalOverflow_Getter";

  @DomName('OverflowEvent.orient')
  @DocsEditable
  int get orient native "OverflowEvent_orient_Getter";

  @DomName('OverflowEvent.verticalOverflow')
  @DocsEditable
  bool get verticalOverflow native "OverflowEvent_verticalOverflow_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('PagePopupController')
class PagePopupController extends NativeFieldWrapperClass1 {
  PagePopupController.internal();

  @DomName('PagePopupController.formatMonth')
  @DocsEditable
  String formatMonth(int year, int zeroBaseMonth) native "PagePopupController_formatMonth_Callback";

  @DomName('PagePopupController.histogramEnumeration')
  @DocsEditable
  void histogramEnumeration(String name, int sample, int boundaryValue) native "PagePopupController_histogramEnumeration_Callback";

  @DomName('PagePopupController.localizeNumberString')
  @DocsEditable
  String localizeNumberString(String numberString) native "PagePopupController_localizeNumberString_Callback";

  @DomName('PagePopupController.setValueAndClosePopup')
  @DocsEditable
  void setValueAndClosePopup(int numberValue, String stringValue) native "PagePopupController_setValueAndClosePopup_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('PageTransitionEvent')
class PageTransitionEvent extends Event {
  PageTransitionEvent.internal() : super.internal();

  @DomName('PageTransitionEvent.persisted')
  @DocsEditable
  bool get persisted native "PageTransitionEvent_persisted_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('HTMLParagraphElement')
class ParagraphElement extends _Element_Merged {
  ParagraphElement.internal() : super.internal();

  @DocsEditable
  factory ParagraphElement() => document.$dom_createElement("p");

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('HTMLParamElement')
class ParamElement extends _Element_Merged {
  ParamElement.internal() : super.internal();

  @DocsEditable
  factory ParamElement() => document.$dom_createElement("param");

  @DomName('HTMLParamElement.name')
  @DocsEditable
  String get name native "HTMLParamElement_name_Getter";

  @DomName('HTMLParamElement.name')
  @DocsEditable
  void set name(String value) native "HTMLParamElement_name_Setter";

  @DomName('HTMLParamElement.value')
  @DocsEditable
  String get value native "HTMLParamElement_value_Getter";

  @DomName('HTMLParamElement.value')
  @DocsEditable
  void set value(String value) native "HTMLParamElement_value_Setter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('Performance')
@SupportedBrowser(SupportedBrowser.CHROME)
@SupportedBrowser(SupportedBrowser.FIREFOX)
@SupportedBrowser(SupportedBrowser.IE)
class Performance extends EventTarget {
  Performance.internal() : super.internal();

  /// Checks if this type is supported on the current platform.
  static bool get supported => true;

  @DomName('Performance.memory')
  @DocsEditable
  MemoryInfo get memory native "Performance_memory_Getter";

  @DomName('Performance.navigation')
  @DocsEditable
  PerformanceNavigation get navigation native "Performance_navigation_Getter";

  @DomName('Performance.timing')
  @DocsEditable
  PerformanceTiming get timing native "Performance_timing_Getter";

  @DomName('Performance.now')
  @DocsEditable
  num now() native "Performance_now_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('PerformanceNavigation')
class PerformanceNavigation extends NativeFieldWrapperClass1 {
  PerformanceNavigation.internal();

  static const int TYPE_BACK_FORWARD = 2;

  static const int TYPE_NAVIGATE = 0;

  static const int TYPE_RELOAD = 1;

  static const int TYPE_RESERVED = 255;

  @DomName('PerformanceNavigation.redirectCount')
  @DocsEditable
  int get redirectCount native "PerformanceNavigation_redirectCount_Getter";

  @DomName('PerformanceNavigation.type')
  @DocsEditable
  int get type native "PerformanceNavigation_type_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('PerformanceTiming')
class PerformanceTiming extends NativeFieldWrapperClass1 {
  PerformanceTiming.internal();

  @DomName('PerformanceTiming.connectEnd')
  @DocsEditable
  int get connectEnd native "PerformanceTiming_connectEnd_Getter";

  @DomName('PerformanceTiming.connectStart')
  @DocsEditable
  int get connectStart native "PerformanceTiming_connectStart_Getter";

  @DomName('PerformanceTiming.domComplete')
  @DocsEditable
  int get domComplete native "PerformanceTiming_domComplete_Getter";

  @DomName('PerformanceTiming.domContentLoadedEventEnd')
  @DocsEditable
  int get domContentLoadedEventEnd native "PerformanceTiming_domContentLoadedEventEnd_Getter";

  @DomName('PerformanceTiming.domContentLoadedEventStart')
  @DocsEditable
  int get domContentLoadedEventStart native "PerformanceTiming_domContentLoadedEventStart_Getter";

  @DomName('PerformanceTiming.domInteractive')
  @DocsEditable
  int get domInteractive native "PerformanceTiming_domInteractive_Getter";

  @DomName('PerformanceTiming.domLoading')
  @DocsEditable
  int get domLoading native "PerformanceTiming_domLoading_Getter";

  @DomName('PerformanceTiming.domainLookupEnd')
  @DocsEditable
  int get domainLookupEnd native "PerformanceTiming_domainLookupEnd_Getter";

  @DomName('PerformanceTiming.domainLookupStart')
  @DocsEditable
  int get domainLookupStart native "PerformanceTiming_domainLookupStart_Getter";

  @DomName('PerformanceTiming.fetchStart')
  @DocsEditable
  int get fetchStart native "PerformanceTiming_fetchStart_Getter";

  @DomName('PerformanceTiming.loadEventEnd')
  @DocsEditable
  int get loadEventEnd native "PerformanceTiming_loadEventEnd_Getter";

  @DomName('PerformanceTiming.loadEventStart')
  @DocsEditable
  int get loadEventStart native "PerformanceTiming_loadEventStart_Getter";

  @DomName('PerformanceTiming.navigationStart')
  @DocsEditable
  int get navigationStart native "PerformanceTiming_navigationStart_Getter";

  @DomName('PerformanceTiming.redirectEnd')
  @DocsEditable
  int get redirectEnd native "PerformanceTiming_redirectEnd_Getter";

  @DomName('PerformanceTiming.redirectStart')
  @DocsEditable
  int get redirectStart native "PerformanceTiming_redirectStart_Getter";

  @DomName('PerformanceTiming.requestStart')
  @DocsEditable
  int get requestStart native "PerformanceTiming_requestStart_Getter";

  @DomName('PerformanceTiming.responseEnd')
  @DocsEditable
  int get responseEnd native "PerformanceTiming_responseEnd_Getter";

  @DomName('PerformanceTiming.responseStart')
  @DocsEditable
  int get responseStart native "PerformanceTiming_responseStart_Getter";

  @DomName('PerformanceTiming.secureConnectionStart')
  @DocsEditable
  int get secureConnectionStart native "PerformanceTiming_secureConnectionStart_Getter";

  @DomName('PerformanceTiming.unloadEventEnd')
  @DocsEditable
  int get unloadEventEnd native "PerformanceTiming_unloadEventEnd_Getter";

  @DomName('PerformanceTiming.unloadEventStart')
  @DocsEditable
  int get unloadEventStart native "PerformanceTiming_unloadEventStart_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('PopStateEvent')
@SupportedBrowser(SupportedBrowser.CHROME)
@SupportedBrowser(SupportedBrowser.FIREFOX)
@SupportedBrowser(SupportedBrowser.IE, '10')
@SupportedBrowser(SupportedBrowser.SAFARI)
class PopStateEvent extends Event {
  PopStateEvent.internal() : super.internal();

  @DomName('PopStateEvent.state')
  @DocsEditable
  Object get state native "PopStateEvent_state_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


typedef void PositionCallback(Geoposition position);
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('PositionError')
class PositionError extends NativeFieldWrapperClass1 {
  PositionError.internal();

  static const int PERMISSION_DENIED = 1;

  static const int POSITION_UNAVAILABLE = 2;

  static const int TIMEOUT = 3;

  @DomName('PositionError.code')
  @DocsEditable
  int get code native "PositionError_code_Getter";

  @DomName('PositionError.message')
  @DocsEditable
  String get message native "PositionError_message_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


typedef void PositionErrorCallback(PositionError error);
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('HTMLPreElement')
class PreElement extends _Element_Merged {
  PreElement.internal() : super.internal();

  @DocsEditable
  factory PreElement() => document.$dom_createElement("pre");

  @DomName('HTMLPreElement.wrap')
  @DocsEditable
  bool get wrap native "HTMLPreElement_wrap_Getter";

  @DomName('HTMLPreElement.wrap')
  @DocsEditable
  void set wrap(bool value) native "HTMLPreElement_wrap_Setter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('ProcessingInstruction')
class ProcessingInstruction extends Node {
  ProcessingInstruction.internal() : super.internal();

  @DomName('ProcessingInstruction.data')
  @DocsEditable
  String get data native "ProcessingInstruction_data_Getter";

  @DomName('ProcessingInstruction.data')
  @DocsEditable
  void set data(String value) native "ProcessingInstruction_data_Setter";

  @DomName('ProcessingInstruction.sheet')
  @DocsEditable
  StyleSheet get sheet native "ProcessingInstruction_sheet_Getter";

  @DomName('ProcessingInstruction.target')
  @DocsEditable
  String get target native "ProcessingInstruction_target_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('HTMLProgressElement')
@SupportedBrowser(SupportedBrowser.CHROME)
@SupportedBrowser(SupportedBrowser.FIREFOX)
@SupportedBrowser(SupportedBrowser.IE, '10')
@SupportedBrowser(SupportedBrowser.SAFARI)
class ProgressElement extends _Element_Merged {
  ProgressElement.internal() : super.internal();

  @DocsEditable
  factory ProgressElement() => document.$dom_createElement("progress");

  /// Checks if this type is supported on the current platform.
  static bool get supported => true;

  @DomName('HTMLProgressElement.labels')
  @DocsEditable
  List<Node> get labels native "HTMLProgressElement_labels_Getter";

  @DomName('HTMLProgressElement.max')
  @DocsEditable
  num get max native "HTMLProgressElement_max_Getter";

  @DomName('HTMLProgressElement.max')
  @DocsEditable
  void set max(num value) native "HTMLProgressElement_max_Setter";

  @DomName('HTMLProgressElement.position')
  @DocsEditable
  num get position native "HTMLProgressElement_position_Getter";

  @DomName('HTMLProgressElement.value')
  @DocsEditable
  num get value native "HTMLProgressElement_value_Getter";

  @DomName('HTMLProgressElement.value')
  @DocsEditable
  void set value(num value) native "HTMLProgressElement_value_Setter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('ProgressEvent')
class ProgressEvent extends Event {
  ProgressEvent.internal() : super.internal();

  @DomName('ProgressEvent.lengthComputable')
  @DocsEditable
  bool get lengthComputable native "ProgressEvent_lengthComputable_Getter";

  @DomName('ProgressEvent.loaded')
  @DocsEditable
  int get loaded native "ProgressEvent_loaded_Getter";

  @DomName('ProgressEvent.total')
  @DocsEditable
  int get total native "ProgressEvent_total_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('HTMLQuoteElement')
class QuoteElement extends _Element_Merged {
  QuoteElement.internal() : super.internal();

  @DomName('HTMLQuoteElement.cite')
  @DocsEditable
  String get cite native "HTMLQuoteElement_cite_Getter";

  @DomName('HTMLQuoteElement.cite')
  @DocsEditable
  void set cite(String value) native "HTMLQuoteElement_cite_Setter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


typedef void RtcErrorCallback(String errorInformation);
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


typedef void RtcSessionDescriptionCallback(RtcSessionDescription sdp);
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


typedef void RtcStatsCallback(RtcStatsResponse response);
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('RadioNodeList')
class RadioNodeList extends NodeList {
  RadioNodeList.internal() : super.internal();

  @DomName('RadioNodeList.value')
  @DocsEditable
  String get value native "RadioNodeList_value_Getter";

  @DomName('RadioNodeList.value')
  @DocsEditable
  void set value(String value) native "RadioNodeList_value_Setter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DomName('Range')
class Range extends NativeFieldWrapperClass1 {
  factory Range() => document.$dom_createRange();

  Range.internal();

  static const int END_TO_END = 2;

  static const int END_TO_START = 3;

  static const int NODE_AFTER = 1;

  static const int NODE_BEFORE = 0;

  static const int NODE_BEFORE_AND_AFTER = 2;

  static const int NODE_INSIDE = 3;

  static const int START_TO_END = 1;

  static const int START_TO_START = 0;

  @DomName('Range.collapsed')
  @DocsEditable
  bool get collapsed native "Range_collapsed_Getter";

  @DomName('Range.commonAncestorContainer')
  @DocsEditable
  Node get commonAncestorContainer native "Range_commonAncestorContainer_Getter";

  @DomName('Range.endContainer')
  @DocsEditable
  Node get endContainer native "Range_endContainer_Getter";

  @DomName('Range.endOffset')
  @DocsEditable
  int get endOffset native "Range_endOffset_Getter";

  @DomName('Range.startContainer')
  @DocsEditable
  Node get startContainer native "Range_startContainer_Getter";

  @DomName('Range.startOffset')
  @DocsEditable
  int get startOffset native "Range_startOffset_Getter";

  @DomName('Range.cloneContents')
  @DocsEditable
  DocumentFragment cloneContents() native "Range_cloneContents_Callback";

  @DomName('Range.cloneRange')
  @DocsEditable
  Range cloneRange() native "Range_cloneRange_Callback";

  @DomName('Range.collapse')
  @DocsEditable
  void collapse(bool toStart) native "Range_collapse_Callback";

  @DomName('Range.compareNode')
  @DocsEditable
  int compareNode(Node refNode) native "Range_compareNode_Callback";

  @DomName('Range.comparePoint')
  @DocsEditable
  int comparePoint(Node refNode, int offset) native "Range_comparePoint_Callback";

  @DomName('Range.createContextualFragment')
  @DocsEditable
  DocumentFragment createContextualFragment(String html) native "Range_createContextualFragment_Callback";

  @DomName('Range.deleteContents')
  @DocsEditable
  void deleteContents() native "Range_deleteContents_Callback";

  @DomName('Range.detach')
  @DocsEditable
  void detach() native "Range_detach_Callback";

  @DomName('Range.expand')
  @DocsEditable
  void expand(String unit) native "Range_expand_Callback";

  @DomName('Range.extractContents')
  @DocsEditable
  DocumentFragment extractContents() native "Range_extractContents_Callback";

  @DomName('Range.getBoundingClientRect')
  @DocsEditable
  ClientRect getBoundingClientRect() native "Range_getBoundingClientRect_Callback";

  @DomName('Range.getClientRects')
  @DocsEditable
  List<ClientRect> getClientRects() native "Range_getClientRects_Callback";

  @DomName('Range.insertNode')
  @DocsEditable
  void insertNode(Node newNode) native "Range_insertNode_Callback";

  @DomName('Range.intersectsNode')
  @DocsEditable
  bool intersectsNode(Node refNode) native "Range_intersectsNode_Callback";

  @DomName('Range.isPointInRange')
  @DocsEditable
  bool isPointInRange(Node refNode, int offset) native "Range_isPointInRange_Callback";

  @DomName('Range.selectNode')
  @DocsEditable
  void selectNode(Node refNode) native "Range_selectNode_Callback";

  @DomName('Range.selectNodeContents')
  @DocsEditable
  void selectNodeContents(Node refNode) native "Range_selectNodeContents_Callback";

  @DomName('Range.setEnd')
  @DocsEditable
  void setEnd(Node refNode, int offset) native "Range_setEnd_Callback";

  @DomName('Range.setEndAfter')
  @DocsEditable
  void setEndAfter(Node refNode) native "Range_setEndAfter_Callback";

  @DomName('Range.setEndBefore')
  @DocsEditable
  void setEndBefore(Node refNode) native "Range_setEndBefore_Callback";

  @DomName('Range.setStart')
  @DocsEditable
  void setStart(Node refNode, int offset) native "Range_setStart_Callback";

  @DomName('Range.setStartAfter')
  @DocsEditable
  void setStartAfter(Node refNode) native "Range_setStartAfter_Callback";

  @DomName('Range.setStartBefore')
  @DocsEditable
  void setStartBefore(Node refNode) native "Range_setStartBefore_Callback";

  @DomName('Range.surroundContents')
  @DocsEditable
  void surroundContents(Node newParent) native "Range_surroundContents_Callback";

  @DomName('Range.toString')
  @DocsEditable
  String toString() native "Range_toString_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('RangeException')
class RangeException extends NativeFieldWrapperClass1 {
  RangeException.internal();

  static const int BAD_BOUNDARYPOINTS_ERR = 1;

  static const int INVALID_NODE_TYPE_ERR = 2;

  @DomName('RangeException.code')
  @DocsEditable
  int get code native "RangeException_code_Getter";

  @DomName('RangeException.message')
  @DocsEditable
  String get message native "RangeException_message_Getter";

  @DomName('RangeException.name')
  @DocsEditable
  String get name native "RangeException_name_Getter";

  @DomName('RangeException.toString')
  @DocsEditable
  String toString() native "RangeException_toString_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('Rect')
class Rect extends NativeFieldWrapperClass1 {
  Rect.internal();

  @DomName('Rect.bottom')
  @DocsEditable
  CssPrimitiveValue get bottom native "Rect_bottom_Getter";

  @DomName('Rect.left')
  @DocsEditable
  CssPrimitiveValue get left native "Rect_left_Getter";

  @DomName('Rect.right')
  @DocsEditable
  CssPrimitiveValue get right native "Rect_right_Getter";

  @DomName('Rect.top')
  @DocsEditable
  CssPrimitiveValue get top native "Rect_top_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


typedef void RequestAnimationFrameCallback(num highResTime);
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('RGBColor')
class RgbColor extends NativeFieldWrapperClass1 {
  RgbColor.internal();

  @DomName('RGBColor.blue')
  @DocsEditable
  CssPrimitiveValue get blue native "RGBColor_blue_Getter";

  @DomName('RGBColor.green')
  @DocsEditable
  CssPrimitiveValue get green native "RGBColor_green_Getter";

  @DomName('RGBColor.red')
  @DocsEditable
  CssPrimitiveValue get red native "RGBColor_red_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('RTCDataChannel')
class RtcDataChannel extends EventTarget {
  RtcDataChannel.internal() : super.internal();

  @DomName('RTCDataChannel.close')
  @DocsEditable
  static const EventStreamProvider<Event> closeEvent = const EventStreamProvider<Event>('close');

  @DomName('RTCDataChannel.error')
  @DocsEditable
  static const EventStreamProvider<Event> errorEvent = const EventStreamProvider<Event>('error');

  @DomName('RTCDataChannel.message')
  @DocsEditable
  static const EventStreamProvider<MessageEvent> messageEvent = const EventStreamProvider<MessageEvent>('message');

  @DomName('RTCDataChannel.open')
  @DocsEditable
  static const EventStreamProvider<Event> openEvent = const EventStreamProvider<Event>('open');

  @DocsEditable
  @DomName('EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent')
  @deprecated
  RtcDataChannelEvents get on =>
    new RtcDataChannelEvents(this);

  @DomName('RTCDataChannel.binaryType')
  @DocsEditable
  String get binaryType native "RTCDataChannel_binaryType_Getter";

  @DomName('RTCDataChannel.binaryType')
  @DocsEditable
  void set binaryType(String value) native "RTCDataChannel_binaryType_Setter";

  @DomName('RTCDataChannel.bufferedAmount')
  @DocsEditable
  int get bufferedAmount native "RTCDataChannel_bufferedAmount_Getter";

  @DomName('RTCDataChannel.label')
  @DocsEditable
  String get label native "RTCDataChannel_label_Getter";

  @DomName('RTCDataChannel.readyState')
  @DocsEditable
  String get readyState native "RTCDataChannel_readyState_Getter";

  @DomName('RTCDataChannel.reliable')
  @DocsEditable
  bool get reliable native "RTCDataChannel_reliable_Getter";

  @DomName('RTCDataChannel.addEventListener')
  @DocsEditable
  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]) native "RTCDataChannel_addEventListener_Callback";

  @DomName('RTCDataChannel.close')
  @DocsEditable
  void close() native "RTCDataChannel_close_Callback";

  @DomName('RTCDataChannel.dispatchEvent')
  @DocsEditable
  bool dispatchEvent(Event event) native "RTCDataChannel_dispatchEvent_Callback";

  @DomName('RTCDataChannel.removeEventListener')
  @DocsEditable
  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]) native "RTCDataChannel_removeEventListener_Callback";

  void send(data) {
    if ((data is ArrayBuffer || data == null)) {
      _send_1(data);
      return;
    }
    if ((data is ArrayBufferView || data == null)) {
      _send_2(data);
      return;
    }
    if ((data is Blob || data == null)) {
      _send_3(data);
      return;
    }
    if ((data is String || data == null)) {
      _send_4(data);
      return;
    }
    throw new ArgumentError("Incorrect number or type of arguments");
  }

  @DomName('RTCDataChannel._send_1')
  @DocsEditable
  void _send_1(data) native "RTCDataChannel__send_1_Callback";

  @DomName('RTCDataChannel._send_2')
  @DocsEditable
  void _send_2(data) native "RTCDataChannel__send_2_Callback";

  @DomName('RTCDataChannel._send_3')
  @DocsEditable
  void _send_3(data) native "RTCDataChannel__send_3_Callback";

  @DomName('RTCDataChannel._send_4')
  @DocsEditable
  void _send_4(data) native "RTCDataChannel__send_4_Callback";

  @DomName('RTCDataChannel.close')
  @DocsEditable
  Stream<Event> get onClose => closeEvent.forTarget(this);

  @DomName('RTCDataChannel.error')
  @DocsEditable
  Stream<Event> get onError => errorEvent.forTarget(this);

  @DomName('RTCDataChannel.message')
  @DocsEditable
  Stream<MessageEvent> get onMessage => messageEvent.forTarget(this);

  @DomName('RTCDataChannel.open')
  @DocsEditable
  Stream<Event> get onOpen => openEvent.forTarget(this);

}

@DocsEditable
@deprecated
class RtcDataChannelEvents extends Events {
  @DocsEditable
  RtcDataChannelEvents(EventTarget _ptr) : super(_ptr);

  @DocsEditable
  EventListenerList get close => this['close'];

  @DocsEditable
  EventListenerList get error => this['error'];

  @DocsEditable
  EventListenerList get message => this['message'];

  @DocsEditable
  EventListenerList get open => this['open'];
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('RTCDataChannelEvent')
class RtcDataChannelEvent extends Event {
  RtcDataChannelEvent.internal() : super.internal();

  @DomName('RTCDataChannelEvent.channel')
  @DocsEditable
  RtcDataChannel get channel native "RTCDataChannelEvent_channel_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('RTCIceCandidate')
class RtcIceCandidate extends NativeFieldWrapperClass1 {
  RtcIceCandidate.internal();

  @DocsEditable
  factory RtcIceCandidate(Map dictionary) => RtcIceCandidate._create(dictionary);
  static RtcIceCandidate _create(Map dictionary) native "RTCIceCandidate_constructor_Callback";

  @DomName('RTCIceCandidate.candidate')
  @DocsEditable
  String get candidate native "RTCIceCandidate_candidate_Getter";

  @DomName('RTCIceCandidate.sdpMLineIndex')
  @DocsEditable
  int get sdpMLineIndex native "RTCIceCandidate_sdpMLineIndex_Getter";

  @DomName('RTCIceCandidate.sdpMid')
  @DocsEditable
  String get sdpMid native "RTCIceCandidate_sdpMid_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('RTCIceCandidateEvent')
class RtcIceCandidateEvent extends Event {
  RtcIceCandidateEvent.internal() : super.internal();

  @DomName('RTCIceCandidateEvent.candidate')
  @DocsEditable
  RtcIceCandidate get candidate native "RTCIceCandidateEvent_candidate_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('RTCPeerConnection')
class RtcPeerConnection extends EventTarget {
  RtcPeerConnection.internal() : super.internal();

  @DomName('RTCPeerConnection.addstream')
  @DocsEditable
  static const EventStreamProvider<MediaStreamEvent> addStreamEvent = const EventStreamProvider<MediaStreamEvent>('addstream');

  @DomName('RTCPeerConnection.datachannel')
  @DocsEditable
  static const EventStreamProvider<RtcDataChannelEvent> dataChannelEvent = const EventStreamProvider<RtcDataChannelEvent>('datachannel');

  @DomName('RTCPeerConnection.icecandidate')
  @DocsEditable
  static const EventStreamProvider<RtcIceCandidateEvent> iceCandidateEvent = const EventStreamProvider<RtcIceCandidateEvent>('icecandidate');

  @DomName('RTCPeerConnection.icechange')
  @DocsEditable
  static const EventStreamProvider<Event> iceChangeEvent = const EventStreamProvider<Event>('icechange');

  @DomName('RTCPeerConnection.negotiationneeded')
  @DocsEditable
  static const EventStreamProvider<Event> negotiationNeededEvent = const EventStreamProvider<Event>('negotiationneeded');

  @DomName('RTCPeerConnection.open')
  @DocsEditable
  static const EventStreamProvider<Event> openEvent = const EventStreamProvider<Event>('open');

  @DomName('RTCPeerConnection.removestream')
  @DocsEditable
  static const EventStreamProvider<MediaStreamEvent> removeStreamEvent = const EventStreamProvider<MediaStreamEvent>('removestream');

  @DomName('RTCPeerConnection.statechange')
  @DocsEditable
  static const EventStreamProvider<Event> stateChangeEvent = const EventStreamProvider<Event>('statechange');

  @DocsEditable
  factory RtcPeerConnection(Map rtcIceServers, [Map mediaConstraints]) {
    if (!?mediaConstraints) {
      return RtcPeerConnection._create(rtcIceServers);
    }
    return RtcPeerConnection._create(rtcIceServers, mediaConstraints);
  }
  static RtcPeerConnection _create(Map rtcIceServers, [Map mediaConstraints]) native "RTCPeerConnection_constructor_Callback";

  @DocsEditable
  @DomName('EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent')
  @deprecated
  RtcPeerConnectionEvents get on =>
    new RtcPeerConnectionEvents(this);

  @DomName('RTCPeerConnection.iceGatheringState')
  @DocsEditable
  String get iceGatheringState native "RTCPeerConnection_iceGatheringState_Getter";

  @DomName('RTCPeerConnection.iceState')
  @DocsEditable
  String get iceState native "RTCPeerConnection_iceState_Getter";

  @DomName('RTCPeerConnection.localDescription')
  @DocsEditable
  RtcSessionDescription get localDescription native "RTCPeerConnection_localDescription_Getter";

  @DomName('RTCPeerConnection.localStreams')
  @DocsEditable
  List<MediaStream> get localStreams native "RTCPeerConnection_localStreams_Getter";

  @DomName('RTCPeerConnection.readyState')
  @DocsEditable
  String get readyState native "RTCPeerConnection_readyState_Getter";

  @DomName('RTCPeerConnection.remoteDescription')
  @DocsEditable
  RtcSessionDescription get remoteDescription native "RTCPeerConnection_remoteDescription_Getter";

  @DomName('RTCPeerConnection.remoteStreams')
  @DocsEditable
  List<MediaStream> get remoteStreams native "RTCPeerConnection_remoteStreams_Getter";

  @DomName('RTCPeerConnection.addEventListener')
  @DocsEditable
  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]) native "RTCPeerConnection_addEventListener_Callback";

  @DomName('RTCPeerConnection.addIceCandidate')
  @DocsEditable
  void addIceCandidate(RtcIceCandidate candidate) native "RTCPeerConnection_addIceCandidate_Callback";

  @DomName('RTCPeerConnection.addStream')
  @DocsEditable
  void addStream(MediaStream stream, [Map mediaConstraints]) native "RTCPeerConnection_addStream_Callback";

  @DomName('RTCPeerConnection.close')
  @DocsEditable
  void close() native "RTCPeerConnection_close_Callback";

  @DomName('RTCPeerConnection.createAnswer')
  @DocsEditable
  void createAnswer(RtcSessionDescriptionCallback successCallback, [RtcErrorCallback failureCallback, Map mediaConstraints]) native "RTCPeerConnection_createAnswer_Callback";

  @DomName('RTCPeerConnection.createDataChannel')
  @DocsEditable
  RtcDataChannel createDataChannel(String label, [Map options]) native "RTCPeerConnection_createDataChannel_Callback";

  @DomName('RTCPeerConnection.createOffer')
  @DocsEditable
  void createOffer(RtcSessionDescriptionCallback successCallback, [RtcErrorCallback failureCallback, Map mediaConstraints]) native "RTCPeerConnection_createOffer_Callback";

  @DomName('RTCPeerConnection.dispatchEvent')
  @DocsEditable
  bool dispatchEvent(Event event) native "RTCPeerConnection_dispatchEvent_Callback";

  @DomName('RTCPeerConnection.getStats')
  @DocsEditable
  void getStats(RtcStatsCallback successCallback, MediaStreamTrack selector) native "RTCPeerConnection_getStats_Callback";

  @DomName('RTCPeerConnection.removeEventListener')
  @DocsEditable
  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]) native "RTCPeerConnection_removeEventListener_Callback";

  @DomName('RTCPeerConnection.removeStream')
  @DocsEditable
  void removeStream(MediaStream stream) native "RTCPeerConnection_removeStream_Callback";

  @DomName('RTCPeerConnection.setLocalDescription')
  @DocsEditable
  void setLocalDescription(RtcSessionDescription description, [VoidCallback successCallback, RtcErrorCallback failureCallback]) native "RTCPeerConnection_setLocalDescription_Callback";

  @DomName('RTCPeerConnection.setRemoteDescription')
  @DocsEditable
  void setRemoteDescription(RtcSessionDescription description, [VoidCallback successCallback, RtcErrorCallback failureCallback]) native "RTCPeerConnection_setRemoteDescription_Callback";

  @DomName('RTCPeerConnection.updateIce')
  @DocsEditable
  void updateIce([Map configuration, Map mediaConstraints]) native "RTCPeerConnection_updateIce_Callback";

  @DomName('RTCPeerConnection.addstream')
  @DocsEditable
  Stream<MediaStreamEvent> get onAddStream => addStreamEvent.forTarget(this);

  @DomName('RTCPeerConnection.datachannel')
  @DocsEditable
  Stream<RtcDataChannelEvent> get onDataChannel => dataChannelEvent.forTarget(this);

  @DomName('RTCPeerConnection.icecandidate')
  @DocsEditable
  Stream<RtcIceCandidateEvent> get onIceCandidate => iceCandidateEvent.forTarget(this);

  @DomName('RTCPeerConnection.icechange')
  @DocsEditable
  Stream<Event> get onIceChange => iceChangeEvent.forTarget(this);

  @DomName('RTCPeerConnection.negotiationneeded')
  @DocsEditable
  Stream<Event> get onNegotiationNeeded => negotiationNeededEvent.forTarget(this);

  @DomName('RTCPeerConnection.open')
  @DocsEditable
  Stream<Event> get onOpen => openEvent.forTarget(this);

  @DomName('RTCPeerConnection.removestream')
  @DocsEditable
  Stream<MediaStreamEvent> get onRemoveStream => removeStreamEvent.forTarget(this);

  @DomName('RTCPeerConnection.statechange')
  @DocsEditable
  Stream<Event> get onStateChange => stateChangeEvent.forTarget(this);

}

@DocsEditable
@deprecated
class RtcPeerConnectionEvents extends Events {
  @DocsEditable
  RtcPeerConnectionEvents(EventTarget _ptr) : super(_ptr);

  @DocsEditable
  EventListenerList get addStream => this['addstream'];

  @DocsEditable
  EventListenerList get iceCandidate => this['icecandidate'];

  @DocsEditable
  EventListenerList get iceChange => this['icechange'];

  @DocsEditable
  EventListenerList get negotiationNeeded => this['negotiationneeded'];

  @DocsEditable
  EventListenerList get open => this['open'];

  @DocsEditable
  EventListenerList get removeStream => this['removestream'];

  @DocsEditable
  EventListenerList get stateChange => this['statechange'];
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('RTCSessionDescription')
class RtcSessionDescription extends NativeFieldWrapperClass1 {
  RtcSessionDescription.internal();

  @DocsEditable
  factory RtcSessionDescription(Map dictionary) => RtcSessionDescription._create(dictionary);
  static RtcSessionDescription _create(Map dictionary) native "RTCSessionDescription_constructor_Callback";

  @DomName('RTCSessionDescription.sdp')
  @DocsEditable
  String get sdp native "RTCSessionDescription_sdp_Getter";

  @DomName('RTCSessionDescription.sdp')
  @DocsEditable
  void set sdp(String value) native "RTCSessionDescription_sdp_Setter";

  @DomName('RTCSessionDescription.type')
  @DocsEditable
  String get type native "RTCSessionDescription_type_Getter";

  @DomName('RTCSessionDescription.type')
  @DocsEditable
  void set type(String value) native "RTCSessionDescription_type_Setter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('RTCStatsElement')
class RtcStatsElement extends NativeFieldWrapperClass1 {
  RtcStatsElement.internal();

  @DomName('RTCStatsElement.timestamp')
  @DocsEditable
  Date get timestamp native "RTCStatsElement_timestamp_Getter";

  @DomName('RTCStatsElement.names')
  @DocsEditable
  List<String> names() native "RTCStatsElement_names_Callback";

  @DomName('RTCStatsElement.stat')
  @DocsEditable
  String stat(String name) native "RTCStatsElement_stat_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('RTCStatsReport')
class RtcStatsReport extends NativeFieldWrapperClass1 {
  RtcStatsReport.internal();

  @DomName('RTCStatsReport.local')
  @DocsEditable
  RtcStatsElement get local native "RTCStatsReport_local_Getter";

  @DomName('RTCStatsReport.remote')
  @DocsEditable
  RtcStatsElement get remote native "RTCStatsReport_remote_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('RTCStatsResponse')
class RtcStatsResponse extends NativeFieldWrapperClass1 {
  RtcStatsResponse.internal();

  @DomName('RTCStatsResponse.result')
  @DocsEditable
  List<RtcStatsReport> result() native "RTCStatsResponse_result_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


typedef void SqlStatementCallback(SqlTransaction transaction, SqlResultSet resultSet);
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


typedef void SqlStatementErrorCallback(SqlTransaction transaction, SqlError error);
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


typedef void SqlTransactionCallback(SqlTransaction transaction);
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


typedef void SqlTransactionErrorCallback(SqlError error);
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


typedef void SqlTransactionSyncCallback(SqlTransactionSync transaction);
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('Screen')
class Screen extends NativeFieldWrapperClass1 {
  Screen.internal();

  @DomName('Screen.availHeight')
  @DocsEditable
  int get availHeight native "Screen_availHeight_Getter";

  @DomName('Screen.availLeft')
  @DocsEditable
  int get availLeft native "Screen_availLeft_Getter";

  @DomName('Screen.availTop')
  @DocsEditable
  int get availTop native "Screen_availTop_Getter";

  @DomName('Screen.availWidth')
  @DocsEditable
  int get availWidth native "Screen_availWidth_Getter";

  @DomName('Screen.colorDepth')
  @DocsEditable
  int get colorDepth native "Screen_colorDepth_Getter";

  @DomName('Screen.height')
  @DocsEditable
  int get height native "Screen_height_Getter";

  @DomName('Screen.pixelDepth')
  @DocsEditable
  int get pixelDepth native "Screen_pixelDepth_Getter";

  @DomName('Screen.width')
  @DocsEditable
  int get width native "Screen_width_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('HTMLScriptElement')
class ScriptElement extends _Element_Merged {
  ScriptElement.internal() : super.internal();

  @DocsEditable
  factory ScriptElement() => document.$dom_createElement("script");

  @DomName('HTMLScriptElement.async')
  @DocsEditable
  bool get async native "HTMLScriptElement_async_Getter";

  @DomName('HTMLScriptElement.async')
  @DocsEditable
  void set async(bool value) native "HTMLScriptElement_async_Setter";

  @DomName('HTMLScriptElement.charset')
  @DocsEditable
  String get charset native "HTMLScriptElement_charset_Getter";

  @DomName('HTMLScriptElement.charset')
  @DocsEditable
  void set charset(String value) native "HTMLScriptElement_charset_Setter";

  @DomName('HTMLScriptElement.crossOrigin')
  @DocsEditable
  String get crossOrigin native "HTMLScriptElement_crossOrigin_Getter";

  @DomName('HTMLScriptElement.crossOrigin')
  @DocsEditable
  void set crossOrigin(String value) native "HTMLScriptElement_crossOrigin_Setter";

  @DomName('HTMLScriptElement.defer')
  @DocsEditable
  bool get defer native "HTMLScriptElement_defer_Getter";

  @DomName('HTMLScriptElement.defer')
  @DocsEditable
  void set defer(bool value) native "HTMLScriptElement_defer_Setter";

  @DomName('HTMLScriptElement.event')
  @DocsEditable
  String get event native "HTMLScriptElement_event_Getter";

  @DomName('HTMLScriptElement.event')
  @DocsEditable
  void set event(String value) native "HTMLScriptElement_event_Setter";

  @DomName('HTMLScriptElement.htmlFor')
  @DocsEditable
  String get htmlFor native "HTMLScriptElement_htmlFor_Getter";

  @DomName('HTMLScriptElement.htmlFor')
  @DocsEditable
  void set htmlFor(String value) native "HTMLScriptElement_htmlFor_Setter";

  @DomName('HTMLScriptElement.src')
  @DocsEditable
  String get src native "HTMLScriptElement_src_Getter";

  @DomName('HTMLScriptElement.src')
  @DocsEditable
  void set src(String value) native "HTMLScriptElement_src_Setter";

  @DomName('HTMLScriptElement.type')
  @DocsEditable
  String get type native "HTMLScriptElement_type_Getter";

  @DomName('HTMLScriptElement.type')
  @DocsEditable
  void set type(String value) native "HTMLScriptElement_type_Setter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('ScriptProfile')
class ScriptProfile extends NativeFieldWrapperClass1 {
  ScriptProfile.internal();

  @DomName('ScriptProfile.head')
  @DocsEditable
  ScriptProfileNode get head native "ScriptProfile_head_Getter";

  @DomName('ScriptProfile.idleTime')
  @DocsEditable
  num get idleTime native "ScriptProfile_idleTime_Getter";

  @DomName('ScriptProfile.title')
  @DocsEditable
  String get title native "ScriptProfile_title_Getter";

  @DomName('ScriptProfile.uid')
  @DocsEditable
  int get uid native "ScriptProfile_uid_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('ScriptProfileNode')
class ScriptProfileNode extends NativeFieldWrapperClass1 {
  ScriptProfileNode.internal();

  @DomName('ScriptProfileNode.callUID')
  @DocsEditable
  int get callUid native "ScriptProfileNode_callUID_Getter";

  @DomName('ScriptProfileNode.functionName')
  @DocsEditable
  String get functionName native "ScriptProfileNode_functionName_Getter";

  @DomName('ScriptProfileNode.lineNumber')
  @DocsEditable
  int get lineNumber native "ScriptProfileNode_lineNumber_Getter";

  @DomName('ScriptProfileNode.numberOfCalls')
  @DocsEditable
  int get numberOfCalls native "ScriptProfileNode_numberOfCalls_Getter";

  @DomName('ScriptProfileNode.selfTime')
  @DocsEditable
  num get selfTime native "ScriptProfileNode_selfTime_Getter";

  @DomName('ScriptProfileNode.totalTime')
  @DocsEditable
  num get totalTime native "ScriptProfileNode_totalTime_Getter";

  @DomName('ScriptProfileNode.url')
  @DocsEditable
  String get url native "ScriptProfileNode_url_Getter";

  @DomName('ScriptProfileNode.visible')
  @DocsEditable
  bool get visible native "ScriptProfileNode_visible_Getter";

  @DomName('ScriptProfileNode.children')
  @DocsEditable
  List<ScriptProfileNode> children() native "ScriptProfileNode_children_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.


@DomName('HTMLSelectElement')
class SelectElement extends _Element_Merged {
  SelectElement.internal() : super.internal();

  @DocsEditable
  factory SelectElement() => document.$dom_createElement("select");

  @DomName('HTMLSelectElement.autofocus')
  @DocsEditable
  bool get autofocus native "HTMLSelectElement_autofocus_Getter";

  @DomName('HTMLSelectElement.autofocus')
  @DocsEditable
  void set autofocus(bool value) native "HTMLSelectElement_autofocus_Setter";

  @DomName('HTMLSelectElement.disabled')
  @DocsEditable
  bool get disabled native "HTMLSelectElement_disabled_Getter";

  @DomName('HTMLSelectElement.disabled')
  @DocsEditable
  void set disabled(bool value) native "HTMLSelectElement_disabled_Setter";

  @DomName('HTMLSelectElement.form')
  @DocsEditable
  FormElement get form native "HTMLSelectElement_form_Getter";

  @DomName('HTMLSelectElement.labels')
  @DocsEditable
  List<Node> get labels native "HTMLSelectElement_labels_Getter";

  @DomName('HTMLSelectElement.length')
  @DocsEditable
  int get length native "HTMLSelectElement_length_Getter";

  @DomName('HTMLSelectElement.length')
  @DocsEditable
  void set length(int value) native "HTMLSelectElement_length_Setter";

  @DomName('HTMLSelectElement.multiple')
  @DocsEditable
  bool get multiple native "HTMLSelectElement_multiple_Getter";

  @DomName('HTMLSelectElement.multiple')
  @DocsEditable
  void set multiple(bool value) native "HTMLSelectElement_multiple_Setter";

  @DomName('HTMLSelectElement.name')
  @DocsEditable
  String get name native "HTMLSelectElement_name_Getter";

  @DomName('HTMLSelectElement.name')
  @DocsEditable
  void set name(String value) native "HTMLSelectElement_name_Setter";

  @DomName('HTMLSelectElement.required')
  @DocsEditable
  bool get required native "HTMLSelectElement_required_Getter";

  @DomName('HTMLSelectElement.required')
  @DocsEditable
  void set required(bool value) native "HTMLSelectElement_required_Setter";

  @DomName('HTMLSelectElement.selectedIndex')
  @DocsEditable
  int get selectedIndex native "HTMLSelectElement_selectedIndex_Getter";

  @DomName('HTMLSelectElement.selectedIndex')
  @DocsEditable
  void set selectedIndex(int value) native "HTMLSelectElement_selectedIndex_Setter";

  @DomName('HTMLSelectElement.size')
  @DocsEditable
  int get size native "HTMLSelectElement_size_Getter";

  @DomName('HTMLSelectElement.size')
  @DocsEditable
  void set size(int value) native "HTMLSelectElement_size_Setter";

  @DomName('HTMLSelectElement.type')
  @DocsEditable
  String get type native "HTMLSelectElement_type_Getter";

  @DomName('HTMLSelectElement.validationMessage')
  @DocsEditable
  String get validationMessage native "HTMLSelectElement_validationMessage_Getter";

  @DomName('HTMLSelectElement.validity')
  @DocsEditable
  ValidityState get validity native "HTMLSelectElement_validity_Getter";

  @DomName('HTMLSelectElement.value')
  @DocsEditable
  String get value native "HTMLSelectElement_value_Getter";

  @DomName('HTMLSelectElement.value')
  @DocsEditable
  void set value(String value) native "HTMLSelectElement_value_Setter";

  @DomName('HTMLSelectElement.willValidate')
  @DocsEditable
  bool get willValidate native "HTMLSelectElement_willValidate_Getter";

  @DomName('HTMLSelectElement.checkValidity')
  @DocsEditable
  bool checkValidity() native "HTMLSelectElement_checkValidity_Callback";

  @DomName('HTMLSelectElement.item')
  @DocsEditable
  Node item(int index) native "HTMLSelectElement_item_Callback";

  @DomName('HTMLSelectElement.namedItem')
  @DocsEditable
  Node namedItem(String name) native "HTMLSelectElement_namedItem_Callback";

  @DomName('HTMLSelectElement.setCustomValidity')
  @DocsEditable
  void setCustomValidity(String error) native "HTMLSelectElement_setCustomValidity_Callback";


  // Override default options, since IE returns SelectElement itself and it
  // does not operate as a List.
  List<OptionElement> get options {
    var options = this.children.where((e) => e is OptionElement).toList();
    // TODO(floitsch): find better way to create a read-only list view.
    return options.take(options.length);
  }

  List<OptionElement> get selectedOptions {
    // IE does not change the selected flag for single-selection items.
    if (this.multiple) {
      var options = this.options.where((o) => o.selected).toList();
      // TODO(floitsch): find better way to create a read-only list view.
      return options.take(options.length);
    } else {
      return [this.options[this.selectedIndex]];
    }
  }
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('HTMLShadowElement')
@SupportedBrowser(SupportedBrowser.CHROME, '25')
@Experimental
class ShadowElement extends _Element_Merged {
  ShadowElement.internal() : super.internal();

  /// Checks if this type is supported on the current platform.
  static bool get supported => true;

  @DomName('HTMLShadowElement.olderShadowRoot')
  @DocsEditable
  ShadowRoot get olderShadowRoot native "HTMLShadowElement_olderShadowRoot_Getter";

  @DomName('HTMLShadowElement.resetStyleInheritance')
  @DocsEditable
  bool get resetStyleInheritance native "HTMLShadowElement_resetStyleInheritance_Getter";

  @DomName('HTMLShadowElement.resetStyleInheritance')
  @DocsEditable
  void set resetStyleInheritance(bool value) native "HTMLShadowElement_resetStyleInheritance_Setter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DomName('ShadowRoot')
@SupportedBrowser(SupportedBrowser.CHROME, '25')
@Experimental
class ShadowRoot extends DocumentFragment {
  ShadowRoot.internal() : super.internal();

  @DomName('ShadowRoot.activeElement')
  @DocsEditable
  Element get activeElement native "ShadowRoot_activeElement_Getter";

  @DomName('ShadowRoot.applyAuthorStyles')
  @DocsEditable
  bool get applyAuthorStyles native "ShadowRoot_applyAuthorStyles_Getter";

  @DomName('ShadowRoot.applyAuthorStyles')
  @DocsEditable
  void set applyAuthorStyles(bool value) native "ShadowRoot_applyAuthorStyles_Setter";

  @DomName('ShadowRoot.innerHTML')
  @DocsEditable
  String get innerHtml native "ShadowRoot_innerHTML_Getter";

  @DomName('ShadowRoot.innerHTML')
  @DocsEditable
  void set innerHtml(String value) native "ShadowRoot_innerHTML_Setter";

  @DomName('ShadowRoot.resetStyleInheritance')
  @DocsEditable
  bool get resetStyleInheritance native "ShadowRoot_resetStyleInheritance_Getter";

  @DomName('ShadowRoot.resetStyleInheritance')
  @DocsEditable
  void set resetStyleInheritance(bool value) native "ShadowRoot_resetStyleInheritance_Setter";

  @DomName('ShadowRoot.cloneNode')
  @DocsEditable
  Node clone(bool deep) native "ShadowRoot_cloneNode_Callback";

  @DomName('ShadowRoot.elementFromPoint')
  @DocsEditable
  Element elementFromPoint(int x, int y) native "ShadowRoot_elementFromPoint_Callback";

  @DomName('ShadowRoot.getElementById')
  @DocsEditable
  Element $dom_getElementById(String elementId) native "ShadowRoot_getElementById_Callback";

  @DomName('ShadowRoot.getElementsByClassName')
  @DocsEditable
  List<Node> $dom_getElementsByClassName(String className) native "ShadowRoot_getElementsByClassName_Callback";

  @DomName('ShadowRoot.getElementsByTagName')
  @DocsEditable
  List<Node> $dom_getElementsByTagName(String tagName) native "ShadowRoot_getElementsByTagName_Callback";

  @DomName('ShadowRoot.getSelection')
  @DocsEditable
  DomSelection getSelection() native "ShadowRoot_getSelection_Callback";

  static bool get supported => _Utils.shadowRootSupported(window.document);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('SharedWorker')
class SharedWorker extends AbstractWorker {
  SharedWorker.internal() : super.internal();

  @DocsEditable
  factory SharedWorker(String scriptURL, [String name]) {
    if (!?name) {
      return SharedWorker._create(scriptURL);
    }
    return SharedWorker._create(scriptURL, name);
  }
  static SharedWorker _create(String scriptURL, [String name]) native "SharedWorker_constructor_Callback";

  @DomName('SharedWorker.port')
  @DocsEditable
  MessagePort get port native "SharedWorker_port_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('SharedWorkerContext')
class SharedWorkerContext extends WorkerContext {
  SharedWorkerContext.internal() : super.internal();

  @DomName('SharedWorkerContext.connect')
  @DocsEditable
  static const EventStreamProvider<Event> connectEvent = const EventStreamProvider<Event>('connect');

  @DocsEditable
  @DomName('EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent')
  @deprecated
  SharedWorkerContextEvents get on =>
    new SharedWorkerContextEvents(this);

  @DomName('SharedWorkerContext.name')
  @DocsEditable
  String get name native "SharedWorkerContext_name_Getter";

  @DomName('SharedWorkerContext.connect')
  @DocsEditable
  Stream<Event> get onConnect => connectEvent.forTarget(this);

}

@DocsEditable
@deprecated
class SharedWorkerContextEvents extends WorkerContextEvents {
  @DocsEditable
  SharedWorkerContextEvents(EventTarget _ptr) : super(_ptr);

  @DocsEditable
  EventListenerList get connect => this['connect'];
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('SourceBuffer')
class SourceBuffer extends NativeFieldWrapperClass1 {
  SourceBuffer.internal();

  @DomName('SourceBuffer.buffered')
  @DocsEditable
  TimeRanges get buffered native "SourceBuffer_buffered_Getter";

  @DomName('SourceBuffer.timestampOffset')
  @DocsEditable
  num get timestampOffset native "SourceBuffer_timestampOffset_Getter";

  @DomName('SourceBuffer.timestampOffset')
  @DocsEditable
  void set timestampOffset(num value) native "SourceBuffer_timestampOffset_Setter";

  @DomName('SourceBuffer.abort')
  @DocsEditable
  void abort() native "SourceBuffer_abort_Callback";

  @DomName('SourceBuffer.append')
  @DocsEditable
  void append(Uint8Array data) native "SourceBuffer_append_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('SourceBufferList')
class SourceBufferList extends EventTarget implements List<SourceBuffer> {
  SourceBufferList.internal() : super.internal();

  @DomName('SourceBufferList.length')
  @DocsEditable
  int get length native "SourceBufferList_length_Getter";

  SourceBuffer operator[](int index) native "SourceBufferList_item_Callback";

  void operator[]=(int index, SourceBuffer value) {
    throw new UnsupportedError("Cannot assign element of immutable List.");
  }
  // -- start List<SourceBuffer> mixins.
  // SourceBuffer is the element type.

  // From Iterable<SourceBuffer>:

  Iterator<SourceBuffer> get iterator {
    // Note: NodeLists are not fixed size. And most probably length shouldn't
    // be cached in both iterator _and_ forEach method. For now caching it
    // for consistency.
    return new FixedSizeListIterator<SourceBuffer>(this);
  }

  dynamic reduce(dynamic initialValue, dynamic combine(dynamic, SourceBuffer)) {
    return IterableMixinWorkaround.reduce(this, initialValue, combine);
  }

  bool contains(SourceBuffer element) => IterableMixinWorkaround.contains(this, element);

  void forEach(void f(SourceBuffer element)) => IterableMixinWorkaround.forEach(this, f);

  String join([String separator]) =>
      IterableMixinWorkaround.joinList(this, separator);

  List mappedBy(f(SourceBuffer element)) => IterableMixinWorkaround.mappedByList(this, f);

  Iterable<SourceBuffer> where(bool f(SourceBuffer element)) =>
      IterableMixinWorkaround.where(this, f);

  bool every(bool f(SourceBuffer element)) => IterableMixinWorkaround.every(this, f);

  bool any(bool f(SourceBuffer element)) => IterableMixinWorkaround.any(this, f);

  List<SourceBuffer> toList() => new List<SourceBuffer>.from(this);
  Set<SourceBuffer> toSet() => new Set<SourceBuffer>.from(this);

  bool get isEmpty => this.length == 0;

  List<SourceBuffer> take(int n) => IterableMixinWorkaround.takeList(this, n);

  Iterable<SourceBuffer> takeWhile(bool test(SourceBuffer value)) {
    return IterableMixinWorkaround.takeWhile(this, test);
  }

  List<SourceBuffer> skip(int n) => IterableMixinWorkaround.skipList(this, n);

  Iterable<SourceBuffer> skipWhile(bool test(SourceBuffer value)) {
    return IterableMixinWorkaround.skipWhile(this, test);
  }

  SourceBuffer firstMatching(bool test(SourceBuffer value), { SourceBuffer orElse() }) {
    return IterableMixinWorkaround.firstMatching(this, test, orElse);
  }

  SourceBuffer lastMatching(bool test(SourceBuffer value), {SourceBuffer orElse()}) {
    return IterableMixinWorkaround.lastMatchingInList(this, test, orElse);
  }

  SourceBuffer singleMatching(bool test(SourceBuffer value)) {
    return IterableMixinWorkaround.singleMatching(this, test);
  }

  SourceBuffer elementAt(int index) {
    return this[index];
  }

  // From Collection<SourceBuffer>:

  void add(SourceBuffer value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addLast(SourceBuffer value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addAll(Iterable<SourceBuffer> iterable) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  // From List<SourceBuffer>:
  void set length(int value) {
    throw new UnsupportedError("Cannot resize immutable List.");
  }

  void clear() {
    throw new UnsupportedError("Cannot clear immutable List.");
  }

  List<SourceBuffer> get reversed =>
      new ReversedListView<SourceBuffer>(this, 0, null);

  void sort([int compare(SourceBuffer a, SourceBuffer b)]) {
    throw new UnsupportedError("Cannot sort immutable List.");
  }

  int indexOf(SourceBuffer element, [int start = 0]) =>
      Lists.indexOf(this, element, start, this.length);

  int lastIndexOf(SourceBuffer element, [int start]) {
    if (start == null) start = length - 1;
    return Lists.lastIndexOf(this, element, start);
  }

  SourceBuffer get first {
    if (this.length > 0) return this[0];
    throw new StateError("No elements");
  }

  SourceBuffer get last {
    if (this.length > 0) return this[this.length - 1];
    throw new StateError("No elements");
  }

  SourceBuffer get single {
    if (length == 1) return this[0];
    if (length == 0) throw new StateError("No elements");
    throw new StateError("More than one element");
  }

  SourceBuffer min([int compare(SourceBuffer a, SourceBuffer b)]) =>
      IterableMixinWorkaround.min(this, compare);

  SourceBuffer max([int compare(SourceBuffer a, SourceBuffer b)]) =>
      IterableMixinWorkaround.max(this, compare);

  SourceBuffer removeAt(int pos) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  SourceBuffer removeLast() {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void remove(Object object) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void removeAll(Iterable elements) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void retainAll(Iterable elements) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void removeMatching(bool test(SourceBuffer element)) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void retainMatching(bool test(SourceBuffer element)) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void setRange(int start, int rangeLength, List<SourceBuffer> from, [int startFrom]) {
    throw new UnsupportedError("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int rangeLength) {
    throw new UnsupportedError("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int rangeLength, [SourceBuffer initialValue]) {
    throw new UnsupportedError("Cannot insertRange on immutable List.");
  }

  List<SourceBuffer> getRange(int start, int rangeLength) =>
      Lists.getRange(this, start, rangeLength, <SourceBuffer>[]);

  // -- end List<SourceBuffer> mixins.

  @DomName('SourceBufferList.addEventListener')
  @DocsEditable
  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]) native "SourceBufferList_addEventListener_Callback";

  @DomName('SourceBufferList.dispatchEvent')
  @DocsEditable
  bool dispatchEvent(Event event) native "SourceBufferList_dispatchEvent_Callback";

  @DomName('SourceBufferList.item')
  @DocsEditable
  SourceBuffer item(int index) native "SourceBufferList_item_Callback";

  @DomName('SourceBufferList.removeEventListener')
  @DocsEditable
  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]) native "SourceBufferList_removeEventListener_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('HTMLSourceElement')
class SourceElement extends _Element_Merged {
  SourceElement.internal() : super.internal();

  @DocsEditable
  factory SourceElement() => document.$dom_createElement("source");

  @DomName('HTMLSourceElement.media')
  @DocsEditable
  String get media native "HTMLSourceElement_media_Getter";

  @DomName('HTMLSourceElement.media')
  @DocsEditable
  void set media(String value) native "HTMLSourceElement_media_Setter";

  @DomName('HTMLSourceElement.src')
  @DocsEditable
  String get src native "HTMLSourceElement_src_Getter";

  @DomName('HTMLSourceElement.src')
  @DocsEditable
  void set src(String value) native "HTMLSourceElement_src_Setter";

  @DomName('HTMLSourceElement.type')
  @DocsEditable
  String get type native "HTMLSourceElement_type_Getter";

  @DomName('HTMLSourceElement.type')
  @DocsEditable
  void set type(String value) native "HTMLSourceElement_type_Setter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('HTMLSpanElement')
class SpanElement extends _Element_Merged {
  SpanElement.internal() : super.internal();

  @DocsEditable
  factory SpanElement() => document.$dom_createElement("span");

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('SpeechGrammar')
class SpeechGrammar extends NativeFieldWrapperClass1 {
  SpeechGrammar.internal();

  @DocsEditable
  factory SpeechGrammar() => SpeechGrammar._create();
  static SpeechGrammar _create() native "SpeechGrammar_constructor_Callback";

  @DomName('SpeechGrammar.src')
  @DocsEditable
  String get src native "SpeechGrammar_src_Getter";

  @DomName('SpeechGrammar.src')
  @DocsEditable
  void set src(String value) native "SpeechGrammar_src_Setter";

  @DomName('SpeechGrammar.weight')
  @DocsEditable
  num get weight native "SpeechGrammar_weight_Getter";

  @DomName('SpeechGrammar.weight')
  @DocsEditable
  void set weight(num value) native "SpeechGrammar_weight_Setter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('SpeechGrammarList')
class SpeechGrammarList extends NativeFieldWrapperClass1 implements List<SpeechGrammar> {
  SpeechGrammarList.internal();

  @DocsEditable
  factory SpeechGrammarList() => SpeechGrammarList._create();
  static SpeechGrammarList _create() native "SpeechGrammarList_constructor_Callback";

  @DomName('SpeechGrammarList.length')
  @DocsEditable
  int get length native "SpeechGrammarList_length_Getter";

  SpeechGrammar operator[](int index) native "SpeechGrammarList_item_Callback";

  void operator[]=(int index, SpeechGrammar value) {
    throw new UnsupportedError("Cannot assign element of immutable List.");
  }
  // -- start List<SpeechGrammar> mixins.
  // SpeechGrammar is the element type.

  // From Iterable<SpeechGrammar>:

  Iterator<SpeechGrammar> get iterator {
    // Note: NodeLists are not fixed size. And most probably length shouldn't
    // be cached in both iterator _and_ forEach method. For now caching it
    // for consistency.
    return new FixedSizeListIterator<SpeechGrammar>(this);
  }

  dynamic reduce(dynamic initialValue, dynamic combine(dynamic, SpeechGrammar)) {
    return IterableMixinWorkaround.reduce(this, initialValue, combine);
  }

  bool contains(SpeechGrammar element) => IterableMixinWorkaround.contains(this, element);

  void forEach(void f(SpeechGrammar element)) => IterableMixinWorkaround.forEach(this, f);

  String join([String separator]) =>
      IterableMixinWorkaround.joinList(this, separator);

  List mappedBy(f(SpeechGrammar element)) => IterableMixinWorkaround.mappedByList(this, f);

  Iterable<SpeechGrammar> where(bool f(SpeechGrammar element)) =>
      IterableMixinWorkaround.where(this, f);

  bool every(bool f(SpeechGrammar element)) => IterableMixinWorkaround.every(this, f);

  bool any(bool f(SpeechGrammar element)) => IterableMixinWorkaround.any(this, f);

  List<SpeechGrammar> toList() => new List<SpeechGrammar>.from(this);
  Set<SpeechGrammar> toSet() => new Set<SpeechGrammar>.from(this);

  bool get isEmpty => this.length == 0;

  List<SpeechGrammar> take(int n) => IterableMixinWorkaround.takeList(this, n);

  Iterable<SpeechGrammar> takeWhile(bool test(SpeechGrammar value)) {
    return IterableMixinWorkaround.takeWhile(this, test);
  }

  List<SpeechGrammar> skip(int n) => IterableMixinWorkaround.skipList(this, n);

  Iterable<SpeechGrammar> skipWhile(bool test(SpeechGrammar value)) {
    return IterableMixinWorkaround.skipWhile(this, test);
  }

  SpeechGrammar firstMatching(bool test(SpeechGrammar value), { SpeechGrammar orElse() }) {
    return IterableMixinWorkaround.firstMatching(this, test, orElse);
  }

  SpeechGrammar lastMatching(bool test(SpeechGrammar value), {SpeechGrammar orElse()}) {
    return IterableMixinWorkaround.lastMatchingInList(this, test, orElse);
  }

  SpeechGrammar singleMatching(bool test(SpeechGrammar value)) {
    return IterableMixinWorkaround.singleMatching(this, test);
  }

  SpeechGrammar elementAt(int index) {
    return this[index];
  }

  // From Collection<SpeechGrammar>:

  void add(SpeechGrammar value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addLast(SpeechGrammar value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addAll(Iterable<SpeechGrammar> iterable) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  // From List<SpeechGrammar>:
  void set length(int value) {
    throw new UnsupportedError("Cannot resize immutable List.");
  }

  void clear() {
    throw new UnsupportedError("Cannot clear immutable List.");
  }

  List<SpeechGrammar> get reversed =>
      new ReversedListView<SpeechGrammar>(this, 0, null);

  void sort([int compare(SpeechGrammar a, SpeechGrammar b)]) {
    throw new UnsupportedError("Cannot sort immutable List.");
  }

  int indexOf(SpeechGrammar element, [int start = 0]) =>
      Lists.indexOf(this, element, start, this.length);

  int lastIndexOf(SpeechGrammar element, [int start]) {
    if (start == null) start = length - 1;
    return Lists.lastIndexOf(this, element, start);
  }

  SpeechGrammar get first {
    if (this.length > 0) return this[0];
    throw new StateError("No elements");
  }

  SpeechGrammar get last {
    if (this.length > 0) return this[this.length - 1];
    throw new StateError("No elements");
  }

  SpeechGrammar get single {
    if (length == 1) return this[0];
    if (length == 0) throw new StateError("No elements");
    throw new StateError("More than one element");
  }

  SpeechGrammar min([int compare(SpeechGrammar a, SpeechGrammar b)]) =>
      IterableMixinWorkaround.min(this, compare);

  SpeechGrammar max([int compare(SpeechGrammar a, SpeechGrammar b)]) =>
      IterableMixinWorkaround.max(this, compare);

  SpeechGrammar removeAt(int pos) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  SpeechGrammar removeLast() {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void remove(Object object) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void removeAll(Iterable elements) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void retainAll(Iterable elements) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void removeMatching(bool test(SpeechGrammar element)) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void retainMatching(bool test(SpeechGrammar element)) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void setRange(int start, int rangeLength, List<SpeechGrammar> from, [int startFrom]) {
    throw new UnsupportedError("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int rangeLength) {
    throw new UnsupportedError("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int rangeLength, [SpeechGrammar initialValue]) {
    throw new UnsupportedError("Cannot insertRange on immutable List.");
  }

  List<SpeechGrammar> getRange(int start, int rangeLength) =>
      Lists.getRange(this, start, rangeLength, <SpeechGrammar>[]);

  // -- end List<SpeechGrammar> mixins.

  void addFromString(String string, [num weight]) {
    if (?weight) {
      _addFromString_1(string, weight);
      return;
    }
    _addFromString_2(string);
    return;
  }

  @DomName('SpeechGrammarList._addFromString_1')
  @DocsEditable
  void _addFromString_1(string, weight) native "SpeechGrammarList__addFromString_1_Callback";

  @DomName('SpeechGrammarList._addFromString_2')
  @DocsEditable
  void _addFromString_2(string) native "SpeechGrammarList__addFromString_2_Callback";

  void addFromUri(String src, [num weight]) {
    if (?weight) {
      _addFromUri_1(src, weight);
      return;
    }
    _addFromUri_2(src);
    return;
  }

  @DomName('SpeechGrammarList._addFromUri_1')
  @DocsEditable
  void _addFromUri_1(src, weight) native "SpeechGrammarList__addFromUri_1_Callback";

  @DomName('SpeechGrammarList._addFromUri_2')
  @DocsEditable
  void _addFromUri_2(src) native "SpeechGrammarList__addFromUri_2_Callback";

  @DomName('SpeechGrammarList.item')
  @DocsEditable
  SpeechGrammar item(int index) native "SpeechGrammarList_item_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('SpeechInputEvent')
class SpeechInputEvent extends Event {
  SpeechInputEvent.internal() : super.internal();

  @DomName('SpeechInputEvent.results')
  @DocsEditable
  List<SpeechInputResult> get results native "SpeechInputEvent_results_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('SpeechInputResult')
class SpeechInputResult extends NativeFieldWrapperClass1 {
  SpeechInputResult.internal();

  @DomName('SpeechInputResult.confidence')
  @DocsEditable
  num get confidence native "SpeechInputResult_confidence_Getter";

  @DomName('SpeechInputResult.utterance')
  @DocsEditable
  String get utterance native "SpeechInputResult_utterance_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('SpeechRecognition')
@SupportedBrowser(SupportedBrowser.CHROME, '25')
@Experimental
class SpeechRecognition extends EventTarget {
  SpeechRecognition.internal() : super.internal();

  @DomName('SpeechRecognition.audioend')
  @DocsEditable
  static const EventStreamProvider<Event> audioEndEvent = const EventStreamProvider<Event>('audioend');

  @DomName('SpeechRecognition.audiostart')
  @DocsEditable
  static const EventStreamProvider<Event> audioStartEvent = const EventStreamProvider<Event>('audiostart');

  @DomName('SpeechRecognition.end')
  @DocsEditable
  static const EventStreamProvider<Event> endEvent = const EventStreamProvider<Event>('end');

  @DomName('SpeechRecognition.error')
  @DocsEditable
  static const EventStreamProvider<SpeechRecognitionError> errorEvent = const EventStreamProvider<SpeechRecognitionError>('error');

  @DomName('SpeechRecognition.nomatch')
  @DocsEditable
  static const EventStreamProvider<SpeechRecognitionEvent> noMatchEvent = const EventStreamProvider<SpeechRecognitionEvent>('nomatch');

  @DomName('SpeechRecognition.result')
  @DocsEditable
  static const EventStreamProvider<SpeechRecognitionEvent> resultEvent = const EventStreamProvider<SpeechRecognitionEvent>('result');

  @DomName('SpeechRecognition.soundend')
  @DocsEditable
  static const EventStreamProvider<Event> soundEndEvent = const EventStreamProvider<Event>('soundend');

  @DomName('SpeechRecognition.soundstart')
  @DocsEditable
  static const EventStreamProvider<Event> soundStartEvent = const EventStreamProvider<Event>('soundstart');

  @DomName('SpeechRecognition.speechend')
  @DocsEditable
  static const EventStreamProvider<Event> speechEndEvent = const EventStreamProvider<Event>('speechend');

  @DomName('SpeechRecognition.speechstart')
  @DocsEditable
  static const EventStreamProvider<Event> speechStartEvent = const EventStreamProvider<Event>('speechstart');

  @DomName('SpeechRecognition.start')
  @DocsEditable
  static const EventStreamProvider<Event> startEvent = const EventStreamProvider<Event>('start');

  @DocsEditable
  factory SpeechRecognition() => SpeechRecognition._create();
  static SpeechRecognition _create() native "SpeechRecognition_constructor_Callback";

  /// Checks if this type is supported on the current platform.
  static bool get supported => true;

  @DocsEditable
  @DomName('EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent')
  @deprecated
  SpeechRecognitionEvents get on =>
    new SpeechRecognitionEvents(this);

  @DomName('SpeechRecognition.continuous')
  @DocsEditable
  bool get continuous native "SpeechRecognition_continuous_Getter";

  @DomName('SpeechRecognition.continuous')
  @DocsEditable
  void set continuous(bool value) native "SpeechRecognition_continuous_Setter";

  @DomName('SpeechRecognition.grammars')
  @DocsEditable
  SpeechGrammarList get grammars native "SpeechRecognition_grammars_Getter";

  @DomName('SpeechRecognition.grammars')
  @DocsEditable
  void set grammars(SpeechGrammarList value) native "SpeechRecognition_grammars_Setter";

  @DomName('SpeechRecognition.interimResults')
  @DocsEditable
  bool get interimResults native "SpeechRecognition_interimResults_Getter";

  @DomName('SpeechRecognition.interimResults')
  @DocsEditable
  void set interimResults(bool value) native "SpeechRecognition_interimResults_Setter";

  @DomName('SpeechRecognition.lang')
  @DocsEditable
  String get lang native "SpeechRecognition_lang_Getter";

  @DomName('SpeechRecognition.lang')
  @DocsEditable
  void set lang(String value) native "SpeechRecognition_lang_Setter";

  @DomName('SpeechRecognition.maxAlternatives')
  @DocsEditable
  int get maxAlternatives native "SpeechRecognition_maxAlternatives_Getter";

  @DomName('SpeechRecognition.maxAlternatives')
  @DocsEditable
  void set maxAlternatives(int value) native "SpeechRecognition_maxAlternatives_Setter";

  @DomName('SpeechRecognition.abort')
  @DocsEditable
  void abort() native "SpeechRecognition_abort_Callback";

  @DomName('SpeechRecognition.addEventListener')
  @DocsEditable
  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]) native "SpeechRecognition_addEventListener_Callback";

  @DomName('SpeechRecognition.dispatchEvent')
  @DocsEditable
  bool dispatchEvent(Event evt) native "SpeechRecognition_dispatchEvent_Callback";

  @DomName('SpeechRecognition.removeEventListener')
  @DocsEditable
  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]) native "SpeechRecognition_removeEventListener_Callback";

  @DomName('SpeechRecognition.start')
  @DocsEditable
  void start() native "SpeechRecognition_start_Callback";

  @DomName('SpeechRecognition.stop')
  @DocsEditable
  void stop() native "SpeechRecognition_stop_Callback";

  @DomName('SpeechRecognition.audioend')
  @DocsEditable
  Stream<Event> get onAudioEnd => audioEndEvent.forTarget(this);

  @DomName('SpeechRecognition.audiostart')
  @DocsEditable
  Stream<Event> get onAudioStart => audioStartEvent.forTarget(this);

  @DomName('SpeechRecognition.end')
  @DocsEditable
  Stream<Event> get onEnd => endEvent.forTarget(this);

  @DomName('SpeechRecognition.error')
  @DocsEditable
  Stream<SpeechRecognitionError> get onError => errorEvent.forTarget(this);

  @DomName('SpeechRecognition.nomatch')
  @DocsEditable
  Stream<SpeechRecognitionEvent> get onNoMatch => noMatchEvent.forTarget(this);

  @DomName('SpeechRecognition.result')
  @DocsEditable
  Stream<SpeechRecognitionEvent> get onResult => resultEvent.forTarget(this);

  @DomName('SpeechRecognition.soundend')
  @DocsEditable
  Stream<Event> get onSoundEnd => soundEndEvent.forTarget(this);

  @DomName('SpeechRecognition.soundstart')
  @DocsEditable
  Stream<Event> get onSoundStart => soundStartEvent.forTarget(this);

  @DomName('SpeechRecognition.speechend')
  @DocsEditable
  Stream<Event> get onSpeechEnd => speechEndEvent.forTarget(this);

  @DomName('SpeechRecognition.speechstart')
  @DocsEditable
  Stream<Event> get onSpeechStart => speechStartEvent.forTarget(this);

  @DomName('SpeechRecognition.start')
  @DocsEditable
  Stream<Event> get onStart => startEvent.forTarget(this);

}

@DocsEditable
@deprecated
class SpeechRecognitionEvents extends Events {
  @DocsEditable
  SpeechRecognitionEvents(EventTarget _ptr) : super(_ptr);

  @DocsEditable
  EventListenerList get audioEnd => this['audioend'];

  @DocsEditable
  EventListenerList get audioStart => this['audiostart'];

  @DocsEditable
  EventListenerList get end => this['end'];

  @DocsEditable
  EventListenerList get error => this['error'];

  @DocsEditable
  EventListenerList get noMatch => this['nomatch'];

  @DocsEditable
  EventListenerList get result => this['result'];

  @DocsEditable
  EventListenerList get soundEnd => this['soundend'];

  @DocsEditable
  EventListenerList get soundStart => this['soundstart'];

  @DocsEditable
  EventListenerList get speechEnd => this['speechend'];

  @DocsEditable
  EventListenerList get speechStart => this['speechstart'];

  @DocsEditable
  EventListenerList get start => this['start'];
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('SpeechRecognitionAlternative')
@SupportedBrowser(SupportedBrowser.CHROME, '25')
@Experimental
class SpeechRecognitionAlternative extends NativeFieldWrapperClass1 {
  SpeechRecognitionAlternative.internal();

  @DomName('SpeechRecognitionAlternative.confidence')
  @DocsEditable
  num get confidence native "SpeechRecognitionAlternative_confidence_Getter";

  @DomName('SpeechRecognitionAlternative.transcript')
  @DocsEditable
  String get transcript native "SpeechRecognitionAlternative_transcript_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('SpeechRecognitionError')
@SupportedBrowser(SupportedBrowser.CHROME, '25')
@Experimental
class SpeechRecognitionError extends Event {
  SpeechRecognitionError.internal() : super.internal();

  @DomName('SpeechRecognitionError.error')
  @DocsEditable
  String get error native "SpeechRecognitionError_error_Getter";

  @DomName('SpeechRecognitionError.message')
  @DocsEditable
  String get message native "SpeechRecognitionError_message_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('SpeechRecognitionEvent')
@SupportedBrowser(SupportedBrowser.CHROME, '25')
@Experimental
class SpeechRecognitionEvent extends Event {
  SpeechRecognitionEvent.internal() : super.internal();

  @DomName('SpeechRecognitionEvent.result')
  @DocsEditable
  SpeechRecognitionResult get result native "SpeechRecognitionEvent_result_Getter";

  @DomName('SpeechRecognitionEvent.resultHistory')
  @DocsEditable
  List<SpeechRecognitionResult> get resultHistory native "SpeechRecognitionEvent_resultHistory_Getter";

  @DomName('SpeechRecognitionEvent.resultIndex')
  @DocsEditable
  int get resultIndex native "SpeechRecognitionEvent_resultIndex_Getter";

  @DomName('SpeechRecognitionEvent.results')
  @DocsEditable
  List<SpeechRecognitionResult> get results native "SpeechRecognitionEvent_results_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('SpeechRecognitionResult')
@SupportedBrowser(SupportedBrowser.CHROME, '25')
@Experimental
class SpeechRecognitionResult extends NativeFieldWrapperClass1 {
  SpeechRecognitionResult.internal();

  @DomName('SpeechRecognitionResult.isFinal')
  @DocsEditable
  bool get isFinal native "SpeechRecognitionResult_isFinal_Getter";

  @DomName('SpeechRecognitionResult.length')
  @DocsEditable
  int get length native "SpeechRecognitionResult_length_Getter";

  @DomName('SpeechRecognitionResult.item')
  @DocsEditable
  SpeechRecognitionAlternative item(int index) native "SpeechRecognitionResult_item_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('SQLError')
class SqlError extends NativeFieldWrapperClass1 {
  SqlError.internal();

  static const int CONSTRAINT_ERR = 6;

  static const int DATABASE_ERR = 1;

  static const int QUOTA_ERR = 4;

  static const int SYNTAX_ERR = 5;

  static const int TIMEOUT_ERR = 7;

  static const int TOO_LARGE_ERR = 3;

  static const int UNKNOWN_ERR = 0;

  static const int VERSION_ERR = 2;

  @DomName('SQLError.code')
  @DocsEditable
  int get code native "SQLError_code_Getter";

  @DomName('SQLError.message')
  @DocsEditable
  String get message native "SQLError_message_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('SQLException')
class SqlException extends NativeFieldWrapperClass1 {
  SqlException.internal();

  static const int CONSTRAINT_ERR = 6;

  static const int DATABASE_ERR = 1;

  static const int QUOTA_ERR = 4;

  static const int SYNTAX_ERR = 5;

  static const int TIMEOUT_ERR = 7;

  static const int TOO_LARGE_ERR = 3;

  static const int UNKNOWN_ERR = 0;

  static const int VERSION_ERR = 2;

  @DomName('SQLException.code')
  @DocsEditable
  int get code native "SQLException_code_Getter";

  @DomName('SQLException.message')
  @DocsEditable
  String get message native "SQLException_message_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('SQLResultSet')
class SqlResultSet extends NativeFieldWrapperClass1 {
  SqlResultSet.internal();

  @DomName('SQLResultSet.insertId')
  @DocsEditable
  int get insertId native "SQLResultSet_insertId_Getter";

  @DomName('SQLResultSet.rows')
  @DocsEditable
  SqlResultSetRowList get rows native "SQLResultSet_rows_Getter";

  @DomName('SQLResultSet.rowsAffected')
  @DocsEditable
  int get rowsAffected native "SQLResultSet_rowsAffected_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('SQLResultSetRowList')
class SqlResultSetRowList extends NativeFieldWrapperClass1 implements List<Map> {
  SqlResultSetRowList.internal();

  @DomName('SQLResultSetRowList.length')
  @DocsEditable
  int get length native "SQLResultSetRowList_length_Getter";

  Map operator[](int index) native "SQLResultSetRowList_item_Callback";

  void operator[]=(int index, Map value) {
    throw new UnsupportedError("Cannot assign element of immutable List.");
  }
  // -- start List<Map> mixins.
  // Map is the element type.

  // From Iterable<Map>:

  Iterator<Map> get iterator {
    // Note: NodeLists are not fixed size. And most probably length shouldn't
    // be cached in both iterator _and_ forEach method. For now caching it
    // for consistency.
    return new FixedSizeListIterator<Map>(this);
  }

  dynamic reduce(dynamic initialValue, dynamic combine(dynamic, Map)) {
    return IterableMixinWorkaround.reduce(this, initialValue, combine);
  }

  bool contains(Map element) => IterableMixinWorkaround.contains(this, element);

  void forEach(void f(Map element)) => IterableMixinWorkaround.forEach(this, f);

  String join([String separator]) =>
      IterableMixinWorkaround.joinList(this, separator);

  List mappedBy(f(Map element)) => IterableMixinWorkaround.mappedByList(this, f);

  Iterable<Map> where(bool f(Map element)) =>
      IterableMixinWorkaround.where(this, f);

  bool every(bool f(Map element)) => IterableMixinWorkaround.every(this, f);

  bool any(bool f(Map element)) => IterableMixinWorkaround.any(this, f);

  List<Map> toList() => new List<Map>.from(this);
  Set<Map> toSet() => new Set<Map>.from(this);

  bool get isEmpty => this.length == 0;

  List<Map> take(int n) => IterableMixinWorkaround.takeList(this, n);

  Iterable<Map> takeWhile(bool test(Map value)) {
    return IterableMixinWorkaround.takeWhile(this, test);
  }

  List<Map> skip(int n) => IterableMixinWorkaround.skipList(this, n);

  Iterable<Map> skipWhile(bool test(Map value)) {
    return IterableMixinWorkaround.skipWhile(this, test);
  }

  Map firstMatching(bool test(Map value), { Map orElse() }) {
    return IterableMixinWorkaround.firstMatching(this, test, orElse);
  }

  Map lastMatching(bool test(Map value), {Map orElse()}) {
    return IterableMixinWorkaround.lastMatchingInList(this, test, orElse);
  }

  Map singleMatching(bool test(Map value)) {
    return IterableMixinWorkaround.singleMatching(this, test);
  }

  Map elementAt(int index) {
    return this[index];
  }

  // From Collection<Map>:

  void add(Map value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addLast(Map value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addAll(Iterable<Map> iterable) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  // From List<Map>:
  void set length(int value) {
    throw new UnsupportedError("Cannot resize immutable List.");
  }

  void clear() {
    throw new UnsupportedError("Cannot clear immutable List.");
  }

  List<Map> get reversed =>
      new ReversedListView<Map>(this, 0, null);

  void sort([int compare(Map a, Map b)]) {
    throw new UnsupportedError("Cannot sort immutable List.");
  }

  int indexOf(Map element, [int start = 0]) =>
      Lists.indexOf(this, element, start, this.length);

  int lastIndexOf(Map element, [int start]) {
    if (start == null) start = length - 1;
    return Lists.lastIndexOf(this, element, start);
  }

  Map get first {
    if (this.length > 0) return this[0];
    throw new StateError("No elements");
  }

  Map get last {
    if (this.length > 0) return this[this.length - 1];
    throw new StateError("No elements");
  }

  Map get single {
    if (length == 1) return this[0];
    if (length == 0) throw new StateError("No elements");
    throw new StateError("More than one element");
  }

  Map min([int compare(Map a, Map b)]) =>
      IterableMixinWorkaround.min(this, compare);

  Map max([int compare(Map a, Map b)]) =>
      IterableMixinWorkaround.max(this, compare);

  Map removeAt(int pos) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  Map removeLast() {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void remove(Object object) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void removeAll(Iterable elements) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void retainAll(Iterable elements) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void removeMatching(bool test(Map element)) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void retainMatching(bool test(Map element)) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void setRange(int start, int rangeLength, List<Map> from, [int startFrom]) {
    throw new UnsupportedError("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int rangeLength) {
    throw new UnsupportedError("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int rangeLength, [Map initialValue]) {
    throw new UnsupportedError("Cannot insertRange on immutable List.");
  }

  List<Map> getRange(int start, int rangeLength) =>
      Lists.getRange(this, start, rangeLength, <Map>[]);

  // -- end List<Map> mixins.

  @DomName('SQLResultSetRowList.item')
  @DocsEditable
  Map item(int index) native "SQLResultSetRowList_item_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('SQLTransaction')
@SupportedBrowser(SupportedBrowser.CHROME)
@SupportedBrowser(SupportedBrowser.SAFARI)
@Experimental
class SqlTransaction extends NativeFieldWrapperClass1 {
  SqlTransaction.internal();

  @DomName('SQLTransaction.executeSql')
  @DocsEditable
  void executeSql(String sqlStatement, List arguments, [SqlStatementCallback callback, SqlStatementErrorCallback errorCallback]) native "SQLTransaction_executeSql_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('SQLTransactionSync')
@SupportedBrowser(SupportedBrowser.CHROME)
@SupportedBrowser(SupportedBrowser.SAFARI)
@Experimental
class SqlTransactionSync extends NativeFieldWrapperClass1 {
  SqlTransactionSync.internal();

  @DomName('SQLTransactionSync.executeSql')
  @DocsEditable
  SqlResultSet executeSql(String sqlStatement, List arguments) native "SQLTransactionSync_executeSql_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.


@DomName('Storage')
class Storage extends NativeFieldWrapperClass1 implements Map<String, String>
     {

  // TODO(nweiz): update this when maps support lazy iteration
  bool containsValue(String value) => values.any((e) => e == value);

  bool containsKey(String key) => $dom_getItem(key) != null;

  String operator [](String key) => $dom_getItem(key);

  void operator []=(String key, String value) { $dom_setItem(key, value); }

  String putIfAbsent(String key, String ifAbsent()) {
    if (!containsKey(key)) this[key] = ifAbsent();
    return this[key];
  }

  String remove(String key) {
    final value = this[key];
    $dom_removeItem(key);
    return value;
  }

  void clear() => $dom_clear();

  void forEach(void f(String key, String value)) {
    for (var i = 0; true; i++) {
      final key = $dom_key(i);
      if (key == null) return;

      f(key, this[key]);
    }
  }

  Collection<String> get keys {
    final keys = [];
    forEach((k, v) => keys.add(k));
    return keys;
  }

  Collection<String> get values {
    final values = [];
    forEach((k, v) => values.add(v));
    return values;
  }

  int get length => $dom_length;

  bool get isEmpty => $dom_key(0) == null;
  Storage.internal();

  @DomName('Storage.length')
  @DocsEditable
  int get $dom_length native "Storage_length_Getter";

  @DomName('Storage.clear')
  @DocsEditable
  void $dom_clear() native "Storage_clear_Callback";

  @DomName('Storage.getItem')
  @DocsEditable
  String $dom_getItem(String key) native "Storage_getItem_Callback";

  @DomName('Storage.key')
  @DocsEditable
  String $dom_key(int index) native "Storage_key_Callback";

  @DomName('Storage.removeItem')
  @DocsEditable
  void $dom_removeItem(String key) native "Storage_removeItem_Callback";

  @DomName('Storage.setItem')
  @DocsEditable
  void $dom_setItem(String key, String data) native "Storage_setItem_Callback";

}
// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DomName('StorageEvent')
class StorageEvent extends Event {
  factory StorageEvent(String type,
    {bool canBubble: false, bool cancelable: false, String key, String oldValue,
    String newValue, String url, Storage storageArea}) {

    var e = document.$dom_createEvent("StorageEvent");
    e.$dom_initStorageEvent(type, canBubble, cancelable, key, oldValue,
        newValue, url, storageArea);
    return e;
  }
  StorageEvent.internal() : super.internal();

  @DomName('StorageEvent.key')
  @DocsEditable
  String get key native "StorageEvent_key_Getter";

  @DomName('StorageEvent.newValue')
  @DocsEditable
  String get newValue native "StorageEvent_newValue_Getter";

  @DomName('StorageEvent.oldValue')
  @DocsEditable
  String get oldValue native "StorageEvent_oldValue_Getter";

  @DomName('StorageEvent.storageArea')
  @DocsEditable
  Storage get storageArea native "StorageEvent_storageArea_Getter";

  @DomName('StorageEvent.url')
  @DocsEditable
  String get url native "StorageEvent_url_Getter";

  @DomName('StorageEvent.initStorageEvent')
  @DocsEditable
  void $dom_initStorageEvent(String typeArg, bool canBubbleArg, bool cancelableArg, String keyArg, String oldValueArg, String newValueArg, String urlArg, Storage storageAreaArg) native "StorageEvent_initStorageEvent_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('StorageInfo')
class StorageInfo extends NativeFieldWrapperClass1 {
  StorageInfo.internal();

  static const int PERSISTENT = 1;

  static const int TEMPORARY = 0;

  @DomName('StorageInfo.queryUsageAndQuota')
  @DocsEditable
  void queryUsageAndQuota(int storageType, [StorageInfoUsageCallback usageCallback, StorageInfoErrorCallback errorCallback]) native "StorageInfo_queryUsageAndQuota_Callback";

  @DomName('StorageInfo.requestQuota')
  @DocsEditable
  void requestQuota(int storageType, int newQuotaInBytes, [StorageInfoQuotaCallback quotaCallback, StorageInfoErrorCallback errorCallback]) native "StorageInfo_requestQuota_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


typedef void StorageInfoErrorCallback(DomException error);
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


typedef void StorageInfoQuotaCallback(int grantedQuotaInBytes);
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


typedef void StorageInfoUsageCallback(int currentUsageInBytes, int currentQuotaInBytes);
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


typedef void StringCallback(String data);
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('HTMLStyleElement')
class StyleElement extends _Element_Merged {
  StyleElement.internal() : super.internal();

  @DocsEditable
  factory StyleElement() => document.$dom_createElement("style");

  @DomName('HTMLStyleElement.disabled')
  @DocsEditable
  bool get disabled native "HTMLStyleElement_disabled_Getter";

  @DomName('HTMLStyleElement.disabled')
  @DocsEditable
  void set disabled(bool value) native "HTMLStyleElement_disabled_Setter";

  @DomName('HTMLStyleElement.media')
  @DocsEditable
  String get media native "HTMLStyleElement_media_Getter";

  @DomName('HTMLStyleElement.media')
  @DocsEditable
  void set media(String value) native "HTMLStyleElement_media_Setter";

  @DomName('HTMLStyleElement.scoped')
  @DocsEditable
  bool get scoped native "HTMLStyleElement_scoped_Getter";

  @DomName('HTMLStyleElement.scoped')
  @DocsEditable
  void set scoped(bool value) native "HTMLStyleElement_scoped_Setter";

  @DomName('HTMLStyleElement.sheet')
  @DocsEditable
  StyleSheet get sheet native "HTMLStyleElement_sheet_Getter";

  @DomName('HTMLStyleElement.type')
  @DocsEditable
  String get type native "HTMLStyleElement_type_Getter";

  @DomName('HTMLStyleElement.type')
  @DocsEditable
  void set type(String value) native "HTMLStyleElement_type_Setter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('StyleMedia')
class StyleMedia extends NativeFieldWrapperClass1 {
  StyleMedia.internal();

  @DomName('StyleMedia.type')
  @DocsEditable
  String get type native "StyleMedia_type_Getter";

  @DomName('StyleMedia.matchMedium')
  @DocsEditable
  bool matchMedium(String mediaquery) native "StyleMedia_matchMedium_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('StyleSheet')
class StyleSheet extends NativeFieldWrapperClass1 {
  StyleSheet.internal();

  @DomName('StyleSheet.disabled')
  @DocsEditable
  bool get disabled native "StyleSheet_disabled_Getter";

  @DomName('StyleSheet.disabled')
  @DocsEditable
  void set disabled(bool value) native "StyleSheet_disabled_Setter";

  @DomName('StyleSheet.href')
  @DocsEditable
  String get href native "StyleSheet_href_Getter";

  @DomName('StyleSheet.media')
  @DocsEditable
  MediaList get media native "StyleSheet_media_Getter";

  @DomName('StyleSheet.ownerNode')
  @DocsEditable
  Node get ownerNode native "StyleSheet_ownerNode_Getter";

  @DomName('StyleSheet.parentStyleSheet')
  @DocsEditable
  StyleSheet get parentStyleSheet native "StyleSheet_parentStyleSheet_Getter";

  @DomName('StyleSheet.title')
  @DocsEditable
  String get title native "StyleSheet_title_Getter";

  @DomName('StyleSheet.type')
  @DocsEditable
  String get type native "StyleSheet_type_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('HTMLTableCaptionElement')
class TableCaptionElement extends _Element_Merged {
  TableCaptionElement.internal() : super.internal();

  @DocsEditable
  factory TableCaptionElement() => document.$dom_createElement("caption");

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('HTMLTableCellElement')
class TableCellElement extends _Element_Merged {
  TableCellElement.internal() : super.internal();

  @DocsEditable
  factory TableCellElement() => document.$dom_createElement("td");

  @DomName('HTMLTableCellElement.cellIndex')
  @DocsEditable
  int get cellIndex native "HTMLTableCellElement_cellIndex_Getter";

  @DomName('HTMLTableCellElement.colSpan')
  @DocsEditable
  int get colSpan native "HTMLTableCellElement_colSpan_Getter";

  @DomName('HTMLTableCellElement.colSpan')
  @DocsEditable
  void set colSpan(int value) native "HTMLTableCellElement_colSpan_Setter";

  @DomName('HTMLTableCellElement.headers')
  @DocsEditable
  String get headers native "HTMLTableCellElement_headers_Getter";

  @DomName('HTMLTableCellElement.headers')
  @DocsEditable
  void set headers(String value) native "HTMLTableCellElement_headers_Setter";

  @DomName('HTMLTableCellElement.rowSpan')
  @DocsEditable
  int get rowSpan native "HTMLTableCellElement_rowSpan_Getter";

  @DomName('HTMLTableCellElement.rowSpan')
  @DocsEditable
  void set rowSpan(int value) native "HTMLTableCellElement_rowSpan_Setter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('HTMLTableColElement')
class TableColElement extends _Element_Merged {
  TableColElement.internal() : super.internal();

  @DocsEditable
  factory TableColElement() => document.$dom_createElement("col");

  @DomName('HTMLTableColElement.span')
  @DocsEditable
  int get span native "HTMLTableColElement_span_Getter";

  @DomName('HTMLTableColElement.span')
  @DocsEditable
  void set span(int value) native "HTMLTableColElement_span_Setter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('HTMLTableElement')
class TableElement extends _Element_Merged {
  TableElement.internal() : super.internal();

  @DocsEditable
  factory TableElement() => document.$dom_createElement("table");

  @DomName('HTMLTableElement.border')
  @DocsEditable
  String get border native "HTMLTableElement_border_Getter";

  @DomName('HTMLTableElement.border')
  @DocsEditable
  void set border(String value) native "HTMLTableElement_border_Setter";

  @DomName('HTMLTableElement.caption')
  @DocsEditable
  TableCaptionElement get caption native "HTMLTableElement_caption_Getter";

  @DomName('HTMLTableElement.caption')
  @DocsEditable
  void set caption(TableCaptionElement value) native "HTMLTableElement_caption_Setter";

  @DomName('HTMLTableElement.rows')
  @DocsEditable
  HtmlCollection get rows native "HTMLTableElement_rows_Getter";

  @DomName('HTMLTableElement.tBodies')
  @DocsEditable
  HtmlCollection get tBodies native "HTMLTableElement_tBodies_Getter";

  @DomName('HTMLTableElement.tFoot')
  @DocsEditable
  TableSectionElement get tFoot native "HTMLTableElement_tFoot_Getter";

  @DomName('HTMLTableElement.tFoot')
  @DocsEditable
  void set tFoot(TableSectionElement value) native "HTMLTableElement_tFoot_Setter";

  @DomName('HTMLTableElement.tHead')
  @DocsEditable
  TableSectionElement get tHead native "HTMLTableElement_tHead_Getter";

  @DomName('HTMLTableElement.tHead')
  @DocsEditable
  void set tHead(TableSectionElement value) native "HTMLTableElement_tHead_Setter";

  @DomName('HTMLTableElement.createCaption')
  @DocsEditable
  Element createCaption() native "HTMLTableElement_createCaption_Callback";

  @DomName('HTMLTableElement.createTBody')
  @DocsEditable
  Element createTBody() native "HTMLTableElement_createTBody_Callback";

  @DomName('HTMLTableElement.createTFoot')
  @DocsEditable
  Element createTFoot() native "HTMLTableElement_createTFoot_Callback";

  @DomName('HTMLTableElement.createTHead')
  @DocsEditable
  Element createTHead() native "HTMLTableElement_createTHead_Callback";

  @DomName('HTMLTableElement.deleteCaption')
  @DocsEditable
  void deleteCaption() native "HTMLTableElement_deleteCaption_Callback";

  @DomName('HTMLTableElement.deleteRow')
  @DocsEditable
  void deleteRow(int index) native "HTMLTableElement_deleteRow_Callback";

  @DomName('HTMLTableElement.deleteTFoot')
  @DocsEditable
  void deleteTFoot() native "HTMLTableElement_deleteTFoot_Callback";

  @DomName('HTMLTableElement.deleteTHead')
  @DocsEditable
  void deleteTHead() native "HTMLTableElement_deleteTHead_Callback";

  @DomName('HTMLTableElement.insertRow')
  @DocsEditable
  Element insertRow(int index) native "HTMLTableElement_insertRow_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('HTMLTableRowElement')
class TableRowElement extends _Element_Merged {
  TableRowElement.internal() : super.internal();

  @DocsEditable
  factory TableRowElement() => document.$dom_createElement("tr");

  @DomName('HTMLTableRowElement.cells')
  @DocsEditable
  HtmlCollection get cells native "HTMLTableRowElement_cells_Getter";

  @DomName('HTMLTableRowElement.rowIndex')
  @DocsEditable
  int get rowIndex native "HTMLTableRowElement_rowIndex_Getter";

  @DomName('HTMLTableRowElement.sectionRowIndex')
  @DocsEditable
  int get sectionRowIndex native "HTMLTableRowElement_sectionRowIndex_Getter";

  @DomName('HTMLTableRowElement.deleteCell')
  @DocsEditable
  void deleteCell(int index) native "HTMLTableRowElement_deleteCell_Callback";

  @DomName('HTMLTableRowElement.insertCell')
  @DocsEditable
  Element insertCell(int index) native "HTMLTableRowElement_insertCell_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('HTMLTableSectionElement')
class TableSectionElement extends _Element_Merged {
  TableSectionElement.internal() : super.internal();

  @DomName('HTMLTableSectionElement.rows')
  @DocsEditable
  HtmlCollection get rows native "HTMLTableSectionElement_rows_Getter";

  @DomName('HTMLTableSectionElement.deleteRow')
  @DocsEditable
  void deleteRow(int index) native "HTMLTableSectionElement_deleteRow_Callback";

  @DomName('HTMLTableSectionElement.insertRow')
  @DocsEditable
  Element insertRow(int index) native "HTMLTableSectionElement_insertRow_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DomName('Text')
class Text extends CharacterData {
  factory Text(String data) => _TextFactoryProvider.createText(data);
  Text.internal() : super.internal();

  @DomName('Text.wholeText')
  @DocsEditable
  String get wholeText native "Text_wholeText_Getter";

  @DomName('Text.replaceWholeText')
  @DocsEditable
  Text replaceWholeText(String content) native "Text_replaceWholeText_Callback";

  @DomName('Text.splitText')
  @DocsEditable
  Text splitText(int offset) native "Text_splitText_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('HTMLTextAreaElement')
class TextAreaElement extends _Element_Merged {
  TextAreaElement.internal() : super.internal();

  @DocsEditable
  factory TextAreaElement() => document.$dom_createElement("textarea");

  @DomName('HTMLTextAreaElement.autofocus')
  @DocsEditable
  bool get autofocus native "HTMLTextAreaElement_autofocus_Getter";

  @DomName('HTMLTextAreaElement.autofocus')
  @DocsEditable
  void set autofocus(bool value) native "HTMLTextAreaElement_autofocus_Setter";

  @DomName('HTMLTextAreaElement.cols')
  @DocsEditable
  int get cols native "HTMLTextAreaElement_cols_Getter";

  @DomName('HTMLTextAreaElement.cols')
  @DocsEditable
  void set cols(int value) native "HTMLTextAreaElement_cols_Setter";

  @DomName('HTMLTextAreaElement.defaultValue')
  @DocsEditable
  String get defaultValue native "HTMLTextAreaElement_defaultValue_Getter";

  @DomName('HTMLTextAreaElement.defaultValue')
  @DocsEditable
  void set defaultValue(String value) native "HTMLTextAreaElement_defaultValue_Setter";

  @DomName('HTMLTextAreaElement.dirName')
  @DocsEditable
  String get dirName native "HTMLTextAreaElement_dirName_Getter";

  @DomName('HTMLTextAreaElement.dirName')
  @DocsEditable
  void set dirName(String value) native "HTMLTextAreaElement_dirName_Setter";

  @DomName('HTMLTextAreaElement.disabled')
  @DocsEditable
  bool get disabled native "HTMLTextAreaElement_disabled_Getter";

  @DomName('HTMLTextAreaElement.disabled')
  @DocsEditable
  void set disabled(bool value) native "HTMLTextAreaElement_disabled_Setter";

  @DomName('HTMLTextAreaElement.form')
  @DocsEditable
  FormElement get form native "HTMLTextAreaElement_form_Getter";

  @DomName('HTMLTextAreaElement.labels')
  @DocsEditable
  List<Node> get labels native "HTMLTextAreaElement_labels_Getter";

  @DomName('HTMLTextAreaElement.maxLength')
  @DocsEditable
  int get maxLength native "HTMLTextAreaElement_maxLength_Getter";

  @DomName('HTMLTextAreaElement.maxLength')
  @DocsEditable
  void set maxLength(int value) native "HTMLTextAreaElement_maxLength_Setter";

  @DomName('HTMLTextAreaElement.name')
  @DocsEditable
  String get name native "HTMLTextAreaElement_name_Getter";

  @DomName('HTMLTextAreaElement.name')
  @DocsEditable
  void set name(String value) native "HTMLTextAreaElement_name_Setter";

  @DomName('HTMLTextAreaElement.placeholder')
  @DocsEditable
  String get placeholder native "HTMLTextAreaElement_placeholder_Getter";

  @DomName('HTMLTextAreaElement.placeholder')
  @DocsEditable
  void set placeholder(String value) native "HTMLTextAreaElement_placeholder_Setter";

  @DomName('HTMLTextAreaElement.readOnly')
  @DocsEditable
  bool get readOnly native "HTMLTextAreaElement_readOnly_Getter";

  @DomName('HTMLTextAreaElement.readOnly')
  @DocsEditable
  void set readOnly(bool value) native "HTMLTextAreaElement_readOnly_Setter";

  @DomName('HTMLTextAreaElement.required')
  @DocsEditable
  bool get required native "HTMLTextAreaElement_required_Getter";

  @DomName('HTMLTextAreaElement.required')
  @DocsEditable
  void set required(bool value) native "HTMLTextAreaElement_required_Setter";

  @DomName('HTMLTextAreaElement.rows')
  @DocsEditable
  int get rows native "HTMLTextAreaElement_rows_Getter";

  @DomName('HTMLTextAreaElement.rows')
  @DocsEditable
  void set rows(int value) native "HTMLTextAreaElement_rows_Setter";

  @DomName('HTMLTextAreaElement.selectionDirection')
  @DocsEditable
  String get selectionDirection native "HTMLTextAreaElement_selectionDirection_Getter";

  @DomName('HTMLTextAreaElement.selectionDirection')
  @DocsEditable
  void set selectionDirection(String value) native "HTMLTextAreaElement_selectionDirection_Setter";

  @DomName('HTMLTextAreaElement.selectionEnd')
  @DocsEditable
  int get selectionEnd native "HTMLTextAreaElement_selectionEnd_Getter";

  @DomName('HTMLTextAreaElement.selectionEnd')
  @DocsEditable
  void set selectionEnd(int value) native "HTMLTextAreaElement_selectionEnd_Setter";

  @DomName('HTMLTextAreaElement.selectionStart')
  @DocsEditable
  int get selectionStart native "HTMLTextAreaElement_selectionStart_Getter";

  @DomName('HTMLTextAreaElement.selectionStart')
  @DocsEditable
  void set selectionStart(int value) native "HTMLTextAreaElement_selectionStart_Setter";

  @DomName('HTMLTextAreaElement.textLength')
  @DocsEditable
  int get textLength native "HTMLTextAreaElement_textLength_Getter";

  @DomName('HTMLTextAreaElement.type')
  @DocsEditable
  String get type native "HTMLTextAreaElement_type_Getter";

  @DomName('HTMLTextAreaElement.validationMessage')
  @DocsEditable
  String get validationMessage native "HTMLTextAreaElement_validationMessage_Getter";

  @DomName('HTMLTextAreaElement.validity')
  @DocsEditable
  ValidityState get validity native "HTMLTextAreaElement_validity_Getter";

  @DomName('HTMLTextAreaElement.value')
  @DocsEditable
  String get value native "HTMLTextAreaElement_value_Getter";

  @DomName('HTMLTextAreaElement.value')
  @DocsEditable
  void set value(String value) native "HTMLTextAreaElement_value_Setter";

  @DomName('HTMLTextAreaElement.willValidate')
  @DocsEditable
  bool get willValidate native "HTMLTextAreaElement_willValidate_Getter";

  @DomName('HTMLTextAreaElement.wrap')
  @DocsEditable
  String get wrap native "HTMLTextAreaElement_wrap_Getter";

  @DomName('HTMLTextAreaElement.wrap')
  @DocsEditable
  void set wrap(String value) native "HTMLTextAreaElement_wrap_Setter";

  @DomName('HTMLTextAreaElement.checkValidity')
  @DocsEditable
  bool checkValidity() native "HTMLTextAreaElement_checkValidity_Callback";

  @DomName('HTMLTextAreaElement.select')
  @DocsEditable
  void select() native "HTMLTextAreaElement_select_Callback";

  @DomName('HTMLTextAreaElement.setCustomValidity')
  @DocsEditable
  void setCustomValidity(String error) native "HTMLTextAreaElement_setCustomValidity_Callback";

  void setRangeText(String replacement, [int start, int end, String selectionMode]) {
    if ((replacement is String || replacement == null) && !?start && !?end && !?selectionMode) {
      _setRangeText_1(replacement);
      return;
    }
    if ((replacement is String || replacement == null) && (start is int || start == null) && (end is int || end == null) && (selectionMode is String || selectionMode == null)) {
      _setRangeText_2(replacement, start, end, selectionMode);
      return;
    }
    throw new ArgumentError("Incorrect number or type of arguments");
  }

  @DomName('HTMLTextAreaElement._setRangeText_1')
  @DocsEditable
  void _setRangeText_1(replacement) native "HTMLTextAreaElement__setRangeText_1_Callback";

  @DomName('HTMLTextAreaElement._setRangeText_2')
  @DocsEditable
  void _setRangeText_2(replacement, start, end, selectionMode) native "HTMLTextAreaElement__setRangeText_2_Callback";

  void setSelectionRange(int start, int end, [String direction]) {
    if (?direction) {
      _setSelectionRange_1(start, end, direction);
      return;
    }
    _setSelectionRange_2(start, end);
    return;
  }

  @DomName('HTMLTextAreaElement._setSelectionRange_1')
  @DocsEditable
  void _setSelectionRange_1(start, end, direction) native "HTMLTextAreaElement__setSelectionRange_1_Callback";

  @DomName('HTMLTextAreaElement._setSelectionRange_2')
  @DocsEditable
  void _setSelectionRange_2(start, end) native "HTMLTextAreaElement__setSelectionRange_2_Callback";

}
// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DomName('TextEvent')
class TextEvent extends UIEvent {
  factory TextEvent(String type,
    {bool canBubble: false, bool cancelable: false, Window view, String data}) {
    if (view == null) {
      view = window;
    }
    var e = document.$dom_createEvent("TextEvent");
    e.$dom_initTextEvent(type, canBubble, cancelable, view, data);
    return e;
  }
  TextEvent.internal() : super.internal();

  @DomName('TextEvent.data')
  @DocsEditable
  String get data native "TextEvent_data_Getter";

  @DomName('TextEvent.initTextEvent')
  @DocsEditable
  void $dom_initTextEvent(String typeArg, bool canBubbleArg, bool cancelableArg, Window viewArg, String dataArg) native "TextEvent_initTextEvent_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('TextMetrics')
class TextMetrics extends NativeFieldWrapperClass1 {
  TextMetrics.internal();

  @DomName('TextMetrics.width')
  @DocsEditable
  num get width native "TextMetrics_width_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('TextTrack')
class TextTrack extends EventTarget {
  TextTrack.internal() : super.internal();

  @DomName('TextTrack.cuechange')
  @DocsEditable
  static const EventStreamProvider<Event> cueChangeEvent = const EventStreamProvider<Event>('cuechange');

  @DocsEditable
  @DomName('EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent')
  @deprecated
  TextTrackEvents get on =>
    new TextTrackEvents(this);

  @DomName('TextTrack.activeCues')
  @DocsEditable
  TextTrackCueList get activeCues native "TextTrack_activeCues_Getter";

  @DomName('TextTrack.cues')
  @DocsEditable
  TextTrackCueList get cues native "TextTrack_cues_Getter";

  @DomName('TextTrack.kind')
  @DocsEditable
  String get kind native "TextTrack_kind_Getter";

  @DomName('TextTrack.label')
  @DocsEditable
  String get label native "TextTrack_label_Getter";

  @DomName('TextTrack.language')
  @DocsEditable
  String get language native "TextTrack_language_Getter";

  @DomName('TextTrack.mode')
  @DocsEditable
  String get mode native "TextTrack_mode_Getter";

  @DomName('TextTrack.mode')
  @DocsEditable
  void set mode(String value) native "TextTrack_mode_Setter";

  @DomName('TextTrack.addCue')
  @DocsEditable
  void addCue(TextTrackCue cue) native "TextTrack_addCue_Callback";

  @DomName('TextTrack.addEventListener')
  @DocsEditable
  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]) native "TextTrack_addEventListener_Callback";

  @DomName('TextTrack.dispatchEvent')
  @DocsEditable
  bool dispatchEvent(Event evt) native "TextTrack_dispatchEvent_Callback";

  @DomName('TextTrack.removeCue')
  @DocsEditable
  void removeCue(TextTrackCue cue) native "TextTrack_removeCue_Callback";

  @DomName('TextTrack.removeEventListener')
  @DocsEditable
  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]) native "TextTrack_removeEventListener_Callback";

  @DomName('TextTrack.cuechange')
  @DocsEditable
  Stream<Event> get onCueChange => cueChangeEvent.forTarget(this);

}

@DocsEditable
@deprecated
class TextTrackEvents extends Events {
  @DocsEditable
  TextTrackEvents(EventTarget _ptr) : super(_ptr);

  @DocsEditable
  EventListenerList get cueChange => this['cuechange'];
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('TextTrackCue')
class TextTrackCue extends EventTarget {
  TextTrackCue.internal() : super.internal();

  @DomName('TextTrackCue.enter')
  @DocsEditable
  static const EventStreamProvider<Event> enterEvent = const EventStreamProvider<Event>('enter');

  @DomName('TextTrackCue.exit')
  @DocsEditable
  static const EventStreamProvider<Event> exitEvent = const EventStreamProvider<Event>('exit');

  @DocsEditable
  factory TextTrackCue(num startTime, num endTime, String text) => TextTrackCue._create(startTime, endTime, text);
  static TextTrackCue _create(num startTime, num endTime, String text) native "TextTrackCue_constructor_Callback";

  @DocsEditable
  @DomName('EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent')
  @deprecated
  TextTrackCueEvents get on =>
    new TextTrackCueEvents(this);

  @DomName('TextTrackCue.align')
  @DocsEditable
  String get align native "TextTrackCue_align_Getter";

  @DomName('TextTrackCue.align')
  @DocsEditable
  void set align(String value) native "TextTrackCue_align_Setter";

  @DomName('TextTrackCue.endTime')
  @DocsEditable
  num get endTime native "TextTrackCue_endTime_Getter";

  @DomName('TextTrackCue.endTime')
  @DocsEditable
  void set endTime(num value) native "TextTrackCue_endTime_Setter";

  @DomName('TextTrackCue.id')
  @DocsEditable
  String get id native "TextTrackCue_id_Getter";

  @DomName('TextTrackCue.id')
  @DocsEditable
  void set id(String value) native "TextTrackCue_id_Setter";

  @DomName('TextTrackCue.line')
  @DocsEditable
  int get line native "TextTrackCue_line_Getter";

  @DomName('TextTrackCue.line')
  @DocsEditable
  void set line(int value) native "TextTrackCue_line_Setter";

  @DomName('TextTrackCue.pauseOnExit')
  @DocsEditable
  bool get pauseOnExit native "TextTrackCue_pauseOnExit_Getter";

  @DomName('TextTrackCue.pauseOnExit')
  @DocsEditable
  void set pauseOnExit(bool value) native "TextTrackCue_pauseOnExit_Setter";

  @DomName('TextTrackCue.position')
  @DocsEditable
  int get position native "TextTrackCue_position_Getter";

  @DomName('TextTrackCue.position')
  @DocsEditable
  void set position(int value) native "TextTrackCue_position_Setter";

  @DomName('TextTrackCue.size')
  @DocsEditable
  int get size native "TextTrackCue_size_Getter";

  @DomName('TextTrackCue.size')
  @DocsEditable
  void set size(int value) native "TextTrackCue_size_Setter";

  @DomName('TextTrackCue.snapToLines')
  @DocsEditable
  bool get snapToLines native "TextTrackCue_snapToLines_Getter";

  @DomName('TextTrackCue.snapToLines')
  @DocsEditable
  void set snapToLines(bool value) native "TextTrackCue_snapToLines_Setter";

  @DomName('TextTrackCue.startTime')
  @DocsEditable
  num get startTime native "TextTrackCue_startTime_Getter";

  @DomName('TextTrackCue.startTime')
  @DocsEditable
  void set startTime(num value) native "TextTrackCue_startTime_Setter";

  @DomName('TextTrackCue.text')
  @DocsEditable
  String get text native "TextTrackCue_text_Getter";

  @DomName('TextTrackCue.text')
  @DocsEditable
  void set text(String value) native "TextTrackCue_text_Setter";

  @DomName('TextTrackCue.track')
  @DocsEditable
  TextTrack get track native "TextTrackCue_track_Getter";

  @DomName('TextTrackCue.vertical')
  @DocsEditable
  String get vertical native "TextTrackCue_vertical_Getter";

  @DomName('TextTrackCue.vertical')
  @DocsEditable
  void set vertical(String value) native "TextTrackCue_vertical_Setter";

  @DomName('TextTrackCue.addEventListener')
  @DocsEditable
  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]) native "TextTrackCue_addEventListener_Callback";

  @DomName('TextTrackCue.dispatchEvent')
  @DocsEditable
  bool dispatchEvent(Event evt) native "TextTrackCue_dispatchEvent_Callback";

  @DomName('TextTrackCue.getCueAsHTML')
  @DocsEditable
  DocumentFragment getCueAsHtml() native "TextTrackCue_getCueAsHTML_Callback";

  @DomName('TextTrackCue.removeEventListener')
  @DocsEditable
  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]) native "TextTrackCue_removeEventListener_Callback";

  @DomName('TextTrackCue.enter')
  @DocsEditable
  Stream<Event> get onEnter => enterEvent.forTarget(this);

  @DomName('TextTrackCue.exit')
  @DocsEditable
  Stream<Event> get onExit => exitEvent.forTarget(this);

}

@DocsEditable
@deprecated
class TextTrackCueEvents extends Events {
  @DocsEditable
  TextTrackCueEvents(EventTarget _ptr) : super(_ptr);

  @DocsEditable
  EventListenerList get enter => this['enter'];

  @DocsEditable
  EventListenerList get exit => this['exit'];
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('TextTrackCueList')
class TextTrackCueList extends NativeFieldWrapperClass1 implements List<TextTrackCue> {
  TextTrackCueList.internal();

  @DomName('TextTrackCueList.length')
  @DocsEditable
  int get length native "TextTrackCueList_length_Getter";

  TextTrackCue operator[](int index) native "TextTrackCueList_item_Callback";

  void operator[]=(int index, TextTrackCue value) {
    throw new UnsupportedError("Cannot assign element of immutable List.");
  }
  // -- start List<TextTrackCue> mixins.
  // TextTrackCue is the element type.

  // From Iterable<TextTrackCue>:

  Iterator<TextTrackCue> get iterator {
    // Note: NodeLists are not fixed size. And most probably length shouldn't
    // be cached in both iterator _and_ forEach method. For now caching it
    // for consistency.
    return new FixedSizeListIterator<TextTrackCue>(this);
  }

  dynamic reduce(dynamic initialValue, dynamic combine(dynamic, TextTrackCue)) {
    return IterableMixinWorkaround.reduce(this, initialValue, combine);
  }

  bool contains(TextTrackCue element) => IterableMixinWorkaround.contains(this, element);

  void forEach(void f(TextTrackCue element)) => IterableMixinWorkaround.forEach(this, f);

  String join([String separator]) =>
      IterableMixinWorkaround.joinList(this, separator);

  List mappedBy(f(TextTrackCue element)) => IterableMixinWorkaround.mappedByList(this, f);

  Iterable<TextTrackCue> where(bool f(TextTrackCue element)) =>
      IterableMixinWorkaround.where(this, f);

  bool every(bool f(TextTrackCue element)) => IterableMixinWorkaround.every(this, f);

  bool any(bool f(TextTrackCue element)) => IterableMixinWorkaround.any(this, f);

  List<TextTrackCue> toList() => new List<TextTrackCue>.from(this);
  Set<TextTrackCue> toSet() => new Set<TextTrackCue>.from(this);

  bool get isEmpty => this.length == 0;

  List<TextTrackCue> take(int n) => IterableMixinWorkaround.takeList(this, n);

  Iterable<TextTrackCue> takeWhile(bool test(TextTrackCue value)) {
    return IterableMixinWorkaround.takeWhile(this, test);
  }

  List<TextTrackCue> skip(int n) => IterableMixinWorkaround.skipList(this, n);

  Iterable<TextTrackCue> skipWhile(bool test(TextTrackCue value)) {
    return IterableMixinWorkaround.skipWhile(this, test);
  }

  TextTrackCue firstMatching(bool test(TextTrackCue value), { TextTrackCue orElse() }) {
    return IterableMixinWorkaround.firstMatching(this, test, orElse);
  }

  TextTrackCue lastMatching(bool test(TextTrackCue value), {TextTrackCue orElse()}) {
    return IterableMixinWorkaround.lastMatchingInList(this, test, orElse);
  }

  TextTrackCue singleMatching(bool test(TextTrackCue value)) {
    return IterableMixinWorkaround.singleMatching(this, test);
  }

  TextTrackCue elementAt(int index) {
    return this[index];
  }

  // From Collection<TextTrackCue>:

  void add(TextTrackCue value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addLast(TextTrackCue value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addAll(Iterable<TextTrackCue> iterable) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  // From List<TextTrackCue>:
  void set length(int value) {
    throw new UnsupportedError("Cannot resize immutable List.");
  }

  void clear() {
    throw new UnsupportedError("Cannot clear immutable List.");
  }

  List<TextTrackCue> get reversed =>
      new ReversedListView<TextTrackCue>(this, 0, null);

  void sort([int compare(TextTrackCue a, TextTrackCue b)]) {
    throw new UnsupportedError("Cannot sort immutable List.");
  }

  int indexOf(TextTrackCue element, [int start = 0]) =>
      Lists.indexOf(this, element, start, this.length);

  int lastIndexOf(TextTrackCue element, [int start]) {
    if (start == null) start = length - 1;
    return Lists.lastIndexOf(this, element, start);
  }

  TextTrackCue get first {
    if (this.length > 0) return this[0];
    throw new StateError("No elements");
  }

  TextTrackCue get last {
    if (this.length > 0) return this[this.length - 1];
    throw new StateError("No elements");
  }

  TextTrackCue get single {
    if (length == 1) return this[0];
    if (length == 0) throw new StateError("No elements");
    throw new StateError("More than one element");
  }

  TextTrackCue min([int compare(TextTrackCue a, TextTrackCue b)]) =>
      IterableMixinWorkaround.min(this, compare);

  TextTrackCue max([int compare(TextTrackCue a, TextTrackCue b)]) =>
      IterableMixinWorkaround.max(this, compare);

  TextTrackCue removeAt(int pos) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  TextTrackCue removeLast() {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void remove(Object object) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void removeAll(Iterable elements) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void retainAll(Iterable elements) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void removeMatching(bool test(TextTrackCue element)) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void retainMatching(bool test(TextTrackCue element)) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void setRange(int start, int rangeLength, List<TextTrackCue> from, [int startFrom]) {
    throw new UnsupportedError("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int rangeLength) {
    throw new UnsupportedError("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int rangeLength, [TextTrackCue initialValue]) {
    throw new UnsupportedError("Cannot insertRange on immutable List.");
  }

  List<TextTrackCue> getRange(int start, int rangeLength) =>
      Lists.getRange(this, start, rangeLength, <TextTrackCue>[]);

  // -- end List<TextTrackCue> mixins.

  @DomName('TextTrackCueList.getCueById')
  @DocsEditable
  TextTrackCue getCueById(String id) native "TextTrackCueList_getCueById_Callback";

  @DomName('TextTrackCueList.item')
  @DocsEditable
  TextTrackCue item(int index) native "TextTrackCueList_item_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('TextTrackList')
class TextTrackList extends EventTarget implements List<TextTrack> {
  TextTrackList.internal() : super.internal();

  @DomName('TextTrackList.addtrack')
  @DocsEditable
  static const EventStreamProvider<TrackEvent> addTrackEvent = const EventStreamProvider<TrackEvent>('addtrack');

  @DocsEditable
  @DomName('EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent')
  @deprecated
  TextTrackListEvents get on =>
    new TextTrackListEvents(this);

  @DomName('TextTrackList.length')
  @DocsEditable
  int get length native "TextTrackList_length_Getter";

  TextTrack operator[](int index) native "TextTrackList_item_Callback";

  void operator[]=(int index, TextTrack value) {
    throw new UnsupportedError("Cannot assign element of immutable List.");
  }
  // -- start List<TextTrack> mixins.
  // TextTrack is the element type.

  // From Iterable<TextTrack>:

  Iterator<TextTrack> get iterator {
    // Note: NodeLists are not fixed size. And most probably length shouldn't
    // be cached in both iterator _and_ forEach method. For now caching it
    // for consistency.
    return new FixedSizeListIterator<TextTrack>(this);
  }

  dynamic reduce(dynamic initialValue, dynamic combine(dynamic, TextTrack)) {
    return IterableMixinWorkaround.reduce(this, initialValue, combine);
  }

  bool contains(TextTrack element) => IterableMixinWorkaround.contains(this, element);

  void forEach(void f(TextTrack element)) => IterableMixinWorkaround.forEach(this, f);

  String join([String separator]) =>
      IterableMixinWorkaround.joinList(this, separator);

  List mappedBy(f(TextTrack element)) => IterableMixinWorkaround.mappedByList(this, f);

  Iterable<TextTrack> where(bool f(TextTrack element)) =>
      IterableMixinWorkaround.where(this, f);

  bool every(bool f(TextTrack element)) => IterableMixinWorkaround.every(this, f);

  bool any(bool f(TextTrack element)) => IterableMixinWorkaround.any(this, f);

  List<TextTrack> toList() => new List<TextTrack>.from(this);
  Set<TextTrack> toSet() => new Set<TextTrack>.from(this);

  bool get isEmpty => this.length == 0;

  List<TextTrack> take(int n) => IterableMixinWorkaround.takeList(this, n);

  Iterable<TextTrack> takeWhile(bool test(TextTrack value)) {
    return IterableMixinWorkaround.takeWhile(this, test);
  }

  List<TextTrack> skip(int n) => IterableMixinWorkaround.skipList(this, n);

  Iterable<TextTrack> skipWhile(bool test(TextTrack value)) {
    return IterableMixinWorkaround.skipWhile(this, test);
  }

  TextTrack firstMatching(bool test(TextTrack value), { TextTrack orElse() }) {
    return IterableMixinWorkaround.firstMatching(this, test, orElse);
  }

  TextTrack lastMatching(bool test(TextTrack value), {TextTrack orElse()}) {
    return IterableMixinWorkaround.lastMatchingInList(this, test, orElse);
  }

  TextTrack singleMatching(bool test(TextTrack value)) {
    return IterableMixinWorkaround.singleMatching(this, test);
  }

  TextTrack elementAt(int index) {
    return this[index];
  }

  // From Collection<TextTrack>:

  void add(TextTrack value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addLast(TextTrack value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addAll(Iterable<TextTrack> iterable) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  // From List<TextTrack>:
  void set length(int value) {
    throw new UnsupportedError("Cannot resize immutable List.");
  }

  void clear() {
    throw new UnsupportedError("Cannot clear immutable List.");
  }

  List<TextTrack> get reversed =>
      new ReversedListView<TextTrack>(this, 0, null);

  void sort([int compare(TextTrack a, TextTrack b)]) {
    throw new UnsupportedError("Cannot sort immutable List.");
  }

  int indexOf(TextTrack element, [int start = 0]) =>
      Lists.indexOf(this, element, start, this.length);

  int lastIndexOf(TextTrack element, [int start]) {
    if (start == null) start = length - 1;
    return Lists.lastIndexOf(this, element, start);
  }

  TextTrack get first {
    if (this.length > 0) return this[0];
    throw new StateError("No elements");
  }

  TextTrack get last {
    if (this.length > 0) return this[this.length - 1];
    throw new StateError("No elements");
  }

  TextTrack get single {
    if (length == 1) return this[0];
    if (length == 0) throw new StateError("No elements");
    throw new StateError("More than one element");
  }

  TextTrack min([int compare(TextTrack a, TextTrack b)]) =>
      IterableMixinWorkaround.min(this, compare);

  TextTrack max([int compare(TextTrack a, TextTrack b)]) =>
      IterableMixinWorkaround.max(this, compare);

  TextTrack removeAt(int pos) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  TextTrack removeLast() {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void remove(Object object) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void removeAll(Iterable elements) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void retainAll(Iterable elements) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void removeMatching(bool test(TextTrack element)) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void retainMatching(bool test(TextTrack element)) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void setRange(int start, int rangeLength, List<TextTrack> from, [int startFrom]) {
    throw new UnsupportedError("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int rangeLength) {
    throw new UnsupportedError("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int rangeLength, [TextTrack initialValue]) {
    throw new UnsupportedError("Cannot insertRange on immutable List.");
  }

  List<TextTrack> getRange(int start, int rangeLength) =>
      Lists.getRange(this, start, rangeLength, <TextTrack>[]);

  // -- end List<TextTrack> mixins.

  @DomName('TextTrackList.addEventListener')
  @DocsEditable
  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]) native "TextTrackList_addEventListener_Callback";

  @DomName('TextTrackList.dispatchEvent')
  @DocsEditable
  bool dispatchEvent(Event evt) native "TextTrackList_dispatchEvent_Callback";

  @DomName('TextTrackList.item')
  @DocsEditable
  TextTrack item(int index) native "TextTrackList_item_Callback";

  @DomName('TextTrackList.removeEventListener')
  @DocsEditable
  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]) native "TextTrackList_removeEventListener_Callback";

  @DomName('TextTrackList.addtrack')
  @DocsEditable
  Stream<TrackEvent> get onAddTrack => addTrackEvent.forTarget(this);

}

@DocsEditable
@deprecated
class TextTrackListEvents extends Events {
  @DocsEditable
  TextTrackListEvents(EventTarget _ptr) : super(_ptr);

  @DocsEditable
  EventListenerList get addTrack => this['addtrack'];
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('TimeRanges')
class TimeRanges extends NativeFieldWrapperClass1 {
  TimeRanges.internal();

  @DomName('TimeRanges.length')
  @DocsEditable
  int get length native "TimeRanges_length_Getter";

  @DomName('TimeRanges.end')
  @DocsEditable
  num end(int index) native "TimeRanges_end_Callback";

  @DomName('TimeRanges.start')
  @DocsEditable
  num start(int index) native "TimeRanges_start_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


typedef void TimeoutHandler();
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('HTMLTitleElement')
class TitleElement extends _Element_Merged {
  TitleElement.internal() : super.internal();

  @DocsEditable
  factory TitleElement() => document.$dom_createElement("title");

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('Touch')
class Touch extends NativeFieldWrapperClass1 {
  Touch.internal();

  @DomName('Touch.clientX')
  @DocsEditable
  int get clientX native "Touch_clientX_Getter";

  @DomName('Touch.clientY')
  @DocsEditable
  int get clientY native "Touch_clientY_Getter";

  @DomName('Touch.identifier')
  @DocsEditable
  int get identifier native "Touch_identifier_Getter";

  @DomName('Touch.pageX')
  @DocsEditable
  int get pageX native "Touch_pageX_Getter";

  @DomName('Touch.pageY')
  @DocsEditable
  int get pageY native "Touch_pageY_Getter";

  @DomName('Touch.screenX')
  @DocsEditable
  int get screenX native "Touch_screenX_Getter";

  @DomName('Touch.screenY')
  @DocsEditable
  int get screenY native "Touch_screenY_Getter";

  @DomName('Touch.target')
  @DocsEditable
  EventTarget get target native "Touch_target_Getter";

  @DomName('Touch.webkitForce')
  @DocsEditable
  num get webkitForce native "Touch_webkitForce_Getter";

  @DomName('Touch.webkitRadiusX')
  @DocsEditable
  int get webkitRadiusX native "Touch_webkitRadiusX_Getter";

  @DomName('Touch.webkitRadiusY')
  @DocsEditable
  int get webkitRadiusY native "Touch_webkitRadiusY_Getter";

  @DomName('Touch.webkitRotationAngle')
  @DocsEditable
  num get webkitRotationAngle native "Touch_webkitRotationAngle_Getter";

}
// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DomName('TouchEvent')
class TouchEvent extends UIEvent {
  factory TouchEvent(TouchList touches, TouchList targetTouches,
      TouchList changedTouches, String type,
      {Window view, int screenX: 0, int screenY: 0, int clientX: 0,
      int clientY: 0, bool ctrlKey: false, bool altKey: false,
      bool shiftKey: false, bool metaKey: false}) {
    if (view == null) {
      view = window;
    }
    var e = document.$dom_createEvent("TouchEvent");
    e.$dom_initTouchEvent(touches, targetTouches, changedTouches, type, view,
        screenX, screenY, clientX, clientY, ctrlKey, altKey, shiftKey, metaKey);
    return e;
  }
  TouchEvent.internal() : super.internal();

  @DomName('TouchEvent.altKey')
  @DocsEditable
  bool get altKey native "TouchEvent_altKey_Getter";

  @DomName('TouchEvent.changedTouches')
  @DocsEditable
  TouchList get changedTouches native "TouchEvent_changedTouches_Getter";

  @DomName('TouchEvent.ctrlKey')
  @DocsEditable
  bool get ctrlKey native "TouchEvent_ctrlKey_Getter";

  @DomName('TouchEvent.metaKey')
  @DocsEditable
  bool get metaKey native "TouchEvent_metaKey_Getter";

  @DomName('TouchEvent.shiftKey')
  @DocsEditable
  bool get shiftKey native "TouchEvent_shiftKey_Getter";

  @DomName('TouchEvent.targetTouches')
  @DocsEditable
  TouchList get targetTouches native "TouchEvent_targetTouches_Getter";

  @DomName('TouchEvent.touches')
  @DocsEditable
  TouchList get touches native "TouchEvent_touches_Getter";

  @DomName('TouchEvent.initTouchEvent')
  @DocsEditable
  void $dom_initTouchEvent(TouchList touches, TouchList targetTouches, TouchList changedTouches, String type, Window view, int screenX, int screenY, int clientX, int clientY, bool ctrlKey, bool altKey, bool shiftKey, bool metaKey) native "TouchEvent_initTouchEvent_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('TouchList')
class TouchList extends NativeFieldWrapperClass1 implements List<Touch> {
  TouchList.internal();

  @DomName('TouchList.length')
  @DocsEditable
  int get length native "TouchList_length_Getter";

  Touch operator[](int index) native "TouchList_item_Callback";

  void operator[]=(int index, Touch value) {
    throw new UnsupportedError("Cannot assign element of immutable List.");
  }
  // -- start List<Touch> mixins.
  // Touch is the element type.

  // From Iterable<Touch>:

  Iterator<Touch> get iterator {
    // Note: NodeLists are not fixed size. And most probably length shouldn't
    // be cached in both iterator _and_ forEach method. For now caching it
    // for consistency.
    return new FixedSizeListIterator<Touch>(this);
  }

  dynamic reduce(dynamic initialValue, dynamic combine(dynamic, Touch)) {
    return IterableMixinWorkaround.reduce(this, initialValue, combine);
  }

  bool contains(Touch element) => IterableMixinWorkaround.contains(this, element);

  void forEach(void f(Touch element)) => IterableMixinWorkaround.forEach(this, f);

  String join([String separator]) =>
      IterableMixinWorkaround.joinList(this, separator);

  List mappedBy(f(Touch element)) => IterableMixinWorkaround.mappedByList(this, f);

  Iterable<Touch> where(bool f(Touch element)) =>
      IterableMixinWorkaround.where(this, f);

  bool every(bool f(Touch element)) => IterableMixinWorkaround.every(this, f);

  bool any(bool f(Touch element)) => IterableMixinWorkaround.any(this, f);

  List<Touch> toList() => new List<Touch>.from(this);
  Set<Touch> toSet() => new Set<Touch>.from(this);

  bool get isEmpty => this.length == 0;

  List<Touch> take(int n) => IterableMixinWorkaround.takeList(this, n);

  Iterable<Touch> takeWhile(bool test(Touch value)) {
    return IterableMixinWorkaround.takeWhile(this, test);
  }

  List<Touch> skip(int n) => IterableMixinWorkaround.skipList(this, n);

  Iterable<Touch> skipWhile(bool test(Touch value)) {
    return IterableMixinWorkaround.skipWhile(this, test);
  }

  Touch firstMatching(bool test(Touch value), { Touch orElse() }) {
    return IterableMixinWorkaround.firstMatching(this, test, orElse);
  }

  Touch lastMatching(bool test(Touch value), {Touch orElse()}) {
    return IterableMixinWorkaround.lastMatchingInList(this, test, orElse);
  }

  Touch singleMatching(bool test(Touch value)) {
    return IterableMixinWorkaround.singleMatching(this, test);
  }

  Touch elementAt(int index) {
    return this[index];
  }

  // From Collection<Touch>:

  void add(Touch value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addLast(Touch value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addAll(Iterable<Touch> iterable) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  // From List<Touch>:
  void set length(int value) {
    throw new UnsupportedError("Cannot resize immutable List.");
  }

  void clear() {
    throw new UnsupportedError("Cannot clear immutable List.");
  }

  List<Touch> get reversed =>
      new ReversedListView<Touch>(this, 0, null);

  void sort([int compare(Touch a, Touch b)]) {
    throw new UnsupportedError("Cannot sort immutable List.");
  }

  int indexOf(Touch element, [int start = 0]) =>
      Lists.indexOf(this, element, start, this.length);

  int lastIndexOf(Touch element, [int start]) {
    if (start == null) start = length - 1;
    return Lists.lastIndexOf(this, element, start);
  }

  Touch get first {
    if (this.length > 0) return this[0];
    throw new StateError("No elements");
  }

  Touch get last {
    if (this.length > 0) return this[this.length - 1];
    throw new StateError("No elements");
  }

  Touch get single {
    if (length == 1) return this[0];
    if (length == 0) throw new StateError("No elements");
    throw new StateError("More than one element");
  }

  Touch min([int compare(Touch a, Touch b)]) =>
      IterableMixinWorkaround.min(this, compare);

  Touch max([int compare(Touch a, Touch b)]) =>
      IterableMixinWorkaround.max(this, compare);

  Touch removeAt(int pos) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  Touch removeLast() {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void remove(Object object) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void removeAll(Iterable elements) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void retainAll(Iterable elements) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void removeMatching(bool test(Touch element)) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void retainMatching(bool test(Touch element)) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void setRange(int start, int rangeLength, List<Touch> from, [int startFrom]) {
    throw new UnsupportedError("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int rangeLength) {
    throw new UnsupportedError("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int rangeLength, [Touch initialValue]) {
    throw new UnsupportedError("Cannot insertRange on immutable List.");
  }

  List<Touch> getRange(int start, int rangeLength) =>
      Lists.getRange(this, start, rangeLength, <Touch>[]);

  // -- end List<Touch> mixins.

  @DomName('TouchList.item')
  @DocsEditable
  Touch item(int index) native "TouchList_item_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('HTMLTrackElement')
@SupportedBrowser(SupportedBrowser.CHROME)
@SupportedBrowser(SupportedBrowser.IE, '10')
@SupportedBrowser(SupportedBrowser.SAFARI)
class TrackElement extends _Element_Merged {
  TrackElement.internal() : super.internal();

  @DocsEditable
  factory TrackElement() => document.$dom_createElement("track");

  /// Checks if this type is supported on the current platform.
  static bool get supported => true;

  static const int ERROR = 3;

  static const int LOADED = 2;

  static const int LOADING = 1;

  static const int NONE = 0;

  @DomName('HTMLTrackElement.default')
  @DocsEditable
  bool get defaultValue native "HTMLTrackElement_default_Getter";

  @DomName('HTMLTrackElement.default')
  @DocsEditable
  void set defaultValue(bool value) native "HTMLTrackElement_default_Setter";

  @DomName('HTMLTrackElement.kind')
  @DocsEditable
  String get kind native "HTMLTrackElement_kind_Getter";

  @DomName('HTMLTrackElement.kind')
  @DocsEditable
  void set kind(String value) native "HTMLTrackElement_kind_Setter";

  @DomName('HTMLTrackElement.label')
  @DocsEditable
  String get label native "HTMLTrackElement_label_Getter";

  @DomName('HTMLTrackElement.label')
  @DocsEditable
  void set label(String value) native "HTMLTrackElement_label_Setter";

  @DomName('HTMLTrackElement.readyState')
  @DocsEditable
  int get readyState native "HTMLTrackElement_readyState_Getter";

  @DomName('HTMLTrackElement.src')
  @DocsEditable
  String get src native "HTMLTrackElement_src_Getter";

  @DomName('HTMLTrackElement.src')
  @DocsEditable
  void set src(String value) native "HTMLTrackElement_src_Setter";

  @DomName('HTMLTrackElement.srclang')
  @DocsEditable
  String get srclang native "HTMLTrackElement_srclang_Getter";

  @DomName('HTMLTrackElement.srclang')
  @DocsEditable
  void set srclang(String value) native "HTMLTrackElement_srclang_Setter";

  @DomName('HTMLTrackElement.track')
  @DocsEditable
  TextTrack get track native "HTMLTrackElement_track_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('TrackEvent')
class TrackEvent extends Event {
  TrackEvent.internal() : super.internal();

  @DomName('TrackEvent.track')
  @DocsEditable
  Object get track native "TrackEvent_track_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('WebKitTransitionEvent')
class TransitionEvent extends Event {
  TransitionEvent.internal() : super.internal();

  @DomName('WebKitTransitionEvent.elapsedTime')
  @DocsEditable
  num get elapsedTime native "WebKitTransitionEvent_elapsedTime_Getter";

  @DomName('WebKitTransitionEvent.propertyName')
  @DocsEditable
  String get propertyName native "WebKitTransitionEvent_propertyName_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('TreeWalker')
class TreeWalker extends NativeFieldWrapperClass1 {
  TreeWalker.internal();

  @DomName('TreeWalker.currentNode')
  @DocsEditable
  Node get currentNode native "TreeWalker_currentNode_Getter";

  @DomName('TreeWalker.currentNode')
  @DocsEditable
  void set currentNode(Node value) native "TreeWalker_currentNode_Setter";

  @DomName('TreeWalker.expandEntityReferences')
  @DocsEditable
  bool get expandEntityReferences native "TreeWalker_expandEntityReferences_Getter";

  @DomName('TreeWalker.filter')
  @DocsEditable
  NodeFilter get filter native "TreeWalker_filter_Getter";

  @DomName('TreeWalker.root')
  @DocsEditable
  Node get root native "TreeWalker_root_Getter";

  @DomName('TreeWalker.whatToShow')
  @DocsEditable
  int get whatToShow native "TreeWalker_whatToShow_Getter";

  @DomName('TreeWalker.firstChild')
  @DocsEditable
  Node firstChild() native "TreeWalker_firstChild_Callback";

  @DomName('TreeWalker.lastChild')
  @DocsEditable
  Node lastChild() native "TreeWalker_lastChild_Callback";

  @DomName('TreeWalker.nextNode')
  @DocsEditable
  Node nextNode() native "TreeWalker_nextNode_Callback";

  @DomName('TreeWalker.nextSibling')
  @DocsEditable
  Node nextSibling() native "TreeWalker_nextSibling_Callback";

  @DomName('TreeWalker.parentNode')
  @DocsEditable
  Node parentNode() native "TreeWalker_parentNode_Callback";

  @DomName('TreeWalker.previousNode')
  @DocsEditable
  Node previousNode() native "TreeWalker_previousNode_Callback";

  @DomName('TreeWalker.previousSibling')
  @DocsEditable
  Node previousSibling() native "TreeWalker_previousSibling_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DomName('UIEvent')
class UIEvent extends Event {
  // In JS, canBubble and cancelable are technically required parameters to
  // init*Event. In practice, though, if they aren't provided they simply
  // default to false (since that's Boolean(undefined)).
  //
  // Contrary to JS, we default canBubble and cancelable to true, since that's
  // what people want most of the time anyway.
  factory UIEvent(String type,
      {Window view, int detail: 0, bool canBubble: true,
      bool cancelable: true}) {
    if (view == null) {
      view = window;
    }
    final e = document.$dom_createEvent("UIEvent");
    e.$dom_initUIEvent(type, canBubble, cancelable, view, detail);
    return e;
  }
  UIEvent.internal() : super.internal();

  @DomName('UIEvent.charCode')
  @DocsEditable
  int get $dom_charCode native "UIEvent_charCode_Getter";

  @DomName('UIEvent.detail')
  @DocsEditable
  int get detail native "UIEvent_detail_Getter";

  @DomName('UIEvent.keyCode')
  @DocsEditable
  int get $dom_keyCode native "UIEvent_keyCode_Getter";

  @DomName('UIEvent.layerX')
  @DocsEditable
  int get layerX native "UIEvent_layerX_Getter";

  @DomName('UIEvent.layerY')
  @DocsEditable
  int get layerY native "UIEvent_layerY_Getter";

  @DomName('UIEvent.pageX')
  @DocsEditable
  int get pageX native "UIEvent_pageX_Getter";

  @DomName('UIEvent.pageY')
  @DocsEditable
  int get pageY native "UIEvent_pageY_Getter";

  @DomName('UIEvent.view')
  @DocsEditable
  WindowBase get view native "UIEvent_view_Getter";

  @DomName('UIEvent.which')
  @DocsEditable
  int get which native "UIEvent_which_Getter";

  @DomName('UIEvent.initUIEvent')
  @DocsEditable
  void $dom_initUIEvent(String type, bool canBubble, bool cancelable, Window view, int detail) native "UIEvent_initUIEvent_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('HTMLUListElement')
class UListElement extends _Element_Merged {
  UListElement.internal() : super.internal();

  @DocsEditable
  factory UListElement() => document.$dom_createElement("ul");

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('Uint16Array')
class Uint16Array extends ArrayBufferView implements List<int> {
  Uint16Array.internal() : super.internal();

  factory Uint16Array(int length) =>
    _TypedArrayFactoryProvider.createUint16Array(length);

  factory Uint16Array.fromList(List<int> list) =>
    _TypedArrayFactoryProvider.createUint16Array_fromList(list);

  factory Uint16Array.fromBuffer(ArrayBuffer buffer, [int byteOffset, int length]) => 
    _TypedArrayFactoryProvider.createUint16Array_fromBuffer(buffer, byteOffset, length);

  static const int BYTES_PER_ELEMENT = 2;

  @DomName('Uint16Array.length')
  @DocsEditable
  int get length native "Uint16Array_length_Getter";

  @DomName('Uint16Array.numericIndexGetter')
  @DocsEditable
  int operator[](int index) native "Uint16Array_numericIndexGetter_Callback";

  @DomName('Uint16Array.numericIndexSetter')
  @DocsEditable
  void operator[]=(int index, int value) native "Uint16Array_numericIndexSetter_Callback";
  // -- start List<int> mixins.
  // int is the element type.

  // From Iterable<int>:

  Iterator<int> get iterator {
    // Note: NodeLists are not fixed size. And most probably length shouldn't
    // be cached in both iterator _and_ forEach method. For now caching it
    // for consistency.
    return new FixedSizeListIterator<int>(this);
  }

  dynamic reduce(dynamic initialValue, dynamic combine(dynamic, int)) {
    return IterableMixinWorkaround.reduce(this, initialValue, combine);
  }

  bool contains(int element) => IterableMixinWorkaround.contains(this, element);

  void forEach(void f(int element)) => IterableMixinWorkaround.forEach(this, f);

  String join([String separator]) =>
      IterableMixinWorkaround.joinList(this, separator);

  List mappedBy(f(int element)) => IterableMixinWorkaround.mappedByList(this, f);

  Iterable<int> where(bool f(int element)) =>
      IterableMixinWorkaround.where(this, f);

  bool every(bool f(int element)) => IterableMixinWorkaround.every(this, f);

  bool any(bool f(int element)) => IterableMixinWorkaround.any(this, f);

  List<int> toList() => new List<int>.from(this);
  Set<int> toSet() => new Set<int>.from(this);

  bool get isEmpty => this.length == 0;

  List<int> take(int n) => IterableMixinWorkaround.takeList(this, n);

  Iterable<int> takeWhile(bool test(int value)) {
    return IterableMixinWorkaround.takeWhile(this, test);
  }

  List<int> skip(int n) => IterableMixinWorkaround.skipList(this, n);

  Iterable<int> skipWhile(bool test(int value)) {
    return IterableMixinWorkaround.skipWhile(this, test);
  }

  int firstMatching(bool test(int value), { int orElse() }) {
    return IterableMixinWorkaround.firstMatching(this, test, orElse);
  }

  int lastMatching(bool test(int value), {int orElse()}) {
    return IterableMixinWorkaround.lastMatchingInList(this, test, orElse);
  }

  int singleMatching(bool test(int value)) {
    return IterableMixinWorkaround.singleMatching(this, test);
  }

  int elementAt(int index) {
    return this[index];
  }

  // From Collection<int>:

  void add(int value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addLast(int value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addAll(Iterable<int> iterable) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  // From List<int>:
  void set length(int value) {
    throw new UnsupportedError("Cannot resize immutable List.");
  }

  void clear() {
    throw new UnsupportedError("Cannot clear immutable List.");
  }

  List<int> get reversed =>
      new ReversedListView<int>(this, 0, null);

  void sort([int compare(int a, int b)]) {
    throw new UnsupportedError("Cannot sort immutable List.");
  }

  int indexOf(int element, [int start = 0]) =>
      Lists.indexOf(this, element, start, this.length);

  int lastIndexOf(int element, [int start]) {
    if (start == null) start = length - 1;
    return Lists.lastIndexOf(this, element, start);
  }

  int get first {
    if (this.length > 0) return this[0];
    throw new StateError("No elements");
  }

  int get last {
    if (this.length > 0) return this[this.length - 1];
    throw new StateError("No elements");
  }

  int get single {
    if (length == 1) return this[0];
    if (length == 0) throw new StateError("No elements");
    throw new StateError("More than one element");
  }

  int min([int compare(int a, int b)]) =>
      IterableMixinWorkaround.min(this, compare);

  int max([int compare(int a, int b)]) =>
      IterableMixinWorkaround.max(this, compare);

  int removeAt(int pos) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  int removeLast() {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void remove(Object object) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void removeAll(Iterable elements) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void retainAll(Iterable elements) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void removeMatching(bool test(int element)) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void retainMatching(bool test(int element)) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void setRange(int start, int rangeLength, List<int> from, [int startFrom]) {
    throw new UnsupportedError("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int rangeLength) {
    throw new UnsupportedError("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int rangeLength, [int initialValue]) {
    throw new UnsupportedError("Cannot insertRange on immutable List.");
  }

  List<int> getRange(int start, int rangeLength) =>
      Lists.getRange(this, start, rangeLength, <int>[]);

  // -- end List<int> mixins.

  @DomName('Uint16Array.setElements')
  @DocsEditable
  void setElements(Object array, [int offset]) native "Uint16Array_setElements_Callback";

  Uint16Array subarray(int start, [int end]) {
    if (?end) {
      return _subarray_1(start, end);
    }
    return _subarray_2(start);
  }

  @DomName('Uint16Array._subarray_1')
  @DocsEditable
  Uint16Array _subarray_1(start, end) native "Uint16Array__subarray_1_Callback";

  @DomName('Uint16Array._subarray_2')
  @DocsEditable
  Uint16Array _subarray_2(start) native "Uint16Array__subarray_2_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('Uint32Array')
class Uint32Array extends ArrayBufferView implements List<int> {
  Uint32Array.internal() : super.internal();

  factory Uint32Array(int length) =>
    _TypedArrayFactoryProvider.createUint32Array(length);

  factory Uint32Array.fromList(List<int> list) =>
    _TypedArrayFactoryProvider.createUint32Array_fromList(list);

  factory Uint32Array.fromBuffer(ArrayBuffer buffer, [int byteOffset, int length]) => 
    _TypedArrayFactoryProvider.createUint32Array_fromBuffer(buffer, byteOffset, length);

  static const int BYTES_PER_ELEMENT = 4;

  @DomName('Uint32Array.length')
  @DocsEditable
  int get length native "Uint32Array_length_Getter";

  @DomName('Uint32Array.numericIndexGetter')
  @DocsEditable
  int operator[](int index) native "Uint32Array_numericIndexGetter_Callback";

  @DomName('Uint32Array.numericIndexSetter')
  @DocsEditable
  void operator[]=(int index, int value) native "Uint32Array_numericIndexSetter_Callback";
  // -- start List<int> mixins.
  // int is the element type.

  // From Iterable<int>:

  Iterator<int> get iterator {
    // Note: NodeLists are not fixed size. And most probably length shouldn't
    // be cached in both iterator _and_ forEach method. For now caching it
    // for consistency.
    return new FixedSizeListIterator<int>(this);
  }

  dynamic reduce(dynamic initialValue, dynamic combine(dynamic, int)) {
    return IterableMixinWorkaround.reduce(this, initialValue, combine);
  }

  bool contains(int element) => IterableMixinWorkaround.contains(this, element);

  void forEach(void f(int element)) => IterableMixinWorkaround.forEach(this, f);

  String join([String separator]) =>
      IterableMixinWorkaround.joinList(this, separator);

  List mappedBy(f(int element)) => IterableMixinWorkaround.mappedByList(this, f);

  Iterable<int> where(bool f(int element)) =>
      IterableMixinWorkaround.where(this, f);

  bool every(bool f(int element)) => IterableMixinWorkaround.every(this, f);

  bool any(bool f(int element)) => IterableMixinWorkaround.any(this, f);

  List<int> toList() => new List<int>.from(this);
  Set<int> toSet() => new Set<int>.from(this);

  bool get isEmpty => this.length == 0;

  List<int> take(int n) => IterableMixinWorkaround.takeList(this, n);

  Iterable<int> takeWhile(bool test(int value)) {
    return IterableMixinWorkaround.takeWhile(this, test);
  }

  List<int> skip(int n) => IterableMixinWorkaround.skipList(this, n);

  Iterable<int> skipWhile(bool test(int value)) {
    return IterableMixinWorkaround.skipWhile(this, test);
  }

  int firstMatching(bool test(int value), { int orElse() }) {
    return IterableMixinWorkaround.firstMatching(this, test, orElse);
  }

  int lastMatching(bool test(int value), {int orElse()}) {
    return IterableMixinWorkaround.lastMatchingInList(this, test, orElse);
  }

  int singleMatching(bool test(int value)) {
    return IterableMixinWorkaround.singleMatching(this, test);
  }

  int elementAt(int index) {
    return this[index];
  }

  // From Collection<int>:

  void add(int value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addLast(int value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addAll(Iterable<int> iterable) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  // From List<int>:
  void set length(int value) {
    throw new UnsupportedError("Cannot resize immutable List.");
  }

  void clear() {
    throw new UnsupportedError("Cannot clear immutable List.");
  }

  List<int> get reversed =>
      new ReversedListView<int>(this, 0, null);

  void sort([int compare(int a, int b)]) {
    throw new UnsupportedError("Cannot sort immutable List.");
  }

  int indexOf(int element, [int start = 0]) =>
      Lists.indexOf(this, element, start, this.length);

  int lastIndexOf(int element, [int start]) {
    if (start == null) start = length - 1;
    return Lists.lastIndexOf(this, element, start);
  }

  int get first {
    if (this.length > 0) return this[0];
    throw new StateError("No elements");
  }

  int get last {
    if (this.length > 0) return this[this.length - 1];
    throw new StateError("No elements");
  }

  int get single {
    if (length == 1) return this[0];
    if (length == 0) throw new StateError("No elements");
    throw new StateError("More than one element");
  }

  int min([int compare(int a, int b)]) =>
      IterableMixinWorkaround.min(this, compare);

  int max([int compare(int a, int b)]) =>
      IterableMixinWorkaround.max(this, compare);

  int removeAt(int pos) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  int removeLast() {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void remove(Object object) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void removeAll(Iterable elements) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void retainAll(Iterable elements) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void removeMatching(bool test(int element)) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void retainMatching(bool test(int element)) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void setRange(int start, int rangeLength, List<int> from, [int startFrom]) {
    throw new UnsupportedError("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int rangeLength) {
    throw new UnsupportedError("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int rangeLength, [int initialValue]) {
    throw new UnsupportedError("Cannot insertRange on immutable List.");
  }

  List<int> getRange(int start, int rangeLength) =>
      Lists.getRange(this, start, rangeLength, <int>[]);

  // -- end List<int> mixins.

  @DomName('Uint32Array.setElements')
  @DocsEditable
  void setElements(Object array, [int offset]) native "Uint32Array_setElements_Callback";

  Uint32Array subarray(int start, [int end]) {
    if (?end) {
      return _subarray_1(start, end);
    }
    return _subarray_2(start);
  }

  @DomName('Uint32Array._subarray_1')
  @DocsEditable
  Uint32Array _subarray_1(start, end) native "Uint32Array__subarray_1_Callback";

  @DomName('Uint32Array._subarray_2')
  @DocsEditable
  Uint32Array _subarray_2(start) native "Uint32Array__subarray_2_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('Uint8Array')
class Uint8Array extends ArrayBufferView implements List<int> {
  Uint8Array.internal() : super.internal();

  factory Uint8Array(int length) =>
    _TypedArrayFactoryProvider.createUint8Array(length);

  factory Uint8Array.fromList(List<int> list) =>
    _TypedArrayFactoryProvider.createUint8Array_fromList(list);

  factory Uint8Array.fromBuffer(ArrayBuffer buffer, [int byteOffset, int length]) => 
    _TypedArrayFactoryProvider.createUint8Array_fromBuffer(buffer, byteOffset, length);

  static const int BYTES_PER_ELEMENT = 1;

  @DomName('Uint8Array.length')
  @DocsEditable
  int get length native "Uint8Array_length_Getter";

  @DomName('Uint8Array.numericIndexGetter')
  @DocsEditable
  int operator[](int index) native "Uint8Array_numericIndexGetter_Callback";

  @DomName('Uint8Array.numericIndexSetter')
  @DocsEditable
  void operator[]=(int index, int value) native "Uint8Array_numericIndexSetter_Callback";
  // -- start List<int> mixins.
  // int is the element type.

  // From Iterable<int>:

  Iterator<int> get iterator {
    // Note: NodeLists are not fixed size. And most probably length shouldn't
    // be cached in both iterator _and_ forEach method. For now caching it
    // for consistency.
    return new FixedSizeListIterator<int>(this);
  }

  dynamic reduce(dynamic initialValue, dynamic combine(dynamic, int)) {
    return IterableMixinWorkaround.reduce(this, initialValue, combine);
  }

  bool contains(int element) => IterableMixinWorkaround.contains(this, element);

  void forEach(void f(int element)) => IterableMixinWorkaround.forEach(this, f);

  String join([String separator]) =>
      IterableMixinWorkaround.joinList(this, separator);

  List mappedBy(f(int element)) => IterableMixinWorkaround.mappedByList(this, f);

  Iterable<int> where(bool f(int element)) =>
      IterableMixinWorkaround.where(this, f);

  bool every(bool f(int element)) => IterableMixinWorkaround.every(this, f);

  bool any(bool f(int element)) => IterableMixinWorkaround.any(this, f);

  List<int> toList() => new List<int>.from(this);
  Set<int> toSet() => new Set<int>.from(this);

  bool get isEmpty => this.length == 0;

  List<int> take(int n) => IterableMixinWorkaround.takeList(this, n);

  Iterable<int> takeWhile(bool test(int value)) {
    return IterableMixinWorkaround.takeWhile(this, test);
  }

  List<int> skip(int n) => IterableMixinWorkaround.skipList(this, n);

  Iterable<int> skipWhile(bool test(int value)) {
    return IterableMixinWorkaround.skipWhile(this, test);
  }

  int firstMatching(bool test(int value), { int orElse() }) {
    return IterableMixinWorkaround.firstMatching(this, test, orElse);
  }

  int lastMatching(bool test(int value), {int orElse()}) {
    return IterableMixinWorkaround.lastMatchingInList(this, test, orElse);
  }

  int singleMatching(bool test(int value)) {
    return IterableMixinWorkaround.singleMatching(this, test);
  }

  int elementAt(int index) {
    return this[index];
  }

  // From Collection<int>:

  void add(int value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addLast(int value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addAll(Iterable<int> iterable) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  // From List<int>:
  void set length(int value) {
    throw new UnsupportedError("Cannot resize immutable List.");
  }

  void clear() {
    throw new UnsupportedError("Cannot clear immutable List.");
  }

  List<int> get reversed =>
      new ReversedListView<int>(this, 0, null);

  void sort([int compare(int a, int b)]) {
    throw new UnsupportedError("Cannot sort immutable List.");
  }

  int indexOf(int element, [int start = 0]) =>
      Lists.indexOf(this, element, start, this.length);

  int lastIndexOf(int element, [int start]) {
    if (start == null) start = length - 1;
    return Lists.lastIndexOf(this, element, start);
  }

  int get first {
    if (this.length > 0) return this[0];
    throw new StateError("No elements");
  }

  int get last {
    if (this.length > 0) return this[this.length - 1];
    throw new StateError("No elements");
  }

  int get single {
    if (length == 1) return this[0];
    if (length == 0) throw new StateError("No elements");
    throw new StateError("More than one element");
  }

  int min([int compare(int a, int b)]) =>
      IterableMixinWorkaround.min(this, compare);

  int max([int compare(int a, int b)]) =>
      IterableMixinWorkaround.max(this, compare);

  int removeAt(int pos) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  int removeLast() {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void remove(Object object) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void removeAll(Iterable elements) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void retainAll(Iterable elements) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void removeMatching(bool test(int element)) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void retainMatching(bool test(int element)) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void setRange(int start, int rangeLength, List<int> from, [int startFrom]) {
    throw new UnsupportedError("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int rangeLength) {
    throw new UnsupportedError("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int rangeLength, [int initialValue]) {
    throw new UnsupportedError("Cannot insertRange on immutable List.");
  }

  List<int> getRange(int start, int rangeLength) =>
      Lists.getRange(this, start, rangeLength, <int>[]);

  // -- end List<int> mixins.

  @DomName('Uint8Array.setElements')
  @DocsEditable
  void setElements(Object array, [int offset]) native "Uint8Array_setElements_Callback";

  Uint8Array subarray(int start, [int end]) {
    if (?end) {
      return _subarray_1(start, end);
    }
    return _subarray_2(start);
  }

  @DomName('Uint8Array._subarray_1')
  @DocsEditable
  Uint8Array _subarray_1(start, end) native "Uint8Array__subarray_1_Callback";

  @DomName('Uint8Array._subarray_2')
  @DocsEditable
  Uint8Array _subarray_2(start) native "Uint8Array__subarray_2_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('Uint8ClampedArray')
class Uint8ClampedArray extends Uint8Array implements List<int> {
  Uint8ClampedArray.internal() : super.internal();

  factory Uint8ClampedArray(int length) =>
    _TypedArrayFactoryProvider.createUint8ClampedArray(length);

  factory Uint8ClampedArray.fromList(List<int> list) =>
    _TypedArrayFactoryProvider.createUint8ClampedArray_fromList(list);

  factory Uint8ClampedArray.fromBuffer(ArrayBuffer buffer, [int byteOffset, int length]) => 
    _TypedArrayFactoryProvider.createUint8ClampedArray_fromBuffer(buffer, byteOffset, length);

  @DomName('Uint8ClampedArray.length')
  @DocsEditable
  int get length native "Uint8ClampedArray_length_Getter";

  @DomName('Uint8ClampedArray.numericIndexGetter')
  @DocsEditable
  int operator[](int index) native "Uint8ClampedArray_numericIndexGetter_Callback";

  @DomName('Uint8ClampedArray.numericIndexSetter')
  @DocsEditable
  void operator[]=(int index, int value) native "Uint8ClampedArray_numericIndexSetter_Callback";
  // -- start List<int> mixins.
  // int is the element type.

  // From Iterable<int>:

  Iterator<int> get iterator {
    // Note: NodeLists are not fixed size. And most probably length shouldn't
    // be cached in both iterator _and_ forEach method. For now caching it
    // for consistency.
    return new FixedSizeListIterator<int>(this);
  }

  dynamic reduce(dynamic initialValue, dynamic combine(dynamic, int)) {
    return IterableMixinWorkaround.reduce(this, initialValue, combine);
  }

  bool contains(int element) => IterableMixinWorkaround.contains(this, element);

  void forEach(void f(int element)) => IterableMixinWorkaround.forEach(this, f);

  String join([String separator]) =>
      IterableMixinWorkaround.joinList(this, separator);

  List mappedBy(f(int element)) => IterableMixinWorkaround.mappedByList(this, f);

  Iterable<int> where(bool f(int element)) =>
      IterableMixinWorkaround.where(this, f);

  bool every(bool f(int element)) => IterableMixinWorkaround.every(this, f);

  bool any(bool f(int element)) => IterableMixinWorkaround.any(this, f);

  List<int> toList() => new List<int>.from(this);
  Set<int> toSet() => new Set<int>.from(this);

  bool get isEmpty => this.length == 0;

  List<int> take(int n) => IterableMixinWorkaround.takeList(this, n);

  Iterable<int> takeWhile(bool test(int value)) {
    return IterableMixinWorkaround.takeWhile(this, test);
  }

  List<int> skip(int n) => IterableMixinWorkaround.skipList(this, n);

  Iterable<int> skipWhile(bool test(int value)) {
    return IterableMixinWorkaround.skipWhile(this, test);
  }

  int firstMatching(bool test(int value), { int orElse() }) {
    return IterableMixinWorkaround.firstMatching(this, test, orElse);
  }

  int lastMatching(bool test(int value), {int orElse()}) {
    return IterableMixinWorkaround.lastMatchingInList(this, test, orElse);
  }

  int singleMatching(bool test(int value)) {
    return IterableMixinWorkaround.singleMatching(this, test);
  }

  int elementAt(int index) {
    return this[index];
  }

  // From Collection<int>:

  void add(int value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addLast(int value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addAll(Iterable<int> iterable) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  // From List<int>:
  void set length(int value) {
    throw new UnsupportedError("Cannot resize immutable List.");
  }

  void clear() {
    throw new UnsupportedError("Cannot clear immutable List.");
  }

  List<int> get reversed =>
      new ReversedListView<int>(this, 0, null);

  void sort([int compare(int a, int b)]) {
    throw new UnsupportedError("Cannot sort immutable List.");
  }

  int indexOf(int element, [int start = 0]) =>
      Lists.indexOf(this, element, start, this.length);

  int lastIndexOf(int element, [int start]) {
    if (start == null) start = length - 1;
    return Lists.lastIndexOf(this, element, start);
  }

  int get first {
    if (this.length > 0) return this[0];
    throw new StateError("No elements");
  }

  int get last {
    if (this.length > 0) return this[this.length - 1];
    throw new StateError("No elements");
  }

  int get single {
    if (length == 1) return this[0];
    if (length == 0) throw new StateError("No elements");
    throw new StateError("More than one element");
  }

  int min([int compare(int a, int b)]) =>
      IterableMixinWorkaround.min(this, compare);

  int max([int compare(int a, int b)]) =>
      IterableMixinWorkaround.max(this, compare);

  int removeAt(int pos) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  int removeLast() {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void remove(Object object) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void removeAll(Iterable elements) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void retainAll(Iterable elements) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void removeMatching(bool test(int element)) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void retainMatching(bool test(int element)) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void setRange(int start, int rangeLength, List<int> from, [int startFrom]) {
    throw new UnsupportedError("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int rangeLength) {
    throw new UnsupportedError("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int rangeLength, [int initialValue]) {
    throw new UnsupportedError("Cannot insertRange on immutable List.");
  }

  List<int> getRange(int start, int rangeLength) =>
      Lists.getRange(this, start, rangeLength, <int>[]);

  // -- end List<int> mixins.

  @DomName('Uint8ClampedArray.setElements')
  @DocsEditable
  void setElements(Object array, [int offset]) native "Uint8ClampedArray_setElements_Callback";

  Uint8ClampedArray subarray(int start, [int end]) {
    if (?end) {
      return _subarray_1(start, end);
    }
    return _subarray_2(start);
  }

  @DomName('Uint8ClampedArray._subarray_1')
  @DocsEditable
  Uint8ClampedArray _subarray_1(start, end) native "Uint8ClampedArray__subarray_1_Callback";

  @DomName('Uint8ClampedArray._subarray_2')
  @DocsEditable
  Uint8ClampedArray _subarray_2(start) native "Uint8ClampedArray__subarray_2_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('HTMLUnknownElement')
class UnknownElement extends _Element_Merged {
  UnknownElement.internal() : super.internal();

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('URL')
class Url extends NativeFieldWrapperClass1 {
  Url.internal();

  static String createObjectUrl(blob_OR_source_OR_stream) {
    if ((blob_OR_source_OR_stream is MediaSource || blob_OR_source_OR_stream == null)) {
      return _createObjectURL_1(blob_OR_source_OR_stream);
    }
    if ((blob_OR_source_OR_stream is MediaStream || blob_OR_source_OR_stream == null)) {
      return _createObjectURL_2(blob_OR_source_OR_stream);
    }
    if ((blob_OR_source_OR_stream is Blob || blob_OR_source_OR_stream == null)) {
      return _createObjectURL_3(blob_OR_source_OR_stream);
    }
    throw new ArgumentError("Incorrect number or type of arguments");
  }

  @DomName('DOMURL._createObjectURL_1')
  @DocsEditable
  static String _createObjectURL_1(blob_OR_source_OR_stream) native "DOMURL__createObjectURL_1_Callback";

  @DomName('DOMURL._createObjectURL_2')
  @DocsEditable
  static String _createObjectURL_2(blob_OR_source_OR_stream) native "DOMURL__createObjectURL_2_Callback";

  @DomName('DOMURL._createObjectURL_3')
  @DocsEditable
  static String _createObjectURL_3(blob_OR_source_OR_stream) native "DOMURL__createObjectURL_3_Callback";

  @DomName('DOMURL.revokeObjectURL')
  @DocsEditable
  static void revokeObjectUrl(String url) native "DOMURL_revokeObjectURL_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('ValidityState')
class ValidityState extends NativeFieldWrapperClass1 {
  ValidityState.internal();

  @DomName('ValidityState.badInput')
  @DocsEditable
  bool get badInput native "ValidityState_badInput_Getter";

  @DomName('ValidityState.customError')
  @DocsEditable
  bool get customError native "ValidityState_customError_Getter";

  @DomName('ValidityState.patternMismatch')
  @DocsEditable
  bool get patternMismatch native "ValidityState_patternMismatch_Getter";

  @DomName('ValidityState.rangeOverflow')
  @DocsEditable
  bool get rangeOverflow native "ValidityState_rangeOverflow_Getter";

  @DomName('ValidityState.rangeUnderflow')
  @DocsEditable
  bool get rangeUnderflow native "ValidityState_rangeUnderflow_Getter";

  @DomName('ValidityState.stepMismatch')
  @DocsEditable
  bool get stepMismatch native "ValidityState_stepMismatch_Getter";

  @DomName('ValidityState.tooLong')
  @DocsEditable
  bool get tooLong native "ValidityState_tooLong_Getter";

  @DomName('ValidityState.typeMismatch')
  @DocsEditable
  bool get typeMismatch native "ValidityState_typeMismatch_Getter";

  @DomName('ValidityState.valid')
  @DocsEditable
  bool get valid native "ValidityState_valid_Getter";

  @DomName('ValidityState.valueMissing')
  @DocsEditable
  bool get valueMissing native "ValidityState_valueMissing_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('HTMLVideoElement')
class VideoElement extends MediaElement {
  VideoElement.internal() : super.internal();

  @DocsEditable
  factory VideoElement() => document.$dom_createElement("video");

  @DomName('HTMLVideoElement.height')
  @DocsEditable
  int get height native "HTMLVideoElement_height_Getter";

  @DomName('HTMLVideoElement.height')
  @DocsEditable
  void set height(int value) native "HTMLVideoElement_height_Setter";

  @DomName('HTMLVideoElement.poster')
  @DocsEditable
  String get poster native "HTMLVideoElement_poster_Getter";

  @DomName('HTMLVideoElement.poster')
  @DocsEditable
  void set poster(String value) native "HTMLVideoElement_poster_Setter";

  @DomName('HTMLVideoElement.videoHeight')
  @DocsEditable
  int get videoHeight native "HTMLVideoElement_videoHeight_Getter";

  @DomName('HTMLVideoElement.videoWidth')
  @DocsEditable
  int get videoWidth native "HTMLVideoElement_videoWidth_Getter";

  @DomName('HTMLVideoElement.webkitDecodedFrameCount')
  @DocsEditable
  int get webkitDecodedFrameCount native "HTMLVideoElement_webkitDecodedFrameCount_Getter";

  @DomName('HTMLVideoElement.webkitDisplayingFullscreen')
  @DocsEditable
  bool get webkitDisplayingFullscreen native "HTMLVideoElement_webkitDisplayingFullscreen_Getter";

  @DomName('HTMLVideoElement.webkitDroppedFrameCount')
  @DocsEditable
  int get webkitDroppedFrameCount native "HTMLVideoElement_webkitDroppedFrameCount_Getter";

  @DomName('HTMLVideoElement.webkitSupportsFullscreen')
  @DocsEditable
  bool get webkitSupportsFullscreen native "HTMLVideoElement_webkitSupportsFullscreen_Getter";

  @DomName('HTMLVideoElement.width')
  @DocsEditable
  int get width native "HTMLVideoElement_width_Getter";

  @DomName('HTMLVideoElement.width')
  @DocsEditable
  void set width(int value) native "HTMLVideoElement_width_Setter";

  @DomName('HTMLVideoElement.webkitEnterFullScreen')
  @DocsEditable
  void webkitEnterFullScreen() native "HTMLVideoElement_webkitEnterFullScreen_Callback";

  @DomName('HTMLVideoElement.webkitEnterFullscreen')
  @DocsEditable
  void webkitEnterFullscreen() native "HTMLVideoElement_webkitEnterFullscreen_Callback";

  @DomName('HTMLVideoElement.webkitExitFullScreen')
  @DocsEditable
  void webkitExitFullScreen() native "HTMLVideoElement_webkitExitFullScreen_Callback";

  @DomName('HTMLVideoElement.webkitExitFullscreen')
  @DocsEditable
  void webkitExitFullscreen() native "HTMLVideoElement_webkitExitFullscreen_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


typedef void VoidCallback();
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('WebGLActiveInfo')
class WebGLActiveInfo extends NativeFieldWrapperClass1 {
  WebGLActiveInfo.internal();

  @DomName('WebGLActiveInfo.name')
  @DocsEditable
  String get name native "WebGLActiveInfo_name_Getter";

  @DomName('WebGLActiveInfo.size')
  @DocsEditable
  int get size native "WebGLActiveInfo_size_Getter";

  @DomName('WebGLActiveInfo.type')
  @DocsEditable
  int get type native "WebGLActiveInfo_type_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('WebGLBuffer')
class WebGLBuffer extends NativeFieldWrapperClass1 {
  WebGLBuffer.internal();

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('WebGLCompressedTextureS3TC')
class WebGLCompressedTextureS3TC extends NativeFieldWrapperClass1 {
  WebGLCompressedTextureS3TC.internal();

  static const int COMPRESSED_RGBA_S3TC_DXT1_EXT = 0x83F1;

  static const int COMPRESSED_RGBA_S3TC_DXT3_EXT = 0x83F2;

  static const int COMPRESSED_RGBA_S3TC_DXT5_EXT = 0x83F3;

  static const int COMPRESSED_RGB_S3TC_DXT1_EXT = 0x83F0;

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('WebGLContextAttributes')
class WebGLContextAttributes extends NativeFieldWrapperClass1 {
  WebGLContextAttributes.internal();

  @DomName('WebGLContextAttributes.alpha')
  @DocsEditable
  bool get alpha native "WebGLContextAttributes_alpha_Getter";

  @DomName('WebGLContextAttributes.alpha')
  @DocsEditable
  void set alpha(bool value) native "WebGLContextAttributes_alpha_Setter";

  @DomName('WebGLContextAttributes.antialias')
  @DocsEditable
  bool get antialias native "WebGLContextAttributes_antialias_Getter";

  @DomName('WebGLContextAttributes.antialias')
  @DocsEditable
  void set antialias(bool value) native "WebGLContextAttributes_antialias_Setter";

  @DomName('WebGLContextAttributes.depth')
  @DocsEditable
  bool get depth native "WebGLContextAttributes_depth_Getter";

  @DomName('WebGLContextAttributes.depth')
  @DocsEditable
  void set depth(bool value) native "WebGLContextAttributes_depth_Setter";

  @DomName('WebGLContextAttributes.premultipliedAlpha')
  @DocsEditable
  bool get premultipliedAlpha native "WebGLContextAttributes_premultipliedAlpha_Getter";

  @DomName('WebGLContextAttributes.premultipliedAlpha')
  @DocsEditable
  void set premultipliedAlpha(bool value) native "WebGLContextAttributes_premultipliedAlpha_Setter";

  @DomName('WebGLContextAttributes.preserveDrawingBuffer')
  @DocsEditable
  bool get preserveDrawingBuffer native "WebGLContextAttributes_preserveDrawingBuffer_Getter";

  @DomName('WebGLContextAttributes.preserveDrawingBuffer')
  @DocsEditable
  void set preserveDrawingBuffer(bool value) native "WebGLContextAttributes_preserveDrawingBuffer_Setter";

  @DomName('WebGLContextAttributes.stencil')
  @DocsEditable
  bool get stencil native "WebGLContextAttributes_stencil_Getter";

  @DomName('WebGLContextAttributes.stencil')
  @DocsEditable
  void set stencil(bool value) native "WebGLContextAttributes_stencil_Setter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('WebGLContextEvent')
class WebGLContextEvent extends Event {
  WebGLContextEvent.internal() : super.internal();

  @DomName('WebGLContextEvent.statusMessage')
  @DocsEditable
  String get statusMessage native "WebGLContextEvent_statusMessage_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('WebGLDebugRendererInfo')
class WebGLDebugRendererInfo extends NativeFieldWrapperClass1 {
  WebGLDebugRendererInfo.internal();

  static const int UNMASKED_RENDERER_WEBGL = 0x9246;

  static const int UNMASKED_VENDOR_WEBGL = 0x9245;

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('WebGLDebugShaders')
class WebGLDebugShaders extends NativeFieldWrapperClass1 {
  WebGLDebugShaders.internal();

  @DomName('WebGLDebugShaders.getTranslatedShaderSource')
  @DocsEditable
  String getTranslatedShaderSource(WebGLShader shader) native "WebGLDebugShaders_getTranslatedShaderSource_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('WebGLDepthTexture')
class WebGLDepthTexture extends NativeFieldWrapperClass1 {
  WebGLDepthTexture.internal();

  static const int UNSIGNED_INT_24_8_WEBGL = 0x84FA;

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('WebGLFramebuffer')
class WebGLFramebuffer extends NativeFieldWrapperClass1 {
  WebGLFramebuffer.internal();

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('WebGLLoseContext')
class WebGLLoseContext extends NativeFieldWrapperClass1 {
  WebGLLoseContext.internal();

  @DomName('WebGLLoseContext.loseContext')
  @DocsEditable
  void loseContext() native "WebGLLoseContext_loseContext_Callback";

  @DomName('WebGLLoseContext.restoreContext')
  @DocsEditable
  void restoreContext() native "WebGLLoseContext_restoreContext_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('WebGLProgram')
class WebGLProgram extends NativeFieldWrapperClass1 {
  WebGLProgram.internal();

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('WebGLRenderbuffer')
class WebGLRenderbuffer extends NativeFieldWrapperClass1 {
  WebGLRenderbuffer.internal();

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('WebGLRenderingContext')
class WebGLRenderingContext extends CanvasRenderingContext {
  WebGLRenderingContext.internal() : super.internal();

  static const int ACTIVE_ATTRIBUTES = 0x8B89;

  static const int ACTIVE_TEXTURE = 0x84E0;

  static const int ACTIVE_UNIFORMS = 0x8B86;

  static const int ALIASED_LINE_WIDTH_RANGE = 0x846E;

  static const int ALIASED_POINT_SIZE_RANGE = 0x846D;

  static const int ALPHA = 0x1906;

  static const int ALPHA_BITS = 0x0D55;

  static const int ALWAYS = 0x0207;

  static const int ARRAY_BUFFER = 0x8892;

  static const int ARRAY_BUFFER_BINDING = 0x8894;

  static const int ATTACHED_SHADERS = 0x8B85;

  static const int BACK = 0x0405;

  static const int BLEND = 0x0BE2;

  static const int BLEND_COLOR = 0x8005;

  static const int BLEND_DST_ALPHA = 0x80CA;

  static const int BLEND_DST_RGB = 0x80C8;

  static const int BLEND_EQUATION = 0x8009;

  static const int BLEND_EQUATION_ALPHA = 0x883D;

  static const int BLEND_EQUATION_RGB = 0x8009;

  static const int BLEND_SRC_ALPHA = 0x80CB;

  static const int BLEND_SRC_RGB = 0x80C9;

  static const int BLUE_BITS = 0x0D54;

  static const int BOOL = 0x8B56;

  static const int BOOL_VEC2 = 0x8B57;

  static const int BOOL_VEC3 = 0x8B58;

  static const int BOOL_VEC4 = 0x8B59;

  static const int BROWSER_DEFAULT_WEBGL = 0x9244;

  static const int BUFFER_SIZE = 0x8764;

  static const int BUFFER_USAGE = 0x8765;

  static const int BYTE = 0x1400;

  static const int CCW = 0x0901;

  static const int CLAMP_TO_EDGE = 0x812F;

  static const int COLOR_ATTACHMENT0 = 0x8CE0;

  static const int COLOR_BUFFER_BIT = 0x00004000;

  static const int COLOR_CLEAR_VALUE = 0x0C22;

  static const int COLOR_WRITEMASK = 0x0C23;

  static const int COMPILE_STATUS = 0x8B81;

  static const int COMPRESSED_TEXTURE_FORMATS = 0x86A3;

  static const int CONSTANT_ALPHA = 0x8003;

  static const int CONSTANT_COLOR = 0x8001;

  static const int CONTEXT_LOST_WEBGL = 0x9242;

  static const int CULL_FACE = 0x0B44;

  static const int CULL_FACE_MODE = 0x0B45;

  static const int CURRENT_PROGRAM = 0x8B8D;

  static const int CURRENT_VERTEX_ATTRIB = 0x8626;

  static const int CW = 0x0900;

  static const int DECR = 0x1E03;

  static const int DECR_WRAP = 0x8508;

  static const int DELETE_STATUS = 0x8B80;

  static const int DEPTH_ATTACHMENT = 0x8D00;

  static const int DEPTH_BITS = 0x0D56;

  static const int DEPTH_BUFFER_BIT = 0x00000100;

  static const int DEPTH_CLEAR_VALUE = 0x0B73;

  static const int DEPTH_COMPONENT = 0x1902;

  static const int DEPTH_COMPONENT16 = 0x81A5;

  static const int DEPTH_FUNC = 0x0B74;

  static const int DEPTH_RANGE = 0x0B70;

  static const int DEPTH_STENCIL = 0x84F9;

  static const int DEPTH_STENCIL_ATTACHMENT = 0x821A;

  static const int DEPTH_TEST = 0x0B71;

  static const int DEPTH_WRITEMASK = 0x0B72;

  static const int DITHER = 0x0BD0;

  static const int DONT_CARE = 0x1100;

  static const int DST_ALPHA = 0x0304;

  static const int DST_COLOR = 0x0306;

  static const int DYNAMIC_DRAW = 0x88E8;

  static const int ELEMENT_ARRAY_BUFFER = 0x8893;

  static const int ELEMENT_ARRAY_BUFFER_BINDING = 0x8895;

  static const int EQUAL = 0x0202;

  static const int FASTEST = 0x1101;

  static const int FLOAT = 0x1406;

  static const int FLOAT_MAT2 = 0x8B5A;

  static const int FLOAT_MAT3 = 0x8B5B;

  static const int FLOAT_MAT4 = 0x8B5C;

  static const int FLOAT_VEC2 = 0x8B50;

  static const int FLOAT_VEC3 = 0x8B51;

  static const int FLOAT_VEC4 = 0x8B52;

  static const int FRAGMENT_SHADER = 0x8B30;

  static const int FRAMEBUFFER = 0x8D40;

  static const int FRAMEBUFFER_ATTACHMENT_OBJECT_NAME = 0x8CD1;

  static const int FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE = 0x8CD0;

  static const int FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE = 0x8CD3;

  static const int FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL = 0x8CD2;

  static const int FRAMEBUFFER_BINDING = 0x8CA6;

  static const int FRAMEBUFFER_COMPLETE = 0x8CD5;

  static const int FRAMEBUFFER_INCOMPLETE_ATTACHMENT = 0x8CD6;

  static const int FRAMEBUFFER_INCOMPLETE_DIMENSIONS = 0x8CD9;

  static const int FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT = 0x8CD7;

  static const int FRAMEBUFFER_UNSUPPORTED = 0x8CDD;

  static const int FRONT = 0x0404;

  static const int FRONT_AND_BACK = 0x0408;

  static const int FRONT_FACE = 0x0B46;

  static const int FUNC_ADD = 0x8006;

  static const int FUNC_REVERSE_SUBTRACT = 0x800B;

  static const int FUNC_SUBTRACT = 0x800A;

  static const int GENERATE_MIPMAP_HINT = 0x8192;

  static const int GEQUAL = 0x0206;

  static const int GREATER = 0x0204;

  static const int GREEN_BITS = 0x0D53;

  static const int HIGH_FLOAT = 0x8DF2;

  static const int HIGH_INT = 0x8DF5;

  static const int INCR = 0x1E02;

  static const int INCR_WRAP = 0x8507;

  static const int INT = 0x1404;

  static const int INT_VEC2 = 0x8B53;

  static const int INT_VEC3 = 0x8B54;

  static const int INT_VEC4 = 0x8B55;

  static const int INVALID_ENUM = 0x0500;

  static const int INVALID_FRAMEBUFFER_OPERATION = 0x0506;

  static const int INVALID_OPERATION = 0x0502;

  static const int INVALID_VALUE = 0x0501;

  static const int INVERT = 0x150A;

  static const int KEEP = 0x1E00;

  static const int LEQUAL = 0x0203;

  static const int LESS = 0x0201;

  static const int LINEAR = 0x2601;

  static const int LINEAR_MIPMAP_LINEAR = 0x2703;

  static const int LINEAR_MIPMAP_NEAREST = 0x2701;

  static const int LINES = 0x0001;

  static const int LINE_LOOP = 0x0002;

  static const int LINE_STRIP = 0x0003;

  static const int LINE_WIDTH = 0x0B21;

  static const int LINK_STATUS = 0x8B82;

  static const int LOW_FLOAT = 0x8DF0;

  static const int LOW_INT = 0x8DF3;

  static const int LUMINANCE = 0x1909;

  static const int LUMINANCE_ALPHA = 0x190A;

  static const int MAX_COMBINED_TEXTURE_IMAGE_UNITS = 0x8B4D;

  static const int MAX_CUBE_MAP_TEXTURE_SIZE = 0x851C;

  static const int MAX_FRAGMENT_UNIFORM_VECTORS = 0x8DFD;

  static const int MAX_RENDERBUFFER_SIZE = 0x84E8;

  static const int MAX_TEXTURE_IMAGE_UNITS = 0x8872;

  static const int MAX_TEXTURE_SIZE = 0x0D33;

  static const int MAX_VARYING_VECTORS = 0x8DFC;

  static const int MAX_VERTEX_ATTRIBS = 0x8869;

  static const int MAX_VERTEX_TEXTURE_IMAGE_UNITS = 0x8B4C;

  static const int MAX_VERTEX_UNIFORM_VECTORS = 0x8DFB;

  static const int MAX_VIEWPORT_DIMS = 0x0D3A;

  static const int MEDIUM_FLOAT = 0x8DF1;

  static const int MEDIUM_INT = 0x8DF4;

  static const int MIRRORED_REPEAT = 0x8370;

  static const int NEAREST = 0x2600;

  static const int NEAREST_MIPMAP_LINEAR = 0x2702;

  static const int NEAREST_MIPMAP_NEAREST = 0x2700;

  static const int NEVER = 0x0200;

  static const int NICEST = 0x1102;

  static const int NONE = 0;

  static const int NOTEQUAL = 0x0205;

  static const int NO_ERROR = 0;

  static const int ONE = 1;

  static const int ONE_MINUS_CONSTANT_ALPHA = 0x8004;

  static const int ONE_MINUS_CONSTANT_COLOR = 0x8002;

  static const int ONE_MINUS_DST_ALPHA = 0x0305;

  static const int ONE_MINUS_DST_COLOR = 0x0307;

  static const int ONE_MINUS_SRC_ALPHA = 0x0303;

  static const int ONE_MINUS_SRC_COLOR = 0x0301;

  static const int OUT_OF_MEMORY = 0x0505;

  static const int PACK_ALIGNMENT = 0x0D05;

  static const int POINTS = 0x0000;

  static const int POLYGON_OFFSET_FACTOR = 0x8038;

  static const int POLYGON_OFFSET_FILL = 0x8037;

  static const int POLYGON_OFFSET_UNITS = 0x2A00;

  static const int RED_BITS = 0x0D52;

  static const int RENDERBUFFER = 0x8D41;

  static const int RENDERBUFFER_ALPHA_SIZE = 0x8D53;

  static const int RENDERBUFFER_BINDING = 0x8CA7;

  static const int RENDERBUFFER_BLUE_SIZE = 0x8D52;

  static const int RENDERBUFFER_DEPTH_SIZE = 0x8D54;

  static const int RENDERBUFFER_GREEN_SIZE = 0x8D51;

  static const int RENDERBUFFER_HEIGHT = 0x8D43;

  static const int RENDERBUFFER_INTERNAL_FORMAT = 0x8D44;

  static const int RENDERBUFFER_RED_SIZE = 0x8D50;

  static const int RENDERBUFFER_STENCIL_SIZE = 0x8D55;

  static const int RENDERBUFFER_WIDTH = 0x8D42;

  static const int RENDERER = 0x1F01;

  static const int REPEAT = 0x2901;

  static const int REPLACE = 0x1E01;

  static const int RGB = 0x1907;

  static const int RGB565 = 0x8D62;

  static const int RGB5_A1 = 0x8057;

  static const int RGBA = 0x1908;

  static const int RGBA4 = 0x8056;

  static const int SAMPLER_2D = 0x8B5E;

  static const int SAMPLER_CUBE = 0x8B60;

  static const int SAMPLES = 0x80A9;

  static const int SAMPLE_ALPHA_TO_COVERAGE = 0x809E;

  static const int SAMPLE_BUFFERS = 0x80A8;

  static const int SAMPLE_COVERAGE = 0x80A0;

  static const int SAMPLE_COVERAGE_INVERT = 0x80AB;

  static const int SAMPLE_COVERAGE_VALUE = 0x80AA;

  static const int SCISSOR_BOX = 0x0C10;

  static const int SCISSOR_TEST = 0x0C11;

  static const int SHADER_TYPE = 0x8B4F;

  static const int SHADING_LANGUAGE_VERSION = 0x8B8C;

  static const int SHORT = 0x1402;

  static const int SRC_ALPHA = 0x0302;

  static const int SRC_ALPHA_SATURATE = 0x0308;

  static const int SRC_COLOR = 0x0300;

  static const int STATIC_DRAW = 0x88E4;

  static const int STENCIL_ATTACHMENT = 0x8D20;

  static const int STENCIL_BACK_FAIL = 0x8801;

  static const int STENCIL_BACK_FUNC = 0x8800;

  static const int STENCIL_BACK_PASS_DEPTH_FAIL = 0x8802;

  static const int STENCIL_BACK_PASS_DEPTH_PASS = 0x8803;

  static const int STENCIL_BACK_REF = 0x8CA3;

  static const int STENCIL_BACK_VALUE_MASK = 0x8CA4;

  static const int STENCIL_BACK_WRITEMASK = 0x8CA5;

  static const int STENCIL_BITS = 0x0D57;

  static const int STENCIL_BUFFER_BIT = 0x00000400;

  static const int STENCIL_CLEAR_VALUE = 0x0B91;

  static const int STENCIL_FAIL = 0x0B94;

  static const int STENCIL_FUNC = 0x0B92;

  static const int STENCIL_INDEX = 0x1901;

  static const int STENCIL_INDEX8 = 0x8D48;

  static const int STENCIL_PASS_DEPTH_FAIL = 0x0B95;

  static const int STENCIL_PASS_DEPTH_PASS = 0x0B96;

  static const int STENCIL_REF = 0x0B97;

  static const int STENCIL_TEST = 0x0B90;

  static const int STENCIL_VALUE_MASK = 0x0B93;

  static const int STENCIL_WRITEMASK = 0x0B98;

  static const int STREAM_DRAW = 0x88E0;

  static const int SUBPIXEL_BITS = 0x0D50;

  static const int TEXTURE = 0x1702;

  static const int TEXTURE0 = 0x84C0;

  static const int TEXTURE1 = 0x84C1;

  static const int TEXTURE10 = 0x84CA;

  static const int TEXTURE11 = 0x84CB;

  static const int TEXTURE12 = 0x84CC;

  static const int TEXTURE13 = 0x84CD;

  static const int TEXTURE14 = 0x84CE;

  static const int TEXTURE15 = 0x84CF;

  static const int TEXTURE16 = 0x84D0;

  static const int TEXTURE17 = 0x84D1;

  static const int TEXTURE18 = 0x84D2;

  static const int TEXTURE19 = 0x84D3;

  static const int TEXTURE2 = 0x84C2;

  static const int TEXTURE20 = 0x84D4;

  static const int TEXTURE21 = 0x84D5;

  static const int TEXTURE22 = 0x84D6;

  static const int TEXTURE23 = 0x84D7;

  static const int TEXTURE24 = 0x84D8;

  static const int TEXTURE25 = 0x84D9;

  static const int TEXTURE26 = 0x84DA;

  static const int TEXTURE27 = 0x84DB;

  static const int TEXTURE28 = 0x84DC;

  static const int TEXTURE29 = 0x84DD;

  static const int TEXTURE3 = 0x84C3;

  static const int TEXTURE30 = 0x84DE;

  static const int TEXTURE31 = 0x84DF;

  static const int TEXTURE4 = 0x84C4;

  static const int TEXTURE5 = 0x84C5;

  static const int TEXTURE6 = 0x84C6;

  static const int TEXTURE7 = 0x84C7;

  static const int TEXTURE8 = 0x84C8;

  static const int TEXTURE9 = 0x84C9;

  static const int TEXTURE_2D = 0x0DE1;

  static const int TEXTURE_BINDING_2D = 0x8069;

  static const int TEXTURE_BINDING_CUBE_MAP = 0x8514;

  static const int TEXTURE_CUBE_MAP = 0x8513;

  static const int TEXTURE_CUBE_MAP_NEGATIVE_X = 0x8516;

  static const int TEXTURE_CUBE_MAP_NEGATIVE_Y = 0x8518;

  static const int TEXTURE_CUBE_MAP_NEGATIVE_Z = 0x851A;

  static const int TEXTURE_CUBE_MAP_POSITIVE_X = 0x8515;

  static const int TEXTURE_CUBE_MAP_POSITIVE_Y = 0x8517;

  static const int TEXTURE_CUBE_MAP_POSITIVE_Z = 0x8519;

  static const int TEXTURE_MAG_FILTER = 0x2800;

  static const int TEXTURE_MIN_FILTER = 0x2801;

  static const int TEXTURE_WRAP_S = 0x2802;

  static const int TEXTURE_WRAP_T = 0x2803;

  static const int TRIANGLES = 0x0004;

  static const int TRIANGLE_FAN = 0x0006;

  static const int TRIANGLE_STRIP = 0x0005;

  static const int UNPACK_ALIGNMENT = 0x0CF5;

  static const int UNPACK_COLORSPACE_CONVERSION_WEBGL = 0x9243;

  static const int UNPACK_FLIP_Y_WEBGL = 0x9240;

  static const int UNPACK_PREMULTIPLY_ALPHA_WEBGL = 0x9241;

  static const int UNSIGNED_BYTE = 0x1401;

  static const int UNSIGNED_INT = 0x1405;

  static const int UNSIGNED_SHORT = 0x1403;

  static const int UNSIGNED_SHORT_4_4_4_4 = 0x8033;

  static const int UNSIGNED_SHORT_5_5_5_1 = 0x8034;

  static const int UNSIGNED_SHORT_5_6_5 = 0x8363;

  static const int VALIDATE_STATUS = 0x8B83;

  static const int VENDOR = 0x1F00;

  static const int VERSION = 0x1F02;

  static const int VERTEX_ATTRIB_ARRAY_BUFFER_BINDING = 0x889F;

  static const int VERTEX_ATTRIB_ARRAY_ENABLED = 0x8622;

  static const int VERTEX_ATTRIB_ARRAY_NORMALIZED = 0x886A;

  static const int VERTEX_ATTRIB_ARRAY_POINTER = 0x8645;

  static const int VERTEX_ATTRIB_ARRAY_SIZE = 0x8623;

  static const int VERTEX_ATTRIB_ARRAY_STRIDE = 0x8624;

  static const int VERTEX_ATTRIB_ARRAY_TYPE = 0x8625;

  static const int VERTEX_SHADER = 0x8B31;

  static const int VIEWPORT = 0x0BA2;

  static const int ZERO = 0;

  @DomName('WebGLRenderingContext.drawingBufferHeight')
  @DocsEditable
  int get drawingBufferHeight native "WebGLRenderingContext_drawingBufferHeight_Getter";

  @DomName('WebGLRenderingContext.drawingBufferWidth')
  @DocsEditable
  int get drawingBufferWidth native "WebGLRenderingContext_drawingBufferWidth_Getter";

  @DomName('WebGLRenderingContext.activeTexture')
  @DocsEditable
  void activeTexture(int texture) native "WebGLRenderingContext_activeTexture_Callback";

  @DomName('WebGLRenderingContext.attachShader')
  @DocsEditable
  void attachShader(WebGLProgram program, WebGLShader shader) native "WebGLRenderingContext_attachShader_Callback";

  @DomName('WebGLRenderingContext.bindAttribLocation')
  @DocsEditable
  void bindAttribLocation(WebGLProgram program, int index, String name) native "WebGLRenderingContext_bindAttribLocation_Callback";

  @DomName('WebGLRenderingContext.bindBuffer')
  @DocsEditable
  void bindBuffer(int target, WebGLBuffer buffer) native "WebGLRenderingContext_bindBuffer_Callback";

  @DomName('WebGLRenderingContext.bindFramebuffer')
  @DocsEditable
  void bindFramebuffer(int target, WebGLFramebuffer framebuffer) native "WebGLRenderingContext_bindFramebuffer_Callback";

  @DomName('WebGLRenderingContext.bindRenderbuffer')
  @DocsEditable
  void bindRenderbuffer(int target, WebGLRenderbuffer renderbuffer) native "WebGLRenderingContext_bindRenderbuffer_Callback";

  @DomName('WebGLRenderingContext.bindTexture')
  @DocsEditable
  void bindTexture(int target, WebGLTexture texture) native "WebGLRenderingContext_bindTexture_Callback";

  @DomName('WebGLRenderingContext.blendColor')
  @DocsEditable
  void blendColor(num red, num green, num blue, num alpha) native "WebGLRenderingContext_blendColor_Callback";

  @DomName('WebGLRenderingContext.blendEquation')
  @DocsEditable
  void blendEquation(int mode) native "WebGLRenderingContext_blendEquation_Callback";

  @DomName('WebGLRenderingContext.blendEquationSeparate')
  @DocsEditable
  void blendEquationSeparate(int modeRGB, int modeAlpha) native "WebGLRenderingContext_blendEquationSeparate_Callback";

  @DomName('WebGLRenderingContext.blendFunc')
  @DocsEditable
  void blendFunc(int sfactor, int dfactor) native "WebGLRenderingContext_blendFunc_Callback";

  @DomName('WebGLRenderingContext.blendFuncSeparate')
  @DocsEditable
  void blendFuncSeparate(int srcRGB, int dstRGB, int srcAlpha, int dstAlpha) native "WebGLRenderingContext_blendFuncSeparate_Callback";

  void bufferData(int target, data_OR_size, int usage) {
    if ((target is int || target == null) && (data_OR_size is ArrayBuffer || data_OR_size == null) && (usage is int || usage == null)) {
      _bufferData_1(target, data_OR_size, usage);
      return;
    }
    if ((target is int || target == null) && (data_OR_size is ArrayBufferView || data_OR_size == null) && (usage is int || usage == null)) {
      _bufferData_2(target, data_OR_size, usage);
      return;
    }
    if ((target is int || target == null) && (data_OR_size is int || data_OR_size == null) && (usage is int || usage == null)) {
      _bufferData_3(target, data_OR_size, usage);
      return;
    }
    throw new ArgumentError("Incorrect number or type of arguments");
  }

  @DomName('WebGLRenderingContext._bufferData_1')
  @DocsEditable
  void _bufferData_1(target, data_OR_size, usage) native "WebGLRenderingContext__bufferData_1_Callback";

  @DomName('WebGLRenderingContext._bufferData_2')
  @DocsEditable
  void _bufferData_2(target, data_OR_size, usage) native "WebGLRenderingContext__bufferData_2_Callback";

  @DomName('WebGLRenderingContext._bufferData_3')
  @DocsEditable
  void _bufferData_3(target, data_OR_size, usage) native "WebGLRenderingContext__bufferData_3_Callback";

  void bufferSubData(int target, int offset, data) {
    if ((target is int || target == null) && (offset is int || offset == null) && (data is ArrayBuffer || data == null)) {
      _bufferSubData_1(target, offset, data);
      return;
    }
    if ((target is int || target == null) && (offset is int || offset == null) && (data is ArrayBufferView || data == null)) {
      _bufferSubData_2(target, offset, data);
      return;
    }
    throw new ArgumentError("Incorrect number or type of arguments");
  }

  @DomName('WebGLRenderingContext._bufferSubData_1')
  @DocsEditable
  void _bufferSubData_1(target, offset, data) native "WebGLRenderingContext__bufferSubData_1_Callback";

  @DomName('WebGLRenderingContext._bufferSubData_2')
  @DocsEditable
  void _bufferSubData_2(target, offset, data) native "WebGLRenderingContext__bufferSubData_2_Callback";

  @DomName('WebGLRenderingContext.checkFramebufferStatus')
  @DocsEditable
  int checkFramebufferStatus(int target) native "WebGLRenderingContext_checkFramebufferStatus_Callback";

  @DomName('WebGLRenderingContext.clear')
  @DocsEditable
  void clear(int mask) native "WebGLRenderingContext_clear_Callback";

  @DomName('WebGLRenderingContext.clearColor')
  @DocsEditable
  void clearColor(num red, num green, num blue, num alpha) native "WebGLRenderingContext_clearColor_Callback";

  @DomName('WebGLRenderingContext.clearDepth')
  @DocsEditable
  void clearDepth(num depth) native "WebGLRenderingContext_clearDepth_Callback";

  @DomName('WebGLRenderingContext.clearStencil')
  @DocsEditable
  void clearStencil(int s) native "WebGLRenderingContext_clearStencil_Callback";

  @DomName('WebGLRenderingContext.colorMask')
  @DocsEditable
  void colorMask(bool red, bool green, bool blue, bool alpha) native "WebGLRenderingContext_colorMask_Callback";

  @DomName('WebGLRenderingContext.compileShader')
  @DocsEditable
  void compileShader(WebGLShader shader) native "WebGLRenderingContext_compileShader_Callback";

  @DomName('WebGLRenderingContext.compressedTexImage2D')
  @DocsEditable
  void compressedTexImage2D(int target, int level, int internalformat, int width, int height, int border, ArrayBufferView data) native "WebGLRenderingContext_compressedTexImage2D_Callback";

  @DomName('WebGLRenderingContext.compressedTexSubImage2D')
  @DocsEditable
  void compressedTexSubImage2D(int target, int level, int xoffset, int yoffset, int width, int height, int format, ArrayBufferView data) native "WebGLRenderingContext_compressedTexSubImage2D_Callback";

  @DomName('WebGLRenderingContext.copyTexImage2D')
  @DocsEditable
  void copyTexImage2D(int target, int level, int internalformat, int x, int y, int width, int height, int border) native "WebGLRenderingContext_copyTexImage2D_Callback";

  @DomName('WebGLRenderingContext.copyTexSubImage2D')
  @DocsEditable
  void copyTexSubImage2D(int target, int level, int xoffset, int yoffset, int x, int y, int width, int height) native "WebGLRenderingContext_copyTexSubImage2D_Callback";

  @DomName('WebGLRenderingContext.createBuffer')
  @DocsEditable
  WebGLBuffer createBuffer() native "WebGLRenderingContext_createBuffer_Callback";

  @DomName('WebGLRenderingContext.createFramebuffer')
  @DocsEditable
  WebGLFramebuffer createFramebuffer() native "WebGLRenderingContext_createFramebuffer_Callback";

  @DomName('WebGLRenderingContext.createProgram')
  @DocsEditable
  WebGLProgram createProgram() native "WebGLRenderingContext_createProgram_Callback";

  @DomName('WebGLRenderingContext.createRenderbuffer')
  @DocsEditable
  WebGLRenderbuffer createRenderbuffer() native "WebGLRenderingContext_createRenderbuffer_Callback";

  @DomName('WebGLRenderingContext.createShader')
  @DocsEditable
  WebGLShader createShader(int type) native "WebGLRenderingContext_createShader_Callback";

  @DomName('WebGLRenderingContext.createTexture')
  @DocsEditable
  WebGLTexture createTexture() native "WebGLRenderingContext_createTexture_Callback";

  @DomName('WebGLRenderingContext.cullFace')
  @DocsEditable
  void cullFace(int mode) native "WebGLRenderingContext_cullFace_Callback";

  @DomName('WebGLRenderingContext.deleteBuffer')
  @DocsEditable
  void deleteBuffer(WebGLBuffer buffer) native "WebGLRenderingContext_deleteBuffer_Callback";

  @DomName('WebGLRenderingContext.deleteFramebuffer')
  @DocsEditable
  void deleteFramebuffer(WebGLFramebuffer framebuffer) native "WebGLRenderingContext_deleteFramebuffer_Callback";

  @DomName('WebGLRenderingContext.deleteProgram')
  @DocsEditable
  void deleteProgram(WebGLProgram program) native "WebGLRenderingContext_deleteProgram_Callback";

  @DomName('WebGLRenderingContext.deleteRenderbuffer')
  @DocsEditable
  void deleteRenderbuffer(WebGLRenderbuffer renderbuffer) native "WebGLRenderingContext_deleteRenderbuffer_Callback";

  @DomName('WebGLRenderingContext.deleteShader')
  @DocsEditable
  void deleteShader(WebGLShader shader) native "WebGLRenderingContext_deleteShader_Callback";

  @DomName('WebGLRenderingContext.deleteTexture')
  @DocsEditable
  void deleteTexture(WebGLTexture texture) native "WebGLRenderingContext_deleteTexture_Callback";

  @DomName('WebGLRenderingContext.depthFunc')
  @DocsEditable
  void depthFunc(int func) native "WebGLRenderingContext_depthFunc_Callback";

  @DomName('WebGLRenderingContext.depthMask')
  @DocsEditable
  void depthMask(bool flag) native "WebGLRenderingContext_depthMask_Callback";

  @DomName('WebGLRenderingContext.depthRange')
  @DocsEditable
  void depthRange(num zNear, num zFar) native "WebGLRenderingContext_depthRange_Callback";

  @DomName('WebGLRenderingContext.detachShader')
  @DocsEditable
  void detachShader(WebGLProgram program, WebGLShader shader) native "WebGLRenderingContext_detachShader_Callback";

  @DomName('WebGLRenderingContext.disable')
  @DocsEditable
  void disable(int cap) native "WebGLRenderingContext_disable_Callback";

  @DomName('WebGLRenderingContext.disableVertexAttribArray')
  @DocsEditable
  void disableVertexAttribArray(int index) native "WebGLRenderingContext_disableVertexAttribArray_Callback";

  @DomName('WebGLRenderingContext.drawArrays')
  @DocsEditable
  void drawArrays(int mode, int first, int count) native "WebGLRenderingContext_drawArrays_Callback";

  @DomName('WebGLRenderingContext.drawElements')
  @DocsEditable
  void drawElements(int mode, int count, int type, int offset) native "WebGLRenderingContext_drawElements_Callback";

  @DomName('WebGLRenderingContext.enable')
  @DocsEditable
  void enable(int cap) native "WebGLRenderingContext_enable_Callback";

  @DomName('WebGLRenderingContext.enableVertexAttribArray')
  @DocsEditable
  void enableVertexAttribArray(int index) native "WebGLRenderingContext_enableVertexAttribArray_Callback";

  @DomName('WebGLRenderingContext.finish')
  @DocsEditable
  void finish() native "WebGLRenderingContext_finish_Callback";

  @DomName('WebGLRenderingContext.flush')
  @DocsEditable
  void flush() native "WebGLRenderingContext_flush_Callback";

  @DomName('WebGLRenderingContext.framebufferRenderbuffer')
  @DocsEditable
  void framebufferRenderbuffer(int target, int attachment, int renderbuffertarget, WebGLRenderbuffer renderbuffer) native "WebGLRenderingContext_framebufferRenderbuffer_Callback";

  @DomName('WebGLRenderingContext.framebufferTexture2D')
  @DocsEditable
  void framebufferTexture2D(int target, int attachment, int textarget, WebGLTexture texture, int level) native "WebGLRenderingContext_framebufferTexture2D_Callback";

  @DomName('WebGLRenderingContext.frontFace')
  @DocsEditable
  void frontFace(int mode) native "WebGLRenderingContext_frontFace_Callback";

  @DomName('WebGLRenderingContext.generateMipmap')
  @DocsEditable
  void generateMipmap(int target) native "WebGLRenderingContext_generateMipmap_Callback";

  @DomName('WebGLRenderingContext.getActiveAttrib')
  @DocsEditable
  WebGLActiveInfo getActiveAttrib(WebGLProgram program, int index) native "WebGLRenderingContext_getActiveAttrib_Callback";

  @DomName('WebGLRenderingContext.getActiveUniform')
  @DocsEditable
  WebGLActiveInfo getActiveUniform(WebGLProgram program, int index) native "WebGLRenderingContext_getActiveUniform_Callback";

  @DomName('WebGLRenderingContext.getAttachedShaders')
  @DocsEditable
  void getAttachedShaders(WebGLProgram program) native "WebGLRenderingContext_getAttachedShaders_Callback";

  @DomName('WebGLRenderingContext.getAttribLocation')
  @DocsEditable
  int getAttribLocation(WebGLProgram program, String name) native "WebGLRenderingContext_getAttribLocation_Callback";

  @DomName('WebGLRenderingContext.getBufferParameter')
  @DocsEditable
  Object getBufferParameter(int target, int pname) native "WebGLRenderingContext_getBufferParameter_Callback";

  @DomName('WebGLRenderingContext.getContextAttributes')
  @DocsEditable
  WebGLContextAttributes getContextAttributes() native "WebGLRenderingContext_getContextAttributes_Callback";

  @DomName('WebGLRenderingContext.getError')
  @DocsEditable
  int getError() native "WebGLRenderingContext_getError_Callback";

  @DomName('WebGLRenderingContext.getExtension')
  @DocsEditable
  Object getExtension(String name) native "WebGLRenderingContext_getExtension_Callback";

  @DomName('WebGLRenderingContext.getFramebufferAttachmentParameter')
  @DocsEditable
  Object getFramebufferAttachmentParameter(int target, int attachment, int pname) native "WebGLRenderingContext_getFramebufferAttachmentParameter_Callback";

  @DomName('WebGLRenderingContext.getParameter')
  @DocsEditable
  Object getParameter(int pname) native "WebGLRenderingContext_getParameter_Callback";

  @DomName('WebGLRenderingContext.getProgramInfoLog')
  @DocsEditable
  String getProgramInfoLog(WebGLProgram program) native "WebGLRenderingContext_getProgramInfoLog_Callback";

  @DomName('WebGLRenderingContext.getProgramParameter')
  @DocsEditable
  Object getProgramParameter(WebGLProgram program, int pname) native "WebGLRenderingContext_getProgramParameter_Callback";

  @DomName('WebGLRenderingContext.getRenderbufferParameter')
  @DocsEditable
  Object getRenderbufferParameter(int target, int pname) native "WebGLRenderingContext_getRenderbufferParameter_Callback";

  @DomName('WebGLRenderingContext.getShaderInfoLog')
  @DocsEditable
  String getShaderInfoLog(WebGLShader shader) native "WebGLRenderingContext_getShaderInfoLog_Callback";

  @DomName('WebGLRenderingContext.getShaderParameter')
  @DocsEditable
  Object getShaderParameter(WebGLShader shader, int pname) native "WebGLRenderingContext_getShaderParameter_Callback";

  @DomName('WebGLRenderingContext.getShaderPrecisionFormat')
  @DocsEditable
  WebGLShaderPrecisionFormat getShaderPrecisionFormat(int shadertype, int precisiontype) native "WebGLRenderingContext_getShaderPrecisionFormat_Callback";

  @DomName('WebGLRenderingContext.getShaderSource')
  @DocsEditable
  String getShaderSource(WebGLShader shader) native "WebGLRenderingContext_getShaderSource_Callback";

  @DomName('WebGLRenderingContext.getSupportedExtensions')
  @DocsEditable
  List<String> getSupportedExtensions() native "WebGLRenderingContext_getSupportedExtensions_Callback";

  @DomName('WebGLRenderingContext.getTexParameter')
  @DocsEditable
  Object getTexParameter(int target, int pname) native "WebGLRenderingContext_getTexParameter_Callback";

  @DomName('WebGLRenderingContext.getUniform')
  @DocsEditable
  Object getUniform(WebGLProgram program, WebGLUniformLocation location) native "WebGLRenderingContext_getUniform_Callback";

  @DomName('WebGLRenderingContext.getUniformLocation')
  @DocsEditable
  WebGLUniformLocation getUniformLocation(WebGLProgram program, String name) native "WebGLRenderingContext_getUniformLocation_Callback";

  @DomName('WebGLRenderingContext.getVertexAttrib')
  @DocsEditable
  Object getVertexAttrib(int index, int pname) native "WebGLRenderingContext_getVertexAttrib_Callback";

  @DomName('WebGLRenderingContext.getVertexAttribOffset')
  @DocsEditable
  int getVertexAttribOffset(int index, int pname) native "WebGLRenderingContext_getVertexAttribOffset_Callback";

  @DomName('WebGLRenderingContext.hint')
  @DocsEditable
  void hint(int target, int mode) native "WebGLRenderingContext_hint_Callback";

  @DomName('WebGLRenderingContext.isBuffer')
  @DocsEditable
  bool isBuffer(WebGLBuffer buffer) native "WebGLRenderingContext_isBuffer_Callback";

  @DomName('WebGLRenderingContext.isContextLost')
  @DocsEditable
  bool isContextLost() native "WebGLRenderingContext_isContextLost_Callback";

  @DomName('WebGLRenderingContext.isEnabled')
  @DocsEditable
  bool isEnabled(int cap) native "WebGLRenderingContext_isEnabled_Callback";

  @DomName('WebGLRenderingContext.isFramebuffer')
  @DocsEditable
  bool isFramebuffer(WebGLFramebuffer framebuffer) native "WebGLRenderingContext_isFramebuffer_Callback";

  @DomName('WebGLRenderingContext.isProgram')
  @DocsEditable
  bool isProgram(WebGLProgram program) native "WebGLRenderingContext_isProgram_Callback";

  @DomName('WebGLRenderingContext.isRenderbuffer')
  @DocsEditable
  bool isRenderbuffer(WebGLRenderbuffer renderbuffer) native "WebGLRenderingContext_isRenderbuffer_Callback";

  @DomName('WebGLRenderingContext.isShader')
  @DocsEditable
  bool isShader(WebGLShader shader) native "WebGLRenderingContext_isShader_Callback";

  @DomName('WebGLRenderingContext.isTexture')
  @DocsEditable
  bool isTexture(WebGLTexture texture) native "WebGLRenderingContext_isTexture_Callback";

  @DomName('WebGLRenderingContext.lineWidth')
  @DocsEditable
  void lineWidth(num width) native "WebGLRenderingContext_lineWidth_Callback";

  @DomName('WebGLRenderingContext.linkProgram')
  @DocsEditable
  void linkProgram(WebGLProgram program) native "WebGLRenderingContext_linkProgram_Callback";

  @DomName('WebGLRenderingContext.pixelStorei')
  @DocsEditable
  void pixelStorei(int pname, int param) native "WebGLRenderingContext_pixelStorei_Callback";

  @DomName('WebGLRenderingContext.polygonOffset')
  @DocsEditable
  void polygonOffset(num factor, num units) native "WebGLRenderingContext_polygonOffset_Callback";

  @DomName('WebGLRenderingContext.readPixels')
  @DocsEditable
  void readPixels(int x, int y, int width, int height, int format, int type, ArrayBufferView pixels) native "WebGLRenderingContext_readPixels_Callback";

  @DomName('WebGLRenderingContext.releaseShaderCompiler')
  @DocsEditable
  void releaseShaderCompiler() native "WebGLRenderingContext_releaseShaderCompiler_Callback";

  @DomName('WebGLRenderingContext.renderbufferStorage')
  @DocsEditable
  void renderbufferStorage(int target, int internalformat, int width, int height) native "WebGLRenderingContext_renderbufferStorage_Callback";

  @DomName('WebGLRenderingContext.sampleCoverage')
  @DocsEditable
  void sampleCoverage(num value, bool invert) native "WebGLRenderingContext_sampleCoverage_Callback";

  @DomName('WebGLRenderingContext.scissor')
  @DocsEditable
  void scissor(int x, int y, int width, int height) native "WebGLRenderingContext_scissor_Callback";

  @DomName('WebGLRenderingContext.shaderSource')
  @DocsEditable
  void shaderSource(WebGLShader shader, String string) native "WebGLRenderingContext_shaderSource_Callback";

  @DomName('WebGLRenderingContext.stencilFunc')
  @DocsEditable
  void stencilFunc(int func, int ref, int mask) native "WebGLRenderingContext_stencilFunc_Callback";

  @DomName('WebGLRenderingContext.stencilFuncSeparate')
  @DocsEditable
  void stencilFuncSeparate(int face, int func, int ref, int mask) native "WebGLRenderingContext_stencilFuncSeparate_Callback";

  @DomName('WebGLRenderingContext.stencilMask')
  @DocsEditable
  void stencilMask(int mask) native "WebGLRenderingContext_stencilMask_Callback";

  @DomName('WebGLRenderingContext.stencilMaskSeparate')
  @DocsEditable
  void stencilMaskSeparate(int face, int mask) native "WebGLRenderingContext_stencilMaskSeparate_Callback";

  @DomName('WebGLRenderingContext.stencilOp')
  @DocsEditable
  void stencilOp(int fail, int zfail, int zpass) native "WebGLRenderingContext_stencilOp_Callback";

  @DomName('WebGLRenderingContext.stencilOpSeparate')
  @DocsEditable
  void stencilOpSeparate(int face, int fail, int zfail, int zpass) native "WebGLRenderingContext_stencilOpSeparate_Callback";

  void texImage2D(int target, int level, int internalformat, int format_OR_width, int height_OR_type, border_OR_canvas_OR_image_OR_pixels_OR_video, [int format, int type, ArrayBufferView pixels]) {
    if ((target is int || target == null) && (level is int || level == null) && (internalformat is int || internalformat == null) && (format_OR_width is int || format_OR_width == null) && (height_OR_type is int || height_OR_type == null) && (border_OR_canvas_OR_image_OR_pixels_OR_video is int || border_OR_canvas_OR_image_OR_pixels_OR_video == null) && (format is int || format == null) && (type is int || type == null) && (pixels is ArrayBufferView || pixels == null)) {
      _texImage2D_1(target, level, internalformat, format_OR_width, height_OR_type, border_OR_canvas_OR_image_OR_pixels_OR_video, format, type, pixels);
      return;
    }
    if ((target is int || target == null) && (level is int || level == null) && (internalformat is int || internalformat == null) && (format_OR_width is int || format_OR_width == null) && (height_OR_type is int || height_OR_type == null) && (border_OR_canvas_OR_image_OR_pixels_OR_video is ImageData || border_OR_canvas_OR_image_OR_pixels_OR_video == null) && !?format && !?type && !?pixels) {
      _texImage2D_2(target, level, internalformat, format_OR_width, height_OR_type, border_OR_canvas_OR_image_OR_pixels_OR_video);
      return;
    }
    if ((target is int || target == null) && (level is int || level == null) && (internalformat is int || internalformat == null) && (format_OR_width is int || format_OR_width == null) && (height_OR_type is int || height_OR_type == null) && (border_OR_canvas_OR_image_OR_pixels_OR_video is ImageElement || border_OR_canvas_OR_image_OR_pixels_OR_video == null) && !?format && !?type && !?pixels) {
      _texImage2D_3(target, level, internalformat, format_OR_width, height_OR_type, border_OR_canvas_OR_image_OR_pixels_OR_video);
      return;
    }
    if ((target is int || target == null) && (level is int || level == null) && (internalformat is int || internalformat == null) && (format_OR_width is int || format_OR_width == null) && (height_OR_type is int || height_OR_type == null) && (border_OR_canvas_OR_image_OR_pixels_OR_video is CanvasElement || border_OR_canvas_OR_image_OR_pixels_OR_video == null) && !?format && !?type && !?pixels) {
      _texImage2D_4(target, level, internalformat, format_OR_width, height_OR_type, border_OR_canvas_OR_image_OR_pixels_OR_video);
      return;
    }
    if ((target is int || target == null) && (level is int || level == null) && (internalformat is int || internalformat == null) && (format_OR_width is int || format_OR_width == null) && (height_OR_type is int || height_OR_type == null) && (border_OR_canvas_OR_image_OR_pixels_OR_video is VideoElement || border_OR_canvas_OR_image_OR_pixels_OR_video == null) && !?format && !?type && !?pixels) {
      _texImage2D_5(target, level, internalformat, format_OR_width, height_OR_type, border_OR_canvas_OR_image_OR_pixels_OR_video);
      return;
    }
    throw new ArgumentError("Incorrect number or type of arguments");
  }

  @DomName('WebGLRenderingContext._texImage2D_1')
  @DocsEditable
  void _texImage2D_1(target, level, internalformat, format_OR_width, height_OR_type, border_OR_canvas_OR_image_OR_pixels_OR_video, format, type, pixels) native "WebGLRenderingContext__texImage2D_1_Callback";

  @DomName('WebGLRenderingContext._texImage2D_2')
  @DocsEditable
  void _texImage2D_2(target, level, internalformat, format_OR_width, height_OR_type, border_OR_canvas_OR_image_OR_pixels_OR_video) native "WebGLRenderingContext__texImage2D_2_Callback";

  @DomName('WebGLRenderingContext._texImage2D_3')
  @DocsEditable
  void _texImage2D_3(target, level, internalformat, format_OR_width, height_OR_type, border_OR_canvas_OR_image_OR_pixels_OR_video) native "WebGLRenderingContext__texImage2D_3_Callback";

  @DomName('WebGLRenderingContext._texImage2D_4')
  @DocsEditable
  void _texImage2D_4(target, level, internalformat, format_OR_width, height_OR_type, border_OR_canvas_OR_image_OR_pixels_OR_video) native "WebGLRenderingContext__texImage2D_4_Callback";

  @DomName('WebGLRenderingContext._texImage2D_5')
  @DocsEditable
  void _texImage2D_5(target, level, internalformat, format_OR_width, height_OR_type, border_OR_canvas_OR_image_OR_pixels_OR_video) native "WebGLRenderingContext__texImage2D_5_Callback";

  @DomName('WebGLRenderingContext.texParameterf')
  @DocsEditable
  void texParameterf(int target, int pname, num param) native "WebGLRenderingContext_texParameterf_Callback";

  @DomName('WebGLRenderingContext.texParameteri')
  @DocsEditable
  void texParameteri(int target, int pname, int param) native "WebGLRenderingContext_texParameteri_Callback";

  void texSubImage2D(int target, int level, int xoffset, int yoffset, int format_OR_width, int height_OR_type, canvas_OR_format_OR_image_OR_pixels_OR_video, [int type, ArrayBufferView pixels]) {
    if ((target is int || target == null) && (level is int || level == null) && (xoffset is int || xoffset == null) && (yoffset is int || yoffset == null) && (format_OR_width is int || format_OR_width == null) && (height_OR_type is int || height_OR_type == null) && (canvas_OR_format_OR_image_OR_pixels_OR_video is int || canvas_OR_format_OR_image_OR_pixels_OR_video == null) && (type is int || type == null) && (pixels is ArrayBufferView || pixels == null)) {
      _texSubImage2D_1(target, level, xoffset, yoffset, format_OR_width, height_OR_type, canvas_OR_format_OR_image_OR_pixels_OR_video, type, pixels);
      return;
    }
    if ((target is int || target == null) && (level is int || level == null) && (xoffset is int || xoffset == null) && (yoffset is int || yoffset == null) && (format_OR_width is int || format_OR_width == null) && (height_OR_type is int || height_OR_type == null) && (canvas_OR_format_OR_image_OR_pixels_OR_video is ImageData || canvas_OR_format_OR_image_OR_pixels_OR_video == null) && !?type && !?pixels) {
      _texSubImage2D_2(target, level, xoffset, yoffset, format_OR_width, height_OR_type, canvas_OR_format_OR_image_OR_pixels_OR_video);
      return;
    }
    if ((target is int || target == null) && (level is int || level == null) && (xoffset is int || xoffset == null) && (yoffset is int || yoffset == null) && (format_OR_width is int || format_OR_width == null) && (height_OR_type is int || height_OR_type == null) && (canvas_OR_format_OR_image_OR_pixels_OR_video is ImageElement || canvas_OR_format_OR_image_OR_pixels_OR_video == null) && !?type && !?pixels) {
      _texSubImage2D_3(target, level, xoffset, yoffset, format_OR_width, height_OR_type, canvas_OR_format_OR_image_OR_pixels_OR_video);
      return;
    }
    if ((target is int || target == null) && (level is int || level == null) && (xoffset is int || xoffset == null) && (yoffset is int || yoffset == null) && (format_OR_width is int || format_OR_width == null) && (height_OR_type is int || height_OR_type == null) && (canvas_OR_format_OR_image_OR_pixels_OR_video is CanvasElement || canvas_OR_format_OR_image_OR_pixels_OR_video == null) && !?type && !?pixels) {
      _texSubImage2D_4(target, level, xoffset, yoffset, format_OR_width, height_OR_type, canvas_OR_format_OR_image_OR_pixels_OR_video);
      return;
    }
    if ((target is int || target == null) && (level is int || level == null) && (xoffset is int || xoffset == null) && (yoffset is int || yoffset == null) && (format_OR_width is int || format_OR_width == null) && (height_OR_type is int || height_OR_type == null) && (canvas_OR_format_OR_image_OR_pixels_OR_video is VideoElement || canvas_OR_format_OR_image_OR_pixels_OR_video == null) && !?type && !?pixels) {
      _texSubImage2D_5(target, level, xoffset, yoffset, format_OR_width, height_OR_type, canvas_OR_format_OR_image_OR_pixels_OR_video);
      return;
    }
    throw new ArgumentError("Incorrect number or type of arguments");
  }

  @DomName('WebGLRenderingContext._texSubImage2D_1')
  @DocsEditable
  void _texSubImage2D_1(target, level, xoffset, yoffset, format_OR_width, height_OR_type, canvas_OR_format_OR_image_OR_pixels_OR_video, type, pixels) native "WebGLRenderingContext__texSubImage2D_1_Callback";

  @DomName('WebGLRenderingContext._texSubImage2D_2')
  @DocsEditable
  void _texSubImage2D_2(target, level, xoffset, yoffset, format_OR_width, height_OR_type, canvas_OR_format_OR_image_OR_pixels_OR_video) native "WebGLRenderingContext__texSubImage2D_2_Callback";

  @DomName('WebGLRenderingContext._texSubImage2D_3')
  @DocsEditable
  void _texSubImage2D_3(target, level, xoffset, yoffset, format_OR_width, height_OR_type, canvas_OR_format_OR_image_OR_pixels_OR_video) native "WebGLRenderingContext__texSubImage2D_3_Callback";

  @DomName('WebGLRenderingContext._texSubImage2D_4')
  @DocsEditable
  void _texSubImage2D_4(target, level, xoffset, yoffset, format_OR_width, height_OR_type, canvas_OR_format_OR_image_OR_pixels_OR_video) native "WebGLRenderingContext__texSubImage2D_4_Callback";

  @DomName('WebGLRenderingContext._texSubImage2D_5')
  @DocsEditable
  void _texSubImage2D_5(target, level, xoffset, yoffset, format_OR_width, height_OR_type, canvas_OR_format_OR_image_OR_pixels_OR_video) native "WebGLRenderingContext__texSubImage2D_5_Callback";

  @DomName('WebGLRenderingContext.uniform1f')
  @DocsEditable
  void uniform1f(WebGLUniformLocation location, num x) native "WebGLRenderingContext_uniform1f_Callback";

  @DomName('WebGLRenderingContext.uniform1fv')
  @DocsEditable
  void uniform1fv(WebGLUniformLocation location, Float32Array v) native "WebGLRenderingContext_uniform1fv_Callback";

  @DomName('WebGLRenderingContext.uniform1i')
  @DocsEditable
  void uniform1i(WebGLUniformLocation location, int x) native "WebGLRenderingContext_uniform1i_Callback";

  @DomName('WebGLRenderingContext.uniform1iv')
  @DocsEditable
  void uniform1iv(WebGLUniformLocation location, Int32Array v) native "WebGLRenderingContext_uniform1iv_Callback";

  @DomName('WebGLRenderingContext.uniform2f')
  @DocsEditable
  void uniform2f(WebGLUniformLocation location, num x, num y) native "WebGLRenderingContext_uniform2f_Callback";

  @DomName('WebGLRenderingContext.uniform2fv')
  @DocsEditable
  void uniform2fv(WebGLUniformLocation location, Float32Array v) native "WebGLRenderingContext_uniform2fv_Callback";

  @DomName('WebGLRenderingContext.uniform2i')
  @DocsEditable
  void uniform2i(WebGLUniformLocation location, int x, int y) native "WebGLRenderingContext_uniform2i_Callback";

  @DomName('WebGLRenderingContext.uniform2iv')
  @DocsEditable
  void uniform2iv(WebGLUniformLocation location, Int32Array v) native "WebGLRenderingContext_uniform2iv_Callback";

  @DomName('WebGLRenderingContext.uniform3f')
  @DocsEditable
  void uniform3f(WebGLUniformLocation location, num x, num y, num z) native "WebGLRenderingContext_uniform3f_Callback";

  @DomName('WebGLRenderingContext.uniform3fv')
  @DocsEditable
  void uniform3fv(WebGLUniformLocation location, Float32Array v) native "WebGLRenderingContext_uniform3fv_Callback";

  @DomName('WebGLRenderingContext.uniform3i')
  @DocsEditable
  void uniform3i(WebGLUniformLocation location, int x, int y, int z) native "WebGLRenderingContext_uniform3i_Callback";

  @DomName('WebGLRenderingContext.uniform3iv')
  @DocsEditable
  void uniform3iv(WebGLUniformLocation location, Int32Array v) native "WebGLRenderingContext_uniform3iv_Callback";

  @DomName('WebGLRenderingContext.uniform4f')
  @DocsEditable
  void uniform4f(WebGLUniformLocation location, num x, num y, num z, num w) native "WebGLRenderingContext_uniform4f_Callback";

  @DomName('WebGLRenderingContext.uniform4fv')
  @DocsEditable
  void uniform4fv(WebGLUniformLocation location, Float32Array v) native "WebGLRenderingContext_uniform4fv_Callback";

  @DomName('WebGLRenderingContext.uniform4i')
  @DocsEditable
  void uniform4i(WebGLUniformLocation location, int x, int y, int z, int w) native "WebGLRenderingContext_uniform4i_Callback";

  @DomName('WebGLRenderingContext.uniform4iv')
  @DocsEditable
  void uniform4iv(WebGLUniformLocation location, Int32Array v) native "WebGLRenderingContext_uniform4iv_Callback";

  @DomName('WebGLRenderingContext.uniformMatrix2fv')
  @DocsEditable
  void uniformMatrix2fv(WebGLUniformLocation location, bool transpose, Float32Array array) native "WebGLRenderingContext_uniformMatrix2fv_Callback";

  @DomName('WebGLRenderingContext.uniformMatrix3fv')
  @DocsEditable
  void uniformMatrix3fv(WebGLUniformLocation location, bool transpose, Float32Array array) native "WebGLRenderingContext_uniformMatrix3fv_Callback";

  @DomName('WebGLRenderingContext.uniformMatrix4fv')
  @DocsEditable
  void uniformMatrix4fv(WebGLUniformLocation location, bool transpose, Float32Array array) native "WebGLRenderingContext_uniformMatrix4fv_Callback";

  @DomName('WebGLRenderingContext.useProgram')
  @DocsEditable
  void useProgram(WebGLProgram program) native "WebGLRenderingContext_useProgram_Callback";

  @DomName('WebGLRenderingContext.validateProgram')
  @DocsEditable
  void validateProgram(WebGLProgram program) native "WebGLRenderingContext_validateProgram_Callback";

  @DomName('WebGLRenderingContext.vertexAttrib1f')
  @DocsEditable
  void vertexAttrib1f(int indx, num x) native "WebGLRenderingContext_vertexAttrib1f_Callback";

  @DomName('WebGLRenderingContext.vertexAttrib1fv')
  @DocsEditable
  void vertexAttrib1fv(int indx, Float32Array values) native "WebGLRenderingContext_vertexAttrib1fv_Callback";

  @DomName('WebGLRenderingContext.vertexAttrib2f')
  @DocsEditable
  void vertexAttrib2f(int indx, num x, num y) native "WebGLRenderingContext_vertexAttrib2f_Callback";

  @DomName('WebGLRenderingContext.vertexAttrib2fv')
  @DocsEditable
  void vertexAttrib2fv(int indx, Float32Array values) native "WebGLRenderingContext_vertexAttrib2fv_Callback";

  @DomName('WebGLRenderingContext.vertexAttrib3f')
  @DocsEditable
  void vertexAttrib3f(int indx, num x, num y, num z) native "WebGLRenderingContext_vertexAttrib3f_Callback";

  @DomName('WebGLRenderingContext.vertexAttrib3fv')
  @DocsEditable
  void vertexAttrib3fv(int indx, Float32Array values) native "WebGLRenderingContext_vertexAttrib3fv_Callback";

  @DomName('WebGLRenderingContext.vertexAttrib4f')
  @DocsEditable
  void vertexAttrib4f(int indx, num x, num y, num z, num w) native "WebGLRenderingContext_vertexAttrib4f_Callback";

  @DomName('WebGLRenderingContext.vertexAttrib4fv')
  @DocsEditable
  void vertexAttrib4fv(int indx, Float32Array values) native "WebGLRenderingContext_vertexAttrib4fv_Callback";

  @DomName('WebGLRenderingContext.vertexAttribPointer')
  @DocsEditable
  void vertexAttribPointer(int indx, int size, int type, bool normalized, int stride, int offset) native "WebGLRenderingContext_vertexAttribPointer_Callback";

  @DomName('WebGLRenderingContext.viewport')
  @DocsEditable
  void viewport(int x, int y, int width, int height) native "WebGLRenderingContext_viewport_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('WebGLShader')
class WebGLShader extends NativeFieldWrapperClass1 {
  WebGLShader.internal();

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('WebGLShaderPrecisionFormat')
class WebGLShaderPrecisionFormat extends NativeFieldWrapperClass1 {
  WebGLShaderPrecisionFormat.internal();

  @DomName('WebGLShaderPrecisionFormat.precision')
  @DocsEditable
  int get precision native "WebGLShaderPrecisionFormat_precision_Getter";

  @DomName('WebGLShaderPrecisionFormat.rangeMax')
  @DocsEditable
  int get rangeMax native "WebGLShaderPrecisionFormat_rangeMax_Getter";

  @DomName('WebGLShaderPrecisionFormat.rangeMin')
  @DocsEditable
  int get rangeMin native "WebGLShaderPrecisionFormat_rangeMin_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('WebGLTexture')
class WebGLTexture extends NativeFieldWrapperClass1 {
  WebGLTexture.internal();

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('WebGLUniformLocation')
class WebGLUniformLocation extends NativeFieldWrapperClass1 {
  WebGLUniformLocation.internal();

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('WebGLVertexArrayObjectOES')
class WebGLVertexArrayObject extends NativeFieldWrapperClass1 {
  WebGLVertexArrayObject.internal();

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('WebKitCSSFilterValue')
class WebKitCssFilterValue extends _CssValueList {
  WebKitCssFilterValue.internal() : super.internal();

  static const int CSS_FILTER_BLUR = 10;

  static const int CSS_FILTER_BRIGHTNESS = 8;

  static const int CSS_FILTER_CONTRAST = 9;

  static const int CSS_FILTER_CUSTOM = 12;

  static const int CSS_FILTER_DROP_SHADOW = 11;

  static const int CSS_FILTER_GRAYSCALE = 2;

  static const int CSS_FILTER_HUE_ROTATE = 5;

  static const int CSS_FILTER_INVERT = 6;

  static const int CSS_FILTER_OPACITY = 7;

  static const int CSS_FILTER_REFERENCE = 1;

  static const int CSS_FILTER_SATURATE = 4;

  static const int CSS_FILTER_SEPIA = 3;

  @DomName('WebKitCSSFilterValue.operationType')
  @DocsEditable
  int get operationType native "WebKitCSSFilterValue_operationType_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('WebKitCSSMixFunctionValue')
class WebKitCssMixFunctionValue extends _CssValueList {
  WebKitCssMixFunctionValue.internal() : super.internal();

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('WebKitNamedFlow')
class WebKitNamedFlow extends EventTarget {
  WebKitNamedFlow.internal() : super.internal();

  @DomName('WebKitNamedFlow.firstEmptyRegionIndex')
  @DocsEditable
  int get firstEmptyRegionIndex native "WebKitNamedFlow_firstEmptyRegionIndex_Getter";

  @DomName('WebKitNamedFlow.name')
  @DocsEditable
  String get name native "WebKitNamedFlow_name_Getter";

  @DomName('WebKitNamedFlow.overset')
  @DocsEditable
  bool get overset native "WebKitNamedFlow_overset_Getter";

  @DomName('WebKitNamedFlow.addEventListener')
  @DocsEditable
  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]) native "WebKitNamedFlow_addEventListener_Callback";

  @DomName('WebKitNamedFlow.dispatchEvent')
  @DocsEditable
  bool dispatchEvent(Event event) native "WebKitNamedFlow_dispatchEvent_Callback";

  @DomName('WebKitNamedFlow.getContent')
  @DocsEditable
  List<Node> getContent() native "WebKitNamedFlow_getContent_Callback";

  @DomName('WebKitNamedFlow.getRegions')
  @DocsEditable
  List<Node> getRegions() native "WebKitNamedFlow_getRegions_Callback";

  @DomName('WebKitNamedFlow.getRegionsByContent')
  @DocsEditable
  List<Node> getRegionsByContent(Node contentNode) native "WebKitNamedFlow_getRegionsByContent_Callback";

  @DomName('WebKitNamedFlow.removeEventListener')
  @DocsEditable
  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]) native "WebKitNamedFlow_removeEventListener_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('WebSocket')
@SupportedBrowser(SupportedBrowser.CHROME)
@SupportedBrowser(SupportedBrowser.FIREFOX)
@SupportedBrowser(SupportedBrowser.IE, '10')
@SupportedBrowser(SupportedBrowser.SAFARI)
class WebSocket extends EventTarget {
  WebSocket.internal() : super.internal();

  @DomName('WebSocket.close')
  @DocsEditable
  static const EventStreamProvider<CloseEvent> closeEvent = const EventStreamProvider<CloseEvent>('close');

  @DomName('WebSocket.error')
  @DocsEditable
  static const EventStreamProvider<Event> errorEvent = const EventStreamProvider<Event>('error');

  @DomName('WebSocket.message')
  @DocsEditable
  static const EventStreamProvider<MessageEvent> messageEvent = const EventStreamProvider<MessageEvent>('message');

  @DomName('WebSocket.open')
  @DocsEditable
  static const EventStreamProvider<Event> openEvent = const EventStreamProvider<Event>('open');

  @DocsEditable
  factory WebSocket(String url) => WebSocket._create(url);
  static WebSocket _create(String url) native "WebSocket_constructor_Callback";

  /// Checks if this type is supported on the current platform.
  static bool get supported => true;

  @DocsEditable
  @DomName('EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent')
  @deprecated
  WebSocketEvents get on =>
    new WebSocketEvents(this);

  static const int CLOSED = 3;

  static const int CLOSING = 2;

  static const int CONNECTING = 0;

  static const int OPEN = 1;

  @DomName('WebSocket.URL')
  @DocsEditable
  String get Url native "WebSocket_URL_Getter";

  @DomName('WebSocket.binaryType')
  @DocsEditable
  String get binaryType native "WebSocket_binaryType_Getter";

  @DomName('WebSocket.binaryType')
  @DocsEditable
  void set binaryType(String value) native "WebSocket_binaryType_Setter";

  @DomName('WebSocket.bufferedAmount')
  @DocsEditable
  int get bufferedAmount native "WebSocket_bufferedAmount_Getter";

  @DomName('WebSocket.extensions')
  @DocsEditable
  String get extensions native "WebSocket_extensions_Getter";

  @DomName('WebSocket.protocol')
  @DocsEditable
  String get protocol native "WebSocket_protocol_Getter";

  @DomName('WebSocket.readyState')
  @DocsEditable
  int get readyState native "WebSocket_readyState_Getter";

  @DomName('WebSocket.url')
  @DocsEditable
  String get url native "WebSocket_url_Getter";

  @DomName('WebSocket.addEventListener')
  @DocsEditable
  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]) native "WebSocket_addEventListener_Callback";

  void close([int code, String reason]) {
    if (?reason) {
      _close_1(code, reason);
      return;
    }
    if (?code) {
      _close_2(code);
      return;
    }
    _close_3();
    return;
  }

  @DomName('WebSocket._close_1')
  @DocsEditable
  void _close_1(code, reason) native "WebSocket__close_1_Callback";

  @DomName('WebSocket._close_2')
  @DocsEditable
  void _close_2(code) native "WebSocket__close_2_Callback";

  @DomName('WebSocket._close_3')
  @DocsEditable
  void _close_3() native "WebSocket__close_3_Callback";

  @DomName('WebSocket.dispatchEvent')
  @DocsEditable
  bool dispatchEvent(Event evt) native "WebSocket_dispatchEvent_Callback";

  @DomName('WebSocket.removeEventListener')
  @DocsEditable
  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]) native "WebSocket_removeEventListener_Callback";

  @DomName('WebSocket.send')
  @DocsEditable
  void send(data) native "WebSocket_send_Callback";

  @DomName('WebSocket.close')
  @DocsEditable
  Stream<CloseEvent> get onClose => closeEvent.forTarget(this);

  @DomName('WebSocket.error')
  @DocsEditable
  Stream<Event> get onError => errorEvent.forTarget(this);

  @DomName('WebSocket.message')
  @DocsEditable
  Stream<MessageEvent> get onMessage => messageEvent.forTarget(this);

  @DomName('WebSocket.open')
  @DocsEditable
  Stream<Event> get onOpen => openEvent.forTarget(this);

}

@DocsEditable
@deprecated
class WebSocketEvents extends Events {
  @DocsEditable
  WebSocketEvents(EventTarget _ptr) : super(_ptr);

  @DocsEditable
  EventListenerList get close => this['close'];

  @DocsEditable
  EventListenerList get error => this['error'];

  @DocsEditable
  EventListenerList get message => this['message'];

  @DocsEditable
  EventListenerList get open => this['open'];
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.


@DomName('WheelEvent')
class WheelEvent extends MouseEvent {

  factory WheelEvent(String type,
      {Window view, int deltaX: 0, int deltaY: 0,
      int detail: 0, int screenX: 0, int screenY: 0, int clientX: 0,
      int clientY: 0, int button: 0, bool canBubble: true,
      bool cancelable: true, bool ctrlKey: false, bool altKey: false,
      bool shiftKey: false, bool metaKey: false, EventTarget relatedTarget}) {

    if (view == null) {
      view = window;
    }
    var eventType = 'WheelEvent';
    if (_Device.isFirefox) {
      eventType = 'MouseScrollEvents';
    }
    final event = document.$dom_createEvent(eventType);
      // Fallthrough for Dartium.
      event.$dom_initMouseEvent(type, canBubble, cancelable, view, detail,
          screenX, screenY, clientX, clientY, ctrlKey, altKey, shiftKey,
          metaKey, button, relatedTarget);
      event.$dom_initWebKitWheelEvent(deltaX,
          deltaY ~/ 120, // Chrome does an auto-convert to pixels.
          view, screenX, screenY, clientX, clientY, ctrlKey, altKey, shiftKey,
          metaKey);

    return event;
  }

  WheelEvent.internal() : super.internal();

  @DomName('WheelEvent.webkitDirectionInvertedFromDevice')
  @DocsEditable
  bool get webkitDirectionInvertedFromDevice native "WheelEvent_webkitDirectionInvertedFromDevice_Getter";

  @DomName('WheelEvent.wheelDeltaX')
  @DocsEditable
  int get $dom_wheelDeltaX native "WheelEvent_wheelDeltaX_Getter";

  @DomName('WheelEvent.wheelDeltaY')
  @DocsEditable
  int get $dom_wheelDeltaY native "WheelEvent_wheelDeltaY_Getter";

  @DomName('WheelEvent.initWebKitWheelEvent')
  @DocsEditable
  void $dom_initWebKitWheelEvent(int wheelDeltaX, int wheelDeltaY, Window view, int screenX, int screenY, int clientX, int clientY, bool ctrlKey, bool altKey, bool shiftKey, bool metaKey) native "WheelEvent_initWebKitWheelEvent_Callback";


  @DomName('WheelEvent.deltaX')
  num get deltaX => $dom_wheelDeltaX;
  @DomName('WheelEvent.deltaY')
  num get deltaY => $dom_wheelDeltaY;
  @DomName('WheelEvent.deltaMode')
  int get deltaMode => 0;

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.


@DomName('Window')
class Window extends EventTarget implements WindowBase {

  /**
   * Executes a [callback] after the immediate execution stack has completed.
   *
   * This will cause the callback to be executed after all processing has
   * completed for the current event, but before any subsequent events.
   */
  void setImmediate(TimeoutHandler callback) {
    _addMicrotaskCallback(callback);
  }

  /**
   * Lookup a port by its [name].  Return null if no port is
   * registered under [name].
   */
  lookupPort(String name) {
    var port = json.parse(document.documentElement.attributes['dart-port:$name']);
    return _deserialize(port);
  }

  /**
   * Register a [port] on this window under the given [name].  This
   * port may be retrieved by any isolate (or JavaScript script)
   * running in this window.
   */
  registerPort(String name, var port) {
    var serialized = _serialize(port);
    document.documentElement.attributes['dart-port:$name'] = json.stringify(serialized);
  }

  /// Checks if _setImmediate is supported.
  static bool get _supportsSetImmediate => false;

  /// Dartium stub for IE's setImmediate.
  void _setImmediate(void callback()) {
    throw new UnsupportedError('setImmediate is not supported');
  }

  Window.internal() : super.internal();

  @DomName('DOMWindow.DOMContentLoaded')
  @DocsEditable
  static const EventStreamProvider<Event> contentLoadedEvent = const EventStreamProvider<Event>('DOMContentLoaded');

  @DomName('DOMWindow.beforeunload')
  @DocsEditable
  static const EventStreamProvider<Event> beforeUnloadEvent = const EventStreamProvider<Event>('beforeunload');

  @DomName('DOMWindow.devicemotion')
  @DocsEditable
  static const EventStreamProvider<DeviceMotionEvent> deviceMotionEvent = const EventStreamProvider<DeviceMotionEvent>('devicemotion');

  @DomName('DOMWindow.deviceorientation')
  @DocsEditable
  static const EventStreamProvider<DeviceOrientationEvent> deviceOrientationEvent = const EventStreamProvider<DeviceOrientationEvent>('deviceorientation');

  @DomName('DOMWindow.hashchange')
  @DocsEditable
  static const EventStreamProvider<Event> hashChangeEvent = const EventStreamProvider<Event>('hashchange');

  @DomName('DOMWindow.message')
  @DocsEditable
  static const EventStreamProvider<MessageEvent> messageEvent = const EventStreamProvider<MessageEvent>('message');

  @DomName('DOMWindow.offline')
  @DocsEditable
  static const EventStreamProvider<Event> offlineEvent = const EventStreamProvider<Event>('offline');

  @DomName('DOMWindow.online')
  @DocsEditable
  static const EventStreamProvider<Event> onlineEvent = const EventStreamProvider<Event>('online');

  @DomName('DOMWindow.pagehide')
  @DocsEditable
  static const EventStreamProvider<Event> pageHideEvent = const EventStreamProvider<Event>('pagehide');

  @DomName('DOMWindow.pageshow')
  @DocsEditable
  static const EventStreamProvider<Event> pageShowEvent = const EventStreamProvider<Event>('pageshow');

  @DomName('DOMWindow.popstate')
  @DocsEditable
  static const EventStreamProvider<PopStateEvent> popStateEvent = const EventStreamProvider<PopStateEvent>('popstate');

  @DomName('DOMWindow.resize')
  @DocsEditable
  static const EventStreamProvider<Event> resizeEvent = const EventStreamProvider<Event>('resize');

  @DomName('DOMWindow.storage')
  @DocsEditable
  static const EventStreamProvider<StorageEvent> storageEvent = const EventStreamProvider<StorageEvent>('storage');

  @DomName('DOMWindow.unload')
  @DocsEditable
  static const EventStreamProvider<Event> unloadEvent = const EventStreamProvider<Event>('unload');

  @DomName('DOMWindow.webkitAnimationEnd')
  @DocsEditable
  static const EventStreamProvider<AnimationEvent> animationEndEvent = const EventStreamProvider<AnimationEvent>('webkitAnimationEnd');

  @DomName('DOMWindow.webkitAnimationIteration')
  @DocsEditable
  static const EventStreamProvider<AnimationEvent> animationIterationEvent = const EventStreamProvider<AnimationEvent>('webkitAnimationIteration');

  @DomName('DOMWindow.webkitAnimationStart')
  @DocsEditable
  static const EventStreamProvider<AnimationEvent> animationStartEvent = const EventStreamProvider<AnimationEvent>('webkitAnimationStart');

  @DocsEditable
  @DomName('EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent')
  @deprecated
  WindowEvents get on =>
    new WindowEvents(this);

  static const int PERSISTENT = 1;

  static const int TEMPORARY = 0;

  @DomName('DOMWindow.applicationCache')
  @DocsEditable
  ApplicationCache get applicationCache native "DOMWindow_applicationCache_Getter";

  @DomName('DOMWindow.closed')
  @DocsEditable
  bool get closed native "DOMWindow_closed_Getter";

  @DomName('DOMWindow.console')
  @DocsEditable
  Console get console native "DOMWindow_console_Getter";

  @DomName('DOMWindow.crypto')
  @DocsEditable
  Crypto get crypto native "DOMWindow_crypto_Getter";

  @DomName('DOMWindow.defaultStatus')
  @DocsEditable
  String get defaultStatus native "DOMWindow_defaultStatus_Getter";

  @DomName('DOMWindow.defaultStatus')
  @DocsEditable
  void set defaultStatus(String value) native "DOMWindow_defaultStatus_Setter";

  @DomName('DOMWindow.defaultstatus')
  @DocsEditable
  String get defaultstatus native "DOMWindow_defaultstatus_Getter";

  @DomName('DOMWindow.defaultstatus')
  @DocsEditable
  void set defaultstatus(String value) native "DOMWindow_defaultstatus_Setter";

  @DomName('DOMWindow.devicePixelRatio')
  @DocsEditable
  num get devicePixelRatio native "DOMWindow_devicePixelRatio_Getter";

  @DomName('DOMWindow.document')
  @DocsEditable
  Document get document native "DOMWindow_document_Getter";

  @DomName('DOMWindow.event')
  @DocsEditable
  Event get event native "DOMWindow_event_Getter";

  @DomName('DOMWindow.history')
  @DocsEditable
  History get history native "DOMWindow_history_Getter";

  @DomName('DOMWindow.indexedDB')
  @DocsEditable
  @SupportedBrowser(SupportedBrowser.CHROME)
  @SupportedBrowser(SupportedBrowser.FIREFOX, '15')
  @SupportedBrowser(SupportedBrowser.IE, '10')
  @Experimental
  IdbFactory get indexedDB native "DOMWindow_indexedDB_Getter";

  @DomName('DOMWindow.innerHeight')
  @DocsEditable
  int get innerHeight native "DOMWindow_innerHeight_Getter";

  @DomName('DOMWindow.innerWidth')
  @DocsEditable
  int get innerWidth native "DOMWindow_innerWidth_Getter";

  @DomName('DOMWindow.localStorage')
  @DocsEditable
  Storage get localStorage native "DOMWindow_localStorage_Getter";

  @DomName('DOMWindow.location')
  @DocsEditable
  Location get location native "DOMWindow_location_Getter";

  @DomName('DOMWindow.location')
  @DocsEditable
  void set location(Location value) native "DOMWindow_location_Setter";

  @DomName('DOMWindow.locationbar')
  @DocsEditable
  BarInfo get locationbar native "DOMWindow_locationbar_Getter";

  @DomName('DOMWindow.menubar')
  @DocsEditable
  BarInfo get menubar native "DOMWindow_menubar_Getter";

  @DomName('DOMWindow.name')
  @DocsEditable
  String get name native "DOMWindow_name_Getter";

  @DomName('DOMWindow.name')
  @DocsEditable
  void set name(String value) native "DOMWindow_name_Setter";

  @DomName('DOMWindow.navigator')
  @DocsEditable
  Navigator get navigator native "DOMWindow_navigator_Getter";

  @DomName('DOMWindow.offscreenBuffering')
  @DocsEditable
  bool get offscreenBuffering native "DOMWindow_offscreenBuffering_Getter";

  @DomName('DOMWindow.opener')
  @DocsEditable
  WindowBase get opener native "DOMWindow_opener_Getter";

  @DomName('DOMWindow.outerHeight')
  @DocsEditable
  int get outerHeight native "DOMWindow_outerHeight_Getter";

  @DomName('DOMWindow.outerWidth')
  @DocsEditable
  int get outerWidth native "DOMWindow_outerWidth_Getter";

  @DomName('DOMWindow.pagePopupController')
  @DocsEditable
  PagePopupController get pagePopupController native "DOMWindow_pagePopupController_Getter";

  @DomName('DOMWindow.pageXOffset')
  @DocsEditable
  int get pageXOffset native "DOMWindow_pageXOffset_Getter";

  @DomName('DOMWindow.pageYOffset')
  @DocsEditable
  int get pageYOffset native "DOMWindow_pageYOffset_Getter";

  @DomName('DOMWindow.parent')
  @DocsEditable
  WindowBase get parent native "DOMWindow_parent_Getter";

  @DomName('DOMWindow.performance')
  @DocsEditable
  @SupportedBrowser(SupportedBrowser.CHROME)
  @SupportedBrowser(SupportedBrowser.FIREFOX)
  @SupportedBrowser(SupportedBrowser.IE)
  Performance get performance native "DOMWindow_performance_Getter";

  @DomName('DOMWindow.personalbar')
  @DocsEditable
  BarInfo get personalbar native "DOMWindow_personalbar_Getter";

  @DomName('DOMWindow.screen')
  @DocsEditable
  Screen get screen native "DOMWindow_screen_Getter";

  @DomName('DOMWindow.screenLeft')
  @DocsEditable
  int get screenLeft native "DOMWindow_screenLeft_Getter";

  @DomName('DOMWindow.screenTop')
  @DocsEditable
  int get screenTop native "DOMWindow_screenTop_Getter";

  @DomName('DOMWindow.screenX')
  @DocsEditable
  int get screenX native "DOMWindow_screenX_Getter";

  @DomName('DOMWindow.screenY')
  @DocsEditable
  int get screenY native "DOMWindow_screenY_Getter";

  @DomName('DOMWindow.scrollX')
  @DocsEditable
  int get scrollX native "DOMWindow_scrollX_Getter";

  @DomName('DOMWindow.scrollY')
  @DocsEditable
  int get scrollY native "DOMWindow_scrollY_Getter";

  @DomName('DOMWindow.scrollbars')
  @DocsEditable
  BarInfo get scrollbars native "DOMWindow_scrollbars_Getter";

  @DomName('DOMWindow.self')
  @DocsEditable
  WindowBase get self native "DOMWindow_self_Getter";

  @DomName('DOMWindow.sessionStorage')
  @DocsEditable
  Storage get sessionStorage native "DOMWindow_sessionStorage_Getter";

  @DomName('DOMWindow.status')
  @DocsEditable
  String get status native "DOMWindow_status_Getter";

  @DomName('DOMWindow.status')
  @DocsEditable
  void set status(String value) native "DOMWindow_status_Setter";

  @DomName('DOMWindow.statusbar')
  @DocsEditable
  BarInfo get statusbar native "DOMWindow_statusbar_Getter";

  @DomName('DOMWindow.styleMedia')
  @DocsEditable
  StyleMedia get styleMedia native "DOMWindow_styleMedia_Getter";

  @DomName('DOMWindow.toolbar')
  @DocsEditable
  BarInfo get toolbar native "DOMWindow_toolbar_Getter";

  @DomName('DOMWindow.top')
  @DocsEditable
  WindowBase get top native "DOMWindow_top_Getter";

  @DomName('DOMWindow.webkitNotifications')
  @DocsEditable
  @SupportedBrowser(SupportedBrowser.CHROME)
  @SupportedBrowser(SupportedBrowser.SAFARI)
  @Experimental
  NotificationCenter get notifications native "DOMWindow_webkitNotifications_Getter";

  @DomName('DOMWindow.webkitStorageInfo')
  @DocsEditable
  StorageInfo get webkitStorageInfo native "DOMWindow_webkitStorageInfo_Getter";

  @DomName('DOMWindow.window')
  @DocsEditable
  WindowBase get window native "DOMWindow_window_Getter";

  @DomName('DOMWindow.addEventListener')
  @DocsEditable
  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]) native "DOMWindow_addEventListener_Callback";

  @DomName('DOMWindow.alert')
  @DocsEditable
  void alert(String message) native "DOMWindow_alert_Callback";

  @DomName('DOMWindow.atob')
  @DocsEditable
  String atob(String string) native "DOMWindow_atob_Callback";

  @DomName('DOMWindow.btoa')
  @DocsEditable
  String btoa(String string) native "DOMWindow_btoa_Callback";

  @DomName('DOMWindow.cancelAnimationFrame')
  @DocsEditable
  void cancelAnimationFrame(int id) native "DOMWindow_cancelAnimationFrame_Callback";

  @DomName('DOMWindow.captureEvents')
  @DocsEditable
  void captureEvents() native "DOMWindow_captureEvents_Callback";

  @DomName('DOMWindow.clearInterval')
  @DocsEditable
  void clearInterval(int handle) native "DOMWindow_clearInterval_Callback";

  @DomName('DOMWindow.clearTimeout')
  @DocsEditable
  void clearTimeout(int handle) native "DOMWindow_clearTimeout_Callback";

  @DomName('DOMWindow.close')
  @DocsEditable
  void close() native "DOMWindow_close_Callback";

  @DomName('DOMWindow.confirm')
  @DocsEditable
  bool confirm(String message) native "DOMWindow_confirm_Callback";

  @DomName('DOMWindow.dispatchEvent')
  @DocsEditable
  bool dispatchEvent(Event evt) native "DOMWindow_dispatchEvent_Callback";

  @DomName('DOMWindow.find')
  @DocsEditable
  bool find(String string, bool caseSensitive, bool backwards, bool wrap, bool wholeWord, bool searchInFrames, bool showDialog) native "DOMWindow_find_Callback";

  @DomName('DOMWindow.getComputedStyle')
  @DocsEditable
  CssStyleDeclaration $dom_getComputedStyle(Element element, String pseudoElement) native "DOMWindow_getComputedStyle_Callback";

  @DomName('DOMWindow.getMatchedCSSRules')
  @DocsEditable
  List<CssRule> getMatchedCssRules(Element element, String pseudoElement) native "DOMWindow_getMatchedCSSRules_Callback";

  @DomName('DOMWindow.getSelection')
  @DocsEditable
  DomSelection getSelection() native "DOMWindow_getSelection_Callback";

  @DomName('DOMWindow.matchMedia')
  @DocsEditable
  MediaQueryList matchMedia(String query) native "DOMWindow_matchMedia_Callback";

  @DomName('DOMWindow.moveBy')
  @DocsEditable
  void moveBy(num x, num y) native "DOMWindow_moveBy_Callback";

  @DomName('DOMWindow.moveTo')
  @DocsEditable
  void moveTo(num x, num y) native "DOMWindow_moveTo_Callback";

  @DomName('DOMWindow.open')
  @DocsEditable
  WindowBase open(String url, String name, [String options]) native "DOMWindow_open_Callback";

  @DomName('DOMWindow.openDatabase')
  @DocsEditable
  @SupportedBrowser(SupportedBrowser.CHROME)
  @SupportedBrowser(SupportedBrowser.SAFARI)
  @Experimental
  Database openDatabase(String name, String version, String displayName, int estimatedSize, [DatabaseCallback creationCallback]) native "DOMWindow_openDatabase_Callback";

  @DomName('DOMWindow.postMessage')
  @DocsEditable
  void postMessage(/*SerializedScriptValue*/ message, String targetOrigin, [List messagePorts]) native "DOMWindow_postMessage_Callback";

  @DomName('DOMWindow.print')
  @DocsEditable
  void print() native "DOMWindow_print_Callback";

  @DomName('DOMWindow.releaseEvents')
  @DocsEditable
  void releaseEvents() native "DOMWindow_releaseEvents_Callback";

  @DomName('DOMWindow.removeEventListener')
  @DocsEditable
  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]) native "DOMWindow_removeEventListener_Callback";

  @DomName('DOMWindow.requestAnimationFrame')
  @DocsEditable
  int requestAnimationFrame(RequestAnimationFrameCallback callback) native "DOMWindow_requestAnimationFrame_Callback";

  @DomName('DOMWindow.resizeBy')
  @DocsEditable
  void resizeBy(num x, num y) native "DOMWindow_resizeBy_Callback";

  @DomName('DOMWindow.resizeTo')
  @DocsEditable
  void resizeTo(num width, num height) native "DOMWindow_resizeTo_Callback";

  @DomName('DOMWindow.scroll')
  @DocsEditable
  void scroll(int x, int y) native "DOMWindow_scroll_Callback";

  @DomName('DOMWindow.scrollBy')
  @DocsEditable
  void scrollBy(int x, int y) native "DOMWindow_scrollBy_Callback";

  @DomName('DOMWindow.scrollTo')
  @DocsEditable
  void scrollTo(int x, int y) native "DOMWindow_scrollTo_Callback";

  @DomName('DOMWindow.setInterval')
  @DocsEditable
  int setInterval(TimeoutHandler handler, int timeout) native "DOMWindow_setInterval_Callback";

  @DomName('DOMWindow.setTimeout')
  @DocsEditable
  int setTimeout(TimeoutHandler handler, int timeout) native "DOMWindow_setTimeout_Callback";

  @DomName('DOMWindow.showModalDialog')
  @DocsEditable
  Object showModalDialog(String url, [Object dialogArgs, String featureArgs]) native "DOMWindow_showModalDialog_Callback";

  @DomName('DOMWindow.stop')
  @DocsEditable
  void stop() native "DOMWindow_stop_Callback";

  @DomName('DOMWindow.webkitCancelAnimationFrame')
  @DocsEditable
  void webkitCancelAnimationFrame(int id) native "DOMWindow_webkitCancelAnimationFrame_Callback";

  @DomName('DOMWindow.webkitConvertPointFromNodeToPage')
  @DocsEditable
  DomPoint convertPointFromNodeToPage(Node node, DomPoint p) native "DOMWindow_webkitConvertPointFromNodeToPage_Callback";

  @DomName('DOMWindow.webkitConvertPointFromPageToNode')
  @DocsEditable
  DomPoint convertPointFromPageToNode(Node node, DomPoint p) native "DOMWindow_webkitConvertPointFromPageToNode_Callback";

  @DomName('DOMWindow.webkitRequestAnimationFrame')
  @DocsEditable
  int webkitRequestAnimationFrame(RequestAnimationFrameCallback callback) native "DOMWindow_webkitRequestAnimationFrame_Callback";

  @DomName('DOMWindow.webkitRequestFileSystem')
  @DocsEditable
  @SupportedBrowser(SupportedBrowser.CHROME)
  @Experimental
  void requestFileSystem(int type, int size, FileSystemCallback successCallback, [ErrorCallback errorCallback]) native "DOMWindow_webkitRequestFileSystem_Callback";

  @DomName('DOMWindow.webkitResolveLocalFileSystemURL')
  @DocsEditable
  @SupportedBrowser(SupportedBrowser.CHROME)
  @Experimental
  void resolveLocalFileSystemUrl(String url, EntryCallback successCallback, [ErrorCallback errorCallback]) native "DOMWindow_webkitResolveLocalFileSystemURL_Callback";

  @DomName('DOMWindow.DOMContentLoaded')
  @DocsEditable
  Stream<Event> get onContentLoaded => contentLoadedEvent.forTarget(this);

  @DomName('DOMWindow.abort')
  @DocsEditable
  Stream<Event> get onAbort => Element.abortEvent.forTarget(this);

  @DomName('DOMWindow.beforeunload')
  @DocsEditable
  Stream<Event> get onBeforeUnload => beforeUnloadEvent.forTarget(this);

  @DomName('DOMWindow.blur')
  @DocsEditable
  Stream<Event> get onBlur => Element.blurEvent.forTarget(this);

  @DomName('DOMWindow.change')
  @DocsEditable
  Stream<Event> get onChange => Element.changeEvent.forTarget(this);

  @DomName('DOMWindow.click')
  @DocsEditable
  Stream<MouseEvent> get onClick => Element.clickEvent.forTarget(this);

  @DomName('DOMWindow.contextmenu')
  @DocsEditable
  Stream<MouseEvent> get onContextMenu => Element.contextMenuEvent.forTarget(this);

  @DomName('DOMWindow.dblclick')
  @DocsEditable
  Stream<Event> get onDoubleClick => Element.doubleClickEvent.forTarget(this);

  @DomName('DOMWindow.devicemotion')
  @DocsEditable
  Stream<DeviceMotionEvent> get onDeviceMotion => deviceMotionEvent.forTarget(this);

  @DomName('DOMWindow.deviceorientation')
  @DocsEditable
  Stream<DeviceOrientationEvent> get onDeviceOrientation => deviceOrientationEvent.forTarget(this);

  @DomName('DOMWindow.drag')
  @DocsEditable
  Stream<MouseEvent> get onDrag => Element.dragEvent.forTarget(this);

  @DomName('DOMWindow.dragend')
  @DocsEditable
  Stream<MouseEvent> get onDragEnd => Element.dragEndEvent.forTarget(this);

  @DomName('DOMWindow.dragenter')
  @DocsEditable
  Stream<MouseEvent> get onDragEnter => Element.dragEnterEvent.forTarget(this);

  @DomName('DOMWindow.dragleave')
  @DocsEditable
  Stream<MouseEvent> get onDragLeave => Element.dragLeaveEvent.forTarget(this);

  @DomName('DOMWindow.dragover')
  @DocsEditable
  Stream<MouseEvent> get onDragOver => Element.dragOverEvent.forTarget(this);

  @DomName('DOMWindow.dragstart')
  @DocsEditable
  Stream<MouseEvent> get onDragStart => Element.dragStartEvent.forTarget(this);

  @DomName('DOMWindow.drop')
  @DocsEditable
  Stream<MouseEvent> get onDrop => Element.dropEvent.forTarget(this);

  @DomName('DOMWindow.error')
  @DocsEditable
  Stream<Event> get onError => Element.errorEvent.forTarget(this);

  @DomName('DOMWindow.focus')
  @DocsEditable
  Stream<Event> get onFocus => Element.focusEvent.forTarget(this);

  @DomName('DOMWindow.hashchange')
  @DocsEditable
  Stream<Event> get onHashChange => hashChangeEvent.forTarget(this);

  @DomName('DOMWindow.input')
  @DocsEditable
  Stream<Event> get onInput => Element.inputEvent.forTarget(this);

  @DomName('DOMWindow.invalid')
  @DocsEditable
  Stream<Event> get onInvalid => Element.invalidEvent.forTarget(this);

  @DomName('DOMWindow.keydown')
  @DocsEditable
  Stream<KeyboardEvent> get onKeyDown => Element.keyDownEvent.forTarget(this);

  @DomName('DOMWindow.keypress')
  @DocsEditable
  Stream<KeyboardEvent> get onKeyPress => Element.keyPressEvent.forTarget(this);

  @DomName('DOMWindow.keyup')
  @DocsEditable
  Stream<KeyboardEvent> get onKeyUp => Element.keyUpEvent.forTarget(this);

  @DomName('DOMWindow.load')
  @DocsEditable
  Stream<Event> get onLoad => Element.loadEvent.forTarget(this);

  @DomName('DOMWindow.message')
  @DocsEditable
  Stream<MessageEvent> get onMessage => messageEvent.forTarget(this);

  @DomName('DOMWindow.mousedown')
  @DocsEditable
  Stream<MouseEvent> get onMouseDown => Element.mouseDownEvent.forTarget(this);

  @DomName('DOMWindow.mousemove')
  @DocsEditable
  Stream<MouseEvent> get onMouseMove => Element.mouseMoveEvent.forTarget(this);

  @DomName('DOMWindow.mouseout')
  @DocsEditable
  Stream<MouseEvent> get onMouseOut => Element.mouseOutEvent.forTarget(this);

  @DomName('DOMWindow.mouseover')
  @DocsEditable
  Stream<MouseEvent> get onMouseOver => Element.mouseOverEvent.forTarget(this);

  @DomName('DOMWindow.mouseup')
  @DocsEditable
  Stream<MouseEvent> get onMouseUp => Element.mouseUpEvent.forTarget(this);

  @DomName('DOMWindow.mousewheel')
  @DocsEditable
  Stream<WheelEvent> get onMouseWheel => Element.mouseWheelEvent.forTarget(this);

  @DomName('DOMWindow.offline')
  @DocsEditable
  Stream<Event> get onOffline => offlineEvent.forTarget(this);

  @DomName('DOMWindow.online')
  @DocsEditable
  Stream<Event> get onOnline => onlineEvent.forTarget(this);

  @DomName('DOMWindow.pagehide')
  @DocsEditable
  Stream<Event> get onPageHide => pageHideEvent.forTarget(this);

  @DomName('DOMWindow.pageshow')
  @DocsEditable
  Stream<Event> get onPageShow => pageShowEvent.forTarget(this);

  @DomName('DOMWindow.popstate')
  @DocsEditable
  Stream<PopStateEvent> get onPopState => popStateEvent.forTarget(this);

  @DomName('DOMWindow.reset')
  @DocsEditable
  Stream<Event> get onReset => Element.resetEvent.forTarget(this);

  @DomName('DOMWindow.resize')
  @DocsEditable
  Stream<Event> get onResize => resizeEvent.forTarget(this);

  @DomName('DOMWindow.scroll')
  @DocsEditable
  Stream<Event> get onScroll => Element.scrollEvent.forTarget(this);

  @DomName('DOMWindow.search')
  @DocsEditable
  Stream<Event> get onSearch => Element.searchEvent.forTarget(this);

  @DomName('DOMWindow.select')
  @DocsEditable
  Stream<Event> get onSelect => Element.selectEvent.forTarget(this);

  @DomName('DOMWindow.storage')
  @DocsEditable
  Stream<StorageEvent> get onStorage => storageEvent.forTarget(this);

  @DomName('DOMWindow.submit')
  @DocsEditable
  Stream<Event> get onSubmit => Element.submitEvent.forTarget(this);

  @DomName('DOMWindow.touchcancel')
  @DocsEditable
  Stream<TouchEvent> get onTouchCancel => Element.touchCancelEvent.forTarget(this);

  @DomName('DOMWindow.touchend')
  @DocsEditable
  Stream<TouchEvent> get onTouchEnd => Element.touchEndEvent.forTarget(this);

  @DomName('DOMWindow.touchmove')
  @DocsEditable
  Stream<TouchEvent> get onTouchMove => Element.touchMoveEvent.forTarget(this);

  @DomName('DOMWindow.touchstart')
  @DocsEditable
  Stream<TouchEvent> get onTouchStart => Element.touchStartEvent.forTarget(this);

  @DomName('DOMWindow.unload')
  @DocsEditable
  Stream<Event> get onUnload => unloadEvent.forTarget(this);

  @DomName('DOMWindow.webkitAnimationEnd')
  @DocsEditable
  Stream<AnimationEvent> get onAnimationEnd => animationEndEvent.forTarget(this);

  @DomName('DOMWindow.webkitAnimationIteration')
  @DocsEditable
  Stream<AnimationEvent> get onAnimationIteration => animationIterationEvent.forTarget(this);

  @DomName('DOMWindow.webkitAnimationStart')
  @DocsEditable
  Stream<AnimationEvent> get onAnimationStart => animationStartEvent.forTarget(this);

  @DomName('DOMWindow.webkitTransitionEnd')
  @DocsEditable
  Stream<TransitionEvent> get onTransitionEnd => Element.transitionEndEvent.forTarget(this);

}

@DocsEditable
@deprecated
class WindowEvents extends Events {
  @DocsEditable
  WindowEvents(EventTarget _ptr) : super(_ptr);

  @DocsEditable
  EventListenerList get contentLoaded => this['DOMContentLoaded'];

  @DocsEditable
  EventListenerList get abort => this['abort'];

  @DocsEditable
  EventListenerList get beforeUnload => this['beforeunload'];

  @DocsEditable
  EventListenerList get blur => this['blur'];

  @DocsEditable
  EventListenerList get canPlay => this['canplay'];

  @DocsEditable
  EventListenerList get canPlayThrough => this['canplaythrough'];

  @DocsEditable
  EventListenerList get change => this['change'];

  @DocsEditable
  EventListenerList get click => this['click'];

  @DocsEditable
  EventListenerList get contextMenu => this['contextmenu'];

  @DocsEditable
  EventListenerList get doubleClick => this['dblclick'];

  @DocsEditable
  EventListenerList get deviceMotion => this['devicemotion'];

  @DocsEditable
  EventListenerList get deviceOrientation => this['deviceorientation'];

  @DocsEditable
  EventListenerList get drag => this['drag'];

  @DocsEditable
  EventListenerList get dragEnd => this['dragend'];

  @DocsEditable
  EventListenerList get dragEnter => this['dragenter'];

  @DocsEditable
  EventListenerList get dragLeave => this['dragleave'];

  @DocsEditable
  EventListenerList get dragOver => this['dragover'];

  @DocsEditable
  EventListenerList get dragStart => this['dragstart'];

  @DocsEditable
  EventListenerList get drop => this['drop'];

  @DocsEditable
  EventListenerList get durationChange => this['durationchange'];

  @DocsEditable
  EventListenerList get emptied => this['emptied'];

  @DocsEditable
  EventListenerList get ended => this['ended'];

  @DocsEditable
  EventListenerList get error => this['error'];

  @DocsEditable
  EventListenerList get focus => this['focus'];

  @DocsEditable
  EventListenerList get hashChange => this['hashchange'];

  @DocsEditable
  EventListenerList get input => this['input'];

  @DocsEditable
  EventListenerList get invalid => this['invalid'];

  @DocsEditable
  EventListenerList get keyDown => this['keydown'];

  @DocsEditable
  EventListenerList get keyPress => this['keypress'];

  @DocsEditable
  EventListenerList get keyUp => this['keyup'];

  @DocsEditable
  EventListenerList get load => this['load'];

  @DocsEditable
  EventListenerList get loadedData => this['loadeddata'];

  @DocsEditable
  EventListenerList get loadedMetadata => this['loadedmetadata'];

  @DocsEditable
  EventListenerList get loadStart => this['loadstart'];

  @DocsEditable
  EventListenerList get message => this['message'];

  @DocsEditable
  EventListenerList get mouseDown => this['mousedown'];

  @DocsEditable
  EventListenerList get mouseMove => this['mousemove'];

  @DocsEditable
  EventListenerList get mouseOut => this['mouseout'];

  @DocsEditable
  EventListenerList get mouseOver => this['mouseover'];

  @DocsEditable
  EventListenerList get mouseUp => this['mouseup'];

  @DocsEditable
  EventListenerList get mouseWheel => this['mousewheel'];

  @DocsEditable
  EventListenerList get offline => this['offline'];

  @DocsEditable
  EventListenerList get online => this['online'];

  @DocsEditable
  EventListenerList get pageHide => this['pagehide'];

  @DocsEditable
  EventListenerList get pageShow => this['pageshow'];

  @DocsEditable
  EventListenerList get pause => this['pause'];

  @DocsEditable
  EventListenerList get play => this['play'];

  @DocsEditable
  EventListenerList get playing => this['playing'];

  @DocsEditable
  EventListenerList get popState => this['popstate'];

  @DocsEditable
  EventListenerList get progress => this['progress'];

  @DocsEditable
  EventListenerList get rateChange => this['ratechange'];

  @DocsEditable
  EventListenerList get reset => this['reset'];

  @DocsEditable
  EventListenerList get resize => this['resize'];

  @DocsEditable
  EventListenerList get scroll => this['scroll'];

  @DocsEditable
  EventListenerList get search => this['search'];

  @DocsEditable
  EventListenerList get seeked => this['seeked'];

  @DocsEditable
  EventListenerList get seeking => this['seeking'];

  @DocsEditable
  EventListenerList get select => this['select'];

  @DocsEditable
  EventListenerList get stalled => this['stalled'];

  @DocsEditable
  EventListenerList get storage => this['storage'];

  @DocsEditable
  EventListenerList get submit => this['submit'];

  @DocsEditable
  EventListenerList get suspend => this['suspend'];

  @DocsEditable
  EventListenerList get timeUpdate => this['timeupdate'];

  @DocsEditable
  EventListenerList get touchCancel => this['touchcancel'];

  @DocsEditable
  EventListenerList get touchEnd => this['touchend'];

  @DocsEditable
  EventListenerList get touchMove => this['touchmove'];

  @DocsEditable
  EventListenerList get touchStart => this['touchstart'];

  @DocsEditable
  EventListenerList get unload => this['unload'];

  @DocsEditable
  EventListenerList get volumeChange => this['volumechange'];

  @DocsEditable
  EventListenerList get waiting => this['waiting'];

  @DocsEditable
  EventListenerList get animationEnd => this['webkitAnimationEnd'];

  @DocsEditable
  EventListenerList get animationIteration => this['webkitAnimationIteration'];

  @DocsEditable
  EventListenerList get animationStart => this['webkitAnimationStart'];

  @DocsEditable
  EventListenerList get transitionEnd => this['webkitTransitionEnd'];
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('Worker')
class Worker extends AbstractWorker {
  Worker.internal() : super.internal();

  @DomName('Worker.message')
  @DocsEditable
  static const EventStreamProvider<MessageEvent> messageEvent = const EventStreamProvider<MessageEvent>('message');

  @DocsEditable
  factory Worker(String scriptUrl) => Worker._create(scriptUrl);
  static Worker _create(String scriptUrl) native "Worker_constructor_Callback";

  @DocsEditable
  @DomName('EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent')
  @deprecated
  WorkerEvents get on =>
    new WorkerEvents(this);

  @DomName('Worker.postMessage')
  @DocsEditable
  void postMessage(/*SerializedScriptValue*/ message, [List messagePorts]) native "Worker_postMessage_Callback";

  @DomName('Worker.terminate')
  @DocsEditable
  void terminate() native "Worker_terminate_Callback";

  @DomName('Worker.message')
  @DocsEditable
  Stream<MessageEvent> get onMessage => messageEvent.forTarget(this);

}

@DocsEditable
@deprecated
class WorkerEvents extends AbstractWorkerEvents {
  @DocsEditable
  WorkerEvents(EventTarget _ptr) : super(_ptr);

  @DocsEditable
  EventListenerList get message => this['message'];
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('WorkerContext')
class WorkerContext extends EventTarget {
  WorkerContext.internal() : super.internal();

  @DomName('WorkerContext.error')
  @DocsEditable
  static const EventStreamProvider<Event> errorEvent = const EventStreamProvider<Event>('error');

  @DocsEditable
  @DomName('EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent')
  @deprecated
  WorkerContextEvents get on =>
    new WorkerContextEvents(this);

  static const int PERSISTENT = 1;

  static const int TEMPORARY = 0;

  @DomName('WorkerContext.indexedDB')
  @DocsEditable
  @SupportedBrowser(SupportedBrowser.CHROME)
  @SupportedBrowser(SupportedBrowser.FIREFOX, '15')
  @SupportedBrowser(SupportedBrowser.IE, '10')
  @Experimental
  IdbFactory get indexedDB native "WorkerContext_indexedDB_Getter";

  @DomName('WorkerContext.location')
  @DocsEditable
  WorkerLocation get location native "WorkerContext_location_Getter";

  @DomName('WorkerContext.navigator')
  @DocsEditable
  WorkerNavigator get navigator native "WorkerContext_navigator_Getter";

  @DomName('WorkerContext.self')
  @DocsEditable
  WorkerContext get self native "WorkerContext_self_Getter";

  @DomName('WorkerContext.webkitNotifications')
  @DocsEditable
  NotificationCenter get webkitNotifications native "WorkerContext_webkitNotifications_Getter";

  @DomName('WorkerContext.addEventListener')
  @DocsEditable
  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]) native "WorkerContext_addEventListener_Callback";

  @DomName('WorkerContext.clearInterval')
  @DocsEditable
  void clearInterval(int handle) native "WorkerContext_clearInterval_Callback";

  @DomName('WorkerContext.clearTimeout')
  @DocsEditable
  void clearTimeout(int handle) native "WorkerContext_clearTimeout_Callback";

  @DomName('WorkerContext.close')
  @DocsEditable
  void close() native "WorkerContext_close_Callback";

  @DomName('WorkerContext.dispatchEvent')
  @DocsEditable
  bool dispatchEvent(Event evt) native "WorkerContext_dispatchEvent_Callback";

  @DomName('WorkerContext.importScripts')
  @DocsEditable
  void importScripts() native "WorkerContext_importScripts_Callback";

  @DomName('WorkerContext.openDatabase')
  @DocsEditable
  @SupportedBrowser(SupportedBrowser.CHROME)
  @SupportedBrowser(SupportedBrowser.SAFARI)
  @Experimental
  Database openDatabase(String name, String version, String displayName, int estimatedSize, [DatabaseCallback creationCallback]) native "WorkerContext_openDatabase_Callback";

  @DomName('WorkerContext.openDatabaseSync')
  @DocsEditable
  @SupportedBrowser(SupportedBrowser.CHROME)
  @SupportedBrowser(SupportedBrowser.SAFARI)
  @Experimental
  DatabaseSync openDatabaseSync(String name, String version, String displayName, int estimatedSize, [DatabaseCallback creationCallback]) native "WorkerContext_openDatabaseSync_Callback";

  @DomName('WorkerContext.removeEventListener')
  @DocsEditable
  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]) native "WorkerContext_removeEventListener_Callback";

  @DomName('WorkerContext.setInterval')
  @DocsEditable
  int setInterval(TimeoutHandler handler, int timeout) native "WorkerContext_setInterval_Callback";

  @DomName('WorkerContext.setTimeout')
  @DocsEditable
  int setTimeout(TimeoutHandler handler, int timeout) native "WorkerContext_setTimeout_Callback";

  @DomName('WorkerContext.webkitRequestFileSystem')
  @DocsEditable
  @SupportedBrowser(SupportedBrowser.CHROME)
  @Experimental
  void requestFileSystem(int type, int size, [FileSystemCallback successCallback, ErrorCallback errorCallback]) native "WorkerContext_webkitRequestFileSystem_Callback";

  @DomName('WorkerContext.webkitRequestFileSystemSync')
  @DocsEditable
  @SupportedBrowser(SupportedBrowser.CHROME)
  @Experimental
  FileSystemSync requestFileSystemSync(int type, int size) native "WorkerContext_webkitRequestFileSystemSync_Callback";

  @DomName('WorkerContext.webkitResolveLocalFileSystemSyncURL')
  @DocsEditable
  @SupportedBrowser(SupportedBrowser.CHROME)
  @Experimental
  EntrySync resolveLocalFileSystemSyncUrl(String url) native "WorkerContext_webkitResolveLocalFileSystemSyncURL_Callback";

  @DomName('WorkerContext.webkitResolveLocalFileSystemURL')
  @DocsEditable
  @SupportedBrowser(SupportedBrowser.CHROME)
  @Experimental
  void resolveLocalFileSystemUrl(String url, EntryCallback successCallback, [ErrorCallback errorCallback]) native "WorkerContext_webkitResolveLocalFileSystemURL_Callback";

  @DomName('WorkerContext.error')
  @DocsEditable
  Stream<Event> get onError => errorEvent.forTarget(this);

}

@DocsEditable
@deprecated
class WorkerContextEvents extends Events {
  @DocsEditable
  WorkerContextEvents(EventTarget _ptr) : super(_ptr);

  @DocsEditable
  EventListenerList get error => this['error'];
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('WorkerLocation')
class WorkerLocation extends NativeFieldWrapperClass1 {
  WorkerLocation.internal();

  @DomName('WorkerLocation.hash')
  @DocsEditable
  String get hash native "WorkerLocation_hash_Getter";

  @DomName('WorkerLocation.host')
  @DocsEditable
  String get host native "WorkerLocation_host_Getter";

  @DomName('WorkerLocation.hostname')
  @DocsEditable
  String get hostname native "WorkerLocation_hostname_Getter";

  @DomName('WorkerLocation.href')
  @DocsEditable
  String get href native "WorkerLocation_href_Getter";

  @DomName('WorkerLocation.pathname')
  @DocsEditable
  String get pathname native "WorkerLocation_pathname_Getter";

  @DomName('WorkerLocation.port')
  @DocsEditable
  String get port native "WorkerLocation_port_Getter";

  @DomName('WorkerLocation.protocol')
  @DocsEditable
  String get protocol native "WorkerLocation_protocol_Getter";

  @DomName('WorkerLocation.search')
  @DocsEditable
  String get search native "WorkerLocation_search_Getter";

  @DomName('WorkerLocation.toString')
  @DocsEditable
  String toString() native "WorkerLocation_toString_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('WorkerNavigator')
class WorkerNavigator extends NativeFieldWrapperClass1 {
  WorkerNavigator.internal();

  @DomName('WorkerNavigator.appName')
  @DocsEditable
  String get appName native "WorkerNavigator_appName_Getter";

  @DomName('WorkerNavigator.appVersion')
  @DocsEditable
  String get appVersion native "WorkerNavigator_appVersion_Getter";

  @DomName('WorkerNavigator.onLine')
  @DocsEditable
  bool get onLine native "WorkerNavigator_onLine_Getter";

  @DomName('WorkerNavigator.platform')
  @DocsEditable
  String get platform native "WorkerNavigator_platform_Getter";

  @DomName('WorkerNavigator.userAgent')
  @DocsEditable
  String get userAgent native "WorkerNavigator_userAgent_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('XPathEvaluator')
class XPathEvaluator extends NativeFieldWrapperClass1 {
  XPathEvaluator.internal();

  @DocsEditable
  factory XPathEvaluator() => XPathEvaluator._create();
  static XPathEvaluator _create() native "XPathEvaluator_constructor_Callback";

  @DomName('XPathEvaluator.createExpression')
  @DocsEditable
  XPathExpression createExpression(String expression, XPathNSResolver resolver) native "XPathEvaluator_createExpression_Callback";

  @DomName('XPathEvaluator.createNSResolver')
  @DocsEditable
  XPathNSResolver createNSResolver(Node nodeResolver) native "XPathEvaluator_createNSResolver_Callback";

  @DomName('XPathEvaluator.evaluate')
  @DocsEditable
  XPathResult evaluate(String expression, Node contextNode, XPathNSResolver resolver, int type, XPathResult inResult) native "XPathEvaluator_evaluate_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('XPathException')
class XPathException extends NativeFieldWrapperClass1 {
  XPathException.internal();

  static const int INVALID_EXPRESSION_ERR = 51;

  static const int TYPE_ERR = 52;

  @DomName('XPathException.code')
  @DocsEditable
  int get code native "XPathException_code_Getter";

  @DomName('XPathException.message')
  @DocsEditable
  String get message native "XPathException_message_Getter";

  @DomName('XPathException.name')
  @DocsEditable
  String get name native "XPathException_name_Getter";

  @DomName('XPathException.toString')
  @DocsEditable
  String toString() native "XPathException_toString_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('XPathExpression')
class XPathExpression extends NativeFieldWrapperClass1 {
  XPathExpression.internal();

  @DomName('XPathExpression.evaluate')
  @DocsEditable
  XPathResult evaluate(Node contextNode, int type, XPathResult inResult) native "XPathExpression_evaluate_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('XPathNSResolver')
class XPathNSResolver extends NativeFieldWrapperClass1 {
  XPathNSResolver.internal();

  @DomName('XPathNSResolver.lookupNamespaceURI')
  @DocsEditable
  String lookupNamespaceUri(String prefix) native "XPathNSResolver_lookupNamespaceURI_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('XPathResult')
class XPathResult extends NativeFieldWrapperClass1 {
  XPathResult.internal();

  static const int ANY_TYPE = 0;

  static const int ANY_UNORDERED_NODE_TYPE = 8;

  static const int BOOLEAN_TYPE = 3;

  static const int FIRST_ORDERED_NODE_TYPE = 9;

  static const int NUMBER_TYPE = 1;

  static const int ORDERED_NODE_ITERATOR_TYPE = 5;

  static const int ORDERED_NODE_SNAPSHOT_TYPE = 7;

  static const int STRING_TYPE = 2;

  static const int UNORDERED_NODE_ITERATOR_TYPE = 4;

  static const int UNORDERED_NODE_SNAPSHOT_TYPE = 6;

  @DomName('XPathResult.booleanValue')
  @DocsEditable
  bool get booleanValue native "XPathResult_booleanValue_Getter";

  @DomName('XPathResult.invalidIteratorState')
  @DocsEditable
  bool get invalidIteratorState native "XPathResult_invalidIteratorState_Getter";

  @DomName('XPathResult.numberValue')
  @DocsEditable
  num get numberValue native "XPathResult_numberValue_Getter";

  @DomName('XPathResult.resultType')
  @DocsEditable
  int get resultType native "XPathResult_resultType_Getter";

  @DomName('XPathResult.singleNodeValue')
  @DocsEditable
  Node get singleNodeValue native "XPathResult_singleNodeValue_Getter";

  @DomName('XPathResult.snapshotLength')
  @DocsEditable
  int get snapshotLength native "XPathResult_snapshotLength_Getter";

  @DomName('XPathResult.stringValue')
  @DocsEditable
  String get stringValue native "XPathResult_stringValue_Getter";

  @DomName('XPathResult.iterateNext')
  @DocsEditable
  Node iterateNext() native "XPathResult_iterateNext_Callback";

  @DomName('XPathResult.snapshotItem')
  @DocsEditable
  Node snapshotItem(int index) native "XPathResult_snapshotItem_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('XMLSerializer')
class XmlSerializer extends NativeFieldWrapperClass1 {
  XmlSerializer.internal();

  @DocsEditable
  factory XmlSerializer() => XmlSerializer._create();
  static XmlSerializer _create() native "XMLSerializer_constructor_Callback";

  @DomName('XMLSerializer.serializeToString')
  @DocsEditable
  String serializeToString(Node node) native "XMLSerializer_serializeToString_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('XSLTProcessor')
@SupportedBrowser(SupportedBrowser.CHROME)
@SupportedBrowser(SupportedBrowser.FIREFOX)
@SupportedBrowser(SupportedBrowser.SAFARI)
class XsltProcessor extends NativeFieldWrapperClass1 {
  XsltProcessor.internal();

  @DocsEditable
  factory XsltProcessor() => XsltProcessor._create();
  static XsltProcessor _create() native "XSLTProcessor_constructor_Callback";

  /// Checks if this type is supported on the current platform.
  static bool get supported => true;

  @DomName('XSLTProcessor.clearParameters')
  @DocsEditable
  void clearParameters() native "XSLTProcessor_clearParameters_Callback";

  @DomName('XSLTProcessor.getParameter')
  @DocsEditable
  String getParameter(String namespaceURI, String localName) native "XSLTProcessor_getParameter_Callback";

  @DomName('XSLTProcessor.importStylesheet')
  @DocsEditable
  void importStylesheet(Node stylesheet) native "XSLTProcessor_importStylesheet_Callback";

  @DomName('XSLTProcessor.removeParameter')
  @DocsEditable
  void removeParameter(String namespaceURI, String localName) native "XSLTProcessor_removeParameter_Callback";

  @DomName('XSLTProcessor.reset')
  @DocsEditable
  void reset() native "XSLTProcessor_reset_Callback";

  @DomName('XSLTProcessor.setParameter')
  @DocsEditable
  void setParameter(String namespaceURI, String localName, String value) native "XSLTProcessor_setParameter_Callback";

  @DomName('XSLTProcessor.transformToDocument')
  @DocsEditable
  Document transformToDocument(Node source) native "XSLTProcessor_transformToDocument_Callback";

  @DomName('XSLTProcessor.transformToFragment')
  @DocsEditable
  DocumentFragment transformToFragment(Node source, Document docVal) native "XSLTProcessor_transformToFragment_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('HTMLAppletElement')
class _AppletElement extends _Element_Merged {
  _AppletElement.internal() : super.internal();

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('HTMLBaseFontElement')
class _BaseFontElement extends _Element_Merged {
  _BaseFontElement.internal() : super.internal();

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('ClientRectList')
class _ClientRectList extends NativeFieldWrapperClass1 implements List<ClientRect> {
  _ClientRectList.internal();

  @DomName('ClientRectList.length')
  @DocsEditable
  int get length native "ClientRectList_length_Getter";

  ClientRect operator[](int index) native "ClientRectList_item_Callback";

  void operator[]=(int index, ClientRect value) {
    throw new UnsupportedError("Cannot assign element of immutable List.");
  }
  // -- start List<ClientRect> mixins.
  // ClientRect is the element type.

  // From Iterable<ClientRect>:

  Iterator<ClientRect> get iterator {
    // Note: NodeLists are not fixed size. And most probably length shouldn't
    // be cached in both iterator _and_ forEach method. For now caching it
    // for consistency.
    return new FixedSizeListIterator<ClientRect>(this);
  }

  dynamic reduce(dynamic initialValue, dynamic combine(dynamic, ClientRect)) {
    return IterableMixinWorkaround.reduce(this, initialValue, combine);
  }

  bool contains(ClientRect element) => IterableMixinWorkaround.contains(this, element);

  void forEach(void f(ClientRect element)) => IterableMixinWorkaround.forEach(this, f);

  String join([String separator]) =>
      IterableMixinWorkaround.joinList(this, separator);

  List mappedBy(f(ClientRect element)) => IterableMixinWorkaround.mappedByList(this, f);

  Iterable<ClientRect> where(bool f(ClientRect element)) =>
      IterableMixinWorkaround.where(this, f);

  bool every(bool f(ClientRect element)) => IterableMixinWorkaround.every(this, f);

  bool any(bool f(ClientRect element)) => IterableMixinWorkaround.any(this, f);

  List<ClientRect> toList() => new List<ClientRect>.from(this);
  Set<ClientRect> toSet() => new Set<ClientRect>.from(this);

  bool get isEmpty => this.length == 0;

  List<ClientRect> take(int n) => IterableMixinWorkaround.takeList(this, n);

  Iterable<ClientRect> takeWhile(bool test(ClientRect value)) {
    return IterableMixinWorkaround.takeWhile(this, test);
  }

  List<ClientRect> skip(int n) => IterableMixinWorkaround.skipList(this, n);

  Iterable<ClientRect> skipWhile(bool test(ClientRect value)) {
    return IterableMixinWorkaround.skipWhile(this, test);
  }

  ClientRect firstMatching(bool test(ClientRect value), { ClientRect orElse() }) {
    return IterableMixinWorkaround.firstMatching(this, test, orElse);
  }

  ClientRect lastMatching(bool test(ClientRect value), {ClientRect orElse()}) {
    return IterableMixinWorkaround.lastMatchingInList(this, test, orElse);
  }

  ClientRect singleMatching(bool test(ClientRect value)) {
    return IterableMixinWorkaround.singleMatching(this, test);
  }

  ClientRect elementAt(int index) {
    return this[index];
  }

  // From Collection<ClientRect>:

  void add(ClientRect value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addLast(ClientRect value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addAll(Iterable<ClientRect> iterable) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  // From List<ClientRect>:
  void set length(int value) {
    throw new UnsupportedError("Cannot resize immutable List.");
  }

  void clear() {
    throw new UnsupportedError("Cannot clear immutable List.");
  }

  List<ClientRect> get reversed =>
      new ReversedListView<ClientRect>(this, 0, null);

  void sort([int compare(ClientRect a, ClientRect b)]) {
    throw new UnsupportedError("Cannot sort immutable List.");
  }

  int indexOf(ClientRect element, [int start = 0]) =>
      Lists.indexOf(this, element, start, this.length);

  int lastIndexOf(ClientRect element, [int start]) {
    if (start == null) start = length - 1;
    return Lists.lastIndexOf(this, element, start);
  }

  ClientRect get first {
    if (this.length > 0) return this[0];
    throw new StateError("No elements");
  }

  ClientRect get last {
    if (this.length > 0) return this[this.length - 1];
    throw new StateError("No elements");
  }

  ClientRect get single {
    if (length == 1) return this[0];
    if (length == 0) throw new StateError("No elements");
    throw new StateError("More than one element");
  }

  ClientRect min([int compare(ClientRect a, ClientRect b)]) =>
      IterableMixinWorkaround.min(this, compare);

  ClientRect max([int compare(ClientRect a, ClientRect b)]) =>
      IterableMixinWorkaround.max(this, compare);

  ClientRect removeAt(int pos) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  ClientRect removeLast() {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void remove(Object object) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void removeAll(Iterable elements) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void retainAll(Iterable elements) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void removeMatching(bool test(ClientRect element)) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void retainMatching(bool test(ClientRect element)) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void setRange(int start, int rangeLength, List<ClientRect> from, [int startFrom]) {
    throw new UnsupportedError("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int rangeLength) {
    throw new UnsupportedError("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int rangeLength, [ClientRect initialValue]) {
    throw new UnsupportedError("Cannot insertRange on immutable List.");
  }

  List<ClientRect> getRange(int start, int rangeLength) =>
      Lists.getRange(this, start, rangeLength, <ClientRect>[]);

  // -- end List<ClientRect> mixins.

  @DomName('ClientRectList.item')
  @DocsEditable
  ClientRect item(int index) native "ClientRectList_item_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('CSSRuleList')
class _CssRuleList extends NativeFieldWrapperClass1 implements List<CssRule> {
  _CssRuleList.internal();

  @DomName('CSSRuleList.length')
  @DocsEditable
  int get length native "CSSRuleList_length_Getter";

  CssRule operator[](int index) native "CSSRuleList_item_Callback";

  void operator[]=(int index, CssRule value) {
    throw new UnsupportedError("Cannot assign element of immutable List.");
  }
  // -- start List<CssRule> mixins.
  // CssRule is the element type.

  // From Iterable<CssRule>:

  Iterator<CssRule> get iterator {
    // Note: NodeLists are not fixed size. And most probably length shouldn't
    // be cached in both iterator _and_ forEach method. For now caching it
    // for consistency.
    return new FixedSizeListIterator<CssRule>(this);
  }

  dynamic reduce(dynamic initialValue, dynamic combine(dynamic, CssRule)) {
    return IterableMixinWorkaround.reduce(this, initialValue, combine);
  }

  bool contains(CssRule element) => IterableMixinWorkaround.contains(this, element);

  void forEach(void f(CssRule element)) => IterableMixinWorkaround.forEach(this, f);

  String join([String separator]) =>
      IterableMixinWorkaround.joinList(this, separator);

  List mappedBy(f(CssRule element)) => IterableMixinWorkaround.mappedByList(this, f);

  Iterable<CssRule> where(bool f(CssRule element)) =>
      IterableMixinWorkaround.where(this, f);

  bool every(bool f(CssRule element)) => IterableMixinWorkaround.every(this, f);

  bool any(bool f(CssRule element)) => IterableMixinWorkaround.any(this, f);

  List<CssRule> toList() => new List<CssRule>.from(this);
  Set<CssRule> toSet() => new Set<CssRule>.from(this);

  bool get isEmpty => this.length == 0;

  List<CssRule> take(int n) => IterableMixinWorkaround.takeList(this, n);

  Iterable<CssRule> takeWhile(bool test(CssRule value)) {
    return IterableMixinWorkaround.takeWhile(this, test);
  }

  List<CssRule> skip(int n) => IterableMixinWorkaround.skipList(this, n);

  Iterable<CssRule> skipWhile(bool test(CssRule value)) {
    return IterableMixinWorkaround.skipWhile(this, test);
  }

  CssRule firstMatching(bool test(CssRule value), { CssRule orElse() }) {
    return IterableMixinWorkaround.firstMatching(this, test, orElse);
  }

  CssRule lastMatching(bool test(CssRule value), {CssRule orElse()}) {
    return IterableMixinWorkaround.lastMatchingInList(this, test, orElse);
  }

  CssRule singleMatching(bool test(CssRule value)) {
    return IterableMixinWorkaround.singleMatching(this, test);
  }

  CssRule elementAt(int index) {
    return this[index];
  }

  // From Collection<CssRule>:

  void add(CssRule value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addLast(CssRule value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addAll(Iterable<CssRule> iterable) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  // From List<CssRule>:
  void set length(int value) {
    throw new UnsupportedError("Cannot resize immutable List.");
  }

  void clear() {
    throw new UnsupportedError("Cannot clear immutable List.");
  }

  List<CssRule> get reversed =>
      new ReversedListView<CssRule>(this, 0, null);

  void sort([int compare(CssRule a, CssRule b)]) {
    throw new UnsupportedError("Cannot sort immutable List.");
  }

  int indexOf(CssRule element, [int start = 0]) =>
      Lists.indexOf(this, element, start, this.length);

  int lastIndexOf(CssRule element, [int start]) {
    if (start == null) start = length - 1;
    return Lists.lastIndexOf(this, element, start);
  }

  CssRule get first {
    if (this.length > 0) return this[0];
    throw new StateError("No elements");
  }

  CssRule get last {
    if (this.length > 0) return this[this.length - 1];
    throw new StateError("No elements");
  }

  CssRule get single {
    if (length == 1) return this[0];
    if (length == 0) throw new StateError("No elements");
    throw new StateError("More than one element");
  }

  CssRule min([int compare(CssRule a, CssRule b)]) =>
      IterableMixinWorkaround.min(this, compare);

  CssRule max([int compare(CssRule a, CssRule b)]) =>
      IterableMixinWorkaround.max(this, compare);

  CssRule removeAt(int pos) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  CssRule removeLast() {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void remove(Object object) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void removeAll(Iterable elements) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void retainAll(Iterable elements) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void removeMatching(bool test(CssRule element)) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void retainMatching(bool test(CssRule element)) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void setRange(int start, int rangeLength, List<CssRule> from, [int startFrom]) {
    throw new UnsupportedError("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int rangeLength) {
    throw new UnsupportedError("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int rangeLength, [CssRule initialValue]) {
    throw new UnsupportedError("Cannot insertRange on immutable List.");
  }

  List<CssRule> getRange(int start, int rangeLength) =>
      Lists.getRange(this, start, rangeLength, <CssRule>[]);

  // -- end List<CssRule> mixins.

  @DomName('CSSRuleList.item')
  @DocsEditable
  CssRule item(int index) native "CSSRuleList_item_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('CSSValueList')
class _CssValueList extends CssValue implements List<CssValue> {
  _CssValueList.internal() : super.internal();

  @DomName('CSSValueList.length')
  @DocsEditable
  int get length native "CSSValueList_length_Getter";

  CssValue operator[](int index) native "CSSValueList_item_Callback";

  void operator[]=(int index, CssValue value) {
    throw new UnsupportedError("Cannot assign element of immutable List.");
  }
  // -- start List<CssValue> mixins.
  // CssValue is the element type.

  // From Iterable<CssValue>:

  Iterator<CssValue> get iterator {
    // Note: NodeLists are not fixed size. And most probably length shouldn't
    // be cached in both iterator _and_ forEach method. For now caching it
    // for consistency.
    return new FixedSizeListIterator<CssValue>(this);
  }

  dynamic reduce(dynamic initialValue, dynamic combine(dynamic, CssValue)) {
    return IterableMixinWorkaround.reduce(this, initialValue, combine);
  }

  bool contains(CssValue element) => IterableMixinWorkaround.contains(this, element);

  void forEach(void f(CssValue element)) => IterableMixinWorkaround.forEach(this, f);

  String join([String separator]) =>
      IterableMixinWorkaround.joinList(this, separator);

  List mappedBy(f(CssValue element)) => IterableMixinWorkaround.mappedByList(this, f);

  Iterable<CssValue> where(bool f(CssValue element)) =>
      IterableMixinWorkaround.where(this, f);

  bool every(bool f(CssValue element)) => IterableMixinWorkaround.every(this, f);

  bool any(bool f(CssValue element)) => IterableMixinWorkaround.any(this, f);

  List<CssValue> toList() => new List<CssValue>.from(this);
  Set<CssValue> toSet() => new Set<CssValue>.from(this);

  bool get isEmpty => this.length == 0;

  List<CssValue> take(int n) => IterableMixinWorkaround.takeList(this, n);

  Iterable<CssValue> takeWhile(bool test(CssValue value)) {
    return IterableMixinWorkaround.takeWhile(this, test);
  }

  List<CssValue> skip(int n) => IterableMixinWorkaround.skipList(this, n);

  Iterable<CssValue> skipWhile(bool test(CssValue value)) {
    return IterableMixinWorkaround.skipWhile(this, test);
  }

  CssValue firstMatching(bool test(CssValue value), { CssValue orElse() }) {
    return IterableMixinWorkaround.firstMatching(this, test, orElse);
  }

  CssValue lastMatching(bool test(CssValue value), {CssValue orElse()}) {
    return IterableMixinWorkaround.lastMatchingInList(this, test, orElse);
  }

  CssValue singleMatching(bool test(CssValue value)) {
    return IterableMixinWorkaround.singleMatching(this, test);
  }

  CssValue elementAt(int index) {
    return this[index];
  }

  // From Collection<CssValue>:

  void add(CssValue value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addLast(CssValue value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addAll(Iterable<CssValue> iterable) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  // From List<CssValue>:
  void set length(int value) {
    throw new UnsupportedError("Cannot resize immutable List.");
  }

  void clear() {
    throw new UnsupportedError("Cannot clear immutable List.");
  }

  List<CssValue> get reversed =>
      new ReversedListView<CssValue>(this, 0, null);

  void sort([int compare(CssValue a, CssValue b)]) {
    throw new UnsupportedError("Cannot sort immutable List.");
  }

  int indexOf(CssValue element, [int start = 0]) =>
      Lists.indexOf(this, element, start, this.length);

  int lastIndexOf(CssValue element, [int start]) {
    if (start == null) start = length - 1;
    return Lists.lastIndexOf(this, element, start);
  }

  CssValue get first {
    if (this.length > 0) return this[0];
    throw new StateError("No elements");
  }

  CssValue get last {
    if (this.length > 0) return this[this.length - 1];
    throw new StateError("No elements");
  }

  CssValue get single {
    if (length == 1) return this[0];
    if (length == 0) throw new StateError("No elements");
    throw new StateError("More than one element");
  }

  CssValue min([int compare(CssValue a, CssValue b)]) =>
      IterableMixinWorkaround.min(this, compare);

  CssValue max([int compare(CssValue a, CssValue b)]) =>
      IterableMixinWorkaround.max(this, compare);

  CssValue removeAt(int pos) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  CssValue removeLast() {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void remove(Object object) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void removeAll(Iterable elements) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void retainAll(Iterable elements) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void removeMatching(bool test(CssValue element)) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void retainMatching(bool test(CssValue element)) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void setRange(int start, int rangeLength, List<CssValue> from, [int startFrom]) {
    throw new UnsupportedError("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int rangeLength) {
    throw new UnsupportedError("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int rangeLength, [CssValue initialValue]) {
    throw new UnsupportedError("Cannot insertRange on immutable List.");
  }

  List<CssValue> getRange(int start, int rangeLength) =>
      Lists.getRange(this, start, rangeLength, <CssValue>[]);

  // -- end List<CssValue> mixins.

  @DomName('CSSValueList.item')
  @DocsEditable
  CssValue item(int index) native "CSSValueList_item_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('HTMLDirectoryElement')
class _DirectoryElement extends _Element_Merged {
  _DirectoryElement.internal() : super.internal();

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('HTMLElement')
class _Element_Merged extends Element {
  _Element_Merged.internal() : super.internal();

  @DomName('HTMLElement.children')
  @DocsEditable
  HtmlCollection get $dom_children native "HTMLElement_children_Getter";

  @DomName('HTMLElement.contentEditable')
  @DocsEditable
  String get contentEditable native "HTMLElement_contentEditable_Getter";

  @DomName('HTMLElement.contentEditable')
  @DocsEditable
  void set contentEditable(String value) native "HTMLElement_contentEditable_Setter";

  @DomName('HTMLElement.dir')
  @DocsEditable
  String get dir native "HTMLElement_dir_Getter";

  @DomName('HTMLElement.dir')
  @DocsEditable
  void set dir(String value) native "HTMLElement_dir_Setter";

  @DomName('HTMLElement.draggable')
  @DocsEditable
  bool get draggable native "HTMLElement_draggable_Getter";

  @DomName('HTMLElement.draggable')
  @DocsEditable
  void set draggable(bool value) native "HTMLElement_draggable_Setter";

  @DomName('HTMLElement.hidden')
  @DocsEditable
  bool get hidden native "HTMLElement_hidden_Getter";

  @DomName('HTMLElement.hidden')
  @DocsEditable
  void set hidden(bool value) native "HTMLElement_hidden_Setter";

  @DomName('HTMLElement.id')
  @DocsEditable
  String get id native "HTMLElement_id_Getter";

  @DomName('HTMLElement.id')
  @DocsEditable
  void set id(String value) native "HTMLElement_id_Setter";

  @DomName('HTMLElement.innerHTML')
  @DocsEditable
  String get innerHtml native "HTMLElement_innerHTML_Getter";

  @DomName('HTMLElement.innerHTML')
  @DocsEditable
  void set innerHtml(String value) native "HTMLElement_innerHTML_Setter";

  @DomName('HTMLElement.isContentEditable')
  @DocsEditable
  bool get isContentEditable native "HTMLElement_isContentEditable_Getter";

  @DomName('HTMLElement.lang')
  @DocsEditable
  String get lang native "HTMLElement_lang_Getter";

  @DomName('HTMLElement.lang')
  @DocsEditable
  void set lang(String value) native "HTMLElement_lang_Setter";

  @DomName('HTMLElement.outerHTML')
  @DocsEditable
  String get outerHtml native "HTMLElement_outerHTML_Getter";

  @DomName('HTMLElement.spellcheck')
  @DocsEditable
  bool get spellcheck native "HTMLElement_spellcheck_Getter";

  @DomName('HTMLElement.spellcheck')
  @DocsEditable
  void set spellcheck(bool value) native "HTMLElement_spellcheck_Setter";

  @DomName('HTMLElement.tabIndex')
  @DocsEditable
  int get tabIndex native "HTMLElement_tabIndex_Getter";

  @DomName('HTMLElement.tabIndex')
  @DocsEditable
  void set tabIndex(int value) native "HTMLElement_tabIndex_Setter";

  @DomName('HTMLElement.title')
  @DocsEditable
  String get title native "HTMLElement_title_Getter";

  @DomName('HTMLElement.title')
  @DocsEditable
  void set title(String value) native "HTMLElement_title_Setter";

  @DomName('HTMLElement.translate')
  @DocsEditable
  bool get translate native "HTMLElement_translate_Getter";

  @DomName('HTMLElement.translate')
  @DocsEditable
  void set translate(bool value) native "HTMLElement_translate_Setter";

  @DomName('HTMLElement.webkitdropzone')
  @DocsEditable
  String get webkitdropzone native "HTMLElement_webkitdropzone_Getter";

  @DomName('HTMLElement.webkitdropzone')
  @DocsEditable
  void set webkitdropzone(String value) native "HTMLElement_webkitdropzone_Setter";

  @DomName('HTMLElement.click')
  @DocsEditable
  void click() native "HTMLElement_click_Callback";

  @DomName('HTMLElement.insertAdjacentElement')
  @DocsEditable
  Element insertAdjacentElement(String where, Element element) native "HTMLElement_insertAdjacentElement_Callback";

  @DomName('HTMLElement.insertAdjacentHTML')
  @DocsEditable
  void insertAdjacentHtml(String where, String html) native "HTMLElement_insertAdjacentHTML_Callback";

  @DomName('HTMLElement.insertAdjacentText')
  @DocsEditable
  void insertAdjacentText(String where, String text) native "HTMLElement_insertAdjacentText_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('EntryArray')
class _EntryArray extends NativeFieldWrapperClass1 implements List<Entry> {
  _EntryArray.internal();

  @DomName('EntryArray.length')
  @DocsEditable
  int get length native "EntryArray_length_Getter";

  Entry operator[](int index) native "EntryArray_item_Callback";

  void operator[]=(int index, Entry value) {
    throw new UnsupportedError("Cannot assign element of immutable List.");
  }
  // -- start List<Entry> mixins.
  // Entry is the element type.

  // From Iterable<Entry>:

  Iterator<Entry> get iterator {
    // Note: NodeLists are not fixed size. And most probably length shouldn't
    // be cached in both iterator _and_ forEach method. For now caching it
    // for consistency.
    return new FixedSizeListIterator<Entry>(this);
  }

  dynamic reduce(dynamic initialValue, dynamic combine(dynamic, Entry)) {
    return IterableMixinWorkaround.reduce(this, initialValue, combine);
  }

  bool contains(Entry element) => IterableMixinWorkaround.contains(this, element);

  void forEach(void f(Entry element)) => IterableMixinWorkaround.forEach(this, f);

  String join([String separator]) =>
      IterableMixinWorkaround.joinList(this, separator);

  List mappedBy(f(Entry element)) => IterableMixinWorkaround.mappedByList(this, f);

  Iterable<Entry> where(bool f(Entry element)) =>
      IterableMixinWorkaround.where(this, f);

  bool every(bool f(Entry element)) => IterableMixinWorkaround.every(this, f);

  bool any(bool f(Entry element)) => IterableMixinWorkaround.any(this, f);

  List<Entry> toList() => new List<Entry>.from(this);
  Set<Entry> toSet() => new Set<Entry>.from(this);

  bool get isEmpty => this.length == 0;

  List<Entry> take(int n) => IterableMixinWorkaround.takeList(this, n);

  Iterable<Entry> takeWhile(bool test(Entry value)) {
    return IterableMixinWorkaround.takeWhile(this, test);
  }

  List<Entry> skip(int n) => IterableMixinWorkaround.skipList(this, n);

  Iterable<Entry> skipWhile(bool test(Entry value)) {
    return IterableMixinWorkaround.skipWhile(this, test);
  }

  Entry firstMatching(bool test(Entry value), { Entry orElse() }) {
    return IterableMixinWorkaround.firstMatching(this, test, orElse);
  }

  Entry lastMatching(bool test(Entry value), {Entry orElse()}) {
    return IterableMixinWorkaround.lastMatchingInList(this, test, orElse);
  }

  Entry singleMatching(bool test(Entry value)) {
    return IterableMixinWorkaround.singleMatching(this, test);
  }

  Entry elementAt(int index) {
    return this[index];
  }

  // From Collection<Entry>:

  void add(Entry value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addLast(Entry value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addAll(Iterable<Entry> iterable) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  // From List<Entry>:
  void set length(int value) {
    throw new UnsupportedError("Cannot resize immutable List.");
  }

  void clear() {
    throw new UnsupportedError("Cannot clear immutable List.");
  }

  List<Entry> get reversed =>
      new ReversedListView<Entry>(this, 0, null);

  void sort([int compare(Entry a, Entry b)]) {
    throw new UnsupportedError("Cannot sort immutable List.");
  }

  int indexOf(Entry element, [int start = 0]) =>
      Lists.indexOf(this, element, start, this.length);

  int lastIndexOf(Entry element, [int start]) {
    if (start == null) start = length - 1;
    return Lists.lastIndexOf(this, element, start);
  }

  Entry get first {
    if (this.length > 0) return this[0];
    throw new StateError("No elements");
  }

  Entry get last {
    if (this.length > 0) return this[this.length - 1];
    throw new StateError("No elements");
  }

  Entry get single {
    if (length == 1) return this[0];
    if (length == 0) throw new StateError("No elements");
    throw new StateError("More than one element");
  }

  Entry min([int compare(Entry a, Entry b)]) =>
      IterableMixinWorkaround.min(this, compare);

  Entry max([int compare(Entry a, Entry b)]) =>
      IterableMixinWorkaround.max(this, compare);

  Entry removeAt(int pos) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  Entry removeLast() {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void remove(Object object) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void removeAll(Iterable elements) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void retainAll(Iterable elements) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void removeMatching(bool test(Entry element)) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void retainMatching(bool test(Entry element)) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void setRange(int start, int rangeLength, List<Entry> from, [int startFrom]) {
    throw new UnsupportedError("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int rangeLength) {
    throw new UnsupportedError("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int rangeLength, [Entry initialValue]) {
    throw new UnsupportedError("Cannot insertRange on immutable List.");
  }

  List<Entry> getRange(int start, int rangeLength) =>
      Lists.getRange(this, start, rangeLength, <Entry>[]);

  // -- end List<Entry> mixins.

  @DomName('EntryArray.item')
  @DocsEditable
  Entry item(int index) native "EntryArray_item_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('EntryArraySync')
class _EntryArraySync extends NativeFieldWrapperClass1 implements List<EntrySync> {
  _EntryArraySync.internal();

  @DomName('EntryArraySync.length')
  @DocsEditable
  int get length native "EntryArraySync_length_Getter";

  EntrySync operator[](int index) native "EntryArraySync_item_Callback";

  void operator[]=(int index, EntrySync value) {
    throw new UnsupportedError("Cannot assign element of immutable List.");
  }
  // -- start List<EntrySync> mixins.
  // EntrySync is the element type.

  // From Iterable<EntrySync>:

  Iterator<EntrySync> get iterator {
    // Note: NodeLists are not fixed size. And most probably length shouldn't
    // be cached in both iterator _and_ forEach method. For now caching it
    // for consistency.
    return new FixedSizeListIterator<EntrySync>(this);
  }

  dynamic reduce(dynamic initialValue, dynamic combine(dynamic, EntrySync)) {
    return IterableMixinWorkaround.reduce(this, initialValue, combine);
  }

  bool contains(EntrySync element) => IterableMixinWorkaround.contains(this, element);

  void forEach(void f(EntrySync element)) => IterableMixinWorkaround.forEach(this, f);

  String join([String separator]) =>
      IterableMixinWorkaround.joinList(this, separator);

  List mappedBy(f(EntrySync element)) => IterableMixinWorkaround.mappedByList(this, f);

  Iterable<EntrySync> where(bool f(EntrySync element)) =>
      IterableMixinWorkaround.where(this, f);

  bool every(bool f(EntrySync element)) => IterableMixinWorkaround.every(this, f);

  bool any(bool f(EntrySync element)) => IterableMixinWorkaround.any(this, f);

  List<EntrySync> toList() => new List<EntrySync>.from(this);
  Set<EntrySync> toSet() => new Set<EntrySync>.from(this);

  bool get isEmpty => this.length == 0;

  List<EntrySync> take(int n) => IterableMixinWorkaround.takeList(this, n);

  Iterable<EntrySync> takeWhile(bool test(EntrySync value)) {
    return IterableMixinWorkaround.takeWhile(this, test);
  }

  List<EntrySync> skip(int n) => IterableMixinWorkaround.skipList(this, n);

  Iterable<EntrySync> skipWhile(bool test(EntrySync value)) {
    return IterableMixinWorkaround.skipWhile(this, test);
  }

  EntrySync firstMatching(bool test(EntrySync value), { EntrySync orElse() }) {
    return IterableMixinWorkaround.firstMatching(this, test, orElse);
  }

  EntrySync lastMatching(bool test(EntrySync value), {EntrySync orElse()}) {
    return IterableMixinWorkaround.lastMatchingInList(this, test, orElse);
  }

  EntrySync singleMatching(bool test(EntrySync value)) {
    return IterableMixinWorkaround.singleMatching(this, test);
  }

  EntrySync elementAt(int index) {
    return this[index];
  }

  // From Collection<EntrySync>:

  void add(EntrySync value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addLast(EntrySync value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addAll(Iterable<EntrySync> iterable) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  // From List<EntrySync>:
  void set length(int value) {
    throw new UnsupportedError("Cannot resize immutable List.");
  }

  void clear() {
    throw new UnsupportedError("Cannot clear immutable List.");
  }

  List<EntrySync> get reversed =>
      new ReversedListView<EntrySync>(this, 0, null);

  void sort([int compare(EntrySync a, EntrySync b)]) {
    throw new UnsupportedError("Cannot sort immutable List.");
  }

  int indexOf(EntrySync element, [int start = 0]) =>
      Lists.indexOf(this, element, start, this.length);

  int lastIndexOf(EntrySync element, [int start]) {
    if (start == null) start = length - 1;
    return Lists.lastIndexOf(this, element, start);
  }

  EntrySync get first {
    if (this.length > 0) return this[0];
    throw new StateError("No elements");
  }

  EntrySync get last {
    if (this.length > 0) return this[this.length - 1];
    throw new StateError("No elements");
  }

  EntrySync get single {
    if (length == 1) return this[0];
    if (length == 0) throw new StateError("No elements");
    throw new StateError("More than one element");
  }

  EntrySync min([int compare(EntrySync a, EntrySync b)]) =>
      IterableMixinWorkaround.min(this, compare);

  EntrySync max([int compare(EntrySync a, EntrySync b)]) =>
      IterableMixinWorkaround.max(this, compare);

  EntrySync removeAt(int pos) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  EntrySync removeLast() {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void remove(Object object) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void removeAll(Iterable elements) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void retainAll(Iterable elements) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void removeMatching(bool test(EntrySync element)) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void retainMatching(bool test(EntrySync element)) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void setRange(int start, int rangeLength, List<EntrySync> from, [int startFrom]) {
    throw new UnsupportedError("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int rangeLength) {
    throw new UnsupportedError("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int rangeLength, [EntrySync initialValue]) {
    throw new UnsupportedError("Cannot insertRange on immutable List.");
  }

  List<EntrySync> getRange(int start, int rangeLength) =>
      Lists.getRange(this, start, rangeLength, <EntrySync>[]);

  // -- end List<EntrySync> mixins.

  @DomName('EntryArraySync.item')
  @DocsEditable
  EntrySync item(int index) native "EntryArraySync_item_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('HTMLFontElement')
class _FontElement extends _Element_Merged {
  _FontElement.internal() : super.internal();

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('HTMLFrameElement')
class _FrameElement extends _Element_Merged {
  _FrameElement.internal() : super.internal();

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('HTMLFrameSetElement')
class _FrameSetElement extends _Element_Merged {
  _FrameSetElement.internal() : super.internal();

  @DocsEditable
  @DomName('EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent')
  @deprecated
  _FrameSetElementEvents get on =>
    new _FrameSetElementEvents(this);

}

@DocsEditable
@deprecated
class _FrameSetElementEvents extends ElementEvents {
  @DocsEditable
  _FrameSetElementEvents(EventTarget _ptr) : super(_ptr);

  @DocsEditable
  EventListenerList get beforeUnload => this['beforeunload'];

  @DocsEditable
  EventListenerList get blur => this['blur'];

  @DocsEditable
  EventListenerList get error => this['error'];

  @DocsEditable
  EventListenerList get focus => this['focus'];

  @DocsEditable
  EventListenerList get hashChange => this['hashchange'];

  @DocsEditable
  EventListenerList get load => this['load'];

  @DocsEditable
  EventListenerList get message => this['message'];

  @DocsEditable
  EventListenerList get offline => this['offline'];

  @DocsEditable
  EventListenerList get online => this['online'];

  @DocsEditable
  EventListenerList get popState => this['popstate'];

  @DocsEditable
  EventListenerList get resize => this['resize'];

  @DocsEditable
  EventListenerList get storage => this['storage'];

  @DocsEditable
  EventListenerList get unload => this['unload'];
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('GamepadList')
class _GamepadList extends NativeFieldWrapperClass1 implements List<Gamepad> {
  _GamepadList.internal();

  @DomName('GamepadList.length')
  @DocsEditable
  int get length native "GamepadList_length_Getter";

  Gamepad operator[](int index) native "GamepadList_item_Callback";

  void operator[]=(int index, Gamepad value) {
    throw new UnsupportedError("Cannot assign element of immutable List.");
  }
  // -- start List<Gamepad> mixins.
  // Gamepad is the element type.

  // From Iterable<Gamepad>:

  Iterator<Gamepad> get iterator {
    // Note: NodeLists are not fixed size. And most probably length shouldn't
    // be cached in both iterator _and_ forEach method. For now caching it
    // for consistency.
    return new FixedSizeListIterator<Gamepad>(this);
  }

  dynamic reduce(dynamic initialValue, dynamic combine(dynamic, Gamepad)) {
    return IterableMixinWorkaround.reduce(this, initialValue, combine);
  }

  bool contains(Gamepad element) => IterableMixinWorkaround.contains(this, element);

  void forEach(void f(Gamepad element)) => IterableMixinWorkaround.forEach(this, f);

  String join([String separator]) =>
      IterableMixinWorkaround.joinList(this, separator);

  List mappedBy(f(Gamepad element)) => IterableMixinWorkaround.mappedByList(this, f);

  Iterable<Gamepad> where(bool f(Gamepad element)) =>
      IterableMixinWorkaround.where(this, f);

  bool every(bool f(Gamepad element)) => IterableMixinWorkaround.every(this, f);

  bool any(bool f(Gamepad element)) => IterableMixinWorkaround.any(this, f);

  List<Gamepad> toList() => new List<Gamepad>.from(this);
  Set<Gamepad> toSet() => new Set<Gamepad>.from(this);

  bool get isEmpty => this.length == 0;

  List<Gamepad> take(int n) => IterableMixinWorkaround.takeList(this, n);

  Iterable<Gamepad> takeWhile(bool test(Gamepad value)) {
    return IterableMixinWorkaround.takeWhile(this, test);
  }

  List<Gamepad> skip(int n) => IterableMixinWorkaround.skipList(this, n);

  Iterable<Gamepad> skipWhile(bool test(Gamepad value)) {
    return IterableMixinWorkaround.skipWhile(this, test);
  }

  Gamepad firstMatching(bool test(Gamepad value), { Gamepad orElse() }) {
    return IterableMixinWorkaround.firstMatching(this, test, orElse);
  }

  Gamepad lastMatching(bool test(Gamepad value), {Gamepad orElse()}) {
    return IterableMixinWorkaround.lastMatchingInList(this, test, orElse);
  }

  Gamepad singleMatching(bool test(Gamepad value)) {
    return IterableMixinWorkaround.singleMatching(this, test);
  }

  Gamepad elementAt(int index) {
    return this[index];
  }

  // From Collection<Gamepad>:

  void add(Gamepad value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addLast(Gamepad value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addAll(Iterable<Gamepad> iterable) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  // From List<Gamepad>:
  void set length(int value) {
    throw new UnsupportedError("Cannot resize immutable List.");
  }

  void clear() {
    throw new UnsupportedError("Cannot clear immutable List.");
  }

  List<Gamepad> get reversed =>
      new ReversedListView<Gamepad>(this, 0, null);

  void sort([int compare(Gamepad a, Gamepad b)]) {
    throw new UnsupportedError("Cannot sort immutable List.");
  }

  int indexOf(Gamepad element, [int start = 0]) =>
      Lists.indexOf(this, element, start, this.length);

  int lastIndexOf(Gamepad element, [int start]) {
    if (start == null) start = length - 1;
    return Lists.lastIndexOf(this, element, start);
  }

  Gamepad get first {
    if (this.length > 0) return this[0];
    throw new StateError("No elements");
  }

  Gamepad get last {
    if (this.length > 0) return this[this.length - 1];
    throw new StateError("No elements");
  }

  Gamepad get single {
    if (length == 1) return this[0];
    if (length == 0) throw new StateError("No elements");
    throw new StateError("More than one element");
  }

  Gamepad min([int compare(Gamepad a, Gamepad b)]) =>
      IterableMixinWorkaround.min(this, compare);

  Gamepad max([int compare(Gamepad a, Gamepad b)]) =>
      IterableMixinWorkaround.max(this, compare);

  Gamepad removeAt(int pos) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  Gamepad removeLast() {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void remove(Object object) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void removeAll(Iterable elements) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void retainAll(Iterable elements) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void removeMatching(bool test(Gamepad element)) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void retainMatching(bool test(Gamepad element)) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void setRange(int start, int rangeLength, List<Gamepad> from, [int startFrom]) {
    throw new UnsupportedError("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int rangeLength) {
    throw new UnsupportedError("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int rangeLength, [Gamepad initialValue]) {
    throw new UnsupportedError("Cannot insertRange on immutable List.");
  }

  List<Gamepad> getRange(int start, int rangeLength) =>
      Lists.getRange(this, start, rangeLength, <Gamepad>[]);

  // -- end List<Gamepad> mixins.

  @DomName('GamepadList.item')
  @DocsEditable
  Gamepad item(int index) native "GamepadList_item_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('HTMLMarqueeElement')
class _MarqueeElement extends _Element_Merged {
  _MarqueeElement.internal() : super.internal();

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('MediaStreamList')
class _MediaStreamList extends NativeFieldWrapperClass1 implements List<MediaStream> {
  _MediaStreamList.internal();

  @DomName('MediaStreamList.length')
  @DocsEditable
  int get length native "MediaStreamList_length_Getter";

  MediaStream operator[](int index) native "MediaStreamList_item_Callback";

  void operator[]=(int index, MediaStream value) {
    throw new UnsupportedError("Cannot assign element of immutable List.");
  }
  // -- start List<MediaStream> mixins.
  // MediaStream is the element type.

  // From Iterable<MediaStream>:

  Iterator<MediaStream> get iterator {
    // Note: NodeLists are not fixed size. And most probably length shouldn't
    // be cached in both iterator _and_ forEach method. For now caching it
    // for consistency.
    return new FixedSizeListIterator<MediaStream>(this);
  }

  dynamic reduce(dynamic initialValue, dynamic combine(dynamic, MediaStream)) {
    return IterableMixinWorkaround.reduce(this, initialValue, combine);
  }

  bool contains(MediaStream element) => IterableMixinWorkaround.contains(this, element);

  void forEach(void f(MediaStream element)) => IterableMixinWorkaround.forEach(this, f);

  String join([String separator]) =>
      IterableMixinWorkaround.joinList(this, separator);

  List mappedBy(f(MediaStream element)) => IterableMixinWorkaround.mappedByList(this, f);

  Iterable<MediaStream> where(bool f(MediaStream element)) =>
      IterableMixinWorkaround.where(this, f);

  bool every(bool f(MediaStream element)) => IterableMixinWorkaround.every(this, f);

  bool any(bool f(MediaStream element)) => IterableMixinWorkaround.any(this, f);

  List<MediaStream> toList() => new List<MediaStream>.from(this);
  Set<MediaStream> toSet() => new Set<MediaStream>.from(this);

  bool get isEmpty => this.length == 0;

  List<MediaStream> take(int n) => IterableMixinWorkaround.takeList(this, n);

  Iterable<MediaStream> takeWhile(bool test(MediaStream value)) {
    return IterableMixinWorkaround.takeWhile(this, test);
  }

  List<MediaStream> skip(int n) => IterableMixinWorkaround.skipList(this, n);

  Iterable<MediaStream> skipWhile(bool test(MediaStream value)) {
    return IterableMixinWorkaround.skipWhile(this, test);
  }

  MediaStream firstMatching(bool test(MediaStream value), { MediaStream orElse() }) {
    return IterableMixinWorkaround.firstMatching(this, test, orElse);
  }

  MediaStream lastMatching(bool test(MediaStream value), {MediaStream orElse()}) {
    return IterableMixinWorkaround.lastMatchingInList(this, test, orElse);
  }

  MediaStream singleMatching(bool test(MediaStream value)) {
    return IterableMixinWorkaround.singleMatching(this, test);
  }

  MediaStream elementAt(int index) {
    return this[index];
  }

  // From Collection<MediaStream>:

  void add(MediaStream value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addLast(MediaStream value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addAll(Iterable<MediaStream> iterable) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  // From List<MediaStream>:
  void set length(int value) {
    throw new UnsupportedError("Cannot resize immutable List.");
  }

  void clear() {
    throw new UnsupportedError("Cannot clear immutable List.");
  }

  List<MediaStream> get reversed =>
      new ReversedListView<MediaStream>(this, 0, null);

  void sort([int compare(MediaStream a, MediaStream b)]) {
    throw new UnsupportedError("Cannot sort immutable List.");
  }

  int indexOf(MediaStream element, [int start = 0]) =>
      Lists.indexOf(this, element, start, this.length);

  int lastIndexOf(MediaStream element, [int start]) {
    if (start == null) start = length - 1;
    return Lists.lastIndexOf(this, element, start);
  }

  MediaStream get first {
    if (this.length > 0) return this[0];
    throw new StateError("No elements");
  }

  MediaStream get last {
    if (this.length > 0) return this[this.length - 1];
    throw new StateError("No elements");
  }

  MediaStream get single {
    if (length == 1) return this[0];
    if (length == 0) throw new StateError("No elements");
    throw new StateError("More than one element");
  }

  MediaStream min([int compare(MediaStream a, MediaStream b)]) =>
      IterableMixinWorkaround.min(this, compare);

  MediaStream max([int compare(MediaStream a, MediaStream b)]) =>
      IterableMixinWorkaround.max(this, compare);

  MediaStream removeAt(int pos) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  MediaStream removeLast() {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void remove(Object object) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void removeAll(Iterable elements) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void retainAll(Iterable elements) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void removeMatching(bool test(MediaStream element)) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void retainMatching(bool test(MediaStream element)) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void setRange(int start, int rangeLength, List<MediaStream> from, [int startFrom]) {
    throw new UnsupportedError("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int rangeLength) {
    throw new UnsupportedError("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int rangeLength, [MediaStream initialValue]) {
    throw new UnsupportedError("Cannot insertRange on immutable List.");
  }

  List<MediaStream> getRange(int start, int rangeLength) =>
      Lists.getRange(this, start, rangeLength, <MediaStream>[]);

  // -- end List<MediaStream> mixins.

  @DomName('MediaStreamList.item')
  @DocsEditable
  MediaStream item(int index) native "MediaStreamList_item_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('SpeechInputResultList')
class _SpeechInputResultList extends NativeFieldWrapperClass1 implements List<SpeechInputResult> {
  _SpeechInputResultList.internal();

  @DomName('SpeechInputResultList.length')
  @DocsEditable
  int get length native "SpeechInputResultList_length_Getter";

  SpeechInputResult operator[](int index) native "SpeechInputResultList_item_Callback";

  void operator[]=(int index, SpeechInputResult value) {
    throw new UnsupportedError("Cannot assign element of immutable List.");
  }
  // -- start List<SpeechInputResult> mixins.
  // SpeechInputResult is the element type.

  // From Iterable<SpeechInputResult>:

  Iterator<SpeechInputResult> get iterator {
    // Note: NodeLists are not fixed size. And most probably length shouldn't
    // be cached in both iterator _and_ forEach method. For now caching it
    // for consistency.
    return new FixedSizeListIterator<SpeechInputResult>(this);
  }

  dynamic reduce(dynamic initialValue, dynamic combine(dynamic, SpeechInputResult)) {
    return IterableMixinWorkaround.reduce(this, initialValue, combine);
  }

  bool contains(SpeechInputResult element) => IterableMixinWorkaround.contains(this, element);

  void forEach(void f(SpeechInputResult element)) => IterableMixinWorkaround.forEach(this, f);

  String join([String separator]) =>
      IterableMixinWorkaround.joinList(this, separator);

  List mappedBy(f(SpeechInputResult element)) => IterableMixinWorkaround.mappedByList(this, f);

  Iterable<SpeechInputResult> where(bool f(SpeechInputResult element)) =>
      IterableMixinWorkaround.where(this, f);

  bool every(bool f(SpeechInputResult element)) => IterableMixinWorkaround.every(this, f);

  bool any(bool f(SpeechInputResult element)) => IterableMixinWorkaround.any(this, f);

  List<SpeechInputResult> toList() => new List<SpeechInputResult>.from(this);
  Set<SpeechInputResult> toSet() => new Set<SpeechInputResult>.from(this);

  bool get isEmpty => this.length == 0;

  List<SpeechInputResult> take(int n) => IterableMixinWorkaround.takeList(this, n);

  Iterable<SpeechInputResult> takeWhile(bool test(SpeechInputResult value)) {
    return IterableMixinWorkaround.takeWhile(this, test);
  }

  List<SpeechInputResult> skip(int n) => IterableMixinWorkaround.skipList(this, n);

  Iterable<SpeechInputResult> skipWhile(bool test(SpeechInputResult value)) {
    return IterableMixinWorkaround.skipWhile(this, test);
  }

  SpeechInputResult firstMatching(bool test(SpeechInputResult value), { SpeechInputResult orElse() }) {
    return IterableMixinWorkaround.firstMatching(this, test, orElse);
  }

  SpeechInputResult lastMatching(bool test(SpeechInputResult value), {SpeechInputResult orElse()}) {
    return IterableMixinWorkaround.lastMatchingInList(this, test, orElse);
  }

  SpeechInputResult singleMatching(bool test(SpeechInputResult value)) {
    return IterableMixinWorkaround.singleMatching(this, test);
  }

  SpeechInputResult elementAt(int index) {
    return this[index];
  }

  // From Collection<SpeechInputResult>:

  void add(SpeechInputResult value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addLast(SpeechInputResult value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addAll(Iterable<SpeechInputResult> iterable) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  // From List<SpeechInputResult>:
  void set length(int value) {
    throw new UnsupportedError("Cannot resize immutable List.");
  }

  void clear() {
    throw new UnsupportedError("Cannot clear immutable List.");
  }

  List<SpeechInputResult> get reversed =>
      new ReversedListView<SpeechInputResult>(this, 0, null);

  void sort([int compare(SpeechInputResult a, SpeechInputResult b)]) {
    throw new UnsupportedError("Cannot sort immutable List.");
  }

  int indexOf(SpeechInputResult element, [int start = 0]) =>
      Lists.indexOf(this, element, start, this.length);

  int lastIndexOf(SpeechInputResult element, [int start]) {
    if (start == null) start = length - 1;
    return Lists.lastIndexOf(this, element, start);
  }

  SpeechInputResult get first {
    if (this.length > 0) return this[0];
    throw new StateError("No elements");
  }

  SpeechInputResult get last {
    if (this.length > 0) return this[this.length - 1];
    throw new StateError("No elements");
  }

  SpeechInputResult get single {
    if (length == 1) return this[0];
    if (length == 0) throw new StateError("No elements");
    throw new StateError("More than one element");
  }

  SpeechInputResult min([int compare(SpeechInputResult a, SpeechInputResult b)]) =>
      IterableMixinWorkaround.min(this, compare);

  SpeechInputResult max([int compare(SpeechInputResult a, SpeechInputResult b)]) =>
      IterableMixinWorkaround.max(this, compare);

  SpeechInputResult removeAt(int pos) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  SpeechInputResult removeLast() {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void remove(Object object) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void removeAll(Iterable elements) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void retainAll(Iterable elements) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void removeMatching(bool test(SpeechInputResult element)) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void retainMatching(bool test(SpeechInputResult element)) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void setRange(int start, int rangeLength, List<SpeechInputResult> from, [int startFrom]) {
    throw new UnsupportedError("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int rangeLength) {
    throw new UnsupportedError("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int rangeLength, [SpeechInputResult initialValue]) {
    throw new UnsupportedError("Cannot insertRange on immutable List.");
  }

  List<SpeechInputResult> getRange(int start, int rangeLength) =>
      Lists.getRange(this, start, rangeLength, <SpeechInputResult>[]);

  // -- end List<SpeechInputResult> mixins.

  @DomName('SpeechInputResultList.item')
  @DocsEditable
  SpeechInputResult item(int index) native "SpeechInputResultList_item_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('SpeechRecognitionResultList')
class _SpeechRecognitionResultList extends NativeFieldWrapperClass1 implements List<SpeechRecognitionResult> {
  _SpeechRecognitionResultList.internal();

  @DomName('SpeechRecognitionResultList.length')
  @DocsEditable
  int get length native "SpeechRecognitionResultList_length_Getter";

  SpeechRecognitionResult operator[](int index) native "SpeechRecognitionResultList_item_Callback";

  void operator[]=(int index, SpeechRecognitionResult value) {
    throw new UnsupportedError("Cannot assign element of immutable List.");
  }
  // -- start List<SpeechRecognitionResult> mixins.
  // SpeechRecognitionResult is the element type.

  // From Iterable<SpeechRecognitionResult>:

  Iterator<SpeechRecognitionResult> get iterator {
    // Note: NodeLists are not fixed size. And most probably length shouldn't
    // be cached in both iterator _and_ forEach method. For now caching it
    // for consistency.
    return new FixedSizeListIterator<SpeechRecognitionResult>(this);
  }

  dynamic reduce(dynamic initialValue, dynamic combine(dynamic, SpeechRecognitionResult)) {
    return IterableMixinWorkaround.reduce(this, initialValue, combine);
  }

  bool contains(SpeechRecognitionResult element) => IterableMixinWorkaround.contains(this, element);

  void forEach(void f(SpeechRecognitionResult element)) => IterableMixinWorkaround.forEach(this, f);

  String join([String separator]) =>
      IterableMixinWorkaround.joinList(this, separator);

  List mappedBy(f(SpeechRecognitionResult element)) => IterableMixinWorkaround.mappedByList(this, f);

  Iterable<SpeechRecognitionResult> where(bool f(SpeechRecognitionResult element)) =>
      IterableMixinWorkaround.where(this, f);

  bool every(bool f(SpeechRecognitionResult element)) => IterableMixinWorkaround.every(this, f);

  bool any(bool f(SpeechRecognitionResult element)) => IterableMixinWorkaround.any(this, f);

  List<SpeechRecognitionResult> toList() => new List<SpeechRecognitionResult>.from(this);
  Set<SpeechRecognitionResult> toSet() => new Set<SpeechRecognitionResult>.from(this);

  bool get isEmpty => this.length == 0;

  List<SpeechRecognitionResult> take(int n) => IterableMixinWorkaround.takeList(this, n);

  Iterable<SpeechRecognitionResult> takeWhile(bool test(SpeechRecognitionResult value)) {
    return IterableMixinWorkaround.takeWhile(this, test);
  }

  List<SpeechRecognitionResult> skip(int n) => IterableMixinWorkaround.skipList(this, n);

  Iterable<SpeechRecognitionResult> skipWhile(bool test(SpeechRecognitionResult value)) {
    return IterableMixinWorkaround.skipWhile(this, test);
  }

  SpeechRecognitionResult firstMatching(bool test(SpeechRecognitionResult value), { SpeechRecognitionResult orElse() }) {
    return IterableMixinWorkaround.firstMatching(this, test, orElse);
  }

  SpeechRecognitionResult lastMatching(bool test(SpeechRecognitionResult value), {SpeechRecognitionResult orElse()}) {
    return IterableMixinWorkaround.lastMatchingInList(this, test, orElse);
  }

  SpeechRecognitionResult singleMatching(bool test(SpeechRecognitionResult value)) {
    return IterableMixinWorkaround.singleMatching(this, test);
  }

  SpeechRecognitionResult elementAt(int index) {
    return this[index];
  }

  // From Collection<SpeechRecognitionResult>:

  void add(SpeechRecognitionResult value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addLast(SpeechRecognitionResult value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addAll(Iterable<SpeechRecognitionResult> iterable) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  // From List<SpeechRecognitionResult>:
  void set length(int value) {
    throw new UnsupportedError("Cannot resize immutable List.");
  }

  void clear() {
    throw new UnsupportedError("Cannot clear immutable List.");
  }

  List<SpeechRecognitionResult> get reversed =>
      new ReversedListView<SpeechRecognitionResult>(this, 0, null);

  void sort([int compare(SpeechRecognitionResult a, SpeechRecognitionResult b)]) {
    throw new UnsupportedError("Cannot sort immutable List.");
  }

  int indexOf(SpeechRecognitionResult element, [int start = 0]) =>
      Lists.indexOf(this, element, start, this.length);

  int lastIndexOf(SpeechRecognitionResult element, [int start]) {
    if (start == null) start = length - 1;
    return Lists.lastIndexOf(this, element, start);
  }

  SpeechRecognitionResult get first {
    if (this.length > 0) return this[0];
    throw new StateError("No elements");
  }

  SpeechRecognitionResult get last {
    if (this.length > 0) return this[this.length - 1];
    throw new StateError("No elements");
  }

  SpeechRecognitionResult get single {
    if (length == 1) return this[0];
    if (length == 0) throw new StateError("No elements");
    throw new StateError("More than one element");
  }

  SpeechRecognitionResult min([int compare(SpeechRecognitionResult a, SpeechRecognitionResult b)]) =>
      IterableMixinWorkaround.min(this, compare);

  SpeechRecognitionResult max([int compare(SpeechRecognitionResult a, SpeechRecognitionResult b)]) =>
      IterableMixinWorkaround.max(this, compare);

  SpeechRecognitionResult removeAt(int pos) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  SpeechRecognitionResult removeLast() {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void remove(Object object) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void removeAll(Iterable elements) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void retainAll(Iterable elements) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void removeMatching(bool test(SpeechRecognitionResult element)) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void retainMatching(bool test(SpeechRecognitionResult element)) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void setRange(int start, int rangeLength, List<SpeechRecognitionResult> from, [int startFrom]) {
    throw new UnsupportedError("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int rangeLength) {
    throw new UnsupportedError("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int rangeLength, [SpeechRecognitionResult initialValue]) {
    throw new UnsupportedError("Cannot insertRange on immutable List.");
  }

  List<SpeechRecognitionResult> getRange(int start, int rangeLength) =>
      Lists.getRange(this, start, rangeLength, <SpeechRecognitionResult>[]);

  // -- end List<SpeechRecognitionResult> mixins.

  @DomName('SpeechRecognitionResultList.item')
  @DocsEditable
  SpeechRecognitionResult item(int index) native "SpeechRecognitionResultList_item_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


@DocsEditable
@DomName('StyleSheetList')
class _StyleSheetList extends NativeFieldWrapperClass1 implements List<StyleSheet> {
  _StyleSheetList.internal();

  @DomName('StyleSheetList.length')
  @DocsEditable
  int get length native "StyleSheetList_length_Getter";

  StyleSheet operator[](int index) native "StyleSheetList_item_Callback";

  void operator[]=(int index, StyleSheet value) {
    throw new UnsupportedError("Cannot assign element of immutable List.");
  }
  // -- start List<StyleSheet> mixins.
  // StyleSheet is the element type.

  // From Iterable<StyleSheet>:

  Iterator<StyleSheet> get iterator {
    // Note: NodeLists are not fixed size. And most probably length shouldn't
    // be cached in both iterator _and_ forEach method. For now caching it
    // for consistency.
    return new FixedSizeListIterator<StyleSheet>(this);
  }

  dynamic reduce(dynamic initialValue, dynamic combine(dynamic, StyleSheet)) {
    return IterableMixinWorkaround.reduce(this, initialValue, combine);
  }

  bool contains(StyleSheet element) => IterableMixinWorkaround.contains(this, element);

  void forEach(void f(StyleSheet element)) => IterableMixinWorkaround.forEach(this, f);

  String join([String separator]) =>
      IterableMixinWorkaround.joinList(this, separator);

  List mappedBy(f(StyleSheet element)) => IterableMixinWorkaround.mappedByList(this, f);

  Iterable<StyleSheet> where(bool f(StyleSheet element)) =>
      IterableMixinWorkaround.where(this, f);

  bool every(bool f(StyleSheet element)) => IterableMixinWorkaround.every(this, f);

  bool any(bool f(StyleSheet element)) => IterableMixinWorkaround.any(this, f);

  List<StyleSheet> toList() => new List<StyleSheet>.from(this);
  Set<StyleSheet> toSet() => new Set<StyleSheet>.from(this);

  bool get isEmpty => this.length == 0;

  List<StyleSheet> take(int n) => IterableMixinWorkaround.takeList(this, n);

  Iterable<StyleSheet> takeWhile(bool test(StyleSheet value)) {
    return IterableMixinWorkaround.takeWhile(this, test);
  }

  List<StyleSheet> skip(int n) => IterableMixinWorkaround.skipList(this, n);

  Iterable<StyleSheet> skipWhile(bool test(StyleSheet value)) {
    return IterableMixinWorkaround.skipWhile(this, test);
  }

  StyleSheet firstMatching(bool test(StyleSheet value), { StyleSheet orElse() }) {
    return IterableMixinWorkaround.firstMatching(this, test, orElse);
  }

  StyleSheet lastMatching(bool test(StyleSheet value), {StyleSheet orElse()}) {
    return IterableMixinWorkaround.lastMatchingInList(this, test, orElse);
  }

  StyleSheet singleMatching(bool test(StyleSheet value)) {
    return IterableMixinWorkaround.singleMatching(this, test);
  }

  StyleSheet elementAt(int index) {
    return this[index];
  }

  // From Collection<StyleSheet>:

  void add(StyleSheet value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addLast(StyleSheet value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addAll(Iterable<StyleSheet> iterable) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  // From List<StyleSheet>:
  void set length(int value) {
    throw new UnsupportedError("Cannot resize immutable List.");
  }

  void clear() {
    throw new UnsupportedError("Cannot clear immutable List.");
  }

  List<StyleSheet> get reversed =>
      new ReversedListView<StyleSheet>(this, 0, null);

  void sort([int compare(StyleSheet a, StyleSheet b)]) {
    throw new UnsupportedError("Cannot sort immutable List.");
  }

  int indexOf(StyleSheet element, [int start = 0]) =>
      Lists.indexOf(this, element, start, this.length);

  int lastIndexOf(StyleSheet element, [int start]) {
    if (start == null) start = length - 1;
    return Lists.lastIndexOf(this, element, start);
  }

  StyleSheet get first {
    if (this.length > 0) return this[0];
    throw new StateError("No elements");
  }

  StyleSheet get last {
    if (this.length > 0) return this[this.length - 1];
    throw new StateError("No elements");
  }

  StyleSheet get single {
    if (length == 1) return this[0];
    if (length == 0) throw new StateError("No elements");
    throw new StateError("More than one element");
  }

  StyleSheet min([int compare(StyleSheet a, StyleSheet b)]) =>
      IterableMixinWorkaround.min(this, compare);

  StyleSheet max([int compare(StyleSheet a, StyleSheet b)]) =>
      IterableMixinWorkaround.max(this, compare);

  StyleSheet removeAt(int pos) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  StyleSheet removeLast() {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void remove(Object object) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void removeAll(Iterable elements) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void retainAll(Iterable elements) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void removeMatching(bool test(StyleSheet element)) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void retainMatching(bool test(StyleSheet element)) {
    throw new UnsupportedError("Cannot remove from immutable List.");
  }

  void setRange(int start, int rangeLength, List<StyleSheet> from, [int startFrom]) {
    throw new UnsupportedError("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int rangeLength) {
    throw new UnsupportedError("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int rangeLength, [StyleSheet initialValue]) {
    throw new UnsupportedError("Cannot insertRange on immutable List.");
  }

  List<StyleSheet> getRange(int start, int rangeLength) =>
      Lists.getRange(this, start, rangeLength, <StyleSheet>[]);

  // -- end List<StyleSheet> mixins.

  @DomName('StyleSheetList.item')
  @DocsEditable
  StyleSheet item(int index) native "StyleSheetList_item_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.


abstract class _AttributeMap implements Map<String, String> {
  final Element _element;

  _AttributeMap(this._element);

  bool containsValue(String value) {
    for (var v in this.values) {
      if (value == v) {
        return true;
      }
    }
    return false;
  }

  String putIfAbsent(String key, String ifAbsent()) {
    if (!containsKey(key)) {
      this[key] = ifAbsent();
    }
    return this[key];
  }

  void clear() {
    for (var key in keys) {
      remove(key);
    }
  }

  void forEach(void f(String key, String value)) {
    for (var key in keys) {
      var value = this[key];
      f(key, value);
    }
  }

  Collection<String> get keys {
    // TODO: generate a lazy collection instead.
    var attributes = _element.$dom_attributes;
    var keys = new List<String>();
    for (int i = 0, len = attributes.length; i < len; i++) {
      if (_matches(attributes[i])) {
        keys.add(attributes[i].$dom_localName);
      }
    }
    return keys;
  }

  Collection<String> get values {
    // TODO: generate a lazy collection instead.
    var attributes = _element.$dom_attributes;
    var values = new List<String>();
    for (int i = 0, len = attributes.length; i < len; i++) {
      if (_matches(attributes[i])) {
        values.add(attributes[i].value);
      }
    }
    return values;
  }

  /**
   * Returns true if there is no {key, value} pair in the map.
   */
  bool get isEmpty {
    return length == 0;
  }

  /**
   * Checks to see if the node should be included in this map.
   */
  bool _matches(Node node);
}

/**
 * Wrapper to expose [Element.attributes] as a typed map.
 */
class _ElementAttributeMap extends _AttributeMap {

  _ElementAttributeMap(Element element): super(element);

  bool containsKey(String key) {
    return _element.$dom_hasAttribute(key);
  }

  String operator [](String key) {
    return _element.$dom_getAttribute(key);
  }

  void operator []=(String key, value) {
    _element.$dom_setAttribute(key, '$value');
  }

  String remove(String key) {
    String value = _element.$dom_getAttribute(key);
    _element.$dom_removeAttribute(key);
    return value;
  }

  /**
   * The number of {key, value} pairs in the map.
   */
  int get length {
    return keys.length;
  }

  bool _matches(Node node) => node.$dom_namespaceUri == null;
}

/**
 * Wrapper to expose namespaced attributes as a typed map.
 */
class _NamespacedAttributeMap extends _AttributeMap {

  final String _namespace;

  _NamespacedAttributeMap(Element element, this._namespace): super(element);

  bool containsKey(String key) {
    return _element.$dom_hasAttributeNS(_namespace, key);
  }

  String operator [](String key) {
    return _element.$dom_getAttributeNS(_namespace, key);
  }

  void operator []=(String key, value) {
    _element.$dom_setAttributeNS(_namespace, key, '$value');
  }

  String remove(String key) {
    String value = this[key];
    _element.$dom_removeAttributeNS(_namespace, key);
    return value;
  }

  /**
   * The number of {key, value} pairs in the map.
   */
  int get length {
    return keys.length;
  }

  bool _matches(Node node) => node.$dom_namespaceUri == _namespace;
}


/**
 * Provides a Map abstraction on top of data-* attributes, similar to the
 * dataSet in the old DOM.
 */
class _DataAttributeMap implements Map<String, String> {

  final Map<String, String> $dom_attributes;

  _DataAttributeMap(this.$dom_attributes);

  // interface Map

  // TODO: Use lazy iterator when it is available on Map.
  bool containsValue(String value) => values.any((v) => v == value);

  bool containsKey(String key) => $dom_attributes.containsKey(_attr(key));

  String operator [](String key) => $dom_attributes[_attr(key)];

  void operator []=(String key, value) {
    $dom_attributes[_attr(key)] = '$value';
  }

  String putIfAbsent(String key, String ifAbsent()) =>
    $dom_attributes.putIfAbsent(_attr(key), ifAbsent);

  String remove(String key) => $dom_attributes.remove(_attr(key));

  void clear() {
    // Needs to operate on a snapshot since we are mutating the collection.
    for (String key in keys) {
      remove(key);
    }
  }

  void forEach(void f(String key, String value)) {
    $dom_attributes.forEach((String key, String value) {
      if (_matches(key)) {
        f(_strip(key), value);
      }
    });
  }

  Collection<String> get keys {
    final keys = new List<String>();
    $dom_attributes.forEach((String key, String value) {
      if (_matches(key)) {
        keys.add(_strip(key));
      }
    });
    return keys;
  }

  Collection<String> get values {
    final values = new List<String>();
    $dom_attributes.forEach((String key, String value) {
      if (_matches(key)) {
        values.add(value);
      }
    });
    return values;
  }

  int get length => keys.length;

  // TODO: Use lazy iterator when it is available on Map.
  bool get isEmpty => length == 0;

  // Helpers.
  String _attr(String key) => 'data-$key';
  bool _matches(String key) => key.startsWith('data-');
  String _strip(String key) => key.substring(5);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.


/**
 * An object representing the top-level context object for web scripting.
 *
 * In a web browser, a [Window] object represents the actual browser window.
 * In a multi-tabbed browser, each tab has its own [Window] object. A [Window]
 * is the container that displays a [Document]'s content. All web scripting
 * happens within the context of a [Window] object.
 *
 * **Note:** This class represents any window, whereas [Window] is
 * used to access the properties and content of the current window.
 *
 * See also:
 *
 * * [DOM Window](https://developer.mozilla.org/en-US/docs/DOM/window) from MDN.
 * * [Window](http://www.w3.org/TR/Window/) from the W3C.
 */
abstract class WindowBase {
  // Fields.

  /**
   * The current location of this window.
   *
   *     Location currentLocation = window.location;
   *     print(currentLocation.href); // 'http://www.example.com:80/'
   */
  LocationBase get location;
  HistoryBase get history;

  /**
   * Indicates whether this window has been closed.
   *
   *     print(window.closed); // 'false'
   *     window.close();
   *     print(window.closed); // 'true'
   */
  bool get closed;

  /**
   * A reference to the window that opened this one.
   *
   *     Window thisWindow = window;
   *     WindowBase otherWindow = thisWindow.open('http://www.example.com/', 'foo');
   *     print(otherWindow.opener == thisWindow); // 'true'
   */
  WindowBase get opener;

  /**
   * A reference to the parent of this window.
   *
   * If this [WindowBase] has no parent, [parent] will return a reference to
   * the [WindowBase] itself.
   *
   *     IFrameElement myIFrame = new IFrameElement();
   *     window.document.body.elements.add(myIFrame);
   *     print(myIframe.contentWindow.parent == window) // 'true'
   *
   *     print(window.parent == window) // 'true'
   */
  WindowBase get parent;

  /**
   * A reference to the topmost window in the window hierarchy.
   *
   * If this [WindowBase] is the topmost [WindowBase], [top] will return a
   * reference to the [WindowBase] itself.
   *
   *     // Add an IFrame to the current window.
   *     IFrameElement myIFrame = new IFrameElement();
   *     window.document.body.elements.add(myIFrame);
   *
   *     // Add an IFrame inside of the other IFrame.
   *     IFrameElement innerIFrame = new IFrameElement();
   *     myIFrame.elements.add(innerIFrame);
   *
   *     print(myIframe.contentWindow.top == window) // 'true'
   *     print(innerIFrame.contentWindow.top == window) // 'true'
   *
   *     print(window.top == window) // 'true'
   */
  WindowBase get top;

  // Methods.
  /**
   * Closes the window.
   *
   * This method should only succeed if the [WindowBase] object is
   * **script-closeable** and the window calling [close] is allowed to navigate
   * the window.
   *
   * A window is script-closeable if it is either a window
   * that was opened by another window, or if it is a window with only one
   * document in its history.
   *
   * A window might not be allowed to navigate, and therefore close, another
   * window due to browser security features.
   *
   *     var other = window.open('http://www.example.com', 'foo');
   *     // Closes other window, as it is script-closeable.
   *     other.close();
   *     print(other.closed()); // 'true'
   *
   *     window.location('http://www.mysite.com', 'foo');
   *     // Does not close this window, as the history has changed.
   *     window.close();
   *     print(window.closed()); // 'false'
   *
   * See also:
   *
   * * [Window close discussion](http://www.w3.org/TR/html5/browsers.html#dom-window-close) from the W3C
   */
  void close();
  void postMessage(var message, String targetOrigin, [List messagePorts]);
}

abstract class LocationBase {
  void set href(String val);
}

abstract class HistoryBase {
  void back();
  void forward();
  void go(int distance);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.


abstract class CssClassSet implements Set<String> {

  String toString() {
    return Strings.join(new List.from(readClasses()), ' ');
  }

  /**
   * Adds the class [token] to the element if it is not on it, removes it if it
   * is.
   */
  bool toggle(String value) {
    Set<String> s = readClasses();
    bool result = false;
    if (s.contains(value)) {
      s.remove(value);
    } else {
      s.add(value);
      result = true;
    }
    writeClasses(s);
    return result;
  }

  /**
   * Returns [:true:] if classes cannot be added or removed from this
   * [:CssClassSet:].
   */
  bool get frozen => false;

  // interface Iterable - BEGIN
  Iterator<String> get iterator => readClasses().iterator;
  // interface Iterable - END

  // interface Collection - BEGIN
  void forEach(void f(String element)) {
    readClasses().forEach(f);
  }

  String join([String separator]) => readClasses().join(separator);

  Iterable mappedBy(f(String element)) => readClasses().mappedBy(f);

  Iterable<String> where(bool f(String element)) => readClasses().where(f);

  bool every(bool f(String element)) => readClasses().every(f);

  bool any(bool f(String element)) => readClasses().any(f);

  bool get isEmpty => readClasses().isEmpty;

  int get length =>readClasses().length;

  dynamic reduce(dynamic initialValue,
      dynamic combine(dynamic previousValue, String element)) {
    return readClasses().reduce(initialValue, combine);
  }
  // interface Collection - END

  // interface Set - BEGIN
  bool contains(String value) => readClasses().contains(value);

  void add(String value) {
    // TODO - figure out if we need to do any validation here
    // or if the browser natively does enough.
    _modify((s) => s.add(value));
  }

  bool remove(Object value) {
    if (value is! String) return false;
    Set<String> s = readClasses();
    bool result = s.remove(value);
    writeClasses(s);
    return result;
  }

  void addAll(Iterable<String> iterable) {
    // TODO - see comment above about validation.
    _modify((s) => s.addAll(iterable));
  }

  void removeAll(Iterable<String> iterable) {
    _modify((s) => s.removeAll(iterable));
  }

  void retainAll(Iterable<String> iterable) {
    _modify((s) => s.retainAll(iterable));
  }

  void removeMatching(bool test(String name)) {
    _modify((s) => s.removeMatching(test));
  }

  void retainMatching(bool test(String name)) {
    _modify((s) => s.retainMatching(test));
  }

  bool isSubsetOf(Collection<String> collection) =>
    readClasses().isSubsetOf(collection);

  bool containsAll(Collection<String> collection) =>
    readClasses().containsAll(collection);

  Set<String> intersection(Collection<String> other) =>
    readClasses().intersection(other);

  String get first => readClasses().first;
  String get last => readClasses().last;
  String get single => readClasses().single;
  List<String> toList() => readClasses().toList();
  Set<String> toSet() => readClasses().toSet();
  String min([int compare(String a, String b)]) =>
      readClasses().min(compare);
  String max([int compare(String a, String b)]) =>
      readClasses().max(compare);
  Iterable<String> take(int n) => readClasses().take(n);
  Iterable<String> takeWhile(bool test(String value)) =>
      readClasses().takeWhile(test);
  Iterable<String> skip(int n) => readClasses().skip(n);
  Iterable<String> skipWhile(bool test(String value)) =>
      readClasses().skipWhile(test);
  String firstMatching(bool test(String value), { String orElse() }) =>
      readClasses().firstMatching(test, orElse: orElse);
  String lastMatching(bool test(String value), {String orElse()}) =>
      readClasses().lastMatching(test, orElse: orElse);
  String singleMatching(bool test(String value)) =>
      readClasses().singleMatching(test);
  String elementAt(int index) => readClasses().elementAt(index);

  void clear() {
    _modify((s) => s.clear());
  }
  // interface Set - END

  /**
   * Helper method used to modify the set of css classes on this element.
   *
   *   f - callback with:
   *      s - a Set of all the css class name currently on this element.
   *
   *   After f returns, the modified set is written to the
   *       className property of this element.
   */
  void _modify( f(Set<String> s)) {
    Set<String> s = readClasses();
    f(s);
    writeClasses(s);
  }

  /**
   * Read the class names from the Element class property,
   * and put them into a set (duplicates are discarded).
   * This is intended to be overridden by specific implementations.
   */
  Set<String> readClasses();

  /**
   * Join all the elements of a set into one string and write
   * back to the element.
   * This is intended to be overridden by specific implementations.
   */
  void writeClasses(Set<String> s);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.


typedef void EventListener(Event event);
// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.


/**
 * Adapter for exposing DOM events as Dart streams.
 */
class _EventStream<T extends Event> extends Stream<T> {
  final EventTarget _target;
  final String _eventType;
  final bool _useCapture;

  _EventStream(this._target, this._eventType, this._useCapture);

  // DOM events are inherently multi-subscribers.
  Stream<T> asBroadcastStream() => this;

  StreamSubscription<T> listen(void onData(T event),
      { void onError(AsyncError error),
      void onDone(),
      bool unsubscribeOnError}) {

    return new _EventStreamSubscription<T>(
        this._target, this._eventType, onData, this._useCapture);
  }
}

class _EventStreamSubscription<T extends Event> extends StreamSubscription<T> {
  int _pauseCount = 0;
  EventTarget _target;
  final String _eventType;
  var _onData;
  final bool _useCapture;

  _EventStreamSubscription(this._target, this._eventType, this._onData,
      this._useCapture) {
    _tryResume();
  }

  void cancel() {
    if (_canceled) {
      throw new StateError("Subscription has been canceled.");
    }

    _unlisten();
    // Clear out the target to indicate this is complete.
    _target = null;
    _onData = null;
  }

  bool get _canceled => _target == null;

  void onData(void handleData(T event)) {
    if (_canceled) {
      throw new StateError("Subscription has been canceled.");
    }
    // Remove current event listener.
    _unlisten();

    _onData = handleData;
    _tryResume();
  }

  /// Has no effect.
  void onError(void handleError(AsyncError error)) {}

  /// Has no effect.
  void onDone(void handleDone()) {}

  void pause([Future resumeSignal]) {
    if (_canceled) {
      throw new StateError("Subscription has been canceled.");
    }
    ++_pauseCount;
    _unlisten();

    if (resumeSignal != null) {
      resumeSignal.whenComplete(resume);
    }
  }

  bool get _paused => _pauseCount > 0;

  void resume() {
    if (_canceled) {
      throw new StateError("Subscription has been canceled.");
    }
    if (!_paused) {
      throw new StateError("Subscription is not paused.");
    }
    --_pauseCount;
    _tryResume();
  }

  void _tryResume() {
    if (_onData != null && !_paused) {
      _target.$dom_addEventListener(_eventType, _onData, _useCapture);
    }
  }

  void _unlisten() {
    if (_onData != null) {
      _target.$dom_removeEventListener(_eventType, _onData, _useCapture);
    }
  }
}


/**
 * A factory to expose DOM events as Streams.
 */
class EventStreamProvider<T extends Event> {
  final String _eventType;

  const EventStreamProvider(this._eventType);

  /**
   * Gets a [Stream] for this event type, on the specified target.
   *
   * This may be used to capture DOM events:
   *
   *     Element.keyDownEvent.forTarget(element, useCapture: true).listen(...);
   *
   * Or for listening to an event which will bubble through the DOM tree:
   *
   *     MediaElement.pauseEvent.forTarget(document.body).listen(...);
   *
   * See also:
   *
   * [addEventListener](http://docs.webplatform.org/wiki/dom/methods/addEventListener)
   */
  Stream<T> forTarget(EventTarget e, {bool useCapture: false}) {
    return new _EventStream(e, _eventType, useCapture);
  }
}

/**
 * A factory to expose DOM events as streams, where the DOM event name has to
 * be determined on the fly (for example, mouse wheel events).
 */
class _CustomEventStreamProvider<T extends Event>
    implements EventStreamProvider<T> {

  final _eventTypeGetter;
  const _CustomEventStreamProvider(this._eventTypeGetter);

  Stream<T> forTarget(EventTarget e, {bool useCapture: false}) {
    return new _EventStream(e, _eventTypeGetter(e), useCapture);
  }
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.


/**
 * Works with KeyboardEvent and KeyEvent to determine how to expose information
 * about Key(board)Events. This class functions like an EventListenerList, and
 * provides a consistent interface for the Dart
 * user, despite the fact that a multitude of browsers that have varying
 * keyboard default behavior.
 *
 * This class is very much a work in progress, and we'd love to get information
 * on how we can make this class work with as many international keyboards as
 * possible. Bugs welcome!
 */
class KeyboardEventController {
  // This code inspired by Closure's KeyHandling library.
  // http://closure-library.googlecode.com/svn/docs/closure_goog_events_keyhandler.js.source.html

  /**
   * The set of keys that have been pressed down without seeing their
   * corresponding keyup event.
   */
  List<KeyboardEvent> _keyDownList;

  /** The set of functions that wish to be notified when a KeyEvent happens. */
  List<Function> _callbacks;

  /** The type of KeyEvent we are tracking (keyup, keydown, keypress). */
  String _type;

  /** The element we are watching for events to happen on. */
  EventTarget _target;

  // The distance to shift from upper case alphabet Roman letters to lower case.
  final int _ROMAN_ALPHABET_OFFSET = "a".charCodes[0] - "A".charCodes[0];

  StreamSubscription _keyUpSubscription, _keyDownSubscription,
      _keyPressSubscription;

  /**
   * An enumeration of key identifiers currently part of the W3C draft for DOM3
   * and their mappings to keyCodes.
   * http://www.w3.org/TR/DOM-Level-3-Events/keyset.html#KeySet-Set
   */
  static Map<String, int> _keyIdentifier = {
    'Up': KeyCode.UP,
    'Down': KeyCode.DOWN,
    'Left': KeyCode.LEFT,
    'Right': KeyCode.RIGHT,
    'Enter': KeyCode.ENTER,
    'F1': KeyCode.F1,
    'F2': KeyCode.F2,
    'F3': KeyCode.F3,
    'F4': KeyCode.F4,
    'F5': KeyCode.F5,
    'F6': KeyCode.F6,
    'F7': KeyCode.F7,
    'F8': KeyCode.F8,
    'F9': KeyCode.F9,
    'F10': KeyCode.F10,
    'F11': KeyCode.F11,
    'F12': KeyCode.F12,
    'U+007F': KeyCode.DELETE,
    'Home': KeyCode.HOME,
    'End': KeyCode.END,
    'PageUp': KeyCode.PAGE_UP,
    'PageDown': KeyCode.PAGE_DOWN,
    'Insert': KeyCode.INSERT
  };

  /** Named constructor to add an onKeyPress event listener to our handler. */
  KeyboardEventController.keypress(EventTarget target) {
    _KeyboardEventController(target, 'keypress');
  }

  /** Named constructor to add an onKeyUp event listener to our handler. */
  KeyboardEventController.keyup(EventTarget target) {
    _KeyboardEventController(target, 'keyup');
  }

  /** Named constructor to add an onKeyDown event listener to our handler. */
  KeyboardEventController.keydown(EventTarget target) {
    _KeyboardEventController(target, 'keydown');
  }

  /**
   * General constructor, performs basic initialization for our improved
   * KeyboardEvent controller.
   */
  _KeyboardEventController(EventTarget target, String type) {
    _callbacks = [];
    _type = type;
    _target = target;
  }

  /**
   * Hook up all event listeners under the covers so we can estimate keycodes
   * and charcodes when they are not provided.
   */
  void _initializeAllEventListeners() {
    _keyDownList = [];
    if (_keyDownSubscription == null) {
      _keyDownSubscription = Element.keyDownEvent.forTarget(
          _target, useCapture: true).listen(processKeyDown);
      _keyPressSubscription = Element.keyPressEvent.forTarget(
          _target, useCapture: true).listen(processKeyUp);
      _keyUpSubscription = Element.keyUpEvent.forTarget(
          _target, useCapture: true).listen(processKeyPress);
    }
  }

  /** Add a callback that wishes to be notified when a KeyEvent occurs. */
  void add(void callback(KeyEvent)) {
    if (_callbacks.length == 0) {
      _initializeAllEventListeners();
    }
    _callbacks.add(callback);
  }

  /**
   * Notify all callback listeners that a KeyEvent of the relevant type has
   * occurred.
   */
  bool _dispatch(KeyEvent event) {
    if (event.type == _type) {
      // Make a copy of the listeners in case a callback gets removed while
      // dispatching from the list.
      List callbacksCopy = new List.from(_callbacks);
      for(var callback in callbacksCopy) {
        callback(event);
      }
    }
  }

  /** Remove the given callback from the listeners list. */
  void remove(void callback(KeyEvent)) {
    var index = _callbacks.indexOf(callback);
    if (index != -1) {
      _callbacks.removeAt(index);
    }
    if (_callbacks.length == 0) {
      // If we have no listeners, don't bother keeping track of keypresses.
      _keyDownSubscription.cancel();
      _keyDownSubscription = null;
      _keyPressSubscription.cancel();
      _keyPressSubscription = null;
      _keyUpSubscription.cancel();
      _keyUpSubscription = null;
    }
  }

  /** Determine if caps lock is one of the currently depressed keys. */
  bool get _capsLockOn =>
      _keyDownList.any((var element) => element.keyCode == KeyCode.CAPS_LOCK);

  /**
   * Given the previously recorded keydown key codes, see if we can determine
   * the keycode of this keypress [event]. (Generally browsers only provide
   * charCode information for keypress events, but with a little
   * reverse-engineering, we can also determine the keyCode.) Returns
   * KeyCode.UNKNOWN if the keycode could not be determined.
   */
  int _determineKeyCodeForKeypress(KeyboardEvent event) {
    // Note: This function is a work in progress. We'll expand this function
    // once we get more information about other keyboards.
    for (var prevEvent in _keyDownList) {
      if (prevEvent._shadowCharCode == event.charCode) {
        return prevEvent.keyCode;
      }
      if ((event.shiftKey || _capsLockOn) && event.charCode >= "A".charCodes[0]
          && event.charCode <= "Z".charCodes[0] && event.charCode +
          _ROMAN_ALPHABET_OFFSET == prevEvent._shadowCharCode) {
        return prevEvent.keyCode;
      }
    }
    return KeyCode.UNKNOWN;
  }

  /**
   * Given the charater code returned from a keyDown [event], try to ascertain
   * and return the corresponding charCode for the character that was pressed.
   * This information is not shown to the user, but used to help polyfill
   * keypress events.
   */
  int _findCharCodeKeyDown(KeyboardEvent event) {
    if (event.keyLocation == 3) { // Numpad keys.
      switch (event.keyCode) {
        case KeyCode.NUM_ZERO:
          // Even though this function returns _charCodes_, for some cases the
          // KeyCode == the charCode we want, in which case we use the keycode
          // constant for readability.
          return KeyCode.ZERO;
        case KeyCode.NUM_ONE:
          return KeyCode.ONE;
        case KeyCode.NUM_TWO:
          return KeyCode.TWO;
        case KeyCode.NUM_THREE:
          return KeyCode.THREE;
        case KeyCode.NUM_FOUR:
          return KeyCode.FOUR;
        case KeyCode.NUM_FIVE:
          return KeyCode.FIVE;
        case KeyCode.NUM_SIX:
          return KeyCode.SIX;
        case KeyCode.NUM_SEVEN:
          return KeyCode.SEVEN;
        case KeyCode.NUM_EIGHT:
          return KeyCode.EIGHT;
        case KeyCode.NUM_NINE:
          return KeyCode.NINE;
        case KeyCode.NUM_MULTIPLY:
          return 42; // Char code for *
        case KeyCode.NUM_PLUS:
          return 43; // +
        case KeyCode.NUM_MINUS:
          return 45; // -
        case KeyCode.NUM_PERIOD:
          return 46; // .
        case KeyCode.NUM_DIVISION:
          return 47; // /
      }
    } else if (event.keyCode >= 65 && event.keyCode <= 90) {
      // Set the "char code" for key down as the lower case letter. Again, this
      // will not show up for the user, but will be helpful in estimating
      // keyCode locations and other information during the keyPress event.
      return event.keyCode + _ROMAN_ALPHABET_OFFSET;
    }
    switch(event.keyCode) {
      case KeyCode.SEMICOLON:
        return KeyCode.FF_SEMICOLON;
      case KeyCode.EQUALS:
        return KeyCode.FF_EQUALS;
      case KeyCode.COMMA:
        return 44; // Ascii value for ,
      case KeyCode.DASH:
        return 45; // -
      case KeyCode.PERIOD:
        return 46; // .
      case KeyCode.SLASH:
        return 47; // /
      case KeyCode.APOSTROPHE:
        return 96; // `
      case KeyCode.OPEN_SQUARE_BRACKET:
        return 91; // [
      case KeyCode.BACKSLASH:
        return 92; // \
      case KeyCode.CLOSE_SQUARE_BRACKET:
        return 93; // ]
      case KeyCode.SINGLE_QUOTE:
        return 39; // '
    }
    return event.keyCode;
  }

  /**
   * Returns true if the key fires a keypress event in the current browser.
   */
  bool _firesKeyPressEvent(KeyEvent event) {
    if (!_Device.isIE && !_Device.isWebKit) {
      return true;
    }

    if (_Device.userAgent.contains('Mac') && event.altKey) {
      return KeyCode.isCharacterKey(event.keyCode);
    }

    // Alt but not AltGr which is represented as Alt+Ctrl.
    if (event.altKey && !event.ctrlKey) {
      return false;
    }

    // Saves Ctrl or Alt + key for IE and WebKit, which won't fire keypress.
    if (!event.shiftKey &&
        (_keyDownList.last.keyCode == KeyCode.CTRL ||
         _keyDownList.last.keyCode == KeyCode.ALT ||
         _Device.userAgent.contains('Mac') &&
         _keyDownList.last.keyCode == KeyCode.META)) {
      return false;
    }

    // Some keys with Ctrl/Shift do not issue keypress in WebKit.
    if (_Device.isWebKit && event.ctrlKey && event.shiftKey && (
        event.keyCode == KeyCode.BACKSLASH ||
        event.keyCode == KeyCode.OPEN_SQUARE_BRACKET ||
        event.keyCode == KeyCode.CLOSE_SQUARE_BRACKET ||
        event.keyCode == KeyCode.TILDE ||
        event.keyCode == KeyCode.SEMICOLON || event.keyCode == KeyCode.DASH ||
        event.keyCode == KeyCode.EQUALS || event.keyCode == KeyCode.COMMA ||
        event.keyCode == KeyCode.PERIOD || event.keyCode == KeyCode.SLASH ||
        event.keyCode == KeyCode.APOSTROPHE ||
        event.keyCode == KeyCode.SINGLE_QUOTE)) {
      return false;
    }

    switch (event.keyCode) {
      case KeyCode.ENTER:
        // IE9 does not fire keypress on ENTER.
        return !_Device.isIE;
      case KeyCode.ESC:
        return !_Device.isWebKit;
    }

    return KeyCode.isCharacterKey(event.keyCode);
  }

  /**
   * Normalize the keycodes to the IE KeyCodes (this is what Chrome, IE, and
   * Opera all use).
   */
  int _normalizeKeyCodes(KeyboardEvent event) {
    // Note: This may change once we get input about non-US keyboards.
    if (_Device.isFirefox) {
      switch(event.keyCode) {
        case KeyCode.FF_EQUALS:
          return KeyCode.EQUALS;
        case KeyCode.FF_SEMICOLON:
          return KeyCode.SEMICOLON;
        case KeyCode.MAC_FF_META:
          return KeyCode.META;
        case KeyCode.WIN_KEY_FF_LINUX:
          return KeyCode.WIN_KEY;
      }
    }
    return event.keyCode;
  }

  /** Handle keydown events. */
  void processKeyDown(KeyboardEvent e) {
    // Ctrl-Tab and Alt-Tab can cause the focus to be moved to another window
    // before we've caught a key-up event.  If the last-key was one of these
    // we reset the state.
    if (_keyDownList.length > 0 &&
        (_keyDownList.last.keyCode == KeyCode.CTRL && !e.ctrlKey ||
         _keyDownList.last.keyCode == KeyCode.ALT && !e.altKey ||
         _Device.userAgent.contains('Mac') &&
         _keyDownList.last.keyCode == KeyCode.META && !e.metaKey)) {
      _keyDownList = [];
    }

    var event = new KeyEvent(e);
    event._shadowKeyCode = _normalizeKeyCodes(event);
    // Technically a "keydown" event doesn't have a charCode. This is
    // calculated nonetheless to provide us with more information in giving
    // as much information as possible on keypress about keycode and also
    // charCode.
    event._shadowCharCode = _findCharCodeKeyDown(event);
    if (_keyDownList.length > 0 && event.keyCode != _keyDownList.last.keyCode &&
        !_firesKeyPressEvent(event)) {
      // Some browsers have quirks not firing keypress events where all other
      // browsers do. This makes them more consistent.
      processKeyPress(event);
    }
    _keyDownList.add(event);
    _dispatch(event);
  }

  /** Handle keypress events. */
  void processKeyPress(KeyboardEvent event) {
    var e = new KeyEvent(event);
    // IE reports the character code in the keyCode field for keypress events.
    // There are two exceptions however, Enter and Escape.
    if (_Device.isIE) {
      if (e.keyCode == KeyCode.ENTER || e.keyCode == KeyCode.ESC) {
        e._shadowCharCode = 0;
      } else {
        e._shadowCharCode = e.keyCode;
      }
    } else if (_Device.isOpera) {
      // Opera reports the character code in the keyCode field.
      e._shadowCharCode = KeyCode.isCharacterKey(e.keyCode) ? e.keyCode : 0;
    }
    // Now we guestimate about what the keycode is that was actually
    // pressed, given previous keydown information.
    e._shadowKeyCode = _determineKeyCodeForKeypress(e);

    // Correct the key value for certain browser-specific quirks.
    if (e._shadowKeyIdentifier != null &&
        _keyIdentifier.containsKey(e._shadowKeyIdentifier)) {
      // This is needed for Safari Windows because it currently doesn't give a
      // keyCode/which for non printable keys.
      e._shadowKeyCode = _keyIdentifier[e._shadowKeyIdentifier];
    }
    e._shadowAltKey = _keyDownList.any((var element) => element.altKey);
    _dispatch(e);
  }

  /** Handle keyup events. */
  void processKeyUp(KeyboardEvent event) {
    var e = new KeyEvent(event);
    KeyboardEvent toRemove = null;
    for (var key in _keyDownList) {
      if (key.keyCode == e.keyCode) {
        toRemove = key;
      }
    }
    if (toRemove != null) {
      _keyDownList =
          _keyDownList.where((element) => element != toRemove).toList();
    } else if (_keyDownList.length > 0) {
      // This happens when we've reached some international keyboard case we
      // haven't accounted for or we haven't correctly eliminated all browser
      // inconsistencies. Filing bugs on when this is reached is welcome!
      _keyDownList.removeLast();
    }
    _dispatch(e);
  }
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.


/**
 * Defines the keycode values for keys that are returned by 
 * KeyboardEvent.keyCode.
 * 
 * Important note: There is substantial divergence in how different browsers
 * handle keycodes and their variants in different locales/keyboard layouts. We
 * provide these constants to help make code processing keys more readable.
 */
abstract class KeyCode {
  // These constant names were borrowed from Closure's Keycode enumeration
  // class.
  // http://closure-library.googlecode.com/svn/docs/closure_goog_events_keycodes.js.source.html  
  static const int WIN_KEY_FF_LINUX = 0;
  static const int MAC_ENTER = 3;
  static const int BACKSPACE = 8;
  static const int TAB = 9;
  /** NUM_CENTER is also NUMLOCK for FF and Safari on Mac. */
  static const int NUM_CENTER = 12;
  static const int ENTER = 13;
  static const int SHIFT = 16;
  static const int CTRL = 17;
  static const int ALT = 18;
  static const int PAUSE = 19;
  static const int CAPS_LOCK = 20;
  static const int ESC = 27;
  static const int SPACE = 32;
  static const int PAGE_UP = 33;
  static const int PAGE_DOWN = 34;
  static const int END = 35;
  static const int HOME = 36;
  static const int LEFT = 37;
  static const int UP = 38;
  static const int RIGHT = 39;
  static const int DOWN = 40;
  static const int NUM_NORTH_EAST = 33;
  static const int NUM_SOUTH_EAST = 34;
  static const int NUM_SOUTH_WEST = 35;
  static const int NUM_NORTH_WEST = 36;
  static const int NUM_WEST = 37;
  static const int NUM_NORTH = 38;
  static const int NUM_EAST = 39;
  static const int NUM_SOUTH = 40;
  static const int PRINT_SCREEN = 44;
  static const int INSERT = 45;
  static const int NUM_INSERT = 45;
  static const int DELETE = 46;
  static const int NUM_DELETE = 46;
  static const int ZERO = 48;
  static const int ONE = 49;
  static const int TWO = 50;
  static const int THREE = 51;
  static const int FOUR = 52;
  static const int FIVE = 53;
  static const int SIX = 54;
  static const int SEVEN = 55;
  static const int EIGHT = 56;
  static const int NINE = 57;
  static const int FF_SEMICOLON = 59;
  static const int FF_EQUALS = 61;
  /**
   * CAUTION: The question mark is for US-keyboard layouts. It varies
   * for other locales and keyboard layouts.
   */
  static const int QUESTION_MARK = 63;
  static const int A = 65;
  static const int B = 66;
  static const int C = 67;
  static const int D = 68;
  static const int E = 69;
  static const int F = 70;
  static const int G = 71;
  static const int H = 72;
  static const int I = 73;
  static const int J = 74;
  static const int K = 75;
  static const int L = 76;
  static const int M = 77;
  static const int N = 78;
  static const int O = 79;
  static const int P = 80;
  static const int Q = 81;
  static const int R = 82;
  static const int S = 83;
  static const int T = 84;
  static const int U = 85;
  static const int V = 86;
  static const int W = 87;
  static const int X = 88;
  static const int Y = 89;
  static const int Z = 90;
  static const int META = 91;
  static const int WIN_KEY_LEFT = 91;
  static const int WIN_KEY_RIGHT = 92;
  static const int CONTEXT_MENU = 93;
  static const int NUM_ZERO = 96;
  static const int NUM_ONE = 97;
  static const int NUM_TWO = 98;
  static const int NUM_THREE = 99;
  static const int NUM_FOUR = 100;
  static const int NUM_FIVE = 101;
  static const int NUM_SIX = 102;
  static const int NUM_SEVEN = 103;
  static const int NUM_EIGHT = 104;
  static const int NUM_NINE = 105;
  static const int NUM_MULTIPLY = 106;
  static const int NUM_PLUS = 107;
  static const int NUM_MINUS = 109;
  static const int NUM_PERIOD = 110;
  static const int NUM_DIVISION = 111;
  static const int F1 = 112;
  static const int F2 = 113;
  static const int F3 = 114;
  static const int F4 = 115;
  static const int F5 = 116;
  static const int F6 = 117;
  static const int F7 = 118;
  static const int F8 = 119;
  static const int F9 = 120;
  static const int F10 = 121;
  static const int F11 = 122;
  static const int F12 = 123;
  static const int NUMLOCK = 144;
  static const int SCROLL_LOCK = 145;

  // OS-specific media keys like volume controls and browser controls.
  static const int FIRST_MEDIA_KEY = 166;
  static const int LAST_MEDIA_KEY = 183;

  /**
   * CAUTION: This constant requires localization for other locales and keyboard
   * layouts.
   */
  static const int SEMICOLON = 186;
  /**
   * CAUTION: This constant requires localization for other locales and keyboard
   * layouts.
   */
  static const int DASH = 189;
  /**
   * CAUTION: This constant requires localization for other locales and keyboard
   * layouts.
   */
  static const int EQUALS = 187;
  /**
   * CAUTION: This constant requires localization for other locales and keyboard
   * layouts.
   */
  static const int COMMA = 188;
  /**
   * CAUTION: This constant requires localization for other locales and keyboard
   * layouts.
   */
  static const int PERIOD = 190;
  /**
   * CAUTION: This constant requires localization for other locales and keyboard
   * layouts.
   */
  static const int SLASH = 191;
  /**
   * CAUTION: This constant requires localization for other locales and keyboard
   * layouts.
   */
  static const int APOSTROPHE = 192;
  /**
   * CAUTION: This constant requires localization for other locales and keyboard
   * layouts.
   */
  static const int TILDE = 192;
  /**
   * CAUTION: This constant requires localization for other locales and keyboard
   * layouts.
   */
  static const int SINGLE_QUOTE = 222;
  /**
   * CAUTION: This constant requires localization for other locales and keyboard
   * layouts.
   */
  static const int OPEN_SQUARE_BRACKET = 219;
  /**
   * CAUTION: This constant requires localization for other locales and keyboard
   * layouts.
   */
  static const int BACKSLASH = 220;
  /**
   * CAUTION: This constant requires localization for other locales and keyboard
   * layouts.
   */
  static const int CLOSE_SQUARE_BRACKET = 221;
  static const int WIN_KEY = 224;
  static const int MAC_FF_META = 224;
  static const int WIN_IME = 229;

  /** A sentinel value if the keycode could not be determined. */
  static const int UNKNOWN = -1;

  /**
   * Returns true if the keyCode produces a (US keyboard) character.
   * Note: This does not (yet) cover characters on non-US keyboards (Russian,
   * Hebrew, etc.).
   */
  static bool isCharacterKey(int keyCode) {
    if ((keyCode >= ZERO && keyCode <= NINE) ||
        (keyCode >= NUM_ZERO && keyCode <= NUM_MULTIPLY) ||
        (keyCode >= A && keyCode <= Z)) {
      return true;
    }
 
    // Safari sends zero key code for non-latin characters.
    if (_Device.isWebKit && keyCode == 0) {
      return true;
    }
 
    return (keyCode == SPACE || keyCode == QUESTION_MARK || keyCode == NUM_PLUS
        || keyCode == NUM_MINUS || keyCode == NUM_PERIOD ||
        keyCode == NUM_DIVISION || keyCode == SEMICOLON ||
        keyCode == FF_SEMICOLON || keyCode == DASH || keyCode == EQUALS ||
        keyCode == FF_EQUALS || keyCode == COMMA || keyCode == PERIOD ||
        keyCode == SLASH || keyCode == APOSTROPHE || keyCode == SINGLE_QUOTE ||
        keyCode == OPEN_SQUARE_BRACKET || keyCode == BACKSLASH ||
        keyCode == CLOSE_SQUARE_BRACKET);
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.


/**
 * Defines the standard key locations returned by
 * KeyboardEvent.getKeyLocation.
 */
abstract class KeyLocation {

  /**
   * The event key is not distinguished as the left or right version
   * of the key, and did not originate from the numeric keypad (or did not
   * originate with a virtual key corresponding to the numeric keypad).
   */
  static const int STANDARD = 0;

  /**
   * The event key is in the left key location.
   */
  static const int LEFT = 1;

  /**
   * The event key is in the right key location.
   */
  static const int RIGHT = 2;

  /**
   * The event key originated on the numeric keypad or with a virtual key
   * corresponding to the numeric keypad.
   */
  static const int NUMPAD = 3;

  /**
   * The event key originated on a mobile device, either on a physical
   * keypad or a virtual keyboard.
   */
  static const int MOBILE = 4;

  /**
   * The event key originated on a game controller or a joystick on a mobile
   * device.
   */
  static const int JOYSTICK = 5;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.


/**
 * Defines the standard keyboard identifier names for keys that are returned
 * by KeyEvent.getKeyboardIdentifier when the key does not have a direct
 * unicode mapping.
 */
abstract class KeyName {

  /** The Accept (Commit, OK) key */
  static const String ACCEPT = "Accept";

  /** The Add key */
  static const String ADD = "Add";

  /** The Again key */
  static const String AGAIN = "Again";

  /** The All Candidates key */
  static const String ALL_CANDIDATES = "AllCandidates";

  /** The Alphanumeric key */
  static const String ALPHANUMERIC = "Alphanumeric";

  /** The Alt (Menu) key */
  static const String ALT = "Alt";

  /** The Alt-Graph key */
  static const String ALT_GRAPH = "AltGraph";

  /** The Application key */
  static const String APPS = "Apps";

  /** The ATTN key */
  static const String ATTN = "Attn";

  /** The Browser Back key */
  static const String BROWSER_BACK = "BrowserBack";

  /** The Browser Favorites key */
  static const String BROWSER_FAVORTIES = "BrowserFavorites";

  /** The Browser Forward key */
  static const String BROWSER_FORWARD = "BrowserForward";

  /** The Browser Home key */
  static const String BROWSER_NAME = "BrowserHome";

  /** The Browser Refresh key */
  static const String BROWSER_REFRESH = "BrowserRefresh";

  /** The Browser Search key */
  static const String BROWSER_SEARCH = "BrowserSearch";

  /** The Browser Stop key */
  static const String BROWSER_STOP = "BrowserStop";

  /** The Camera key */
  static const String CAMERA = "Camera";

  /** The Caps Lock (Capital) key */
  static const String CAPS_LOCK = "CapsLock";

  /** The Clear key */
  static const String CLEAR = "Clear";

  /** The Code Input key */
  static const String CODE_INPUT = "CodeInput";

  /** The Compose key */
  static const String COMPOSE = "Compose";

  /** The Control (Ctrl) key */
  static const String CONTROL = "Control";

  /** The Crsel key */
  static const String CRSEL = "Crsel";

  /** The Convert key */
  static const String CONVERT = "Convert";

  /** The Copy key */
  static const String COPY = "Copy";

  /** The Cut key */
  static const String CUT = "Cut";

  /** The Decimal key */
  static const String DECIMAL = "Decimal";

  /** The Divide key */
  static const String DIVIDE = "Divide";

  /** The Down Arrow key */
  static const String DOWN = "Down";

  /** The diagonal Down-Left Arrow key */
  static const String DOWN_LEFT = "DownLeft";

  /** The diagonal Down-Right Arrow key */
  static const String DOWN_RIGHT = "DownRight";

  /** The Eject key */
  static const String EJECT = "Eject";

  /** The End key */
  static const String END = "End";

  /**
   * The Enter key. Note: This key value must also be used for the Return
   *  (Macintosh numpad) key
   */
  static const String ENTER = "Enter";

  /** The Erase EOF key */
  static const String ERASE_EOF= "EraseEof";

  /** The Execute key */
  static const String EXECUTE = "Execute";

  /** The Exsel key */
  static const String EXSEL = "Exsel";

  /** The Function switch key */
  static const String FN = "Fn";

  /** The F1 key */
  static const String F1 = "F1";

  /** The F2 key */
  static const String F2 = "F2";

  /** The F3 key */
  static const String F3 = "F3";

  /** The F4 key */
  static const String F4 = "F4";

  /** The F5 key */
  static const String F5 = "F5";

  /** The F6 key */
  static const String F6 = "F6";

  /** The F7 key */
  static const String F7 = "F7";

  /** The F8 key */
  static const String F8 = "F8";

  /** The F9 key */
  static const String F9 = "F9";

  /** The F10 key */
  static const String F10 = "F10";

  /** The F11 key */
  static const String F11 = "F11";

  /** The F12 key */
  static const String F12 = "F12";

  /** The F13 key */
  static const String F13 = "F13";

  /** The F14 key */
  static const String F14 = "F14";

  /** The F15 key */
  static const String F15 = "F15";

  /** The F16 key */
  static const String F16 = "F16";

  /** The F17 key */
  static const String F17 = "F17";

  /** The F18 key */
  static const String F18 = "F18";

  /** The F19 key */
  static const String F19 = "F19";

  /** The F20 key */
  static const String F20 = "F20";

  /** The F21 key */
  static const String F21 = "F21";

  /** The F22 key */
  static const String F22 = "F22";

  /** The F23 key */
  static const String F23 = "F23";

  /** The F24 key */
  static const String F24 = "F24";

  /** The Final Mode (Final) key used on some asian keyboards */
  static const String FINAL_MODE = "FinalMode";

  /** The Find key */
  static const String FIND = "Find";

  /** The Full-Width Characters key */
  static const String FULL_WIDTH = "FullWidth";

  /** The Half-Width Characters key */
  static const String HALF_WIDTH = "HalfWidth";

  /** The Hangul (Korean characters) Mode key */
  static const String HANGUL_MODE = "HangulMode";

  /** The Hanja (Korean characters) Mode key */
  static const String HANJA_MODE = "HanjaMode";

  /** The Help key */
  static const String HELP = "Help";

  /** The Hiragana (Japanese Kana characters) key */
  static const String HIRAGANA = "Hiragana";

  /** The Home key */
  static const String HOME = "Home";

  /** The Insert (Ins) key */
  static const String INSERT = "Insert";

  /** The Japanese-Hiragana key */
  static const String JAPANESE_HIRAGANA = "JapaneseHiragana";

  /** The Japanese-Katakana key */
  static const String JAPANESE_KATAKANA = "JapaneseKatakana";

  /** The Japanese-Romaji key */
  static const String JAPANESE_ROMAJI = "JapaneseRomaji";

  /** The Junja Mode key */
  static const String JUNJA_MODE = "JunjaMode";

  /** The Kana Mode (Kana Lock) key */
  static const String KANA_MODE = "KanaMode";

  /**
   * The Kanji (Japanese name for ideographic characters of Chinese origin)
   * Mode key
   */
  static const String KANJI_MODE = "KanjiMode";

  /** The Katakana (Japanese Kana characters) key */
  static const String KATAKANA = "Katakana";

  /** The Start Application One key */
  static const String LAUNCH_APPLICATION_1 = "LaunchApplication1";

  /** The Start Application Two key */
  static const String LAUNCH_APPLICATION_2 = "LaunchApplication2";

  /** The Start Mail key */
  static const String LAUNCH_MAIL = "LaunchMail";

  /** The Left Arrow key */
  static const String LEFT = "Left";

  /** The Menu key */
  static const String MENU = "Menu";

  /**
   * The Meta key. Note: This key value shall be also used for the Apple
   * Command key
   */
  static const String META = "Meta";

  /** The Media Next Track key */
  static const String MEDIA_NEXT_TRACK = "MediaNextTrack";

  /** The Media Play Pause key */
  static const String MEDIA_PAUSE_PLAY = "MediaPlayPause";

  /** The Media Previous Track key */
  static const String MEDIA_PREVIOUS_TRACK = "MediaPreviousTrack";

  /** The Media Stop key */
  static const String MEDIA_STOP = "MediaStop";

  /** The Mode Change key */
  static const String MODE_CHANGE = "ModeChange";

  /** The Next Candidate function key */
  static const String NEXT_CANDIDATE = "NextCandidate";

  /** The Nonconvert (Don't Convert) key */
  static const String NON_CONVERT = "Nonconvert";

  /** The Number Lock key */
  static const String NUM_LOCK = "NumLock";

  /** The Page Down (Next) key */
  static const String PAGE_DOWN = "PageDown";

  /** The Page Up key */
  static const String PAGE_UP = "PageUp";

  /** The Paste key */
  static const String PASTE = "Paste";

  /** The Pause key */
  static const String PAUSE = "Pause";

  /** The Play key */
  static const String PLAY = "Play";

  /**
   * The Power key. Note: Some devices may not expose this key to the
   * operating environment
   */
  static const String POWER = "Power";

  /** The Previous Candidate function key */
  static const String PREVIOUS_CANDIDATE = "PreviousCandidate";

  /** The Print Screen (PrintScrn, SnapShot) key */
  static const String PRINT_SCREEN = "PrintScreen";

  /** The Process key */
  static const String PROCESS = "Process";

  /** The Props key */
  static const String PROPS = "Props";

  /** The Right Arrow key */
  static const String RIGHT = "Right";

  /** The Roman Characters function key */
  static const String ROMAN_CHARACTERS = "RomanCharacters";

  /** The Scroll Lock key */
  static const String SCROLL = "Scroll";

  /** The Select key */
  static const String SELECT = "Select";

  /** The Select Media key */
  static const String SELECT_MEDIA = "SelectMedia";

  /** The Separator key */
  static const String SEPARATOR = "Separator";

  /** The Shift key */
  static const String SHIFT = "Shift";

  /** The Soft1 key */
  static const String SOFT_1 = "Soft1";

  /** The Soft2 key */
  static const String SOFT_2 = "Soft2";

  /** The Soft3 key */
  static const String SOFT_3 = "Soft3";

  /** The Soft4 key */
  static const String SOFT_4 = "Soft4";

  /** The Stop key */
  static const String STOP = "Stop";

  /** The Subtract key */
  static const String SUBTRACT = "Subtract";

  /** The Symbol Lock key */
  static const String SYMBOL_LOCK = "SymbolLock";

  /** The Up Arrow key */
  static const String UP = "Up";

  /** The diagonal Up-Left Arrow key */
  static const String UP_LEFT = "UpLeft";

  /** The diagonal Up-Right Arrow key */
  static const String UP_RIGHT = "UpRight";

  /** The Undo key */
  static const String UNDO = "Undo";

  /** The Volume Down key */
  static const String VOLUME_DOWN = "VolumeDown";

  /** The Volume Mute key */
  static const String VOLUMN_MUTE = "VolumeMute";

  /** The Volume Up key */
  static const String VOLUMN_UP = "VolumeUp";

  /** The Windows Logo key */
  static const String WIN = "Win";

  /** The Zoom key */
  static const String ZOOM = "Zoom";

  /**
   * The Backspace (Back) key. Note: This key value shall be also used for the
   * key labeled 'delete' MacOS keyboards when not modified by the 'Fn' key
   */
  static const String BACKSPACE = "Backspace";

  /** The Horizontal Tabulation (Tab) key */
  static const String TAB = "Tab";

  /** The Cancel key */
  static const String CANCEL = "Cancel";

  /** The Escape (Esc) key */
  static const String ESC = "Esc";

  /** The Space (Spacebar) key:   */
  static const String SPACEBAR = "Spacebar";

  /**
   * The Delete (Del) Key. Note: This key value shall be also used for the key
   * labeled 'delete' MacOS keyboards when modified by the 'Fn' key
   */
  static const String DEL = "Del";

  /** The Combining Grave Accent (Greek Varia, Dead Grave) key */
  static const String DEAD_GRAVE = "DeadGrave";

  /**
   * The Combining Acute Accent (Stress Mark, Greek Oxia, Tonos, Dead Eacute)
   * key
   */
  static const String DEAD_EACUTE = "DeadEacute";

  /** The Combining Circumflex Accent (Hat, Dead Circumflex) key */
  static const String DEAD_CIRCUMFLEX = "DeadCircumflex";

  /** The Combining Tilde (Dead Tilde) key */
  static const String DEAD_TILDE = "DeadTilde";

  /** The Combining Macron (Long, Dead Macron) key */
  static const String DEAD_MACRON = "DeadMacron";

  /** The Combining Breve (Short, Dead Breve) key */
  static const String DEAD_BREVE = "DeadBreve";

  /** The Combining Dot Above (Derivative, Dead Above Dot) key */
  static const String DEAD_ABOVE_DOT = "DeadAboveDot";

  /**
   * The Combining Diaeresis (Double Dot Abode, Umlaut, Greek Dialytika,
   * Double Derivative, Dead Diaeresis) key
   */
  static const String DEAD_UMLAUT = "DeadUmlaut";

  /** The Combining Ring Above (Dead Above Ring) key */
  static const String DEAD_ABOVE_RING = "DeadAboveRing";

  /** The Combining Double Acute Accent (Dead Doubleacute) key */
  static const String DEAD_DOUBLEACUTE = "DeadDoubleacute";

  /** The Combining Caron (Hacek, V Above, Dead Caron) key */
  static const String DEAD_CARON = "DeadCaron";

  /** The Combining Cedilla (Dead Cedilla) key */
  static const String DEAD_CEDILLA = "DeadCedilla";

  /** The Combining Ogonek (Nasal Hook, Dead Ogonek) key */
  static const String DEAD_OGONEK = "DeadOgonek";

  /**
   * The Combining Greek Ypogegrammeni (Greek Non-Spacing Iota Below, Iota
   * Subscript, Dead Iota) key
   */
  static const String DEAD_IOTA = "DeadIota";

  /**
   * The Combining Katakana-Hiragana Voiced Sound Mark (Dead Voiced Sound) key
   */
  static const String DEAD_VOICED_SOUND = "DeadVoicedSound";

  /**
   * The Combining Katakana-Hiragana Semi-Voiced Sound Mark (Dead Semivoiced
   * Sound) key
   */
  static const String DEC_SEMIVOICED_SOUND= "DeadSemivoicedSound";

  /**
   * Key value used when an implementation is unable to identify another key
   * value, due to either hardware, platform, or software constraints
   */
  static const String UNIDENTIFIED = "Unidentified";
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.


/**
 * Contains the set of standard values returned by HTMLDocument.getReadyState.
 */
abstract class ReadyState {
  /**
   * Indicates the document is still loading and parsing.
   */
  static const String LOADING = "loading";

  /**
   * Indicates the document is finished parsing but is still loading
   * subresources.
   */
  static const String INTERACTIVE = "interactive";

  /**
   * Indicates the document and all subresources have been loaded.
   */
  static const String COMPLETE = "complete";
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.


// TODO(antonm): support not DOM isolates too.
class _Timer implements Timer {
  final canceller;

  _Timer(this.canceller);

  void cancel() { canceller(); }
}

get _timerFactoryClosure => (int milliSeconds, void callback(Timer timer), bool repeating) {
  var maker;
  var canceller;
  if (repeating) {
    maker = window.setInterval;
    canceller = window.clearInterval;
  } else {
    maker = window.setTimeout;
    canceller = window.clearTimeout;
  }
  Timer timer;
  final int id = maker(() { callback(timer); }, milliSeconds);
  timer = new _Timer(() { canceller(id); });
  return timer;
};
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.


class _HttpRequestUtils {

  // Helper for factory HttpRequest.get
  static HttpRequest get(String url,
                            onComplete(HttpRequest request),
                            bool withCredentials) {
    final request = new HttpRequest();
    request.open('GET', url, true);

    request.withCredentials = withCredentials;

    request.onReadyStateChange.listen((e) {
      if (request.readyState == HttpRequest.DONE) {
        onComplete(request);
      }
    });

    request.send();

    return request;
  }
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.


class _CssStyleDeclarationFactoryProvider {
  static CssStyleDeclaration createCssStyleDeclaration_css(String css) {
    final style = new Element.tag('div').style;
    style.cssText = css;
    return style;
  }

  static CssStyleDeclaration createCssStyleDeclaration() {
    return new CssStyleDeclaration.css('');
  }
}

class _DocumentFragmentFactoryProvider {
  @DomName('Document.createDocumentFragment')
  static DocumentFragment createDocumentFragment() =>
      document.createDocumentFragment();

  static DocumentFragment createDocumentFragment_html(String html) {
    final fragment = new DocumentFragment();
    fragment.innerHtml = html;
    return fragment;
  }

  // TODO(nweiz): enable this when XML is ported.
  // factory DocumentFragment.xml(String xml) {
  //   final fragment = new DocumentFragment();
  //   final e = new XMLElement.tag("xml");
  //   e.innerHtml = xml;
  //
  //   // Copy list first since we don't want liveness during iteration.
  //   final List nodes = new List.from(e.nodes);
  //   fragment.nodes.addAll(nodes);
  //   return fragment;
  // }

  static DocumentFragment createDocumentFragment_svg(String svgContent) {
    final fragment = new DocumentFragment();
    final e = new svg.SvgSvgElement();
    e.innerHtml = svgContent;

    // Copy list first since we don't want liveness during iteration.
    final List nodes = new List.from(e.nodes);
    fragment.nodes.addAll(nodes);
    return fragment;
  }
}
/**
 * A custom KeyboardEvent that attempts to eliminate cross-browser
 * inconsistencies, and also provide both keyCode and charCode information
 * for all key events (when such information can be determined).
 *
 * This class is very much a work in progress, and we'd love to get information
 * on how we can make this class work with as many international keyboards as
 * possible. Bugs welcome!
 */
class KeyEvent implements KeyboardEvent {
  /** The parent KeyboardEvent that this KeyEvent is wrapping and "fixing". */
  KeyboardEvent _parent;

  /** The "fixed" value of whether the alt key is being pressed. */
  bool _shadowAltKey;

  /** Caculated value of what the estimated charCode is for this event. */
  int _shadowCharCode;

  /** Caculated value of what the estimated keyCode is for this event. */
  int _shadowKeyCode;

  /** Caculated value of what the estimated keyCode is for this event. */
  int get keyCode => _shadowKeyCode;

  /** Caculated value of what the estimated charCode is for this event. */
  int get charCode => this.type == 'keypress' ? _shadowCharCode : 0;

  /** Caculated value of whether the alt key is pressed is for this event. */
  bool get altKey => _shadowAltKey;

  /** Caculated value of what the estimated keyCode is for this event. */
  int get which => keyCode;

  /** Accessor to the underlying keyCode value is the parent event. */
  int get _realKeyCode => _parent.keyCode;

  /** Accessor to the underlying charCode value is the parent event. */
  int get _realCharCode => _parent.charCode;

  /** Accessor to the underlying altKey value is the parent event. */
  bool get _realAltKey => _parent.altKey;

  /** Construct a KeyEvent with [parent] as event we're emulating. */
  KeyEvent(KeyboardEvent parent) {
    _parent = parent;
    _shadowAltKey = _realAltKey;
    _shadowCharCode = _realCharCode;
    _shadowKeyCode = _realKeyCode;
  }

  /** True if the altGraphKey is pressed during this event. */
  bool get altGraphKey => _parent.altGraphKey;
  bool get bubbles => _parent.bubbles;
  /** True if this event can be cancelled. */
  bool get cancelable => _parent.cancelable;
  bool get cancelBubble => _parent.cancelBubble;
  void set cancelBubble(bool cancel) {
    _parent.cancelBubble = cancel;
  }
  /** Accessor to the clipboardData available for this event. */
  Clipboard get clipboardData => _parent.clipboardData;
  /** True if the ctrl key is pressed during this event. */
  bool get ctrlKey => _parent.ctrlKey;
  /** Accessor to the target this event is listening to for changes. */
  EventTarget get currentTarget => _parent.currentTarget;
  bool get defaultPrevented => _parent.defaultPrevented;
  int get detail => _parent.detail;
  int get eventPhase => _parent.eventPhase;
  /**
   * Accessor to the part of the keyboard that the key was pressed from (one of
   * KeyLocation.STANDARD, KeyLocation.RIGHT, KeyLocation.LEFT,
   * KeyLocation.NUMPAD, KeyLocation.MOBILE, KeyLocation.JOYSTICK).
   */
  int get keyLocation => _parent.keyLocation;
  int get layerX => _parent.layerX;
  int get layerY => _parent.layerY;
  /** True if the Meta (or Mac command) key is pressed during this event. */
  bool get metaKey => _parent.metaKey;
  int get pageX => _parent.pageX;
  int get pageY => _parent.pageY;
  bool get returnValue => _parent.returnValue;
  void set returnValue(bool value) {
    _parent.returnValue = value;
  }
  /** True if the shift key was pressed during this event. */
  bool get shiftKey => _parent.shiftKey;
  int get timeStamp => _parent.timeStamp;
  /**
   * The type of key event that occurred. One of "keydown", "keyup", or
   * "keypress".
   */
  String get type => _parent.type;
  Window get view => _parent.view;
  void preventDefault() => _parent.preventDefault();
  void stopImmediatePropagation() => _parent.stopImmediatePropagation();
  void stopPropagation() => _parent.stopPropagation();
  void $dom_initUIEvent(String type, bool canBubble, bool cancelable,
      Window view, int detail) {
    throw new UnsupportedError("Cannot initialize a UI Event from a KeyEvent.");
  }
  void $dom_initEvent(String eventTypeArg, bool canBubbleArg,
      bool cancelableArg) {
    throw new UnsupportedError("Cannot initialize an Event from a KeyEvent.");
  }
  String get _shadowKeyIdentifier => _parent.$dom_keyIdentifier;

  int get $dom_charCode => charCode;
  int get $dom_keyCode => keyCode;
  EventTarget get target => _parent.target;
  String get $dom_keyIdentifier {
    throw new UnsupportedError("keyIdentifier is unsupported.");
  }
  void $dom_initKeyboardEvent(String type, bool canBubble, bool cancelable,
      Window view, String keyIdentifier, int keyLocation, bool ctrlKey,
      bool altKey, bool shiftKey, bool metaKey,
      bool altGraphKey) {
    throw new UnsupportedError(
        "Cannot initialize a KeyboardEvent from a KeyEvent.");
  }
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.


class _TypedArrayFactoryProvider {
  static Float32Array createFloat32Array(int length) => _F32(length);
  static Float32Array createFloat32Array_fromList(List<num> list) =>
      _F32(ensureNative(list));
  static Float32Array createFloat32Array_fromBuffer(ArrayBuffer buffer,
      [int byteOffset = 0, int length]) => _F32(buffer, byteOffset, length);
  static _F32(arg0, [arg1, arg2]) native "Float32Array_constructor_Callback";

  static Float64Array createFloat64Array(int length) => _F64(length);
  static Float64Array createFloat64Array_fromList(List<num> list) =>
      _F64(ensureNative(list));
  static Float64Array createFloat64Array_fromBuffer(ArrayBuffer buffer,
      [int byteOffset = 0, int length]) => _F64(buffer, byteOffset, length);
  static _F64(arg0, [arg1, arg2]) native "Float64Array_constructor_Callback";

  static Int8Array createInt8Array(int length) => _I8(length);
  static Int8Array createInt8Array_fromList(List<num> list) =>
      _I8(ensureNative(list));
  static Int8Array createInt8Array_fromBuffer(ArrayBuffer buffer,
      [int byteOffset = 0, int length]) => _I8(buffer, byteOffset, length);
  static _I8(arg0, [arg1, arg2]) native "Int8Array_constructor_Callback";

  static Int16Array createInt16Array(int length) => _I16(length);
  static Int16Array createInt16Array_fromList(List<num> list) =>
      _I16(ensureNative(list));
  static Int16Array createInt16Array_fromBuffer(ArrayBuffer buffer,
      [int byteOffset = 0, int length]) => _I16(buffer, byteOffset, length);
  static _I16(arg0, [arg1, arg2]) native "Int16Array_constructor_Callback";

  static Int32Array createInt32Array(int length) => _I32(length);
  static Int32Array createInt32Array_fromList(List<num> list) =>
      _I32(ensureNative(list));
  static Int32Array createInt32Array_fromBuffer(ArrayBuffer buffer,
      [int byteOffset = 0, int length]) => _I32(buffer, byteOffset, length);
  static _I32(arg0, [arg1, arg2]) native "Int32Array_constructor_Callback";

  static Uint8Array createUint8Array(int length) => _U8(length);
  static Uint8Array createUint8Array_fromList(List<num> list) =>
      _U8(ensureNative(list));
  static Uint8Array createUint8Array_fromBuffer(ArrayBuffer buffer,
      [int byteOffset = 0, int length]) => _U8(buffer, byteOffset, length);
  static _U8(arg0, [arg1, arg2]) native "Uint8Array_constructor_Callback";

  static Uint16Array createUint16Array(int length) => _U16(length);
  static Uint16Array createUint16Array_fromList(List<num> list) =>
      _U16(ensureNative(list));
  static Uint16Array createUint16Array_fromBuffer(ArrayBuffer buffer,
      [int byteOffset = 0, int length]) => _U16(buffer, byteOffset, length);
  static _U16(arg0, [arg1, arg2]) native "Uint16Array_constructor_Callback";

  static Uint32Array createUint32Array(int length) => _U32(length);
  static Uint32Array createUint32Array_fromList(List<num> list) =>
      _U32(ensureNative(list));
  static Uint32Array createUint32Array_fromBuffer(ArrayBuffer buffer,
      [int byteOffset = 0, int length]) => _U32(buffer, byteOffset, length);
  static _U32(arg0, [arg1, arg2]) native "Uint32Array_constructor_Callback";

  static Uint8ClampedArray createUint8ClampedArray(int length) => _U8C(length);
  static Uint8ClampedArray createUint8ClampedArray_fromList(
      List<num> list) => _U8C(ensureNative(list));
  static Uint8ClampedArray createUint8ClampedArray_fromBuffer(
      ArrayBuffer buffer, [int byteOffset = 0, int length]) =>
      _U8C(buffer, byteOffset, length);
  static _U8C(arg0, [arg1, arg2]) native "Uint8ClampedArray_constructor_Callback";

  static ensureNative(List list) => list;  // TODO: make sure.
}

class _TextFactoryProvider {
  static Text createText(String data) => document.$dom_createTextNode(data);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.


/**
 * Utils for device detection.
 */
class _Device {
  /**
   * Gets the browser's user agent. Using this function allows tests to inject
   * the user agent.
   * Returns the user agent.
   */
  static String get userAgent => window.navigator.userAgent;

  /**
   * Determines if the current device is running Opera.
   */
  static bool get isOpera => userAgent.contains("Opera", 0);

  /**
   * Determines if the current device is running Internet Explorer.
   */
  static bool get isIE => !isOpera && userAgent.contains("MSIE", 0);

  /**
   * Determines if the current device is running Firefox.
   */
  static bool get isFirefox => userAgent.contains("Firefox", 0);

  /**
   * Determines if the current device is running WebKit.
   */
  static bool get isWebKit => !isOpera && userAgent.contains("WebKit", 0);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.


_serialize(var message) {
  return new _JsSerializer().traverse(message);
}

class _JsSerializer extends _Serializer {

  visitSendPortSync(SendPortSync x) {
    if (x is _JsSendPortSync) return visitJsSendPortSync(x);
    if (x is _LocalSendPortSync) return visitLocalSendPortSync(x);
    if (x is _RemoteSendPortSync) return visitRemoteSendPortSync(x);
    throw "Unknown port type $x";
  }

  visitJsSendPortSync(_JsSendPortSync x) {
    return [ 'sendport', 'nativejs', x._id ];
  }

  visitLocalSendPortSync(_LocalSendPortSync x) {
    return [ 'sendport', 'dart',
             ReceivePortSync._isolateId, x._receivePort._portId ];
  }

  visitSendPort(SendPort x) {
    throw new UnimplementedError('Asynchronous send port not yet implemented.');
  }

  visitRemoteSendPortSync(_RemoteSendPortSync x) {
    return [ 'sendport', 'dart', x._isolateId, x._portId ];
  }
}

_deserialize(var message) {
  return new _JsDeserializer().deserialize(message);
}


class _JsDeserializer extends _Deserializer {

  static const _UNSPECIFIED = const Object();

  deserializeSendPort(List x) {
    String tag = x[1];
    switch (tag) {
      case 'nativejs':
        num id = x[2];
        return new _JsSendPortSync(id);
      case 'dart':
        num isolateId = x[2];
        num portId = x[3];
        return ReceivePortSync._lookup(isolateId, portId);
      default:
        throw 'Illegal SendPortSync type: $tag';
    }
  }
}

// The receiver is JS.
class _JsSendPortSync implements SendPortSync {

  num _id;
  _JsSendPortSync(this._id);

  callSync(var message) {
    var serialized = _serialize(message);
    var result = _callPortSync(_id, serialized);
    return _deserialize(result);
  }

  bool operator==(var other) {
    return (other is _JsSendPortSync) && (_id == other._id);
  }

  int get hashCode => _id;
}

// TODO(vsm): Differentiate between Dart2Js and Dartium isolates.
// The receiver is a different Dart isolate, compiled to JS.
class _RemoteSendPortSync implements SendPortSync {

  int _isolateId;
  int _portId;
  _RemoteSendPortSync(this._isolateId, this._portId);

  callSync(var message) {
    var serialized = _serialize(message);
    var result = _call(_isolateId, _portId, serialized);
    return _deserialize(result);
  }

  static _call(int isolateId, int portId, var message) {
    var target = 'dart-port-$isolateId-$portId';
    // TODO(vsm): Make this re-entrant.
    // TODO(vsm): Set this up set once, on the first call.
    var source = '$target-result';
    var result = null;
    var listener = (Event e) {
      result = json.parse(_getPortSyncEventData(e));
    };
    window.on[source].add(listener);
    _dispatchEvent(target, [source, message]);
    window.on[source].remove(listener);
    return result;
  }

  bool operator==(var other) {
    return (other is _RemoteSendPortSync) && (_isolateId == other._isolateId)
      && (_portId == other._portId);
  }

  int get hashCode => _isolateId >> 16 + _portId;
}

// The receiver is in the same Dart isolate, compiled to JS.
class _LocalSendPortSync implements SendPortSync {

  ReceivePortSync _receivePort;

  _LocalSendPortSync._internal(this._receivePort);

  callSync(var message) {
    // TODO(vsm): Do a more efficient deep copy.
    var copy = _deserialize(_serialize(message));
    var result = _receivePort._callback(copy);
    return _deserialize(_serialize(result));
  }

  bool operator==(var other) {
    return (other is _LocalSendPortSync)
      && (_receivePort == other._receivePort);
  }

  int get hashCode => _receivePort.hashCode;
}

// TODO(vsm): Move this to dart:isolate.  This will take some
// refactoring as there are dependences here on the DOM.  Users
// interact with this class (or interface if we change it) directly -
// new ReceivePortSync.  I think most of the DOM logic could be
// delayed until the corresponding SendPort is registered on the
// window.

// A Dart ReceivePortSync (tagged 'dart' when serialized) is
// identifiable / resolvable by the combination of its isolateid and
// portid.  When a corresponding SendPort is used within the same
// isolate, the _portMap below can be used to obtain the
// ReceivePortSync directly.  Across isolates (or from JS), an
// EventListener can be used to communicate with the port indirectly.
class ReceivePortSync {

  static Map<int, ReceivePortSync> _portMap;
  static int _portIdCount;
  static int _cachedIsolateId;

  num _portId;
  Function _callback;
  EventListener _listener;

  ReceivePortSync() {
    if (_portIdCount == null) {
      _portIdCount = 0;
      _portMap = new Map<int, ReceivePortSync>();
    }
    _portId = _portIdCount++;
    _portMap[_portId] = this;
  }

  static int get _isolateId {
    // TODO(vsm): Make this coherent with existing isolate code.
    if (_cachedIsolateId == null) {
      _cachedIsolateId = _getNewIsolateId();
    }
    return _cachedIsolateId;
  }

  static String _getListenerName(isolateId, portId) =>
      'dart-port-$isolateId-$portId';
  String get _listenerName => _getListenerName(_isolateId, _portId);

  void receive(callback(var message)) {
    _callback = callback;
    if (_listener == null) {
      _listener = (Event e) {
        var data = json.parse(_getPortSyncEventData(e));
        var replyTo = data[0];
        var message = _deserialize(data[1]);
        var result = _callback(message);
        _dispatchEvent(replyTo, _serialize(result));
      };
      window.on[_listenerName].add(_listener);
    }
  }

  void close() {
    _portMap.remove(_portId);
    if (_listener != null) window.on[_listenerName].remove(_listener);
  }

  SendPortSync toSendPort() {
    return new _LocalSendPortSync._internal(this);
  }

  static SendPortSync _lookup(int isolateId, int portId) {
    if (isolateId == _isolateId) {
      return _portMap[portId].toSendPort();
    } else {
      return new _RemoteSendPortSync(isolateId, portId);
    }
  }
}

get _isolateId => ReceivePortSync._isolateId;

void _dispatchEvent(String receiver, var message) {
  var event = new CustomEvent(receiver, canBubble: false, cancelable:false,
    detail: json.stringify(message));
  window.dispatchEvent(event);
}

String _getPortSyncEventData(CustomEvent event) => event.detail;
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.


typedef void _MicrotaskCallback();

/**
 * This class attempts to invoke a callback as soon as the current event stack
 * unwinds, but before the browser repaints.
 */
abstract class _MicrotaskScheduler {
  bool _nextMicrotaskFrameScheduled = false;
  _MicrotaskCallback _callback;

  _MicrotaskScheduler(this._callback);

  /**
   * Creates the best possible microtask scheduler for the current platform.
   */
  factory _MicrotaskScheduler.best(_MicrotaskCallback callback) {
    if (Window._supportsSetImmediate) {
      return new _SetImmediateScheduler(callback);
    } else if (MutationObserver.supported) {
      return new _MutationObserverScheduler(callback);
    }
    return new _PostMessageScheduler(callback);
  }

  /**
   * Schedules a microtask callback if one has not been scheduled already.
   */
  void maybeSchedule() {
    if (this._nextMicrotaskFrameScheduled) {
      return;
    }
    this._nextMicrotaskFrameScheduled = true;
    this._schedule();
  }

  /**
   * Does the actual scheduling of the callback.
   */
  void _schedule();

  /**
   * Handles the microtask callback and forwards it if necessary.
   */
  void _onCallback() {
    // Ignore spurious messages.
    if (!_nextMicrotaskFrameScheduled) {
      return;
    }
    _nextMicrotaskFrameScheduled = false;
    this._callback();
  }
}

/**
 * Scheduler which uses window.postMessage to schedule events.
 */
class _PostMessageScheduler extends _MicrotaskScheduler {
  const _MICROTASK_MESSAGE = "DART-MICROTASK";

  _PostMessageScheduler(_MicrotaskCallback callback): super(callback) {
      // Messages from other windows do not cause a security risk as
      // all we care about is that _handleMessage is called
      // after the current event loop is unwound and calling the function is
      // a noop when zero requests are pending.
      window.onMessage.listen(this._handleMessage);
  }

  void _schedule() {
    window.postMessage(_MICROTASK_MESSAGE, "*");
  }

  void _handleMessage(e) {
    this._onCallback();
  }
}

/**
 * Scheduler which uses a MutationObserver to schedule events.
 */
class _MutationObserverScheduler extends _MicrotaskScheduler {
  MutationObserver _observer;
  Element _dummy;

  _MutationObserverScheduler(_MicrotaskCallback callback): super(callback) {
    // Mutation events get fired as soon as the current event stack is unwound
    // so we just make a dummy event and listen for that.
    _observer = new MutationObserver(this._handleMutation);
    _dummy = new DivElement();
    _observer.observe(_dummy, attributes: true);
  }

  void _schedule() {
    // Toggle it to trigger the mutation event.
    _dummy.hidden = !_dummy.hidden;
  }

  _handleMutation(List<MutationRecord> mutations, MutationObserver observer) {
    this._onCallback();
  }
}

/**
 * Scheduler which uses window.setImmediate to schedule events.
 */
class _SetImmediateScheduler extends _MicrotaskScheduler {
  _SetImmediateScheduler(_MicrotaskCallback callback): super(callback);

  void _schedule() {
    window._setImmediate(_handleImmediate);
  }

  void _handleImmediate() {
    this._onCallback();
  }
}

List<TimeoutHandler> _pendingMicrotasks;
_MicrotaskScheduler _microtaskScheduler = null;

void _maybeScheduleMicrotaskFrame() {
  if (_microtaskScheduler == null) {
    _microtaskScheduler =
      new _MicrotaskScheduler.best(_completeMicrotasks);
  }
  _microtaskScheduler.maybeSchedule();
}

/**
 * Registers a [callback] which is called after the current execution stack
 * unwinds.
 */
void _addMicrotaskCallback(TimeoutHandler callback) {
  if (_pendingMicrotasks == null) {
    _pendingMicrotasks = <TimeoutHandler>[];
    _maybeScheduleMicrotaskFrame();
  }
  _pendingMicrotasks.add(callback);
}


/**
 * Complete all pending microtasks.
 */
void _completeMicrotasks() {
  var callbacks = _pendingMicrotasks;
  _pendingMicrotasks = null;
  for (var callback in callbacks) {
    callback();
  }
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// Patch file for the dart:isolate library.


/********************************************************
  Inserted from lib/isolate/serialization.dart
 ********************************************************/

class _MessageTraverserVisitedMap {

  operator[](var object) => null;
  void operator[]=(var object, var info) { }

  void reset() { }
  void cleanup() { }

}

/** Abstract visitor for dart objects that can be sent as isolate messages. */
abstract class _MessageTraverser {

  _MessageTraverserVisitedMap _visited;
  _MessageTraverser() : _visited = new _MessageTraverserVisitedMap();

  /** Visitor's entry point. */
  traverse(var x) {
    if (isPrimitive(x)) return visitPrimitive(x);
    _visited.reset();
    var result;
    try {
      result = _dispatch(x);
    } finally {
      _visited.cleanup();
    }
    return result;
  }

  _dispatch(var x) {
    if (isPrimitive(x)) return visitPrimitive(x);
    if (x is List) return visitList(x);
    if (x is Map) return visitMap(x);
    if (x is SendPort) return visitSendPort(x);
    if (x is SendPortSync) return visitSendPortSync(x);

    // Overridable fallback.
    return visitObject(x);
  }

  visitPrimitive(x);
  visitList(List x);
  visitMap(Map x);
  visitSendPort(SendPort x);
  visitSendPortSync(SendPortSync x);

  visitObject(Object x) {
    // TODO(floitsch): make this a real exception. (which one)?
    throw "Message serialization: Illegal value $x passed";
  }

  static bool isPrimitive(x) {
    return (x == null) || (x is String) || (x is num) || (x is bool);
  }
}


/** Visitor that serializes a message as a JSON array. */
abstract class _Serializer extends _MessageTraverser {
  int _nextFreeRefId = 0;

  visitPrimitive(x) => x;

  visitList(List list) {
    int copyId = _visited[list];
    if (copyId != null) return ['ref', copyId];

    int id = _nextFreeRefId++;
    _visited[list] = id;
    var jsArray = _serializeList(list);
    // TODO(floitsch): we are losing the generic type.
    return ['list', id, jsArray];
  }

  visitMap(Map map) {
    int copyId = _visited[map];
    if (copyId != null) return ['ref', copyId];

    int id = _nextFreeRefId++;
    _visited[map] = id;
    var keys = _serializeList(map.keys.toList());
    var values = _serializeList(map.values.toList());
    // TODO(floitsch): we are losing the generic type.
    return ['map', id, keys, values];
  }

  _serializeList(List list) {
    int len = list.length;
    var result = new List.fixedLength(len);
    for (int i = 0; i < len; i++) {
      result[i] = _dispatch(list[i]);
    }
    return result;
  }
}

/** Deserializes arrays created with [_Serializer]. */
abstract class _Deserializer {
  Map<int, dynamic> _deserialized;

  _Deserializer();

  static bool isPrimitive(x) {
    return (x == null) || (x is String) || (x is num) || (x is bool);
  }

  deserialize(x) {
    if (isPrimitive(x)) return x;
    // TODO(floitsch): this should be new HashMap<int, dynamic>()
    _deserialized = new HashMap();
    return _deserializeHelper(x);
  }

  _deserializeHelper(x) {
    if (isPrimitive(x)) return x;
    assert(x is List);
    switch (x[0]) {
      case 'ref': return _deserializeRef(x);
      case 'list': return _deserializeList(x);
      case 'map': return _deserializeMap(x);
      case 'sendport': return deserializeSendPort(x);
      default: return deserializeObject(x);
    }
  }

  _deserializeRef(List x) {
    int id = x[1];
    var result = _deserialized[id];
    assert(result != null);
    return result;
  }

  List _deserializeList(List x) {
    int id = x[1];
    // We rely on the fact that Dart-lists are directly mapped to Js-arrays.
    List dartList = x[2];
    _deserialized[id] = dartList;
    int len = dartList.length;
    for (int i = 0; i < len; i++) {
      dartList[i] = _deserializeHelper(dartList[i]);
    }
    return dartList;
  }

  Map _deserializeMap(List x) {
    Map result = new Map();
    int id = x[1];
    _deserialized[id] = result;
    List keys = x[2];
    List values = x[3];
    int len = keys.length;
    assert(len == values.length);
    for (int i = 0; i < len; i++) {
      var key = _deserializeHelper(keys[i]);
      var value = _deserializeHelper(values[i]);
      result[key] = value;
    }
    return result;
  }

  deserializeSendPort(List x);

  deserializeObject(List x) {
    // TODO(floitsch): Use real exception (which one?).
    throw "Unexpected serialized object";
  }
}

// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.


// Iterator for arrays with fixed size.
class FixedSizeListIterator<T> implements Iterator<T> {
  final List<T> _array;
  final int _length;  // Cache array length for faster access.
  int _position;
  T _current;
  
  FixedSizeListIterator(List<T> array)
      : _array = array,
        _position = -1,
        _length = array.length;

  bool moveNext() {
    int nextPosition = _position + 1;
    if (nextPosition < _length) {
      _current = _array[nextPosition];
      _position = nextPosition;
      return true;
    }
    _current = null;
    _position = _length;
    return false;
  }

  T get current => _current;
}

// Iterator for arrays with variable size.
class _VariableSizeListIterator<T> implements Iterator<T> {
  final List<T> _array;
  int _position;
  T _current;

  _VariableSizeListIterator(List<T> array)
      : _array = array,
        _position = -1;

  bool moveNext() {
    int nextPosition = _position + 1;
    if (nextPosition < _array.length) {
      _current = _array[nextPosition];
      _position = nextPosition;
      return true;
    }
    _current = null;
    _position = _array.length;
    return false;
  }

  T get current => _current;
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.


// This API is exploratory.
spawnDomFunction(Function topLevelFunction) => _Utils.spawnDomFunctionImpl(topLevelFunction);

// testRunner implementation.
// FIXME: provide a separate lib for testRunner.

var _testRunner;

TestRunner get testRunner {
  if (_testRunner == null)
    _testRunner = new TestRunner._(_NPObject.retrieve("testRunner"));
  return _testRunner;
}

class TestRunner {
  final _NPObject _npObject;

  TestRunner._(this._npObject);

  display() => _npObject.invoke('display');
  dumpAsText() => _npObject.invoke('dumpAsText');
  notifyDone() => _npObject.invoke('notifyDone');
  setCanOpenWindows() => _npObject.invoke('setCanOpenWindows');
  waitUntilDone() => _npObject.invoke('waitUntilDone');
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.


class _Utils {
  static List convertToList(List list) {
    // FIXME: [possible optimization]: do not copy the array if Dart_IsArray is fine w/ it.
    final length = list.length;
    List result = new List.fixedLength(length);
    result.setRange(0, length, list);
    return result;
  }

  static List convertMapToList(Map map) {
    List result = [];
    map.forEach((k, v) => result.addAll([k, v]));
    return result;
  }

  static void populateMap(Map result, List list) {
    for (int i = 0; i < list.length; i += 2) {
      result[list[i]] = list[i + 1];
    }
  }

  static bool isMap(obj) => obj is Map;

  static Map createMap() => {};

  static makeUnimplementedError(String fileName, int lineNo) {
    return new UnsupportedError('[info: $fileName:$lineNo]');
  }

  static window() native "Utils_window";
  static print(String message) native "Utils_print";
  static SendPort spawnDomFunctionImpl(Function topLevelFunction) native "Utils_spawnDomFunction";
  static int _getNewIsolateId() native "Utils_getNewIsolateId";
  static bool shadowRootSupported(Document document) native "Utils_shadowRootSupported";
}

class _NPObject extends NativeFieldWrapperClass1 {
  _NPObject.internal();
  static _NPObject retrieve(String key) native "NPObject_retrieve";
  property(String propertyName) native "NPObject_property";
  invoke(String methodName, [List args = null]) native "NPObject_invoke";
}

class _DOMWindowCrossFrame extends NativeFieldWrapperClass1 implements
    WindowBase {
  _DOMWindowCrossFrame.internal();

  // Fields.
  HistoryBase get history native "DOMWindow_history_cross_frame_Getter";
  LocationBase get location native "DOMWindow_location_cross_frame_Getter";
  bool get closed native "DOMWindow_closed_Getter";
  int get length native "DOMWindow_length_Getter";
  WindowBase get opener native "DOMWindow_opener_Getter";
  WindowBase get parent native "DOMWindow_parent_Getter";
  WindowBase get top native "DOMWindow_top_Getter";

  // Methods.
  void close() native "DOMWindow_close_Callback";
  void postMessage(/*SerializedScriptValue*/ message, String targetOrigin, [List messagePorts]) native "DOMWindow_postMessage_Callback";

  // Implementation support.
  String get typeName => "DOMWindow";
}

class _HistoryCrossFrame extends NativeFieldWrapperClass1 implements HistoryBase {
  _HistoryCrossFrame.internal();

  // Methods.
  void back() native "History_back_Callback";
  void forward() native "History_forward_Callback";
  void go(int distance) native "History_go_Callback";

  // Implementation support.
  String get typeName => "History";
}

class _LocationCrossFrame extends NativeFieldWrapperClass1 implements LocationBase {
  _LocationCrossFrame.internal();

  // Fields.
  void set href(String) native "Location_href_Setter";

  // Implementation support.
  String get typeName => "Location";
}

class _DOMStringMap extends NativeFieldWrapperClass1 implements Map<String, String> {
  _DOMStringMap.internal();

  bool containsValue(String value) => Maps.containsValue(this, value);
  bool containsKey(String key) native "DOMStringMap_containsKey_Callback";
  String operator [](String key) native "DOMStringMap_item_Callback";
  void operator []=(String key, String value) native "DOMStringMap_setItem_Callback";
  String putIfAbsent(String key, String ifAbsent()) => Maps.putIfAbsent(this, key, ifAbsent);
  String remove(String key) native "DOMStringMap_remove_Callback";
  void clear() => Maps.clear(this);
  void forEach(void f(String key, String value)) => Maps.forEach(this, f);
  Collection<String> get keys native "DOMStringMap_getKeys_Callback";
  Collection<String> get values => Maps.getValues(this);
  int get length => Maps.length(this);
  bool get isEmpty => Maps.isEmpty(this);
}

get _printClosure => (s) {
  try {
    window.console.log(s);
  } catch (_) {
    _Utils.print(s);
  }
};
