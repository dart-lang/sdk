// Copyright (c) 2023, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.
//
// This file has been automatically generated. Please do not edit it manually.
// Generated by tests/ffi/generator/structs_by_value_tests_generator.dart.
//
// SharedObjects=ffi_test_functions
// VMOptions=
// VMOptions=--deterministic --optimization-counter-threshold=90
// VMOptions=--use-slow-path
// VMOptions=--use-slow-path --stacktrace-every=100

import 'dart:ffi';

import "package:expect/expect.dart";
import "package:ffi/ffi.dart";

import 'dylib_utils.dart';

// Reuse the compound classes.
import 'function_structs_by_value_generated_compounds.dart';

final ffiTestFunctions = dlopenPlatformSpecific("ffi_test_functions");
void main() {
  // Force dlopen so @Native lookups in DynamicLibrary.process() succeed.
  dlopenGlobalPlatformSpecific('ffi_test_functions');

  for (int i = 0; i < 100; ++i) {
    testPassStruct1ByteIntx10Native();
    testPassStruct3BytesHomogeneousUint8x10Native();
    testPassStruct3BytesInt2ByteAlignedx10Native();
    testPassStruct4BytesHomogeneousInt16x10Native();
    testPassStruct7BytesHomogeneousUint8x10Native();
    testPassStruct7BytesInt4ByteAlignedx10Native();
    testPassStruct8BytesIntx10Native();
    testPassStruct8BytesHomogeneousFloatx10Native();
    testPassStruct8BytesMixedx10Native();
    testPassStruct9BytesHomogeneousUint8x10Native();
    testPassStruct9BytesInt4Or8ByteAlignedx10Native();
    testPassStruct12BytesHomogeneousFloatx6Native();
    testPassStruct16BytesHomogeneousFloatx5Native();
    testPassStruct16BytesMixedx10Native();
    testPassStruct16BytesMixed2x10Native();
    testPassStruct17BytesIntx10Native();
    testPassStruct19BytesHomogeneousUint8x10Native();
    testPassStruct20BytesHomogeneousInt32x10Native();
    testPassStruct20BytesHomogeneousFloatNative();
    testPassStruct32BytesHomogeneousDoublex5Native();
    testPassStruct40BytesHomogeneousDoubleNative();
    testPassStruct1024BytesHomogeneousUint64Native();
    testPassFloatStruct16BytesHomogeneousFloatFloatStruct1Native();
    testPassFloatStruct32BytesHomogeneousDoubleFloatStructNative();
    testPassInt8Struct16BytesMixedInt8Struct16BytesMixedInNative();
    testPassDoublex6Struct16BytesMixedx4Int32Native();
    testPassInt32x4Struct16BytesMixedx4DoubleNative();
    testPassStruct40BytesHomogeneousDoubleStruct4BytesHomoNative();
    testPassInt32x8Doublex8Int64Int8Struct1ByteIntInt64IntNative();
    testPassStructAlignmentInt16Native();
    testPassStructAlignmentInt32Native();
    testPassStructAlignmentInt64Native();
    testPassStruct8BytesNestedIntx10Native();
    testPassStruct8BytesNestedFloatx10Native();
    testPassStruct8BytesNestedFloat2x10Native();
    testPassStruct8BytesNestedMixedx10Native();
    testPassStruct16BytesNestedIntx2Native();
    testPassStruct32BytesNestedIntx2Native();
    testPassStructNestedIntStructAlignmentInt16Native();
    testPassStructNestedIntStructAlignmentInt32Native();
    testPassStructNestedIntStructAlignmentInt64Native();
    testPassStructNestedIrregularEvenBiggerx4Native();
    testPassStruct8BytesInlineArrayIntx4Native();
    testPassStructInlineArrayIrregularx4Native();
    testPassStructInlineArray100BytesNative();
    testPassStructStruct16BytesHomogeneousFloat2x5Native();
    testPassStructStruct32BytesHomogeneousDouble2x5Native();
    testPassStructStruct16BytesMixed3x10Native();
    testPassUint8Struct32BytesInlineArrayMultiDimensionalINative();
    testPassUint8Struct4BytesInlineArrayMultiDimensionalInNative();
    testPassStruct3BytesPackedIntx10Native();
    testPassStruct8BytesPackedIntx10Native();
    testPassStruct9BytesPackedMixedx10DoubleInt32x2Native();
    testPassStruct5BytesPackedMixedNative();
    testPassStructNestedAlignmentStruct5BytesPackedMixedNative();
    testPassStruct6BytesInlineArrayIntNative();
    testPassStruct15BytesInlineArrayMixedNative();
    testPassUnion4BytesMixedx10Native();
    testPassUnion8BytesNestedFloatx10Native();
    testPassUnion9BytesNestedIntx10Native();
    testPassUnion16BytesNestedInlineArrayFloatx10Native();
    testPassUnion16BytesNestedFloatx10Native();
    testPassUint8Boolx9Struct10BytesHomogeneousBoolBoolNative();
    testPassUint8Boolx9Struct10BytesInlineArrayBoolBoolNative();
    testPassUint8Struct1ByteBoolNative();
    testPassWCharStructInlineArrayIntUintPtrx2LongUnsignedNative();
    testPassInt64x7Struct12BytesHomogeneousInt32Native();
  }
}

@Native<
    Int64 Function(
        Struct1ByteInt,
        Struct1ByteInt,
        Struct1ByteInt,
        Struct1ByteInt,
        Struct1ByteInt,
        Struct1ByteInt,
        Struct1ByteInt,
        Struct1ByteInt,
        Struct1ByteInt,
        Struct1ByteInt)>(symbol: 'PassStruct1ByteIntx10')
external int passStruct1ByteIntx10Native(
    Struct1ByteInt a0,
    Struct1ByteInt a1,
    Struct1ByteInt a2,
    Struct1ByteInt a3,
    Struct1ByteInt a4,
    Struct1ByteInt a5,
    Struct1ByteInt a6,
    Struct1ByteInt a7,
    Struct1ByteInt a8,
    Struct1ByteInt a9);

/// Smallest struct with data.
/// 10 struct arguments will exhaust available registers.
void testPassStruct1ByteIntx10Native() {
  final a0Pointer = calloc<Struct1ByteInt>();
  final Struct1ByteInt a0 = a0Pointer.ref;
  final a1Pointer = calloc<Struct1ByteInt>();
  final Struct1ByteInt a1 = a1Pointer.ref;
  final a2Pointer = calloc<Struct1ByteInt>();
  final Struct1ByteInt a2 = a2Pointer.ref;
  final a3Pointer = calloc<Struct1ByteInt>();
  final Struct1ByteInt a3 = a3Pointer.ref;
  final a4Pointer = calloc<Struct1ByteInt>();
  final Struct1ByteInt a4 = a4Pointer.ref;
  final a5Pointer = calloc<Struct1ByteInt>();
  final Struct1ByteInt a5 = a5Pointer.ref;
  final a6Pointer = calloc<Struct1ByteInt>();
  final Struct1ByteInt a6 = a6Pointer.ref;
  final a7Pointer = calloc<Struct1ByteInt>();
  final Struct1ByteInt a7 = a7Pointer.ref;
  final a8Pointer = calloc<Struct1ByteInt>();
  final Struct1ByteInt a8 = a8Pointer.ref;
  final a9Pointer = calloc<Struct1ByteInt>();
  final Struct1ByteInt a9 = a9Pointer.ref;

  a0.a0 = -1;
  a1.a0 = 2;
  a2.a0 = -3;
  a3.a0 = 4;
  a4.a0 = -5;
  a5.a0 = 6;
  a6.a0 = -7;
  a7.a0 = 8;
  a8.a0 = -9;
  a9.a0 = 10;

  final result =
      passStruct1ByteIntx10Native(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);

  print("result = $result");

  Expect.equals(5, result);

  calloc.free(a0Pointer);
  calloc.free(a1Pointer);
  calloc.free(a2Pointer);
  calloc.free(a3Pointer);
  calloc.free(a4Pointer);
  calloc.free(a5Pointer);
  calloc.free(a6Pointer);
  calloc.free(a7Pointer);
  calloc.free(a8Pointer);
  calloc.free(a9Pointer);
}

@Native<
        Int64 Function(
            Struct3BytesHomogeneousUint8,
            Struct3BytesHomogeneousUint8,
            Struct3BytesHomogeneousUint8,
            Struct3BytesHomogeneousUint8,
            Struct3BytesHomogeneousUint8,
            Struct3BytesHomogeneousUint8,
            Struct3BytesHomogeneousUint8,
            Struct3BytesHomogeneousUint8,
            Struct3BytesHomogeneousUint8,
            Struct3BytesHomogeneousUint8)>(
    symbol: 'PassStruct3BytesHomogeneousUint8x10')
external int passStruct3BytesHomogeneousUint8x10Native(
    Struct3BytesHomogeneousUint8 a0,
    Struct3BytesHomogeneousUint8 a1,
    Struct3BytesHomogeneousUint8 a2,
    Struct3BytesHomogeneousUint8 a3,
    Struct3BytesHomogeneousUint8 a4,
    Struct3BytesHomogeneousUint8 a5,
    Struct3BytesHomogeneousUint8 a6,
    Struct3BytesHomogeneousUint8 a7,
    Struct3BytesHomogeneousUint8 a8,
    Struct3BytesHomogeneousUint8 a9);

/// Not a multiple of word size, not a power of two.
/// 10 struct arguments will exhaust available registers.
void testPassStruct3BytesHomogeneousUint8x10Native() {
  final a0Pointer = calloc<Struct3BytesHomogeneousUint8>();
  final Struct3BytesHomogeneousUint8 a0 = a0Pointer.ref;
  final a1Pointer = calloc<Struct3BytesHomogeneousUint8>();
  final Struct3BytesHomogeneousUint8 a1 = a1Pointer.ref;
  final a2Pointer = calloc<Struct3BytesHomogeneousUint8>();
  final Struct3BytesHomogeneousUint8 a2 = a2Pointer.ref;
  final a3Pointer = calloc<Struct3BytesHomogeneousUint8>();
  final Struct3BytesHomogeneousUint8 a3 = a3Pointer.ref;
  final a4Pointer = calloc<Struct3BytesHomogeneousUint8>();
  final Struct3BytesHomogeneousUint8 a4 = a4Pointer.ref;
  final a5Pointer = calloc<Struct3BytesHomogeneousUint8>();
  final Struct3BytesHomogeneousUint8 a5 = a5Pointer.ref;
  final a6Pointer = calloc<Struct3BytesHomogeneousUint8>();
  final Struct3BytesHomogeneousUint8 a6 = a6Pointer.ref;
  final a7Pointer = calloc<Struct3BytesHomogeneousUint8>();
  final Struct3BytesHomogeneousUint8 a7 = a7Pointer.ref;
  final a8Pointer = calloc<Struct3BytesHomogeneousUint8>();
  final Struct3BytesHomogeneousUint8 a8 = a8Pointer.ref;
  final a9Pointer = calloc<Struct3BytesHomogeneousUint8>();
  final Struct3BytesHomogeneousUint8 a9 = a9Pointer.ref;

  a0.a0 = 1;
  a0.a1 = 2;
  a0.a2 = 3;
  a1.a0 = 4;
  a1.a1 = 5;
  a1.a2 = 6;
  a2.a0 = 7;
  a2.a1 = 8;
  a2.a2 = 9;
  a3.a0 = 10;
  a3.a1 = 11;
  a3.a2 = 12;
  a4.a0 = 13;
  a4.a1 = 14;
  a4.a2 = 15;
  a5.a0 = 16;
  a5.a1 = 17;
  a5.a2 = 18;
  a6.a0 = 19;
  a6.a1 = 20;
  a6.a2 = 21;
  a7.a0 = 22;
  a7.a1 = 23;
  a7.a2 = 24;
  a8.a0 = 25;
  a8.a1 = 26;
  a8.a2 = 27;
  a9.a0 = 28;
  a9.a1 = 29;
  a9.a2 = 30;

  final result = passStruct3BytesHomogeneousUint8x10Native(
      a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);

  print("result = $result");

  Expect.equals(465, result);

  calloc.free(a0Pointer);
  calloc.free(a1Pointer);
  calloc.free(a2Pointer);
  calloc.free(a3Pointer);
  calloc.free(a4Pointer);
  calloc.free(a5Pointer);
  calloc.free(a6Pointer);
  calloc.free(a7Pointer);
  calloc.free(a8Pointer);
  calloc.free(a9Pointer);
}

@Native<
        Int64 Function(
            Struct3BytesInt2ByteAligned,
            Struct3BytesInt2ByteAligned,
            Struct3BytesInt2ByteAligned,
            Struct3BytesInt2ByteAligned,
            Struct3BytesInt2ByteAligned,
            Struct3BytesInt2ByteAligned,
            Struct3BytesInt2ByteAligned,
            Struct3BytesInt2ByteAligned,
            Struct3BytesInt2ByteAligned,
            Struct3BytesInt2ByteAligned)>(
    symbol: 'PassStruct3BytesInt2ByteAlignedx10')
external int passStruct3BytesInt2ByteAlignedx10Native(
    Struct3BytesInt2ByteAligned a0,
    Struct3BytesInt2ByteAligned a1,
    Struct3BytesInt2ByteAligned a2,
    Struct3BytesInt2ByteAligned a3,
    Struct3BytesInt2ByteAligned a4,
    Struct3BytesInt2ByteAligned a5,
    Struct3BytesInt2ByteAligned a6,
    Struct3BytesInt2ByteAligned a7,
    Struct3BytesInt2ByteAligned a8,
    Struct3BytesInt2ByteAligned a9);

/// Not a multiple of word size, not a power of two.
/// With alignment rules taken into account size is 4 bytes.
/// 10 struct arguments will exhaust available registers.
void testPassStruct3BytesInt2ByteAlignedx10Native() {
  final a0Pointer = calloc<Struct3BytesInt2ByteAligned>();
  final Struct3BytesInt2ByteAligned a0 = a0Pointer.ref;
  final a1Pointer = calloc<Struct3BytesInt2ByteAligned>();
  final Struct3BytesInt2ByteAligned a1 = a1Pointer.ref;
  final a2Pointer = calloc<Struct3BytesInt2ByteAligned>();
  final Struct3BytesInt2ByteAligned a2 = a2Pointer.ref;
  final a3Pointer = calloc<Struct3BytesInt2ByteAligned>();
  final Struct3BytesInt2ByteAligned a3 = a3Pointer.ref;
  final a4Pointer = calloc<Struct3BytesInt2ByteAligned>();
  final Struct3BytesInt2ByteAligned a4 = a4Pointer.ref;
  final a5Pointer = calloc<Struct3BytesInt2ByteAligned>();
  final Struct3BytesInt2ByteAligned a5 = a5Pointer.ref;
  final a6Pointer = calloc<Struct3BytesInt2ByteAligned>();
  final Struct3BytesInt2ByteAligned a6 = a6Pointer.ref;
  final a7Pointer = calloc<Struct3BytesInt2ByteAligned>();
  final Struct3BytesInt2ByteAligned a7 = a7Pointer.ref;
  final a8Pointer = calloc<Struct3BytesInt2ByteAligned>();
  final Struct3BytesInt2ByteAligned a8 = a8Pointer.ref;
  final a9Pointer = calloc<Struct3BytesInt2ByteAligned>();
  final Struct3BytesInt2ByteAligned a9 = a9Pointer.ref;

  a0.a0 = -1;
  a0.a1 = 2;
  a1.a0 = -3;
  a1.a1 = 4;
  a2.a0 = -5;
  a2.a1 = 6;
  a3.a0 = -7;
  a3.a1 = 8;
  a4.a0 = -9;
  a4.a1 = 10;
  a5.a0 = -11;
  a5.a1 = 12;
  a6.a0 = -13;
  a6.a1 = 14;
  a7.a0 = -15;
  a7.a1 = 16;
  a8.a0 = -17;
  a8.a1 = 18;
  a9.a0 = -19;
  a9.a1 = 20;

  final result = passStruct3BytesInt2ByteAlignedx10Native(
      a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);

  print("result = $result");

  Expect.equals(10, result);

  calloc.free(a0Pointer);
  calloc.free(a1Pointer);
  calloc.free(a2Pointer);
  calloc.free(a3Pointer);
  calloc.free(a4Pointer);
  calloc.free(a5Pointer);
  calloc.free(a6Pointer);
  calloc.free(a7Pointer);
  calloc.free(a8Pointer);
  calloc.free(a9Pointer);
}

@Native<
        Int64 Function(
            Struct4BytesHomogeneousInt16,
            Struct4BytesHomogeneousInt16,
            Struct4BytesHomogeneousInt16,
            Struct4BytesHomogeneousInt16,
            Struct4BytesHomogeneousInt16,
            Struct4BytesHomogeneousInt16,
            Struct4BytesHomogeneousInt16,
            Struct4BytesHomogeneousInt16,
            Struct4BytesHomogeneousInt16,
            Struct4BytesHomogeneousInt16)>(
    symbol: 'PassStruct4BytesHomogeneousInt16x10')
external int passStruct4BytesHomogeneousInt16x10Native(
    Struct4BytesHomogeneousInt16 a0,
    Struct4BytesHomogeneousInt16 a1,
    Struct4BytesHomogeneousInt16 a2,
    Struct4BytesHomogeneousInt16 a3,
    Struct4BytesHomogeneousInt16 a4,
    Struct4BytesHomogeneousInt16 a5,
    Struct4BytesHomogeneousInt16 a6,
    Struct4BytesHomogeneousInt16 a7,
    Struct4BytesHomogeneousInt16 a8,
    Struct4BytesHomogeneousInt16 a9);

/// Exactly word size on 32-bit architectures.
/// 10 struct arguments will exhaust available registers.
void testPassStruct4BytesHomogeneousInt16x10Native() {
  final a0Pointer = calloc<Struct4BytesHomogeneousInt16>();
  final Struct4BytesHomogeneousInt16 a0 = a0Pointer.ref;
  final a1Pointer = calloc<Struct4BytesHomogeneousInt16>();
  final Struct4BytesHomogeneousInt16 a1 = a1Pointer.ref;
  final a2Pointer = calloc<Struct4BytesHomogeneousInt16>();
  final Struct4BytesHomogeneousInt16 a2 = a2Pointer.ref;
  final a3Pointer = calloc<Struct4BytesHomogeneousInt16>();
  final Struct4BytesHomogeneousInt16 a3 = a3Pointer.ref;
  final a4Pointer = calloc<Struct4BytesHomogeneousInt16>();
  final Struct4BytesHomogeneousInt16 a4 = a4Pointer.ref;
  final a5Pointer = calloc<Struct4BytesHomogeneousInt16>();
  final Struct4BytesHomogeneousInt16 a5 = a5Pointer.ref;
  final a6Pointer = calloc<Struct4BytesHomogeneousInt16>();
  final Struct4BytesHomogeneousInt16 a6 = a6Pointer.ref;
  final a7Pointer = calloc<Struct4BytesHomogeneousInt16>();
  final Struct4BytesHomogeneousInt16 a7 = a7Pointer.ref;
  final a8Pointer = calloc<Struct4BytesHomogeneousInt16>();
  final Struct4BytesHomogeneousInt16 a8 = a8Pointer.ref;
  final a9Pointer = calloc<Struct4BytesHomogeneousInt16>();
  final Struct4BytesHomogeneousInt16 a9 = a9Pointer.ref;

  a0.a0 = -1;
  a0.a1 = 2;
  a1.a0 = -3;
  a1.a1 = 4;
  a2.a0 = -5;
  a2.a1 = 6;
  a3.a0 = -7;
  a3.a1 = 8;
  a4.a0 = -9;
  a4.a1 = 10;
  a5.a0 = -11;
  a5.a1 = 12;
  a6.a0 = -13;
  a6.a1 = 14;
  a7.a0 = -15;
  a7.a1 = 16;
  a8.a0 = -17;
  a8.a1 = 18;
  a9.a0 = -19;
  a9.a1 = 20;

  final result = passStruct4BytesHomogeneousInt16x10Native(
      a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);

  print("result = $result");

  Expect.equals(10, result);

  calloc.free(a0Pointer);
  calloc.free(a1Pointer);
  calloc.free(a2Pointer);
  calloc.free(a3Pointer);
  calloc.free(a4Pointer);
  calloc.free(a5Pointer);
  calloc.free(a6Pointer);
  calloc.free(a7Pointer);
  calloc.free(a8Pointer);
  calloc.free(a9Pointer);
}

@Native<
        Int64 Function(
            Struct7BytesHomogeneousUint8,
            Struct7BytesHomogeneousUint8,
            Struct7BytesHomogeneousUint8,
            Struct7BytesHomogeneousUint8,
            Struct7BytesHomogeneousUint8,
            Struct7BytesHomogeneousUint8,
            Struct7BytesHomogeneousUint8,
            Struct7BytesHomogeneousUint8,
            Struct7BytesHomogeneousUint8,
            Struct7BytesHomogeneousUint8)>(
    symbol: 'PassStruct7BytesHomogeneousUint8x10')
external int passStruct7BytesHomogeneousUint8x10Native(
    Struct7BytesHomogeneousUint8 a0,
    Struct7BytesHomogeneousUint8 a1,
    Struct7BytesHomogeneousUint8 a2,
    Struct7BytesHomogeneousUint8 a3,
    Struct7BytesHomogeneousUint8 a4,
    Struct7BytesHomogeneousUint8 a5,
    Struct7BytesHomogeneousUint8 a6,
    Struct7BytesHomogeneousUint8 a7,
    Struct7BytesHomogeneousUint8 a8,
    Struct7BytesHomogeneousUint8 a9);

/// Sub word size on 64 bit architectures.
/// 10 struct arguments will exhaust available registers.
void testPassStruct7BytesHomogeneousUint8x10Native() {
  final a0Pointer = calloc<Struct7BytesHomogeneousUint8>();
  final Struct7BytesHomogeneousUint8 a0 = a0Pointer.ref;
  final a1Pointer = calloc<Struct7BytesHomogeneousUint8>();
  final Struct7BytesHomogeneousUint8 a1 = a1Pointer.ref;
  final a2Pointer = calloc<Struct7BytesHomogeneousUint8>();
  final Struct7BytesHomogeneousUint8 a2 = a2Pointer.ref;
  final a3Pointer = calloc<Struct7BytesHomogeneousUint8>();
  final Struct7BytesHomogeneousUint8 a3 = a3Pointer.ref;
  final a4Pointer = calloc<Struct7BytesHomogeneousUint8>();
  final Struct7BytesHomogeneousUint8 a4 = a4Pointer.ref;
  final a5Pointer = calloc<Struct7BytesHomogeneousUint8>();
  final Struct7BytesHomogeneousUint8 a5 = a5Pointer.ref;
  final a6Pointer = calloc<Struct7BytesHomogeneousUint8>();
  final Struct7BytesHomogeneousUint8 a6 = a6Pointer.ref;
  final a7Pointer = calloc<Struct7BytesHomogeneousUint8>();
  final Struct7BytesHomogeneousUint8 a7 = a7Pointer.ref;
  final a8Pointer = calloc<Struct7BytesHomogeneousUint8>();
  final Struct7BytesHomogeneousUint8 a8 = a8Pointer.ref;
  final a9Pointer = calloc<Struct7BytesHomogeneousUint8>();
  final Struct7BytesHomogeneousUint8 a9 = a9Pointer.ref;

  a0.a0 = 1;
  a0.a1 = 2;
  a0.a2 = 3;
  a0.a3 = 4;
  a0.a4 = 5;
  a0.a5 = 6;
  a0.a6 = 7;
  a1.a0 = 8;
  a1.a1 = 9;
  a1.a2 = 10;
  a1.a3 = 11;
  a1.a4 = 12;
  a1.a5 = 13;
  a1.a6 = 14;
  a2.a0 = 15;
  a2.a1 = 16;
  a2.a2 = 17;
  a2.a3 = 18;
  a2.a4 = 19;
  a2.a5 = 20;
  a2.a6 = 21;
  a3.a0 = 22;
  a3.a1 = 23;
  a3.a2 = 24;
  a3.a3 = 25;
  a3.a4 = 26;
  a3.a5 = 27;
  a3.a6 = 28;
  a4.a0 = 29;
  a4.a1 = 30;
  a4.a2 = 31;
  a4.a3 = 32;
  a4.a4 = 33;
  a4.a5 = 34;
  a4.a6 = 35;
  a5.a0 = 36;
  a5.a1 = 37;
  a5.a2 = 38;
  a5.a3 = 39;
  a5.a4 = 40;
  a5.a5 = 41;
  a5.a6 = 42;
  a6.a0 = 43;
  a6.a1 = 44;
  a6.a2 = 45;
  a6.a3 = 46;
  a6.a4 = 47;
  a6.a5 = 48;
  a6.a6 = 49;
  a7.a0 = 50;
  a7.a1 = 51;
  a7.a2 = 52;
  a7.a3 = 53;
  a7.a4 = 54;
  a7.a5 = 55;
  a7.a6 = 56;
  a8.a0 = 57;
  a8.a1 = 58;
  a8.a2 = 59;
  a8.a3 = 60;
  a8.a4 = 61;
  a8.a5 = 62;
  a8.a6 = 63;
  a9.a0 = 64;
  a9.a1 = 65;
  a9.a2 = 66;
  a9.a3 = 67;
  a9.a4 = 68;
  a9.a5 = 69;
  a9.a6 = 70;

  final result = passStruct7BytesHomogeneousUint8x10Native(
      a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);

  print("result = $result");

  Expect.equals(2485, result);

  calloc.free(a0Pointer);
  calloc.free(a1Pointer);
  calloc.free(a2Pointer);
  calloc.free(a3Pointer);
  calloc.free(a4Pointer);
  calloc.free(a5Pointer);
  calloc.free(a6Pointer);
  calloc.free(a7Pointer);
  calloc.free(a8Pointer);
  calloc.free(a9Pointer);
}

@Native<
        Int64 Function(
            Struct7BytesInt4ByteAligned,
            Struct7BytesInt4ByteAligned,
            Struct7BytesInt4ByteAligned,
            Struct7BytesInt4ByteAligned,
            Struct7BytesInt4ByteAligned,
            Struct7BytesInt4ByteAligned,
            Struct7BytesInt4ByteAligned,
            Struct7BytesInt4ByteAligned,
            Struct7BytesInt4ByteAligned,
            Struct7BytesInt4ByteAligned)>(
    symbol: 'PassStruct7BytesInt4ByteAlignedx10')
external int passStruct7BytesInt4ByteAlignedx10Native(
    Struct7BytesInt4ByteAligned a0,
    Struct7BytesInt4ByteAligned a1,
    Struct7BytesInt4ByteAligned a2,
    Struct7BytesInt4ByteAligned a3,
    Struct7BytesInt4ByteAligned a4,
    Struct7BytesInt4ByteAligned a5,
    Struct7BytesInt4ByteAligned a6,
    Struct7BytesInt4ByteAligned a7,
    Struct7BytesInt4ByteAligned a8,
    Struct7BytesInt4ByteAligned a9);

/// Sub word size on 64 bit architectures.
/// With alignment rules taken into account size is 8 bytes.
/// 10 struct arguments will exhaust available registers.
void testPassStruct7BytesInt4ByteAlignedx10Native() {
  final a0Pointer = calloc<Struct7BytesInt4ByteAligned>();
  final Struct7BytesInt4ByteAligned a0 = a0Pointer.ref;
  final a1Pointer = calloc<Struct7BytesInt4ByteAligned>();
  final Struct7BytesInt4ByteAligned a1 = a1Pointer.ref;
  final a2Pointer = calloc<Struct7BytesInt4ByteAligned>();
  final Struct7BytesInt4ByteAligned a2 = a2Pointer.ref;
  final a3Pointer = calloc<Struct7BytesInt4ByteAligned>();
  final Struct7BytesInt4ByteAligned a3 = a3Pointer.ref;
  final a4Pointer = calloc<Struct7BytesInt4ByteAligned>();
  final Struct7BytesInt4ByteAligned a4 = a4Pointer.ref;
  final a5Pointer = calloc<Struct7BytesInt4ByteAligned>();
  final Struct7BytesInt4ByteAligned a5 = a5Pointer.ref;
  final a6Pointer = calloc<Struct7BytesInt4ByteAligned>();
  final Struct7BytesInt4ByteAligned a6 = a6Pointer.ref;
  final a7Pointer = calloc<Struct7BytesInt4ByteAligned>();
  final Struct7BytesInt4ByteAligned a7 = a7Pointer.ref;
  final a8Pointer = calloc<Struct7BytesInt4ByteAligned>();
  final Struct7BytesInt4ByteAligned a8 = a8Pointer.ref;
  final a9Pointer = calloc<Struct7BytesInt4ByteAligned>();
  final Struct7BytesInt4ByteAligned a9 = a9Pointer.ref;

  a0.a0 = -1;
  a0.a1 = 2;
  a0.a2 = -3;
  a1.a0 = 4;
  a1.a1 = -5;
  a1.a2 = 6;
  a2.a0 = -7;
  a2.a1 = 8;
  a2.a2 = -9;
  a3.a0 = 10;
  a3.a1 = -11;
  a3.a2 = 12;
  a4.a0 = -13;
  a4.a1 = 14;
  a4.a2 = -15;
  a5.a0 = 16;
  a5.a1 = -17;
  a5.a2 = 18;
  a6.a0 = -19;
  a6.a1 = 20;
  a6.a2 = -21;
  a7.a0 = 22;
  a7.a1 = -23;
  a7.a2 = 24;
  a8.a0 = -25;
  a8.a1 = 26;
  a8.a2 = -27;
  a9.a0 = 28;
  a9.a1 = -29;
  a9.a2 = 30;

  final result = passStruct7BytesInt4ByteAlignedx10Native(
      a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);

  print("result = $result");

  Expect.equals(15, result);

  calloc.free(a0Pointer);
  calloc.free(a1Pointer);
  calloc.free(a2Pointer);
  calloc.free(a3Pointer);
  calloc.free(a4Pointer);
  calloc.free(a5Pointer);
  calloc.free(a6Pointer);
  calloc.free(a7Pointer);
  calloc.free(a8Pointer);
  calloc.free(a9Pointer);
}

@Native<
    Int64 Function(
        Struct8BytesInt,
        Struct8BytesInt,
        Struct8BytesInt,
        Struct8BytesInt,
        Struct8BytesInt,
        Struct8BytesInt,
        Struct8BytesInt,
        Struct8BytesInt,
        Struct8BytesInt,
        Struct8BytesInt)>(symbol: 'PassStruct8BytesIntx10')
external int passStruct8BytesIntx10Native(
    Struct8BytesInt a0,
    Struct8BytesInt a1,
    Struct8BytesInt a2,
    Struct8BytesInt a3,
    Struct8BytesInt a4,
    Struct8BytesInt a5,
    Struct8BytesInt a6,
    Struct8BytesInt a7,
    Struct8BytesInt a8,
    Struct8BytesInt a9);

/// Exactly word size struct on 64bit architectures.
/// 10 struct arguments will exhaust available registers.
void testPassStruct8BytesIntx10Native() {
  final a0Pointer = calloc<Struct8BytesInt>();
  final Struct8BytesInt a0 = a0Pointer.ref;
  final a1Pointer = calloc<Struct8BytesInt>();
  final Struct8BytesInt a1 = a1Pointer.ref;
  final a2Pointer = calloc<Struct8BytesInt>();
  final Struct8BytesInt a2 = a2Pointer.ref;
  final a3Pointer = calloc<Struct8BytesInt>();
  final Struct8BytesInt a3 = a3Pointer.ref;
  final a4Pointer = calloc<Struct8BytesInt>();
  final Struct8BytesInt a4 = a4Pointer.ref;
  final a5Pointer = calloc<Struct8BytesInt>();
  final Struct8BytesInt a5 = a5Pointer.ref;
  final a6Pointer = calloc<Struct8BytesInt>();
  final Struct8BytesInt a6 = a6Pointer.ref;
  final a7Pointer = calloc<Struct8BytesInt>();
  final Struct8BytesInt a7 = a7Pointer.ref;
  final a8Pointer = calloc<Struct8BytesInt>();
  final Struct8BytesInt a8 = a8Pointer.ref;
  final a9Pointer = calloc<Struct8BytesInt>();
  final Struct8BytesInt a9 = a9Pointer.ref;

  a0.a0 = -1;
  a0.a1 = 2;
  a0.a2 = -3;
  a1.a0 = 4;
  a1.a1 = -5;
  a1.a2 = 6;
  a2.a0 = -7;
  a2.a1 = 8;
  a2.a2 = -9;
  a3.a0 = 10;
  a3.a1 = -11;
  a3.a2 = 12;
  a4.a0 = -13;
  a4.a1 = 14;
  a4.a2 = -15;
  a5.a0 = 16;
  a5.a1 = -17;
  a5.a2 = 18;
  a6.a0 = -19;
  a6.a1 = 20;
  a6.a2 = -21;
  a7.a0 = 22;
  a7.a1 = -23;
  a7.a2 = 24;
  a8.a0 = -25;
  a8.a1 = 26;
  a8.a2 = -27;
  a9.a0 = 28;
  a9.a1 = -29;
  a9.a2 = 30;

  final result =
      passStruct8BytesIntx10Native(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);

  print("result = $result");

  Expect.equals(15, result);

  calloc.free(a0Pointer);
  calloc.free(a1Pointer);
  calloc.free(a2Pointer);
  calloc.free(a3Pointer);
  calloc.free(a4Pointer);
  calloc.free(a5Pointer);
  calloc.free(a6Pointer);
  calloc.free(a7Pointer);
  calloc.free(a8Pointer);
  calloc.free(a9Pointer);
}

@Native<
        Float Function(
            Struct8BytesHomogeneousFloat,
            Struct8BytesHomogeneousFloat,
            Struct8BytesHomogeneousFloat,
            Struct8BytesHomogeneousFloat,
            Struct8BytesHomogeneousFloat,
            Struct8BytesHomogeneousFloat,
            Struct8BytesHomogeneousFloat,
            Struct8BytesHomogeneousFloat,
            Struct8BytesHomogeneousFloat,
            Struct8BytesHomogeneousFloat)>(
    symbol: 'PassStruct8BytesHomogeneousFloatx10')
external double passStruct8BytesHomogeneousFloatx10Native(
    Struct8BytesHomogeneousFloat a0,
    Struct8BytesHomogeneousFloat a1,
    Struct8BytesHomogeneousFloat a2,
    Struct8BytesHomogeneousFloat a3,
    Struct8BytesHomogeneousFloat a4,
    Struct8BytesHomogeneousFloat a5,
    Struct8BytesHomogeneousFloat a6,
    Struct8BytesHomogeneousFloat a7,
    Struct8BytesHomogeneousFloat a8,
    Struct8BytesHomogeneousFloat a9);

/// Arguments passed in FP registers as long as they fit.
/// 10 struct arguments will exhaust available registers.
void testPassStruct8BytesHomogeneousFloatx10Native() {
  final a0Pointer = calloc<Struct8BytesHomogeneousFloat>();
  final Struct8BytesHomogeneousFloat a0 = a0Pointer.ref;
  final a1Pointer = calloc<Struct8BytesHomogeneousFloat>();
  final Struct8BytesHomogeneousFloat a1 = a1Pointer.ref;
  final a2Pointer = calloc<Struct8BytesHomogeneousFloat>();
  final Struct8BytesHomogeneousFloat a2 = a2Pointer.ref;
  final a3Pointer = calloc<Struct8BytesHomogeneousFloat>();
  final Struct8BytesHomogeneousFloat a3 = a3Pointer.ref;
  final a4Pointer = calloc<Struct8BytesHomogeneousFloat>();
  final Struct8BytesHomogeneousFloat a4 = a4Pointer.ref;
  final a5Pointer = calloc<Struct8BytesHomogeneousFloat>();
  final Struct8BytesHomogeneousFloat a5 = a5Pointer.ref;
  final a6Pointer = calloc<Struct8BytesHomogeneousFloat>();
  final Struct8BytesHomogeneousFloat a6 = a6Pointer.ref;
  final a7Pointer = calloc<Struct8BytesHomogeneousFloat>();
  final Struct8BytesHomogeneousFloat a7 = a7Pointer.ref;
  final a8Pointer = calloc<Struct8BytesHomogeneousFloat>();
  final Struct8BytesHomogeneousFloat a8 = a8Pointer.ref;
  final a9Pointer = calloc<Struct8BytesHomogeneousFloat>();
  final Struct8BytesHomogeneousFloat a9 = a9Pointer.ref;

  a0.a0 = -1.0;
  a0.a1 = 2.0;
  a1.a0 = -3.0;
  a1.a1 = 4.0;
  a2.a0 = -5.0;
  a2.a1 = 6.0;
  a3.a0 = -7.0;
  a3.a1 = 8.0;
  a4.a0 = -9.0;
  a4.a1 = 10.0;
  a5.a0 = -11.0;
  a5.a1 = 12.0;
  a6.a0 = -13.0;
  a6.a1 = 14.0;
  a7.a0 = -15.0;
  a7.a1 = 16.0;
  a8.a0 = -17.0;
  a8.a1 = 18.0;
  a9.a0 = -19.0;
  a9.a1 = 20.0;

  final result = passStruct8BytesHomogeneousFloatx10Native(
      a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);

  print("result = $result");

  Expect.approxEquals(10.0, result);

  calloc.free(a0Pointer);
  calloc.free(a1Pointer);
  calloc.free(a2Pointer);
  calloc.free(a3Pointer);
  calloc.free(a4Pointer);
  calloc.free(a5Pointer);
  calloc.free(a6Pointer);
  calloc.free(a7Pointer);
  calloc.free(a8Pointer);
  calloc.free(a9Pointer);
}

@Native<
    Float Function(
        Struct8BytesMixed,
        Struct8BytesMixed,
        Struct8BytesMixed,
        Struct8BytesMixed,
        Struct8BytesMixed,
        Struct8BytesMixed,
        Struct8BytesMixed,
        Struct8BytesMixed,
        Struct8BytesMixed,
        Struct8BytesMixed)>(symbol: 'PassStruct8BytesMixedx10')
external double passStruct8BytesMixedx10Native(
    Struct8BytesMixed a0,
    Struct8BytesMixed a1,
    Struct8BytesMixed a2,
    Struct8BytesMixed a3,
    Struct8BytesMixed a4,
    Struct8BytesMixed a5,
    Struct8BytesMixed a6,
    Struct8BytesMixed a7,
    Struct8BytesMixed a8,
    Struct8BytesMixed a9);

/// On x64, arguments go in int registers because it is not only float.
/// 10 struct arguments will exhaust available registers.
void testPassStruct8BytesMixedx10Native() {
  final a0Pointer = calloc<Struct8BytesMixed>();
  final Struct8BytesMixed a0 = a0Pointer.ref;
  final a1Pointer = calloc<Struct8BytesMixed>();
  final Struct8BytesMixed a1 = a1Pointer.ref;
  final a2Pointer = calloc<Struct8BytesMixed>();
  final Struct8BytesMixed a2 = a2Pointer.ref;
  final a3Pointer = calloc<Struct8BytesMixed>();
  final Struct8BytesMixed a3 = a3Pointer.ref;
  final a4Pointer = calloc<Struct8BytesMixed>();
  final Struct8BytesMixed a4 = a4Pointer.ref;
  final a5Pointer = calloc<Struct8BytesMixed>();
  final Struct8BytesMixed a5 = a5Pointer.ref;
  final a6Pointer = calloc<Struct8BytesMixed>();
  final Struct8BytesMixed a6 = a6Pointer.ref;
  final a7Pointer = calloc<Struct8BytesMixed>();
  final Struct8BytesMixed a7 = a7Pointer.ref;
  final a8Pointer = calloc<Struct8BytesMixed>();
  final Struct8BytesMixed a8 = a8Pointer.ref;
  final a9Pointer = calloc<Struct8BytesMixed>();
  final Struct8BytesMixed a9 = a9Pointer.ref;

  a0.a0 = -1.0;
  a0.a1 = 2;
  a0.a2 = -3;
  a1.a0 = 4.0;
  a1.a1 = -5;
  a1.a2 = 6;
  a2.a0 = -7.0;
  a2.a1 = 8;
  a2.a2 = -9;
  a3.a0 = 10.0;
  a3.a1 = -11;
  a3.a2 = 12;
  a4.a0 = -13.0;
  a4.a1 = 14;
  a4.a2 = -15;
  a5.a0 = 16.0;
  a5.a1 = -17;
  a5.a2 = 18;
  a6.a0 = -19.0;
  a6.a1 = 20;
  a6.a2 = -21;
  a7.a0 = 22.0;
  a7.a1 = -23;
  a7.a2 = 24;
  a8.a0 = -25.0;
  a8.a1 = 26;
  a8.a2 = -27;
  a9.a0 = 28.0;
  a9.a1 = -29;
  a9.a2 = 30;

  final result =
      passStruct8BytesMixedx10Native(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);

  print("result = $result");

  Expect.approxEquals(15.0, result);

  calloc.free(a0Pointer);
  calloc.free(a1Pointer);
  calloc.free(a2Pointer);
  calloc.free(a3Pointer);
  calloc.free(a4Pointer);
  calloc.free(a5Pointer);
  calloc.free(a6Pointer);
  calloc.free(a7Pointer);
  calloc.free(a8Pointer);
  calloc.free(a9Pointer);
}

@Native<
        Int64 Function(
            Struct9BytesHomogeneousUint8,
            Struct9BytesHomogeneousUint8,
            Struct9BytesHomogeneousUint8,
            Struct9BytesHomogeneousUint8,
            Struct9BytesHomogeneousUint8,
            Struct9BytesHomogeneousUint8,
            Struct9BytesHomogeneousUint8,
            Struct9BytesHomogeneousUint8,
            Struct9BytesHomogeneousUint8,
            Struct9BytesHomogeneousUint8)>(
    symbol: 'PassStruct9BytesHomogeneousUint8x10')
external int passStruct9BytesHomogeneousUint8x10Native(
    Struct9BytesHomogeneousUint8 a0,
    Struct9BytesHomogeneousUint8 a1,
    Struct9BytesHomogeneousUint8 a2,
    Struct9BytesHomogeneousUint8 a3,
    Struct9BytesHomogeneousUint8 a4,
    Struct9BytesHomogeneousUint8 a5,
    Struct9BytesHomogeneousUint8 a6,
    Struct9BytesHomogeneousUint8 a7,
    Struct9BytesHomogeneousUint8 a8,
    Struct9BytesHomogeneousUint8 a9);

/// Argument is a single byte over a multiple of word size.
/// 10 struct arguments will exhaust available registers.
/// Struct only has 1-byte aligned fields to test struct alignment itself.
/// Tests upper bytes in the integer registers that are partly filled.
/// Tests stack alignment of non word size stack arguments.
void testPassStruct9BytesHomogeneousUint8x10Native() {
  final a0Pointer = calloc<Struct9BytesHomogeneousUint8>();
  final Struct9BytesHomogeneousUint8 a0 = a0Pointer.ref;
  final a1Pointer = calloc<Struct9BytesHomogeneousUint8>();
  final Struct9BytesHomogeneousUint8 a1 = a1Pointer.ref;
  final a2Pointer = calloc<Struct9BytesHomogeneousUint8>();
  final Struct9BytesHomogeneousUint8 a2 = a2Pointer.ref;
  final a3Pointer = calloc<Struct9BytesHomogeneousUint8>();
  final Struct9BytesHomogeneousUint8 a3 = a3Pointer.ref;
  final a4Pointer = calloc<Struct9BytesHomogeneousUint8>();
  final Struct9BytesHomogeneousUint8 a4 = a4Pointer.ref;
  final a5Pointer = calloc<Struct9BytesHomogeneousUint8>();
  final Struct9BytesHomogeneousUint8 a5 = a5Pointer.ref;
  final a6Pointer = calloc<Struct9BytesHomogeneousUint8>();
  final Struct9BytesHomogeneousUint8 a6 = a6Pointer.ref;
  final a7Pointer = calloc<Struct9BytesHomogeneousUint8>();
  final Struct9BytesHomogeneousUint8 a7 = a7Pointer.ref;
  final a8Pointer = calloc<Struct9BytesHomogeneousUint8>();
  final Struct9BytesHomogeneousUint8 a8 = a8Pointer.ref;
  final a9Pointer = calloc<Struct9BytesHomogeneousUint8>();
  final Struct9BytesHomogeneousUint8 a9 = a9Pointer.ref;

  a0.a0 = 1;
  a0.a1 = 2;
  a0.a2 = 3;
  a0.a3 = 4;
  a0.a4 = 5;
  a0.a5 = 6;
  a0.a6 = 7;
  a0.a7 = 8;
  a0.a8 = 9;
  a1.a0 = 10;
  a1.a1 = 11;
  a1.a2 = 12;
  a1.a3 = 13;
  a1.a4 = 14;
  a1.a5 = 15;
  a1.a6 = 16;
  a1.a7 = 17;
  a1.a8 = 18;
  a2.a0 = 19;
  a2.a1 = 20;
  a2.a2 = 21;
  a2.a3 = 22;
  a2.a4 = 23;
  a2.a5 = 24;
  a2.a6 = 25;
  a2.a7 = 26;
  a2.a8 = 27;
  a3.a0 = 28;
  a3.a1 = 29;
  a3.a2 = 30;
  a3.a3 = 31;
  a3.a4 = 32;
  a3.a5 = 33;
  a3.a6 = 34;
  a3.a7 = 35;
  a3.a8 = 36;
  a4.a0 = 37;
  a4.a1 = 38;
  a4.a2 = 39;
  a4.a3 = 40;
  a4.a4 = 41;
  a4.a5 = 42;
  a4.a6 = 43;
  a4.a7 = 44;
  a4.a8 = 45;
  a5.a0 = 46;
  a5.a1 = 47;
  a5.a2 = 48;
  a5.a3 = 49;
  a5.a4 = 50;
  a5.a5 = 51;
  a5.a6 = 52;
  a5.a7 = 53;
  a5.a8 = 54;
  a6.a0 = 55;
  a6.a1 = 56;
  a6.a2 = 57;
  a6.a3 = 58;
  a6.a4 = 59;
  a6.a5 = 60;
  a6.a6 = 61;
  a6.a7 = 62;
  a6.a8 = 63;
  a7.a0 = 64;
  a7.a1 = 65;
  a7.a2 = 66;
  a7.a3 = 67;
  a7.a4 = 68;
  a7.a5 = 69;
  a7.a6 = 70;
  a7.a7 = 71;
  a7.a8 = 72;
  a8.a0 = 73;
  a8.a1 = 74;
  a8.a2 = 75;
  a8.a3 = 76;
  a8.a4 = 77;
  a8.a5 = 78;
  a8.a6 = 79;
  a8.a7 = 80;
  a8.a8 = 81;
  a9.a0 = 82;
  a9.a1 = 83;
  a9.a2 = 84;
  a9.a3 = 85;
  a9.a4 = 86;
  a9.a5 = 87;
  a9.a6 = 88;
  a9.a7 = 89;
  a9.a8 = 90;

  final result = passStruct9BytesHomogeneousUint8x10Native(
      a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);

  print("result = $result");

  Expect.equals(4095, result);

  calloc.free(a0Pointer);
  calloc.free(a1Pointer);
  calloc.free(a2Pointer);
  calloc.free(a3Pointer);
  calloc.free(a4Pointer);
  calloc.free(a5Pointer);
  calloc.free(a6Pointer);
  calloc.free(a7Pointer);
  calloc.free(a8Pointer);
  calloc.free(a9Pointer);
}

@Native<
        Int64 Function(
            Struct9BytesInt4Or8ByteAligned,
            Struct9BytesInt4Or8ByteAligned,
            Struct9BytesInt4Or8ByteAligned,
            Struct9BytesInt4Or8ByteAligned,
            Struct9BytesInt4Or8ByteAligned,
            Struct9BytesInt4Or8ByteAligned,
            Struct9BytesInt4Or8ByteAligned,
            Struct9BytesInt4Or8ByteAligned,
            Struct9BytesInt4Or8ByteAligned,
            Struct9BytesInt4Or8ByteAligned)>(
    symbol: 'PassStruct9BytesInt4Or8ByteAlignedx10')
external int passStruct9BytesInt4Or8ByteAlignedx10Native(
    Struct9BytesInt4Or8ByteAligned a0,
    Struct9BytesInt4Or8ByteAligned a1,
    Struct9BytesInt4Or8ByteAligned a2,
    Struct9BytesInt4Or8ByteAligned a3,
    Struct9BytesInt4Or8ByteAligned a4,
    Struct9BytesInt4Or8ByteAligned a5,
    Struct9BytesInt4Or8ByteAligned a6,
    Struct9BytesInt4Or8ByteAligned a7,
    Struct9BytesInt4Or8ByteAligned a8,
    Struct9BytesInt4Or8ByteAligned a9);

/// Argument is a single byte over a multiple of word size.
/// With alignment rules taken into account size is 12 or 16 bytes.
/// 10 struct arguments will exhaust available registers.
///
void testPassStruct9BytesInt4Or8ByteAlignedx10Native() {
  final a0Pointer = calloc<Struct9BytesInt4Or8ByteAligned>();
  final Struct9BytesInt4Or8ByteAligned a0 = a0Pointer.ref;
  final a1Pointer = calloc<Struct9BytesInt4Or8ByteAligned>();
  final Struct9BytesInt4Or8ByteAligned a1 = a1Pointer.ref;
  final a2Pointer = calloc<Struct9BytesInt4Or8ByteAligned>();
  final Struct9BytesInt4Or8ByteAligned a2 = a2Pointer.ref;
  final a3Pointer = calloc<Struct9BytesInt4Or8ByteAligned>();
  final Struct9BytesInt4Or8ByteAligned a3 = a3Pointer.ref;
  final a4Pointer = calloc<Struct9BytesInt4Or8ByteAligned>();
  final Struct9BytesInt4Or8ByteAligned a4 = a4Pointer.ref;
  final a5Pointer = calloc<Struct9BytesInt4Or8ByteAligned>();
  final Struct9BytesInt4Or8ByteAligned a5 = a5Pointer.ref;
  final a6Pointer = calloc<Struct9BytesInt4Or8ByteAligned>();
  final Struct9BytesInt4Or8ByteAligned a6 = a6Pointer.ref;
  final a7Pointer = calloc<Struct9BytesInt4Or8ByteAligned>();
  final Struct9BytesInt4Or8ByteAligned a7 = a7Pointer.ref;
  final a8Pointer = calloc<Struct9BytesInt4Or8ByteAligned>();
  final Struct9BytesInt4Or8ByteAligned a8 = a8Pointer.ref;
  final a9Pointer = calloc<Struct9BytesInt4Or8ByteAligned>();
  final Struct9BytesInt4Or8ByteAligned a9 = a9Pointer.ref;

  a0.a0 = -1;
  a0.a1 = 2;
  a1.a0 = -3;
  a1.a1 = 4;
  a2.a0 = -5;
  a2.a1 = 6;
  a3.a0 = -7;
  a3.a1 = 8;
  a4.a0 = -9;
  a4.a1 = 10;
  a5.a0 = -11;
  a5.a1 = 12;
  a6.a0 = -13;
  a6.a1 = 14;
  a7.a0 = -15;
  a7.a1 = 16;
  a8.a0 = -17;
  a8.a1 = 18;
  a9.a0 = -19;
  a9.a1 = 20;

  final result = passStruct9BytesInt4Or8ByteAlignedx10Native(
      a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);

  print("result = $result");

  Expect.equals(10, result);

  calloc.free(a0Pointer);
  calloc.free(a1Pointer);
  calloc.free(a2Pointer);
  calloc.free(a3Pointer);
  calloc.free(a4Pointer);
  calloc.free(a5Pointer);
  calloc.free(a6Pointer);
  calloc.free(a7Pointer);
  calloc.free(a8Pointer);
  calloc.free(a9Pointer);
}

@Native<
        Float Function(
            Struct12BytesHomogeneousFloat,
            Struct12BytesHomogeneousFloat,
            Struct12BytesHomogeneousFloat,
            Struct12BytesHomogeneousFloat,
            Struct12BytesHomogeneousFloat,
            Struct12BytesHomogeneousFloat)>(
    symbol: 'PassStruct12BytesHomogeneousFloatx6')
external double passStruct12BytesHomogeneousFloatx6Native(
    Struct12BytesHomogeneousFloat a0,
    Struct12BytesHomogeneousFloat a1,
    Struct12BytesHomogeneousFloat a2,
    Struct12BytesHomogeneousFloat a3,
    Struct12BytesHomogeneousFloat a4,
    Struct12BytesHomogeneousFloat a5);

/// Arguments in FPU registers on arm hardfp and arm64.
/// Struct arguments will exhaust available registers, and leave some empty.
/// The last argument is to test whether arguments are backfilled.
void testPassStruct12BytesHomogeneousFloatx6Native() {
  final a0Pointer = calloc<Struct12BytesHomogeneousFloat>();
  final Struct12BytesHomogeneousFloat a0 = a0Pointer.ref;
  final a1Pointer = calloc<Struct12BytesHomogeneousFloat>();
  final Struct12BytesHomogeneousFloat a1 = a1Pointer.ref;
  final a2Pointer = calloc<Struct12BytesHomogeneousFloat>();
  final Struct12BytesHomogeneousFloat a2 = a2Pointer.ref;
  final a3Pointer = calloc<Struct12BytesHomogeneousFloat>();
  final Struct12BytesHomogeneousFloat a3 = a3Pointer.ref;
  final a4Pointer = calloc<Struct12BytesHomogeneousFloat>();
  final Struct12BytesHomogeneousFloat a4 = a4Pointer.ref;
  final a5Pointer = calloc<Struct12BytesHomogeneousFloat>();
  final Struct12BytesHomogeneousFloat a5 = a5Pointer.ref;

  a0.a0 = -1.0;
  a0.a1 = 2.0;
  a0.a2 = -3.0;
  a1.a0 = 4.0;
  a1.a1 = -5.0;
  a1.a2 = 6.0;
  a2.a0 = -7.0;
  a2.a1 = 8.0;
  a2.a2 = -9.0;
  a3.a0 = 10.0;
  a3.a1 = -11.0;
  a3.a2 = 12.0;
  a4.a0 = -13.0;
  a4.a1 = 14.0;
  a4.a2 = -15.0;
  a5.a0 = 16.0;
  a5.a1 = -17.0;
  a5.a2 = 18.0;

  final result =
      passStruct12BytesHomogeneousFloatx6Native(a0, a1, a2, a3, a4, a5);

  print("result = $result");

  Expect.approxEquals(9.0, result);

  calloc.free(a0Pointer);
  calloc.free(a1Pointer);
  calloc.free(a2Pointer);
  calloc.free(a3Pointer);
  calloc.free(a4Pointer);
  calloc.free(a5Pointer);
}

@Native<
        Float Function(
            Struct16BytesHomogeneousFloat,
            Struct16BytesHomogeneousFloat,
            Struct16BytesHomogeneousFloat,
            Struct16BytesHomogeneousFloat,
            Struct16BytesHomogeneousFloat)>(
    symbol: 'PassStruct16BytesHomogeneousFloatx5')
external double passStruct16BytesHomogeneousFloatx5Native(
    Struct16BytesHomogeneousFloat a0,
    Struct16BytesHomogeneousFloat a1,
    Struct16BytesHomogeneousFloat a2,
    Struct16BytesHomogeneousFloat a3,
    Struct16BytesHomogeneousFloat a4);

/// On Linux x64 argument is transferred on stack because it is over 16 bytes.
/// Arguments in FPU registers on arm hardfp and arm64.
/// 5 struct arguments will exhaust available registers.
void testPassStruct16BytesHomogeneousFloatx5Native() {
  final a0Pointer = calloc<Struct16BytesHomogeneousFloat>();
  final Struct16BytesHomogeneousFloat a0 = a0Pointer.ref;
  final a1Pointer = calloc<Struct16BytesHomogeneousFloat>();
  final Struct16BytesHomogeneousFloat a1 = a1Pointer.ref;
  final a2Pointer = calloc<Struct16BytesHomogeneousFloat>();
  final Struct16BytesHomogeneousFloat a2 = a2Pointer.ref;
  final a3Pointer = calloc<Struct16BytesHomogeneousFloat>();
  final Struct16BytesHomogeneousFloat a3 = a3Pointer.ref;
  final a4Pointer = calloc<Struct16BytesHomogeneousFloat>();
  final Struct16BytesHomogeneousFloat a4 = a4Pointer.ref;

  a0.a0 = -1.0;
  a0.a1 = 2.0;
  a0.a2 = -3.0;
  a0.a3 = 4.0;
  a1.a0 = -5.0;
  a1.a1 = 6.0;
  a1.a2 = -7.0;
  a1.a3 = 8.0;
  a2.a0 = -9.0;
  a2.a1 = 10.0;
  a2.a2 = -11.0;
  a2.a3 = 12.0;
  a3.a0 = -13.0;
  a3.a1 = 14.0;
  a3.a2 = -15.0;
  a3.a3 = 16.0;
  a4.a0 = -17.0;
  a4.a1 = 18.0;
  a4.a2 = -19.0;
  a4.a3 = 20.0;

  final result = passStruct16BytesHomogeneousFloatx5Native(a0, a1, a2, a3, a4);

  print("result = $result");

  Expect.approxEquals(10.0, result);

  calloc.free(a0Pointer);
  calloc.free(a1Pointer);
  calloc.free(a2Pointer);
  calloc.free(a3Pointer);
  calloc.free(a4Pointer);
}

@Native<
    Double Function(
        Struct16BytesMixed,
        Struct16BytesMixed,
        Struct16BytesMixed,
        Struct16BytesMixed,
        Struct16BytesMixed,
        Struct16BytesMixed,
        Struct16BytesMixed,
        Struct16BytesMixed,
        Struct16BytesMixed,
        Struct16BytesMixed)>(symbol: 'PassStruct16BytesMixedx10')
external double passStruct16BytesMixedx10Native(
    Struct16BytesMixed a0,
    Struct16BytesMixed a1,
    Struct16BytesMixed a2,
    Struct16BytesMixed a3,
    Struct16BytesMixed a4,
    Struct16BytesMixed a5,
    Struct16BytesMixed a6,
    Struct16BytesMixed a7,
    Struct16BytesMixed a8,
    Struct16BytesMixed a9);

/// On x64, arguments are split over FP and int registers.
/// On x64, it will exhaust the integer registers with the 6th argument.
/// The rest goes on the stack.
/// On arm, arguments are 8 byte aligned.
void testPassStruct16BytesMixedx10Native() {
  final a0Pointer = calloc<Struct16BytesMixed>();
  final Struct16BytesMixed a0 = a0Pointer.ref;
  final a1Pointer = calloc<Struct16BytesMixed>();
  final Struct16BytesMixed a1 = a1Pointer.ref;
  final a2Pointer = calloc<Struct16BytesMixed>();
  final Struct16BytesMixed a2 = a2Pointer.ref;
  final a3Pointer = calloc<Struct16BytesMixed>();
  final Struct16BytesMixed a3 = a3Pointer.ref;
  final a4Pointer = calloc<Struct16BytesMixed>();
  final Struct16BytesMixed a4 = a4Pointer.ref;
  final a5Pointer = calloc<Struct16BytesMixed>();
  final Struct16BytesMixed a5 = a5Pointer.ref;
  final a6Pointer = calloc<Struct16BytesMixed>();
  final Struct16BytesMixed a6 = a6Pointer.ref;
  final a7Pointer = calloc<Struct16BytesMixed>();
  final Struct16BytesMixed a7 = a7Pointer.ref;
  final a8Pointer = calloc<Struct16BytesMixed>();
  final Struct16BytesMixed a8 = a8Pointer.ref;
  final a9Pointer = calloc<Struct16BytesMixed>();
  final Struct16BytesMixed a9 = a9Pointer.ref;

  a0.a0 = -1.0;
  a0.a1 = 2;
  a1.a0 = -3.0;
  a1.a1 = 4;
  a2.a0 = -5.0;
  a2.a1 = 6;
  a3.a0 = -7.0;
  a3.a1 = 8;
  a4.a0 = -9.0;
  a4.a1 = 10;
  a5.a0 = -11.0;
  a5.a1 = 12;
  a6.a0 = -13.0;
  a6.a1 = 14;
  a7.a0 = -15.0;
  a7.a1 = 16;
  a8.a0 = -17.0;
  a8.a1 = 18;
  a9.a0 = -19.0;
  a9.a1 = 20;

  final result =
      passStruct16BytesMixedx10Native(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);

  print("result = $result");

  Expect.approxEquals(10.0, result);

  calloc.free(a0Pointer);
  calloc.free(a1Pointer);
  calloc.free(a2Pointer);
  calloc.free(a3Pointer);
  calloc.free(a4Pointer);
  calloc.free(a5Pointer);
  calloc.free(a6Pointer);
  calloc.free(a7Pointer);
  calloc.free(a8Pointer);
  calloc.free(a9Pointer);
}

@Native<
    Float Function(
        Struct16BytesMixed2,
        Struct16BytesMixed2,
        Struct16BytesMixed2,
        Struct16BytesMixed2,
        Struct16BytesMixed2,
        Struct16BytesMixed2,
        Struct16BytesMixed2,
        Struct16BytesMixed2,
        Struct16BytesMixed2,
        Struct16BytesMixed2)>(symbol: 'PassStruct16BytesMixed2x10')
external double passStruct16BytesMixed2x10Native(
    Struct16BytesMixed2 a0,
    Struct16BytesMixed2 a1,
    Struct16BytesMixed2 a2,
    Struct16BytesMixed2 a3,
    Struct16BytesMixed2 a4,
    Struct16BytesMixed2 a5,
    Struct16BytesMixed2 a6,
    Struct16BytesMixed2 a7,
    Struct16BytesMixed2 a8,
    Struct16BytesMixed2 a9);

/// On x64, arguments are split over FP and int registers.
/// On x64, it will exhaust the integer registers with the 6th argument.
/// The rest goes on the stack.
/// On arm, arguments are 4 byte aligned.
void testPassStruct16BytesMixed2x10Native() {
  final a0Pointer = calloc<Struct16BytesMixed2>();
  final Struct16BytesMixed2 a0 = a0Pointer.ref;
  final a1Pointer = calloc<Struct16BytesMixed2>();
  final Struct16BytesMixed2 a1 = a1Pointer.ref;
  final a2Pointer = calloc<Struct16BytesMixed2>();
  final Struct16BytesMixed2 a2 = a2Pointer.ref;
  final a3Pointer = calloc<Struct16BytesMixed2>();
  final Struct16BytesMixed2 a3 = a3Pointer.ref;
  final a4Pointer = calloc<Struct16BytesMixed2>();
  final Struct16BytesMixed2 a4 = a4Pointer.ref;
  final a5Pointer = calloc<Struct16BytesMixed2>();
  final Struct16BytesMixed2 a5 = a5Pointer.ref;
  final a6Pointer = calloc<Struct16BytesMixed2>();
  final Struct16BytesMixed2 a6 = a6Pointer.ref;
  final a7Pointer = calloc<Struct16BytesMixed2>();
  final Struct16BytesMixed2 a7 = a7Pointer.ref;
  final a8Pointer = calloc<Struct16BytesMixed2>();
  final Struct16BytesMixed2 a8 = a8Pointer.ref;
  final a9Pointer = calloc<Struct16BytesMixed2>();
  final Struct16BytesMixed2 a9 = a9Pointer.ref;

  a0.a0 = -1.0;
  a0.a1 = 2.0;
  a0.a2 = -3.0;
  a0.a3 = 4;
  a1.a0 = -5.0;
  a1.a1 = 6.0;
  a1.a2 = -7.0;
  a1.a3 = 8;
  a2.a0 = -9.0;
  a2.a1 = 10.0;
  a2.a2 = -11.0;
  a2.a3 = 12;
  a3.a0 = -13.0;
  a3.a1 = 14.0;
  a3.a2 = -15.0;
  a3.a3 = 16;
  a4.a0 = -17.0;
  a4.a1 = 18.0;
  a4.a2 = -19.0;
  a4.a3 = 20;
  a5.a0 = -21.0;
  a5.a1 = 22.0;
  a5.a2 = -23.0;
  a5.a3 = 24;
  a6.a0 = -25.0;
  a6.a1 = 26.0;
  a6.a2 = -27.0;
  a6.a3 = 28;
  a7.a0 = -29.0;
  a7.a1 = 30.0;
  a7.a2 = -31.0;
  a7.a3 = 32;
  a8.a0 = -33.0;
  a8.a1 = 34.0;
  a8.a2 = -35.0;
  a8.a3 = 36;
  a9.a0 = -37.0;
  a9.a1 = 38.0;
  a9.a2 = -39.0;
  a9.a3 = 40;

  final result =
      passStruct16BytesMixed2x10Native(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);

  print("result = $result");

  Expect.approxEquals(20.0, result);

  calloc.free(a0Pointer);
  calloc.free(a1Pointer);
  calloc.free(a2Pointer);
  calloc.free(a3Pointer);
  calloc.free(a4Pointer);
  calloc.free(a5Pointer);
  calloc.free(a6Pointer);
  calloc.free(a7Pointer);
  calloc.free(a8Pointer);
  calloc.free(a9Pointer);
}

@Native<
    Int64 Function(
        Struct17BytesInt,
        Struct17BytesInt,
        Struct17BytesInt,
        Struct17BytesInt,
        Struct17BytesInt,
        Struct17BytesInt,
        Struct17BytesInt,
        Struct17BytesInt,
        Struct17BytesInt,
        Struct17BytesInt)>(symbol: 'PassStruct17BytesIntx10')
external int passStruct17BytesIntx10Native(
    Struct17BytesInt a0,
    Struct17BytesInt a1,
    Struct17BytesInt a2,
    Struct17BytesInt a3,
    Struct17BytesInt a4,
    Struct17BytesInt a5,
    Struct17BytesInt a6,
    Struct17BytesInt a7,
    Struct17BytesInt a8,
    Struct17BytesInt a9);

/// Arguments are passed as pointer to copy on arm64.
/// Tests that the memory allocated for copies are rounded up to word size.
void testPassStruct17BytesIntx10Native() {
  final a0Pointer = calloc<Struct17BytesInt>();
  final Struct17BytesInt a0 = a0Pointer.ref;
  final a1Pointer = calloc<Struct17BytesInt>();
  final Struct17BytesInt a1 = a1Pointer.ref;
  final a2Pointer = calloc<Struct17BytesInt>();
  final Struct17BytesInt a2 = a2Pointer.ref;
  final a3Pointer = calloc<Struct17BytesInt>();
  final Struct17BytesInt a3 = a3Pointer.ref;
  final a4Pointer = calloc<Struct17BytesInt>();
  final Struct17BytesInt a4 = a4Pointer.ref;
  final a5Pointer = calloc<Struct17BytesInt>();
  final Struct17BytesInt a5 = a5Pointer.ref;
  final a6Pointer = calloc<Struct17BytesInt>();
  final Struct17BytesInt a6 = a6Pointer.ref;
  final a7Pointer = calloc<Struct17BytesInt>();
  final Struct17BytesInt a7 = a7Pointer.ref;
  final a8Pointer = calloc<Struct17BytesInt>();
  final Struct17BytesInt a8 = a8Pointer.ref;
  final a9Pointer = calloc<Struct17BytesInt>();
  final Struct17BytesInt a9 = a9Pointer.ref;

  a0.a0 = -1;
  a0.a1 = 2;
  a0.a2 = -3;
  a1.a0 = 4;
  a1.a1 = -5;
  a1.a2 = 6;
  a2.a0 = -7;
  a2.a1 = 8;
  a2.a2 = -9;
  a3.a0 = 10;
  a3.a1 = -11;
  a3.a2 = 12;
  a4.a0 = -13;
  a4.a1 = 14;
  a4.a2 = -15;
  a5.a0 = 16;
  a5.a1 = -17;
  a5.a2 = 18;
  a6.a0 = -19;
  a6.a1 = 20;
  a6.a2 = -21;
  a7.a0 = 22;
  a7.a1 = -23;
  a7.a2 = 24;
  a8.a0 = -25;
  a8.a1 = 26;
  a8.a2 = -27;
  a9.a0 = 28;
  a9.a1 = -29;
  a9.a2 = 30;

  final result =
      passStruct17BytesIntx10Native(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);

  print("result = $result");

  Expect.equals(15, result);

  calloc.free(a0Pointer);
  calloc.free(a1Pointer);
  calloc.free(a2Pointer);
  calloc.free(a3Pointer);
  calloc.free(a4Pointer);
  calloc.free(a5Pointer);
  calloc.free(a6Pointer);
  calloc.free(a7Pointer);
  calloc.free(a8Pointer);
  calloc.free(a9Pointer);
}

@Native<
        Int64 Function(
            Struct19BytesHomogeneousUint8,
            Struct19BytesHomogeneousUint8,
            Struct19BytesHomogeneousUint8,
            Struct19BytesHomogeneousUint8,
            Struct19BytesHomogeneousUint8,
            Struct19BytesHomogeneousUint8,
            Struct19BytesHomogeneousUint8,
            Struct19BytesHomogeneousUint8,
            Struct19BytesHomogeneousUint8,
            Struct19BytesHomogeneousUint8)>(
    symbol: 'PassStruct19BytesHomogeneousUint8x10')
external int passStruct19BytesHomogeneousUint8x10Native(
    Struct19BytesHomogeneousUint8 a0,
    Struct19BytesHomogeneousUint8 a1,
    Struct19BytesHomogeneousUint8 a2,
    Struct19BytesHomogeneousUint8 a3,
    Struct19BytesHomogeneousUint8 a4,
    Struct19BytesHomogeneousUint8 a5,
    Struct19BytesHomogeneousUint8 a6,
    Struct19BytesHomogeneousUint8 a7,
    Struct19BytesHomogeneousUint8 a8,
    Struct19BytesHomogeneousUint8 a9);

/// The minimum alignment of this struct is only 1 byte based on its fields.
/// Test that the memory backing these structs is extended to the right size.
///
void testPassStruct19BytesHomogeneousUint8x10Native() {
  final a0Pointer = calloc<Struct19BytesHomogeneousUint8>();
  final Struct19BytesHomogeneousUint8 a0 = a0Pointer.ref;
  final a1Pointer = calloc<Struct19BytesHomogeneousUint8>();
  final Struct19BytesHomogeneousUint8 a1 = a1Pointer.ref;
  final a2Pointer = calloc<Struct19BytesHomogeneousUint8>();
  final Struct19BytesHomogeneousUint8 a2 = a2Pointer.ref;
  final a3Pointer = calloc<Struct19BytesHomogeneousUint8>();
  final Struct19BytesHomogeneousUint8 a3 = a3Pointer.ref;
  final a4Pointer = calloc<Struct19BytesHomogeneousUint8>();
  final Struct19BytesHomogeneousUint8 a4 = a4Pointer.ref;
  final a5Pointer = calloc<Struct19BytesHomogeneousUint8>();
  final Struct19BytesHomogeneousUint8 a5 = a5Pointer.ref;
  final a6Pointer = calloc<Struct19BytesHomogeneousUint8>();
  final Struct19BytesHomogeneousUint8 a6 = a6Pointer.ref;
  final a7Pointer = calloc<Struct19BytesHomogeneousUint8>();
  final Struct19BytesHomogeneousUint8 a7 = a7Pointer.ref;
  final a8Pointer = calloc<Struct19BytesHomogeneousUint8>();
  final Struct19BytesHomogeneousUint8 a8 = a8Pointer.ref;
  final a9Pointer = calloc<Struct19BytesHomogeneousUint8>();
  final Struct19BytesHomogeneousUint8 a9 = a9Pointer.ref;

  a0.a0 = 1;
  a0.a1 = 2;
  a0.a2 = 3;
  a0.a3 = 4;
  a0.a4 = 5;
  a0.a5 = 6;
  a0.a6 = 7;
  a0.a7 = 8;
  a0.a8 = 9;
  a0.a9 = 10;
  a0.a10 = 11;
  a0.a11 = 12;
  a0.a12 = 13;
  a0.a13 = 14;
  a0.a14 = 15;
  a0.a15 = 16;
  a0.a16 = 17;
  a0.a17 = 18;
  a0.a18 = 19;
  a1.a0 = 20;
  a1.a1 = 21;
  a1.a2 = 22;
  a1.a3 = 23;
  a1.a4 = 24;
  a1.a5 = 25;
  a1.a6 = 26;
  a1.a7 = 27;
  a1.a8 = 28;
  a1.a9 = 29;
  a1.a10 = 30;
  a1.a11 = 31;
  a1.a12 = 32;
  a1.a13 = 33;
  a1.a14 = 34;
  a1.a15 = 35;
  a1.a16 = 36;
  a1.a17 = 37;
  a1.a18 = 38;
  a2.a0 = 39;
  a2.a1 = 40;
  a2.a2 = 41;
  a2.a3 = 42;
  a2.a4 = 43;
  a2.a5 = 44;
  a2.a6 = 45;
  a2.a7 = 46;
  a2.a8 = 47;
  a2.a9 = 48;
  a2.a10 = 49;
  a2.a11 = 50;
  a2.a12 = 51;
  a2.a13 = 52;
  a2.a14 = 53;
  a2.a15 = 54;
  a2.a16 = 55;
  a2.a17 = 56;
  a2.a18 = 57;
  a3.a0 = 58;
  a3.a1 = 59;
  a3.a2 = 60;
  a3.a3 = 61;
  a3.a4 = 62;
  a3.a5 = 63;
  a3.a6 = 64;
  a3.a7 = 65;
  a3.a8 = 66;
  a3.a9 = 67;
  a3.a10 = 68;
  a3.a11 = 69;
  a3.a12 = 70;
  a3.a13 = 71;
  a3.a14 = 72;
  a3.a15 = 73;
  a3.a16 = 74;
  a3.a17 = 75;
  a3.a18 = 76;
  a4.a0 = 77;
  a4.a1 = 78;
  a4.a2 = 79;
  a4.a3 = 80;
  a4.a4 = 81;
  a4.a5 = 82;
  a4.a6 = 83;
  a4.a7 = 84;
  a4.a8 = 85;
  a4.a9 = 86;
  a4.a10 = 87;
  a4.a11 = 88;
  a4.a12 = 89;
  a4.a13 = 90;
  a4.a14 = 91;
  a4.a15 = 92;
  a4.a16 = 93;
  a4.a17 = 94;
  a4.a18 = 95;
  a5.a0 = 96;
  a5.a1 = 97;
  a5.a2 = 98;
  a5.a3 = 99;
  a5.a4 = 100;
  a5.a5 = 101;
  a5.a6 = 102;
  a5.a7 = 103;
  a5.a8 = 104;
  a5.a9 = 105;
  a5.a10 = 106;
  a5.a11 = 107;
  a5.a12 = 108;
  a5.a13 = 109;
  a5.a14 = 110;
  a5.a15 = 111;
  a5.a16 = 112;
  a5.a17 = 113;
  a5.a18 = 114;
  a6.a0 = 115;
  a6.a1 = 116;
  a6.a2 = 117;
  a6.a3 = 118;
  a6.a4 = 119;
  a6.a5 = 120;
  a6.a6 = 121;
  a6.a7 = 122;
  a6.a8 = 123;
  a6.a9 = 124;
  a6.a10 = 125;
  a6.a11 = 126;
  a6.a12 = 127;
  a6.a13 = 128;
  a6.a14 = 129;
  a6.a15 = 130;
  a6.a16 = 131;
  a6.a17 = 132;
  a6.a18 = 133;
  a7.a0 = 134;
  a7.a1 = 135;
  a7.a2 = 136;
  a7.a3 = 137;
  a7.a4 = 138;
  a7.a5 = 139;
  a7.a6 = 140;
  a7.a7 = 141;
  a7.a8 = 142;
  a7.a9 = 143;
  a7.a10 = 144;
  a7.a11 = 145;
  a7.a12 = 146;
  a7.a13 = 147;
  a7.a14 = 148;
  a7.a15 = 149;
  a7.a16 = 150;
  a7.a17 = 151;
  a7.a18 = 152;
  a8.a0 = 153;
  a8.a1 = 154;
  a8.a2 = 155;
  a8.a3 = 156;
  a8.a4 = 157;
  a8.a5 = 158;
  a8.a6 = 159;
  a8.a7 = 160;
  a8.a8 = 161;
  a8.a9 = 162;
  a8.a10 = 163;
  a8.a11 = 164;
  a8.a12 = 165;
  a8.a13 = 166;
  a8.a14 = 167;
  a8.a15 = 168;
  a8.a16 = 169;
  a8.a17 = 170;
  a8.a18 = 171;
  a9.a0 = 172;
  a9.a1 = 173;
  a9.a2 = 174;
  a9.a3 = 175;
  a9.a4 = 176;
  a9.a5 = 177;
  a9.a6 = 178;
  a9.a7 = 179;
  a9.a8 = 180;
  a9.a9 = 181;
  a9.a10 = 182;
  a9.a11 = 183;
  a9.a12 = 184;
  a9.a13 = 185;
  a9.a14 = 186;
  a9.a15 = 187;
  a9.a16 = 188;
  a9.a17 = 189;
  a9.a18 = 190;

  final result = passStruct19BytesHomogeneousUint8x10Native(
      a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);

  print("result = $result");

  Expect.equals(18145, result);

  calloc.free(a0Pointer);
  calloc.free(a1Pointer);
  calloc.free(a2Pointer);
  calloc.free(a3Pointer);
  calloc.free(a4Pointer);
  calloc.free(a5Pointer);
  calloc.free(a6Pointer);
  calloc.free(a7Pointer);
  calloc.free(a8Pointer);
  calloc.free(a9Pointer);
}

@Native<
        Int32 Function(
            Struct20BytesHomogeneousInt32,
            Struct20BytesHomogeneousInt32,
            Struct20BytesHomogeneousInt32,
            Struct20BytesHomogeneousInt32,
            Struct20BytesHomogeneousInt32,
            Struct20BytesHomogeneousInt32,
            Struct20BytesHomogeneousInt32,
            Struct20BytesHomogeneousInt32,
            Struct20BytesHomogeneousInt32,
            Struct20BytesHomogeneousInt32)>(
    symbol: 'PassStruct20BytesHomogeneousInt32x10')
external int passStruct20BytesHomogeneousInt32x10Native(
    Struct20BytesHomogeneousInt32 a0,
    Struct20BytesHomogeneousInt32 a1,
    Struct20BytesHomogeneousInt32 a2,
    Struct20BytesHomogeneousInt32 a3,
    Struct20BytesHomogeneousInt32 a4,
    Struct20BytesHomogeneousInt32 a5,
    Struct20BytesHomogeneousInt32 a6,
    Struct20BytesHomogeneousInt32 a7,
    Struct20BytesHomogeneousInt32 a8,
    Struct20BytesHomogeneousInt32 a9);

/// Argument too big to go into integer registers on arm64.
/// The arguments are passed as pointers to copies.
/// The amount of arguments exhausts the number of integer registers, such that
/// pointers to copies are also passed on the stack.
void testPassStruct20BytesHomogeneousInt32x10Native() {
  final a0Pointer = calloc<Struct20BytesHomogeneousInt32>();
  final Struct20BytesHomogeneousInt32 a0 = a0Pointer.ref;
  final a1Pointer = calloc<Struct20BytesHomogeneousInt32>();
  final Struct20BytesHomogeneousInt32 a1 = a1Pointer.ref;
  final a2Pointer = calloc<Struct20BytesHomogeneousInt32>();
  final Struct20BytesHomogeneousInt32 a2 = a2Pointer.ref;
  final a3Pointer = calloc<Struct20BytesHomogeneousInt32>();
  final Struct20BytesHomogeneousInt32 a3 = a3Pointer.ref;
  final a4Pointer = calloc<Struct20BytesHomogeneousInt32>();
  final Struct20BytesHomogeneousInt32 a4 = a4Pointer.ref;
  final a5Pointer = calloc<Struct20BytesHomogeneousInt32>();
  final Struct20BytesHomogeneousInt32 a5 = a5Pointer.ref;
  final a6Pointer = calloc<Struct20BytesHomogeneousInt32>();
  final Struct20BytesHomogeneousInt32 a6 = a6Pointer.ref;
  final a7Pointer = calloc<Struct20BytesHomogeneousInt32>();
  final Struct20BytesHomogeneousInt32 a7 = a7Pointer.ref;
  final a8Pointer = calloc<Struct20BytesHomogeneousInt32>();
  final Struct20BytesHomogeneousInt32 a8 = a8Pointer.ref;
  final a9Pointer = calloc<Struct20BytesHomogeneousInt32>();
  final Struct20BytesHomogeneousInt32 a9 = a9Pointer.ref;

  a0.a0 = -1;
  a0.a1 = 2;
  a0.a2 = -3;
  a0.a3 = 4;
  a0.a4 = -5;
  a1.a0 = 6;
  a1.a1 = -7;
  a1.a2 = 8;
  a1.a3 = -9;
  a1.a4 = 10;
  a2.a0 = -11;
  a2.a1 = 12;
  a2.a2 = -13;
  a2.a3 = 14;
  a2.a4 = -15;
  a3.a0 = 16;
  a3.a1 = -17;
  a3.a2 = 18;
  a3.a3 = -19;
  a3.a4 = 20;
  a4.a0 = -21;
  a4.a1 = 22;
  a4.a2 = -23;
  a4.a3 = 24;
  a4.a4 = -25;
  a5.a0 = 26;
  a5.a1 = -27;
  a5.a2 = 28;
  a5.a3 = -29;
  a5.a4 = 30;
  a6.a0 = -31;
  a6.a1 = 32;
  a6.a2 = -33;
  a6.a3 = 34;
  a6.a4 = -35;
  a7.a0 = 36;
  a7.a1 = -37;
  a7.a2 = 38;
  a7.a3 = -39;
  a7.a4 = 40;
  a8.a0 = -41;
  a8.a1 = 42;
  a8.a2 = -43;
  a8.a3 = 44;
  a8.a4 = -45;
  a9.a0 = 46;
  a9.a1 = -47;
  a9.a2 = 48;
  a9.a3 = -49;
  a9.a4 = 50;

  final result = passStruct20BytesHomogeneousInt32x10Native(
      a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);

  print("result = $result");

  Expect.equals(25, result);

  calloc.free(a0Pointer);
  calloc.free(a1Pointer);
  calloc.free(a2Pointer);
  calloc.free(a3Pointer);
  calloc.free(a4Pointer);
  calloc.free(a5Pointer);
  calloc.free(a6Pointer);
  calloc.free(a7Pointer);
  calloc.free(a8Pointer);
  calloc.free(a9Pointer);
}

@Native<Float Function(Struct20BytesHomogeneousFloat)>(
    symbol: 'PassStruct20BytesHomogeneousFloat')
external double passStruct20BytesHomogeneousFloatNative(
    Struct20BytesHomogeneousFloat a0);

/// Argument too big to go into FPU registers in hardfp and arm64.
void testPassStruct20BytesHomogeneousFloatNative() {
  final a0Pointer = calloc<Struct20BytesHomogeneousFloat>();
  final Struct20BytesHomogeneousFloat a0 = a0Pointer.ref;

  a0.a0 = -1.0;
  a0.a1 = 2.0;
  a0.a2 = -3.0;
  a0.a3 = 4.0;
  a0.a4 = -5.0;

  final result = passStruct20BytesHomogeneousFloatNative(a0);

  print("result = $result");

  Expect.approxEquals(-3.0, result);

  calloc.free(a0Pointer);
}

@Native<
        Double Function(
            Struct32BytesHomogeneousDouble,
            Struct32BytesHomogeneousDouble,
            Struct32BytesHomogeneousDouble,
            Struct32BytesHomogeneousDouble,
            Struct32BytesHomogeneousDouble)>(
    symbol: 'PassStruct32BytesHomogeneousDoublex5')
external double passStruct32BytesHomogeneousDoublex5Native(
    Struct32BytesHomogeneousDouble a0,
    Struct32BytesHomogeneousDouble a1,
    Struct32BytesHomogeneousDouble a2,
    Struct32BytesHomogeneousDouble a3,
    Struct32BytesHomogeneousDouble a4);

/// Arguments in FPU registers on arm64.
/// 5 struct arguments will exhaust available registers.
void testPassStruct32BytesHomogeneousDoublex5Native() {
  final a0Pointer = calloc<Struct32BytesHomogeneousDouble>();
  final Struct32BytesHomogeneousDouble a0 = a0Pointer.ref;
  final a1Pointer = calloc<Struct32BytesHomogeneousDouble>();
  final Struct32BytesHomogeneousDouble a1 = a1Pointer.ref;
  final a2Pointer = calloc<Struct32BytesHomogeneousDouble>();
  final Struct32BytesHomogeneousDouble a2 = a2Pointer.ref;
  final a3Pointer = calloc<Struct32BytesHomogeneousDouble>();
  final Struct32BytesHomogeneousDouble a3 = a3Pointer.ref;
  final a4Pointer = calloc<Struct32BytesHomogeneousDouble>();
  final Struct32BytesHomogeneousDouble a4 = a4Pointer.ref;

  a0.a0 = -1.0;
  a0.a1 = 2.0;
  a0.a2 = -3.0;
  a0.a3 = 4.0;
  a1.a0 = -5.0;
  a1.a1 = 6.0;
  a1.a2 = -7.0;
  a1.a3 = 8.0;
  a2.a0 = -9.0;
  a2.a1 = 10.0;
  a2.a2 = -11.0;
  a2.a3 = 12.0;
  a3.a0 = -13.0;
  a3.a1 = 14.0;
  a3.a2 = -15.0;
  a3.a3 = 16.0;
  a4.a0 = -17.0;
  a4.a1 = 18.0;
  a4.a2 = -19.0;
  a4.a3 = 20.0;

  final result = passStruct32BytesHomogeneousDoublex5Native(a0, a1, a2, a3, a4);

  print("result = $result");

  Expect.approxEquals(10.0, result);

  calloc.free(a0Pointer);
  calloc.free(a1Pointer);
  calloc.free(a2Pointer);
  calloc.free(a3Pointer);
  calloc.free(a4Pointer);
}

@Native<Double Function(Struct40BytesHomogeneousDouble)>(
    symbol: 'PassStruct40BytesHomogeneousDouble')
external double passStruct40BytesHomogeneousDoubleNative(
    Struct40BytesHomogeneousDouble a0);

/// Argument too big to go into FPU registers in arm64.
void testPassStruct40BytesHomogeneousDoubleNative() {
  final a0Pointer = calloc<Struct40BytesHomogeneousDouble>();
  final Struct40BytesHomogeneousDouble a0 = a0Pointer.ref;

  a0.a0 = -1.0;
  a0.a1 = 2.0;
  a0.a2 = -3.0;
  a0.a3 = 4.0;
  a0.a4 = -5.0;

  final result = passStruct40BytesHomogeneousDoubleNative(a0);

  print("result = $result");

  Expect.approxEquals(-3.0, result);

  calloc.free(a0Pointer);
}

@Native<Uint64 Function(Struct1024BytesHomogeneousUint64)>(
    symbol: 'PassStruct1024BytesHomogeneousUint64')
external int passStruct1024BytesHomogeneousUint64Native(
    Struct1024BytesHomogeneousUint64 a0);

/// Test 1kb struct.
void testPassStruct1024BytesHomogeneousUint64Native() {
  final a0Pointer = calloc<Struct1024BytesHomogeneousUint64>();
  final Struct1024BytesHomogeneousUint64 a0 = a0Pointer.ref;

  a0.a0 = 1;
  a0.a1 = 2;
  a0.a2 = 3;
  a0.a3 = 4;
  a0.a4 = 5;
  a0.a5 = 6;
  a0.a6 = 7;
  a0.a7 = 8;
  a0.a8 = 9;
  a0.a9 = 10;
  a0.a10 = 11;
  a0.a11 = 12;
  a0.a12 = 13;
  a0.a13 = 14;
  a0.a14 = 15;
  a0.a15 = 16;
  a0.a16 = 17;
  a0.a17 = 18;
  a0.a18 = 19;
  a0.a19 = 20;
  a0.a20 = 21;
  a0.a21 = 22;
  a0.a22 = 23;
  a0.a23 = 24;
  a0.a24 = 25;
  a0.a25 = 26;
  a0.a26 = 27;
  a0.a27 = 28;
  a0.a28 = 29;
  a0.a29 = 30;
  a0.a30 = 31;
  a0.a31 = 32;
  a0.a32 = 33;
  a0.a33 = 34;
  a0.a34 = 35;
  a0.a35 = 36;
  a0.a36 = 37;
  a0.a37 = 38;
  a0.a38 = 39;
  a0.a39 = 40;
  a0.a40 = 41;
  a0.a41 = 42;
  a0.a42 = 43;
  a0.a43 = 44;
  a0.a44 = 45;
  a0.a45 = 46;
  a0.a46 = 47;
  a0.a47 = 48;
  a0.a48 = 49;
  a0.a49 = 50;
  a0.a50 = 51;
  a0.a51 = 52;
  a0.a52 = 53;
  a0.a53 = 54;
  a0.a54 = 55;
  a0.a55 = 56;
  a0.a56 = 57;
  a0.a57 = 58;
  a0.a58 = 59;
  a0.a59 = 60;
  a0.a60 = 61;
  a0.a61 = 62;
  a0.a62 = 63;
  a0.a63 = 64;
  a0.a64 = 65;
  a0.a65 = 66;
  a0.a66 = 67;
  a0.a67 = 68;
  a0.a68 = 69;
  a0.a69 = 70;
  a0.a70 = 71;
  a0.a71 = 72;
  a0.a72 = 73;
  a0.a73 = 74;
  a0.a74 = 75;
  a0.a75 = 76;
  a0.a76 = 77;
  a0.a77 = 78;
  a0.a78 = 79;
  a0.a79 = 80;
  a0.a80 = 81;
  a0.a81 = 82;
  a0.a82 = 83;
  a0.a83 = 84;
  a0.a84 = 85;
  a0.a85 = 86;
  a0.a86 = 87;
  a0.a87 = 88;
  a0.a88 = 89;
  a0.a89 = 90;
  a0.a90 = 91;
  a0.a91 = 92;
  a0.a92 = 93;
  a0.a93 = 94;
  a0.a94 = 95;
  a0.a95 = 96;
  a0.a96 = 97;
  a0.a97 = 98;
  a0.a98 = 99;
  a0.a99 = 100;
  a0.a100 = 101;
  a0.a101 = 102;
  a0.a102 = 103;
  a0.a103 = 104;
  a0.a104 = 105;
  a0.a105 = 106;
  a0.a106 = 107;
  a0.a107 = 108;
  a0.a108 = 109;
  a0.a109 = 110;
  a0.a110 = 111;
  a0.a111 = 112;
  a0.a112 = 113;
  a0.a113 = 114;
  a0.a114 = 115;
  a0.a115 = 116;
  a0.a116 = 117;
  a0.a117 = 118;
  a0.a118 = 119;
  a0.a119 = 120;
  a0.a120 = 121;
  a0.a121 = 122;
  a0.a122 = 123;
  a0.a123 = 124;
  a0.a124 = 125;
  a0.a125 = 126;
  a0.a126 = 127;
  a0.a127 = 128;

  final result = passStruct1024BytesHomogeneousUint64Native(a0);

  print("result = $result");

  Expect.equals(8256, result);

  calloc.free(a0Pointer);
}

@Native<
    Float Function(
        Float,
        Struct16BytesHomogeneousFloat,
        Float,
        Struct16BytesHomogeneousFloat,
        Float,
        Struct16BytesHomogeneousFloat,
        Float,
        Struct16BytesHomogeneousFloat,
        Float)>(symbol: 'PassFloatStruct16BytesHomogeneousFloatFloatStruct1')
external double passFloatStruct16BytesHomogeneousFloatFloatStruct1Native(
    double a0,
    Struct16BytesHomogeneousFloat a1,
    double a2,
    Struct16BytesHomogeneousFloat a3,
    double a4,
    Struct16BytesHomogeneousFloat a5,
    double a6,
    Struct16BytesHomogeneousFloat a7,
    double a8);

/// Tests the alignment of structs in FPU registers and backfilling.
void testPassFloatStruct16BytesHomogeneousFloatFloatStruct1Native() {
  double a0;
  final a1Pointer = calloc<Struct16BytesHomogeneousFloat>();
  final Struct16BytesHomogeneousFloat a1 = a1Pointer.ref;
  double a2;
  final a3Pointer = calloc<Struct16BytesHomogeneousFloat>();
  final Struct16BytesHomogeneousFloat a3 = a3Pointer.ref;
  double a4;
  final a5Pointer = calloc<Struct16BytesHomogeneousFloat>();
  final Struct16BytesHomogeneousFloat a5 = a5Pointer.ref;
  double a6;
  final a7Pointer = calloc<Struct16BytesHomogeneousFloat>();
  final Struct16BytesHomogeneousFloat a7 = a7Pointer.ref;
  double a8;

  a0 = -1.0;
  a1.a0 = 2.0;
  a1.a1 = -3.0;
  a1.a2 = 4.0;
  a1.a3 = -5.0;
  a2 = 6.0;
  a3.a0 = -7.0;
  a3.a1 = 8.0;
  a3.a2 = -9.0;
  a3.a3 = 10.0;
  a4 = -11.0;
  a5.a0 = 12.0;
  a5.a1 = -13.0;
  a5.a2 = 14.0;
  a5.a3 = -15.0;
  a6 = 16.0;
  a7.a0 = -17.0;
  a7.a1 = 18.0;
  a7.a2 = -19.0;
  a7.a3 = 20.0;
  a8 = -21.0;

  final result = passFloatStruct16BytesHomogeneousFloatFloatStruct1Native(
      a0, a1, a2, a3, a4, a5, a6, a7, a8);

  print("result = $result");

  Expect.approxEquals(-11.0, result);

  calloc.free(a1Pointer);
  calloc.free(a3Pointer);
  calloc.free(a5Pointer);
  calloc.free(a7Pointer);
}

@Native<
    Double Function(
        Float,
        Struct32BytesHomogeneousDouble,
        Float,
        Struct32BytesHomogeneousDouble,
        Float,
        Struct32BytesHomogeneousDouble,
        Float,
        Struct32BytesHomogeneousDouble,
        Float)>(symbol: 'PassFloatStruct32BytesHomogeneousDoubleFloatStruct')
external double passFloatStruct32BytesHomogeneousDoubleFloatStructNative(
    double a0,
    Struct32BytesHomogeneousDouble a1,
    double a2,
    Struct32BytesHomogeneousDouble a3,
    double a4,
    Struct32BytesHomogeneousDouble a5,
    double a6,
    Struct32BytesHomogeneousDouble a7,
    double a8);

/// Tests the alignment of structs in FPU registers and backfilling.
void testPassFloatStruct32BytesHomogeneousDoubleFloatStructNative() {
  double a0;
  final a1Pointer = calloc<Struct32BytesHomogeneousDouble>();
  final Struct32BytesHomogeneousDouble a1 = a1Pointer.ref;
  double a2;
  final a3Pointer = calloc<Struct32BytesHomogeneousDouble>();
  final Struct32BytesHomogeneousDouble a3 = a3Pointer.ref;
  double a4;
  final a5Pointer = calloc<Struct32BytesHomogeneousDouble>();
  final Struct32BytesHomogeneousDouble a5 = a5Pointer.ref;
  double a6;
  final a7Pointer = calloc<Struct32BytesHomogeneousDouble>();
  final Struct32BytesHomogeneousDouble a7 = a7Pointer.ref;
  double a8;

  a0 = -1.0;
  a1.a0 = 2.0;
  a1.a1 = -3.0;
  a1.a2 = 4.0;
  a1.a3 = -5.0;
  a2 = 6.0;
  a3.a0 = -7.0;
  a3.a1 = 8.0;
  a3.a2 = -9.0;
  a3.a3 = 10.0;
  a4 = -11.0;
  a5.a0 = 12.0;
  a5.a1 = -13.0;
  a5.a2 = 14.0;
  a5.a3 = -15.0;
  a6 = 16.0;
  a7.a0 = -17.0;
  a7.a1 = 18.0;
  a7.a2 = -19.0;
  a7.a3 = 20.0;
  a8 = -21.0;

  final result = passFloatStruct32BytesHomogeneousDoubleFloatStructNative(
      a0, a1, a2, a3, a4, a5, a6, a7, a8);

  print("result = $result");

  Expect.approxEquals(-11.0, result);

  calloc.free(a1Pointer);
  calloc.free(a3Pointer);
  calloc.free(a5Pointer);
  calloc.free(a7Pointer);
}

@Native<
    Double Function(
        Int8,
        Struct16BytesMixed,
        Int8,
        Struct16BytesMixed,
        Int8,
        Struct16BytesMixed,
        Int8,
        Struct16BytesMixed,
        Int8)>(symbol: 'PassInt8Struct16BytesMixedInt8Struct16BytesMixedIn')
external double passInt8Struct16BytesMixedInt8Struct16BytesMixedInNative(
    int a0,
    Struct16BytesMixed a1,
    int a2,
    Struct16BytesMixed a3,
    int a4,
    Struct16BytesMixed a5,
    int a6,
    Struct16BytesMixed a7,
    int a8);

/// Tests the alignment of structs in integers registers and on the stack.
/// Arm32 aligns this struct at 8.
/// Also, arm32 allocates the second struct partially in registers, partially
/// on stack.
/// Test backfilling of integer registers.
void testPassInt8Struct16BytesMixedInt8Struct16BytesMixedInNative() {
  int a0;
  final a1Pointer = calloc<Struct16BytesMixed>();
  final Struct16BytesMixed a1 = a1Pointer.ref;
  int a2;
  final a3Pointer = calloc<Struct16BytesMixed>();
  final Struct16BytesMixed a3 = a3Pointer.ref;
  int a4;
  final a5Pointer = calloc<Struct16BytesMixed>();
  final Struct16BytesMixed a5 = a5Pointer.ref;
  int a6;
  final a7Pointer = calloc<Struct16BytesMixed>();
  final Struct16BytesMixed a7 = a7Pointer.ref;
  int a8;

  a0 = -1;
  a1.a0 = 2.0;
  a1.a1 = -3;
  a2 = 4;
  a3.a0 = -5.0;
  a3.a1 = 6;
  a4 = -7;
  a5.a0 = 8.0;
  a5.a1 = -9;
  a6 = 10;
  a7.a0 = -11.0;
  a7.a1 = 12;
  a8 = -13;

  final result = passInt8Struct16BytesMixedInt8Struct16BytesMixedInNative(
      a0, a1, a2, a3, a4, a5, a6, a7, a8);

  print("result = $result");

  Expect.approxEquals(-7.0, result);

  calloc.free(a1Pointer);
  calloc.free(a3Pointer);
  calloc.free(a5Pointer);
  calloc.free(a7Pointer);
}

@Native<
    Double Function(
        Double,
        Double,
        Double,
        Double,
        Double,
        Double,
        Struct16BytesMixed,
        Struct16BytesMixed,
        Struct16BytesMixed,
        Struct16BytesMixed,
        Int32)>(symbol: 'PassDoublex6Struct16BytesMixedx4Int32')
external double passDoublex6Struct16BytesMixedx4Int32Native(
    double a0,
    double a1,
    double a2,
    double a3,
    double a4,
    double a5,
    Struct16BytesMixed a6,
    Struct16BytesMixed a7,
    Struct16BytesMixed a8,
    Struct16BytesMixed a9,
    int a10);

/// On Linux x64, it will exhaust xmm registers first, after 6 doubles and 2
/// structs. The rest of the structs will go on the stack.
/// The int will be backfilled into the int register.
void testPassDoublex6Struct16BytesMixedx4Int32Native() {
  double a0;
  double a1;
  double a2;
  double a3;
  double a4;
  double a5;
  final a6Pointer = calloc<Struct16BytesMixed>();
  final Struct16BytesMixed a6 = a6Pointer.ref;
  final a7Pointer = calloc<Struct16BytesMixed>();
  final Struct16BytesMixed a7 = a7Pointer.ref;
  final a8Pointer = calloc<Struct16BytesMixed>();
  final Struct16BytesMixed a8 = a8Pointer.ref;
  final a9Pointer = calloc<Struct16BytesMixed>();
  final Struct16BytesMixed a9 = a9Pointer.ref;
  int a10;

  a0 = -1.0;
  a1 = 2.0;
  a2 = -3.0;
  a3 = 4.0;
  a4 = -5.0;
  a5 = 6.0;
  a6.a0 = -7.0;
  a6.a1 = 8;
  a7.a0 = -9.0;
  a7.a1 = 10;
  a8.a0 = -11.0;
  a8.a1 = 12;
  a9.a0 = -13.0;
  a9.a1 = 14;
  a10 = -15;

  final result = passDoublex6Struct16BytesMixedx4Int32Native(
      a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);

  print("result = $result");

  Expect.approxEquals(-8.0, result);

  calloc.free(a6Pointer);
  calloc.free(a7Pointer);
  calloc.free(a8Pointer);
  calloc.free(a9Pointer);
}

@Native<
    Double Function(
        Int32,
        Int32,
        Int32,
        Int32,
        Struct16BytesMixed,
        Struct16BytesMixed,
        Struct16BytesMixed,
        Struct16BytesMixed,
        Double)>(symbol: 'PassInt32x4Struct16BytesMixedx4Double')
external double passInt32x4Struct16BytesMixedx4DoubleNative(
    int a0,
    int a1,
    int a2,
    int a3,
    Struct16BytesMixed a4,
    Struct16BytesMixed a5,
    Struct16BytesMixed a6,
    Struct16BytesMixed a7,
    double a8);

/// On Linux x64, it will exhaust int registers first.
/// The rest of the structs will go on the stack.
/// The double will be backfilled into the xmm register.
void testPassInt32x4Struct16BytesMixedx4DoubleNative() {
  int a0;
  int a1;
  int a2;
  int a3;
  final a4Pointer = calloc<Struct16BytesMixed>();
  final Struct16BytesMixed a4 = a4Pointer.ref;
  final a5Pointer = calloc<Struct16BytesMixed>();
  final Struct16BytesMixed a5 = a5Pointer.ref;
  final a6Pointer = calloc<Struct16BytesMixed>();
  final Struct16BytesMixed a6 = a6Pointer.ref;
  final a7Pointer = calloc<Struct16BytesMixed>();
  final Struct16BytesMixed a7 = a7Pointer.ref;
  double a8;

  a0 = -1;
  a1 = 2;
  a2 = -3;
  a3 = 4;
  a4.a0 = -5.0;
  a4.a1 = 6;
  a5.a0 = -7.0;
  a5.a1 = 8;
  a6.a0 = -9.0;
  a6.a1 = 10;
  a7.a0 = -11.0;
  a7.a1 = 12;
  a8 = -13.0;

  final result = passInt32x4Struct16BytesMixedx4DoubleNative(
      a0, a1, a2, a3, a4, a5, a6, a7, a8);

  print("result = $result");

  Expect.approxEquals(-7.0, result);

  calloc.free(a4Pointer);
  calloc.free(a5Pointer);
  calloc.free(a6Pointer);
  calloc.free(a7Pointer);
}

@Native<
        Double Function(Struct40BytesHomogeneousDouble,
            Struct4BytesHomogeneousInt16, Struct8BytesHomogeneousFloat)>(
    symbol: 'PassStruct40BytesHomogeneousDoubleStruct4BytesHomo')
external double passStruct40BytesHomogeneousDoubleStruct4BytesHomoNative(
    Struct40BytesHomogeneousDouble a0,
    Struct4BytesHomogeneousInt16 a1,
    Struct8BytesHomogeneousFloat a2);

/// On various architectures, first struct is allocated on stack.
/// Check that the other two arguments are allocated on registers.
void testPassStruct40BytesHomogeneousDoubleStruct4BytesHomoNative() {
  final a0Pointer = calloc<Struct40BytesHomogeneousDouble>();
  final Struct40BytesHomogeneousDouble a0 = a0Pointer.ref;
  final a1Pointer = calloc<Struct4BytesHomogeneousInt16>();
  final Struct4BytesHomogeneousInt16 a1 = a1Pointer.ref;
  final a2Pointer = calloc<Struct8BytesHomogeneousFloat>();
  final Struct8BytesHomogeneousFloat a2 = a2Pointer.ref;

  a0.a0 = -1.0;
  a0.a1 = 2.0;
  a0.a2 = -3.0;
  a0.a3 = 4.0;
  a0.a4 = -5.0;
  a1.a0 = 6;
  a1.a1 = -7;
  a2.a0 = 8.0;
  a2.a1 = -9.0;

  final result =
      passStruct40BytesHomogeneousDoubleStruct4BytesHomoNative(a0, a1, a2);

  print("result = $result");

  Expect.approxEquals(-5.0, result);

  calloc.free(a0Pointer);
  calloc.free(a1Pointer);
  calloc.free(a2Pointer);
}

@Native<
        Double Function(
            Int32,
            Int32,
            Int32,
            Int32,
            Int32,
            Int32,
            Int32,
            Int32,
            Double,
            Double,
            Double,
            Double,
            Double,
            Double,
            Double,
            Double,
            Int64,
            Int8,
            Struct1ByteInt,
            Int64,
            Int8,
            Struct4BytesHomogeneousInt16,
            Int64,
            Int8,
            Struct8BytesInt,
            Int64,
            Int8,
            Struct8BytesHomogeneousFloat,
            Int64,
            Int8,
            Struct8BytesMixed,
            Int64,
            Int8,
            StructAlignmentInt16,
            Int64,
            Int8,
            StructAlignmentInt32,
            Int64,
            Int8,
            StructAlignmentInt64)>(
    symbol: 'PassInt32x8Doublex8Int64Int8Struct1ByteIntInt64Int')
external double passInt32x8Doublex8Int64Int8Struct1ByteIntInt64IntNative(
    int a0,
    int a1,
    int a2,
    int a3,
    int a4,
    int a5,
    int a6,
    int a7,
    double a8,
    double a9,
    double a10,
    double a11,
    double a12,
    double a13,
    double a14,
    double a15,
    int a16,
    int a17,
    Struct1ByteInt a18,
    int a19,
    int a20,
    Struct4BytesHomogeneousInt16 a21,
    int a22,
    int a23,
    Struct8BytesInt a24,
    int a25,
    int a26,
    Struct8BytesHomogeneousFloat a27,
    int a28,
    int a29,
    Struct8BytesMixed a30,
    int a31,
    int a32,
    StructAlignmentInt16 a33,
    int a34,
    int a35,
    StructAlignmentInt32 a36,
    int a37,
    int a38,
    StructAlignmentInt64 a39);

/// Test alignment and padding of 16 byte int within struct.
void testPassInt32x8Doublex8Int64Int8Struct1ByteIntInt64IntNative() {
  int a0;
  int a1;
  int a2;
  int a3;
  int a4;
  int a5;
  int a6;
  int a7;
  double a8;
  double a9;
  double a10;
  double a11;
  double a12;
  double a13;
  double a14;
  double a15;
  int a16;
  int a17;
  final a18Pointer = calloc<Struct1ByteInt>();
  final Struct1ByteInt a18 = a18Pointer.ref;
  int a19;
  int a20;
  final a21Pointer = calloc<Struct4BytesHomogeneousInt16>();
  final Struct4BytesHomogeneousInt16 a21 = a21Pointer.ref;
  int a22;
  int a23;
  final a24Pointer = calloc<Struct8BytesInt>();
  final Struct8BytesInt a24 = a24Pointer.ref;
  int a25;
  int a26;
  final a27Pointer = calloc<Struct8BytesHomogeneousFloat>();
  final Struct8BytesHomogeneousFloat a27 = a27Pointer.ref;
  int a28;
  int a29;
  final a30Pointer = calloc<Struct8BytesMixed>();
  final Struct8BytesMixed a30 = a30Pointer.ref;
  int a31;
  int a32;
  final a33Pointer = calloc<StructAlignmentInt16>();
  final StructAlignmentInt16 a33 = a33Pointer.ref;
  int a34;
  int a35;
  final a36Pointer = calloc<StructAlignmentInt32>();
  final StructAlignmentInt32 a36 = a36Pointer.ref;
  int a37;
  int a38;
  final a39Pointer = calloc<StructAlignmentInt64>();
  final StructAlignmentInt64 a39 = a39Pointer.ref;

  a0 = -1;
  a1 = 2;
  a2 = -3;
  a3 = 4;
  a4 = -5;
  a5 = 6;
  a6 = -7;
  a7 = 8;
  a8 = -9.0;
  a9 = 10.0;
  a10 = -11.0;
  a11 = 12.0;
  a12 = -13.0;
  a13 = 14.0;
  a14 = -15.0;
  a15 = 16.0;
  a16 = -17;
  a17 = 18;
  a18.a0 = -19;
  a19 = 20;
  a20 = -21;
  a21.a0 = 22;
  a21.a1 = -23;
  a22 = 24;
  a23 = -25;
  a24.a0 = 26;
  a24.a1 = -27;
  a24.a2 = 28;
  a25 = -29;
  a26 = 30;
  a27.a0 = -31.0;
  a27.a1 = 32.0;
  a28 = -33;
  a29 = 34;
  a30.a0 = -35.0;
  a30.a1 = 36;
  a30.a2 = -37;
  a31 = 38;
  a32 = -39;
  a33.a0 = 40;
  a33.a1 = -41;
  a33.a2 = 42;
  a34 = -43;
  a35 = 44;
  a36.a0 = -45;
  a36.a1 = 46;
  a36.a2 = -47;
  a37 = 48;
  a38 = -49;
  a39.a0 = 50;
  a39.a1 = -51;
  a39.a2 = 52;

  final result = passInt32x8Doublex8Int64Int8Struct1ByteIntInt64IntNative(
      a0,
      a1,
      a2,
      a3,
      a4,
      a5,
      a6,
      a7,
      a8,
      a9,
      a10,
      a11,
      a12,
      a13,
      a14,
      a15,
      a16,
      a17,
      a18,
      a19,
      a20,
      a21,
      a22,
      a23,
      a24,
      a25,
      a26,
      a27,
      a28,
      a29,
      a30,
      a31,
      a32,
      a33,
      a34,
      a35,
      a36,
      a37,
      a38,
      a39);

  print("result = $result");

  Expect.approxEquals(26.0, result);

  calloc.free(a18Pointer);
  calloc.free(a21Pointer);
  calloc.free(a24Pointer);
  calloc.free(a27Pointer);
  calloc.free(a30Pointer);
  calloc.free(a33Pointer);
  calloc.free(a36Pointer);
  calloc.free(a39Pointer);
}

@Native<Int64 Function(StructAlignmentInt16)>(
    symbol: 'PassStructAlignmentInt16')
external int passStructAlignmentInt16Native(StructAlignmentInt16 a0);

/// Test alignment and padding of 16 byte int within struct.
void testPassStructAlignmentInt16Native() {
  final a0Pointer = calloc<StructAlignmentInt16>();
  final StructAlignmentInt16 a0 = a0Pointer.ref;

  a0.a0 = -1;
  a0.a1 = 2;
  a0.a2 = -3;

  final result = passStructAlignmentInt16Native(a0);

  print("result = $result");

  Expect.equals(-2, result);

  calloc.free(a0Pointer);
}

@Native<Int64 Function(StructAlignmentInt32)>(
    symbol: 'PassStructAlignmentInt32')
external int passStructAlignmentInt32Native(StructAlignmentInt32 a0);

/// Test alignment and padding of 32 byte int within struct.
void testPassStructAlignmentInt32Native() {
  final a0Pointer = calloc<StructAlignmentInt32>();
  final StructAlignmentInt32 a0 = a0Pointer.ref;

  a0.a0 = -1;
  a0.a1 = 2;
  a0.a2 = -3;

  final result = passStructAlignmentInt32Native(a0);

  print("result = $result");

  Expect.equals(-2, result);

  calloc.free(a0Pointer);
}

@Native<Int64 Function(StructAlignmentInt64)>(
    symbol: 'PassStructAlignmentInt64')
external int passStructAlignmentInt64Native(StructAlignmentInt64 a0);

/// Test alignment and padding of 64 byte int within struct.
void testPassStructAlignmentInt64Native() {
  final a0Pointer = calloc<StructAlignmentInt64>();
  final StructAlignmentInt64 a0 = a0Pointer.ref;

  a0.a0 = -1;
  a0.a1 = 2;
  a0.a2 = -3;

  final result = passStructAlignmentInt64Native(a0);

  print("result = $result");

  Expect.equals(-2, result);

  calloc.free(a0Pointer);
}

@Native<
    Int64 Function(
        Struct8BytesNestedInt,
        Struct8BytesNestedInt,
        Struct8BytesNestedInt,
        Struct8BytesNestedInt,
        Struct8BytesNestedInt,
        Struct8BytesNestedInt,
        Struct8BytesNestedInt,
        Struct8BytesNestedInt,
        Struct8BytesNestedInt,
        Struct8BytesNestedInt)>(symbol: 'PassStruct8BytesNestedIntx10')
external int passStruct8BytesNestedIntx10Native(
    Struct8BytesNestedInt a0,
    Struct8BytesNestedInt a1,
    Struct8BytesNestedInt a2,
    Struct8BytesNestedInt a3,
    Struct8BytesNestedInt a4,
    Struct8BytesNestedInt a5,
    Struct8BytesNestedInt a6,
    Struct8BytesNestedInt a7,
    Struct8BytesNestedInt a8,
    Struct8BytesNestedInt a9);

/// Simple nested struct. No alignment gaps on any architectures.
/// 10 arguments exhaust registers on all platforms.
void testPassStruct8BytesNestedIntx10Native() {
  final a0Pointer = calloc<Struct8BytesNestedInt>();
  final Struct8BytesNestedInt a0 = a0Pointer.ref;
  final a1Pointer = calloc<Struct8BytesNestedInt>();
  final Struct8BytesNestedInt a1 = a1Pointer.ref;
  final a2Pointer = calloc<Struct8BytesNestedInt>();
  final Struct8BytesNestedInt a2 = a2Pointer.ref;
  final a3Pointer = calloc<Struct8BytesNestedInt>();
  final Struct8BytesNestedInt a3 = a3Pointer.ref;
  final a4Pointer = calloc<Struct8BytesNestedInt>();
  final Struct8BytesNestedInt a4 = a4Pointer.ref;
  final a5Pointer = calloc<Struct8BytesNestedInt>();
  final Struct8BytesNestedInt a5 = a5Pointer.ref;
  final a6Pointer = calloc<Struct8BytesNestedInt>();
  final Struct8BytesNestedInt a6 = a6Pointer.ref;
  final a7Pointer = calloc<Struct8BytesNestedInt>();
  final Struct8BytesNestedInt a7 = a7Pointer.ref;
  final a8Pointer = calloc<Struct8BytesNestedInt>();
  final Struct8BytesNestedInt a8 = a8Pointer.ref;
  final a9Pointer = calloc<Struct8BytesNestedInt>();
  final Struct8BytesNestedInt a9 = a9Pointer.ref;

  a0.a0.a0 = -1;
  a0.a0.a1 = 2;
  a0.a1.a0 = -3;
  a0.a1.a1 = 4;
  a1.a0.a0 = -5;
  a1.a0.a1 = 6;
  a1.a1.a0 = -7;
  a1.a1.a1 = 8;
  a2.a0.a0 = -9;
  a2.a0.a1 = 10;
  a2.a1.a0 = -11;
  a2.a1.a1 = 12;
  a3.a0.a0 = -13;
  a3.a0.a1 = 14;
  a3.a1.a0 = -15;
  a3.a1.a1 = 16;
  a4.a0.a0 = -17;
  a4.a0.a1 = 18;
  a4.a1.a0 = -19;
  a4.a1.a1 = 20;
  a5.a0.a0 = -21;
  a5.a0.a1 = 22;
  a5.a1.a0 = -23;
  a5.a1.a1 = 24;
  a6.a0.a0 = -25;
  a6.a0.a1 = 26;
  a6.a1.a0 = -27;
  a6.a1.a1 = 28;
  a7.a0.a0 = -29;
  a7.a0.a1 = 30;
  a7.a1.a0 = -31;
  a7.a1.a1 = 32;
  a8.a0.a0 = -33;
  a8.a0.a1 = 34;
  a8.a1.a0 = -35;
  a8.a1.a1 = 36;
  a9.a0.a0 = -37;
  a9.a0.a1 = 38;
  a9.a1.a0 = -39;
  a9.a1.a1 = 40;

  final result = passStruct8BytesNestedIntx10Native(
      a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);

  print("result = $result");

  Expect.equals(20, result);

  calloc.free(a0Pointer);
  calloc.free(a1Pointer);
  calloc.free(a2Pointer);
  calloc.free(a3Pointer);
  calloc.free(a4Pointer);
  calloc.free(a5Pointer);
  calloc.free(a6Pointer);
  calloc.free(a7Pointer);
  calloc.free(a8Pointer);
  calloc.free(a9Pointer);
}

@Native<
    Float Function(
        Struct8BytesNestedFloat,
        Struct8BytesNestedFloat,
        Struct8BytesNestedFloat,
        Struct8BytesNestedFloat,
        Struct8BytesNestedFloat,
        Struct8BytesNestedFloat,
        Struct8BytesNestedFloat,
        Struct8BytesNestedFloat,
        Struct8BytesNestedFloat,
        Struct8BytesNestedFloat)>(symbol: 'PassStruct8BytesNestedFloatx10')
external double passStruct8BytesNestedFloatx10Native(
    Struct8BytesNestedFloat a0,
    Struct8BytesNestedFloat a1,
    Struct8BytesNestedFloat a2,
    Struct8BytesNestedFloat a3,
    Struct8BytesNestedFloat a4,
    Struct8BytesNestedFloat a5,
    Struct8BytesNestedFloat a6,
    Struct8BytesNestedFloat a7,
    Struct8BytesNestedFloat a8,
    Struct8BytesNestedFloat a9);

/// Simple nested struct. No alignment gaps on any architectures.
/// 10 arguments exhaust fpu registers on all platforms.
void testPassStruct8BytesNestedFloatx10Native() {
  final a0Pointer = calloc<Struct8BytesNestedFloat>();
  final Struct8BytesNestedFloat a0 = a0Pointer.ref;
  final a1Pointer = calloc<Struct8BytesNestedFloat>();
  final Struct8BytesNestedFloat a1 = a1Pointer.ref;
  final a2Pointer = calloc<Struct8BytesNestedFloat>();
  final Struct8BytesNestedFloat a2 = a2Pointer.ref;
  final a3Pointer = calloc<Struct8BytesNestedFloat>();
  final Struct8BytesNestedFloat a3 = a3Pointer.ref;
  final a4Pointer = calloc<Struct8BytesNestedFloat>();
  final Struct8BytesNestedFloat a4 = a4Pointer.ref;
  final a5Pointer = calloc<Struct8BytesNestedFloat>();
  final Struct8BytesNestedFloat a5 = a5Pointer.ref;
  final a6Pointer = calloc<Struct8BytesNestedFloat>();
  final Struct8BytesNestedFloat a6 = a6Pointer.ref;
  final a7Pointer = calloc<Struct8BytesNestedFloat>();
  final Struct8BytesNestedFloat a7 = a7Pointer.ref;
  final a8Pointer = calloc<Struct8BytesNestedFloat>();
  final Struct8BytesNestedFloat a8 = a8Pointer.ref;
  final a9Pointer = calloc<Struct8BytesNestedFloat>();
  final Struct8BytesNestedFloat a9 = a9Pointer.ref;

  a0.a0.a0 = -1.0;
  a0.a1.a0 = 2.0;
  a1.a0.a0 = -3.0;
  a1.a1.a0 = 4.0;
  a2.a0.a0 = -5.0;
  a2.a1.a0 = 6.0;
  a3.a0.a0 = -7.0;
  a3.a1.a0 = 8.0;
  a4.a0.a0 = -9.0;
  a4.a1.a0 = 10.0;
  a5.a0.a0 = -11.0;
  a5.a1.a0 = 12.0;
  a6.a0.a0 = -13.0;
  a6.a1.a0 = 14.0;
  a7.a0.a0 = -15.0;
  a7.a1.a0 = 16.0;
  a8.a0.a0 = -17.0;
  a8.a1.a0 = 18.0;
  a9.a0.a0 = -19.0;
  a9.a1.a0 = 20.0;

  final result = passStruct8BytesNestedFloatx10Native(
      a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);

  print("result = $result");

  Expect.approxEquals(10.0, result);

  calloc.free(a0Pointer);
  calloc.free(a1Pointer);
  calloc.free(a2Pointer);
  calloc.free(a3Pointer);
  calloc.free(a4Pointer);
  calloc.free(a5Pointer);
  calloc.free(a6Pointer);
  calloc.free(a7Pointer);
  calloc.free(a8Pointer);
  calloc.free(a9Pointer);
}

@Native<
    Float Function(
        Struct8BytesNestedFloat2,
        Struct8BytesNestedFloat2,
        Struct8BytesNestedFloat2,
        Struct8BytesNestedFloat2,
        Struct8BytesNestedFloat2,
        Struct8BytesNestedFloat2,
        Struct8BytesNestedFloat2,
        Struct8BytesNestedFloat2,
        Struct8BytesNestedFloat2,
        Struct8BytesNestedFloat2)>(symbol: 'PassStruct8BytesNestedFloat2x10')
external double passStruct8BytesNestedFloat2x10Native(
    Struct8BytesNestedFloat2 a0,
    Struct8BytesNestedFloat2 a1,
    Struct8BytesNestedFloat2 a2,
    Struct8BytesNestedFloat2 a3,
    Struct8BytesNestedFloat2 a4,
    Struct8BytesNestedFloat2 a5,
    Struct8BytesNestedFloat2 a6,
    Struct8BytesNestedFloat2 a7,
    Struct8BytesNestedFloat2 a8,
    Struct8BytesNestedFloat2 a9);

/// Simple nested struct. No alignment gaps on any architectures.
/// 10 arguments exhaust fpu registers on all platforms.
/// The nesting is irregular, testing homogenous float rules on arm and arm64,
/// and the fpu register usage on x64.
void testPassStruct8BytesNestedFloat2x10Native() {
  final a0Pointer = calloc<Struct8BytesNestedFloat2>();
  final Struct8BytesNestedFloat2 a0 = a0Pointer.ref;
  final a1Pointer = calloc<Struct8BytesNestedFloat2>();
  final Struct8BytesNestedFloat2 a1 = a1Pointer.ref;
  final a2Pointer = calloc<Struct8BytesNestedFloat2>();
  final Struct8BytesNestedFloat2 a2 = a2Pointer.ref;
  final a3Pointer = calloc<Struct8BytesNestedFloat2>();
  final Struct8BytesNestedFloat2 a3 = a3Pointer.ref;
  final a4Pointer = calloc<Struct8BytesNestedFloat2>();
  final Struct8BytesNestedFloat2 a4 = a4Pointer.ref;
  final a5Pointer = calloc<Struct8BytesNestedFloat2>();
  final Struct8BytesNestedFloat2 a5 = a5Pointer.ref;
  final a6Pointer = calloc<Struct8BytesNestedFloat2>();
  final Struct8BytesNestedFloat2 a6 = a6Pointer.ref;
  final a7Pointer = calloc<Struct8BytesNestedFloat2>();
  final Struct8BytesNestedFloat2 a7 = a7Pointer.ref;
  final a8Pointer = calloc<Struct8BytesNestedFloat2>();
  final Struct8BytesNestedFloat2 a8 = a8Pointer.ref;
  final a9Pointer = calloc<Struct8BytesNestedFloat2>();
  final Struct8BytesNestedFloat2 a9 = a9Pointer.ref;

  a0.a0.a0 = -1.0;
  a0.a1 = 2.0;
  a1.a0.a0 = -3.0;
  a1.a1 = 4.0;
  a2.a0.a0 = -5.0;
  a2.a1 = 6.0;
  a3.a0.a0 = -7.0;
  a3.a1 = 8.0;
  a4.a0.a0 = -9.0;
  a4.a1 = 10.0;
  a5.a0.a0 = -11.0;
  a5.a1 = 12.0;
  a6.a0.a0 = -13.0;
  a6.a1 = 14.0;
  a7.a0.a0 = -15.0;
  a7.a1 = 16.0;
  a8.a0.a0 = -17.0;
  a8.a1 = 18.0;
  a9.a0.a0 = -19.0;
  a9.a1 = 20.0;

  final result = passStruct8BytesNestedFloat2x10Native(
      a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);

  print("result = $result");

  Expect.approxEquals(10.0, result);

  calloc.free(a0Pointer);
  calloc.free(a1Pointer);
  calloc.free(a2Pointer);
  calloc.free(a3Pointer);
  calloc.free(a4Pointer);
  calloc.free(a5Pointer);
  calloc.free(a6Pointer);
  calloc.free(a7Pointer);
  calloc.free(a8Pointer);
  calloc.free(a9Pointer);
}

@Native<
    Double Function(
        Struct8BytesNestedMixed,
        Struct8BytesNestedMixed,
        Struct8BytesNestedMixed,
        Struct8BytesNestedMixed,
        Struct8BytesNestedMixed,
        Struct8BytesNestedMixed,
        Struct8BytesNestedMixed,
        Struct8BytesNestedMixed,
        Struct8BytesNestedMixed,
        Struct8BytesNestedMixed)>(symbol: 'PassStruct8BytesNestedMixedx10')
external double passStruct8BytesNestedMixedx10Native(
    Struct8BytesNestedMixed a0,
    Struct8BytesNestedMixed a1,
    Struct8BytesNestedMixed a2,
    Struct8BytesNestedMixed a3,
    Struct8BytesNestedMixed a4,
    Struct8BytesNestedMixed a5,
    Struct8BytesNestedMixed a6,
    Struct8BytesNestedMixed a7,
    Struct8BytesNestedMixed a8,
    Struct8BytesNestedMixed a9);

/// Simple nested struct. No alignment gaps on any architectures.
/// 10 arguments exhaust all registers on all platforms.
void testPassStruct8BytesNestedMixedx10Native() {
  final a0Pointer = calloc<Struct8BytesNestedMixed>();
  final Struct8BytesNestedMixed a0 = a0Pointer.ref;
  final a1Pointer = calloc<Struct8BytesNestedMixed>();
  final Struct8BytesNestedMixed a1 = a1Pointer.ref;
  final a2Pointer = calloc<Struct8BytesNestedMixed>();
  final Struct8BytesNestedMixed a2 = a2Pointer.ref;
  final a3Pointer = calloc<Struct8BytesNestedMixed>();
  final Struct8BytesNestedMixed a3 = a3Pointer.ref;
  final a4Pointer = calloc<Struct8BytesNestedMixed>();
  final Struct8BytesNestedMixed a4 = a4Pointer.ref;
  final a5Pointer = calloc<Struct8BytesNestedMixed>();
  final Struct8BytesNestedMixed a5 = a5Pointer.ref;
  final a6Pointer = calloc<Struct8BytesNestedMixed>();
  final Struct8BytesNestedMixed a6 = a6Pointer.ref;
  final a7Pointer = calloc<Struct8BytesNestedMixed>();
  final Struct8BytesNestedMixed a7 = a7Pointer.ref;
  final a8Pointer = calloc<Struct8BytesNestedMixed>();
  final Struct8BytesNestedMixed a8 = a8Pointer.ref;
  final a9Pointer = calloc<Struct8BytesNestedMixed>();
  final Struct8BytesNestedMixed a9 = a9Pointer.ref;

  a0.a0.a0 = -1;
  a0.a0.a1 = 2;
  a0.a1.a0 = -3.0;
  a1.a0.a0 = 4;
  a1.a0.a1 = -5;
  a1.a1.a0 = 6.0;
  a2.a0.a0 = -7;
  a2.a0.a1 = 8;
  a2.a1.a0 = -9.0;
  a3.a0.a0 = 10;
  a3.a0.a1 = -11;
  a3.a1.a0 = 12.0;
  a4.a0.a0 = -13;
  a4.a0.a1 = 14;
  a4.a1.a0 = -15.0;
  a5.a0.a0 = 16;
  a5.a0.a1 = -17;
  a5.a1.a0 = 18.0;
  a6.a0.a0 = -19;
  a6.a0.a1 = 20;
  a6.a1.a0 = -21.0;
  a7.a0.a0 = 22;
  a7.a0.a1 = -23;
  a7.a1.a0 = 24.0;
  a8.a0.a0 = -25;
  a8.a0.a1 = 26;
  a8.a1.a0 = -27.0;
  a9.a0.a0 = 28;
  a9.a0.a1 = -29;
  a9.a1.a0 = 30.0;

  final result = passStruct8BytesNestedMixedx10Native(
      a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);

  print("result = $result");

  Expect.approxEquals(15.0, result);

  calloc.free(a0Pointer);
  calloc.free(a1Pointer);
  calloc.free(a2Pointer);
  calloc.free(a3Pointer);
  calloc.free(a4Pointer);
  calloc.free(a5Pointer);
  calloc.free(a6Pointer);
  calloc.free(a7Pointer);
  calloc.free(a8Pointer);
  calloc.free(a9Pointer);
}

@Native<Int64 Function(Struct16BytesNestedInt, Struct16BytesNestedInt)>(
    symbol: 'PassStruct16BytesNestedIntx2')
external int passStruct16BytesNestedIntx2Native(
    Struct16BytesNestedInt a0, Struct16BytesNestedInt a1);

/// Deeper nested struct to test recursive member access.
void testPassStruct16BytesNestedIntx2Native() {
  final a0Pointer = calloc<Struct16BytesNestedInt>();
  final Struct16BytesNestedInt a0 = a0Pointer.ref;
  final a1Pointer = calloc<Struct16BytesNestedInt>();
  final Struct16BytesNestedInt a1 = a1Pointer.ref;

  a0.a0.a0.a0 = -1;
  a0.a0.a0.a1 = 2;
  a0.a0.a1.a0 = -3;
  a0.a0.a1.a1 = 4;
  a0.a1.a0.a0 = -5;
  a0.a1.a0.a1 = 6;
  a0.a1.a1.a0 = -7;
  a0.a1.a1.a1 = 8;
  a1.a0.a0.a0 = -9;
  a1.a0.a0.a1 = 10;
  a1.a0.a1.a0 = -11;
  a1.a0.a1.a1 = 12;
  a1.a1.a0.a0 = -13;
  a1.a1.a0.a1 = 14;
  a1.a1.a1.a0 = -15;
  a1.a1.a1.a1 = 16;

  final result = passStruct16BytesNestedIntx2Native(a0, a1);

  print("result = $result");

  Expect.equals(8, result);

  calloc.free(a0Pointer);
  calloc.free(a1Pointer);
}

@Native<Int64 Function(Struct32BytesNestedInt, Struct32BytesNestedInt)>(
    symbol: 'PassStruct32BytesNestedIntx2')
external int passStruct32BytesNestedIntx2Native(
    Struct32BytesNestedInt a0, Struct32BytesNestedInt a1);

/// Even deeper nested struct to test recursive member access.
void testPassStruct32BytesNestedIntx2Native() {
  final a0Pointer = calloc<Struct32BytesNestedInt>();
  final Struct32BytesNestedInt a0 = a0Pointer.ref;
  final a1Pointer = calloc<Struct32BytesNestedInt>();
  final Struct32BytesNestedInt a1 = a1Pointer.ref;

  a0.a0.a0.a0.a0 = -1;
  a0.a0.a0.a0.a1 = 2;
  a0.a0.a0.a1.a0 = -3;
  a0.a0.a0.a1.a1 = 4;
  a0.a0.a1.a0.a0 = -5;
  a0.a0.a1.a0.a1 = 6;
  a0.a0.a1.a1.a0 = -7;
  a0.a0.a1.a1.a1 = 8;
  a0.a1.a0.a0.a0 = -9;
  a0.a1.a0.a0.a1 = 10;
  a0.a1.a0.a1.a0 = -11;
  a0.a1.a0.a1.a1 = 12;
  a0.a1.a1.a0.a0 = -13;
  a0.a1.a1.a0.a1 = 14;
  a0.a1.a1.a1.a0 = -15;
  a0.a1.a1.a1.a1 = 16;
  a1.a0.a0.a0.a0 = -17;
  a1.a0.a0.a0.a1 = 18;
  a1.a0.a0.a1.a0 = -19;
  a1.a0.a0.a1.a1 = 20;
  a1.a0.a1.a0.a0 = -21;
  a1.a0.a1.a0.a1 = 22;
  a1.a0.a1.a1.a0 = -23;
  a1.a0.a1.a1.a1 = 24;
  a1.a1.a0.a0.a0 = -25;
  a1.a1.a0.a0.a1 = 26;
  a1.a1.a0.a1.a0 = -27;
  a1.a1.a0.a1.a1 = 28;
  a1.a1.a1.a0.a0 = -29;
  a1.a1.a1.a0.a1 = 30;
  a1.a1.a1.a1.a0 = -31;
  a1.a1.a1.a1.a1 = 32;

  final result = passStruct32BytesNestedIntx2Native(a0, a1);

  print("result = $result");

  Expect.equals(16, result);

  calloc.free(a0Pointer);
  calloc.free(a1Pointer);
}

@Native<Int64 Function(StructNestedIntStructAlignmentInt16)>(
    symbol: 'PassStructNestedIntStructAlignmentInt16')
external int passStructNestedIntStructAlignmentInt16Native(
    StructNestedIntStructAlignmentInt16 a0);

/// Test alignment and padding of nested struct with 16 byte int.
void testPassStructNestedIntStructAlignmentInt16Native() {
  final a0Pointer = calloc<StructNestedIntStructAlignmentInt16>();
  final StructNestedIntStructAlignmentInt16 a0 = a0Pointer.ref;

  a0.a0.a0 = -1;
  a0.a0.a1 = 2;
  a0.a0.a2 = -3;
  a0.a1.a0 = 4;
  a0.a1.a1 = -5;
  a0.a1.a2 = 6;

  final result = passStructNestedIntStructAlignmentInt16Native(a0);

  print("result = $result");

  Expect.equals(3, result);

  calloc.free(a0Pointer);
}

@Native<Int64 Function(StructNestedIntStructAlignmentInt32)>(
    symbol: 'PassStructNestedIntStructAlignmentInt32')
external int passStructNestedIntStructAlignmentInt32Native(
    StructNestedIntStructAlignmentInt32 a0);

/// Test alignment and padding of nested struct with 32 byte int.
void testPassStructNestedIntStructAlignmentInt32Native() {
  final a0Pointer = calloc<StructNestedIntStructAlignmentInt32>();
  final StructNestedIntStructAlignmentInt32 a0 = a0Pointer.ref;

  a0.a0.a0 = -1;
  a0.a0.a1 = 2;
  a0.a0.a2 = -3;
  a0.a1.a0 = 4;
  a0.a1.a1 = -5;
  a0.a1.a2 = 6;

  final result = passStructNestedIntStructAlignmentInt32Native(a0);

  print("result = $result");

  Expect.equals(3, result);

  calloc.free(a0Pointer);
}

@Native<Int64 Function(StructNestedIntStructAlignmentInt64)>(
    symbol: 'PassStructNestedIntStructAlignmentInt64')
external int passStructNestedIntStructAlignmentInt64Native(
    StructNestedIntStructAlignmentInt64 a0);

/// Test alignment and padding of nested struct with 64 byte int.
void testPassStructNestedIntStructAlignmentInt64Native() {
  final a0Pointer = calloc<StructNestedIntStructAlignmentInt64>();
  final StructNestedIntStructAlignmentInt64 a0 = a0Pointer.ref;

  a0.a0.a0 = -1;
  a0.a0.a1 = 2;
  a0.a0.a2 = -3;
  a0.a1.a0 = 4;
  a0.a1.a1 = -5;
  a0.a1.a2 = 6;

  final result = passStructNestedIntStructAlignmentInt64Native(a0);

  print("result = $result");

  Expect.equals(3, result);

  calloc.free(a0Pointer);
}

@Native<
        Double Function(
            StructNestedIrregularEvenBigger,
            StructNestedIrregularEvenBigger,
            StructNestedIrregularEvenBigger,
            StructNestedIrregularEvenBigger)>(
    symbol: 'PassStructNestedIrregularEvenBiggerx4')
external double passStructNestedIrregularEvenBiggerx4Native(
    StructNestedIrregularEvenBigger a0,
    StructNestedIrregularEvenBigger a1,
    StructNestedIrregularEvenBigger a2,
    StructNestedIrregularEvenBigger a3);

/// Return big irregular struct as smoke test.
void testPassStructNestedIrregularEvenBiggerx4Native() {
  final a0Pointer = calloc<StructNestedIrregularEvenBigger>();
  final StructNestedIrregularEvenBigger a0 = a0Pointer.ref;
  final a1Pointer = calloc<StructNestedIrregularEvenBigger>();
  final StructNestedIrregularEvenBigger a1 = a1Pointer.ref;
  final a2Pointer = calloc<StructNestedIrregularEvenBigger>();
  final StructNestedIrregularEvenBigger a2 = a2Pointer.ref;
  final a3Pointer = calloc<StructNestedIrregularEvenBigger>();
  final StructNestedIrregularEvenBigger a3 = a3Pointer.ref;

  a0.a0 = 1;
  a0.a1.a0.a0 = 2;
  a0.a1.a0.a1.a0.a0 = -3;
  a0.a1.a0.a1.a0.a1 = 4;
  a0.a1.a0.a1.a1.a0 = -5.0;
  a0.a1.a0.a2 = 6;
  a0.a1.a0.a3.a0.a0 = -7.0;
  a0.a1.a0.a3.a1 = 8.0;
  a0.a1.a0.a4 = 9;
  a0.a1.a0.a5.a0.a0 = 10.0;
  a0.a1.a0.a5.a1.a0 = -11.0;
  a0.a1.a0.a6 = 12;
  a0.a1.a1.a0.a0 = -13;
  a0.a1.a1.a0.a1 = 14;
  a0.a1.a1.a1.a0 = -15.0;
  a0.a1.a2 = 16.0;
  a0.a1.a3 = -17.0;
  a0.a2.a0.a0 = 18;
  a0.a2.a0.a1.a0.a0 = -19;
  a0.a2.a0.a1.a0.a1 = 20;
  a0.a2.a0.a1.a1.a0 = -21.0;
  a0.a2.a0.a2 = 22;
  a0.a2.a0.a3.a0.a0 = -23.0;
  a0.a2.a0.a3.a1 = 24.0;
  a0.a2.a0.a4 = 25;
  a0.a2.a0.a5.a0.a0 = 26.0;
  a0.a2.a0.a5.a1.a0 = -27.0;
  a0.a2.a0.a6 = 28;
  a0.a2.a1.a0.a0 = -29;
  a0.a2.a1.a0.a1 = 30;
  a0.a2.a1.a1.a0 = -31.0;
  a0.a2.a2 = 32.0;
  a0.a2.a3 = -33.0;
  a0.a3 = 34.0;
  a1.a0 = 35;
  a1.a1.a0.a0 = 36;
  a1.a1.a0.a1.a0.a0 = -37;
  a1.a1.a0.a1.a0.a1 = 38;
  a1.a1.a0.a1.a1.a0 = -39.0;
  a1.a1.a0.a2 = 40;
  a1.a1.a0.a3.a0.a0 = -41.0;
  a1.a1.a0.a3.a1 = 42.0;
  a1.a1.a0.a4 = 43;
  a1.a1.a0.a5.a0.a0 = 44.0;
  a1.a1.a0.a5.a1.a0 = -45.0;
  a1.a1.a0.a6 = 46;
  a1.a1.a1.a0.a0 = -47;
  a1.a1.a1.a0.a1 = 48;
  a1.a1.a1.a1.a0 = -49.0;
  a1.a1.a2 = 50.0;
  a1.a1.a3 = -51.0;
  a1.a2.a0.a0 = 52;
  a1.a2.a0.a1.a0.a0 = -53;
  a1.a2.a0.a1.a0.a1 = 54;
  a1.a2.a0.a1.a1.a0 = -55.0;
  a1.a2.a0.a2 = 56;
  a1.a2.a0.a3.a0.a0 = -57.0;
  a1.a2.a0.a3.a1 = 58.0;
  a1.a2.a0.a4 = 59;
  a1.a2.a0.a5.a0.a0 = 60.0;
  a1.a2.a0.a5.a1.a0 = -61.0;
  a1.a2.a0.a6 = 62;
  a1.a2.a1.a0.a0 = -63;
  a1.a2.a1.a0.a1 = 64;
  a1.a2.a1.a1.a0 = -65.0;
  a1.a2.a2 = 66.0;
  a1.a2.a3 = -67.0;
  a1.a3 = 68.0;
  a2.a0 = 69;
  a2.a1.a0.a0 = 70;
  a2.a1.a0.a1.a0.a0 = -71;
  a2.a1.a0.a1.a0.a1 = 72;
  a2.a1.a0.a1.a1.a0 = -73.0;
  a2.a1.a0.a2 = 74;
  a2.a1.a0.a3.a0.a0 = -75.0;
  a2.a1.a0.a3.a1 = 76.0;
  a2.a1.a0.a4 = 77;
  a2.a1.a0.a5.a0.a0 = 78.0;
  a2.a1.a0.a5.a1.a0 = -79.0;
  a2.a1.a0.a6 = 80;
  a2.a1.a1.a0.a0 = -81;
  a2.a1.a1.a0.a1 = 82;
  a2.a1.a1.a1.a0 = -83.0;
  a2.a1.a2 = 84.0;
  a2.a1.a3 = -85.0;
  a2.a2.a0.a0 = 86;
  a2.a2.a0.a1.a0.a0 = -87;
  a2.a2.a0.a1.a0.a1 = 88;
  a2.a2.a0.a1.a1.a0 = -89.0;
  a2.a2.a0.a2 = 90;
  a2.a2.a0.a3.a0.a0 = -91.0;
  a2.a2.a0.a3.a1 = 92.0;
  a2.a2.a0.a4 = 93;
  a2.a2.a0.a5.a0.a0 = 94.0;
  a2.a2.a0.a5.a1.a0 = -95.0;
  a2.a2.a0.a6 = 96;
  a2.a2.a1.a0.a0 = -97;
  a2.a2.a1.a0.a1 = 98;
  a2.a2.a1.a1.a0 = -99.0;
  a2.a2.a2 = 100.0;
  a2.a2.a3 = -101.0;
  a2.a3 = 102.0;
  a3.a0 = 103;
  a3.a1.a0.a0 = 104;
  a3.a1.a0.a1.a0.a0 = -105;
  a3.a1.a0.a1.a0.a1 = 106;
  a3.a1.a0.a1.a1.a0 = -107.0;
  a3.a1.a0.a2 = 108;
  a3.a1.a0.a3.a0.a0 = -109.0;
  a3.a1.a0.a3.a1 = 110.0;
  a3.a1.a0.a4 = 111;
  a3.a1.a0.a5.a0.a0 = 112.0;
  a3.a1.a0.a5.a1.a0 = -113.0;
  a3.a1.a0.a6 = 114;
  a3.a1.a1.a0.a0 = -115;
  a3.a1.a1.a0.a1 = 116;
  a3.a1.a1.a1.a0 = -117.0;
  a3.a1.a2 = 118.0;
  a3.a1.a3 = -119.0;
  a3.a2.a0.a0 = 120;
  a3.a2.a0.a1.a0.a0 = -121;
  a3.a2.a0.a1.a0.a1 = 122;
  a3.a2.a0.a1.a1.a0 = -123.0;
  a3.a2.a0.a2 = 124;
  a3.a2.a0.a3.a0.a0 = -125.0;
  a3.a2.a0.a3.a1 = 126.0;
  a3.a2.a0.a4 = 127;
  a3.a2.a0.a5.a0.a0 = 128.0;
  a3.a2.a0.a5.a1.a0 = -129.0;
  a3.a2.a0.a6 = 130;
  a3.a2.a1.a0.a0 = -131;
  a3.a2.a1.a0.a1 = 132;
  a3.a2.a1.a1.a0 = -133.0;
  a3.a2.a2 = 134.0;
  a3.a2.a3 = -135.0;
  a3.a3 = 136.0;

  final result = passStructNestedIrregularEvenBiggerx4Native(a0, a1, a2, a3);

  print("result = $result");

  Expect.approxEquals(1572.0, result);

  calloc.free(a0Pointer);
  calloc.free(a1Pointer);
  calloc.free(a2Pointer);
  calloc.free(a3Pointer);
}

@Native<
    Int32 Function(
        Struct8BytesInlineArrayInt,
        Struct8BytesInlineArrayInt,
        Struct8BytesInlineArrayInt,
        Struct8BytesInlineArrayInt)>(symbol: 'PassStruct8BytesInlineArrayIntx4')
external int passStruct8BytesInlineArrayIntx4Native(
    Struct8BytesInlineArrayInt a0,
    Struct8BytesInlineArrayInt a1,
    Struct8BytesInlineArrayInt a2,
    Struct8BytesInlineArrayInt a3);

/// Simple struct with inline array.
void testPassStruct8BytesInlineArrayIntx4Native() {
  final a0Pointer = calloc<Struct8BytesInlineArrayInt>();
  final Struct8BytesInlineArrayInt a0 = a0Pointer.ref;
  final a1Pointer = calloc<Struct8BytesInlineArrayInt>();
  final Struct8BytesInlineArrayInt a1 = a1Pointer.ref;
  final a2Pointer = calloc<Struct8BytesInlineArrayInt>();
  final Struct8BytesInlineArrayInt a2 = a2Pointer.ref;
  final a3Pointer = calloc<Struct8BytesInlineArrayInt>();
  final Struct8BytesInlineArrayInt a3 = a3Pointer.ref;

  a0.a0[0] = 1;
  a0.a0[1] = 2;
  a0.a0[2] = 3;
  a0.a0[3] = 4;
  a0.a0[4] = 5;
  a0.a0[5] = 6;
  a0.a0[6] = 7;
  a0.a0[7] = 8;
  a1.a0[0] = 9;
  a1.a0[1] = 10;
  a1.a0[2] = 11;
  a1.a0[3] = 12;
  a1.a0[4] = 13;
  a1.a0[5] = 14;
  a1.a0[6] = 15;
  a1.a0[7] = 16;
  a2.a0[0] = 17;
  a2.a0[1] = 18;
  a2.a0[2] = 19;
  a2.a0[3] = 20;
  a2.a0[4] = 21;
  a2.a0[5] = 22;
  a2.a0[6] = 23;
  a2.a0[7] = 24;
  a3.a0[0] = 25;
  a3.a0[1] = 26;
  a3.a0[2] = 27;
  a3.a0[3] = 28;
  a3.a0[4] = 29;
  a3.a0[5] = 30;
  a3.a0[6] = 31;
  a3.a0[7] = 32;

  final result = passStruct8BytesInlineArrayIntx4Native(a0, a1, a2, a3);

  print("result = $result");

  Expect.equals(528, result);

  calloc.free(a0Pointer);
  calloc.free(a1Pointer);
  calloc.free(a2Pointer);
  calloc.free(a3Pointer);
}

@Native<
    Int32 Function(
        StructInlineArrayIrregular,
        StructInlineArrayIrregular,
        StructInlineArrayIrregular,
        StructInlineArrayIrregular)>(symbol: 'PassStructInlineArrayIrregularx4')
external int passStructInlineArrayIrregularx4Native(
    StructInlineArrayIrregular a0,
    StructInlineArrayIrregular a1,
    StructInlineArrayIrregular a2,
    StructInlineArrayIrregular a3);

/// Irregular struct with inline array.
void testPassStructInlineArrayIrregularx4Native() {
  final a0Pointer = calloc<StructInlineArrayIrregular>();
  final StructInlineArrayIrregular a0 = a0Pointer.ref;
  final a1Pointer = calloc<StructInlineArrayIrregular>();
  final StructInlineArrayIrregular a1 = a1Pointer.ref;
  final a2Pointer = calloc<StructInlineArrayIrregular>();
  final StructInlineArrayIrregular a2 = a2Pointer.ref;
  final a3Pointer = calloc<StructInlineArrayIrregular>();
  final StructInlineArrayIrregular a3 = a3Pointer.ref;

  a0.a0[0].a0 = -1;
  a0.a0[0].a1 = 2;
  a0.a0[1].a0 = -3;
  a0.a0[1].a1 = 4;
  a0.a1 = 5;
  a1.a0[0].a0 = 6;
  a1.a0[0].a1 = -7;
  a1.a0[1].a0 = 8;
  a1.a0[1].a1 = -9;
  a1.a1 = 10;
  a2.a0[0].a0 = -11;
  a2.a0[0].a1 = 12;
  a2.a0[1].a0 = -13;
  a2.a0[1].a1 = 14;
  a2.a1 = 15;
  a3.a0[0].a0 = 16;
  a3.a0[0].a1 = -17;
  a3.a0[1].a0 = 18;
  a3.a0[1].a1 = -19;
  a3.a1 = 20;

  final result = passStructInlineArrayIrregularx4Native(a0, a1, a2, a3);

  print("result = $result");

  Expect.equals(50, result);

  calloc.free(a0Pointer);
  calloc.free(a1Pointer);
  calloc.free(a2Pointer);
  calloc.free(a3Pointer);
}

@Native<Int32 Function(StructInlineArray100Bytes)>(
    symbol: 'PassStructInlineArray100Bytes')
external int passStructInlineArray100BytesNative(StructInlineArray100Bytes a0);

/// Regular larger struct with inline array.
void testPassStructInlineArray100BytesNative() {
  final a0Pointer = calloc<StructInlineArray100Bytes>();
  final StructInlineArray100Bytes a0 = a0Pointer.ref;

  a0.a0[0] = 1;
  a0.a0[1] = 2;
  a0.a0[2] = 3;
  a0.a0[3] = 4;
  a0.a0[4] = 5;
  a0.a0[5] = 6;
  a0.a0[6] = 7;
  a0.a0[7] = 8;
  a0.a0[8] = 9;
  a0.a0[9] = 10;
  a0.a0[10] = 11;
  a0.a0[11] = 12;
  a0.a0[12] = 13;
  a0.a0[13] = 14;
  a0.a0[14] = 15;
  a0.a0[15] = 16;
  a0.a0[16] = 17;
  a0.a0[17] = 18;
  a0.a0[18] = 19;
  a0.a0[19] = 20;
  a0.a0[20] = 21;
  a0.a0[21] = 22;
  a0.a0[22] = 23;
  a0.a0[23] = 24;
  a0.a0[24] = 25;
  a0.a0[25] = 26;
  a0.a0[26] = 27;
  a0.a0[27] = 28;
  a0.a0[28] = 29;
  a0.a0[29] = 30;
  a0.a0[30] = 31;
  a0.a0[31] = 32;
  a0.a0[32] = 33;
  a0.a0[33] = 34;
  a0.a0[34] = 35;
  a0.a0[35] = 36;
  a0.a0[36] = 37;
  a0.a0[37] = 38;
  a0.a0[38] = 39;
  a0.a0[39] = 40;
  a0.a0[40] = 41;
  a0.a0[41] = 42;
  a0.a0[42] = 43;
  a0.a0[43] = 44;
  a0.a0[44] = 45;
  a0.a0[45] = 46;
  a0.a0[46] = 47;
  a0.a0[47] = 48;
  a0.a0[48] = 49;
  a0.a0[49] = 50;
  a0.a0[50] = 51;
  a0.a0[51] = 52;
  a0.a0[52] = 53;
  a0.a0[53] = 54;
  a0.a0[54] = 55;
  a0.a0[55] = 56;
  a0.a0[56] = 57;
  a0.a0[57] = 58;
  a0.a0[58] = 59;
  a0.a0[59] = 60;
  a0.a0[60] = 61;
  a0.a0[61] = 62;
  a0.a0[62] = 63;
  a0.a0[63] = 64;
  a0.a0[64] = 65;
  a0.a0[65] = 66;
  a0.a0[66] = 67;
  a0.a0[67] = 68;
  a0.a0[68] = 69;
  a0.a0[69] = 70;
  a0.a0[70] = 71;
  a0.a0[71] = 72;
  a0.a0[72] = 73;
  a0.a0[73] = 74;
  a0.a0[74] = 75;
  a0.a0[75] = 76;
  a0.a0[76] = 77;
  a0.a0[77] = 78;
  a0.a0[78] = 79;
  a0.a0[79] = 80;
  a0.a0[80] = 81;
  a0.a0[81] = 82;
  a0.a0[82] = 83;
  a0.a0[83] = 84;
  a0.a0[84] = 85;
  a0.a0[85] = 86;
  a0.a0[86] = 87;
  a0.a0[87] = 88;
  a0.a0[88] = 89;
  a0.a0[89] = 90;
  a0.a0[90] = 91;
  a0.a0[91] = 92;
  a0.a0[92] = 93;
  a0.a0[93] = 94;
  a0.a0[94] = 95;
  a0.a0[95] = 96;
  a0.a0[96] = 97;
  a0.a0[97] = 98;
  a0.a0[98] = 99;
  a0.a0[99] = 100;

  final result = passStructInlineArray100BytesNative(a0);

  print("result = $result");

  Expect.equals(5050, result);

  calloc.free(a0Pointer);
}

@Native<
        Float Function(
            StructStruct16BytesHomogeneousFloat2,
            StructStruct16BytesHomogeneousFloat2,
            StructStruct16BytesHomogeneousFloat2,
            StructStruct16BytesHomogeneousFloat2,
            StructStruct16BytesHomogeneousFloat2)>(
    symbol: 'PassStructStruct16BytesHomogeneousFloat2x5')
external double passStructStruct16BytesHomogeneousFloat2x5Native(
    StructStruct16BytesHomogeneousFloat2 a0,
    StructStruct16BytesHomogeneousFloat2 a1,
    StructStruct16BytesHomogeneousFloat2 a2,
    StructStruct16BytesHomogeneousFloat2 a3,
    StructStruct16BytesHomogeneousFloat2 a4);

/// Arguments in FPU registers on arm hardfp and arm64.
/// 5 struct arguments will exhaust available registers.
void testPassStructStruct16BytesHomogeneousFloat2x5Native() {
  final a0Pointer = calloc<StructStruct16BytesHomogeneousFloat2>();
  final StructStruct16BytesHomogeneousFloat2 a0 = a0Pointer.ref;
  final a1Pointer = calloc<StructStruct16BytesHomogeneousFloat2>();
  final StructStruct16BytesHomogeneousFloat2 a1 = a1Pointer.ref;
  final a2Pointer = calloc<StructStruct16BytesHomogeneousFloat2>();
  final StructStruct16BytesHomogeneousFloat2 a2 = a2Pointer.ref;
  final a3Pointer = calloc<StructStruct16BytesHomogeneousFloat2>();
  final StructStruct16BytesHomogeneousFloat2 a3 = a3Pointer.ref;
  final a4Pointer = calloc<StructStruct16BytesHomogeneousFloat2>();
  final StructStruct16BytesHomogeneousFloat2 a4 = a4Pointer.ref;

  a0.a0.a0 = -1.0;
  a0.a1[0].a0 = 2.0;
  a0.a1[1].a0 = -3.0;
  a0.a2 = 4.0;
  a1.a0.a0 = -5.0;
  a1.a1[0].a0 = 6.0;
  a1.a1[1].a0 = -7.0;
  a1.a2 = 8.0;
  a2.a0.a0 = -9.0;
  a2.a1[0].a0 = 10.0;
  a2.a1[1].a0 = -11.0;
  a2.a2 = 12.0;
  a3.a0.a0 = -13.0;
  a3.a1[0].a0 = 14.0;
  a3.a1[1].a0 = -15.0;
  a3.a2 = 16.0;
  a4.a0.a0 = -17.0;
  a4.a1[0].a0 = 18.0;
  a4.a1[1].a0 = -19.0;
  a4.a2 = 20.0;

  final result =
      passStructStruct16BytesHomogeneousFloat2x5Native(a0, a1, a2, a3, a4);

  print("result = $result");

  Expect.approxEquals(10.0, result);

  calloc.free(a0Pointer);
  calloc.free(a1Pointer);
  calloc.free(a2Pointer);
  calloc.free(a3Pointer);
  calloc.free(a4Pointer);
}

@Native<
        Double Function(
            StructStruct32BytesHomogeneousDouble2,
            StructStruct32BytesHomogeneousDouble2,
            StructStruct32BytesHomogeneousDouble2,
            StructStruct32BytesHomogeneousDouble2,
            StructStruct32BytesHomogeneousDouble2)>(
    symbol: 'PassStructStruct32BytesHomogeneousDouble2x5')
external double passStructStruct32BytesHomogeneousDouble2x5Native(
    StructStruct32BytesHomogeneousDouble2 a0,
    StructStruct32BytesHomogeneousDouble2 a1,
    StructStruct32BytesHomogeneousDouble2 a2,
    StructStruct32BytesHomogeneousDouble2 a3,
    StructStruct32BytesHomogeneousDouble2 a4);

/// Arguments in FPU registers on arm64.
/// 5 struct arguments will exhaust available registers.
void testPassStructStruct32BytesHomogeneousDouble2x5Native() {
  final a0Pointer = calloc<StructStruct32BytesHomogeneousDouble2>();
  final StructStruct32BytesHomogeneousDouble2 a0 = a0Pointer.ref;
  final a1Pointer = calloc<StructStruct32BytesHomogeneousDouble2>();
  final StructStruct32BytesHomogeneousDouble2 a1 = a1Pointer.ref;
  final a2Pointer = calloc<StructStruct32BytesHomogeneousDouble2>();
  final StructStruct32BytesHomogeneousDouble2 a2 = a2Pointer.ref;
  final a3Pointer = calloc<StructStruct32BytesHomogeneousDouble2>();
  final StructStruct32BytesHomogeneousDouble2 a3 = a3Pointer.ref;
  final a4Pointer = calloc<StructStruct32BytesHomogeneousDouble2>();
  final StructStruct32BytesHomogeneousDouble2 a4 = a4Pointer.ref;

  a0.a0.a0 = -1.0;
  a0.a1[0].a0 = 2.0;
  a0.a1[1].a0 = -3.0;
  a0.a2 = 4.0;
  a1.a0.a0 = -5.0;
  a1.a1[0].a0 = 6.0;
  a1.a1[1].a0 = -7.0;
  a1.a2 = 8.0;
  a2.a0.a0 = -9.0;
  a2.a1[0].a0 = 10.0;
  a2.a1[1].a0 = -11.0;
  a2.a2 = 12.0;
  a3.a0.a0 = -13.0;
  a3.a1[0].a0 = 14.0;
  a3.a1[1].a0 = -15.0;
  a3.a2 = 16.0;
  a4.a0.a0 = -17.0;
  a4.a1[0].a0 = 18.0;
  a4.a1[1].a0 = -19.0;
  a4.a2 = 20.0;

  final result =
      passStructStruct32BytesHomogeneousDouble2x5Native(a0, a1, a2, a3, a4);

  print("result = $result");

  Expect.approxEquals(10.0, result);

  calloc.free(a0Pointer);
  calloc.free(a1Pointer);
  calloc.free(a2Pointer);
  calloc.free(a3Pointer);
  calloc.free(a4Pointer);
}

@Native<
    Float Function(
        StructStruct16BytesMixed3,
        StructStruct16BytesMixed3,
        StructStruct16BytesMixed3,
        StructStruct16BytesMixed3,
        StructStruct16BytesMixed3,
        StructStruct16BytesMixed3,
        StructStruct16BytesMixed3,
        StructStruct16BytesMixed3,
        StructStruct16BytesMixed3,
        StructStruct16BytesMixed3)>(symbol: 'PassStructStruct16BytesMixed3x10')
external double passStructStruct16BytesMixed3x10Native(
    StructStruct16BytesMixed3 a0,
    StructStruct16BytesMixed3 a1,
    StructStruct16BytesMixed3 a2,
    StructStruct16BytesMixed3 a3,
    StructStruct16BytesMixed3 a4,
    StructStruct16BytesMixed3 a5,
    StructStruct16BytesMixed3 a6,
    StructStruct16BytesMixed3 a7,
    StructStruct16BytesMixed3 a8,
    StructStruct16BytesMixed3 a9);

/// On x64, arguments are split over FP and int registers.
/// On x64, it will exhaust the integer registers with the 6th argument.
/// The rest goes on the stack.
/// On arm, arguments are 4 byte aligned.
void testPassStructStruct16BytesMixed3x10Native() {
  final a0Pointer = calloc<StructStruct16BytesMixed3>();
  final StructStruct16BytesMixed3 a0 = a0Pointer.ref;
  final a1Pointer = calloc<StructStruct16BytesMixed3>();
  final StructStruct16BytesMixed3 a1 = a1Pointer.ref;
  final a2Pointer = calloc<StructStruct16BytesMixed3>();
  final StructStruct16BytesMixed3 a2 = a2Pointer.ref;
  final a3Pointer = calloc<StructStruct16BytesMixed3>();
  final StructStruct16BytesMixed3 a3 = a3Pointer.ref;
  final a4Pointer = calloc<StructStruct16BytesMixed3>();
  final StructStruct16BytesMixed3 a4 = a4Pointer.ref;
  final a5Pointer = calloc<StructStruct16BytesMixed3>();
  final StructStruct16BytesMixed3 a5 = a5Pointer.ref;
  final a6Pointer = calloc<StructStruct16BytesMixed3>();
  final StructStruct16BytesMixed3 a6 = a6Pointer.ref;
  final a7Pointer = calloc<StructStruct16BytesMixed3>();
  final StructStruct16BytesMixed3 a7 = a7Pointer.ref;
  final a8Pointer = calloc<StructStruct16BytesMixed3>();
  final StructStruct16BytesMixed3 a8 = a8Pointer.ref;
  final a9Pointer = calloc<StructStruct16BytesMixed3>();
  final StructStruct16BytesMixed3 a9 = a9Pointer.ref;

  a0.a0.a0 = -1.0;
  a0.a1[0].a0 = 2.0;
  a0.a1[0].a1 = -3;
  a0.a1[0].a2 = 4;
  a0.a2[0] = -5;
  a0.a2[1] = 6;
  a1.a0.a0 = -7.0;
  a1.a1[0].a0 = 8.0;
  a1.a1[0].a1 = -9;
  a1.a1[0].a2 = 10;
  a1.a2[0] = -11;
  a1.a2[1] = 12;
  a2.a0.a0 = -13.0;
  a2.a1[0].a0 = 14.0;
  a2.a1[0].a1 = -15;
  a2.a1[0].a2 = 16;
  a2.a2[0] = -17;
  a2.a2[1] = 18;
  a3.a0.a0 = -19.0;
  a3.a1[0].a0 = 20.0;
  a3.a1[0].a1 = -21;
  a3.a1[0].a2 = 22;
  a3.a2[0] = -23;
  a3.a2[1] = 24;
  a4.a0.a0 = -25.0;
  a4.a1[0].a0 = 26.0;
  a4.a1[0].a1 = -27;
  a4.a1[0].a2 = 28;
  a4.a2[0] = -29;
  a4.a2[1] = 30;
  a5.a0.a0 = -31.0;
  a5.a1[0].a0 = 32.0;
  a5.a1[0].a1 = -33;
  a5.a1[0].a2 = 34;
  a5.a2[0] = -35;
  a5.a2[1] = 36;
  a6.a0.a0 = -37.0;
  a6.a1[0].a0 = 38.0;
  a6.a1[0].a1 = -39;
  a6.a1[0].a2 = 40;
  a6.a2[0] = -41;
  a6.a2[1] = 42;
  a7.a0.a0 = -43.0;
  a7.a1[0].a0 = 44.0;
  a7.a1[0].a1 = -45;
  a7.a1[0].a2 = 46;
  a7.a2[0] = -47;
  a7.a2[1] = 48;
  a8.a0.a0 = -49.0;
  a8.a1[0].a0 = 50.0;
  a8.a1[0].a1 = -51;
  a8.a1[0].a2 = 52;
  a8.a2[0] = -53;
  a8.a2[1] = 54;
  a9.a0.a0 = -55.0;
  a9.a1[0].a0 = 56.0;
  a9.a1[0].a1 = -57;
  a9.a1[0].a2 = 58;
  a9.a2[0] = -59;
  a9.a2[1] = 60;

  final result = passStructStruct16BytesMixed3x10Native(
      a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);

  print("result = $result");

  Expect.approxEquals(30.0, result);

  calloc.free(a0Pointer);
  calloc.free(a1Pointer);
  calloc.free(a2Pointer);
  calloc.free(a3Pointer);
  calloc.free(a4Pointer);
  calloc.free(a5Pointer);
  calloc.free(a6Pointer);
  calloc.free(a7Pointer);
  calloc.free(a8Pointer);
  calloc.free(a9Pointer);
}

@Native<
    Uint32 Function(
        Uint8,
        Struct32BytesInlineArrayMultiDimensionalInt,
        Uint8,
        Struct8BytesInlineArrayMultiDimensionalInt,
        Uint8,
        Struct8BytesInlineArrayMultiDimensionalInt,
        Uint8)>(symbol: 'PassUint8Struct32BytesInlineArrayMultiDimensionalI')
external int passUint8Struct32BytesInlineArrayMultiDimensionalINative(
    int a0,
    Struct32BytesInlineArrayMultiDimensionalInt a1,
    int a2,
    Struct8BytesInlineArrayMultiDimensionalInt a3,
    int a4,
    Struct8BytesInlineArrayMultiDimensionalInt a5,
    int a6);

/// Test multi dimensional inline array struct as argument.
void testPassUint8Struct32BytesInlineArrayMultiDimensionalINative() {
  int a0;
  final a1Pointer = calloc<Struct32BytesInlineArrayMultiDimensionalInt>();
  final Struct32BytesInlineArrayMultiDimensionalInt a1 = a1Pointer.ref;
  int a2;
  final a3Pointer = calloc<Struct8BytesInlineArrayMultiDimensionalInt>();
  final Struct8BytesInlineArrayMultiDimensionalInt a3 = a3Pointer.ref;
  int a4;
  final a5Pointer = calloc<Struct8BytesInlineArrayMultiDimensionalInt>();
  final Struct8BytesInlineArrayMultiDimensionalInt a5 = a5Pointer.ref;
  int a6;

  a0 = 1;
  a1.a0[0][0][0][0][0] = 2;
  a1.a0[0][0][0][0][1] = 3;
  a1.a0[0][0][0][1][0] = 4;
  a1.a0[0][0][0][1][1] = 5;
  a1.a0[0][0][1][0][0] = 6;
  a1.a0[0][0][1][0][1] = 7;
  a1.a0[0][0][1][1][0] = 8;
  a1.a0[0][0][1][1][1] = 9;
  a1.a0[0][1][0][0][0] = 10;
  a1.a0[0][1][0][0][1] = 11;
  a1.a0[0][1][0][1][0] = 12;
  a1.a0[0][1][0][1][1] = 13;
  a1.a0[0][1][1][0][0] = 14;
  a1.a0[0][1][1][0][1] = 15;
  a1.a0[0][1][1][1][0] = 16;
  a1.a0[0][1][1][1][1] = 17;
  a1.a0[1][0][0][0][0] = 18;
  a1.a0[1][0][0][0][1] = 19;
  a1.a0[1][0][0][1][0] = 20;
  a1.a0[1][0][0][1][1] = 21;
  a1.a0[1][0][1][0][0] = 22;
  a1.a0[1][0][1][0][1] = 23;
  a1.a0[1][0][1][1][0] = 24;
  a1.a0[1][0][1][1][1] = 25;
  a1.a0[1][1][0][0][0] = 26;
  a1.a0[1][1][0][0][1] = 27;
  a1.a0[1][1][0][1][0] = 28;
  a1.a0[1][1][0][1][1] = 29;
  a1.a0[1][1][1][0][0] = 30;
  a1.a0[1][1][1][0][1] = 31;
  a1.a0[1][1][1][1][0] = 32;
  a1.a0[1][1][1][1][1] = 33;
  a2 = 34;
  a3.a0[0][0][0] = 35;
  a3.a0[0][0][1] = 36;
  a3.a0[0][1][0] = 37;
  a3.a0[0][1][1] = 38;
  a3.a0[1][0][0] = 39;
  a3.a0[1][0][1] = 40;
  a3.a0[1][1][0] = 41;
  a3.a0[1][1][1] = 42;
  a4 = 43;
  a5.a0[0][0][0] = 44;
  a5.a0[0][0][1] = 45;
  a5.a0[0][1][0] = 46;
  a5.a0[0][1][1] = 47;
  a5.a0[1][0][0] = 48;
  a5.a0[1][0][1] = 49;
  a5.a0[1][1][0] = 50;
  a5.a0[1][1][1] = 51;
  a6 = 52;

  final result = passUint8Struct32BytesInlineArrayMultiDimensionalINative(
      a0, a1, a2, a3, a4, a5, a6);

  print("result = $result");

  Expect.equals(1378, result);

  calloc.free(a1Pointer);
  calloc.free(a3Pointer);
  calloc.free(a5Pointer);
}

@Native<
    Uint32 Function(Uint8, Struct4BytesInlineArrayMultiDimensionalInt,
        Uint8)>(symbol: 'PassUint8Struct4BytesInlineArrayMultiDimensionalIn')
external int passUint8Struct4BytesInlineArrayMultiDimensionalInNative(
    int a0, Struct4BytesInlineArrayMultiDimensionalInt a1, int a2);

/// Test struct in multi dimensional inline array.
void testPassUint8Struct4BytesInlineArrayMultiDimensionalInNative() {
  int a0;
  final a1Pointer = calloc<Struct4BytesInlineArrayMultiDimensionalInt>();
  final Struct4BytesInlineArrayMultiDimensionalInt a1 = a1Pointer.ref;
  int a2;

  a0 = 1;
  a1.a0[0][0].a0 = 2;
  a1.a0[0][1].a0 = -3;
  a1.a0[1][0].a0 = 4;
  a1.a0[1][1].a0 = -5;
  a2 = 6;

  final result =
      passUint8Struct4BytesInlineArrayMultiDimensionalInNative(a0, a1, a2);

  print("result = $result");

  Expect.equals(5, result);

  calloc.free(a1Pointer);
}

@Native<
    Int64 Function(
        Struct3BytesPackedInt,
        Struct3BytesPackedInt,
        Struct3BytesPackedInt,
        Struct3BytesPackedInt,
        Struct3BytesPackedInt,
        Struct3BytesPackedInt,
        Struct3BytesPackedInt,
        Struct3BytesPackedInt,
        Struct3BytesPackedInt,
        Struct3BytesPackedInt)>(symbol: 'PassStruct3BytesPackedIntx10')
external int passStruct3BytesPackedIntx10Native(
    Struct3BytesPackedInt a0,
    Struct3BytesPackedInt a1,
    Struct3BytesPackedInt a2,
    Struct3BytesPackedInt a3,
    Struct3BytesPackedInt a4,
    Struct3BytesPackedInt a5,
    Struct3BytesPackedInt a6,
    Struct3BytesPackedInt a7,
    Struct3BytesPackedInt a8,
    Struct3BytesPackedInt a9);

/// Small struct with mis-aligned member.
void testPassStruct3BytesPackedIntx10Native() {
  final a0Pointer = calloc<Struct3BytesPackedInt>();
  final Struct3BytesPackedInt a0 = a0Pointer.ref;
  final a1Pointer = calloc<Struct3BytesPackedInt>();
  final Struct3BytesPackedInt a1 = a1Pointer.ref;
  final a2Pointer = calloc<Struct3BytesPackedInt>();
  final Struct3BytesPackedInt a2 = a2Pointer.ref;
  final a3Pointer = calloc<Struct3BytesPackedInt>();
  final Struct3BytesPackedInt a3 = a3Pointer.ref;
  final a4Pointer = calloc<Struct3BytesPackedInt>();
  final Struct3BytesPackedInt a4 = a4Pointer.ref;
  final a5Pointer = calloc<Struct3BytesPackedInt>();
  final Struct3BytesPackedInt a5 = a5Pointer.ref;
  final a6Pointer = calloc<Struct3BytesPackedInt>();
  final Struct3BytesPackedInt a6 = a6Pointer.ref;
  final a7Pointer = calloc<Struct3BytesPackedInt>();
  final Struct3BytesPackedInt a7 = a7Pointer.ref;
  final a8Pointer = calloc<Struct3BytesPackedInt>();
  final Struct3BytesPackedInt a8 = a8Pointer.ref;
  final a9Pointer = calloc<Struct3BytesPackedInt>();
  final Struct3BytesPackedInt a9 = a9Pointer.ref;

  a0.a0 = -1;
  a0.a1 = 2;
  a1.a0 = -3;
  a1.a1 = 4;
  a2.a0 = -5;
  a2.a1 = 6;
  a3.a0 = -7;
  a3.a1 = 8;
  a4.a0 = -9;
  a4.a1 = 10;
  a5.a0 = -11;
  a5.a1 = 12;
  a6.a0 = -13;
  a6.a1 = 14;
  a7.a0 = -15;
  a7.a1 = 16;
  a8.a0 = -17;
  a8.a1 = 18;
  a9.a0 = -19;
  a9.a1 = 20;

  final result = passStruct3BytesPackedIntx10Native(
      a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);

  print("result = $result");

  Expect.equals(10, result);

  calloc.free(a0Pointer);
  calloc.free(a1Pointer);
  calloc.free(a2Pointer);
  calloc.free(a3Pointer);
  calloc.free(a4Pointer);
  calloc.free(a5Pointer);
  calloc.free(a6Pointer);
  calloc.free(a7Pointer);
  calloc.free(a8Pointer);
  calloc.free(a9Pointer);
}

@Native<
    Int64 Function(
        Struct8BytesPackedInt,
        Struct8BytesPackedInt,
        Struct8BytesPackedInt,
        Struct8BytesPackedInt,
        Struct8BytesPackedInt,
        Struct8BytesPackedInt,
        Struct8BytesPackedInt,
        Struct8BytesPackedInt,
        Struct8BytesPackedInt,
        Struct8BytesPackedInt)>(symbol: 'PassStruct8BytesPackedIntx10')
external int passStruct8BytesPackedIntx10Native(
    Struct8BytesPackedInt a0,
    Struct8BytesPackedInt a1,
    Struct8BytesPackedInt a2,
    Struct8BytesPackedInt a3,
    Struct8BytesPackedInt a4,
    Struct8BytesPackedInt a5,
    Struct8BytesPackedInt a6,
    Struct8BytesPackedInt a7,
    Struct8BytesPackedInt a8,
    Struct8BytesPackedInt a9);

/// Struct with mis-aligned member.
void testPassStruct8BytesPackedIntx10Native() {
  final a0Pointer = calloc<Struct8BytesPackedInt>();
  final Struct8BytesPackedInt a0 = a0Pointer.ref;
  final a1Pointer = calloc<Struct8BytesPackedInt>();
  final Struct8BytesPackedInt a1 = a1Pointer.ref;
  final a2Pointer = calloc<Struct8BytesPackedInt>();
  final Struct8BytesPackedInt a2 = a2Pointer.ref;
  final a3Pointer = calloc<Struct8BytesPackedInt>();
  final Struct8BytesPackedInt a3 = a3Pointer.ref;
  final a4Pointer = calloc<Struct8BytesPackedInt>();
  final Struct8BytesPackedInt a4 = a4Pointer.ref;
  final a5Pointer = calloc<Struct8BytesPackedInt>();
  final Struct8BytesPackedInt a5 = a5Pointer.ref;
  final a6Pointer = calloc<Struct8BytesPackedInt>();
  final Struct8BytesPackedInt a6 = a6Pointer.ref;
  final a7Pointer = calloc<Struct8BytesPackedInt>();
  final Struct8BytesPackedInt a7 = a7Pointer.ref;
  final a8Pointer = calloc<Struct8BytesPackedInt>();
  final Struct8BytesPackedInt a8 = a8Pointer.ref;
  final a9Pointer = calloc<Struct8BytesPackedInt>();
  final Struct8BytesPackedInt a9 = a9Pointer.ref;

  a0.a0 = 1;
  a0.a1 = 2;
  a0.a2 = 3;
  a0.a3 = 4;
  a0.a4 = 5;
  a1.a0 = 6;
  a1.a1 = 7;
  a1.a2 = 8;
  a1.a3 = 9;
  a1.a4 = 10;
  a2.a0 = 11;
  a2.a1 = 12;
  a2.a2 = 13;
  a2.a3 = 14;
  a2.a4 = 15;
  a3.a0 = 16;
  a3.a1 = 17;
  a3.a2 = 18;
  a3.a3 = 19;
  a3.a4 = 20;
  a4.a0 = 21;
  a4.a1 = 22;
  a4.a2 = 23;
  a4.a3 = 24;
  a4.a4 = 25;
  a5.a0 = 26;
  a5.a1 = 27;
  a5.a2 = 28;
  a5.a3 = 29;
  a5.a4 = 30;
  a6.a0 = 31;
  a6.a1 = 32;
  a6.a2 = 33;
  a6.a3 = 34;
  a6.a4 = 35;
  a7.a0 = 36;
  a7.a1 = 37;
  a7.a2 = 38;
  a7.a3 = 39;
  a7.a4 = 40;
  a8.a0 = 41;
  a8.a1 = 42;
  a8.a2 = 43;
  a8.a3 = 44;
  a8.a4 = 45;
  a9.a0 = 46;
  a9.a1 = 47;
  a9.a2 = 48;
  a9.a3 = 49;
  a9.a4 = 50;

  final result = passStruct8BytesPackedIntx10Native(
      a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);

  print("result = $result");

  Expect.equals(1275, result);

  calloc.free(a0Pointer);
  calloc.free(a1Pointer);
  calloc.free(a2Pointer);
  calloc.free(a3Pointer);
  calloc.free(a4Pointer);
  calloc.free(a5Pointer);
  calloc.free(a6Pointer);
  calloc.free(a7Pointer);
  calloc.free(a8Pointer);
  calloc.free(a9Pointer);
}

@Native<
    Double Function(
        Struct9BytesPackedMixed,
        Struct9BytesPackedMixed,
        Struct9BytesPackedMixed,
        Struct9BytesPackedMixed,
        Struct9BytesPackedMixed,
        Struct9BytesPackedMixed,
        Struct9BytesPackedMixed,
        Struct9BytesPackedMixed,
        Struct9BytesPackedMixed,
        Struct9BytesPackedMixed,
        Double,
        Int32,
        Int32)>(symbol: 'PassStruct9BytesPackedMixedx10DoubleInt32x2')
external double passStruct9BytesPackedMixedx10DoubleInt32x2Native(
    Struct9BytesPackedMixed a0,
    Struct9BytesPackedMixed a1,
    Struct9BytesPackedMixed a2,
    Struct9BytesPackedMixed a3,
    Struct9BytesPackedMixed a4,
    Struct9BytesPackedMixed a5,
    Struct9BytesPackedMixed a6,
    Struct9BytesPackedMixed a7,
    Struct9BytesPackedMixed a8,
    Struct9BytesPackedMixed a9,
    double a10,
    int a11,
    int a12);

/// Struct with mis-aligned member.
/// Tests backfilling of CPU and FPU registers.
void testPassStruct9BytesPackedMixedx10DoubleInt32x2Native() {
  final a0Pointer = calloc<Struct9BytesPackedMixed>();
  final Struct9BytesPackedMixed a0 = a0Pointer.ref;
  final a1Pointer = calloc<Struct9BytesPackedMixed>();
  final Struct9BytesPackedMixed a1 = a1Pointer.ref;
  final a2Pointer = calloc<Struct9BytesPackedMixed>();
  final Struct9BytesPackedMixed a2 = a2Pointer.ref;
  final a3Pointer = calloc<Struct9BytesPackedMixed>();
  final Struct9BytesPackedMixed a3 = a3Pointer.ref;
  final a4Pointer = calloc<Struct9BytesPackedMixed>();
  final Struct9BytesPackedMixed a4 = a4Pointer.ref;
  final a5Pointer = calloc<Struct9BytesPackedMixed>();
  final Struct9BytesPackedMixed a5 = a5Pointer.ref;
  final a6Pointer = calloc<Struct9BytesPackedMixed>();
  final Struct9BytesPackedMixed a6 = a6Pointer.ref;
  final a7Pointer = calloc<Struct9BytesPackedMixed>();
  final Struct9BytesPackedMixed a7 = a7Pointer.ref;
  final a8Pointer = calloc<Struct9BytesPackedMixed>();
  final Struct9BytesPackedMixed a8 = a8Pointer.ref;
  final a9Pointer = calloc<Struct9BytesPackedMixed>();
  final Struct9BytesPackedMixed a9 = a9Pointer.ref;
  double a10;
  int a11;
  int a12;

  a0.a0 = 1;
  a0.a1 = 2.0;
  a1.a0 = 3;
  a1.a1 = 4.0;
  a2.a0 = 5;
  a2.a1 = 6.0;
  a3.a0 = 7;
  a3.a1 = 8.0;
  a4.a0 = 9;
  a4.a1 = 10.0;
  a5.a0 = 11;
  a5.a1 = 12.0;
  a6.a0 = 13;
  a6.a1 = 14.0;
  a7.a0 = 15;
  a7.a1 = 16.0;
  a8.a0 = 17;
  a8.a1 = 18.0;
  a9.a0 = 19;
  a9.a1 = 20.0;
  a10 = -21.0;
  a11 = 22;
  a12 = -23;

  final result = passStruct9BytesPackedMixedx10DoubleInt32x2Native(
      a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12);

  print("result = $result");

  Expect.approxEquals(188.0, result);

  calloc.free(a0Pointer);
  calloc.free(a1Pointer);
  calloc.free(a2Pointer);
  calloc.free(a3Pointer);
  calloc.free(a4Pointer);
  calloc.free(a5Pointer);
  calloc.free(a6Pointer);
  calloc.free(a7Pointer);
  calloc.free(a8Pointer);
  calloc.free(a9Pointer);
}

@Native<Double Function(Struct5BytesPackedMixed)>(
    symbol: 'PassStruct5BytesPackedMixed')
external double passStruct5BytesPackedMixedNative(Struct5BytesPackedMixed a0);

/// This packed struct happens to have only aligned members.
void testPassStruct5BytesPackedMixedNative() {
  final a0Pointer = calloc<Struct5BytesPackedMixed>();
  final Struct5BytesPackedMixed a0 = a0Pointer.ref;

  a0.a0 = -1.0;
  a0.a1 = 2;

  final result = passStruct5BytesPackedMixedNative(a0);

  print("result = $result");

  Expect.approxEquals(1.0, result);

  calloc.free(a0Pointer);
}

@Native<Double Function(StructNestedAlignmentStruct5BytesPackedMixed)>(
    symbol: 'PassStructNestedAlignmentStruct5BytesPackedMixed')
external double passStructNestedAlignmentStruct5BytesPackedMixedNative(
    StructNestedAlignmentStruct5BytesPackedMixed a0);

/// Check alignment of packed struct in non-packed struct.
void testPassStructNestedAlignmentStruct5BytesPackedMixedNative() {
  final a0Pointer = calloc<StructNestedAlignmentStruct5BytesPackedMixed>();
  final StructNestedAlignmentStruct5BytesPackedMixed a0 = a0Pointer.ref;

  a0.a0 = 1;
  a0.a1.a0 = 2.0;
  a0.a1.a1 = 3;

  final result = passStructNestedAlignmentStruct5BytesPackedMixedNative(a0);

  print("result = $result");

  Expect.approxEquals(6.0, result);

  calloc.free(a0Pointer);
}

@Native<Double Function(Struct6BytesInlineArrayInt)>(
    symbol: 'PassStruct6BytesInlineArrayInt')
external double passStruct6BytesInlineArrayIntNative(
    Struct6BytesInlineArrayInt a0);

/// Check alignment of packed struct array in non-packed struct.
void testPassStruct6BytesInlineArrayIntNative() {
  final a0Pointer = calloc<Struct6BytesInlineArrayInt>();
  final Struct6BytesInlineArrayInt a0 = a0Pointer.ref;

  a0.a0[0].a0 = -1;
  a0.a0[0].a1 = 2;
  a0.a0[1].a0 = -3;
  a0.a0[1].a1 = 4;

  final result = passStruct6BytesInlineArrayIntNative(a0);

  print("result = $result");

  Expect.approxEquals(2.0, result);

  calloc.free(a0Pointer);
}

@Native<Double Function(Struct15BytesInlineArrayMixed)>(
    symbol: 'PassStruct15BytesInlineArrayMixed')
external double passStruct15BytesInlineArrayMixedNative(
    Struct15BytesInlineArrayMixed a0);

/// Check alignment of packed struct array in non-packed struct.
void testPassStruct15BytesInlineArrayMixedNative() {
  final a0Pointer = calloc<Struct15BytesInlineArrayMixed>();
  final Struct15BytesInlineArrayMixed a0 = a0Pointer.ref;

  a0.a0[0].a0 = -1.0;
  a0.a0[0].a1 = 2;
  a0.a0[1].a0 = -3.0;
  a0.a0[1].a1 = 4;
  a0.a0[2].a0 = -5.0;
  a0.a0[2].a1 = 6;

  final result = passStruct15BytesInlineArrayMixedNative(a0);

  print("result = $result");

  Expect.approxEquals(3.0, result);

  calloc.free(a0Pointer);
}

@Native<
    Double Function(
        Union4BytesMixed,
        Union4BytesMixed,
        Union4BytesMixed,
        Union4BytesMixed,
        Union4BytesMixed,
        Union4BytesMixed,
        Union4BytesMixed,
        Union4BytesMixed,
        Union4BytesMixed,
        Union4BytesMixed)>(symbol: 'PassUnion4BytesMixedx10')
external double passUnion4BytesMixedx10Native(
    Union4BytesMixed a0,
    Union4BytesMixed a1,
    Union4BytesMixed a2,
    Union4BytesMixed a3,
    Union4BytesMixed a4,
    Union4BytesMixed a5,
    Union4BytesMixed a6,
    Union4BytesMixed a7,
    Union4BytesMixed a8,
    Union4BytesMixed a9);

/// Check placement of mixed integer/float union.
void testPassUnion4BytesMixedx10Native() {
  final a0Pointer = calloc<Union4BytesMixed>();
  final Union4BytesMixed a0 = a0Pointer.ref;
  final a1Pointer = calloc<Union4BytesMixed>();
  final Union4BytesMixed a1 = a1Pointer.ref;
  final a2Pointer = calloc<Union4BytesMixed>();
  final Union4BytesMixed a2 = a2Pointer.ref;
  final a3Pointer = calloc<Union4BytesMixed>();
  final Union4BytesMixed a3 = a3Pointer.ref;
  final a4Pointer = calloc<Union4BytesMixed>();
  final Union4BytesMixed a4 = a4Pointer.ref;
  final a5Pointer = calloc<Union4BytesMixed>();
  final Union4BytesMixed a5 = a5Pointer.ref;
  final a6Pointer = calloc<Union4BytesMixed>();
  final Union4BytesMixed a6 = a6Pointer.ref;
  final a7Pointer = calloc<Union4BytesMixed>();
  final Union4BytesMixed a7 = a7Pointer.ref;
  final a8Pointer = calloc<Union4BytesMixed>();
  final Union4BytesMixed a8 = a8Pointer.ref;
  final a9Pointer = calloc<Union4BytesMixed>();
  final Union4BytesMixed a9 = a9Pointer.ref;

  a0.a0 = 1;
  a1.a0 = 2;
  a2.a0 = 3;
  a3.a0 = 4;
  a4.a0 = 5;
  a5.a0 = 6;
  a6.a0 = 7;
  a7.a0 = 8;
  a8.a0 = 9;
  a9.a0 = 10;

  final result =
      passUnion4BytesMixedx10Native(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);

  print("result = $result");

  Expect.approxEquals(55.0, result);

  calloc.free(a0Pointer);
  calloc.free(a1Pointer);
  calloc.free(a2Pointer);
  calloc.free(a3Pointer);
  calloc.free(a4Pointer);
  calloc.free(a5Pointer);
  calloc.free(a6Pointer);
  calloc.free(a7Pointer);
  calloc.free(a8Pointer);
  calloc.free(a9Pointer);
}

@Native<
    Double Function(
        Union8BytesNestedFloat,
        Union8BytesNestedFloat,
        Union8BytesNestedFloat,
        Union8BytesNestedFloat,
        Union8BytesNestedFloat,
        Union8BytesNestedFloat,
        Union8BytesNestedFloat,
        Union8BytesNestedFloat,
        Union8BytesNestedFloat,
        Union8BytesNestedFloat)>(symbol: 'PassUnion8BytesNestedFloatx10')
external double passUnion8BytesNestedFloatx10Native(
    Union8BytesNestedFloat a0,
    Union8BytesNestedFloat a1,
    Union8BytesNestedFloat a2,
    Union8BytesNestedFloat a3,
    Union8BytesNestedFloat a4,
    Union8BytesNestedFloat a5,
    Union8BytesNestedFloat a6,
    Union8BytesNestedFloat a7,
    Union8BytesNestedFloat a8,
    Union8BytesNestedFloat a9);

/// Check placement of mixed floats union.
void testPassUnion8BytesNestedFloatx10Native() {
  final a0Pointer = calloc<Union8BytesNestedFloat>();
  final Union8BytesNestedFloat a0 = a0Pointer.ref;
  final a1Pointer = calloc<Union8BytesNestedFloat>();
  final Union8BytesNestedFloat a1 = a1Pointer.ref;
  final a2Pointer = calloc<Union8BytesNestedFloat>();
  final Union8BytesNestedFloat a2 = a2Pointer.ref;
  final a3Pointer = calloc<Union8BytesNestedFloat>();
  final Union8BytesNestedFloat a3 = a3Pointer.ref;
  final a4Pointer = calloc<Union8BytesNestedFloat>();
  final Union8BytesNestedFloat a4 = a4Pointer.ref;
  final a5Pointer = calloc<Union8BytesNestedFloat>();
  final Union8BytesNestedFloat a5 = a5Pointer.ref;
  final a6Pointer = calloc<Union8BytesNestedFloat>();
  final Union8BytesNestedFloat a6 = a6Pointer.ref;
  final a7Pointer = calloc<Union8BytesNestedFloat>();
  final Union8BytesNestedFloat a7 = a7Pointer.ref;
  final a8Pointer = calloc<Union8BytesNestedFloat>();
  final Union8BytesNestedFloat a8 = a8Pointer.ref;
  final a9Pointer = calloc<Union8BytesNestedFloat>();
  final Union8BytesNestedFloat a9 = a9Pointer.ref;

  a0.a0 = -1.0;
  a1.a0 = 2.0;
  a2.a0 = -3.0;
  a3.a0 = 4.0;
  a4.a0 = -5.0;
  a5.a0 = 6.0;
  a6.a0 = -7.0;
  a7.a0 = 8.0;
  a8.a0 = -9.0;
  a9.a0 = 10.0;

  final result = passUnion8BytesNestedFloatx10Native(
      a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);

  print("result = $result");

  Expect.approxEquals(5.0, result);

  calloc.free(a0Pointer);
  calloc.free(a1Pointer);
  calloc.free(a2Pointer);
  calloc.free(a3Pointer);
  calloc.free(a4Pointer);
  calloc.free(a5Pointer);
  calloc.free(a6Pointer);
  calloc.free(a7Pointer);
  calloc.free(a8Pointer);
  calloc.free(a9Pointer);
}

@Native<
    Double Function(
        Union9BytesNestedInt,
        Union9BytesNestedInt,
        Union9BytesNestedInt,
        Union9BytesNestedInt,
        Union9BytesNestedInt,
        Union9BytesNestedInt,
        Union9BytesNestedInt,
        Union9BytesNestedInt,
        Union9BytesNestedInt,
        Union9BytesNestedInt)>(symbol: 'PassUnion9BytesNestedIntx10')
external double passUnion9BytesNestedIntx10Native(
    Union9BytesNestedInt a0,
    Union9BytesNestedInt a1,
    Union9BytesNestedInt a2,
    Union9BytesNestedInt a3,
    Union9BytesNestedInt a4,
    Union9BytesNestedInt a5,
    Union9BytesNestedInt a6,
    Union9BytesNestedInt a7,
    Union9BytesNestedInt a8,
    Union9BytesNestedInt a9);

/// Mixed-size union argument.
void testPassUnion9BytesNestedIntx10Native() {
  final a0Pointer = calloc<Union9BytesNestedInt>();
  final Union9BytesNestedInt a0 = a0Pointer.ref;
  final a1Pointer = calloc<Union9BytesNestedInt>();
  final Union9BytesNestedInt a1 = a1Pointer.ref;
  final a2Pointer = calloc<Union9BytesNestedInt>();
  final Union9BytesNestedInt a2 = a2Pointer.ref;
  final a3Pointer = calloc<Union9BytesNestedInt>();
  final Union9BytesNestedInt a3 = a3Pointer.ref;
  final a4Pointer = calloc<Union9BytesNestedInt>();
  final Union9BytesNestedInt a4 = a4Pointer.ref;
  final a5Pointer = calloc<Union9BytesNestedInt>();
  final Union9BytesNestedInt a5 = a5Pointer.ref;
  final a6Pointer = calloc<Union9BytesNestedInt>();
  final Union9BytesNestedInt a6 = a6Pointer.ref;
  final a7Pointer = calloc<Union9BytesNestedInt>();
  final Union9BytesNestedInt a7 = a7Pointer.ref;
  final a8Pointer = calloc<Union9BytesNestedInt>();
  final Union9BytesNestedInt a8 = a8Pointer.ref;
  final a9Pointer = calloc<Union9BytesNestedInt>();
  final Union9BytesNestedInt a9 = a9Pointer.ref;

  a0.a0.a0 = -1;
  a0.a0.a1 = 2;
  a0.a0.a2 = -3;
  a1.a0.a0 = 4;
  a1.a0.a1 = -5;
  a1.a0.a2 = 6;
  a2.a0.a0 = -7;
  a2.a0.a1 = 8;
  a2.a0.a2 = -9;
  a3.a0.a0 = 10;
  a3.a0.a1 = -11;
  a3.a0.a2 = 12;
  a4.a0.a0 = -13;
  a4.a0.a1 = 14;
  a4.a0.a2 = -15;
  a5.a0.a0 = 16;
  a5.a0.a1 = -17;
  a5.a0.a2 = 18;
  a6.a0.a0 = -19;
  a6.a0.a1 = 20;
  a6.a0.a2 = -21;
  a7.a0.a0 = 22;
  a7.a0.a1 = -23;
  a7.a0.a2 = 24;
  a8.a0.a0 = -25;
  a8.a0.a1 = 26;
  a8.a0.a2 = -27;
  a9.a0.a0 = 28;
  a9.a0.a1 = -29;
  a9.a0.a2 = 30;

  final result =
      passUnion9BytesNestedIntx10Native(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);

  print("result = $result");

  Expect.approxEquals(15.0, result);

  calloc.free(a0Pointer);
  calloc.free(a1Pointer);
  calloc.free(a2Pointer);
  calloc.free(a3Pointer);
  calloc.free(a4Pointer);
  calloc.free(a5Pointer);
  calloc.free(a6Pointer);
  calloc.free(a7Pointer);
  calloc.free(a8Pointer);
  calloc.free(a9Pointer);
}

@Native<
        Double Function(
            Union16BytesNestedInlineArrayFloat,
            Union16BytesNestedInlineArrayFloat,
            Union16BytesNestedInlineArrayFloat,
            Union16BytesNestedInlineArrayFloat,
            Union16BytesNestedInlineArrayFloat,
            Union16BytesNestedInlineArrayFloat,
            Union16BytesNestedInlineArrayFloat,
            Union16BytesNestedInlineArrayFloat,
            Union16BytesNestedInlineArrayFloat,
            Union16BytesNestedInlineArrayFloat)>(
    symbol: 'PassUnion16BytesNestedInlineArrayFloatx10')
external double passUnion16BytesNestedInlineArrayFloatx10Native(
    Union16BytesNestedInlineArrayFloat a0,
    Union16BytesNestedInlineArrayFloat a1,
    Union16BytesNestedInlineArrayFloat a2,
    Union16BytesNestedInlineArrayFloat a3,
    Union16BytesNestedInlineArrayFloat a4,
    Union16BytesNestedInlineArrayFloat a5,
    Union16BytesNestedInlineArrayFloat a6,
    Union16BytesNestedInlineArrayFloat a7,
    Union16BytesNestedInlineArrayFloat a8,
    Union16BytesNestedInlineArrayFloat a9);

/// Union with homogenous floats.
void testPassUnion16BytesNestedInlineArrayFloatx10Native() {
  final a0Pointer = calloc<Union16BytesNestedInlineArrayFloat>();
  final Union16BytesNestedInlineArrayFloat a0 = a0Pointer.ref;
  final a1Pointer = calloc<Union16BytesNestedInlineArrayFloat>();
  final Union16BytesNestedInlineArrayFloat a1 = a1Pointer.ref;
  final a2Pointer = calloc<Union16BytesNestedInlineArrayFloat>();
  final Union16BytesNestedInlineArrayFloat a2 = a2Pointer.ref;
  final a3Pointer = calloc<Union16BytesNestedInlineArrayFloat>();
  final Union16BytesNestedInlineArrayFloat a3 = a3Pointer.ref;
  final a4Pointer = calloc<Union16BytesNestedInlineArrayFloat>();
  final Union16BytesNestedInlineArrayFloat a4 = a4Pointer.ref;
  final a5Pointer = calloc<Union16BytesNestedInlineArrayFloat>();
  final Union16BytesNestedInlineArrayFloat a5 = a5Pointer.ref;
  final a6Pointer = calloc<Union16BytesNestedInlineArrayFloat>();
  final Union16BytesNestedInlineArrayFloat a6 = a6Pointer.ref;
  final a7Pointer = calloc<Union16BytesNestedInlineArrayFloat>();
  final Union16BytesNestedInlineArrayFloat a7 = a7Pointer.ref;
  final a8Pointer = calloc<Union16BytesNestedInlineArrayFloat>();
  final Union16BytesNestedInlineArrayFloat a8 = a8Pointer.ref;
  final a9Pointer = calloc<Union16BytesNestedInlineArrayFloat>();
  final Union16BytesNestedInlineArrayFloat a9 = a9Pointer.ref;

  a0.a0[0] = -1.0;
  a0.a0[1] = 2.0;
  a0.a0[2] = -3.0;
  a0.a0[3] = 4.0;
  a1.a0[0] = -5.0;
  a1.a0[1] = 6.0;
  a1.a0[2] = -7.0;
  a1.a0[3] = 8.0;
  a2.a0[0] = -9.0;
  a2.a0[1] = 10.0;
  a2.a0[2] = -11.0;
  a2.a0[3] = 12.0;
  a3.a0[0] = -13.0;
  a3.a0[1] = 14.0;
  a3.a0[2] = -15.0;
  a3.a0[3] = 16.0;
  a4.a0[0] = -17.0;
  a4.a0[1] = 18.0;
  a4.a0[2] = -19.0;
  a4.a0[3] = 20.0;
  a5.a0[0] = -21.0;
  a5.a0[1] = 22.0;
  a5.a0[2] = -23.0;
  a5.a0[3] = 24.0;
  a6.a0[0] = -25.0;
  a6.a0[1] = 26.0;
  a6.a0[2] = -27.0;
  a6.a0[3] = 28.0;
  a7.a0[0] = -29.0;
  a7.a0[1] = 30.0;
  a7.a0[2] = -31.0;
  a7.a0[3] = 32.0;
  a8.a0[0] = -33.0;
  a8.a0[1] = 34.0;
  a8.a0[2] = -35.0;
  a8.a0[3] = 36.0;
  a9.a0[0] = -37.0;
  a9.a0[1] = 38.0;
  a9.a0[2] = -39.0;
  a9.a0[3] = 40.0;

  final result = passUnion16BytesNestedInlineArrayFloatx10Native(
      a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);

  print("result = $result");

  Expect.approxEquals(20.0, result);

  calloc.free(a0Pointer);
  calloc.free(a1Pointer);
  calloc.free(a2Pointer);
  calloc.free(a3Pointer);
  calloc.free(a4Pointer);
  calloc.free(a5Pointer);
  calloc.free(a6Pointer);
  calloc.free(a7Pointer);
  calloc.free(a8Pointer);
  calloc.free(a9Pointer);
}

@Native<
    Double Function(
        Union16BytesNestedFloat,
        Union16BytesNestedFloat,
        Union16BytesNestedFloat,
        Union16BytesNestedFloat,
        Union16BytesNestedFloat,
        Union16BytesNestedFloat,
        Union16BytesNestedFloat,
        Union16BytesNestedFloat,
        Union16BytesNestedFloat,
        Union16BytesNestedFloat)>(symbol: 'PassUnion16BytesNestedFloatx10')
external double passUnion16BytesNestedFloatx10Native(
    Union16BytesNestedFloat a0,
    Union16BytesNestedFloat a1,
    Union16BytesNestedFloat a2,
    Union16BytesNestedFloat a3,
    Union16BytesNestedFloat a4,
    Union16BytesNestedFloat a5,
    Union16BytesNestedFloat a6,
    Union16BytesNestedFloat a7,
    Union16BytesNestedFloat a8,
    Union16BytesNestedFloat a9);

/// Union with homogenous floats.
void testPassUnion16BytesNestedFloatx10Native() {
  final a0Pointer = calloc<Union16BytesNestedFloat>();
  final Union16BytesNestedFloat a0 = a0Pointer.ref;
  final a1Pointer = calloc<Union16BytesNestedFloat>();
  final Union16BytesNestedFloat a1 = a1Pointer.ref;
  final a2Pointer = calloc<Union16BytesNestedFloat>();
  final Union16BytesNestedFloat a2 = a2Pointer.ref;
  final a3Pointer = calloc<Union16BytesNestedFloat>();
  final Union16BytesNestedFloat a3 = a3Pointer.ref;
  final a4Pointer = calloc<Union16BytesNestedFloat>();
  final Union16BytesNestedFloat a4 = a4Pointer.ref;
  final a5Pointer = calloc<Union16BytesNestedFloat>();
  final Union16BytesNestedFloat a5 = a5Pointer.ref;
  final a6Pointer = calloc<Union16BytesNestedFloat>();
  final Union16BytesNestedFloat a6 = a6Pointer.ref;
  final a7Pointer = calloc<Union16BytesNestedFloat>();
  final Union16BytesNestedFloat a7 = a7Pointer.ref;
  final a8Pointer = calloc<Union16BytesNestedFloat>();
  final Union16BytesNestedFloat a8 = a8Pointer.ref;
  final a9Pointer = calloc<Union16BytesNestedFloat>();
  final Union16BytesNestedFloat a9 = a9Pointer.ref;

  a0.a0.a0 = -1.0;
  a0.a0.a1 = 2.0;
  a1.a0.a0 = -3.0;
  a1.a0.a1 = 4.0;
  a2.a0.a0 = -5.0;
  a2.a0.a1 = 6.0;
  a3.a0.a0 = -7.0;
  a3.a0.a1 = 8.0;
  a4.a0.a0 = -9.0;
  a4.a0.a1 = 10.0;
  a5.a0.a0 = -11.0;
  a5.a0.a1 = 12.0;
  a6.a0.a0 = -13.0;
  a6.a0.a1 = 14.0;
  a7.a0.a0 = -15.0;
  a7.a0.a1 = 16.0;
  a8.a0.a0 = -17.0;
  a8.a0.a1 = 18.0;
  a9.a0.a0 = -19.0;
  a9.a0.a1 = 20.0;

  final result = passUnion16BytesNestedFloatx10Native(
      a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);

  print("result = $result");

  Expect.approxEquals(10.0, result);

  calloc.free(a0Pointer);
  calloc.free(a1Pointer);
  calloc.free(a2Pointer);
  calloc.free(a3Pointer);
  calloc.free(a4Pointer);
  calloc.free(a5Pointer);
  calloc.free(a6Pointer);
  calloc.free(a7Pointer);
  calloc.free(a8Pointer);
  calloc.free(a9Pointer);
}

@Native<
    Int32 Function(
        Uint8,
        Bool,
        Bool,
        Bool,
        Bool,
        Bool,
        Bool,
        Bool,
        Bool,
        Bool,
        Struct10BytesHomogeneousBool,
        Bool)>(symbol: 'PassUint8Boolx9Struct10BytesHomogeneousBoolBool')
external int passUint8Boolx9Struct10BytesHomogeneousBoolBoolNative(
    int a0,
    bool a1,
    bool a2,
    bool a3,
    bool a4,
    bool a5,
    bool a6,
    bool a7,
    bool a8,
    bool a9,
    Struct10BytesHomogeneousBool a10,
    bool a11);

/// Passing bools and a struct with bools.
/// Exhausts the registers to test bools and the bool struct alignment on the
/// stack.
void testPassUint8Boolx9Struct10BytesHomogeneousBoolBoolNative() {
  int a0;
  bool a1;
  bool a2;
  bool a3;
  bool a4;
  bool a5;
  bool a6;
  bool a7;
  bool a8;
  bool a9;
  final a10Pointer = calloc<Struct10BytesHomogeneousBool>();
  final Struct10BytesHomogeneousBool a10 = a10Pointer.ref;
  bool a11;

  a0 = 1;
  a1 = false;
  a2 = true;
  a3 = false;
  a4 = true;
  a5 = false;
  a6 = true;
  a7 = false;
  a8 = true;
  a9 = false;
  a10.a0 = true;
  a10.a1 = false;
  a10.a2 = true;
  a10.a3 = false;
  a10.a4 = true;
  a10.a5 = false;
  a10.a6 = true;
  a10.a7 = false;
  a10.a8 = true;
  a10.a9 = false;
  a11 = true;

  final result = passUint8Boolx9Struct10BytesHomogeneousBoolBoolNative(
      a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);

  print("result = $result");

  Expect.equals(11, result);

  calloc.free(a10Pointer);
}

@Native<
    Int32 Function(
        Uint8,
        Bool,
        Bool,
        Bool,
        Bool,
        Bool,
        Bool,
        Bool,
        Bool,
        Bool,
        Struct10BytesInlineArrayBool,
        Bool)>(symbol: 'PassUint8Boolx9Struct10BytesInlineArrayBoolBool')
external int passUint8Boolx9Struct10BytesInlineArrayBoolBoolNative(
    int a0,
    bool a1,
    bool a2,
    bool a3,
    bool a4,
    bool a5,
    bool a6,
    bool a7,
    bool a8,
    bool a9,
    Struct10BytesInlineArrayBool a10,
    bool a11);

/// Passing bools and a struct with bools.
/// Exhausts the registers to test bools and the bool struct alignment on the
/// stack.
void testPassUint8Boolx9Struct10BytesInlineArrayBoolBoolNative() {
  int a0;
  bool a1;
  bool a2;
  bool a3;
  bool a4;
  bool a5;
  bool a6;
  bool a7;
  bool a8;
  bool a9;
  final a10Pointer = calloc<Struct10BytesInlineArrayBool>();
  final Struct10BytesInlineArrayBool a10 = a10Pointer.ref;
  bool a11;

  a0 = 1;
  a1 = false;
  a2 = true;
  a3 = false;
  a4 = true;
  a5 = false;
  a6 = true;
  a7 = false;
  a8 = true;
  a9 = false;
  a10.a0[0] = true;
  a10.a0[1] = false;
  a10.a0[2] = true;
  a10.a0[3] = false;
  a10.a0[4] = true;
  a10.a0[5] = false;
  a10.a0[6] = true;
  a10.a0[7] = false;
  a10.a0[8] = true;
  a10.a0[9] = false;
  a11 = true;

  final result = passUint8Boolx9Struct10BytesInlineArrayBoolBoolNative(
      a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);

  print("result = $result");

  Expect.equals(11, result);

  calloc.free(a10Pointer);
}

@Native<Bool Function(Uint8, Struct1ByteBool)>(
    symbol: 'PassUint8Struct1ByteBool')
external bool passUint8Struct1ByteBoolNative(int a0, Struct1ByteBool a1);

/// Returning a bool.
void testPassUint8Struct1ByteBoolNative() {
  int a0;
  final a1Pointer = calloc<Struct1ByteBool>();
  final Struct1ByteBool a1 = a1Pointer.ref;

  a0 = 1;
  a1.a0 = false;

  final result = passUint8Struct1ByteBoolNative(a0, a1);

  print("result = $result");

  Expect.equals(1 % 2 != 0, result);

  calloc.free(a1Pointer);
}

@Native<
        WChar Function(
            WChar, StructInlineArrayInt, UintPtr, UintPtr, Long, UnsignedLong)>(
    symbol: 'PassWCharStructInlineArrayIntUintPtrx2LongUnsigned')
external int passWCharStructInlineArrayIntUintPtrx2LongUnsignedNative(
    int a0, StructInlineArrayInt a1, int a2, int a3, int a4, int a5);

/// Returning a wchar.
void testPassWCharStructInlineArrayIntUintPtrx2LongUnsignedNative() {
  int a0;
  final a1Pointer = calloc<StructInlineArrayInt>();
  final StructInlineArrayInt a1 = a1Pointer.ref;
  int a2;
  int a3;
  int a4;
  int a5;

  a0 = 1;
  a1.a0[0] = 2;
  a1.a0[1] = 3;
  a1.a0[2] = 4;
  a1.a0[3] = 5;
  a1.a0[4] = 6;
  a1.a0[5] = 7;
  a1.a0[6] = 8;
  a1.a0[7] = 9;
  a1.a0[8] = 10;
  a1.a0[9] = 11;
  a2 = 12;
  a3 = 13;
  a4 = 14;
  a5 = 15;

  final result = passWCharStructInlineArrayIntUintPtrx2LongUnsignedNative(
      a0, a1, a2, a3, a4, a5);

  print("result = $result");

  Expect.equals(120, result);

  calloc.free(a1Pointer);
}

@Native<
        Int64 Function(Int64, Int64, Int64, Int64, Int64, Int64, Int64,
            Struct12BytesHomogeneousInt32)>(
    symbol: 'PassInt64x7Struct12BytesHomogeneousInt32')
external int passInt64x7Struct12BytesHomogeneousInt32Native(int a0, int a1,
    int a2, int a3, int a4, int a5, int a6, Struct12BytesHomogeneousInt32 a7);

/// Struct stradles last argument register
void testPassInt64x7Struct12BytesHomogeneousInt32Native() {
  int a0;
  int a1;
  int a2;
  int a3;
  int a4;
  int a5;
  int a6;
  final a7Pointer = calloc<Struct12BytesHomogeneousInt32>();
  final Struct12BytesHomogeneousInt32 a7 = a7Pointer.ref;

  a0 = -1;
  a1 = 2;
  a2 = -3;
  a3 = 4;
  a4 = -5;
  a5 = 6;
  a6 = -7;
  a7.a0 = 8;
  a7.a1 = -9;
  a7.a2 = 10;

  final result = passInt64x7Struct12BytesHomogeneousInt32Native(
      a0, a1, a2, a3, a4, a5, a6, a7);

  print("result = $result");

  Expect.equals(5, result);

  calloc.free(a7Pointer);
}
