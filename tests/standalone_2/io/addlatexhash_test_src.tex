\documentclass{article}
\usepackage{epsfig}
\usepackage{color}
\usepackage{dart}
\usepackage{bnf}
\usepackage{hyperref}
\usepackage{lmodern}
\newcommand{\code}[1]{{\sf #1}}
\title{Test File used by addlatexhash}

\begin{document}
\maketitle
\tableofcontents
\newpage

\pagestyle{myheadings}
\markright{Test file used by addlatexhash}

% begin Ecma boilerplate
\section{Scope}
\LMLabel{ecmaScope}

% Selected certain paragraphs from the spec, created exactly eight
% copies of each of them, modifying the copies in ways that should
% not affect the hash values; to verify correct behavior, grep for
% '^ *\\LMHash' in the output LaTeX source or take every 2nd line
% from the list file, and check that the sequence of hashes consists
% of subsequences of identical values, all with length eight.

% Test a "normal" paragraph -------------------------------------------

%0 original
\LMHash{}
This Ecma standard specifies the syntax and semantics of the Dart programming language.  It does not specify the APIs of the Dart libraries except where those library elements are essential to the correct functioning of the language itself (e.g., the existence of class \cd{Object} with methods such as \cd{noSuchMethod}, \cd{runtimeType}).

%1 enlarge white space; NB: cannot add new white space, just enlarge
\LMHash{}
This Ecma         standard specifies the syntax and semantics of the Dart programming language.  It does not 		specify the APIs of the Dart libraries except where those library elements are essential to the correct functioning of the language itself (e.g., the existence of class \cd{Object} with methods such as \cd{noSuchMethod}, \cd{runtimeType}).

%2 insert extra newlines
\LMHash{}
This Ecma standard specifies the syntax and semantics of the Dart
programming language.  It does not specify the APIs of the Dart
libraries except where those library elements are essential to the
correct functioning of the language itself (e.g., the existence of
class \cd{Object} with methods such as \cd{noSuchMethod},
\cd{runtimeType}).

%3 insert comments
\LMHash{}
This Ecma standard specifies the syntax and semantics of the Dart % blah
programming language.  It does not specify the APIs of the Dart%blah
libraries except where those library elements are essential to the% blah
correct functioning of the language itself (e.g., the existence of
class \cd{Object} with methods such as \cd{noSuchMethod},
\cd{runtimeType}). % blah blah

%4 insert commentary
\LMHash{}
This Ecma standard specifies the syntax and semantics of the Dart programming language.  It does not specify the APIs of the Dart libraries except where those library elements are \commentary{whatever} essential to the correct functioning of the language itself (e.g., the existence of class \cd{Object} with methods such as \cd{noSuchMethod}, \cd{runtimeType}).

%5 insert rationale
\LMHash{}
This Ecma standard specifies the syntax and semantics of the Dart programming language.  It does not specify the APIs of the \rationale{whatever} Dart libraries except where those library elements are essential to the correct functioning of the language itself (e.g., the existence of class \cd{Object} with methods such as \cd{noSuchMethod}, \cd{runtimeType}).

%6 insert nested rationale/commentary
\LMHash{}
This Ecma standard specifies \rationale{whatever \commentary{whatever}} the syntax and semantics of the Dart programming language.  It does not specify the APIs of the Dart libraries except where those library elements are essential to the correct functioning of the language itself (e.g., the existence of class \cd{Object} with methods such as \cd{noSuchMethod}, \cd{runtimeType}).

%7 insert all; note that this block ends with more blank lines, too
\LMHash{}
This Ecma         standard 		specifies the syntax \rationale{whatever \commentary{whatever}} and semantics of the Dart programming language.  It does not specify the APIs of the
             Dart libraries except where those library elements are
essential to the correct functioning of
the language itself (e.g., the existence of class
\cd{Object} with methods such as \cd{noSuchMethod}, \cd{runtimeType}).





\section{Conformance}
\LMLabel{ecmaConformance}

% Test a paragraph including math mode --------------------------------

%0 original
\LMHash{}
A list $x_1, \ldots, x_n$ denotes any list of $n$ elements of the form $x_i, 1 \le i \le n$. Note that $n$ may be zero, in which case the list is empty. We use such lists extensively throughout this specification.

%1 enlarge white space in math mode; NB: cannot add new ws, even in math mode
\LMHash{}
A list $x_1,        \ldots,      x_n$ denotes any list of $n$ elements of the form $x_i, 1 \le i \le n$. Note that $n$ may be zero, in which case the list is empty. We use such lists extensively throughout this specification.

%2 enlarge other white space
\LMHash{}
A list $x_1, \ldots, x_n$ denotes         any list of $n$ elements
of the form $x_i, 1 \le i \le n$.
		 Note that $n$ may be zero, in
which case the list is empty. We use such lists
 extensively throughout this
specification.

%3 add comments, also in math mode
\LMHash{}
A list $x_1, \ldots, x_n$ denotes any list of $n$ elements% blah % blah
of the form $x_i, 1% blah
\le i % blah
 \le n$. Note that $n$ may be zero, in which
% blah blah %
case the list is empty. We use such lists extensively throughout this
specification.

%4 even multiple newlines do not count when before '$'
\LMHash{}
A list $x_1, \ldots, x_n$ denotes any list of $n$ elements of the form


$x_i, 1 \le i \le n$. Note that $n$ may be zero, in which case the list is empty. We use such lists extensively throughout this specification.

%5 multiple new lines and leading ws before '$', and comments
\LMHash{}
A list $x_1, \ldots, x_n$ denotes any list of $n$ elements of the form $x_i, 1 \le i \le n$. Note that

% blah blah blah blah blah blah blah blah
% blah blah blah blah blah blah blah blah
% blah blah blah blah blah blah blah blah
% blah blah blah blah blah blah blah blah

 	 $n$ may be zero, in which case the list is empty. We use such lists extensively throughout this specification.

%6 precede paragraph with comments
\LMHash{}
% blah
% blah
%
A list $x_1, \ldots, x_n$ denotes any list of $n$ elements of the form $x_i, 1 \le i \le n$. Note that $n$ may be zero, in which case the list is empty. We use such lists extensively throughout this specification.

%7 insert comment lines in the middle of the paragraph
\LMHash{}
A list $x_1, \ldots, x_n$ denotes any list of $n$ elements of the form $x_i, 1 \le i \le n$. Note that $n$ may be zero,
%
% blah
%
in which case the list is empty. We use such lists extensively throughout this specification.


% Test paragraph plus dartCode, with commentary -----------------------

%0 original
\LMHash{}
If a  declaration $d$ named $n$ is in the namespace induced by a scope $S$, then $d$ {\em hides} any declaration named $n$ that is available in the lexically enclosing scope of $S$.

\commentary {
A consequence of these rules is that it is possible to hide a type with a method or variable.
Naming conventions usually prevent such abuses. Nevertheless,the following program is legal:
}

\begin{dartCode}
\CLASS{} HighlyStrung \{
  String() $=>$ "?";
\}
\end{dartCode}

%1 delete/insert in the commentary, altering number of paragraphs in there
\LMHash{}
If a  declaration $d$ named $n$ is in the namespace induced by a scope $S$, then $d$ {\em hides} any declaration named $n$ that is available in the lexically enclosing scope of $S$.

\commentary {% NB: this space before brace begin is ignored by LaTeX
New paragraph.

New paragraph new paragraph new paragraph new paragraph new paragraph new paragraph new paragraph new paragraph new paragraph new paragraph new paragraph new paragraph new paragraph new paragraph new paragraph new paragraph new paragraph.

New paragraph,
new paragraph, and
new paragraph. % blah \commentary{ with unbalanced '{'

  \rationale{nested rationale}

Naming conventions usually prevent such abuses. Nevertheless,the following program is legal:
}

\begin{dartCode}
\CLASS{} HighlyStrung \{
  String() $=>$ "?";
\}
\end{dartCode}

%2 remove commentary entirely, including newlines
\LMHash{}
If a  declaration $d$ named $n$ is in the namespace induced by a scope $S$, then $d$ {\em hides} any declaration named $n$ that is available in the lexically enclosing scope of $S$.

\begin{dartCode}
\CLASS{} HighlyStrung \{
  String() $=>$ "?";
\}
\end{dartCode}

%3 change the amount of indentation in dartCode
\LMHash{}
If a  declaration $d$ named $n$ is in the namespace induced by a scope $S$, then $d$ {\em hides} any declaration named $n$ that is available in the lexically enclosing scope of $S$.

\commentary {
A consequence of these rules is that it is possible to hide a type with a method or variable.
Naming conventions usually prevent such abuses. Nevertheless,the following program is legal:
}

\begin{dartCode}
      \CLASS{} HighlyStrung \{
                  String() $=>$ "?";
      \}
\end{dartCode}

%4 change other white space in dartCode
\LMHash{}
If a  declaration $d$ named $n$ is in the namespace induced by a scope $S$, then $d$ {\em hides} any declaration named $n$ that is available in the lexically enclosing scope of $S$.

\commentary {
A consequence of these rules is that it is possible to hide a type with a method or variable.
Naming conventions usually prevent such abuses. Nevertheless,the following program is legal:
}

\begin{dartCode}

\CLASS{} 			HighlyStrung \{
String() $=>$ "?";


\}
\end{dartCode}

%5 add comments in dartCode
\LMHash{}
If a  declaration $d$ named $n$ is in the namespace induced by a scope $S$, then $d$ {\em hides} any declaration named $n$ that is available in the lexically enclosing scope of $S$.

\commentary {
A consequence of these rules is that it is possible to hide a type with a method or variable.
Naming conventions usually prevent such abuses. Nevertheless,the following program is legal:
}

\begin{dartCode}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\CLASS{} HighlyStrung \{
  String() $=>$ "?";% blah % blah
\} % blah
%blah
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{dartCode}

%6 remove commentary
\LMHash{}
If a  declaration $d$ named $n$ is in the namespace induced by a scope $S$, then $d$ {\em hides} any declaration named $n$ that is available in the lexically enclosing scope of $S$.

\begin{dartCode}
\CLASS{} HighlyStrung \{
  String() $=>$ "?";
\}
\end{dartCode}

%7 add comment lines after the block
\LMHash{}
If a  declaration $d$ named $n$ is in the namespace induced by a scope $S$, then $d$ {\em hides} any declaration named $n$ that is available in the lexically enclosing scope of $S$.

\commentary {
A consequence of these rules is that it is possible to hide a type with a method or variable.
Naming conventions usually prevent such abuses. Nevertheless,the following program is legal:
}

\begin{dartCode}
\CLASS{} HighlyStrung \{
  String() $=>$ "?";
\}
\end{dartCode}

% blah blah blah blah blah blah blah blah blah
% blah blah blah blah blah blah blah blah blah
% blah blah blah blah blah blah blah blah blah
% no blank lines before \section this time
\section{Variables}
\LMLabel{variables}

% Test paragraph followed by grammar ----------------------------------

%0 original
\LMHash{}
Variables are storage locations in memory.

\begin{grammar}
{\bf variableDeclaration:}
      declaredIdentifier (`,' identifier)*
      .

{\bf declaredIdentifier:}
      metadata finalConstVarOrType identifier
    .

{\bf finalConstVarOrType:}\FINAL{} type?;
           \CONST{} type?;
	varOrType
    .

 {\bf varOrType:}\VAR{};
	type
    .

 {\bf initializedVariableDeclaration:}
      declaredIdentifier (`=' expression)? (`,' initializedIdentifier)* % could do top level here
    .

{\bf initializedIdentifier:}
      identifier (`=' expression)? % could do top-level here
    .

{\bf initializedIdentifierList:}
      initializedIdentifier (`,' initializedIdentifier)*
    .




  \end{grammar}

%1 collecting grammar rules on single lines
\LMHash{}
Variables are storage locations in memory.

\begin{grammar}
  {\bf variableDeclaration:} declaredIdentifier (`,' identifier)* .

  {\bf declaredIdentifier:} metadata finalConstVarOrType identifier .

  {\bf finalConstVarOrType:}\FINAL{} type?; \CONST{} type?; varOrType .

  {\bf varOrType:}\VAR{}; type .

  {\bf initializedVariableDeclaration:} declaredIdentifier (`=' expression)? (`,' initializedIdentifier)* .

  {\bf initializedIdentifier:} identifier (`=' expression)? .

  {\bf initializedIdentifierList:} initializedIdentifier (`,' initializedIdentifier)* .
\end{grammar}

%2 adding comments to grammar
\LMHash{}
Variables are storage locations in memory.

\begin{grammar}% blah
%blah
{\bf variableDeclaration:}%blah
      declaredIdentifier (`,' identifier)*%blah
      .%blah
%blah
{\bf declaredIdentifier:}
      metadata finalConstVarOrType identifier
    .

{\bf finalConstVarOrType:}\FINAL{} type?;
           \CONST{} type?;
	varOrType
    .

 {\bf varOrType:}\VAR{};
	type
    .

 {\bf initializedVariableDeclaration:}
      declaredIdentifier (`=' expression)? (`,' initializedIdentifier)* % could do top level here
    .

{\bf initializedIdentifier:}
      identifier (`=' expression)? % could do top-level here
    .

{\bf initializedIdentifierList:}
      initializedIdentifier (`,' initializedIdentifier)*
    .%        blah



%blah
  \end{grammar}%blah

%3 removing empty lines from grammar
\LMHash{}
Variables are storage locations in memory.

\begin{grammar}
{\bf variableDeclaration:}
      declaredIdentifier (`,' identifier)*
      .
{\bf declaredIdentifier:}
      metadata finalConstVarOrType identifier
    .
{\bf finalConstVarOrType:}\FINAL{} type?;
           \CONST{} type?;
	varOrType
    .
 {\bf varOrType:}\VAR{};
	type
    .
 {\bf initializedVariableDeclaration:}
      declaredIdentifier (`=' expression)? (`,' initializedIdentifier)* % could do top level here
    .
{\bf initializedIdentifier:}
      identifier (`=' expression)? % could do top-level here
    .
{\bf initializedIdentifierList:}
      initializedIdentifier (`,' initializedIdentifier)*
    .
  \end{grammar}

%4 inserting comment block in grammar
\LMHash{}
Variables are storage locations in memory.

\begin{grammar}
{\bf variableDeclaration:}
      declaredIdentifier (`,' identifier)*
      .

{\bf declaredIdentifier:}
      metadata finalConstVarOrType identifier
    .

{\bf finalConstVarOrType:}\FINAL{} type?;
           \CONST{} type?;
	varOrType
    .

 {\bf varOrType:}\VAR{};
	type
    .
%% {\bf finalConstVarOrType:}\FINAL{} type?;
%%            \CONST{} type?;
%% 	varOrType
%%     .

%%  {\bf varOrType:}\VAR{};
%% 	type
%%     .


 {\bf initializedVariableDeclaration:}
      declaredIdentifier (`=' expression)? (`,' initializedIdentifier)* % could do top level here
    .

{\bf initializedIdentifier:}
      identifier (`=' expression)? % could do top-level here
    .

{\bf initializedIdentifierList:}
      initializedIdentifier (`,' initializedIdentifier)*
    .




  \end{grammar}

%5 adding commentary/rationale in grammar (may not happen, is OK anyway)
\LMHash{}
Variables are storage locations in memory.

\begin{grammar}
{\bf variableDeclaration:}
      declaredIdentifier (`,' identifier)*
      .

{\bf declaredIdentifier:}
      metadata finalConstVarOrType identifier
    .

\rationale{blah \commentary{blah}}
{\bf finalConstVarOrType:}\FINAL{} type?;
           \CONST{} type?;
	varOrType
    .

 {\bf varOrType:}\VAR{};
	type
    .

 {\bf initializedVariableDeclaration:}
      declaredIdentifier (`=' expression)? (`,' initializedIdentifier)* % could do top level here
    .

{\bf initializedIdentifier:}
      identifier (`=' expression)? % could do top-level here
    .

{\bf initializedIdentifierList:}
      initializedIdentifier (`,' initializedIdentifier)*
    .




  \end{grammar}

%6 inserting newlines in grammar (not new paragraph, only at existing ws)
\LMHash{}
Variables are storage locations in memory.

\begin{grammar}
{\bf variableDeclaration:}
      declaredIdentifier
(`,'
identifier)*
      .

{\bf declaredIdentifier:}
      metadata finalConstVarOrType
                                   identifier
    .

{\bf
finalConstVarOrType:}\FINAL{}
type?;
           \CONST{} type?;
	varOrType
    .

 {\bf varOrType:}\VAR{};
	type
    .

 {\bf initializedVariableDeclaration:}
      declaredIdentifier (`=' expression)?
                         (`,' initializedIdentifier)*
                         % could do top level here
    .

{\bf initializedIdentifier:}
      identifier (`=' expression)? % could do top-level here
    .

{\bf initializedIdentifierList:}
      initializedIdentifier (`,' initializedIdentifier)*
    .




  \end{grammar}

%7
\LMHash{}
Variables are storage locations in memory.

\begin{grammar}
{\bf variableDeclaration:}
      declaredIdentifier (`,' identifier)*
      .

{\bf declaredIdentifier:}
      metadata finalConstVarOrType identifier
    .

{\bf finalConstVarOrType:}\FINAL{} type?;
           \CONST{} type?;
	varOrType
    .

 {\bf varOrType:}\VAR{};
	type
    .

 {\bf initializedVariableDeclaration:}
      declaredIdentifier (`=' expression)? (`,' initializedIdentifier)* % could do top level here
    .

{\bf initializedIdentifier:}
      identifier (`=' expression)? % could do top-level here
    .

{\bf initializedIdentifierList:}
      initializedIdentifier (`,' initializedIdentifier)*
    .




  \end{grammar}

\subsection{Evaluation of Implicit  Variable Getters}
\LMLabel{evaluationOfImplicitVariableGetters}

% Test itemized list, right after paragraph ---------------------------

%0 original
\LMHash{}
Let $d$ be the declaration of a static or instance variable $v$.  If $d$ is an instance variable, then the invocation of the implicit getter  of $v$ evaluates to the value stored in $v$.
If $d$ is a static or library variable then the implicit getter method of $v$ executes as follows:
\begin{itemize}
\item {\bf Non-constant variable declaration with initializer}. If $d$ is of one of the forms \code{\VAR{} $v$ = $e$;} ,  \code{$T$ $v$ = $e$;} ,   \code{\FINAL{} $v$ = $e$;} ,  \code{\FINAL{} $T$ $v$ = $e$;}, \code{\STATIC{} $v$ = $e$; }, \code{\STATIC{} $T$ $v$ = $e$; }, \code{\STATIC{} \FINAL{} $v$ = $e$; } or \code{\STATIC{} \FINAL{} $T$ $v$ = $e$;} and no value has yet been stored into $v$ then the initializer expression $e$ is evaluated. If, during the evaluation of $e$, the getter for $v$ is invoked, a \code{CyclicInitializationError} is thrown. If the evaluation succeeded yielding an object $o$, let $r = o$, otherwise let $r = \NULL{}$. In any case, $r$ is stored into $v$. The result of executing the getter is $r$.
\item  {\bf Constant variable declaration}. If $d$ is of one of the forms \code{\CONST{} $v$ = $e$; } ,  \code{\CONST{} $T$  $v$ = $e$; },  \code{\STATIC{} \CONST{} $v$ = $e$; }  or \code{\STATIC{} \CONST{} $T$ $v$ = $e$;} the result of the getter is the value of the compile time constant $e$. \commentary{Note that a compile time constant cannot depend on itself, so no cyclic references can occur.}
Otherwise
\item {\bf Variable declaration without initializer}. The result of executing the getter method is the value stored in $v$.
\end{itemize}

%1 insert blank lines and comments between paragraph and list ---------
\LMHash{}
Let $d$ be the declaration of a static or instance variable $v$.  If $d$ is an instance variable, then the invocation of the implicit getter  of $v$ evaluates to the value stored in $v$.
If $d$ is a static or library variable then the implicit getter method of $v$ executes as follows:

%blah
%blah

\begin{itemize}
\item {\bf Non-constant variable declaration with initializer}. If $d$ is of one of the forms \code{\VAR{} $v$ = $e$;} ,  \code{$T$ $v$ = $e$;} ,   \code{\FINAL{} $v$ = $e$;} ,  \code{\FINAL{} $T$ $v$ = $e$;}, \code{\STATIC{} $v$ = $e$; }, \code{\STATIC{} $T$ $v$ = $e$; }, \code{\STATIC{} \FINAL{} $v$ = $e$; } or \code{\STATIC{} \FINAL{} $T$ $v$ = $e$;} and no value has yet been stored into $v$ then the initializer expression $e$ is evaluated. If, during the evaluation of $e$, the getter for $v$ is invoked, a \code{CyclicInitializationError} is thrown. If the evaluation succeeded yielding an object $o$, let $r = o$, otherwise let $r = \NULL{}$. In any case, $r$ is stored into $v$. The result of executing the getter is $r$.
\item  {\bf Constant variable declaration}. If $d$ is of one of the forms \code{\CONST{} $v$ = $e$; } ,  \code{\CONST{} $T$  $v$ = $e$; },  \code{\STATIC{} \CONST{} $v$ = $e$; }  or \code{\STATIC{} \CONST{} $T$ $v$ = $e$;} the result of the getter is the value of the compile time constant $e$. \commentary{Note that a compile time constant cannot depend on itself, so no cyclic references can occur.}
Otherwise
\item {\bf Variable declaration without initializer}. The result of executing the getter method is the value stored in $v$.
\end{itemize}

%2 insert line break before each item
\LMHash{}
Let $d$ be the declaration of a static or instance variable $v$.  If $d$ is an instance variable, then the invocation of the implicit getter  of $v$ evaluates to the value stored in $v$.
If $d$ is a static or library variable then the implicit getter method of $v$ executes as follows:
\begin{itemize}
\item
{\bf Non-constant variable declaration with initializer}. If $d$ is of one of the forms \code{\VAR{} $v$ = $e$;} ,  \code{$T$ $v$ = $e$;} ,   \code{\FINAL{} $v$ = $e$;} ,  \code{\FINAL{} $T$ $v$ = $e$;}, \code{\STATIC{} $v$ = $e$; }, \code{\STATIC{} $T$ $v$ = $e$; }, \code{\STATIC{} \FINAL{} $v$ = $e$; } or \code{\STATIC{} \FINAL{} $T$ $v$ = $e$;} and no value has yet been stored into $v$ then the initializer expression $e$ is evaluated. If, during the evaluation of $e$, the getter for $v$ is invoked, a \code{CyclicInitializationError} is thrown. If the evaluation succeeded yielding an object $o$, let $r = o$, otherwise let $r = \NULL{}$. In any case, $r$ is stored into $v$. The result of executing the getter is $r$.
\item
{\bf Constant variable declaration}. If $d$ is of one of the forms \code{\CONST{} $v$ = $e$; } ,  \code{\CONST{} $T$  $v$ = $e$; },  \code{\STATIC{} \CONST{} $v$ = $e$; }  or \code{\STATIC{} \CONST{} $T$ $v$ = $e$;} the result of the getter is the value of the compile time constant $e$. \commentary{Note that a compile time constant cannot depend on itself, so no cyclic references can occur.}
Otherwise
\item
{\bf Variable declaration without initializer}. The result of executing the getter method is the value stored in $v$.
\end{itemize}

%3 insert blank/comment lines between,before,after items, and on begin/end
\LMHash{}
Let $d$ be the declaration of a static or instance variable $v$.  If $d$ is an instance variable, then the invocation of the implicit getter  of $v$ evaluates to the value stored in $v$.
If $d$ is a static or library variable then the implicit getter method of $v$ executes as follows:
\begin{itemize}%blah

% blah

\item {\bf Non-constant variable declaration with initializer}. If $d$ is of one of the forms \code{\VAR{} $v$ = $e$;} ,  \code{$T$ $v$ = $e$;} ,   \code{\FINAL{} $v$ = $e$;} ,  \code{\FINAL{} $T$ $v$ = $e$;}, \code{\STATIC{} $v$ = $e$; }, \code{\STATIC{} $T$ $v$ = $e$; }, \code{\STATIC{} \FINAL{} $v$ = $e$; } or \code{\STATIC{} \FINAL{} $T$ $v$ = $e$;} and no value has yet been stored into $v$ then the initializer expression $e$ is evaluated. If, during the evaluation of $e$, the getter for $v$ is invoked, a \code{CyclicInitializationError} is thrown. If the evaluation succeeded yielding an object $o$, let $r = o$, otherwise let $r = \NULL{}$. In any case, $r$ is stored into $v$. The result of executing the getter is $r$.

\item  {\bf Constant variable declaration}. If $d$ is of one of the forms \code{\CONST{} $v$ = $e$; } ,  \code{\CONST{} $T$  $v$ = $e$; },  \code{\STATIC{} \CONST{} $v$ = $e$; }  or \code{\STATIC{} \CONST{} $T$ $v$ = $e$;} the result of the getter is the value of the compile time constant $e$. \commentary{Note that a compile time constant cannot depend on itself, so no cyclic references can occur.}
Otherwise

%blah
%blah
%blah


\item {\bf Variable declaration without initializer}. The result of executing the getter method is the value stored in $v$.

% blah
\end{itemize}%blah

%4 insert commentary/rationale inside itemized list
\LMHash{}
Let $d$ be the declaration of a static or instance variable $v$.  If $d$ is an instance variable, then the invocation of the implicit getter  of $v$ evaluates to the value stored in $v$.
If $d$ is a static or library variable then the implicit getter method of $v$ executes as follows:
\begin{itemize}
\commentary{maybe this will not happen, but it is ok}
\item {\bf Non-constant variable declaration with initializer}. If $d$ is of one of the forms \code{\VAR{} $v$ = $e$;} ,  \code{$T$ $v$ = $e$;} ,   \code{\FINAL{} $v$ = $e$;} ,  \code{\FINAL{} $T$ $v$ = $e$;}, \code{\STATIC{} $v$ = $e$; }, \code{\STATIC{} $T$ $v$ = $e$; }, \code{\STATIC{} \FINAL{} $v$ = $e$; } or \code{\STATIC{} \FINAL{} $T$ $v$ = $e$;} and no value has yet been stored into $v$ then the initializer expression $e$ is evaluated. If, during the evaluation of $e$, the getter for $v$ is invoked, a \code{CyclicInitializationError} is thrown. If the evaluation succeeded yielding an object $o$, let $r = o$, otherwise let $r = \NULL{}$. In any case, $r$ is stored into $v$. The result of executing the getter is $r$.
\rationale{but rationale at the end of an item seems to make sense}
\item  {\bf Constant variable declaration}. If $d$ is of one of the forms \code{\CONST{} $v$ = $e$; } ,  \code{\CONST{} $T$  $v$ = $e$; },  \code{\STATIC{} \CONST{} $v$ = $e$; }  or \code{\STATIC{} \CONST{} $T$ $v$ = $e$;} the result of the getter is the value of the compile time constant $e$. \commentary{Note that a compile time constant cannot depend on itself, so no cyclic references can occur.}
Otherwise
\item {\bf Variable declaration without initializer}. The result of executing the getter method is the value stored in $v$.
\end{itemize}
\rationale{and we can of course have it immediately after the list}

%5 add line breaks in items, with/without indentation
\LMHash{}
Let $d$ be the declaration of a static or instance variable $v$.  If $d$ is an instance variable, then the invocation of the implicit getter  of $v$ evaluates to the value stored in $v$.
If $d$ is a static or library variable then the implicit getter method of $v$ executes as follows:
\begin{itemize}
\item {\bf Non-constant variable declaration with initializer}. If $d$
is of one of the forms \code{\VAR{} $v$ = $e$;} ,  \code{$T$ $v$ = $e$;} ,
\code{\FINAL{} $v$ = $e$;} ,  \code{\FINAL{} $T$ $v$ = $e$;},
\code{\STATIC{} $v$ = $e$; }, \code{\STATIC{} $T$ $v$ = $e$; },
\code{\STATIC{} \FINAL{} $v$ = $e$; } or
\code{\STATIC{} \FINAL{} $T$ $v$ = $e$;} and no value has yet been stored
into $v$ then the initializer expression $e$ is evaluated. If, during
the evaluation of $e$, the getter for $v$ is invoked, a
\code{CyclicInitializationError} is thrown. If the evaluation succeeded
yielding an object $o$, let $r = o$, otherwise let $r = \NULL{}$. In
any case, $r$ is stored into $v$. The result of executing the getter
is $r$.
\item  {\bf Constant variable declaration}. If $d$ is of one of the
    forms \code{\CONST{} $v$ = $e$; } ,  \code{\CONST{} $T$  $v$ = $e$; },
    \code{\STATIC{} \CONST{} $v$ = $e$; } or
    \code{\STATIC{} \CONST{} $T$ $v$ = $e$;} the result of the getter is the
    value of the compile time constant $e$.
    \commentary{Note that a compile time constant cannot depend on
      itself, so no cyclic references can occur.}
    Otherwise
\item {\bf Variable declaration without initializer}. The result of
    executing the getter method is the value stored in $v$.
\end{itemize}

%6 add line breaks, then "eliminate" them with comments
\LMHash{}
Let $d$ be the declaration of a static or instance%
variable $v$.  If $d$ is an instance variable, then the %
invocation of the implicit getter  of $v$ evaluates to%
                   the value stored in $v$.
If $d$ is a static or library variable then the implicit %
getter method of $v$ executes as follows: %

\begin{itemize}
\item {\bf Non-constant variable declaration with initializer}. If $d$ is of one of the forms \code{\VAR{} $v$ = $e$;} ,  \code{$T$ $v$ = $e$;} ,   \code{\FINAL{} $v$ = $e$;} ,  \code{\FINAL{} $T$ $v$ = $e$;}, \code{\STATIC{} $v$ = $e$; }, \code{\STATIC{} $T$ $v$ = $e$; }, \code{\STATIC{} \FINAL{} $v$ = $e$; } or \code{\STATIC{} \FINAL{} $T$ $v$ = $e$;} and no value has yet been stored into $v$ then the initializer expression $e$ is evaluated. If, during the evaluation of $e$, the getter for $v$ is invoked, a \code{CyclicInitializationError} is thrown. If the evaluation succeeded yielding an object $o$, let $r = o$, otherwise let $r = \NULL{}$. In any case, $r$ is stored into $v$. The result of executing the getter is $r$. %

\item  {\bf Constant variable declaration}. If $d$ is of one of the%
 forms \code{\CONST{} $v$ = $e$; } ,  \code{\CONST{} $T$  $v$ = $e$; },  %
\code{\STATIC{} \CONST{} $v$ = $e$; }  or%
\code{\STATIC{} \CONST{} $T$ $v$ = $e$;} the result of the getter is the value of the compile time constant $e$. \commentary{Note that a compile time constant cannot depend on itself, so no cyclic references can occur.}
Otherwise
\item {\bf Variable declaration without initializer}. The result of executing the getter method is the value stored in $v$.
\end{itemize}

%7 eliminate line break before environment and before \item
\LMHash{}
Let $d$ be the declaration of a static or instance variable $v$.  If $d$ is an instance variable, then the invocation of the implicit getter  of $v$ evaluates to the value stored in $v$.
If $d$ is a static or library variable then the implicit getter method of $v$ executes as follows: \begin{itemize}
\item {\bf Non-constant variable declaration with initializer}. If $d$ is of one of the forms \code{\VAR{} $v$ = $e$;} ,  \code{$T$ $v$ = $e$;} ,   \code{\FINAL{} $v$ = $e$;} ,  \code{\FINAL{} $T$ $v$ = $e$;}, \code{\STATIC{} $v$ = $e$; }, \code{\STATIC{} $T$ $v$ = $e$; }, \code{\STATIC{} \FINAL{} $v$ = $e$; } or \code{\STATIC{} \FINAL{} $T$ $v$ = $e$;} and no value has yet been stored into $v$ then the initializer expression $e$ is evaluated. If, during the evaluation of $e$, the getter for $v$ is invoked, a \code{CyclicInitializationError} is thrown. If the evaluation succeeded yielding an object $o$, let $r = o$, otherwise let $r = \NULL{}$. In any case, $r$ is stored into $v$. The result of executing the getter is $r$. \item  {\bf Constant variable declaration}. If $d$ is of one of the forms \code{\CONST{} $v$ = $e$; } ,  \code{\CONST{} $T$  $v$ = $e$; },  \code{\STATIC{} \CONST{} $v$ = $e$; }  or \code{\STATIC{} \CONST{} $T$ $v$ = $e$;} the result of the getter is the value of the compile time constant $e$. \commentary{Note that a compile time constant cannot depend on itself, so no cyclic references can occur.}
Otherwise%
\item {\bf Variable declaration without initializer}. The result of executing the getter method is the value stored in $v$.
\end{itemize}

% Test multiple commentary/rationale blocks in succession -------------

%0 original
\LMHash{}
The run time type of a function object always implements the class \cd{Function}.

\commentary{
One cannot assume, based on the above, that  given a function \cd{f}, \cd{f.runtimeType} will actually be \cd{Function}, or that any two distinct function objects necessarily have the same runtime type.
}

\rationale{
It is up to the implementation to choose an appropriate representation for functions.
For example, consider that a closure produced via property extraction treats equality different from ordinary closures, and is therefore likely a different class. Implementations may also use different classes for functions based on arity and or type. Arity may be implicitly affected by whether a function is an instance method (with an implicit receiver parameter) or not. The variations are manifold, and so this specification only guarantees that function objects are instances of some class that is considered to implement \cd{Function}.

}

%1 remove commentary/first
\LMHash{}
The run time type of a function object always implements the class \cd{Function}.

\rationale{
It is up to the implementation to choose an appropriate representation for functions.
For example, consider that a closure produced via property extraction treats equality different from ordinary closures, and is therefore likely a different class. Implementations may also use different classes for functions based on arity and or type. Arity may be implicitly affected by whether a function is an instance method (with an implicit receiver parameter) or not. The variations are manifold, and so this specification only guarantees that function objects are instances of some class that is considered to implement \cd{Function}.

}

%2 remove rationale second
\LMHash{}
The run time type of a function object always implements the class \cd{Function}.

\commentary{
One cannot assume, based on the above, that  given a function \cd{f}, \cd{f.runtimeType} will actually be \cd{Function}, or that any two distinct function objects necessarily have the same runtime type.
}

%3 remove both
\LMHash{}
The run time type of a function object always implements the class \cd{Function}.

%4 make first in paragraph, even with \par (double newline)
\LMHash{}
\commentary{
One cannot assume, based on the above, that  given a function \cd{f}, \cd{f.runtimeType} will actually be \cd{Function}, or that any two distinct function objects necessarily have the same runtime type.
}

\rationale{
It is up to the implementation to choose an appropriate representation for functions.
For example, consider that a closure produced via property extraction treats equality different from ordinary closures, and is therefore likely a different class. Implementations may also use different classes for functions based on arity and or type. Arity may be implicitly affected by whether a function is an instance method (with an implicit receiver parameter) or not. The variations are manifold, and so this specification only guarantees that function objects are instances of some class that is considered to implement \cd{Function}.

}

The run time type of a function object always implements the class \cd{Function}.

%5 insert misleading 'dartCode' comments
\LMHash{}
The run time type of a function object always implements the class \cd{Function}.

\commentary{
One cannot assume, based on the above, that  given a function \cd{f}, \cd{f.runt
imeType} will actually be \cd{Function}, or that any two distinct function objec
%\begin{dartCode}
ts necessarily have the same runtime type.
}

\rationale{
It is up to the implementation to choose an appropriate representation for functions.
%\end{dartCode}
For example, consider that a closure produced via property extraction treats equality different from ordinary closures, and is therefore likely a different class. Implementations may also use different classes for functions based on arity and or type. Arity may be implicitly affected by whether a function is an instance method (with an implicit receiver parameter) or not. The variations are manifold, and so this specification only guarantees that function objects are instances of some class that is considered to implement \cd{Function}.

}

%6 remove empty lines between normative and non-normative text
\LMHash{}
The run time type of a function object always implements the class \cd{Function}.
\commentary{
One cannot assume, based on the above, that  given a function \cd{f}, \cd{f.runtimeType} will actually be \cd{Function}, or that any two distinct function objects necessarily have the same runtime type.
}
\rationale{
It is up to the implementation to choose an appropriate representation for functions.
For example, consider that a closure produced via property extraction treats equality different from ordinary closures, and is therefore likely a different class. Implementations may also use different classes for functions based on arity and or type. Arity may be implicitly affected by whether a function is an instance method (with an implicit receiver parameter) or not. The variations are manifold, and so this specification only guarantees that function objects are instances of some class that is considered to implement \cd{Function}.

}

%7 remove white space between normative and non-normative text
\LMHash{}
The run time type of a function object always implements the class \cd{Function}.\commentary{
One cannot assume, based on the above, that  given a function \cd{f}, \cd{f.runtimeType} will actually be \cd{Function}, or that any two distinct function objects necessarily have the same runtime type.
}\rationale{
It is up to the implementation to choose an appropriate representation for functions.
For example, consider that a closure produced via property extraction treats equality different from ordinary closures, and is therefore likely a different class. Implementations may also use different classes for functions based on arity and or type. Arity may be implicitly affected by whether a function is an instance method (with an implicit receiver parameter) or not. The variations are manifold, and so this specification only guarantees that function objects are instances of some class that is considered to implement \cd{Function}.}

% Test structure command (\section) with leading white space ----------

 \subsection{ Equality}
 \LMLabel{equality}

 The subsection should end the hashing block, so these words should
 not affect the previous hash value.

% ---------------------------------------------------------------------

\end{document}
