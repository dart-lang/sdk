// Copyright (c) 2025, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// This test was generated by Gemini.

import 'dart:io';
import 'package:test/test.dart';

// The simple script to be run in a child process.
// It prints both executable paths to standard output.
const String _testScriptContent = '''
import 'dart:io';

void main() {
  print(Platform.executable);
  print(Platform.resolvedExecutable);
}
''';

void main() {
  group('Platform executable properties', () {
    test(
      'Platform.executable and Platform.resolvedExecutable should differ '
      'when executed via a symbolic link',
      () {
        // 1. Get the absolute path to the current Dart executable.
        final dartExecutablePath = Platform.resolvedExecutable;

        // 2. Create a temporary directory and the necessary files.
        final tempDir = Directory.systemTemp.createTempSync(
          'dart_symlink_test_',
        );
        final symlinkPath =
            '${tempDir.path}${Platform.pathSeparator}dart_symlink';
        final childScriptPath =
            '${tempDir.path}${Platform.pathSeparator}child_script.dart';

        try {
          // Create the symbolic link.
          Link(symlinkPath).createSync(dartExecutablePath, recursive: true);

          // Write the child script to a file.
          File(childScriptPath).writeAsStringSync(_testScriptContent);

          // 3. Execute the child script using the symlink.
          final result = Process.runSync(
            symlinkPath, // This is the key: use the symlink path
            [childScriptPath],
            runInShell: true,
          );

          // Verify the child process exited successfully.
          expect(
            result.exitCode,
            0,
            reason: 'Child process failed: ${result.stderr}',
          );

          // 4. Parse the output.
          final output = result.stdout.toString().trim().split('\n');
          final executablePath = output[0];
          final resolvedExecutablePath = output[1];

          // 5. Assert the paths are different.
          expect(executablePath, isNot(equals(resolvedExecutablePath)));
          print('Executable: $executablePath');
          print('Resolved Executable: $resolvedExecutablePath');
        } finally {
          // Clean up the temporary directory.
          if (tempDir.existsSync()) {
            tempDir.deleteSync(recursive: true);
          }
        }
      },
      // This is the important part: use the 'skip' parameter.
      // The test will be skipped unless the platform is Linux or MacOS.
      skip: (!Platform.isLinux && !Platform.isMacOS) ? true : false,
    );
  });
}
